ding to linkage in the
            // "out" list.  Terminate the
            //
            DereferenceControlSent( pCs );
        }

        // Flush the out of order list.
        //
        while (!IsListEmpty( &pTunnel->listOutOfOrder ))
        {
            CONTROLRECEIVED* pCr;
            ADAPTERCB* pAdapter;

            pLink = RemoveHeadList( &pTunnel->listOutOfOrder );
            InitializeListHead( pLink );
            pCr = CONTAINING_RECORD( pLink, CONTROLRECEIVED, linkOutOfOrder );

            TRACE( TL_I, TM_Recv, ( "Flush pCr=$%p", pCr ) );

            pAdapter = pTunnel->pAdapter;
            FreeBufferToPool( &pAdapter->poolFrameBuffers, pCr->pBuffer, TRUE );

            if (pCr->pVc)
            {
                DereferenceVc( pCr->pVc );
            }

            FREE_CONTROLRECEIVED( pAdapter, pCr );
        }

        // Cancel the "hello" timer if it's running.
        //
        if (pTunnel->pTqiHello)
        {
            TimerQCancelItem( pTunnel->pTimerQ, pTunnel->pTqiHello );
            pTunnel->pTqiHello = NULL;
        }

        if (ulFlags & TCBF_PeerInitRef)
        {
            // Remove the "peer initiation" tunnel reference.
            //
            ClearFlags( &pTunnel->ulFlags, TCBF_PeerInitRef );
            DereferenceTunnel( pTunnel );
        }

        if (ulFlags & TCBF_FsmCloseRef)
        {
            // Remove the "graceful close" tunnel reference.
            //
            ClearFlags( &pTunnel->ulFlags, TCBF_FsmCloseRef );
            DereferenceTunnel( pTunnel );
        }
    }
}


VOID
CallTransitionComplete(
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN L2TPCALLSTATE state )

    // Sets 'pVc's state to it's new CS_Idle or CS_Established state and sets
    // up for reporting the result to the client.
    //
    // IMPORTANT: Caller must hold 'pTunnel->lockT' and 'pVc->lockV'.
    //
{
    ULONG ulFlags;

    pVc->state = state;

    ulFlags = ReadFlags( &pVc->ulFlags );
    if (!(ulFlags & VCBM_Pending))
    {
        if (ulFlags & VCBF_CallClosableByPeer)
        {
            // Nothing else was pending and the call is closable so either
            // peer initiated a close or some fatal error occurred which will
            // be cleaned up as if peer initiated a close.
            //
            ASSERT( pVc->status != NDIS_STATUS_SUCCESS );
            SetFlags( &pVc->ulFlags, VCBF_PeerClosePending );
            ClearFlags( &pVc->ulFlags, VCBF_CallClosableByPeer );
        }
        else
        {
            // Nothing was pending and the call's not closable, so there's no
            // action required for this transition.
            //
            TRACE( TL_I, TM_Fsm, ( "Call not closable" ) );
            return;
        }
    }
    else if (ulFlags & VCBF_ClientOpenPending)
    {
        if (pVc->status != NDIS_STATUS_SUCCESS)
        {
            // A pending client open just failed and will bring down the call.
            // From this point on we will fail new attempts to close the call
            // from both client and peer.
            //
            ClearFlags( &pVc->ulFlags,
                (VCBF_CallClosableByClient | VCBF_CallClosableByPeer ));
        }
    }
    else if (ulFlags & VCBF_PeerOpenPending)
    {
        if (pVc->status != NDIS_STATUS_SUCCESS)
        {
            // A pending peer open just failed and will bring down the call.
            // From this point on we will fail new attempts to close the call
            // from the peer.  Client closes must be accepted because of the
            // way CoNDIS loops dispatched close calls back to the CM's close
            // handler.
            //
            ClearFlags( &pVc->ulFlags, VCBF_CallClosableByPeer );
        }
    }

    // Update some call statistics.
    //
    {
        LARGE_INTEGER lrgTime;

        NdisGetCurrentSystemTime( &lrgTime );
        if (pVc->state == CS_Idle)
        {
            if (pVc->stats.llCallUp)
            {
                pVc->stats.ulSeconds = (ULONG )
                   (((ULONGLONG )lrgTime.QuadPart - pVc->stats.llCallUp)
                       / 10000000);
            }
        }
        else
        {
            ASSERT( pVc->state == CS_Established );
            pVc->stats.llCallUp = (ULONGLONG )lrgTime.QuadPart;

            pVc->stats.ulMinSendWindow =
                pVc->stats.ulMaxSendWindow =
                    pVc->ulSendWindow;
        }
    }

    TRACE( TL_A, TM_Fsm, ( "CALL %d ON TUNNEL %d %s",
        (ULONG )pVc->usCallId, (ULONG )pTunnel->usTunnelId,
        ((state == CS_Established) ? "UP" : "DOWN") ) );
        
    WPLOG( LL_M, LM_Fsm, ( "CALL %p, Cid %d, ON TUNNEL %p, Tid %d %s",
        pVc, (ULONG )pVc->usCallId, pTunnel, (ULONG )pTunnel->usTunnelId,
        ((state == CS_Established) ? "UP" : "DOWN") ) );

    // Move the VC onto the tunnel's completing list.  The VC may or may not
    // be on the tunnel request list, but if it is, remove it.
    //
    RemoveEntryList( &pVc->linkRequestingVcs );
    InitializeListHead( &pVc->linkRequestingVcs );
    
    // Check if this VC is already on the list
    if(!(ReadFlags(&pVc->ulFlags) & VCBF_CompPending))
    {
        ASSERT( pVc->linkCompletingVcs.Flink == &pVc->linkCompletingVcs );
        ASSERT( pVc->linkCompletingVcs.Blink == &pVc->linkCompletingVcs );
        SetFlags( &pVc->ulFlags, VCBF_CompPending );
        InsertTailList( &pTunnel->listCompletingVcs, &pVc->linkCompletingVcs );
    }
}


//-----------------------------------------------------------------------------
// FSM utility routines (alphabetically)
//-----------------------------------------------------------------------------

VOID
FsmInCallEstablished(
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN CONTROLMSGINFO* pControl )

    // Incoming call creation FSM Established state processing for VC 'pVc'.
    // 'PControl' is the exploded control message information.
    //
    // IMPORTANT: Caller must hold 'pVc->lockV' and 'pTunnel->lockT'.
    //
{
    if (*(pControl->pusMsgType) == CMT_CDN)
    {
        // Call is down.
        //
        pVc->status = NDIS_STATUS_TAPI_DISCONNECTMODE_NORMAL;
        CallTransitionComplete( pTunnel, pVc, CS_Idle );
    }
}


VOID
FsmInCallIdle(
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN CONTROLMSGINFO* pControl )

    // Incoming call creation FSM Idle state processing for VC 'pVc'.
    // 'PControl' is the exploded control message information.
    //
    // IMPORTANT: Caller must hold 'pVc->lockV' and 'pTunnel->lockT'.
    //
{
    ADAPTERCB* pAdapter;

    pAdapter = pVc->pAdapter;

    if (*(pControl->pusMsgType) == CMT_ICRQ)
    {
        if (!(ReadFlags( &pVc->ulFlags ) & VCBF_PeerOpenPending))
        {
            // If no open is pending, the call and/or owning tunnel has been
            // slammed, we are in the clean up phase, and no response should
            // be made.
            //
            TRACE( TL_A, TM_Fsm, ( "IC aborted" ) );
            WPLOG( LL_A, LM_Fsm, ( "ICRQ received & we're in the cleanup phase" ) );
            return;
        }

        if (*pControl->pusAssignedCallId)
        {
            pVc->usAssignedCallId = *(pControl->pusAssignedCallId);
        }

        if (pVc->usResult)
        {
            // Call is down, but must hold the VC until the closing message is
            // acknowledged.
            //
            pVc->status = NDIS_STATUS_TAPI_DISCONNECTMODE_NORMAL;
            pVc->state = CS_Idle;
            SendControl(
                pTunnel, pVc, CMT_CDN,
                (ULONG )pVc->usResult, (ULONG )pVc->usError, NULL,
                CSF_CallIdleOnAck );
        }
        else
        {
            if (pAdapter->usPayloadReceiveWindow)
            {
                SetFlags( &pVc->ulFlags, VCBF_Sequencing );
            }

            // Stash call serial number.
            //
            if (pControl->pulCallSerialNumber)
            {
                pVc->pLcParams->ulCallSerialNumber =
                    *(pControl->pulCallSerialNumber);
            }
            else
            {
                pVc->pLcParams->ulCallSerialNumber = 0;
            }

            // Stash acceptable bearer types.
            //
            pVc->pTcInfo->ulMediaMode = 0;
            if (pControl->pulBearerType)
            {
                if (*(pControl->pulBearerType) & BBM_Analog)
                {
                    pVc->pTcInfo->ulMediaMode |= LINEMEDIAMODE_DATAMODEM;
                }

                if (*(pControl->pulBearerType) & BBM_Digital)
                {
                    pVc->pTcInfo->ulMediaMode |= LINEMEDIAMODE_DIGITALDATA;
                }
            }

            // Stash physical channel ID.
            //
            if (pControl->pulPhysicalChannelId)
            {
                pVc->pLcParams->ulPhysicalChannelId =
                    *(pControl->pulPhysicalChannelId);
            }
            else
            {
                pVc->pLcParams->ulPhysicalChannelId = 0xFFFFFFFF;
            }

            // Note: The phone numbers of the caller and callee as well as the
            // Subaddress are available at this point.  Currently, the
            // CallerID field of the TAPI structures is used for the IP
            // address of the other end of the tunnel, which is used above for
            // the IPSEC filters.  The WAN caller information may also be
            // useful but there is no obvious way to return both the WAN and
            // tunnel endpoints in the current TAPI structures.

            // Send response.
            //
            pVc->state = CS_WaitConnect;
            SendControl( pTunnel, pVc, CMT_ICRP, 0, 0, NULL, 0 );
        }
    }
}


VOID
FsmInCallWaitConnect(
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN CONTROLMSGINFO* pControl )

    // Incoming call creation FSM WaitConnect state processing for VC 'pVc'.
    // 'PControl' is the exploded control message information.
    //
    // IMPORTANT: Caller must hold 'pVc->lockV' and 'pTunnel->lockT'.
    //
{
    if (*(pControl->pusMsgType) == CMT_ICCN)
    {
        if (pControl->pulTxConnectSpeed)
        {
            pVc->ulConnectBps = *(pControl->pulTxConnectSpeed);
        }
        else
        {
            // Not supposed to happen, but go on with a least common
            // denominator if it does.
            //
            pVc->ulConnectBps = 9600;
        }

        if (pControl->pulFramingType
            && !(*(pControl->pulFramingType) & FBM_Sync))
        {
            // Uh oh, the call is not using synchronous framing, which is the
            // only one NDISWAN supports.  Peer should have noticed we don't
            // support asynchronous during tunnel setup.  Close the call.
            //
            TRACE( TL_A, TM_Fsm, ( "Sync framing?" ) );
            WPLOG( LL_A, LM_Fsm, ( "Sync framing?" ) );

            if (!(pVc->pAdapter->ulFlags & ACBF_IgnoreFramingMismatch))
            {
                ScheduleTunnelWork(
                    pTunnel, pVc, FsmCloseCall,
                    (ULONG_PTR )CRESULT_GeneralWithError,
                    (ULONG_PTR )GERR_None,
                    0, 0, FALSE, FALSE );
                return;
            }
        }

        if (!pControl->pusRWindowSize)
        {
            // Peer did not send a receive window AVP so we're not doing Ns/Nr
            // flow control on the session.  If we requested sequencing peer
            // is really supposed to send his window, but if he doesn't assume
            // that means he wants no sequencing.  The draft/RFC is a little
            // ambiguous on this point.
            //
            DBG_if (ReadFlags( &pVc->ulFlags ) & VCBF_Sequencing)
                TRACE( TL_A, TM_Fsm, ( "No rw when we sent one?" ) );

            ClearFlags( &pVc->ulFlags, VCBF_Sequencing );
        }
        else
        {
            ULONG ulNew;

            if (*(pControl->pusRWindowSize) == 0)
            {
                // When peer sends a receive window of 0 it means he needs
                // sequencing to do out of order handling but doesn't want to
                // do flow control.  (Why would anyone choose this?) We fake
                // "no flow control" by setting a huge send window that should
                // never be filled.
                //
                pVc->ulMaxSendWindow = 10000;
            }
            else
            {
                pVc->ulMaxSendWindow = *(pControl->pusRWindowSize);
            }

            // Set the initial send window to 1/2 the maximum, to "slow start"
            // in case the networks congested.  If it's not the window will
            // quickly adapt to the maximum.
            //
            ulNew = pVc->ulMaxSendWindow >> 1;
            pVc->ulSendWindow = max( ulNew, 1 );
        }

        // Initialize the round trip time to the packet processing delay, if
        // any, per the draft/RFC.  The PPD is in 1/10ths of seconds.
        //
        if (pControl->pusPacketProcDelay)
        {
            pVc->ulRoundTripMs =
                ((ULONG )*(pControl->pusPacketProcDelay)) * 100;
        }
        else if (pVc->ulRoundTripMs == 0)
        {
            pVc->ulRoundTripMs = pVc->pAdapter->ulInitialSendTimeoutMs;
        }

        // Call is up.
        //
        CallTransitionComplete( pTunnel, pVc, CS_Established );
    }
    else if (*(pControl->pusMsgType) == CMT_CDN)
    {
        // Call is down.
        //
        pVc->status = NDIS_STATUS_TAPI_DISCONNECTMODE_NORMAL;
        CallTransitionComplete( pTunnel, pVc, CS_Idle );
    }
}


VOID
FsmInCallWaitReply(
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN CONTROLMSGINFO* pControl )

    // Incoming call creation FSM WaitReply state processing for VC 'pVc'.
    // 'PControl' is the exploded control message information.
    //
    // IMPORTANT: Caller must hold 'pVc->lockV' and 'pTunnel->lockT'.
    //
{
    ADAPTERCB* pAdapter;

    pAdapter = pVc->pAdapter;

    if (*(pControl->pusMsgType) == CMT_ICRP)
    {
        pVc->pMakeCall->Flags |= CALL_PARAMETERS_CHANGED;

        if (pControl->pusAssignedCallId && *(pControl->pusAssignedCallId) > 0)
        {
            pVc->usAssignedCallId = *(pControl->pusAssignedCallId);
        }
        else
        {
            ASSERT( !"No assigned CID?" );
            WPLOG( LL_A, LM_Fsm, ( "*** pVc = %p, no assigned CID", pVc ) );
            ScheduleTunnelWork(
                pTunnel, NULL, FsmCloseTunnel,
                (ULONG_PTR )TRESULT_GeneralWithError,
                (ULONG_PTR )GERR_BadCallId,
                0, 0, FALSE, FALSE );
            return;
        }

        // Use the queried media speed to set the connect speed
        //
        pVc->ulConnectBps = pTunnel->ulMediaSpeed;

        if (pControl->pusRWindowSize)
        {
            ULONG ulNew;

            SetFlags( &pVc->ulFlags, VCBF_Sequencing );

            if (*(pControl->pusRWindowSize) == 0)
            {
                // When peer sends a receive window of 0 it means he needs
                // sequencing to do out of order handling but doesn't want to
                // do flow control.  (Why would anyone choose this?) We fake
                // "no flow control" by setting a huge send window that should
                // never be filled.
                //
                pVc->ulMaxSendWindow = 10000;
            }
            else
            {
                pVc->ulMaxSendWindow = (ULONG )*(pControl->pusRWindowSize);
            }

            // Set the initial send window to 1/2 the maximum, to "slow start"
            // in case the networks congested.  If it's not the window will
            // quickly adapt to the maximum.
            //
            ulNew = pVc->ulMaxSendWindow >> 1;
            pVc->ulSendWindow = max( ulNew, 1 );
        }

        // Initialize the round trip time to the packet processing delay, if
        // any, per the draft/RFC.  The PPD is in 1/10ths of seconds.  If it's
        // not here, it might show up in the InCallConn.
        //
        if (pControl->pusPacketProcDelay)
        {
            pVc->ulRoundTripMs =
                ((ULONG )*(pControl->pusPacketProcDelay)) * 100;
        }

        // Send InCallConn and the call is up.
        //
        SendControl( pTunnel, pVc, CMT_ICCN, 0, 0, NULL, 0 );
        CallTransitionComplete( pTunnel, pVc, CS_Established );

    }
    else if (*(pControl->pusMsgType) == CMT_CDN)
    {
        USHORT usResult;
        USHORT usError;

        if (pControl->pusResult)
        {
            usResult = *(pControl->pusResult);
            if(pControl->pusError)
            {
                usError = *(pControl->pusError);
            }
            else
            {
                usError = GERR_None;
            }
        }
        else
        {
            usResult = CRESULT_GeneralWithError;
            usError = GERR_BadValue;
        }

        // Map the result/error to a TAPI disconnect code.
        //
        pVc->status = StatusFromResultAndError( usResult, usError );

        // Call is down.
        //
        CallTransitionComplete( pTunnel, pVc, CS_Idle );
    }
}


VOID
FsmOutCallBearerAnswer(
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc )

    // The bearer WAN media has answered the call initiated by an outgoing
    // call request from peer.  'PVc' is the VC control block associated with
    // the outgoing call.
    //
    // IMPORTANT: Caller must hold 'pVc->lockV' and 'pTunnel->lockT'.
    //
{
    ADAPTERCB* pAdapter;

    ASSERT( pVc->state == CS_WaitCsAnswer );

    pAdapter = pVc->pAdapter;

    // Send OutCallConn, and the call is up.
    //
    SendControl( pTunnel, pVc, CMT_OCCN, 0, 0, NULL, 0 );
    CallTransitionComplete( pTunnel, pVc, CS_Established );
}


VOID
FsmOutCallEstablished(
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN CONTROLMSGINFO* pControl )

    // Outgoing call creation FSM Established state processing for VC 'pVc'.
    // 'PControl' is the exploded control message information.
    //
    // IMPORTANT: Caller must hold 'pVc->lockV' and 'pTunnel->lockT'.
    //
{
    if (*(pControl->pusMsgType) == CMT_CDN)
    {
        // Call is down.
        //
        pVc->status = NDIS_STATUS_TAPI_DISCONNECTMODE_NORMAL;
        CallTransitionComplete( pTunnel, pVc, CS_Idle );
    }
}


VOID
FsmOutCallIdle(
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN CONTROLMSGINFO* pControl )

    // Outgoing call creation FSM Idle state processing for VC 'pVc'.
    // 'PControl' is the exploded control message information.
    //
    // IMPORTANT: Caller must hold 'pVc->lockV' and 'pTunnel->lockT'.
    //
{
    ADAPTERCB* pAdapter;

    pAdapter = pVc->pAdapter;

    if (*(pControl->pusMsgType) == CMT_OCRQ)
    {
        if (!(ReadFlags( &pVc->ulFlags ) & VCBF_PeerOpenPending))
        {
            // If no open is pending, the call and/or owning tunnel has been
            // slammed, we are in the clean up phase, and no response should
            // be made.
            //
            TRACE( TL_A, TM_Fsm, ( "OC aborted" ) );
            WPLOG( LL_A, LM_Fsm, ( "OCRQ received & we're in the cleanup phase" ) );
            return;
        }

        if (pControl->pusAssignedCallId)
        {
            pVc->usAssignedCallId = *(pControl->pusAssignedCallId);
        }

        if (pVc->usResult)
        {
            // Call is down.
            //
            pVc->status =
                StatusFromResultAndError( pVc->usResult, pVc->usError );

            pVc->state = CS_Idle;
            SendControl(
                pTunnel, pVc, CMT_CDN,
                (ULONG )pVc->usResult, (ULONG )pVc->usError, NULL,
                CSF_CallIdleOnAck );
        }
        else
        {
            // Stash the call serial number.
            //
            if (pControl->pulCallSerialNumber)
            {
                pVc->pLcParams->ulCallSerialNumber =
                    *(pControl->pulCallSerialNumber);
            }
            else
            {
                pVc->pLcParams->ulCallSerialNumber = 0;
            }

            // The minimum and maximum rates acceptable to peer must be
            // dropped on the floor here and the TAPI structures for incoming
            // calls do not have a way to report such information.
            //
            // Calculate the connect bps to report to NDISWAN and to peer.
            // Since we have no WAN link and no real way to figure the link
            // speed, it's just a guesstimate of the LAN speed or the maximum
            // acceptable to peer, whichever is smaller.
            //
            if (pControl->pulMaximumBps)
            {
                pVc->ulConnectBps = (ULONG )*(pControl->pulMaximumBps);
            }
            if (pVc->ulConnectBps > pTunnel->ulMediaSpeed)
            {
                pVc->ulConnectBps = pTunnel->ulMediaSpeed;
            }

            // Stash the requested bearer types.
            //
            pVc->pTcInfo->ulMediaMode = 0;
            if (pControl->pulBearerType)
            {
                if (*(pControl->pulBearerType) & BBM_Analog)
                {
                    pVc->pTcInfo->ulMediaMode |= LINEMEDIAMODE_DATAMODEM;
                }

                if (*(pControl->pulBearerType) & BBM_Digital)
                {
                    pVc->pTcInfo->ulMediaMode |= LINEMEDIAMODE_DIGITALDATA;
                }
            }

            // Stash the maximum send window.
            //
            if (pControl->pusRWindowSize)
            {
                SetFlags( &pVc->ulFlags, VCBF_Sequencing );

                if (*(pControl->pusRWindowSize) == 0)
                {
                    // When peer sends a receive window of 0 it means he needs
                    // sequencing to do out of order handling but doesn't want
                    // to do flow control.  (Why would anyone choose this?)  We
                    // fake "no flow control" by setting a huge send window
                    // that should never be filled.
                    //
                    pVc->ulMaxSendWindow = 10000;
                }
                else
                {
                    pVc->ulMaxSendWindow = (ULONG )*(pControl->pusRWindowSize);
                }
            }

            // Initialize the round trip time to the packet processing delay,
            // if any, per the draft/RFC.  The PPD is in 1/10ths of seconds.
            //
            if (pControl->pusPacketProcDelay)
            {
                pVc->ulRoundTripMs =
                    ((ULONG )*(pControl->pusPacketProcDelay)) * 100;
            }
            else
            {
                pVc->ulRoundTripMs = pAdapter->ulInitialSendTimeoutMs;
            }

            // Note: The phone numbers of the caller and callee as well as the
            // Subaddress are available at this point.  Currently, the
            // CallerID field of the TAPI structures is used for the IP
            // address of the other end of the tunnel, which is used above for
            // the IPSEC filters.  The WAN caller information may also be
            // useful but there is no obvious way to return both the WAN and
            // tunnel endpoints in the current TAPI structures.
            // Store the IP address of the peer.

            pVc->state = CS_WaitCsAnswer;
            SendControl( pTunnel, pVc, CMT_OCRP, 0, 0, NULL, 0 );

            // For now, with only "null" WAN call handoff supported, the
            // bearer answer event is also generated here.
            //
            FsmOutCallBearerAnswer( pTunnel, pVc );
        }
    }
}


VOID
FsmOutCallWaitReply(
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN CONTROLMSGINFO* pControl )

    // Outgoing call creation FSM WaitReply state processing for VC 'pVc'.
    // 'PControl' is the exploded control message information.
    //
    // IMPORTANT: Caller must hold 'pVc->lockV' and 'pTunnel->lockT'.
    //
{
    if (*(pControl->pusMsgType) == CMT_OCRP)
    {
        pVc->pMakeCall->Flags |= CALL_PARAMETERS_CHANGED;

        // Stash the assigned Call-ID.
        //
        if (pControl->pusAssignedCallId && *(pControl->pusAssignedCallId) > 0)
        {
            pVc->usAssignedCallId = *(pControl->pusAssignedCallId);
        }
        else
        {
            // Peer ignored a MUST we can't cover up, by not sending a Call-ID
            // for call control and payload traffic headed his way.
            //
            ASSERT( !"No assigned CID?" );
            ScheduleTunnelWork(
                pTunnel, NULL, FsmCloseTunnel,
                (ULONG_PTR )TRESULT_GeneralWithError,
                (ULONG_PTR )GERR_None,
                0, 0, FALSE, FALSE );
            return;
        }

        // Stash the physical channel ID.
        //
        if (pControl->pulPhysicalChannelId)
        {
            pVc->pLcParams->ulPhysicalChannelId =
                *(pControl->pulPhysicalChannelId);
        }
        else
        {
            pVc->pLcParams->ulPhysicalChannelId = 0xFFFFFFFF;
        }

        pVc->state = CS_WaitConnect;
    }
    else if (*(pControl->pusMsgType) == CMT_CDN)
    {
        USHORT usResult;
        USHORT usError;

        if (pControl->pusResult)
        {
            usResult = *(pControl->pusResult);
            if(pControl->pusError)
            {
                usError = *(pControl->pusError);
            }
            else
            {
                usError = GERR_None;
            }
        }
        else
        {
            usResult = CRESULT_GeneralWithError;
            usError = GERR_BadValue;
        }

        // Map the result/error to a TAPI disconnect code.
        //
        pVc->status = StatusFromResultAndError( usResult, usError );

        // Call is down.
        //
        CallTransitionComplete( pTunnel, pVc, CS_Idle );
    }
}


VOID
FsmOutCallWaitConnect(
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN CONTROLMSGINFO* pControl )

    // Outgoing call creation FSM WaitConnect state processing for VC 'pVc'.
    // 'PControl' is the exploded control message information.
    //
    // IMPORTANT: Caller must hold 'pVc->lockV' and 'pTunnel->lockT'.
    //
{
    if (*(pControl->pusMsgType) == CMT_OCCN)
    {
        // Stash the connect BPS.
        //
        if (pControl->pulTxConnectSpeed)
        {
            pVc->ulConnectBps = *(pControl->pulTxConnectSpeed);
        }
        else
        {
            // Not supposed to happen, but try to go on with a least common
            // denominator if it does.
            //
            pVc->ulConnectBps = 9600;
        }

        DBG_if (pControl->pulFramingType
                && !(*(pControl->pulFramingType) & FBM_Sync))
        {
            // Should not happen since we said in our request we only want
            // synchronous framing.  If it does, go on in the hope that this
            // AVP is what peer got wrong and not the framing itself.
            //
            ASSERT( "No sync framing?" );
        }

        // Stash the maximum send window.
        //
        if (!pControl->pusRWindowSize)
        {
            // Peer did not send a receive window AVP so we're not doing Ns/Nr
            // flow control on the session.  If we requested sequencing peer
            // is really supposed to send his window, but if he doesn't assume
            // that means he wants no sequencing.  The draft/RFC is a little
            // ambiguous on this point.
            //
            DBG_if (ReadFlags( &pVc->ulFlags ) & VCBF_Sequencing)
                TRACE( TL_A, TM_Fsm, ( "No rw when we sent one?" ) );

            ClearFlags( &pVc->ulFlags, VCBF_Sequencing );
        }
        else
        {
            ULONG ulNew;

            if (*(pControl->pusRWindowSize) == 0)
            {
                // When peer sends a receive window of 0 it means he needs
                // sequencing to do out of order handling but doesn't want to
                // do flow control.  (Why would anyone choose this?)  We fake
                // "no flow control" by setting a huge send window that should
                // never be filled.
                //
                pVc->ulMaxSendWindow = 10000;
            }
            else
            {
                pVc->ulMaxSendWindow = *(pControl->pusRWindowSize);
            }

            // Set the initial send window to 1/2 the maximum, to "slow start"
            // in case the networks congested.  If it's not the window will
            // quickly adapt to the maximum.
            //
            ulNew = pVc->ulMaxSendWindow << 1;
            pVc->ulSendWindow = max( ulNew, 1 );
        }

        // Initialize the round trip time to the packet processing delay, if
        // any, per the draft/RFC.  The PPD is in 1/10ths of seconds.
        //
        if (pControl->pusPacketProcDelay)
        {
            pVc->ulRoundTripMs =
                ((ULONG )*(pControl->pusPacketProcDelay)) * 100;
        }
        else
        {
            pVc->ulRoundTripMs = pVc->pAdapter->ulInitialSendTimeoutMs;
        }

        // Call is up.
        //
        CallTransitionComplete( pTunnel, pVc, CS_Established );
    }
    else if (*(pControl->pusMsgType) == CMT_CDN)
    {
        USHORT usResult;
        USHORT usError;

        if (pControl->pusResult)
        {
            usResult = *(pControl->pusResult);
            if(pControl->pusError)
            {
                usError = *(pControl->pusError);
            }
            else
            {
                usError = GERR_None;
            }
        }
        else
        {
            usResult = CRESULT_GeneralWithError;
            usError = GERR_BadValue;
        }

        // Map the result/error to a TAPI disconnect code.
        //
        pVc->status = StatusFromResultAndError( usResult, usError );

        // Call is down.
        //
        CallTransitionComplete( pTunnel, pVc, CS_Idle );
    }
}


VOID
FsmTunnelEstablished(
    IN TUNNELCB* pTunnel,
    IN CONTROLMSGINFO* pControl )

    // Tunnel creation FSM Established state processing for tunnel 'pTunnel'.
    // 'PControl' is the exploded control message information.
    //
    // IMPORTANT: Caller must hold 'pTunnel->lockT'.
    //
{
    ADAPTERCB* pAdapter;

    pAdapter = pTunnel->pAdapter;

    if (*(pControl->pusMsgType) == CMT_StopCCN)
    {
        // Peer taking tunnel down.
        //
        TunnelTransitionComplete( pTunnel, CCS_Idle );
    }
}


VOID
FsmTunnelIdle(
    IN TUNNELCB* pTunnel,
    IN CONTROLMSGINFO* pControl )

    // Tunnel creation FSM Idle state processing for tunnel 'pTunnel'.
    // 'PControl' is the exploded control message information.
    //
    // IMPORTANT: Caller must hold 'pTunnel->lockT'.
    //
{
    NDIS_STATUS status;
    ADAPTERCB* pAdapter;
    USHORT usResult;
    USHORT usError;

    pAdapter = pTunnel->pAdapter;

    if (*(pControl->pusMsgType) == CMT_SCCRQ)
    {
        SetFlags( &pTunnel->ulFlags, (TCBF_PeerInitiated | TCBF_PeerInitRef) );

        if (ReferenceSap( pAdapter ))
        {
            // A SAP is active.  Because SAPs can be deregistered without
            // closing active incoming tunnels, we need a reference on the
            // open TDI context for the tunnel.  We call TdixReference rather
            // than TdixOpen, because with TDI guaranteed to be open the
            // effect is the same and TdixReference can be called at DISPATCH
            // IRQL while TdixOpen cannot.  The reference on the SAP is then
            // removed since we don't want the tunnel to prevent the SAP from
            // being deregistered.
            //
            TdixReference( &pAdapter->tdix );
            SetFlags( &pTunnel->ulFlags, TCBF_TdixReferenced );
            DereferenceSap( pAdapter );
        }
        else
        {
            // No SAP is active.  The only reason peer's request got this far
            // is that an outgoing call or just-deregistered-SAP had TDI open.
            // Discard it as if TDI had not been open.
            //
            TRACE( TL_I, TM_Fsm, ( "No active SAP" ) );
            TunnelTransitionComplete( pTunnel, CCS_Idle );
            return;
        }

        GetCcAvps( pTunnel, pControl, &usResult, &usError );
        if (usResult)
        {
            // The tunnel is down, but must hold it and any VCs until the
            // closing exchange is acknowledged.
            //
            SendControl(
                pTunnel, NULL, CMT_StopCCN,
                (ULONG )usResult, (ULONG )usError, NULL, CSF_TunnelIdleOnAck );
        }
        else
        {
            // Tunnel creation successfully underway.  Flip the flag that
            // tells MakeCall to queue requesting VCs on the result.
            //
            SetFlags( &pTunnel->ulFlags, TCBF_CcInTransition );

            if (pControl->pchChallenge)
            {
                CHAR* pszPassword;

                // Challenge received.  Calculate the response value, based on
                // the password from the registry.
                //
                pAdapter = pTunnel->pAdapter;
                if (pAdapter->pszPassword)
                {
                    pszPassword = pAdapter->pszPassword;
                }
                else
                {
                    pszPassword = "";
                }

                CalculateResponse(
                    pControl->pchChallenge,
                    (ULONG )pControl->usChallengeLength,
                    pszPassword,
                    CMT_SCCRP,
                    pTunnel->achResponseToSend );
            }

            pTunnel->state = CCS_WaitCtlConnect;
            SendControl(
                pTunnel, NULL, CMT_SCCRP,
                (pControl->pchChallenge != NULL), 0, NULL, 0 );
        }
    }
}


VOID
FsmTunnelWaitCtlConnect(
    IN TUNNELCB* pTunnel,
    IN CONTROLMSGINFO* pControl )

    // Tunnel creation FSM WaitCtlConnect state processing for tunnel
    // 'pTunnel'.  'PControl' is the exploded control message information.
    //
    // IMPORTANT: Caller must hold 'pTunnel->lockT'.
    //
{
    ADAPTERCB* pAdapter;

    pAdapter = pTunnel->pAdapter;

    if (*(pControl->pusMsgType) == CMT_SCCCN)
    {
        USHORT usResult;

        usResult = 0;
        if (pAdapter->pszPassword)
        {
            // We sent a challenge.
            //
            if (pControl->pchResponse)
            {
                CHAR achResponseExpected[ 16 ];
                ULONG i;

                // Challenge response received.  Calculate the expected
                // response and compare to that received.
                //
                CalculateResponse(
                    pTunnel->achChallengeToSend,
                    sizeof(pTunnel->achChallengeToSend),
                    pAdapter->pszPassword,
                    CMT_SCCCN,
                    achResponseExpected );

                for (i = 0; i < 16; ++i)
                {
                    if (achResponseExpected[ i ] != pControl->pchResponse[ i ])
                    {
                        break;
                    }
                }

                if (i < 16)
                {
                    TRACE( TL_N, TM_Fsm, ( "Wrong challenge response" ) );
                    usResult = TRESULT_NotAuthorized;
                }
            }
            else
            {
                // We sent a challenge and got no challenge response.
                // 
                //
                TRACE( TL_N, TM_Fsm, ( "No challenge response" ) );
                usResult = TRESULT_FsmError;
            }
        }

        if (usResult)
        {
            // Tunnel going down.
            //
            pTunnel->state = CCS_Idle;
            SendControl(
                pTunnel, NULL, CMT_StopCCN,
                (ULONG )usResult, 0, NULL, CSF_TunnelIdleOnAck );
        }
        else
        {
            // Tunnel is up.
            //
            TunnelTransitionComplete( pTunnel, CCS_Established );
        }
    }
    else if (*(pControl->pusMsgType) == CMT_StopCCN)
    {
        // Peer taking tunnel down.
        //
        TunnelTransitionComplete( pTunnel, CCS_Idle );
    }
}


VOID
FsmTunnelWaitCtlReply(
    IN TUNNELCB* pTunnel,
    IN CONTROLMSGINFO* pControl )

    // Tunnel creation FSM WaitCtlReply state processing for tunnel 'pTunnel'.
    // 'PControl' is the exploded control message information.
    //
    // IMPORTANT: Caller must hold 'pTunnel->lockT'.
    //
{
    NDIS_STATUS status;
    ADAPTERCB* pAdapter;
    USHORT usResult;
    USHORT usError;

    pAdapter = pTunnel->pAdapter;

    if (*(pControl->pusMsgType) == CMT_SCCRP)
    {
        GetCcAvps( pTunnel, pControl, &usResult, &usError );

        if (pAdapter->pszPassword)
        {
            // We sent a challenge.
            //
            if (pControl->pchResponse)
            {
                CHAR achResponseExpected[ 16 ];
                ULONG i;

                // Challenge response received.  Calculate the expected
                // response and compare to that received.
                //
                CalculateResponse(
                    pTunnel->achChallengeToSend,
                    sizeof(pTunnel->achChallengeToSend),
                    pAdapter->pszPassword,
                    CMT_SCCRP,
                    achResponseExpected );

                for (i = 0; i < 16; ++i)
                {
                    if (achResponseExpected[ i ] != pControl->pchResponse[ i ])
                    {
                        break;
                    }
                }

                if (i < 16)
                {
                    TRACE( TL_N, TM_Fsm, ( "Wrong challenge response" ) );
                    usResult = TRESULT_General;
                }
            }
            else
            {
                // We sent a challenge and got no challenge response.  Treat
                // this as if a bad response was received.
                //
                TRACE( TL_N, TM_Fsm, ( "No challenge response" ) );
                usResult = TRESULT_General;
            }
        }

        if (usResult)
        {
            // Tunnel creation failed, so shut down.
            //
            pTunnel->state = CCS_Idle;
            SendControl(
                pTunnel, NULL, CMT_StopCCN,
                (ULONG )usResult, (ULONG )usError, NULL, CSF_TunnelIdleOnAck );
        }
        else
        {
            if (pControl->pchChallenge)
            {
                CHAR* pszPassword;

                // Challenge received.  Calculate the response value, based on
                // the password from the registry.
                //
                pAdapter = pTunnel->pAdapter;
                if (pAdapter->pszPassword)
                    pszPassword = pAdapter->pszPassword;
                else
                    pszPassword = "";

                CalculateResponse(
                    pControl->pchChallenge,
                    (ULONG )pControl->usChallengeLength,
                    pszPassword,
                    CMT_SCCCN,
                    pTunnel->achResponseToSend );
            }

            // Tunnel is up.
            //
            SendControl( pTunnel, NULL, CMT_SCCCN,
                (pControl->pchChallenge != NULL), 0, NULL, CSF_QueryMediaSpeed);
            TunnelTransitionComplete( pTunnel, CCS_Established );
        }
    }
    else if (*(pControl->pusMsgType) == CMT_StopCCN)
    {
        // Peer taking tunnel down.
        //
        TunnelTransitionComplete( pTunnel, CCS_Idle );
    }
}


VOID
GetCcAvps(
    IN TUNNELCB* pTunnel,
    IN CONTROLMSGINFO* pControl,
    OUT USHORT* pusResult,
    OUT USHORT* pusError )

    // Retrieve and interpret control connection AVPs received in the SCCRQ or
    // SCCRP message in 'pControl', returning the result and error codes for
    // the response in '*pusResult' and '*pusError'.  'PTunnel' is the tunnel
    // control block.
    //
{
    ULONG ulNew;

    *pusResult = 0;
    *pusError = GERR_None;

    if (!pControl->pusProtocolVersion
        || *(pControl->pusProtocolVersion) != L2TP_ProtocolVersion)
    {
        // Peer wants to do a version of L2TP that doesn't match the only
        // one we understand.
        //
        TRACE( TL_A, TM_Recv, ( "Bad protocol version?" ) );
        WPLOG( LL_A, LM_Recv, ( "Bad protocol version?" ) );
        *pusResult = TRESULT_BadProtocolVersion;
        return;
    }

    // Make sure the MUST fields are really there and have valid values, then
    // store them in our control blocks.
    //
    if (!pControl->pusAssignedTunnelId
        || *(pControl->pusAssignedTunnelId) == 0
        || !pControl->pulFramingCaps)
    {
        TRACE( TL_A, TM_Recv, ( "Missing MUSTs?" ) );
        WPLOG( LL_A, LM_Recv, ( "Missing MUSTs?" ) );
        *pusResult = TRESULT_GeneralWithError;
        *pusError = GERR_BadValue;
        return;
    }

    pTunnel->usAssignedTunnelId = *(pControl->pusAssignedTunnelId);
    pTunnel->ulFramingCaps = *(pControl->pulFramingCaps);

    if (pControl->pulBearerCaps)
    {
        pTunnel->ulBearerCaps = *(pControl->pulBearerCaps);
    }
    else
    {
        pTunnel->ulBearerCaps = 0;
    }

    if (pControl->pusRWindowSize && *(pControl->pusRWindowSize))
    {
        // Peer provided his receive window, which becomes our send window.
        //
        pTunnel->ulMaxSendWindow = (ULONG )*(pControl->pusRWindowSize);
    }
    else
    {
        // Peer provided no receive window, so use the default of 4 per the
        // draft/RFC.
        //
        pTunnel->ulMaxSendWindow = L2TP_DefaultReceiveWindow;
    }

    // Set the initial send window to 1/2 the maximum, to "slow start" in case
    // the network is congested.  If it's not the window will quickly adapt to
    // the maximum.
    //
    ulNew = pTunnel->ulMaxSendWindow >> 1;
    pTunnel->ulSendWindow = max( ulNew, 1 );
}


ULONG
StatusFromResultAndError(
    IN USHORT usResult,
    IN USHORT usError )

    // Map non-success L2TP result/error codes to a best-fit TAPI
    // NDIS_STATUS_TAPI_DISCONNECT_* code.
    //
{
    ULONG ulResult;

    switch (usResult)
    {
        case CRESULT_GeneralWithError:
        {
            switch (usError)
            {
                case GERR_TryAnother:
                {
                    ulResult = NDIS_STATUS_TAPI_DISCONNECTMODE_BUSY;
                    break;
                }

                case GERR_BadValue:
                case GERR_BadLength:
                case GERR_NoControlConnection:
                case GERR_NoResources:
                {
                    ulResult = NDIS_STATUS_TAPI_DISCONNECTMODE_UNAVAIL;
                    break;
                }

                default:
                {
                    ulResult = NDIS_STATUS_TAPI_DISCONNECTMODE_REJECT;
                    break;
                }
            }
            break;
        }

        case CRESULT_Busy:
        {
            ulResult = NDIS_STATUS_TAPI_DISCONNECTMODE_BUSY;
            break;
        }

        case CRESULT_NoCarrier:
        case CRESULT_NoDialTone:
        case CRESULT_Timeout:
        case CRESULT_NoFacilitiesTemporary:
        case CRESULT_NoFacilitiesPermanent:
        case CRESULT_Administrative:
        {
            ulResult = NDIS_STATUS_TAPI_DISCONNECTMODE_UNAVAIL;
            break;
        }

        case CRESULT_NoFraming:
        {
            ulResult = NDIS_STATUS_TAPI_DISCONNECTMODE_INCOMPATIBLE;
            break;
        }

        case CRESULT_InvalidDestination:
        {
            ulResult = NDIS_STATUS_TAPI_DISCONNECTMODE_BADADDRESS;
            break;
        }

        case CRESULT_LostCarrier:
        default:
        {
            ulResult = NDIS_STATUS_TAPI_DISCONNECTMODE_CONGESTION;
            break;
        }
    }

    return ulResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ndis\rasl2tp\debug.h ===
// Copyright (c) 1997, Microsoft Corporation, all rights reserved
//
// debug.h
// RAS L2TP WAN mini-port/call-manager driver
// Debug helper header
//
// 01/07/97 Steve Cobb


#ifndef _DEBUG_H_
#define _DEBUG_H_


//-----------------------------------------------------------------------------
// Debug constants
//-----------------------------------------------------------------------------

// Memory tags used with NdisAllocateMemoryWithTag to identify allocations
// made by the L2TP driver.  Also, several context blocks define a first field
// of 'ulTag' set to these values for ASSERT sanity checking and eased memory
// dump browsing.  Such tags are set to MTAG_FREED just before NdisFreeMemory
// is called.
//
#define MTAG_FREED       '0T2L'
#define MTAG_ADAPTERCB   '1T2L'
#define MTAG_TUNNELCB    '2T2L'
#define MTAG_VCCB        '3T2L'
#define MTAG_VCTABLE     '4T2L'
#define MTAG_WORKITEM    '5T2L'
#define MTAG_TIMERQ      '6T2L'
#define MTAG_TIMERQITEM  '7T2L'
#define MTAG_PACKETPOOL  '8T2L'
#define MTAG_FBUFPOOL    '9T2L'
#define MTAG_HBUFPOOL    'aT2L'
#define MTAG_TDIXRDG     'bT2L'
#define MTAG_TDIXSDG     'cT2L'
#define MTAG_CTRLRECD    'dT2L'
#define MTAG_CTRLSENT    'eT2L'
#define MTAG_PAYLRECD    'fT2L'
#define MTAG_PAYLSENT    'gT2L'
#define MTAG_INCALL      'hT2L'
#define MTAG_UTIL        'iT2L'
#define MTAG_ROUTEQUERY  'jT2L'
#define MTAG_ROUTESET    'kT2L'
#define MTAG_L2TPPARAMS  'lT2L'
#define MTAG_TUNNELWORK  'mT2L'
#define MTAG_TDIXROUTE   'nT2L'
#define MTAG_CTRLMSGINFO 'oT2L'

// Trace levels.
//
#define TL_None 0    // Trace disabled
#define TL_A    0x10 // Alert
#define TL_I    0x18 // Interface (highest level workable for general use)
#define TL_N    0x20 // Normal
#define TL_V    0x30 // Verbose

// Trace mask bits.
//
#define TM_Cm    0x00000001 // Call manager general
#define TM_Mp    0x00000002 // Mini-port general
#define TM_Send  0x00000004 // Send path
#define TM_Recv  0x00000008 // Receive path
#define TM_Fsm   0x00000010 // Finite state machines
#define TM_Init  0x00000020 // Initialization
#define TM_Res   0x00000040 // Resources such as memory allocs/frees
#define TM_Misc  0x00000080 // Miscellaneous
#define TM_CMsg  0x00000100 // Control messages and received AVPs
#define TM_Msg   0x00000200 // Verbose message, address, Ns/Nr, payload
#define TM_TWrk  0x00001000 // Tunnel work APC queuing
#define TM_Ref   0x00010000 // References
#define TM_Time  0x00020000 // Timer queue
#define TM_Tdi   0x00040000 // TDI and extensions
#define TM_Pool  0x00080000 // Buffer and packet pooling
#define TM_Stat  0x00100000 // Call statistics
#define TM_Spec  0x01000000 // Special purpose temporary traces
#define TM_MDmp  0x10000000 // Message dumps
#define TM_Dbg   0x80000000 // Debug corruption checks

#define TM_Wild  0xFFFFFFFF // Everything
#define TM_All   0x7FFFFFFF // Everything except corruption checks
#define TM_BTWrk 0x00000FFF // Base with messages and tunnel work
#define TM_BCMsg 0x000001FF // Base with control messages
#define TM_XCMsg 0x001401FF // Base with control messages extended
#define TM_Base  0x000000FF // Base only

// Bytes to appear on each line of dump output.
//
#define DUMP_BytesPerLine 16


//-----------------------------------------------------------------------------
// Debug global declarations (defined in debug.c)
//-----------------------------------------------------------------------------

// Active debug trace level and active trace set mask.  Set these variables
// with the debugger at startup to enable and filter the debug output.  All
// messages with (TL_*) level less than or equal to 'g_ulTraceLevel' and from
// any (TM_*) set(s) present in 'g_ulTraceMask' are displayed.
//
extern ULONG g_ulTraceLevel;
extern ULONG g_ulTraceMask;


//-----------------------------------------------------------------------------
// Debug macros
//-----------------------------------------------------------------------------

#if DBG

// TRACE sends printf style output to the kernel debugger.  Caller indicates a
// "verbosity" level with the 'ulLevel' argument and associates the trace with
// one or more trace sets with the 'ulMask' bit mask argument.  Notice that
// the variable count printf arguments 'Args' must be parenthesized.  For
// example...
//
// A "leave" routine message:
//     TRACE( TL_N, TM_Init, ( "DriverEntry=$%x", status ) );
// An error condition occurred:
//     TRACE( TL_E, TM_Init, ( "NdisMRegisterMiniport=$%x", status ) );
//
//
#define TRACE(ulLevel,ulMask,Args)                             \
{                                                              \
    if (ulLevel <= g_ulTraceLevel && (g_ulTraceMask & ulMask)) \
    {                                                          \
        DbgPrint( "L2TP: " );                                  \
        DbgPrint Args;                                         \
        DbgPrint( "\n" );                                      \
    }                                                          \
}

// ASSERT checks caller's assertion expression and if false, prints a kernel
// debugger message and breaks.
//
#undef ASSERT
#define ASSERT(x)                                           \
{                                                           \
    if (!(x))                                               \
    {                                                       \
        DbgPrint( "L2TP: !ASSERT( %s ) at line %d of %s\n", \
            #x, __LINE__, __FILE__ );                       \
        DbgBreakPoint();                                    \
    }                                                       \
}

// DUMP prints to the kernel debugger a hex dump of 'cb' bytes starting at 'p'
// in groups of 'ul'.  If 'f' is set the address of each line in shown before
// the dump.  DUMPB, DUMPW, and DUMPDW are BYTE, WORD, and DWORD dumps
// respectively.  Note that the multi-byte dumps do not reflect little-endian
// (Intel) byte order.  The 'ulLevel' and 'ulMask' are described for TRACE.
//
#define DUMP(ulLevel,ulMask,p,cb,f,ul)                         \
{                                                              \
    if (ulLevel <= g_ulTraceLevel && (g_ulTraceMask & ulMask)) \
    {                                                          \
        Dump( (CHAR* )p, cb, f, ul );                          \
    }                                                          \
}

#define DUMPB(ulLevel,ulMask,p,cb)                             \
{                                                              \
    if (ulLevel <= g_ulTraceLevel && (g_ulTraceMask & ulMask)) \
    {                                                          \
        Dump( (CHAR* )p, cb, 0, 1 );                           \
    }                                                          \
}

#define DUMPW(ulLevel,ulMask,p,cb)                             \
{                                                              \
    if (ulLevel <= g_ulTraceLevel && (g_ulTraceMask & ulMask)) \
    {                                                          \
        Dump( (CHAR* )p, cb, 0, 2 );                           \
    }                                                          \
}

#define DUMPDW(ulLevel,ulMask,p,cb)                            \
{                                                              \
    if (ulLevel <= g_ulTraceLevel && (g_ulTraceMask & ulMask)) \
    {                                                          \
        Dump( (CHAR* )p, cb, 0, 4 );                           \
    }                                                          \
}


// Double-linked list corruption detector.  Runs the test if 'ulMask' is
// enabled, with TM_Dbg a suggested setting.  Shows verbose output if
// 'ulLevel' is at or above the current trace threshold.
//
#define CHECKLIST(ulMask,p,ulLevel)                            \
{                                                              \
    if (g_ulTraceMask & ulMask)                                \
    {                                                          \
        CheckList( p, (BOOLEAN )(ulLevel <= g_ulTraceLevel) ); \
    }                                                          \
}


// DBG_if can be used to put in TRACE/DUMPs conditional on an expression that
// need not be evaluated in non-DBG builds, e.g the statements below generate
// no code in a non-DBG build, but in DBG builds print the TRACE if x<y and
// asserts otherwise.
//
//     DBG_if (x < y)
//         TRACE( TL_N, TM_Misc, ( "x < y" ) );
//     DBG_else
//         ASSERT( FALSE );
//
//
#define DBG_if(x) if (x)
#define DBG_else  else


#else // !DBG

// Debug macros compile out of non-DBG builds.
//
#define TRACE(ulLevel,ulMask,Args)
#undef ASSERT
#define ASSERT(x)
#define DUMP(ulLevel,ulMask,p,cb,f,dw)
#define DUMPB(ulLevel,ulMask,p,cb)
#define DUMPW(ulLevel,ulMask,p,cb)
#define DUMPDW(ulLevel,ulMask,p,cb)
#define CHECKLIST(ulMask,p,ulLevel)
#define DBG_if(x)
#define DBG_else

#endif


//-----------------------------------------------------------------------------
// Prototypes
//-----------------------------------------------------------------------------

VOID
CheckList(
    IN LIST_ENTRY* pList,
    IN BOOLEAN fShowLinks );

VOID
Dump(
    CHAR* p,
    ULONG cb,
    BOOLEAN fAddress,
    ULONG ulGroup );

VOID
DumpLine(
    CHAR* p,
    ULONG cb,
    BOOLEAN  fAddress,
    ULONG ulGroup );
    
    
//-----------------------------------------------------------------------------
// WPP Tracing
//-----------------------------------------------------------------------------

#define LL_A    1
#define LL_M    2
#define LL_I    3
#define LL_V    4

#define WPP_CONTROL_GUIDS \
    WPP_DEFINE_CONTROL_GUID(CtlGuid,(d58c126e, b309, 11d1, 969e, 0000f875a5bc),  \
        WPP_DEFINE_BIT(LM_Res)  \
        WPP_DEFINE_BIT(LM_CMsg) \
        WPP_DEFINE_BIT(LM_Cm)   \
        WPP_DEFINE_BIT(LM_Fsm)  \
        WPP_DEFINE_BIT(LM_Send) \
        WPP_DEFINE_BIT(LM_Recv) \
        WPP_DEFINE_BIT(LM_Tdi)  \
        WPP_DEFINE_BIT(LM_Pool) \
        WPP_DEFINE_BIT(LM_Misc) \
        WPP_DEFINE_BIT(LM_Mp) )
        
#define WPP_LEVEL_FLAGS_LOGGER(lvl,flags) WPP_LEVEL_LOGGER(flags)
#define WPP_LEVEL_FLAGS_ENABLED(lvl, flags) (WPP_LEVEL_ENABLED(flags) && WPP_CONTROL(WPP_BIT_ ## flags).Level >= lvl)


#endif // _DEBUG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ndis\rasl2tp\l2tpp.h ===
// Copyright (c) 1997, Microsoft Corporation, all rights reserved
//
// l2tpp.h
// RAS L2TP WAN mini-port/call-manager driver
// Main private header (precompiled)
//
// 01/07/97 Steve Cobb
//
//
// About naming:
//
// This driver contains code for both the L2TP mini-port and the L2TP call
// manager.  All handler routines exported to NDIS are prefixed with either
// 'Lmp' for the mini-port handlers or 'Lcm' for the call manager handlers.
//
//
// About locks:
//
// Data structures that may change during simultaneous requests to different
// processors in a multi-processor system must be protected with spin-locks or
// accessed only with interlocked routines.  Where locking is required to
// access a data field in this header, the comment for that field indicates
// same.  A CoNDIS client is a trusted kernel mode component and presumed to
// follow the documented call sequences of CoNDIS.  Some access conflicts that
// might be caused by goofy clients are not checked, though the easy ones are.
// Cases where multiple clients might conflict are protected even though, for
// now, the TAPI proxy is expected to be the only client.
//
//
// About TDI and NDIS compliance:
//
// This driver is generally compliant with documented TDI and NDIS procedures,
// but there are two compliance issues worth mentioning.  First, it takes
// performance advantage from the fact that NDIS_BUFFERs and TDI I/O buffers
// are both defined as MDLs (see NDISBUFFERISMDL in tdix.c).  Second, it is
// built by default to take advantage of an IRP handling optimization which
// may be non-TDI-compliant though the docs are not real clear on the point
// (see ALLOCATEIRPS in tdix.c).  The driver could be made fully compliant on
// the first point in one hour and on the second by changing a #if
// option...but there would be a performance penalty.  Finally,
// InterlockedExchangePointer and InterlockedCompareExchangePointer are used,
// though there don't currently appear to be any NDIS equivalents.


#ifndef _L2TPP_H_
#define _L2TPP_H_


// If set, less commom allocations such as 1-per-call control blocks are made
// from lookaside lists.  Otherwise they are made using heap calls.  This
// option makes sense where a large number of calls are expected to be
// handled.
//
#define LLISTALL 0

// If set, ReadFlags translates into a simple assigment, otherwise it is an
// Interlocked operation.  Set this to 1 if a bus read of ULONG size is
// atomic.
//
#define READFLAGSDIRECT 1

#include <ntddk.h>
#include <tdi.h>
#include <tdikrnl.h>
#include <tdiinfo.h>
#include <ntddtcp.h>
#include <ntddip.h>
#include <ntddndis.h>
#include <ipinfo.h>
#include <tcpinfo.h>
#include <ndis.h>
#include <ndiswan.h>
#include <ndistapi.h>
#include <ntverp.h>
//#include <ndisadd.h>  // Temporary
#include <md5.h>
#include <bpool.h>
#include <ppool.h>
#include <timer.h>
#include <debug.h>
#include <tdix.h>
#include <l2tp.h>
#include <l2tprfc.h>


//-----------------------------------------------------------------------------
// Constants
//-----------------------------------------------------------------------------

// The NDIS version we report when registering mini-port and address family.
//
#define NDIS_MajorVersion 5
#define NDIS_MinorVersion 0

// Size of an IPv4 header.  Because the RawIp driver returns the IP header on
// received datagrams, this must be added onto the allocated buffer size.  We
// assume there will be no rarely used IP-option fields on L2TP traffic.
//
// Note: Suggested to PradeepB that RawIp should strip the IP header, and he
//       is considering adding an open-address option.  This can be removed if
//       said option materializes.
//
#define IpFixedHeaderSize 20

// UDP header size
#define UDP_HEADER_SIZE 8
                  
// The maximum number of bytes in a frame including the largest L2TP payload
// header, plus the 32 bytes the OID_WAN_GET_INFO documentation says should be
// reserved internally for "bridging and additional protocols".  This value is
// used for receive buffer allocations internally.  The L2TP draft/RFC
// guarantees that control messages will fit in L2TP_MaxFrameSize, so a buffer
// of this size is capable of receiving either payload or control packets.
//
#define L2TP_FrameBufferSize (L2TP_MaxFrameSize + L2TP_MaxPayloadHeader + 32)

// The maximum number of bytes in an L2TP control or payload header.  This
// value is used for buffer allocations internally.
//
#define L2TP_HeaderBufferSize L2TP_MaxHeaderSize + IpFixedHeaderSize + UDP_HEADER_SIZE

// Reported speed of a LAN tunnel in bits/second.
//
#define L2TP_LanBps 10000000

// The vendor name passed to peer during tunnel creation.
//
#define L2TP_VendorName "Microsoft"

// The firmware/software revision passed to peer during tunnel creation.  The
// value indicates "NT 5.0".
//
#define L2TP_FirmwareRevision VER_PRODUCTVERSION_W
// The maximum length of an IP address string of the form "a.b.c.d".
//
#define L2TP_MaxDottedIpLen 15

// Milliseconds in a Hello timer interval.  Not to be confused with the Hello
// timeout which is generally much longer than this.  See '*Hello*' fields in
// the TUNNELCB.
//
#define L2TP_HelloIntervalMs 10000


//-----------------------------------------------------------------------------
// Data types
//-----------------------------------------------------------------------------

// Forward declarations.
//
typedef struct _VCCB VCCB;
typedef struct _INCALLSETUP INCALLSETUP;
typedef struct _TUNNELWORK TUNNELWORK;


// Adapter control block defining the state of a single L2TP mini-port
// adapter.  An adapter commonly supports multiple VPN devices.  Adapter
// blocks are allocated in MiniportInitialize and deallocated in MiniportHalt.
//
typedef struct
_ADAPTERCB
{
    // Set to MTAG_ADAPTERCB for easy identification in memory dumps and use
    // in assertions.
    //
    ULONG ulTag;

    // Reference count on this control block.  The reference pairs are:
    //
    // (a) A reference is added when the MiniportAdapterHandle field is set,
    //     i.e. when LmpInitialize succeeds and cleared when the LmpHalt
    //     handler is called.  The adapter block is actually passed to NDIS
    //     before it's known if LmpInitialize will succeed but according to
    //     ArvindM NDIS will not call halt unless it succeeds.
    //
    // (b) A reference is added when the NdisAfHandle field is set and removed
    //     when it is cleared.
    //
    // (c) A reference is added when the NdisSapHandle field is set and
    //     removed when it is cleared.
    //
    // (d) A reference is added for the VCCB's back pointer and removed when
    //     the VCCB is freed.
    //
    // (e) A reference is added for the TUNNELCB's back pointer and removed
    //     when the TUNNELCB is freed.
    //
    // (f) A reference is added when an NDIS_WORK_ITEM is scheduled and
    //     removed when it has completed.
    //
    // Access is via ReferenceAdapter and DereferenceAdapter only.
    //
    LONG lRef;

    // ACBF_* bit flags indicating various options.  Access restrictions are
    // indicated for each individual flag.  Many of these flags are set
    // permanently at initialization and so have no access limitation.
    //
    // ACBF_OutgoingRoleLac: Set when the driver is to assume the role of the
    //     L2TP Access Concentrator (LAC) as opposed to the L2TP Network
    //     Server (LNS) when making outgoing calls.  It would be simple to act
    //     either as LAC or LNS based on a CALL_PARAMETER field, if necessary,
    //     though this is not currently implemented.
    //
    // ACBF_IgnoreFramingMismatch: Set when a received framing type bit of
    //     "asynchronous" is to be ignored, rather than failing the
    //     negotiation.  This is a hedge against buggy peers as there are late
    //     draft changes to the order of the framing type bits.
    //
    // ACBF_ExclusiveTunnels: Set when an exclusive tunnel is to be created to
    //     the peer for each outgoing call even if another tunnel already
    //     exists to the peer.  This is a default and may be overridden in the
    //     L2TP specific call parameters.
    //
    // ACBF_SapActive: Set when the TDI open associated with the NdisSapHandle
    //     is successful and cleared when the corresponding TDI close is
    //     scheduled.  Access is protected by 'lockSap'.
    //
    ULONG ulFlags;
        #define ACBF_OutgoingRoleLac       0x00000001
        #define ACBF_IgnoreFramingMismatch 0x00000002
        #define ACBF_ExclusiveTunnels      0x00000004
        #define ACBF_SapActive             0x00000010

    // The maximum number of out-of-order packets that may be queued on any
    // tunnel or link.  The value is read from the registry.  The value 0
    // effectively disables out-of-order handling.
    //
    SHORT sMaxOutOfOrder;

    // The maximum receive window we send to peer during tunnel setup for the
    // control session.  The value is read from the registry.  The value 0
    // means the Receive Window Size AVP should not be sent, though for
    // control this just results in peer using a default of 4.
    //
    USHORT usControlReceiveWindow;

    // The maximum receive window we send to peer during call setup for the
    // payload session.  The value is read from the registry.  The value 0
    // means the Receive Window Size AVP should not be sent, which results in
    // no sequence/acknowledge numbers being used for calls we initiate.  Note
    // that on peer originatated calls where peer specifies a window, 0 will
    // result in the default of 4 being offered.
    //
    USHORT usPayloadReceiveWindow;

    // The Hello timeout in milliseconds, i.e. the time that must elapse from
    // the last incoming packet before a "Hello" message is sent to verify the
    // media is still up.  The value is read from the registry.  A value of 0
    // effectively disables the Hello mechanism.
    //
    ULONG ulHelloMs;

    // The maximum milliseconds to wait for an acknowledge after sending a
    // control or payload packet.  The value is read from the registry.
    //
    ULONG ulMaxSendTimeoutMs;

    // The initial milliseconds to wait for an acknowledge after sending a
    // control or payload packet.  The send timeout is adaptive, so this value
    // is the seed only.  The value is read from the registry.
    //
    ULONG ulInitialSendTimeoutMs;

    // The maximum milliseconds to wait for an outgoing packet on which to
    // piggyback an acknowledge before sending a zero data acknowledge.  If
    // the value is greater than 1/4 of the current send timeout, the former
    // is used, i.e. this is the "maximum adaptive maximum".
    //
    ULONG ulMaxAckDelayMs;

    // The maximum number of times a control packet is retransmitted before
    // the owning tunnel is reset.  The value is read from the registry.
    //
    ULONG ulMaxRetransmits;

    // The randomly unique tie-breaker AVP value sent with all SCCRQ messages.
    // This field is currently unused.  After due consideration, I have
    // decided not to send tie-breaker AVPs in our SCCRQs.  The mechanism is
    // way too complicated for a rare case.  If peer really doesn't want two
    // tunnels he will simply ignore ours and let it timeout and fail anyway.
    // This is a minor, and I believe harmless, incompliance with the
    // draft/RFC.  My guess is that others will reach this same conclusion and
    // not send tie-breakers either.
    //
    CHAR achTieBreaker[ 8 ];

    // The password shared with peer for tunnel identification.  The value is
    // read from the registry.  Currently, only a single password for all
    // peers is used, though a password indexed by 'hostname' will likely be
    // added in the future.
    //
    CHAR* pszPassword;

    // The driver description read from the registry.  The value is used as
    // the L2TP line name when reporting up capabilities.
    //
    WCHAR* pszDriverDesc;

    // Our framing and bearer capablities bit masks as passed in SCCRQ.
    //
    ULONG ulFramingCaps;
    ULONG ulBearerCaps;

    // The string sent as the host name, or NULL if none.  The value is read
    // from the registry.
    //
    CHAR* pszHostName;

    // The next progressively increasing reference number likely to be unique
    // for all interconnected LACs/LNSs for a significant period of time.  It
    // is for use by administrators on either end of the tunnel to use when
    // investigating call failure problems.  Access is via Interlocked
    // routines.
    //
    ULONG ulCallSerialNumber;


    // VC TABLE --------------------------------------------------------------

    // The array of VC control block addresses allocated during adapter
    // initialization.  The VC control blocks themselves are created and hung
    // off this table dynamically.  Our Call-ID context returned to us by peer
    // in each L2TP packet is a 1-based index into this table.  (The 0 Call-ID
    // is reserved by L2TP to mean "not call specific").
    //
    // If an element is NULL, it means the Call-ID is not in use.  If an
    // element is -1, it means the Call-ID has been reserved, but messages
    // with the Call-ID are not yet acceptable.  Any other value is the
    // address of a VCCB for which messages can be accepted.  'VCCB.pTunnel'
    // is guaranteed valid while a VCCB is in the array.
    //
    // Access to the array is protected by 'lockVcs'.
    //
    VCCB** ppVcs;

    // The number of elements in the 'ppVcs' array.  This corresponds to the
    // number of configured VPN devices read from the registry during
    // initialization.
    //
    USHORT usMaxVcs;

    // Number of slots in 'usMaxVcs' that are available, i.e. NULL.  Access is
    // protected by 'lockVcs'
    //
    LONG lAvailableVcSlots;

    // Lock protecting the VC table, "available" counter, and 'listVcs'.
    //
    NDIS_SPIN_LOCK lockVcs;

    // The next Call-ID above 'usMaxVcs' for use only in terminating a call
    // gracefully.  Access is by the GetNextTerminationCallId routine only.
    //
    USHORT usNextTerminationCallId;


    // TUNNEL CHAIN ----------------------------------------------------------

    // Head of a double-linked list of active TUNNELCBs.  At no time will two
    // tunnels in the list have the same 'TUNNELCB.usTunnelId' or same
    // 'TUNNELCB.ulIpAddress'/'TUNNELCB.usAssignedTunnelId' pair.  Access to
    // the list links is protected by 'lockTunnels'.
    //
    LIST_ENTRY listTunnels;
    NDIS_SPIN_LOCK lockTunnels;

    // The tunnel identifier to assign to the next tunnel created.  Only the
    // GetNextTunnelId routine should access this field.
    //
    USHORT usNextTunnelId;


    // TDI -------------------------------------------------------------------

    // TDI extension context containing TDI state information for the adapter.
    // Access is via Tdix* interface routines, which handle all locking
    // internally.
    //
    TDIXCONTEXT tdix;


    // NDIS BOOKKEEPING ------------------------------------------------------

    // NDIS's handle for this mini-port adapter passed to us in
    // MiniportInitialize.  This is passed back to various NdisXxx calls.
    //
    NDIS_HANDLE MiniportAdapterHandle;

    // NDIS's handle for our SAP as passed to our CmRegisterSapHandler or NULL
    // if none.  Only one SAP handle is supported because (a) the TAPI proxy's
    // is expected to be the only one, and (b) there are no L2TP SAP
    // properties that would ever lead us to direct a call to a second SAP
    // anyway.  Any client's attempt to register a second SAP will fail.  A
    // value of NULL indicates no SAP handle is currently registered.  Writers
    // must hold 'lockSap'.  Readers must hold 'lockSap' or a SAP reference.
    //
    NDIS_HANDLE NdisSapHandle;

    // Line and address IDs assigned by NDIS to the active SAP.
    //
    ULONG ulSapLineId;
    ULONG ulSapAddressId;

    // NDIS's handle for our Address Family as passed to our CmOpenAfHandler
    // or NULL if none.  Only one is supported.  See NdisSapHandle above.
    // Access is via Interlocked routines.
    //
    NDIS_HANDLE NdisAfHandle;

    // This adapter's capabilities as returned to callers on
    // OID_WAN_CO_GET_INFO.  These capabilities are also used as defaults for
    // the corresponding VCCB.linkinfo settings during MiniportCoCreateVc.
    //
    NDIS_WAN_CO_INFO info;

    // Reference count on the NdisAfHandle.  The reference pairs are:
    //
    // (a) A reference is added when the address family is opened and removed
    //     when it is closed.
    //
    // (b) A reference is added when a SAP is registered on the address family
    //     and removed when it is deregistered.
    //
    // (c) A reference is added when a VC is created on the address family and
    //     removed when it is deleted.
    //
    // Access is via ReferenceAf and DereferenceAf only.
    //
    LONG lAfRef;

    // Reference count on the NdisSapHandle.  The reference pairs are:
    //
    // (a) A reference is added when the SAP is registered and removed when it
    //     is de-registered.
    //
    // (b) A reference is added and immediately removed in FsmTunnelIdle to
    //     test for an active SAP in order to immediately reject requested
    //     tunnels when no SAP is active.
    //
    // (c) A reference is added when before calling
    //     NdisMCmDispatchIncomingCall and removed when the call returns.
    //
    // Access is via ReferenceSap and DereferenceSap only, excepting initial
    // reference by RegisterSapPassive.  Access is protected by 'lockSap'.
    //
    LONG lSapRef;

    // This lock protects the 'lSapRef' and 'NdisSapHandle' fields.
    //
    NDIS_SPIN_LOCK lockSap;


    // RESOURCE POOLS --------------------------------------------------------

    // Count of initialized but not yet completed timers.  We cannot allow a
    // Halt to complete until this goes to 0, because if we did our driver
    // could be unloaded with running timers in our memory which results in a
    // bugcheck.
    //
    ULONG ulTimers;

    // Pool of full frame buffers with pre-attached NDIS_BUFFER descriptors.
    // The pool is accessed via the interface defined in bpool.h, which
    // handles all locking internally.
    //
    BUFFERPOOL poolFrameBuffers;

    // Pool of L2TP header buffers with pre-attached NDIS_BUFFER descriptors.
    // The pool is accessed via the interface defined in bpool.h, which
    // handles all locking internally.
    //
    BUFFERPOOL poolHeaderBuffers;

    // Pool of NDIS_PACKET descriptors used in indication of received frames.
    // The pool is accessed via the interface defined in ppool.h, which
    // handles all locking internally.
    //
    PACKETPOOL poolPackets;

    // Lookaside list of NDIS_WORK_ITEM scheduling descriptors with extra
    // context space used by all tunnels and VCs attached to the adapter.
    //
    NPAGED_LOOKASIDE_LIST llistWorkItems;

    // Lookaside list of TIMERQITEM timer event descriptors used by all
    // tunnels and VCs attached to the adapter.
    //
    NPAGED_LOOKASIDE_LIST llistTimerQItems;

    // Lookaside list of CONTROLSENT sent control packet contexts used by all
    // tunnels attached to the adapter.
    //
    NPAGED_LOOKASIDE_LIST llistControlSents;

    // Lookaside list of PAYLOADLSENT sent payload packet contexts used by all
    // VCs attached to the adapter.
    //
    NPAGED_LOOKASIDE_LIST llistPayloadSents;

    // Lookaside list of TUNNELWORK incoming VC setup contexts used for all
    // tunnels attached to the adapter.
    //
    NPAGED_LOOKASIDE_LIST llistTunnelWorks;

    // Lookaside list of CONTROLMSGINFO contexts used for all tunnels and VCs
    // attached to the adapter.
    //
    NPAGED_LOOKASIDE_LIST llistControlMsgInfos;

#if LLISTALL
    // Lookaside list of TUNNELCBs from which the 'listTunnels' control blocks
    // are allocated.
    //
    NPAGED_LOOKASIDE_LIST llistTunnels;

    // Lookaside list of VCCBs from which the control blocks dynamically
    // attached to '*ppVcs' are allocated.
    //
    NPAGED_LOOKASIDE_LIST llistVcs;

    // Lookaside list of TIMERQ descriptors used by all tunnels attached to
    // the adapter.
    //
    NPAGED_LOOKASIDE_LIST llistTimerQs;

    // Lookaside list of CONTROLRECEIVED received control packet contexts used
    // by all tunnels attached to the adapter.
    //
    NPAGED_LOOKASIDE_LIST llistControlReceiveds;

    // Lookaside list of PAYLOADRECEIVED received payload packet contexts used
    // by all VCs attached to the adapter.
    //
    NPAGED_LOOKASIDE_LIST llistPayloadReceiveds;

    // Lookaside list of CALLSETUP incoming VC setup contexts used for all
    // incoming VCs attached to the adapter.
    //
    NPAGED_LOOKASIDE_LIST llistInCallSetups;
#endif
}
ADAPTERCB;


// Tunnel control block, describing the state of an L2TP tunnel, i.e. an L2TP
// control channel session to another L2TP LNS or LAC.  Each tunnel may have
// zero or more VCs associated with it.  Tunnel control blocks are allocated
// from 'ADAPTERCB.llistTunnels' in CmMakeCall and ReceiveControl.  Blocks are
// deallocated when the last reference is removed, e.g. when the control
// connection FSM terminates the tunnel.
//
typedef struct
_TUNNELCB
{
    // Links to the prev/next TUNNELCB in the owning adapter's tunnel list.
    // Access to the list links is protected by 'ADAPTERCB.lockTunnels'.
    //
    LIST_ENTRY linkTunnels;

    // Set to MTAG_TUNNELCB for easy identification in memory dumps and use in
    // assertions.
    //
    ULONG ulTag;

    // Reference count on this control block.  The reference pairs are:
    //
    // (a) A reference is added when a call on a VCCB is active or becoming
    //     active and removed when it is deactivated, i.e. during the period
    //     the VCCB is on 'listVcs'.  This covers the back pointer in the
    //     VCCB.
    //
    // (b) A reference is added when peer initiates a tunnel and removed when
    //     the tunnel transitions to idle state.  This keeps peer-initiated
    //     tunnels from terminating when there are no no calls, since by
    //     convention, it is peer who closes the tunnel in that case.
    //
    // (c) A reference is added when a graceful tunnel close is initiated and
    //     removed when the tunnel transitions to idle state.
    //
    // (d) A reference is added when the delayed control acknowledge timer is
    //     scheduled and removed by the timer event handler.
    //
    // (e) LookUpTunnelAndVcCbs adds a reference that is removed at the end of
    //     the L2tpReceive handler.  This covers the receive path.
    //
    // (f) A reference is added when a CONTROLSENT context is assigned a
    //     tunnel back pointer and removed when the context is freed.
    //
    // (g) A reference is added when a PAYLOADSENT context is assigned a
    //     tunnel back pointer and removed when the context is freed.
    //
    // (h) ScheduleTunnelWork adds a reference that is removed by TunnelWork
    //     after executing the work.  This covers the tunnel pointer passed as
    //     a context to NdisScheduleWorkItem.
    //
    // Access is via ReferenceTunnel and DereferenceTunnel only which use
    // 'ADAPTERCB.lockTunnels' for protection.
    //
    LONG lRef;

    // Back pointer to owning adapter's control block.
    //
    ADAPTERCB* pAdapter;

    // This lock protects TUNNELCB send, receive, and state fields as noted in
    // other field descriptions.
    //
    NDIS_SPIN_LOCK lockT;


    // TUNNEL SETUP ----------------------------------------------------------

    // IP address and UDP port of the remote end of the tunnel in network byte
    // order.  The IP address is pulled from the call parameters passed to
    // CmMakeCall.  It is updated with the last source IP address received
    // from a peer passing this tunnel's ID, per the L2TP draft/RFC section
    // 8.1 on "L2TP over IP/UDP media".  However, it is assumed that the
    // updated source address will not match the address of another existing
    // tunnel.  The UDP port (not used in raw IP mode) is initially the well
    // known L2TP port (1701).  It is updated with the last source UDP port
    // received from peer on this tunnel.  Access is protected by
    // 'pAdapter->lockTunnels'.
    //
    TDIXIPADDRESS address;

    // IP address and ifindex of my end of the tunnel in network byte
    // used to get the media speed and build IP header
    TDIXIPADDRESS localaddress;

    TDIXUDPCONNECTCONTEXT udpContext;

    // "Connection" cookie returned by TdixAddHostRoute.  This may be passed
    // to TdixSendDatagram to send on the connected channel (used for sent
    // payloads) as opposed to the unconnected channel (used for receives and
    // sent controls).  The address is invalid after TdixDeleteHostRoute is
    // called.
    //
    TDIXROUTE* pRoute;

    // Our unique tunnel identifier sent back to us by peer in the L2TP
    // header.  The value is chosen, using GetNextTunnelId, from a sequential
    // counter in ADAPTERCB and has no further meaning.
    //
    USHORT usTunnelId;

    // The tunnel identifier chosen by peer that we send back to him in the
    // L2TP header Tunnel-ID field for all packets on this tunnel.  A value of
    // 0 indicates no ID has been assigned.
    //
    USHORT usAssignedTunnelId;

    // TCBF_* bit flags indicating various options and states.  Access is via
    // the interlocked ReadFlags/SetFlags/ClearFlags routines only.
    //
    // TCBF_TdixReferenced: Set when the tunnel has referenced the adapter's
    //     TDI extension context by successfully calling TdixOpen.
    //     DereferenceTunnel uses this to automatically dereference the
    //     context when the tunnel is dereferenced.
    //
    // TCBF_CcInTransition: Set when the control connection FSM has begun but
    //     not finished a sequence of state changes that will end up in either
    //     Idle or Established state.  When this flag is set new requests to
    //     bring the tunnel up or down are queued on 'listRequestingVcs' for
    //     re-execution when a result is known.  Access to the bit is
    //     protected by 'lockT'.
    //
    // TCBF_PeerInitiated: Set when the tunnel was initiated by the peer,
    //     rather than a local request.  If all calls are dropped and this bit
    //     is not set, we close the tunnel gracefully.
    //
    // TCBF_PeerInitRef: Set when a reference for peer initation is taken on
    //     the tunnel and cleared when the reference is removed.
    //
    // TCBF_HostRouteAdded: Set when the host route is successfully added and
    //     referenced and removed when it is dereferenced.
    //
    // TCBF_HostRouteChanged: Set when a host route changed has been attempted
    //     on the tunnel, and never cleared.
    //
    // TCBF_PeerNotResponding: Set when the tunnel is closed due to lack of
    //     response from peer, i.e. after all retries have been exhausted.
    //
    // TCBF_Closing: Set as soon as the tunnel is known to be transitioning to
    //     idle state.  Access is protected by 'lockT'.
    //
    // TCBF_FsmCloseRef: Set when a graceful closing exchange is initiated by
    //     FsmClose and cleared when the tunnel reaches idle state.
    //
    // TCBF_InWork: Set when an APC is scheduled to execute work from the
    //     'listWork' queue.  Access is protected by 'lockWork'.
    //
    ULONG ulFlags;
        #define TCBF_TdixReferenced    0x00000001
        #define TCBF_CcInTransition    0x00000002
        #define TCBF_PeerInitiated     0x00000004
        #define TCBF_PeerInitRef       0x00000008
        #define TCBF_HostRouteAdded    0x00000010
        #define TCBF_PeerNotResponding 0x00000020
        #define TCBF_HostRouteChanged  0x00000040
        #define TCBF_Closing           0x00000100
        #define TCBF_FsmCloseRef       0x00000200
        #define TCBF_InWork            0x00001000
        #define TCBF_SendConnected     0x00002000
        #define TCBF_LocalAddrSet      0x00004000

    // The current state of the tunnel's control connection creation FSM.  See
    // also 'VCCB.state'.
    //
    // Only one tunnel creation session may be underway even if CmMakeCall has
    // been called on multiple VCs over this tunnel.  For this reason,
    // transitions to/from the Idle or Established states must be protected by
    // 'lockT'.  See also TCBF_CcInTransition flag and 'listRequestingVcs'.
    //
    // The protocol sorts out the case of simultaneous originate and receive
    // requests ensuring that one gets dropped before it reaches Established
    // state when either provides a tie-breaker.  We always provide a
    // tie-breaker for IP media.  For QOS-enabled medias where one control
    // channel per call makes sense and no tie-breakers are passed, a lower
    // level VC ID will be used to distinguish tunnel control blocks on
    // receive.  So, a single TUNNELCB will never have both originated and
    // received control channels in Established state.
    //
    L2TPCCSTATE state;

    // Double-linked queue of all VCCBs waiting for the tunnel to open.  New
    // VCs must not be linked on closing tunnels, i.e. those with the
    // TCBF_Closing flag set.  Access is protected by 'lockT'.
    //
    LIST_ENTRY listRequestingVcs;

    // Double-linked queue of VCCBs whose VCBF_XxxPending operation has
    // completed.  'VCCB.status' is the status that will be indicated.  This
    // mechanism is necessary to avoid the spin-lock issues that results when
    // one tries to call NDIS completion APIs from the bowels of the FSMs.
    //
    LIST_ENTRY listCompletingVcs;
    
    // Peer's framing and bearer capablities.
    //
    ULONG ulFramingCaps;
    ULONG ulBearerCaps;

    // The challenge and challenge response sent to peer.  These are in the
    // control block for convenience, as they must be passed thru the work
    // scheduling mechanism and don't fit easily into the generic arguments.
    //
    CHAR achChallengeToSend[ 16 ];
    CHAR achResponseToSend[ 16 ];


    // SEND STATE ------------------------------------------------------------

    // Next Sent, the sequence number of next control packet transmitted on
    // this tunnel.  The field is initialized to 0 and incremented after
    // assignment to an outgoing packet, excepting retransmissions.  Access is
    // protected by 'lockT'.
    //
    USHORT usNs;

    // Double-linked list of outstanding sends, i.e. CONTROLSENTs sorted by
    // the 'usNs' field with lower values near the head.  The list contains
    // all active unacknowledged CONTROLSENT contexts, even those that may be
    // waiting for their first transmission.  Access is protected by 'lockT'.
    //
    LIST_ENTRY listSendsOut;

    // The number of control packets sent but not acknowledged or timed out.
    // Access is protected by 'lockT'.
    //
    ULONG ulSendsOut;

    // The number of sent but unacknowledged packets that may be outstanding.
    // This value is adjusted dynamically.  Per the draft/RFC, when
    // 'ulAcksSinceSendTimeout' reaches the current setting, the window is
    // increased by one.  When a send timeout expires the window is reduced by
    // half.  Access is protected by 'lockT'.
    //
    ULONG ulSendWindow;

    // The maximum value of 'ulSendWindow'.  Peer chooses this value during
    // call setup by offering a receive window.
    //
    ULONG ulMaxSendWindow;

    // The number of packets acknowledged since the last timeout.  The value
    // is reset when a timeout occurs or the send window is adjusted upward.
    // See 'ulSendWindow'.  Access is protected by 'lockT'.
    //
    ULONG ulAcksSinceSendTimeout;

    // The estimated round trip time in milliseconds.  This is the RTT value
    // from Appendix A of the draft/RFC.  The value is adjusted as each
    // acknowledge is received.  It is initialized to the Packet Processing
    // Delay reported by peer.  See 'ulSendTimeoutMs'.  Access is protected by
    // 'lockT'.
    //
    ULONG ulRoundTripMs;

    // The estimated mean deviation in milliseconds, an approximation of the
    // standard deviation.  This is the DEV value from Appendix A of the
    // draft/RFC.  The value is adjusted as each acknowledge is received.  It
    // is initially 0.  See 'ulSendTimeoutMs'.  Access is protected by
    // 'lockT'.
    //
    LONG lDeviationMs;

    // Milliseconds before it is assumed a sent packet will not be
    // acknowledged and needs to be retransmitted.  This is the ATO value from
    // Appendix A of the draft/RFC.  This value is adjusted as each
    // acknowledge is received, with a maximum of
    // 'ADAPTERCB.ulMaxSendTimeoutMs'.  Access is protected by 'lockT'.
    //
    ULONG ulSendTimeoutMs;

    // The timer event descriptor scheduled to occur when it is time to stop
    // waiting for an outgoing send on which to piggyback an acknowledge.
    // This will be NULL when no delayed acknowledge is pending.  Per the
    // draft/RFC, the timeout used is 1/4 of the 'ulSendTimeoutMs'.  Access is
    // protected by 'lockT'.
    //
    TIMERQITEM* pTqiDelayedAck;

    // The timer event descriptor which expires when it's time to check for
    // lack of any incoming packets.  To reduce the cost of constantly
    // resetting a Hello timer with a full timeout (which with unsequenced
    // payloads usually results in an NdisCancelTimer/NdisSetTimer on each
    // received packet), the timeout is broken into intervals of
    // L2TP_HelloIntervalMs.  If it expires and both 'ulRemainingHelloMs' and
    // 'ulHelloResetsThisInterval' are 0, a "Hello" message is sent to the
    // peer to verify that the media is still up.  Access to this field is
    // protected by 'lockT'.
    //
    TIMERQITEM* pTqiHello;

    // The milliseconds left to wait in all remaining Hello intervals and the
    // number of resets since the last Hello interval timeout.
    //
    ULONG ulRemainingHelloMs;
    ULONG ulHelloResetsThisInterval;
    
    // RECEIVE STATE ---------------------------------------------------------

    // Next Received, the sequence number one higher than that of the last
    // control packet received on this tunnel or 0 if none.  Access is
    // protected by 'lockT'.
    //
    USHORT usNr;

    // Double-linked list of out-of-order receives, i.e. CONTROLRECEIVEs
    // sorted by the 'usNs' field with lower values near the head.  The
    // maximum queue length is 'ADAPTERCB.sMaxOutOfOrder'.  Access is
    // protected by 'lockT'.
    //
    LIST_ENTRY listOutOfOrder;


    // TIMER QUEUE -----------------------------------------------------------

    // Timer queue for both the control and data channels.  The timer queue is
    // accessed via the interface defined in timer.h, which handles all
    // locking internally.
    //
    TIMERQ* pTimerQ;


    // WORK QUEUE ------------------------------------------------------------

    // Double-linked list NDIS_WORK_ITEMs queued for serialized execution at
    // PASSIVE IRQL.  The next item to be executed is at the head of the list.
    // Access is protected via the ScheduleTunnelWork routine, which protects
    // the list with 'lockWork'.  See also TCBF_InWork.
    //
    LIST_ENTRY listWork;
    NDIS_SPIN_LOCK lockWork;


    // VC CHAIN --------------------------------------------------------------

    // Head of a double-linked list of VCCBs associated with the tunnel, i.e.
    // with calls active or in the process of becoming active.  New VCs must
    // not be linked on closing tunnels, i.e. those with the TCBF_Closing flag
    // set.  Access to the links is protected by 'lockVcs'.
    //
    LIST_ENTRY listVcs;
    NDIS_SPIN_LOCK lockVcs;

    // media speed
    ULONG ulMediaSpeed;
}
TUNNELCB;


// Call statistics block.
//
typedef struct
_CALLSTATS
{
    // System time call reached established state.  When the block is being
    // used for cumulative statistics of multiple calls, this is the number of
    // calls instead.
    //
    LONGLONG llCallUp;

    // Duration in seconds of now idle call.
    //
    ULONG ulSeconds;

    // Total data bytes received and sent.
    //
    ULONG ulDataBytesRecd;
    ULONG ulDataBytesSent;

    // Number of received packets indicated up.
    //
    ULONG ulRecdDataPackets;

    // Number of received packets linked on the out-of-order queue before
    // being indicated up.
    //
    ULONG ulDataPacketsDequeued;

    // Number of received packets of zero length.  Includes packets with the
    // R-bit set.
    //
    ULONG ulRecdZlbs;

    // Number of received packets with R-bit set.
    //
    ULONG ulRecdResets;

    // Number of received packets with R-bit set that are out of date.
    //
    ULONG ulRecdResetsIgnored;

    // Number of data packets sent with and without sequence numbers.  The sum
    // of the two is the total data packets sent.
    //
    ULONG ulSentDataPacketsSeq;
    ULONG ulSentDataPacketsUnSeq;

    // Number of packets sent that were acknowledged and timed out.  If the
    // call is cancelled with packets outstanding the sum of the two may be
    // less than 'ulSentDataPacketsSeq'.
    //
    ULONG ulSentPacketsAcked;
    ULONG ulSentPacketsTimedOut;

    // Number of zero length acknowledges sent.
    //
    ULONG ulSentZAcks;

    // Number of packets sent with the R-bit set.
    //
    ULONG ulSentResets;

    // Number of times the send window was changed.
    //
    ULONG ulSendWindowChanges;

    // Total of all send window sizes, one for each 'ulSentDataPacketsSeq'.
    //
    ULONG ulSendWindowTotal;

    // Largest send window.
    //
    ULONG ulMaxSendWindow;

    // Smallest send window.
    //
    ULONG ulMinSendWindow;

    // Number of sample round trips.  (sequenced packets only)
    //
    ULONG ulRoundTrips;

    // Total of all round trips in milliseconds.  (sequenced packets only)
    //
    ULONG ulRoundTripMsTotal;

    // Longest round trip,  (sequenced packets only)
    //
    ULONG ulMaxRoundTripMs;

    // Shortest round trip.  (sequenced packets only)
    //
    ULONG ulMinRoundTripMs;
}
CALLSTATS;


// Virtual circuit control block defining the state of a single L2TP VC, i.e.
// one line device endpoint and the call, if any, active on it.  A VC is never
// used for incoming and outgoing calls simultaneously.  A single NDIS VC maps
// to one of these.
//
typedef struct
_VCCB
{
    // Links to the prev/next VCCB in the owning tunnel's active VC list.
    // Access is protected by 'TUNNELCB.lockVcs'.
    //
    LIST_ENTRY linkVcs;

    // Set to MTAG_VCCB for easy identification in memory dumps and use in
    // assertions.
    //
    ULONG ulTag;

    // Reference count on this VC control block.  The reference pairs are:
    //
    // (a) LmpCoCreateVc adds a reference that is removed by LmpCoDeleteVc.
    //     This covers all clients that learn of the VCCB via NDIS.
    //
    // (b) LookUpTunnelAndVcCbs adds a reference that is removed at the end of
    //     the L2tpReceive handler.  This covers the receive path.
    //
    // (c) A reference is added when a CONTROLSENT context with 'pVc'
    //     referring to this VCCB is assigned the back pointer and removed
    //     when the context is freed.
    //
    // (d) A reference is added when a PAYLOADSENT context with 'pVc'
    //     referring to this VCCB is assigned the back pointer and removed
    //     when the context is freed.
    //
    // (e) ScheduleTunnelWork adds a reference that is removed by TunnelWork
    //     after executing the work.
    //
    // (f) A reference is added before scheduling the delayed payload
    //     acknowledge timer and removed in the timer event handler.
    //
    // (g) A reference is taken by CompleteVcs covering use of the VC popped
    //     from the tunnel's completing list, and released after use.
    //
    // (h) A reference is taken prior to calling NdisMCmDispatchIncomingCall
    //     and removed by the completion handler.
    //
    // (i) A reference is added when a CONTROLRECEIVED context with 'pVc'
    //     referring to this VCCB is assigned the back pointer and removed
    //     when the context is freed.
    //
    // The field is accessed only by the ReferenceVc and DereferenceVc
    // routines, which protect with Interlocked routines.
    //
    LONG lRef;

    // Back pointer to owning adapter's control block.
    //
    ADAPTERCB* pAdapter;

    // Back pointer to owning tunnel's control block or NULL if none.
    // Guaranteed valid whenever the VC is linked into a tunnel's 'listVcs',
    // i.e. when it holds a reference on the tunnel.  It is safe to use this
    // if you hold a reference on the call.  Otherwise, it is not.  Be very
    // careful here.
    //
    TUNNELCB* pTunnel;

    // This lock protects VCCB payload send and receive paths as noted in
    // other field descriptions.  In cases where both 'lockV' and
    // 'pTunnel->lockT' are required 'lockT' must be obtained first.
    //
    NDIS_SPIN_LOCK lockV;


    // CALL SETUP ------------------------------------------------------------

    // Our unique call identifier sent back to us by peer in the L2TP header.
    // The value is a 1-based index into the 'ADAPTERCB.ppVcs' array.
    //
    USHORT usCallId;

    // The call identifier, chosen by peer, that we send back to him in the
    // L2TP header Call-ID field for all packets on this call.  A value of 0
    // indicates no Call-ID has been assigned.
    //
    USHORT usAssignedCallId;

    // VCBF_* bit flags indicating various options and states.  Access is via
    // the interlocked ReadFlags/SetFlags/ClearFlags routines.
    //
    // VCBF_IndicateReceivedTime: Set if MakeCall caller sets the
    //     MediaParameters.Flags RECEIVE_TIME_INDICATION flag requesting the
    //     TimeReceived field of the NDIS packet be filled with a timestamp.
    //
    // VCBF_CallClosableByClient: Set when a call is in a state where
    //     LcmCmCloseCall requests to initiate clean-up should be accepted.
    //     This may be set when VCBF_CallClosableByPeer is not, which means we
    //     have indicated an incoming close to client and are waiting for him
    //     to do a client close in response (in that weird CoNDIS way).  The
    //     flag is protected by 'lockV'.
    //
    // VCBF_CallClosableByPeer: Set when the call is in a state where an idle
    //     transition without operations pending should be mapped to a
    //     PeerClose event.  This will never be set when
    //     VCBF_CallClosableByClient is not.  The flag is protected by
    //     'lockV'.
    //
    // VCBF_DefaultLcParams: Set when the 'pLcParams' field was allocated by
    //     us rather than being owned by client.
    //
    // VCBF_IncomingFsm: Set when the VC is executing the Incoming Call FSM
    //     rather than Outgoing Call FSM in the active incoming/outgoing call.
    //     For client initiated calls this will set if the adapter's
    //     ACBF_OutgoingRoleLac flag, read from the registry, is set.
    //
    // VCBF_PeerInitiatedCall: Set when an the active call was initiated by
    //     the peer, clear if it was initiated by the client.
    //
    // VCBF_Sequencing: Set unless no Receive Window AVP is provided/received
    //     during call setup, resulting in "no sequencing" mode where Ns/Nr
    //     fields are not sent in the payload header.  This also effectively
    //     disables out-of-order processing.
    //
    // VCBF_VcCreated: Set when the VC has been created successfully.  This is
    //     the "creation" that occurs with the client, not the mini-port.
    // VCBF_VcActivated: Set when the VC has been activated successfully.
    // VCBF_VcDispatched: Set when the VC has dispatched an incoming call to
    //     the client and client has returned success or pended.
    // VCBM_VcState: Bit mask including each of the above 3 NDIS state flags.
    //
    // VCBF_VcDeleted: Set when the DeleteVC handler has been called on this
    //     VC.  This guards against NDPROXY double-deleting VCs which it has
    //     been known to do.
    //
    // The pending bits below are mutually exclusive (except ClientClose which
    // may occur after but simultaneous with ClientOpen), and so require lock
    // protection by 'lockV':
    //
    // VCBF_PeerOpenPending: Set when peer attempts to establish a call, and
    //     the result is not yet known.
    // VCBF_ClientOpenPending: Set when client attempts to establish a call,
    //     and the result is not yet known.
    // VCBF_PeerClosePending: Set when peer attempts to close an established
    //     call and the result is not yet known.  Access is protected by
    //     'lockV'.
    // VCBF_ClientClosePending: Set when client attempts to close an
    //     established call and the result is not yet known.  Access is
    //     protected by 'lockV'.
    // VCBM_Pending: Bit mask that includes each of the 4 pending flags.
    //
    // VCBF_ClientCloseCompletion: Set when client close completion is in
    //     progress.
    //
    // VCBF_IcsAlloc: Set when the 'pInCall' block has been locked for
    //     allocation and cleared when the call is torn down.  Accessed only
    //     by the LockIcs/UnlockIcs routines.
    // VCBF_IcsGrace: Set when the 'pInCall' pointer has been locked for a
    //     grace period during which the response to the incoming call message
    //     is sent.  Accessed only by the LockIcs/UnlockIcs routines.
    //
    // VCBF_WaitInCallComplete: Set when the client is expected to call our
    //     call manager's IncomingCallComplete handler.  This guards against
    //     NDPROXY double completing calls which it has been known to do.
    // VCBF_WaitCloseCall: Set when the client is expected to call our call
    //     manager's CloseCall handler.  This is strictly a debug aid.
    //
    // VCBF_CompPending: Set when this VC is put on tunnel's listCompletingVcs list
    //
    ULONG ulFlags;
        #define VCBF_IndicateTimeReceived  0x00000001
        #define VCBF_CallClosableByClient  0x00000002
        #define VCBF_CallClosableByPeer    0x00000004
        #define VCBF_DefaultLcParams       0x00000008
        #define VCBF_IncomingFsm           0x00000010
        #define VCBF_PeerInitiatedCall     0x00000020
        #define VCBF_Sequencing            0x00000040
        #define VCBF_VcCreated             0x00000100
        #define VCBF_VcActivated           0x00000200
        #define VCBF_VcDispatched          0x00000400
        #define VCBM_VcState               0x00000700
        #define VCBF_PeerOpenPending       0x00001000
        #define VCBF_ClientOpenPending     0x00002000
        #define VCBF_PeerClosePending      0x00004000
        #define VCBF_ClientClosePending    0x00008000
        #define VCBM_Pending               0x0000F000
        #define VCBF_VcDeleted             0x00010000
        #define VCBF_ClientCloseCompletion 0x00020000
        #define VCBF_IcsAlloc              0x00040000
        #define VCBF_IcsGrace              0x00080000
        #define VCBF_WaitInCallComplete    0x00100000
        #define VCBF_WaitCloseCall         0x00200000
        #define VCBF_CompPending           0x01000000
        

    // Reference count on the active call.  Fields in this CALL SETUP section
    // and in the CALL STATISTICS section should not be accessed without a
    // call reference while the VC is activated.  References may only be added
    // when the VCCB_VcActivated flag is set, and this is enforced by
    // ReferenceCall.  The reference pairs are:
    //
    // (a) A reference is added when a VC is activated and removed when it is
    //     de-activated.
    //
    // (b) A reference is added when the send handler accepts a packet.  For
    //     unsequenced sends the reference is removed by the send complete
    //     routine.  For sequenced sends it it removed when the PAYLOADSENT
    //     context is destroyed.
    //
    // (c) A reference is added before scheduling a ZLB send and removed by
    //     the send completion routine.
    //
    // (d) A reference is added before entering ReceivePayload and removed on
    //     exit from same.
    //
    // (e) A reference is added before dispatching the call that is removed
    //     when the dispatch is completed.
    //
    // The field is accessed only by the ReferenceCall and DereferenceCall
    // routines, which protect the field with 'lockCall'.
    //
    LONG lCallRef;
    NDIS_SPIN_LOCK lockCall;

    // The current state of the VCs call creation, i.e. the control channel's
    // data channel setup for this VC.  Access is protected by 'lockV' once
    // the VC is set up to receive call control messages.
    //
    L2TPCALLSTATE state;

    // Links to the prev/next VCCB in the owning tunnel's requesting VC list
    // VC list.  Access is protected by 'TUNNELCB.lockT'.
    //
    LIST_ENTRY linkRequestingVcs;

    // Links to the prev/next VCCB in the owning tunnel's completing VC list.
    // Access is protected by 'TUNNELCB.lockT'.
    //
    LIST_ENTRY linkCompletingVcs;

    // This is set to the pending peer open/close or client open operation
    // result to be reported to client.
    //
    NDIS_STATUS status;

    // The received call setup message context.  When peer initiates a call,
    // we must create a VC and dispatch the incoming call to the client above.
    // This is an asynchronous operation that must occur right in the middle
    // of receive processing.  This context stores information about the
    // received message so it can be processed when it is known if client will
    // accept the call.  It also includes the CO_CALL_PARAMETERS buffer
    // dispatched to client on incoming calls.  The field is valid only until
    // LcmCmIncomingCallComplete handler is called, at which time it is set to
    // NULL.
    //
    // Shortcut addresses of the TAPI call info passed up in the
    // NdisMCmDispatchIncomingCall.  Obviously, they are valid only when
    // 'pInCall' is valid.  When invalid they are set to NULL.
    //
    INCALLSETUP* pInCall;
    CO_AF_TAPI_INCOMING_CALL_PARAMETERS UNALIGNED * pTiParams;
    LINE_CALL_INFO* pTcInfo;

    // Reference count on the 'pInCall' context.  The reference pairs are:
    //
    // (a) A reference is added when the context is allocated and removed
    //     by CallSetupComplete.
    //
    // (b) A reference is added before passing addresses within the context to
    //     ReceiveControlExpected and removed after that routine returns.
    //
    // The field is accessed only by the ReferenceIcs and DereferenceIcs
    // routines, which protect with Interlocked routines.  An exception is
    // initializion to 1 by SetupVcAsynchronously.
    //
    LONG lInCallRef;

    // Address of the call parameters passed down in CmMakeCall.  This field
    // will only be valid until the NdisMCmMakeCallComplete notification for
    // the associated call is made, at which time it is reset to NULL.  Access
    // is via Interlocked routines.
    //
    // Shortcut addresses of the TAPI call parameters (both levels) and the
    // L2TP-specific call parameters in the 'pMakeCall' buffer.  Obviously,
    // they are valid only when 'pMakeCall' is valid.  When invalid they are
    // set to NULL.
    //
    CO_CALL_PARAMETERS* pMakeCall;
    CO_AF_TAPI_MAKE_CALL_PARAMETERS UNALIGNED* pTmParams;
    LINE_CALL_PARAMS* pTcParams;

    // Shortcut address of the L2TP-specific call parameters in the
    // 'pMakeCall' or 'pInCall' buffer.  Obviously, this is only valid when
    // 'pMakeCall' or 'pInCall' is non-NULL.  When invalid this is NULL.  On
    // MakeCall, caller may not provide 'pLcParams' in which case one is
    // allocated and initialized to defaults for the convenience of the rest
    // of the code.  This temporary buffer is not reported to caller on
    // MakeCallComplete.
    //
    L2TP_CALL_PARAMETERS* pLcParams;

    // The result and error to report in the coming incoming/outgoing call
    // reply message.
    //
    USHORT usResult;
    USHORT usError;

    // The connect speed in bits/second.  This is the transmit speed value
    // reported by the peer LAC, or the value we reported to the peer LNS and
    // to NDISWAN.  Since we have no real knowledge of connect speed, we
    // report the minimum of the maximum rate acceptable to peer and
    // L2TP_LanBps.
    //
    ULONG ulConnectBps;

    // SEND STATE ------------------------------------------------------------

    // Next Sent, the sequence number of next payload packet transmitted on
    // this call.  The field is initialized to 0 and incremented after
    // assignment to an outgoing packet, excepting retransmissions.  Access is
    // protected by 'lockV'.
    //
    USHORT usNs;

    // Double-linked list of outstanding sends, i.e. PAYLOADSENTs sorted by
    // the 'usNs' field with lower values near the head.  Access is protected
    // by 'lockV'.
    //
    LIST_ENTRY listSendsOut;

    // The number of sent but unacknowledged packets that may be outstanding.
    // This value is adjusted dynamically.  Per the draft/RFC, when
    // 'ulAcksSinceSendTimeout' reaches the current setting, the window is
    // increased by one.  When a send timeout expires the window is reduced by
    // half.  The actual send window throttling is done by NDISWAN, based on
    // our indications of the changing window size.  Access is protected by
    // 'lockV'.
    //
    ULONG ulSendWindow;

    // The maximum value of 'ulSendWindow'.  Peer chooses this value during
    // call setup.
    //
    ULONG ulMaxSendWindow;

    // The number of packets acknowledged since the last timeout.  The value
    // is reset when a timeout occurs or the send window is adjusted upward.
    // See 'ulSendWindow'.  Access is protected by 'lockV'.
    //
    ULONG ulAcksSinceSendTimeout;

    // The estimated round trip time in milliseconds.  This is the RTT value
    // from Appendix A of the draft/RFC.  The value is adjusted as each
    // acknowledge is received.  It is initialized to the Packet Processing
    // Delay reported by peer.  See 'ulSendTimeoutMs'.  Access is protected by
    // 'lockV'.
    //
    ULONG ulRoundTripMs;

    // The estimated mean deviation in milliseconds, an approximation of the
    // standard deviation.  This is the DEV value from Appendix A of the
    // draft/RFC.  The value is adjusted as each acknowledge is received.  It
    // is initially 0.  See 'ulSendTimeoutMs'.  Access is protected by
    // 'lockV'.
    //
    LONG lDeviationMs;

    // Milliseconds before it is assumed a sent packet will never be
    // acknowledged.  This is the ATO value from Appendix A of the draft/RFC.
    // This value is adjusted as each acknowledge is received, with a maximum
    // of 'ADAPTERCB.ulMaxSendTimeoutMs'.  Access is protected by 'lockV'.
    //
    ULONG ulSendTimeoutMs;

    // The timer event descriptor scheduled to occur when it is time to stop
    // waiting for an outgoing send on which to piggyback an acknowledge.
    // This will be NULL when no delayed acknowledge is pending.  Per the
    // draft/RFC, the timeout used is 1/4 of the 'ulSendTimeoutMs'.  Access is
    // protected by 'lockV'.
    //
    TIMERQITEM* pTqiDelayedAck;


    // RECEIVE STATE ---------------------------------------------------------

    // Next Received, the sequence number one higher than that of the last
    // payload packet received on this call or 0 if none.  Access is protected
    // by 'lockV'.
    //
    USHORT usNr;

    // Double-linked list of out-of-order receives, i.e. PAYLOADRECEIVEs
    // sorted by the 'usNs' field with lower values near the head.  The
    // maximum queue length is 'ADAPTERCB.sMaxOutOfOrder'.  Access is
    // protected by 'lockV'.
    //
    LIST_ENTRY listOutOfOrder;


    // NDIS BOOKKEEPING ------------------------------------------------------

    // NDIS's handle for this VC passed to us in MiniportCoCreateVcHandler.
    // This is passed back to NDIS in various NdisXxx calls.
    //
    NDIS_HANDLE NdisVcHandle;

    // Configuration settings returned to callers on OID_WAN_CO_GET_INFO and
    // modified by callers on OID_WAN_CO_SET_INFO.  Older NDISWAN references to
    // "LINK" map straight to "VC" in the NDIS 5.0 world.  Access is not
    // protected because each ULONG in the structure is independent so no
    // incoherency can result from multiple access.
    //
    NDIS_WAN_CO_GET_LINK_INFO linkinfo;


    // STATISTICS ------------------------------------------------------------

    // Statistics for the current call.  Access is protected by 'lockV'.
    //
    CALLSTATS stats;
}
VCCB;


// The "exploded" description of an L2TP header, as output by
// ExplodeL2tpHeader.
//
typedef struct
_L2TPHEADERINFO
{
    // Addresses of header fields.  Some may be NULL indicating the field was
    // not present in the header.
    //
    USHORT* pusBits;
    USHORT* pusLength;
    USHORT* pusTunnelId;
    USHORT* pusCallId;
    USHORT* pusNs;
    USHORT* pusNr;

    // Length of the variable length header in bytes.
    //
    ULONG ulHeaderLength;

    // Address and length in bytes of the data following the variable length
    // header.
    //
    CHAR* pData;
    ULONG ulDataLength;
}
L2TPHEADERINFO;


// The "exploded" description of an Attribute/Value Pair (AVP), as output by
// ExplodeAvpHeader.  The "value" is located and sized but not interpreted or
// byte-ordered until a GetAvpValueXxx routine is applied.
//
typedef struct
_AVPINFO
{
    // Addresses of header fields.  All are always present.
    //
    UNALIGNED USHORT* pusBits;
    UNALIGNED USHORT* pusVendorId;
    UNALIGNED USHORT* pusAttribute;

    // The length of the entire AVP, extracted from '*pusBits'.
    //
    USHORT usOverallLength;

    // Length of the value in bytes and the address of the value.
    //
    USHORT usValueLength;
    CHAR* pValue;
}
AVPINFO;


// The "exploded" description of a control message, as output by
// ExplodeControlAvps.
//
typedef struct
_CONTROLMSGINFO
{
    // GERR_* code indicating the result of the ExplodeControlAvps operation.
    // Other fields should not be referenced unless this is GERR_None.
    //
    USHORT usXError;

    // True when the message is a tunnel setup message, false if it is a call
    // setup message.
    //
    BOOLEAN fTunnelMsg;

    // Address of message type AVP value.  The message type AVP is present in
    // all valid control messages.
    //
    UNALIGNED USHORT* pusMsgType;

    // Addresses of additional AVP values.  These may be NULL indicating the
    // AVP was not found in the message.  The length field following variable
    // length fields is valid whenever the value address is non-NULL.
    //
    USHORT* pusResult;
    USHORT* pusError;
    CHAR* pchResultMsg;
    USHORT usResultMsgLength;
    UNALIGNED USHORT* pusProtocolVersion;
    UNALIGNED USHORT* pusFirmwareRevision;
    UNALIGNED ULONG* pulFramingCaps;
    UNALIGNED ULONG* pulBearerCaps;
    CHAR* pchTieBreaker;
    CHAR* pchHostName;
    USHORT usHostNameLength;
    UNALIGNED USHORT* pusAssignedTunnelId;
    UNALIGNED USHORT* pusRWindowSize;
    UNALIGNED USHORT* pusAssignedCallId;
    UNALIGNED ULONG* pulCallSerialNumber;
    UNALIGNED ULONG* pulMinimumBps;
    UNALIGNED ULONG* pulMaximumBps;
    UNALIGNED ULONG* pulBearerType;
    UNALIGNED ULONG* pulFramingType;
    UNALIGNED USHORT* pusPacketProcDelay;
    CHAR* pchDialedNumber;
    USHORT usDialedNumberLength;
    CHAR* pchDialingNumber;
    USHORT usDialingNumberLength;
    UNALIGNED ULONG* pulTxConnectSpeed;
    UNALIGNED ULONG* pulPhysicalChannelId;
    CHAR* pchSubAddress;
    USHORT usSubAddressLength;
    CHAR* pchChallenge;
    USHORT usChallengeLength;
    CHAR* pchResponse;
    UNALIGNED USHORT* pusProxyAuthType;
    CHAR* pchProxyAuthResponse;
    USHORT usProxyAuthResponseLength;
    UNALIGNED ULONG* pulCallErrors;
    UNALIGNED ULONG* pulAccm;
    BOOLEAN fSequencingRequired;
}
CONTROLMSGINFO;


// Context for a control packet received out of order which is queued rather
// than discarding in the hope that the missing packet will arrive.
//
typedef struct
_CONTROLRECEIVED
{
    // Link to the prev/next link in the 'TUNNELCB.listOutOfOrder' list.
    //
    LIST_ENTRY linkOutOfOrder;

    // 'Next Sent' sequence number received in the packet.
    //
    USHORT usNs;

    // Associated VC or NULL if none.
    //
    VCCB* pVc;

    // The received GetBufferFromPool buffer.
    //
    CHAR* pBuffer;

    // The "exploded" description of the control message.
    //
    CONTROLMSGINFO control;
}
CONTROLRECEIVED;


// Context for a control packet sent but not yet acknowledged.  This block is
// queued on the 'TUNNELCB.listSendsOut' and 'TUNNELCB.listSendsPending'
// lists, and is associated with SendControlTimerEvents.
//
typedef struct
_CONTROLSENT
{
    // Link to the prev/next link in the 'TUNNELCB.listSendsOut' list.
    //
    LIST_ENTRY linkSendsOut;

    // Reference count on this context.  The reference pairs are:
    //
    // (a) A reference is added when the context is queued into the
    //     'listSendsOut' list, and removed by the de-queuer.
    //
    // (b) A reference is added before sending (and also before
    //     'pTqiSendTimeout' is scheduled) and is removed by the send
    //     completion routine.
    //
    // (c) A reference is added before 'pTqiSendTimeout' is scheduled and
    //     removed as the timer event handler exits.
    //
    LONG lRef;

    // 'Next Sent' sequence number sent with the packet.
    //
    USHORT usNs;

    // The message type of the packet.  (debug use only)
    //
    USHORT usMsgType;

    // Timer event descriptor scheduled for the packet.
    //
    TIMERQITEM* pTqiSendTimeout;

    // Number of times the packet has been retransmitted.
    //
    ULONG ulRetransmits;

    // CSF_* flags indicating various options.
    //
    // CSF_Pending: Set when transmission or retransmission of the packet is
    //     pending.  Access is protected by 'pTunnel->lockT'.
    //
    // CSF_TunnelIdleOnAck:  Set when TunnelTransitionComplete is to be
    //     executed when the message is acknowledged, moving to CCS_Idle
    //     state.
    //
    // CSF_CallIdleOnAck:  Set when CallTransitionComplete is to be executed
    //     when the message is acknowledged, moving to CS_Idle state.
    //
    ULONG ulFlags;
        #define CSF_Pending          0x00000001
        #define CSF_TunnelIdleOnAck  0x00000010
        #define CSF_CallIdleOnAck    0x00000020
        #define CSF_QueryMediaSpeed  0x00000040   
        #define CSF_IpUdpHeaders     0x00000080

    // The outstanding packet's buffer, as passed to TDI.
    //
    CHAR* pBuffer;

    // The length of the data to send in 'pBuffer'.
    //
    ULONG ulBufferLength;

    // Back pointer to owning tunnel.
    //
    TUNNELCB* pTunnel;

    // Back pointer to owning VC, or NULL if none.
    //
    VCCB* pVc;

    // The NDIS system time at which the packet was originally sent.
    //
    LONGLONG llTimeSent;

    // The IRP passed to TDI by the TDIX extension library, or NULL if none or
    // it's already been completed.  (for debug purposes only)
    //
    IRP* pIrp;
}
CONTROLSENT;


// Context for a payload packet received out of order which is queued for a
// time rather than discarding in the hope that the missing packet will
// arrive.
//
typedef struct
_PAYLOADRECEIVED
{
    // Link to the prev/next link in the 'VCCB.listOutOfOrder' list.
    //
    LIST_ENTRY linkOutOfOrder;

    // 'Next Sent' sequence number received in the packet.
    //
    USHORT usNs;

    // The received GetBufferFromPool buffer.
    //
    CHAR* pBuffer;

    // Offset of the payload to indicate received in 'pBuffer'.
    //
    ULONG ulPayloadOffset;

    // Length in bytes of the payload to indicate received in 'pBuffer'.
    //
    ULONG ulPayloadLength;

    // NDIS time the packet was received from the net, or 0 if caller did not
    // choose the RECEIVE_TIME_INDICATION option in his call parameters.
    //
    LONGLONG llTimeReceived;
}
PAYLOADRECEIVED;


// Context for a payload packet sent but not yet acknowledged.  This block is
// queued on the 'VCCB.listSendsOut', and is associated with
// SendPayloadTimerEvents.
//
typedef struct
_PAYLOADSENT
{
    // Link to the prev/next link in the 'VCCB.listSendsOut' list.
    //
    LIST_ENTRY linkSendsOut;

    // Link to the prev/next link in the 'g_listDebugPs' list.  The list is
    // maintained only when PSDEBUG is defined, but this is included always
    // for the convenience of KD extension users.  (for debug purposes only)
    //
    LIST_ENTRY linkDebugPs;

    // Reference count on this context.  The reference pairs are:
    //
    // (a) A reference is added when the context is queued into the
    //     'listSendsOut' list, and removed by the de-queuer.
    //
    // (b) A reference is added before sending (and also before the time is
    //     scheduled) and removed by the send completion routine.
    //
    // (c) A reference is added before scheduling the timer and removed by the
    //     timer event handler.
    //
    LONG lRef;

    // 'Next Sent' sequence number sent with the packet.
    //
    USHORT usNs;

    // Timer event descriptor scheduled to fire when it's time to give up on
    // receiving an acknowledge of the packet.
    //
    TIMERQITEM* pTqiSendTimeout;

    // The built NDIS packet.
    //
    NDIS_PACKET* pPacket;

    // The L2TP header buffer prepended to the payload buffer.
    //
    CHAR* pBuffer;

    // Back pointer to the owning tunnel control block.
    //
    TUNNELCB* pTunnel;

    // Back pointer to the owning VC control block.
    //
    VCCB* pVc;

    // Status of the completed packet.
    //
    NDIS_STATUS status;

    // The NDIS system time at which the packet was originally sent.
    //
    LONGLONG llTimeSent;

    // The IRP passed to TDI by the TDIX extension library, or NULL if none or
    // it's already been completed.  (for debug purposes only)
    //
    IRP* pIrp;
}
PAYLOADSENT;


// Tunnel work handler that executes tunnel related work at PASSIVE IRQL.
// 'PWork' is the work context that should be freed with FREE_TUNNELWORK when
// the handler is done accessing the 'punpArgs' array.  'PTunnel' is the
// owning tunnel.  'PVc' is the owning VC, or NULL if none.  'PunpArgs' is an
// array of 4 auxillary arguments as passed to ScheduleTunnelWork.
//
typedef
VOID
(*PTUNNELWORK)(
    IN TUNNELWORK* pWork,
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN ULONG_PTR* punpArgs );


// Tunnel work item describing a single unit of tunnel related work to be
// executed serially at PASSIVE IRQL by the TunnelWork mechanism.
//
typedef struct
_TUNNELWORK
{
    // Link to the prev/next link in the 'TUNNELCB.listWork' queue.
    //
    LIST_ENTRY linkWork;

    // Handler that executes this work item.
    //
    PTUNNELWORK pHandler;

    // The associated VC, if any.
    //
    VCCB* pVc;

    // Auxillary arguments passed to handler.
    //
    ULONG_PTR aunpArgs[ 4 ];
}
TUNNELWORK;


// Context of call setup for an incoming call.  The information is used to
// store and later resume receive processing of an peer's call initiation
// across the asynchronous CoNdis calls, and for building the call parameter
// buffer to dispatch to client.
//
typedef struct
_INCALLSETUP
{
    // See ReceiveControl for descriptions.
    //
    CHAR* pBuffer;
    L2TPHEADERINFO info;
    CONTROLMSGINFO control;

    // Buffer in which the incoming call parameters to be dispatched to caller
    // are built.
    //
    PVOID pvDummyPointerAligner;
    
    CHAR achCallParams[ sizeof(CO_CALL_PARAMETERS)

                        + sizeof(PVOID)
                        + sizeof(CO_CALL_MANAGER_PARAMETERS)

                        + sizeof(PVOID)
                        + sizeof(CO_MEDIA_PARAMETERS)
                        + sizeof(CO_AF_TAPI_INCOMING_CALL_PARAMETERS)

                        + sizeof(PVOID)
                        + sizeof(LINE_CALL_INFO)

                        + sizeof(PVOID)
                        + sizeof(L2TP_CALL_PARAMETERS)

                        + ((L2TP_MaxDottedIpLen + 1) * sizeof(WCHAR)) ];
}
INCALLSETUP;


// The L2TP role played by an L2TP peer.  The values may be read from the
// registry, so don't change randomly.
//
typedef enum
_L2TPROLE
{
    LR_Lns = 1,
    LR_Lac = 2
}
L2TPROLE;


// The strategy employed when it is time to add a host route and that route is
// found to already exists.
//
// Note: The values currently match the those of the registry parameter
//       "UseExistingRoutes".  Check GetRegistrySettings code before changing.
//
typedef enum
_HOSTROUTEEXISTS
{
    HRE_Use = 0,
    HRE_Fail = 1,
    HRE_Reference = 2
}
HOSTROUTEEXISTS;


// Link status block for transfer across locks.  See TransferLinkStatusInfo
// and IndicateLinkStatus.
//
typedef struct
_LINKSTATUSINFO
{
    NDIS_HANDLE MiniportAdapterHandle;
    NDIS_HANDLE NdisVcHandle;
    WAN_CO_LINKPARAMS params;
}
LINKSTATUSINFO;


//-----------------------------------------------------------------------------
// Macros/inlines
//-----------------------------------------------------------------------------

#define CtrlObjFromUdpContext(_x) \
    (_x)->pCtrlAddr
    
#define PayloadObjFromUdpContext(_x) \
    (_x)->pPayloadAddr
    
// These basics are not in the DDK headers for some reason.
//
#define min( a, b ) (((a) < (b)) ? (a) : (b))
#define max( a, b ) (((a) > (b)) ? (a) : (b))

#define InsertBefore( pNewL, pL )    \
{                                    \
    (pNewL)->Flink = (pL);           \
    (pNewL)->Blink = (pL)->Blink;    \
    (pNewL)->Flink->Blink = (pNewL); \
    (pNewL)->Blink->Flink = (pNewL); \
}

#define InsertAfter( pNewL, pL )     \
{                                    \
    (pNewL)->Flink = (pL)->Flink;    \
    (pNewL)->Blink = (pL);           \
    (pNewL)->Flink->Blink = (pNewL); \
    (pNewL)->Blink->Flink = (pNewL); \
}

// Pad to the size of the given datatype.  (Borrowed from wdm.h which is not
// otherwise needed)
//
#define ALIGN_DOWN(length, type) \
    ((ULONG)(length) & ~(sizeof(type) - 1))

#define ALIGN_UP(length, type) \
    (ALIGN_DOWN(((ULONG)(length) + sizeof(type) - 1), type))

// Winsock-ish host/network byte order converters for short and long integers.
//
#if (defined(_M_IX86) && (_MSC_FULL_VER > 13009037)) || ((defined(_M_AMD64) || defined(_M_IA64)) && (_MSC_FULL_VER > 13009175))
#define htons(x) _byteswap_ushort((USHORT)(x))
#define htonl(x) _byteswap_ulong((ULONG)(x))
#else
#define htons( a ) ((((a) & 0xFF00) >> 8) |\
                    (((a) & 0x00FF) << 8))
#define htonl( a ) ((((a) & 0xFF000000) >> 24) | \
                    (((a) & 0x00FF0000) >> 8)  | \
                    (((a) & 0x0000FF00) << 8)  | \
                    (((a) & 0x000000FF) << 24))
#endif
#define ntohs( a ) htons(a)
#define ntohl( a ) htonl(a)

// network byte order             
#define IPADDR_IS_MULTICAST(_addr)          (((_addr) & 0x000000f0) == 0x000000e0)
#define IPADDR_IS_BROADCAST(_addr)          ((_addr) == 0xffffffff)


// Place in a TRACE argument list to correspond with a format of "%d.%d.%d.%d"
// to print network byte-ordered IP address 'x' in human readable form.
//
#define IPADDRTRACE( x ) ((x) & 0x000000FF),         \
                         (((x) >> 8) & 0x000000FF),  \
                         (((x) >> 16) & 0x000000FF), \
                         (((x) >> 24) & 0x000000FF)

// Place in a TRACE argument list to correspond with a format of "%d" to print
// a percentage of two integers, or an average of two integers, or those
// values rounded.
//
#define PCTTRACE( n, d ) ((d) ? (((n) * 100) / (d)) : 0)
#define AVGTRACE( t, c ) ((c) ? ((t) / (c)) : 0)
#define PCTRNDTRACE( n, d ) ((d) ? (((((n) * 1000) / (d)) + 5) / 10) : 0)
#define AVGRNDTRACE( t, c ) ((c) ? (((((t) * 10) / (c)) + 5) / 10) : 0)

// All memory allocations and frees are done with these ALLOC_*/FREE_*
// macros/inlines to allow memory management scheme changes without global
// editing.  For example, might choose to lump several lookaside lists of
// nearly equal sized items into a single list for efficiency.
//
// NdisFreeMemory requires the length of the allocation as an argument.  NT
// currently doesn't use this for non-paged memory, but according to JameelH,
// Windows95 does.  These inlines stash the length at the beginning of the
// allocation, providing the traditional malloc/free interface.  The
// stash-area is a ULONGLONG so that all allocated blocks remain ULONGLONG
// aligned as they would be otherwise, preventing problems on Alphas.
//
__inline
VOID*
ALLOC_NONPAGED(
    IN ULONG ulBufLength,
    IN ULONG ulTag )
{
    CHAR* pBuf;

    NdisAllocateMemoryWithTag(
        &pBuf, (UINT )(ulBufLength + MEMORY_ALLOCATION_ALIGNMENT), ulTag );
    if (!pBuf)
    {
        return NULL;
    }

    ((ULONG* )pBuf)[ 0 ] = ulBufLength;
    ((ULONG* )pBuf)[ 1 ] = 0xC0BBC0DE;
    return pBuf + MEMORY_ALLOCATION_ALIGNMENT;
}

__inline
VOID
FREE_NONPAGED(
    IN VOID* pBuf )
{
    ULONG ulBufLen;

    ulBufLen = *((ULONG* )(((CHAR* )pBuf) - MEMORY_ALLOCATION_ALIGNMENT));
    NdisFreeMemory(
        ((CHAR* )pBuf) - MEMORY_ALLOCATION_ALIGNMENT,
        (UINT )(ulBufLen + MEMORY_ALLOCATION_ALIGNMENT),
        0 );
}

#define ALLOC_NDIS_WORK_ITEM( pA ) \
    NdisAllocateFromNPagedLookasideList( &(pA)->llistWorkItems )
#define FREE_NDIS_WORK_ITEM( pA, pNwi ) \
    NdisFreeToNPagedLookasideList( &(pA)->llistWorkItems, (pNwi) )

#define ALLOC_TIMERQITEM( pA ) \
    NdisAllocateFromNPagedLookasideList( &(pA)->llistTimerQItems )
#define FREE_TIMERQITEM( pA, pTqi ) \
    NdisFreeToNPagedLookasideList( &(pA)->llistTimerQItems, (pTqi) )

#define ALLOC_CONTROLSENT( pA ) \
    NdisAllocateFromNPagedLookasideList( &(pA)->llistControlSents )
#define FREE_CONTROLSENT( pA, pCs ) \
    NdisFreeToNPagedLookasideList( &(pA)->llistControlSents, (pCs) )

#define ALLOC_PAYLOADSENT( pA ) \
    NdisAllocateFromNPagedLookasideList( &(pA)->llistPayloadSents )
#define FREE_PAYLOADSENT( pA, pPs ) \
    NdisFreeToNPagedLookasideList( &(pA)->llistPayloadSents, (pPs) )

#define ALLOC_TUNNELWORK( pA ) \
    NdisAllocateFromNPagedLookasideList( &(pA)->llistTunnelWorks )
#define FREE_TUNNELWORK( pA, pCs ) \
    NdisFreeToNPagedLookasideList( &(pA)->llistTunnelWorks, (pCs) )

#if LLISTALL

#define ALLOC_TUNNELCB( pA ) \
    NdisAllocateFromNPagedLookasideList( &(pA)->llistTunnels )
#define FREE_TUNNELCB( pA, pT ) \
    NdisFreeToNPagedLookasideList( &(pA)->llistTunnels, (pT) )

#define ALLOC_VCCB( pA ) \
    NdisAllocateFromNPagedLookasideList( &(pA)->llistVcs )
#define FREE_VCCB( pA, pV ) \
    NdisFreeToNPagedLookasideList( &(pA)->llistVcs, (pV) )

#define ALLOC_TIMERQ( pA ) \
    NdisAllocateFromNPagedLookasideList( &(pA)->llistTimerQs )
#define FREE_TIMERQ( pA, pTq ) \
    NdisFreeToNPagedLookasideList( &(pA)->llistTimerQs, (pTq) )

#define ALLOC_CONTROLRECEIVED( pA ) \
    NdisAllocateFromNPagedLookasideList( &(pA)->llistControlReceiveds )
#define FREE_CONTROLRECEIVED( pA, pCr ) \
    NdisFreeToNPagedLookasideList( &(pA)->llistControlReceiveds, (pCr) )

#define ALLOC_PAYLOADRECEIVED( pA ) \
    NdisAllocateFromNPagedLookasideList( &(pA)->llistPayloadReceiveds )
#define FREE_PAYLOADRECEIVED( pA, pPr ) \
    NdisFreeToNPagedLookasideList( &(pA)->llistPayloadReceiveds, (pPr) )

#define ALLOC_INCALLSETUP( pA ) \
    NdisAllocateFromNPagedLookasideList( &(pA)->llistInCallSetups )
#define FREE_INCALLSETUP( pA, pCs ) \
    NdisFreeToNPagedLookasideList( &(pA)->llistInCallSetups, (pCs) )

#else // !LLISTALL

#define ALLOC_TUNNELCB( pA ) \
    ALLOC_NONPAGED( sizeof(TUNNELCB), MTAG_TUNNELCB )
#define FREE_TUNNELCB( pA, pT ) \
    FREE_NONPAGED( pT )

#define ALLOC_VCCB( pA ) \
    ALLOC_NONPAGED( sizeof(VCCB), MTAG_VCCB )
#define FREE_VCCB( pA, pV ) \
    FREE_NONPAGED( pV )

#define ALLOC_TIMERQ( pA ) \
    ALLOC_NONPAGED( sizeof(TIMERQ), MTAG_TIMERQ )
#define FREE_TIMERQ( pA, pTq ) \
    FREE_NONPAGED( pTq )

#define ALLOC_CONTROLRECEIVED( pA ) \
    ALLOC_NONPAGED( sizeof(CONTROLRECEIVED), MTAG_CTRLRECD )
#define FREE_CONTROLRECEIVED( pA, pCr ) \
    FREE_NONPAGED( pCr )

#define ALLOC_PAYLOADRECEIVED( pA ) \
    ALLOC_NONPAGED( sizeof(PAYLOADRECEIVED), MTAG_PAYLRECD )
#define FREE_PAYLOADRECEIVED( pA, pPr ) \
    FREE_NONPAGED( pPr )

#define ALLOC_INCALLSETUP( pA ) \
    ALLOC_NONPAGED( sizeof(INCALLSETUP), MTAG_INCALL )
#define FREE_INCALLSETUP( pA, pCs ) \
    FREE_NONPAGED( pCs )

#define ALLOC_CONTROLMSGINFO( pA ) \
    NdisAllocateFromNPagedLookasideList( &(pA)->llistControlMsgInfos )
#define FREE_CONTROLMSGINFO( pA, pCmi ) \
    NdisFreeToNPagedLookasideList( &(pA)->llistControlMsgInfos, (pCmi) )

#endif // !LLISTALL

#if READFLAGSDIRECT

#define ReadFlags( pulFlags ) \
    (*pulFlags)

#endif


//-----------------------------------------------------------------------------
// Prototypes (alphabetically)
//-----------------------------------------------------------------------------

VOID
ActivateCallIdSlot(
    IN VCCB* pVc );

VOID
AddHostRoute(
    IN TUNNELWORK* pWork,
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN ULONG_PTR* punpArgs );

BOOLEAN
AdjustSendWindowAtAckReceived(
    IN ULONG ulMaxSendWindow,
    IN OUT ULONG* pulAcksSinceSendTimeout,
    IN OUT ULONG* pulSendWindow );

VOID
AdjustTimeoutsAtAckReceived(
    IN LONGLONG llSendTime,
    IN ULONG ulMaxSendTimeoutMs,
    OUT ULONG* pulSendTimeoutMs,
    IN OUT ULONG* pulRoundTripMs,
    IN OUT LONG* plDeviationMs );

VOID
AdjustTimeoutsAndSendWindowAtTimeout(
    IN ULONG ulMaxSendTimeoutMs,
    IN LONG lDeviationMs,
    OUT ULONG* pulSendTimeoutMs,
    IN OUT ULONG* pulRoundTripMs,
    IN OUT ULONG* pulSendWindow,
    OUT ULONG* pulAcksSinceSendTimeout );

VOID
CalculateResponse(
    IN UCHAR* puchChallenge,
    IN ULONG ulChallengeLength,
    IN CHAR* pszPassword,
    IN UCHAR uchId,
    OUT UCHAR* puchResponse );

VOID
CallCleanUp(
    IN VCCB* pVc );

VOID
CallTransitionComplete(
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN L2TPCALLSTATE state );

VOID
ChangeHostRoute(
    IN TUNNELWORK* pWork,
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN ULONG_PTR* punpArgs );

VOID
ClearFlags(
    IN OUT ULONG* pulFlags,
    IN ULONG ulMask );

VOID
CloseCall(
    IN TUNNELWORK* pWork,
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN ULONG_PTR* punpArgs );

BOOLEAN
CloseCall2(
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN USHORT usResult,
    IN USHORT usError );

VOID
CloseTdix(
    IN TUNNELWORK* pWork,
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN ULONG_PTR* punpArgs );

VOID
CloseTunnel(
    IN TUNNELWORK* pWork,
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN ULONG_PTR* punpArgs );

VOID
CloseTunnel2(
    IN TUNNELCB* pTunnel );

VOID
CompleteVcs(
    IN TUNNELCB* pTunnel );

VOID
DeleteHostRoute(
    IN TUNNELWORK* pWork,
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN ULONG_PTR* punpArgs );

VOID
DereferenceAdapter(
    IN ADAPTERCB* pAdapter );

VOID
DereferenceCall(
    IN VCCB* pVc );

LONG
DereferenceControlSent(
    IN CONTROLSENT* pSent );

LONG
DereferencePayloadSent(
    IN PAYLOADSENT* pPs );

VOID
DereferenceSap(
    IN ADAPTERCB* pAdapter );

LONG
DereferenceTunnel(
    IN TUNNELCB* pTunnel );

VOID
DereferenceVc(
    IN VCCB* pVc );

VOID
DottedFromIpAddress(
    IN ULONG ulIpAddress,
    OUT CHAR* pszIpAddress,
    IN BOOLEAN fUnicode );

NDIS_STATUS
ExecuteWork(
    IN ADAPTERCB* pAdapter,
    IN NDIS_PROC pProc,
    IN PVOID pContext,
    IN ULONG ulArg1,
    IN ULONG ulArg2,
    IN ULONG ulArg3,
    IN ULONG ulArg4 );

#if 0
VOID
ExplodeWanAddress(
    IN WAN_ADDRESS* pWanAddress,
    OUT CHAR** ppArg1,
    OUT ULONG* pulLength1,
    OUT CHAR** ppArg2,
    OUT ULONG* pulLength2,
    OUT CHAR** ppArg3,
    OUT ULONG* pulLength3 );
#endif

VOID
FsmCloseCall(
    IN TUNNELWORK* pWork,
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN ULONG_PTR* punpArgs );

VOID
FsmCloseTunnel(
    IN TUNNELWORK* pWork,
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN ULONG_PTR* punpArgs );

VOID
FsmOpenCall(
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc );

VOID
FsmOpenTunnel(
    IN TUNNELWORK* pWork,
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN ULONG_PTR* punpArgs );

VOID
FsmOpenIdleTunnel(
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc );

BOOLEAN
FsmReceive(
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN CHAR* pBuffer,
    IN CONTROLMSGINFO* pControl );

CHAR*
GetFullHostNameFromRegistry(
    VOID );

USHORT
GetNextTerminationCallId(
    IN ADAPTERCB* pAdapter );

USHORT
GetNextTunnelId(
    IN ADAPTERCB* pAdapter );

VOID
IndicateLinkStatus(
    IN VCCB* pVc,
    IN LINKSTATUSINFO* pInfo );

ULONG
IpAddressFromDotted(
    IN CHAR* pchIpAddress );

NDIS_STATUS
LcmCmOpenAf(
    IN NDIS_HANDLE CallMgrBindingContext,
    IN PCO_ADDRESS_FAMILY AddressFamily,
    IN NDIS_HANDLE NdisAfHandle,
    OUT PNDIS_HANDLE CallMgrAfContext );

NDIS_STATUS
LcmCmCloseAf(
    IN NDIS_HANDLE CallMgrAfContext );

NDIS_STATUS
LcmCmRegisterSap(
    IN NDIS_HANDLE CallMgrAfContext,
    IN PCO_SAP Sap,
    IN NDIS_HANDLE NdisSapHandle,
    OUT PNDIS_HANDLE CallMgrSapContext );

NDIS_STATUS
LcmCmDeregisterSap(
    NDIS_HANDLE CallMgrSapContext );

#ifndef OLDMCM

NDIS_STATUS
LcmCmCreateVc(
    IN NDIS_HANDLE ProtocolAfContext,
    IN NDIS_HANDLE NdisVcHandle,
    OUT PNDIS_HANDLE ProtocolVcContext );

NDIS_STATUS
LcmCmDeleteVc(
    IN NDIS_HANDLE ProtocolVcContext );

#endif // !OLDMCM

NDIS_STATUS
LcmCmMakeCall(
    IN NDIS_HANDLE CallMgrVcContext,
    IN OUT PCO_CALL_PARAMETERS CallParameters,
    IN NDIS_HANDLE NdisPartyHandle,
    OUT PNDIS_HANDLE CallMgrPartyContext );

NDIS_STATUS
LcmCmCloseCall(
    IN NDIS_HANDLE CallMgrVcContext,
    IN NDIS_HANDLE CallMgrPartyContext,
    IN PVOID CloseData,
    IN UINT Size );

VOID
LcmCmIncomingCallComplete(
    IN NDIS_STATUS Status,
    IN NDIS_HANDLE CallMgrVcContext,
    IN PCO_CALL_PARAMETERS CallParameters );

VOID
LcmCmActivateVcComplete(
    IN NDIS_STATUS Status,
    IN NDIS_HANDLE CallMgrVcContext,
    IN PCO_CALL_PARAMETERS CallParameters );

VOID
LcmCmDeactivateVcComplete(
    IN NDIS_STATUS Status,
    IN NDIS_HANDLE CallMgrVcContext );

NDIS_STATUS
LcmCmModifyCallQoS(
    IN NDIS_HANDLE CallMgrVcContext,
    IN PCO_CALL_PARAMETERS CallParameters );

NDIS_STATUS
LcmCmRequest(
    IN NDIS_HANDLE CallMgrAfContext,
    IN NDIS_HANDLE CallMgrVcContext,
    IN NDIS_HANDLE CallMgrPartyContext,
    IN OUT PNDIS_REQUEST NdisRequest );

NDIS_STATUS
LmpInitialize(
    OUT PNDIS_STATUS OpenErrorStatus,
    OUT PUINT SelectedMediumIndex,
    IN PNDIS_MEDIUM MediumArray,
    IN UINT MediumArraySize,
    IN NDIS_HANDLE MiniportAdapterHandle,
    IN NDIS_HANDLE WrapperConfigurationContext );

VOID
LmpHalt(
    IN NDIS_HANDLE MiniportAdapterContext );

NDIS_STATUS
LmpReset(
    OUT PBOOLEAN AddressingReset,
    IN NDIS_HANDLE MiniportAdapterContext );

VOID
LmpReturnPacket(
    IN NDIS_HANDLE MiniportAdapterContext,
    IN PNDIS_PACKET Packet );

NDIS_STATUS
LmpQueryInformation(
    IN NDIS_HANDLE MiniportAdapterContext,
    IN NDIS_OID Oid,
    IN PVOID InformationBuffer,
    IN ULONG InformationBufferLength,
    OUT PULONG BytesWritten,
    OUT PULONG BytesNeeded );

NDIS_STATUS
LmpSetInformation(
    IN NDIS_HANDLE MiniportAdapterContext,
    IN NDIS_OID Oid,
    IN PVOID InformationBuffer,
    IN ULONG InformationBufferLength,
    OUT PULONG BytesRead,
    OUT PULONG BytesNeeded );

#ifdef OLDMCM

NDIS_STATUS
LmpCoCreateVc(
    IN NDIS_HANDLE MiniportAdapterContext,
    IN NDIS_HANDLE NdisVcHandle,
    IN PNDIS_HANDLE MiniportVcContext );

NDIS_STATUS
LmpCoDeleteVc(
    IN NDIS_HANDLE MiniportVcContext );

#endif // OLDMCM

NDIS_STATUS
LmpCoActivateVc(
    IN NDIS_HANDLE MiniportVcContext,
    IN OUT PCO_CALL_PARAMETERS CallParameters );

NDIS_STATUS
LmpCoDeactivateVc(
    IN NDIS_HANDLE MiniportVcContext );

VOID
LmpCoSendPackets(
    IN NDIS_HANDLE MiniportVcContext,
    IN PPNDIS_PACKET PacketArray,
    IN UINT NumberOfPackets );

NDIS_STATUS
LmpCoRequest(
    IN NDIS_HANDLE MiniportAdapterContext,
    IN NDIS_HANDLE MiniportVcContext,
    IN OUT PNDIS_REQUEST NdisRequest );

VOID
L2tpReceive(
    IN TDIXCONTEXT* pTdix,
    IN TDIXRDGINFO* pRdg,
    IN CHAR* pBuffer,
    IN ULONG ulOffset,
    IN ULONG ulBufferLen );

CHAR*
MsgTypePszFromUs(
    IN USHORT usMsgType );

#if READFLAGSDIRECT == 0
ULONG
ReadFlags(
    IN ULONG* pulFlags );
#endif

BOOLEAN
ReceiveControlExpected(
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN CHAR* pBuffer,
    IN CONTROLMSGINFO* pControl );

VOID
ReferenceAdapter(
    IN ADAPTERCB* pAdapter );

BOOLEAN
ReferenceCall(
    IN VCCB* pVc );

VOID
ReferenceControlSent(
    IN CONTROLSENT* pSent );

VOID
ReferencePayloadSent(
    IN PAYLOADSENT* pPs );

BOOLEAN
ReferenceSap(
    IN ADAPTERCB* pAdapter );

LONG
ReferenceTunnel(
    IN TUNNELCB* pTunnel,
    IN BOOLEAN fHaveLockTunnels );

VOID
ReferenceVc(
    IN VCCB* pVc );

BOOLEAN
ReleaseCallIdSlot(
    IN VCCB* pVc );

NDIS_STATUS
ReserveCallIdSlot(
    IN VCCB* pVc );

VOID
ResetHelloTimer(
    IN TUNNELCB* pTunnel );

VOID
ScheduleTunnelWork(
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN PTUNNELWORK pHandler,
    IN ULONG_PTR unpArg0,
    IN ULONG_PTR unpArg1,
    IN ULONG_PTR unpArg2,
    IN ULONG_PTR unpArg3,
    IN BOOLEAN fTcbPreReferenced,
    IN BOOLEAN fHighPriority );

NDIS_STATUS
ScheduleWork(
    IN ADAPTERCB* pAdapter,
    IN NDIS_PROC pProc,
    IN PVOID pContext );

VOID
SendControlAck(
    IN TUNNELWORK* pWork,
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN ULONG_PTR* punpArgs );

VOID
SendControl(
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN USHORT usMsgType,
    IN ULONG ulBuildAvpsArg1,
    IN ULONG ulBuildAvpsArg2,
    IN PVOID pvBuildAvpsArg3,
    IN ULONG ulFlags );

VOID
SendControlTimerEvent(
    IN TIMERQITEM* pItem,
    IN VOID* pContext,
    IN TIMERQEVENT event );

VOID
SendPayload(
    IN VCCB* pVc,
    IN NDIS_PACKET* pPacket );

VOID
SendPayloadAck(
    IN TUNNELWORK* pWork,
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN ULONG_PTR* punpArgs );

VOID
SendPending(
    IN TUNNELWORK* pWork,
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN ULONG_PTR* punpArgs );

VOID
SetFlags(
    IN OUT ULONG* pulFlags,
    IN ULONG ulMask );

TUNNELCB*
SetupTunnel(
    IN ADAPTERCB* pAdapter,
    IN ULONG ulIpAddress,
    IN USHORT usUdpPort,
    IN USHORT usAssignedTunnelId,
    IN BOOLEAN fExclusive );

VOID
SetupVcAsynchronously(
    IN TUNNELCB* pTunnel,
    IN ULONG ulIpAddress,
    IN CHAR* pBuffer,
    IN CONTROLMSGINFO* pControl );

WCHAR*
StrDupAsciiToUnicode(
    IN CHAR* psz,
    IN ULONG ulPszBytes );

WCHAR*
StrDupNdisString(
    IN NDIS_STRING* pNdisString );

CHAR*
StrDupNdisVarDataDescStringA(
    IN NDIS_VAR_DATA_DESC* pDesc );

CHAR*
StrDupNdisVarDataDescStringToA(
    IN NDIS_VAR_DATA_DESC UNALIGNED* pDesc );

CHAR*
StrDupNdisStringToA(
    IN NDIS_STRING* pNdisString );

CHAR*
StrDupSized(
    IN CHAR* psz,
    IN ULONG ulLength,
    IN ULONG ulExtra );

CHAR*
StrDupUnicodeToAscii(
    IN WCHAR* pwsz,
    IN ULONG ulPwszBytes );

ULONG
StrLenW(
    IN WCHAR* psz );

VOID
TransferLinkStatusInfo(
    IN VCCB* pVc,
    OUT LINKSTATUSINFO* pInfo );

TUNNELCB*
TunnelCbFromIpAddressAndAssignedTunnelId(
    IN ADAPTERCB* pAdapter,
    IN ULONG ulIpAddress,
    IN USHORT usUdpPort,
    IN USHORT usAssignedTunnelId );

VOID
TunnelTransitionComplete(
    IN TUNNELCB* pTunnel,
    IN L2TPCCSTATE state );

VOID
UpdateGlobalCallStats(
    IN VCCB* pVc );

VCCB*
VcCbFromCallId(
    IN TUNNELCB* pTunnel,
    IN USHORT usCallId );


#endif // _L2TPP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ndis\rasl2tp\l2tp.h ===
// Copyright (c) 1997, Microsoft Corporation, all rights reserved
//
// l2tp.h
//
// Public header for NDIS 5.0 clients and call managers wishing to make calls
// and register Service Access Points using L2TP, the Layer 2 Tunneling
// Protocol.
//
// 01/07/97 Steve Cobb
//
//
// About NdisClRegisterSap 'Sap':
//
// Clients registering an L2TP SAP via NdisClRegisterSap should pass for the
// 'Sap' argument either NULL or an CO_AF_TAPI_SAP structure.  L2TP currently
// supports only a single SAP so the CO_AF_TAPI_SAP, if passed, will be
// ignored.
//
//
// About NdisClMakeCall 'CallParameters':
//
// Clients calling NdisClMakeCall on an L2TP VC should pass
// CO_AF_TAPI_MAKE_CALL_PARAMETERS as the media specific CallParameters
// argument, i.e. CallParameters->MediaParameters->MediaSpecific.Parameters.
// An L2TP_CALL_PARAMETERS structure (below) should be passed in the
// DevSpecificData field of the LINE_CALL_PARAMS within the above structure.
// While it is recommended that caller provide L2TP_CALL_PARAMETERS, the
// driver will accept calls made with none in which case defaults will be
// used.


#ifndef _L2TP_H_
#define _L2TP_H_


// CO_AF_TAPI_MAKE_CALL_PARAMETERS.LineCallParams.ulDevSpecificOffset for L2TP
// calls.  This is passed down on NdisClMakeCall and returned to client's
// ClMakeCallCompleteHandler handler.
//
typedef struct
_L2TP_CALL_PARAMETERS
{
    // L2TPCPF_* bit flags indicating various call options.
    //
    // L2TPCPF_ExclusiveTunnel:  Set when an exclusive tunnel is to be created
    //     to the peer even if another tunnel already exists to the peer.
    //
    ULONG ulFlags;
        #define L2TPCPF_ExclusiveTunnel 0x00000001

    // The vendor-specific physical channel ID of the call reported to LNS by
    // LAC.
    //
    // To MakeCall: The ID reported to peer LNS, or 0xFFFFFFFF for none.  This
    //     has effect only if the OutgoingRole is LAC.
    //
    // From MakeCallCompleteHandler: The ID reported by the L2TP LAC or
    //     0xFFFFFFFF if none.
    //
    ULONG ulPhysicalChannelId;

    // The reasonably unique, progressively increasing call serial number
    // shared by both L2TP peers for troubleshooting.
    //
    // To MakeCall:  Must be set to 0, though ignored.
    //
    // From MakeCallCompleteHandler: The number assigned to the call.
    //
    ULONG ulCallSerialNumber;
}
L2TP_CALL_PARAMETERS;


#endif // _L2TP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ndis\rasl2tp\l2tprfc.h ===
// Copyright (c) 1997, Microsoft Corporation, all rights reserved
//
// l2tprfc.h
// RAS L2TP WAN mini-port/call-manager driver
// L2TP RFC header
//
// 01/07/97 Steve Cobb
//
// This header contains definitions from the L2TP draft/RFC, currently
// draft-12.
//


#ifndef _L2TPRFC_H_
#define _L2TPRFC_H_


//-----------------------------------------------------------------------------
// Constants
//-----------------------------------------------------------------------------

// The UDP port at which L2TP messages will arrive.
//
#define L2TP_UdpPort 1701

// The IP protocol number on which messages will arrive.  (No number has been
// assigned so this is a placeholder for now)
//
#define L2TP_IpProtocol 254

// The standard value for the Hello timer in milliseconds.
//
#define L2TP_HelloMs 60000

// The maximum number of bytes in a frame excluding all L2TP and PPP HDLC-ish
// framing overhead.
//
#define L2TP_MaxFrameSize 1500

// Maximum number of bytes in an L2TP control or payload header.
//
#define L2TP_MaxHeaderSize 14
#define L2TP_MinHeaderSize 6

// The maximum number of bytes in the L2TP payload packet header including
// padding.  The 14 represents all possible fields defined in the RFC.  The
// "+8" represents allowance for up to 8 bytes of padding to be specified in
// the header.  While there is theoretically no limit to the padding, there is
// no discussion in the L2TP forum indicating interest in more than 8 bytes.
//
#define L2TP_MaxPayloadHeader (14 + 8)

// The default packet processing delay in 1/10 second, i.e. 1/2 second.
//
#define L2TP_LnsDefaultPpd 5

// The default control send timeout in milliseconds, i.e. 1 second.
//
#define L2TP_DefaultSendTimeoutMs 1000

// The default control/payload piggybacking acknowledge delay in milliseconds.
//
#define L2TP_MaxAckDelay 500

// The implicit receive window offered control channels where no Receive
// Window AVP is provided.
//
#define L2TP_DefaultReceiveWindow 4

// Highest L2TP protocol version we support.
//
#define L2TP_ProtocolVersion 0x0100

// Default maximum send timeout in milliseconds.  The draft only says the cap
// must be no less than 8 seconds, so 10 seconds is selected as reasonable and
// safe.
//
#define L2TP_DefaultMaxSendTimeoutMs 10000

// Default maximum retransmissions before assuming peer is unreachable.
//
#define L2TP_DefaultMaxRetransmits 5

// Size in bytes of the fixed portion of a control message attribute/value
// pair, i.e. the size of an AVP with zero length value.
//
#define L2TP_AvpHeaderSize 6

// L2TP protocol control message types.
//
#define CMT_SCCRQ    1   // Start-Control-Connection-Request
#define CMT_SCCRP    2   // Start-Control-Connection-Reply
#define CMT_SCCCN    3   // Start-Control-Connection-Connected
#define CMT_StopCCN  4   // Stop-Control-Connection-Notify
#define CMT_StopCCRP 5   // Stop-Control-Connection-Reply (obsolete)
#define CMT_Hello    6   // Hello, i.e. keep-alive
#define CMT_OCRQ     7   // Outgoing-Call-Request
#define CMT_OCRP     8   // Outgoing-Call-Reply
#define CMT_OCCN     9   // Outgoing-Call-Connected
#define CMT_ICRQ     10  // Incoming-Call-Request
#define CMT_ICRP     11  // Incoming-Call-Reply
#define CMT_ICCN     12  // Incoming-Call-Connected
#define CMT_CCRQ     13  // Call-Clear-Request (obsolete)
#define CMT_CDN      14  // Call-Disconnect-Notify
#define CMT_WEN      15  // WAN-Error-Notify
#define CMT_SLI      16  // Set-Link-Info

// L2TP Attribute codes.
//
#define ATTR_MsgType            0
#define ATTR_Result             1
#define ATTR_ProtocolVersion    2
#define ATTR_FramingCaps        3
#define ATTR_BearerCaps         4
#define ATTR_TieBreaker         5
#define ATTR_FirmwareRevision   6
#define ATTR_HostName           7
#define ATTR_VendorName         8
#define ATTR_AssignedTunnelId   9
#define ATTR_RWindowSize        10
#define ATTR_Challenge          11
#define ATTR_Q931Cause          12
#define ATTR_ChallengeResponse  13
#define ATTR_AssignedCallId     14
#define ATTR_CallSerialNumber   15
#define ATTR_MinimumBps         16
#define ATTR_MaximumBps         17
#define ATTR_BearerType         18
#define ATTR_FramingType        19
#define ATTR_PacketProcDelay    20
#define ATTR_DialedNumber       21
#define ATTR_DialingNumber      22
#define ATTR_SubAddress         23
#define ATTR_TxConnectSpeed     24
#define ATTR_PhysicalChannelId  25
#define ATTR_InitialLcpConfig   26
#define ATTR_LastSLcpConfig     27
#define ATTR_LastRLcpConfig     28
#define ATTR_ProxyAuthType      29
#define ATTR_ProxyAuthName      30
#define ATTR_ProxyAuthChallenge 31
#define ATTR_ProxyAuthId        32
#define ATTR_ProxyAuthResponse  33
#define ATTR_CallErrors         34
#define ATTR_Accm               35
#define ATTR_RandomVector       36
#define ATTR_PrivateGroupId     37
#define ATTR_RxConnectSpeed     38
#define ATTR_SequencingRequired 39

#define ATTR_MAX 39

// L2TP protocol general error codes.
//
#define GERR_None                0
#define GERR_NoControlConnection 1
#define GERR_BadLength           2
#define GERR_BadValue            3
#define GERR_NoResources         4
#define GERR_BadCallId           5
#define GERR_VendorSpecific      6
#define GERR_TryAnother          7

// Tunnel Result Code AVP values, used in StopCCN message.
//
#define TRESULT_General            1
#define TRESULT_GeneralWithError   2
#define TRESULT_CcExists           3
#define TRESULT_NotAuthorized      4
#define TRESULT_BadProtocolVersion 5
#define TRESULT_Shutdown           6
#define TRESULT_FsmError           7

// Call Result Code values, used in CDN message.
//
#define CRESULT_LostCarrier           1
#define CRESULT_GeneralWithError      2
#define CRESULT_Administrative        3
#define CRESULT_NoFacilitiesTemporary 4
#define CRESULT_NoFacilitiesPermanent 5
#define CRESULT_InvalidDestination    6
#define CRESULT_NoCarrier             7
#define CRESULT_Busy                  8
#define CRESULT_NoDialTone            9
#define CRESULT_Timeout               10
#define CRESULT_NoFraming             11

// L2TP header bitmasks for the first 2 bytes of every L2TP message.
//
#define HBM_T       0x8000 // Control packet
#define HBM_L       0x4000 // Length field present
#define HBM_R       0x2000 // Reset Sr
#define HBM_F       0x0800 // Nr/Ns fields present
#define HBM_S       0x0200 // Offset field present
#define HBM_P       0x0100 // Preferential treatment bit
#define HBM_Bits    0xFFFC // All bits, excluding protocol version field
#define HBM_Ver     0x0003 // Protocol version (L2TP or L2F)
#define HBM_Control 0xc800 // Fixed value of bits in control message

// The defined header bits version number field values.
//
#define VER_L2f  0x0000
#define VER_L2tp 0x0002

// AVP header bitmasks for the first 2 bytes of every Attribute Value Pair.
//
#define ABM_M             0x8000 // Mandatory
#define ABM_H             0x4000 // Hidden
#define ABM_Reserved      0x3C00 // Reserved bits, must be 0
#define ABM_OverallLength 0x03FF // AVP's length including value

// Bearer capabilties AVP bitmasks.
//
#define BBM_Analog  0x00000001
#define BBM_Digital 0x00000002

// Framing capabilities/type AVP bitmasks.
//
#define FBM_Sync  0x00000001
#define FBM_Async 0x00000002

// Proxy Authentication types.
//
#define PAT_Text 1
#define PAT_Chap 2
#define PAT_Pap  3
#define PAT_None 4


//-----------------------------------------------------------------------------
// Data types
//-----------------------------------------------------------------------------

// The "Control Connection" state of a single L2TP tunnel.
//
typedef enum
_L2TPCCSTATE
{
    CCS_Idle = 0,
    CCS_WaitCtlReply,
    CCS_WaitCtlConnect,
    CCS_Established
}
L2TPCCSTATE;


// The "LNS/LAC Outgoing/Incoming Call" state of a single L2TP VC.  Only one
// of the 4 call creation FSMs can be running or Established on a single VC at
// once, so the states are combined in a single table.
//
typedef enum
_L2TPCALLSTATE
{
    CS_Idle = 0,
    CS_WaitTunnel,
    CS_WaitReply,
    CS_WaitConnect,
    CS_WaitDisconnect,
    CS_WaitCsAnswer,
    CS_Established
}
L2TPCALLSTATE;


#endif // _L2TPRFC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ndis\rasl2tp\mp.c ===
// Copyright (c) 1997, Microsoft Corporation, all rights reserved
//
// mp.c
// RAS L2TP WAN mini-port/call-manager driver
// Mini-port routines
//
// 01/07/97 Steve Cobb


#include "l2tpp.h"

#include "mp.tmh"

// The adapter control block address is recorded in this global as a debugging
// aid.  This global must not be read by any code.
//
ADAPTERCB* g_pDebugAdapter;

// The number of packets indicated up to and returned from the driver above.
//
LONG g_lPacketsIndicated = 0;
LONG g_lPacketsReturned = 0;

// Call statistics totals for all calls since loading, calls and the lock
// protecting access to them.  For this global only, the 'ullCallUp' field is
// the number of calls recorded, rather than a time.
//
CALLSTATS g_stats;
NDIS_SPIN_LOCK g_lockStats;

// Default settings for the NDIS_WAN_CO_INFO capabilities of an adapter.
//
static NDIS_WAN_CO_INFO g_infoDefaults =
{
    L2TP_MaxFrameSize,                  // MaxFrameSize
    0,                                  // MaxSendWindow (placeholder)
    PPP_FRAMING                         // FramingBits
        | PPP_COMPRESS_ADDRESS_CONTROL
        | PPP_COMPRESS_PROTOCOL_FIELD,
    0,                                  // DesiredACCM
};


//-----------------------------------------------------------------------------
// Local prototypes (alphabetically)
//-----------------------------------------------------------------------------

VOID
FreeAdapter(
    IN ADAPTERCB* pAdapter );

NDIS_STATUS
GetRegistrySettings(
    IN NDIS_HANDLE WrapperConfigurationContext,
    OUT USHORT* pusMaxVcs,
    OUT TDIXMEDIATYPE* pMediaType,
    OUT L2TPROLE* pOutgoingRole,
    OUT ULONG* pulMaxSendTimeoutMs,
    OUT ULONG* pulInitialSendTimeoutMs,
    OUT ULONG* pulMaxRetransmits,
    OUT ULONG* pulHelloMs,
    OUT ULONG* pulMaxAckDelayMs,
    OUT SHORT* psMaxOutOfOrder,
    OUT USHORT* pusControlReceiveWindow,
    OUT USHORT* pusPayloadReceiveWindow,
    OUT ULONG* pulPayloadSendWindow,
    OUT USHORT* pusLlistDepth,
    OUT CHAR** ppszHostName,
    OUT CHAR** ppszPassword,
    OUT BOOLEAN* pfIgnoreFramingMismatch,
    OUT BOOLEAN* pfExclusiveTunnels,
    OUT HOSTROUTEEXISTS* phre,
    OUT BOOLEAN* pfDisableUdpXsums,
    OUT WCHAR** ppszDriverDesc );

NDIS_STATUS
QueryInformation(
    IN ADAPTERCB* pAdapter,
    IN VCCB* pLink,
    IN NDIS_OID Oid,
    IN PVOID InformationBuffer,
    IN ULONG InformationBufferLength,
    OUT PULONG BytesWritten,
    OUT PULONG BytesNeeded );

NDIS_STATUS
SetInformation(
    IN ADAPTERCB* pAdapter,
    IN VCCB* pLink,
    IN NDIS_OID Oid,
    IN PVOID InformationBuffer,
    IN ULONG InformationBufferLength,
    OUT PULONG BytesRead,
    OUT PULONG BytesNeeded );


//-----------------------------------------------------------------------------
// Mini-port handlers
//-----------------------------------------------------------------------------

NDIS_STATUS
LmpInitialize(
    OUT PNDIS_STATUS OpenErrorStatus,
    OUT PUINT SelectedMediumIndex,
    IN PNDIS_MEDIUM MediumArray,
    IN UINT MediumArraySize,
    IN NDIS_HANDLE MiniportAdapterHandle,
    IN NDIS_HANDLE WrapperConfigurationContext )

    // Standard 'MiniportInitialize' routine called by NDIS to initialize a
    // new WAN adapter.  See DDK doc.  The driver will receive no requests
    // until this initialization has completed.
    //
{
    NDIS_STATUS status;
    ADAPTERCB* pAdapter;

    TRACE( TL_I, TM_Init, ( "LmpInit" ) );

    status = *OpenErrorStatus = NDIS_STATUS_SUCCESS;

    // Find the medium index in the array of media, looking for the only one
    // we support, 'NdisMediumCoWan'.
    //
    {
        UINT i;

        for (i = 0; i < MediumArraySize; ++i)
        {
            if (MediumArray[ i ] == NdisMediumCoWan)
            {
                break;
            }
        }

        if (i >= MediumArraySize)
        {
            TRACE( TL_A, TM_Init, ( "medium?" ) );
            return NDIS_STATUS_FAILURE;
        }

        *SelectedMediumIndex = i;
    }

    // Allocate and zero a control block for the new adapter.
    //
    pAdapter = ALLOC_NONPAGED( sizeof(*pAdapter), MTAG_ADAPTERCB );
    TRACE( TL_N, TM_Init, ( "Acb=$%p", pAdapter ) );
    if (!pAdapter)
    {
        return NDIS_STATUS_RESOURCES;
    }
    NdisZeroMemory( pAdapter, sizeof(*pAdapter) );

    // The adapter control block address is recorded in 'g_pDebugAdapter' as a
    // debugging aid only.  This global is not to be read by any code.
    //
    g_pDebugAdapter = pAdapter;

    // Set a marker for easier memory dump browsing and future assertions.
    //
    pAdapter->ulTag = MTAG_ADAPTERCB;

    // Save the NDIS handle associated with this adapter for use in future
    // NdisXxx calls.
    //
    pAdapter->MiniportAdapterHandle = MiniportAdapterHandle;

    // Initialize the list of active tunnels and it's lock.
    //
    InitializeListHead( &pAdapter->listTunnels );
    NdisAllocateSpinLock( &pAdapter->lockTunnels );

    // Copy default NDISWAN information.  Some of these are updated below.
    //
    NdisMoveMemory( &pAdapter->info, &g_infoDefaults, sizeof(pAdapter->info) );
    pAdapter->info.MaxFrameSize = 1400;

    do
    {
        TDIXMEDIATYPE tmt;
        L2TPROLE role;
        USHORT usLlistDepth;
        BOOLEAN fIgnoreFramingMismatch;
        BOOLEAN fExclusiveTunnels;
        HOSTROUTEEXISTS hre;
        BOOLEAN fDisableUdpXsums;

        // Read this adapter's registry settings.
        //
        status = GetRegistrySettings(
            WrapperConfigurationContext,
            &pAdapter->usMaxVcs,
            &tmt,
            &role,
            &pAdapter->ulMaxSendTimeoutMs,
            &pAdapter->ulInitialSendTimeoutMs,
            &pAdapter->ulMaxRetransmits,
            &pAdapter->ulHelloMs,
            &pAdapter->ulMaxAckDelayMs,
            &pAdapter->sMaxOutOfOrder,
            &pAdapter->usControlReceiveWindow,
            &pAdapter->usPayloadReceiveWindow,
            &pAdapter->info.MaxSendWindow,
            &usLlistDepth,
            &pAdapter->pszHostName,
            &pAdapter->pszPassword,
            &fIgnoreFramingMismatch,
            &fExclusiveTunnels,
            &hre,
            &fDisableUdpXsums,
            &pAdapter->pszDriverDesc );

        if (status != NDIS_STATUS_SUCCESS)
        {
            // Set 'usMaxVcs' to 0 as an indication to FreeAdapter that the
            // lookaside lists and pools were not initialized.
            //
            pAdapter->usMaxVcs = 0;
            break;
        }

        // Convert the outgoing call role and mismatch flags to the equivalent
        // control block flag settings.
        //
        if (role == LR_Lac)
        {
            pAdapter->ulFlags |= ACBF_OutgoingRoleLac;
        }

        if (fIgnoreFramingMismatch)
        {
            pAdapter->ulFlags |= ACBF_IgnoreFramingMismatch;
        }

        if (fExclusiveTunnels)
        {
            pAdapter->ulFlags |= ACBF_ExclusiveTunnels;
        }

        // Initialize our framing and bearer capability bit masks.  NDISWAN
        // supports only synchronous framing.  Until we add the full LAC
        // support, we have no bearer capabilities for both the LAC and LNS
        // roles.
        //
        pAdapter->ulFramingCaps = FBM_Sync;
        pAdapter->ulBearerCaps = 0;

        // Initialize lookaside lists, buffer pools, and packet pool.  On NT,
        // lookaside depths are optimized by the system based on usage
        // regardless of the depth set, but choose something reasonable
        // anyway.
        //
        {
            if (pAdapter->usMaxVcs < usLlistDepth)
            {
                usLlistDepth = pAdapter->usMaxVcs;
            }

            NdisInitializeNPagedLookasideList(
                &pAdapter->llistWorkItems,
                NULL, NULL, 0,
                sizeof(NDIS_WORK_ITEM),
                MTAG_WORKITEM,
                usLlistDepth );

            NdisInitializeNPagedLookasideList(
                &pAdapter->llistTimerQItems,
                NULL, NULL, 0,
                sizeof(TIMERQITEM),
                MTAG_TIMERQITEM,
                usLlistDepth );

            NdisInitializeNPagedLookasideList(
                &pAdapter->llistControlSents,
                NULL, NULL, 0,
                sizeof(CONTROLSENT),
                MTAG_CTRLSENT,
                usLlistDepth );

            NdisInitializeNPagedLookasideList(
                &pAdapter->llistPayloadSents,
                NULL, NULL, 0,
                sizeof(PAYLOADSENT),
                MTAG_PAYLSENT,
                usLlistDepth );

            NdisInitializeNPagedLookasideList(
                &pAdapter->llistTunnelWorks,
                NULL, NULL, 0,
                sizeof(TUNNELWORK),
                MTAG_TUNNELWORK,
                usLlistDepth );

            NdisInitializeNPagedLookasideList(
                &pAdapter->llistControlMsgInfos,
                NULL, NULL, 0,
                sizeof(CONTROLMSGINFO),
                MTAG_CTRLMSGINFO,
                usLlistDepth );

#if LLISTALL
            NdisInitializeNPagedLookasideList(
                &pAdapter->llistTunnels,
                NULL, NULL, 0,
                sizeof(TUNNELCB),
                MTAG_TUNNELCB,
                usLlistDepth );

            NdisInitializeNPagedLookasideList(
                &pAdapter->llistVcs,
                NULL, NULL, 0,
                sizeof(VCCB),
                MTAG_VCCB,
                usLlistDepth );

            NdisInitializeNPagedLookasideList(
                &pAdapter->llistTimerQs,
                NULL, NULL, 0,
                sizeof(TIMERQ),
                MTAG_TIMERQ,
                usLlistDepth );

            NdisInitializeNPagedLookasideList(
                &pAdapter->llistControlReceiveds,
                NULL, NULL, 0,
                sizeof(CONTROLRECEIVED),
                MTAG_CTRLRECD,,
                usLlistDepth );

            NdisInitializeNPagedLookasideList(
                &pAdapter->llistPayloadReceiveds,
                NULL, NULL, 0,
                sizeof(PAYLOADRECEIVED),
                MTAG_PAYLRECD,
                usLlistDepth );

            NdisInitializeNPagedLookasideList(
                &pAdapter->llistInCallSetups,
                NULL, NULL, 0,
                sizeof(INCALLSETUP),
                MTAG_INCALL,
                usLlistDepth );
#endif

            InitBufferPool(
                &pAdapter->poolFrameBuffers,
                L2TP_FrameBufferSize
                    + ((tmt == TMT_RawIp) ? IpFixedHeaderSize : 0),
                0, 10, 0,
                TRUE, MTAG_FBUFPOOL );

            InitBufferPool(
                &pAdapter->poolHeaderBuffers,
                L2TP_HeaderBufferSize,
                0, 20, 0,
                TRUE, MTAG_HBUFPOOL );

            InitPacketPool(
                &pAdapter->poolPackets,
                0, 0, 30, 0,
                MTAG_PACKETPOOL );
        }

        // Initialize the TDI extension context.
        //
        TdixInitialize(
            tmt,
            hre,
            ((fDisableUdpXsums) ? TDIXF_DisableUdpXsums : 0),
            L2tpReceive,
            &pAdapter->poolFrameBuffers,
            &pAdapter->tdix );

        // Allocate and zero the VC control block address array.
        //
        {
            ULONG ulSize;

            ulSize = pAdapter->usMaxVcs * sizeof(VCCB*);
            pAdapter->ppVcs = ALLOC_NONPAGED( ulSize, MTAG_VCTABLE );
            TRACE( TL_V, TM_Init, ( "VcTable=$%p", pAdapter->ppVcs ) );
            if (!pAdapter->ppVcs)
            {
                status = NDIS_STATUS_RESOURCES;
                break;
            }

            NdisZeroMemory( pAdapter->ppVcs, ulSize );

            // Allocate the lock that guards the table.
            //
            NdisAllocateSpinLock( &pAdapter->lockVcs );

            // At this point, all VC slots in the table are available.
            //
            pAdapter->lAvailableVcSlots = (LONG )pAdapter->usMaxVcs;

            // Set the initial value of the termination call ID counter.  See
            // GetNextTerminationCallId.
            //
            pAdapter->usNextTerminationCallId = pAdapter->usMaxVcs + 1;

        }

        // Inform NDIS of the attributes of our adapter.  Set the
        // 'MiniportAdapterContext' returned to us by NDIS when it calls our
        // handlers to the address of our adapter control block.  Turn off
        // hardware oriented timeouts.
        //
        NdisMSetAttributesEx(
            MiniportAdapterHandle,
            (NDIS_HANDLE)pAdapter,
            (UINT)-1,
            NDIS_ATTRIBUTE_IGNORE_PACKET_TIMEOUT
                | NDIS_ATTRIBUTE_IGNORE_REQUEST_TIMEOUT,
            NdisInterfaceInternal );

        // Register the address family of our call manager with NDIS for the
        // newly bound adapter.  We use the mini-port form of
        // RegisterAddressFamily instead of the protocol form, though that
        // would also work.  With the protocol form, our internal call manager
        // would have to go thru NDIS to talk to the mini-port instead of just
        // calling directly.  Since the L2TP call manager is not likely to be
        // useful with anything but the L2TP mini-port, this would be a waste.
        // The mini-port form also causes the call manager VC context to
        // automatically map to the mini-port VC context, which is exactly
        // what we want.
        //
        // NDIS notifies all call manager clients of the new family we
        // register.  The TAPI proxy is the only client expected to be
        // interested.  NDISWAN will receive the notification, but ignore it
        // and wait for the TAPI proxy to notify it of the proxied version.
        //
        {
            NDIS_CALL_MANAGER_CHARACTERISTICS ncmc;
            CO_ADDRESS_FAMILY family;

            NdisZeroMemory( &family, sizeof(family) );
            family.MajorVersion = NDIS_MajorVersion;
            family.MinorVersion = NDIS_MinorVersion;
            family.AddressFamily = CO_ADDRESS_FAMILY_TAPI_PROXY;

            NdisZeroMemory( &ncmc, sizeof(ncmc) );
            ncmc.MajorVersion = NDIS_MajorVersion;
            ncmc.MinorVersion = NDIS_MinorVersion;
            ncmc.CmCreateVcHandler = LcmCmCreateVc;
            ncmc.CmDeleteVcHandler = LcmCmDeleteVc;
            ncmc.CmOpenAfHandler = LcmCmOpenAf;
            ncmc.CmCloseAfHandler = LcmCmCloseAf;
            ncmc.CmRegisterSapHandler = LcmCmRegisterSap;
            ncmc.CmDeregisterSapHandler = LcmCmDeregisterSap;
            ncmc.CmMakeCallHandler = LcmCmMakeCall;
            ncmc.CmCloseCallHandler = LcmCmCloseCall;
            ncmc.CmIncomingCallCompleteHandler = LcmCmIncomingCallComplete;
            // no CmAddPartyHandler
            // no CmDropPartyHandler
            ncmc.CmActivateVcCompleteHandler = LcmCmActivateVcComplete;
            ncmc.CmDeactivateVcCompleteHandler = LcmCmDeactivateVcComplete;
            ncmc.CmModifyCallQoSHandler = LcmCmModifyCallQoS;
            ncmc.CmRequestHandler = LcmCmRequest;
            // no CmRequestCompleteHandler

            TRACE( TL_I, TM_Cm, ( "NdisMCmRegAf" ) );
            status = NdisMCmRegisterAddressFamily(
                MiniportAdapterHandle, &family, &ncmc, sizeof(ncmc) );
            TRACE( TL_I, TM_Cm, ( "NdisMCmRegAf=$%x", status ) );
        }
    }
    while (FALSE);

    if (status == NDIS_STATUS_SUCCESS)
    {
        // Add a reference that will eventually be removed by an NDIS call to
        // the LmpHalt handler.
        //
        ReferenceAdapter( pAdapter );
    }
    else
    {
        // Failed, so undo whatever portion succeeded.
        //
        if (pAdapter)
        {
            FreeAdapter( pAdapter );
        }
    }

    TRACE( TL_V, TM_Init, ( "LmpInit=$%08x", status ) );
    return status;
}


VOID
LmpHalt(
    IN NDIS_HANDLE MiniportAdapterContext )

    // Standard 'MiniportHalt' routine called by NDIS to deallocate all
    // resources attached to the adapter.  NDIS does not make any other calls
    // for this mini-port adapter during or after this call.  NDIS will not
    // call this routine when packets indicated as received have not been
    // returned, or when any VC is created and known to NDIS.  Runs at PASSIVE
    // IRQL.
    //
{
    ADAPTERCB* pAdapter;

    TRACE( TL_I, TM_Mp, ( "LmpHalt" ) );

    pAdapter = (ADAPTERCB* )MiniportAdapterContext;
    if (!pAdapter || pAdapter->ulTag != MTAG_ADAPTERCB)
    {
        ASSERT( !"Atag?" );
        return;
    }

    // Don't allow the halt to complete before all timers have completed as
    // this can result in a 0xC7 bugcheck if the driver is immediately
    // unloaded.  All timers should be in the process of terminating before
    // NDIS calls this handler, so this should occur very quickly.
    //
    while (pAdapter->ulTimers)
    {
        TRACE( TL_A, TM_Mp, ( "LmpHalt timers=%d", pAdapter->ulTimers ) );
        WPLOG( LL_A, LM_Mp, ( "LmpHalt timers=%d", pAdapter->ulTimers ) );
        NdisMSleep( 100000 );
    }

    DereferenceAdapter( pAdapter );

    TRACE( TL_V, TM_Mp, ( "LmpHalt done" ) );
}


NDIS_STATUS
LmpReset(
    OUT PBOOLEAN AddressingReset,
    IN NDIS_HANDLE MiniportAdapterContext )

    // Standard 'MiniportReset' routine called by NDIS to reset the driver's
    // software state.
    //
{
    TRACE( TL_I, TM_Mp, ( "LmpReset" ) );

    return NDIS_STATUS_NOT_RESETTABLE;
}


VOID
LmpReturnPacket(
    IN NDIS_HANDLE MiniportAdapterContext,
    IN PNDIS_PACKET Packet )

    // Standard 'MiniportReturnPacket' routine called by NDIS when a packet
    // used to indicate a receive has been released by the driver above.
    //
{
    VCCB* pVc;
    CHAR* pBuffer;
    ADAPTERCB* pAdapter;
    NDIS_BUFFER* pTrimmedBuffer;
    PACKETHEAD* pHead;
    PACKETPOOL* pPool;

    TRACE( TL_N, TM_Mp, ( "LmpReturnPacket" ) );

    // Unpack the context information we stashed earlier.
    //
    pHead = *((PACKETHEAD** )(&Packet->MiniportReserved[ 0 ]));
    pBuffer = *((CHAR** )(&Packet->MiniportReserved[ sizeof(VOID*) ]));

    // Find the adapter from the PACKETHEAD address.
    //
    pPool = PacketPoolFromPacketHead( pHead );
    pAdapter = CONTAINING_RECORD( pPool, ADAPTERCB, poolPackets );
    ASSERT( pAdapter->ulTag == MTAG_ADAPTERCB );

    // Free the descriptor created by NdisCopyBuffer.
    //
    NdisUnchainBufferAtFront( Packet, &pTrimmedBuffer );
    if (pTrimmedBuffer)
    {
        extern ULONG g_ulNdisFreeBuffers;

        NdisFreeBuffer( pTrimmedBuffer );
        NdisInterlockedIncrement( &g_ulNdisFreeBuffers );
    }

    // Free the buffer and packet back to the pools.
    //
    FreeBufferToPool( &pAdapter->poolFrameBuffers, pBuffer, TRUE );
    FreePacketToPool( &pAdapter->poolPackets, pHead, TRUE );

    NdisInterlockedIncrement( &g_lPacketsReturned );

    TRACE( TL_V, TM_Mp, ( "LmpReturnPacket done" ) );
}


NDIS_STATUS
LmpCoActivateVc(
    IN NDIS_HANDLE MiniportVcContext,
    IN OUT PCO_CALL_PARAMETERS CallParameters )

    // Standard 'MiniportCoActivateVc' routine called by NDIS in response to a
    // protocol's request to activate a virtual circuit.
    //
{
    ASSERT( !"LmpCoActVc?" );
    return NDIS_STATUS_SUCCESS;
}


NDIS_STATUS
LmpCoDeactivateVc(
    IN NDIS_HANDLE MiniportVcContext )

    // Standard 'MiniportCoDeactivateVc' routine called by NDIS in response to
    // a protocol's request to de-activate a virtual circuit.
    //
{
    ASSERT( !"LmpCoDeactVc?" );
    return NDIS_STATUS_SUCCESS;
}


VOID
LmpCoSendPackets(
    IN NDIS_HANDLE MiniportVcContext,
    IN PPNDIS_PACKET PacketArray,
    IN UINT NumberOfPackets )

    // Standard 'MiniportCoDeactivateVc' routine called by NDIS in response to
    // a protocol's request to send packets on a virtual circuit.
    //
{
    UINT i;
    NDIS_STATUS status;
    NDIS_PACKET** ppPacket;
    VCCB* pVc;

    TRACE( TL_N, TM_Send, ( "LmpCoSendPackets(%d)", NumberOfPackets ) );

    pVc = (VCCB* )MiniportVcContext;
    ASSERT( pVc->ulTag == MTAG_VCCB );

    for (i = 0, ppPacket = PacketArray;
         i < NumberOfPackets;
         ++i, ++ppPacket)
    {
        NDIS_PACKET* pPacket = *ppPacket;

        // SendPayload sends the packet and eventually calls
        // NdisMCoSendComplete to notify caller of the result.
        //
        NDIS_SET_PACKET_STATUS( pPacket, NDIS_STATUS_PENDING );
        SendPayload( pVc, pPacket );
    }

    TRACE( TL_V, TM_Send, ( "LmpCoSendPackets done" ) );
}


NDIS_STATUS
LmpCoRequest(
    IN NDIS_HANDLE MiniportAdapterContext,
    IN NDIS_HANDLE MiniportVcContext,
    IN OUT PNDIS_REQUEST NdisRequest )

    // Standard 'MiniportCoRequestHandler' routine called by NDIS in response
    // to a protocol's request information from the mini-port.  Unlike the
    // Query/SetInformation handlers that this routine obsoletes, requests are
    // not serialized.
    //
{
    ADAPTERCB* pAdapter;
    VCCB* pVc;
    NDIS_STATUS status;

    TRACE( TL_N, TM_Mp, ( "LmpCoReq" ) );

    pAdapter = (ADAPTERCB* )MiniportAdapterContext;
    if (pAdapter->ulTag != MTAG_ADAPTERCB)
    {
        ASSERT( !"Atag?" );
        return NDIS_STATUS_INVALID_DATA;
    }

    pVc = (VCCB* )MiniportVcContext;
    if (pVc && pVc->ulTag != MTAG_VCCB)
    {
        ASSERT( !"Vtag?" );
        return NDIS_STATUS_INVALID_DATA;
    }

    switch (NdisRequest->RequestType)
    {
        case NdisRequestQueryInformation:
        {
            status = QueryInformation(
                pAdapter,
                pVc,
                NdisRequest->DATA.QUERY_INFORMATION.Oid,
                NdisRequest->DATA.QUERY_INFORMATION.InformationBuffer,
                NdisRequest->DATA.QUERY_INFORMATION.InformationBufferLength,
                &NdisRequest->DATA.QUERY_INFORMATION.BytesWritten,
                &NdisRequest->DATA.QUERY_INFORMATION.BytesNeeded );
            break;
        }

        case NdisRequestSetInformation:
        {
            status = SetInformation(
                pAdapter,
                pVc,
                NdisRequest->DATA.SET_INFORMATION.Oid,
                NdisRequest->DATA.SET_INFORMATION.InformationBuffer,
                NdisRequest->DATA.SET_INFORMATION.InformationBufferLength,
                &NdisRequest->DATA.SET_INFORMATION.BytesRead,
                &NdisRequest->DATA.SET_INFORMATION.BytesNeeded );
            break;
        }

        default:
        {
            status = NDIS_STATUS_NOT_SUPPORTED;
            TRACE( TL_A, TM_Mp, ( "type=%d?", NdisRequest->RequestType ) );
            break;
        }
    }

    TRACE( TL_V, TM_Mp, ( "LmpCoReq=$%x", status ) );
    return status;
}


//-----------------------------------------------------------------------------
// Mini-port utility routines (alphabetically)
// Some are used externally
//-----------------------------------------------------------------------------

VOID
DereferenceAdapter(
    IN ADAPTERCB* pAdapter )

    // Removes a reference from the adapter control block 'pAdapter', and when
    // frees the adapter resources when the last reference is removed.
    //
{
    LONG lRef;

    lRef = NdisInterlockedDecrement( &pAdapter->lRef );

    TRACE( TL_N, TM_Ref, ( "DerefA to %d", lRef ) );
    ASSERT( lRef >= 0 );

    if (lRef == 0)
    {
        FreeAdapter( pAdapter );
    }
}


VOID
FreeAdapter(
    IN ADAPTERCB* pAdapter )

    // Frees all resources allocated for adapter 'pAdapter', including
    // 'pAdapter' itself.
    //
{
    BOOLEAN fSuccess;

    ASSERT( IsListEmpty( &pAdapter->listTunnels ) );

    if (pAdapter->ppVcs)
    {
        FREE_NONPAGED( pAdapter->ppVcs );
    }

    // Setting 'usMaxVcs' to 0 is LmpInitialize's way of telling us that the
    // lookaside lists and pools were not initialized.
    //
    if (pAdapter->usMaxVcs)
    {
        NdisDeleteNPagedLookasideList( &pAdapter->llistWorkItems );
        NdisDeleteNPagedLookasideList( &pAdapter->llistTimerQItems );
        NdisDeleteNPagedLookasideList( &pAdapter->llistControlSents );
        NdisDeleteNPagedLookasideList( &pAdapter->llistPayloadSents );
        NdisDeleteNPagedLookasideList( &pAdapter->llistTunnelWorks );
        NdisDeleteNPagedLookasideList( &pAdapter->llistControlMsgInfos );

#if LLISTALL
        NdisDeleteNPagedLookasideList( &pAdapter->llistTunnels );
        NdisDeleteNPagedLookasideList( &pAdapter->llistVcs );
        NdisDeleteNPagedLookasideList( &pAdapter->llistTimerQs );
        NdisDeleteNPagedLookasideList( &pAdapter->llistControlReceiveds );
        NdisDeleteNPagedLookasideList( &pAdapter->llistPayloadReceiveds );
        NdisDeleteNPagedLookasideList( &pAdapter->llistInCallSetups );
#endif

        fSuccess = FreeBufferPool( &pAdapter->poolFrameBuffers );
        ASSERT( fSuccess );
        fSuccess = FreeBufferPool( &pAdapter->poolHeaderBuffers );
        ASSERT( fSuccess );
        fSuccess = FreePacketPool( &pAdapter->poolPackets );
        ASSERT( fSuccess );
    }

    if (pAdapter->pszPassword)
    {
        FREE_NONPAGED( pAdapter->pszPassword );
    }

    if (pAdapter->pszDriverDesc)
    {
        FREE_NONPAGED( pAdapter->pszDriverDesc );
    }

    if (pAdapter->pszHostName)
    {
        FREE_NONPAGED( pAdapter->pszHostName );
    }

    pAdapter->ulTag = MTAG_FREED;
    FREE_NONPAGED( pAdapter );
}


NDIS_STATUS
GetRegistrySettings(
    IN NDIS_HANDLE WrapperConfigurationContext,
    OUT USHORT* pusMaxVcs,
    OUT TDIXMEDIATYPE* pMediaType,
    OUT L2TPROLE* pOutgoingRole,
    OUT ULONG* pulMaxSendTimeoutMs,
    OUT ULONG* pulInitialSendTimeoutMs,
    OUT ULONG* pulMaxRetransmits,
    OUT ULONG* pulHelloMs,
    OUT ULONG* pulMaxAckDelayMs,
    OUT SHORT* psMaxOutOfOrder,
    OUT USHORT* pusControlReceiveWindow,
    OUT USHORT* pusPayloadReceiveWindow,
    OUT ULONG* pulPayloadSendWindow,
    OUT USHORT* pusLlistDepth,
    OUT CHAR** ppszHostName,
    OUT CHAR** ppszPassword,
    OUT BOOLEAN* pfIgnoreFramingMismatch,
    OUT BOOLEAN* pfExclusiveTunnels,
    OUT HOSTROUTEEXISTS* phre,
    OUT BOOLEAN* pfDisableUdpXsums,
    OUT WCHAR**  ppszDriverDesc )

    // Read this mini-port's registry settings into caller's output variables.
    // 'WrapperConfigurationContext' is the handle to passed to
    // MiniportInitialize.
    //
{
    NDIS_STATUS status;
    NDIS_HANDLE hCfg;
    NDIS_CONFIGURATION_PARAMETER* pncp;

    NdisOpenConfiguration( &status, &hCfg, WrapperConfigurationContext );
    if (status != NDIS_STATUS_SUCCESS)
        return status;

    do
    {
        // (recommended) The number of VCs we must be able to provide.
        //
        {
            NDIS_STRING nstr = NDIS_STRING_CONST( "MaxWanEndpoints" );

            NdisReadConfiguration(
                &status, &pncp, hCfg, &nstr, NdisParameterInteger );
            if (status == NDIS_STATUS_SUCCESS)
            {
                *pusMaxVcs = (USHORT )pncp->ParameterData.IntegerData;

                // Make sure it's a valid value.  The implicit upper bound
                // imposed by the protocol's Tunnel-Id/Call-ID sizes is 65535.
                // Settings above 1000 are not recommended, but will work if
                // huge amounts of memory and bandwidth are available.
                //
                if (*pusMaxVcs < 1)
                {
                    status = NDIS_STATUS_INVALID_DATA;
                    break;
                }
            }
            else
            {
                *pusMaxVcs = 1000;
                status = NDIS_STATUS_SUCCESS;
            }
        }

        // (recommended) The media type to run L2TP over.
        //
        {
            NDIS_STRING nstr = NDIS_STRING_CONST( "VpnMediaType" );

            NdisReadConfiguration(
                &status, &pncp, hCfg, &nstr, NdisParameterInteger );
            if (status == NDIS_STATUS_SUCCESS)
            {
                *pMediaType = (TDIXMEDIATYPE )pncp->ParameterData.IntegerData;

                // Make sure it's a valid type.
                //
                if (*pMediaType != TMT_Udp && *pMediaType != TMT_RawIp)
                {
                    status = NDIS_STATUS_INVALID_DATA;
                    break;
                }
            }
            else
            {
                // No media type in registry.  Default to UDP.
                //
                *pMediaType = TMT_Udp;
                status = NDIS_STATUS_SUCCESS;
            }
        }

        // (optional) The maximum send timeout in milliseconds.
        //
        {
            NDIS_STRING nstr = NDIS_STRING_CONST( "MaxSendTimeoutMs" );

            NdisReadConfiguration(
                &status, &pncp, hCfg, &nstr, NdisParameterInteger );
            if (status == NDIS_STATUS_SUCCESS)
            {
                *pulMaxSendTimeoutMs = pncp->ParameterData.IntegerData;

                // Make sure it's a valid value.
                //
                if (*pulMaxSendTimeoutMs == 0)
                {
                    *pulMaxSendTimeoutMs = 0x7FFFFFFF;
                }
            }
            else
            {
                // No value in registry.  Set a reasonable default.
                //
                *pulMaxSendTimeoutMs = L2TP_DefaultMaxSendTimeoutMs;
                status = NDIS_STATUS_SUCCESS;
            }
        }

        // (optional) The initial send timeout in milliseconds.
        //
        {
            NDIS_STRING nstr = NDIS_STRING_CONST( "InitialSendTimeoutMs" );

            NdisReadConfiguration(
                &status, &pncp, hCfg, &nstr, NdisParameterInteger );
            if (status == NDIS_STATUS_SUCCESS)
            {
                *pulInitialSendTimeoutMs = pncp->ParameterData.IntegerData;

                // Make sure it's a valid value.
                //
                if (*pulInitialSendTimeoutMs == 0)
                {
                    *pulInitialSendTimeoutMs = 0x7FFFFFFF;
                }

                if (*pulInitialSendTimeoutMs > *pulMaxSendTimeoutMs)
                    *pulInitialSendTimeoutMs = *pulMaxSendTimeoutMs;
            }
            else
            {
                // No value in registry.  Set a reasonable default.
                //
                *pulInitialSendTimeoutMs = L2TP_DefaultSendTimeoutMs;
                status = NDIS_STATUS_SUCCESS;
            }
        }

        // (optional) The maximum number of control message retransmissions
        //            before the tunnel is reset.
        //
        {
            NDIS_STRING nstr = NDIS_STRING_CONST( "MaxRetransmits" );

            NdisReadConfiguration(
                &status, &pncp, hCfg, &nstr, NdisParameterInteger );
            if (status == NDIS_STATUS_SUCCESS)
            {
                *pulMaxRetransmits = pncp->ParameterData.IntegerData;
            }
            else
            {
                // No value in registry.  Set a reasonable default.
                //
                *pulMaxRetransmits = L2TP_DefaultMaxRetransmits;
                status = NDIS_STATUS_SUCCESS;
            }
        }

        // (optional) The control Hello timeout in milliseconds.
        //
        {
            NDIS_STRING nstr = NDIS_STRING_CONST( "HelloMs" );

            NdisReadConfiguration(
                &status, &pncp, hCfg, &nstr, NdisParameterInteger );
            if (status == NDIS_STATUS_SUCCESS)
            {
                *pulHelloMs = pncp->ParameterData.IntegerData;
            }
            else
            {
                // No value in registry.  Set a reasonable default.
                //
                *pulHelloMs = L2TP_HelloMs;
                status = STATUS_SUCCESS;
            }
        }

        // (optional) The maximum piggyback delay in milliseconds before
        //            sending a zero payload acknowledgement.
        //
        {
            NDIS_STRING nstr = NDIS_STRING_CONST( "MaxAckDelayMs" );

            NdisReadConfiguration(
                &status, &pncp, hCfg, &nstr, NdisParameterInteger );
            if (status == NDIS_STATUS_SUCCESS)
            {
                *pulMaxAckDelayMs = pncp->ParameterData.IntegerData;
            }
            else
            {
                // No value in registry.  Set a reasonable default.
                //
                *pulMaxAckDelayMs = L2TP_MaxAckDelay;
                status = NDIS_STATUS_SUCCESS;
            }
        }

        // (optional) The maximum number of out-of-order packets to queue.
        //
        {
            NDIS_STRING nstr = NDIS_STRING_CONST( "MaxOutOfOrder" );

            NdisReadConfiguration(
                &status, &pncp, hCfg, &nstr, NdisParameterInteger );
            if (status == NDIS_STATUS_SUCCESS)
            {
                *psMaxOutOfOrder = (SHORT )pncp->ParameterData.IntegerData;

                // Make sure it's not negative and within 1/4 of the possible
                // sequence values to avoid aliasing.  Zero effectively
                // disables out of order handling.
                //
                if (*psMaxOutOfOrder < 0 || *psMaxOutOfOrder > 0x4000)
                {
                    status = NDIS_STATUS_INVALID_DATA;
                    break;
                }
            }
            else
            {
                // No value in registry.  Set a reasonable default.
                //
                *psMaxOutOfOrder = 100;
                status = NDIS_STATUS_SUCCESS;
            }
        }

        // (optional) The role (LNS or LAC) that the adapter will play in
        //            outgoing calls.  The role played for incoming calls is
        //            determined by the role the peer plays in his call
        //            request.
        //
        {
            NDIS_STRING nstr = NDIS_STRING_CONST( "OutgoingRole" );

            NdisReadConfiguration(
                &status, &pncp, hCfg, &nstr, NdisParameterInteger );
            if (status == NDIS_STATUS_SUCCESS)
            {
                *pOutgoingRole = (L2TPROLE )pncp->ParameterData.IntegerData;

                // Make sure it's a valid role.
                //
                if (*pOutgoingRole != LR_Lac && *pOutgoingRole != LR_Lns)
                {
                    status = NDIS_STATUS_INVALID_DATA;
                    break;
                }
            }
            else
            {
                // No role in registry.  Default to LAC.
                //
                *pOutgoingRole = LR_Lac;
                status = NDIS_STATUS_SUCCESS;
            }
        }

        // (optional) The control receive window sent to peer to indicate how
        //            many sent control messages peer may have outstanding.
        //
        {
            NDIS_STRING nstr = NDIS_STRING_CONST( "ControlReceiveWindow" );

            NdisReadConfiguration(
                &status, &pncp, hCfg, &nstr, NdisParameterInteger );
            if (status == NDIS_STATUS_SUCCESS)
            {
                *pusControlReceiveWindow =
                   (USHORT )pncp->ParameterData.IntegerData;
            }
            else
            {
                // No setting in registry.  Set a reasonable default.
                //
                *pusControlReceiveWindow = 8;
                status = NDIS_STATUS_SUCCESS;
            }
        }

        // (optional) The payload receive window sent to peer to indicate how
        //            many send payloads peer may have outstanding on any one
        //            call.  A value of 0 disables all Ns/Nr sequencing on the
        //            payload channel for locally requested calls.
        //
        {
            NDIS_STRING nstr = NDIS_STRING_CONST( "PayloadReceiveWindow" );

            NdisReadConfiguration(
                &status, &pncp, hCfg, &nstr, NdisParameterInteger );
            if (status == NDIS_STATUS_SUCCESS)
            {
                *pusPayloadReceiveWindow =
                   (USHORT )pncp->ParameterData.IntegerData;
            }
            else
            {
                // No setting in registry.  Set a reasonable default.
                //
                // Note: Default changed to 0 (off) from 16 due to performance
                //       study that shows significantly better results without
                //       flow control, presumably due to interference with
                //       higher level timers.
                //
                *pusPayloadReceiveWindow = 0;
                status = NDIS_STATUS_SUCCESS;
            }
        }

        // (optional) The maximum payload send window size reported to
        //            NDISWAN.  Peer may set the actual send window higher or
        //            lower, but if higher this is the actual maximum.
        //
        {
            NDIS_STRING nstr = NDIS_STRING_CONST( "PayloadSendWindow" );

            NdisReadConfiguration(
                &status, &pncp, hCfg, &nstr, NdisParameterInteger );
            if (status == NDIS_STATUS_SUCCESS)
            {
                *pulPayloadSendWindow =
                   (ULONG )pncp->ParameterData.IntegerData;
            }
            else
            {
                // No setting in registry.  Set a reasonable default.
                //
                *pulPayloadSendWindow = 16;
                status = NDIS_STATUS_SUCCESS;
            }
        }

        // (optional) The lookaside list depth ceiling, where higher values
        //            allow this driver to consume more non-paged pool in
        //            return for performance gain at high volumes.  Setting
        //            this value above 'MaxVcs' has no effect.
        //
        {
            NDIS_STRING nstr = NDIS_STRING_CONST( "LookasideDepth" );

            NdisReadConfiguration(
                &status, &pncp, hCfg, &nstr, NdisParameterInteger );
            if (status == NDIS_STATUS_SUCCESS)
            {
                *pusLlistDepth = (USHORT )pncp->ParameterData.IntegerData;
            }
            else
            {
                // No setting in registry.  Set a reasonable default.
                //
                *pusLlistDepth = 30;
                status = NDIS_STATUS_SUCCESS;
            }
        }

        // The host name passed to peer and used as the base of the
        //  call serial number.
        // Host name is required as this is used in hostname MUST AVP.
        {
            NDIS_STRING nstr = NDIS_STRING_CONST( "HostName" );
            
            NdisReadConfiguration(
                &status, &pncp, hCfg, &nstr, NdisParameterString );
            if (status == NDIS_STATUS_SUCCESS)
            {
                *ppszHostName =
                    StrDupNdisStringToA( &pncp->ParameterData.StringData );
                if(!*ppszHostName)
                {
                    status = NDIS_STATUS_RESOURCES;
                }
            }
            else
            {
                // No setting in registry, so use a default.
                //
                *ppszHostName = GetFullHostNameFromRegistry();
                if (!*ppszHostName)
                {
                    *ppszHostName = StrDupSized("NONE", sizeof("NONE"), 0);
                }

                if(*ppszHostName)
                {
                    status = NDIS_STATUS_SUCCESS;
                }
                else
                {
                    status = NDIS_STATUS_RESOURCES;
                }
            }
            
            if(status != NDIS_STATUS_SUCCESS)
            {
                break;
            }
        }


        // (optional) The single password shared with peer for use in
        //            verifying peer's identity.  If specified, authentication
        //            of peer is required, and if not, authentication is not
        //            provided.
        //
        {
            NDIS_STRING nstr = NDIS_STRING_CONST( "Password" );

            NdisReadConfiguration(
                &status, &pncp, hCfg, &nstr, NdisParameterString );
            if (status == NDIS_STATUS_SUCCESS)
            {
                *ppszPassword =
                    StrDupNdisStringToA( &pncp->ParameterData.StringData );
            }
            else
            {
                // No setting in registry...and no default.
                //
                *ppszPassword = NULL;
                status = NDIS_STATUS_SUCCESS;
            }
        }

        // (optional) Buggy peer hedge flag to ignore framing mismatches.
        //
        {
            NDIS_STRING nstr = NDIS_STRING_CONST( "IgnoreFramingMismatch" );

            NdisReadConfiguration(
                &status, &pncp, hCfg, &nstr, NdisParameterInteger );
            if (status == NDIS_STATUS_SUCCESS)
            {
                *pfIgnoreFramingMismatch =
                    (BOOLEAN )!!(pncp->ParameterData.IntegerData);
            }
            else
            {
                // No value in registry.  Set a reasonable default.
                //
                *pfIgnoreFramingMismatch = TRUE;
                status = NDIS_STATUS_SUCCESS;
            }
        }

        // (optional) Flag indicating whether, by default, separate tunnels
        //            are to be created for each outgoing call even if a
        //            tunnel already exists to the same peer.  This setting
        //            can be overridden via L2TP-specific call parameters.
        //
        {
            NDIS_STRING nstr = NDIS_STRING_CONST( "ExclusiveTunnels" );

            NdisReadConfiguration(
                &status, &pncp, hCfg, &nstr, NdisParameterInteger );
            if (status == NDIS_STATUS_SUCCESS)
            {
                *pfExclusiveTunnels =
                    (BOOLEAN )!!(pncp->ParameterData.IntegerData);
            }
            else
            {
                // No value in registry.  Set a default.
                //
                *pfExclusiveTunnels = FALSE;
                status = NDIS_STATUS_SUCCESS;
            }
        }

        // (optional) Flag indicating whether routes created outside this
        //            driver may be used as L2TP host routes.  If the flag is
        //            not set, the pre-existing host routes will cause the
        //            tunnel to close.
        //
        {
            NDIS_STRING nstr = NDIS_STRING_CONST( "UseExistingRoutes" );
            BOOLEAN fDefault;

            fDefault = FALSE;

            NdisReadConfiguration(
                &status, &pncp, hCfg, &nstr, NdisParameterInteger );
            if (status == NDIS_STATUS_SUCCESS)
            {
                *phre = (HOSTROUTEEXISTS )pncp->ParameterData.IntegerData;

                if (*phre != HRE_Use
                    && *phre != HRE_Fail
#if ROUTEWITHREF
                    && *phre != HRE_Reference
#endif
                   )
                {
                    // Bad value in registry.
                    //
                    fDefault = TRUE;
                }
            }
            else
            {
                // No value in registry.
                //
                status = NDIS_STATUS_SUCCESS;
                fDefault = TRUE;
            }

            if (fDefault)
            {
#if ROUTEWITHREF
                // Set default to "reference" as this allows simultaneous L2TP
                // and PPTP connections between the same two peers without
                // host route trashing.
                //
                *phre = HRE_Reference;
#else
                // Set default to "fail" to prevent L2TP from stomping on a
                // PPTP host route.
                //
                *phre = HRE_Fail;
#endif
            }
        }

        // (optional) Flag indicating whether UDP checksums should be disabled
        //            on L2TP payload traffic.
        //
        {
            NDIS_STRING nstr = NDIS_STRING_CONST( "DisableUdpChecksums" );

            NdisReadConfiguration(
                &status, &pncp, hCfg, &nstr, NdisParameterInteger );
            if (status == NDIS_STATUS_SUCCESS)
            {
                *pfDisableUdpXsums =
                    (BOOLEAN )!!(pncp->ParameterData.IntegerData);
            }
            else
            {

                // No value in registry.  Set a default.  The L2TP draft says
                // implementation MUST default to "enabled".
                //
                *pfDisableUdpXsums = TRUE;
                status = NDIS_STATUS_SUCCESS;
            }
        }

        // (required) The driver description string, which is reported to TAPI
        //            as the L2TP line name.
        //
        {
            NDIS_STRING nstr = NDIS_STRING_CONST( "DriverDesc" );

            NdisReadConfiguration(
                &status, &pncp, hCfg, &nstr, NdisParameterString );
            if (status == NDIS_STATUS_SUCCESS)
            {
                *ppszDriverDesc =
                    StrDupNdisString( &pncp->ParameterData.StringData );
            }
            else
            {
                // No setting in registry...and no default.
                //
                *ppszDriverDesc = NULL;
                status = NDIS_STATUS_SUCCESS;
            }
        }
    }
    while (FALSE);

    NdisCloseConfiguration( hCfg );

    TRACE( TL_N, TM_Init,
        ( "Reg: vcs=%d mt=%d or=%d lld=%d hto=%d ooo=%d mad=%d dx=%d",
        *pusMaxVcs,
        *pMediaType,
        *pOutgoingRole,
        (ULONG )*pusLlistDepth,
        *pulHelloMs,
        (INT )*psMaxOutOfOrder,
        *pulMaxAckDelayMs,
        (UINT )*pfDisableUdpXsums ) );
    TRACE( TL_N, TM_Init,
        ( "Reg: mto=%d ito=%d mrt=%d crw=%d prw=%d psw=%d ifm=%d xt=%d xr=%d",
        *pulMaxSendTimeoutMs,
        *pulInitialSendTimeoutMs,
        *pulMaxRetransmits,
        (UINT )*pusControlReceiveWindow,
        (UINT )*pusPayloadReceiveWindow,
        (UINT )*pulPayloadSendWindow,
        (UINT )*pfIgnoreFramingMismatch,
        (UINT )*pfExclusiveTunnels,
        (UINT )*phre));
    TRACE( TL_N, TM_Init,
        ( "Reg: hn=\"%s\" pw=\"%s\"",
        ((*ppszHostName) ? *ppszHostName : ""),
        ((*ppszPassword) ? *ppszPassword : "") ) );

    return status;
}


NDIS_STATUS
QueryInformation(
    IN ADAPTERCB* pAdapter,
    IN VCCB* pVc,
    IN NDIS_OID Oid,
    IN PVOID InformationBuffer,
    IN ULONG InformationBufferLength,
    OUT PULONG BytesWritten,
    OUT PULONG BytesNeeded )

    // Handle QueryInformation requests.  Arguments are as for the standard
    // NDIS 'MiniportQueryInformation' handler except this routine does not
    // count on being serialized with respect to other requests.
    //
{
    NDIS_STATUS status;
    ULONG ulInfo;
    VOID* pInfo;
    ULONG ulInfoLen;

    status = NDIS_STATUS_SUCCESS;

    // The cases in this switch statement find or create a buffer containing
    // the requested information and point 'pInfo' at it, noting it's length
    // in 'ulInfoLen'.  Since many of the OIDs return a ULONG, a 'ulInfo'
    // buffer is set up as the default.
    //
    ulInfo = 0;
    pInfo = &ulInfo;
    ulInfoLen = sizeof(ulInfo);

    switch (Oid)
    {
        case OID_GEN_MAXIMUM_LOOKAHEAD:
        {
            // Report the maximum number of bytes we can always provide as
            // lookahead data on receive indications.  We always indicate full
            // packets so this is the same as the receive block size.  And
            // since we always allocate enough for a full packet, the receive
            // block size is the same as the frame size.
            //
            TRACE( TL_N, TM_Mp, ( "QInfo(OID_GEN_MAXIMUM_LOOKAHEAD)" ) );
            ulInfo = L2TP_MaxFrameSize;
            break;
        }

        case OID_GEN_MAC_OPTIONS:
        {
            // Report a bitmask defining optional properties of the driver.
            //
            // NDIS_MAC_OPTION_COPY_LOOKAHEAD_DATA promises that our receive
            // buffer is not on a device-specific card.
            //
            // NDIS_MAC_OPTION_TRANSFERS_NOT_PEND promises we won't return
            // NDIS_STATUS_PENDING from our TransferData handler which is true
            // since we don't have one.
            //
            TRACE( TL_N, TM_Mp, ( "QInfo(OID_GEN_MAC_OPTIONS)" ) );
            ulInfo = NDIS_MAC_OPTION_COPY_LOOKAHEAD_DATA
                     | NDIS_MAC_OPTION_TRANSFERS_NOT_PEND;
            break;
        }

        case OID_WAN_MEDIUM_SUBTYPE:
        {
            // Report the media subtype we support.  NDISWAN may use this in
            // the future (doesn't now) to provide framing differences for
            // different media.
            //
            TRACE( TL_N, TM_Mp, ( "QInfo(OID_WAN_MEDIUM_SUBTYPE)" ) );
            ulInfo = NdisWanMediumL2TP;
            break;
        }

        case OID_WAN_CO_GET_INFO:
        {
            // Report the capabilities of the adapter.
            //
            TRACE( TL_N, TM_Mp, ( "QInfo(OID_WAN_CO_GET_INFO)" ) );
            pInfo = &pAdapter->info;
            ulInfoLen = sizeof(NDIS_WAN_CO_INFO);
            break;
        }

        case OID_WAN_CO_GET_LINK_INFO:
        {
            // Report the current state of the link.
            //
            TRACE( TL_N, TM_Mp, ( "QInfo(OID_WAN_CO_GET_LINK_INFO)" ) );

            if (!pVc)
            {
                return NDIS_STATUS_INVALID_DATA;
            }

            pInfo = &pVc->linkinfo;
            ulInfoLen = sizeof(NDIS_WAN_CO_GET_LINK_INFO);
            break;
        }

        case OID_WAN_CO_GET_COMP_INFO:
        {
            // Report the type of compression we provide, which is none.
            //
            TRACE( TL_N, TM_Mp, ( "QInfo(OID_WAN_CO_GET_COMP_INFO)" ) );
            status = NDIS_STATUS_NOT_SUPPORTED;
            ulInfoLen = 0;
            break;
        }

        case OID_WAN_CO_GET_STATS_INFO:
        {
            // Because L2TP doesn't do compression, NDISWAN will use it's own
            // statistics and not query ours.
            //
            ASSERT( !"OID_WAN_CO_GET_STATS_INFO?" );
            status = NDIS_STATUS_NOT_SUPPORTED;
            ulInfoLen = 0;
            break;
        }

        case OID_GEN_SUPPORTED_LIST:
        {
            static ULONG aulSupportedOids[] = {
                OID_GEN_SUPPORTED_LIST,
                OID_GEN_MAXIMUM_LOOKAHEAD,
                OID_GEN_MAC_OPTIONS,
                OID_WAN_MEDIUM_SUBTYPE,
                OID_WAN_CO_GET_INFO,
                OID_WAN_CO_GET_LINK_INFO,
                OID_WAN_CO_SET_LINK_INFO,
                OID_CO_TAPI_CM_CAPS,
                OID_CO_TAPI_LINE_CAPS,
                OID_CO_TAPI_ADDRESS_CAPS,
                OID_CO_TAPI_GET_CALL_DIAGNOSTICS
            };

            TRACE( TL_N, TM_Mp, ( "QInfo(OID_GEN_SUPPORTED_LIST)" ) );
            pInfo = aulSupportedOids;
            ulInfoLen = sizeof(aulSupportedOids);
            break;
        }

#if 0
        // These OIDs are mandatory according to current doc, but since
        // NDISWAN never requests them they are omitted.
        //
        case OID_GEN_HARDWARE_STATUS:
        case OID_GEN_MEDIA_SUPPORTED:
        case OID_GEN_MEDIA_IN_USE:
        case OID_GEN_MEDIA_IN_USE:
        case OID_GEN_MAXIMUM_FRAME_SIZE:
        case OID_GEN_LINK_SPEED:
        case OID_GEN_TRANSMIT_BUFFER_SPACE:
        case OID_GEN_RECEIVE_BUFFER_SPACE:
        case OID_GEN_TRANSMIT_BLOCK_SIZE:
        case OID_GEN_RECEIVE_BLOCK_SIZE:
        case OID_GEN_VENDOR_ID:
        case OID_GEN_VENDOR_DESCRIPTION:
        case OID_GEN_VENDOR_DRIVER_VERSION:
        case OID_GEN_CURRENT_PACKET_FILTER:
        case OID_GEN_CURRENT_LOOKAHEAD:
        case OID_GEN_DRIVER_VERSION:
        case OID_GEN_MAXIMUM_TOTAL_SIZE:
        case OID_GEN_MAC_OPTIONS:
        case OID_GEN_MEDIA_CONNECT_STATUS:
        case OID_GEN_MAXIMUM_SEND_PACKETS:
        case OID_WAN_PERMANENT_ADDRESS:
        case OID_WAN_CURRENT_ADDRESS:
        case OID_WAN_QUALITY_OF_SERVICE:
        case OID_WAN_LINE_COUNT:
#endif
        default:
        {
            TRACE( TL_A, TM_Mp, ( "Q-OID=$%08x?", Oid ) );
            status = NDIS_STATUS_NOT_SUPPORTED;
            ulInfoLen = 0;
            break;
        }
    }

    if (ulInfoLen > InformationBufferLength)
    {
        // Caller's buffer is too small.  Tell him what he needs.
        //
        *BytesNeeded = ulInfoLen;
        status = NDIS_STATUS_INVALID_LENGTH;
    }
    else
    {
        // Copy the found result to caller's buffer.
        //
        if (ulInfoLen > 0)
        {
            NdisMoveMemory( InformationBuffer, pInfo, ulInfoLen );
            DUMPDW( TL_N, TM_Mp, pInfo, ulInfoLen );
        }

        *BytesNeeded = *BytesWritten = ulInfoLen;
    }

    return status;
}


VOID
ReferenceAdapter(
    IN ADAPTERCB* pAdapter )

    // Adds areference to the adapter block, 'pAdapter'.
    //
{
    LONG lRef;

    lRef = NdisInterlockedIncrement( &pAdapter->lRef );

    TRACE( TL_N, TM_Ref, ( "RefA to %d", lRef ) );
}


NDIS_STATUS
SetInformation(
    IN ADAPTERCB* pAdapter,
    IN VCCB* pVc,
    IN NDIS_OID Oid,
    IN PVOID InformationBuffer,
    IN ULONG InformationBufferLength,
    OUT PULONG BytesRead,
    OUT PULONG BytesNeeded )

    // Handle SetInformation requests.  Arguments are as for the standard NDIS
    // 'MiniportQueryInformation' handler except this routine does not count
    // on being serialized with respect to other requests.
    //
{
    NDIS_STATUS status;

    status = NDIS_STATUS_SUCCESS;

    switch (Oid)
    {
        case OID_WAN_CO_SET_LINK_INFO:
        {
            // Read new link state settings.
            //
            TRACE( TL_N, TM_Mp, ( "SInfo(OID_WAN_CO_SET_LINK_INFO)" ) );
            if (InformationBufferLength < sizeof(NDIS_WAN_CO_SET_LINK_INFO))
            {
                status = NDIS_STATUS_INVALID_LENGTH;
                *BytesRead = 0;
            }
            else
            {
                if (!pVc)
                    return NDIS_STATUS_INVALID_DATA;

                ASSERT( sizeof(pVc->linkinfo)
                    == sizeof(NDIS_WAN_CO_SET_LINK_INFO) );

                NdisMoveMemory( &pVc->linkinfo, InformationBuffer,
                    sizeof(pVc->linkinfo) );
                DUMPB( TL_N, TM_Mp, &pVc->linkinfo, sizeof(pVc->linkinfo) );

                *BytesRead = sizeof(NDIS_WAN_CO_SET_LINK_INFO);
            }

            *BytesNeeded = sizeof(NDIS_WAN_CO_SET_LINK_INFO);
        }
        break;

        case OID_WAN_CO_SET_COMP_INFO:
        {
            // L2TP doesn't provide compression.
            //
            TRACE( TL_N, TM_Mp, ( "SInfo(OID_WAN_CO_SET_COMP_INFO)" ) );
            status = NDIS_STATUS_NOT_SUPPORTED;
            *BytesRead = *BytesNeeded = 0;
            break;
        }

#if 0
        // These OIDs are mandatory according to current doc, but since
        // NDISWAN never requests them they are omitted.
        //
        case OID_GEN_CURRENT_PACKET_FILTER:
        case OID_GEN_CURRENT_LOOKAHEAD:
        case OID_GEN_PROTOCOL_OPTIONS:
        case OID_WAN_PROTOCOL_TYPE:
        case OID_WAN_HEADER_FORMAT:
#endif
        default:
        {
            TRACE( TL_A, TM_Mp, ( "S-OID=$%08x?", Oid ) );
            status = NDIS_STATUS_NOT_SUPPORTED;
            *BytesRead = *BytesNeeded = 0;
            break;
        }
    }

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ndis\rasl2tp\main.c ===
// Copyright (c) 1997, Microsoft Corporation, all rights reserved
//
// main.c
// RAS L2TP WAN mini-port/call-manager driver
// Main routine (DriverEntry) and global data definitions
//
// 01/07/97 Steve Cobb


#include "l2tpp.h"

#include "main.tmh"

//-----------------------------------------------------------------------------
// Local prototypes
//-----------------------------------------------------------------------------

NDIS_STATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath );

// Mark routine to be unloaded after initialization.
//
#pragma NDIS_INIT_FUNCTION(DriverEntry)

PDRIVER_OBJECT g_DriverObject = NULL;

VOID LmpUnload(
    PVOID DriverObject)
{
    if(g_DriverObject != NULL)
    {
        WPP_CLEANUP(g_DriverObject);
    }
}

//-----------------------------------------------------------------------------
// Routines
//-----------------------------------------------------------------------------

NDIS_STATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath )

    // Standard 'DriverEntry' driver initialization entrypoint called by the
    // I/0 system at IRQL PASSIVE_LEVEL before any other call to the driver.
    //
    // On NT, 'DriverObject' is the driver object created by the I/0 system
    // and 'RegistryPath' specifies where driver specific parameters are
    // stored.  These arguments are opaque to this driver (and should remain
    // so for portability) which only forwards them to the NDIS wrapper.
    //
    // Returns the value returned by NdisMRegisterMiniport, per the doc on
    // "DriverEntry of NDIS Miniport Drivers".
    //
{
    NDIS_STATUS status;
    NDIS_MINIPORT_CHARACTERISTICS nmc;
    NDIS_HANDLE NdisWrapperHandle;

    TRACE( TL_N, TM_Init, ( "DriverEntry" ) );

    // Register  this driver with the NDIS wrapper.  This call must occur
    // before any other NdisXxx calls.
    //
    NdisMInitializeWrapper(
        &NdisWrapperHandle, DriverObject, RegistryPath, NULL );

    // Set up the mini-port characteristics table that tells NDIS how to call
    // our mini-port.
    //
    NdisZeroMemory( &nmc, sizeof(nmc) );

    nmc.MajorNdisVersion = NDIS_MajorVersion;
    nmc.MinorNdisVersion = NDIS_MinorVersion;
    nmc.Reserved = NDIS_USE_WAN_WRAPPER;
    // no CheckForHangHandler
    // no DisableInterruptHandler
    // no EnableInterruptHandler
    nmc.HaltHandler = LmpHalt;
    // no HandleInterruptHandler
    nmc.InitializeHandler = LmpInitialize;
    // no ISRHandler
    // no QueryInformationHandler (see CoRequestHandler)
    nmc.ResetHandler = LmpReset;
    // no SendHandler (see CoSendPacketsHandler)
    // no WanSendHandler (see CoSendPacketsHandler)
    // no SetInformationHandler (see CoRequestHandler)
    // no TransferDataHandler
    // no WanTransferDataHandler
    nmc.ReturnPacketHandler = LmpReturnPacket;
    // no SendPacketsHandler (see CoSendPacketsHandler)
    // no AllocateCompleteHandler
    nmc.CoActivateVcHandler = LmpCoActivateVc;
    nmc.CoDeactivateVcHandler = LmpCoDeactivateVc;
    nmc.CoSendPacketsHandler = LmpCoSendPackets;
    nmc.CoRequestHandler = LmpCoRequest;

    // Register this driver as the L2TP mini-port.  This will result in NDIS
    // calling back at LmpInitialize.
    //
    TRACE( TL_V, TM_Init, ( "NdisMRegMp" ) );
    status = NdisMRegisterMiniport( NdisWrapperHandle, &nmc, sizeof(nmc) );
    TRACE( TL_A, TM_Init, ( "NdisMRegMp=$%x", status ) );

    if (status == NDIS_STATUS_SUCCESS)
    {
        {
            extern CALLSTATS g_stats;
            extern NDIS_SPIN_LOCK g_lockStats;

            NdisZeroMemory( &g_stats, sizeof(g_stats) );
            NdisAllocateSpinLock( &g_lockStats );
        }

#ifdef PSDEBUG
        {
            extern LIST_ENTRY g_listDebugPs;
            extern NDIS_SPIN_LOCK g_lockDebugPs;

            InitializeListHead( &g_listDebugPs );
            NdisAllocateSpinLock( &g_lockDebugPs );
        }
#endif

        // WPP tracing support
        NdisMRegisterUnloadHandler(NdisWrapperHandle, LmpUnload);
 
        g_DriverObject = DriverObject;
        WPP_INIT_TRACING(DriverObject, RegistryPath);
    }
    else
    {
        NdisTerminateWrapper( NdisWrapperHandle, NULL );
    }

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ndis\rasl2tp\receive.c ===
// Copyright (c) 1997, Microsoft Corporation, all rights reserved
//
// receive.c
// RAS L2TP WAN mini-port/call-manager driver
// Receive routines
//
// 01/07/97 Steve Cobb


#include "l2tpp.h"

#include "receive.tmh"

extern LONG g_lPacketsIndicated;


//-----------------------------------------------------------------------------
// Local prototypes (alphabetically)
//-----------------------------------------------------------------------------

SHORT
CompareSequence(
    USHORT us1,
    USHORT us2 );

VOID
ControlAcknowledged(
    IN TUNNELCB* pTunnel,
    IN USHORT usReceivedNr );

VOID
ControlAckTimerEvent(
    IN TIMERQITEM* pItem,
    IN VOID* pContext,
    IN TIMERQEVENT event );

USHORT
ExplodeAvpHeader(
    IN CHAR* pAvp,
    IN USHORT usMaxAvpLength,
    OUT AVPINFO* pInfo );

VOID
ExplodeControlAvps(
    IN CHAR* pFirstAvp,
    IN CHAR* pEndOfBuffer,
    OUT CONTROLMSGINFO* pControl );

USHORT
ExplodeL2tpHeader(
    IN CHAR* pL2tpHeader,
    IN ULONG ulBufferLength,
    IN OUT L2TPHEADERINFO* pInfo );

USHORT
GetAvpValueFixedAch(
    IN AVPINFO* pAvp,
    IN USHORT usArraySize,
    OUT CHAR** ppch );

USHORT
GetAvpValueFixedAul(
    IN AVPINFO* pAvp,
    IN USHORT usArraySize,
    OUT UNALIGNED ULONG** paulArray );

USHORT
GetAvpValueFlag(
    IN AVPINFO* pAvp,
    OUT UNALIGNED BOOLEAN* pf );

USHORT
GetAvpValueUl(
    IN AVPINFO* pAvp,
    OUT UNALIGNED ULONG** ppul );

USHORT
GetAvpValueUs(
    IN AVPINFO* pAvp,
    OUT UNALIGNED USHORT** ppus );

USHORT
GetAvpValue2UsAndVariableAch(
    IN AVPINFO* pAvp,
    OUT UNALIGNED USHORT** ppus1,
    OUT UNALIGNED USHORT** ppus2,
    OUT CHAR** ppch,
    OUT USHORT* pusArraySize );

USHORT
GetAvpValueVariableAch(
    IN AVPINFO* pAvp,
    OUT CHAR** ppch,
    OUT USHORT* pusArraySize );

VOID
GetCcAvps(
    IN TUNNELCB* pTunnel,
    IN CONTROLMSGINFO* pControl,
    OUT USHORT* pusResult,
    OUT USHORT* pusError );

VOID
HelloTimerEvent(
    IN TIMERQITEM* pItem,
    IN VOID* pContext,
    IN TIMERQEVENT event );

VOID
IndicateReceived(
    IN VCCB* pVc,
    IN CHAR* pBuffer,
    IN ULONG ulOffset,
    IN ULONG ulLength,
    IN LONGLONG llTimeReceived );

BOOLEAN
LookUpTunnelAndVcCbs(
    IN ADAPTERCB* pAdapter,
    IN USHORT* pusTunnelId,
    IN USHORT* pusCallId,
    IN L2TPHEADERINFO* pHeader,
    IN CONTROLMSGINFO* pControl,
    OUT TUNNELCB** ppTunnel,
    OUT VCCB** ppVc );

VOID
PayloadAcknowledged(
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN USHORT usReceivedNr );

VOID
PayloadAckTimerEvent(
    IN TIMERQITEM* pItem,
    IN VOID* pContext,
    IN TIMERQEVENT event );

BOOLEAN
ReceiveControl(
    IN ADAPTERCB* pAdapter,
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN CHAR* pBuffer,
    IN ULONG ulAvpOffset,
    IN ULONG ulAvpLength,
    IN TDIXRDGINFO* pRdg,
    IN L2TPHEADERINFO* pInfo,
    IN CONTROLMSGINFO* pControl );

BOOLEAN
ReceiveFromOutOfOrder(
    IN VCCB* pVc );

BOOLEAN
ReceivePayload(
    IN ADAPTERCB* pAdapter,
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN CHAR* pBuffer,
    IN ULONG ulPayloadOffset,
    IN ULONG ulPayloadLength,
    IN L2TPHEADERINFO* pInfo );

VOID
ScheduleControlAck(
    IN TUNNELCB* pTunnel,
    IN USHORT usMsgTypeToAcknowledge );

VOID
SchedulePayloadAck(
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc );

VCCB*
VcCbFromCallId(
    IN TUNNELCB* pTunnel,
    IN USHORT usCallId );

VOID
ZombieAckIfNecessary(
    IN TUNNELCB* pTunnel,
    IN L2TPHEADERINFO* pHeader,
    IN CONTROLMSGINFO* pControl );

//-----------------------------------------------------------------------------
// Main receive handlers
//-----------------------------------------------------------------------------

VOID
L2tpReceive(
    IN TDIXCONTEXT* pTdix,
    IN TDIXRDGINFO* pRdg,
    IN CHAR* pBuffer,
    IN ULONG ulOffset,
    IN ULONG ulBufferLength )

    // TDIXRECEIVEDG handler that receives all incoming L2TP traffic.  'PTdix'
    // is our TDI extension context.  'PRdg' points to the RDGINFO context
    // 'PBuffer' is the address of the virtual buffer associated with an NDIS
    // buffer from our pool passed to TDIX during initialization.  We are
    // responsible for eventually calling FreeBufferToPool on 'pBuffer'.
    // 'UlOffset' is the offset to the first usable data in 'pBuffer'.
    // 'UlBufferLen' is the data byte count of 'pBuffer'.
    //
{
    USHORT usXError;
    NDIS_STATUS status;
    L2TPHEADERINFO info;
    CONTROLMSGINFO* pControl;
    ADAPTERCB* pAdapter;
    TUNNELCB* pTunnel;
    VCCB* pVc;
    BOOLEAN fFreeBuffer;
    ULONG ulAvpOffset = 0;
    ULONG ulAvpLength = 0;
    
    TDIXIPADDRESS* pAddress = &pRdg->source; 

    DUMPW( TL_A, TM_MDmp, pBuffer + ulOffset, 16 );

    pAdapter = CONTAINING_RECORD( pTdix, ADAPTERCB, tdix );

    fFreeBuffer = TRUE;
    pTunnel = NULL;
    pVc = NULL;
    pControl = NULL;

    do
    {
        // Parse the packet's L2TP header into a conveniently usable form,
        // checking that it is consistent with itself and indicates a protocol
        // version we know.
        //
        if(ulOffset >= ulBufferLength || (ulBufferLength - ulOffset < L2TP_MinHeaderSize))
        {
            // Invalid length
            TRACE( TL_A, TM_Recv, ( "Discard: invalid recv buffer length" ) );
            WPLOG( LL_A, LM_Recv, ( "Discard: invalid recv buffer length" ) );
            break;
        }
        
        usXError = ExplodeL2tpHeader(pBuffer + ulOffset, ulBufferLength - ulOffset, &info );
        if (usXError != GERR_None)
        {
            // Not a coherent L2TP header.  Discard the packet.
            //
            TRACE( TL_A, TM_Recv, ( "Discard: invalid L2TP Header" ) );
            WPLOG( LL_A, LM_Recv, ( "Discard: invalid L2TP Header" ) );
            break;
        }

        ASSERT( info.ulDataLength <= L2TP_MaxFrameSize );

        if (*info.pusBits & HBM_T)
        {
        
            WPLOG( LL_M, LM_CMsg,
                ( "RECV <- %!IPADDR!/%d Length=%d, Tid %d, Cid %d, Ns=%d, Nr=%d",
                pAddress->ulIpAddress, ntohs(pAddress->sUdpPort), 
                ulBufferLength - ulOffset, *info.pusTunnelId, *info.pusCallId, 
                info.pusNs ? *info.pusNs : 0, info.pusNr ? *info.pusNr : 0) );
                
            // Explode the control message into the conveniently usable
            // 'control' form, while checking it for coherency.  This must be
            // done here so the LookUp routine can peek ahead at the assigned
            // call ID in CallDisconnNotify, if necessary.  Ugly, but that's
            // the way L2TP is defined.
            //
            pControl = ALLOC_CONTROLMSGINFO( pAdapter );
            if (pControl)
            {
                ulAvpOffset = (ULONG )(info.pData - pBuffer);
                ulAvpLength = info.ulDataLength;

                if (ulAvpLength)
                {
                    ExplodeControlAvps(
                        pBuffer + ulAvpOffset,
                        pBuffer + ulAvpOffset + ulAvpLength,
                        pControl );
                }
                else
                {
                    // No AVPs.  Most likely a ZACK.
                    //
                    pControl->usXError = GERR_BadValue;
                }
            }
            else
            {
                TRACE( TL_A, TM_Recv, ( "***Failed to allocate CONTROLMSGINFO" ) );
                WPLOG( LL_A, LM_Recv, ( "***Failed to allocate CONTROLMSGINFO" ) );
                break;
            }
        }

        // Find the tunnel and VC control blocks based on the header values.
        //
        if (!LookUpTunnelAndVcCbs(
                pAdapter, info.pusTunnelId, info.pusCallId,
                &info, pControl, &pTunnel, &pVc ))
        {
            // Invalid Tunnel-ID/Call-ID combination.  Discard the packet.
            // Zombie acknowledge may have been performed if the packet was a
            // CDN.
            //
            // The draft/RFC says the tunnel should be closed and restarted on
            // receipt of a malformed Control Connection message.  Seems
            // pretty harsh.  For now, just discard such packets.
            //
            break;
        }

        if (pTunnel)
        {
            // Verify this packet comes from the right source address
            if(pTunnel->address.ulIpAddress != pAddress->ulIpAddress)
            {
                // Drop this packet
                break;
            }

            // Any message received on a tunnel resets it's Hello timer.
            //
            ResetHelloTimer( pTunnel );
        }
        
        if (*info.pusBits & HBM_T)
        {
            // It's a tunnel or call control packet.
            //
            if (pControl)
            {
                fFreeBuffer =
                    ReceiveControl(
                        pAdapter, pTunnel, pVc,
                        pBuffer, ulAvpOffset, ulAvpLength,
                        pRdg, &info, pControl );
            }
        }
        else
        {
            // It's a VC payload packet.
            //
            if (!pVc)
            {
                TRACE( TL_A, TM_Recv, ( "Payload w/o VC?" ) );
                WPLOG( LL_A, LM_Recv, ( "Payload w/o VC?" ) );
                break;
            }

#if 0
            // !!! This is a hack to force NDISWAN into PPP framing mode.
            // Need a cleaner way to do this, or simply have NDISWAN assume it
            // for L2TP links.  (NDISWAN bug 152167)
            //
            if (pVc->usNr == 0)
            {
                CHAR* pBufferX;

                pBufferX = GetBufferFromPool( &pAdapter->poolFrameBuffers );
                if (pBufferX)
                {
                    pBufferX[ 0 ] = (CHAR )0xFF;
                    pBufferX[ 1 ] = (CHAR )0x03;
                    pBufferX[ 2 ] = (CHAR )0xC0;
                    pBufferX[ 3 ] = (CHAR )0x21;
                    pBufferX[ 4 ] = (CHAR )0x01;
                    pBufferX[ 5 ] = (CHAR )0x06;

                    IndicateReceived( pVc, pBufferX, 0, 6, (ULONGLONG )0 );
                }
            }
#endif

            if (ReferenceCall( pVc ))
            {
                fFreeBuffer =
                    ReceivePayload(
                        pAdapter, pTunnel, pVc,
                        pBuffer,
                        (ULONG )(info.pData - pBuffer),
                        info.ulDataLength,
                        &info );

                DereferenceCall( pVc );
            }
            else
            {
                TRACE( TL_A, TM_Recv, ( "Discard: Call $%p not active", pVc ) );
                WPLOG( LL_A, LM_Recv, ( "Discard: Call $%p not active", pVc ) );
            }
        }
    }
    while (FALSE);

    if (pControl)
    {
        FREE_CONTROLMSGINFO( pAdapter, pControl );
    }

    if (fFreeBuffer)
    {
        FreeBufferToPool( &pAdapter->poolFrameBuffers, pBuffer, TRUE );
    }

    if (pTunnel)
    {
        DereferenceTunnel( pTunnel );
    }

    if (pVc)
    {
        DereferenceVc( pVc );
    }
}


BOOLEAN
ReceiveControl(
    IN ADAPTERCB* pAdapter,
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN CHAR* pBuffer,
    IN ULONG ulAvpOffset,
    IN ULONG ulAvpLength,
    IN TDIXRDGINFO* pRdg,
    IN L2TPHEADERINFO* pInfo,
    IN CONTROLMSGINFO* pControl )

    // Receive processing for control packet in 'pBuffer'.  The AVPs following
    // the header start at 'ulAvpOffset' and are 'ulAvpLength' bytes long.
    // 'PBuffer' is the receive buffer TDIX retrieved with
    // 'GetBufferFromPool'.  'PAdapter' is the adapter control block.
    // 'PTunnel' and 'pVc' are the tunnel and VC control blocks associated
    // with the received buffer, or NULL if none.  'pAddress' is the IP
    // address/port of the sending peer.  'PInfo' is the exploded header
    // information.  'PControl' is the control message information, which was
    // exploded earlier.
    //
    // Returns true if caller should free 'pBuffer', or false if this routine
    // has taken ownership of the buffer and will see it's freed.
    //
{
    LIST_ENTRY* pLink;
    BOOLEAN fCallerFreesBuffer;
    SHORT sDiff;
    VCCB** ppVcs;
    ULONG ulcpVcs;

    TDIXIPADDRESS* pAddress = &pRdg->source; 

    TRACE( TL_V, TM_Recv, ( "ReceiveControl" ) );

    ASSERT( !(pVc && !pTunnel) );

    if (ulAvpLength > 0)
    {
        if (pControl->usXError != GERR_None)
        {
            // The message was incoherent or contained "mandatory" AVPs we
            // don't recognize.
            //
            if (pVc && pControl->usXError == GERR_BadValue)
            {
                // "Bad values", which includes unrecognized mandatories,
                // terminate the call.
                //
                ScheduleTunnelWork(
                    pTunnel, pVc, FsmCloseCall,
                    (ULONG_PTR )CRESULT_GeneralWithError,
                    (ULONG_PTR )pControl->usXError,
                    0, 0, FALSE, FALSE );
            }
            else if (pTunnel)
            {
                // Any other corruption terminates the tunnel.
                //
                ScheduleTunnelWork(
                    pTunnel, NULL, FsmCloseTunnel,
                    (ULONG_PTR )TRESULT_GeneralWithError,
                    (ULONG_PTR )pControl->usXError,
                    0, 0, FALSE, FALSE );
            }

            return TRUE;
        }

        if (!pTunnel)
        {
            // IPSec should ensure this is valid source IP address.
            ASSERT(pAddress->ulIpAddress != 0 &&
                !IPADDR_IS_BROADCAST(pAddress->ulIpAddress) &&
                !IPADDR_IS_MULTICAST(pAddress->ulIpAddress));
        
            if (*(pControl->pusMsgType) == CMT_SCCRQ
                && pControl->pusAssignedTunnelId
                && *(pControl->pusAssignedTunnelId) != 0)
            {
                // Peer wants to start a new tunnel.  Find a tunnel block with
                // peer's IP address and assigned Tunnel-ID, or create, if
                // necessary.  The returned block is linked in the adapter's
                // list and and referenced.  The reference is the one for peer
                // initiation, i.e. case (b).
                //
                // If this is a retransmit SCCRQ, this is undone after the
                // sequence check below.  It must be done/undone rather than
                // never done because each message, including retransmits,
                // must have Ns/Nr processing performed and that processing
                // requires a tunnel control block.
                //
                pTunnel = SetupTunnel(
                    pAdapter, pAddress->ulIpAddress, pAddress->sUdpPort,
                    *(pControl->pusAssignedTunnelId), FALSE );

                if (!pTunnel)
                {
                    return TRUE;
                }
            }
            else
            {
                // Don't know what tunnel the message if for and it's not a
                // "create new tunnel" request, so there's nothing useful to
                // do.  Ignore it.
                //
                TRACE( TL_A, TM_Recv, ( "CMT %d w/o tunnel?", *(pControl->pusMsgType) ) );
                WPLOG( LL_A, LM_Recv, ( "CMT %d w/o tunnel?", *(pControl->pusMsgType) ) );
                return TRUE;
            }
        }

        if (*(pControl->pusMsgType) == CMT_SCCRQ
            || *(pControl->pusMsgType) == CMT_SCCRP)
        {
            // The source UDP port of the received message is recorded for
            // SCCRQ and SCCRP only, i.e. for the first message received
            // from peer.
            //
            pTunnel->address.sUdpPort = pAddress->sUdpPort;
            TRACE( TL_I, TM_Recv,
                ( "Peer UDP=%d", (UINT )ntohs( pAddress->sUdpPort ) ) );

            pTunnel->localaddress.ulIpAddress = pRdg->dest.ulIpAddress;
            pTunnel->localaddress.ifindex = pRdg->dest.ifindex;
            pTunnel->localaddress.sUdpPort = (SHORT)( htons( L2TP_UdpPort ));
            pTunnel->ulFlags |= TCBF_LocalAddrSet;

            TRACE( TL_I, TM_CMsg, ("L2TP-- dest %d.%d.%d.%d ifindex %d", 
                IPADDRTRACE(pRdg->dest.ulIpAddress), pRdg->dest.ifindex));
                
            WPLOG( LL_M, LM_CMsg, ("Received on %!IPADDR!", pRdg->dest.ulIpAddress));
        }
    }
    else if (!pTunnel)
    {
        // Peer messed up and sent an ACK on tunnel ID 0, which is impossible
        // according to the protocol.
        //
        TRACE( TL_A, TM_Recv, ( "ZACK w/o tunnel?" ) );
        WPLOG( LL_A, LM_Recv, ( "ZACK w/o tunnel?" ) );
        return TRUE;
    }

    ASSERT( pTunnel );

    NdisAcquireSpinLock( &pTunnel->lockT );
    {
        // Do "acknowledged" handling on sends acknowledged by peer in the
        // received packet.
        //
        ControlAcknowledged( pTunnel, *(pInfo->pusNr) );

        if (ulAvpLength == 0)
        {
            // There are no AVPs so this was an acknowledgement only.  We're
            // done.
            //
            NdisReleaseSpinLock( &pTunnel->lockT );
            return TRUE;
        }

        fCallerFreesBuffer = TRUE;
        do
        {
            // Further packet processing depends on where the packet's
            // sequence number falls relative to what we've already received.
            //
            sDiff = CompareSequence( *(pInfo->pusNs), pTunnel->usNr );
            if (sDiff == 0)
            {
                // It's the expected packet.  Process it, setting up the VC
                // and popping from the out-of-order list as indicated.  The
                // 'Next Received' is incremented outside, because that step
                // should not happen on a SetupVcAsynchronously restart.
                //
                ++pTunnel->usNr;
                fCallerFreesBuffer =
                    ReceiveControlExpected( pTunnel, pVc, pBuffer, pControl );
                break;
            }
            else if (sDiff < 0)
            {
                // The received 'Next Sent' is before our 'Next Receive'.
                // Peer may have retransmitted while our acknowledge was in
                // transit, or the acknowledge may have been lost.  Schedule
                // another acknowledge.
                //
                TRACE( TL_A, TM_Recv, ( "Control re-ack" ) );
                WPLOG( LL_A, LM_Recv, ( "Control re-ack" ) );
                ScheduleControlAck( pTunnel, 0 );

                if (*(pControl->pusMsgType) == CMT_SCCRQ)
                {
                    // Since SCCRQ is a duplicate, the reference added by
                    // SetupTunnel above must be undone.  In this special case
                    // the TCBF_PeerInitRef flag was never set and so need not
                    // be cleared.
                    //
                    DereferenceTunnel( pTunnel );
                }
                break;
            }
            else if (sDiff < pAdapter->sMaxOutOfOrder)
            {
                CONTROLRECEIVED* pCr;
                BOOLEAN fDiscard;

                // The packet is beyond the one we expected, but within our
                // out-of-order window.
                //
                if (ReadFlags( &pTunnel->ulFlags ) & TCBF_Closing)
                {
                    // The tunnel is closing and the out-of-order queue has
                    // been flushed, so just discard the packet.
                    //
                    TRACE( TL_A, TM_Recv, ( "Control discarded: ooo but closing" ) );
                    WPLOG( LL_A, LM_Recv, ( "Control discarded: ooo but closing" ) );
                    break;
                }

                // Allocate a control-received context
                // and queue the packet on the out-of-order list.
                //
                pCr = ALLOC_CONTROLRECEIVED( pAdapter );
                if (!pCr)
                {
                    break;
                }

                // Fill in the context with the relevant packet information.
                //
                pCr->usNs = *(pInfo->pusNs);
                pCr->pVc = pVc;
                pCr->pBuffer = pBuffer;
                NdisMoveMemory(
                    &pCr->control, pControl, sizeof(pCr->control) );

                if (pCr->pVc)
                {
                    // Add a VC reference covering the reference stored in the
                    // context, which will be removed when the context is
                    // freed.
                    //
                    ReferenceVc( pCr->pVc );
                }

                // Find the first link on the out-of-order list with an 'Ns'
                // greater than that in the received message, or the head if
                // none.
                //
                fDiscard = FALSE;
                for (pLink = pTunnel->listOutOfOrder.Flink;
                     pLink != &pTunnel->listOutOfOrder;
                     pLink = pLink->Flink)
                {
                    CONTROLRECEIVED* pThisCr;
                    SHORT sThisDiff;

                    pThisCr = CONTAINING_RECORD(
                        pLink, CONTROLRECEIVED, linkOutOfOrder );

                    sThisDiff = CompareSequence( pCr->usNs, pThisCr->usNs );

                    if (sThisDiff < 0)
                    {
                        break;
                    }

                    if (sThisDiff == 0)
                    {
                        // It's a retransmit that's already on our queue.
                        //
                        if (pCr->pVc)
                        {
                            DereferenceVc( pCr->pVc );
                        }

                        FREE_CONTROLRECEIVED( pAdapter, pCr );
                        fDiscard = TRUE;
                        break;
                    }
                }

                if (fDiscard)
                {
                    break;
                }

                // Queue up the context as out-of-order.
                //
                TRACE( TL_I, TM_Recv,
                    ( "Control %d out-of-order %d",
                    *(pInfo->pusNs), (LONG )sDiff ) );
                InsertBefore( &pCr->linkOutOfOrder, pLink );
                fCallerFreesBuffer = FALSE;
                break;
            }
            DBG_else
            {
                TRACE( TL_A, TM_Recv,
                    ( "Control discarded: Beyond ooo" ) );
            }
        }
        while (FALSE);

        // Complete any VCs listed as completing.
        //
        CompleteVcs( pTunnel );
    }
    NdisReleaseSpinLock( &pTunnel->lockT );

    return fCallerFreesBuffer;
}


BOOLEAN
ReceiveControlExpected(
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN CHAR* pBuffer,
    IN CONTROLMSGINFO* pControl )

    // Called to do packet processing when the packet received is the expected
    // 'Next Receive' packet.  'PBuffer' is the receive buffer.  'PTunnel' is
    // the valid tunnel control block.  'PVc' is the call's VC control block
    // and may be NULL, if the VC for the call has not yet been set up.
    // 'PControl' is the expoded control message information.
    //
    // Returns true if the buffer should be freed by caller, false if it was
    // queued for further processing.
    //
    // IMPORTANT: Caller must hold the 'pTunnel->lockT'.
    //
{
    ADAPTERCB* pAdapter;
    BOOLEAN fProcessed;
    SHORT sDiff;

    pAdapter = pTunnel->pAdapter;

    // Schedule an acknowledge-only packet to be sent if no outgoing traffic
    // appears to piggyback on within a reasonable time.  Note this occurs
    // even if the asynchronous VC set up was invoked.  Ns/Nr processing must
    // occur before any data processing that may cause delays.
    //
    ScheduleControlAck( pTunnel, *(pControl->pusMsgType) );

    // Pass the packet to the control FSMs.
    //
    fProcessed = FsmReceive( pTunnel, pVc, pBuffer, pControl );
    if (fProcessed)
    {
        // The VC is setup and the packet has been processed.  See if any
        // packets on the received out-of-order queue can now be processed.
        //
        for (;;)
        {
            LIST_ENTRY* pFirstLink;
            CONTROLRECEIVED* pFirstCr;
            BOOLEAN fOutOfOrderProcessed;

            pFirstLink = pTunnel->listOutOfOrder.Flink;
            if (pFirstLink == &pTunnel->listOutOfOrder)
            {
                break;
            }

            pFirstCr = CONTAINING_RECORD(
                pFirstLink, CONTROLRECEIVED, linkOutOfOrder );

            sDiff = CompareSequence( pFirstCr->usNs, pTunnel->usNr );
            if (sDiff == 0)
            {
                // Yes, it's the next expected packet.  Update 'Next Receive'
                // and pass the packet to the control FSMs.
                //
                TRACE( TL_I, TM_Recv,
                    ( "Control %d from queue", (UINT )pFirstCr->usNs ) );
                RemoveEntryList( pFirstLink );
                InitializeListHead( pFirstLink );

                ++pTunnel->usNr;
                fOutOfOrderProcessed =
                    FsmReceive(
                        pTunnel, pFirstCr->pVc,
                        pFirstCr->pBuffer, &pFirstCr->control );

                ScheduleControlAck(
                    pTunnel, *(pFirstCr->control.pusMsgType) );

                if (fOutOfOrderProcessed)
                {
                    FreeBufferToPool(
                        &pAdapter->poolFrameBuffers, pFirstCr->pBuffer, TRUE );
                }

                if (pFirstCr->pVc)
                {
                    DereferenceVc( pFirstCr->pVc );
                }

                FREE_CONTROLRECEIVED( pAdapter, pFirstCr );
            }
            else if (sDiff > 0)
            {
                // No, there's still some missing.
                //
                TRACE( TL_I, TM_Recv,
                    ( "Control %d still missing", pTunnel->usNr ) );
                break;
            }
            else
            {
                ASSERT( "Old control queued?" );
                break;
            }
        }
    }

    return fProcessed;
}


BOOLEAN
ReceivePayload(
    IN ADAPTERCB* pAdapter,
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN CHAR* pBuffer,
    IN ULONG ulPayloadOffset,
    IN ULONG ulPayloadLength,
    IN L2TPHEADERINFO* pInfo )

    // Receive processing for payload in 'pBuffer' of 'ulPayloadLength' bytes
    // starting at offset 'ulPayloadOffset'.  'PBuffer' is the receive buffer
    // TDIX retrieved with 'GetBufferFromPool'.  'PAdapter, 'pTunnel' and
    // 'PVc' are the adapter, tunnel, and VC control blocks associated with
    // the received buffer.  'PInfo' is the exploded header information.
    //
    // Returns true if caller should free 'pBuffer', or false if this routine
    // has taken ownership of the buffer and will see it's freed.
    //
{
    LONGLONG llTimeReceived;
    BOOLEAN fCallerFreesBuffer;

    TRACE( TL_V, TM_Recv, ( "ReceivePayload" ) );

    if (!pTunnel || !pVc)
    {
        // Both control blocks are always required to receive payload.
        //
        TRACE( TL_A, TM_Recv, ( "Discard: No CB" ) );
        WPLOG( LL_A, LM_Recv, ( "Discard: No CB" ) );
        return TRUE;
    }

    // Note the time if client's call parameters indicated interest in time
    // received.
    //
    if (ReadFlags( &pVc->ulFlags ) & VCBF_IndicateTimeReceived)
    {
        NdisGetCurrentSystemTime( (LARGE_INTEGER* )&llTimeReceived );
    }
    else
    {
        llTimeReceived = 0;
    }

    if (!(ReadFlags( &pVc->ulFlags ) & VCBF_Sequencing) || !pInfo->pusNr)
    {
        DBG_if (ReadFlags( &pVc->ulFlags ) & VCBF_Sequencing)
            TRACE( TL_A, TM_Recv, ( "No Nr field?" ) );

        if (ulPayloadLength > 0)
        {
            // Flow control was disabled during negotiation.  This should be
            // extremely rare, since a compliant peer MUST implement flow
            // control.
            //
            IndicateReceived(
                pVc, pBuffer, ulPayloadOffset,
                ulPayloadLength, llTimeReceived );
            return FALSE;
        }
        else
        {
            NdisAcquireSpinLock( &pVc->lockV );
            {
                ++pVc->stats.ulRecdZlbs;
            }
            NdisReleaseSpinLock( &pVc->lockV );
            return TRUE;
        }
    }

    fCallerFreesBuffer = TRUE;
    NdisAcquireSpinLock( &pVc->lockV );
    do
    {
        SHORT sDiff;

        // All R-bit handling occurs first.  Peer sends a packet with the
        // R-bit set to indicate that all packets expected between the last
        // packet and this packet should be assumed lost.
        //
        if (*(pInfo->pusBits) & HBM_R)
        {
            ++pVc->stats.ulRecdResets;

            sDiff = CompareSequence( *(pInfo->pusNs), pVc->usNr );
            if (sDiff > 0)
            {
                TRACE( TL_I, TM_Recv,
                    ( "Reset Nr=%d from %d",
                    (LONG )*(pInfo->pusNs), (LONG )pVc->usNr ) );

                pVc->usNr = *(pInfo->pusNs);
            }
            else
            {
                ++pVc->stats.ulRecdResetsIgnored;

                TRACE( TL_I, TM_Recv,
                    ( "Reset Nr=%d from %d ignored",
                    (LONG )*(pInfo->pusNs), (LONG )pVc->usNr ) );
            }
        }

        // Do "acknowledged" handling on sends acknowledged by peer in the
        // received packet.
        //
        PayloadAcknowledged( pTunnel, pVc, *(pInfo->pusNr) );

        // If there's no payload and the R-bit is not set, this was an
        // acknowledgement only and we're done.
        //
        if (ulPayloadLength == 0)
        {
            ++pVc->stats.ulRecdZlbs;

            if (*(pInfo->pusBits) & HBM_R)
            {
                BOOLEAN fReceivedFromOutOfOrder;

                // Indicate up any packet on the out-of-order list made
                // receivable by the R-bit reset.
                //
                fReceivedFromOutOfOrder = FALSE;
                while (ReceiveFromOutOfOrder( pVc ))
                {
                    fReceivedFromOutOfOrder = TRUE;
                }

                if (fReceivedFromOutOfOrder)
                {
                    // Schedule an acknowledge-only packet to be sent if no
                    // outgoing traffic appears to piggyback on within a
                    // reasonable time.
                    //
                    SchedulePayloadAck( pTunnel, pVc );
                }
            }

            break;
        }

        DBG_if (pInfo->pusNs && pInfo->pusNr)
        {
            TRACE( TL_N, TM_Recv, ( "len=%d Ns=%d Nr=%d",
                (ULONG )*(pInfo->pusLength),
                (ULONG )*(pInfo->pusNs),
                (ULONG )*(pInfo->pusNr) ) );
        }

        // Further packet processing depends on where the packet's sequence
        // number falls relative to what we've already received.
        //
        sDiff = CompareSequence( *(pInfo->pusNs), pVc->usNr );
        if (sDiff == 0)
        {
            // It's the next expected packet.  Update 'Next Receive' and
            // indicate the payload received to the driver above.
            //
            pVc->usNr = *(pInfo->pusNs) + 1;

            NdisReleaseSpinLock( &pVc->lockV );
            {
                IndicateReceived(
                    pVc, pBuffer, ulPayloadOffset, ulPayloadLength,
                    llTimeReceived );
            }
            NdisAcquireSpinLock( &pVc->lockV );

            // Indicate up any packets on the out-of-order list that were
            // waiting for this one.
            //
            while (ReceiveFromOutOfOrder( pVc ))
                ;

            // Schedule an acknowledge-only packet to be sent if no outgoing
            // traffic appears to piggyback on within a reasonable time.
            //
            SchedulePayloadAck( pTunnel, pVc );
        }
        else if (sDiff < 0)
        {
            // The received 'Next Sent' is before our 'Next Receive'.  Maybe
            // an out-of-order packet we didn't wait for long enough.  It's
            // useless at this point.
            //
            TRACE( TL_A, TM_Recv, ( "Payload discarded: Old Ns" ) );
            WPLOG( LL_A, LM_Recv, ( "Payload discarded: Old Ns" ) );
            break;
        }
        else if (sDiff < pAdapter->sMaxOutOfOrder)
        {
            LIST_ENTRY* pLink;
            PAYLOADRECEIVED* pPr;
            BOOLEAN fDiscard;

            TRACE( TL_I, TM_Recv,
                ( "%d out-of-order %d", *(pInfo->pusNs), (LONG )sDiff ) );

            // The packet is beyond the one we expected, but within our
            // out-of-order window.  Allocate a payload-received context and
            // queue it up on the out-of-order list.
            //
            pPr = ALLOC_PAYLOADRECEIVED( pAdapter );
            if (!pPr)
            {
                TRACE( TL_A, TM_Recv, ( "Alloc PR?" ) );
                WPLOG( LL_A, LM_Recv, ( "Failed to allocate PAYLOADRECEIVED" ) );
                break;
            }

            // Fill in the context with the relevant packet information.
            //
            pPr->usNs = *(pInfo->pusNs);
            pPr->pBuffer = pBuffer;
            pPr->ulPayloadOffset = ulPayloadOffset;
            pPr->ulPayloadLength = ulPayloadLength;
            pPr->llTimeReceived = llTimeReceived;

            // Queue up the context on the out-of-order list, keeping the list
            // correctly sorted by 'Ns'.
            //
            fDiscard = FALSE;
            for (pLink = pVc->listOutOfOrder.Flink;
                 pLink != &pVc->listOutOfOrder;
                 pLink = pLink->Flink)
            {
                PAYLOADRECEIVED* pThisPr;
                SHORT sThisDiff;

                pThisPr = CONTAINING_RECORD(
                    pLink, PAYLOADRECEIVED, linkOutOfOrder );

                sThisDiff = CompareSequence( pPr->usNs, pThisPr->usNs );

                if (sThisDiff < 0)
                {
                    break;
                }

                if (sThisDiff == 0)
                {
                    // This shouldn't happen because payloads are not
                    // retransmitted, but do the right thing just in case.
                    //
                    TRACE( TL_A, TM_Recv, ( "Payload on ooo queue?" ) );
                    fDiscard = TRUE;
                    break;
                }
            }

            if (fDiscard)
            {
                FREE_PAYLOADRECEIVED( pAdapter, pPr );
                break;
            }

            InsertBefore( &pPr->linkOutOfOrder, pLink );
        }
        else
        {
            // The packet is beyond the one we expected and outside our
            // out-of-order window.  Discard it.
            //
            TRACE( TL_A, TM_Recv, ( "Out-of-order %d too far" , (LONG )sDiff ) );
            WPLOG( LL_A, LM_Recv, ( "Out-of-order %d too far" , (LONG )sDiff ) );

            break;
        }

        fCallerFreesBuffer = FALSE;
    }
    while (FALSE);
    NdisReleaseSpinLock( &pVc->lockV );

    return fCallerFreesBuffer;
}


//-----------------------------------------------------------------------------
// Receive utility routines (alphabetically)
//-----------------------------------------------------------------------------

SHORT
CompareSequence(
    USHORT us1,
    USHORT us2 )

    // Returns the "logical" difference between sequence numbers 'us1' and
    // 'us2' accounting for the possibility of rollover.
    //
{
    USHORT usDiff = us1 - us2;

    if (usDiff == 0)
        return 0;

    if (usDiff < 0x4000)
        return (SHORT )usDiff;

    return -((SHORT )(0 - usDiff));
}


VOID
ControlAcknowledged(
    IN TUNNELCB* pTunnel,
    IN USHORT usReceivedNr )

    // Dequeues and cancels the timer of all control-sent contexts in the
    // tunnel's 'listSendsOut' queue with 'Next Sent' less than
    // 'usReceivedNr'.
    //
    // IMPORTANT: Caller must hold 'pTunnel->lockT'.
    //
{
    ADAPTERCB* pAdapter;
    BOOLEAN fFoundOne;

    pAdapter = pTunnel->pAdapter;
    fFoundOne = FALSE;

    while (!IsListEmpty( &pTunnel->listSendsOut ))
    {
        CONTROLSENT* pCs;
        LIST_ENTRY* pLink;

        pLink = pTunnel->listSendsOut.Flink;
        pCs = CONTAINING_RECORD( pLink, CONTROLSENT, linkSendsOut );

        // The list is in 'Ns' order so as soon as a non-acknowledge is hit
        // we're done.
        //
        if (CompareSequence( pCs->usNs, usReceivedNr ) >= 0)
        {
            break;
        }

        fFoundOne = TRUE;

        // Remove the context from the "outstanding send" list and cancel the
        // associated timer.  Doesn't matter if the cancel fails because the
        // expire handler will recognize that the context is not linked into
        // the "out" list and do nothing.
        //
        RemoveEntryList( pLink );
        InitializeListHead( pLink );
        TimerQCancelItem( pTunnel->pTimerQ, pCs->pTqiSendTimeout );

        // Per the draft/RFC, adjustments to the send window and send timeouts
        // are necessary.  Per Karn's Algorithm, if the packet was
        // retransmitted it is useless for timeout adjustment because it's not
        // known if peer responded to the original send or the retransmission.
        //
        if (pCs->ulRetransmits == 0)
        {
            AdjustTimeoutsAtAckReceived(
                pCs->llTimeSent,
                pAdapter->ulMaxSendTimeoutMs,
                &pTunnel->ulSendTimeoutMs,
                &pTunnel->ulRoundTripMs,
                &pTunnel->lDeviationMs );
        }

        // See if it's time to open the send window a bit further.
        //
        AdjustSendWindowAtAckReceived(
            pTunnel->ulMaxSendWindow,
            &pTunnel->ulAcksSinceSendTimeout,
            &pTunnel->ulSendWindow );

        TRACE( TL_N, TM_Send,
            ( "T%d: ACK(%d) new rtt=%d dev=%d ato=%d sw=%d",
            (ULONG )pTunnel->usTunnelId, (ULONG )pCs->usNs,
            pTunnel->ulRoundTripMs, pTunnel->lDeviationMs,
            pTunnel->ulSendTimeoutMs, pTunnel->ulSendWindow ) );

        // Execute any "on ACK" options and note that delayed action
        // processing is now required.
        //
        if (pCs->ulFlags & CSF_TunnelIdleOnAck)
        {
            TRACE( TL_N, TM_Send, ( "Tunnel idle on ACK" ) );
            ScheduleTunnelWork(
                pTunnel, NULL, CloseTunnel,
                0, 0, 0, 0, FALSE, FALSE );
        }
        else if (pCs->ulFlags & CSF_CallIdleOnAck)
        {
            TRACE( TL_N, TM_Send, ( "Call idle on ACK" ) );
            ASSERT( pCs->pVc );
            ScheduleTunnelWork(
                pTunnel, pCs->pVc, CloseCall,
                0, 0, 0, 0, FALSE, FALSE );
        }

        if (pCs->ulFlags & CSF_Pending)
        {
            // The context is queued for retransmission, so de-queue it.  In
            // this state the context has already been assumed "not
            // outstanding" so no need to adjust the counter as below.
            //
            pCs->ulFlags &= ~(CSF_Pending);
        }
        else
        {
            // The context is not queued for retranmission, so adjust the
            // counter to indicate it is no longer outstanding.
            //
            --pTunnel->ulSendsOut;
        }

        // Remove the reference corresponding to linkage in the "outstanding
        // send" list.
        //
        DereferenceControlSent( pCs );
    }

    if (fFoundOne)
    {
        // See if any sends were pending on a closed send window.
        //
        ScheduleTunnelWork(
            pTunnel, NULL, SendPending,
            0, 0, 0, 0, FALSE, FALSE );
    }
}


VOID
ControlAckTimerEvent(
    IN TIMERQITEM* pItem,
    IN VOID* pContext,
    IN TIMERQEVENT event )

    // PTIMERQEVENT handler that fires when it's time to stop waiting for an
    // outgoing control packet on which to piggyback an acknowledge.
    //
{
    TUNNELCB* pTunnel;
    ADAPTERCB* pAdapter;
    BOOLEAN fSendAck;

    TRACE( TL_N, TM_Recv,
        ( "ControlAckTimerEvent(%s)", TimerQPszFromEvent( event ) ) );

    // Unpack context information.
    //
    pTunnel = (TUNNELCB* )pContext;
    pAdapter = pTunnel->pAdapter;

    if (event == TE_Expire)
    {
        NdisAcquireSpinLock( &pTunnel->lockT );
        {
            if (pItem == pTunnel->pTqiDelayedAck)
            {
                pTunnel->pTqiDelayedAck = NULL;
                fSendAck = TRUE;
            }
            else
            {
                fSendAck = FALSE;
            }
        }
        NdisReleaseSpinLock( &pTunnel->lockT );

        if (fSendAck)
        {
            // The timer expired and was not been cancelled or terminated
            // while the expire processing was being set up, meaning it's time
            // to send a zero-AVP control packet to give peer the acknowledge
            // we were hoping to piggyback onto a random outgoing control
            // packet.
            //
            ScheduleTunnelWork(
                pTunnel, NULL, SendControlAck, 0, 0, 0, 0, FALSE, FALSE );
        }
        DBG_else
        {
            TRACE( TL_I, TM_Send, ( "CAck aborted" ) );
        }
    }

    // Free the timer event descriptor and remove the reference covering the
    // scheduled timer.
    //
    FREE_TIMERQITEM( pAdapter, pItem );
    DereferenceTunnel( pTunnel );
}


VOID
PayloadAckTimerEvent(
    IN TIMERQITEM* pItem,
    IN VOID* pContext,
    IN TIMERQEVENT event )

    // PTIMERQEVENT handler that fires when it's time to stop waiting for an
    // outgoing payload packet on which to piggyback an acknowledge.
    //
{
    VCCB* pVc;
    ADAPTERCB* pAdapter;
    BOOLEAN fSendAck;

    TRACE( TL_N, TM_Recv,
        ( "PayloadAckTimerEvent(%s)=$%p",
        TimerQPszFromEvent( event ), pItem ) );

    // Unpack context information.
    //
    pVc = (VCCB* )pContext;
    pAdapter = pVc->pAdapter;

    if (event == TE_Expire)
    {
        if (ReferenceCall( pVc ))
        {
            NdisAcquireSpinLock( &pVc->lockV );
            {
                if (pItem == pVc->pTqiDelayedAck)
                {
                    fSendAck = TRUE;
                    pVc->pTqiDelayedAck = NULL;
                    ++pVc->stats.ulSentZAcks;
                }
                else
                {
                    fSendAck = FALSE;
                }
            }
            NdisReleaseSpinLock( &pVc->lockV );

            if (fSendAck)
            {
                // The timer expired and was not been cancelled or terminated
                // while the expire processing was being set up, plus the call
                // is still up, meaning it's time to send a zero-AVP control
                // packet to give peer the acknowledge we were hoping to
                // piggyback onto a random outgoing payload packet.
                //
                ScheduleTunnelWork(
                    pVc->pTunnel, pVc, SendPayloadAck,
                    0, 0, 0, 0, FALSE, FALSE );
            }
            else
            {
                TRACE( TL_I, TM_Send, ( "PAck aborted" ) );
                DereferenceCall( pVc );
            }
        }
        else
        {
            NdisAcquireSpinLock( &pVc->lockV );
            {
                if (pItem == pVc->pTqiDelayedAck)
                {
                    pVc->pTqiDelayedAck = NULL;
                }
            }
            NdisReleaseSpinLock( &pVc->lockV );
        }
    }

    // Free the timer event descriptor and remove the reference covering the
    // scheduled timer.
    //
    FREE_TIMERQITEM( pAdapter, pItem );
    DereferenceVc( pVc );
}


USHORT
ExplodeAvpHeader(
    IN CHAR* pAvp,
    IN USHORT usMaxAvpLength,
    OUT AVPINFO* pInfo )

    // Fills caller's '*pInfo' with the addresses of the various fields in the
    // AVP header at 'pAvp'.  The byte order of the fields in 'pAvpHeader',
    // with the exception of the Value field, are flipped to host-byte-order
    // in place.  The length and value length are extracted.  'UsMaxAvpLength'
    // is the maximum size of the AVP in bytes.
    //
    // Returns GERR_None if 'pAvpHeader' is a coherent AVP header, or a
    // GERR_* failure code.
    //
{
    UNALIGNED USHORT* pusCur;
    USHORT usBits;

    if (usMaxAvpLength < L2TP_AvpHeaderSize)
    {
        TRACE( TL_A, TM_Recv, ( "Avp: Short buffer?" ) );
        WPLOG( LL_A, LM_Recv, ( "Avp: Short buffer?" ) );
        return GERR_BadLength;
    }

    pusCur = (UNALIGNED USHORT* )pAvp;

    // The first 2 bytes contain bits that indicate the presence/absence of
    // the other header fields.
    //
    *pusCur = ntohs( *pusCur );
    pInfo->pusBits = pusCur;
    usBits = *pusCur;
    ++pusCur;

    // As of draft-09, AVPs with reserved bits not set to zero MUST be treated
    // as unrecognized.
    //
    if ((usBits & ABM_Reserved) != 0)
    {
        return GERR_BadValue;
    }

    // Extract the Overall Length sub-field and verify that it says the AVP is
    // at least as long as the fixed portion of the header.
    //
    pInfo->usOverallLength = (usBits & ABM_OverallLength);
    if (pInfo->usOverallLength > usMaxAvpLength
        || pInfo->usOverallLength < L2TP_AvpHeaderSize)
    {
        TRACE( TL_A, TM_Recv, ( "Avp: Bad length?" ) );
        WPLOG( LL_A, LM_Recv, ( "Avp: Bad length?" ) );
        return GERR_BadLength;
    }

    // Vendor-ID field.
    //
    *pusCur = ntohs( *pusCur );
    pInfo->pusVendorId = pusCur;
    ++pusCur;

    // Attribute field.
    //
    *pusCur = ntohs( *pusCur );
    pInfo->pusAttribute = pusCur;
    ++pusCur;

    // Value field.
    //
    pInfo->pValue = (CHAR* )pusCur;
    pInfo->usValueLength = pInfo->usOverallLength - L2TP_AvpHeaderSize;

    return GERR_None;
}


#define MAX_NAME_LENGTH     64

VOID
ExplodeControlAvps(
    IN CHAR* pFirstAvp,
    IN CHAR* pEndOfBuffer,
    OUT CONTROLMSGINFO* pControl )

    // Fills caller's '*pControl' buffer with the exploded interpretation of
    // the message with AVP list starting at 'pFirstAvp'.  'PEndOfBuffer'
    // points to the first byte beyond the end of the received buffer.  The
    // AVP values are returned as addresses of the corresponding value field
    // in the AVPs.  Fields not present are returned as NULL.  The byte order
    // of the fields in 'pControl' is flipped to host-byte-order in place.
    // The values themselves are not validated, only the message format.  Sets
    // 'pControl->usXError' to GERR_None if successful, or the GERR_* failure
    // code.
    //
{
    USHORT usXError;
    AVPINFO avp;
    CHAR* pCur;
    CHAR szName[MAX_NAME_LENGTH];
    int NameLength;
    

    DUMPW( TL_A, TM_MDmp, pFirstAvp, (ULONG )(pEndOfBuffer - pFirstAvp) );

    NdisZeroMemory( pControl, sizeof(*pControl) );
    pCur = pFirstAvp;

    // Read and validate the Message Type AVP, which is the first AVP of all
    // control messages.
    //
    usXError = ExplodeAvpHeader( pCur, (USHORT )(pEndOfBuffer - pCur), &avp );
    if (usXError != GERR_None)
    {
        TRACE( TL_A, TM_CMsg, ( "Bad AVP header" ) );
        WPLOG( LL_A, LM_CMsg, ( "Bad AVP header" ) );
        pControl->usXError = usXError;
        return;
    }

    if (*(avp.pusAttribute) != ATTR_MsgType
        || *(avp.pusVendorId) != 0
        || (*(avp.pusBits) & ABM_H))
    {
        TRACE( TL_A, TM_CMsg, ( "Bad MsgType AVP" ) );
        WPLOG( LL_A, LM_CMsg, ( "Bad MsgType AVP" ) );
        pControl->usXError = GERR_BadValue;
        return;
    }

    usXError = GetAvpValueUs( &avp, &pControl->pusMsgType );
    if (usXError != GERR_None)
    {
        TRACE( TL_A, TM_CMsg, ( "Bad MsgType Us" ) );
        WPLOG( LL_A, LM_CMsg, ( "Bad MsgType Us" ) );
        pControl->usXError = usXError;
        return;
    }

    pCur += avp.usOverallLength;

    TRACE( TL_I, TM_CMsg, ( "*MsgType=%s", MsgTypePszFromUs( *(pControl->pusMsgType) ) ) );
    WPLOG( LL_M, LM_CMsg, ( "*MsgType=%s", MsgTypePszFromUs( *(pControl->pusMsgType) ) ) );

    // Make sure the message type code is valid, and if it is, explode any
    // additional AVPs in the message.
    //
    switch (*(pControl->pusMsgType))
    {
        case CMT_SCCRQ:
        case CMT_SCCRP:
        case CMT_SCCCN:
        case CMT_StopCCN:
        case CMT_Hello:
        {
            // Mark the messages above as tunnel control rather than call
            // control.
            //
            pControl->fTunnelMsg = TRUE;

            // ...fall thru...
        }

        case CMT_OCRQ:
        case CMT_OCRP:
        case CMT_OCCN:
        case CMT_ICRQ:
        case CMT_ICRP:
        case CMT_ICCN:
        case CMT_CDN:
        case CMT_WEN:
        case CMT_SLI:
        {
            // Walk the list of AVPs, exploding each AVP in turn.  Excepting
            // the Message Type, the order of the AVPs is not defined.
            //
            for ( ; pCur < pEndOfBuffer; pCur += avp.usOverallLength )
            {
                usXError = ExplodeAvpHeader(
                    pCur, (USHORT )(pEndOfBuffer - pCur), &avp );
                if (usXError != GERR_None)
                {
                    break;
                }

                if (*avp.pusVendorId != 0)
                {
                    // The AVP has a non-IETF vendor ID, and we don't
                    // recognize any.  If the AVP is optional, just ignore it.
                    // If it's mandatory, then fail.
                    //
                    if (*avp.pusBits & ABM_M)
                    {
                        TRACE( TL_A, TM_CMsg, ( "Non-0 Vendor ID %d, M-bit is set", *avp.pusVendorId ) );
                        WPLOG( LL_A, LM_CMsg, ( "Non-0 Vendor ID %d, M-bit is set", *avp.pusVendorId ) );
                        usXError = GERR_BadValue;
                        break;
                    }
                    continue;
                }

                if (*avp.pusBits & ABM_H)
                {
                    BOOLEAN fIgnore;

                    TRACE( TL_A, TM_CMsg, ( "Hidden bit on AVP %d", (LONG )(*avp.pusAttribute) ) );

                    // !!! Remove this when H-bit support is added.
                    //
                    switch (*avp.pusAttribute)
                    {
                        case ATTR_ProxyAuthName:
                        case ATTR_ProxyAuthChallenge:
                        case ATTR_ProxyAuthId:
                        case ATTR_ProxyAuthResponse:
                        case ATTR_DialedNumber:
                        case ATTR_DialingNumber:
                        case ATTR_SubAddress:
                        case ATTR_InitialLcpConfig:
                        case ATTR_LastSLcpConfig:
                        case ATTR_LastRLcpConfig:
                        case ATTR_Accm:
                        case ATTR_PrivateGroupId:
                        {
                            fIgnore = TRUE;
                            break;
                        }

                        default:
                        {
                            fIgnore = FALSE;
                            break;
                        }
                    }

                    if (fIgnore)
                    {
                        TRACE( TL_A, TM_CMsg, ( "Hidden AVP ignored" ) );
                        break;
                    }

                    // The AVP has the "hidden" bit set meaning the value is
                    // hashed with MD5.  This requires a shared secret from
                    // the tunnel authentication, which we don't do.  If the
                    // AVP is optional, just ignore it.  If it's mandatory,
                    // fail.
                    //
                    if (*avp.pusBits & ABM_M)
                    {
                        usXError = GERR_BadValue;
                        break;
                    }
                    continue;
                }

                switch (*avp.pusAttribute)
                {
                    case ATTR_Result:
                    {
                        usXError = GetAvpValue2UsAndVariableAch(
                            &avp,
                            &pControl->pusResult,
                            &pControl->pusError,
                            &pControl->pchResultMsg,
                            &pControl->usResultMsgLength );

                        DBG_if (usXError == GERR_None)
                        {
                            TRACE( TL_A, TM_CMsg, ( "*Result=%d", 
                                (ULONG )(*(pControl->pusResult))));
                        }
                        
                        WPLOG( LL_M, LM_CMsg, ( "*Result=%d", 
                            (usXError == GERR_None) ? (ULONG )(*(pControl->pusResult)) : -1 ));

                        break;
                    }

                    case ATTR_HostName:
                    {
                        usXError = GetAvpValueVariableAch(
                            &avp,
                            &pControl->pchHostName,
                            &pControl->usHostNameLength );

                        if(usXError == GERR_None)
                        {
                            NameLength = (pControl->usHostNameLength < MAX_NAME_LENGTH) ? pControl->usHostNameLength : MAX_NAME_LENGTH - 1;
                            NdisMoveMemory(szName, pControl->pchHostName, NameLength); 
                            szName[NameLength] = '\0';
                        
                            TRACE( TL_A, TM_CMsg, ( "*HostName=%s", szName));
                            WPLOG( LL_M, LM_CMsg, ( "*HostName=%s", szName));
                        }
                        else
                        {
                            WPLOG( LL_M, LM_CMsg, ( "*HostName is bad"));
                        }
                                                             
                        break;
                    }
                    
                    case ATTR_VendorName:
                    {
                        PCHAR pchVendorName;
                        USHORT usVendorNameLength;
                        
                        usXError = GetAvpValueVariableAch(
                            &avp,
                            &pchVendorName,
                            &usVendorNameLength);

                        if(usXError == GERR_None)
                        {
                            NameLength = (usVendorNameLength < MAX_NAME_LENGTH) ? usVendorNameLength : MAX_NAME_LENGTH - 1;
                            NdisMoveMemory(szName, pchVendorName, NameLength); 
                            szName[NameLength] = '\0';
                        
                            TRACE( TL_A, TM_CMsg, ( "*VendorName=%s", szName));
                            WPLOG( LL_M, LM_CMsg, ( "*VendorName=%s", szName));
                        }
                        else
                        {
                            WPLOG( LL_M, LM_CMsg, ( "*VendorName is bad"));
                        }
                                                             
                        break;
                    }
                    
                    case ATTR_FirmwareRevision:
                    {
                        usXError = GetAvpValueUs(
                            &avp, &pControl->pusFirmwareRevision );

                        DBG_if (usXError == GERR_None)
                        {
                            TRACE( TL_A, TM_CMsg, ( "*FirmwareVer=$%04x",
                                (ULONG )(*(pControl->pusFirmwareRevision)) ) );
                        }
                        
                        WPLOG( LL_M, LM_CMsg, ( "*FirmwareVer=%04x", 
                            (usXError == GERR_None) ? (ULONG )(*(pControl->pusFirmwareRevision)) : 0xBAD ));

                        break;
                    }
                              
                    case ATTR_ProtocolVersion:
                    {
                        usXError = GetAvpValueUs(
                            &avp, &pControl->pusProtocolVersion );

                        DBG_if (usXError == GERR_None)
                        {
                            TRACE( TL_A, TM_CMsg, ( "*ProtVer=$%04x",
                                (ULONG )(*(pControl->pusProtocolVersion)) ) );
                        }
                        
                        WPLOG( LL_M, LM_CMsg, ( "*ProtVer=%04x", 
                            (usXError == GERR_None) ? (ULONG )(*(pControl->pusProtocolVersion)) : 0xBAD ));

                        break;
                    }

                    case ATTR_FramingCaps:
                    {
                        usXError = GetAvpValueUl(
                            &avp, &pControl->pulFramingCaps );

                        DBG_if (usXError == GERR_None)
                        {
                            TRACE( TL_A, TM_CMsg, ( "*FramingCaps=$%08x", 
                                *(pControl->pulFramingCaps) ) );
                        }
                        
                        WPLOG( LL_M, LM_CMsg, ( "*FramingCaps=%08x", 
                            (usXError == GERR_None) ? *(pControl->pulFramingCaps) : (ULONG) 0xBAD ));
                        
                        break;
                    }

                    case ATTR_BearerCaps:
                    {
                        usXError = GetAvpValueUl(
                            &avp, &pControl->pulBearerCaps );

                        DBG_if (usXError == GERR_None)
                        {
                            TRACE( TL_A, TM_CMsg, ( "*BearerCaps=$%08x",
                                *(pControl->pulBearerCaps) ) );
                        }
                        
                        WPLOG( LL_M, LM_CMsg, ( "*BearerCaps=%08x", 
                            (usXError == GERR_None) ? *(pControl->pulBearerCaps) : (ULONG) 0xBAD ));

                        break;
                    }

                    case ATTR_TieBreaker:
                    {
                        usXError = GetAvpValueFixedAch(
                            &avp, 8, &pControl->pchTieBreaker );

                        DBG_if (usXError == GERR_None)
                        {
                            TRACE( TL_A, TM_CMsg, ( "*Tiebreaker" ) );
                        }
                        
                        WPLOG( LL_M, LM_CMsg, ( "*Tiebreaker %s",
                            (usXError == GERR_None) ? "*" : "bad" ));

                        break;
                    }

                    case ATTR_AssignedTunnelId:
                    {
                        usXError = GetAvpValueUs(
                            &avp, &pControl->pusAssignedTunnelId );

                        DBG_if (usXError == GERR_None)
                        {
                            TRACE( TL_A, TM_CMsg, ( "*AssignTid=%d",
                                (ULONG )(*(pControl->pusAssignedTunnelId)) ) );
                        }
                        
                        WPLOG( LL_M, LM_CMsg, ( "*AssignTid=%d", 
                            (usXError == GERR_None) ? (ULONG )(*(pControl->pusAssignedTunnelId)) : -1 ));

                        break;
                    }

                    case ATTR_RWindowSize:
                    {
                        usXError = GetAvpValueUs(
                            &avp, &pControl->pusRWindowSize );

                        DBG_if (usXError == GERR_None)
                        {
                            TRACE( TL_A, TM_CMsg, ( "*RWindow=%d",
                                (ULONG )(*(pControl->pusRWindowSize)) ) );
                        }
                        
                        WPLOG( LL_M, LM_CMsg, ( "*RWindow=%d", 
                            (usXError == GERR_None) ? (ULONG )(*(pControl->pusRWindowSize)) : -1 ));

                        break;
                    }

                    case ATTR_AssignedCallId:
                    {
                        usXError = GetAvpValueUs(
                            &avp, &pControl->pusAssignedCallId );

                        DBG_if (usXError == GERR_None)
                        {
                            TRACE( TL_A, TM_CMsg, ( "*AssignCid=%d",
                                (ULONG )(*(pControl->pusAssignedCallId)) ) );
                        }
                        
                        WPLOG( LL_M, LM_CMsg, ( "*AssignCid=%d", 
                            (usXError == GERR_None) ? (ULONG )(*(pControl->pusAssignedCallId)) : -1 ));

                        break;
                    }

                    case ATTR_CallSerialNumber:
                    {
                        usXError = GetAvpValueUl(
                            &avp, &pControl->pulCallSerialNumber );

                        if (usXError == GERR_BadLength)
                        {
                            // Be tolerant here because the meaning in the
                            // draft has changed a few times.
                            //
                            TRACE( TL_A, TM_CMsg,
                                ( "Weird CallSerial# length ignored" ) );
                            usXError = GERR_None;
                        }

                        DBG_if (usXError == GERR_None)
                        {
                            TRACE( TL_A, TM_CMsg, ( "*CallSerial#" ) );
                        }
                        
                        WPLOG( LL_M, LM_CMsg, ( "*CallSerial# %s", 
                            (usXError == GERR_None) ? "*" : "bad" ));

                        break;
                    }

                    case ATTR_MinimumBps:
                    {
                        usXError = GetAvpValueUl(
                            &avp, &pControl->pulMinimumBps );

                        DBG_if (usXError == GERR_None)
                        {
                            TRACE( TL_A, TM_CMsg, ( "*MinBps=%d",
                                *(pControl->pulMinimumBps) ) );
                        }
                        
                        WPLOG( LL_M, LM_CMsg, ( "*MinBps=%d", 
                            (usXError == GERR_None) ? *(pControl->pulMinimumBps) : -1 ));

                        break;
                    }

                    case ATTR_MaximumBps:
                    {
                        usXError = GetAvpValueUl(
                            &avp, &pControl->pulMaximumBps );

                        DBG_if (usXError == GERR_None)
                        {
                            TRACE( TL_A, TM_CMsg, ( "*MaxBps=%d",
                                *(pControl->pulMaximumBps) ) );
                        }
                        
                        WPLOG( LL_M, LM_CMsg, ( "*MaxBps=%d", 
                            (usXError == GERR_None) ? *(pControl->pulMaximumBps) : -1 ));

                        break;
                    }

                    case ATTR_BearerType:
                    {
                        usXError = GetAvpValueUl(
                            &avp, &pControl->pulBearerType );

                        DBG_if (usXError == GERR_None)
                        {
                            TRACE( TL_A, TM_CMsg, ( "*BearerType=$%08x",
                                *(pControl->pulBearerType) ) );
                        }
                        
                        WPLOG( LL_M, LM_CMsg, ( "*BearerType=%08x", 
                            (usXError == GERR_None) ? *(pControl->pulBearerType) : (ULONG)'BAD' ));

                        break;
                    }

                    case ATTR_FramingType:
                    {
                        usXError = GetAvpValueUl(
                            &avp, &pControl->pulFramingType );

                        DBG_if (usXError == GERR_None)
                        {
                            TRACE( TL_A, TM_CMsg, ( "*FramingType=$%08x",
                                *(pControl->pulFramingType) ) );
                        }

                        WPLOG( LL_M, LM_CMsg, ( "*FramingType=$%08x", 
                            (usXError == GERR_None) ? *(pControl->pulFramingType) : (ULONG)'BAD' ));
                            
                        break;
                    }

                    case ATTR_PacketProcDelay:
                    {
                        usXError = GetAvpValueUs(
                            &avp, &pControl->pusPacketProcDelay );

                        DBG_if (usXError == GERR_None)
                        {
                            TRACE( TL_A, TM_CMsg, ( "*PPD=%d",
                                (ULONG )(*(pControl->pusPacketProcDelay)) ) );
                        }
                        
                        WPLOG( LL_M, LM_CMsg, ( "*PPD=%d", 
                            (usXError == GERR_None) ? (ULONG )(*(pControl->pusPacketProcDelay)) : -1 ));

                        break;
                    }

                    case ATTR_DialedNumber:
                    {
                        usXError = GetAvpValueVariableAch(
                            &avp,
                            &pControl->pchDialedNumber,
                            &pControl->usDialedNumberLength );

                        DBG_if (usXError == GERR_None)
                        {
                            TRACE( TL_A, TM_CMsg, ( "*Dialed#" ) );
                        }
                        
                        WPLOG( LL_M, LM_CMsg, ( "*Dialed# %s", 
                            (usXError == GERR_None) ? "*" : "bad" ));
                        
                        break;
                    }

                    case ATTR_DialingNumber:
                    {
                        usXError = GetAvpValueVariableAch(
                            &avp,
                            &pControl->pchDialingNumber,
                            &pControl->usDialingNumberLength );

                        DBG_if (usXError == GERR_None)
                        {
                            TRACE( TL_A, TM_CMsg, ( "*Dialing#" ) );
                        }
                        
                        WPLOG( LL_M, LM_CMsg, ( "*Dialing# %s", 
                            (usXError == GERR_None) ? "*" : "bad" ));

                        break;
                    }

                    case ATTR_SubAddress:
                    {
                        usXError = GetAvpValueVariableAch(
                            &avp,
                            &pControl->pchSubAddress,
                            &pControl->usSubAddressLength );

                        DBG_if (usXError == GERR_None)
                        {
                            TRACE( TL_A, TM_CMsg, ( "*SubAddr" ) );
                        }
                        
                        WPLOG( LL_M, LM_CMsg, ( "*SubAddr %s", 
                            (usXError == GERR_None) ? "*" : "bad" ));

                        break;
                    }

                    case ATTR_TxConnectSpeed:
                    {
                        usXError = GetAvpValueUl(
                            &avp, &pControl->pulTxConnectSpeed );

                        DBG_if (usXError == GERR_None)
                        {
                            TRACE( TL_A, TM_CMsg, ( "*TxSpeed=%d",
                                *(pControl->pulTxConnectSpeed) ) );
                        }
                        
                        WPLOG( LL_M, LM_CMsg, ( "*TxSpeed=%d", 
                            (usXError == GERR_None) ? *(pControl->pulTxConnectSpeed) : -1 ));

                        break;
                    }

                    case ATTR_PhysicalChannelId:
                    {
                        usXError = GetAvpValueUl(
                            &avp, &pControl->pulPhysicalChannelId );

                        DBG_if (usXError == GERR_None)
                        {
                            TRACE( TL_A, TM_CMsg, ( "*PhysChannelId=$%08x",
                                *(pControl->pulPhysicalChannelId) ) );
                        }
                        
                        WPLOG( LL_M, LM_CMsg, ( "*PhysChannelId=%08x", 
                            (usXError == GERR_None) ? *(pControl->pulPhysicalChannelId) : (ULONG)'BAD' ));

                        break;
                    }

                    case ATTR_Challenge:
                    {
                        usXError = GetAvpValueVariableAch(
                            &avp,
                            &pControl->pchChallenge,
                            &pControl->usChallengeLength );

                        DBG_if (usXError == GERR_None)
                        {
                            TRACE( TL_A, TM_CMsg, ( "*Challenge" ) );
                        }
                        
                        WPLOG( LL_M, LM_CMsg, ( "*Challenge %s", 
                            (usXError == GERR_None) ? "*" : "bad" ));

                        break;
                    }

                    case ATTR_ChallengeResponse:
                    {
                        usXError = GetAvpValueFixedAch(
                            &avp, 16, &pControl->pchResponse );

                        DBG_if (usXError == GERR_None)
                        {
                            TRACE( TL_A, TM_CMsg, ( "*ChallengeResp" ) );
                        }
                        
                        WPLOG( LL_M, LM_CMsg, ( "*ChallengeResp %s", 
                            (usXError == GERR_None) ? "*" : "bad" ));

                        break;
                    }

                    case ATTR_ProxyAuthType:
                    {
                        usXError = GetAvpValueUs(
                            &avp, &pControl->pusProxyAuthType );

                        DBG_if (usXError == GERR_None)
                        {
                            TRACE( TL_A, TM_CMsg, ( "*ProxyAuthType=%d",
                                (ULONG )(*(pControl->pusProxyAuthType)) ) );
                        }

                        WPLOG( LL_M, LM_CMsg, ( "*ProxyAuthType=%d", 
                            (usXError == GERR_None) ? (ULONG )(*(pControl->pusProxyAuthType)) : -1 ));
                                                
                        break;
                    }

                    case ATTR_ProxyAuthResponse:
                    {
                        usXError = GetAvpValueVariableAch(
                            &avp,
                            &pControl->pchProxyAuthResponse,
                            &pControl->usProxyAuthResponseLength );

                        DBG_if (usXError == GERR_None)
                        {
                            TRACE( TL_A, TM_CMsg, ( "*ProxyAuthResponse" ) );
                        }
                        
                        WPLOG( LL_M, LM_CMsg, ( "*ProxyAuthResponse %s", 
                            (usXError == GERR_None) ? "*" : "bad" ));

                        break;
                    }

                    case ATTR_CallErrors:
                    {
                        usXError = GetAvpValueFixedAul(
                            &avp, 6, &pControl->pulCallErrors );

                        DBG_if (usXError == GERR_None)
                        {
                            TRACE( TL_A, TM_CMsg, ( "*CallErrors" ) );
                        }
                        
                        WPLOG( LL_M, LM_CMsg, ( "*CallErrors %s", 
                            (usXError == GERR_None) ? "*" : "bad" ));

                        break;
                    }

                    case ATTR_Accm:
                    {
                        usXError = GetAvpValueFixedAul(
                            &avp, 2, &pControl->pulAccm );

                        DBG_if (usXError == GERR_None)
                        {
                            TRACE( TL_A, TM_CMsg, ( "*Accm" ) );
                        }
                        
                        WPLOG( LL_M, LM_CMsg, ( "*Accm %s", 
                            (usXError == GERR_None) ? "*" : "bad" ));

                        break;
                    }

                    case ATTR_SequencingRequired:
                    {
                        usXError = GetAvpValueFlag(
                            &avp, &pControl->fSequencingRequired );

                        DBG_if (usXError == GERR_None)
                        {
                            TRACE( TL_A, TM_CMsg, ( "*SeqReqd" ) );
                        }
                        
                        WPLOG( LL_M, LM_CMsg, ( "*SeqReqd %s", 
                            (usXError == GERR_None) ? "*" : "bad" ));
                        
                        break;
                    }

                    default:
                    {
                        // The AVP is not one we handle.  If optional, just
                        // ignore it, but if mandatory, fail.
                        //
                        TRACE( TL_A, TM_CMsg, ( "*AVP %d ignored", (ULONG )*avp.pusAttribute ) );
                        WPLOG( LL_A, LM_CMsg, ( "*AVP %d ignored", (ULONG )*avp.pusAttribute ) );
                                                         
                        if (*avp.pusBits & ABM_M)
                        {
                            if (*avp.pusAttribute <= ATTR_MAX)
                            {
                                // This is a bug in the peer, but ignoring it
                                // is the best action.
                                //
                                TRACE( TL_A, TM_CMsg, 
                                    ( "Known AVP %d marked mandatory ignored",
                                    (LONG )(*avp.pusAttribute) ) );
                                    
                                WPLOG( LL_A, LM_CMsg, 
                                    ( "Known AVP %d marked mandatory ignored",
                                    (LONG )(*avp.pusAttribute) ) );
                            }
                            else
                            {
                                usXError = GERR_BadValue;
                            }
                        }
                        break;
                    }
                }

                if (usXError != GERR_None)
                {
                    break;
                }
            }

            ASSERT( pCur <= pEndOfBuffer );
            break;
        }

        default:
        {
            TRACE( TL_A, TM_CMsg, ( "Unknown CMT %d", (ULONG )*(pControl->pusMsgType) ) );
            WPLOG( LL_A, LM_CMsg, ( "Unknown CMT %d", (ULONG )*(pControl->pusMsgType) ) );
            usXError = GERR_BadValue;
            break;
        }
    }

    DBG_if (usXError != GERR_None)
        TRACE( TL_A, TM_CMsg, ( "XError=%d", (UINT )usXError ) );

    pControl->usXError = usXError;
}


USHORT
ExplodeL2tpHeader(
    IN CHAR* pL2tpHeader,
    IN ULONG ulBufferLength,
    IN OUT L2TPHEADERINFO* pInfo )

    // Fills caller's '*pInfo' with the addresses of the various fields in the
    // L2TP header at 'pL2tpHeader'.  Fields not present are returned as NULL.
    // The byte order of the fields in 'pL2tpHeader' is flipped to
    // host-byte-order in place.  'UlBufferLength' is the length in bytes from
    // 'pL2tpHeader' to the end of the buffer.
    //
    // Returns GERR_None if 'pL2tpHeader' is a coherent L2TP header, or a
    // GERR_* failure code.
    //
{
    USHORT *pusCur;
    USHORT usOffset;
    USHORT usBits;
    PUSHORT pusEndBuffer = (PUSHORT)(pL2tpHeader + ulBufferLength) - 1;

    pusCur = (USHORT*)pL2tpHeader;

    // The first 2 bytes contain bits that indicate the presence/absence of
    // the other header fields.
    //
    *pusCur = ntohs( *pusCur );
    pInfo->pusBits = pusCur;
    usBits = *pusCur;
    ++pusCur;

    // The T bit indicates a control packet, as opposed to a payload packet.
    //
    if (usBits & HBM_T)
    {
        // Verify the field-present bits guaranteed to be set/clear in a
        // control header are set correctly.
        //
        if ((usBits & HBM_Bits) != HBM_Control)
        {
            TRACE( TL_A, TM_CMsg, ( "Header: Bad bits=$%04x?", (ULONG )usBits ) );
            WPLOG( LL_A, LM_CMsg, ( "Header: Bad bits=$%04x?", (ULONG )usBits ) );
            return GERR_BadValue;
        }
    }

    // Verify the version indicates L2TP.  Cisco's L2F can theoretically
    // co-exist on the same media address, though we don't support that.
    //
    if ((usBits & HBM_Ver) != VER_L2tp)
    {
        TRACE( TL_A, TM_Recv, ( "Header: Non-L2TP Ver=%d?", (usBits & HBM_Ver )) );
        WPLOG( LL_A, LM_Recv, ( "Header: Non-L2TP Ver=%d?", (usBits & HBM_Ver )) );
        return GERR_BadValue;
    }

    // The L bit indicates a Length field is present.
    //
    if (usBits & HBM_L)
    {
        *pusCur = ntohs( *pusCur );
        pInfo->pusLength = pusCur;
        ++pusCur;
    }
    else
    {
        pInfo->pusLength = NULL;
    }

    // The Tunnel-ID field is always present.
    //
    *pusCur = ntohs( *pusCur );
    pInfo->pusTunnelId = pusCur;
    ++pusCur;

    // The Call-ID field is always present.
    //
    if(pusCur > pusEndBuffer)
    {
        return GERR_BadValue;
    }
    *pusCur = ntohs( *pusCur );
    pInfo->pusCallId = pusCur;
    ++pusCur;

    // The F bit indicates the Ns and Nr fields are present.
    //
    if (usBits & HBM_F)
    {
        if(pusCur > pusEndBuffer)
        {
            return GERR_BadValue;
        }
    
        *pusCur = ntohs( *pusCur );
        pInfo->pusNs = pusCur;
        ++pusCur;
        
        if(pusCur > pusEndBuffer)
        {
            return GERR_BadValue;
        }
        
        *pusCur = ntohs( *pusCur );
        pInfo->pusNr = pusCur;
        ++pusCur;
    }
    else
    {
        pInfo->pusNs = NULL;
        pInfo->pusNr = NULL;
    }

    // The S bit indicates the Offset field is present.  The S bit appears in
    // the payload header only, as was verified above.
    //
    if (usBits & HBM_S)
    {
        if(pusCur > pusEndBuffer)
        {
            return GERR_BadValue;
        }
    
        *pusCur = ntohs( *pusCur );
        usOffset = *pusCur;
        ++pusCur;
    }
    else
    {
        usOffset = 0;
    }

    // End and length of header.
    //
    pInfo->pData = ((CHAR* )pusCur) + usOffset;
    pInfo->ulHeaderLength = (ULONG )(pInfo->pData - pL2tpHeader);

    // "Official" data length.
    //
    if (pInfo->pusLength)
    {
        // Verify any specified length is at least as long as the set header
        // bits imply and no longer than the received buffer.
        //
        if (*(pInfo->pusLength) < pInfo->ulHeaderLength
            || *(pInfo->pusLength) > ulBufferLength)
        {
            TRACE( TL_A, TM_Recv, ( "Header: Bad Length?" ) );
            WPLOG( LL_A, LM_Recv, ( "Header: Bad Length? Length = %d, HeaderLength = %d", 
                *(pInfo->pusLength), pInfo->ulHeaderLength) );
            return GERR_BadLength;
        }

        // Use the L2TP length as the "official" length, i.e. any strange
        // bytes received beyond what the L2TP header says it sent will be
        // ignored.
        //
        pInfo->ulDataLength = *(pInfo->pusLength) - pInfo->ulHeaderLength;

        DBG_if( *(pInfo->pusLength) != ulBufferLength )
            TRACE( TL_A, TM_Recv, ( "EOB padding ignored" ) );
    }
    else
    {
        // Verify any implied length is at least as long as the set header
        // bits imply.
        //
        if (ulBufferLength < pInfo->ulHeaderLength)
        {
            TRACE( TL_A, TM_Recv, ( "Header: Bad Length?" ) );
            WPLOG( LL_A, LM_Recv, ( "Header: Bad Length? BufferLength = %d, HeaderLength = %d",
                 ulBufferLength, pInfo->ulHeaderLength) );
            return GERR_BadLength;
        }

        // No length field so the received buffer length is the "official"
        // length.
        //
        pInfo->ulDataLength = ulBufferLength - pInfo->ulHeaderLength;
    }

    return GERR_None;
}


USHORT
GetAvpValueFixedAch(
    IN AVPINFO* pAvp,
    IN USHORT usArraySize,
    OUT CHAR** ppch )

    // Set callers '*ppch' to point to value field of AVP 'pAvp' containing an
    // array of 'usArraySize' bytes.  No byte ordering is done.
    //
    // Returns GERR_None if successful, or a GERR_* error code.
    //
{
    // Make sure it's the right size.
    //
    if (pAvp->usValueLength != usArraySize)
    {
        return GERR_BadLength;
    }

    *ppch = pAvp->pValue;
    return GERR_None;
}


USHORT
GetAvpValueFixedAul(
    IN AVPINFO* pAvp,
    IN USHORT usArraySize,
    OUT UNALIGNED ULONG** paulArray )

    // Set callers '*paulArray' to point to value field of AVP 'pAvp'
    // containing an array of 'usArraySize' ULONGs, converted to host
    // byte-order.  A 2-byte reserved field is assumed to preceed the first
    // ULONG.
    //
    // Returns GERR_None if successful, or a GERR_* error code.
    //
{
    USHORT* pusCur;
    UNALIGNED ULONG* pulCur;
    ULONG i;

    // Make sure it's the right size.
    //
    if (pAvp->usValueLength != sizeof(USHORT) + (usArraySize * sizeof(ULONG)))
    {
        return GERR_BadLength;
    }

    pusCur = (USHORT* )pAvp->pValue;

    // Skip over and ignore the 'Reserved' field.
    //
    ++pusCur;

    *paulArray = (UNALIGNED ULONG* )pusCur;
    for (i = 0, pulCur = *paulArray;
         i < usArraySize;
         ++i, ++pulCur)
    {
        // Convert to host byte-order.
        //
        *pulCur = ntohl( *pulCur );
    }

    return GERR_None;
}


USHORT
GetAvpValueFlag(
    IN AVPINFO* pAvp,
    OUT UNALIGNED BOOLEAN* pf )

    // Set callers '*pf' to true since with a flag AVP the existence is the
    // data, and performs the routine AVP validations.
    //
    // Returns GERR_None if successful, or a GERR_* error code.
    //
{
    // Make sure it's the right size.
    //
    if (pAvp->usValueLength != 0)
    {
        return GERR_BadLength;
    }

    *pf = TRUE;

    return GERR_None;
}


USHORT
GetAvpValueUs(
    IN AVPINFO* pAvp,
    OUT UNALIGNED USHORT** ppus )

    // Set callers '*ppus' to point to the USHORT value field of AVP 'pAvp'.
    // The field is host byte-ordered.
    //
    // Returns GERR_None if successful, or a GERR_* error code.
    //
{
    UNALIGNED USHORT* pusCur;

    // Make sure it's the right size.
    //
    if (pAvp->usValueLength != sizeof(USHORT))
    {
        return GERR_BadLength;
    }

    // Convert in place to host byte-order.
    //
    pusCur = (USHORT* )pAvp->pValue;
    *pusCur = ntohs( *pusCur );
    *ppus = pusCur;

    return GERR_None;
}


USHORT
GetAvpValue2UsAndVariableAch(
    IN AVPINFO* pAvp,
    OUT UNALIGNED USHORT** ppus1,
    OUT UNALIGNED USHORT** ppus2,
    OUT CHAR** ppch,
    OUT USHORT* pusArraySize )

    // Gets the data from an AVP with 2 USHORTs followed by a variable length
    // array.  Sets '*ppus1' and '*ppus2' to the two short integers and
    // '*ppus' to the variable length array.  '*PusArraySize is set to the
    // length of the '*ppch' array.  'pAvp'.  The field is host byte-ordered.
    //
    // Returns GERR_None if successful, or a GERR_* error code.
    //
{
    UNALIGNED USHORT* pusCur;

    // Make sure it's the right size.
    //
    if (pAvp->usValueLength < sizeof(USHORT))
    {
        return GERR_BadLength;
    }

    // Convert in place to host byte-order.
    //
    pusCur = (USHORT* )pAvp->pValue;
    *pusCur = ntohs( *pusCur );
    *ppus1 = pusCur;
    ++pusCur;
    
    // NOTE: second ushort value and the rest are optional
    if (pAvp->usValueLength >= (2 * sizeof(USHORT)))
    {
        *pusCur = ntohs( *pusCur );
        *ppus2 = pusCur;
    }
    else
    {
        *ppus2 = NULL;
    }

    ++pusCur;

    if (pAvp->usValueLength > (2 * sizeof(USHORT)))
    {
        *ppch = (CHAR* )pusCur;
        *pusArraySize = pAvp->usValueLength - (2 * sizeof(USHORT));
    }
    else
    {
        *ppch = NULL;
        *pusArraySize = 0;
    }

    return GERR_None;
}


USHORT
GetAvpValueUl(
    IN AVPINFO* pAvp,
    OUT UNALIGNED ULONG** ppul )

    // Set callers '*ppul' to point to the ULONG value field of AVP 'pAvp'.
    // The field is host byte-ordered.
    //
    // Returns GERR_None if successful, or a GERR_* error code.
    //
{
    UNALIGNED ULONG* pulCur;

    // Make sure it's the right size.
    //
    if (pAvp->usValueLength != sizeof(ULONG))
    {
        return GERR_BadLength;
    }

    // Convert in place to host byte-order.
    //
    pulCur = (UNALIGNED ULONG* )pAvp->pValue;
    *pulCur = ntohl( *pulCur );
    *ppul = pulCur;

    return GERR_None;
}


USHORT
GetAvpValueVariableAch(
    IN AVPINFO* pAvp,
    OUT CHAR** ppch,
    OUT USHORT* pusArraySize )

    // Set callers '*ppch' to point to value field of AVP 'pAvp' containing an
    // array of bytes, where '*pusArraySize' is set to the length in bytes.
    // No byte ordering is done.
    //
    // Returns GERR_None if successful, or a GERR_* error code.
    //
{
    // The win9x clients send null host names. Remove the check.
    //if(pAvp->usValueLength == 0 || pAvp->pValue[0] == '\0')
    //{
    //    return GERR_BadLength;
    //}

    *pusArraySize = pAvp->usValueLength;
    *ppch = pAvp->pValue;

    return GERR_None;
}


VOID
HelloTimerEvent(
    IN TIMERQITEM* pItem,
    IN VOID* pContext,
    IN TIMERQEVENT event )

    // PTIMERQEVENT handler set to expire when a "Hello" interval has expired.
    //
{
    ADAPTERCB* pAdapter;
    TUNNELCB* pTunnel;
    BOOLEAN fReusedTimerQItem;

    TRACE( TL_V, TM_Send,
        ( "HelloTimerEvent(%s)", TimerQPszFromEvent( event ) ) );

    // Unpack context information.
    //
    pTunnel = (TUNNELCB* )pContext;
    pAdapter = pTunnel->pAdapter;

    fReusedTimerQItem = FALSE;

    if (event == TE_Expire)
    {
        NdisAcquireSpinLock( &pTunnel->lockT );
        {
            if (pTunnel->ulHelloResetsThisInterval == 0
                && pTunnel->ulRemainingHelloMs == 0)
            {
                if (pTunnel->state != CCS_Idle && pItem == pTunnel->pTqiHello)
                {
                    // The full timeout period has expired, the tunnel's not
                    // idle, and the hello timer was not cancelled or
                    // terminated since the expire timer fired.  It's time to
                    // send a "Hello" message to make sure the media is still
                    // up.
                    //
                    SendControl( pTunnel, NULL, CMT_Hello, 0, 0, NULL, 0 );
                }
                DBG_else
                {
                    TRACE( TL_A, TM_Send, ( "Hello aborted" ) );
                }

                pTunnel->pTqiHello = NULL;
            }
            else
            {
                ULONG ulTimeoutMs;

                // Not a full timeout expiration event.  Adjust interval
                // counters and schedule next interval timeout.
                //
                if (pTunnel->ulHelloResetsThisInterval > 0)
                {
                    pTunnel->ulRemainingHelloMs = pAdapter->ulHelloMs;
                    pTunnel->ulHelloResetsThisInterval = 0;
                }

                if (pTunnel->ulRemainingHelloMs >= L2TP_HelloIntervalMs)
                {
                    ulTimeoutMs = L2TP_HelloIntervalMs;
                    pTunnel->ulRemainingHelloMs -= L2TP_HelloIntervalMs;
                }
                else
                {
                    ulTimeoutMs = pTunnel->ulRemainingHelloMs;
                    pTunnel->ulRemainingHelloMs = 0;
                }

                TimerQInitializeItem( pItem );
                TimerQScheduleItem(
                    pTunnel->pTimerQ,
                    pItem,
                    ulTimeoutMs,
                    HelloTimerEvent,
                    pTunnel );

                fReusedTimerQItem = TRUE;
            }
        }
        NdisReleaseSpinLock( &pTunnel->lockT );
    }

    if (!fReusedTimerQItem)
    {
        FREE_TIMERQITEM( pAdapter, pItem );
    }
}


VOID
IndicateReceived(
    IN VCCB* pVc,
    IN CHAR* pBuffer,
    IN ULONG ulOffset,
    IN ULONG ulLength,
    IN LONGLONG llTimeReceived )

    // Indicates to the client above a packet received on VC 'pVc' containing
    // 'ulLength' bytes of data from NDIS_BUFFER 'pBuffer' starting 'ulOffset'
    // bytes in.  Caller must not reference 'pBuffer' after calling this
    // routine.  'UllTimeReceived' is the time the packet was received from
    // the net, or 0 if call parameters said client doesn't care.
    //
    // IMPORTANT: Caller should not hold any spinlocks as this routine make
    //            NDIS indications.
    //
{
    NDIS_STATUS status;
    NDIS_PACKET* pPacket;
    NDIS_BUFFER* pTrimmedBuffer;
    ADAPTERCB* pAdapter;
    PACKETHEAD* pHead;
    LONG* plRef;
    LONG lRef;

    pAdapter = pVc->pAdapter;

    pPacket = GetPacketFromPool( &pAdapter->poolPackets, &pHead );
    if (!pPacket)
    {
        // Packet descriptor pool is maxed.
        //
        FreeBufferToPool( &pAdapter->poolFrameBuffers, pBuffer, TRUE );
        return;
    }

    // Lop off the L2TP header and hook the corresponding NDIS_BUFFER to the
    // packet.  The "copy" here refers to descriptor information only.  The
    // packet data is not copied.
    //
    NdisCopyBuffer(
        &status,
        &pTrimmedBuffer,
        PoolHandleForNdisCopyBufferFromBuffer( pBuffer ),
        NdisBufferFromBuffer( pBuffer ),
        ulOffset,
        ulLength );

    if (status != STATUS_SUCCESS)
    {
        // Can't get a MDL which likely means the system is toast.
        //
        TRACE( TL_A, TM_Recv, ( "NdisCopyBuffer=%08x?", status ) );
        WPLOG( LL_A, LM_Recv, ( "NdisCopyBuffer=%08x?", status ) );
        FreePacketToPool( &pAdapter->poolPackets, pHead, TRUE );
        FreeBufferToPool( &pAdapter->poolFrameBuffers, pBuffer, TRUE );
        return;
    }
    else
    {
        extern ULONG g_ulNdisCopyBuffers;

        NdisInterlockedIncrement( &g_ulNdisCopyBuffers );
    }

    NdisChainBufferAtFront( pPacket, pTrimmedBuffer );

    // Stash the time the packet was received in the packet.
    //
    NDIS_SET_PACKET_TIME_RECEIVED( pPacket, llTimeReceived );

    // Pre-set the packet to success, since a random value of
    // NDIS_STATUS_RESOURCES would prevent our ReturnPackets handler from
    // getting called.
    //
    NDIS_SET_PACKET_STATUS( pPacket, NDIS_STATUS_SUCCESS );

    // Stash our context information with the packet for clean-up use in
    // LmpReturnPacket, then indicate the packet to NDISWAN.
    //
    *((PACKETHEAD** )(&pPacket->MiniportReserved[ 0 ])) = pHead;
    *((CHAR** )(&pPacket->MiniportReserved[ sizeof(VOID*) ])) = pBuffer;

    TRACE( TL_N, TM_Recv, ( "NdisMCoIndRecPkt(len=%d)...", ulLength ) );
    NdisMCoIndicateReceivePacket( pVc->NdisVcHandle, &pPacket, 1 );
    TRACE( TL_N, TM_Recv, ( "NdisMCoIndRecPkt done" ) );

    // Tell NDIS our "receive process" is complete.  Since we deal with one
    // packet at a time and NDISWAN does also, this doesn't accomplish
    // anything, but the consensus is it's bad form to omit it.
    //
    TRACE( TL_N, TM_Recv, ( "NdisMCoRecComp..." ) );
    NdisMCoReceiveComplete( pAdapter->MiniportAdapterHandle );
    TRACE( TL_N, TM_Recv, ( "NdisMCoRecComp done" ) );

    NdisInterlockedIncrement( &g_lPacketsIndicated );

    NdisAcquireSpinLock( &pVc->lockV );
    {
        ++pVc->stats.ulRecdDataPackets;
        pVc->stats.ulDataBytesRecd += ulLength;
    }
    NdisReleaseSpinLock( &pVc->lockV );
}


TUNNELCB*
TunnelCbFromTunnelId(
    IN ADAPTERCB* pAdapter,
    IN USHORT usTunnelId )

    // Return the tunnel control block associated with 'ulIpAddress' in
    // 'pAdapter's list of TUNNELCBs or NULL if not found.
    //
    // IMPORTANT:  Caller must hold 'pAdapter->lockTunnels'.
    //
{
    TUNNELCB* pTunnel;
    LIST_ENTRY* pLink;

    pTunnel = NULL;

    for (pLink = pAdapter->listTunnels.Flink;
         pLink != &pAdapter->listTunnels;
         pLink = pLink->Flink)
    {
        TUNNELCB* pThis;

        pThis = CONTAINING_RECORD( pLink, TUNNELCB, linkTunnels );
        if (pThis->usTunnelId == usTunnelId)
        {
            pTunnel = pThis;
            break;
        }
    }

    return pTunnel;
}


BOOLEAN
LookUpTunnelAndVcCbs(
    IN ADAPTERCB* pAdapter,
    IN USHORT* pusTunnelId,
    IN USHORT* pusCallId,
    IN L2TPHEADERINFO* pHeader,
    IN CONTROLMSGINFO* pControl,
    OUT TUNNELCB** ppTunnel,
    OUT VCCB** ppVc )

    // Fill caller's '*ppTunnel' and '*ppVc' with the control blocks implied
    // by the Tunnel-ID and Call-ID found in the header, if any.  'PHeader' is
    // the exploded L2TP header.  'PControl' is the exploded control message
    // info or NULL if payload.
    //
    // Returns true if a valid combination is found.  This does not
    // necessarily mean that both tunnel and VC outputs are non-NULL.
    //
    // Returns false if the combination is invalid.  In this case, the packet
    // is zombie acked if necessary.  See ZombieAckIfNecessary routine.
    //
{
    BOOLEAN fFail;

    *ppVc = NULL;
    *ppTunnel = NULL;

    // As of draft-05 Tunnel-ID and Call-ID are no longer optional.
    //
    ASSERT( pusCallId );
    ASSERT( pusTunnelId );

    if (*pusCallId)
    {
        // Non-0 Call-ID must have non-0 Tunnel-ID
        if(!*pusTunnelId)
        {
            return FALSE;
        }
    
        if (*pusCallId > pAdapter->usMaxVcs)
        {
            // Non-0 Call-ID out of range of the table, i.e. it's a VC that is
            // being used for graceful termination and is not passed up.  Look
            // up tunnel and VC blocks by walking lists.
            //
            // Search the adapter's list of active tunnels for the one
            // with peer's specified Tunnel-ID.
            //
            NdisAcquireSpinLock( &pAdapter->lockTunnels );
            {
                *ppTunnel = TunnelCbFromTunnelId( pAdapter, *pusTunnelId );
                if (*ppTunnel)
                {
                    ReferenceTunnel( *ppTunnel, TRUE );
                }
            }
            NdisReleaseSpinLock( &pAdapter->lockTunnels );

            if (*ppTunnel)
            {
                // Search the tunnel's list of active VCs for the one with
                // peer's specified Call-ID.
                //
                NdisAcquireSpinLock( &((*ppTunnel)->lockVcs) );
                {
                    *ppVc = VcCbFromCallId( *ppTunnel, *pusCallId );
                    if (*ppVc)
                    {
                        ReferenceVc( *ppVc );
                    }
                }
                NdisReleaseSpinLock( &((*ppTunnel)->lockVcs) );

                if (!*ppVc)
                {
                    // Non-0 Call-ID out of range of table with no
                    // associated VC control block.
                    //
                    TRACE( TL_A, TM_Recv, ( "CBs bad: Big CID w/!pV" ) );
                    WPLOG( LL_A, LM_Recv, ( "CBs bad: Big CID w/!pV" ) );
                    ZombieAckIfNecessary( *ppTunnel, pHeader, pControl );
                    DereferenceTunnel( *ppTunnel );
                    *ppTunnel = NULL;
                    return FALSE;
                }
            }
            else
            {
                // Non-0 Call-ID out of range of table with no tunnel
                // control block associated with the Tunnel-ID.
                //
                TRACE( TL_A, TM_Recv, ( "CBs bad: Big CID w/!pT" ) );
                WPLOG( LL_A, LM_Recv, ( "CBs bad: Big CID w/!pT" ) );
                return FALSE;
            }
        }
        else
        {
            // Read the VCCB* from the adapter's table.
            //
            fFail = FALSE;
            NdisDprAcquireSpinLock( &pAdapter->lockVcs );
            {
                *ppVc = pAdapter->ppVcs[ *pusCallId - 1 ];

                if (*ppVc && *ppVc != (VCCB* )-1)
                {
                    ReferenceVc( *ppVc );

                    *ppTunnel = (*ppVc)->pTunnel;
                    ASSERT( *ppTunnel );
                    ReferenceTunnel( *ppTunnel, FALSE );

                    if(*pusTunnelId != (*ppTunnel)->usTunnelId)
                    {
                        // Non-0 Call-ID is associated with a tunnel different
                        // than the one indicated by peer in the header.
                        //
                        TRACE( TL_A, TM_Recv,
                            ( "CBs bad: TIDs=%d,%d?",
                            (ULONG )*pusTunnelId,
                            (ULONG )(*ppTunnel)->usTunnelId ) );

                        WPLOG( LL_A, LM_Recv,
                            ( "CBs bad: TIDs=%d,%d?",
                            (ULONG )*pusTunnelId,
                            (ULONG )(*ppTunnel)->usTunnelId ) );
                               
                        DereferenceTunnel( *ppTunnel );
                        *ppTunnel = NULL;
                        DereferenceVc( *ppVc );
                        *ppVc = NULL;
                        fFail = TRUE;
                    }
                }
                else
                {
                    // Non-0 Call-ID without an active VC.
                    //
                    TRACE( TL_A, TM_Recv,
                        ( "CBs bad: CID=%d, pV=$%p?",
                        (ULONG )*pusCallId, *ppVc ) );

                    WPLOG( LL_A, LM_Recv,
                        ( "CBs bad: CID=%d, pV=$%p?",
                        (ULONG )*pusCallId, *ppVc ) );
                           
                    // Search the adapter's list of active tunnels for the one
                    // with peer's specified Tunnel-ID.
                    //
                    NdisAcquireSpinLock( &pAdapter->lockTunnels );
                    {
                        *ppTunnel = TunnelCbFromTunnelId(
                            pAdapter, *pusTunnelId );
                        if (*ppTunnel)
                        {
                            ReferenceTunnel( *ppTunnel, TRUE );
                        }
                    }
                    NdisReleaseSpinLock( &pAdapter->lockTunnels );

                    *ppVc = NULL;
                    fFail = TRUE;
                }
            }
            NdisDprReleaseSpinLock( &pAdapter->lockVcs );

            if (fFail)
            {
                if (*ppTunnel)
                {
                    ZombieAckIfNecessary( *ppTunnel, pHeader, pControl );
                    DereferenceTunnel( *ppTunnel );
                    *ppTunnel = NULL;
                }

                return FALSE;
            }
        }
    }
    else if (*pusTunnelId)
    {
        // 0 Call-ID with non-0 Tunnel-ID.  Search the list of active tunnels
        // for the one with peer's specified Tunnel-ID.
        //
        NdisAcquireSpinLock( &pAdapter->lockTunnels );
        {
            *ppTunnel = TunnelCbFromTunnelId( pAdapter, *pusTunnelId );
            if (*ppTunnel)
            {
                ReferenceTunnel( *ppTunnel, TRUE );
            }
        }
        NdisReleaseSpinLock( &pAdapter->lockTunnels );

        if (!*ppTunnel)
        {
            // 0 Call-Id with bogus Tunnel-ID.
            //
            TRACE( TL_A, TM_Recv,
                ( "CBs bad: Cid=0, Tid=%d, pT=0?",
                (ULONG )*pusTunnelId ) );
                
            WPLOG( LL_A, LM_Recv,
                ( "CBs bad: Cid=0, Tid=%d, pT=0?",
                (ULONG )*pusTunnelId ) );
                
            return FALSE;
        }

        if (pControl
            && pControl->usXError == GERR_None
            && pControl->pusMsgType
            && *(pControl->pusMsgType) == CMT_CDN
            && pControl->pusAssignedCallId)
        {
            // The CallDisconnectNotify message includes the sender's assigned
            // Call-ID as an AVP so that it may be sent before sender receives
            // peer's assigned Call-ID.  Unfortunately, this requires this
            // routine to have AVP knowledge.  Search the tunnel's list of
            // associated VCs for the one with peer's specified Assigned
            // Call-ID.
            //
            NdisDprAcquireSpinLock( &((*ppTunnel)->lockVcs) );
            {
                *ppVc = VcCbFromCallId(
                    *ppTunnel, *(pControl->pusAssignedCallId) );

                if (*ppVc)
                {
                    ReferenceVc( *ppVc );
                }
            }
            NdisDprReleaseSpinLock( &((*ppTunnel)->lockVcs) );

            if (!*ppVc)
            {
                // 0 Call-Id CDN with no associated VC.
                //
                TRACE( TL_A, TM_Recv,
                    ( "CBs bad: CDN Tid %d, !pVc?", (ULONG )*pusTunnelId ) );
                    
                WPLOG( LL_A, LM_Recv,
                    ( "CBs bad: CDN Tid %d, !pVc?", (ULONG )*pusTunnelId ) );
                    
                ZombieAckIfNecessary( *ppTunnel, pHeader, pControl );
                DereferenceTunnel( *ppTunnel );
                *ppTunnel = NULL;
                return FALSE;
            }
        }
    }

    // Note: 0 Call-ID with 0 Tunnel-ID should only occur on peer's SCCRQ to
    // start a tunnel, but that means it's not an error here, even though we
    // report back neither control block.

    ASSERT( !*ppTunnel || (*ppTunnel)->ulTag == MTAG_TUNNELCB );
    ASSERT( !*ppVc || (*ppVc)->ulTag == MTAG_VCCB );
    TRACE( TL_N, TM_Recv,
        ( "CBs good: pT=$%p, pV=$%p", *ppTunnel, *ppVc ) );

    return TRUE;
}


VOID
PayloadAcknowledged(
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN USHORT usReceivedNr )

    // Cancels the timer of all payload-sent contexts in the VCs
    // 'listSendsOut' queue with 'Next Sent' less than 'usReceivedNr'.
    //
    // IMPORTANT: Caller must hold 'pVc->lockV', which may be released and
    //            re-acquired by this routine.  Caller must not hold any other
    //            locks.
    //
{
    while (!IsListEmpty( &pVc->listSendsOut ))
    {
        PAYLOADSENT* pPs;
        LIST_ENTRY* pLink;
        BOOLEAN fUpdateSendWindow;
        LINKSTATUSINFO info;

        pLink = pVc->listSendsOut.Flink;
        pPs = CONTAINING_RECORD( pLink, PAYLOADSENT, linkSendsOut );

        // The list is in 'Ns' order so as soon as a non-acknowledge is hit
        // we're done.
        //
        if (CompareSequence( pPs->usNs, usReceivedNr ) >= 0)
        {
            break;
        }

        // This packet has been acknowledged.
        //
        pPs->status = NDIS_STATUS_SUCCESS;

        // Remove the context from the head of the "outstanding send" list.
        // The corresponding dereference occurs below.
        //
        RemoveEntryList( &pPs->linkSendsOut );
        InitializeListHead( &pPs->linkSendsOut );

        // Doesn't matter if this cancel fails because the expire handler will
        // recognize that the context is not linked into the "out" list and do
        // nothing.
        //
        TimerQCancelItem( pTunnel->pTimerQ, pPs->pTqiSendTimeout );

        // Adjust the timeouts and, if necessary, the send window as suggested
        // in the draft/RFC.
        //
        AdjustTimeoutsAtAckReceived(
            pPs->llTimeSent,
            pTunnel->pAdapter->ulMaxSendTimeoutMs,
            &pVc->ulSendTimeoutMs,
            &pVc->ulRoundTripMs,
            &pVc->lDeviationMs );

        fUpdateSendWindow =
            AdjustSendWindowAtAckReceived(
                pVc->ulMaxSendWindow,
                &pVc->ulAcksSinceSendTimeout,
                &pVc->ulSendWindow );

        TRACE( TL_V, TM_Send,
            ( "C%d: ACK(%d) new rtt=%d dev=%d ato=%d sw=%d",
            (ULONG )pVc->usCallId, (ULONG )pPs->usNs,
            pVc->ulRoundTripMs, pVc->ulSendTimeoutMs,
            pVc->lDeviationMs, pVc->ulSendWindow ) );

        // Update the statistics the reflect the acknowledge, it's round trip
        // time, and any change in the send window.  The field
        // 'pVc->UlRoundTripMs' is really an "estimate" of the next round trip
        // rather than the actual trip time.  However, just after an
        // acknowledge has been received, the two are identical so it can be
        // used in the statistics here.
        //
        ++pVc->stats.ulSentPacketsAcked;
        ++pVc->stats.ulRoundTrips;
        pVc->stats.ulRoundTripMsTotal += pVc->ulRoundTripMs;

        if (pVc->ulRoundTripMs > pVc->stats.ulMaxRoundTripMs)
        {
            pVc->stats.ulMaxRoundTripMs = pVc->ulRoundTripMs;
        }

        if (pVc->ulRoundTripMs < pVc->stats.ulMinRoundTripMs
            || pVc->stats.ulRoundTrips == 1)
        {
            pVc->stats.ulMinRoundTripMs = pVc->ulRoundTripMs;
        }

        if (fUpdateSendWindow)
        {
            ++pVc->stats.ulSendWindowChanges;

            if (pVc->ulSendWindow > pVc->stats.ulMaxSendWindow)
            {
                pVc->stats.ulMaxSendWindow = pVc->ulSendWindow;
            }
            else if (pVc->ulSendWindow < pVc->stats.ulMinSendWindow)
            {
                pVc->stats.ulMinSendWindow = pVc->ulSendWindow;
            }

            // Indicate the send window change to NDISWAN.  The lock is
            // released first since this involves a call outside our driver.
            //
            TransferLinkStatusInfo( pVc, &info );
            NdisReleaseSpinLock( &pVc->lockV );
            {
                IndicateLinkStatus( pVc, &info );
            }
            NdisAcquireSpinLock( &pVc->lockV );
        }

        // This dereference corresponds to the removal of the context from the
        // "outstanding send" list above.
        //
        DereferencePayloadSent( pPs );
    }
}


BOOLEAN
ReceiveFromOutOfOrder(
    IN VCCB* pVc )

    // "Receives" the first buffer queued on 'pVc's out-of-order list if it is
    // the next expected packet.
    //
    // Returns true if a buffer was "received", false otherwise.  If true is
    // returned, caller should call SchedulePayloadAck.  It's not called here
    // so caller can receive multiple packets from the out-of-order queue and
    // set the timer once.
    //
    // IMPORTANT: Caller must hold 'pVc->lockV'.  Also, be aware this routine
    //            may release and re-acquire the lock to make the NDIS receive
    //            indication.
    //
{
    ADAPTERCB* pAdapter;
    LIST_ENTRY* pFirstLink;
    PAYLOADRECEIVED* pFirstPr;
    SHORT sDiff;

    TRACE( TL_N, TM_Recv, ( "ReceiveFromOutOfOrder Nr=%d", pVc->usNr ) );

    if (IsListEmpty( &pVc->listOutOfOrder ))
    {
        // No out-of-order buffers queued.
        //
        TRACE( TL_N, TM_Recv, ( "None queued" ) );
        return FALSE;
    }

    pAdapter = pVc->pAdapter;
    pFirstLink = pVc->listOutOfOrder.Flink;
    pFirstPr = CONTAINING_RECORD( pFirstLink, PAYLOADRECEIVED, linkOutOfOrder );

    // Verify the next queued buffer is in sequence first.
    //
    sDiff = CompareSequence( pFirstPr->usNs, pVc->usNr );
    if (sDiff > 0)
    {
        // No, first queued packet is still beyond the next one expected.
        //
        TRACE( TL_I, TM_Recv,
            ( "Still out-of-order, Ns=%d", pFirstPr->usNs ) );
        return FALSE;
    }

    // De-queue the first out-of-order buffer and if it's exactly the one we
    // expected, update 'Next Receive'to be the one following it's 'Next
    // Send'.  When peer sends an R-bit to set 'Next Receive' ahead, packets
    // prior to the new expected packet may be queued before the expected
    // packet.  These packets are still good and are immediately indicated up,
    // but since 'Next Receive' is already updated in that case, it is not
    // adjusted here.
    //
    RemoveEntryList( pFirstLink );
    InitializeListHead( pFirstLink );

    if (sDiff == 0)
    {
        pVc->usNr = pFirstPr->usNs + 1;
    }

    TRACE( TL_I, TM_Recv, ( "%d from queue", (UINT )pFirstPr->usNs ) );
    ++pVc->stats.ulDataPacketsDequeued;

    NdisReleaseSpinLock( &pVc->lockV );
    {
        // Indicate the buffer to the driver above, and free it's out-of-order
        // context.
        //
        IndicateReceived(
            pVc,
            pFirstPr->pBuffer,
            pFirstPr->ulPayloadOffset,
            pFirstPr->ulPayloadLength,
            pFirstPr->llTimeReceived );

        FREE_PAYLOADRECEIVED( pAdapter, pFirstPr );
    }
    NdisAcquireSpinLock( &pVc->lockV );

    return TRUE;
}


VOID
ResetHelloTimer(
    IN TUNNELCB* pTunnel )

    // Resets (logically anyway) the 'pTunnel' Hello timer.
    //
{
    ADAPTERCB* pAdapter;

    pAdapter = pTunnel->pAdapter;

    if (pAdapter->ulHelloMs)
    {
        NdisAcquireSpinLock( &pTunnel->lockT );
        {
            if (pTunnel->state != CCS_Idle)
            {
                if (pTunnel->pTqiHello)
                {
                    TRACE( TL_V, TM_Send, ( "Reset HelloTimer" ) );

                    // Timer's running so just note that a reset has occurred
                    // since it was started.
                    //
                    ++pTunnel->ulHelloResetsThisInterval;
                }
                else
                {
                    TRACE( TL_I, TM_Send, ( "Kickstart HelloTimer" ) );

                    // Timer is not running.  Kickstart it by scheduling an
                    // "instant expire" event that will reset the interval.
                    //
                    pTunnel->pTqiHello = ALLOC_TIMERQITEM( pAdapter );
                    if (pTunnel->pTqiHello)
                    {
                        pTunnel->ulHelloResetsThisInterval = 1;
                        pTunnel->ulRemainingHelloMs = 0;

                        TimerQInitializeItem( pTunnel->pTqiHello );
                        TimerQScheduleItem(
                            pTunnel->pTimerQ,
                            pTunnel->pTqiHello,
                            0,
                            HelloTimerEvent,
                            pTunnel );
                    }
                }
            }
        }
        NdisReleaseSpinLock( &pTunnel->lockT );
    }
}


VOID
ScheduleControlAck(
    IN TUNNELCB* pTunnel,
    IN USHORT usMsgTypeToAcknowledge )

    // Schedule a 'ControlAckTimerEvent' to occur in 1/4 of the standard send
    // timeout.  If one's already ticking no action is taken, because any
    // packet that goes out will get it done.  Doesn't matter who requested
    // it.  'UsMsgTypeToAcknowledge' is the CMT_* code of the message to be
    // acknowledged and is used for performance tuning.
    //
    // IMPORTANT: Caller must hold 'pTunnel->lockT'.
    //
{
    TIMERQITEM* pTqi;
    ADAPTERCB* pAdapter;
    ULONG ulDelayMs;
    BOOLEAN fFastAck;

    if ((usMsgTypeToAcknowledge == CMT_StopCCN
            || usMsgTypeToAcknowledge == CMT_ICCN
            || usMsgTypeToAcknowledge == CMT_OCCN
            || usMsgTypeToAcknowledge == CMT_CDN)
        || (pTunnel->ulSendsOut < pTunnel->ulSendWindow))
    {
        TRACE( TL_N, TM_Recv, ( "Fast ACK" ) );

        // Certain messages where follow-on messages are unlikely are
        // acknowledged without delay, as are all messages when the send
        // window is closed.
        //
        fFastAck = TRUE;
    }
    else
    {
        fFastAck = FALSE;
    }

    if (pTunnel->pTqiDelayedAck)
    {
        if (fFastAck)
        {
            TimerQExpireItem( pTunnel->pTimerQ, pTunnel->pTqiDelayedAck );
        }
    }
    else
    {
        pAdapter = pTunnel->pAdapter;
        pTqi = ALLOC_TIMERQITEM( pAdapter );
        if (!pTqi)
        {
            return;
        }

        pTunnel->pTqiDelayedAck = pTqi;

        if (fFastAck)
        {
            ulDelayMs = 0;
        }
        else
        {
            ulDelayMs = pTunnel->ulSendTimeoutMs >> 2;
            if (ulDelayMs > pAdapter->ulMaxAckDelayMs)
            {
                ulDelayMs = pAdapter->ulMaxAckDelayMs;
            }
        }

        TRACE( TL_N, TM_Recv, ( "SchedControlAck(%dms)", ulDelayMs ) );

        ReferenceTunnel( pTunnel, FALSE );
        TimerQInitializeItem( pTqi );
        TimerQScheduleItem(
             pTunnel->pTimerQ,
             pTqi,
             ulDelayMs,
             ControlAckTimerEvent,
             pTunnel );
    }
}


VOID
SchedulePayloadAck(
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc )

    // Schedule a 'PayloadAckTimerEvent' to occur in 1/4 of the standard send
    // timeout.  If one's already ticking no action is taken, because any
    // packet that goes out will get it done.  Doesn't matter who requested
    // it.
    //
    // IMPORTANT: Caller must hold 'pVc->lockV'.
    //
{
    ADAPTERCB* pAdapter;
    TIMERQITEM* pTqi;
    ULONG ulDelayMs;

    if (!pVc->pTqiDelayedAck)
    {
        pAdapter = pVc->pAdapter;
        pTqi = ALLOC_TIMERQITEM( pAdapter );
        if (!pTqi)
        {
            return;
        }

        pVc->pTqiDelayedAck = pTqi;

        ulDelayMs = pVc->ulSendTimeoutMs >> 2;
        if (ulDelayMs > pAdapter->ulMaxAckDelayMs)
        {
            ulDelayMs = pAdapter->ulMaxAckDelayMs;
        }

        TRACE( TL_N, TM_Recv,
            ( "SchedPayloadAck(%dms)=$%p", ulDelayMs, pTqi ) );

        ReferenceVc( pVc );
        TimerQInitializeItem( pTqi );
        TimerQScheduleItem(
             pTunnel->pTimerQ,
             pTqi,
             ulDelayMs,
             PayloadAckTimerEvent,
             pVc );
    }
}


VCCB*
VcCbFromCallId(
    IN TUNNELCB* pTunnel,
    IN USHORT usCallId )

    // Return the VC control block associated with 'usCallId' in 'pTunnel's
    // list of active VCs or NULL if not found.
    //
    // IMPORTANT:  Caller must hold 'pTunnel->lockVcs'.
    //
{
    VCCB* pVc;
    LIST_ENTRY* pLink;

    pVc = NULL;

    for (pLink = pTunnel->listVcs.Flink;
         pLink != &pTunnel->listVcs;
         pLink = pLink->Flink)
    {
        VCCB* pThis;

        pThis = CONTAINING_RECORD( pLink, VCCB, linkVcs );
        if (pThis->usCallId == usCallId)
        {
            pVc = pThis;
            break;
        }
    }

    return pVc;
}


VOID
ZombieAckIfNecessary(
    IN TUNNELCB* pTunnel,
    IN L2TPHEADERINFO* pHeader,
    IN CONTROLMSGINFO* pControl )

    // Determines if a message not matched to any VC warrants a "zombie"
    // re-acknowledge, and if so, schedules one.  This situation arises when
    // our side sends an acknowledge to peer's CDN on a given call and the
    // acknowledge is lost.  Our side tears down the VC immediately, but peer
    // will eventually drop the entire tunnel if no acknowledge of his follow
    // on CDN retransmits are received, thus affecting calls beyond the one
    // dropped.  This routine acknowledges such retransmissions.
    //
    // Another simpler approach would be to take a reference on the call and
    // hold it for a full retransmission interval before dereferencing.
    // However, this would block the drop indications up and would therefore,
    // from dial-out user's point of view, cause a potentially long delay
    // whenever server disconnected a call.  This is judged undesirable enough
    // to tolerate the zombie ack messiness.
    //
    // 'PTunnel' is the associated tunnel control block.  'PHeader' is the
    // exploded L2TP header.  'PControl' is the exploded control header, or
    // NULL if not a control message.  Caller should already have determined
    // that no VC is associated with the message.
    //
{
    if (pControl
        && pControl->usXError == GERR_None
        && pControl->pusMsgType
        && *(pControl->pusMsgType) == CMT_CDN
        && pControl->pusAssignedCallId)
    {
        // It's a CDN message and a candidate for re-acknowledgement.  See if
        // it's sequence number is prior to or equal to the next expected
        // packet.  If so, schedule a zombie acknowledge.
        //
        if (CompareSequence( *(pHeader->pusNs), pTunnel->usNr ) <= 0)
        {
            TRACE( TL_A, TM_Send, ( "Zombie acking" ) );

            NdisAcquireSpinLock( &pTunnel->lockT );
            {
                // Cancel any pending delayed acknowledge timeout.
                //
                if (pTunnel->pTqiDelayedAck)
                {
                    TimerQCancelItem(
                        pTunnel->pTimerQ, pTunnel->pTqiDelayedAck );
                    pTunnel->pTqiDelayedAck = NULL;
                }
            }
            NdisReleaseSpinLock( &pTunnel->lockT );

            ScheduleTunnelWork(
                pTunnel, NULL, SendControlAck, 0, 0, 0, 0, FALSE, FALSE );
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ndis\rasl2tp\ppool.c ===
// Copyright (c) 1997, Microsoft Corporation, all rights reserved
//
// ppool.c
// RAS L2TP WAN mini-port/call-manager driver
// Packet pool management routines
//
// 01/07/97 Steve Cobb, adapted from Gurdeep's WANARP code.


#include "l2tpp.h"

#include "ppool.tmh"

// Debug count of detected double-frees that should not be happening.
//
ULONG g_ulDoublePacketFrees = 0;


//-----------------------------------------------------------------------------
// Local prototypes (alphabetically)
//-----------------------------------------------------------------------------

PACKETHEAD*
AddPacketBlockToPool(
    IN PACKETPOOL* pPool );

VOID
FreeUnusedPacketPoolBlocks(
    IN PACKETPOOL* pPool );


//-----------------------------------------------------------------------------
// Interface routines
//-----------------------------------------------------------------------------

VOID
InitPacketPool(
    OUT PACKETPOOL* pPool,
    IN ULONG ulProtocolReservedLength,
    IN ULONG ulMaxPackets,
    IN ULONG ulPacketsPerBlock,
    IN ULONG ulFreesPerCollection,
    IN ULONG ulTag )

    // Initialize caller's packet pool control block 'pPool'.
    // 'UlProtocolReservedLength' is the size in bytes of the
    // 'ProtocolReserved' array of each individual packet.  'UlMaxPackets' is
    // the maximum number of packets allowed in the entire pool, or 0 for
    // unlimited.  'UlPacketsPerBlock' is the number of packets to include in
    // each block of packets.  'UlFreesPerCollection' is the number of
    // FreePacketToPool calls until the next garbage collect scan, or 0 for
    // default.  'UlTag' is the memory identification tag to use when
    // allocating blocks.
    //
    // IMPORTANT: Caller's 'pPool' packet must be protected from multiple
    //            access during this call.
    //
{
    pPool->ulProtocolReservedLength = ulProtocolReservedLength;
    pPool->ulPacketsPerBlock = ulPacketsPerBlock;
    pPool->ulMaxPackets = ulMaxPackets;
    pPool->ulFreesSinceCollection = 0;
    pPool->ulTag = ulTag;

    if (ulFreesPerCollection)
    {
        pPool->ulFreesPerCollection = ulFreesPerCollection;
    }
    else
    {
        // Calculate default garbage collection trigger.  Don't want to be too
        // aggressive here.
        //
        pPool->ulFreesPerCollection = 200 * pPool->ulPacketsPerBlock;
    }

    TRACE( TL_N, TM_Pool, ( "InitPp tag=$%08x pr=%d cnt=%d",
        pPool->ulTag,
        pPool->ulProtocolReservedLength,
        pPool->ulPacketsPerBlock ) );

    InitializeListHead( &pPool->listBlocks );
    InitializeListHead( &pPool->listFreePackets );
    NdisAllocateSpinLock( &pPool->lock );
}


BOOLEAN
FreePacketPool(
    IN PACKETPOOL* pPool )

    // Free up all resources allocated in packet pool 'pPool'.  This is the
    // inverse of InitPacketPool.
    //
    // Returns true if successful, false if any of the pool could not be freed
    // due to outstanding packets.
    //
{
    BOOLEAN fSuccess;

    TRACE( TL_N, TM_Pool, ( "FreePp" ) );

    NdisAcquireSpinLock( &pPool->lock );
    {
        FreeUnusedPacketPoolBlocks( pPool );
        fSuccess = (pPool->ulCurPackets == 0);
    }
    NdisReleaseSpinLock( &pPool->lock );

    return fSuccess;
}


NDIS_PACKET*
GetPacketFromPool(
    IN PACKETPOOL* pPool,
    OUT PACKETHEAD** ppHead )

    // Returns the address of the NDIS_PACKET descriptor allocated from the
    // pool 'pPool'.  The pool is expanded, if necessary, but caller should
    // still check for NULL return since the pool may have been at maximum
    // size.  'PpHead' is the "cookie" that is used to return the packet to
    // the pool (see FreePacketToPool).  Caller would normally stash this
    // value in the appropriate 'reserved' areas of the packet for retrieval
    // later.
    //
{
    LIST_ENTRY* pLink;
    PACKETHEAD* pHead;
    NDIS_PACKET* pPacket;

    NdisAcquireSpinLock( &pPool->lock );
    {
        if (IsListEmpty( &pPool->listFreePackets ))
        {
            pLink = NULL;
        }
        else
        {
            pLink = RemoveHeadList( &pPool->listFreePackets );
            InitializeListHead( pLink );
            pHead = CONTAINING_RECORD( pLink, PACKETHEAD, linkFreePackets );
            --pHead->pBlock->ulFreePackets;
        }
    }
    NdisReleaseSpinLock( &pPool->lock );

    if (!pLink)
    {
        // The free list was empty.  Try to expand the pool.
        //
        pHead = AddPacketBlockToPool( pPool );
        if (!pHead)
        {
            TRACE( TL_A, TM_Pool, ( "GetPfP failed?" ) );
            return NULL;
        }
    }

    TRACE( TL_N, TM_Pool,
        ( "GetPfP=$%p/h=$%p, %d free",
        pHead->pNdisPacket, pHead, pHead->pBlock->ulFreePackets ) );

    *ppHead = pHead;
    return pHead->pNdisPacket;
}


VOID
FreePacketToPool(
    IN PACKETPOOL* pPool,
    IN PACKETHEAD* pHead,
    IN BOOLEAN fGarbageCollection )

    // Returns 'pPacket' to the pool of unused packets 'pPool'.  'PPacket'
    // must have been previously allocated with GetPacketFromPool.
    // 'FGarbageCollection' is set when the free should be considered for
    // purposes of garbage collection.  This is used by the AddPacketToPool
    // routine to avoid counting the initial "add" frees.  Normal callers
    // should set this flag.
    //
{
    DBG_if (fGarbageCollection)
    {
        TRACE( TL_N, TM_Pool,
            ( "FreePtoP($%p,h=$%p) %d free",
            pHead->pNdisPacket, pHead, pHead->pBlock->ulFreePackets ) );
    }

    NdisAcquireSpinLock( &pPool->lock );
    do
    {
        if (pHead->linkFreePackets.Flink != &pHead->linkFreePackets)
        {
            ASSERT( !"Double free?" );
            WPLOG( LL_A, LM_Pool, ( "Double free pHead = %p", pHead ) );
            ++g_ulDoublePacketFrees;
            break;
        }

        InsertHeadList( &pPool->listFreePackets, &pHead->linkFreePackets );
        ++pHead->pBlock->ulFreePackets;

        if (fGarbageCollection)
        {
            ++pPool->ulFreesSinceCollection;

            if (pPool->ulFreesSinceCollection >= pPool->ulFreesPerCollection)
            {
                // Time to collect garbage, i.e. free any blocks in the pool
                // not in use.
                //
                FreeUnusedPacketPoolBlocks( pPool );
                pPool->ulFreesSinceCollection = 0;
            }
        }
    }
    while (FALSE);
    NdisReleaseSpinLock( &pPool->lock );
}


VOID
CollectPacketPoolGarbage(
    PACKETPOOL* pPool )

    // Force a garbage collection event on the pool 'pPool'.
    //
{
    NdisAcquireSpinLock( &pPool->lock );
    {
        FreeUnusedPacketPoolBlocks( pPool );
        pPool->ulFreesSinceCollection = 0;
    }
    NdisReleaseSpinLock( &pPool->lock );
}


//-----------------------------------------------------------------------------
// Utility routines (alphabetically)
//-----------------------------------------------------------------------------

PACKETHEAD*
AddPacketBlockToPool(
    IN PACKETPOOL* pPool )

    // Allocate a new packet block and add it to the packet pool 'pPool'.
    //
    // Returns the PACKETHEAD allocated from the pool or NULL if none.
    //
{
    NDIS_STATUS status;
    PACKETBLOCKHEAD* pNew;
    ULONG ulSize;
    ULONG ulCount;
    BOOLEAN fOk;
    PACKETHEAD* pReturn;

    TRACE( TL_A, TM_Pool, ( "AddPpBlock(%d+%d)",
        pPool->ulCurPackets, pPool->ulPacketsPerBlock ) );

    fOk = FALSE;
    pNew = NULL;

    NdisAcquireSpinLock( &pPool->lock );
    {
        do
        {
            if (pPool->ulMaxPackets
                && pPool->ulCurPackets >= pPool->ulMaxPackets)
            {
                // No can do.  The pool's already at maximum size.
                //
                TRACE( TL_A, TM_Pool, ( "Pp maxed?" ) );
                WPLOG( LL_A, LM_Pool, ( "Pp maxed?" ) );
                break;
            }

            // Calculate the contiguous block's size and the number of packets
            // it will hold.
            //
            ulCount = pPool->ulPacketsPerBlock;
            if (pPool->ulMaxPackets)
            {
                if (ulCount > pPool->ulMaxPackets - pPool->ulCurPackets)
                {
                    ulCount = pPool->ulMaxPackets - pPool->ulCurPackets;
                }
            }
            ulSize = sizeof(PACKETBLOCKHEAD) + (ulCount * sizeof(PACKETHEAD));

            // Allocate the contiguous memory block for the PACKETBLOCK header
            // and the individual PACKETHEADs.
            //
            pNew = ALLOC_NONPAGED( ulSize, pPool->ulTag );
            if (!pNew)
            {
                TRACE( TL_A, TM_Res, ( "Alloc PB?") );
                WPLOG( LL_A, LM_Res, ( "Failed to allocate PB") );
                break;
            }

            /* Zero only the block header portion.
            */
            NdisZeroMemory( pNew, sizeof(PACKETBLOCKHEAD) );

            // Allocate a pool of NDIS_PACKET descriptors.
            //
            NdisAllocatePacketPool(
                &status,
                &pNew->hNdisPool,
                ulCount,
                pPool->ulProtocolReservedLength );

            if (status != NDIS_STATUS_SUCCESS)
            {
                TRACE( TL_A, TM_Pool, ( "AllocPp=$%x?", status ) );
                WPLOG( LL_A, LM_Pool, ( "AllocPp=$%x?", status ) );
                break;
            }

            // Fill in the back pointer to the pool.
            //
            pNew->pPool = pPool;

            // Link the new block.  At this point, all the packets are
            // effectively "in use".  They are made available in the loop
            // below.
            //
            pNew->ulPackets = ulCount;
            pPool->ulCurPackets += ulCount;
            InsertHeadList( &pPool->listBlocks, &pNew->linkBlocks );

            fOk = TRUE;
        }
        while (FALSE);
    }
    NdisReleaseSpinLock( &pPool->lock );

    if (!fOk)
    {
        // Bailing, undo whatever succeeded.
        //
        if (pNew)
        {
            if (pNew->hNdisPool)
            {
                NdisFreePacketPool( pNew->hNdisPool );
            }
            FREE_NONPAGED( pNew );
        }

        return NULL;
    }

    // Initialize each individual packet header and add it to the list of free
    // packets.
    //
    {
        ULONG i;
        PACKETHEAD* pHead;

        pReturn = NULL;

        // For each PACKETHEAD of the block...
        //
        for (i = 0, pHead = (PACKETHEAD* )(pNew + 1);
             i < ulCount;
             ++i, ++pHead)
        {
            InitializeListHead( &pHead->linkFreePackets );
            pHead->pBlock = pNew;
            pHead->pNdisPacket = NULL;

            // Associate an NDIS_PACKET descriptor from the pool we
            // allocated above.
            //
            NdisAllocatePacket( &status, &pHead->pNdisPacket, pNew->hNdisPool );

            if (status != NDIS_STATUS_SUCCESS)
            {
                TRACE( TL_A, TM_Pool, ( "AllocP=$%x?", status ) );
                WPLOG( LL_A, LM_Pool, ( "AllocP=$%x?", status ) );
                pHead->pNdisPacket = NULL;
                continue;
            }

            if (pReturn)
            {
                // Add the constructed packet to the list of free packets.
                // The 'FALSE' tells the garbage collection algorithm the
                // operation is an "add" rather than a "release" and should be
                // ignored.
                //
                FreePacketToPool( pPool, pHead, FALSE );
            }
            else
            {
                // The first successfully constructed packet is returned by
                // this routine.
                //
                pReturn = pHead;
            }
        }
    }

    return pReturn;
}


VOID
FreeUnusedPacketPoolBlocks(
    IN PACKETPOOL* pPool )

    // Check if any of the blocks in pool 'pPool' are not in use, and if so,
    // free them.
    //
    // IMPORTANT: Caller must hold the pool lock.
    //
    // NOTE: The MSDN doc says that no locks may be held while calling
    // NdisFreePacketXxx, but according to JameelH that is incorrect.
    //
{
    LIST_ENTRY* pLink;

    TRACE( TL_A, TM_Pool, ( "FreeUnusedPpBlocks" ) );

    // For each block in the pool...
    //
    pLink = pPool->listBlocks.Flink;
    while (pLink != &pPool->listBlocks)
    {
        LIST_ENTRY* pLinkNext;
        PACKETBLOCKHEAD* pBlock;

        pLinkNext = pLink->Flink;

        pBlock = CONTAINING_RECORD( pLink, PACKETBLOCKHEAD, linkBlocks );
        if (pBlock->ulFreePackets >= pBlock->ulPackets)
        {
            ULONG i;
            PACKETHEAD* pHead;

            TRACE( TL_A, TM_Pool, ( "FreePpBlock(%d-%d)",
                pPool->ulCurPackets, pPool->ulPacketsPerBlock ) );

            // Found a block with no packets in use.  Walk the packet block
            // removing each packet from the pool's free list and freeing any
            // associated NDIS_PACKET descriptor.
            //
            for (i = 0, pHead = (PACKETHEAD* )(pBlock + 1);
                 i < pBlock->ulPackets;
                 ++i, ++pHead)
            {
                RemoveEntryList( &pHead->linkFreePackets );
                InitializeListHead( &pHead->linkFreePackets );

                if (pHead->pNdisPacket)
                {
                    NdisFreePacket( pHead->pNdisPacket );
                }
            }

            // Remove and release the unused block.
            //
            RemoveEntryList( pLink );
            InitializeListHead( pLink );
            pPool->ulCurPackets -= pBlock->ulPackets;

            if (pBlock->hNdisPool)
            {
                NdisFreePacketPool( pBlock->hNdisPool );
            }

            FREE_NONPAGED( pBlock );
        }

        pLink = pLinkNext;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ndis\rasl2tp\ppool.h ===
// Copyright (c) 1997, Microsoft Corporation, all rights reserved
//
// ppool.h
// RAS L2TP WAN mini-port/call-manager driver
// Packet pool management header
//
// 01/07/97 Steve Cobb, adapted from Gurdeep's WANARP code.


#ifndef _PPOOL_H_
#define _PPOOL_H_


//-----------------------------------------------------------------------------
// Data structures
//-----------------------------------------------------------------------------

// Packet pool control block.  A packet pool encapsulates an NDIS packet pool
// handling all pool growth and shrinkage internally.
//
typedef struct
_PACKETPOOL
{
    // Size in bytes of the ProtocolReserved array for each packet in the
    // pool.
    //
    ULONG ulProtocolReservedLength;

    // The optimal number of packets to allocate in each packet block.
    //
    ULONG ulPacketsPerBlock;

    // Maximum number of individual packets that may be allocated in the
    // entire pool, or 0 for unlimited.
    //
    ULONG ulMaxPackets;

    // Current number of individual packets allocated in the entire pool.
    //
    ULONG ulCurPackets;

    // Garbage collection occurs after this many calls to FreePacketToPool.
    //
    ULONG ulFreesPerCollection;

    // Number of calls to FreeBufferToPool since a garbage collection.
    //
    ULONG ulFreesSinceCollection;

    // Memory identification tag for allocated blocks.
    //
    ULONG ulTag;

    // Head of the double linked list of PACKETBLOCKHEADs.  Access to the list
    // is protected with 'lock' in this structure.
    //
    LIST_ENTRY listBlocks;

    // Head of the double linked list of free PACKETHEADs.  Each PACKETHEAD in
    // the list is ready to go, i.e. it already has an NDIS_PACKET associated
    // with it.  Access to the list is prototected by 'lock' in this
    // structure.  Interlocked push/pop is not used because (a) the list of
    // blocks and this list must lock each other and (b) double links are
    // necessary for garbage collection.
    //
    LIST_ENTRY listFreePackets;

    // This lock protects this structure and both the list of blocks and the
    // list of packets.
    //
    NDIS_SPIN_LOCK lock;
}
PACKETPOOL;


// Header of a single block of packets from a packet pool.  The PACKETHEAD of
// the first buffer immediately follows.
//
typedef struct
_PACKETBLOCKHEAD
{
    // Links to the prev/next packet block header in the packet pool's list.
    //
    LIST_ENTRY linkBlocks;

    // NDIS's handle of the pool of NDIS_PACKET descriptors associated with
    // this block, or NULL if none.
    //
    NDIS_HANDLE hNdisPool;

    // Back pointer to the packet pool.
    //
    PACKETPOOL* pPool;

    // Number of individual packets in this block.
    //
    ULONG ulPackets;

    // Number of individual packets in this block on the free list.
    //
    ULONG ulFreePackets;
}
PACKETBLOCKHEAD;


// Control information for an individual packet.  For the packet pool, this
// "header" does not actually preceed anything, but this keeps the terminology
// consistent with the very similar buffer pool routines.
//
typedef struct
_PACKETHEAD
{
    // Link to next packet header in the packet pool's free list.
    //
    LIST_ENTRY linkFreePackets;

    // Back link to owning packet block header.
    //
    PACKETBLOCKHEAD* pBlock;

    // NDIS packet descriptor of this buffer.
    //
    NDIS_PACKET* pNdisPacket;
}
PACKETHEAD;


//-----------------------------------------------------------------------------
// Interface prototypes and inline definitions
//-----------------------------------------------------------------------------

VOID
InitPacketPool(
    OUT PACKETPOOL* pPool,
    IN ULONG ulProtocolReservedLength,
    IN ULONG ulMaxPackets,
    IN ULONG ulPacketsPerBlock,
    IN ULONG ulFreesPerCollection,
    IN ULONG ulTag );

BOOLEAN
FreePacketPool(
    IN PACKETPOOL* pPool );

NDIS_PACKET*
GetPacketFromPool(
    IN PACKETPOOL* pPool,
    OUT PACKETHEAD** ppHead );

VOID
FreePacketToPool(
    IN PACKETPOOL* pPool,
    IN PACKETHEAD* pHead,
    IN BOOLEAN fGarbageCollection );

PACKETPOOL*
PacketPoolFromPacketHead(
    IN PACKETHEAD* pHead );

VOID
CollectPacketPoolGarbage(
    PACKETPOOL* pPool );

__inline
PACKETPOOL*
PacketPoolFromPacketHead(
    IN PACKETHEAD* pHead )

    // Returns the address of the pool, given 'pHead', the address of a
    // PACKETHEAD like the one returned from GetPacketFromPool.
    //
{
    return pHead->pBlock->pPool;
}


#endif // PPOOL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ndis\rasl2tp\tdix.h ===
// Copyright (c) 1997, Microsoft Corporation, all rights reserved
//
// tdix.h
// RAS L2TP WAN mini-port/call-manager driver
// TDI extensions header
//
// 01/07/97 Steve Cobb


#ifndef _TDIX_H_
#define _TDIX_H_


//-----------------------------------------------------------------------------
// Datatypes
//-----------------------------------------------------------------------------

// Forward declarations.
//
typedef struct _TDIXCONTEXT TDIXCONTEXT;
typedef struct _TDIXROUTE TDIXROUTE;
typedef enum _HOSTROUTEEXISTS HOSTROUTEEXISTS;

// 'UDP' and 'RawIp' media type address descriptor.
//
typedef struct
_TDIXIPADDRESS
{
    // IP address in network byte order.
    //
    ULONG ulIpAddress;

    // UDP port in network byte order.  Always 0 for 'RawIp' media.
    //
    SHORT sUdpPort;

    // interface index
    uint ifindex; 

}
TDIXIPADDRESS;


// Read datagram information context used to pass context information from the
// ReadDatagram event handler to the RECEIVE_DATAGRAM completion routine.
//
typedef struct
_TDIXRDGINFO
{
    // The associated TDIX context;
    //
    TDIXCONTEXT* pTdix;

    // The source IP address of the received datagram in network byte order.
    //
    TDIXIPADDRESS source;

    // The buffer, allocated from caller's buffer pool, containing the
    // datagram information.
    //
    CHAR* pBuffer;

    // The length of the information copied to caller's buffer.
    //
    ULONG ulBufferLen;

    TDIXIPADDRESS dest;
}
TDIXRDGINFO;

// TDIX client's send-complete handler prototype.  'PTdix' is the TDI
// extension context.  'PContext1' and 'pContext2' are the contexts passed to
// TdixSenddagram.  'PBuffer' is the buffer passed to TdiSendDatagram.
//
typedef
VOID
(*PTDIXSENDCOMPLETE)(
    IN TDIXCONTEXT* pTdix,
    IN VOID* pContext1,
    IN VOID* pContext2,
    IN CHAR* pBuffer );


// Send datagram information context used to pass context information from
// TdixSendDatagram to the send datagram completion handler.
//
typedef struct
_TDIXSDGINFO
{
    // The associated TDIX context;
    //
    TDIXCONTEXT* pTdix;

    // The buffer passed by caller to TdixSendDatagram.
    //
    CHAR* pBuffer;

    // Caller's send-complete handler.
    //
    PTDIXSENDCOMPLETE pSendCompleteHandler;

    // Caller's contexts to be returned to his send-complete handler.
    //
    VOID* pContext1;
    VOID* pContext2;

    // TDI request information.
    //
    TDI_CONNECTION_INFORMATION tdiconninfo;
    TA_IP_ADDRESS taip;
}
TDIXSDGINFO;


#define ALLOC_TDIXRDGINFO( pTdix ) \
    NdisAllocateFromNPagedLookasideList( &(pTdix)->llistRdg )
#define FREE_TDIXRDGINFO( pTdix, pRdg ) \
    NdisFreeToNPagedLookasideList( &(pTdix)->llistRdg, (pRdg) )

#define ALLOC_TDIXSDGINFO( pTdix ) \
    NdisAllocateFromNPagedLookasideList( &(pTdix)->llistSdg )
#define FREE_TDIXSDGINFO( pTdix, pSdg ) \
    NdisFreeToNPagedLookasideList( &(pTdix)->llistSdg, (pSdg) )

#define ALLOC_TDIXROUTE( pTdix ) \
    ALLOC_NONPAGED( sizeof(TDIXROUTE), MTAG_TDIXROUTE )
#define FREE_TDIXROUTE( pTdix, pR ) \
    FREE_NONPAGED( pR )
    

// TDIX client's receive handler prototype.  'PTdix' is the TDI extension
// context.  'PAddress' is the source address of the received datagram, which
// for IP is a network byte-order IP address.  'PBuffer' is the receive buffer
// of 'ulBytesLength' bytes where the first "real" data is at offset
// 'ulOffset'.  It is caller's responsibility to call FreeBufferToPool with
// the same pool passed to TdixInitialize.
//
typedef
VOID
(*PTDIXRECEIVE)(
    IN TDIXCONTEXT* pTdix,
    IN TDIXRDGINFO* pRdg,
    IN CHAR* pBuffer,
    IN ULONG ulOffset,
    IN ULONG ulBufferLength );

//
//
typedef
NDIS_STATUS
(*PTDIX_SEND_HANDLER)(
    IN TDIXCONTEXT* pTdix,
    IN FILE_OBJECT* FileObj,
    IN PTDIXSENDCOMPLETE pSendCompleteHandler,
    IN VOID* pContext1,
    IN VOID* pContext2,
    IN VOID* pAddress,
    IN CHAR* pBuffer,
    IN ULONG ulBufferLength,
    OUT IRP** ppIrp );

// The TDI media types that L2TP can run on.  The values are read from the
// registry, so don't change randomly.
//
typedef enum
_TDIXMEDIATYPE
{
    TMT_RawIp = 1,
    TMT_Udp = 2
}
TDIXMEDIATYPE;



// Context of a TDI extension session.  Code outside the TdixXxx routines
// should avoid referring to fields in this structure.
//
typedef struct
_TDIXCONTEXT
{
    // Reference count on this TDI session.  The reference pairs are:
    //
    // (a) TdixOpen adds a reference that TdixClose removes.
    //
    // (b) TdixAddHostRoute adds a reference when it links a new route into
    //     the TDIXCONTEXT.listRoutes and TdixDeleteHostRoute removes it.
    //
    // The field is accessed only by the ReferenceTdix and DereferenceTdix
    // routines which protect access via 'lock'.
    //
    LONG lRef;

    // Handle of the transport address object returned from ZwCreateFile, and
    // the object address of same.
    //
    HANDLE hAddress;
    FILE_OBJECT* pAddress;
    
    // Handle of the raw IP address object returned from ZwCreateFile, and
    // the object address of same.
    //
    HANDLE hRawAddress;
    FILE_OBJECT* pRawAddress;

    // The media type in use on this context.
    //
    TDIXMEDIATYPE mediatype;

    // Handle of the IP stack address object returned from ZwCreateFile, and
    // the object address of same.  The IP stack address is needed to use the
    // referenced route IOCTLs supported in IP, but not in UDP, i.e. IP route
    // management calls are used in both UDP and raw IP modes.
    //
    HANDLE hIpStackAddress;
    FILE_OBJECT* pIpStackAddress;

    // TDIXF_* bit flags indicating various options and states.  Access is via
    // the interlocked ReadFlags/SetFlags/ClearFlags routines only.
    //
    // TDIXF_Pending: Set when an open or close operation is pending, clear
    //     otherwise.  Access is protected by 'lock'.
    //
    // TDIXF_DisableUdpXsums: Set when UDP checksums should be disabled.
    //
    ULONG ulFlags;
        #define TDIXF_Pending         0x00000001
        #define TDIXF_DisableUdpXsums 0x00000002

    // The strategy employed when it is time to add a host route and that
    // route is found to already exists.
    //
    HOSTROUTEEXISTS hre;

    // The NDIS buffer pool from which buffers for received datagrams are
    // allocated.
    //
    BUFFERPOOL* pPoolNdisBuffers;

    // Client's receive handler called when packets are received.
    //
    PTDIXRECEIVE pReceiveHandler;

    // Double-linked list of TDIXROUTEs.  Access is protected by 'lock'.
    //
    LIST_ENTRY listRoutes;

    // Lookaside list of TDIXRDGINFO blocks, used to pass context information
    // from the ReadDatagram event handler to the RECEIVE_DATAGRAM completion
    // routine.
    //
    NPAGED_LOOKASIDE_LIST llistRdg;

    // Lookaside list of TDIXSDGINFO blocks, used to pass context information
    // from TdixSendDatagram to the SEND_DATAGRAM completion routine.
    //
    NPAGED_LOOKASIDE_LIST llistSdg;

    // Spinlock protecting access to TDIXCONTENT fields as noted in the field
    // descriptions.
    //
    NDIS_SPIN_LOCK lock;
}
TDIXCONTEXT;


typedef struct
_TDIXUDPCONNECTCONTEXT
{
    // Set if we are using different address objects for 
    // control and payload packets.
    //
    BOOLEAN fUsePayloadAddr;

    // Handle and address of the transport address object returned from 
    // ZwCreateFile for sending l2tp control messages on this route.
    //
    HANDLE hCtrlAddr;
    FILE_OBJECT* pCtrlAddr;

    // Handle and address of the transport address object returned from 
    // ZwCreateFile for sending l2tp payloads on this route.
    //
    HANDLE hPayloadAddr;
    FILE_OBJECT* pPayloadAddr;
}
TDIXUDPCONNECTCONTEXT;


// Context information for a single host route.  The contexts are linked into
// the TDIXCONTEXT's list of host routes.  Access to all fields is protected
// by 'TDIXCONTEXT.lockHostRoutes'.
//
typedef struct
_TDIXROUTE
{
    // Double-linked link of 'TDIXCONTEXT.listRoutes'.  The block is linked
    // whenever there is an L2TP host route context for a given route.
    //
    LIST_ENTRY linkRoutes;


    // Host IP address of the route in network byte order.
    //
    ULONG ulIpAddress;

    // Host port in network byte order.
    //
    SHORT sPort;

    // Interface index of added route.
    //
    ULONG InterfaceIndex;

    // Number of references on the route.  A block may be linked with the
    // reference count at zero during deletion but never without the pending
    // flag set.
    //
    LONG lRef;

    // Set when an add or delete of this route is pending.  References should
    // not be taken when either operation is pending.
    //
    BOOLEAN fPending;

    // Set if the route was not actually added because it already exists, i.e.
    // we are in HRE_Use mode and someone besides L2TP added it.
    //
    BOOLEAN fUsedNonL2tpRoute;

    // Set if we are using different address objects for 
    // control and payload packets.
    //
    BOOLEAN fUsePayloadAddr;

    // Handle and address of the transport address object returned from 
    // ZwCreateFile for sending l2tp control messages on this route.
    //
    HANDLE hCtrlAddr;
    FILE_OBJECT* pCtrlAddr;

    // Handle and address of the transport address object returned from 
    // ZwCreateFile for sending l2tp payloads on this route.
    //
    HANDLE hPayloadAddr;
    FILE_OBJECT* pPayloadAddr;
}
TDIXROUTE;

//-----------------------------------------------------------------------------
// Interface prototypes
//-----------------------------------------------------------------------------

VOID
TdixInitialize(
    IN TDIXMEDIATYPE mediatype,
    IN HOSTROUTEEXISTS hre,
    IN ULONG ulFlags,
    IN PTDIXRECEIVE pReceiveHandler,
    IN BUFFERPOOL* pPoolNdisBuffers,
    IN OUT TDIXCONTEXT* pTdix );

NDIS_STATUS
TdixOpen(
    OUT TDIXCONTEXT* pTdix );

VOID
TdixClose(
    IN TDIXCONTEXT* pTdix );

VOID
TdixReference(
    IN TDIXCONTEXT* pTdix );

NDIS_STATUS
TdixSend(
    IN TDIXCONTEXT* pTdix,
    IN FILE_OBJECT* pFileObj,
    IN PTDIXSENDCOMPLETE pSendCompleteHandler,
    IN VOID* pContext1,
    IN VOID* pContext2,
    IN VOID* pAddress,
    IN CHAR* pBuffer,
    IN ULONG ulBufferLength,
    OUT IRP** ppIrp ) ;

NDIS_STATUS
TdixSendDatagram(
    IN TDIXCONTEXT* pTdix,
    IN FILE_OBJECT* pFileObj,
    IN PTDIXSENDCOMPLETE pSendCompleteHandler,
    IN VOID* pContext1,
    IN VOID* pContext2,
    IN VOID* pAddress,
    IN CHAR* pBuffer,
    IN ULONG ulBufferLength,
    OUT IRP** ppIrp );

VOID
TdixDestroyConnection(
    TDIXUDPCONNECTCONTEXT *pUdpContext);
    

NDIS_STATUS
TdixSetupConnection(
    IN TDIXCONTEXT* pTdix,
    IN TDIXROUTE *pTdixRoute,
    IN ULONG ulLocalIpAddress,
    IN TDIXUDPCONNECTCONTEXT* pUdpContext);

VOID*
TdixAddHostRoute(
    IN TDIXCONTEXT* pTdix,
    IN ULONG ulIpAddress,
    IN ULONG ulIfIndex);

VOID
TdixDeleteHostRoute(
    IN TDIXCONTEXT* pTdix,
    IN ULONG ulIpAddress);

NTSTATUS 
TdixGetInterfaceInfo(
    IN TDIXCONTEXT* pTdix,
    IN ULONG ulIpAddress,
    OUT PULONG pulSpeed);

#endif // _TDIX_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ndis\rasl2tp\timer.h ===
// Copyright (c) 1997, Microsoft Corporation, all rights reserved
//
// timer.h
// RAS L2TP WAN mini-port/call-manager driver
// Timer management header
//
// 01/07/97 Steve Cobb
//
// This interface encapsulates the queuing of multiple timer events onto a
// single NDIS timer.


#ifndef _TIMER_H_
#define _TIMER_H_


//-----------------------------------------------------------------------------
// Data structures
//-----------------------------------------------------------------------------

// Forward declarations.
//
typedef struct _TIMERQ TIMERQ;
typedef struct _TIMERQITEM TIMERQITEM;
typedef enum _TIMERQEVENT TIMERQEVENT;


// Timer queue event handler.  'PTqi' and 'pContext' are the timer event
// descriptor and user context passed to TimerQScheduleItem.  'Event' is the
// timer event code indicating whether the timer expired, was cancelled, or
// the queue was terminated.
//
// The "cancel" event is never generated internally, but only by a user call
// to TimerQCancelItem, thus user may require specific locks be held for
// "cancel" events.  User cannot require than specific locks be held for
// "expire" or "terminate" events as these may be generated internally.  User
// should pay attention to the return codes of TimerQCancelItem and
// TimerQTerminateItem calls, as it will occassionally be impossible to stop
// an "expire" event that has not yet been processed from occurring.
//
typedef
VOID
(*PTIMERQEVENT)(
    IN TIMERQITEM* pTqi,
    IN VOID* pContext,
    IN TIMERQEVENT event );

// Timer queue termination completion handler.  'PTimerQ' is the timer queue
// descriptor.  'PContext' is user's context as passed to TimerQTerminate.
// Caller must not free or reuse the TIMERQ before this routine is called.
//
typedef
VOID
(*PTIMERQTERMINATECOMPLETE)(
    IN TIMERQ* pTimerQ,
    IN VOID* pContext );


// Timer queue descriptor.  All access should be via the TimerQ* interface.
// There is no reason user should look inside.  All necessary locking is
// handled internally.
//
typedef struct
_TIMERQ
{
    // Set to MTAG_TIMERQ when the block is valid and to MTAG_FREED when no
    // longer valid.
    //
    LONG ulTag;

    // Head of a double-linked list of "ticking" TIMERQITEMs.  The list is
    // sorted by time to expiration with the earliest expiration at the head
    // of the list.  The list is protected by 'lock'.
    //
    LIST_ENTRY listItems;

    // Caller's terminate complete handler as passed to TimerQTerminate.  This
    // is non-NULL only when our internal timer event handler must call it.
    //
    PTIMERQTERMINATECOMPLETE pHandler;

    // User's PTIMERQTERMINATECOMPLETE context passed back to 'pHandler'.
    //
    VOID* pContext;

    // Set when the timer queue is terminating.  No other requests are
    // accepted when this is the case.
    //
    BOOLEAN fTerminating;

    // Spin lock protecting the 'listItems' list.
    //
    NDIS_SPIN_LOCK lock;

    // NDIS timer object.
    //
    NDIS_TIMER timer;
}
TIMERQ;


// Timer queue event descriptor.  All access should be via the TimerQ*
// interface.  There is no reason user should look inside.  This is exposed to
// allow user to efficiently manage allocation of TIMERQITEMS for several
// timers from a large pool.
//
typedef struct
_TIMERQITEM
{
    // Links to the prev/next TIMERQITEM in the owning TIMERQ's chain of
    // pending timer events.  Access is protected by 'lock' in the TIMERQ
    // structure.
    //
    LIST_ENTRY linkItems;

    // System time at which this event should occur.
    //
    LONGLONG llExpireTime;

    // User's routine to handle the timeout event when it occurs.
    //
    PTIMERQEVENT pHandler;

    // User's PTIMERQEVENT context passed back to 'pHandler'.
    //
    VOID* pContext;
}
TIMERQITEM;


// Indicates the event which triggered user's callback to be called.
//
typedef enum
_TIMERQEVENT
{
    // The timeout interval has elapsed or user called TimerQExpireItem.
    //
    TE_Expire,

    // User called TimerQCancelItem.
    //
    TE_Cancel,

    // User called TimerQTerminateItem or called TimerQTerminate while the
    // item was queued.
    //
    TE_Terminate
}
TIMERQEVENT;


//-----------------------------------------------------------------------------
// Interface prototypes
//-----------------------------------------------------------------------------

BOOLEAN
IsTimerQItemScheduled(
    IN TIMERQITEM* pItem );

VOID
TimerQInitialize(
    IN TIMERQ* pTimerQ );

VOID
TimerQInitializeItem(
    IN TIMERQITEM* pItem );

VOID
TimerQTerminate(
    IN TIMERQ* pTimerQ,
    IN PTIMERQTERMINATECOMPLETE pHandler,
    IN VOID* pContext );

VOID
TimerQScheduleItem(
    IN TIMERQ* pTimerQ,
    IN OUT TIMERQITEM* pNewItem,
    IN ULONG ulTimeoutMs,
    IN PTIMERQEVENT pHandler,
    IN VOID* pContext );

BOOLEAN
TimerQCancelItem(
    IN TIMERQ* pTimerQ,
    IN TIMERQITEM* pItem );

BOOLEAN
TimerQExpireItem(
    IN TIMERQ* pTimerQ,
    IN TIMERQITEM* pItem );

CHAR*
TimerQPszFromEvent(
    IN TIMERQEVENT event );

BOOLEAN
TimerQTerminateItem(
    IN TIMERQ* pTimerQ,
    IN TIMERQITEM* pItem );


#endif // TIMER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ndis\rasl2tp\timer.c ===
// Copyright (c) 1997, Microsoft Corporation, all rights reserved
//
// timer.c
// RAS L2TP WAN mini-port/call-manager driver
// Timer management routines
//
// 01/07/97 Steve Cobb


#include "l2tpp.h"

#include "timer.tmh"

//-----------------------------------------------------------------------------
// Local prototypes (alphabetically)
//-----------------------------------------------------------------------------

BOOLEAN
RemoveTqi(
    IN TIMERQ* pTimerQ,
    IN TIMERQITEM* pItem,
    IN TIMERQEVENT event );

VOID
SetTimer(
    IN TIMERQ* pTimerQ,
    IN LONGLONG llCurrentTime );

VOID
TimerEvent(
    IN PVOID SystemSpecific1,
    IN PVOID FunctionContext,
    IN PVOID SystemSpecific2,
    IN PVOID SystemSpecific3 );


//-----------------------------------------------------------------------------
// Interface routines
//-----------------------------------------------------------------------------

VOID
TimerQInitialize(
    IN TIMERQ* pTimerQ )

    // Initializes caller's timer queue context 'pTimerQ'.
    //
{
    TRACE( TL_N, TM_Time, ( "TqInit" ) );

    InitializeListHead( &pTimerQ->listItems );
    NdisAllocateSpinLock( &pTimerQ->lock );
    NdisInitializeTimer( &pTimerQ->timer, TimerEvent, pTimerQ );
    pTimerQ->pHandler = NULL;
    pTimerQ->fTerminating = FALSE;
    pTimerQ->ulTag = MTAG_TIMERQ;
}


VOID
TimerQInitializeItem(
    IN TIMERQITEM* pItem )

    // Initializes caller's timer queue item, 'pItem'.  This should be called
    // before passing 'pItem' to any other TimerQ routine.
    //
{
    InitializeListHead( &pItem->linkItems );
}


VOID
TimerQTerminate(
    IN TIMERQ* pTimerQ,
    IN PTIMERQTERMINATECOMPLETE pHandler,
    IN VOID* pContext )

    // Terminates timer queue 'pTimerQ'.  Each scheduled item is called back
    // with TE_Terminate.  Caller's 'pHandler' is called with 'pTimerQ' and
    // 'pContext' so the 'pTimerQ' can be freed, if necessary.  Caller's
    // 'pTimerQ' must remain accessible until the 'pHandler' callback occurs,
    // which might be after this routine returns.
    //
{
    BOOLEAN fCancelled;
    LIST_ENTRY list;
    LIST_ENTRY* pLink;

    TRACE( TL_N, TM_Time, ( "TqTerm" ) );

    InitializeListHead( &list );

    NdisAcquireSpinLock( &pTimerQ->lock );
    {
        pTimerQ->fTerminating = TRUE;

        // Stop the timer.
        //
        NdisCancelTimer( &pTimerQ->timer, &fCancelled );
        TRACE( TL_N, TM_Time, ( "NdisCancelTimer" ) );

        if (!fCancelled && !IsListEmpty( &pTimerQ->listItems ))
        {
            // No event was cancelled but the list of events is not empty.
            // This means the timer has fired, but our internal handler has
            // not yet been called to process it, though it eventually will
            // be.  The internal handler must be the one to call the terminate
            // complete in this case, because there is no way for it to know
            // it cannot reference 'pTimerQ'.  Indicate this to the handler by
            // filling in the termination handler.
            //
            TRACE( TL_A, TM_Time, ( "Mid-expire Q" ) );
            pTimerQ->pHandler = pHandler;
            pTimerQ->pContext = pContext;
            pHandler = NULL;
        }

        // Move the scheduled events to a temporary list, marking them all
        // "not on queue" so any attempt by user to cancel the item will be
        // ignored.
        //
        while (!IsListEmpty( &pTimerQ->listItems ))
        {
            pLink = RemoveHeadList( &pTimerQ->listItems );
            InsertTailList( &list, pLink );
        }
    }
    NdisReleaseSpinLock( &pTimerQ->lock );

    // Must be careful here.  If 'pHandler' was set NULL above, 'pTimerQ' must
    // not be referenced in the rest of this routine.
    //
    // Call user's "terminate" event handler for each removed item.
    //
    while (!IsListEmpty( &list ))
    {
        TIMERQITEM* pItem;

        pLink = RemoveHeadList( &list );
        InitializeListHead( pLink );
        pItem = CONTAINING_RECORD( pLink, TIMERQITEM, linkItems );
        TRACE( TL_I, TM_Time,
            ( "Flush TQI=$%p, handler=$%p", pItem, pItem->pHandler ) );
        pItem->pHandler( pItem, pItem->pContext, TE_Terminate );
    }

    // Call user's "terminate complete" handler, if it's still our job.
    //
    if (pHandler)
    {
        pTimerQ->ulTag = MTAG_FREED;
        pHandler( pTimerQ, pContext );
    }
}


VOID
TimerQScheduleItem(
    IN TIMERQ* pTimerQ,
    IN OUT TIMERQITEM* pNewItem,
    IN ULONG ulTimeoutMs,
    IN PTIMERQEVENT pHandler,
    IN VOID* pContext )

    // Schedule new timer event 'pNewItem' on timer queue 'pTimerQ'.  When the
    // event occurs in 'ulTimeoutMs' milliseconds, the 'pHandler' routine is
    // called with arguments 'pNewItem', 'pContext', and TE_Expired.  If the
    // item is cancelled or the queue terminated 'pHandler' is called as above
    // but with TE_Cancel or TE_Terminate as appropriate.
    //
{
    TRACE( TL_N, TM_Time, ( "TqSchedItem(ms=%d)", ulTimeoutMs ) );

    pNewItem->pHandler = pHandler;
    pNewItem->pContext = pContext;

    NdisAcquireSpinLock( &pTimerQ->lock );
    {
        LIST_ENTRY* pLink;
        LARGE_INTEGER lrgTime;

        ASSERT( pNewItem->linkItems.Flink == &pNewItem->linkItems );

        // The system time at which the timeout will occur is stored.
        //
        NdisGetCurrentSystemTime( &lrgTime );
        pNewItem->llExpireTime =
            lrgTime.QuadPart + (((LONGLONG )ulTimeoutMs) * 10000);

        // Walk the list of timer items looking for the first item that will
        // expire before the new item.  Do it backwards so the likely case of
        // many timeouts with roughly the same interval is handled
        // efficiently.
        //
        for (pLink = pTimerQ->listItems.Blink;
             pLink != &pTimerQ->listItems;
             pLink = pLink->Blink )
        {
            TIMERQITEM* pItem;

            pItem = CONTAINING_RECORD( pLink, TIMERQITEM, linkItems );

            if (pItem->llExpireTime < pNewItem->llExpireTime)
            {
                break;
            }
        }

        // Link the new item into the timer queue after the found item (or
        // after the head if none was found).
        //
        InsertAfter( &pNewItem->linkItems, pLink );

        if (pTimerQ->listItems.Flink == &pNewItem->linkItems)
        {
            // The new item expires before all other items so need to re-set
            // the NDIS timer.
            //
            SetTimer( pTimerQ, lrgTime.QuadPart );
        }
    }
    NdisReleaseSpinLock( &pTimerQ->lock );
}


BOOLEAN
TimerQCancelItem(
    IN TIMERQ* pTimerQ,
    IN TIMERQITEM* pItem )

    // Remove scheduled timer event 'pItem' from timer queue 'pTimerQ' and
    // call user's handler with event 'TE_Cancel', or nothing if 'pItem' is
    // NULL.
    //
    // Returns true if the timer was cancelled, false if it not, i.e. it was
    // not on the queue, possibly because it expired already.
    //
{
    TRACE( TL_N, TM_Time, ( "TqCancelItem" ) );
    return RemoveTqi( pTimerQ, pItem, TE_Cancel );
}


BOOLEAN
TimerQExpireItem(
    IN TIMERQ* pTimerQ,
    IN TIMERQITEM* pItem )

    // Remove scheduled timer event 'pItem' from timer queue 'pTimerQ' and
    // call user's handler with event 'TE_Expire', or do nothing if 'pItem' is
    // NULL.
    //
    // Returns true if the timer was expired, false if it not, i.e. it was not
    // on the queue, possibly because it expired already.
    //
{
    TRACE( TL_N, TM_Time, ( "TqExpireItem" ) );
    return RemoveTqi( pTimerQ, pItem, TE_Expire );
}


BOOLEAN
TimerQTerminateItem(
    IN TIMERQ* pTimerQ,
    IN TIMERQITEM* pItem )

    // Remove scheduled timer event 'pItem' from timer queue 'pTimerQ', or do
    // nothing if 'pItem' is NULL.
    //
    // Returns true if the timer was terminated, false if it not, i.e. it was not
    // on the queue, possibly because it expired already.
    //
{
    TRACE( TL_N, TM_Time, ( "TqTermItem" ) );
    return RemoveTqi( pTimerQ, pItem, TE_Terminate );
}


#if DBG
CHAR*
TimerQPszFromEvent(
    IN TIMERQEVENT event )

    // Debug utility to convert timer event coode 'event' to a corresponding
    // display string.
    //
{
    static CHAR* aszEvent[ 3 ] =
    {
        "expire",
        "cancel",
        "terminate"
    };

    return aszEvent[ (ULONG )event ];
}
#endif


//-----------------------------------------------------------------------------
// Timer utility routines (alphabetically)
//-----------------------------------------------------------------------------

BOOLEAN
RemoveTqi(
    IN TIMERQ* pTimerQ,
    IN TIMERQITEM* pItem,
    IN TIMERQEVENT event )

    // Remove scheduled timer event 'pItem' from timer queue 'pTimerQ' and
    // call user's handler with event 'event'.  The 'TE_Expire' event handler
    // is not called directly, but rescheduled with a 0 timeout so it occurs
    // immediately, but at DPC when no locks are held just like the original
    // timer had fired..
    //
    // Returns true if the item was on the queue, false otherwise.
    //
{
    BOOLEAN fFirst;
    LIST_ENTRY* pLink;

    if (!pItem)
    {
        TRACE( TL_N, TM_Time, ( "NULL pTqi" ) );
        return FALSE;
    }

    pLink = &pItem->linkItems;

    NdisAcquireSpinLock( &pTimerQ->lock );
    {
        if (pItem->linkItems.Flink == &pItem->linkItems
            || pTimerQ->fTerminating)
        {
            // The item is not on the queue.  Another operation may have
            // already dequeued it, but may not yet have called user's
            // handler.
            //
            TRACE( TL_N, TM_Time, ( "Not scheduled" ) );
            NdisReleaseSpinLock( &pTimerQ->lock );
            return FALSE;
        }

        fFirst = (pLink == pTimerQ->listItems.Flink);
        if (fFirst)
        {
            BOOLEAN fCancelled;

            // Cancelling first item on list, so cancel the NDIS timer.
            //
            NdisCancelTimer( &pTimerQ->timer, &fCancelled );
            TRACE( TL_N, TM_Time, ( "NdisCancelTimer" ) );

            if (!fCancelled)
            {
                // Too late.  The item has expired already but has not yet
                // been removed from the list by the internal handler.
                //
                TRACE( TL_A, TM_Time, ( "Mid-expire e=%d $%p($%p)",
                    event, pItem->pHandler, pItem->pContext ) );
                NdisReleaseSpinLock( &pTimerQ->lock );
                return FALSE;
            }
        }

        // Un-schedule the event and mark the item descriptor "off queue", so
        // any later attempt to cancel will do nothing.
        //
        RemoveEntryList( pLink );
        InitializeListHead( pLink );

        if (fFirst)
        {
            // Re-set the NDIS timer to reflect the timeout of the new first
            // item, if any.
            //
            SetTimer( pTimerQ, 0 );
        }
    }
    NdisReleaseSpinLock( &pTimerQ->lock );

    if (event == TE_Expire)
    {
        TimerQScheduleItem(
            pTimerQ, pItem, 0, pItem->pHandler, pItem->pContext );
    }
    else
    {
        // Call user's event handler.
        //
        pItem->pHandler( pItem, pItem->pContext, event );
    }

    return TRUE;
}


VOID
SetTimer(
    IN TIMERQ* pTimerQ,
    IN LONGLONG llCurrentTime )

    // Sets the NDIS timer to expire when the timeout of the first link, if
    // any, in the timer queue 'pTimerQ' occurs.  Any previously set timeout
    // is "overwritten".  'LlCurrentTime' is the current system time, if
    // known, or 0 if not.
    //
    // IMPORTANT: Caller must hold the TIMERQ lock.
    //
{
    LIST_ENTRY* pFirstLink;
    TIMERQITEM* pFirstItem;
    LONGLONG llTimeoutMs;
    ULONG ulTimeoutMs;

    if (IsListEmpty( &pTimerQ->listItems ))
    {
        return;
    }

    pFirstLink = pTimerQ->listItems.Flink;
    pFirstItem = CONTAINING_RECORD( pFirstLink, TIMERQITEM, linkItems );

    if (llCurrentTime == 0)
    {
        LARGE_INTEGER lrgTime;

        NdisGetCurrentSystemTime( &lrgTime );
        llCurrentTime = lrgTime.QuadPart;
    }

    llTimeoutMs = (pFirstItem->llExpireTime - llCurrentTime) / 10000;
    if (llTimeoutMs <= 0)
    {
        // The timeout interval is negative, i.e. it's already passed.  Set it
        // to zero so it is triggered immediately.
        //
        ulTimeoutMs = 0;
    }
    else
    {
        // The timeout interval is in the future.
        //
        ASSERT( ((LARGE_INTEGER* )&llTimeoutMs)->HighPart == 0 );
        ulTimeoutMs = ((LARGE_INTEGER* )&llTimeoutMs)->LowPart;
    }

    NdisSetTimer( &pTimerQ->timer, ulTimeoutMs );
    TRACE( TL_N, TM_Time, ( "NdisSetTimer(%dms)", ulTimeoutMs ) );
}


VOID
TimerEvent(
    IN PVOID SystemSpecific1,
    IN PVOID FunctionContext,
    IN PVOID SystemSpecific2,
    IN PVOID SystemSpecific3 )

    // NDIS_TIMER_FUNCTION called when a timer expires.
    //
{
    TIMERQ* pTimerQ;
    LIST_ENTRY* pLink;
    TIMERQITEM* pItem;
    PTIMERQTERMINATECOMPLETE pHandler;

    TRACE( TL_N, TM_Time, ( "TimerEvent" ) );

    pTimerQ = (TIMERQ* )FunctionContext;
    if (!pTimerQ || pTimerQ->ulTag != MTAG_TIMERQ)
    {
        // Should not happen.
        //
        TRACE( TL_A, TM_Time, ( "Not TIMERQ?" ) );
        return;
    }

    NdisAcquireSpinLock( &pTimerQ->lock );
    {
        pHandler = pTimerQ->pHandler;
        if (!pHandler)
        {
            // The termination handler is not set, so proceed normally.
            // Remove the first event item, make it un-cancel-able, and re-set
            // the timer for the next event.
            //
            if (IsListEmpty( &pTimerQ->listItems ))
            {
                // Should not happen (but does sometimes on MP Alpha?).
                //
                TRACE( TL_A, TM_Time, ( "No item queued?" ) );
                pItem = NULL;
            }
            else
            {
                pLink = RemoveHeadList( &pTimerQ->listItems );
                InitializeListHead( pLink );
                pItem = CONTAINING_RECORD( pLink, TIMERQITEM, linkItems );
                SetTimer( pTimerQ, 0 );
            }
        }
    }
    NdisReleaseSpinLock( &pTimerQ->lock );

    if (pHandler)
    {
        // The termination handler was set meaning the timer queue has been
        // terminated between this event firing and this handler being called.
        // That means we are the one who calls user's termination handler.
        // 'pTimerQ' must not be referenced after that call.
        //
        TRACE( TL_A, TM_Time, ( "Mid-event case handled" ) );
        pTimerQ->ulTag = MTAG_FREED;
        pHandler( pTimerQ, pTimerQ->pContext );
        return;
    }

    if (pItem)
    {
        // Call user's "expire" event handler.
        //
        pItem->pHandler( pItem, pItem->pContext, TE_Expire );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ndis\rasl2tp\kdext\kdexts.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    kdexts.c

Abstract:

    This file contains the generic routines and initialization code
    for the kernel debugger extensions dll.

Author:


Environment:

    User Mode

--*/

#include "precomp.h"
#pragma hdrstop

#include <imagehlp.h>
#include <ntdbg.h>
#include <ntsdexts.h>
//#define NOEXTAPI
#include <wdbgexts.h>
#include <ntverp.h>
//#include <stdexts.h>

//
// globals
//
//EXT_API_VERSION        ApiVersion = { 3, 5, EXT_API_VERSION_NUMBER, 0 };
EXT_API_VERSION        ApiVersion = { 5, 0, EXT_API_VERSION_NUMBER, 0 };
WINDBG_EXTENSION_APIS  ExtensionApis;
ULONG                  STeip;
ULONG                  STebp;
ULONG                  STesp;
USHORT                 SavedMajorVersion;
USHORT                 SavedMinorVersion;
USHORT                 usProcessorArchitecture;
BOOL                   bDebuggingChecked;

PSZ szProcessorArchitecture[] = {
    "Intel",
    "MIPS",
    "Alpha",
    "PPC"
};
#define cArchitecture (sizeof(szProcessorArchitecture) / sizeof(PSZ))

VOID
WinDbgExtensionDllInit(
    PWINDBG_EXTENSION_APIS lpExtensionApis,
    USHORT MajorVersion,
    USHORT MinorVersion
    )
{
    ULONG offKeProcessorArchitecture;
    ULONG Result;

    ExtensionApis = *lpExtensionApis;

    SavedMajorVersion = MajorVersion;
    SavedMinorVersion = MinorVersion;

    bDebuggingChecked = (SavedMajorVersion == 0x0c);
    usProcessorArchitecture = (USHORT)-1;

    return;
}

DECLARE_API( version )
{
#if DBG
    PCHAR DebuggerType = "Checked";
#else
    PCHAR DebuggerType = "Free";
#endif

    dprintf( "%s Extension dll for Build %d debugging %s kernel for Build %d\n",
             DebuggerType,
             VER_PRODUCTBUILD,
             SavedMajorVersion == 0x0c ? "Checked" : "Free",
             SavedMinorVersion
           );
}

VOID
CheckVersion(
    VOID
    )
{
#if DBG
    if ((SavedMajorVersion != 0x0c) || (SavedMinorVersion != VER_PRODUCTBUILD)) {
        dprintf("\r\n*** Extension DLL(%d Checked) does not match target system(%d %s)\r\n\r\n",
                VER_PRODUCTBUILD, SavedMinorVersion, (SavedMajorVersion==0x0f) ? "Free" : "Checked" );
    }
#else
    if ((SavedMajorVersion != 0x0f) || (SavedMinorVersion != VER_PRODUCTBUILD)) {
        dprintf("\r\n*** Extension DLL(%d Free) does not match target system(%d %s)\r\n\r\n",
                VER_PRODUCTBUILD, SavedMinorVersion, (SavedMajorVersion==0x0f) ? "Free" : "Checked" );
    }
#endif
}

LPEXT_API_VERSION
ExtensionApiVersion(
    VOID
    )
{
    return &ApiVersion;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ndis\rasl2tp\send.c ===
// Copyright (c) 1997, Microsoft Corporation, all rights reserved
//
// send.c
// RAS L2TP WAN mini-port/call-manager driver
// Send routines
//
// 01/07/97 Steve Cobb


#include "l2tpp.h"

#include "send.tmh"

//* Structure of a UDP header.
typedef struct UDPHeader {
    ushort      uh_src;             // Source port.
    ushort      uh_dest;            // Destination port.
    ushort      uh_length;          // Length
    ushort      uh_xsum;            // Checksum.
} UDPHeader;

#define IP_VERSION              0x40

//* IP Header format.
typedef struct IPHeader {
    uchar       iph_verlen;             // Version and length.
    uchar       iph_tos;                // Type of service.
    ushort      iph_length;             // Total length of datagram.
    ushort      iph_id;                 // Identification.
    ushort      iph_offset;             // Flags and fragment offset.
    uchar       iph_ttl;                // Time to live.
    uchar       iph_protocol;           // Protocol.
    ushort      iph_xsum;               // Header checksum.
    IPAddr      iph_src;                // Source address.
    IPAddr      iph_dest;               // Destination address.
} IPHeader;

#ifdef PSDEBUG

// List of all allocated PAYLOADSENT contexts and the lock that protects the
// list.  (for debug purposes only)
//
NDIS_SPIN_LOCK g_lockDebugPs;
LIST_ENTRY g_listDebugPs;

#endif


// Debug counts of client oddities that should not be happening.
//
ULONG g_ulSendZlbWithoutHostRoute = 0;


// Callback to add AVPs to an outgoing control message.  'PTunnel' is the
// tunnel control block.  'PVc' is the VC control block for call control
// messages or NULL for tunnel control messages.  'ulArg1', 'ulArg2', and
// 'pvArg3' are caller's arguments as passed for SendControl.  'PAvpBuffer' is
// the address of the buffer to receive the built AVPs.  '*PulAvpLength' is
// set to the length of the built AVPs.
//
typedef
VOID
(*PBUILDAVPS)(
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN ULONG ulArg1,
    IN ULONG ulArg2,
    IN PVOID pvArg3,
    IN OUT CHAR* pAvpBuffer,
    OUT ULONG* pulAvpLength );


//-----------------------------------------------------------------------------
// Local prototypes (alphabetically)
//-----------------------------------------------------------------------------

USHORT
BuildAvpAch(
    IN USHORT usAttribute,
    IN BOOLEAN fMandatory,
    IN CHAR* pszValue,
    IN USHORT usValueLength,
    OUT CHAR* pAvp );

USHORT
BuildAvpAul(
    IN USHORT usAttribute,
    IN BOOLEAN fMandatory,
    IN UNALIGNED ULONG* pulValue,
    IN USHORT usValues,
    OUT CHAR* pAvp );

USHORT
BuildAvpFlag(
    IN USHORT usAttribute,
    IN BOOLEAN fMandatory,
    OUT CHAR* pAvp );

USHORT
BuildAvpUl(
    IN USHORT usAttribute,
    IN BOOLEAN fMandatory,
    IN ULONG ulValue,
    OUT CHAR* pAvp );

USHORT
BuildAvpUs(
    IN USHORT usAttribute,
    IN BOOLEAN fMandatory,
    IN USHORT usValue,
    OUT CHAR* pAvp );

USHORT
BuildAvp2UsAndAch(
    IN USHORT usAttribute,
    IN BOOLEAN fMandatory,
    IN USHORT usValue1,
    IN USHORT usValue2,
    IN CHAR* pszValue,
    IN USHORT usValueLength,
    OUT CHAR* pAvp );

VOID
BuildCdnAvps(
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN ULONG ulArg1,
    IN ULONG ulArg2,
    IN PVOID pvArg3,
    IN OUT CHAR* pAvpBuffer,
    OUT ULONG* pulAvpLength );

VOID
BuildHelloAvps(
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN ULONG ulArg1,
    IN ULONG ulArg2,
    IN PVOID pvArg3,
    IN OUT CHAR* pAvpBuffer,
    OUT ULONG* pulAvpLength );

VOID
BuildIccnAvps(
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN ULONG ulArg1,
    IN ULONG ulArg2,
    IN PVOID pvArg3,
    IN OUT CHAR* pAvpBuffer,
    OUT ULONG* pulAvpLength );

VOID
BuildIcrpAvps(
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN ULONG ulArg1,
    IN ULONG ulArg2,
    IN PVOID pvArg3,
    IN OUT CHAR* pAvpBuffer,
    OUT ULONG* pulAvpLength );

VOID
BuildIcrqAvps(
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN ULONG ulArg1,
    IN ULONG ulArg2,
    IN PVOID pvArg3,
    IN OUT CHAR* pAvpBuffer,
    OUT ULONG* pulAvpLength );

ULONG
BuildL2tpHeader(
    IN OUT CHAR* pBuffer,
    IN BOOLEAN fControl,
    IN BOOLEAN fReset,
    IN USHORT* pusTunnelId,
    IN USHORT* pusCallId,
    IN USHORT* pusNs,
    IN USHORT usNr );

VOID
BuildOccnAvps(
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN ULONG ulArg1,
    IN ULONG ulArg2,
    IN PVOID pvArg3,
    IN OUT CHAR* pAvpBuffer,
    OUT ULONG* pulAvpLength );

VOID
BuildOcrpAvps(
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN ULONG ulArg1,
    IN ULONG ulArg2,
    IN PVOID pvArg3,
    IN OUT CHAR* pAvpBuffer,
    OUT ULONG* pulAvpLength );

VOID
BuildOcrqAvps(
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN ULONG ulArg1,
    IN ULONG ulArg2,
    IN PVOID pvArg3,
    IN OUT CHAR* pAvpBuffer,
    OUT ULONG* pulAvpLength );

VOID
BuildScccnAvps(
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN ULONG ulArg1,
    IN ULONG ulArg2,
    IN PVOID pvArg3,
    IN OUT CHAR* pAvpBuffer,
    OUT ULONG* pulAvpLength );

VOID
BuildSccrpAvps(
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN ULONG ulArg1,
    IN ULONG ulArg2,
    IN PVOID pvArg3,
    IN OUT CHAR* pAvpBuffer,
    OUT ULONG* pulAvpLength );

VOID
BuildSccrqAvps(
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN ULONG ulArg1,
    IN ULONG ulArg2,
    IN PVOID pvArg3,
    IN OUT CHAR* pAvpBuffer,
    OUT ULONG* pulAvpLength );

VOID
BuildStopccnAvps(
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN ULONG ulArg1,
    IN ULONG ulArg2,
    IN PVOID pvArg3,
    IN OUT CHAR* pAvpBuffer,
    OUT ULONG* pulAvpLength );

VOID
BuildWenAvps(
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN ULONG ulArg1,
    IN ULONG ulArg2,
    IN PVOID pvArg3,
    IN OUT CHAR* pAvpBuffer,
    OUT ULONG* pulAvpLength );

VOID
CompletePayloadSent(
    IN TUNNELWORK* pWork,
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN ULONG_PTR* punpArgs );

VOID
SendControlComplete(
    IN TDIXCONTEXT* pTdix,
    IN VOID* pContext1,
    IN VOID* pContext2,
    IN CHAR* pBuffer );

VOID
SendHeaderComplete(
    IN TDIXCONTEXT* pTdix,
    IN VOID* pContext1,
    IN VOID* pContext2,
    IN CHAR* pBuffer );

VOID
SendPayloadReset(
    IN TUNNELWORK* pWork,
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN ULONG_PTR* punpArgs );

VOID
SendPayloadSeq(
    TUNNELWORK* pWork,
    TUNNELCB* pTunnel,
    VCCB* pVc,
    ULONG_PTR* punpArgs );

VOID
SendPayloadSeqComplete(
    IN TDIXCONTEXT* pTdix,
    IN VOID* pContext1,
    IN VOID* pContext2,
    IN CHAR* pBuffer );

VOID
SendPayloadUnseq(
    TUNNELWORK* pWork,
    TUNNELCB* pTunnel,
    VCCB* pVc,
    ULONG_PTR* punpArgs );

VOID
SendPayloadUnseqComplete(
    IN TDIXCONTEXT* pTdix,
    IN VOID* pContext1,
    IN VOID* pContext2,
    IN CHAR* pBuffer );

VOID
SendPayloadTimerEvent(
    IN TIMERQITEM* pItem,
    IN VOID* pContext,
    IN TIMERQEVENT event );

VOID
SendZlb(
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN USHORT usNs,
    IN USHORT usNr,
    IN BOOLEAN fReset );

VOID
UpdateControlHeaderNr(
    IN CHAR* pBuffer,
    IN USHORT usNr );

VOID
UpdateHeaderLength(
    IN CHAR* pBuffer,
    IN USHORT usLength );

ULONG BuildIpUdpHeaders(
    IN TUNNELCB* pTunnel,
    IN OUT CHAR* pBuffer,
    IN ULONG ulLength);

//-----------------------------------------------------------------------------
// Send routines
//-----------------------------------------------------------------------------

VOID
SendControl(
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN USHORT usMsgType,
    IN ULONG ulBuildAvpsArg1,
    IN ULONG ulBuildAvpsArg2,
    IN PVOID pvBuildAvpsArg3,
    IN ULONG ulFlags )

    // Build and send a control message.  'PTunnel' is the tunnel control
    // block, always non-NULL.  'PVc' is the VC control block, non-NULL for
    // call connection (as opposed to tunnel connection) messages.
    // 'UsMsgType' is the message type AVP value of the message to build.
    // 'UlBuildAvpsArgX' are the arguments passed to the PBUILDAVP handler
    // associated with 'usMsgType', where the meaning depends on the specific
    // handler.  'UlFlags' is the CSF_* flag options associated with the sent
    // message context, or 0 if none.
    //
    // IMPORTANT:  Caller must hold 'pTunnel->lockT'.  If 'pVc' is non-NULL
    //             caller must also hold 'pVc->lockV'.
    //
{
    NDIS_STATUS status;
    ADAPTERCB* pAdapter;
    NDIS_BUFFER* pNdisBuffer;
    PBUILDAVPS pBuildAvpsHandler;
    TIMERQITEM* pTqiSendTimeout;
    CONTROLSENT* pCs;
    USHORT usAssignedCallId;
    ULONG ulLength;
    ULONG ulAvpLength;
    CHAR* pBuffer;
    CHAR* pCurrBuffer;

    static PBUILDAVPS apBuildAvpHandlers[ 16 ] =
    {
        BuildSccrqAvps,    // CMT_SCCRQ
        BuildSccrpAvps,    // CMT_SCCRP
        BuildScccnAvps,    // CMT_SCCCN
        BuildStopccnAvps,  // CMT_StopCCN
        NULL,              // CMT_StopCCRP (obsolete)
        BuildHelloAvps,    // CMT_Hello
        BuildOcrqAvps,     // CMT_OCRQ
        BuildOcrpAvps,     // CMT_OCRP
        BuildOccnAvps,     // CMT_OCCN
        BuildIcrqAvps,     // CMT_ICRQ
        BuildIcrpAvps,     // CMT_ICRP
        BuildIccnAvps,     // CMT_ICCN
        NULL,              // CMT_CCRQ (obsolete)
        BuildCdnAvps,      // CMT_CDN
        BuildWenAvps,      // CMT_WEN
        NULL               // CMT_SLI
    };

    TRACE( TL_V, TM_CMsg, ( "SendControl" ) );

    pAdapter = pTunnel->pAdapter;
    pBuffer = NULL;
    pTqiSendTimeout = NULL;
    pCs = NULL;

    do
    {
        // Get an NDIS_BUFFER to hold the control message.
        //
        pBuffer = GetBufferFromPool( &pAdapter->poolFrameBuffers );
        if (!pBuffer)
        {
            WPLOG( LL_A, LM_Res, ( "Failed to allocate buffer"));
            status = NDIS_STATUS_RESOURCES;
            break;
        }

        // Get an "unacknowledged send timeout" timer event descriptor.
        //
        pTqiSendTimeout = ALLOC_TIMERQITEM( pAdapter );
        if (!pTqiSendTimeout)
        {
            WPLOG( LL_A, LM_CMsg, ( "Failed to allocate timer event descriptor"));
            status = NDIS_STATUS_RESOURCES;
            break;
        }

        // Get a "control message sent" context.
        //
        pCs = ALLOC_CONTROLSENT( pAdapter );
        if (!pCs)
        {
            WPLOG( LL_A, LM_CMsg, ( "Failed to allocate CONTROLSENT"));
            status = NDIS_STATUS_RESOURCES;
            break;
        }

        status = NDIS_STATUS_SUCCESS;
    }
    while (FALSE);

    if (status != NDIS_STATUS_SUCCESS)
    {
        if (pBuffer)
        {
            FreeBufferToPool( &pAdapter->poolFrameBuffers, pBuffer, TRUE );
        }

        if (pTqiSendTimeout)
        {
            FREE_TIMERQITEM( pAdapter, pTqiSendTimeout );
        }

        // System is probably toast but try to be orderly.
        //
        ScheduleTunnelWork(
            pTunnel, NULL, FsmCloseTunnel,
            (ULONG_PTR )TRESULT_GeneralWithError,
            (ULONG_PTR )GERR_NoResources,
            0, 0, FALSE, FALSE );
        return;
    }

    // Build IP & UDP headers?                       
    if ((ReadFlags(&pTunnel->ulFlags) & (TCBF_SendConnected | TCBF_LocalAddrSet)) == 
         TCBF_LocalAddrSet) {
        ulFlags |= CSF_IpUdpHeaders;
        pCurrBuffer = pBuffer + sizeof(IPHeader) + sizeof(UDPHeader);
    } else {
        pCurrBuffer = pBuffer;
    }
                                   
    // Build an L2TP control header in 'pCurrBuffer'.  The Call-ID is 0 for tunnel
    // control messages, or peer's assigned call ID for call control messages.
    //
    usAssignedCallId = (pVc) ? pVc->usAssignedCallId : 0;
    ulLength =
        BuildL2tpHeader(
            pCurrBuffer,
            TRUE,
            FALSE,
            &pTunnel->usAssignedTunnelId,
            &usAssignedCallId,
            &pTunnel->usNs,
            pTunnel->usNr );
            
    WPLOG( LL_M, LM_CMsg, ( "SEND -> %!IPADDR!/%d %s Tid %d, Peer's Tid %d, Peer's Cid %d, Ns=%d, Nr=%d",
        pTunnel->address.ulIpAddress, ntohs(pTunnel->address.sUdpPort),
        MsgTypePszFromUs( usMsgType ), 
        pTunnel->usTunnelId, pTunnel->usAssignedTunnelId, usAssignedCallId,
        pTunnel->usNs, pTunnel->usNr));  

    // Call the message type's "build AVPs" handler to add AVPs to the buffer
    // following the header.
    //
    ASSERT( usMsgType > 0 && usMsgType <= 16 );
    pBuildAvpsHandler = apBuildAvpHandlers[ usMsgType - 1 ];
    pBuildAvpsHandler(
        pTunnel, pVc,
        ulBuildAvpsArg1, ulBuildAvpsArg2, pvBuildAvpsArg3,
        pCurrBuffer + ulLength, &ulAvpLength );
    ulLength += ulAvpLength;
    UpdateHeaderLength( pCurrBuffer, (USHORT )ulLength );
    
    // Build IP & UDP headers if necessary
    if(ulFlags & CSF_IpUdpHeaders)
    {
        ulLength = BuildIpUdpHeaders(pTunnel, pBuffer, ulLength);
    }
    
    // Pare down the frame buffer to the actual length used.
    //
    pNdisBuffer = NdisBufferFromBuffer( pBuffer );
    NdisAdjustBufferLength( pNdisBuffer, (UINT )ulLength );

    // Set up the "control message sent" context with the information needed
    // to send the message and track it's progress through retransmissions.
    //
    pCs->lRef = 0;
    pCs->usNs = pTunnel->usNs;
    pCs->usMsgType = usMsgType;
    TimerQInitializeItem( pTqiSendTimeout );
    pCs->pTqiSendTimeout = pTqiSendTimeout;
    pCs->ulRetransmits = 0;
    pCs->pBuffer = pBuffer;
    pCs->ulBufferLength = ulLength;
    pCs->pTunnel = pTunnel;
    pCs->pVc = pVc;
    pCs->ulFlags = ulFlags | CSF_Pending;
    pCs->pIrp = NULL;

    // Bump the 'Next Send' counter since this message has been assigned the
    // current value.
    //
    ++pTunnel->usNs;

    // Take a reference that is removed when the context is removed from the
    // "outstanding send" list.  Take a VC and tunnel reference that is
    // removed when the context is freed.
    //
    ReferenceControlSent( pCs );
    ReferenceTunnel( pTunnel, FALSE );

    if (pCs->pVc)
    {
        ReferenceVc( pCs->pVc );
    }

    // Queue the context as "active" with transmission pending in 'Next Sent'
    // sort order, i.e. at the tail.
    //
    InsertTailList( &pTunnel->listSendsOut, &pCs->linkSendsOut );

    // See if the send window allows it to go now.
    //
    ScheduleTunnelWork(
        pTunnel, NULL, SendPending,
        0, 0, 0, 0, FALSE, FALSE );
}


VOID
SendPending(
    IN TUNNELWORK* pWork,
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN ULONG_PTR* punpArgs )

    // A PTUNNELWORK routine to try to send pending messages from the
    // "outstanding send" list until the send window is full.
    //
    // This routine is called only at PASSIVE IRQL.
    //
{
    NDIS_STATUS status;
    ADAPTERCB* pAdapter;
    LIST_ENTRY* pLink;
    CONTROLSENT* pCs;
    ULONG ulFlags;

    TRACE( TL_N, TM_CMsg, ( "SendPending(sout=%d,sw=%d)",
        pTunnel->ulSendsOut, pTunnel->ulSendWindow ) );

    TRACE( TL_V, TM_CMsg, ( "SendPending(sout=%d,sw=%d)",
        pTunnel->ulSendsOut, pTunnel->ulSendWindow ) );
        
    // Unpack context information then free the work item.
    //
    pAdapter = pTunnel->pAdapter;
    FREE_TUNNELWORK( pAdapter, pWork );

    NdisAcquireSpinLock( &pTunnel->lockT );
    {
        for (;;)
        {
            if (pTunnel->ulSendsOut >= pTunnel->ulSendWindow)
            {
                // The send window is closed.
                //
                break;
            }

            // Scan the "outstanding send" queue for the next send context
            // pending transmission.  Can't save our place for the next
            // iteration because the lock must be released and re-acquired
            // below to send the packet.
            //
            for (pLink = pTunnel->listSendsOut.Flink;
                 pLink != &pTunnel->listSendsOut;
                 pLink = pLink->Flink)
            {
                pCs = CONTAINING_RECORD( pLink, CONTROLSENT, linkSendsOut );
                if (pCs->ulFlags & CSF_Pending)
                {
                    break;
                }
            }

            if (pLink == &pTunnel->listSendsOut)
            {
                // There is nothing pending.
                //
                break;
            }

            // The send window is open and a pending send has been found.
            // Mark the context "not pending" and close the window by one to
            // account for the coming send.
            //
            ulFlags = pCs->ulFlags;
            pCs->ulFlags &= ~(CSF_Pending | CSF_QueryMediaSpeed);
            ++pTunnel->ulSendsOut;

            // Cancel any pending delayed acknowledge timeout, because the
            // acknowledge will piggyback on this packet.
            //
            if (pTunnel->pTqiDelayedAck)
            {
                TimerQCancelItem( pTunnel->pTimerQ, pTunnel->pTqiDelayedAck );
                pTunnel->pTqiDelayedAck = NULL;
            }

            if (pCs->ulRetransmits == 0)
            {
                LARGE_INTEGER lrgTime;

                // This is the original send so note the time sent.
                //
                NdisGetCurrentSystemTime( &lrgTime );
                pCs->llTimeSent = lrgTime.QuadPart;
            }
            else
            {
                // In the retransmission, the 'Next Send' is the same as the
                // original, but the 'Next Receive' field is updated.
                //
                UpdateControlHeaderNr( pCs->pBuffer, pTunnel->usNr );
            }

            // Take a reference that will be removed in the send completion
            // routine.
            //
            ReferenceControlSent( pCs );

            TRACE( TL_A, TM_CMsg, ( "%sSEND(%d) %s, +sout=%d, to=%d",
                ((g_ulTraceLevel <= TL_I) ? "" : "\nL2TP: "),
                pCs->ulRetransmits,
                MsgTypePszFromUs( pCs->usMsgType ),
                pTunnel->ulSendsOut,
                pTunnel->ulSendTimeoutMs ) );
            DUMPW( TL_A, TM_MDmp, pCs->pBuffer, pCs->ulBufferLength );

            NdisReleaseSpinLock( &pTunnel->lockT );

            // query media speed if necessary
            if(ulFlags & CSF_QueryMediaSpeed)
            {
                TdixGetInterfaceInfo(&pAdapter->tdix, 
                                     pTunnel->localaddress.ulIpAddress, 
                                     &pTunnel->ulMediaSpeed);
            }

            {
                FILE_OBJECT* FileObj;
                PTDIX_SEND_HANDLER SendFunc;

                // Call TDI to send the control message.
                //
                if (pCs->ulFlags & CSF_IpUdpHeaders) {
                    FileObj = pAdapter->tdix.pRawAddress;
                    SendFunc = TdixSendDatagram;
                }
                else if (ReadFlags(&pTunnel->ulFlags) & TCBF_SendConnected) {
                    ASSERT(pTunnel->pRoute != NULL);
                    FileObj = CtrlObjFromUdpContext(&pTunnel->udpContext);
                    SendFunc = TdixSend;
                } else {
                    FileObj = pAdapter->tdix.pAddress;
                    SendFunc = TdixSendDatagram;
                }

                status = SendFunc(&pAdapter->tdix,
                                  FileObj,
                                  SendControlComplete,
                                  pCs,
                                  NULL,
                                  &pTunnel->address,
                                  pCs->pBuffer,
                                  pCs->ulBufferLength,
                                  &pCs->pIrp );

                ASSERT( status == NDIS_STATUS_PENDING );
            }
            NdisAcquireSpinLock( &pTunnel->lockT );
        }
    }
    NdisReleaseSpinLock( &pTunnel->lockT );
}


VOID
SendPayload(
    IN VCCB* pVc,
    IN NDIS_PACKET* pPacket )

    // Sends payload packet 'pPacket' on VC 'pVc' eventually calling
    // NdisMCoSendComplete with the result.
    //
    // IMPORTANT: Caller must not hold any locks.
    //
{
    NDIS_STATUS status;
    TUNNELCB* pTunnel;
    ADAPTERCB* pAdapter;
    CHAR* pBuffer;

    TRACE( TL_V, TM_Send, ( "SendPayload" ) );

    pAdapter = pVc->pAdapter;
    pTunnel = pVc->pTunnel;
    status = NDIS_STATUS_SUCCESS;

    if (pTunnel)
    {
        if (ReadFlags( &pTunnel->ulFlags ) & TCBF_HostRouteAdded)
        {
            // Take a reference on the call.  For unsequenced sends, this is
            // released when the TdixSendDatagram completes.  For sequenced
            // sends, it is released when the PAYLOADSENT context is freed.
            //
            if (ReferenceCall( pVc ))
            {
                // Get an NDIS_BUFFER to hold the L2TP header that will be
                // tacked onto the front of NDISWAN's PPP-framed data packet.
                //
                pBuffer = GetBufferFromPool( &pAdapter->poolHeaderBuffers );
                if (!pBuffer)
                {
                    WPLOG( LL_A, LM_Res, ( "Failed to allocate buffer"));
                    DereferenceCall( pVc );
                    status = NDIS_STATUS_RESOURCES;
                }
            }
            else
            {
                TRACE( TL_A, TM_Send, ( "Send on inactive $%p", pVc ) );
                WPLOG( LL_A, LM_Send, ( "Send on inactive %p", pVc ) );
                status = NDIS_STATUS_FAILURE;
            }
        }
        else
        {
            TRACE( TL_A, TM_Send, ( "SendPayload w/o host route?" ) );
            WPLOG( LL_A, LM_Send, ( "SendPayload w/o host route?" ) );
            status = NDIS_STATUS_FAILURE;
        }
    }
    else
    {
        TRACE( TL_A, TM_Send, ( "Send $%p w/o pT?", pVc ) );
        WPLOG( LL_A, LM_Send, ( "Send $%p w/o pT?", pVc ) );
        status = NDIS_STATUS_FAILURE;
    }

    if (status != NDIS_STATUS_SUCCESS)
    {
        NDIS_SET_PACKET_STATUS( pPacket, status );
        TRACE( TL_A, TM_Send, ( "NdisMCoSendComp($%x)", status ) );
        WPLOG( LL_A, LM_Send, ( "NdisMCoSendComp($%x)", status ) );
        NdisMCoSendComplete( status, pVc->NdisVcHandle, pPacket );
        TRACE( TL_N, TM_Send, ( "NdisMCoSendComp done" ) );
        return;
    }

    if (ReadFlags( &pVc->ulFlags ) & VCBF_Sequencing)
    {
         ScheduleTunnelWork(
             pTunnel, pVc, SendPayloadSeq,
             (ULONG_PTR )pPacket, (ULONG_PTR )pBuffer, 0, 0, FALSE, FALSE );
    }
    else
    {
         ScheduleTunnelWork(
             pTunnel, pVc, SendPayloadUnseq,
             (ULONG_PTR )pPacket, (ULONG_PTR )pBuffer, 0, 0, FALSE, FALSE );
    }
}


VOID
SendPayloadSeq(
    TUNNELWORK* pWork,
    TUNNELCB* pTunnel,
    VCCB* pVc,
    ULONG_PTR* punpArgs )

    // A PTUNNELWORK routine to handle sending a sequenced payload packet on a
    // VC.  Arg0 is the packet to send.  Arg1 is the header buffer to fill in.
    //
    // This routine is called only at PASSIVE IRQL.
    //
{
    NDIS_STATUS status;
    ADAPTERCB* pAdapter;
    PAYLOADSENT* pPs;
    TIMERQITEM* pTqiSendTimeout;
    LARGE_INTEGER lrgTime;
    ULONG ulLength;
    ULONG ulFullLength;
    NDIS_PACKET* pPacket;
    CHAR* pBuffer;
    NDIS_BUFFER* pNdisBuffer;
    USHORT usNs;

    TRACE( TL_V, TM_Send, ( "SendPayloadSeq" ) );

    // Unpack context information then free the work item.
    //
    pAdapter = pTunnel->pAdapter;
    pPacket = (NDIS_PACKET* )(punpArgs[ 0 ]);
    pBuffer = (CHAR* )(punpArgs[ 1 ]);
    FREE_TUNNELWORK( pAdapter, pWork );

    pTqiSendTimeout = NULL;
    pPs = NULL;

    do
    {
        // Get an "unacknowledged send timeout" timer event descriptor.
        //
        pTqiSendTimeout = ALLOC_TIMERQITEM( pAdapter );
        if (!pTqiSendTimeout)
        {
            status = NDIS_STATUS_RESOURCES;
            break;
        }

        // Get a "payload message sent" context.
        //
        pPs = ALLOC_PAYLOADSENT( pAdapter );
        if (!pPs)
        {
            status = NDIS_STATUS_RESOURCES;
            break;
        }

        NdisAcquireSpinLock( &pVc->lockV );
        {
            // Retrieve the 'Next Send' value to assign this packet, then
            // bump the counter for the next guy.
            //
            usNs = pVc->usNs;
            ++pVc->usNs;

            // Build an L2TP payload header with Ns/Nr fields in
            // 'pBuffer'.
            //
            ulLength =
                BuildL2tpHeader(
                    pBuffer,
                    FALSE,
                    FALSE,
                    &pTunnel->usAssignedTunnelId,
                    &pVc->usAssignedCallId,
                    &usNs,
                    pVc->usNr );

            // Pare down the header buffer to the actual length used then
            // chain it onto the PPP-framed data we got from NDISWAN.
            //
            pNdisBuffer = NdisBufferFromBuffer( pBuffer );
            NdisAdjustBufferLength( pNdisBuffer, (UINT )ulLength );
            NdisChainBufferAtFront( pPacket, pNdisBuffer );
            NdisQueryPacket( pPacket, NULL, NULL, NULL, &ulFullLength );
            UpdateHeaderLength( pBuffer, (USHORT )ulFullLength );

            // Cancel any pending delayed acknowledge timeout, because the
            // acknowledge will piggyback on this packet.
            //
            if (pVc->pTqiDelayedAck)
            {
                TimerQCancelItem( pTunnel->pTimerQ, pVc->pTqiDelayedAck );
                pVc->pTqiDelayedAck = NULL;
            }

            // Fill the "payload message sent" context with the information
            // needed to track the progress of the payload's acknowledgement.
            //
            pPs->usNs = usNs;
            pPs->lRef = 0;
            TimerQInitializeItem( pTqiSendTimeout );
            pPs->pTqiSendTimeout = pTqiSendTimeout;
            pPs->pPacket = pPacket;
            pPs->pBuffer = pBuffer;

            ReferenceTunnel( pTunnel, FALSE );
            pPs->pTunnel = pTunnel;

            ReferenceVc( pVc );
            pPs->pVc = pVc;

            pPs->status = NDIS_STATUS_FAILURE;
            NdisGetCurrentSystemTime( &lrgTime );
            pPs->llTimeSent = lrgTime.QuadPart;
            pPs->pIrp = NULL;

            // Link the payload in the "outstanding" list and take a reference
            // on the context corresponding to this linkage.  Take a second
            // reference that will be removed by the send completion handler.
            // Take a third that will be removed by the timer event handler.
            //
            ReferencePayloadSent( pPs );
            InsertTailList( &pVc->listSendsOut, &pPs->linkSendsOut );
            ReferencePayloadSent( pPs );
            ReferencePayloadSent( pPs );

#ifdef PSDEBUG
            {
                extern LIST_ENTRY g_listDebugPs;
                extern NDIS_SPIN_LOCK g_lockDebugPs;

                NdisAcquireSpinLock( &g_lockDebugPs );
                {
                    InsertTailList( &g_listDebugPs, &pPs->linkDebugPs );
                }
                NdisReleaseSpinLock( &g_lockDebugPs );
            }
#endif

            TimerQScheduleItem(
                pTunnel->pTimerQ,
                pPs->pTqiSendTimeout,
                pVc->ulSendTimeoutMs,
                SendPayloadTimerEvent,
                pPs );

            TRACE( TL_A, TM_Msg,
                ( "%sSEND payload, len=%d Ns=%d Nr=%d to=%d",
                ((g_ulTraceLevel <= TL_I) ? "" : "\nL2TP: "),
                ulFullLength, pPs->usNs, pVc->usNr, pVc->ulSendTimeoutMs ) );
            DUMPW( TL_A, TM_MDmp, pPs->pBuffer, ulLength );

            ++pVc->stats.ulSentDataPacketsSeq;
            pVc->stats.ulDataBytesSent += (ulFullLength - ulLength);
            pVc->stats.ulSendWindowTotal += pVc->ulSendWindow;
        }
        NdisReleaseSpinLock( &pVc->lockV );

        status = NDIS_STATUS_SUCCESS;
    }
    while (FALSE);

    if (status != NDIS_STATUS_SUCCESS)
    {
        FreeBufferToPool( &pAdapter->poolHeaderBuffers, pBuffer, TRUE );

        if (pTqiSendTimeout)
        {
            FREE_TIMERQITEM( pAdapter, pTqiSendTimeout );
        }

        ASSERT( !pPs );

        // Complete the send, indicating the failure.
        //
        NDIS_SET_PACKET_STATUS( pPacket, status );
        TRACE( TL_A, TM_Send, ( "NdisMCoSendComp($%x)", status ) );
        WPLOG( LL_A, LM_Send, ( "NdisMCoSendComp($%x)", status ) );
        NdisMCoSendComplete( status, pVc->NdisVcHandle, pPacket );
        TRACE( TL_N, TM_Send, ( "NdisMCoSendComp done" ) );
        return;
    }

    // Call TDI to send the payload message.
    //
    {
        FILE_OBJECT* FileObj;
        PTDIX_SEND_HANDLER SendFunc;

        if (ReadFlags(&pTunnel->ulFlags) & TCBF_SendConnected) {

            ASSERT(pTunnel->pRoute != NULL);

            FileObj =  PayloadObjFromUdpContext(&pTunnel->udpContext);
            SendFunc = TdixSend;
        } else {
            FileObj = pAdapter->tdix.pAddress;
            SendFunc = TdixSendDatagram;
        }
    
        status = SendFunc(&pAdapter->tdix,
                          FileObj,
                          SendPayloadSeqComplete,
                          pPs,
                          NULL,
                          &pTunnel->address,
                          pBuffer,
                          ulFullLength,
                          &pPs->pIrp );
    }

    ASSERT( status == NDIS_STATUS_PENDING );
}


VOID
SendPayloadUnseq(
    TUNNELWORK* pWork,
    TUNNELCB* pTunnel,
    VCCB* pVc,
    ULONG_PTR* punpArgs )

    // A PTUNNELWORK routine to handle sending an unsequenced payload packet
    // on a VC.  Arg0 is the NDIS_PACKET.  Arg1 is the header buffer to fill
    // in.
    //
    // This routine is called only at PASSIVE IRQL.
    //
{
    NDIS_STATUS status;
    ADAPTERCB* pAdapter;
    ULONG ulLength;
    UINT unFullLength;
    NDIS_PACKET* pPacket;
    CHAR* pBuffer;
    NDIS_BUFFER* pNdisBuffer;

    TRACE( TL_V, TM_Send, ( "SendPayloadUnseq" ) );

    // Unpack context information then free the work item.
    //
    pAdapter = pTunnel->pAdapter;
    pPacket = (NDIS_PACKET* )(punpArgs[ 0 ]);
    pBuffer = (CHAR* )(punpArgs[ 1 ]);
    FREE_TUNNELWORK( pAdapter, pWork );

    NdisAcquireSpinLock( &pVc->lockV );
    {
        // Build an L2TP payload header without Ns/Nr fields in 'pBuffer'.
        //
        ulLength =
            BuildL2tpHeader(
                pBuffer,
                FALSE,
                FALSE,
                &pTunnel->usAssignedTunnelId,
                &pVc->usAssignedCallId,
                NULL,
                0 );

        // Pare down the header buffer to the actual length used then
        // chain it onto the PPP-framed data we got from NDISWAN.  Poke
        // the L2TP header to update the length field accounting for the
        // data.
        //
        pNdisBuffer = NdisBufferFromBuffer( pBuffer );
        NdisAdjustBufferLength( pNdisBuffer, (UINT )ulLength );
        NdisChainBufferAtFront( pPacket, pNdisBuffer );
        NdisQueryPacket( pPacket, NULL, NULL, NULL, &unFullLength );
        UpdateHeaderLength( pBuffer, (USHORT )unFullLength );

        TRACE( TL_A, TM_Msg,
             ( "%sSEND payload(%d), len=%d",
             ((g_ulTraceLevel <= TL_I) ? "" : "\nL2TP: "),
             ++pVc->usNs,
             unFullLength ) );
        DUMPW( TL_A, TM_MDmp, pBuffer, ulLength );

        ++pVc->stats.ulSentDataPacketsUnSeq;
        pVc->stats.ulDataBytesSent += ((ULONG )unFullLength - ulLength);
    }
    NdisReleaseSpinLock( &pVc->lockV );

    // Call TDI to send the payload message.
    //
    {
        FILE_OBJECT* FileObj;
        PTDIX_SEND_HANDLER SendFunc;

        NdisAcquireSpinLock(&pTunnel->lockT);

        if (pTunnel->pRoute != NULL) {
            FileObj = PayloadObjFromUdpContext(&pTunnel->udpContext);
            SendFunc = TdixSend;
        } else {
            FileObj = pAdapter->tdix.pAddress;
            SendFunc = TdixSendDatagram;
        }

        NdisReleaseSpinLock(&pTunnel->lockT);

        status = SendFunc(&pAdapter->tdix,
                          FileObj,
                          SendPayloadUnseqComplete,
                          pVc,
                          pPacket,
                          &pTunnel->address,
                          pBuffer,
                          (ULONG )unFullLength,
                          NULL );
    }

    ASSERT( status == NDIS_STATUS_PENDING );
}


VOID
SendControlAck(
    IN TUNNELWORK* pWork,
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN ULONG_PTR* punpArgs )

    // A PTUNNELWORK routine to send a control acknowledge.
    //
    // This routine is called only at PASSIVE IRQL.
    //
{
    ADAPTERCB* pAdapter;

    TRACE( TL_N, TM_Send, ( "SendControlAck" ) );

    // Unpack context information then free the work item.
    //
    pAdapter = pTunnel->pAdapter;
    FREE_TUNNELWORK( pAdapter, pWork );

    SendZlb( pTunnel, NULL, pTunnel->usNs, pTunnel->usNr, FALSE );
}


VOID
SendPayloadAck(
    IN TUNNELWORK* pWork,
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN ULONG_PTR* punpArgs )

    // A PTUNNELWORK routine to send a payload acknowledge.
    //
    // This routine is called only at PASSIVE IRQL.
    //
    // IMPORTANT: Caller must take a call reference before calling that is
    //            removed by the send completion handler.
    //
{
    ADAPTERCB* pAdapter;

    TRACE( TL_N, TM_Send, ( "SendPayloadAck" ) );

    // Unpack context information then free the work item.
    //
    pAdapter = pTunnel->pAdapter;
    FREE_TUNNELWORK( pAdapter, pWork );

    ASSERT( pVc );
    ASSERT( pVc->usAssignedCallId > 0 );

    SendZlb( pTunnel, pVc, pVc->usNs, pVc->usNr, FALSE );
}


VOID
SendPayloadReset(
    IN TUNNELWORK* pWork,
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN ULONG_PTR* punpArgs )

    // A PTUNNELWORK routine to send a payload reset.  Arg0 is the "Next Sent"
    // value to send in the reset message.
    //
    // This routine is called only at PASSIVE IRQL.
    //
    // IMPORTANT: Caller must take a call reference before calling that is
    //            removed by the send completion handler.
    //
{
    ADAPTERCB* pAdapter;
    USHORT usNs;

    // Unpack context information then free the work item.
    //
    pAdapter = pTunnel->pAdapter;
    usNs = (USHORT )(punpArgs[ 0 ]);
    FREE_TUNNELWORK( pAdapter, pWork );

    TRACE( TL_A, TM_Send, ( "Send Reset=%d", (LONG )usNs ) );
    WPLOG( LL_A, LM_Send, ( "Send Reset=%d", (LONG )usNs ) );
    ASSERT( pVc );
    ASSERT( pVc->usAssignedCallId > 0 );

    SendZlb( pTunnel, pVc, usNs, pVc->usNr, TRUE );
}


VOID
ReferenceControlSent(
    IN CONTROLSENT* pCs )

    // Reference the control-sent context 'pCs'.
    //
{
    LONG lRef;

    lRef = NdisInterlockedIncrement( &pCs->lRef );
    TRACE( TL_N, TM_Ref, ( "RefCs to %d", lRef ) );
}


LONG
DereferenceControlSent(
    IN CONTROLSENT* pCs )

    // Reference the control-sent context 'pCs'.
    //
    // Returns the reference count of the dereferenced context.
    //
{
    LONG lRef;
    ADAPTERCB* pAdapter;
    NDIS_BUFFER* pNdisBuffer;

    lRef = NdisInterlockedDecrement( &pCs->lRef );
    TRACE( TL_N, TM_Ref, ( "DerefCs to %d", lRef ) );
    ASSERT( lRef >= 0 );

    if (lRef == 0)
    {
        pAdapter = pCs->pTunnel->pAdapter;

        ASSERT( pCs->linkSendsOut.Flink == &pCs->linkSendsOut );

        pNdisBuffer = NdisBufferFromBuffer( pCs->pBuffer );
        NdisAdjustBufferLength(
            pNdisBuffer, BufferSizeFromBuffer( pCs->pBuffer ) );
        FreeBufferToPool(
            &pAdapter->poolFrameBuffers, pCs->pBuffer, TRUE );

        if (pCs->pVc)
        {
            DereferenceVc( pCs->pVc );
        }

        ASSERT( pCs->pTunnel )
        DereferenceTunnel( pCs->pTunnel );

        FREE_TIMERQITEM( pAdapter, pCs->pTqiSendTimeout );
        FREE_CONTROLSENT( pAdapter, pCs );
    }

    return lRef;
}


VOID
ReferencePayloadSent(
    IN PAYLOADSENT* pPs )

    // Reference the payload-sent context 'pPs'.
    //
{
    LONG lRef;

    lRef = NdisInterlockedIncrement( &pPs->lRef );
    TRACE( TL_N, TM_Ref, ( "RefPs to %d", lRef ) );
}


LONG
DereferencePayloadSent(
    IN PAYLOADSENT* pPs )

    // Reference the payload-sent context 'pPs'.
    //
    // Returns the reference count of the dereferenced context.
    //
{
    LONG lRef;
    ADAPTERCB* pAdapter;

    lRef = NdisInterlockedDecrement( &pPs->lRef );
    TRACE( TL_N, TM_Ref, ( "DerefPs to %d", lRef ) );
    ASSERT( lRef >= 0 );

    if (lRef == 0)
    {
        ASSERT( pPs->linkSendsOut.Flink == &pPs->linkSendsOut );

        // The actual work is scheduled because it calls outside the driver
        // and we don't want any lock restrictions on this routine.
        //
        ScheduleTunnelWork(
            pPs->pTunnel, pPs->pVc, CompletePayloadSent,
            (ULONG_PTR )pPs, 0, 0, 0, FALSE, FALSE );
    }

    return lRef;
}


//-----------------------------------------------------------------------------
// Send utility routines (alphabetically)
//-----------------------------------------------------------------------------

USHORT
BuildAvpAch(
    IN USHORT usAttribute,
    IN BOOLEAN fMandatory,
    IN CHAR* pszValue,
    IN USHORT usValueLength,
    OUT CHAR* pAvp )

    // Builds a byte-array-valued AVP in caller's buffer 'pAvp' with attribute
    // field value 'usAttribute' and value the first 'usValueLength' bytes of
    // array 'pszlValue'.  'FMandatory' indicates the M-bit should be set in
    // the AVP.
    //
    // Returns the length of the built AVP.
    //
{
    UNALIGNED USHORT* pusCur;
    UNALIGNED USHORT* pusBits;
    USHORT usLength;

    pusCur = (UNALIGNED USHORT* )pAvp;
    pusBits = pusCur;
    ++pusCur;

    // Set Vendor ID to "IETF-defined".
    //
    *pusCur = 0;
    ++pusCur;

    // Set Attribute field.
    //
    *pusCur = htons( usAttribute );
    ++pusCur;

    // Set Value field.
    //
    if (usValueLength)
    {
        NdisMoveMemory( (CHAR* )pusCur, pszValue, (ULONG )usValueLength );
        ((CHAR* )pusCur) += usValueLength;
    }

    // Now, go back and set bits/length field.
    //
    usLength = (USHORT )(((CHAR* )pusCur) - pAvp);
    *pusBits = usLength;
    if (fMandatory)
    {
        *pusBits |= ABM_M;
    }
    *pusBits = htons( *pusBits );

    return usLength;
}


USHORT
BuildAvpAul(
    IN USHORT usAttribute,
    IN BOOLEAN fMandatory,
    IN UNALIGNED ULONG* pulValue,
    IN USHORT usValues,
    OUT CHAR* pAvp )

    // Builds a ULONG-array-valued AVP in caller's buffer 'pAvp' with
    // attribute field value 'usAttribute' and value the first 'usValues'
    // ULONGS of array 'pszlValue'.  'FMandatory' indicates the M-bit should
    // be set in the AVP.
    //
    // Returns the length of the built AVP.
    //
{
    UNALIGNED USHORT* pusCur;
    UNALIGNED USHORT* pusBits;
    USHORT usLength;
    USHORT i;

    pusCur = (UNALIGNED USHORT* )pAvp;
    pusBits = pusCur;
    ++pusCur;

    // Set Vendor ID to "IETF-defined".
    //
    *pusCur = 0;
    ++pusCur;

    // Set Attribute field.
    //
    *pusCur = htons( usAttribute );
    ++pusCur;

    // Set Value field.
    //
    for (i = 0; i < usValues; ++i)
    {
        *((UNALIGNED ULONG* )pusCur) = pulValue[ i ];
        *((UNALIGNED ULONG* )pusCur) = htonl( *((UNALIGNED ULONG* )pusCur) );
        pusCur += 2;
    }

    // Now, go back and set bits/length field.
    //
    usLength = (USHORT )(((CHAR* )pusCur) - pAvp);
    *pusBits = usLength;
    if (fMandatory)
    {
        *pusBits |= ABM_M;
    }
    *pusBits = htons( *pusBits );

    return usLength;
}


USHORT
BuildAvpFlag(
    IN USHORT usAttribute,
    IN BOOLEAN fMandatory,
    OUT CHAR* pAvp )

    // Builds an empty (no data) flag AVP in caller's buffer 'pAvp' with
    // attribute field value 'usAttribute'.  'FMandatory' indicates the M-bit
    // should be set in the AVP.
    //
    // Returns the length of the built AVP.
    //
{
    UNALIGNED USHORT* pusCur;
    UNALIGNED USHORT* pusBits;
    USHORT usLength;

    pusCur = (UNALIGNED USHORT* )pAvp;
    pusBits = pusCur;
    ++pusCur;

    // Set Vendor ID to "IETF-defined".
    //
    *pusCur = 0;
    ++pusCur;

    // Set Attribute field.
    //
    *pusCur = htons( usAttribute );
    ++pusCur;

    // Now, go back and set bits/length field.
    //
    usLength = (USHORT )(((CHAR* )pusCur) - pAvp);
    *pusBits = usLength;
    if (fMandatory)
    {
        *pusBits |= ABM_M;
    }
    *pusBits = htons( *pusBits );

    return usLength;
}


USHORT
BuildAvpUl(
    IN USHORT usAttribute,
    IN BOOLEAN fMandatory,
    IN ULONG ulValue,
    OUT CHAR* pAvp )

    // Builds a ULONG-valued AVP in caller's buffer 'pAvp' with attribute
    // field value 'usAttribute' and value 'ulValue'.  'FMandatory' indicates
    // the M-bit should be set in the AVP.
    //
    // Returns the length of the built AVP.
    //
{
    UNALIGNED USHORT* pusCur;
    UNALIGNED USHORT* pusBits;
    USHORT usLength;

    pusCur = (UNALIGNED USHORT* )pAvp;
    pusBits = pusCur;
    ++pusCur;

    // Set Vendor ID to "IETF-defined".
    //
    *pusCur = 0;
    ++pusCur;

    // Set Attribute field.
    //
    *pusCur = htons( usAttribute );
    ++pusCur;

    // Set Value field.
    //
    *((UNALIGNED ULONG* )pusCur) = htonl( ulValue );
    pusCur += 2;

    // Now, go back and set bits/length field.
    //
    usLength = (USHORT )(((CHAR* )pusCur) - pAvp);
    *pusBits = usLength;
    if (fMandatory)
    {
        *pusBits |= ABM_M;
    }
    *pusBits = htons( *pusBits );

    return usLength;
}


USHORT
BuildAvpUs(
    IN USHORT usAttribute,
    IN BOOLEAN fMandatory,
    IN USHORT usValue,
    OUT CHAR* pAvp )

    // Builds a USHORT-valued AVP in caller's buffer 'pAvp' with attribute
    // field value 'usAttribute' and value 'usValue'.  'FMandatory' indicates
    // the M-bit should be set in the AVP.
    //
    // Returns the length of the built AVP.
    //
{
    UNALIGNED USHORT* pusCur;
    UNALIGNED USHORT* pusBits;
    USHORT usLength;

    pusCur = (UNALIGNED USHORT* )pAvp;
    pusBits = pusCur;
    ++pusCur;

    // Set Vendor ID to "IETF-defined".
    //
    *pusCur = 0;
    ++pusCur;

    // Set Attribute field.
    //
    *pusCur = htons( usAttribute );
    ++pusCur;

    // Set Value field.
    //
    *pusCur = htons( usValue );
    ++pusCur;

    // Now, go back and set bits/length field.
    //
    usLength = (USHORT )(((CHAR* )pusCur) - pAvp);
    *pusBits = usLength;
    if (fMandatory)
    {
        *pusBits |= ABM_M;
    }
    *pusBits = htons( *pusBits );

    return usLength;
}


USHORT
BuildAvp2UsAndAch(
    IN USHORT usAttribute,
    IN BOOLEAN fMandatory,
    IN USHORT usValue1,
    IN USHORT usValue2,
    IN CHAR* pszValue,
    IN USHORT usValueLength,
    OUT CHAR* pAvp )

    // Builds an AVP consisting of 'usValue1' and 'usValue2' followed by
    // message 'pszValue' of length 'usValueLength' bytes in caller's buffer
    // 'pAvp' with attribute field value 'usAttribute'.  'FMandatory'
    // indicates the M-bit should be set in the AVP.
    //
    // Returns the length of the built AVP.
    //
{
    UNALIGNED USHORT* pusCur;
    UNALIGNED USHORT* pusBits;
    USHORT usLength;

    pusCur = (UNALIGNED USHORT* )pAvp;
    pusBits = pusCur;
    ++pusCur;

    // Set Vendor ID to "IETF-defined".
    //
    *pusCur = 0;
    ++pusCur;

    // Set Attribute field.
    //
    *pusCur = htons( usAttribute );
    ++pusCur;

    // Set first USHORT value field.
    //
    *pusCur = htons( usValue1 );
    ++pusCur;

    // Set second USHORT value field.
    //
    *pusCur = htons( usValue2 );
    ++pusCur;

    // Set message value field.
    //
    if (usValueLength)
    {
        NdisMoveMemory( (CHAR* )pusCur, pszValue, (ULONG )usValueLength );
        ((CHAR*)pusCur) += usValueLength;
    }

    // Now, go back and set bits/length field.
    //
    usLength = (USHORT )(((CHAR* )pusCur) - pAvp);
    *pusBits = usLength;
    if (fMandatory)
    {
        *pusBits |= ABM_M;
    }
    *pusBits = htons( *pusBits );

    return usLength;
}


VOID
BuildCdnAvps(
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN ULONG ulArg1,
    IN ULONG ulArg2,
    IN PVOID pvArg3,
    IN OUT CHAR* pAvpBuffer,
    OUT ULONG* pulAvpLength )

    // PBUILDAVPS handler to add AVPs to an outgoing CallDisconnNotify control
    // message.  'PTunnel' and 'pVc' are the tunnel/VC control blocks.
    // 'ulArg1' and 'ulArg2' are the result and error codes to be returned.
    // 'pvArg3' is ignored.  'PAvpBuffer' is the address of the buffer to
    // receive the built AVPs.  '*PulAvpLength' is set to the length of the
    // built AVPs.
    //
{
    CHAR* pCurAvp;
    ULONG ulAvpLength;
    USHORT usResult;
    USHORT usError;

    TRACE( TL_V, TM_Send, ( "BuildCdnAvps" ) );

    usResult = (USHORT )ulArg1;
    usError = (USHORT )ulArg2;

    pCurAvp = pAvpBuffer;

    pCurAvp += BuildAvpUs(
        ATTR_MsgType, TRUE, CMT_CDN, pCurAvp );

    pCurAvp += BuildAvp2UsAndAch(
        ATTR_Result, TRUE, usResult, usError, NULL, 0, pCurAvp );
    
    WPLOG( LL_M, LM_CMsg, ( "Result=%d, Error=%d", usResult, usError));

    pCurAvp += BuildAvpUs(
        ATTR_AssignedCallId, TRUE, pVc->usCallId, pCurAvp );

    *pulAvpLength = (ULONG )(pCurAvp - pAvpBuffer);
}


VOID
BuildHelloAvps(
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN ULONG ulArg1,
    IN ULONG ulArg2,
    IN PVOID pvArg3,
    IN OUT CHAR* pAvpBuffer,
    OUT ULONG* pulAvpLength )

    // PBUILDAVPS handler to add AVPs to an outgoing Hello control message.
    // 'PTunnel' is the tunnel control block.  'PVc', 'ulArgX' and 'pvArg3' are ignored.
    // 'PAvpBuffer' is the address of the buffer to receive the built AVPs.
    // '*PulAvpLength' is set to the length of the built AVPs.
    //
{
    CHAR* pCurAvp;
    ULONG ulAvpLength;
    ADAPTERCB* pAdapter;

    TRACE( TL_V, TM_Send, ( "BuildHelloAvps" ) );

    pAdapter = pTunnel->pAdapter;
    pCurAvp = pAvpBuffer;

    pCurAvp += BuildAvpUs(
        ATTR_MsgType, TRUE, CMT_Hello, pCurAvp );

    *pulAvpLength = (ULONG )(pCurAvp - pAvpBuffer);
}


VOID
BuildIccnAvps(
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN ULONG ulArg1,
    IN ULONG ulArg2,
    IN PVOID pvArg3,
    IN OUT CHAR* pAvpBuffer,
    OUT ULONG* pulAvpLength )

    // PBUILDAVPS handler to add AVPs to an outgoing Incoming-Call-Connected
    // control message.  'PTunnel' and 'pVc' are the tunnel/VC control blocks.
    // 'UlArgX' and 'pvArg3' are ignored.  'PAvpBuffer' is the address of the buffer to
    // receive the built AVPs.  '*PulAvpLength' is set to the length of the
    // built AVPs.
    //
{
    CHAR* pCurAvp;
    ULONG ulAvpLength;
    ADAPTERCB* pAdapter;
    BOOLEAN fSequencing;

    pAdapter = pTunnel->pAdapter;

    TRACE( TL_V, TM_Send, ( "BuildIccnAvps" ) );

    pCurAvp = pAvpBuffer;

    pCurAvp += BuildAvpUs(
        ATTR_MsgType, TRUE, CMT_ICCN, pCurAvp );

    // For now, we don't support WAN link relays, so this is the estimated
    // speed of the LAN relay.  This could be totally wrong if, for instance,
    // the tunnel is itself tunneled over a PPP link.
    //
    pCurAvp += BuildAvpUl(
        ATTR_TxConnectSpeed, TRUE, pVc->ulConnectBps, pCurAvp );

    pCurAvp += BuildAvpUl(
        ATTR_FramingType, TRUE, FBM_Sync, pCurAvp );

    fSequencing = !!(ReadFlags( &pVc->ulFlags ) & VCBF_Sequencing);
    if (fSequencing)
    {
        USHORT usRWindow;

        usRWindow = pAdapter->usPayloadReceiveWindow;
        if (!usRWindow)
        {
            usRWindow = L2TP_DefaultReceiveWindow;
        }

        pCurAvp += BuildAvpUs(
            ATTR_RWindowSize, TRUE, usRWindow, pCurAvp );
    }

#if 0
    // Use the LNS default PPD even when we're LAC, for now.
    //
    pCurAvp += BuildAvpUs(
        ATTR_PacketProcDelay, TRUE, L2TP_LnsDefaultPpd, pCurAvp );
#endif

    pCurAvp += BuildAvpUs(
        ATTR_ProxyAuthType, FALSE, PAT_None, pCurAvp );

    if (fSequencing)
    {
        pCurAvp += BuildAvpFlag(
            ATTR_SequencingRequired, TRUE, pCurAvp );
    }

    *pulAvpLength = (ULONG )(pCurAvp - pAvpBuffer);
}


VOID
BuildIcrpAvps(
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN ULONG ulArg1,
    IN ULONG ulArg2,
    IN PVOID pvArg3,
    IN OUT CHAR* pAvpBuffer,
    OUT ULONG* pulAvpLength )

    // PBUILDAVPS handler to add AVPs to an outgoing Incoming-Call-Reply
    // control message.  'PTunnel' and 'pVc' are the tunnel/VC control blocks.
    // 'UlArgX' and 'pvArg3' are ignored.  'PAvpBuffer' is the address of the buffer to
    // receive the built AVPs.  '*PulAvpLength' is set to the length of the
    // built AVPs.
    //
{
    CHAR* pCurAvp;
    ULONG ulAvpLength;
    ADAPTERCB* pAdapter;

    pAdapter = pTunnel->pAdapter;

    TRACE( TL_V, TM_Send, ( "BuildIcrpAvps" ) );

    pCurAvp = pAvpBuffer;

    pCurAvp += BuildAvpUs(
        ATTR_MsgType, TRUE, CMT_ICRP, pCurAvp );

    pCurAvp += BuildAvpUs(
        ATTR_AssignedCallId, TRUE, pVc->usCallId, pCurAvp );

    if (ReadFlags( &pVc->ulFlags ) & VCBF_Sequencing)
    {
        USHORT usRWindow;

        usRWindow = pAdapter->usPayloadReceiveWindow;
        if (!usRWindow)
            usRWindow = L2TP_DefaultReceiveWindow;

        pCurAvp += BuildAvpUs(
            ATTR_RWindowSize, TRUE, usRWindow, pCurAvp );
    }

#if 0
    pCurAvp += BuildAvpUs(
        ATTR_PacketProcDelay, TRUE, L2TP_LnsDefaultPpd, pCurAvp );
#endif

    *pulAvpLength = (ULONG )(pCurAvp - pAvpBuffer);
}


VOID
BuildIcrqAvps(
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN ULONG ulArg1,
    IN ULONG ulArg2,
    IN PVOID pvArg3,
    IN OUT CHAR* pAvpBuffer,
    OUT ULONG* pulAvpLength )

    // PBUILDAVPS handler to add AVPs to an outgoing Incoming-Call-Request
    // control message.  'PTunnel' and 'pVc' are the tunnel/VC control block.
    // 'UlArgX' and 'pvArg3' are ignored.  'PAvpBuffer' is the address of the buffer to
    // receive the built AVPs.  '*PulAvpLength' is set to the length of the
    // built AVPs.
    //
{
    CHAR* pCurAvp;
    ULONG ulAvpLength;
    ADAPTERCB* pAdapter;

    pAdapter = pTunnel->pAdapter;

    TRACE( TL_V, TM_Send, ( "BuildIcrqAvps" ) );

    pCurAvp = pAvpBuffer;

    pCurAvp += BuildAvpUs(
        ATTR_MsgType, TRUE, CMT_ICRQ, pCurAvp );

    pCurAvp += BuildAvpUs(
        ATTR_AssignedCallId, TRUE, pVc->usCallId, pCurAvp );

    pCurAvp += BuildAvpUl(
        ATTR_CallSerialNumber, TRUE,
        pVc->pLcParams->ulCallSerialNumber, pCurAvp );

    {
        ULONG ulBearerType;

        ulBearerType = 0;
        if (pVc->pTcParams->ulMediaMode & LINEMEDIAMODE_DATAMODEM)
        {
            ulBearerType |= BBM_Analog;
        }

        if (pVc->pTcParams->ulMediaMode & LINEMEDIAMODE_DIGITALDATA)
        {
            ulBearerType |= BBM_Digital;
        }

        pCurAvp += BuildAvpUl(
            ATTR_BearerType, TRUE, ulBearerType, pCurAvp );
    }

    if (pVc->pLcParams->ulPhysicalChannelId != 0xFFFFFFFF)
    {
        pCurAvp += BuildAvpUl(
            ATTR_PhysicalChannelId, FALSE,
            pVc->pLcParams->ulPhysicalChannelId, pCurAvp );
    }

    *pulAvpLength = (ULONG )(pCurAvp - pAvpBuffer);
}


ULONG
BuildL2tpHeader(
    IN OUT CHAR* pBuffer,
    IN BOOLEAN fControl,
    IN BOOLEAN fReset,
    IN USHORT* pusTunnelId,
    IN USHORT* pusCallId,
    IN USHORT* pusNs,
    IN USHORT usNr )

    // Fill in caller's 'pBuffer' with an L2TP header matching caller's
    // arguments.  'FControl' indicates to build a control header, otherwise a
    // payload header is built.  'fReset' indicates to build a reset rather
    // than a simple acknowledge.  Arguments that are not to appear in the
    // header are NULL.  Note that 'usNr' is not a pointer because it's
    // appearance in the header is tied to the appearance of 'pusNs'.
    //
    // Returns the total length of the header.
    //
{
    UNALIGNED USHORT* pusBits;
    UNALIGNED USHORT* pusLength;
    UNALIGNED USHORT* pusCur;
    ULONG ulLength;

    pusCur = (UNALIGNED USHORT* )pBuffer;
    pusBits = pusCur;
    ++pusCur;

    pusLength = pusCur;
    ++pusCur;

    // Initialize header bit mask with the version, and set the length bit
    // since the Length field is always sent.
    //
    *pusBits = HBM_L | VER_L2tp;
    if (fControl)
    {
        ASSERT( pusTunnelId && pusCallId && pusNs && !fReset );
        *pusBits |= HBM_T;
    }
    else if (fReset)
    {
        ASSERT( pusTunnelId && pusCallId && pusNs );
        *pusBits |= HBM_R;
    }

    if (pusTunnelId)
    {
        // Tunnel-ID field present.  Draft-05 removes the 'I' bit that used to
        // indicate the Tunnel-ID is present.  It is now assumed to be always
        // present.
        //
        *pusCur = htons( *pusTunnelId );
        ++pusCur;
    }

    if (pusCallId)
    {
        // Call-ID field present.  Draft-05 removes the 'C' bit that used to
        // indicate the Tunnel-ID is present.  It is now assumed to be always
        // present.
        //
        *pusCur = htons( *pusCallId );
        ++pusCur;
    }

    if (pusNs)
    {
        // Ns and Nr fields are present.
        //
        *pusBits |= HBM_F;
        *pusCur = htons( *pusNs );
        ++pusCur;
        *pusCur = htons( usNr );
        ++pusCur;
    }

    // Fill in the header and length fields with the accumulated
    // values.
    //
    *pusBits = htons( *pusBits );
    *pusLength = (USHORT )(((CHAR* )pusCur) - pBuffer);
    ulLength = (ULONG )*pusLength;
    *pusLength = htons( *pusLength );

    return ulLength;
}


VOID
BuildOccnAvps(
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN ULONG ulArg1,
    IN ULONG ulArg2,
    IN PVOID pvArg3,
    IN OUT CHAR* pAvpBuffer,
    OUT ULONG* pulAvpLength )

    // PBUILDAVPS handler to add AVPs to an outgoing Outgoing-Call-Connected
    // control message.  'PTunnel' and 'pVc' are the tunnel/VC control blocks.
    // 'UlArgX' and 'pvArg3' are ignored.  'PAvpBuffer' is the address of the buffer to
    // receive the built AVPs.  '*PulAvpLength' is set to the length of the
    // built AVPs.
    //
{
    CHAR* pCurAvp;
    ULONG ulAvpLength;
    ADAPTERCB* pAdapter;
    BOOLEAN fSequencing;

    pAdapter = pTunnel->pAdapter;

    TRACE( TL_V, TM_Send, ( "BuildOccnAvps" ) );

    pCurAvp = pAvpBuffer;

    pCurAvp += BuildAvpUs(
        ATTR_MsgType, TRUE, CMT_OCCN, pCurAvp );

    pCurAvp += BuildAvpUl(
        ATTR_TxConnectSpeed, TRUE, pVc->ulConnectBps, pCurAvp );

    pCurAvp += BuildAvpUl(
        ATTR_FramingType, TRUE, FBM_Sync, pCurAvp );

    fSequencing = !!(ReadFlags( &pVc->ulFlags ) & VCBF_Sequencing);
    if (fSequencing)
    {
        USHORT usRWindow;

        usRWindow = pAdapter->usPayloadReceiveWindow;
        if (!usRWindow)
        {
            usRWindow = L2TP_DefaultReceiveWindow;
        }

        pCurAvp += BuildAvpUs(
            ATTR_RWindowSize, TRUE, usRWindow, pCurAvp );
    }

#if 0
    // Use the LNS default PPD even when we're LAC, for now.
    //
    pCurAvp += BuildAvpUs(
        ATTR_PacketProcDelay, TRUE, L2TP_LnsDefaultPpd, pCurAvp );
#endif

    if (fSequencing)
    {
        pCurAvp += BuildAvpFlag(
            ATTR_SequencingRequired, TRUE, pCurAvp );
    }

    *pulAvpLength = (ULONG )(pCurAvp - pAvpBuffer);
}


VOID
BuildOcrpAvps(
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN ULONG ulArg1,
    IN ULONG ulArg2,
    IN PVOID pvArg3,
    IN OUT CHAR* pAvpBuffer,
    OUT ULONG* pulAvpLength )

    // PBUILDAVPS handler to add AVPs to an outgoing Outgoing-Call-Reply
    // control message.  'PTunnel' and 'pVc' are the tunnel/VC control blocks.
    // 'UlArgX' and 'pvArg3' are ignored.  'PAvpBuffer' is the address of the buffer to
    // receive the built AVPs.  '*PulAvpLength' is set to the length of the
    // built AVPs.
    //
{
    CHAR* pCurAvp;
    ULONG ulAvpLength;

    TRACE( TL_V, TM_Send, ( "BuildOcrpAvps" ) );

    pCurAvp = pAvpBuffer;

    pCurAvp += BuildAvpUs(
        ATTR_MsgType, TRUE, CMT_OCRP, pCurAvp );

    pCurAvp += BuildAvpUs(
        ATTR_AssignedCallId, TRUE, pVc->usCallId, pCurAvp );

    ASSERT( pVc->pLcParams );
    if (pVc->pLcParams->ulPhysicalChannelId != 0xFFFFFFFF)
    {
        pCurAvp += BuildAvpUl(
            ATTR_PhysicalChannelId, FALSE,
            pVc->pLcParams->ulPhysicalChannelId, pCurAvp );
    }

    *pulAvpLength = (ULONG )(pCurAvp - pAvpBuffer);
}


VOID
BuildOcrqAvps(
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN ULONG ulArg1,
    IN ULONG ulArg2,
    IN PVOID pvArg3,
    IN OUT CHAR* pAvpBuffer,
    OUT ULONG* pulAvpLength )

    // PBUILDAVPS handler to add AVPs to an outgoing Outgoing-Call-Request
    // control message.  'PTunnel' and 'pVc' are the tunnel/VC control block.
    // 'UlArgX' are ignored.  'PAvpBuffer' is the address of the buffer to
    // receive the built AVPs.  '*PulAvpLength' is set to the length of the
    // built AVPs.
    //
{
    CHAR* pCurAvp;
    ULONG ulAvpLength;
    ADAPTERCB* pAdapter;

    pAdapter = pTunnel->pAdapter;

    TRACE( TL_V, TM_Send, ( "BuildOcrqAvps" ) );

    pCurAvp = pAvpBuffer;

    pCurAvp += BuildAvpUs(
        ATTR_MsgType, TRUE, CMT_OCRQ, pCurAvp );

    pCurAvp += BuildAvpUs(
        ATTR_AssignedCallId, TRUE, pVc->usCallId, pCurAvp );

    pCurAvp += BuildAvpUl(
        ATTR_CallSerialNumber, TRUE,
        pVc->pLcParams->ulCallSerialNumber, pCurAvp );

    {
        ULONG ulBps;

        ulBps = pVc->pTcParams->ulMinRate;
        if (ulBps == 0)
        {
            ulBps = 1;
        }
        else if (ulBps > 0x7FFFFFFF)
        {
            ulBps = 0x7FFFFFFF;
        }

        pCurAvp += BuildAvpUl(
            ATTR_MinimumBps, TRUE, ulBps, pCurAvp );

        ulBps = pVc->pTcParams->ulMaxRate;
        if (ulBps == 0)
        {
            ulBps = 1;
        }
        else if (ulBps > 0x7FFFFFFF)
        {
            ulBps = 0x7FFFFFFF;
        }

        pCurAvp += BuildAvpUl(
            ATTR_MaximumBps, TRUE, ulBps, pCurAvp );
    }

    {
        ULONG ulBearerType;

        ulBearerType = 0;
        if (pVc->pTcParams->ulMediaMode & LINEMEDIAMODE_DATAMODEM)
        {
            ulBearerType |= BBM_Analog;
        }

        if (pVc->pTcParams->ulMediaMode & LINEMEDIAMODE_DIGITALDATA)
        {
            ulBearerType |= BBM_Digital;
        }

        pCurAvp += BuildAvpUl(
            ATTR_BearerType, TRUE, ulBearerType, pCurAvp );
    }

    pCurAvp += BuildAvpUl(
        ATTR_FramingType, TRUE, FBM_Sync, pCurAvp );

    if (ReadFlags( &pVc->ulFlags ) & VCBF_Sequencing)
    {
        ASSERT( pAdapter->usPayloadReceiveWindow );
        pCurAvp += BuildAvpUs(
            ATTR_RWindowSize, TRUE,
            pAdapter->usPayloadReceiveWindow, pCurAvp );
    }

#if 0
    pCurAvp += BuildAvpUs(
        ATTR_PacketProcDelay, TRUE, L2TP_LnsDefaultPpd, pCurAvp );
#endif

    *pulAvpLength = (ULONG )(pCurAvp - pAvpBuffer);
}


VOID
BuildScccnAvps(
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN ULONG ulArg1,
    IN ULONG ulArg2,
    IN PVOID pvArg3,
    IN OUT CHAR* pAvpBuffer,
    OUT ULONG* pulAvpLength )

    // PBUILDAVPS handler to add AVPs to an outgoing Start-Cc-Connected
    // control message.  'PTunnel' is the tunnel control block.  'PVc' is
    // ignored.  'UlArg1' is the true if a challenge response is to be sent,
    // false otherwise.  'UlArg2' and 'pvArg3' are ignored.  'PAvpBuffer' is
    // the address of the buffer to receive the built AVPs.  '*PulAvpLength'
    // is set to the length of the built AVPs.
    //
{
    CHAR* pCurAvp;
    ULONG ulAvpLength;

    TRACE( TL_V, TM_Send, ( "BuildScccnAvps" ) );

    pCurAvp = pAvpBuffer;

    pCurAvp += BuildAvpUs(
        ATTR_MsgType, TRUE, CMT_SCCCN, pCurAvp );

    if (ulArg1)
    {
        pCurAvp += BuildAvpAch(
            ATTR_ChallengeResponse, TRUE,
            pTunnel->achResponseToSend, sizeof(pTunnel->achResponseToSend),
            pCurAvp );
    }

    *pulAvpLength = (ULONG )(pCurAvp - pAvpBuffer);
}


VOID
BuildSccrpAvps(
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN ULONG ulArg1,
    IN ULONG ulArg2,
    IN PVOID pvArg3,
    IN OUT CHAR* pAvpBuffer,
    OUT ULONG* pulAvpLength )

    // PBUILDAVPS handler to add AVPs to an outgoing Start-Cc-Reply control
    // message.  'PTunnel' is the tunnel control block.  'PVc' is ignored.
    // 'UlArg1' is true if a challenge response is to be sent, false
    // otherwise.  'UlArg2' and 'pvArg3' are ignored.  'PAvpBuffer' is the
    // address of the buffer to receive the built AVPs.  '*PulAvpLength' is
    // set to the length of the built AVPs.
    //
{
    CHAR* pCurAvp;
    ULONG ulAvpLength;
    ADAPTERCB* pAdapter;

    TRACE( TL_N, TM_Send, ( "BuildSccrpAvps" ) );

    pAdapter = pTunnel->pAdapter;

    pCurAvp = pAvpBuffer;

    pCurAvp += BuildAvpUs(
        ATTR_MsgType, TRUE, CMT_SCCRP, pCurAvp );

    pCurAvp += BuildAvpUs(
        ATTR_ProtocolVersion, TRUE, L2TP_ProtocolVersion, pCurAvp );

    pCurAvp += BuildAvpUl(
        ATTR_FramingCaps, TRUE, pAdapter->ulFramingCaps, pCurAvp );

    pCurAvp += BuildAvpUl(
        ATTR_BearerCaps, TRUE, pAdapter->ulBearerCaps, pCurAvp );

    pCurAvp += BuildAvpUs(
        ATTR_FirmwareRevision, FALSE, L2TP_FirmwareRevision, pCurAvp );

    ASSERT( pAdapter->pszHostName );
    pCurAvp += BuildAvpAch(
        ATTR_HostName, TRUE,
        pAdapter->pszHostName,
        (USHORT )strlen( pAdapter->pszHostName ),
        pCurAvp );

    pCurAvp += BuildAvpAch(
        ATTR_VendorName, FALSE,
        L2TP_VendorName, (USHORT )strlen( L2TP_VendorName ), pCurAvp );

    pCurAvp += BuildAvpUs(
        ATTR_AssignedTunnelId, TRUE, pTunnel->usTunnelId, pCurAvp );

    if (pAdapter->usControlReceiveWindow)
    {
        pCurAvp += BuildAvpUs(
            ATTR_RWindowSize, TRUE,
            pAdapter->usControlReceiveWindow, pCurAvp );
    }

    if (pAdapter->pszPassword)
    {
        pCurAvp += BuildAvpAch(
            ATTR_Challenge, TRUE,
            pTunnel->achChallengeToSend,
            sizeof(pTunnel->achChallengeToSend),
            pCurAvp );
    }

    if (ulArg1)
    {
        pCurAvp += BuildAvpAch(
            ATTR_ChallengeResponse, TRUE,
            pTunnel->achResponseToSend,
            sizeof(pTunnel->achResponseToSend),
            pCurAvp );
    }

    *pulAvpLength = (ULONG )(pCurAvp - pAvpBuffer);
}


VOID
BuildSccrqAvps(
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN ULONG ulArg1,
    IN ULONG ulArg2,
    IN PVOID pvArg3,
    IN OUT CHAR* pAvpBuffer,
    OUT ULONG* pulAvpLength )

    // PBUILDAVPS handler to add AVPs to an outgoing Start-Cc-Request control
    // message.  'PTunnel' is the tunnel control block.  'PVc', 'ulArgX' and 'pvArg3'
    // are ignored.  'PAvpBuffer' is the address of the buffer to receive the
    // built AVPs.  '*PulAvpLength' is set to the length of the built AVPs.
    //
{
    CHAR* pCurAvp;
    ULONG ulAvpLength;
    ADAPTERCB* pAdapter;

    TRACE( TL_V, TM_Send, ( "BuildSccrqAvps" ) );

    pAdapter = pTunnel->pAdapter;
    pCurAvp = pAvpBuffer;

    pCurAvp += BuildAvpUs(
        ATTR_MsgType, TRUE, CMT_SCCRQ, pCurAvp );

    pCurAvp += BuildAvpUs(
        ATTR_ProtocolVersion, TRUE, L2TP_ProtocolVersion, pCurAvp );

    pCurAvp += BuildAvpUl(
        ATTR_FramingCaps, TRUE, pAdapter->ulFramingCaps, pCurAvp );

    pCurAvp += BuildAvpUl(
        ATTR_BearerCaps, TRUE, pAdapter->ulBearerCaps, pCurAvp );

    pCurAvp += BuildAvpUs(
        ATTR_FirmwareRevision, FALSE, L2TP_FirmwareRevision, pCurAvp );

    if (pAdapter->pszHostName)
    {
        pCurAvp += BuildAvpAch(
            ATTR_HostName, TRUE,
            pAdapter->pszHostName,
            (USHORT )strlen( pAdapter->pszHostName ),
            pCurAvp );
    }

    pCurAvp += BuildAvpAch(
        ATTR_VendorName, FALSE,
        L2TP_VendorName, (USHORT )strlen( L2TP_VendorName ), pCurAvp );

    pCurAvp += BuildAvpUs(
        ATTR_AssignedTunnelId, TRUE, pTunnel->usTunnelId, pCurAvp );

    if (pAdapter->usControlReceiveWindow)
    {
        pCurAvp += BuildAvpUs(
            ATTR_RWindowSize, TRUE, pAdapter->usControlReceiveWindow, pCurAvp );
    }

    if (pAdapter->pszPassword)
    {
        pCurAvp += BuildAvpAch(
            ATTR_Challenge, TRUE,
            pTunnel->achChallengeToSend,
            sizeof(pTunnel->achChallengeToSend),
            pCurAvp );
    }

    *pulAvpLength = (ULONG )(pCurAvp - pAvpBuffer);
}


VOID
BuildStopccnAvps(
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN ULONG ulArg1,
    IN ULONG ulArg2,
    IN PVOID pvArg3,
    IN OUT CHAR* pAvpBuffer,
    OUT ULONG* pulAvpLength )

    // PBUILDAVPS handler to add AVPs to an outgoing Stop-Cc-Notify control
    // message.  'PTunnel' is the tunnel control block.  'PVc' is ignored.
    // 'ulArg1' and 'ulArg2' are the result and error codes to be sent.
    // 'pvArg3' is ignored.  'PAvpBuffer' is the address of the buffer to
    // receive the built AVPs.  '*PulAvpLength' is set to the length of the
    // built AVPs.
    //
{
    CHAR* pCurAvp;
    ULONG ulAvpLength;
    USHORT usResult;
    USHORT usError;

    TRACE( TL_V, TM_Send, ( "BuildStopCcReqAvps" ) );

    usResult = (USHORT )ulArg1;
    usError = (USHORT )ulArg2;

    pCurAvp = pAvpBuffer;

    pCurAvp += BuildAvpUs(
        ATTR_MsgType, TRUE, CMT_StopCCN, pCurAvp );

    pCurAvp += BuildAvpUs(
        ATTR_AssignedTunnelId, TRUE, pTunnel->usTunnelId, pCurAvp );

    pCurAvp += BuildAvp2UsAndAch(
        ATTR_Result, TRUE, usResult, usError, NULL, 0, pCurAvp );

    WPLOG( LL_M, LM_CMsg, ( "Result=%d, Error=%d", usResult, usError));
            
    *pulAvpLength = (ULONG )(pCurAvp - pAvpBuffer);
}


VOID
BuildWenAvps(
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN ULONG ulArg1,
    IN ULONG ulArg2,
    IN PVOID pvArg3,
    IN OUT CHAR* pAvpBuffer,
    OUT ULONG* pulAvpLength )

    // PBUILDAVPS handler to add AVPs to an outgoing Wan-Error-Notify control
    // message.  'PTunnel' and 'pVc' are the tunnel/VC control block.
    // 'pvArg3' is the address of an array of 6 error ULONGs, i.e. CRC,
    // framing, hardware overrun, buffer overrun, timeouts, and alignment
    // errors that this routine FREE_NONPAGEDs after use. 'ulArgX' are ignored.  
    // 'PAvpBuffer' is the address of the buffer to
    // receive the built AVPs.  '*PulAvpLength' is set to the length of the
    // built AVPs.
    //
{
    CHAR* pCurAvp;
    ULONG ulAvpLength;
    ADAPTERCB* pAdapter;
    UNALIGNED ULONG* pul;

    pAdapter = pTunnel->pAdapter;
    pul = (UNALIGNED ULONG* )pvArg3;

    TRACE( TL_V, TM_Send, ( "BuildWenAvps" ) );

    pCurAvp = pAvpBuffer;

    pCurAvp += BuildAvpUs(
        ATTR_MsgType, TRUE, CMT_WEN, pCurAvp );

    pCurAvp += BuildAvpAul(
        ATTR_CallErrors, TRUE, pul, 6, pCurAvp );
    FREE_NONPAGED( pul );

    *pulAvpLength = (ULONG )(pCurAvp - pAvpBuffer);
}


VOID
CompletePayloadSent(
    IN TUNNELWORK* pWork,
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN ULONG_PTR* punpArgs )

    // A PTUNNELWORK routine to complete a "sent payload".  Arg0 is the
    // PAYLOADSENT context which has already been de-queued from the
    // "outstanding send" list.
    //
    // This routine is called only at PASSIVE IRQL.
    //
{
    NDIS_STATUS status;
    ADAPTERCB* pAdapter;
    PAYLOADSENT* pPs;
    NDIS_BUFFER* pNdisBuffer;

    // Unpack context information then free the work item.
    //
    pAdapter = pTunnel->pAdapter;
    pPs = (PAYLOADSENT* )(punpArgs[ 0 ]);
    FREE_TUNNELWORK( pAdapter, pWork );

    TRACE( TL_N, TM_Send, ( "CompletePayloadSent(Ns=%d)", (UINT )pPs->usNs ) );

    // Undo the adjustments made before the send so the owner of each
    // component resource gets back what they originally provided for clean-up
    // and recycling.
    //
    NdisUnchainBufferAtFront( pPs->pPacket, &pNdisBuffer );
    NdisAdjustBufferLength(
        pNdisBuffer, BufferSizeFromBuffer( pPs->pBuffer ) );
    FreeBufferToPool( &pAdapter->poolHeaderBuffers, pPs->pBuffer, TRUE );

    // Notify sending driver of the result.
    //
    NDIS_SET_PACKET_STATUS( pPs->pPacket, pPs->status );
    TRACE( TL_N, TM_Send, ("NdisMCoSendComp(s=$%x)", pPs->status ) );
    NdisMCoSendComplete( pPs->status, pPs->pVc->NdisVcHandle, pPs->pPacket );
    TRACE( TL_N, TM_Send, ("NdisMCoSendComp done" ) );

    DereferenceCall( pVc );
    DereferenceTunnel( pPs->pTunnel );
    DereferenceVc( pPs->pVc );

#ifdef PSDEBUG
    {
        extern LIST_ENTRY g_listDebugPs;
        extern NDIS_SPIN_LOCK g_lockDebugPs;

        NdisAcquireSpinLock( &g_lockDebugPs );
        {
            RemoveEntryList( &pPs->linkDebugPs );
            InitializeListHead( &pPs->linkDebugPs );
        }
        NdisReleaseSpinLock( &g_lockDebugPs );
    }
#endif

    FREE_TIMERQITEM( pAdapter, pPs->pTqiSendTimeout );
    FREE_PAYLOADSENT( pAdapter, pPs );
}


VOID
SendControlComplete(
    IN TDIXCONTEXT* pTdix,
    IN VOID* pContext1,
    IN VOID* pContext2,
    IN CHAR* pBuffer )

    // PTDIXSENDCOMPLETE handler for sends that send only a single buffer from
    // the 'ADAPTERCB.poolFrameBuffers' pool.
    //
{
    CONTROLSENT* pCs;
    ULONG ulSendTimeoutMs;

    TRACE( TL_V, TM_Send, ( "SendControlComp" ) );

    pCs = (CONTROLSENT* )pContext1;
    pCs->pIrp = NULL;

    // "Instant expire" the timer if the message is longer queued as an
    // outstanding send, i.e. it's been cancelled or terminated.  This is the
    // easiest way to clean up quickly yet reliably in this odd case.
    // Accessing the link and the send timeout without locks held is
    // technically not allowed, but the consequence of a misread is just a
    // very slight additional delay.  This is judged preferable to adding the
    // cost of taking and releasing a spinlock to every send.
    //
    if (pCs->linkSendsOut.Flink == &pCs->linkSendsOut)
    {
        ulSendTimeoutMs = 0;
        TRACE( TL_A, TM_Send,
            ( "Instant expire pCs=$%p pT=%p", pCs, pCs->pTunnel ) );
    }
    else
    {
        ulSendTimeoutMs = pCs->pTunnel->ulSendTimeoutMs;
    }

    // Schedule a retransmit of the packet, should it go unacknowledged.  This
    // occurs here rather than in SendPending to remove any chance of having
    // the same MDL chain outstanding in two separate calls to the IP stack.
    //
    // Note: The logical code commented out below can be omitted for
    // efficiency because the ReferenceControlSent for this scheduled timer
    // and the DereferenceControlSent for this completed send cancel each
    // other out.
    //
    // ReferenceControlSent( pCs );
    // DereferenceControlSent( pCs );
    //
    ASSERT( pCs->pTqiSendTimeout );
    TimerQScheduleItem(
        pCs->pTunnel->pTimerQ,
        pCs->pTqiSendTimeout,
        ulSendTimeoutMs,
        SendControlTimerEvent,
        pCs );
}


VOID
SendControlTimerEvent(
    IN TIMERQITEM* pItem,
    IN VOID* pContext,
    IN TIMERQEVENT event )

    // PTIMERQEVENT handler set to expire when it's time to give up on
    // receiving an acknowledge to the sent control packet indicated by
    // 'pContext'.
    //
{
    NDIS_STATUS status;
    ADAPTERCB* pAdapter;
    TUNNELCB* pTunnel;
    CONTROLSENT* pCs;

    TRACE( TL_N, TM_Send,
        ( "SendControlTimerEvent(%s)", TimerQPszFromEvent( event ) ) );

    // Unpack context information.  The timer item is owned by the "control
    // sent" context and freed indirectly by dereferencing below.
    //
    pCs = (CONTROLSENT* )pContext;
    pTunnel = pCs->pTunnel;
    pAdapter = pTunnel->pAdapter;

    if (event == TE_Expire)
    {
        // Timer expired, meaning it's time to give up on ever receiving an
        // acknowledge to the sent packet.  Per the draft/RFC, adjustments to
        // the send window and send timeouts are necessary.
        //
        NdisAcquireSpinLock( &pTunnel->lockT );
        do
        {
            if (pCs->linkSendsOut.Flink == &pCs->linkSendsOut)
            {
                // The context is not on the out queue, so it must have been
                // cancelled or terminated while the expire handling was being
                // set up.  Do nothing.
                //
                TRACE( TL_I, TM_Send,
                    ( "T%d: Timeout aborted", (ULONG )pTunnel->usTunnelId ) );
                break;
            }

            AdjustTimeoutsAndSendWindowAtTimeout(
                pAdapter->ulMaxSendTimeoutMs,
                pTunnel->lDeviationMs,
                &pTunnel->ulSendTimeoutMs,
                &pTunnel->ulRoundTripMs,
                &pTunnel->ulSendWindow,
                &pTunnel->ulAcksSinceSendTimeout );

            --pTunnel->ulSendsOut;
            ++pCs->ulRetransmits;

            TRACE( TL_I, TM_Send,
                ( "Tid %d: TIMEOUT(%d) -sout=%d +retry=%d rtt=%d ato=%d sw=%d",
                (ULONG )pTunnel->usTunnelId, (ULONG )pCs->usNs,
                pTunnel->ulSendsOut, pCs->ulRetransmits,
                pTunnel->ulRoundTripMs, pTunnel->ulSendTimeoutMs,
                pTunnel->ulSendWindow ) );
                
            WPLOG( LL_M, LM_Send,
                ( "Tid %d: TIMEOUT(%d) -sout=%d +retry=%d rtt=%d ato=%d sw=%d",
                (ULONG )pTunnel->usTunnelId, (ULONG )pCs->usNs,
                pTunnel->ulSendsOut, pCs->ulRetransmits,
                pTunnel->ulRoundTripMs, pTunnel->ulSendTimeoutMs,
                pTunnel->ulSendWindow ) );

            // Retransmit the packet, or close the tunnel if retries are
            // exhausted.
            //
            if (pCs->ulRetransmits > pAdapter->ulMaxRetransmits)
            {
                // Retries are exhausted.  Give up and close the tunnel.  No
                // point in trying to be graceful since peer is not
                // responding.
                //
                SetFlags( &pTunnel->ulFlags, TCBF_PeerNotResponding );

                RemoveEntryList( &pCs->linkSendsOut );
                InitializeListHead( &pCs->linkSendsOut );
                DereferenceControlSent( pCs );

                ScheduleTunnelWork(
                    pTunnel, NULL, CloseTunnel,
                    0, 0, 0, 0, FALSE, FALSE );
            }
            else
            {
                // Retries remaining.  Mark the packet as pending
                // retransmission, then see if the send window allows the
                // retransmit to go now.
                //
                pCs->ulFlags |= CSF_Pending;
                ScheduleTunnelWork(
                    pTunnel, NULL, SendPending,
                    0, 0, 0, 0, FALSE, FALSE );
            }
        }
        while (FALSE);
        NdisReleaseSpinLock( &pTunnel->lockT );
    }

    // Remove the reference covering the scheduled timer.
    //
    DereferenceControlSent( pCs );
}


VOID
SendHeaderComplete(
    IN TDIXCONTEXT* pTdix,
    IN VOID* pContext1,
    IN VOID* pContext2,
    IN CHAR* pBuffer )

    // PTDIXSENDCOMPLETE handler for sends that send only a single buffer from
    // the 'ADAPTERCB.poolHeaderBuffers' pool.
    //
{
    ADAPTERCB* pAdapter;
    VCCB* pVc;
    NDIS_BUFFER* pNdisBuffer;

    TRACE( TL_V, TM_Send, ( "SendHeaderComp" ) );

    pAdapter = (ADAPTERCB* )pContext1;
    pVc = (VCCB* )pContext2;

    // Undo the adjustments made before the send the buffer is ready for
    // re-use.
    //
    pNdisBuffer = NdisBufferFromBuffer( pBuffer );
    NdisAdjustBufferLength( pNdisBuffer, BufferSizeFromBuffer( pBuffer ) );
    FreeBufferToPool( &pAdapter->poolHeaderBuffers, pBuffer, TRUE );

    if (pVc)
    {
        DereferenceCall( pVc );
    }
}


VOID
SendPayloadSeqComplete(
    IN TDIXCONTEXT* pTdix,
    IN VOID* pContext1,
    IN VOID* pContext2,
    IN CHAR* pBuffer )

    // PTDIXSENDCOMPLETE handler for sequenced payloads.
    //
{
    PAYLOADSENT* pPs;

    TRACE( TL_V, TM_Send, ( "SendPayloadSeqComp" ) );

    pPs = (PAYLOADSENT* )pContext1;
    pPs->pIrp = NULL;
    DereferencePayloadSent( pPs );
}


VOID
SendPayloadUnseqComplete(
    IN TDIXCONTEXT* pTdix,
    IN VOID* pContext1,
    IN VOID* pContext2,
    IN CHAR* pBuffer )

    // PTDIXSENDCOMPLETE handler for unsequenced payloads.
    //
{
    ADAPTERCB* pAdapter;
    VCCB* pVc;
    NDIS_PACKET* pPacket;
    NDIS_BUFFER* pNdisBuffer;

    TRACE( TL_V, TM_Send, ( "SendPayloadUnseqComp" ) );

    pVc = (VCCB* )pContext1;
    pPacket = (NDIS_PACKET* )pContext2;
    pAdapter = pVc->pAdapter;

    // Undo the adjustments made before the send so the owner of each
    // component resource gets back what they originally provided for clean-up
    // and recycling.
    //
    NdisUnchainBufferAtFront( pPacket, &pNdisBuffer );
    NdisAdjustBufferLength( pNdisBuffer, BufferSizeFromBuffer( pBuffer ) );
    FreeBufferToPool( &pAdapter->poolHeaderBuffers, pBuffer, TRUE );

    // Notify sending driver of the result.  Without sequencing, just trying
    // to send it is enough to claim success.
    //
    NDIS_SET_PACKET_STATUS( pPacket, NDIS_STATUS_SUCCESS );
    TRACE( TL_N, TM_Send, ("NdisMCoSendComp($%x)", NDIS_STATUS_SUCCESS ) );
    NdisMCoSendComplete( NDIS_STATUS_SUCCESS, pVc->NdisVcHandle, pPacket );
    TRACE( TL_N, TM_Send, ("NdisMCoSendComp done" ) );

    DereferenceCall( pVc );
}


VOID
SendPayloadTimerEvent(
    IN TIMERQITEM* pItem,
    IN VOID* pContext,
    IN TIMERQEVENT event )

    // PTIMERQEVENT handler set to expire when it's time to give up on
    // receiving an acknowledge to the sent payload packet indicated in the
    // PAYLOADSENT* 'pContext'.
    //
{
    PAYLOADSENT* pPs;
    ADAPTERCB* pAdapter;
    TUNNELCB* pTunnel;
    VCCB* pVc;

    TRACE( TL_N, TM_Send,
        ( "SendPayloadTimerEvent(%s)", TimerQPszFromEvent( event ) ) );

    // Unpack context information.  The timer item is owned by the "payload
    // sent" context and freed indirectly by the de-referencing of that
    // context below.
    //
    pPs = (PAYLOADSENT* )pContext;
    pVc = pPs->pVc;
    pTunnel = pPs->pTunnel;
    pAdapter = pVc->pAdapter;

    if (event == TE_Expire)
    {
        LONG lOldSendWindow;
        LONG lSwChange;
        BOOLEAN fCallActive;
        LINKSTATUSINFO info;

        // Timer expired, meaning it's time to give up on ever receiving an
        // acknowledge to the sent packet.
        //
        NdisAcquireSpinLock( &pVc->lockV );
        do
        {
            if (pPs->linkSendsOut.Flink == &pPs->linkSendsOut)
            {
                // The context is not on the "outstanding send" list, so it
                // must have been cancelled or terminated while the expire
                // handling was being set up.  Do nothing.
                //
                TRACE( TL_I, TM_Send,
                    ( "C%d: Timeout aborted", (ULONG )pVc->usCallId ) );
                fCallActive = FALSE;
                break;
            }

            // This packet was not acknowledged.
            //
            pPs->status = NDIS_STATUS_FAILURE;

            // Remove the context from the "outstanding send" list.  The
            // corresponding dereference occurs below.
            //
            RemoveEntryList( &pPs->linkSendsOut );
            InitializeListHead( &pPs->linkSendsOut );

            // The rest has to do with call related fields so get a reference
            // now.  This is removed by the "reset" send completion.
            //
            fCallActive = ReferenceCall( pVc );
            if (fCallActive)
            {
                // Per the draft/RFC, adjustments to the send window and send
                // timeouts are necessary when a send times out.
                //
                lOldSendWindow = (LONG )pVc->ulSendWindow;
                AdjustTimeoutsAndSendWindowAtTimeout(
                    pAdapter->ulMaxSendTimeoutMs,
                    pVc->lDeviationMs,
                    &pVc->ulSendTimeoutMs,
                    &pVc->ulRoundTripMs,
                    &pVc->ulSendWindow,
                    &pVc->ulAcksSinceSendTimeout );
                lSwChange = ((LONG )pVc->ulSendWindow) - lOldSendWindow;

                TRACE( TL_I, TM_Send,
                    ( "C%d: TIMEOUT(%d) new rtt=%d ato=%d sw=%d(%+d)",
                    (ULONG )pVc->usCallId, (ULONG )pPs->usNs,
                    pVc->ulRoundTripMs, pVc->ulSendTimeoutMs,
                    pVc->ulSendWindow, lSwChange ) );

                if (lSwChange != 0)
                {
                    // The send window changed, i.e. it closed some because of
                    // the timeout.  Update the statistics accordingly.
                    //
                    ++pVc->stats.ulSendWindowChanges;

                    if (pVc->ulSendWindow > pVc->stats.ulMaxSendWindow)
                    {
                        pVc->stats.ulMaxSendWindow = pVc->ulSendWindow;
                    }
                    else if (pVc->ulSendWindow < pVc->stats.ulMinSendWindow)
                    {
                        pVc->stats.ulMinSendWindow = pVc->ulSendWindow;
                    }

                    // Need to release the lock before indicating the link
                    // status change outside our driver, so make a "safe" copy
                    // of the link status information.
                    //
                    TransferLinkStatusInfo( pVc, &info );
                }

                // Send a zero length payload with the R-bit set to reset the
                // peer's Nr to the packet after this one.  The call reference
                // will be removed when the send completes.
                //
                ScheduleTunnelWork(
                    pTunnel, pVc, SendPayloadReset,
                    (ULONG_PTR )(pPs->usNs + 1), 0, 0, 0, FALSE, FALSE );

                ++pVc->stats.ulSentResets;
                ++pVc->stats.ulSentPacketsTimedOut;
            }

            // Remove the reference for linkage in the "outstanding send"
            // list.
            //
            DereferencePayloadSent( pPs );

        }
        while (FALSE);
        NdisReleaseSpinLock( &pVc->lockV );

        if (fCallActive && lSwChange != 0)
        {
            // Inform NDISWAN of the new send window since it's the component
            // that actually does the throttling.
            //
            IndicateLinkStatus( pVc, &info );
        }
    }

    // Remove the reference covering the scheduled timer event.
    //
    DereferencePayloadSent( pPs );
}


VOID
SendZlb(
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN USHORT usNs,
    IN USHORT usNr,
    IN BOOLEAN fReset )

    // Send a data-less packet with sequence 'usNs' and 'usNr' on 'pTunnel'.
    // 'PVc' is the associated VC, or NULL if none.  When 'pVc' is provided,
    // 'fReset' may be set to indicate a payload reset is to be built,
    // otherwise a simple acknowledge is built.
    //
    // This routine is called only at PASSIVE IRQL.
    //
    // IMPORTANT: Caller must take a call reference before calling that is
    //            removed by the send completion handler.
    //
{
    NDIS_STATUS status;
    ADAPTERCB* pAdapter;
    CHAR* pBuffer;
    CHAR* pCurrBuffer;
    ULONG ulLength;
    USHORT usAssignedCallId;
    BOOLEAN fControl, fIpUdpHeaders;
    NDIS_BUFFER* pNdisBuffer;

    pAdapter = pTunnel->pAdapter;

    usAssignedCallId = (pVc) ? pVc->usAssignedCallId : 0;
    fControl = (usAssignedCallId == 0);
    ASSERT( !(fReset && fControl) );

    if (!fControl && !(ReadFlags( &pTunnel->ulFlags ) & TCBF_HostRouteAdded))
    {
        TRACE( TL_A, TM_Send, ( "SendZlb w/o host route?" ) );
        WPLOG( LL_A, LM_Send, ( "SendZlb w/o host route?" ) );
        ++g_ulSendZlbWithoutHostRoute;
        if (pVc)
        {
            DereferenceCall( pVc );
        }
        return;
    }

    // Get an NDIS_BUFFER to hold the L2TP header.
    //
    pBuffer = GetBufferFromPool( &pAdapter->poolHeaderBuffers );
    if (!pBuffer)
    {
        WPLOG( LL_A, LM_Res, ( "Failed to allocate buffer"));
        if (pVc)
        {
            DereferenceCall( pVc );
        }
        return;
    }
    
    if ((ReadFlags(&pTunnel->ulFlags) & (TCBF_SendConnected | TCBF_LocalAddrSet)) == 
        TCBF_LocalAddrSet) {      
        pCurrBuffer = pBuffer + sizeof(IPHeader) + sizeof(UDPHeader);
        fIpUdpHeaders = TRUE;
    }
    else
    {
        pCurrBuffer = pBuffer;
        fIpUdpHeaders = FALSE;
    }

    // Fill in 'pBuffer' with the L2TP header.
    //
    ulLength =
        BuildL2tpHeader(
            pCurrBuffer,
            fControl,
            fReset,
            &pTunnel->usAssignedTunnelId,
            &usAssignedCallId,
            &usNs,
            usNr );
            
    // Build IP & UDP headers if necessary
    if(fIpUdpHeaders)
    {
        ulLength = BuildIpUdpHeaders(pTunnel, pBuffer, ulLength);
    }

    // Pare down the buffer to the actual length used.
    //
    pNdisBuffer = NdisBufferFromBuffer( pBuffer );
    NdisAdjustBufferLength( pNdisBuffer, (UINT )ulLength );

    // Call TDI to send the bare L2TP header.
    //
    TRACE( TL_A, TM_Msg,
        ( "%sSEND ZLB(Nr=%d) CID=%d R=%d",
        (g_ulTraceLevel <= TL_I) ? "" : "\nL2TP: ",
        (ULONG )usNr, (ULONG )usAssignedCallId, (ULONG )fReset ) );
    DUMPW( TL_A, TM_MDmp, pBuffer, ulLength );

    {
        PTDIX_SEND_HANDLER SendFunc;
        FILE_OBJECT* FileObj;

        if(fIpUdpHeaders)
        {
            FileObj = pAdapter->tdix.pRawAddress;
            SendFunc = TdixSendDatagram;
        }
        else if (ReadFlags(&pTunnel->ulFlags) & TCBF_SendConnected) {

            ASSERT(pTunnel->pRoute != NULL);

            SendFunc = TdixSend;

            if (fControl)
            {
                FileObj = 
                    CtrlObjFromUdpContext(&pTunnel->udpContext);
            }
            else
            {
                FileObj = 
                    PayloadObjFromUdpContext(&pTunnel->udpContext);
            }

        } else {
            FileObj = pAdapter->tdix.pAddress;
            SendFunc = TdixSendDatagram;
        }

        status = 
            SendFunc(
                &pAdapter->tdix,
                FileObj,
                SendHeaderComplete,
                pAdapter,
                pVc,
                &pTunnel->address.ulIpAddress,
                pBuffer,
                ulLength,
                NULL );
    }

    ASSERT( status == NDIS_STATUS_PENDING );
}


VOID
UpdateControlHeaderNr(
    IN CHAR* pBuffer,
    IN USHORT usNr )

    // Updates the 'Next Receive' field of control message buffer 'pBuffer'
    // with the value 'usNr'.
    //
{
    USHORT* pusNr;

    // Fortunately, the control header up to 'Next Receive' is fixed so a
    // simple offset calculation can be used.
    //
    pusNr = ((USHORT* )pBuffer) + 5;
    *pusNr = htons( usNr );
}


VOID
UpdateHeaderLength(
    IN CHAR* pBuffer,
    IN USHORT usLength )

    // Updates the 'Length' field of the L2TP message buffer 'pBuffer' to the
    // value 'usLength'.
    //
{
    USHORT* pusLength;

    // Fortunately, the control header up to 'Length' is fixed so a simple
    // offset calculation can be used.
    //
    pusLength = ((USHORT* )pBuffer) + 1;
    *pusLength = htons( usLength );
}


// ** xsum - Checksum a flat buffer.
//
//  This is the lowest level checksum routine. It returns the uncomplemented
//  checksum of a flat buffer.
//
//  Entry:  Buffer      - Buffer to be checksummed.
//          Size        - Size in bytes of Buffer.
//          InitialValue - Value of previous Xsum to add this Xsum to.
//  
//  Returns: The uncomplemented checksum of buffer.
//
USHORT
xsumComp(void *Buffer, int Size,  USHORT InitialValue)
{
    USHORT  UNALIGNED *Buffer1 = (USHORT UNALIGNED *)Buffer; // Buffer expressed as shorts.
    ULONG   csum = InitialValue;

    USHORT tmp;
    UCHAR tmp2[2];

    while (Size > 1) {

    tmp=*Buffer1;
    Buffer1++;
    //csum += *Buffer1++;
    csum +=htons(tmp);
    Size -= sizeof(USHORT);
    }

    if (Size) {
        tmp2[0]=*(UCHAR *)Buffer1;              // For odd buffers, add in last byte.
        tmp2[1]=0;
        tmp=*(USHORT*)tmp2;
    csum += htons(tmp);
    }

    csum = (csum >> 16) + (csum & 0xffff);
    csum += (csum >> 16);
    return (USHORT)csum;
}


ULONG BuildIpUdpHeaders(
    IN TUNNELCB* pTunnel,
    IN OUT CHAR* pBuffer,
    IN ULONG ulLength)
{
    IPHeader *IPH = (IPHeader *) pBuffer;
    UDPHeader *UDPH = (UDPHeader *) (pBuffer + sizeof(IPHeader));
    
    IPH->iph_verlen = IP_VERSION + (sizeof(IPHeader) >> 2);
    IPH->iph_tos=0;
    IPH->iph_length=htons((USHORT)ulLength + sizeof(IPHeader) + sizeof(UDPHeader));
    IPH->iph_id=0;          // filled by TCPIP
    IPH->iph_offset=0;
    IPH->iph_ttl=128;
    IPH->iph_protocol=17;
    IPH->iph_xsum = 0;      // filled by TCPIP
    IPH->iph_src = pTunnel->localaddress.ulIpAddress;
    IPH->iph_dest = pTunnel->address.ulIpAddress;
    
    UDPH->uh_src = pTunnel->localaddress.sUdpPort;
    UDPH->uh_dest = pTunnel->address.sUdpPort;
    UDPH->uh_length = htons((USHORT)ulLength + sizeof(UDPHeader));
    UDPH->uh_xsum = 0;
    
    // Fill in fields of UDP Header.  Calculate XSum over pseudoheader and UDP header.
    {
        USHORT pseudoHeaderXSum;
        UCHAR pshTmp[4];
        USHORT udpXSum;
    
        // Compute UDP pseudo header checksum
        pseudoHeaderXSum=xsumComp(&IPH->iph_src, 8, 0);
        pshTmp[0] = 0;
        pshTmp[1] = IPH->iph_protocol;
        NdisMoveMemory((void *)&pshTmp[2], (void *)&UDPH->uh_length, 2);
        
        pseudoHeaderXSum = xsumComp(pshTmp, 4, pseudoHeaderXSum);
    
        // Compute UDP header checksum
        udpXSum=xsumComp(UDPH, 8, pseudoHeaderXSum);
    
        // Compute UDP data checksum
        udpXSum = xsumComp(pBuffer + sizeof(IPHeader) + sizeof(UDPHeader), (int)ulLength, udpXSum);
        
        UDPH->uh_xsum = htons(~udpXSum);
    }

    ulLength += IpFixedHeaderSize + UDP_HEADER_SIZE;
    return ulLength;                         
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ndis\rasl2tp\util.c ===
// Copyright (c) 1997, Microsoft Corporation, all rights reserved
//
// util.c
// RAS L2TP WAN mini-port/call-manager driver
// General utility routines
//
// 01/07/97 Steve Cobb


#include "l2tpp.h"

#include "util.tmh"

// Debug counts of oddities that should not be happening.
//
ULONG g_ulAllocTwFailures = 0;


//-----------------------------------------------------------------------------
// Local prototypes (alphabetically)
//-----------------------------------------------------------------------------

ULONG
atoul(
    IN CHAR* pszNumber );

VOID
ReversePsz(
    IN OUT CHAR* psz );

VOID
TunnelWork(
    IN NDIS_WORK_ITEM* pWork,
    IN VOID* pContext );

VOID
ultoa(
    IN ULONG ul,
    OUT CHAR* pszBuf );


//-----------------------------------------------------------------------------
// General utility routines (alphabetically)
//-----------------------------------------------------------------------------

#if 0
ULONGLONG g_llLastTime2 = 0;
ULONGLONG g_llLastTime1 = 0;
ULONGLONG g_llLastTime = 0;
NDIS_SPIN_LOCK g_lockX;

VOID
XNdisGetCurrentSystemTime(
    IN LARGE_INTEGER* plrgTime )
{
    static BOOLEAN f = 0;

    if (!f)
    {
        NdisAllocateSpinLock( &g_lockX );
        f = 1;
    }

    NdisGetCurrentSystemTime( plrgTime );

    NdisAcquireSpinLock( &g_lockX );
    {
        LONGLONG ll;

        g_llLastTime2 = g_llLastTime1;
        g_llLastTime1 = g_llLastTime;
        g_llLastTime = plrgTime->QuadPart;
        ll = g_llLastTime - g_llLastTime1;
        TRACE( TL_I, TM_Spec, ( "Time delta=%d", *((LONG* )&ll) ) );
        ASSERT( g_llLastTime >= g_llLastTime1 );
    }
    NdisReleaseSpinLock( &g_lockX );
}
#endif


VOID
AddHostRoute(
    IN TUNNELWORK* pWork,
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN ULONG_PTR* punpArgs )

    // A PTUNNELWORK routine to change an existing host route.
    //
    // This routine is called only at PASSIVE IRQL.
    //
{
    ADAPTERCB*  pAdapter;

    TRACE( TL_N, TM_Misc, ( "AddHostRoute" ) );

    // Unpack context information then free the work item.
    //
    pAdapter = pTunnel->pAdapter;
    FREE_TUNNELWORK( pAdapter, pWork );

    // Add the host route, noting success for clean-up later, or closing the
    // tunnel on failure.
    //
    pTunnel->pRoute = 
        TdixAddHostRoute( 
            &pAdapter->tdix, 
            pTunnel->address.ulIpAddress,
            pTunnel->localaddress.ifindex);

    if (pTunnel->pRoute != NULL)
    {
        NDIS_STATUS status;
        
        // Setup the connection to do connected udp
        // if required
        //
        
        pTunnel->pRoute->sPort = pTunnel->address.sUdpPort;
        
        status = TdixSetupConnection(
                    &pAdapter->tdix, 
                    pTunnel->pRoute,
                    pTunnel->localaddress.ulIpAddress,
                    &pTunnel->udpContext);

        if(status != STATUS_SUCCESS)
        {
            TdixDestroyConnection(&pTunnel->udpContext);
            TdixDeleteHostRoute(&pAdapter->tdix, 
                pTunnel->address.ulIpAddress);

            pTunnel->pRoute = NULL;
            
            ScheduleTunnelWork(
                pTunnel, NULL, FsmCloseTunnel,
                (ULONG_PTR )TRESULT_GeneralWithError,
                (ULONG_PTR )GERR_NoResources,
                0, 0, FALSE, FALSE );
        }

        SetFlags( &pTunnel->ulFlags, TCBF_HostRouteAdded );

        if (pTunnel->udpContext.hCtrlAddr != NULL) {
            SetFlags (&pTunnel->ulFlags, TCBF_SendConnected);
        }
    }
    else
    {
        ScheduleTunnelWork(
            pTunnel, NULL, FsmCloseTunnel,
            (ULONG_PTR )TRESULT_GeneralWithError,
            (ULONG_PTR )GERR_NoResources,
            0, 0, FALSE, FALSE );
    }
}


BOOLEAN
AdjustSendWindowAtAckReceived(
    IN ULONG ulMaxSendWindow,
    IN OUT ULONG* pulAcksSinceSendTimeout,
    IN OUT ULONG* pulSendWindow )

    // Adjust send window/factors for the acknowledge just received.
    //
    // Returns true if the send window was changed, false if not.
    //
{
    // Update the "ack streak" counter and, if a full windows worth has been
    // received since timing out, bump up the send window.
    //
    ++(*pulAcksSinceSendTimeout);
    if (*pulAcksSinceSendTimeout >= *pulSendWindow
        && *pulSendWindow < ulMaxSendWindow)
    {
        TRACE( TL_N, TM_Send,
            ( "SW open to %d, %d acks",
            (*pulSendWindow), *pulAcksSinceSendTimeout ) );

        *pulAcksSinceSendTimeout = 0;
        ++(*pulSendWindow);
        return TRUE;
    }

    return FALSE;
}


VOID
AdjustTimeoutsAtAckReceived(
    IN LONGLONG llSendTime,
    IN ULONG ulMaxSendTimeoutMs,
    OUT ULONG* pulSendTimeoutMs,
    IN OUT ULONG* pulRoundTripMs,
    IN OUT LONG* plDeviationMs )

    // Adjust send timeout/factors for the acknowledge just received.
    //
{
    LARGE_INTEGER lrgTime;
    LONGLONG llSampleMs;
    ULONG ulSampleMs;
    LONG lDiff;
    LONG lDif8;
    LONG lAbsDif8;
    LONG lDev8;
    ULONG ulAto;

    // First, calculate the "sample", i.e. the time that was actually required
    // for the round trip.
    //
    NdisGetCurrentSystemTime( &lrgTime );
    if (llSendTime > lrgTime.QuadPart)
    {
        // This shouldn't happen but once it appeared that it did, so this
        // defensive conditional is included.  Maybe NdisGetCurrentSystemTime
        // has a bug?
        //
        TRACE( TL_A, TM_Misc, ( "Future send time?" ) );
        llSendTime = lrgTime.QuadPart;
    }

    llSampleMs = (lrgTime.QuadPart - llSendTime) / 10000;
    ASSERT( ((LARGE_INTEGER* )(&llSampleMs))->HighPart == 0 );
    ulSampleMs = (ULONG )(((LARGE_INTEGER* )(&llSampleMs))->LowPart);

    // The typical 'alpha' of 1/8, 'beta' of 1/4, and 'chi' of 4 are used, per
    // the suggestion in the draft/RFC.  To eliminate multiplication and
    // division, the factors are scaled by 8, calculated, and scaled back.
    //
    // Find the intermediate DIFF value, representing the difference between
    // the estimated and actual round trip times, and the scaled and absolute
    // scaled values of same.
    //
    lDiff = (LONG )ulSampleMs - (LONG )(*pulRoundTripMs);
    lDif8 = lDiff << 3;
    lAbsDif8 = (lDif8 < 0) ? -lDif8 : lDif8;

    // Calculate the scaled new DEV value, representing the approximate
    // standard deviation.
    //
    lDev8 = *plDeviationMs << 3;
    lDev8 = lDev8 + ((lAbsDif8 - lDev8) << 1);
    *plDeviationMs = lDev8 >> 3;

    // Find the scaled new RTT value, representing the estimated round trip
    // time.  The draft/RFC shows the calculation "old RTT + diff", but that's
    // just the "sample" we found earlier, i.e. the actual round trip time of
    // this packet.
    //
    *pulRoundTripMs = ulSampleMs;

    // Calculate the ATO value, representing the new send timeout.  Because of
    // clock granularity the timeout might come out 0, which is converted to
    // the more reasonable 1.
    //
    ulAto = (ULONG )(((LONG )*pulRoundTripMs) + (*plDeviationMs << 2));
    if (ulAto == 0)
    {
        ulAto = 1;
    }
    *pulSendTimeoutMs = min( ulAto, ulMaxSendTimeoutMs );
}


VOID
AdjustTimeoutsAndSendWindowAtTimeout(
    IN ULONG ulMaxSendTimeoutMs,
    IN LONG lDeviationMs,
    OUT ULONG* pulSendTimeoutMs,
    IN OUT ULONG* pulRoundTripMs,
    IN OUT ULONG* pulSendWindow,
    OUT ULONG* pulAcksSinceSendTimeout )

    // Adjust send timeout/factors and send window for the timeout that just
    // occurred.
    //
    // Returns true if the send window was changed, false if not.
    //
{
    ULONG ulNew;

    // Using the suggested 'delta' of 2, the round trip estimate is doubled.
    //
    *pulRoundTripMs <<= 1;

    // Using the typical 'chi' of 4, the send timeout is increased.  Because
    // of clock granularity the timeout might come out 0, which is converted
    // to the more reasonable 1.
    //
    ulNew = (ULONG )(((LONG )*pulRoundTripMs) + (lDeviationMs << 2));
    *pulSendTimeoutMs = min( ulNew, ulMaxSendTimeoutMs );
    if (*pulSendTimeoutMs == 0)
    {
        *pulSendTimeoutMs = 1;
    }

    // The send window is halved.
    //
    ulNew = *pulSendWindow >> 1;
    *pulSendWindow = max( ulNew, 1 );

    // Consecutive acknowledge counter is reset.
    //
    *pulAcksSinceSendTimeout = 0;
}

VOID
CalculateResponse(
    IN UCHAR* puchChallenge,
    IN ULONG ulChallengeLength,
    IN CHAR* pszPassword,
    IN UCHAR uchId,
    OUT UCHAR* puchResponse )

    // Loads caller's 16-byte challenge response buffer, 'puchResponse', with
    // the CHAP-style MD5ed response based on packet ID 'uchId', the
    // 'ulChallengeLength' byte challenge 'puchChallenge', and the null
    // terminated password 'pszPassword'.
    //
{
    ULONG ul;
    MD5_CTX md5ctx;

    MD5Init( &md5ctx );
    MD5Update( &md5ctx, &uchId, 1 );
    MD5Update( &md5ctx, pszPassword, strlen( pszPassword ) );
    MD5Update( &md5ctx, puchChallenge, ulChallengeLength );
    MD5Final( &md5ctx );

    NdisMoveMemory( puchResponse, md5ctx.digest, 16 );
}


VOID
ChangeHostRoute(
    IN TUNNELWORK* pWork,
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN ULONG_PTR* punpArgs )

    // A PTUNNELWORK routine to change an existing host route.  Arg0 is the IP
    // address of the existing host route to be deleted.  Arg1 is the IP
    // address of the host route to add.
    //
    // This routine is called only at PASSIVE IRQL.
    //
{
    ADAPTERCB* pAdapter;
    ULONG ulOldIpAddress;
    ULONG ulNewIpAddress;

    TRACE( TL_N, TM_Misc, ( "ChangeHostRoute" ) );

    // Unpack context information then free the work item.
    //
    pAdapter = pTunnel->pAdapter;
    ulOldIpAddress = (ULONG )(punpArgs[ 0 ]);
    ulNewIpAddress = (ULONG )(punpArgs[ 1 ]);
    FREE_TUNNELWORK( pAdapter, pWork );

    // Add the new host route, then delete the old one.
    //
    if (TdixAddHostRoute( 
        &pAdapter->tdix, 
        ulNewIpAddress, 
        pTunnel->localaddress.ifindex))
    {
        ClearFlags( &pTunnel->ulFlags, TCBF_HostRouteAdded );
        TdixDestroyConnection(&pTunnel->udpContext);
        TdixDeleteHostRoute( &pAdapter->tdix, ulOldIpAddress);
    }
    else
    {
        ScheduleTunnelWork(
            pTunnel, NULL, CloseTunnel,
            0, 0, 0, 0, FALSE, FALSE );
    }
}


VOID
ClearFlags(
    IN OUT ULONG* pulFlags,
    IN ULONG ulMask )

    // Set 'ulMask' bits in '*pulFlags' flags as an interlocked operation.
    //
{
    ULONG ulFlags;
    ULONG ulNewFlags;

    do
    {
        ulFlags = ReadFlags( pulFlags );
        ulNewFlags = ulFlags & ~(ulMask);
    }
    while (InterlockedCompareExchange(
               pulFlags, ulNewFlags, ulFlags ) != (LONG )ulFlags);
}


VOID
CloseTdix(
    IN TUNNELWORK* pWork,
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN ULONG_PTR* punpArgs )

    // A PTUNNELWORK routine to close the TDIX context associated with a
    // tunnel.
    //
    // This routine is called only at PASSIVE IRQL.
    //
{
    ADAPTERCB* pAdapter;

    TRACE( TL_N, TM_Misc, ( "CloseTdix" ) );

    // Unpack context information then free the work item.
    //
    pAdapter = pTunnel->pAdapter;
    FREE_TUNNELWORK( pAdapter, pWork );

    // Delete the old host route, and note same in tunnel flags.
    //
    TdixClose( &pAdapter->tdix );
    ClearFlags( &pTunnel->ulFlags, TCBF_TdixReferenced );
}


VOID
DeleteHostRoute(
    IN TUNNELWORK* pWork,
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN ULONG_PTR* pulArgs )

    // A PTUNNELWORK routine to change an existing host route.
    //
    // This routine is called only at PASSIVE IRQL.
    //
{
    ADAPTERCB* pAdapter;

    TRACE( TL_N, TM_Misc, ( "DeleteHostRoute" ) );

    // Unpack context information then free the work item.
    //
    pAdapter = pTunnel->pAdapter;
    FREE_TUNNELWORK( pAdapter, pWork );

    // Destroy the connected udp context
    //
    TdixDestroyConnection(&pTunnel->udpContext);

    // Delete the old host route, and note same in tunnel flags.
    //
    TdixDeleteHostRoute( &pAdapter->tdix, 
                    pTunnel->address.ulIpAddress);
    ClearFlags( &pTunnel->ulFlags, TCBF_HostRouteAdded );
}


VOID
DottedFromIpAddress(
    IN ULONG ulIpAddress,
    OUT CHAR* pszIpAddress,
    IN BOOLEAN fUnicode )

    // Converts network byte-ordered IP addresss 'ulIpAddress' to a string in
    // the a.b.c.d form and returns same in caller's 'pszIpAddress' buffer.
    // The buffer should be at least 16 characters long.  If 'fUnicode' is set
    // the returned 'pszIpAddress' is in Unicode and must be at least 16 wide
    // characters long.
    //
{
    CHAR szBuf[ 3 + 1 ];

    ULONG ulA = (ulIpAddress & 0x000000FF);
    ULONG ulB = (ulIpAddress & 0x0000FF00) >> 8;
    ULONG ulC = (ulIpAddress & 0x00FF0000) >> 16;
    ULONG ulD = (ulIpAddress & 0xFF000000) >> 24;

    ultoa( ulA, szBuf );
    strcpy( pszIpAddress, szBuf );
    strcat( pszIpAddress, "." );
    ultoa( ulB, szBuf );
    strcat( pszIpAddress, szBuf );
    strcat( pszIpAddress, "." );
    ultoa( ulC, szBuf );
    strcat( pszIpAddress, szBuf );
    strcat( pszIpAddress, "." );
    ultoa( ulD, szBuf );
    strcat( pszIpAddress, szBuf );

    if (fUnicode)
    {
        WCHAR* psz;

        psz = StrDupAsciiToUnicode( pszIpAddress, strlen( pszIpAddress ) );
        if (psz)
        {
            NdisMoveMemory(
                pszIpAddress, psz, (StrLenW( psz ) + 1) * sizeof(WCHAR) );
            FREE_NONPAGED( psz );
        }
        else
        {
            *((WCHAR*)pszIpAddress) = L'\0';
        }
    }
}


#if 0
NDIS_STATUS
ExecuteWork(
    IN ADAPTERCB* pAdapter,
    IN NDIS_PROC pProc,
    IN PVOID pContext,
    IN ULONG ulArg1,
    IN ULONG ulArg2,
    IN ULONG ulArg3,
    IN ULONG ulArg4 )

    // This provides a way to call a routine designed to be called by the
    // ScheduleWork utility when caller is already at passive IRQL.  The
    // 'pProc' routine is executed inline instead of scheduled.  The context
    // 'pContext' is passed to 'pProc' The extra context arguments 'ulArg1'
    // and 'ulArg2' are stashed in extra space allocated on the end of the
    // NDIS_WORK_ITEM.  'PAdapter' is the adapter control block from which the
    // work item is allocated.
    //
    // Returns NDIS_STATUS_SUCCESS or an error code.
    //
{
    NDIS_STATUS status;
    NDIS_WORK_ITEM* pWork;

    // TDI setup must be done at PASSIVE IRQL so schedule a routine to do it.
    //
    pWork = ALLOC_NDIS_WORK_ITEM( pAdapter );
    if (!pWork)
    {
        return NDIS_STATUS_RESOURCES;
    }

    ((ULONG*)(pWork + 1))[ 0 ] = ulArg1;
    ((ULONG*)(pWork + 1))[ 1 ] = ulArg2;
    ((ULONG*)(pWork + 1))[ 2 ] = ulArg3;
    ((ULONG*)(pWork + 1))[ 3 ] = ulArg4;

    pProc( pWork, pContext );
}
#endif


USHORT
GetNextTerminationCallId(
    IN ADAPTERCB* pAdapter )

    // Returns the next unused termination Call-ID.  Termination Call-IDs are
    // IDs out of the VC lookup table range that are used to gracefully
    // terminate failed incoming calls.
    //
{
    do
    {
        ++pAdapter->usNextTerminationCallId;
    }
    while (pAdapter->usNextTerminationCallId < pAdapter->usMaxVcs + 1);

    return pAdapter->usNextTerminationCallId;
}


USHORT
GetNextTunnelId(
    IN ADAPTERCB* pAdapter )

    // Returns the next tunnel ID to be assigned.
    //
    // IMPORTANT: Caller must hold 'pAdapter->lockTunnels'.
{
    while (++pAdapter->usNextTunnelId == 0)
        ;

    return pAdapter->usNextTunnelId;
}


CHAR*
GetFullHostNameFromRegistry(
    VOID )

    // Returns a heap block containing an ASCII string of the form
    // "hostname.domain", or if no domain of the form "hostname".  Returns
    // NULL if none.  Caller must eventually call FREE_NONPAGED on the
    // returned string.
    //
{
    NTSTATUS status;
    OBJECT_ATTRIBUTES objattr;
    UNICODE_STRING uni;
    HANDLE hParams;
    CHAR* pszResult;
    WCHAR* pszFullHostName;
    KEY_VALUE_PARTIAL_INFORMATION* pHostNameValue;
    KEY_VALUE_PARTIAL_INFORMATION* pDomainValue;
    ULONG ulSize;

    TRACE( TL_I, TM_Cm, ( "GetFullHostNameFromRegistry" ) );

    hParams = NULL;
    pszFullHostName = NULL;
    pHostNameValue = NULL;
    pDomainValue = NULL;
    pszResult = NULL;

    #define GFHNFR_BufSize 512

    do
    {
        // Get a handle to the TCPIP Parameters registry key.
        //
        RtlInitUnicodeString(
            &uni,
            L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\Tcpip\\Parameters" );
        InitializeObjectAttributes(
            &objattr, &uni, OBJ_CASE_INSENSITIVE, NULL, NULL );

        status = ZwOpenKey(
            &hParams, KEY_QUERY_VALUE, &objattr );
        if (status != STATUS_SUCCESS)
        {
            TRACE( TL_A, TM_Cm, ( "ZwOpenKey(ipp)=$%08x?", status ) );
            break;
        }

        // Query the "Hostname" registry value.
        //
        pHostNameValue = ALLOC_NONPAGED( GFHNFR_BufSize, MTAG_UTIL );
        if (!pHostNameValue)
        {
            break;
        }

        RtlInitUnicodeString( &uni, L"Hostname" );
        status = ZwQueryValueKey(
            hParams, &uni, KeyValuePartialInformation,
            pHostNameValue, GFHNFR_BufSize, &ulSize );
        if (status != STATUS_SUCCESS || pHostNameValue->Type != REG_SZ || 
            pHostNameValue->DataLength < sizeof(WCHAR) * 2)
        {
            TRACE( TL_A, TM_Cm, ( "ZwQValueKey=$%08x?", status ) );
            break;
        }
        
        ASSERT(pHostNameValue->DataLength < GFHNFR_BufSize);
        
        // Query the "Domain" registry value.
        //
        pDomainValue = ALLOC_NONPAGED( GFHNFR_BufSize, MTAG_UTIL );
        if (pDomainValue)
        {
            RtlInitUnicodeString( &uni, L"Domain" );
            status = ZwQueryValueKey(
                hParams, &uni, KeyValuePartialInformation,
                pDomainValue, GFHNFR_BufSize, &ulSize );
        }
        else
        {
            status = !STATUS_SUCCESS;
        }

        // Build a Unicode version of the combined "hostname.domain" or
        // "hostname".
        //
        pszFullHostName = ALLOC_NONPAGED( GFHNFR_BufSize * 2, MTAG_UTIL );
        if (!pszFullHostName)
        {
            break;
        }

        NdisMoveMemory(pszFullHostName, pHostNameValue->Data, pHostNameValue->DataLength);
        pszFullHostName[pHostNameValue->DataLength/2 - 1] = L'\0';
        
        if (status == STATUS_SUCCESS
            && pDomainValue->Type == REG_SZ
            && pDomainValue->DataLength >= sizeof(WCHAR) * 2
            && ((WCHAR* )pDomainValue->Data)[ 0 ] != L'\0')
        {
            WCHAR* pch;

            pch = &pszFullHostName[pHostNameValue->DataLength / 2 - 1];
            *pch = L'.';
            ++pch;
            NdisMoveMemory( pch, (WCHAR* )pDomainValue->Data, pDomainValue->DataLength);
            pch[pDomainValue->DataLength/2 - 1] = L'\0'; 
        }

        // Convert the Unicode version to ASCII.
        //
        pszResult = StrDupUnicodeToAscii(
            pszFullHostName, StrLenW( pszFullHostName ) * sizeof(WCHAR) );
    }
    while (FALSE);

    if (hParams)
    {
        ZwClose( hParams );
    }

    if (pHostNameValue)
    {
        FREE_NONPAGED( pHostNameValue );
    }

    if (pDomainValue)
    {
        FREE_NONPAGED( pDomainValue );
    }

    if (pszFullHostName)
    {
        FREE_NONPAGED( pszFullHostName );
    }

    return pszResult;
}


ULONG
IpAddressFromDotted(
    IN CHAR* pchIpAddress )

    // Convert caller's a.b.c.d IP address string to the network byte-order
    // numeric equivalent.
    //
    // Returns the numeric IP address or 0 if formatted incorrectly.
    //
{
    INT i;
    ULONG ulResult;
    CHAR* pch;

    ulResult = 0;
    pch = pchIpAddress;

    for (i = 1; i <= 4; ++i)
    {
        ULONG ulField;

        ulField = atoul( pch );

        if (ulField > 255)
            return 0;

        ulResult = (ulResult << 8) + ulField;

        while (*pch >= '0' && *pch <= '9')
            ++pch;

        if (i < 4 && *pch != '.')
            return 0;

        ++pch;
    }

    return htonl( ulResult );
}


VOID
IndicateLinkStatus(
    IN VCCB* pVc,
    IN LINKSTATUSINFO* pInfo )

    // Indicate new WAN_CO_LINKPARAMS settings for 'pVc' to NDISWAN.  Caller
    // should not be holding locks.
    //
{
    ASSERT( pInfo->params.SendWindow > 0 );

    TRACE( TL_I, TM_Mp, ( "NdisMCoIndStatus(LINK) bps=%d sw=%d",
        pInfo->params.TransmitSpeed, pInfo->params.SendWindow ) );
    NdisMCoIndicateStatus(
        pInfo->MiniportAdapterHandle,
        pInfo->NdisVcHandle,
        NDIS_STATUS_WAN_CO_LINKPARAMS,
        &pInfo->params,
        sizeof(pInfo->params) );
    TRACE( TL_N, TM_Mp, ( "NdisMCoIndStatus done" ) );
}


CHAR*
MsgTypePszFromUs(
    IN USHORT usMsgType )

    // Debug utility to convert message type attribute code 'usMsgType' to a
    // corresponding display string.
    //
{
    static CHAR szBuf[ 5 + 1 ];
    static CHAR* aszMsgType[ 16 ] =
    {
        "SCCRQ",
        "SCCRP",
        "SCCCN",
        "StopCCN",
        "StopCCRP???",
        "Hello",
        "OCRQ",
        "OCRP",
        "OCCN",
        "ICRQ",
        "ICRP",
        "ICCN",
        "CCR???",
        "CDN",
        "WEN",
        "SLI"
    };

    if (usMsgType >= 1 && usMsgType <= 16)
    {
        return aszMsgType[ usMsgType - 1 ];
    }
    else
    {
        ultoa( (ULONG )usMsgType, szBuf );
        return szBuf;
    }
}


#ifndef READFLAGSDIRECT
ULONG
ReadFlags(
    IN ULONG* pulFlags )

    // Read the value of '*pulFlags' as an interlocked operation.
    //
{
    return InterlockedExchangeAdd( pulFlags, 0 );
}
#endif


VOID
ScheduleTunnelWork(
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN PTUNNELWORK pHandler,
    IN ULONG_PTR unpArg0,
    IN ULONG_PTR unpArg1,
    IN ULONG_PTR unpArg2,
    IN ULONG_PTR unpArg3,
    IN BOOLEAN fTcbPreReferenced,
    IN BOOLEAN fHighPriority )

    // Schedules caller's 'pHandler' to be executed in an APC serially with
    // other work scheduled via this routine.  'PTunnel' is the tunnel to
    // which the work is related.  'UnpArgX' are the context arguments passed
    // to caller's 'pHandler'.  'FPreRefenced' indicates caller has already
    // made the tunnel reference associated with a scheduled work item.  This
    // is a convenience if he already holds 'ADAPTERCB.lockTunnels'.
    // 'FHighPriority' causes the item to be queued at the head rather than
    // the tail of the list.
    //
{
    ADAPTERCB* pAdapter;
    TUNNELWORK* pWork;

    pAdapter = pTunnel->pAdapter;

    if (!fTcbPreReferenced)
    {
        // Each queued work item holds a tunnel reference.
        //
        ReferenceTunnel( pTunnel, FALSE );
    }

    pWork = ALLOC_TUNNELWORK( pAdapter );
    if (!pWork)
    {
        // Can't get memory to schedule an APC so there's no
        // way we'll ever get things cleaned up.
        //
        ++g_ulAllocTwFailures;
        if (!fTcbPreReferenced)
        {
            DereferenceTunnel( pTunnel );
        }
        return;
    }

    if (pVc)
    {
        // Each queued work item that refers to a VC holds a VC reference.
        //
        ReferenceVc( pVc );
    }

    pWork->pHandler = pHandler;
    pWork->pVc = pVc;
    pWork->aunpArgs[ 0 ] = unpArg0;
    pWork->aunpArgs[ 1 ] = unpArg1;
    pWork->aunpArgs[ 2 ] = unpArg2;
    pWork->aunpArgs[ 3 ] = unpArg3;

    NdisAcquireSpinLock( &pTunnel->lockWork );
    {
        if (fHighPriority)
        {
            InsertHeadList( &pTunnel->listWork, &pWork->linkWork );
            TRACE( TL_N, TM_TWrk, ( "Q-TunnelWork($%08x,HIGH)", pHandler ) );
        }
        else
        {
            InsertTailList( &pTunnel->listWork, &pWork->linkWork );
            TRACE( TL_N, TM_TWrk, ( "Q-TunnelWork($%08x)", pHandler ) );
        }

        // Kickstart the tunnel worker if it's not running already.
        //
        if (!(ReadFlags( &pTunnel->ulFlags ) & TCBF_InWork ))
        {
            SetFlags( &pTunnel->ulFlags, TCBF_InWork );
            TRACE( TL_N, TM_TWrk, ( "Schedule TunnelWork" ) );
            ScheduleWork( pAdapter, TunnelWork, pTunnel );
        }
    }
    NdisReleaseSpinLock( &pTunnel->lockWork );
}


NDIS_STATUS
ScheduleWork(
    IN ADAPTERCB* pAdapter,
    IN NDIS_PROC pProc,
    IN PVOID pContext )

    // Schedules a PASSIVE IRQL callback to routine 'pProc' which will be
    // passed 'pContext'.  'PAdapter' is the adapter control block from which
    // the work item is allocated.  This routine takes an adapter reference
    // that should be removed by the called 'pProc'.
    //
    // Returns NDIS_STATUS_SUCCESS or an error code.
    //
{
    NDIS_STATUS status;
    NDIS_WORK_ITEM* pWork;

    pWork = ALLOC_NDIS_WORK_ITEM( pAdapter );
    if (!pWork)
    {
        return NDIS_STATUS_RESOURCES;
    }

    NdisInitializeWorkItem( pWork, pProc, pContext );

    ReferenceAdapter( pAdapter );
    status = NdisScheduleWorkItem( pWork );
    if (status != NDIS_STATUS_SUCCESS)
    {
        FREE_NDIS_WORK_ITEM( pAdapter, pWork );
        DereferenceAdapter( pAdapter );
    }

    return status;
}


VOID
SetFlags(
    IN OUT ULONG* pulFlags,
    IN ULONG ulMask )

    // Set 'ulMask' bits in '*pulFlags' flags as an interlocked operation.
    //
{
    ULONG ulFlags;
    ULONG ulNewFlags;

    do
    {
        ulFlags = InterlockedExchangeAdd( pulFlags, 0 );
        ulNewFlags = ulFlags | ulMask;
    }
    while (InterlockedCompareExchange(
               pulFlags, ulNewFlags, ulFlags ) != (LONG )ulFlags);
}

WCHAR*
StrDupNdisString(
    IN NDIS_STRING* pNdisString )

    // Returns null-terminated Unicode copy of the NDIS_STRING 'pNdisString'
    // Caller must eventually call FREE_NONPAGED on the returned string.
    //
{
    WCHAR* pwszDup = NULL;

    if(pNdisString->Length >= sizeof(WCHAR) && (pNdisString->Length & 1) == 0 &&
        pNdisString->Buffer[0] != L'\0')             
    {
        pwszDup = ALLOC_NONPAGED( pNdisString->Length + sizeof(WCHAR), MTAG_UTIL );
        if (pwszDup)
        {
            NdisMoveMemory( pwszDup, pNdisString->Buffer, pNdisString->Length );
            pwszDup[pNdisString->Length / sizeof(WCHAR)] = L'\0';
        }
    }

    return pwszDup;
}


CHAR*
StrDupNdisStringToA(
    IN NDIS_STRING* pNdisString )

    // Returns null-terminated ASCII copy of the NDIS_STRING 'pNdisString'
    // Caller must eventually call FREE_NONPAGED on the returned string.
    //
{
    return StrDupUnicodeToAscii( pNdisString->Buffer, pNdisString->Length );
}

CHAR*
StrDupNdisVarDataDescStringToA(
    IN NDIS_VAR_DATA_DESC UNALIGNED* pDesc )

    // Returns null-terminated ASCII copy of the NDIS_VAR_DATA_DESC string
    // 'pDesc'.  Caller must eventually call FREE_NON-PAGED on the returned
    // string.
    //
{
    return StrDupUnicodeToAscii(
        (WCHAR* )(((CHAR* )pDesc) + pDesc->Offset), pDesc->Length );
}


CHAR*
StrDupSized(
    IN CHAR* psz,
    IN ULONG ulLength,
    IN ULONG ulExtra )

    // Return a duplicate of the first 'ulLength' bytes of 'psz' followed by a
    // null character and 'ulExtra' extra bytes, or NULL on error.  Caller
    // must eventually call FREE_NONPAGED on the returned string.
    //
{
    CHAR* pszDup = NULL;
    
    if(ulLength && psz[0] != '\0')
    {
        pszDup = ALLOC_NONPAGED( ulLength + 1 + ulExtra, MTAG_UTIL );
        if (pszDup)
        {
            NdisMoveMemory( pszDup, psz, ulLength );
            pszDup[ ulLength ] = '\0';
        }
    }

    return pszDup;
}

CHAR*
StrDupUnicodeToAscii(
    IN WCHAR* pwsz,
    IN ULONG ulPwszBytes )

    // Returns an ASCII duplicate of Unicode string 'pwsz', where 'pwsz' is
    // 'ulPwszBytes' in length and not necessarily null terminated.  A null
    // terminator is added to the ASCII result.  The "conversion" consists of
    // picking out every other byte, hopefully all the non-zero ones.  This is
    // not foolproof, but then Unicode doesn't convert to ASCII in any
    // foolproof way.  It is caller's responsibility to FREE_NONPAGED the
    // returned string, if non-NULL.
    //
{
    CHAR* pszDup = NULL;

    // Validate the input parameters
    // Don't allow empty string
    if(ulPwszBytes >= sizeof(WCHAR) && (ulPwszBytes & 1) == 0 && 
        pwsz[0] != L'\0' && *((PCHAR)pwsz + 1) == '\0')
    {
        pszDup = ALLOC_NONPAGED( ulPwszBytes/2 + 1, MTAG_UTIL );
        if (pszDup)
        {
            ULONG i;
        
            for (i = 0; i < ulPwszBytes / sizeof(WCHAR); ++i)
            {
                pszDup[ i ] = (CHAR)pwsz[ i ];
            }
            
            pszDup[ulPwszBytes / sizeof(WCHAR)] = '\0';
        }
    }

    return pszDup;
}


WCHAR*
StrDupAsciiToUnicode(
    IN CHAR* psz,
    IN ULONG ulPszBytes )

    // Returns a Unicode duplicate of ASCII string 'psz', where 'psz' is
    // 'ulPszBytes' in length and not necessarily null terminated.  A null
    // terminator is added to the Unicode result.  The "conversion" consists
    // of adding zero characters every other byte.  This is not foolproof, but
    // is OK for numericals like IP address strings, avoiding the change to
    // PASSIVE IRQL required to use the real RTL conversions.  It is caller's
    // responsibility to FREE_NONPAGED the returned string, if non-NULL.
    //
{
    WCHAR* pwszDup = NULL;
    
    if(ulPszBytes >= sizeof(CHAR) && psz[0] != '\0')
    {
        pwszDup = (WCHAR* )ALLOC_NONPAGED(
            (ulPszBytes + 1) * sizeof(WCHAR), MTAG_UTIL );
        if (pwszDup)
        {
            ULONG i;
    
            for (i = 0; i < ulPszBytes; ++i)
            {
                pwszDup[ i ] = (WCHAR )(psz[ i ]);
            }
    
            pwszDup[ i ] = L'\0';
        }
    }

    return pwszDup;
}


ULONG
StrLenW(
    IN WCHAR* psz )

    // Return the length in characters of null terminated wide string 'psz'.
    //
{
    ULONG ulLen;

    ulLen = 0;

    if (psz)
    {
        while (*psz++ != L'\0')
        {
            ++ulLen;
        }
    }

    return ulLen;
}


TUNNELCB*
TunnelCbFromIpAddressAndAssignedTunnelId(
    IN ADAPTERCB* pAdapter,
    IN ULONG ulIpAddress,
    IN USHORT usUdpPort,
    IN USHORT usAssignedTunnelId )

    // Return the tunnel control block associated with 'ulIpAddress' in
    // 'pAdapter's list of TUNNELCBs or NULL if not found.  If
    // 'usAssignedTunnelId' is non-zero, that must match as well, otherwise it
    // is ignored.  Tunnels in the process of closing are not returned.
    //
    // IMPORTANT:  Caller must hold 'pAdapter->lockTunnels'.
    //
{
    TUNNELCB* pTunnel;
    LIST_ENTRY* pLink;

    pTunnel = NULL;

    for (pLink = pAdapter->listTunnels.Flink;
         pLink != &pAdapter->listTunnels;
         pLink = pLink->Flink)
    {
        TUNNELCB* pThis;

        pThis = CONTAINING_RECORD( pLink, TUNNELCB, linkTunnels );
        if (pThis->address.ulIpAddress == ulIpAddress
            && (!usUdpPort 
                || usUdpPort == pThis->address.sUdpPort)
            && (!usAssignedTunnelId
                || usAssignedTunnelId == pThis->usAssignedTunnelId))
        {
            BOOLEAN fClosing;

            fClosing = !!(ReadFlags( &pThis->ulFlags ) & TCBF_Closing);
            if (fClosing)
            {
                TRACE( TL_A, TM_Misc, ( "Closing pT=$%p skipped", pThis ) );
            }
            else
            {
                pTunnel = pThis;
                break;
            }
        }
    }

    return pTunnel;
}


VOID
TransferLinkStatusInfo(
    IN VCCB* pVc,
    OUT LINKSTATUSINFO* pInfo )

    // Transfer information from 'pVc' to callers 'pInfo' block in preparation
    // for a call to IndicateLinkStatus after 'lockV' has been released.
    //
    // IMPORTANT: Caller must hold 'pVc->lockV'.
    //
{
    ADAPTERCB* pAdapter;

    pAdapter = pVc->pAdapter;

    pInfo->MiniportAdapterHandle = pAdapter->MiniportAdapterHandle;
    pInfo->NdisVcHandle = pVc->NdisVcHandle;

    //
    // Convert to bytes per second
    //
    pInfo->params.TransmitSpeed = pVc->ulConnectBps/8;
    pInfo->params.ReceiveSpeed = pInfo->params.TransmitSpeed/8;

    pInfo->params.SendWindow =
        min( pVc->ulSendWindow, pAdapter->info.MaxSendWindow );
}


VOID
TunnelWork(
    IN NDIS_WORK_ITEM* pWork,
    IN VOID* pContext )

    // An NDIS_PROC routine to execute work from a tunnel work queue.  The
    // context passed is the TUNNELCB, which has been referenced for this
    // operation.
    //
    // This routine is called only at PASSIVE IRQL.
    //
{
    ADAPTERCB* pAdapter;
    TUNNELCB* pTunnel;
    LIST_ENTRY* pLink;
    LONG lDerefTunnels;

    // Unpack context information then free the work item.
    //
    pTunnel = (TUNNELCB* )pContext;
    pAdapter = pTunnel->pAdapter;
    FREE_NDIS_WORK_ITEM( pAdapter, pWork );

    // Execute all work queued on the tunnel serially.
    //
    lDerefTunnels = 0;
    NdisAcquireSpinLock( &pTunnel->lockWork );
    {
        ASSERT( ReadFlags( &pTunnel->ulFlags ) & TCBF_InWork );

        while (!IsListEmpty( &pTunnel->listWork ))
        {
            TUNNELWORK* pTunnelWork;

            pLink = RemoveHeadList( &pTunnel->listWork );
            InitializeListHead( pLink );
            pTunnelWork = CONTAINING_RECORD( pLink, TUNNELWORK, linkWork );

            TRACE( TL_N, TM_TWrk,
                ( "\nL2TP: TUNNELWORK=$%08x", pTunnelWork->pHandler ) );

            NdisReleaseSpinLock( &pTunnel->lockWork );
            {
                VCCB* pVc;

                pVc = pTunnelWork->pVc;
                pTunnelWork->pHandler( pTunnelWork, pTunnel, pVc, pTunnelWork->aunpArgs );

                if (pVc)
                {
                    DereferenceVc( pVc );
                }

                ++lDerefTunnels;
            }
            NdisAcquireSpinLock( &pTunnel->lockWork );
        }

        ClearFlags( &pTunnel->ulFlags, TCBF_InWork );
    }
    NdisReleaseSpinLock( &pTunnel->lockWork );

    while (lDerefTunnels--)
    {
        DereferenceTunnel( pTunnel );
    }

    // Remove the reference for scheduled work.
    //
    DereferenceAdapter( pAdapter );
}


VOID
UpdateGlobalCallStats(
    IN VCCB* pVc )

    // Add the call statistics in 'pVc' to the global call statistics.
    //
    // IMPORTANT: Caller must hold 'pVc->lockV'.
    //
{
    extern CALLSTATS g_stats;
    extern NDIS_SPIN_LOCK g_lockStats;
    CALLSTATS* pStats;

    pStats = &pVc->stats;

    if (pStats->ulSeconds == 0)
    {
        return;
    }

    NdisAcquireSpinLock( &g_lockStats );
    {
        ++g_stats.llCallUp;
        g_stats.ulSeconds += pStats->ulSeconds;
        g_stats.ulDataBytesRecd += pStats->ulDataBytesRecd;
        g_stats.ulDataBytesSent += pStats->ulDataBytesSent;
        g_stats.ulRecdDataPackets += pStats->ulRecdDataPackets;
        g_stats.ulDataPacketsDequeued += pStats->ulDataPacketsDequeued;
        g_stats.ulRecdZlbs += pStats->ulRecdZlbs;
        g_stats.ulRecdResets += pStats->ulRecdResets;
        g_stats.ulRecdResetsIgnored += pStats->ulRecdResetsIgnored;
        g_stats.ulSentDataPacketsSeq += pStats->ulSentDataPacketsSeq;
        g_stats.ulSentDataPacketsUnSeq += pStats->ulSentDataPacketsUnSeq;
        g_stats.ulSentPacketsAcked += pStats->ulSentPacketsAcked;
        g_stats.ulSentPacketsTimedOut += pStats->ulSentPacketsTimedOut;
        g_stats.ulSentZAcks += pStats->ulSentZAcks;
        g_stats.ulSentResets += pStats->ulSentResets;
        g_stats.ulSendWindowChanges += pStats->ulSendWindowChanges;
        g_stats.ulSendWindowTotal += pStats->ulSendWindowTotal;
        g_stats.ulMaxSendWindow += pStats->ulMaxSendWindow;
        g_stats.ulMinSendWindow += pStats->ulMinSendWindow;
        g_stats.ulRoundTrips += pStats->ulRoundTrips;
        g_stats.ulRoundTripMsTotal += pStats->ulRoundTripMsTotal;
        g_stats.ulMaxRoundTripMs += pStats->ulMaxRoundTripMs;
        g_stats.ulMinRoundTripMs += pStats->ulMinRoundTripMs;
    }
    NdisReleaseSpinLock( &g_lockStats );

    TRACE( TL_I, TM_Stat,
        ( ".--- CALL STATISTICS -------------------------" ) );
    TRACE( TL_I, TM_Stat,
        ( "| Duration:    %d minutes, %d seconds",
            pStats->ulSeconds / 60,
            pStats->ulSeconds % 60 ) );
    TRACE( TL_I, TM_Stat,
        ( "| Data out:    %d bytes, %d/sec, %d/pkt",
            pStats->ulDataBytesSent,
            AVGTRACE(
                pStats->ulDataBytesSent,
                pStats->ulSeconds ),
            AVGTRACE(
                pStats->ulDataBytesSent,
                pStats->ulRecdDataPackets ) ) );
    TRACE( TL_I, TM_Stat,
        ( "| Data in:     %d bytes, %d/sec, %d/pkt",
            pStats->ulDataBytesRecd,
            AVGTRACE( pStats->ulDataBytesRecd, pStats->ulSeconds ),
            AVGTRACE(
                pStats->ulDataBytesRecd,
                pStats->ulSentDataPacketsSeq
                    + pStats->ulSentDataPacketsUnSeq ) ) );
    TRACE( TL_I, TM_Stat,
        ( "| Acks in:     %d/%d (%d%%) %d flushed",
            pStats->ulSentPacketsAcked,
            pStats->ulSentDataPacketsSeq,
            PCTTRACE(
                pStats->ulSentPacketsAcked,
                pStats->ulSentPacketsAcked
                    + pStats->ulSentPacketsTimedOut ),
                pStats->ulSentDataPacketsSeq
                    + pStats->ulSentDataPacketsUnSeq
                    - pStats->ulSentPacketsAcked
                    - pStats->ulSentPacketsTimedOut ) );
    TRACE( TL_I, TM_Stat,
        ( "| Misordered:  %d (%d%%)",
            pStats->ulDataPacketsDequeued,
            PCTTRACE(
                pStats->ulDataPacketsDequeued,
                pStats->ulRecdDataPackets ) ) );
    TRACE( TL_I, TM_Stat,
        ( "| Out:         Resets=%d ZAcks=%d UnSeqs=%d",
            pStats->ulSentResets,
            pStats->ulSentZAcks,
            pStats->ulSentDataPacketsUnSeq ) );
    TRACE( TL_I, TM_Stat,
        ( "| In:          Resets=%d (%d%% old) Zlbs=%d",
            pStats->ulRecdResets,
            PCTTRACE(
                pStats->ulRecdResetsIgnored,
                pStats->ulRecdResets ),
            pStats->ulRecdZlbs ) );
    TRACE( TL_I, TM_Stat,
        ( "| Send window: Min=%d Avg=%d Max=%d Changes=%d",
            pStats->ulMinSendWindow,
            AVGTRACE(
                pStats->ulSendWindowTotal,
                pStats->ulSentDataPacketsSeq ),
            pStats->ulMaxSendWindow,
            pStats->ulSendWindowChanges ) );
    TRACE( TL_I, TM_Stat,
        ( "| Trip in ms:  Min=%d Avg=%d Max=%d",
            pStats->ulMinRoundTripMs,
            AVGTRACE(
                pStats->ulRoundTripMsTotal,
                pStats->ulRoundTrips ),
            pStats->ulMaxRoundTripMs ) );
    TRACE( TL_I, TM_Stat,
        ( "'---------------------------------------------" ) );
}


//-----------------------------------------------------------------------------
// Local utility routines (alphabetically)
//-----------------------------------------------------------------------------

ULONG
atoul(
    IN CHAR* pszNumber )

    // Convert string of digits 'pszNumber' to it's ULONG value.
    //
{
    ULONG ulResult;

    ulResult = 0;
    while (*pszNumber)
    {
        if(*pszNumber >= '0' && *pszNumber <= '9')
        {
            ulResult *= 10;
            ulResult += *pszNumber - '0';
        }
        else
        {
            break;
        }
        
        ++pszNumber;
    }

    return ulResult;
}


VOID
ReversePsz(
    IN OUT CHAR* psz )

    // Reverse the order of the characters in 'psz' in place.
    //
{
    CHAR* pchLeft;
    CHAR* pchRight;

    pchLeft = psz;
    pchRight = psz + strlen( psz ) - 1;

    while (pchLeft < pchRight)
    {
        CHAR ch;

        ch = *pchLeft;
        *pchLeft = *pchRight;
        *pchRight = ch;

        ++pchLeft;
        --pchRight;
    }
}


VOID
ultoa(
    IN ULONG ul,
    OUT CHAR* pszBuf )

    // Convert 'ul' to null-terminated string form in caller's 'pszBuf'.  It's
    // caller job to make sure 'pszBuf' is long enough to hold the returned
    // string.
    //
{
    CHAR* pch;

    pch = pszBuf;
    do
    {
        *pch++ = (CHAR )((ul % 10) + '0');
        ul /= 10;
    }
    while (ul);

    *pch = '\0';
    ReversePsz( pszBuf );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ndis\rasl2tp\kdext\exts.h ===
/************************************************************************\
*
* MODULE: exts.h
*
* DESCRIPTION: macro driving file for use with stdexts.h and stdexts.c.
*
* Copyright (c) 6/9/1995, Microsoft Corporation
*
* 6/9/1995 SanfordS Created
*
\************************************************************************/

DOIT(   help
        ,"help -v [cmd]\n"
        ,"  help      - Prints short help text on all commands.\n"
         "  help -v   - Prints long help text on all commands.\n"
         "  help cmd  - Prints long help on given command.\n"
        ,"v"
        ,CUSTOM)

DOIT(   dso
        ,"dso <struct> [field] [address]\n"
        ,"  - Dumps struct offsets and values, e.g:\n"
         "      dso ADAPTERCB 806955b0\n"
        ,""
        ,CUSTOM)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ndis\rasl2tp\tdix.c ===
// Copyright (c) 1997, Microsoft Corporation, all rights reserved
//
// tdix.c
// RAS L2TP WAN mini-port/call-manager driver
// TDI extensions interface
//
// 01/07/97 Steve Cobb
//
// These routines encapsulate L2TP's usage of TDI, with the intent of
// minimalizing the change required to support other TDI transports in the
// future, e.g. Frame Relay.
//
//
// About ALLOCATEIRPS:
//
// This driver is lower level code than typical TDI client drivers.  It has
// locked MDL-mapped input buffers readily available and does not need to
// provide any mapping to user mode client requests on completion.  This
// allows a performance gain from allocating and deallocating IRPs directly,
// thus avoiding unnecessary setup in TdiBuildInternalDeviceControlIrp and
// unnecessary APC queuing in IoCompleteRequest.  Define ALLOCATEIRPs 1 (in
// sources file) to make this optimization, or define it 0 to use the strictly
// TDI-compliant TdiBuildInternalDeviceControlIrp method.
//
//
// About NDISBUFFERISMDL:
//
// Calls to TdiBuildSendDatagram assume the NDIS_BUFFER can be passed in place
// of an MDL which avoids a pointless copy.  If this is not the case, an
// explicit MDL buffer would need to be allocated and caller's buffer copied
// to the MDL buffer before sending.  Same issue for TdiBuildReceiveDatagram,
// except of course that the copy would be from the MDL buffer to caller's
// buffer after receiving.
//
//
// About ROUTEWITHREF:
//
// Calls the IP_SET_ROUTEWITHREF IOCTLs rather than the TCP_SET_INFORMATION_EX
// IOCTLs to set up the host route.  The referenced route IOCTLs prevent PPTP
// and L2TP from walking on each others routes.  This setting provided only as
// a hedge against failure of the ROUTEWITHREF IOCTL.  Assuming it works it
// should always be preferable.
//

#include "l2tpp.h"

#include "tdix.tmh"

#define IP_PKTINFO          19 // receive packet information

typedef struct in_pktinfo {
    ULONG   ipi_addr; // destination IPv4 address
    UINT    ipi_ifindex; // received interface index
} IN_PKTINFO;


// Debug count of errors that should not be happening.
//
ULONG g_ulTdixOpenFailures = 0;
ULONG g_ulTdixSendDatagramFailures = 0;
ULONG g_ulTdixAddHostRouteFailures = 0;
ULONG g_ulTdixDeleteHostRouteFailures = 0;
ULONG g_ulTdixOpenCtrlAddrFailures = 0;
ULONG g_ulTdixOpenPayloadAddrFailures = 0;
ULONG g_ulTdixSetInterfaceFailures = 0;
ULONG g_ulTdixConnectAddrFailures = 0;
ULONG g_ulTdixAddHostRouteSuccesses = 0;
ULONG g_ulTdixDeleteHostRouteSuccesses = 0;
ULONG g_ulTdixOpenCtrlAddrSuccesses = 0;
ULONG g_ulTdixOpenPayloadAddrSuccesses = 0;
ULONG g_ulTdixSetInterfaceSuccesses = 0;
ULONG g_ulTdixConnectAddrSuccesses = 0;
ULONG g_ulNoBestRoute = 0;
NTSTATUS g_statusLastAhrSetRouteFailure = 0;
NTSTATUS g_statusLastAhrTcpQueryInfoExFailure = 0;
NTSTATUS g_statusLastDhrSetRouteFailure = 0;
NTSTATUS g_statusLastDhrTcpQueryInfoExFailure = 0;


#if NDISBUFFERISMDL
#else
#error Additional code to copy NDIS_BUFFER to/from MDL NYI.
#endif


//-----------------------------------------------------------------------------
// Local datatypes
//-----------------------------------------------------------------------------



//-----------------------------------------------------------------------------
// Local prototypes (alphabetically)
//-----------------------------------------------------------------------------

NTSTATUS
TdixConnectAddrInterface(
    FILE_OBJECT* pFileObj,
    HANDLE hFileHandle,
    TDIXROUTE* pTdixRoute
    );

VOID
TdixDisableUdpChecksums(
    IN FILE_OBJECT* pAddress);

VOID
TdixDoClose(
    TDIXCONTEXT* pTdix);

VOID
TdixEnableIpPktInfo(
    IN FILE_OBJECT* pAddress);

VOID
TdixEnableIpHdrIncl(
    IN FILE_OBJECT* pAddress);

VOID
TdixExtractAddress(
    IN TDIXCONTEXT* pTdix,
    OUT TDIXRDGINFO* pRdg,
    IN VOID* pTransportAddress,
    IN LONG lTransportAddressLen,
    IN VOID* Options,
    IN LONG OptionsLength);

NTSTATUS
TdixInstallEventHandler(
    IN FILE_OBJECT* pAddress,
    IN INT nEventType,
    IN VOID* pfuncEventHandler,
    IN VOID* pEventContext );

NTSTATUS
TdixOpenIpAddress(
    IN UNICODE_STRING* puniDevice,
    IN TDIXIPADDRESS* pTdixAddr,
    OUT HANDLE* phAddress,
    OUT FILE_OBJECT** ppFileObject );

NTSTATUS
TdixReceiveDatagramComplete(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context );

NTSTATUS
TdixReceiveDatagramHandler(
    IN PVOID TdiEventContext,
    IN LONG SourceAddressLength,
    IN PVOID SourceAddress,
    IN LONG OptionsLength,
    IN PVOID Options,
    IN ULONG ReceiveDatagramFlags,
    IN ULONG BytesIndicated,
    IN ULONG BytesAvailable,
    OUT ULONG* BytesTaken,
    IN PVOID Tsdu,
    OUT PIRP* IoRequestPacket );

TDIXROUTE*
TdixRouteFromIpAddress(
    IN TDIXCONTEXT* pTdix,
    IN ULONG ulIpAddress);

NTSTATUS
TdixSendComplete(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context );

NTSTATUS
TdixSendDatagramComplete(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context );


//-----------------------------------------------------------------------------
// Interface routines
//-----------------------------------------------------------------------------

VOID
TdixInitialize(
    IN TDIXMEDIATYPE mediatype,
    IN HOSTROUTEEXISTS hre,
    IN ULONG ulFlags,
    IN PTDIXRECEIVE pReceiveHandler,
    IN BUFFERPOOL* pPoolNdisBuffers,
    IN OUT TDIXCONTEXT* pTdix )

    // Initialize caller's 'pTdix' buffer for future sessions using media type
    // 'mediatype', the 'hre' existing host route strategy, and TDIXF_*
    // options 'ulFlags'.  Caller's receive datagram callback
    // 'pReceiveHandler' is called with a buffer allocated from caller's
    // buffer pool 'pPoolNdisBuffers'.
    //
{
    TRACE( TL_N, TM_Tdi, ( "TdixInit" ) );

    pTdix->lRef = 0;
    pTdix->hAddress = NULL;
    pTdix->pAddress = NULL;
    pTdix->hRawAddress = NULL;
    pTdix->pRawAddress = NULL;
    pTdix->mediatype = mediatype;
    pTdix->hre = hre;
    pTdix->ulFlags |= ulFlags;
    pTdix->ulFlags = 0;
    InitializeListHead( &pTdix->listRoutes );
    NdisAllocateSpinLock( &pTdix->lock );
    pTdix->pPoolNdisBuffers = pPoolNdisBuffers;
    pTdix->pReceiveHandler = pReceiveHandler;

    // The 'llistRdg' and 'llistSdg' lookaside lists are initialized at
    // TdixOpen.
}


NDIS_STATUS
TdixOpen(
    OUT TDIXCONTEXT* pTdix )

    // Open the TDI transport address matching the selected media and register
    // to receive datagrams at the selected handler.  'PTdix' is the
    // previously intialized context.
    //
    // This call must be made at PASSIVE IRQL.
    //
    // Returns NDIS_STATUS_SUCCESS if successful, or NDIS_STATUS_FAILURE.
    //
{
    NTSTATUS status;
    OBJECT_ATTRIBUTES oa;
    IO_STATUS_BLOCK iosb;
    FILE_FULL_EA_INFORMATION* pEa;
    ULONG ulEaLength;
    TA_IP_ADDRESS* pTaIp;
    TDI_ADDRESS_IP* pTdiIp;
    CHAR achEa[ 100 ];
    UNICODE_STRING uniDevice;
    UNICODE_STRING uniProtocolNumber;
    WCHAR achRawIpDevice[ sizeof(DD_RAW_IP_DEVICE_NAME) + 10 ];
    WCHAR achProtocolNumber[ 10 ];
    SHORT sPort;
    LONG lRef;

    // Open the TDI extensions or notice that it's already been requested
    // and/or completed.
    //
    for (;;)
    {
        BOOLEAN fPending;
        BOOLEAN fDoOpen;

        fPending = FALSE;
        fDoOpen = FALSE;

        NdisAcquireSpinLock( &pTdix->lock );
        {
            if (ReadFlags( &pTdix->ulFlags) & TDIXF_Pending)
            {
                fPending = TRUE;
            }
            else
            {
                lRef = ++pTdix->lRef;
                TRACE( TL_N, TM_Tdi, ( "TdixOpen, refs=%d", lRef ) );
                if (lRef == 1)
                {
                    SetFlags( &pTdix->ulFlags, TDIXF_Pending );
                    fDoOpen = TRUE;
                }
            }
        }
        NdisReleaseSpinLock( &pTdix->lock );

        if (fDoOpen)
        {
            // Go on and open the transport address.
            //
            break;
        }

        if (!fPending)
        {
            // It's already open, so report success.
            //
            return NDIS_STATUS_SUCCESS;
        }

        // An operation is already in progress.  Give it some time to finish
        // then check again.
        //
        TRACE( TL_I, TM_Tdi, ( "NdisMSleep(open)" ) );
        NdisMSleep( 100000 );
        TRACE( TL_I, TM_Tdi, ( "NdisMSleep(open) done" ) );
    }

    do
    {
        // Set up parameters needed to open the UDP transport address.  First, the
        // object attributes.
        //
        if(pTdix->mediatype == TMT_Udp)
        {
            TDIXIPADDRESS TdixIpAddress;

            TRACE( TL_V, TM_Tdi, ( "UDP" ) );

            // Build the UDP device name as a counted string.
            //
            uniDevice.Buffer = DD_UDP_DEVICE_NAME;
            uniDevice.Length = sizeof(DD_UDP_DEVICE_NAME) - sizeof(WCHAR);

            NdisZeroMemory(&TdixIpAddress, sizeof(TdixIpAddress));
            TdixIpAddress.sUdpPort = (SHORT)( htons( L2TP_UdpPort ));

            status = TdixOpenIpAddress(
                &uniDevice,
                &TdixIpAddress,
                &pTdix->hAddress,
                &pTdix->pAddress );

            if (status != STATUS_SUCCESS)
            {
                break;
            }

            TdixEnableIpPktInfo(pTdix->pAddress);
        }
        
        // Set up parameters needed to open the raw IP address.
        {
            TDIXIPADDRESS TdixIpAddress;

            TRACE( TL_A, TM_Tdi, ( "Raw IP" ) );

            // Build the raw IP device name as a counted string.  The device
            // name is followed by a path separator then the protocol number
            // of interest.
            //
            uniDevice.Buffer = achRawIpDevice;
            uniDevice.Length = 0;
            uniDevice.MaximumLength = sizeof(achRawIpDevice);
            RtlAppendUnicodeToString( &uniDevice, DD_RAW_IP_DEVICE_NAME );

            uniDevice.Buffer[ uniDevice.Length / sizeof(WCHAR) ]
                = OBJ_NAME_PATH_SEPARATOR;
            uniDevice.Length += sizeof(WCHAR);

            uniProtocolNumber.Buffer = achProtocolNumber;
            uniProtocolNumber.MaximumLength = sizeof(achProtocolNumber);
            RtlIntegerToUnicodeString(
                (ULONG )L2TP_IpProtocol, 10, &uniProtocolNumber );

            RtlAppendUnicodeStringToString( &uniDevice, &uniProtocolNumber );

            ASSERT( uniDevice.Length < sizeof(achRawIpDevice) );

            NdisZeroMemory(&TdixIpAddress, sizeof(TdixIpAddress));

            status = TdixOpenIpAddress(
                &uniDevice,
                &TdixIpAddress,
                &pTdix->hRawAddress,
                &pTdix->pRawAddress );

            if (status != STATUS_SUCCESS)
            {
                break;
            }
            
            // Enable IP header inclusion   
            TdixEnableIpHdrIncl(pTdix->pRawAddress);
        }

        // Initialize the lookaside lists of read/send-datagram contexts.
        //
        NdisInitializeNPagedLookasideList(
            &pTdix->llistRdg,
            NULL,
            NULL,
            0,
            sizeof(TDIXRDGINFO),
            MTAG_TDIXRDG,
            10 );

        NdisInitializeNPagedLookasideList(
            &pTdix->llistSdg,
            NULL,
            NULL,
            0,
            sizeof(TDIXSDGINFO),
            MTAG_TDIXSDG,
            10 );

        // Install our receive datagram handler.  Caller's 'pReceiveHandler' will
        // be called by our handler when a datagram arrives and TDI business is
        // out of the way.
        //
        status =
            TdixInstallEventHandler(
                pTdix->pAddress,
                TDI_EVENT_RECEIVE_DATAGRAM,
                TdixReceiveDatagramHandler,
                pTdix );

#if ROUTEWITHREF
        {
            TDIXIPADDRESS TdixIpAddress;

            // Open the IP stack address which is needed in both UDP and raw IP
            // mode for referenced route management.
            //

            NdisZeroMemory(&TdixIpAddress, sizeof(TdixIpAddress));

            uniDevice.Buffer = DD_IP_DEVICE_NAME;
            uniDevice.Length = sizeof(DD_IP_DEVICE_NAME) - sizeof(WCHAR);

            status = TdixOpenIpAddress(
                &uniDevice,
                &TdixIpAddress,
                &pTdix->hIpStackAddress,
                &pTdix->pIpStackAddress );

            if (status != STATUS_SUCCESS)
            {
                break;
            }
        }
#endif
    }
    while (FALSE);

    // Report results after marking the operation complete.
    //
    {
        BOOLEAN fDoClose;

        fDoClose = FALSE;
        NdisAcquireSpinLock( &pTdix->lock );
        {
            if (status == STATUS_SUCCESS)
            {
                ClearFlags( &pTdix->ulFlags, TDIXF_Pending );
            }
            else
            {
                ++g_ulTdixOpenFailures;
                ASSERT( pTdix->lRef == 1)
                pTdix->lRef = 0;
                fDoClose = TRUE;
            }
        }
        NdisReleaseSpinLock( &pTdix->lock );

        if (status != STATUS_SUCCESS)
        {
            TdixDoClose( pTdix );
        }
    }

    TRACE( TL_N, TM_Tdi, ( "TdixOpen=$%08x", status ) );
    return
        (status == STATUS_SUCCESS)
            ? NDIS_STATUS_SUCCESS
            : NDIS_STATUS_FAILURE;
}


VOID
TdixReference(
    IN TDIXCONTEXT* pTdix )

    // Increments the TDI extension reference count, like TdixOpen, except
    // this routine may be called at DISPATCH IRQL.
    //
    // This call must only be made if it is known that the TDI context is
    // already fully open.
    //
{
    NdisAcquireSpinLock( &pTdix->lock );
    {
        ASSERT( pTdix->lRef > 0 );
        ++pTdix->lRef;
    }
    NdisReleaseSpinLock( &pTdix->lock );
}


VOID
TdixClose(
    IN TDIXCONTEXT* pTdix )

    // Undo TdixOpen actions for transport context 'pTdix'.
    //
    // This call must be made at PASSIVE IRQL.
    //
{
    for (;;)
    {
        LONG lRef;
        BOOLEAN fPending;
        BOOLEAN fDoClose;

        fPending = FALSE;
        fDoClose = FALSE;

        NdisAcquireSpinLock( &pTdix->lock );
        {
            if (ReadFlags( &pTdix->ulFlags ) & TDIXF_Pending)
            {
                fPending = TRUE;
            }
            else
            {
                lRef = --pTdix->lRef;
                ASSERT( lRef >= 0 );
                TRACE( TL_N, TM_Tdi, ( "TdixClose, refs=%d", lRef ) );
                if (lRef == 0)
                {
                    SetFlags( &pTdix->ulFlags, TDIXF_Pending );
                    fDoClose = TRUE;
                }
            }
        }
        NdisReleaseSpinLock( &pTdix->lock );

        if (fDoClose)
        {
            // Go on and close the transport address.
            //
            break;
        }

        if (!fPending)
        {
            // It's still got references, so just return;
            //
            return;
        }

        // An operation is already in progress.  Give it some time to finish
        // then check again.
        //
        TRACE( TL_I, TM_Tdi, ( "NdisMSleep(close)" ) );
        NdisMSleep( 100000 );
        TRACE( TL_I, TM_Tdi, ( "NdisMSleep(close) done" ) );
    }

    ASSERT( IsListEmpty( &pTdix->listRoutes ) );
    TdixDoClose( pTdix );
}

NDIS_STATUS
TdixSend(
    IN TDIXCONTEXT* pTdix,
    IN FILE_OBJECT* pFileObj,
    IN PTDIXSENDCOMPLETE pSendCompleteHandler,
    IN VOID* pContext1,
    IN VOID* pContext2,
    IN VOID* pAddress,
    IN CHAR* pBuffer,
    IN ULONG ulBufferLength,
    OUT IRP** ppIrp ) 
    // Send a datagram buffer 'pBuffer', 'ulBufferLength' bytes long, to
    // remote address 'pAddress'.  The buffer must be from a BUFFERPOOL of
    // NDIS_BUFFERs.  'PTdix' is the transport context.
    // 'PSendDatagramCompleteHander' is caller's completion handler which is
    // passed 'pContext1' and 'pContext2'.  If 'ppIrp' is non-NULL '*ppIrp' is
    // set to the address of the posted IRP, this for debugging purposes.
    //
    // This call must be made at PASSIVE IRQL.
    //
    // Returns NDIS_STATUS_SUCCESS if successful, or NDIS_STATUS_FAILURE.
    //
{
    NDIS_STATUS status;
    NTSTATUS iostatus;
    TDIXSDGINFO* pSdg;
    SHORT sPort;
    PIRP pIrp;
    TDI_ADDRESS_IP* pTdiIp;
    DEVICE_OBJECT* DeviceObj;

    TRACE( TL_N, TM_Tdi, ( "TdixSend(dst=%d.%d.%d.%d/%d,len=%d)",
        IPADDRTRACE( ((TDIXIPADDRESS* )pAddress)->ulIpAddress ),
        (ULONG )(ntohs( ((TDIXIPADDRESS* )pAddress)->sUdpPort )),
        ulBufferLength ) );

    ASSERT(pFileObj != NULL);

    do
    {
        // Allocate a context for this send-datagram from our lookaside list.
        //
        pSdg = ALLOC_TDIXSDGINFO( pTdix );
        if (pSdg)
        {
            // Fill in the send-datagram context.
            //
            pSdg->pTdix = pTdix;
            pSdg->pSendCompleteHandler = pSendCompleteHandler;
            pSdg->pContext1 = pContext1;
            pSdg->pContext2 = pContext2;
            pSdg->pBuffer = pBuffer;
        }
        else
        {
            status = NDIS_STATUS_RESOURCES;
            break;
        }

#if 0
        // Put the destination IP address in the "connection" structure as TDI
        // expects.  The "connection" is part of our context as it must be
        // available to TDI until the request completes.
        //
        pSdg->taip.TAAddressCount = 1;
        pSdg->taip.Address[ 0 ].AddressLength = TDI_ADDRESS_LENGTH_IP;
        pSdg->taip.Address[ 0 ].AddressType = TDI_ADDRESS_TYPE_IP;

        pTdiIp = &pSdg->taip.Address[ 0 ].Address[ 0 ];

        sPort = ((TDIXIPADDRESS* )pAddress)->sUdpPort;
        if (sPort == 0 && pTdix->mediatype == TMT_Udp)
        {
            sPort = (SHORT )(htons( L2TP_UdpPort ));
        }

        pTdiIp->sin_port = sPort;
        pTdiIp->in_addr = ((TDIXIPADDRESS* )pAddress)->ulIpAddress;
        NdisZeroMemory( pTdiIp->sin_zero, sizeof(pTdiIp->sin_zero) );

        pSdg->tdiconninfo.UserDataLength = 0;
        pSdg->tdiconninfo.UserData = NULL;
        pSdg->tdiconninfo.OptionsLength = 0;
        pSdg->tdiconninfo.Options = NULL;
        pSdg->tdiconninfo.RemoteAddressLength = sizeof(pSdg->taip);
        pSdg->tdiconninfo.RemoteAddress = &pSdg->taip;
#endif

        DeviceObj = pFileObj->DeviceObject;

#if ALLOCATEIRPS
        // Allocate the IRP directly.
        //
        pIrp = IoAllocateIrp(DeviceObj->StackSize, FALSE );
#else
        // Allocate a "send datagram" IRP with base initialization.
        //
        pIrp =
            TdiBuildInternalDeviceControlIrp(
                TDI_SEND,
                DeviceObj,
                FileObj,
                NULL,
                NULL );
#endif

        if (!pIrp)
        {
            TRACE( TL_A, TM_Res, ( "Failed to allocate TDI_SEND IRP" ) );
            WPLOG( LL_A, LM_Res, ( "Failed to allocate TDI_SEND IRP" ) );
            status = NDIS_STATUS_RESOURCES;
            break;
        }

        // Complete the "send datagram" IRP initialization.
        //
        TdiBuildSend(
            pIrp,
            DeviceObj,
            pFileObj,
            TdixSendComplete,
            pSdg,
            NdisBufferFromBuffer( pBuffer ),
            0,
            ulBufferLength);

        if (ppIrp)
        {
            *ppIrp = pIrp;
        }

        // Tell the I/O manager to pass our IRP to the transport for
        // processing.
        //
        iostatus = IoCallDriver( DeviceObj, pIrp );
        ASSERT( iostatus == STATUS_PENDING );

        status = NDIS_STATUS_SUCCESS;
    }
    while (FALSE);

    if (status != NDIS_STATUS_SUCCESS)
    {
        // Pull a half Jameel, i.e. convert a synchronous failure to an
        // asynchronous failure from client's perspective.  However, clean up
        // context here.
        //
        ++g_ulTdixSendDatagramFailures;
        if (pSdg)
        {
            FREE_TDIXSDGINFO( pTdix, pSdg );
        }

        pSendCompleteHandler( pTdix, pContext1, pContext2, pBuffer );
    }

    return NDIS_STATUS_PENDING;
}

NDIS_STATUS
TdixSendDatagram(
    IN TDIXCONTEXT* pTdix,
    IN FILE_OBJECT* FileObj,
    IN PTDIXSENDCOMPLETE pSendCompleteHandler,
    IN VOID* pContext1,
    IN VOID* pContext2,
    IN VOID* pAddress,
    IN CHAR* pBuffer,
    IN ULONG ulBufferLength,
    OUT IRP** ppIrp )

    // Send a datagram buffer 'pBuffer', 'ulBufferLength' bytes long, to
    // remote address 'pAddress'.  The buffer must be from a BUFFERPOOL of
    // NDIS_BUFFERs.  'PTdix' is the transport context.
    // 'PSendDatagramCompleteHander' is caller's completion handler which is
    // passed 'pContext1' and 'pContext2'.  If 'ppIrp' is non-NULL '*ppIrp' is
    // set to the address of the posted IRP, this for debugging purposes.
    //
    // This call must be made at PASSIVE IRQL.
    //
    // Returns NDIS_STATUS_SUCCESS if successful, or NDIS_STATUS_FAILURE.
    //
{
    NDIS_STATUS status;
    NTSTATUS iostatus;
    TDIXSDGINFO* pSdg;
    SHORT sPort;
    PIRP pIrp;
    TDI_ADDRESS_IP* pTdiIp;

    TRACE( TL_N, TM_Tdi, ( "TdixSendDg(dst=%d.%d.%d.%d/%d,len=%d)",
        IPADDRTRACE( ((TDIXIPADDRESS* )pAddress)->ulIpAddress ),
        (ULONG )(ntohs( ((TDIXIPADDRESS* )pAddress)->sUdpPort )),
        ulBufferLength ) );

    ASSERT(FileObj);
    
    do
    {
        // Allocate a context for this send-datagram from our lookaside list.
        //
        pSdg = ALLOC_TDIXSDGINFO( pTdix );
        if (pSdg)
        {
            // Fill in the send-datagram context.
            //
            pSdg->pTdix = pTdix;
            pSdg->pSendCompleteHandler = pSendCompleteHandler;
            pSdg->pContext1 = pContext1;
            pSdg->pContext2 = pContext2;
            pSdg->pBuffer = pBuffer;
        }
        else
        {
            status = NDIS_STATUS_RESOURCES;
            break;
        }

        // Put the destination IP address in the "connection" structure as TDI
        // expects.  The "connection" is part of our context as it must be
        // available to TDI until the request completes.
        //
        pSdg->taip.TAAddressCount = 1;
        pSdg->taip.Address[ 0 ].AddressLength = TDI_ADDRESS_LENGTH_IP;
        pSdg->taip.Address[ 0 ].AddressType = TDI_ADDRESS_TYPE_IP;

        pTdiIp = &pSdg->taip.Address[ 0 ].Address[ 0 ];

        sPort = ((TDIXIPADDRESS* )pAddress)->sUdpPort;
        if (sPort == 0 && pTdix->mediatype == TMT_Udp)
        {
            sPort = (SHORT )(htons( L2TP_UdpPort ));
        }

        pTdiIp->sin_port = sPort;
        pTdiIp->in_addr = ((TDIXIPADDRESS* )pAddress)->ulIpAddress;
        NdisZeroMemory( pTdiIp->sin_zero, sizeof(pTdiIp->sin_zero) );

        pSdg->tdiconninfo.UserDataLength = 0;
        pSdg->tdiconninfo.UserData = NULL;
        pSdg->tdiconninfo.OptionsLength = 0;
        pSdg->tdiconninfo.Options = NULL;
        pSdg->tdiconninfo.RemoteAddressLength = sizeof(pSdg->taip);
        pSdg->tdiconninfo.RemoteAddress = &pSdg->taip;

#if ALLOCATEIRPS
        // Allocate the IRP directly.
        //
        pIrp = IoAllocateIrp(
            FileObj->DeviceObject->StackSize, FALSE );
#else
        // Allocate a "send datagram" IRP with base initialization.
        //
        pIrp =
            TdiBuildInternalDeviceControlIrp(
                TDI_SEND_DATAGRAM,
                FileObject->DeviceObject,
                pTdix->pAddress,
                NULL,
                NULL );
#endif

        if (!pIrp)
        {
            TRACE( TL_A, TM_Res, ( "Failed to allocate TDI_SEND_DATAGRAM IRP" ) );
            WPLOG( LL_A, LM_Res, ( "Failed to allocate TDI_SEND_DATAGRAM IRP" ) );
            status = NDIS_STATUS_RESOURCES;
            break;
        }

        // Complete the "send datagram" IRP initialization.
        //
        TdiBuildSendDatagram(
            pIrp,
            FileObj->DeviceObject,
            FileObj,
            TdixSendDatagramComplete,
            pSdg,
            NdisBufferFromBuffer( pBuffer ),
            ulBufferLength,
            &pSdg->tdiconninfo );

        if (ppIrp)
        {
            *ppIrp = pIrp;
        }

        // Tell the I/O manager to pass our IRP to the transport for
        // processing.
        //
        iostatus = IoCallDriver( FileObj->DeviceObject, pIrp );
        ASSERT( iostatus == STATUS_PENDING );

        status = NDIS_STATUS_SUCCESS;
    }
    while (FALSE);

    if (status != NDIS_STATUS_SUCCESS)
    {
        // Pull a half Jameel, i.e. convert a synchronous failure to an
        // asynchronous failure from client's perspective.  However, clean up
        // context here.
        //
        ++g_ulTdixSendDatagramFailures;
        if (pSdg)
        {
            FREE_TDIXSDGINFO( pTdix, pSdg );
        }

        pSendCompleteHandler( pTdix, pContext1, pContext2, pBuffer );
    }

    return NDIS_STATUS_PENDING;
}

VOID
TdixDestroyConnection(
    TDIXUDPCONNECTCONTEXT *pUdpContext)
{
    if (pUdpContext->fUsePayloadAddr) {

        ASSERT(pUdpContext->hPayloadAddr != NULL);
        
        //TdixInstallEventHandler(pUdpContext->pPayloadAddr,
        //    TDI_EVENT_RECEIVE_DATAGRAM, NULL, NULL);

        ObDereferenceObject( pUdpContext->pPayloadAddr );

        // Close the payload address object
        //
        ZwClose(pUdpContext->hPayloadAddr);
        pUdpContext->hPayloadAddr = NULL;
        pUdpContext->fUsePayloadAddr = FALSE;
    }

    if (pUdpContext->hCtrlAddr != NULL) {
        
        //TdixInstallEventHandler(pUdpContext->pCtrlAddr,
        //    TDI_EVENT_RECEIVE_DATAGRAM, NULL, NULL);

        // Close the Ctrl address object
        //
        ObDereferenceObject( pUdpContext->pCtrlAddr );
        ZwClose (pUdpContext->hCtrlAddr);
        pUdpContext->hCtrlAddr = NULL;
    }
}


NDIS_STATUS
TdixSetupConnection(
    IN TDIXCONTEXT* pTdix,
    IN TDIXROUTE *pTdixRoute,
    IN ULONG ulLocalIpAddress,
    IN TDIXUDPCONNECTCONTEXT* pUdpContext)
 {
    NDIS_STATUS status = STATUS_SUCCESS;
    
    ASSERT(pUdpContext != NULL);
    
    if (pTdix->mediatype == TMT_Udp) 
    {

        do {
            UNICODE_STRING uniDevice;
            UNICODE_STRING uniProtocolNumber;
            TDIXIPADDRESS TdixIpAddress;

            // Create an address object that we can send across.  If we have udp xsums
            // disabled we will need to create two address objects, one for control
            // and one for payload.  This allows payload specific features to be
            // implemented.
            //
            uniDevice.Buffer = DD_UDP_DEVICE_NAME;
            uniDevice.Length = sizeof(DD_UDP_DEVICE_NAME) - sizeof(WCHAR);

            TdixIpAddress.sUdpPort = (SHORT)(htons(L2TP_UdpPort));
            TdixIpAddress.ulIpAddress = ulLocalIpAddress;
         
            // Build the UDP device name as a counted string.
            //
            status = TdixOpenIpAddress(&uniDevice, 
                                     &TdixIpAddress,
                                     &pUdpContext->hCtrlAddr, 
                                     &pUdpContext->pCtrlAddr );

            if (status != STATUS_SUCCESS)
            {
                TRACE( TL_A, TM_Tdi, ( "TdixOpenIpAddress failed %x?", status ) );
                WPLOG( LL_A, LM_Tdi, ( "TdixOpenIpAddress failed %x?", status ) );
                break;
            }

            TdixEnableIpPktInfo(pUdpContext->pCtrlAddr);
            
            status = TdixInstallEventHandler(
                pUdpContext->pCtrlAddr,
                TDI_EVENT_RECEIVE_DATAGRAM,
                TdixReceiveDatagramHandler,
                pTdix);
                    
            if (status != STATUS_SUCCESS)
            {
                TRACE( TL_A, TM_Tdi, ( "AHR InstallEventHandler=%x?", status ) );
                break;
            }

            //
            // Associate a particular "send" IP interface index with the address
            // object, so that if that interface disappears traffic will not be
            // "re-routed" often back into the tunnel producing disastrous
            // looping.
            //
            status = TdixConnectAddrInterface(pUdpContext->pCtrlAddr,
                                           pUdpContext->hCtrlAddr,
                                           pTdixRoute);


            if (status != STATUS_SUCCESS)
            {
                TRACE( TL_A, TM_Tdi, ( "TdixConnectAddrInterface failed %x", status ) );
                WPLOG( LL_A, LM_Tdi, ( "TdixConnectAddrInterface failed %x", status ) );
                break;
            }

            // If udp xsums are disabled we need to create another address object.
            // We will set this object to disable udp xsums and then use it to
            // send payload data.
            //
            // If udp xsums are enabled we can use the same address object for
            // payloads that we use for contrl frames.
            //
            if (pTdix->ulFlags & TDIXF_DisableUdpXsums)
            {
                // Open the address object
                //
                status = TdixOpenIpAddress(&uniDevice, 
                                           &TdixIpAddress,
                                           &pUdpContext->hPayloadAddr,
                                           &pUdpContext->pPayloadAddr );

                if (status != STATUS_SUCCESS)
                {
                    TRACE( TL_A, TM_Tdi, ( "AHR OpenPayloadAddr=%x?", status ) );
                    WPLOG( LL_A, LM_Tdi, ( "AHR OpenPayloadAddr=%x?", status ) );
                    pUdpContext->hPayloadAddr = NULL;
                    break;
                }
                
                pUdpContext->fUsePayloadAddr = TRUE;

                TdixDisableUdpChecksums( pUdpContext->pPayloadAddr );
                
                TdixEnableIpPktInfo(pUdpContext->pPayloadAddr);
                
                status = TdixInstallEventHandler(
                    pUdpContext->pPayloadAddr,
                    TDI_EVENT_RECEIVE_DATAGRAM,
                    TdixReceiveDatagramHandler,
                    pTdix);
                        
                if (status != STATUS_SUCCESS)
                {
                    TRACE( TL_A, TM_Tdi, ( "AHR InstallEventHandler=%x?", status ) );
                    break;
                }

                // Associate a particular "send" IP interface index with the address
                // object, so that if that interface disappears traffic will not be
                // "re-routed" often back into the tunnel producing disastrous
                // looping.
                //
                status = TdixConnectAddrInterface(pUdpContext->pPayloadAddr, 
                                               pUdpContext->hPayloadAddr,
                                               pTdixRoute );

                if (status != STATUS_SUCCESS)
                {
                    TRACE( TL_A, TM_Tdi, ( "AHR ConnectPayloadAddr=%x?", status ) );
                    WPLOG( LL_A, LM_Tdi, ( "AHR ConnectPayloadAddr=%x?", status ) );
                    break;
                }
            } 
            else 
            {
                pUdpContext->hPayloadAddr = pUdpContext->hCtrlAddr;
                pUdpContext->pPayloadAddr = pUdpContext->pCtrlAddr;

                TRACE( TL_I, TM_Tdi, ( "AHR Ctrl==Payload") );
            }

        } while ( FALSE );

    }

    return status;
}


VOID*
TdixAddHostRoute(
    IN TDIXCONTEXT* pTdix,
    IN ULONG ulIpAddress,
    IN ULONG ulIfIndex)

    // Adds a host route for the remote peer's network byte-ordered IP address
    // 'ulIpAddress', i.e. routes packets directed to the L2TP peer to the LAN
    // card rather than back into the tunnel where it would loop infinitely.
    // 'PTdix' is the is caller's TDI extension context.
    //
    // Returns true if the route was added, false otherwise.
    //
    // Note: This routine borrows heavily from PPTP.
    //
{
    TCP_REQUEST_QUERY_INFORMATION_EX QueryBuf;
    TCP_REQUEST_SET_INFORMATION_EX* pSetBuf;
    VOID* pBuffer2;
    PIO_STACK_LOCATION pIrpSp;
    PDEVICE_OBJECT pDeviceObject;
    PDEVICE_OBJECT pIpDeviceObject;
    NTSTATUS status = STATUS_SUCCESS;
    PIRP pIrp;
    IO_STATUS_BLOCK iosb;
    IPRouteEntry* pBuffer;
    IPRouteEntry* pRouteEntry;
    IPRouteEntry* pNewRouteEntry;
    IPRouteEntry* pBestRoute;
    ULONG ulRouteCount;
    ULONG ulSize;
    ULONG i;
    ULONG ulBestMask;
    ULONG ulBestMetric;
    TDIXROUTE* pTdixRoute;
    BOOLEAN fNewRoute;
    BOOLEAN fPending;
    BOOLEAN fOpenPending;
    BOOLEAN fUsedNonL2tpRoute;
    LONG lRef;
    KEVENT  event;

    if (ulIpAddress == 0)
    {
        TRACE( TL_A, TM_Tdi, ( "IP == 0?" ) );
        return ((VOID*)NULL);
    }

    TRACE( TL_N, TM_Tdi,
        ( "TdixAddHostRoute(ip=%d.%d.%d.%d)", IPADDRTRACE( ulIpAddress ) ) );

    // Host routes are referenced since more than one tunnel to the same peer
    // (allowed by L2TP) shares the same system route.  See if this is just a
    // reference or the actual add of the system host route.
    //
    for (;;)
    {
        fPending = FALSE;
        fOpenPending = FALSE;
        pTdixRoute = NULL;
        fNewRoute = FALSE;

        NdisAcquireSpinLock( &pTdix->lock );
        do
        {
            if (pTdix->lRef <= 0)
            {
                // TDIX is closed or closing, so the add route fails.
                //
                break;
            }

            if (ReadFlags( &pTdix->ulFlags ) & TDIXF_Pending)
            {
                // A TdixOpen is pending.  Wait for it to finish before
                // adding the route.
                //
                fOpenPending = TRUE;
                break;
            }

            pTdixRoute = TdixRouteFromIpAddress( pTdix, ulIpAddress );
            if (pTdixRoute)
            {
                // Found an existing route context.
                //
                fPending = pTdixRoute->fPending;
                if (!fPending)
                {
                    // No other operation is pending on the route context.
                    // Take a reference.
                    //
                    ++pTdixRoute->lRef;
                }
                break;
            }
            
            // No existing route context.  Create and link a new one.
            //
            pTdixRoute = ALLOC_TDIXROUTE( pTdix );
            if (pTdixRoute)
            {
                NdisZeroMemory(pTdixRoute, sizeof(TDIXROUTE));

                pTdixRoute->ulIpAddress = ulIpAddress;
                pTdixRoute->lRef = 1;
                pTdixRoute->fPending = TRUE;
                pTdixRoute->fUsedNonL2tpRoute = FALSE;

                InsertTailList(
                    &pTdix->listRoutes, &pTdixRoute->linkRoutes );
                lRef = ++pTdix->lRef;
                TRACE( TL_N, TM_Tdi, ( "TdixAHR, refs=%d", lRef ) );
                WPLOG( LL_M, LM_Tdi, ( "TdixAHR, refs=%d", lRef ) );

                fPending = pTdixRoute->fPending;
                fNewRoute = TRUE;
            }
        }
        while (FALSE);
        NdisReleaseSpinLock( &pTdix->lock );

        if (!fOpenPending)
        {
            if (!pTdixRoute)
            {
                // TDIX is closed or we couldn't find an existing route
                // context or create a new one.  Report failure.
                //
                return ((VOID*)NULL);
            }

            if (fNewRoute)
            {
                // Created a new route context so go on to make the IOCTL
                // calls to add the associated system host route.
                //
                break;
            }

            if (!fPending)
            {
                // Took a reference on an existing route context.  Report
                // success.
                //
                return (pTdixRoute);
            }
        }

        // An operation is already pending.  Give it some time to finish then
        // check again.
        //
        TRACE( TL_I, TM_Tdi, ( "NdisMSleep(add)" ) );
        NdisMSleep( 100000 );
        TRACE( TL_I, TM_Tdi, ( "NdisMSleep(add) done" ) );
    }

    // Do the IOCTLs to add the host route.
    //
    pBuffer = NULL;
    pBuffer2 = NULL;
    fUsedNonL2tpRoute = FALSE;

    do
    {

        // Get the routing table from the IP stack.  This make take a few
        // iterations since the size of the buffer required is not known.  Set
        // up the static request information first.
        //
        QueryBuf.ID.toi_entity.tei_entity = CL_NL_ENTITY;
        QueryBuf.ID.toi_entity.tei_instance = 0;
        QueryBuf.ID.toi_class = INFO_CLASS_PROTOCOL;
        QueryBuf.ID.toi_type = INFO_TYPE_PROVIDER;
        pDeviceObject = IoGetRelatedDeviceObject( pTdix->pAddress );

        status = !STATUS_SUCCESS;
        ulRouteCount = 20;
        for (;;)
        {
            // Allocate a buffer big enough for 'ulRouteCount' routes.
            //
            ulSize = sizeof(IPRouteEntry) * ulRouteCount;
            QueryBuf.ID.toi_id = IP_MIB_RTTABLE_ENTRY_ID;
            NdisZeroMemory( &QueryBuf.Context, CONTEXT_SIZE );

            pBuffer = (IPRouteEntry* )ALLOC_NONPAGED( ulSize, MTAG_ROUTEQUERY );
            if (!pBuffer)
            {
                TRACE( TL_A, TM_Res, ( "Alloc RQ?" ) );
                WPLOG( LL_A, LM_Res, ( "Alloc RQ?" ) );
                break;
            }

            // Set up a request to the IP stack to fill the buffer with the
            // routing table and send it to the stack.
            //
            KeInitializeEvent(&event, SynchronizationEvent, FALSE);

            pIrp =
                IoBuildDeviceIoControlRequest(
                    IOCTL_TCP_QUERY_INFORMATION_EX,
                    pDeviceObject,
                    (PVOID )&QueryBuf,
                    sizeof(QueryBuf),
                    pBuffer,
                    ulSize,
                    FALSE,
                    &event,
                    &iosb);

            if (!pIrp)
            {
                TRACE( TL_A, TM_Res, ( "Build Q Irp?" ) );
                WPLOG( LL_A, LM_Res, ( "Build Q Irp?" ) );
                break;
            }

            pIrpSp = IoGetNextIrpStackLocation( pIrp );
            pIrpSp->FileObject = pTdix->pAddress;

            status = IoCallDriver( pDeviceObject, pIrp );

            if (status == STATUS_PENDING) {
                KeWaitForSingleObject(&event,
                                      Executive,
                                      KernelMode,
                                      FALSE,
                                      NULL);

                status = iosb.Status;
            }

            if (status != STATUS_BUFFER_OVERFLOW)
            {
                if (status != STATUS_SUCCESS)
                {
                    g_statusLastAhrTcpQueryInfoExFailure = status;
                }
                break;
            }

            // The buffer didn't hold the routing table.  Undo in preparation
            // for another try with twice as big a buffer.
            //
            ulRouteCount <<= 1;
            FREE_NONPAGED( pBuffer );
        }

        if (status != STATUS_SUCCESS)
        {
            TRACE( TL_A, TM_Tdi, ( "AHR Q_INFO_EX=%d?", status ) );
            WPLOG( LL_A, LM_Tdi, ( "AHR Q_INFO_EX=%d?", status ) );
            break;
        }

        status = !STATUS_SUCCESS;

        // Calculate how many routes were loaded into our buffer.
        //
        ulRouteCount = (ULONG )(iosb.Information / sizeof(IPRouteEntry));

        // Walk the route table looking for the "best route" that will be used
        // to route packets to the peer, i.e. the one with the highest
        // priority metric, and within that, the highest class address mask.
        //
        pBestRoute = NULL;
        ulBestMask = 0;
        ulBestMetric = (ULONG )-1;

        for (i = 0, pRouteEntry = pBuffer;
             i < ulRouteCount;
             ++i, ++pRouteEntry)
        {
            if (pRouteEntry->ire_dest == (ulIpAddress & pRouteEntry->ire_mask) &&
                ulIfIndex == pRouteEntry->ire_index)
            {
                // Found a route that applies to peer's IP address.
                //
                if (!pBestRoute
                    || (ulBestMask == pRouteEntry->ire_mask)
                       && (pRouteEntry->ire_metric1 < ulBestMetric))
                {
                    // The route has a lower (higher priority) metric than
                    // anything found so far.
                    //
                    pBestRoute = pRouteEntry;
                    ulBestMask = pRouteEntry->ire_mask;
                    ulBestMetric = pRouteEntry->ire_metric1;
                    continue;
                }

                if (ntohl( pRouteEntry->ire_mask ) > ntohl( ulBestMask ))
                {
                    // The route has a higher address class mask than anything
                    // found so far.
                    //
                    pBestRoute = pRouteEntry;
                    ulBestMask = pRouteEntry->ire_mask;
                    ulBestMetric = pRouteEntry->ire_metric1;
                }
            }
        }

        if (pBestRoute)
        {
            // Found the route that will be used to route peer's address.
            //
            if (pBestRoute->ire_dest == ulIpAddress
                && pBestRoute->ire_mask == 0xFFFFFFFF)
            {
                // The host route already exists.
                //
                if (pTdix->hre == HRE_Use)
                {
                    TRACE( TL_I, TM_Tdi, ( "Route exists (use as is)" ) );
                    status = STATUS_SUCCESS;
                    fUsedNonL2tpRoute = TRUE;
                    break;
                }
                else if (pTdix->hre == HRE_Fail)
                {
                    TRACE( TL_I, TM_Tdi, ( "Route exists (fail)" ) );
                    break;
                }

                // If we reach here then we are in HRE_Reference mode, so drop
                // thru and re-add the route so it's reference in the IP stack
                // will be incremented.
            }

            pTdixRoute->InterfaceIndex = pBestRoute->ire_index;

#if ROUTEWITHREF
            // Allocate a buffer to hold our request to add a new route.
            //
            ulSize = sizeof(IPRouteEntry);
            pBuffer2 = ALLOC_NONPAGED( ulSize, MTAG_ROUTESET );
            if (!pBuffer2)
            {
                TRACE( TL_A, TM_Res, ( "Alloc SI?" ) );
                WPLOG( LL_A, LM_Res, ( "Alloc SI?" ) );
                break;
            }

            // Fill in the request buffer with the information about the new
            // specific route.  The best route is used as a template.
            //
            pNewRouteEntry = (IPRouteEntry* )pBuffer2;
            NdisMoveMemory( pNewRouteEntry, pBestRoute, sizeof(IPRouteEntry) );

            pNewRouteEntry->ire_dest = ulIpAddress;
            pNewRouteEntry->ire_mask = 0xFFFFFFFF;

            // Check DIRECT/INDIRECT only if this is not a host route
            if(pBestRoute->ire_mask != 0xFFFFFFFF)
            {
                if ((pBestRoute->ire_nexthop & pBestRoute->ire_mask)
                     == (ulIpAddress & pBestRoute->ire_mask))
                {
                    pNewRouteEntry->ire_type = IRE_TYPE_DIRECT;
                }
                else
                {
                    pNewRouteEntry->ire_type = IRE_TYPE_INDIRECT;
                }
            }
            pNewRouteEntry->ire_proto = IRE_PROTO_NETMGMT;

            pIpDeviceObject =
                IoGetRelatedDeviceObject( pTdix->pIpStackAddress );

            KeInitializeEvent(&event, SynchronizationEvent, FALSE);

            pIrp =
                IoBuildDeviceIoControlRequest(
                    IOCTL_IP_SET_ROUTEWITHREF,
                    pIpDeviceObject,
                    pNewRouteEntry,
                    ulSize,
                    NULL,
                    0,
                    FALSE,
                    &event,
                    &iosb);
            if (!pIrp)
            {
                TRACE( TL_A, TM_Res, ( "Build SET_ROUTEWITHREF Irp?" ) );
                WPLOG( LL_A, LM_Res, ( "Build SET_ROUTEWITHREF Irp?" ) );
                break;
            }

            pIrpSp = IoGetNextIrpStackLocation( pIrp );
            pIrpSp->FileObject = pTdix->pIpStackAddress;

            // Send the request to the IP stack.
            //
            status = IoCallDriver( pIpDeviceObject, pIrp );
#else
            // Allocate a buffer to hold our request to add a new route.
            //
            ulSize =
                sizeof(TCP_REQUEST_SET_INFORMATION_EX) + sizeof(IPRouteEntry);
            pBuffer2 = ALLOC_NONPAGED( ulSize, MTAG_ROUTESET );
            if (!pBuffer2)
            {
                TRACE( TL_A, TM_Res, ( "Alloc SI?" ) );
                WPLOG( LL_A, LM_Res, ( "Alloc SI?" ) );
                break;
            }

            // Fill in the request buffer with the information about the new
            // specific route.  The best route is used as a template.
            //
            pSetBuf = (TCP_REQUEST_SET_INFORMATION_EX* )pBuffer2;
            NdisZeroMemory( pSetBuf, ulSize );

            pSetBuf->ID.toi_entity.tei_entity = CL_NL_ENTITY;
            pSetBuf->ID.toi_entity.tei_instance = 0;
            pSetBuf->ID.toi_class = INFO_CLASS_PROTOCOL;
            pSetBuf->ID.toi_type = INFO_TYPE_PROVIDER;
            pSetBuf->ID.toi_id = IP_MIB_RTTABLE_ENTRY_ID;
            pSetBuf->BufferSize = sizeof(IPRouteEntry);

            pNewRouteEntry = (IPRouteEntry* )&pSetBuf->Buffer[ 0 ];
            NdisMoveMemory( pNewRouteEntry, pBestRoute, sizeof(IPRouteEntry) );

            pNewRouteEntry->ire_dest = ulIpAddress;
            pNewRouteEntry->ire_mask = 0xFFFFFFFF;

            // Check DIRECT/INDIRECT only if this is not a host route
            if(pBestRoute->ire_mask != 0xFFFFFFFF)
            {
                if ((pBestRoute->ire_nexthop & pBestRoute->ire_mask)
                     == (ulIpAddress & pBestRoute->ire_mask))
                {
                    pNewRouteEntry->ire_type = IRE_TYPE_DIRECT;
                }
                else
                {
                    pNewRouteEntry->ire_type = IRE_TYPE_INDIRECT;
                }
            }
            pNewRouteEntry->ire_proto = IRE_PROTO_NETMGMT;

            KeInitializeEvent(&event, SynchronizationEvent, FALSE);

            pIrp =
                IoBuildDeviceIoControlRequest(
                    IOCTL_TCP_SET_INFORMATION_EX,
                    pDeviceObject,
                    pSetBuf,
                    ulSize,
                    NULL,
                    0,
                    FALSE,
                    &event,
                    &iosb);

            if (!pIrp)
            {
                TRACE( TL_A, TM_Res, ( "Build TCP_SET_INFORMATION_EX Irp?" ) );
                WPLOG( LL_A, LM_Res, ( "Build TCP_SET_INFORMATION_EX Irp?" ) );
                break;
            }

            pIrpSp = IoGetNextIrpStackLocation( pIrp );
            pIrpSp->FileObject = pTdix->pAddress;

            // Send the request to the IP stack.
            //
            status = IoCallDriver( pDeviceObject, pIrp );
#endif
            if (status == STATUS_PENDING) {
                KeWaitForSingleObject(&event,
                                      Executive,
                                      KernelMode,
                                      FALSE,
                                      NULL);
                status = iosb.Status;
            }

            if (status != STATUS_SUCCESS)
            {
                TRACE( TL_A, TM_Tdi, ( "AHR SET_ROUTE=$%08x?", status ) );
                WPLOG( LL_A, LM_Tdi, ( "AHR SET_ROUTE=$%08x?", status ) );
                g_statusLastAhrSetRouteFailure = status;
                break;
            }

            TRACE( TL_N, TM_Tdi,
                ( "Add host route %d.%d.%d.%d type %d nexthop %d.%d.%d.%d index %d",
                IPADDRTRACE( pNewRouteEntry->ire_dest ),
                pNewRouteEntry->ire_type,
                IPADDRTRACE( pNewRouteEntry->ire_nexthop ),
                pNewRouteEntry->ire_index ) );
                
            WPLOG( LL_M, LM_Tdi,
                ( "Add host route %!IPADDR! type %d nexthop %!IPADDR! index %d",
                pNewRouteEntry->ire_dest,
                pNewRouteEntry->ire_type,
                pNewRouteEntry->ire_nexthop,
                pNewRouteEntry->ire_index ) );
                
        }
        else
        {
            ++g_ulNoBestRoute;
            TRACE( TL_A, TM_Tdi, ( "No best route for $%08x?", ulIpAddress ) );
            WPLOG( LL_A, LM_Tdi, ( "No best route for %!IPADDR!?", ulIpAddress ) );
            break;
        }
    }
    while (FALSE);

    if (pBuffer)
    {
        FREE_NONPAGED( pBuffer );
    }

    if (pBuffer2)
    {
        FREE_NONPAGED( pBuffer2 );
    }

    // Update the route context.
    //
    {
        BOOLEAN fDoClose;
        LONG lRefTemp;

        fDoClose = FALSE;
        NdisAcquireSpinLock( &pTdix->lock );
        {
            pTdixRoute->fUsedNonL2tpRoute = fUsedNonL2tpRoute;

            if (status == STATUS_SUCCESS)
            {
                ++g_ulTdixAddHostRouteSuccesses;
                pTdixRoute->fPending = FALSE;
            }
            else
            {
                ++g_ulTdixAddHostRouteFailures;
                RemoveEntryList( &pTdixRoute->linkRoutes );
                lRefTemp = --pTdix->lRef;
                TRACE( TL_A, TM_Tdi, ( "TdixAHR fail, refs=%d", lRefTemp ) );
                if (lRefTemp <= 0)
                {
                    fDoClose = TRUE;
                }
                FREE_TDIXROUTE( pTdxi, pTdixRoute );
                pTdixRoute = NULL;
            }
        }
        NdisReleaseSpinLock( &pTdix->lock );

        if (fDoClose)
        {
            TdixDoClose( pTdix );
        }
    }

    return (pTdixRoute);
}


VOID
TdixDeleteHostRoute(
    IN TDIXCONTEXT* pTdix,
    IN ULONG ulIpAddress)

    // Deletes the host route added for network byte-ordered IP address
    // 'ulIpAddress'.  'PTdix' is caller's TDI extension context.
    //
    // Note: This routine borrows heavily from PPTP.
    //
{
    TCP_REQUEST_QUERY_INFORMATION_EX QueryBuf;
    TCP_REQUEST_SET_INFORMATION_EX *pSetBuf;
    VOID* pBuffer2;
    PIO_STACK_LOCATION pIrpSp;
    PDEVICE_OBJECT pDeviceObject;
    PDEVICE_OBJECT pIpDeviceObject;
    UCHAR context[ CONTEXT_SIZE ];
    NTSTATUS status;
    PIRP pIrp;
    IO_STATUS_BLOCK iosb;
    IPRouteEntry* pBuffer;
    IPRouteEntry* pRouteEntry;
    IPRouteEntry* pNewRouteEntry;
    ULONG ulRouteCount;
    ULONG ulSize;
    ULONG i;
    TDIXROUTE* pTdixRoute;
    BOOLEAN fPending;
    BOOLEAN fDoDelete;
    KEVENT  event;

    TRACE( TL_N, TM_Tdi, ( "TdixDeleteHostRoute(%d.%d.%d.%d)",
        IPADDRTRACE( ulIpAddress ) ) );

    if (!ulIpAddress)
    {
        TRACE( TL_A, TM_Tdi, ( "!IP?" ) );
        return;
    }

    // Host routes are referenced since more than one tunnel to the same peer
    // (allowed by L2TP) shares the same system route.  First, see if this is
    // just a dereference or the final deletion of the system host route.
    //
    for (;;)
    {
        fDoDelete = FALSE;
        fPending = FALSE;

        NdisAcquireSpinLock( &pTdix->lock );
        do
        {
            // These asserts hold because we never delete routes we didn't
            // add, and since the route we added holds a TDIX reference, TDIX
            // cannot be opening or closing.
            //
            ASSERT( pTdix->lRef > 0 );
            ASSERT( !(ReadFlags( &pTdix->ulFlags) & TDIXF_Pending) );

            pTdixRoute = TdixRouteFromIpAddress( pTdix, ulIpAddress );
            if (pTdixRoute)
            {
                // Route exists. Remove a reference.
                //
                fPending = pTdixRoute->fPending;
                if (!fPending)
                {
                    if (--pTdixRoute->lRef <= 0)
                    {
                        // Last "add" reference has been removed so call the
                        // IOCTLs to delete the system route.
                        //
                        pTdixRoute->fPending = TRUE;
                        fDoDelete = TRUE;
                    }
                }
            }
            DBG_else
            {
                ASSERT( FALSE );
            }
        }
        while (FALSE);
        NdisReleaseSpinLock( &pTdix->lock );

        if (fDoDelete)
        {
            // This is the last reference, so go on and issue the IOCTLs to
            // delete the system host route.
            //
            break;
        }

        if (!fPending)
        {
            // Just remove a reference.
            //
            return;
        }

        // An operation is already pending.  Give it some time to finish then
        // check again.
        //
        TRACE( TL_I, TM_Tdi, ( "NdisMSleep(del)" ) );
        NdisMSleep( 100000 );
        TRACE( TL_I, TM_Tdi, ( "NdisMSleep(del)" ) );
    }

    pBuffer = NULL;

    do
    {
        if (pTdixRoute->fUsedNonL2tpRoute)
        {
            // Used a route we didn't add so don't delete it either.
            //
            status = STATUS_SUCCESS;
            break;
        }

        // Get the routing table from the IP stack.  This make take a few
        // iterations since the size of the buffer required is not known.  Set
        // up the static request information first.
        //
        QueryBuf.ID.toi_entity.tei_entity = CL_NL_ENTITY;
        QueryBuf.ID.toi_entity.tei_instance = 0;
        QueryBuf.ID.toi_class = INFO_CLASS_PROTOCOL;
        QueryBuf.ID.toi_type = INFO_TYPE_PROVIDER;
        pDeviceObject = IoGetRelatedDeviceObject( pTdix->pAddress );

        status = !STATUS_SUCCESS;
        ulRouteCount = 20;
        for (;;)
        {
            // Allocate a buffer big enough for 'ulRouteCount' routes.
            //
            ulSize = sizeof(IPRouteEntry) * ulRouteCount;
            QueryBuf.ID.toi_id = IP_MIB_RTTABLE_ENTRY_ID;
            NdisZeroMemory( &QueryBuf.Context, CONTEXT_SIZE );

            pBuffer = (IPRouteEntry* )ALLOC_NONPAGED( ulSize, MTAG_ROUTEQUERY );
            if (!pBuffer)
            {
                TRACE( TL_A, TM_Res, ( "Alloc RQ?" ) );
                WPLOG( LL_A, LM_Res, ( "Alloc RQ?" ) );
                break;
            }

            // Set up a request to the IP stack to fill the buffer with the
            // routing table and send it to the stack.
            //
            KeInitializeEvent(&event, SynchronizationEvent, FALSE);

            pIrp = IoBuildDeviceIoControlRequest(
                IOCTL_TCP_QUERY_INFORMATION_EX,
                pDeviceObject,
                (PVOID )&QueryBuf,
                sizeof(QueryBuf),
                pBuffer,
                ulSize,
                FALSE,
                &event,
                &iosb );

            if (!pIrp)
            {
                TRACE( TL_A, TM_Res, ( "TCP_QI Irp?" ) );
                WPLOG( LL_A, LM_Res, ( "TCP_QI Irp?" ) );
                break;
            }

            pIrpSp = IoGetNextIrpStackLocation( pIrp );
            pIrpSp->FileObject = pTdix->pAddress;

            status = IoCallDriver( pDeviceObject, pIrp );

            if (status == STATUS_PENDING) {
                KeWaitForSingleObject(&event,
                                      Executive,
                                      KernelMode,
                                      FALSE,
                                      NULL);

                status = iosb.Status;
            }

            if (status != STATUS_BUFFER_OVERFLOW)
            {
                if (status != STATUS_SUCCESS)
                {
                    TRACE( TL_A, TM_Tdi, ( "DHR Q_INFO_EX=%d?", status ) );
                    WPLOG( LL_A, LM_Tdi, ( "DHR Q_INFO_EX=%d?", status ) );
                    g_statusLastDhrTcpQueryInfoExFailure = status;
                }
                break;
            }

            // The buffer didn't hold the routing table.  Undo in preparation for
            // another try with twice as big a buffer.
            //
            ulRouteCount <<= 1;
            FREE_NONPAGED( pBuffer );
        }

        if (status != STATUS_SUCCESS)
        {
            break;
        }

        // Calculate how many routes were loaded into our buffer.
        //
        ulRouteCount = (ULONG )(iosb.Information / sizeof(IPRouteEntry));

        // Walk the route table looking for the route we added in
        // TdixAddHostRoute.
        //
        status = !STATUS_SUCCESS;
        pBuffer2 = NULL;
        for (i = 0, pRouteEntry = pBuffer;
             i < ulRouteCount;
             ++i, ++pRouteEntry)
        {
            if (pRouteEntry->ire_dest == ulIpAddress
                && pRouteEntry->ire_proto == IRE_PROTO_NETMGMT)
            {
#if ROUTEWITHREF
                // Found the added route.  Allocate a buffer to hold our
                // request to delete the route.
                //
                ulSize = sizeof(IPRouteEntry);
                pBuffer2 = ALLOC_NONPAGED( ulSize, MTAG_ROUTESET );
                if (!pBuffer2)
                {
                    TRACE( TL_A, TM_Res, ( "Failed to allocate IPRouteEntry" ) );
                    WPLOG( LL_A, LM_Res, ( "Failed to allocate IPRouteEntry" ) );
                    break;
                }

                // Use the found route as a template for the route entry
                // marked for deletion.
                //
                pNewRouteEntry = (IPRouteEntry* )pBuffer2;
                NdisMoveMemory(
                    pNewRouteEntry, pRouteEntry, sizeof(IPRouteEntry) );
                pNewRouteEntry->ire_type = IRE_TYPE_INVALID;

                pIpDeviceObject =
                    IoGetRelatedDeviceObject( pTdix->pIpStackAddress );

                KeInitializeEvent(&event, SynchronizationEvent, FALSE);

                pIrp = IoBuildDeviceIoControlRequest(
                    IOCTL_IP_SET_ROUTEWITHREF,
                    pIpDeviceObject,
                    pNewRouteEntry,
                    ulSize,
                    NULL,
                    0,
                    FALSE,
                    &event,
                    &iosb);

                if (!pIrp)
                {
                    TRACE( TL_A, TM_Res, ( "TCP_SI Irp?" ) );
                    WPLOG( LL_A, LM_Res, ( "TCP_SI Irp?" ) );
                    break;
                }

                pIrpSp = IoGetNextIrpStackLocation( pIrp );
                pIrpSp->FileObject = pTdix->pIpStackAddress;

                // Send the request to the IP stack.
                //
                status = IoCallDriver( pIpDeviceObject, pIrp );
#else
                // Found the added route.  Allocate a buffer to hold our
                // request to delete the route.
                //
                ulSize = sizeof(TCP_REQUEST_SET_INFORMATION_EX)
                    + sizeof(IPRouteEntry);
                pBuffer2 = ALLOC_NONPAGED( ulSize, MTAG_ROUTESET );
                if (!pBuffer2)
                {
                    TRACE( TL_A, TM_Res, ( "!pSetBuf" ) );
                    WPLOG( LL_A, LM_Res, ( "!pSetBuf" ) );
                    break;
                }

                // Fill in the request buffer with static information about
                // changing routes.
                //
                pSetBuf = (TCP_REQUEST_SET_INFORMATION_EX *)pBuffer2;
                NdisZeroMemory( pSetBuf, ulSize );

                pSetBuf->ID.toi_entity.tei_entity = CL_NL_ENTITY;
                pSetBuf->ID.toi_entity.tei_instance = 0;
                pSetBuf->ID.toi_class = INFO_CLASS_PROTOCOL;
                pSetBuf->ID.toi_type = INFO_TYPE_PROVIDER;
                pSetBuf->ID.toi_id = IP_MIB_RTTABLE_ENTRY_ID;
                pSetBuf->BufferSize = sizeof(IPRouteEntry);

                // Use the found route as a template for the route entry marked
                // for deletion.
                //
                pNewRouteEntry = (IPRouteEntry* )&pSetBuf->Buffer[ 0 ];
                NdisMoveMemory(
                    pNewRouteEntry, pRouteEntry, sizeof(IPRouteEntry) );
                pNewRouteEntry->ire_type = IRE_TYPE_INVALID;

                KeInitializeEvent(&event, SynchronizationEvent, FALSE);

                pIrp = IoBuildDeviceIoControlRequest(
                    IOCTL_TCP_SET_INFORMATION_EX,
                    pDeviceObject,
                    pSetBuf,
                    ulSize,
                    NULL,
                    0,
                    FALSE,
                    &event,
                    &iosb);

                if (!pIrp)
                {
                    TRACE( TL_A, TM_Res, ( "TCP_SI Irp?" ) );
                    WPLOG( LL_A, LM_Res, ( "TCP_SI Irp?" ) );
                    break;
                }

                pIrpSp = IoGetNextIrpStackLocation( pIrp );
                pIrpSp->FileObject = pTdix->pAddress;

                // Send the request to the IP stack.
                //
                status = IoCallDriver( pDeviceObject, pIrp );
#endif
                if (status == STATUS_PENDING) {
                    KeWaitForSingleObject(&event,
                                          Executive,
                                          KernelMode,
                                          FALSE,
                                          NULL);
                    status = iosb.Status;
                }

                if (status != STATUS_SUCCESS)
                {
                    TRACE( TL_A, TM_Tdi, ( "DHR SET_ROUTE=%d?", status ) );
                    WPLOG( LL_A, LM_Tdi, ( "DHR SET_ROUTE=%d?", status ) );
                    g_statusLastDhrSetRouteFailure = status;
                    break;
                }

                break;
            }
        }

        if (pBuffer2)
        {
            FREE_NONPAGED( pBuffer2 );
        }

        TRACE( TL_V, TM_Tdi, ( "TdixDeleteHostRoute done" ) );
    }
    while (FALSE);

    if (pBuffer)
    {
        FREE_NONPAGED( pBuffer );
    }

    if (pTdixRoute->fUsePayloadAddr) {

        ASSERT(pTdixRoute->hPayloadAddr != NULL);

        ObDereferenceObject( pTdixRoute->pPayloadAddr );

        // Close the payload address object
        //
        ZwClose(pTdixRoute->hPayloadAddr);
        pTdixRoute->hPayloadAddr = NULL;
        pTdixRoute->fUsePayloadAddr = FALSE;
    }

    if (pTdixRoute->hCtrlAddr != NULL) {

        // Close the Ctrl address object
        //
        ObDereferenceObject( pTdixRoute->pCtrlAddr );
        ZwClose (pTdixRoute->hCtrlAddr);
        pTdixRoute->hCtrlAddr = NULL;
    }

    // Remove the route context effectively unpending the operation.
    //
    {
        BOOLEAN fDoClose;
        LONG lRef;

        fDoClose = FALSE;
        NdisAcquireSpinLock( &pTdix->lock );
        {
            if (status == STATUS_SUCCESS)
            {
                ++g_ulTdixDeleteHostRouteSuccesses;
            }
            else
            {
                ++g_ulTdixDeleteHostRouteFailures;
            }

            ASSERT( pTdixRoute->lRef == 0 );
            RemoveEntryList( &pTdixRoute->linkRoutes );

            lRef = --pTdix->lRef;
            TRACE( TL_N, TM_Tdi, ( "TdixDHR, refs=%d", lRef ) );
            if (lRef == 0)
            {
                fDoClose = TRUE;
            }

            FREE_TDIXROUTE( pTdix, pTdixRoute );
        }
        NdisReleaseSpinLock( &pTdix->lock );

        if (fDoClose)
        {
            TdixDoClose( pTdix );
        }
    }
}

NTSTATUS 
TdixGetInterfaceInfo(
    IN TDIXCONTEXT* pTdix,
    IN ULONG ulIpAddress,
    OUT PULONG pulSpeed)
{
    TCP_REQUEST_QUERY_INFORMATION_EX QueryBuf;
    PDEVICE_OBJECT pDeviceObject;
    NTSTATUS status;
    PIRP pIrp;
    PIO_STACK_LOCATION pIrpSp;
    IO_STATUS_BLOCK iosb;
    UCHAR pBuffer[256];
    KEVENT event;
    IPInterfaceInfo* pInterfaceInfo;

    // Get the routing table from the IP stack.  This make take a few
    // iterations since the size of the buffer required is not known.  Set
    // up the static request information first.
    //
    QueryBuf.ID.toi_entity.tei_entity = CL_NL_ENTITY;
    QueryBuf.ID.toi_entity.tei_instance = 0;
    QueryBuf.ID.toi_class = INFO_CLASS_PROTOCOL;
    QueryBuf.ID.toi_type = INFO_TYPE_PROVIDER;
    QueryBuf.ID.toi_id = IP_INTFC_INFO_ID;
    *(ULONG *)QueryBuf.Context = ulIpAddress;

    pDeviceObject = IoGetRelatedDeviceObject( pTdix->pAddress );
    
    // Set up a request to the IP stack to fill the buffer with the
    // routing table and send it to the stack.
    KeInitializeEvent(&event, SynchronizationEvent, FALSE);

    pIrp =
        IoBuildDeviceIoControlRequest(
            IOCTL_TCP_QUERY_INFORMATION_EX,
            pDeviceObject,
            (PVOID )&QueryBuf,
            sizeof(QueryBuf),
            pBuffer,
            sizeof(pBuffer),
            FALSE,
            &event,
            &iosb);

    if (!pIrp)
    {
        TRACE( TL_A, TM_Res, ( "Build Q Irp?" ) );
        WPLOG( LL_A, LM_Res, ( "Build Q Irp?" ) );
        return NDIS_STATUS_RESOURCES;
    }

    pIrpSp = IoGetNextIrpStackLocation( pIrp );
    pIrpSp->FileObject = pTdix->pAddress;

    status = IoCallDriver( pDeviceObject, pIrp );

    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&event,
                              Executive,
                              KernelMode,
                              FALSE,
                              NULL);

        status = iosb.Status;
    }

    if (status == STATUS_SUCCESS)
    {
        *pulSpeed = ((IPInterfaceInfo *)pBuffer)->iii_speed;
    }

    return status;
}

//-----------------------------------------------------------------------------
// Local utility routines (alphabetically)
//-----------------------------------------------------------------------------

NTSTATUS
TdixSetTdiAOOption(
    IN FILE_OBJECT* pAddress,
    IN ULONG ulOption,
    IN ULONG ulValue)

    // Turn off UDP checksums on open UDP address object 'pAddress'.
    //
{
    NTSTATUS status;
    PDEVICE_OBJECT pDeviceObject;
    PIO_STACK_LOCATION pIrpSp;
    IO_STATUS_BLOCK iosb;
    PIRP pIrp;
    TCP_REQUEST_SET_INFORMATION_EX* pInfo;
    CHAR achBuf[ sizeof(*pInfo) + sizeof(ULONG) ];

    pInfo = (TCP_REQUEST_SET_INFORMATION_EX* )achBuf;
    pInfo->ID.toi_entity.tei_entity = CL_TL_ENTITY;
    pInfo->ID.toi_entity.tei_instance = 0;
    pInfo->ID.toi_class = INFO_CLASS_PROTOCOL;
    pInfo->ID.toi_type = INFO_TYPE_ADDRESS_OBJECT;
    pInfo->ID.toi_id = ulOption;

    NdisMoveMemory( pInfo->Buffer, &ulValue, sizeof(ulValue) );
    pInfo->BufferSize = sizeof(ulValue);

    pDeviceObject = IoGetRelatedDeviceObject( pAddress );

    pIrp = IoBuildDeviceIoControlRequest(
        IOCTL_TCP_WSH_SET_INFORMATION_EX,
        pDeviceObject,
        (PVOID )pInfo,
        sizeof(*pInfo) + sizeof(ulValue),
        NULL,
        0,
        FALSE,
        NULL,
        &iosb );

    if (!pIrp)
    {
        TRACE( TL_A, TM_Res, ( "TdixSetTdiAOOption Irp?" ) );
        WPLOG( LL_A, LM_Res, ( "TdixSetTdiAOOption Irp?" ) );
        return NDIS_STATUS_RESOURCES;
    }

    pIrpSp = IoGetNextIrpStackLocation( pIrp );
    pIrpSp->FileObject = pAddress;

    status = IoCallDriver( pDeviceObject, pIrp );

    if(NT_SUCCESS(status))
    {
        status = iosb.Status;
    }

    return status;
}


VOID
TdixDisableUdpChecksums(
    IN FILE_OBJECT* pAddress )

    // Turn off UDP checksums on open UDP address object 'pAddress'.
    //
{
    NTSTATUS status;

    status = TdixSetTdiAOOption(pAddress, AO_OPTION_XSUM, FALSE);

    TRACE( TL_I, TM_Tdi, ( "Disable XSUMs($%p)=$%08x",
        pAddress, status ) );
}

VOID
TdixEnableIpPktInfo(
    IN FILE_OBJECT* pAddress )

    // Turn on IP_PKTINFO on open UDP address object 'pAddress'.
    //
{
    NTSTATUS status;

    status = TdixSetTdiAOOption(pAddress, AO_OPTION_IP_PKTINFO, TRUE);

    TRACE( TL_I, TM_Tdi, ( "Enable IP_PKTINFO ($%p)=$%08x",
        pAddress, status ) );
}

VOID
TdixEnableIpHdrIncl(
    IN FILE_OBJECT* pAddress )

    // Turn on IP_HDRINCL on raw IP address object.
    //
{
    NTSTATUS status;

    status = TdixSetTdiAOOption(pAddress, AO_OPTION_IP_HDRINCL, TRUE);

    TRACE( TL_I, TM_Tdi, ( "Enable IP_HDRINCL($%p)=$%08x",
        pAddress, status ) );
}

VOID
TdixDoClose(
    TDIXCONTEXT* pTdix )

    // Called when 'pTdix->lRef' reaches 0 to close down the TDI session.
    // 'PTdix' is the transport context for the session.
    //
{
    TRACE( TL_N, TM_Tdi, ( "TdixDoClose" ) );

    if (pTdix->pAddress)
    {
        // Install a NULL handler, effectively uninstalling.
        //
        TdixInstallEventHandler( pTdix->pAddress,
            TDI_EVENT_RECEIVE_DATAGRAM, NULL, pTdix );

        ObDereferenceObject( pTdix->pAddress );
        pTdix->pAddress = NULL;

        // If have a valid transport address, the lookaside lists were also
        // initialized.
        //
        NdisDeleteNPagedLookasideList( &pTdix->llistRdg );
        NdisDeleteNPagedLookasideList( &pTdix->llistSdg );
    }

    if (pTdix->hAddress)
    {
        ZwClose( pTdix->hAddress );
        pTdix->hAddress = NULL;
    }
    
    if (pTdix->hRawAddress)
    {
        ZwClose( pTdix->hRawAddress );
        pTdix->hRawAddress = NULL;
    }
    

#if ROUTEWITHREF
    if (pTdix->hIpStackAddress)
    {
        ZwClose( pTdix->hIpStackAddress );
        pTdix->hIpStackAddress = NULL;
    }
#endif

    if (pTdix->pIpStackAddress)
    {
        ObDereferenceObject( pTdix->pIpStackAddress );
        pTdix->pIpStackAddress = NULL;
    }

    // Mark the operation complete.
    //
    NdisAcquireSpinLock( &pTdix->lock );
    {
        ASSERT( pTdix->lRef == 0 );
        ClearFlags( &pTdix->ulFlags, TDIXF_Pending );
    }
    NdisReleaseSpinLock( &pTdix->lock );
}

VOID
TdixExtractAddress(
    IN TDIXCONTEXT* pTdix,
    OUT TDIXRDGINFO* pRdg,
    IN VOID* pTransportAddress,
    IN LONG lTransportAddressLen,
    IN VOID* Options,
    IN LONG OptionsLength)
    // Fills callers '*pAddress' with the useful part of the transport address
    // 'pTransportAddress' of length 'lTransportAddressLen'.  'PTdix' is our
    // context.
    //
{
    TDIXIPADDRESS* pAddress = &pRdg->source;
    TA_IP_ADDRESS* pTAddress = (TA_IP_ADDRESS* )pTransportAddress;

    ASSERT( lTransportAddressLen == sizeof(TA_IP_ADDRESS) );
    ASSERT( pTAddress->TAAddressCount == 1 );
    ASSERT( pTAddress->Address[ 0 ].AddressType == TDI_ADDRESS_TYPE_IP );
    ASSERT( pTAddress->Address[ 0 ].AddressLength == TDI_ADDRESS_LENGTH_IP );

    // source address   
    pAddress->ulIpAddress = pTAddress->Address[ 0 ].Address[ 0 ].in_addr;
    pAddress->sUdpPort = pTAddress->Address[ 0 ].Address[ 0 ].sin_port;

    // dest address
    if(Options) 
    {
        IN_PKTINFO* pktinfo = (IN_PKTINFO*)TDI_CMSG_DATA(Options);

        ASSERT(((PTDI_CMSGHDR)Options)->cmsg_type == IP_PKTINFO);

        // Fill in the ancillary data object header information.
        pRdg->dest.ulIpAddress = pktinfo->ipi_addr;

        // Get the index of the local interface on which the packet arrived.
        pRdg->dest.ifindex = pktinfo->ipi_ifindex;
    } 
}


NTSTATUS
TdixInstallEventHandler(
    IN FILE_OBJECT* pAddress,
    IN INT nEventType,
    IN VOID* pfuncEventHandler,
    IN VOID* pEventContext )

    // Install a TDI event handler routine 'pfuncEventHandler' to be called
    // when events of type 'nEventType' occur.  'PEventContext' is passed to
    // the handler.  'PAddress' is the transport address object.
    //
    // This call must be made at PASSIVE IRQL.
    //
    // Returns 0 if successful or an error code.
    //
{
    NTSTATUS status;
    PIRP pIrp;

    TRACE( TL_N, TM_Tdi, ( "TdixInstallEventHandler" ) );

    // Allocate a "set event" IRP with base initialization.
    //
    pIrp =
        TdiBuildInternalDeviceControlIrp(
            TDI_SET_EVENT_HANDLER,
            pAddress->DeviceObject,
            pAddress,
            NULL,
            NULL );

    if (!pIrp)
    {
        TRACE( TL_A, TM_Res, ( "TdiBuildIDCIrp?" ) );
        WPLOG( LL_A, LM_Res, ( "TdiBuildIDCIrp?" ) );
        return NDIS_STATUS_RESOURCES;
    }

    // Complete the "set event" IRP initialization.
    //
    TdiBuildSetEventHandler(
        pIrp,
        pAddress->DeviceObject,
        pAddress,
        NULL,
        NULL,
        nEventType,
        pfuncEventHandler,
        pEventContext );

    // Tell the I/O manager to pass our IRP to the transport for processing.
    //
    status = IoCallDriver( pAddress->DeviceObject, pIrp );
    if (status != STATUS_SUCCESS)
    {
        TRACE( TL_A, TM_Tdi, ( "IoCallDriver=$%08x?", status ) );
        WPLOG( LL_A, LM_Tdi, ( "IoCallDriver=$%08x?", status ) );
        return status;
    }

    TRACE( TL_V, TM_Tdi, ( "TdixInstallEventHandler=0" ) );
    return STATUS_SUCCESS;
}


NTSTATUS
TdixOpenIpAddress(
    IN UNICODE_STRING* puniDevice,
    IN TDIXIPADDRESS* pTdixAddr,
    OUT HANDLE* phAddress,
    OUT FILE_OBJECT** ppFileObject )

    // Open a transport address for the IP-based protocol with name
    // '*puniDevice' and port 'sPort'.  'SPort' may be 0 indicating "any"
    // port.  "Any" address is assumed.  Loads the open address object handle
    // into '*phAddress' and the referenced file object into '*ppFileObject'.
    //
    // Returns STATUS_SUCCESS or an error code.
    //
{
    NTSTATUS status;
    OBJECT_ATTRIBUTES oa;
    IO_STATUS_BLOCK iosb;
    FILE_FULL_EA_INFORMATION *pEa;
    ULONG ulEaLength;
    TA_IP_ADDRESS UNALIGNED *pTaIp;
    TDI_ADDRESS_IP UNALIGNED *pTdiIp;
    CHAR achEa[ 100 ];
    HANDLE hAddress;
    FILE_OBJECT* pFileObject;

    hAddress = NULL;
    pFileObject = NULL;

    // Initialize object attributes, a parameter needed to open the device.
    //
    InitializeObjectAttributes(
        &oa, puniDevice, OBJ_CASE_INSENSITIVE, NULL, NULL );

    // Set up the extended attribute that tells the IP stack the IP
    // address/port from which we want to receive.  For raw IP we say "any
    // address and port" and for UDP we say "any address on the L2TP
    // port".  Is this an ugly structure or what?
    //
    ASSERT( sizeof(FILE_FULL_EA_INFORMATION)
        + TDI_TRANSPORT_ADDRESS_LENGTH + sizeof(TA_IP_ADDRESS) <= 100);

    pEa = (FILE_FULL_EA_INFORMATION* )achEa;
    pEa->NextEntryOffset = 0;
    pEa->Flags = 0;
    pEa->EaNameLength = TDI_TRANSPORT_ADDRESS_LENGTH;
    pEa->EaValueLength = sizeof(TA_IP_ADDRESS);
    NdisMoveMemory(
        pEa->EaName, TdiTransportAddress, TDI_TRANSPORT_ADDRESS_LENGTH );

    // Note: The ZwCreateFile wants the sized name to have a null
    //       terminator character (go figure), so add it and account for
    //       it with the "+ 1" below.
    //
    pEa->EaName[ TDI_TRANSPORT_ADDRESS_LENGTH ] = '\0';

    pTaIp = (TA_IP_ADDRESS UNALIGNED* )
        (pEa->EaName + TDI_TRANSPORT_ADDRESS_LENGTH + 1);
    pTaIp->TAAddressCount = 1;
    pTaIp->Address[ 0 ].AddressLength = TDI_ADDRESS_LENGTH_IP;
    pTaIp->Address[ 0 ].AddressType = TDI_ADDRESS_TYPE_IP;

    pTdiIp = &pTaIp->Address[ 0 ].Address[ 0 ];
    pTdiIp->sin_port = pTdixAddr->sUdpPort;
    pTdiIp->in_addr = pTdixAddr->ulIpAddress;
    NdisZeroMemory( pTdiIp->sin_zero, sizeof(pTdiIp->sin_zero) );

    ulEaLength = (ULONG )((CHAR* )(pTaIp + 1) - (CHAR* )pEa);

    // Open the transport address.
    //
    status =
        ZwCreateFile(
            &hAddress,
            FILE_READ_DATA | FILE_WRITE_DATA,
            &oa,
            &iosb,
            NULL,
            FILE_ATTRIBUTE_NORMAL,
            FILE_SHARE_WRITE,
            FILE_OPEN,
            0,
            pEa,
            ulEaLength );

    if (status != STATUS_SUCCESS)
    {
        TRACE( TL_A, TM_Tdi, ( "ZwCreateFile(%S)=$%08x,ios=$%x?",
            puniDevice->Buffer, status, iosb.Information ) );
        WPLOG( LL_A, LM_Tdi, ( "ZwCreateFile(%S)=$%08x",
            puniDevice->Buffer, status) );
        return status;
    }

    // Get the object address from the handle.  This also checks our
    // permissions on the object.
    //
    status =
        ObReferenceObjectByHandle(
            hAddress,
            0,
            NULL,
            KernelMode,
            &pFileObject,
            NULL );

    if (status != STATUS_SUCCESS)
    {
        TRACE( TL_A, TM_Tdi,
            ( "ObRefObjByHandle(%S)=$%08x?", puniDevice->Buffer, status ) );
        WPLOG( LL_A, LM_Tdi,
            ( "ObRefObjByHandle(%S)=$%08x?", puniDevice->Buffer, status ) );
        ZwClose( hAddress );
        return status;
    }

    *phAddress = hAddress;
    *ppFileObject = pFileObject;
    return STATUS_SUCCESS;
}


NTSTATUS
TdixReceiveDatagramHandler(
    IN PVOID TdiEventContext,
    IN LONG SourceAddressLength,
    IN PVOID SourceAddress,
    IN LONG OptionsLength,
    IN PVOID Options,
    IN ULONG ReceiveDatagramFlags,
    IN ULONG BytesIndicated,
    IN ULONG BytesAvailable,
    OUT ULONG* BytesTaken,
    IN PVOID Tsdu,
    OUT PIRP* IoRequestPacket )

    // Standard TDI ClientEventReceiveDatagram indication handler.  See TDI
    // doc.  Runs at DISPATCH IRQL.
    //
{
    TDIXCONTEXT* pTdix;
    TDIXRDGINFO* pRdg;
    CHAR* pBuffer;
    NDIS_BUFFER* pNdisBuffer;
    PIRP pIrp;

    TRACE( TL_N, TM_Tdi, ( "TdixRecvDg, f=$%08x bi=%d, ba=%d",
        ReceiveDatagramFlags, BytesIndicated, BytesAvailable ) );


    if (BytesAvailable > L2TP_FrameBufferSize) {

        // We received a larger datagram then expected or can handle,
        // so we just ignore the datagram.
        //
        ASSERT( !"BytesAvailable > L2TP_FrameBufferSize?" );
        *IoRequestPacket = NULL;
        *BytesTaken = 0;
        return STATUS_SUCCESS;
    }

    pTdix = (TDIXCONTEXT* )TdiEventContext;

    // Allocate a receive pBuffer from TDIX client's pool.
    //
    pBuffer = GetBufferFromPool( pTdix->pPoolNdisBuffers );
    if (!pBuffer)
    {
        // Not a whole lot we can do with this unlikely error from inside this
        // handler, so we just ignore the datagram.
        //
        return STATUS_SUCCESS;
    }

    // Allocate a context for this read-datagram from our lookaside list.
    //
    pRdg = ALLOC_TDIXRDGINFO( pTdix );
    if (pRdg)
    {
        // Fill in the read-datagram context with the information that won't
        // otherwise be available in the completion routine.
        //
        pRdg->pTdix = pTdix;
        pRdg->pBuffer = pBuffer;
        pRdg->ulBufferLen = BytesAvailable;

        // Extract the useful IP address from the more general transport
        // address information.
        //

        TdixExtractAddress(
            pTdix, pRdg, SourceAddress, SourceAddressLength, Options, OptionsLength);
    }
    else
    {
        // Not a whole lot we can do with this unlikely error from inside this
        // handler, so we just ignore the datagram.
        //
        FreeBufferToPool( pTdix->pPoolNdisBuffers, pBuffer, TRUE );
        return STATUS_SUCCESS;
    }

    if (BytesIndicated < BytesAvailable)
    {
        // The less common case where all the information is not immediately
        // available.  Allocate an IRP to request the data.
        //
#if ALLOCATEIRPS
        // Allocate the IRP directly.
        //
        pIrp = IoAllocateIrp(
            pTdix->pAddress->DeviceObject->StackSize, FALSE );
#else
        // Allocate a "receive datagram" IRP with base initialization.
        //
        pIrp =
            TdiBuildInternalDeviceControlIrp(
                TDI_RECEIVE_DATAGRAM,
                pTdix->pAddress->DeviceObject,
                pTdix->pAddress,
                NULL,
                NULL );
#endif

        if (!pIrp)
        {
            // Not a whole lot we can do with this unlikely error from inside
            // this handler, so we just ignore the datagram.
            //
            FreeBufferToPool( pTdix->pPoolNdisBuffers, pBuffer, TRUE );
            FREE_TDIXRDGINFO( pTdix, pRdg );
            return STATUS_SUCCESS;
        }

        pNdisBuffer = NdisBufferFromBuffer( pBuffer );

        // Complete the "receive datagram" IRP initialization.
        //
        TdiBuildReceiveDatagram(
            pIrp,
            pTdix->pAddress->DeviceObject,
            pTdix->pAddress,
            TdixReceiveDatagramComplete,
            pRdg,
            pNdisBuffer,
            0,
            NULL,
            NULL,
            0 );

        // Adjust the IRP's stack location to make the transport's stack
        // current.  Normally IoCallDriver handles this, but this IRP doesn't
        // go thru IoCallDriver.  Seems like it would be the transport's job
        // to make this adjustment, but IP for one doesn't seem to do it.
        // There is a similar adjustment in both the redirector and PPTP.
        //
        IoSetNextIrpStackLocation( pIrp );

        *IoRequestPacket = pIrp;
        *BytesTaken = 0;

        return STATUS_MORE_PROCESSING_REQUIRED;
    }
    else
    {
        // The common case where all the information is immediately available.
        // Copy it to from the transport buffer and call client's completion
        // handler directly.  See bug 329371.
        //
        NdisMoveMemory( pBuffer, (CHAR* )Tsdu, BytesIndicated );
        TdixReceiveDatagramComplete( NULL, NULL, pRdg );

        *IoRequestPacket = NULL;
        *BytesTaken = BytesIndicated;

        return STATUS_SUCCESS;
    }

    // Not reached.
}


NTSTATUS
TdixReceiveDatagramComplete(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context )

    // Standard NT I/O completion routine.  See DDK doc.  Called with a NULL
    // 'DeviceObject' and 'Irp' to complete the fast-past Irp-less receives.
    //
{
    TDIXRDGINFO* pRdg;
    BOOLEAN fBad;
    ULONG ulOffset;

    pRdg = (TDIXRDGINFO* )Context;

    TRACE( TL_N, TM_Tdi, ( "TdixRecvDgComp" ) );

    fBad = FALSE;
    ulOffset = 0;

    if (pRdg->pTdix->mediatype == TMT_RawIp)
    {
        UCHAR uchVersion;

        // The raw IP stack doesn't strip the IP header from the received
        // datagram for some reason, so calculate the offset to the "real"
        // data at the end of the IP header.
        //
        uchVersion = *((UCHAR* )pRdg->pBuffer) >> 4;
        if (uchVersion == 4)
        {
            // Good, it's IP version 4.  Find the length of the IP header,
            // which can vary depending on the presence of option fields.
            //
            ulOffset = (*((UCHAR* )pRdg->pBuffer) & 0x0F) * sizeof(ULONG);
        }
        else
        {
            // It's not IP version 4, the only version we handle.
            //
            TRACE( TL_A, TM_Tdi, ( "Not IPv4? v=%d?", (ULONG )uchVersion ) );
            WPLOG( LL_A, LM_Tdi, ( "Not IPv4? v=%d?", (ULONG )uchVersion ) );
            fBad = TRUE;
        }
    }

    if (!fBad && (!Irp || Irp->IoStatus.Status == STATUS_SUCCESS))
    {
        // Pass the result to the TDIX client's handler.
        //
        pRdg->pTdix->pReceiveHandler(
            pRdg->pTdix,
            pRdg,
            pRdg->pBuffer,
            ulOffset,
            pRdg->ulBufferLen );
    }

    // Free the read-datagram context.
    //
    FREE_TDIXRDGINFO( pRdg->pTdix, pRdg );

#if ALLOCATEIRPS
    // Release the IRP resources, if any, and tell the I/O manager to forget
    // it existed in the standard way.
    //
    if (Irp)
    {
        IoFreeIrp( Irp );
        return STATUS_MORE_PROCESSING_REQUIRED;
    }
#endif

    // Let the I/O manager release the IRP resources, if any.
    //
    return STATUS_SUCCESS;
}


TDIXROUTE*
TdixRouteFromIpAddress(
    IN TDIXCONTEXT* pTdix,
    IN ULONG ulIpAddress)

    // Returns the host route context associated with IP address 'ulIpAddress'
    // from the TDIX context 'pTdix's list of host routes, or NULL if none.
    // 'UlIpAddress' is in network byte order.
    //
    // IMPORTANT:  The caller must hold 'pTdix->lock'.
    //
{
    LIST_ENTRY* pLink;

    for (pLink = pTdix->listRoutes.Flink;
         pLink != &pTdix->listRoutes;
         pLink = pLink->Flink)
    {
        TDIXROUTE* pRoute;

        pRoute = CONTAINING_RECORD( pLink, TDIXROUTE, linkRoutes );
        if (pRoute->ulIpAddress == ulIpAddress)
        {
            return pRoute;
        }
    }

    return NULL;
}


NTSTATUS
TdixSendComplete(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context )

    // Standard NT I/O completion routine.  See DDK doc.
    //
{
    TDIXSDGINFO* pSdg;

    if (Irp->IoStatus.Status != STATUS_SUCCESS)
    {
        TRACE( TL_A, TM_Tdi, ( "TdixSendComp, s=$%08x?",
            Irp->IoStatus.Status ) );
        WPLOG( LL_A, LM_Tdi, ( "TdixSendComp, s=$%08x?",
            Irp->IoStatus.Status ) );
    }

    pSdg = (TDIXSDGINFO* )Context;

    // Pass the result to the TDIX client's handler.
    //
    pSdg->pSendCompleteHandler(
        pSdg->pTdix, pSdg->pContext1, pSdg->pContext2, pSdg->pBuffer );

    // Free the send-complete context.
    //
    FREE_TDIXSDGINFO( pSdg->pTdix, pSdg );

#if ALLOCATEIRPS
    // Release the IRP resources and tell the I/O manager to forget it existed
    // in the standard way.
    //
    IoFreeIrp( Irp );
    return STATUS_MORE_PROCESSING_REQUIRED;
#else
    // Let the I/O manager release the IRP resources.
    //
    return STATUS_SUCCESS;
#endif
}

NTSTATUS
TdixSendDatagramComplete(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context )

    // Standard NT I/O completion routine.  See DDK doc.
    //
{
    TDIXSDGINFO* pSdg;

    if (Irp->IoStatus.Status != STATUS_SUCCESS)
    {
        TRACE( TL_A, TM_Tdi, ( "TdixSendDgComp, s=$%08x?",
            Irp->IoStatus.Status ) );
        WPLOG( LL_A, LM_Tdi, ( "TdixSendDgComp, s=$%08x?",
            Irp->IoStatus.Status ) );
    }

    pSdg = (TDIXSDGINFO* )Context;

    // Pass the result to the TDIX client's handler.
    //
    pSdg->pSendCompleteHandler(
        pSdg->pTdix, pSdg->pContext1, pSdg->pContext2, pSdg->pBuffer );

    // Free the send-complete context.
    //
    FREE_TDIXSDGINFO( pSdg->pTdix, pSdg );

#if ALLOCATEIRPS
    // Release the IRP resources and tell the I/O manager to forget it existed
    // in the standard way.
    //
    IoFreeIrp( Irp );
    return STATUS_MORE_PROCESSING_REQUIRED;
#else
    // Let the I/O manager release the IRP resources.
    //
    return STATUS_SUCCESS;
#endif
}

NTSTATUS
TdixConnectAddrInterface(
    FILE_OBJECT* pFileObj,
    HANDLE hFileHandle,
    TDIXROUTE* pTdixRoute
    )
{
    NTSTATUS status;
    PDEVICE_OBJECT pDeviceObj;
    PIO_STACK_LOCATION pIrpSp;
    IO_STATUS_BLOCK iosb;
    PIRP pIrp;
    TCP_REQUEST_SET_INFORMATION_EX* pInfo;
    CHAR achBuf[ sizeof(*pInfo) + sizeof(ULONG) ];
    ULONG ulValue;
    TDI_CONNECTION_INFORMATION RequestConnInfo;
    KEVENT  Event;
    TA_IP_ADDRESS taip;
    TDI_ADDRESS_IP* pTdiIp;


    pDeviceObj = IoGetRelatedDeviceObject( pFileObj );

#if 0
    KeInitializeEvent(&Event, SynchronizationEvent, FALSE);

    pIrp = TdiBuildInternalDeviceControlIrp(TDI_ASSOCIATE_ADDRESS,
                                            pDeviceObj,
                                            pFileObj,
                                            &Event,
                                            &iosb);

    if (!pIrp) {
        TRACE( TL_A, TM_Tdi, ( "SetIfcIndex Associate Irp?" ) );
        return !STATUS_SUCCESS;
    }

    TdiBuildAssociateAddress(pIrp, 
                             pDeviceObj, 
                             pFileObj, 
                             NULL, 
                             NULL,
                             hFileHandle);

    status = IoCallDriver( pDeviceObj, pIrp );

    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&Event, Executive, KernelMode, FALSE, 0);
    }

    if (iosb.Status != STATUS_SUCCESS)
    {
        TRACE( TL_A, TM_Tdi, ( "SetIfcIndex Associate=%x?", status ) );
        return (iosb.Status);
    }
#endif

    pInfo = (TCP_REQUEST_SET_INFORMATION_EX* )achBuf;
    pInfo->ID.toi_entity.tei_entity = CL_TL_ENTITY;
    pInfo->ID.toi_entity.tei_instance = 0;
    pInfo->ID.toi_class = INFO_CLASS_PROTOCOL;
    pInfo->ID.toi_type = INFO_TYPE_ADDRESS_OBJECT;
    pInfo->ID.toi_id = AO_OPTION_IP_UCASTIF;

    ulValue = pTdixRoute->InterfaceIndex;

    NdisMoveMemory( pInfo->Buffer, &ulValue, sizeof(ulValue) );
    pInfo->BufferSize = sizeof(ulValue);

    KeInitializeEvent(&Event, SynchronizationEvent, FALSE);

    pIrp = IoBuildDeviceIoControlRequest(
        IOCTL_TCP_WSH_SET_INFORMATION_EX,
        pDeviceObj,
        (PVOID )pInfo,
        sizeof(*pInfo) + sizeof(ulValue),
        NULL,
        0,
        FALSE,
        &Event,
        &iosb );

    if (!pIrp)
    {
        TRACE( TL_A, TM_Tdi, ( "SetIfcIndex Irp?" ) );
        return !STATUS_SUCCESS;
    }

    pIrpSp = IoGetNextIrpStackLocation( pIrp );
    pIrpSp->FileObject = pFileObj;

    status = IoCallDriver( pDeviceObj, pIrp );

    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&Event,
                              Executive,
                              KernelMode,
                              FALSE,
                              NULL);
        status = iosb.Status;
    }

    if (status != STATUS_SUCCESS)
    {
        TRACE( TL_A, TM_Tdi, ( "SetIfcIndex=%x?", status ) );
        return status;
    }

    KeInitializeEvent(&Event, SynchronizationEvent, FALSE);

    pIrp = TdiBuildInternalDeviceControlIrp(TDI_CONNECT,
                                            pDeviceObj,
                                            pFileObj,
                                            &Event,
                                            &iosb);

    if (!pIrp) {
        TRACE( TL_A, TM_Res, ( "SetIfcIndex ConnectIrp?" ) );
        WPLOG( LL_A, LM_Res, ( "SetIfcIndex ConnectIrp?" ) );
        return !STATUS_SUCCESS;
    }

    // Put the destination IP address in the "connection" structure as TDI
    // expects.  
    //
    taip.TAAddressCount = 1;
    taip.Address[ 0 ].AddressLength = TDI_ADDRESS_LENGTH_IP;
    taip.Address[ 0 ].AddressType = TDI_ADDRESS_TYPE_IP;

    pTdiIp = &taip.Address[ 0 ].Address[ 0 ];
    pTdiIp->sin_port = pTdixRoute->sPort;
    pTdiIp->in_addr = pTdixRoute->ulIpAddress;
    NdisZeroMemory( pTdiIp->sin_zero, sizeof(pTdiIp->sin_zero) );

    RequestConnInfo.Options = NULL;
    RequestConnInfo.OptionsLength = 0;
    RequestConnInfo.RemoteAddress = &taip;
    RequestConnInfo.RemoteAddressLength = sizeof(taip);
    RequestConnInfo.UserData = NULL;
    RequestConnInfo.UserDataLength = 0;

    TdiBuildConnect(pIrp,
                    pDeviceObj,
                    pFileObj,
                    NULL,
                    NULL,
                    0,
                    &RequestConnInfo,
                    NULL);

    status = IoCallDriver( pDeviceObj, pIrp );

    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&Event, Executive, KernelMode, FALSE, 0);
    }

    if (iosb.Status != STATUS_SUCCESS)
    {
        TRACE( TL_A, TM_Tdi, ( "SetIfcIndex Connect=%x?", status ) );
        WPLOG( LL_A, LM_Tdi, ( "SetIfcIndex Connect=%x?", status ) );
        return (iosb.Status);
    }

    return (STATUS_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ndis\rasl2tp\kdext\dsocode.c ===
/****************************** Module Header ******************************\
* Module Name: dsocode.c
*
* Copyright (c) 1985-96, Microsoft Corporation
*
* This file contains the dump structure offset (dso) extension. It is
*  included by $(ALT_PROJECT)\dsotable.c which is generated by structo.exe
*
* History:
* 06/17/96 GerardoB Created
\***************************************************************************/
#include <stdexts.h>

/***************************************************************************\
* dsoTerminateString
*
* This is used to "parse" the command line. It null-terminates a space
*  delimited string, returns its size and a pointer to the begining
*  of next string
*
* 06/17/96 Created Gerardob
\***************************************************************************/
LPSTR dsoTerminateString(LPSTR psz, PDWORD pdwSize)
{
    LPSTR pszWork = psz;

    while (*pszWork != 0) {
        if (*pszWork == ' ') {
            *pszWork++ = 0;
            break;
        }
        pszWork++;
    }

    *pdwSize = (DWORD)(pszWork - psz);
    if (*pszWork != 0) {
        (*pdwSize)--;
    }

    while ((*pszWork != 0) && (*pszWork == ' ')) {
        pszWork++;
    }

    return pszWork;
}
/***************************************************************************\
* dsoGetOffset
*
* If the highest order bit of psot->dwOffset is set, then the value is a
*  relative offset from the previous field; otherwise, it is the
*  actual field offset from the beginnig of the structure
*
* 06/20/96 Created Gerardob
\***************************************************************************/
UINT dsoGetOffset (PSTRUCTUREOFFSETSTABLE psot)
{
    if (!(psot->dwOffset & 0x80000000)) {
        return psot->dwOffset;
    } else {
        return ((psot->dwOffset & ~0x80000000) + dsoGetOffset(psot - 1));
    }
}
/***************************************************************************\
* dsoGetSize
*
* The field size is calculated by substracting its offset from the next
*  field's offset. If the struct has unions, several "fields" might have
*  the same offset, or a given table entry (i.e., a field) might have an
*  offset value greater than the offset value for the next entry (a union
*  of two structures).
*
* 06/26/96 Created Gerardob
\***************************************************************************/
UINT dsoGetSize (PSTRUCTUREOFFSETSTABLE psot, DWORD dwOffset)
{
    DWORD dwNextFieldOffset;

    do {
        psot++;
        dwNextFieldOffset = dsoGetOffset(psot);
    } while (dwNextFieldOffset <= dwOffset);

    return dwNextFieldOffset - dwOffset;
}
/***************************************************************************\
* dsoGetStruct
*
* 07/03/96 Created Gerardob
\***************************************************************************/
PSTRUCTURESTABLE dosGetStruct (LPSTR pszStruct, DWORD dwSize)
{
    PSTRUCTURESTABLE pst = gst;

    /*
     * try an exact match
     */
    while (pst->pszName != NULL) {
        if (!_stricmp(pszStruct, pst->pszName)) {
            return pst;
        }
        pst++;
    }

    /*
     * Partial prefix match
     */
    pst = gst;
    while (pst->pszName != NULL) {
        if (!_strnicmp(pszStruct, pst->pszName, dwSize)) {
            return pst;
        }
        pst++;
    }

    return NULL;

}
/***************************************************************************\
* dsoGetField
*
* 07/03/96 Created Gerardob
\***************************************************************************/
PSTRUCTUREOFFSETSTABLE dosGetField (PSTRUCTUREOFFSETSTABLE psot, LPSTR pszField, DWORD dwSize)
{
    PSTRUCTUREOFFSETSTABLE psotFirst = psot;

    /*
     * try an exact match
     */
    while (psot->pszField != NULL) {
        if (!_stricmp(pszField, psot->pszField)) {
            return psot;
        }
        psot++;
    }

    /*
     * Partial prefix match
     */
    psot = psotFirst;
    while (psot->pszField != NULL) {
        if (!_strnicmp(pszField, psot->pszField, dwSize)) {
            return psot;
        }
        psot++;
    }
    return NULL;

}
/***************************************************************************\
* Idso
*
* !dso StructName [FieldName] [Address]
*
* 06/17/96 Created Gerardob
\***************************************************************************/
BOOL Idso(DWORD opts, LPSTR pszCmdLine)
{
    BOOL fOneField = FALSE;
    DWORD dwOptions;
    DWORD dwValue, dwSize, dwBytesRead, dwOffset, dwOffsetNext, dwFieldsPerRow, dwMoveSize;
    DWORD dwBuffer [20];  /* Make sure it has an even number of elemnts and at least 4*/
    const DWORD *pcdwLimit = dwBuffer + (sizeof(dwBuffer) / sizeof(*dwBuffer));
    DWORD *pdwValue;
    LPSTR pszField, pszAddress;
    PBYTE pBufferOffset;
    PSTRUCTURESTABLE pst;
    PSTRUCTUREOFFSETSTABLE psot;
    PVOID pAddress = NULL;

    if (pszCmdLine == NULL) {
        return FALSE;
    }

    /*
     * NULL terminate first argument and get a pointer to
     *  second one (presumably the field name)
     */
    /*
     * Get the options, if any
     */
    if (*pszCmdLine == '-') {
       dwOptions = GetOpts(&pszCmdLine, NULL);
    }

    /*
     * Find the struct table
     */
    pszField = dsoTerminateString(pszCmdLine, &dwSize);
    pst = dosGetStruct (pszCmdLine, dwSize);
    if (pst == NULL) {
        Print("Structure not found: %s\n", pszCmdLine);
        return TRUE;
    }

    /*
     * Got a table
     */
    psot = pst->psot;

    /*
     * If there is another argument, let's assume a field name follows
     */
    if (*pszField != 0) {
        /*
         * Find the field
         */
        pszAddress = dsoTerminateString(pszField, &dwSize);
        psot = dosGetField (psot, pszField, dwSize);

        /*
         * If it didn't find the field and an address was provided, game over.
         * Otherwise, the second parameter might be the address
         */
        if (psot == NULL) {
            if (*pszAddress != 0) {
                Print("Field not found: %s. Struct: %s\n", pszField, pst->pszName);
                return TRUE;
            } else {
                pszAddress = pszField;
                /*
                 * Reset psot since this argument was not a field
                 */
                psot = pst->psot;
            }
        } else {
            fOneField = TRUE;
        }

        /*
         * Get the pointer to the struct
         */
        if (*pszAddress != 0) {
            pAddress = EvalExp(pszAddress);
            if (pAddress == NULL) {
                /*
                 * EvalExp displayed the error message, so return silently
                 */
                return TRUE;
            }
        }

    } /* if (*pszField != 0) */


    /*
     * If a field name was specified, dump that field only
     * Otherwise, dump the whole table.
     */
    if (fOneField) {
        /*
         * If no address available, just display the field name and offset
         */
        dwOffset = dsoGetOffset(psot);
        Print ("Structure %s - Size: %#lx\n", pst->pszName, pst->dwSize);
        Print("Field: %s - Offset: %#lx\n", psot->pszField, dwOffset);
        if (pAddress == NULL) {
            return TRUE;
        }

        /*
         * Printing field value
         */

        /*123456789 1*/
        Print("Address   Value\n");

        dwBytesRead = 0;
        dwSize = dsoGetSize(psot, dwOffset);
        /*
         * Print 4 DWORDS per row; one row per loop
         */

        do { /* while ((int)dwSize > 0) */

            /*
             * Read values for next row
             */
            if (4 * sizeof(DWORD) >= dwSize) {
                dwMoveSize = dwSize;
            } else {
                dwMoveSize = 4 * sizeof(DWORD);
            }
            moveBlock(dwBuffer, (PBYTE)pAddress + dwOffset + dwBytesRead, dwMoveSize);
            pBufferOffset = (PBYTE)dwBuffer;

            /*
             * Print the address
             */
            Print("%08lx  ", (DWORD)((PBYTE)pAddress + dwOffset + dwBytesRead));
            /*
             * Keep track of bytes read (dwBytesRead) and bytes
             *  remaining to be read (dwSize)
             */
            dwBytesRead += dwMoveSize;
            dwSize -= dwMoveSize;
            /*
             * Print the values, one dword at the time
             */
            while (dwMoveSize >= sizeof(DWORD)) {
                Print("%08lx ", *((DWORD *)pBufferOffset));
                pBufferOffset += sizeof(DWORD);
                dwMoveSize -= sizeof(DWORD);
            }
            /*
             * If less than a DWORD left, zero extend and print a DWORD
             */
            if (dwMoveSize > 0) {
                dwValue = 0;
                memcpy(&dwValue, pBufferOffset, dwMoveSize);
                Print("%0*lx", dwMoveSize * 2, dwValue);
            }
            Print("\n");

        } while ((int)dwSize > 0);

        return TRUE;

    } /* if (fOneField) */


    /*
     * Printing all the fields.
     */
    Print ("Structure %s - Size: %#lx\n", pst->pszName, pst->dwSize);

    dwOffset = 0;
    pBufferOffset = NULL; /* Forces the local buffer to be loaded */
    dwFieldsPerRow = 0;


    /*
     * Loop through all fields in the table. Print one field per loop
     */
    while (psot->pszField != NULL) {
        /*
         * Print two fields per row
         */
        if (dwFieldsPerRow == 2) {
            Print("\n");
            dwFieldsPerRow = 1;
        } else {
            dwFieldsPerRow++;
        }

        /*
         * If no address provided, Print field name(s) and offset(s) only
         */
        if (pAddress == NULL) {
            Print("%03lx  %-34.33s", dsoGetOffset(psot), psot->pszField);
        } else {
            /*
             * Printing offsets and values.
             *
             * Get the size of the value and max it to one DWORD
             */
            dwOffsetNext = dsoGetOffset(psot + 1);
            if (dwOffsetNext > dwOffset) {
                dwSize = dwOffsetNext - dwOffset;
            } else {
                dwSize = dsoGetSize(psot, dwOffset);
            }
            if (dwSize > sizeof(DWORD)) {
                dwSize = sizeof(DWORD);
            }

            /*
             * Get a pointer to the value in the local buffer
             * If the value is not in the buffer, load it
             */
            pdwValue = (PDWORD)(pBufferOffset + dwOffset);
            if ((pdwValue < dwBuffer) || (pdwValue + dwSize > pcdwLimit)) {
                pBufferOffset = (PBYTE)dwBuffer - dwOffset;
                pdwValue = dwBuffer;

                if (sizeof(dwBuffer) >= pst->dwSize - dwOffset) {
                    dwMoveSize = pst->dwSize - dwOffset;
                } else {
                    dwMoveSize = sizeof(dwBuffer);
                }
                moveBlock((PBYTE)dwBuffer, (PBYTE)pAddress + dwOffset, dwMoveSize);

            }

            /*
             * Copy the value and print it
             */
            dwValue = 0; /* in case size < sizeof(DWORD) */
            memcpy(&dwValue, pdwValue, dwSize);
            Print("(%03lx) %08lx %-24.23s", dwOffset, dwValue, psot->pszField);
        } /* if (pAddress == NULL) */


        dwOffset = dwOffsetNext;
        psot++;

    } /* while (psot->pszField != NULL) */

    Print("\n");

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ndis\raspppoe\bpool.h ===
// Copyright (c) 1997, Microsoft Corporation, all rights reserved
//
// bpool.h
// RAS L2TP WAN mini-port/call-manager driver
// Buffer pool management header
//
// 01/07/97 Steve Cobb, adapted from Gurdeep's WANARP code.


#ifndef _BPOOL_H_
#define _BPOOL_H_


//-----------------------------------------------------------------------------
// Data structures
//-----------------------------------------------------------------------------

// Buffer pool control block.  A buffer pool prevents fragmentation of the
// non-paged memory pool by allocating the memory for a group of buffers in a
// single contiguous block.  At user's option, the buffer pool routines may
// allocate a pool of NDIS_BUFFER buffer descriptors and associate each with
// the memory buffers sliced from the contiguous block.  This allows the
// buffer to be reused while the virtual->physical memory mapping is performed
// only once.  All necessary pool growth and shrinkage is handled internally.
//
typedef struct
_BUFFERPOOL
{
    // Size in bytes of an individual buffer in the pool.
    //
    ULONG ulBufferSize;

    // The optimal number of buffers to allocate in each buffer block.
    //
    ULONG ulBuffersPerBlock;

    // Maximum number of individual buffers that may be allocated in the
    // entire pool or 0 for unlimited.
    //
    ULONG ulMaxBuffers;

    // Current number of individual buffers allocated in the entire pool.
    //
    ULONG ulCurBuffers;

    // Garbage collection occurs after this many calls to FreeBufferToPool.
    //
    ULONG ulFreesPerCollection;

    // Number of calls to FreeBufferToPool since a garbage collection.
    //
    ULONG ulFreesSinceCollection;

    // Indicates an NDIS_BUFFER is to be associated with each individual
    // buffer in the pool.
    //
    BOOLEAN fAssociateNdisBuffer;

    // Memory identification tag for allocated blocks.
    //
    ULONG ulTag;

    // Head of the double linked list of BUFFERBLOCKHEADs.  Access to the list
    // is protected with 'lock' in this structure.
    //
    LIST_ENTRY listBlocks;

    // Head of the double linked list of free BUFFERHEADs.  Each BUFFERHEAD in
    // the list is ready to go, i.e. it preceeds it's already allocated memory
    // buffer and, if appropriate, has an NDIS_BUFFER associated with it.
    // Access to the list is protected by 'lock' in this structure.
    // Interlocked push/pop is not used because (a) the list of blocks and the
    // list of buffers must lock each other and (b) double links are necessary
    // for garbage collection.
    //
    LIST_ENTRY listFreeBuffers;

    // This lock protects this structure and both the list of blocks and the
    // list of buffers.
    //
    NDIS_SPIN_LOCK lock;
}
BUFFERPOOL;


// Header of a single block of buffers from a buffer pool.  The BUFFERHEAD of
// the first buffer immediately follows.
//
typedef struct
_BUFFERBLOCKHEAD
{
    // Link to the prev/next buffer block header in the buffer pool's list.
    //
    LIST_ENTRY linkBlocks;

    // NDIS's handle of the pool of NDIS_BUFFER descriptors associated with
    // this block, or NULL if none.  (Note: With the current NT implementation
    // of NDIS_BUFFER as MDL this is always NULL).
    //
    NDIS_HANDLE hNdisPool;

    // Back pointer to the buffer pool.
    //
    BUFFERPOOL* pPool;

    // Number of individual buffers in this block.
    //
    ULONG ulBuffers;

    // Number of individual buffers in this block on the free list.
    //
    ULONG ulFreeBuffers;
}
BUFFERBLOCKHEAD;


// Header of an individual buffer.  The buffer memory itself immediately
// follows.
//
typedef struct
_BUFFERHEAD
{
    // Links to prev/next buffer header in the buffer pool's free list.
    //
    LIST_ENTRY linkFreeBuffers;

    // Back link to owning buffer block header.
    //
    BUFFERBLOCKHEAD* pBlock;

    // NDIS buffer descriptor of this buffer.  This is NULL unless the pool is
    // initialized with the 'fAssociateNdisBuffer' option.
    //
    NDIS_BUFFER* pNdisBuffer;
}
BUFFERHEAD;


//-----------------------------------------------------------------------------
// Interface prototypes and inline definitions
//-----------------------------------------------------------------------------

VOID
InitBufferPool(
    OUT BUFFERPOOL* pPool,
    IN ULONG ulBufferSize,
    IN ULONG ulMaxBuffers,
    IN ULONG ulBuffersPerBlock,
    IN ULONG ulFreesPerCollection,
    IN BOOLEAN fAssociateNdisBuffer,
    IN ULONG ulTag );

BOOLEAN
FreeBufferPool(
    IN BUFFERPOOL* pPool );

CHAR*
GetBufferFromPool(
    IN BUFFERPOOL* pPool );

VOID
FreeBufferToPool(
    IN BUFFERPOOL* pPool,
    IN CHAR* pBuffer,
    IN BOOLEAN fGarbageCollection );

NDIS_BUFFER*
NdisBufferFromBuffer(
    IN CHAR* pBuffer );

ULONG
BufferSizeFromBuffer(
    IN CHAR* pBuffer );

NDIS_BUFFER*
PoolHandleForNdisCopyBufferFromBuffer(
    IN CHAR* pBuffer );

VOID
CollectBufferPoolGarbage(
    BUFFERPOOL* pPool );


#endif // BPOOL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ndis\rasl2tp\kdext\l2tpext.h ===
#include <l2tpp.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ndis\rasl2tp\kdext\precomp.h ===
#ifndef __PRECOMP_H__
#define __PRECOMP_H__

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windef.h>
#include <winbase.h>
#include <ntosp.h>
#include <stdio.h>

#include <ndis.h>
#include <cxport.h>
#include <ip.h>
#include <tdiinfo.h>
#include <ipinfo.h>
#include <ntddip.h>
#include <ipfilter.h>
#include <tdistat.h>
#include <wanpub.h>

#define FIELDOFFSET(type, field)    ((UINT)&(((type *)0)->field))

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ndis\rasl2tp\kdext\l2tpext.c ===
#include "precomp.h"
#pragma hdrstop

PSTR pszExtName = "L2TP";

#include <stdexts.h>
#include <stdexts.c>

DllInit(
    HANDLE hModule,
    DWORD  dwReason,
    DWORD  dwReserved
    )
{
    switch (dwReason) {
        case DLL_THREAD_ATTACH:
            break;

        case DLL_THREAD_DETACH:
            break;

        case DLL_PROCESS_DETACH:
            break;

        case DLL_PROCESS_ATTACH:
            break;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ndis\raspppoe\bpool.c ===
// Copyright (c) 1997, Microsoft Corporation, all rights reserved
//
// bpool.c
// RAS L2TP WAN mini-port/call-manager driver
// Buffer pool management routines
//
// 01/07/97 Steve Cobb, adapted from Gurdeep's WANARP code.


#include <ntddk.h>
#include <ntddndis.h>
#include <ndis.h>
#include <ndiswan.h>
#include <ndistapi.h>
#include <ntverp.h>

#include "debug.h"
#include "timer.h"
#include "bpool.h"
#include "ppool.h"
#include "util.h"
#include "packet.h"
#include "protocol.h"
#include "miniport.h"
#include "tapi.h"


// Debug count of detected double-frees that should not be happening.
//
ULONG g_ulDoubleBufferFrees = 0;

// Debug  count of calls to NdisAllocateBuffer/NdisCopyBuffer/NdisFreeBuffer,
// where the total of Alloc and Copy should equal Free in idle state.
//
ULONG g_ulNdisAllocateBuffers = 0;
ULONG g_ulNdisCopyBuffers = 0;
ULONG g_ulNdisFreeBuffers = 0;

//-----------------------------------------------------------------------------
// Local prototypes (alphabetically)
//-----------------------------------------------------------------------------

CHAR*
AddBufferBlockToPool(
    IN BUFFERPOOL* pPool );

VOID
FreeUnusedBufferPoolBlocks(
    IN BUFFERPOOL* pPool );


//-----------------------------------------------------------------------------
// Interface routines
//-----------------------------------------------------------------------------

VOID
InitBufferPool(
    OUT BUFFERPOOL* pPool,
    IN ULONG ulBufferSize,
    IN ULONG ulMaxBuffers,
    IN ULONG ulBuffersPerBlock,
    IN ULONG ulFreesPerCollection,
    IN BOOLEAN fAssociateNdisBuffer,
    IN ULONG ulTag )

    // Initialize caller's buffer pool control block 'pPool'.  'UlBufferSize'
    // is the size in bytes of an individual buffer.  'UlMaxBuffers' is the
    // maximum number of buffers allowed in the entire pool or 0 for
    // unlimited.  'UlBuffersPerBlock' is the number of buffers to include in
    // each block of buffers.  'UlFreesPerCollection' is the number of
    // FreeBufferToPool calls until the next garbage collect scan, or 0 for
    // default.  'FAssociateNdisBuffer' is set if an NDIS_BUFFER should be
    // allocated and associated with each individual buffer.  'UlTag' is the
    // memory identification tag to use when allocating blocks.
    //
    // IMPORTANT: Caller's 'pPool' buffer must be protected from multiple
    //            access during this call.
    //
{
    // The requested buffer size is padded, if necessary, so it alligns
    // properly when buffer blocks are layed out.  The alignment rule also
    // applies to the BUFFERBLOCKHEAD and BUFFERHEAD structures, which
    // currently align perfectly.  We will verify once here, rather than code
    // around everywhere else.
    //
    ASSERT( (ALIGN_UP( sizeof(BUFFERBLOCKHEAD), ULONGLONG )
        == sizeof(BUFFERBLOCKHEAD)) );
    ASSERT( (ALIGN_UP( sizeof(BUFFERHEAD), ULONGLONG )
        == sizeof(BUFFERHEAD)) );
    pPool->ulBufferSize = ALIGN_UP( ulBufferSize, ULONGLONG );

    pPool->ulMaxBuffers = ulMaxBuffers;
    pPool->ulBuffersPerBlock = ulBuffersPerBlock;
    pPool->ulFreesSinceCollection = 0;
    pPool->fAssociateNdisBuffer = fAssociateNdisBuffer;
    pPool->ulTag = ulTag;

    if (ulFreesPerCollection)
    {
        pPool->ulFreesPerCollection = ulFreesPerCollection;
    }
    else
    {
        // Calculate default garbage collection trigger.  Don't want to be too
        // aggressive here.
        //
        pPool->ulFreesPerCollection = 200 * pPool->ulBuffersPerBlock;
    }

    TRACE( TL_N, TM_Pool, ( "InitBp tag=$%08x buf=%d cnt=%d",
        pPool->ulTag, pPool->ulBufferSize, pPool->ulBuffersPerBlock ) );

    InitializeListHead( &pPool->listBlocks );
    InitializeListHead( &pPool->listFreeBuffers );
    NdisAllocateSpinLock( &pPool->lock );
}


BOOLEAN
FreeBufferPool(
    IN BUFFERPOOL* pPool )

    // Free up all resources allocated in buffer pool 'pPool'.  This is the
    // inverse of InitBufferPool.
    //
    // Returns true if successful, false if any of the pool could not be freed
    // due to outstanding packets.
    //
{
    BOOLEAN fSuccess;

    TRACE( TL_N, TM_Pool, ( "FreeBp" ) );

    NdisAcquireSpinLock( &pPool->lock );
    {
        FreeUnusedBufferPoolBlocks( pPool );
        fSuccess = (pPool->ulCurBuffers == 0);
    }
    NdisReleaseSpinLock( &pPool->lock );

    return fSuccess;
}


CHAR*
GetBufferFromPool(
    IN BUFFERPOOL* pPool )

    // Returns the address of the useable memory in an individual buffer
    // allocated from the pool 'pPool'.  The pool is expanded, if necessary,
    // but caller should still check for NULL return since the pool may have
    // been at maximum size.
    //
{
    LIST_ENTRY* pLink;
    BUFFERHEAD* pHead;
    CHAR* pBuffer;

    NdisAcquireSpinLock( &pPool->lock );
    {
        if (IsListEmpty( &pPool->listFreeBuffers ))
        {
            pLink = NULL;
        }
        else
        {
            pLink = RemoveHeadList( &pPool->listFreeBuffers );
            InitializeListHead( pLink );
            pHead = CONTAINING_RECORD( pLink, BUFFERHEAD, linkFreeBuffers );
            --pHead->pBlock->ulFreeBuffers;
        }
    }
    NdisReleaseSpinLock( &pPool->lock );

    if (pLink)
    {
        pBuffer = (CHAR* )(pHead + 1);
    }
    else
    {
        // The free list was empty.  Try to expand the pool.
        //
        pBuffer = AddBufferBlockToPool( pPool );
    }

    DBG_if (pBuffer)
    {
        pHead = (BUFFERHEAD* )(pBuffer - sizeof(BUFFERHEAD));
        TRACE( TL_N, TM_Pool, ( "GetBfp=$%p, %d free",
            pBuffer, pHead->pBlock->ulFreeBuffers ) );
    }
    DBG_else
    {
        TRACE( TL_A, TM_Pool, ( "GetBfp failed?" ) );
    }

    return pBuffer;
}


VOID
FreeBufferToPool(
    IN BUFFERPOOL* pPool,
    IN CHAR* pBuffer,
    IN BOOLEAN fGarbageCollection )

    // Returns 'pBuffer' to the pool of unused buffers 'pPool'.  'PBuffer'
    // must have been previously allocated with GetBufferFromPool.
    // 'FGarbageCollection' is set when the free should be considered for
    // purposes of garbage collection.  This is used by the AddBufferToPool
    // routine to avoid counting the initial "add" frees.  Normal callers
    // should set this flag.
    //
{
    BUFFERHEAD* pHead;

    pHead = ((BUFFERHEAD* )pBuffer) - 1;

    DBG_if (fGarbageCollection)
    {
        TRACE( TL_I, TM_Pool, ( "FreeBtoP($%p) %d free",
            pBuffer, pHead->pBlock->ulFreeBuffers + 1 ) );
    }

    // Requested by Chun Ye to catch IPSEC problem.
    //
    ASSERT( pHead->pNdisBuffer && !((MDL* )pHead->pNdisBuffer)->Next );

    NdisAcquireSpinLock( &pPool->lock );
    do
    {
        if (pHead->linkFreeBuffers.Flink != &pHead->linkFreeBuffers)
        {
            ASSERT( !"Double free?" );
            ++g_ulDoubleBufferFrees;
            break;
        }

        InsertHeadList( &pPool->listFreeBuffers, &pHead->linkFreeBuffers );
        ++pHead->pBlock->ulFreeBuffers;

        if (fGarbageCollection)
        {
            ++pPool->ulFreesSinceCollection;

            if (pPool->ulFreesSinceCollection >= pPool->ulFreesPerCollection)
            {
                // Time to collect garbage, i.e. free any blocks in the
                // pool not in use.
                //
                FreeUnusedBufferPoolBlocks( pPool );
                pPool->ulFreesSinceCollection = 0;
            }
        }
    }
    while (FALSE);
    NdisReleaseSpinLock( &pPool->lock );
}


NDIS_BUFFER*
NdisBufferFromBuffer(
    IN CHAR* pBuffer )

    // Returns the NDIS_BUFFER associated with the buffer 'pBuffer' which was
    // obtained previously with GetBufferFromPool.
    //
{
    BUFFERHEAD* pHead;

    pHead = ((BUFFERHEAD* )pBuffer) - 1;
    return pHead->pNdisBuffer;
}


ULONG
BufferSizeFromBuffer(
    IN CHAR* pBuffer )

    // Returns the original size of the buffer 'pBuffer' which was obtained
    // previously with GetBufferFromPool.  This is useful for undoing
    // NdisAdjustBufferLength.
    //
{
    BUFFERHEAD* pHead;

    pHead = ((BUFFERHEAD* )pBuffer) - 1;
    return pHead->pBlock->pPool->ulBufferSize;
}


NDIS_BUFFER*
PoolHandleForNdisCopyBufferFromBuffer(
    IN CHAR* pBuffer )

    // Returns the handle of the pool from which the NDIS_BUFFER associated
    // with the buffer 'pBuffer' was obtained.  Caller may use the handle to
    // pass to NdisCopyBuffer, one such use per buffer at a time.
    //
{
    BUFFERHEAD* pHead;

    pHead = ((BUFFERHEAD* )pBuffer) - 1;
    return pHead->pBlock->hNdisPool;
}


VOID
CollectBufferPoolGarbage(
    BUFFERPOOL* pPool )

    // Force a garbage collection event on the pool 'pPool'.
    //
{
    NdisAcquireSpinLock( &pPool->lock );
    {
        FreeUnusedBufferPoolBlocks( pPool );
        pPool->ulFreesSinceCollection = 0;
    }
    NdisReleaseSpinLock( &pPool->lock );
}


//-----------------------------------------------------------------------------
// Local utility routines (alphabetically)
//-----------------------------------------------------------------------------

CHAR*
AddBufferBlockToPool(
    IN BUFFERPOOL* pPool )

    // Allocate a new buffer block and add it to the buffer pool 'pPool'.
    //
    // Returns the address of the usable memory of an individual buffer
    // allocated from the pool or NULL if none.
    //
{
    NDIS_STATUS status;
    BUFFERBLOCKHEAD* pNew;
    ULONG ulSize;
    ULONG ulCount;
    BOOLEAN fOk;
    BOOLEAN fAssociateNdisBuffer;
    CHAR* pReturn;

    TRACE( TL_A, TM_Pool, ( "AddBpBlock(%d+%d)",
        pPool->ulCurBuffers, pPool->ulBuffersPerBlock ) );

    fOk = FALSE;
    pNew = NULL;

    NdisAcquireSpinLock( &pPool->lock );
    {
        // Save this for reference after the lock is released.
        //
        fAssociateNdisBuffer = pPool->fAssociateNdisBuffer;

        do
        {
            if (pPool->ulMaxBuffers
                && pPool->ulCurBuffers >= pPool->ulMaxBuffers)
            {
                // No can do.  The pool's already at maximum size.
                //
                TRACE( TL_A, TM_Pool, ( "Bp maxed?" ) );
                break;
            }

            // Calculate the contiguous block's size and the number of buffers
            // it will hold.
            //
            ulCount = pPool->ulBuffersPerBlock;
            if (pPool->ulMaxBuffers)
            {
                if (ulCount > pPool->ulMaxBuffers - pPool->ulCurBuffers)
                {
                    ulCount = pPool->ulMaxBuffers - pPool->ulCurBuffers;
                }
            }
            ulSize = sizeof(BUFFERBLOCKHEAD) +
                (ulCount * (sizeof(BUFFERHEAD) + pPool->ulBufferSize));

            // Allocate the contiguous memory block for the BUFFERBLOCK header
            // and the individual buffers.
            //
            pNew = ALLOC_NONPAGED( ulSize, pPool->ulTag );
            if (!pNew)
            {
                TRACE( TL_A, TM_Pool, ( "Alloc BB?" ) );
                break;
            }

            // Zero only the block header portion.
            //
            NdisZeroMemory( pNew, sizeof(BUFFERBLOCKHEAD) );

            if (fAssociateNdisBuffer)
            {
                // Allocate a pool of NDIS_BUFFER descriptors.
                //
                // Twice as many descriptors are allocated as buffers so
                // caller can use the PoolHandleForNdisCopyBufferFromBuffer
                // routine to obtain a pool handle to pass to the
                // NdisCopyBuffer used to trim the L2TP header from received
                // packets.  In the current NDIS implmentation on NT this does
                // nothing but return a NULL handle and STATUS_SUCCESS,
                // because NDIS_BUFFER's are just MDL's,
                // NdisAllocateBufferPool is basically a no-op, and for that
                // matter, NdisCopyBuffer doesn't really use the pool handle
                // it's passed.  It's cheap to stay strictly compliant here,
                // though, so we do that.
                //
                NdisAllocateBufferPool(
                    &status, &pNew->hNdisPool, ulCount * 2 );
                if (status != NDIS_STATUS_SUCCESS)
                {
                    TRACE( TL_A, TM_Pool, ( "AllocBp=$%x?", status ) );
                    break;
                }
            }

            // Fill in the back pointer to the pool.
            //
            pNew->pPool = pPool;

            // Link the new block.  At this point, all the buffers are
            // effectively "in use".  They are made available in the loop
            // below.
            //
            pNew->ulBuffers = ulCount;
            pPool->ulCurBuffers += ulCount;
            InsertHeadList( &pPool->listBlocks, &pNew->linkBlocks );

            fOk = TRUE;
        }
        while (FALSE);
    }
    NdisReleaseSpinLock( &pPool->lock );

    if (!fOk)
    {
        // Bailing, undo whatever succeeded.
        //
        if (pNew)
        {
            if (pNew->hNdisPool)
            {
                NdisFreeBufferPool( pNew->hNdisPool );
            }
            FREE_NONPAGED( pNew );
        }

        return NULL;
    }

    // Initialize each individual buffer slice and add it to the list of free
    // buffers.
    //
    {
        ULONG i;
        CHAR* pBuffer;
        BUFFERHEAD* pHead;

        pReturn = NULL;

        // For each slice of the block, where a slice consists of a BUFFERHEAD
        // and the buffer memory that immediately follows it...
        //
        for (i = 0, pHead = (BUFFERHEAD* )(pNew + 1);
             i < ulCount;
             ++i, pHead = (BUFFERHEAD* )
                      ((CHAR* )(pHead + 1) + pPool->ulBufferSize))
        {
            pBuffer = (CHAR* )(pHead + 1);

            InitializeListHead( &pHead->linkFreeBuffers );
            pHead->pBlock = pNew;
            pHead->pNdisBuffer = NULL;

            if (fAssociateNdisBuffer)
            {
                // Associate an NDIS_BUFFER descriptor from the pool we
                // allocated above.
                //
                NdisAllocateBuffer(
                    &status, &pHead->pNdisBuffer, pNew->hNdisPool,
                    pBuffer, pPool->ulBufferSize );

                if (status != NDIS_STATUS_SUCCESS)
                {
                    TRACE( TL_A, TM_Pool, ( "AllocB=$%x?", status ) );
                    ASSERT( FALSE );
                    pHead->pNdisBuffer = NULL;
                    continue;
                }
                else
                {
                    NdisInterlockedIncrement( &g_ulNdisAllocateBuffers );
                }
            }

            if (pReturn)
            {
                // Add the constructed buffer to the list of free buffers.
                // The 'FALSE' tells the garbage collection algorithm the
                // operation is an "add" rather than a "release" and should be
                // ignored.
                //
                FreeBufferToPool( pPool, pBuffer, FALSE );
            }
            else
            {
                // The first successfully constructed buffer is returned by
                // this routine.
                //
                pReturn = pBuffer;
            }
        }
    }

    return pReturn;
}


VOID
FreeUnusedBufferPoolBlocks(
    IN BUFFERPOOL* pPool )

    // Check if any of the blocks in pool 'pPool' are not in use, and if so,
    // free them.
    //
    // IMPORTANT: Caller must hold the pool lock.
    //
{
    LIST_ENTRY* pLink;

    TRACE( TL_A, TM_Pool, ( "FreeUnusedBpBlocks" ) );

    // For each block in the pool...
    //
    pLink = pPool->listBlocks.Flink;
    while (pLink != &pPool->listBlocks)
    {
        LIST_ENTRY* pLinkNext;
        BUFFERBLOCKHEAD* pBlock;

        pLinkNext = pLink->Flink;

        pBlock = CONTAINING_RECORD( pLink, BUFFERBLOCKHEAD, linkBlocks );
        if (pBlock->ulFreeBuffers >= pBlock->ulBuffers)
        {
            ULONG i;
            BUFFERHEAD* pHead;

            TRACE( TL_A, TM_Pool, ( "FreeBpBlock(%d-%d)",
                pPool->ulCurBuffers, pPool->ulBuffersPerBlock ) );

            // Found a block with no buffers in use.  Walk the buffer block
            // removing each buffer from the pool's free list and freeing any
            // associated NDIS_BUFFER descriptor.
            //
            for (i = 0, pHead = (BUFFERHEAD* )(pBlock + 1);
                 i < pBlock->ulBuffers;
                 ++i, pHead = (BUFFERHEAD* )
                      (((CHAR* )(pHead + 1)) + pPool->ulBufferSize))
            {
                RemoveEntryList( &pHead->linkFreeBuffers );
                InitializeListHead( &pHead->linkFreeBuffers );

                if (pHead->pNdisBuffer)
                {
                    NdisFreeBuffer( pHead->pNdisBuffer );
                    NdisInterlockedIncrement( &g_ulNdisFreeBuffers );
                }
            }

            // Remove and release the unused block.
            //
            RemoveEntryList( pLink );
            InitializeListHead( pLink );
            pPool->ulCurBuffers -= pBlock->ulBuffers;

            if (pBlock->hNdisPool)
            {
                NdisFreeBufferPool( pBlock->hNdisPool );
            }

            FREE_NONPAGED( pBlock );
        }

        pLink = pLinkNext;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ndis\raspppoe\debug.h ===
// Copyright (c) 1997, Microsoft Corporation, all rights reserved
//
// debug.h
// RAS L2TP WAN mini-port/call-manager driver
// Debug helper header
//
// 01/07/97 Steve Cobb


#ifndef _DEBUG_H_
#define _DEBUG_H_


//-----------------------------------------------------------------------------
// Debug constants
//-----------------------------------------------------------------------------

// Memory tags used with NdisAllocateMemoryWithTag to identify allocations
// made by the L2TP driver.  Also, several context blocks define a first field
// of 'ulTag' set to these values for ASSERT sanity checking and eased memory
// dump browsing.  Such tags are set to MTAG_FREED just before NdisFreeMemory
// is called.
//

#define MTAG_ADAPTER                        'PoEa'
#define MTAG_BINDING                        'PoEb'
#define MTAG_BUFFERPOOL                     'PoEc'
#define MTAG_PACKETPOOL                     'PoEd'
#define MTAG_PPPOEPACKET                    'PoEe'
#define MTAG_TAPIPROV                       'PoEf'
#define MTAG_LINE                           'PoEg'
#define MTAG_CALL                           'PoEh'
#define MTAG_HANDLETABLE                    'PoEi'
#define MTAG_HANDLECB                       'PoEj'
#define MTAG_TIMERQ                         'PoEk'
#define MTAG_FREED                          'PoEl'
#define MTAG_LLIST_WORKITEMS                'PoEm'

#if 0
#define MTAG_FREED       '0T2L'
#define MTAG_ADAPTERCB   '1T2L'
#define MTAG_TUNNELCB    '2T2L'
#define MTAG_VCCB        '3T2L'
#define MTAG_VCTABLE     '4T2L'
#define MTAG_WORKITEM    '5T2L'
#define MTAG_TIMERQ      '6T2L'
#define MTAG_TIMERQITEM  '7T2L'
#define MTAG_PACKETPOOL  '8T2L'
#define MTAG_FBUFPOOL    '9T2L'
#define MTAG_HBUFPOOL    'aT2L'
#define MTAG_TDIXRDG     'bT2L'
#define MTAG_TDIXSDG     'cT2L'
#define MTAG_CTRLRECD    'dT2L'
#define MTAG_CTRLSENT    'eT2L'
#define MTAG_PAYLRECD    'fT2L'
#define MTAG_PAYLSENT    'gT2L'
#define MTAG_INCALL      'hT2L'
#define MTAG_UTIL        'iT2L'
#define MTAG_ROUTEQUERY  'jT2L'
#define MTAG_ROUTESET    'kT2L'
#define MTAG_L2TPPARAMS  'lT2L'
#define MTAG_TUNNELWORK  'mT2L'
#define MTAG_TDIXROUTE   'nT2L'
#define MTAG_CTRLMSGINFO 'oT2L'
#endif

// Trace levels.
//
#define TL_None 0    // Trace disabled
#define TL_A    0x10 // Alert
#define TL_I    0x18 // Interface (highest level workable for general use)
#define TL_N    0x20 // Normal
#define TL_V    0x30 // Verbose

// Trace mask bits.
//
#define TM_Mp    0x00000001 // Mini-port general
#define TM_Tp    0x00000002 // Tapi general
#define TM_Pr    0x00000004 // Protocol general
#define TM_Fsm   0x00000010 // Finite state machines
#define TM_Mn    0x00000020 // Main module
#define TM_Pk    0x00000040 // Packet general

#define TM_Init  0x00000020 // Initialization
#define TM_Misc  0x00000040 // Miscellaneous
#define TM_TWrk  0x00001000 // Tunnel work APC queuing
#define TM_Ref   0x00010000 // References
#define TM_Time  0x00020000 // Timer queue
#define TM_Pool  0x00080000 // Buffer and packet pooling
#define TM_Stat  0x00100000 // Call statistics
#define TM_Spec  0x01000000 // Special purpose temporary traces
#define TM_MDmp  0x10000000 // Message dumps
#define TM_Dbg   0x80000000 // Debug corruption checks

#define TM_Wild  0xFFFFFFFF // Everything
#define TM_All   0x7FFFFFFF // Everything except corruption checks
#define TM_BTWrk 0x00000FFF // Base with messages and tunnel work
#define TM_BCMsg 0x000001FF // Base with control messages
#define TM_XCMsg 0x001401FF // Base with control messages extended
#define TM_Base  0x000000FF // Base only

// Bytes to appear on each line of dump output.
//
#define DUMP_BytesPerLine 16


//-----------------------------------------------------------------------------
// Debug global declarations (defined in debug.c)
//-----------------------------------------------------------------------------

// Active debug trace level and active trace set mask.  Set these variables
// with the debugger at startup to enable and filter the debug output.  All
// messages with (TL_*) level less than or equal to 'g_ulTraceLevel' and from
// any (TM_*) set(s) present in 'g_ulTraceMask' are displayed.
//
extern ULONG g_ulTraceLevel;
extern ULONG g_ulTraceMask;


//-----------------------------------------------------------------------------
// Debug macros
//-----------------------------------------------------------------------------

#if DBG

// TRACE sends printf style output to the kernel debugger.  Caller indicates a
// "verbosity" level with the 'ulLevel' argument and associates the trace with
// one or more trace sets with the 'ulMask' bit mask argument.  Notice that
// the variable count printf arguments 'Args' must be parenthesized.  For
// example...
//
// A "leave" routine message:
//     TRACE( TL_N, TM_Init, ( "DriverEntry=$%x", status ) );
// An error condition occurred:
//     TRACE( TL_E, TM_Init, ( "NdisMRegisterMiniport=$%x", status ) );
//
//
#define TRACE(ulLevel,ulMask,Args)                             \
{                                                              \
    if (ulLevel <= g_ulTraceLevel && (g_ulTraceMask & ulMask)) \
    {                                                          \
        DbgPrint( "PPPoE: " );                                  \
        DbgPrint Args;                                         \
        DbgPrint( "\n" );                                      \
    }                                                          \
}

// ASSERT checks caller's assertion expression and if false, prints a kernel
// debugger message and breaks.
//
#undef ASSERT
#define ASSERT(x)                                           \
{                                                           \
    if (!(x))                                               \
    {                                                       \
        DbgPrint( "PPPoE: !ASSERT( %s ) at line %d of %s\n", \
            #x, __LINE__, __FILE__ );                       \
        DbgBreakPoint();                                    \
    }                                                       \
}

// DUMP prints to the kernel debugger a hex dump of 'cb' bytes starting at 'p'
// in groups of 'ul'.  If 'f' is set the address of each line in shown before
// the dump.  DUMPB, DUMPW, and DUMPDW are BYTE, WORD, and DWORD dumps
// respectively.  Note that the multi-byte dumps do not reflect little-endian
// (Intel) byte order.  The 'ulLevel' and 'ulMask' are described for TRACE.
//
#define DUMP(ulLevel,ulMask,p,cb,f,ul)                         \
{                                                              \
    if (ulLevel <= g_ulTraceLevel && (g_ulTraceMask & ulMask)) \
    {                                                          \
        Dump( (CHAR* )p, cb, f, ul );                          \
    }                                                          \
}

#define DUMPB(ulLevel,ulMask,p,cb)                             \
{                                                              \
    if (ulLevel <= g_ulTraceLevel && (g_ulTraceMask & ulMask)) \
    {                                                          \
        Dump( (CHAR* )p, cb, 0, 1 );                           \
    }                                                          \
}

#define DUMPW(ulLevel,ulMask,p,cb)                             \
{                                                              \
    if (ulLevel <= g_ulTraceLevel && (g_ulTraceMask & ulMask)) \
    {                                                          \
        Dump( (CHAR* )p, cb, 0, 2 );                           \
    }                                                          \
}

#define DUMPDW(ulLevel,ulMask,p,cb)                            \
{                                                              \
    if (ulLevel <= g_ulTraceLevel && (g_ulTraceMask & ulMask)) \
    {                                                          \
        Dump( (CHAR* )p, cb, 0, 4 );                           \
    }                                                          \
}


// Double-linked list corruption detector.  Runs the test if 'ulMask' is
// enabled, with TM_Dbg a suggested setting.  Shows verbose output if
// 'ulLevel' is at or above the current trace threshold.
//
#define CHECKLIST(ulMask,p,ulLevel)                            \
{                                                              \
    if (g_ulTraceMask & ulMask)                                \
    {                                                          \
        CheckList( p, (BOOLEAN )(ulLevel <= g_ulTraceLevel) ); \
    }                                                          \
}


// DBG_if can be used to put in TRACE/DUMPs conditional on an expression that
// need not be evaluated in non-DBG builds, e.g the statements below generate
// no code in a non-DBG build, but in DBG builds print the TRACE if x<y and
// asserts otherwise.
//
//     DBG_if (x < y)
//         TRACE( TL_N, TM_Misc, ( "x < y" ) );
//     DBG_else
//         ASSERT( FALSE );
//
//
#define DBG_if(x) if (x)
#define DBG_else  else


#else // !DBG

// Debug macros compile out of non-DBG builds.
//
#define TRACE(ulLevel,ulMask,Args)
#undef ASSERT
#define ASSERT(x)
#define DUMP(ulLevel,ulMask,p,cb,f,dw)
#define DUMPB(ulLevel,ulMask,p,cb)
#define DUMPW(ulLevel,ulMask,p,cb)
#define DUMPDW(ulLevel,ulMask,p,cb)
#define CHECKLIST(ulMask,p,ulLevel)
#define DBG_if(x)
#define DBG_else

#endif


//-----------------------------------------------------------------------------
// Prototypes
//-----------------------------------------------------------------------------

VOID
CheckList(
    IN LIST_ENTRY* pList,
    IN BOOLEAN fShowLinks );

VOID
Dump(
    CHAR* p,
    ULONG cb,
    BOOLEAN fAddress,
    ULONG ulGroup );

VOID
DumpLine(
    CHAR* p,
    ULONG cb,
    BOOLEAN  fAddress,
    ULONG ulGroup );


#endif // _DEBUG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ndis\rasl2tp\kdext\makefile.inc ===
l2tpext.c:  l2tpext.h

precomp.h:  l2tpext.h

l2tpext.pph:    l2tpext.h
    @echo Creating $@ from $**
    $(C_PREPROCESSOR) $(C_DEFINES) $** > $@

dsotable.c: l2tpext.pph l2tpext.txt dsocode.c
    @echo Creating $@
    structo -i h -p -s l2tpext.txt -o $@ l2tpext.pph

clean:
    del dsotable.c l2tpext.pph
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ndis\raspppoe\debug.c ===
// Copyright (c) 1997, Microsoft Corporation, all rights reserved
//
// debug.c
// RAS L2TP WAN mini-port/call-manager driver
// Debug utilities and globals
//
// 01/07/97 Steve Cobb


#include <ntddk.h>
#include <ntddndis.h>
#include <ndis.h>

#include "debug.h"


//-----------------------------------------------------------------------------
// Global data definitions
//-----------------------------------------------------------------------------

#ifdef TESTMODE
#define DEFAULTTRACELEVEL  TL_N
#define DEFAULTTRACEMASK   TM_Wild & ~( TM_Time | TM_Pool )
#else
#define DEFAULTTRACELEVEL  TL_None
#define DEFAULTTRACEMASK   TM_Base
#endif

// Active debug trace level and active trace set mask.  Set these variables
// with the debugger at startup to enable and filter the debug output.  All
// messages with (TL_*) level less than or equal to 'g_ulTraceLevel' are
// displayed.  All messages from any (TM_*) set(s) present in 'g_ulTraceMask'
// are displayed.
//
ULONG g_ulTraceLevel = DEFAULTTRACELEVEL;
ULONG g_ulTraceMask = DEFAULTTRACEMASK;


//-----------------------------------------------------------------------------
// Routines
//-----------------------------------------------------------------------------


#if DBG
VOID
CheckList(
    IN LIST_ENTRY* pList,
    IN BOOLEAN fShowLinks )

    // Tries to detect corruption in list 'pList', printing verbose linkage
    // output if 'fShowLinks' is set.
    //
{
    LIST_ENTRY* pLink;
    ULONG ul;

    ul = 0;
    for (pLink = pList->Flink;
         pLink != pList;
         pLink = pLink->Flink)
    {
        if (fShowLinks)
        {
            DbgPrint( "L2TP: CheckList($%p) Flink(%d)=$%p\n",
                pList, ul, pLink );
        }
        ++ul;
    }

    for (pLink = pList->Blink;
         pLink != pList;
         pLink = pLink->Blink)
    {
        if (fShowLinks)
        {
            DbgPrint( "L2TP: CheckList($%p) Blink(%d)=$%p\n",
                pList, ul, pLink );
        }
        --ul;
    }

    if (ul)
    {
        DbgBreakPoint();
    }
}
#endif


#if DBG
VOID
Dump(
    IN CHAR* p,
    IN ULONG cb,
    IN BOOLEAN fAddress,
    IN ULONG ulGroup )

    // Hex dump 'cb' bytes starting at 'p' grouping 'ulGroup' bytes together.
    // For example, with 'ulGroup' of 1, 2, and 4:
    //
    // 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 |................|
    // 0000 0000 0000 0000 0000 0000 0000 0000 |................|
    // 00000000 00000000 00000000 00000000 |................|
    //
    // If 'fAddress' is true, the memory address dumped is prepended to each
    // line.
    //
{
    while (cb)
    {
        INT cbLine;

        cbLine = (cb < DUMP_BytesPerLine) ? cb : DUMP_BytesPerLine;
        DumpLine( p, cbLine, fAddress, ulGroup );
        cb -= cbLine;
        p += cbLine;
    }
}
#endif


#if DBG
VOID
DumpLine(
    IN CHAR* p,
    IN ULONG cb,
    IN BOOLEAN fAddress,
    IN ULONG ulGroup )
{
    CHAR* pszDigits = "0123456789ABCDEF";
    CHAR szHex[ ((2 + 1) * DUMP_BytesPerLine) + 1 ];
    CHAR* pszHex = szHex;
    CHAR szAscii[ DUMP_BytesPerLine + 1 ];
    CHAR* pszAscii = szAscii;
    ULONG ulGrouped = 0;

    if (fAddress)
        DbgPrint( "L2TP: %p: ", p );
    else
        DbgPrint( "L2TP: " );

    while (cb)
    {
        *pszHex++ = pszDigits[ ((UCHAR )*p) / 16 ];
        *pszHex++ = pszDigits[ ((UCHAR )*p) % 16 ];

        if (++ulGrouped >= ulGroup)
        {
            *pszHex++ = ' ';
            ulGrouped = 0;
        }

        *pszAscii++ = (*p >= 32 && *p < 128) ? *p : '.';

        ++p;
        --cb;
    }

    *pszHex = '\0';
    *pszAscii = '\0';

    DbgPrint(
        "%-*s|%-*s|\n",
        (2 * DUMP_BytesPerLine) + (DUMP_BytesPerLine / ulGroup), szHex,
        DUMP_BytesPerLine, szAscii );
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ndis\raspppoe\fsm.h ===
#ifndef _FSM_H_
#define _FSM_H_

VOID
FsmMakeCall(
	IN CALL* pCall
	);

VOID
FsmReceiveCall(
	IN CALL* pCall,
	IN BINDING* pBinding,
	IN PPPOE_PACKET* pPacket
	);

NDIS_STATUS
FsmAnswerCall(
	IN CALL* pCall
	);
	
VOID 
FsmRun(
	IN CALL* pCall,
	IN BINDING* pBinding,
	IN PPPOE_PACKET* pRecvPacket,
	IN NDIS_STATUS* pStatus
	);

VOID
FsmSendPADITimeout(
    IN TIMERQITEM* pTqi,
    IN VOID* pContext,
    IN TIMERQEVENT event 
    );

VOID
FsmSendPADRTimeout(
    IN TIMERQITEM* pTqi,
    IN VOID* pContext,
    IN TIMERQEVENT event 
    );    


VOID
FsmOfferingTimeout(
    IN TIMERQITEM* pTqi,
    IN VOID* pContext,
    IN TIMERQEVENT event 
    );

  
#endif // _FSM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ndis\raspppoe\main.c ===
// Copyright (c) 2000, Microsoft Corporation, all rights reserved
//
// main.c
// RAS PPPoE mini-port/call-manager driver
// Main routine (DriverEntry) and global data definitions
//
// 01/26/2000 Hakan BERK
//


#include <ntddk.h>
#include <ndis.h>
#include <ndiswan.h>
#include <ndistapi.h>

#include "debug.h"
#include "timer.h"
#include "bpool.h"
#include "ppool.h"
#include "util.h"
#include "packet.h"
#include "protocol.h"
#include "miniport.h"
#include "packet.h"

//-----------------------------------------------------------------------------
// Global Variables
//-----------------------------------------------------------------------------

NDIS_HANDLE gl_NdisWrapperHandle = NULL;
NDIS_HANDLE gl_NdisProtocolHandle = NULL;

//
// Lookaside list for work items
//
NPAGED_LOOKASIDE_LIST gl_llistWorkItems;

//-----------------------------------------------------------------------------
// Local prototypes
//-----------------------------------------------------------------------------


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath );

//
// Mark routine to be unloaded after initialization.
//
#pragma NDIS_INIT_FUNCTION(DriverEntry)


VOID
DriverUnload(
    IN PDRIVER_OBJECT DriverObject
    );

//-----------------------------------------------------------------------------
// Routines
//-----------------------------------------------------------------------------

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    The DriverEntry routine is the main entry point for the driver.
    It is responsible for the initializing the Miniport wrapper and
    registering the driver with the Miniport wrapper.

Parameters:

    DriverObject _ Pointer to driver object created by the system.

    RegistryPath _ Pointer to registery path name used to read registry
                   parameters.

Return Values:

    STATUS_SUCCESS
    STATUS_UNSUCCESSFUL

---------------------------------------------------------------------------*/
{
    NTSTATUS ntStatus;
    NDIS_STATUS status;

    TRACE( TL_N, TM_Mn, ( "+DriverEntry" ) );

    do
    {

        //
        // Register miniport
        //
        status = MpRegisterMiniport( DriverObject, RegistryPath, &gl_NdisWrapperHandle );

        if (status != NDIS_STATUS_SUCCESS)
        {
            TRACE( TL_A, TM_Mn, ( "MpRegisterMiniport=$%x", status ) );
            break;
        }

        //
        // Register protocol
        //
        status = PrRegisterProtocol( DriverObject, RegistryPath, &gl_NdisProtocolHandle );

        if (status != NDIS_STATUS_SUCCESS)
        {
            TRACE( TL_A, TM_Mn, ( "PrRegisterProtocol=$%x", status ) );
            break;
        }

        //
        // Set driver object's unload function
        //
        NdisMRegisterUnloadHandler( gl_NdisWrapperHandle, DriverUnload );
        
        //
        // Initialize the lookaside list for bindings
        //
        InitializeWorkItemLookasideList( &gl_llistWorkItems,
                                         MTAG_LLIST_WORKITEMS );

    } while ( FALSE );
    
    if ( status == NDIS_STATUS_SUCCESS )
    {
        ntStatus = STATUS_SUCCESS;
    }
    else
    {
        if(NULL != gl_NdisWrapperHandle)
        {
            NdisTerminateWrapper(gl_NdisWrapperHandle, NULL);
            gl_NdisWrapperHandle = NULL;
        }
        
        ntStatus = STATUS_UNSUCCESSFUL;
    }

    TRACE( TL_N, TM_Mn, ( "-DriverEntry=$%x",ntStatus ) );

    return ntStatus;
}

VOID
DriverUnload(
    IN PDRIVER_OBJECT DriverObject
    )
{
    NDIS_STATUS Status;
    
    TRACE( TL_N, TM_Mn, ( "+DriverUnload" ) );

    //
    // First deregister the protocol
    //
    NdisDeregisterProtocol( &Status, gl_NdisProtocolHandle );

    //
    // Clean up the protocol resources before driver unloads
    //
    PrUnload();

    NdisDeleteNPagedLookasideList( &gl_llistWorkItems );

    TRACE( TL_N, TM_Mn, ( "-DriverUnload" ) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ndis\raspppoe\miniport.c ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Module Name:

    miniport.c

Abstract:

    This module contains all the Miniport interface processing routines.  

Author:

    Hakan Berk - Microsoft, Inc. (hakanb@microsoft.com) Feb-2000

Environment:

    Windows 2000 kernel mode Miniport driver or equivalent.

Revision History:

---------------------------------------------------------------------------*/
#include <ntddk.h>
#include <ntddndis.h>
#include <ndis.h>
#include <ndiswan.h>
#include <ndistapi.h>
#include <ntverp.h>

#include "debug.h"
#include "timer.h"
#include "bpool.h"
#include "ppool.h"
#include "util.h"
#include "packet.h"
#include "protocol.h"
#include "miniport.h"
#include "tapi.h"
#include "fsm.h"

//
// This is our global adapter context
//
ADAPTER* gl_pAdapter = NULL;

//
// Lock that controls access to gl_pAdapter.
// This lock is necesarry for requests submitted from the bindings as
// they will not know if the adapter is halted or not.
//
NDIS_SPIN_LOCK gl_lockAdapter;

//
// We need a flag to indicate if lock is allocated or not
//
BOOLEAN gl_fLockAllocated = FALSE;

//
// The timer queue that handles the scheduled timer events.
//
TIMERQ gl_TimerQ;

//
// This is used to create a unique identifier in packets
//
ULONG gl_UniqueCounter = 0;

VOID
CreateUniqueValue( 
    IN HDRV_CALL hdCall,
    OUT CHAR* pUniqueValue,
    OUT USHORT* pSize
    )
{
    CHAR* pBuf = pUniqueValue;
    ULONG usUniqueValue = InterlockedIncrement( &gl_UniqueCounter );
    
    NdisMoveMemory( pBuf, (CHAR*) &hdCall, sizeof( HDRV_CALL ) );

    pBuf += sizeof( HDRV_CALL );

    NdisMoveMemory( pBuf, (CHAR*) &usUniqueValue, sizeof( ULONG ) );
    
    *pSize = sizeof( HDRV_CALL ) + sizeof( ULONG );

}

HDRV_CALL
RetrieveHdCallFromUniqueValue(
    IN CHAR* pUniqueValue,
    IN USHORT Size
    )
{
    
    if ( Size != sizeof( HDRV_CALL ) + sizeof( ULONG ) )
        return (HDRV_CALL) NULL;

    return ( * (UNALIGNED HDRV_CALL*) pUniqueValue );
}
    

////////////////////////////////////
//
// Local function prototypes
//
////////////////////////////////////

VOID 
ReferenceAdapter(
    IN ADAPTER* pAdapter,
    IN BOOLEAN fAcquireLock
    );

VOID DereferenceAdapter(
    IN ADAPTER* pAdapter
    );

ADAPTER* AllocAdapter();

VOID FreeAdapter( 
    ADAPTER* pAdapter
    );

NDIS_STATUS MpInitialize(
    OUT PNDIS_STATUS  OpenErrorStatus,
    OUT PUINT  SelectedMediumIndex,
    IN PNDIS_MEDIUM  MediumArray,
    IN UINT  MediumArraySize,
    IN NDIS_HANDLE  MiniportAdapterHandle,
    IN NDIS_HANDLE  WrapperConfigurationContext
    );

VOID MpHalt(
    IN NDIS_HANDLE MiniportAdapterContext
    );

NDIS_STATUS MpReset(
    OUT PBOOLEAN    AddressingReset,
    IN  NDIS_HANDLE MiniportAdapterContext
    );

NDIS_STATUS MpWanSend(
    IN NDIS_HANDLE  MiniportAdapterContext,
    IN NDIS_HANDLE  NdisLinkHandle,
    IN PNDIS_WAN_PACKET  WanPacket
    );

NDIS_STATUS MpQueryInformation(
    IN NDIS_HANDLE  MiniportAdapterContext,
    IN NDIS_OID  Oid,
    IN PVOID  InformationBuffer,
    IN ULONG  InformationBufferLength,
    OUT PULONG  BytesWritten,
    OUT PULONG  BytesNeeded
    );

NDIS_STATUS MpSetInformation(
    IN NDIS_HANDLE  MiniportAdapterContext,
    IN NDIS_OID  Oid,
    IN PVOID  InformationBuffer,
    IN ULONG  InformationBufferLength,
    OUT PULONG  BytesWritten,
    OUT PULONG  BytesNeeded
    );

////////////////////////////////////
//
// Interface functions definitions
//
////////////////////////////////////

NDIS_STATUS 
MpRegisterMiniport(
    IN PDRIVER_OBJECT pDriverObject,
    IN PUNICODE_STRING pRegistryPath,
    OUT NDIS_HANDLE* pNdisWrapperHandle
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function will be called from DriverEntry() to register the miniport
    and create an instance of the adapter.
    
Parameters:

    DriverObject _ Pointer to driver object created by the system.

    RegistryPath _ Pointer to registery path name used to read registry
                   parameters.
    
Return Values:

    NDIS_STATUS_SUCCESFUL: Miniport registered succesfully.

    NDIS_STATUS_FAILURE: Miniport failed to register succesfully.
---------------------------------------------------------------------------*/
{
    NDIS_HANDLE NdisWrapperHandle;
    NDIS_STATUS status;
    NDIS_MINIPORT_CHARACTERISTICS nmc;

    TRACE( TL_I, TM_Mp, ("+MpRegisterMiniport") );

    NdisMInitializeWrapper( &NdisWrapperHandle,
                            pDriverObject,
                            pRegistryPath,
                            NULL );

    //
    // Fill in the miniport characteristics
    //
    NdisZeroMemory( &nmc, sizeof( NDIS_MINIPORT_CHARACTERISTICS ) );

    nmc.MajorNdisVersion = MP_NDIS_MajorVersion;
    nmc.MinorNdisVersion = MP_NDIS_MinorVersion;
    nmc.Reserved = NDIS_USE_WAN_WRAPPER;

    nmc.InitializeHandler = MpInitialize;
    nmc.ResetHandler = MpReset;
    nmc.HaltHandler = MpHalt;
    nmc.QueryInformationHandler = MpQueryInformation;
    nmc.SetInformationHandler = MpSetInformation;
    nmc.WanSendHandler = MpWanSend;
    // no CheckForHangHandler
    // no DisableInterruptHandler
    // no EnableInterruptHandler
    // no HandleInterruptHandler
    // no ISRHandler
    // no SendHandler (see WanSendHandler)
    // no TransferDataHandler
    // no WanTransferDataHandler
    // no ReturnPacketHandler
    // no SendPacketsHandler (see WanSendHandler)
    // no AllocateCompleteHandler
    // no CoActivateVcHandler
    // no CoDeactivateVcHandler
    // no CoSendPacketsHandler 
    // no CoRequestHandler
        
    //
    // Set the characteristics registering the miniport
    //
    status = NdisMRegisterMiniport( NdisWrapperHandle,
                                    &nmc,
                                    sizeof( NDIS_MINIPORT_CHARACTERISTICS ) );

    //
    // If registeration of miniport was not successful,
    // undo the initialization of wrapper
    //
    if ( status != NDIS_STATUS_SUCCESS )
    {
        NdisTerminateWrapper( NdisWrapperHandle, NULL );
    }
    else
    {
        *pNdisWrapperHandle = NdisWrapperHandle;
    }

    TRACE( TL_I, TM_Mp, ("-MpRegisterMiniport=$%x",status) );
        
    return status;
}



////////////////////////////////////
//
// Local function definitions
//
////////////////////////////////////

VOID 
ReferenceAdapter(
    IN ADAPTER* pAdapter,
    IN BOOLEAN fAcquireLock
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function will increment the reference count on the adapter object.
    
    CAUTION: If fAcquireLock is set, this function will acquire the lock for the
             call, otherwise it will assume the caller owns the lock.
    
Parameters:

    pAdapter _ A pointer to our call information structure.

    fAcquireLock _ Indicates if the caller already has the lock or not.
                   Caller must set this flag to FALSE if it has the lock, 
                   otherwise it must be supplied as TRUE.

Return Values:

    None
---------------------------------------------------------------------------*/
{
    LONG lRef;
    
    ASSERT( VALIDATE_ADAPTER( pAdapter ) );

    TRACE( TL_V, TM_Mp, ("+ReferenceAdapter") );

    if ( fAcquireLock )
        NdisAcquireSpinLock( &pAdapter->lockAdapter );

    lRef = ++pAdapter->lRef;

    if ( fAcquireLock )
        NdisReleaseSpinLock( &pAdapter->lockAdapter );

    TRACE( TL_V, TM_Mp, ("-ReferenceAdapter=$%d",lRef) );
}

VOID 
DereferenceAdapter(
    IN ADAPTER* pAdapter
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function will decrement the reference count on the adapter object

    If the ref count drops to 0 (which means the adapter has been halted),
    it will set fire pAdapter->eventAdapterHalted. 

Parameters:

    pAdapter _ A pointer ot our call information structure.

Return Values:

    None
---------------------------------------------------------------------------*/   
{
    LONG lRef;
    BOOLEAN fSignalAdapterHaltedEvent = FALSE;
    
    ASSERT( VALIDATE_ADAPTER( pAdapter ) );

    TRACE( TL_V, TM_Mp, ("+DereferenceAdapter") );

    NdisAcquireSpinLock( &pAdapter->lockAdapter );

    lRef = --pAdapter->lRef;
    
    if ( lRef == 0 )
    {

        pAdapter->ulMpFlags &= ~MPBF_MiniportInitialized;
        pAdapter->ulMpFlags &= ~MPBF_MiniportHaltPending;
        pAdapter->ulMpFlags |= MPBF_MiniportHalted;
                    
        fSignalAdapterHaltedEvent = TRUE;
    }

    NdisReleaseSpinLock( &pAdapter->lockAdapter );


    //
    // Signal the halting of the adapter if we need to
    //
    if ( fSignalAdapterHaltedEvent )
        NdisSetEvent( &pAdapter->eventAdapterHalted );

    TRACE( TL_V, TM_Mp, ("-DereferenceAdapter=$%x",lRef) );
}

ADAPTER* 
AllocAdapter()
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function will allocate the resources for the adapter object and return
    a pointer to it.
    
Parameters:

    None
    
Return Values:

    pAdapter: A pointer to the newly allocated adapter object.
    
    NULL: Resources were not available to create the adapter.
    
---------------------------------------------------------------------------*/
{
    ADAPTER* pAdapter = NULL;

    TRACE( TL_N, TM_Mp, ("+AllocAdapter") );

    if ( ALLOC_ADAPTER( &pAdapter ) != NDIS_STATUS_SUCCESS )
    {
        TRACE( TL_A, TM_Mp, ("AllocAdapter: Could not allocate context") );

        TRACE( TL_N, TM_Mp, ("-AllocAdapter") );

        return NULL;
    }

    //
    // Clear the memory 
    //
    NdisZeroMemory( pAdapter, sizeof( ADAPTER ) );

    //
    // Initialize adapter tag
    //
    pAdapter->tagAdapter = MTAG_ADAPTER;
        
    //
    // Allocate the lock that controls access to the adapter
    //
    NdisAllocateSpinLock( &pAdapter->lockAdapter );

    //
    // Initialize the state
    //
    pAdapter->ulMpFlags = MPBF_MiniportIdle;

    TRACE( TL_N, TM_Mp, ("-AllocAdapter") );

    return pAdapter;
}

NDIS_STATUS
ReadRegistrySettings(
    IN OUT ADAPTER* pAdapter,
    IN     NDIS_HANDLE WrapperConfigurationContext
    )
{
    NDIS_STATUS status = NDIS_STATUS_FAILURE;
    NDIS_HANDLE hCfg = 0;
    NDIS_CONFIGURATION_PARAMETER* pncp = 0;
    BOOLEAN fMaxLinesDefinedInRegistry = FALSE;

    TRACE( TL_N, TM_Mp, ("+ReadRegistrySettings") );

    do
    {
        //
        // Open the Ndis configuration, it will be closed at the end of the
        // while loop before we exit it. 
        //
        NdisOpenConfiguration( &status, 
                               &hCfg, 
                               WrapperConfigurationContext );

        if ( status != NDIS_STATUS_SUCCESS )
        {
            TRACE( TL_A, TM_Mp, ("ReadRegistrySettings: NdisOpenConfiguration() failed") );

            break;
        }

        //
        // Read fClientRole value from the registry only in the debug builds
        //
        {
#if DBG        
            NDIS_STRING nstr = NDIS_STRING_CONST( "fClientRole" );

            NdisReadConfiguration( &status, 
                                   &pncp, 
                                   hCfg, 
                                   &nstr, 
                                   NdisParameterInteger );
                                   
            if (status == NDIS_STATUS_SUCCESS)
            {
                TRACE( TL_N, TM_Mp, ("ReadRegistrySettings: Read fClientRole from registry") );

                pAdapter->fClientRole = ( pncp->ParameterData.IntegerData > 0 ) ? TRUE : FALSE;
            }
            else
#endif        
            {
                TRACE( TL_N, TM_Mp, ("ReadRegistrySettings: Could not read fClientRole from registry, using default value") );

                pAdapter->fClientRole = TRUE;

                status = NDIS_STATUS_SUCCESS;
            }

        }

#if DBG
        //
        // Read ServiceName and ServiceNameLength values from the registry.
        // These are server side only values.
        //
        {
            NDIS_STRING nstr = NDIS_STRING_CONST( "ServiceName" );


            NdisReadConfiguration( &status, 
                                   &pncp, 
                                   hCfg, 
                                   &nstr, 
                                   NdisParameterString );

            if (status == NDIS_STATUS_SUCCESS)
            {
                ANSI_STRING AnsiString;

                NdisZeroMemory( &AnsiString, sizeof( ANSI_STRING ) );
                
                status = RtlUnicodeStringToAnsiString( &AnsiString, &pncp->ParameterData.StringData, TRUE );

                if ( status == STATUS_SUCCESS )
                {
                    TRACE( TL_N, TM_Mp, ("ReadRegistrySettings: Read ServiceName from registry") );

                    pAdapter->nServiceNameLength = ( MAX_SERVICE_NAME_LENGTH < AnsiString.Length ) ? 
                                                     MAX_SERVICE_NAME_LENGTH : AnsiString.Length;

                    NdisMoveMemory( pAdapter->ServiceName, AnsiString.Buffer, pAdapter->nServiceNameLength ) ;

                    RtlFreeAnsiString( &AnsiString );
                }
                
            }

            if ( status != NDIS_STATUS_SUCCESS )
            {
                PWSTR wszKeyName = L"ComputerName";
                PWSTR wszPath = L"ComputerName\\ComputerName";
                RTL_QUERY_REGISTRY_TABLE QueryTable[2];
                UNICODE_STRING UnicodeStr;
                WCHAR wszName[ MAX_COMPUTERNAME_LENGTH + 1];
    
                NdisZeroMemory( QueryTable, 2 * sizeof( RTL_QUERY_REGISTRY_TABLE ) );
                
                QueryTable[0].QueryRoutine = NULL;
                QueryTable[0].Flags = RTL_QUERY_REGISTRY_REQUIRED | RTL_QUERY_REGISTRY_DIRECT;
                QueryTable[0].Name = wszKeyName;
                QueryTable[0].EntryContext = (PVOID) &UnicodeStr;
                
                NdisZeroMemory( &UnicodeStr, sizeof( UNICODE_STRING ) );
    
                UnicodeStr.Length = 0;
                UnicodeStr.MaximumLength = MAX_COMPUTERNAME_LENGTH + 1;
                UnicodeStr.Buffer = wszName;
    
                status = RtlQueryRegistryValues( RTL_REGISTRY_CONTROL, 
                                                 wszPath,
                                                 QueryTable,
                                                 NULL,
                                                 NULL );
    
                if ( status == STATUS_SUCCESS )
                {
                    ANSI_STRING AnsiString;
    
                    NdisZeroMemory( &AnsiString, sizeof( ANSI_STRING ) );
                    
                    status = RtlUnicodeStringToAnsiString( &AnsiString, &UnicodeStr, TRUE );
    
                    if ( status == STATUS_SUCCESS )
                    {
                        TRACE( TL_N, TM_Mp, ("ReadRegistrySettings: Using Machine Name as ServiceName") );
    
                        NdisMoveMemory( pAdapter->ServiceName, AnsiString.Buffer, AnsiString.Length );
    
                        NdisMoveMemory( pAdapter->ServiceName + AnsiString.Length, 
                                        SERVICE_NAME_EXTENSION, 
                                        sizeof( SERVICE_NAME_EXTENSION ) );
    
                        //
                        // -1 is to ignore the terminating NULL character
                        //
                        pAdapter->nServiceNameLength = AnsiString.Length + sizeof( SERVICE_NAME_EXTENSION ) - 1;
    
                        RtlFreeAnsiString( &AnsiString );
    
                        status = NDIS_STATUS_SUCCESS;
                    }
                }

            }

            if ( status != NDIS_STATUS_SUCCESS )
            {
                TRACE( TL_N, TM_Mp, ("ReadRegistrySettings: Using default hardcoded service name") );

                NdisMoveMemory( pAdapter->ServiceName, "MS-RAS PPPoE", sizeof( "MS-RAS PPPoE" ) );

                pAdapter->nServiceNameLength = ( sizeof( "MS-RAS PPPoE" ) / sizeof( CHAR ) ) - 1;

                status = NDIS_STATUS_SUCCESS;
            }

            //
            // Future: Convert service name to UTF-8
            //         It turns out that we can not do this conversion from a kernel module,
            //         so the value read from the registry must be in UTF-8 format itself.
            //
            
        }

        //
        // Read AC-Name and AC-NameLength values from the registry.
        // These are server side only values.
        //
        {
            NDIS_STRING nstr = NDIS_STRING_CONST( "ACName" );

            NdisReadConfiguration( &status, 
                                   &pncp, 
                                   hCfg, 
                                   &nstr, 
                                   NdisParameterString );
                                   
            if (status == NDIS_STATUS_SUCCESS)
            {
                ANSI_STRING AnsiString;

                NdisZeroMemory( &AnsiString, sizeof( ANSI_STRING ) );
                
                status = RtlUnicodeStringToAnsiString( &AnsiString, &pncp->ParameterData.StringData, TRUE );

                if ( status == STATUS_SUCCESS )
                {
                    TRACE( TL_N, TM_Mp, ("ReadRegistrySettings: Read AC-Name from registry") );
                    
                    pAdapter->nACNameLength = ( MAX_AC_NAME_LENGTH < AnsiString.Length ) ? 
                                                MAX_AC_NAME_LENGTH : AnsiString.Length;
                                                     
                    NdisMoveMemory( pAdapter->ACName, AnsiString.Buffer, pAdapter->nACNameLength ) ;
                
                    RtlFreeAnsiString( &AnsiString );

                }
                
            }

            if ( status != NDIS_STATUS_SUCCESS )
            {
                PWSTR wszKeyName = L"ComputerName";
                PWSTR wszPath = L"ComputerName\\ComputerName";
                RTL_QUERY_REGISTRY_TABLE QueryTable[2];
                UNICODE_STRING UnicodeStr;
                WCHAR wszName[ MAX_COMPUTERNAME_LENGTH + 1];
    
                NdisZeroMemory( QueryTable, 2 * sizeof( RTL_QUERY_REGISTRY_TABLE ) );
                
                QueryTable[0].QueryRoutine = NULL;
                QueryTable[0].Flags = RTL_QUERY_REGISTRY_REQUIRED | RTL_QUERY_REGISTRY_DIRECT;
                QueryTable[0].Name = wszKeyName;
                QueryTable[0].EntryContext = (PVOID) &UnicodeStr;
                
                NdisZeroMemory( &UnicodeStr, sizeof( UNICODE_STRING ) );
    
                UnicodeStr.Length = 0;
                UnicodeStr.MaximumLength = MAX_COMPUTERNAME_LENGTH + 1;
                UnicodeStr.Buffer = wszName;
    
                status = RtlQueryRegistryValues( RTL_REGISTRY_CONTROL, 
                                                 wszPath,
                                                 QueryTable,
                                                 NULL,
                                                 NULL );
    
                if ( status == STATUS_SUCCESS )
                {
                    ANSI_STRING AnsiString;
    
                    NdisZeroMemory( &AnsiString, sizeof( ANSI_STRING ) );
                    
                    status = RtlUnicodeStringToAnsiString( &AnsiString, &UnicodeStr, TRUE );
    
                    if ( status == STATUS_SUCCESS )
                    {
                        TRACE( TL_N, TM_Mp, ("ReadRegistrySettings: Using Machine Name as AC-Name") );
    
                        NdisMoveMemory( pAdapter->ACName, AnsiString.Buffer, AnsiString.Length );
    
                        pAdapter->nACNameLength = AnsiString.Length;
    
                        RtlFreeAnsiString( &AnsiString );
    
                        status = NDIS_STATUS_SUCCESS;
                    }
                }

            }

            if ( status != NDIS_STATUS_SUCCESS )
            {
                TRACE( TL_N, TM_Mp, ("ReadRegistrySettings: Using default hardcoded value for AC-Name") );

                NdisMoveMemory( pAdapter->ACName, "MS-RAS Access Concentrator", sizeof( "MS-RAS Access Concentrator" ) );

                pAdapter->nACNameLength = ( sizeof( "MS-RAS Access Concentrator" ) / sizeof( CHAR ) ) - 1;

                status = NDIS_STATUS_SUCCESS;
            }

            //
            // Future: Convert AC name to UTF-8
            //         It turns out that we can not do this conversion from a kernel module,
            //         so the value read from the registry must be in UTF-8 format itself.
            //
            
        }

        //
        // Read nClientQuota value
        // These is a server side only value.
        //
        {
            NDIS_STRING nstr = NDIS_STRING_CONST( "ClientQuota" );

            NdisReadConfiguration( &status, 
                                   &pncp, 
                                   hCfg, 
                                   &nstr, 
                                   NdisParameterInteger );
                                   
            if (status == NDIS_STATUS_SUCCESS)
            {
                TRACE( TL_N, TM_Mp, ("ReadRegistrySettings: Read ClientQuota from registry") );

                pAdapter->nClientQuota = (UINT) pncp->ParameterData.IntegerData;
            }
            else
#endif            
            {
                TRACE( TL_N, TM_Mp, ("ReadRegistrySettings: Could not read ClientQuota from registry, using default value") );
                
                pAdapter->nClientQuota = 3;

                status = NDIS_STATUS_SUCCESS;
            }
#if DBG
        }

        //
        // Read MaxLines value
        //
        {
            NDIS_STRING nstr = NDIS_STRING_CONST( "MaxLines" );

            NdisReadConfiguration( &status, 
                                   &pncp, 
                                   hCfg, 
                                   &nstr, 
                                   NdisParameterInteger );
                                   
            if (status == NDIS_STATUS_SUCCESS)
            {
                TRACE( TL_N, TM_Mp, ("ReadRegistrySettings: Read MaxLines from registry") );

                pAdapter->nMaxLines = (UINT) pncp->ParameterData.IntegerData;

                fMaxLinesDefinedInRegistry = TRUE;
            }
            else
#endif            
            {
                TRACE( TL_N, TM_Mp, ("ReadRegistrySettings: Could not read MaxLines from registry, using default value") );
                
                pAdapter->nMaxLines = 1;

                status = NDIS_STATUS_SUCCESS;
            }
#if DBG
        }

        //
        // Read CallsPerLine value
        //
        {
            NDIS_STRING nstr = NDIS_STRING_CONST( "CallsPerLine" );

            NdisReadConfiguration( &status, 
                                   &pncp, 
                                   hCfg, 
                                   &nstr, 
                                   NdisParameterInteger );
                                   
            if (status == NDIS_STATUS_SUCCESS)
            {
                TRACE( TL_N, TM_Mp, ("ReadRegistrySettings: Read CallsPerLine from registry") );

                pAdapter->nCallsPerLine = (UINT) pncp->ParameterData.IntegerData;
            }
            else
#endif            
            {
                TRACE( TL_N, TM_Mp, ("ReadRegistrySettings: Could not read CallsPerLine from registry, using default value") );
                
                pAdapter->nCallsPerLine = 1;

                status = NDIS_STATUS_SUCCESS;
            }
#if DBG            
        }
#endif
        //
        // Read WanEndPoints if MaxLines was not defined in registry
        //
        if ( !fMaxLinesDefinedInRegistry )
        {
            NDIS_STRING nstr = NDIS_STRING_CONST( "WanEndPoints" );

            NdisReadConfiguration( &status, 
                                   &pncp, 
                                   hCfg, 
                                   &nstr, 
                                   NdisParameterInteger );
                                   
            if (status == NDIS_STATUS_SUCCESS)
            {
                TRACE( TL_N, TM_Mp, ("ReadRegistrySettings: Read WanEndPoints from registry") );

                pAdapter->nMaxLines = 1;

                pAdapter->nCallsPerLine = (UINT) pncp->ParameterData.IntegerData;
            }

            status = NDIS_STATUS_SUCCESS;
        }

        //
        // Read MaxTimeouts value
        //
        {
            NDIS_STRING nstr = NDIS_STRING_CONST( "MaxTimeouts" );

            NdisReadConfiguration( &status, 
                                   &pncp, 
                                   hCfg, 
                                   &nstr, 
                                   NdisParameterInteger );
                                   
            if (status == NDIS_STATUS_SUCCESS)
            {
                TRACE( TL_N, TM_Mp, ("ReadRegistrySettings: Read MaxTimeouts from registry") );

                pAdapter->nMaxTimeouts = (UINT) pncp->ParameterData.IntegerData;
            }
            else
            {
                TRACE( TL_N, TM_Mp, ("ReadRegistrySettings: Could not read MaxTimeouts from registry, using default value") );

                pAdapter->nMaxTimeouts = 3;

                status = NDIS_STATUS_SUCCESS;
            }
        }

        //
        // Read SendTimeout value
        //
        {
            NDIS_STRING nstr = NDIS_STRING_CONST( "SendTimeout" );

            NdisReadConfiguration( &status, 
                                   &pncp, 
                                   hCfg, 
                                   &nstr, 
                                   NdisParameterInteger );
                                   
            if (status == NDIS_STATUS_SUCCESS)
            {
                TRACE( TL_N, TM_Mp, ("ReadRegistrySettings: Read SendTimeout from registry") );

                pAdapter->ulSendTimeout = (ULONG) pncp->ParameterData.IntegerData;
            }
            else
            {
                TRACE( TL_N, TM_Mp, ("ReadRegistrySettings: Could not read SendTimeout from registry, using default value") );
                
                pAdapter->ulSendTimeout = 5000;

                status = NDIS_STATUS_SUCCESS;
            }
        }

        //
        // Read RecvTimeout value
        //
        {
            NDIS_STRING nstr = NDIS_STRING_CONST( "RecvTimeout" );

            NdisReadConfiguration( &status, 
                                   &pncp, 
                                   hCfg, 
                                   &nstr, 
                                   NdisParameterInteger );
                                   
            if (status == NDIS_STATUS_SUCCESS)
            {
                TRACE( TL_N, TM_Mp, ("ReadRegistrySettings: Read RecvTimeout from registry") );

                pAdapter->ulRecvTimeout = (ULONG) pncp->ParameterData.IntegerData;
            }
            else
            {
                TRACE( TL_N, TM_Mp, ("ReadRegistrySettings: Could not read RecvTimeout from registry, using default value") );
                
                pAdapter->ulRecvTimeout = 5000;

                status = NDIS_STATUS_SUCCESS;
            }
        }

        //
        // Read fAcceptAnyService value from the registry
        //
        {
            NDIS_STRING nstr = NDIS_STRING_CONST( "fAcceptAnyService" );

            NdisReadConfiguration( &status, 
                                   &pncp, 
                                   hCfg, 
                                   &nstr, 
                                   NdisParameterInteger );
                                   
            if (status == NDIS_STATUS_SUCCESS)
            {
                TRACE( TL_N, TM_Mp, ("ReadRegistrySettings: Read fAcceptAnyService from registry") );

                pAdapter->fAcceptAnyService = ( pncp->ParameterData.IntegerData > 0 ) ? TRUE : FALSE;
            }
            else
            {
                TRACE( TL_N, TM_Mp, ("ReadRegistrySettings: Could not read fAcceptAnyService from registry, using default value") );

                pAdapter->fAcceptAnyService = TRUE;

                status = NDIS_STATUS_SUCCESS;
            }

        }

        //
        // Close the Ndis configuration
        //
        NdisCloseConfiguration( hCfg );
        
    } while ( FALSE );

    TRACE( TL_N, TM_Mp, ("-ReadRegistrySettings=$%x",status) );

    return status;
}

NDIS_STATUS 
InitializeAdapter(
    IN ADAPTER* pAdapter,
    IN NDIS_HANDLE MiniportAdapterHandle,
    IN NDIS_HANDLE WrapperConfigurationContext
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function will initialize the contents of the adapter object.

    It will be called from inside MpInitialize() and it will read the necesarry
    values from the registry to initialize the adapter context.
    
Parameters:

    pAdapter _ A pointer to our adapter information structure.

Return Values:

    None
---------------------------------------------------------------------------*/   
{
    NDIS_STATUS status = NDIS_STATUS_SUCCESS;
    NDIS_PHYSICAL_ADDRESS HighestAcceptableAddress = NDIS_PHYSICAL_ADDRESS_CONST(-1,-1);
    
    ASSERT( VALIDATE_ADAPTER( pAdapter ) );

    TRACE( TL_N, TM_Mp, ("+InitializeAdapter") );

    //
    // Initialize and reset the adapter halted event
    //
    NdisInitializeEvent( &pAdapter->eventAdapterHalted );

    NdisResetEvent( &pAdapter->eventAdapterHalted );

    //
    // Set the state
    //
    pAdapter->ulMpFlags = MPBF_MiniportInitialized;

    //
    // Set NDIS's corresponding handle 
    //
    pAdapter->MiniportAdapterHandle = MiniportAdapterHandle;

    //
    // Read values from registry
    //
    status = ReadRegistrySettings( pAdapter, WrapperConfigurationContext );
    
    pAdapter->nMaxSendPackets = 1;

    //
    // Initialize the NdisWanInfo structure
    //
    pAdapter->NdisWanInfo.MaxFrameSize     = PACKET_PPP_PAYLOAD_MAX_LENGTH;
    pAdapter->NdisWanInfo.MaxTransmit      = 1;
    pAdapter->NdisWanInfo.HeaderPadding    = PPPOE_PACKET_HEADER_LENGTH;
    pAdapter->NdisWanInfo.TailPadding      = 0;
    pAdapter->NdisWanInfo.Endpoints        = pAdapter->nCallsPerLine * pAdapter->nMaxLines;
    pAdapter->NdisWanInfo.MemoryFlags      = 0;
    pAdapter->NdisWanInfo.HighestAcceptableAddress = HighestAcceptableAddress;
    pAdapter->NdisWanInfo.FramingBits      = PPP_FRAMING |
                                             // PPP_COMPRESS_ADDRESS_CONTROL |
                                             // PPP_COMPRESS_PROTOCOL_FIELD |
                                             TAPI_PROVIDER;
    pAdapter->NdisWanInfo.DesiredACCM      = 0;
    
    TRACE( TL_N, TM_Mp, ("-InitializeAdapter=$%x",status) );

    return status;
}

VOID 
FreeAdapter( 
    ADAPTER* pAdapter
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function will deallocate the resources for the adapter object.
    
Parameters:

    pAdapter _ A pointer to our adapter information structure.

Return Values:

    None
---------------------------------------------------------------------------*/
{

    ASSERT( VALIDATE_ADAPTER( pAdapter ) );

    TRACE( TL_N, TM_Mp, ("+FreeAdapter") );

    NdisFreeSpinLock( &pAdapter->lockAdapter );

    FREE_ADAPTER( pAdapter );

    TRACE( TL_N, TM_Mp, ("-FreeAdapter") );

}

NDIS_STATUS 
MpInitialize(
    OUT PNDIS_STATUS  OpenErrorStatus,
    OUT PUINT  SelectedMediumIndex,
    IN PNDIS_MEDIUM  MediumArray,
    IN UINT  MediumArraySize,
    IN NDIS_HANDLE  MiniportAdapterHandle,
    IN NDIS_HANDLE  WrapperConfigurationContext
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    The MiniportInitialize request is called to have the Miniport driver
    initialize the adapter.

    No other request will be outstanding on the Miniport when this routine
    is called.  No other request will be submitted to the Miniport until
    the operation is completed.

    The wrapper will supply an array containing a list of the media types
    that it supports.  The Miniport driver reads this array and returns
    the index of the media type that the wrapper should treat her as.
    If the Miniport driver is impersonating a media type that is different
    from the true media type, this must be done completely transparently to
    the wrapper.

    If the Miniport driver cannot find a media type supported by both it
    and the wrapper, it returns NDIS_STATUS_UNSUPPORTED_MEDIA.

    The status value NDIS_STATUS_OPEN_ERROR has a special meaning.  It
    indicates that the OpenErrorStatus parameter has returned a valid status
    which the wrapper can examine to obtain more information about the error.

    This routine is called with interrupts enabled, and a call to MiniportISR
    will occur if the adapter generates any interrupts.  During this routine
    MiniportDisableInterrupt and MiniportEnableInterrupt will not be called,
    so it is the responsibility of the Miniport driver to acknowledge and
    clear any interrupts generated.

    This routine will be called from the context of MpRegisterMiniport().

Parameters:

    OpenErrorStatus _ Returns more information about the reason for the
                      failure. Currently, the only values defined match those
                      specified as Open Error Codes in Appendix B of the IBM
                      Local Area Network Technical Reference.

    SelectedMediumIndex _ Returns the index in MediumArray of the medium type
                          that the Miniport driver wishes to be viewed as.
                          Note that even though the NDIS interface may complete
                          this request asynchronously, it must return this
                          index on completion of this function.

    MediumArray _ An array of medium types which the wrapper supports.

    MediumArraySize _ The number of elements in MediumArray.

    MiniportAdapterHandle _ A handle identifying the Miniport. The Miniport
                            driver must supply this handle in future requests
                            that refer to the Miniport.

    WrapperConfigurationContext _ The handle used for calls to NdisOpenConfiguration.

Return Values:

    NDIS_STATUS_ADAPTER_NOT_FOUND
    NDIS_STATUS_FAILURE
    NDIS_STATUS_NOT_ACCEPTED
    NDIS_STATUS_OPEN_ERROR
    NDIS_STATUS_RESOURCES
    NDIS_STATUS_SUCCESS
    NDIS_STATUS_UNSUPPORTED_MEDIA

---------------------------------------------------------------------------*/    
{
    NDIS_STATUS status = NDIS_STATUS_SUCCESS;
    ADAPTER* pAdapter = NULL;
    UINT i;

    TRACE( TL_I, TM_Mp, ("+MpInitialize") );

    do
    {
        //
        // Select the medium
        //
        for (i=0; i<MediumArraySize; i++)
        {
            if ( MediumArray[i] == NdisMediumWan )
                break;
        }

        //
        // Check if we have found a medium supported
        //
        if ( i < MediumArraySize )
        {
            *SelectedMediumIndex = i;
        }
        else
        {
            TRACE( TL_A, TM_Mp, ("MpInitialize: Unsupported Media") );

            status = NDIS_STATUS_UNSUPPORTED_MEDIA;
            
            break;
        }
    
        //
        // Allocate the adapter block
        //
        pAdapter = AllocAdapter();
        
        if ( pAdapter == NULL )
        {
            TRACE( TL_A, TM_Mp, ("MpInitialize: Resources unavailable") );

            status = NDIS_STATUS_FAILURE;
            
            break;
        }

        //
        // Initialize the adapter
        //
        status = InitializeAdapter( pAdapter, 
                                    MiniportAdapterHandle, 
                                    WrapperConfigurationContext );

        if ( status != NDIS_STATUS_SUCCESS )
        {
            TRACE( TL_A, TM_Mp, ("MpInitialize: InitializeAdapter() failed") );
            
            break;
        }
            
        //
        // Inform NDIS about our miniport adapter context
        //
        NdisMSetAttributesEx(MiniportAdapterHandle,
                             pAdapter,
                             0,
                             NDIS_ATTRIBUTE_IGNORE_PACKET_TIMEOUT |
                             NDIS_ATTRIBUTE_IGNORE_REQUEST_TIMEOUT |
                             NDIS_ATTRIBUTE_NO_HALT_ON_SUSPEND |
                             NDIS_ATTRIBUTE_DESERIALIZE,
                             NdisInterfaceInternal );

        //
        // Do the global initialization
        //
        gl_pAdapter = pAdapter;

        //
        // Allocate the packet pools
        //
        PacketPoolInit();

        //
        // Do one-time only initialization of global members
        //
        if ( !gl_fLockAllocated )
        {
            //
            // Allocate the spin lock
            //
            NdisAllocateSpinLock( &gl_lockAdapter );

            //
            // Initialize the timer queue
            //
            TimerQInitialize( &gl_TimerQ );

            //
            // Finally set lock allocated flag, and start giving access
            // to the adapter context for requests from the protocol
            //
            gl_fLockAllocated = TRUE;
        }
            
        //
        // Reference the adapter for initialization.
        // This reference will be removed in MpHalt().
        //
        ReferenceAdapter( pAdapter, TRUE );

    } while ( FALSE );

    if ( status != NDIS_STATUS_SUCCESS )
    {
        if ( pAdapter != NULL )
        {
            FreeAdapter( pAdapter );
        }
    }

    TRACE( TL_I, TM_Mp, ("-MpInitialize=$%x",status) );

    return status;
}

VOID 
MpHalt(
    IN NDIS_HANDLE MiniportAdapterContext
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    The MiniportHalt request is used to halt the adapter such that it is
    no longer functioning.  The Miniport driver should stop the adapter
    and deregister all of its resources before returning from this routine.

    It is not necessary for the Miniport to complete all outstanding
    requests and no other requests will be submitted to the Miniport
    until the operation is completed.

    Interrupts are enabled during the call to this routine.

Parameters:

    MiniportAdapterContext _ The adapter handle passed to NdisMSetAttributes
                             during MiniportInitialize.

Return Values:

    None.

---------------------------------------------------------------------------*/   
{
    ADAPTER* pAdapter = MiniportAdapterContext;

    TRACE( TL_I, TM_Mp, ("+MpHalt") );

    //
    // Make sure adapter context is a valid one
    //
    if ( !VALIDATE_ADAPTER( pAdapter ) )
    {
        TRACE( TL_I, TM_Mp, ("-MpHalt") );

        return;
    }

    //
    // Lock the adapter and set halt pending bit
    //
    NdisAcquireSpinLock( &pAdapter->lockAdapter );

    pAdapter->ulMpFlags |= MPBF_MiniportHaltPending;

    NdisReleaseSpinLock( &pAdapter->lockAdapter );

    //
    // Shutdown the tapi provider
    //
    {
        NDIS_TAPI_PROVIDER_SHUTDOWN DummyRequest;

        NdisZeroMemory( &DummyRequest, sizeof( NDIS_TAPI_PROVIDER_SHUTDOWN ) );

        TpProviderShutdown( pAdapter, &DummyRequest, FALSE);

    }

    //
    // Remove the reference added in MpInitialize()
    //
    DereferenceAdapter( pAdapter );

    //
    // Wait for all references to be removed
    //
    NdisWaitEvent( &pAdapter->eventAdapterHalted, 0 );

    //
    // All references have been removed, now wait for all packets owned by NDIS
    // to be returned.
    //
    // Note that no synchronization is necesarry for reading the value of NumPacketsOwnedByNdis
    // at this point since it can only be incremented when there is at least 1 reference on the 
    // binding - at this point ref count is 0 -, and because it can not be incremented, it can 
    // only reach 0 once.
    //
    while ( pAdapter->NumPacketsOwnedByNdiswan )
    {
        NdisMSleep( 10000 );
    }

    //
    // Do deallocation of global resources first
    //
    NdisAcquireSpinLock( &gl_lockAdapter );

    gl_pAdapter = NULL;

    PacketPoolUninit();

    NdisReleaseSpinLock( &gl_lockAdapter );

    //
    // Now we can clean up the adapter context
    //
    FreeAdapter( pAdapter );
    
    TRACE( TL_I, TM_Mp, ("-MpHalt") );
}

NDIS_STATUS 
MpReset(
    OUT PBOOLEAN    AddressingReset,
    IN  NDIS_HANDLE MiniportAdapterContext
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    The MiniportReset request instructs the Miniport driver to issue a
    hardware reset to the network adapter.  The Miniport driver also
    resets its software state.

    The MiniportReset request may also reset the parameters of the adapter.
    If a hardware reset of the adapter resets the current station address
    to a value other than what it is currently configured to, the Miniport
    driver automatically restores the current station address following the
    reset.  Any multicast or functional addressing masks reset by the
    hardware do not have to be reprogrammed by the Miniport.
    NOTE: This is change from the NDIS 3.0 driver specification.  If the
    multicast or functional addressing information, the packet filter, the
    lookahead size, and so on, needs to be restored, the Miniport indicates
    this with setting the flag AddressingReset to TRUE.

    It is not necessary for the Miniport to complete all outstanding requests
    and no other requests will be submitted to the Miniport until the
    operation is completed.  Also, the Miniport does not have to signal
    the beginning and ending of the reset with NdisMIndicateStatus.
    NOTE: These are different than the NDIS 3.0 driver specification.

    The Miniport driver must complete the original request, if the orginal
    call to MiniportReset return NDIS_STATUS_PENDING, by calling
    NdisMResetComplete.

    If the underlying hardware does not provide a reset function under
    software control, then this request completes abnormally with
    NDIS_STATUS_NOT_RESETTABLE.  If the underlying hardware attempts a
    reset and finds recoverable errors, the request completes successfully
    with NDIS_STATUS_SOFT_ERRORS.  If the underlying hardware resets and,
    in the process, finds nonrecoverable errors, the request completes
    successfully with the status NDIS_STATUS_HARD_ERRORS.  If the
    underlying  hardware reset is accomplished without any errors,
    the request completes successfully with the status NDIS_STATUS_SUCCESS.

    Interrupts are in any state during this call.

Parameters:

    MiniportAdapterContext _ The adapter handle passed to NdisMSetAttributes
                             during MiniportInitialize.

    AddressingReset _ The Miniport indicates if the wrapper needs to call
                      MiniportSetInformation to restore the addressing
                      information to the current values by setting this
                      value to TRUE.

Return Values:

    NDIS_STATUS_HARD_ERRORS
    NDIS_STATUS_NOT_ACCEPTED
    NDIS_STATUS_NOT_RESETTABLE
    NDIS_STATUS_PENDING
    NDIS_STATUS_SOFT_ERRORS
    NDIS_STATUS_SUCCESS

---------------------------------------------------------------------------*/    
{
    TRACE( TL_I, TM_Mp, ("+MpReset") );

    TRACE( TL_I, TM_Mp, ("-MpReset") );

    return NDIS_STATUS_NOT_RESETTABLE;
}

NDIS_STATUS 
MpWanSend(
    IN NDIS_HANDLE  MiniportAdapterContext,
    IN NDIS_HANDLE  NdisLinkHandle,
    IN PNDIS_WAN_PACKET  WanPacket
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    The Ndis(M)WanSend instructs a WAN driver to transmit a packet through the
    adapter onto the medium.

    Ownership of both the packet descriptor and the packet data is transferred
    to the WAN driver until the request is completed, either synchronously or
    asynchronously.  If the WAN driver returns a status other than
    NDIS_STATUS_PENDING, then the request is complete, and ownership of the
    packet immediately reverts to the protocol.  If the WAN driver returns
    NDIS_STATUS_PENDING, then the WAN driver must later indicate completion
    of the request by calling Ndis(M)WanSendComplete.

    The WAN driver should NOT return a status of NDIS_STATUS_RESOURCES to
    indicate that there are not enough resources available to process the
    transmit.  Instead, the miniport should queue the send for a later time
    or lower the MaxTransmits value.

    The WAN miniport can NOT call NdisMSendResourcesAvailable.

    The packet passed in Ndis(M)WanSend will contain simple HDLC PPP framing
    if PPP framing is set.  For SLIP or RAS framing, the packet contains only
    the data portion with no framing whatsoever.

    A WAN driver must NOT provide software loopback or promiscuous mode
    loopback.  Both of these are fully provided for in the WAN wrapper.

    NOTE: The MacReservedx section as well as the WanPacketQueue section of
          the NDIS_WAN_PACKET is fully available for use by the WAN driver.

    Interrupts are in any state during this routine.

Parameters:

    MacBindingHandle _ The handle to be passed to NdisMWanSendComplete().

    NdisLinkHandle _ The Miniport link handle passed to NDIS_LINE_UP

    WanPacket _ A pointer to the NDIS_WAN_PACKET strucutre.  The structure
                contains a pointer to a contiguous buffer with guaranteed
                padding at the beginning and end.  The driver may manipulate
                the buffer in any way.

    typedef struct _NDIS_WAN_PACKET
    {
        LIST_ENTRY          WanPacketQueue;
        PUCHAR              CurrentBuffer;
        ULONG               CurrentLength;
        PUCHAR              StartBuffer;
        PUCHAR              EndBuffer;
        PVOID               ProtocolReserved1;
        PVOID               ProtocolReserved2;
        PVOID               ProtocolReserved3;
        PVOID               ProtocolReserved4;
        PVOID               MacReserved1;       // Link
        PVOID               MacReserved2;       // MacBindingHandle
        PVOID               MacReserved3;
        PVOID               MacReserved4;

    } NDIS_WAN_PACKET, *PNDIS_WAN_PACKET;

    The available header padding is simply CurrentBuffer-StartBuffer.
    The available tail padding is EndBuffer-(CurrentBuffer+CurrentLength).

Return Values:

    NDIS_STATUS_INVALID_DATA
    NDIS_STATUS_INVALID_LENGTH
    NDIS_STATUS_INVALID_OID
    NDIS_STATUS_NOT_ACCEPTED
    NDIS_STATUS_NOT_SUPPORTED
    NDIS_STATUS_PENDING
    NDIS_STATUS_SUCCESS
    NDIS_STATUS_FAILURE

---------------------------------------------------------------------------*/    
{
    ADAPTER* pAdapter = MiniportAdapterContext;
    NDIS_STATUS status = NDIS_STATUS_FAILURE;
    CALL* pCall = NULL;
    BINDING* pBinding = NULL;
    PPPOE_PACKET* pPacket = NULL;
    BOOLEAN fTapiProvReferenced = FALSE;

    TRACE( TL_V, TM_Mp, ("+MpWanSend($%x,$%x,$%x)",MiniportAdapterContext,NdisLinkHandle,WanPacket) );

    do
    {
        //
        // Make sure adapter context is a valid one
        //
        if ( !VALIDATE_ADAPTER( pAdapter ) )
        {
            TRACE( TL_A, TM_Tp, ("MpWanSend($%x,$%x,$%x): Invalid adapter handle supplied",
                                MiniportAdapterContext,
                                NdisLinkHandle,
                                WanPacket) );   
        
            break;
        }

        NdisAcquireSpinLock( &pAdapter->lockAdapter );

        //
        // Make sure the handle table will not be freed as long as we need it 
        // in this function
        //
        if ( !( pAdapter->TapiProv.ulTpFlags & TPBF_TapiProvShutdownPending ) &&
              ( pAdapter->TapiProv.ulTpFlags & TPBF_TapiProvInitialized ) )
        {
            fTapiProvReferenced = TRUE;

            ReferenceTapiProv( pAdapter, FALSE );
        }
        else
        {
            NdisReleaseSpinLock( &pAdapter->lockAdapter );

            TRACE( TL_A, TM_Tp, ("MpWanSend($%x,$%x,$%x): Tapi provider not initialized, or shutting down",
                                MiniportAdapterContext,
                                NdisLinkHandle,
                                WanPacket) );   
            break;
        }

        //
        // Map the handle to the pointer for the call context
        //
        pCall = RetrieveFromHandleTable( pAdapter->TapiProv.hCallTable, NdisLinkHandle );

        if ( pCall == NULL )
        {
            NdisReleaseSpinLock( &pAdapter->lockAdapter );

            TRACE( TL_A, TM_Tp, ("MpWanSend($%x,$%x,$%x): Invalid call handle supplied",
                                MiniportAdapterContext,
                                NdisLinkHandle,
                                WanPacket) );   

            break;
        }

        NdisAcquireSpinLock( &pCall->lockCall );

        if ( pCall->pBinding == NULL )
        {
            NdisReleaseSpinLock( &pCall->lockCall );

            NdisReleaseSpinLock( &pAdapter->lockAdapter );
            
            TRACE( TL_A, TM_Tp, ("MpWanSend($%x,$%x,$%x): Binding not found",
                                MiniportAdapterContext,
                                NdisLinkHandle,
                                WanPacket) );   

            break;
        }

        status = PacketInitializePAYLOADToSend( &pPacket,
                                                pCall->SrcAddr,
                                                pCall->DestAddr,
                                                pCall->usSessionId,
                                                WanPacket,
                                                pCall->pLine->pAdapter );

        if ( status != NDIS_STATUS_SUCCESS )
        {
            NdisReleaseSpinLock( &pCall->lockCall );

            NdisReleaseSpinLock( &pAdapter->lockAdapter );
            
            TRACE( TL_N, TM_Tp, ("MpWanSend($%x,$%x,$%x): Could not init payload packet to send",
                                MiniportAdapterContext,
                                NdisLinkHandle,
                                WanPacket) );   

            break;
        }

        pBinding = pCall->pBinding;
        
        ReferenceBinding( pBinding, TRUE );
        
        //
        // Reference the packet so that if PrSend() pends,
        // packet still exists around
        //
        ReferencePacket( pPacket );                                                 

        //
        // Release the locks to send the packet
        //
        NdisReleaseSpinLock( &pCall->lockCall );

        NdisReleaseSpinLock( &pAdapter->lockAdapter );

        //
        // Packet is ready, so send it
        //
        status = PrSend( pBinding, pPacket );

        //
        // Since the result of send will always be completed by a call to NdisMWanSendComplete(),
        // we have to return NDIS_STATUS_PENDING from this function.
        //
        status = NDIS_STATUS_PENDING;

        //
        // We can free the packet as we have a reference on the packet
        //
        PacketFree( pPacket );

    } while ( FALSE );

    //
    // If a reference is added on the tapi provider, remove it
    //
    if ( fTapiProvReferenced )
    {
        DereferenceTapiProv( pAdapter );
    }
    
    TRACE( TL_V, TM_Mp, ("-MpWanSend($%x,$%x,$%x)=$%x",MiniportAdapterContext,NdisLinkHandle,WanPacket,status) );

    return status;

}

typedef struct
_SUPPORTED_OIDS
{
    NDIS_OID ndisOid;
    CHAR szOidName[64];
}
SUPPORTED_OIDS;

SUPPORTED_OIDS
SupportedOidsArray[] = {

    {   OID_GEN_CURRENT_LOOKAHEAD,      "OID_GEN_CURRENT_LOOKAHEAD"     }, 
    {   OID_GEN_DRIVER_VERSION,         "OID_GEN_DRIVER_VERSION"        },
    {   OID_GEN_HARDWARE_STATUS,        "OID_GEN_HARDWARE_STATUS"       },
    {   OID_GEN_LINK_SPEED,             "OID_GEN_LINK_SPEED"            },
    {   OID_GEN_MAC_OPTIONS,            "OID_GEN_MAC_OPTIONS"           },
    {   OID_GEN_MAXIMUM_LOOKAHEAD,      "OID_GEN_MAXIMUM_LOOKAHEAD"     },
    {   OID_GEN_MAXIMUM_FRAME_SIZE,     "OID_GEN_MAXIMUM_FRAME_SIZE"    },
    {   OID_GEN_MAXIMUM_TOTAL_SIZE,     "OID_GEN_MAXIMUM_TOTAL_SIZE"    },
    {   OID_GEN_MEDIA_SUPPORTED,        "OID_GEN_MEDIA_SUPPORTED"       },
    {   OID_GEN_MEDIA_IN_USE,           "OID_GEN_MEDIA_IN_USE"          },
    {   OID_GEN_RCV_ERROR,              "OID_GEN_RCV_ERROR"             },
    {   OID_GEN_RCV_OK,                 "OID_GEN_RCV_OK"                },
    {   OID_GEN_RECEIVE_BLOCK_SIZE,     "OID_GEN_RECEIVE_BLOCK_SIZE"    },
    {   OID_GEN_RECEIVE_BUFFER_SPACE,   "OID_GEN_RECEIVE_BUFFER_SPACE"  },
    {   OID_GEN_SUPPORTED_LIST,         "OID_GEN_SUPPORTED_LIST"        },
    {   OID_GEN_TRANSMIT_BLOCK_SIZE,    "OID_GEN_TRANSMIT_BLOCK_SIZE"   },
    {   OID_GEN_TRANSMIT_BUFFER_SPACE,  "OID_GEN_TRANSMIT_BUFFER_SPACE" },
    {   OID_GEN_VENDOR_DESCRIPTION,     "OID_GEN_VENDOR_DESCRIPTION"    },
    {   OID_GEN_VENDOR_ID,              "OID_GEN_VENDOR_ID"             },
    {   OID_GEN_XMIT_ERROR,             "OID_GEN_XMIT_ERROR"            },
    {   OID_GEN_XMIT_OK,                "OID_GEN_XMIT_OK"               },

    {   OID_PNP_CAPABILITIES,           "OID_PNP_CAPABILITIES"          },
    {   OID_PNP_SET_POWER,              "OID_PNP_SET_POWER"             },
    {   OID_PNP_QUERY_POWER,            "OID_PNP_QUERY_POWER"           },
    {   OID_PNP_ENABLE_WAKE_UP,         "OID_PNP_ENABLE_WAKE_UP"        },

    {   OID_TAPI_CLOSE,                 "OID_TAPI_CLOSE"                },
    {   OID_TAPI_DROP,                  "OID_TAPI_DROP"                 },
    {   OID_TAPI_GET_ADDRESS_CAPS,      "OID_TAPI_GET_ADDRESS_CAPS"     },
    {   OID_TAPI_GET_ADDRESS_STATUS,    "OID_TAPI_GET_ADDRESS_STATUS"   },
    {   OID_TAPI_GET_CALL_INFO,         "OID_TAPI_GET_CALL_INFO"        },
    {   OID_TAPI_GET_CALL_STATUS,       "OID_TAPI_GET_CALL_STATUS"      },
    {   OID_TAPI_GET_DEV_CAPS,          "OID_TAPI_GET_DEV_CAPS"         },
    {   OID_TAPI_GET_EXTENSION_ID,      "OID_TAPI_GET_EXTENSION_ID"     },
    {   OID_TAPI_MAKE_CALL,             "OID_TAPI_MAKE_CALL"            },
    {   OID_TAPI_CLOSE_CALL,            "OID_TAPI_CLOSE_CALL"           },
    {   OID_TAPI_NEGOTIATE_EXT_VERSION, "OID_TAPI_NEGOTIATE_EXT_VERSION"},
    {   OID_TAPI_OPEN,                  "OID_TAPI_OPEN"                 },
    {   OID_TAPI_ANSWER,                "OID_TAPI_ANSWER"               },
    {   OID_TAPI_PROVIDER_INITIALIZE,   "OID_TAPI_PROVIDER_INITIALIZE"  },
    {   OID_TAPI_PROVIDER_SHUTDOWN,     "OID_TAPI_PROVIDER_SHUTDOWN"    },
    {   OID_TAPI_SET_STATUS_MESSAGES,   "OID_TAPI_SET_STATUS_MESSAGES"  },
    {   OID_TAPI_SET_DEFAULT_MEDIA_DETECTION, "OID_TAPI_SET_DEFAULT_MEDIA_DETECTION"    },

    {   OID_WAN_CURRENT_ADDRESS,        "OID_WAN_CURRENT_ADDRESS"       },
    {   OID_WAN_GET_BRIDGE_INFO,        "OID_WAN_GET_BRIDGE_INFO"       },
    {   OID_WAN_GET_COMP_INFO,          "OID_WAN_GET_COMP_INFO"         },
    {   OID_WAN_GET_INFO,               "OID_WAN_GET_INFO"              },
    {   OID_WAN_GET_LINK_INFO,          "OID_WAN_GET_LINK_INFO"         },
    {   OID_WAN_GET_STATS_INFO,         "OID_WAN_GET_STATS_INFO"        },
    {   OID_WAN_HEADER_FORMAT,          "OID_WAN_HEADER_FORMAT"         },
    {   OID_WAN_LINE_COUNT,             "OID_WAN_LINE_COUNT"            },
    {   OID_WAN_MEDIUM_SUBTYPE,         "OID_WAN_MEDIUM_SUBTYPE"        },
    {   OID_WAN_PERMANENT_ADDRESS,      "OID_WAN_PERMANENT_ADDRESS"     },
    {   OID_WAN_PROTOCOL_TYPE,          "OID_WAN_PERMANENT_ADDRESS"     },
    {   OID_WAN_QUALITY_OF_SERVICE,     "OID_WAN_QUALITY_OF_SERVICE"    },
    {   OID_WAN_SET_BRIDGE_INFO,        "OID_WAN_SET_BRIDGE_INFO"       },
    {   OID_WAN_SET_COMP_INFO,          "OID_WAN_SET_COMP_INFO"         },
    {   OID_WAN_SET_LINK_INFO,          "OID_WAN_SET_LINK_INFO"         },
    {   (NDIS_OID) 0,                   "UNKNOWN OID"                   }
};

CHAR* GetOidName(
    NDIS_OID Oid
    )
{
    //
    // Calculate the number of oids we support.
    // (Subtract one for unknown oid)
    //
    UINT nNumOids = ( sizeof( SupportedOidsArray ) / sizeof( SUPPORTED_OIDS ) ) - 1;
    UINT i;
    
    for ( i = 0; i < nNumOids; i++ )
    {
        if ( Oid == SupportedOidsArray[i].ndisOid )
            break;
    }

    return SupportedOidsArray[i].szOidName;
}

#define ENFORCE_SAFE_TOTAL_SIZE(mainStruct, embeddedStruct)                                                            \
   ((mainStruct*) InformationBuffer)->embeddedStruct.ulTotalSize = InformationBufferLength - FIELD_OFFSET(mainStruct, embeddedStruct)

#define RETRIEVE_NEEDED_AND_USED_LENGTH(mainStruct, embeddedStruct) \
   {                                                                                                                             \
      NeededLength = ((mainStruct*) InformationBuffer)->embeddedStruct.ulNeededSize + FIELD_OFFSET(mainStruct, embeddedStruct);  \
      UsedLength = ((mainStruct*) InformationBuffer)->embeddedStruct.ulUsedSize + FIELD_OFFSET(mainStruct, embeddedStruct);      \
   } 

NDIS_STATUS 
MpQueryInformation(
    IN NDIS_HANDLE  MiniportAdapterContext,
    IN NDIS_OID  Oid,
    IN PVOID  InformationBuffer,
    IN ULONG  InformationBufferLength,
    OUT PULONG  BytesWritten,
    OUT PULONG  BytesNeeded
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    The MiniportQueryInformation request allows the inspection of the
    Miniport driver's capabilities and current status.

    If the Miniport does not complete the call immediately (by returning
    NDIS_STATUS_PENDING), it must call NdisMQueryInformationComplete to
    complete the call.  The Miniport controls the buffers pointed to by
    InformationBuffer, BytesWritten, and BytesNeeded until the request
    completes.

    No other requests of the following kind will be submitted to the Miniport 
    driver until this request has been completed:
       1. MiniportQueryInformation()
       2. MiniportSetInformation()
       3. MiniportHalt()

    Note that the wrapper will intercept all queries of the following OIDs:
        OID_GEN_CURRENT_PACKET_FILTER,
        OID_GEN_PROTOCOL_OPTIONS,
        OID_802_5_CURRENT_FUNCTIONAL,
        OID_802_3_MULTICAST_LIST,
        OID_FDDI_LONG_MULTICAST_LIST,
        OID_FDDI_SHORT_MULTICAST_LIST.

    Interrupts are in any state during this call.

Parameters:

    MiniportAdapterContext _ The adapter handle passed to NdisMSetAttributes
                             during MiniportInitialize.

    Oid _ The OID.  (See section 7.4 of the NDIS 3.0 specification for a
          complete description of OIDs.)

    InformationBuffer _ The buffer that will receive the information.
                        (See section 7.4 of the NDIS 3.0 specification
                        for a description of the length required for each
                        OID.)

    InformationBufferLength _ The length in bytes of InformationBuffer.

    BytesWritten _ Returns the number of bytes written into
                   InformationBuffer.

    BytesNeeded _ This parameter returns the number of additional bytes
                  needed to satisfy the OID.

Return Values:

    NDIS_STATUS_INVALID_DATA
    NDIS_STATUS_INVALID_LENGTH
    NDIS_STATUS_INVALID_OID
    NDIS_STATUS_NOT_ACCEPTED
    NDIS_STATUS_NOT_SUPPORTED
    NDIS_STATUS_PENDING
    NDIS_STATUS_RESOURCES
    NDIS_STATUS_FAILURE
    NDIS_STATUS_SUCCESS

---------------------------------------------------------------------------*/    
{

    ADAPTER* pAdapter = (ADAPTER*) MiniportAdapterContext;
    NDIS_STATUS status = NDIS_STATUS_FAILURE;

    ULONG GenericUlong;
    PVOID SourceBuffer = NULL;

    ULONG NeededLength = 0;
    ULONG UsedLength = 0;

    //
    // This can be any string that represents PPPoE as a MAC address, but
    // it must be up to 6 chars long.
    //
    UCHAR PPPoEWanAddress[6] = { '3', 'P', 'o', 'E', '0', '0' };
    
    TRACE( TL_I, TM_Mp, ("+MpQueryInformation($%x):%s",(ULONG) Oid, GetOidName( Oid ) ) );

    //
    // Make sure adapter context is a valid one
    //
    if ( !VALIDATE_ADAPTER( pAdapter ) )
        return status;

    switch ( Oid )
    {
        case OID_GEN_MAXIMUM_LOOKAHEAD:
        {
            NeededLength = sizeof( GenericUlong );
            GenericUlong = pAdapter->NdisWanInfo.MaxFrameSize;

            SourceBuffer = &GenericUlong;
            
            status = NDIS_STATUS_SUCCESS;
            
            break;
        }

        case OID_GEN_MAC_OPTIONS:
        {
            NeededLength = sizeof( GenericUlong );
            GenericUlong = NDIS_MAC_OPTION_TRANSFERS_NOT_PEND;

            SourceBuffer = &GenericUlong;
            
            status = NDIS_STATUS_SUCCESS;
            
            break;
        }
        
        case OID_GEN_SUPPORTED_LIST:
        {
            //
            // Calculate the number of oids we support.
            // (Subtract one for unknown oid)
            //
            UINT nNumOids = ( sizeof( SupportedOidsArray ) / sizeof( SUPPORTED_OIDS ) ) - 1;

            NeededLength = nNumOids * sizeof( NDIS_OID );

            if ( InformationBufferLength >= NeededLength )
            {
                NDIS_OID* NdisOidArray = (NDIS_OID*) InformationBuffer;
                UINT i;

                for ( i = 0; i < nNumOids; i++ )
                {
                    NdisOidArray[i] = SupportedOidsArray[i].ndisOid;
                }
            
                status = NDIS_STATUS_SUCCESS;
            }
            
            break;
        }

        case OID_GEN_RCV_ERROR:
        case OID_GEN_RCV_OK:   
        case OID_GEN_XMIT_ERROR:
        case OID_GEN_XMIT_OK:
        case OID_GEN_CURRENT_LOOKAHEAD:
        case OID_GEN_DRIVER_VERSION:
        case OID_GEN_HARDWARE_STATUS:
        case OID_GEN_LINK_SPEED:
        case OID_GEN_MAXIMUM_FRAME_SIZE:
        case OID_GEN_MAXIMUM_TOTAL_SIZE:
        case OID_GEN_MEDIA_SUPPORTED:
        case OID_GEN_MEDIA_IN_USE:
        case OID_GEN_RECEIVE_BLOCK_SIZE:
        case OID_GEN_RECEIVE_BUFFER_SPACE:
        case OID_GEN_TRANSMIT_BLOCK_SIZE:
        case OID_GEN_TRANSMIT_BUFFER_SPACE:
        case OID_GEN_VENDOR_DESCRIPTION:
        case OID_GEN_VENDOR_ID:
        {
            status = NDIS_STATUS_NOT_SUPPORTED;

            break;
        }

        case OID_TAPI_GET_ADDRESS_CAPS:
        {
            NeededLength = sizeof( NDIS_TAPI_GET_ADDRESS_CAPS );
            
            if ( InformationBufferLength < NeededLength )
            {
                break;
            }

            ENFORCE_SAFE_TOTAL_SIZE(
                           NDIS_TAPI_GET_ADDRESS_CAPS,
                           LineAddressCaps
                           );
                           
            status = TpGetAddressCaps( pAdapter, 
                                       (PNDIS_TAPI_GET_ADDRESS_CAPS) InformationBuffer );

            RETRIEVE_NEEDED_AND_USED_LENGTH(
                    NDIS_TAPI_GET_ADDRESS_CAPS, 
                    LineAddressCaps
                    );
            break;
        }

        case OID_TAPI_GET_CALL_INFO:
        {
            NeededLength = sizeof( NDIS_TAPI_GET_CALL_INFO );
            
            if ( InformationBufferLength < NeededLength )
            {
                break;
            }

            ENFORCE_SAFE_TOTAL_SIZE(
                           NDIS_TAPI_GET_CALL_INFO,
                           LineCallInfo
                           );
            
            status = TpGetCallInfo( pAdapter, 
                                    (PNDIS_TAPI_GET_CALL_INFO) InformationBuffer );

            RETRIEVE_NEEDED_AND_USED_LENGTH(
                           NDIS_TAPI_GET_CALL_INFO,
                           LineCallInfo
                           );

            break;
        }

        case OID_TAPI_GET_CALL_STATUS:
        {
            NeededLength = sizeof( NDIS_TAPI_GET_CALL_STATUS );
            
            if ( InformationBufferLength < NeededLength )
            {
                break;
            }
            
            ENFORCE_SAFE_TOTAL_SIZE(
                           NDIS_TAPI_GET_CALL_STATUS,
                           LineCallStatus
                           );

            status = TpGetCallStatus( pAdapter, 
                                      (PNDIS_TAPI_GET_CALL_STATUS) InformationBuffer );

            RETRIEVE_NEEDED_AND_USED_LENGTH(
                           NDIS_TAPI_GET_CALL_STATUS,
                           LineCallStatus
                           );

            break;

        }

        case OID_TAPI_GET_DEV_CAPS:
        {
            NeededLength = sizeof( NDIS_TAPI_GET_DEV_CAPS );
            
            if ( InformationBufferLength < NeededLength )
            {
                break;
            }

            ENFORCE_SAFE_TOTAL_SIZE(
                           NDIS_TAPI_GET_DEV_CAPS,
                           LineDevCaps
                           );
            
            status = TpGetDevCaps( pAdapter, 
                                  (PNDIS_TAPI_GET_DEV_CAPS) InformationBuffer );

            RETRIEVE_NEEDED_AND_USED_LENGTH(
                           NDIS_TAPI_GET_DEV_CAPS,
                           LineDevCaps
                           );
            
            break;

        }

        case OID_TAPI_GET_ID:
        {
            NeededLength = sizeof( NDIS_TAPI_GET_ID );
            
            if ( InformationBufferLength < NeededLength )
            {
                break;
            }
            
            ENFORCE_SAFE_TOTAL_SIZE(
                           NDIS_TAPI_GET_ID,
                           DeviceID
                           );

            status = TpGetId( pAdapter, 
                              (PNDIS_TAPI_GET_ID) InformationBuffer,
                              InformationBufferLength );

            RETRIEVE_NEEDED_AND_USED_LENGTH(
                           NDIS_TAPI_GET_ID,
                           DeviceID
                           );

            break;
        }

        case OID_TAPI_GET_ADDRESS_STATUS:
        {
            NeededLength = sizeof( NDIS_TAPI_GET_ADDRESS_STATUS );
            
            if ( InformationBufferLength < NeededLength )
            {
                break;
            }
            
            ENFORCE_SAFE_TOTAL_SIZE(
                           NDIS_TAPI_GET_ADDRESS_STATUS,
                           LineAddressStatus
                           );

            status = TpGetAddressStatus( pAdapter, 
                                         (PNDIS_TAPI_GET_ADDRESS_STATUS) InformationBuffer );

            RETRIEVE_NEEDED_AND_USED_LENGTH(
                           NDIS_TAPI_GET_ADDRESS_STATUS,
                           LineAddressStatus
                           );

            break;
        }

        case OID_TAPI_GET_EXTENSION_ID:
        {
            NeededLength = sizeof( NDIS_TAPI_GET_EXTENSION_ID );
            
            if ( InformationBufferLength < NeededLength )
            {
                break;
            }
            
            status = TpGetExtensionId( pAdapter, 
                                      (PNDIS_TAPI_GET_EXTENSION_ID) InformationBuffer );
            break;
        }

        case OID_TAPI_MAKE_CALL:        
        {
            NeededLength = sizeof( NDIS_TAPI_MAKE_CALL );
            
            if ( InformationBufferLength < NeededLength )
            {
                break;
            }

            ENFORCE_SAFE_TOTAL_SIZE(
                           NDIS_TAPI_MAKE_CALL,
                           LineCallParams
                           );
            
            status = TpMakeCall( pAdapter, 
                                 (PNDIS_TAPI_MAKE_CALL) InformationBuffer,
                                 InformationBufferLength );
            break;
        }

        case OID_TAPI_NEGOTIATE_EXT_VERSION:
        {
            NeededLength = sizeof( NDIS_TAPI_NEGOTIATE_EXT_VERSION );
            
            if ( InformationBufferLength < NeededLength )
            {
                break;
            }
            
            status = TpNegotiateExtVersion( pAdapter, 
                                            (PNDIS_TAPI_NEGOTIATE_EXT_VERSION) InformationBuffer );
            break;
        }

        case OID_TAPI_OPEN:
        {
            NeededLength = sizeof( NDIS_TAPI_OPEN );
            
            if ( InformationBufferLength < NeededLength )
            {
                break;
            }
            
            status = TpOpenLine( pAdapter, 
                                 (PNDIS_TAPI_OPEN) InformationBuffer );
            break;
        }

        case OID_TAPI_PROVIDER_INITIALIZE:
        {
            NeededLength = sizeof( NDIS_TAPI_PROVIDER_INITIALIZE );
            
            if ( InformationBufferLength < NeededLength )
            {
                break;
            }
            
            status = TpProviderInitialize( pAdapter, 
                                           (PNDIS_TAPI_PROVIDER_INITIALIZE) InformationBuffer );
            break;
        }        

        case OID_WAN_GET_INFO:
        {
            NeededLength = sizeof( NDIS_WAN_INFO );

            if ( InformationBufferLength < NeededLength )
            {
                break;
            }
            
            status = MpWanGetInfo( pAdapter,
                                   (PNDIS_WAN_INFO) InformationBuffer );

            break;
        }
        
        case OID_WAN_MEDIUM_SUBTYPE:
        {
            NeededLength = sizeof( GenericUlong );
            GenericUlong = NdisWanMediumPppoe;

            SourceBuffer = &GenericUlong;

            status = NDIS_STATUS_SUCCESS;
            
            break;
        }

        case OID_WAN_CURRENT_ADDRESS:
        case OID_WAN_PERMANENT_ADDRESS:
        {
            NeededLength = sizeof( PPPoEWanAddress );
            SourceBuffer = PPPoEWanAddress;

            status = NDIS_STATUS_SUCCESS;
            
            break;
        }

        case OID_WAN_GET_LINK_INFO:
        {
            NeededLength = sizeof( NDIS_WAN_GET_LINK_INFO );
            
            if ( InformationBufferLength < NeededLength )
            {
                break;
            }
            
            status = MpWanGetLinkInfo( pAdapter, 
                                       (PNDIS_WAN_GET_LINK_INFO) InformationBuffer );

            break;
        }
        
        case OID_WAN_GET_BRIDGE_INFO:
        case OID_WAN_GET_STATS_INFO:
        case OID_WAN_HEADER_FORMAT:
        case OID_WAN_LINE_COUNT:
        case OID_WAN_PROTOCOL_TYPE:
        case OID_WAN_QUALITY_OF_SERVICE:
        case OID_WAN_SET_BRIDGE_INFO:
        case OID_WAN_SET_COMP_INFO:
        case OID_WAN_SET_LINK_INFO:
        case OID_WAN_GET_COMP_INFO: 
        {
            status = NDIS_STATUS_NOT_SUPPORTED;

            break;
        }

        case OID_PNP_CAPABILITIES:
        {
            NDIS_PNP_CAPABILITIES UNALIGNED * pPnpCaps = (NDIS_PNP_CAPABILITIES UNALIGNED *) InformationBuffer;
            
            NeededLength = sizeof( NDIS_PNP_CAPABILITIES );

            if ( InformationBufferLength < NeededLength )
            {
                break;
            }

            pPnpCaps->Flags = 0;
            pPnpCaps->WakeUpCapabilities.MinMagicPacketWakeUp = NdisDeviceStateUnspecified;
            pPnpCaps->WakeUpCapabilities.MinPatternWakeUp     = NdisDeviceStateUnspecified;
            pPnpCaps->WakeUpCapabilities.MinLinkChangeWakeUp  = NdisDeviceStateUnspecified;

            status = NDIS_STATUS_SUCCESS;
            
            break;
        }
        
        case OID_PNP_QUERY_POWER:
        case OID_PNP_ENABLE_WAKE_UP:
        {
            NeededLength = 0;
            
            status = NDIS_STATUS_SUCCESS;

            break;
        }

        default:
        {
            //
            // Unknown OID
            //
            status = NDIS_STATUS_INVALID_OID;
            
            break;      
        }
    }

    if ( status != NDIS_STATUS_NOT_SUPPORTED && 
         status != NDIS_STATUS_INVALID_OID )
    {

        if ( InformationBufferLength >= NeededLength )
        {
            if ( status == NDIS_STATUS_SUCCESS )
            {

               if ( SourceBuffer )
               {
                   NdisMoveMemory( InformationBuffer, SourceBuffer, NeededLength );
               }
               
               *BytesWritten = NeededLength;
            }  
            else if ( status == NDIS_STATUS_INVALID_LENGTH )
            {
               *BytesWritten = 0;
               *BytesNeeded = NeededLength;
            }

        }
        else
        {
            *BytesWritten = 0;
            *BytesNeeded = NeededLength;
    
            status = NDIS_STATUS_INVALID_LENGTH;
        }

    }
    
    TRACE( TL_I, TM_Mp, ("-MpQueryInformation()=$%x",status) );

    return status;

}

NDIS_STATUS 
MpSetInformation(
    IN NDIS_HANDLE  MiniportAdapterContext,
    IN NDIS_OID  Oid,
    IN PVOID  InformationBuffer,
    IN ULONG  InformationBufferLength,
    OUT PULONG  BytesWritten,
    OUT PULONG  BytesNeeded
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    The MiniportSetInformation request allows for control of the Miniport
    by changing information maintained by the Miniport driver.

    Any of the settable NDIS Global Oids may be used. (see section 7.4 of
    the NDIS 3.0 specification for a complete description of the NDIS Oids.)

    If the Miniport does not complete the call immediately (by returning
    NDIS_STATUS_PENDING), it must call NdisMSetInformationComplete to
    complete the call.  The Miniport controls the buffers pointed to by
    InformationBuffer, BytesRead, and BytesNeeded until the request completes.

    Interrupts are in any state during the call, and no other requests will
    be submitted to the Miniport until this request is completed.

Parameters:

    MiniportAdapterContext _ The adapter handle passed to NdisMSetAttributes
                             during MiniportInitialize.

    Oid _ The OID.  (See section 7.4 of the NDIS 3.0 specification for
          a complete description of OIDs.)

    InformationBuffer _ The buffer that will receive the information.
                        (See section 7.4 of the NDIS 3.0 specification for
                        a description of the length required for each OID.)

    InformationBufferLength _ The length in bytes of InformationBuffer.

    BytesRead_ Returns the number of bytes read from InformationBuffer.

    BytesNeeded _ This parameter returns the number of additional bytes
                  expected to satisfy the OID.

Return Values:

    NDIS_STATUS_INVALID_DATA
    NDIS_STATUS_INVALID_LENGTH
    NDIS_STATUS_INVALID_OID
    NDIS_STATUS_NOT_ACCEPTED
    NDIS_STATUS_NOT_SUPPORTED
    NDIS_STATUS_PENDING
    NDIS_STATUS_RESOURCES
    NDIS_STATUS_SUCCESS

---------------------------------------------------------------------------*/    
{
    ADAPTER* pAdapter = MiniportAdapterContext;
    NDIS_STATUS status = NDIS_STATUS_FAILURE;

    PVOID SourceBuffer = NULL;

    ULONG NeededLength = 0;
    ULONG GenericUlong;

    TRACE( TL_I, TM_Mp, ("+MpSetInformation($%x):%s",(ULONG) Oid, GetOidName( Oid ) ) );

    //
    // Make sure adapter context is a valid one
    //
    if ( !VALIDATE_ADAPTER( pAdapter ) )
        return status;

    switch ( Oid )
    {

        case OID_TAPI_ANSWER:
        {
            NeededLength = sizeof( NDIS_TAPI_ANSWER );
            
            if ( InformationBufferLength < NeededLength )
            {
                break;
            }
            
            status = TpAnswerCall( pAdapter, 
                                   (PNDIS_TAPI_ANSWER) InformationBuffer );
            break;
        }

        case OID_TAPI_CLOSE:
        {
            NeededLength = sizeof( NDIS_TAPI_CLOSE );
            
            if ( InformationBufferLength < NeededLength )
            {
                break;
            }
            
            status = TpCloseLine( pAdapter, 
                                  (PNDIS_TAPI_CLOSE) InformationBuffer,
                                  TRUE);
            break;
        }

        case OID_TAPI_CLOSE_CALL:
        {
            NeededLength = sizeof( NDIS_TAPI_CLOSE_CALL );
            
            if ( InformationBufferLength < NeededLength )
            {
                break;
            }
            
            status = TpCloseCall( pAdapter, 
                                  (PNDIS_TAPI_CLOSE_CALL) InformationBuffer,
                                  TRUE );
            break;
        }

        case OID_TAPI_DROP:     
        {
            NeededLength = sizeof( NDIS_TAPI_DROP );
            
            if ( InformationBufferLength < NeededLength )
            {
                break;
            }
            
            status = TpDropCall( pAdapter, 
                                 (PNDIS_TAPI_DROP) InformationBuffer,
                                 0 );
            break;
        }

        case OID_TAPI_PROVIDER_SHUTDOWN:
        {
            NeededLength = sizeof( NDIS_TAPI_PROVIDER_SHUTDOWN );
            
            if ( InformationBufferLength < NeededLength )
            {
                break;
            }
            
            status = TpProviderShutdown( pAdapter, 
                                         (PNDIS_TAPI_PROVIDER_SHUTDOWN) InformationBuffer,
                                         TRUE );
            break;
        }

        case OID_TAPI_SET_DEFAULT_MEDIA_DETECTION:
        {
            NeededLength = sizeof( NDIS_TAPI_SET_DEFAULT_MEDIA_DETECTION );
            
            if ( InformationBufferLength < NeededLength )
            {
                break;
            }
            
            status = TpSetDefaultMediaDetection( pAdapter, 
                                                 (PNDIS_TAPI_SET_DEFAULT_MEDIA_DETECTION) InformationBuffer );
            break;
        }

        case OID_TAPI_SET_STATUS_MESSAGES:
        {
            NeededLength = sizeof( NDIS_TAPI_SET_STATUS_MESSAGES );
            
            if ( InformationBufferLength < NeededLength )
            {
                break;
            }
            
            status = TpSetStatusMessages( pAdapter, 
                                          (PNDIS_TAPI_SET_STATUS_MESSAGES) InformationBuffer );
            break;
        }

        case OID_WAN_SET_LINK_INFO:
        {
            NeededLength = sizeof( NDIS_WAN_SET_LINK_INFO );
            
            if ( InformationBufferLength < NeededLength )
            {
                break;
            }
            
            status = MpWanSetLinkInfo( pAdapter, 
                                       (PNDIS_WAN_SET_LINK_INFO) InformationBuffer );

            break;
        }

        case OID_PNP_SET_POWER:
        case OID_PNP_ENABLE_WAKE_UP:
        {
            NeededLength = 0;
            
            status = NDIS_STATUS_SUCCESS;

            break;
        }        

        default:
        {
            //
            // Unknown OID
            //
            status = NDIS_STATUS_INVALID_OID;
            
            break;      
        }

    }

    if ( status != NDIS_STATUS_NOT_SUPPORTED && 
         status != NDIS_STATUS_INVALID_OID )
    {

        if ( InformationBufferLength >= NeededLength )
        {
            if ( SourceBuffer )
                NdisMoveMemory( InformationBuffer, SourceBuffer, NeededLength );
                
            *BytesWritten = NeededLength;

        }
        else
        {
            *BytesWritten = 0;
            *BytesNeeded = NeededLength;
    
            status = NDIS_STATUS_INVALID_LENGTH;
        }

    }
    
    TRACE( TL_I, TM_Mp, ("-MpSetInformation()=$%x",status) );

    return status;

}

VOID 
MpNotifyBindingRemoval( 
    BINDING* pBinding 
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function will be called by the protocol module to notify the miniport 
    about the removal of a binding.

    Miniport identifies and drops the calls over the binding..
    
Parameters:

    pBinding _ A pointer to our binding information structure.

Return Values:

    None
---------------------------------------------------------------------------*/   
{
    ADAPTER* pAdapter = NULL;

    ASSERT( VALIDATE_BINDING( pBinding ) );

    TRACE( TL_N, TM_Mp, ("+MpNotifyBindingRemoval($%x)",pBinding) );

    if ( !gl_fLockAllocated )
    {
        TRACE( TL_A, TM_Mp, ("MpNotifyBindingRemoval($%x): Global lock not allocated yet",pBinding) );

        TRACE( TL_N, TM_Mp, ("-MpNotifyBindingRemoval($%x)",pBinding) );

        return;
    }

    NdisAcquireSpinLock( &gl_lockAdapter );

    if (  gl_pAdapter && 
         !( gl_pAdapter->ulMpFlags & MPBF_MiniportHaltPending ) &&
          ( gl_pAdapter->ulMpFlags & MPBF_MiniportInitialized ) )
    {

        pAdapter = gl_pAdapter;

        NdisAcquireSpinLock( &pAdapter->lockAdapter );

        if ( !( pAdapter->TapiProv.ulTpFlags & TPBF_TapiProvShutdownPending ) &&
              ( pAdapter->TapiProv.ulTpFlags & TPBF_TapiProvInitialized ) )
        {
            ReferenceTapiProv( pAdapter, FALSE );

            NdisReleaseSpinLock( &pAdapter->lockAdapter );
        }
        else
        {
            NdisReleaseSpinLock( &pAdapter->lockAdapter );

            pAdapter = NULL;
        }
    }

    NdisReleaseSpinLock( &gl_lockAdapter );

    if ( pAdapter == NULL )
    {
        TRACE( TL_A, TM_Mp, ("MpNotifyBindingRemoval($%x): Tapi provider not initialized or no adapters found",pBinding) );

        TRACE( TL_N, TM_Mp, ("-MpNotifyBindingRemoval($%x)",pBinding) );

        return;
    }

    //
    // Complete any queued received packets in case PrReceiveComplete()
    // is not called
    //
    PrReceiveComplete( pBinding );

    NdisAcquireSpinLock( &pAdapter->lockAdapter );

    do
    {
        HANDLE_TABLE hCallTable = NULL;
        UINT hCallTableSize = 0;
        UINT i = 0;
        CALL* pCall;
        HDRV_CALL hdCall;
        
        //
        // Traverse the call handle table and drop calls over
        // the removed binding
        //
        hCallTableSize = pAdapter->nMaxLines * pAdapter->nCallsPerLine;
        
        hCallTable = pAdapter->TapiProv.hCallTable;

        for ( i = 0; i < hCallTableSize; i++ )
        {
            NDIS_TAPI_DROP DummyRequest;
            BOOLEAN fDropCall = FALSE;
            
            pCall = RetrieveFromHandleTableByIndex( hCallTable, (USHORT) i );

            if ( pCall == NULL )
                continue;

            NdisAcquireSpinLock( &pCall->lockCall );

            if ( pCall->pBinding == pBinding )
            {
                //
                // This call is over the removed binding,
                // so it should be dropped
                //
                ReferenceCall( pCall, FALSE );

                fDropCall = TRUE;
            }

            NdisReleaseSpinLock( &pCall->lockCall );

            if ( !fDropCall )
            {
                pCall = NULL;
                
                continue;
            }

            NdisReleaseSpinLock( &pAdapter->lockAdapter );

            //
            // Initialize the request, and drop the call
            //
            DummyRequest.hdCall = pCall->hdCall;

            TpDropCall( pAdapter, &DummyRequest, LINEDISCONNECTMODE_UNREACHABLE );

            //
            // Remove the reference added above
            //
            DereferenceCall( pCall );

            //
            // Re-acquire the adapter's lock
            //
            NdisAcquireSpinLock( &pAdapter->lockAdapter );
            
        }

    } while ( FALSE );

    NdisReleaseSpinLock( &pAdapter->lockAdapter );
    
    //
    // Remove the reference added above
    //
    DereferenceTapiProv( pAdapter );

    TRACE( TL_N, TM_Mp, ("-MpNotifyBindingRemoval($%x)",pBinding) );
}

CALL*
MpMapPacketWithSessionIdToCall(
    IN ADAPTER* pAdapter,
    IN PPPOE_PACKET* pPacket
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function will be called to map an in session packet to a call in 
    call handle table.

    If such a call is identified, it will be referenced and a pointer to 
    it will be returned. It is the caller's responsibility to remove the
    added reference.
    
Parameters:

    pAdapter _ A pointer to our adapter information structure.
    
    pPacket _ A PPPoE packet received over the wire.

Return Values:

    A pointer to the call context that the packet must be dispatched to.
    NULL if no such calls could be identified.
    
---------------------------------------------------------------------------*/   
{
    CALL* pCall = NULL;
    CALL* pReturnCall = NULL;

    TRACE( TL_V, TM_Mp, ("+MpMapPacketWithSessionIdToCall($%x)",pPacket) );
    
    NdisAcquireSpinLock( &pAdapter->lockAdapter );
    
    if ( pAdapter->fClientRole )
    {
        HANDLE_TABLE hCallTable = NULL;
        UINT hCallTableSize = 0;
        UINT i = 0;

        CHAR* pSrcAddr = PacketGetSrcAddr( pPacket );
        CHAR* pDestAddr = PacketGetDestAddr( pPacket );
        USHORT usSessionId = PacketGetSessionId( pPacket );

        //
        // Miniport acting as a client:
        // Our algorithm is to search for the call handle table
        // to find the matching call
        //
        hCallTableSize = pAdapter->nMaxLines * pAdapter->nCallsPerLine;
            
        hCallTable = pAdapter->TapiProv.hCallTable;
    
        for ( i = 0; i < hCallTableSize ; i++ )
        {
        
            pCall = RetrieveFromHandleTableByIndex( hCallTable, (USHORT) i );

            if ( pCall == NULL )
                continue;

            if ( ( pCall->usSessionId == usSessionId ) &&
                 ( NdisEqualMemory( pCall->SrcAddr, pDestAddr, 6 * sizeof( CHAR ) ) ) &&
                 ( NdisEqualMemory( pCall->DestAddr, pSrcAddr, 6 * sizeof( CHAR ) ) ) )
            {
                //
                // The packet is intended for this call
                //
                ReferenceCall( pCall, TRUE );

                pReturnCall = pCall;

                break;
            }

        }

    }
    else
    {
        
        HANDLE_TABLE hCallTable = NULL;
        CHAR* pSrcAddr = PacketGetSrcAddr( pPacket );
        CHAR* pDestAddr = PacketGetDestAddr( pPacket );
        USHORT usSessionId = PacketGetSessionId( pPacket );

        //
        // Miniport acting as a server:
        // Our algorithm is to use the session id directly as the index 
        // to the call handle table
        //
        hCallTable = pAdapter->TapiProv.hCallTable;

        pCall = RetrieveFromHandleTableBySessionId( hCallTable, usSessionId );

        if ( pCall )
        {

            if ( ( pCall->usSessionId == usSessionId ) &&
                 ( NdisEqualMemory( pCall->SrcAddr, pDestAddr, 6 * sizeof( CHAR ) ) ) &&
                 ( NdisEqualMemory( pCall->DestAddr, pSrcAddr, 6 * sizeof( CHAR ) ) ) )
            {

                ReferenceCall( pCall, TRUE );

                pReturnCall = pCall;

            }
            
        }

    }

    NdisReleaseSpinLock( &pAdapter->lockAdapter );

    TRACE( TL_V, TM_Mp, ("-MpMapPacketWithSessionIdToCall($%x)=$%x",pPacket,pReturnCall) );

    return pReturnCall;
}

CALL*
MpMapPacketWithoutSessionIdToCall(
    IN ADAPTER* pAdapter,
    IN PPPOE_PACKET* pPacket
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function will be called to map an out of session packet to a call that
    is in connecting state.

    If such a call is identified, it will be referenced and a pointer to 
    it will be returned. It is the caller's responsibility to remove the
    added reference.

    This function will only be called for PADO or PADS packets.

    We use the HostUnique tags to save the handle to the call, and
    use them to map the returned packet back to the related call. This provides a 
    very efficient mapping for these control packets.

    Our HostUnique tags are prepared in this way. We append hdCall,
    which is unique for a call, to a uniquely generated ULONG value to come up with
    a longer unique value. And when we receive the packet we decode the unique value to reach 
    hdCall and use that to retrieve the call pointer.

Parameters:

    pAdapter _ A pointer to our adapter information structure.

    pPacket _ A PPPoE packet received over the wire.

Return Values:

    A pointer to the call context that the packet must be dispatched to.
    NULL if no such calls could be identified.
    
---------------------------------------------------------------------------*/   
{
    USHORT usCode = PacketGetCode( pPacket );
    CHAR* pUniqueValue = NULL;
    USHORT UniqueValueSize = 0;
    HDRV_CALL hdCall = (HDRV_CALL) NULL;
    CALL* pCall = NULL;

    TRACE( TL_N, TM_Mp, ("+MpMapPacketWithoutSessionIdToCall($%x)",pPacket) );
    
    PacketRetrieveHostUniqueTag( pPacket,
                                 &UniqueValueSize,
                                 &pUniqueValue );

    if ( pUniqueValue == NULL )
    {
        TRACE( TL_A, TM_Mp, ("MpMapPacketWithoutSessionIdToCall($%x): Could not retrieve HostUnique tag",pPacket) );
    
        TRACE( TL_N, TM_Mp, ("-MpMapPacketWithoutSessionIdToCall($%x)",pPacket) );

        return NULL;
    }

    //
    // Decode the unique value and retrieve the call handle
    //
    hdCall = RetrieveHdCallFromUniqueValue( pUniqueValue, UniqueValueSize );

    if ( hdCall == (HDRV_CALL) NULL )
    {
        TRACE( TL_A, TM_Mp, ("MpMapPacketWithoutSessionIdToCall($%x): Could not retrieve call handle from unique value",pPacket) );
    
        TRACE( TL_N, TM_Mp, ("-MpMapPacketWithoutSessionIdToCall($%x)",pPacket) );

        return NULL;
    }

    NdisAcquireSpinLock( &pAdapter->lockAdapter );

    //
    // Retrieve the call pointer using the call handle
    //
    pCall = RetrieveFromHandleTable( pAdapter->TapiProv.hCallTable, 
                                     (NDIS_HANDLE) hdCall );

    if ( pCall )
    {
        if ( !( pCall->ulClFlags & CLBF_CallDropped ||
                pCall->ulClFlags & CLBF_CallClosePending ) )
        {
            ReferenceCall( pCall, TRUE );
        }
        else
        {
            pCall = NULL;
        }
    }

    NdisReleaseSpinLock( &pAdapter->lockAdapter );

    TRACE( TL_N, TM_Mp, ("-MpMapPacketWithoutSessionIdToCall($%x)=$%x",pPacket,pCall) );
    
    return pCall;
}

BOOLEAN
MpVerifyServiceName(
    IN ADAPTER* pAdapter,
    IN PPPOE_PACKET* pPacket,
    IN BOOLEAN fAcceptEmptyServiceNameTag
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function will be called to verify that a requested service name is 
    supported by our server.

    CAUTION: Do not attempt to lock anything inside this function, and make sure
             not to call any function that may do it because it must be lock free
             (caller might be holding locks).

Parameters:

    pAdapter  _ Pointer to the adapter structure that received the packet.
    
    pPacket _ A PADI or PADR packet received.

    fAcceptEmptyServiceNameTag _ An empty service name tag is valid in a PADI
                                 packet but not in a PADR packet. This flag 
                                 indicates this behavior.

Return Values:

    None
---------------------------------------------------------------------------*/   
{
    BOOLEAN fRet = FALSE;
    USHORT tagServiceNameLength = 0;
    CHAR* tagServiceNameValue = NULL;
    
    TRACE( TL_V, TM_Mp, ("+MpVerifyServiceName($%x)",pPacket) );

    RetrieveTag( pPacket,
                 tagServiceName,
                 &tagServiceNameLength,
                 &tagServiceNameValue,
                 0,
                 NULL,
                 FALSE );
    do
    {
        if ( fAcceptEmptyServiceNameTag )
        {
            if ( tagServiceNameLength == 0 && tagServiceNameValue != NULL )
            {
                fRet = TRUE;

                break;
            }
        }

        if ( tagServiceNameLength == pAdapter->nServiceNameLength && 
             NdisEqualMemory( tagServiceNameValue, pAdapter->ServiceName, tagServiceNameLength) )
        {
            fRet = TRUE;
        }
        
    } while ( FALSE );

                
    TRACE( TL_V, TM_Mp, ("-MpVerifyServiceName($%x)=$%x",pPacket,fRet) );

    return fRet;

}

VOID
MpReplyToPADI(
    IN ADAPTER* pAdapter,
    IN BINDING* pBinding,
    IN PPPOE_PACKET* pPADI
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function will be called when a PADI packet is received.

    It will look at the services we offer and reply to the PADI packet with a 
    PADO packet informing the client of our services.
    
Parameters:

    pAdapter  _ Pointer to the adapter structure that received the packet.

    pBinding _ Pointer to the binding that the packet is received over.

    pPacket _ A received PADI packet.

Return Values:

    None
---------------------------------------------------------------------------*/   
{
    TRACE( TL_N, TM_Mp, ("+MpReplyToPADI") );

    //
    // Verify the requested service name and 
    //
    if ( MpVerifyServiceName( pAdapter, pPADI, TRUE ) )
    {
        NDIS_STATUS status;
        PPPOE_PACKET* pPADO = NULL;

        status = PacketInitializePADOToSend( pPADI,
                                             &pPADO,
                                             pBinding->LocalAddress,
                                             pAdapter->nServiceNameLength,
                                             pAdapter->ServiceName,
                                             pAdapter->nACNameLength,
                                             pAdapter->ACName,
                                             TRUE );

        if ( status == NDIS_STATUS_SUCCESS )
        {
            //
            // Insert the empty generic service name tag
            //
            status = PacketInsertTag( pPADO,
                                      tagServiceName,
                                      0,
                                      NULL,
                                      NULL );
    
            if ( status == NDIS_STATUS_SUCCESS )
            {
                UINT i;
                
                ReferencePacket( pPADO );
                        
                ReferenceBinding( pBinding, TRUE );
    
                PrSend( pBinding, pPADO );
    
                PacketFree( pPADO );
            }
        }

    }

    TRACE( TL_N, TM_Mp, ("-MpReplyToPADI") );
}

BOOLEAN 
MpCheckClientQuota(
    IN ADAPTER* pAdapter,
    IN PPPOE_PACKET* pPacket
    )
{
    BOOLEAN fRet = FALSE;
    HANDLE_TABLE hCallTable = NULL;
    UINT hCallTableSize = 0;
    CALL* pCall;
    CHAR *pSrcAddr = NULL;
    UINT nNumCurrentConn = 0;
    UINT i;
    
    TRACE( TL_N, TM_Mp, ("+MpCheckClientQuota") );

    pSrcAddr = PacketGetSrcAddr( pPacket );

    NdisAcquireSpinLock( &pAdapter->lockAdapter );

    hCallTableSize = pAdapter->nMaxLines * pAdapter->nCallsPerLine;
            
    hCallTable = pAdapter->TapiProv.hCallTable;
    
    for ( i = 0; i < hCallTableSize; i++ )
    {
        pCall = RetrieveFromHandleTableByIndex( hCallTable, (USHORT) i );

        if ( pCall == NULL )
            continue;

        if ( NdisEqualMemory( pCall->DestAddr, pSrcAddr, 6 * sizeof( CHAR ) ) )
        {
            nNumCurrentConn++;

            continue;
        }
    }

    NdisReleaseSpinLock( &pAdapter->lockAdapter );

    if ( nNumCurrentConn < pAdapter->nClientQuota )
    {
        fRet = TRUE;
    }

    TRACE( TL_N, TM_Mp, ("-MpCheckClientQuota=$%d",(UINT) fRet) );

    return fRet;

}

VOID
MpSendPADSWithError(
    IN BINDING* pBinding,
    IN PPPOE_PACKET* pPADR,
    IN ULONG ulErrorCode
    )
{
    NDIS_STATUS status;
    PPPOE_PACKET* pPADS = NULL;
    
    TRACE( TL_N, TM_Mp, ("+MpSendPADSWithError") );

    status = PacketInitializePADSToSend( pPADR,
                                         &pPADS,
                                         (USHORT) 0 );

    if ( status == NDIS_STATUS_SUCCESS )
    {
        switch (ulErrorCode)
        {
            case PPPOE_ERROR_SERVICE_NOT_SUPPORTED:

                status = PacketInsertTag( pPADS,
                                          tagServiceNameError,
                                          PPPOE_ERROR_SERVICE_NOT_SUPPORTED_MSG_SIZE,
                                          PPPOE_ERROR_SERVICE_NOT_SUPPORTED_MSG,
                                          NULL );

                break;
                                 
            case PPPOE_ERROR_INVALID_AC_COOKIE_TAG:

                status = PacketInsertTag( pPADS,
                                          tagGenericError,
                                          PPPOE_ERROR_INVALID_AC_COOKIE_TAG_MSG_SIZE,
                                          PPPOE_ERROR_INVALID_AC_COOKIE_TAG_MSG,
                                          NULL );

                break;

            case PPPOE_ERROR_CLIENT_QUOTA_EXCEEDED:

                status = PacketInsertTag( pPADS,
                                          tagACSystemError,
                                          PPPOE_ERROR_CLIENT_QUOTA_EXCEEDED_MSG_SIZE,
                                          PPPOE_ERROR_CLIENT_QUOTA_EXCEEDED_MSG,
                                          NULL );

                break;
                
        }

    }

    if ( status == NDIS_STATUS_SUCCESS )
    {
        ReferencePacket( pPADS );
        
        ReferenceBinding( pBinding, TRUE );

        PrSend( pBinding, pPADS );

    }

    if ( pPADS )
    {
        PacketFree( pPADS );
    }

    TRACE( TL_N, TM_Mp, ("-MpSendPADSWithError") );

}


VOID
MpRecvCtrlPacket(
    IN BINDING* pBinding,
    IN PPPOE_PACKET* pPacket
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function will be called by MpRecvPacket() when the packet received
    is a control packet. 

    Caller (MpRecPacket()) will make sure that in the context of this function 
    gl_pAdapter, gl_pAdapter->TapiProv.hCallTable and gl_pAdapter->TapiProv.hLineTable 
    are valid. It will also reference and dereference TapiProv correctly.

    This function will identify the call the packet is for and dispatch the 
    packet to it.
    
Parameters:

    pBinding _ Pointer to the binding structure that packet was received over.
    
    pPacket _ A PPPoE packet received over the wire.

Return Values:

    None
---------------------------------------------------------------------------*/   
{
    ADAPTER* pAdapter = NULL;
    BOOLEAN fIndicateReceive = FALSE;
    USHORT usCode;
    CALL* pCall = NULL;

    TRACE( TL_N, TM_Mp, ("+MpRecvCtrlPacket($%x)",pPacket) );

    pAdapter = gl_pAdapter;

    usCode = PacketGetCode( pPacket );

    switch( usCode )
    {
        case PACKET_CODE_PADI:

                //
                // Ignore the received PADI packets unless we act as a server and we have open lines.
                //
                if ( !pAdapter->fClientRole && ( pAdapter->TapiProv.nActiveLines > 0 ) )
                {
                    TRACE( TL_N, TM_Mp, ("MpRecvCtrlPacket($%x): PADI received",pPacket) );

                    MpReplyToPADI( pAdapter, pBinding, pPacket );
                }

                break;

        case PACKET_CODE_PADR:

                //
                // Ignore the received PADR packets unless we act as a server.
                //
                if ( !pAdapter->fClientRole )
                {
                    ULONG ulErrorCode = PPPOE_NO_ERROR;

                    TRACE( TL_N, TM_Mp, ("MpRecvCtrlPacket($%x): PADR received",pPacket) );
                    
                    //
                    // Verify the requested service name and validate the AC Cookie
                    // tag, and if they look OK, then start receiving the call.
                    //
                    if ( !MpVerifyServiceName( pAdapter, pPacket, TRUE ) )
                    {
                        ulErrorCode = PPPOE_ERROR_SERVICE_NOT_SUPPORTED;
                    }
                    else if ( !PacketValidateACCookieTagInPADR( pPacket ) )
                    {
                        ulErrorCode = PPPOE_ERROR_INVALID_AC_COOKIE_TAG;
                    }
                    else if ( !MpCheckClientQuota( pAdapter, pPacket ) )
                    {
                        ulErrorCode = PPPOE_ERROR_CLIENT_QUOTA_EXCEEDED;
                    }

                    if ( ulErrorCode == PPPOE_NO_ERROR )
                    {
                        TpReceiveCall( pAdapter, pBinding, pPacket );
                    }
                    else
                    {
                        MpSendPADSWithError( pBinding, pPacket, ulErrorCode );
                    }
                
                }

                break;
                
        case PACKET_CODE_PADO:

                if ( pAdapter->fClientRole )
                {
                    TRACE( TL_N, TM_Mp, ("MpRecvCtrlPacket($%x): PADO received",pPacket) );

                    //
                    // Retrieve the call handle from the PADO packet
                    //
                    pCall = MpMapPacketWithoutSessionIdToCall( pAdapter, pPacket );

                    if ( pCall )
                    {
                        //
                        // Dispatch the packet to related call
                        //
                        FsmRun( pCall, pBinding, pPacket, NULL );
                                
                        //
                        // Remove the reference added in MpMapPacketWithoutSessionIdToCall()
                        //
                        DereferenceCall( pCall );
                    }

                }

                break;
                
        case PACKET_CODE_PADS:

                if ( pAdapter->fClientRole )
                {                   
                    TRACE( TL_N, TM_Mp, ("MpRecvCtrlPacket($%x): PADS received",pPacket) );

                    //
                    // Retrieve the call handle from the PADS packet
                    //
                    pCall = MpMapPacketWithoutSessionIdToCall( pAdapter, pPacket );

                    if ( pCall )
                    {
                        //
                        // For PADS packet, we must make sure that no other calls 
                        // between the same 2 machines already have the same session id.
                        //  
                        {
                            HANDLE_TABLE hCallTable = NULL; 
                            UINT hCallTableSize     = 0;
                            UINT i                  = 0;
                    
                            USHORT usSessionId = PacketGetSessionId( pPacket );
                            CHAR* pSrcAddr     = PacketGetSrcAddr( pPacket );
                            CHAR* pDestAddr    = PacketGetDestAddr( pPacket );
    
                            BOOLEAN fDuplicateFound = FALSE;
                            CALL* pTempCall         = NULL;

                            TRACE( TL_N, TM_Mp, ("MpRecvCtrlPacket($%x): Checking for duplicate session",pPacket) );

                            NdisAcquireSpinLock( &pAdapter->lockAdapter );
                
                            hCallTableSize = pAdapter->nMaxLines * pAdapter->nCallsPerLine;
                    
                            hCallTable = pAdapter->TapiProv.hCallTable;
            
                            for ( i = 0; i < hCallTableSize ; i++ )
                            {
                
                                pTempCall = RetrieveFromHandleTableByIndex( hCallTable, (USHORT) i );
            
                                if ( pTempCall == NULL )
                                    continue;
        
                                if ( ( pTempCall->usSessionId == usSessionId ) &&
                                     ( NdisEqualMemory( pTempCall->SrcAddr, pSrcAddr, 6 * sizeof( CHAR ) ) ) &&
                                     ( NdisEqualMemory( pTempCall->DestAddr, pDestAddr, 6 * sizeof( CHAR ) ) ) )
                                {
                                    //
                                    // Another call has been detected between the 2 machines with the same
                                    // session id, so do not accept this session
                                    //
                                    fDuplicateFound = TRUE;
                                    
                                    break;
                                }
                            }
    
                            NdisReleaseSpinLock( &pAdapter->lockAdapter );
    
                            if ( fDuplicateFound )
                            {
                                //
                                // We have found another session with the same machine that has the
                                // same session id, so we can not accept this new session.
                                //
                                // Remove the reference added in MpMapPacketWithoutSessionId() and 
                                // drop the packet
                                //
                                TRACE( TL_A, TM_Mp, ("MpRecvCtrlPacket($%x): Packet dropped - Duplicate session found",pPacket) );
                                
                                DereferenceCall( pCall );
                                
                                break;
                            }
    
                        }

                        TRACE( TL_N, TM_Mp, ("MpRecvCtrlPacket($%x): No duplicate sessions found",pPacket) );

                        //
                        // Dispatch the packet to related call
                        //
                        FsmRun( pCall, pBinding, pPacket, NULL );
                                
                        //
                        // Remove the reference added in MpMapPacketWithoutSessionIdToCall()
                        //
                        DereferenceCall( pCall );
    
                    } // if ( pCall ) ...
    
                }   // if ( fClientRole ) ...

                break;
                
        case PACKET_CODE_PADT:

                TRACE( TL_N, TM_Mp, ("MpRecvCtrlPacket($%x): PADT received",pPacket) );

                //
                // PADT packet must have a session id.
                // Identify the session and drop the call.
                //
                pCall = MpMapPacketWithSessionIdToCall( pAdapter, pPacket );

                if ( pCall )
                {
                    NDIS_TAPI_DROP DummyRequest;
                    
                    TRACE( TL_N, TM_Mp, ("MpRecvCtrlPacket($%x): Call being dropped - PADT received",pPacket) );

                    //
                    // Initialize the request, and drop the call
                    //
                    DummyRequest.hdCall = pCall->hdCall;

                    TpDropCall( pAdapter, &DummyRequest, LINEDISCONNECTMODE_NORMAL );

                    //
                    // Remove the reference added in MpMapPacketWithSessionIdToCall()
                    //
                    DereferenceCall( pCall );

                }

                break;

        default:

                break;
    }

    TRACE( TL_N, TM_Mp, ("-MpRecvCtrlPacket($%x)",pPacket) );

}

VOID
MpRecvPacket(
    IN BINDING* pBinding,
    IN PPPOE_PACKET* pPacket
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function will be called by the protocol module to notify the miniport 
    when a packet is received.

    If packet is a control packet, it will call MpRecvCtrlPacket(), otherwise
    it will identify the call and notify NDISWAN about the packet received.
    
Parameters:

    pBinding _ Pointer to the binding structure that packet was received over.
    
    pPacket _ A PPPoE packet received over the wire.

Return Values:

    None
---------------------------------------------------------------------------*/   
{

    ADAPTER* pAdapter = NULL;
    CALL* pCall = NULL;

    TRACE( TL_V, TM_Mp, ("+MpReceivePacket($%x)",pPacket) );

    if ( !gl_fLockAllocated )
    {
        TRACE( TL_V, TM_Mp, ("-MpReceivePacket($%x): Lock not allocated",pPacket) );

        return;
    }

    NdisAcquireSpinLock( &gl_lockAdapter );

    if (  gl_pAdapter && 
         !( gl_pAdapter->ulMpFlags & MPBF_MiniportHaltPending ) &&
          ( gl_pAdapter->ulMpFlags & MPBF_MiniportInitialized ) )
    {

        pAdapter = gl_pAdapter;

        NdisAcquireSpinLock( &pAdapter->lockAdapter );

        if ( !( pAdapter->TapiProv.ulTpFlags & TPBF_TapiProvShutdownPending ) &&
              ( pAdapter->TapiProv.ulTpFlags & TPBF_TapiProvInitialized ) )
        {
            ReferenceTapiProv( pAdapter, FALSE );

            NdisReleaseSpinLock( &pAdapter->lockAdapter );
        }
        else
        {
            NdisReleaseSpinLock( &pAdapter->lockAdapter );

            pAdapter = NULL;
        }
    }

    NdisReleaseSpinLock( &gl_lockAdapter );

    if ( pAdapter == NULL )
    {
        TRACE( TL_V, TM_Mp, ("-MpReceivePacket($%x): Adapter not found",pPacket) );

        return;
    }

    if ( PacketGetCode( pPacket ) == PACKET_CODE_PAYLOAD )
    {
        //
        // Payload packet is received
        //
    
        pCall = MpMapPacketWithSessionIdToCall( pAdapter, pPacket );

        if ( pCall )
        {
            NdisAcquireSpinLock( &pCall->lockCall );

            //
            // Make sure call is not dropped, closed or closing, and receive window is still open
            //
            if ( !( pCall->ulClFlags & ( CLBF_CallDropped | CLBF_CallClosePending | CLBF_CallClosed ) ) && 
                  ( pCall->nReceivedPackets < MAX_RECEIVED_PACKETS ) )
            {
                // 
                // Reference the packet. It will be dereferenced when indicated to NDISWAN, or
                // when the queue is destroyed because the call is getting cleaned up.
                //
                ReferencePacket( pPacket );

                //
                // Insert into the receive queue and bump up the received packet count
                //
                InsertTailList( &pCall->linkReceivedPackets, &pPacket->linkPackets );

                pCall->nReceivedPackets++;

                //
                // Try to schedule an IndicateReceivedPackets handler
                //
                MpScheduleIndicateReceivedPacketsHandler( pCall );

            }

            NdisReleaseSpinLock( &pCall->lockCall );

            //
            // Remove the reference added by MpMapPacketWithSessionIdToCall()
            //
            DereferenceCall( pCall );                             
        }

    }
    else
    {
        //
        // Control packet is received, process it
        //

        MpRecvCtrlPacket( pBinding, pPacket );
    }

    //
    // Remove the reference added above
    //
    DereferenceTapiProv( pAdapter );
    
    TRACE( TL_V, TM_Mp, ("-MpReceivePacket($%x)",pPacket) );
}

VOID
MpIndicateReceivedPackets(
    IN TIMERQITEM* pTqi,
    IN VOID* pContext,
    IN TIMERQEVENT event
    )
{
    ULONG ulPacketsToIndicate = MAX_INDICATE_RECEIVED_PACKETS;
    CALL* pCall = (CALL*) pContext;

    PPPOE_PACKET* pPacket = NULL;
    LIST_ENTRY* pLink = NULL;

    ASSERT( VALIDATE_CALL( pCall ) );

    NdisAcquireSpinLock( &pCall->lockCall );

    while ( ulPacketsToIndicate > 0 && 
            pCall->stateCall == CL_stateSessionUp &&
            pCall->nReceivedPackets > 0)
    {
        ulPacketsToIndicate--;
        
        pLink = RemoveHeadList( &pCall->linkReceivedPackets );

        pCall->nReceivedPackets--;

        NdisReleaseSpinLock( &pCall->lockCall );

        {
            NDIS_STATUS status;
            CHAR* pPayload = NULL;
            USHORT usSize = 0;

            pPacket = (PPPOE_PACKET*) CONTAINING_RECORD( pLink, PPPOE_PACKET, linkPackets );

            PacketRetrievePayload( pPacket,
                                   &pPayload,
                                   &usSize );

            //
            // Future: Make sure the size of the packet is less than the max of what NDISWAN expects 
            //
            // if ( usSize > pCall->NdisWanLinkInfo.MaxRecvFrameSize )
            // {
            //  TRACE( TL_A, TM_Mp, ("MpReceivePacket($%x): PAYLOAD too large to be indicated to NDISWAN",pPacket) );
            // }
            // else

            TRACE( TL_V, TM_Mp, ("MpReceivePacket($%x): PAYLOAD is being indicated to NDISWAN",pPacket) );
    
            NdisMWanIndicateReceive( &status,
                                     pCall->pLine->pAdapter->MiniportAdapterHandle,
                                     pCall->NdisLinkContext,
                                     pPayload,
                                     (UINT) usSize );

            DereferencePacket( pPacket );

        }

        NdisAcquireSpinLock( &pCall->lockCall );
    }

    //
    // Check if there are more packets to indicate
    //
    if ( pCall->stateCall == CL_stateSessionUp &&
         pCall->nReceivedPackets > 0)
    {
        //
        // More packets to indicate, so schedule another timer manually.
        // We can not use MpScheduleIndicateReceivedPacketsHandler() function here
        // because of performance reasons, so we do it manually.
        //
        // Since we are scheduling another handler, we do not dereference and reference 
        // the call context.
        //
        TimerQInitializeItem( &pCall->timerReceivedPackets );

        TimerQScheduleItem( &gl_TimerQ,
                            &pCall->timerReceivedPackets,
                            (ULONG) RECEIVED_PACKETS_TIMEOUT,
                            MpIndicateReceivedPackets,
                            (PVOID) pCall );

        NdisReleaseSpinLock( &pCall->lockCall );
                            
    }
    else
    {
        //
        // We are done, so let's remove the reference on the call context, and
        // reset the CLBF_CallReceivePacketHandlerScheduled flag
        //
        pCall->ulClFlags &= ~CLBF_CallReceivePacketHandlerScheduled;

        NdisReleaseSpinLock( &pCall->lockCall );

        DereferenceCall( pCall );
        
    }

}

VOID 
MpScheduleIndicateReceivedPacketsHandler(
    CALL* pCall
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function will be called to schedule MpIndicateReceivedPackets() handler.

    It will check if we are allowed to schedule it first, and if we are, then it
    will schedule it and reference the call context.

    CAUTION :Caller MUST be holding pCall->lockCall.
    
Parameters:

    pCall _ Pointer to our call context.
    
Return Values:

    NONE
    
---------------------------------------------------------------------------*/   
{

    if ( !( pCall->ulClFlags & CLBF_CallReceivePacketHandlerScheduled ) &&
            pCall->stateCall == CL_stateSessionUp &&
            pCall->nReceivedPackets > 0 )
    {

        pCall->ulClFlags |= CLBF_CallReceivePacketHandlerScheduled;
        
        TimerQInitializeItem( &pCall->timerReceivedPackets );

        TimerQScheduleItem( &gl_TimerQ,
                            &pCall->timerReceivedPackets,
                            (ULONG) RECEIVED_PACKETS_TIMEOUT,
                            MpIndicateReceivedPackets,
                            (PVOID) pCall );

        ReferenceCall( pCall, FALSE );

    }

}

NDIS_STATUS
MpWanGetInfo(
    IN ADAPTER* pAdapter,
    IN PNDIS_WAN_INFO pWanInfo
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function will be called when miniport receives an OID_WAN_GET_INFO
    query from NDISWAN. It will acquire the necesarry information and return it
    back to NDISWAN.

    All the info is initialized when the adapter is initialized except for
    MaxFrameSize which depends on the active bindings. That's why we query 
    the protocol to get the current MaxFrameSize, and pass it back.
    
Parameters:

    pAdapter _ Pointer to our adapter context.
    
    pWanInfo _ Pointer to the NDIS_WAN_INFO structure to be filled in.

Return Values:

    NDIS_STATUS_SUCCESS
    
---------------------------------------------------------------------------*/   
{
    NDIS_STATUS status = NDIS_STATUS_SUCCESS;

    TRACE( TL_N, TM_Mp, ("+MpWanGetInfo") );

    //
    // Retrieve the current MaxFrameSize from protocol
    //
    pAdapter->NdisWanInfo.MaxFrameSize = PrQueryMaxFrameSize();

    //
    // Pass data back to NDISWAN
    //
    *pWanInfo = pAdapter->NdisWanInfo;

    TRACE( TL_N, TM_Mp, ("-MpWanGetInfo()=$%x",status) );

    return status;
}

NDIS_STATUS
MpWanGetLinkInfo(
    IN ADAPTER* pAdapter,
    IN PNDIS_WAN_GET_LINK_INFO pWanLinkInfo
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function will be called when miniport receives an OID_WAN_GET_LINK_INFO
    query from NDISWAN. It will acquire the necesarry information and return it
    back to NDISWAN.

    All the info is initialized in TpCallStateChangeHandler() when TAPI is signaled 
    to LINECALLSTATE_CONNECTED state.

Parameters:

    pAdapter _ Pointer to our adapter context.
    
    pWanLinkInfo _ Pointer to the NDIS_WAN_GET_LINK_INFO structure to be filled in.

Return Values:

    NDIS_STATUS_FAILURE
    NDIS_STATUS_SUCCESS
    
---------------------------------------------------------------------------*/   
{
    NDIS_STATUS status = NDIS_STATUS_FAILURE;
    CALL* pCall = NULL;

    TRACE( TL_N, TM_Mp, ("+MpWanGetLinkInfo") );

    pCall = RetrieveFromHandleTable( pAdapter->TapiProv.hCallTable,
                                     pWanLinkInfo->NdisLinkHandle );

    if ( pCall )
    {
        *pWanLinkInfo = pCall->NdisWanLinkInfo;

        status = NDIS_STATUS_SUCCESS;
    }

    TRACE( TL_N, TM_Mp, ("-MpWanGetLinkInfo()=$%x",status) );

    return status;
}

NDIS_STATUS
MpWanSetLinkInfo(
    IN ADAPTER* pAdapter,
    IN PNDIS_WAN_SET_LINK_INFO pWanLinkInfo
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function will be called when miniport receives an OID_WAN_SET_LINK_INFO
    request from NDISWAN. It will do some checks on the passed in params, and if
    the values are acceptiable it will copy them onto the call context.

Parameters:

    pAdapter _ Pointer to our adapter context.
    
    pWanLinkInfo _ Pointer to the NDIS_WAN_SET_LINK_INFO structure.

Return Values:

    NDIS_STATUS_FAILURE
    NDIS_STATUS_SUCCESS
    
---------------------------------------------------------------------------*/   
{
    NDIS_STATUS status = NDIS_STATUS_FAILURE;
    CALL* pCall = NULL;

    TRACE( TL_N, TM_Mp, ("+MpWanSetLinkInfo") );

    pCall = RetrieveFromHandleTable( pAdapter->TapiProv.hCallTable,
                                     pWanLinkInfo->NdisLinkHandle );

    if ( pCall )
    {
        do
        {
            if ( pWanLinkInfo->MaxSendFrameSize > pCall->ulMaxFrameSize )
            {
                TRACE( TL_A, TM_Mp, ("MpWanSetLinkInfo: Requested MaxSendFrameSize is larger than NIC's") );
            }

            if ( pWanLinkInfo->MaxRecvFrameSize < pCall->ulMaxFrameSize )
            {
                TRACE( TL_A, TM_Mp, ("MpWanSetLinkInfo: Requested MaxRecvFrameSize is smaller than NIC's") );
            }

            if ( pWanLinkInfo->HeaderPadding != pAdapter->NdisWanInfo.HeaderPadding )
            {
                TRACE( TL_A, TM_Mp, ("MpWanSetLinkInfo: Requested HeaderPadding is different than what we asked for") );
            }

            if ( pWanLinkInfo->SendFramingBits & ~pAdapter->NdisWanInfo.FramingBits )
            {
                TRACE( TL_A, TM_Mp, ("MpWanSetLinkInfo: Unknown send framing bits requested") );

                break;
            }
            
            if ( pWanLinkInfo->RecvFramingBits & ~pAdapter->NdisWanInfo.FramingBits )
            {
                TRACE( TL_A, TM_Mp, ("MpWanSetLinkInfo: Unknown recv framing bits requested") );

                break;
            }

            //
            // Ignore FrameSize if the values are 0.
            //
            if(pWanLinkInfo->MaxSendFrameSize != 0)
            {
                pCall->NdisWanLinkInfo.MaxSendFrameSize = pWanLinkInfo->MaxSendFrameSize;
            }

            if(pWanLinkInfo->MaxRecvFrameSize != 0)
            {
                pCall->NdisWanLinkInfo.MaxRecvFrameSize = pWanLinkInfo->MaxRecvFrameSize;
            }

            RtlCopyMemory(&pCall->NdisWanLinkInfo.HeaderPadding,
                           &pWanLinkInfo->HeaderPadding,
                           sizeof(NDIS_WAN_GET_LINK_INFO) - 
                           FIELD_OFFSET(NDIS_WAN_GET_LINK_INFO, HeaderPadding));
                           
            // pCall->NdisWanLinkInfo = * ( (PNDIS_WAN_GET_LINK_INFO) pWanLinkInfo );
    
            status = NDIS_STATUS_SUCCESS;
        
        } while ( FALSE );
    }

    TRACE( TL_N, TM_Mp, ("-MpWanSetLinkInfo()=$%x",status) );

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ndis\raspppoe\fsm.c ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Module Name:

    fsm.c

Abstract:

    This module contains the routines for the PPPoE finite state machine.

Author:

    Hakan Berk - Microsoft, Inc. (hakanb@microsoft.com) Feb-2000

Environment:

    Windows 2000 kernel mode Miniport driver or equivalent.

Revision History:

---------------------------------------------------------------------------*/

#include <ntddk.h>
#include <ntddndis.h>
#include <ndis.h>
#include <ndiswan.h>
#include <ndistapi.h>
#include <ntverp.h>

#include "debug.h"
#include "timer.h"
#include "bpool.h"
#include "ppool.h"
#include "util.h"
#include "packet.h"
#include "protocol.h"
#include "miniport.h"
#include "tapi.h"
#include "fsm.h"

extern TIMERQ gl_TimerQ;

VOID
FsmMakeCall(
	IN CALL* pCall
	)
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

	This function kicks the PPPoE FSM for an outbound call.

	It is called at IRQL_PASSIVE level as a scheduled operation.

	When this function is entered, the call has 3 references on it:
		1. One for scheduling this function.
		2. One for dropping the call.
		3. One for closing the call.

	The removal of the reference will be handled by the caller.
	
	The call will be in stateIdle when this function is entered.
	
Parameters:

	pCall _ A pointer to our call information structure.

Return Values:

	None
	
---------------------------------------------------------------------------*/		
{
	ASSERT( VALIDATE_CALL( pCall ) );

	TRACE( TL_N, TM_Fsm, ("+FsmMakeCall") );
	
	//
	// Notify TAPI that our call is in dialing state
	//
	TpCallStateChangeHandler( pCall, LINECALLSTATE_DIALING, 0 );

	NdisAcquireSpinLock( &pCall->lockCall );

	//
	// If call is already dropped or close is pending,
	// do not proceed.
	//
	if ( pCall->ulClFlags & CLBF_CallClosePending ||
		 pCall->ulClFlags & CLBF_CallDropped )
	{
		TRACE( TL_N, TM_Fsm, ("FsmMakeCall: Call already dropped or close pending") );
		
		NdisReleaseSpinLock( &pCall->lockCall );

		TRACE( TL_N, TM_Fsm, ("-FsmMakeCall") );
		
		return;
	}

	pCall->stateCall = CL_stateSendPadi;

	NdisReleaseSpinLock( &pCall->lockCall );
	
	FsmRun( pCall, NULL, NULL, NULL );

	TRACE( TL_N, TM_Fsm, ("-FsmMakeCall") );
	
}

VOID
FsmReceiveCall(
	IN CALL* pCall,
	IN BINDING* pBinding,
	IN PPPOE_PACKET* pPacket
	)
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

	This function kicks the PPPoE FSM for an inbound call.

	It is called at IRQL_DISPATCH level.

	When this function is entered, the call has 3 references on it:
		1. One for running this function.
		2. One for dropping the call.
		3. One for closing the call.

	The removal of the reference will be handled by the caller.

	The call will be in stateIdle when this function is entered.

	This function will be called when a valid PADR packet is received and 
	a new call context is created. It will initialize the state of call context
	to CL_stateRecvdPadr, and call FsmRun() to run the state machine.
		
Parameters:

	pCall _ A pointer to our call information structure.

	pBinding _ Binding over which the packet is received.

	pPacket _ A PADR packet received.

Return Values:

	None
	
---------------------------------------------------------------------------*/		
{
	ASSERT( VALIDATE_CALL( pCall ) );
	
	TRACE( TL_N, TM_Fsm, ("+FsmReceiveCall") );

	NdisAcquireSpinLock( &pCall->lockCall );

	//
	// If call is already dropped or close is pending,
	// do not proceed.
	//
	if ( pCall->ulClFlags & CLBF_CallClosePending ||
		 pCall->ulClFlags & CLBF_CallDropped )
	{
		TRACE( TL_N, TM_Fsm, ("FsmReceiveCall: Call already dropped or close pending") );
		
		NdisReleaseSpinLock( &pCall->lockCall );

		TRACE( TL_N, TM_Fsm, ("-FsmReceiveCall") );

		return;
	}
	
	pCall->stateCall = CL_stateRecvdPadr;

	NdisReleaseSpinLock( &pCall->lockCall );

	FsmRun( pCall, pBinding, pPacket, NULL );

	TRACE( TL_N, TM_Fsm, ("-FsmReceiveCall") );

}

NDIS_STATUS
FsmAnswerCall(
	IN CALL* pCall
	)
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

	This function will be called when a call indicated to TAPI in 
	LINECALLSTATE_OFFERING state is accepted by TAPI with an OID_TAPI_ANSWER.

	It will change the state of the call to CL_stateSendPads, and run FSM.
	
Parameters:

	pCall _ A pointer to our call information structure.

Return Values:

	NDIS_STATUS_SUCCESS
	NDIS_STATUS_FAILURE
	NDIS_STATUS_XXXXXXX
	
---------------------------------------------------------------------------*/		
{
	NDIS_STATUS status = NDIS_STATUS_FAILURE;
	
	ASSERT( VALIDATE_CALL( pCall ) );
	
	TRACE( TL_N, TM_Fsm, ("+FsmAnswerCall") );

	NdisAcquireSpinLock( &pCall->lockCall );

	//
	// If call is already dropped or close is pending,
	// do not proceed.
	//
	if ( pCall->ulClFlags & CLBF_CallClosePending ||
		 pCall->ulClFlags & CLBF_CallDropped )
	{
		TRACE( TL_N, TM_Fsm, ("FsmAnswerCall: Call already dropped or close pending") );
		
		NdisReleaseSpinLock( &pCall->lockCall );

		TRACE( TL_N, TM_Fsm, ("-FsmAnswerCall=$%x",status) );	

		return status;
	}

	if ( pCall->stateCall != CL_stateOffering )
	{
		TRACE( TL_A, TM_Fsm, ("FsmAnswerCall: Call state changed unexpectedly from CL_stateOffering") );
		
		NdisReleaseSpinLock( &pCall->lockCall );

		TRACE( TL_N, TM_Fsm, ("-FsmAnswerCall=$%x",status) );	

		return status;
	}

	pCall->stateCall = CL_stateSendPads;
	
	NdisReleaseSpinLock( &pCall->lockCall );

	FsmRun( pCall, NULL, NULL, &status );

	TRACE( TL_N, TM_Fsm, ("-FsmAnswerCall=$%x",status) );	

	return status;
}


VOID 
FsmRun(
	IN CALL* pCall,
	IN BINDING* pBinding,
	IN PPPOE_PACKET* pRecvPacket,
	IN NDIS_STATUS* pStatus
	)
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

	This function is the heart of the FSM. It looks at the call context's information
	and takes necesarry actions.

	It will be called at both IRQL_PASSIVE and IRQL_DISPATCH level.

	If this function is entered, then the call must have a reference on it just for 
	running this function.

	The removal of the reference must be handled by the caller.
	
Parameters:

	pCall _ A pointer to our call information structure.

	pBinding _ A pointer to the binding context over which a packet was received.
	           Must be NULL if no packets were received.

	pRecvPacket _ A pointer to a received packet context.
	              Must be NULL if no packets were received.

	pStatus _ An optional parameter when the caller requests status about the
	          operations performed.

Return Values:

	None
	
---------------------------------------------------------------------------*/	
{
	BOOLEAN fLockReleased = FALSE;
	BOOLEAN fDropCall = FALSE;
	BOOLEAN fCloseCall = FALSE;
	BOOLEAN fFallThru = FALSE;
	ULONG ulLineDisconnectMode = 0;

	TRACE( TL_N, TM_Fsm, ("+FsmRun") );

	NdisAcquireSpinLock( &pCall->lockCall );

	//
	// If call is already dropped or close is pending,
	// do not proceed; just remove the reference for FSM and return.
	//
	if ( pCall->ulClFlags & CLBF_CallClosePending ||
		 pCall->ulClFlags & CLBF_CallDropped )
	{
		TRACE( TL_N, TM_Fsm, ("FsmRun: Call already dropped or close pending") );

		NdisReleaseSpinLock( &pCall->lockCall );

		TRACE( TL_N, TM_Fsm, ("-FsmRun") );

		return;
	}

	switch ( pCall->stateCall )
	{

		case CL_stateSendPadi:

			//
			// In this state, we are making a new outbound call, and we should broadcast
			// a PADI packet
			//
			{
				NDIS_STATUS status;
				PPPOE_PACKET* pPacket = NULL;
				CHAR tagHostUniqueValue[16];
				USHORT tagHostUniqueLength;


				TRACE( TL_N, TM_Fsm, ("FsmRun: CL_stateSendPadi") );

				if ( pRecvPacket != NULL )
				{
					TRACE( TL_A, TM_Fsm, ("FsmRun: Can not process packets in this state") );

					break;
				}
				
				CreateUniqueValue( pCall->hdCall,
								   tagHostUniqueValue,
								   &tagHostUniqueLength );

				//
				// Create a PADI packet to send
				//
				status = PacketInitializePADIToSend( &pPacket,
													 pCall->nServiceNameLength,
													 pCall->ServiceName,
													 tagHostUniqueLength,
													 tagHostUniqueValue );

				if ( status != NDIS_STATUS_SUCCESS )
				{
					TRACE( TL_A, TM_Fsm, ("FsmRun: Failed to initialize PADI to send") );

					fDropCall = TRUE;

					ulLineDisconnectMode = LINEDISCONNECTMODE_UNKNOWN;

					break;
				}

				//
				// Attach packet to call context
				//
				pCall->pSendPacket = pPacket;

				ReferencePacket( pPacket );
				
				//
				// Initialize and schedule the timeout handler
				//
				pCall->nNumTimeouts = 0;
				
				TimerQInitializeItem( &pCall->timerTimeout );

				TimerQScheduleItem( &gl_TimerQ,
									&pCall->timerTimeout,
									pCall->pLine->pAdapter->ulSendTimeout,
									FsmSendPADITimeout,
									(PVOID) pCall );

				//
				// Reference call for the timeout handler
				//
				ReferenceCall( pCall, FALSE );

				//
				// Advance the state to next
				//
				pCall->stateCall = CL_stateWaitPado;

				NdisReleaseSpinLock( &pCall->lockCall );

				fLockReleased = TRUE;

				//
				// Packet is ready, so broadcast it
				//
				status = PrBroadcast( pPacket );

				if ( status != NDIS_STATUS_SUCCESS )
				{
					//
					// Broadcast unsuccesfull, drop the call
					//
					TRACE( TL_A, TM_Fsm, ("FsmRun: Failed to broadcast PADI") );

					fDropCall = TRUE;

					ulLineDisconnectMode = LINEDISCONNECTMODE_UNREACHABLE;

				}

				DereferencePacket( pPacket );

			}

			break;

		case CL_stateWaitPado:

			//
			// In this state, we are waiting for a PADO packet, and it seems like we have 
			// received a packet to process
			//

			{
				PPPOE_PACKET* pPacket;

				USHORT usRecvHostUniqueLength;
				USHORT usSendHostUniqueLength;
				CHAR*  pRecvHostUniqueValue = NULL;
				CHAR*  pSendHostUniqueValue = NULL;

				USHORT usRecvACNameLength;
				CHAR*  pRecvACNameValue = NULL;

				USHORT usRecvServiceNameLength;
				USHORT usSendServiceNameLength;
				CHAR*  pRecvServiceNameValue = NULL;
				CHAR*  pSendServiceNameValue = NULL;

				TRACE( TL_N, TM_Fsm, ("FsmRun: CL_stateWaitPado") );

				//
				// Make sure that we received a packet
				//
				if ( pRecvPacket == NULL )
				{
					TRACE( TL_A, TM_Fsm, ("FsmRun: No packets received") );
					
					break;
				}

				//
				// Make sure that we received a PADO packet
				//
				if ( PacketGetCode( pRecvPacket ) != PACKET_CODE_PADO )
				{
					TRACE( TL_A, TM_Fsm, ("FsmRun: Packet not PADO") );
					
					break;
				}

				//
				// Check for errors
				//
				if ( PacketAnyErrorTagsReceived( pRecvPacket ) )
				{
					TRACE( TL_A, TM_Fsm, ("FsmRun: Error tag received in the packet") );

					//
					// We do not need to drop the call since we might receive other
					// PADO packets from different servers.
					//
					
					break;
				}

				//
				// Verify the host unique tag
				//
				if ( pCall->pSendPacket == NULL )
				{	
					//
					// Something is wrong, the last send packet is freed, just return
					//
					TRACE( TL_A, TM_Fsm, ("FsmRun: Last sent packet is freed") );

					fDropCall = TRUE;

					ulLineDisconnectMode = LINEDISCONNECTMODE_UNKNOWN;
					
					break;
				}

				pPacket = pCall->pSendPacket;

				PacketRetrieveHostUniqueTag( pPacket,
											 &usSendHostUniqueLength,
											 &pSendHostUniqueValue );
											
				PacketRetrieveHostUniqueTag( pRecvPacket,
											 &usRecvHostUniqueLength,
											 &pRecvHostUniqueValue );

				if ( usSendHostUniqueLength != usRecvHostUniqueLength )
				{
					//
					// Lengths of host unique tags mismatch, drop the packet
					//
					TRACE( TL_A, TM_Fsm, ("FsmRun: Host Unique tag lengths mismatch") );
					
					break;
				}

				if ( !NdisEqualMemory( pSendHostUniqueValue, pRecvHostUniqueValue, usSendHostUniqueLength ) )
				{
					//
					// Host unique tag values mismatch, drop the packet
					// 
					TRACE( TL_A, TM_Fsm, ("FsmRun: Host Unique tag values mismatch") );
					
					break;
				}

				//
				// Host unique id is validated, retrieve the AC-name tag
				//
				PacketRetrieveACNameTag( pRecvPacket,
										 &usRecvACNameLength,
										 &pRecvACNameValue );

				if ( usRecvACNameLength == 0 )
				{
					//
					// AC name is invalid, drop the packet
					// 
					TRACE( TL_A, TM_Fsm, ("FsmRun: Invalid AC-Name tag") );
					
					break;
				}

            if ( pCall->fACNameSpecified )
            {
               //
               // Caller specified an AC Name, so validate it
               //
               if ( pCall->nACNameLength != usRecvACNameLength )
               {
   					//
	   				// Received AC name does not match the specified one, drop the packet
		   			//
			   		TRACE( TL_A, TM_Fsm, ("FsmRun: AC Name Length mismatch") );
				   	
					   break;
               }

               if ( !NdisEqualMemory( pRecvACNameValue, pCall->ACName, usRecvACNameLength ) )
         		{
				   	//
			   		// Host unique tag values mismatch, drop the packet
   					// 
	   				TRACE( TL_A, TM_Fsm, ("FsmRun: AC Name mismatch") );
		   			
			   		break;
				   }
               
            }
            else
            {
               //
               // No AC Name was specified so copy the AC Name from the received packet
               //
   				pCall->nACNameLength = ( MAX_AC_NAME_LENGTH < usRecvACNameLength ) ?
	          								    MAX_AC_NAME_LENGTH : usRecvACNameLength;
									   
   				NdisMoveMemory( pCall->ACName, pRecvACNameValue, pCall->nACNameLength );
            }

				//
				// AC-Name is validated, verify the service-name tag
				//
				PacketRetrieveServiceNameTag( pPacket,
											  &usSendServiceNameLength,
											  &pSendServiceNameValue,
											  0,
											  NULL );
											
				PacketRetrieveServiceNameTag( pRecvPacket,
											  &usRecvServiceNameLength,
											  &pRecvServiceNameValue,
											  0,
											  NULL );
											  
				//
				// Make sure we have received a service-name at least
				//
				if ( pRecvServiceNameValue == NULL )
				{
					TRACE( TL_A, TM_Fsm, ("FsmRun: No service-name tag in a received PADO") );
					
					break;
				}

                //
                // If fAcceptAnyService is FALSE, then make sure the requested service is in the PADO 
                // received, otherwise if we have requested an empty service name, then try to find it 
                // in the PADO, if not use the first service name from it.
                //
                {
					BOOLEAN fFound = FALSE;
					CHAR*  pFirstRecvServiceNameValue = NULL;
					USHORT usFirstRecvServiceNameLength = 0;
                    BOOLEAN fAcceptAnyService = pCall->pLine->pAdapter->fAcceptAnyService;
					//
					// We have asked for a specific service name, so let's
					// see if the server responded with it
					//
					while ( usRecvServiceNameLength >= 0 && pRecvServiceNameValue != NULL )
					{
                        if ( pFirstRecvServiceNameValue == NULL )
                        {
                            pFirstRecvServiceNameValue = pRecvServiceNameValue;
                            usFirstRecvServiceNameLength = usRecvServiceNameLength;
                        }
						
						if ( usRecvServiceNameLength == usSendServiceNameLength )
						{

							if ( NdisEqualMemory( pSendServiceNameValue, 
												  pRecvServiceNameValue, 
												  usSendServiceNameLength ) )
							{
								fFound = TRUE;
			
								break;
							}
						}

						PacketRetrieveServiceNameTag( pRecvPacket,
													  &usRecvServiceNameLength,
													  &pRecvServiceNameValue,
													  usRecvServiceNameLength,
													  pRecvServiceNameValue );
						
					}

					if ( !fFound )
					{
                        if ( fAcceptAnyService )
                        {
                            //
                            // Use the first service in the PADO, if we have requested an
                            // empty service-name
                            //
                            if ( usSendServiceNameLength == 0 )
                            {
                                pCall->nServiceNameLength = ( MAX_SERVICE_NAME_LENGTH < usFirstRecvServiceNameLength ) ?
                                                              MAX_SERVICE_NAME_LENGTH : usFirstRecvServiceNameLength;

                                if ( pCall->nServiceNameLength > 0 )
                                {
                                    if(NULL != pFirstRecvServiceNameValue)
                                    {
                                        NdisMoveMemory( pCall->ServiceName, 
                                                    pFirstRecvServiceNameValue, 
                                                    pCall->nServiceNameLength );
                                    }                                                    
                                    
                                    fFound = TRUE;
                                }
                            }
                        }

                        if ( !fFound )
                        {
                            //
                            // We could not find a matching service name tag, so drop the packet
                            //
                            TRACE( TL_A, TM_Fsm, ("FsmRun: PADO does not contain the service-name tag we requested") );
                            
                            break;
                        }
                    }
                }

				//
				// Received packet is validated, so set the dest addr in the call.
				// The source address will be copied on the call in PrAddCallToBinding() below.
				//
				NdisMoveMemory( pCall->DestAddr, PacketGetSrcAddr( pRecvPacket ), 6 * sizeof( CHAR ) );
				
				//
				// Received packet is validated, so proceed to next state
				//
				pCall->stateCall = CL_stateSendPadr;
				fFallThru = TRUE;

				//
				// As we are done with the last sent packet, free it
				//
				pCall->pSendPacket = NULL;
				
				PacketFree( pPacket );

				//
				// Cancel the timeout handler and attach call to binding
				//
				NdisReleaseSpinLock( &pCall->lockCall );

				TimerQCancelItem( &gl_TimerQ, &pCall->timerTimeout );

				PrAddCallToBinding( pBinding, pCall );

				//
				// Notify TAPI that our call is in proceeding state
				//
				TpCallStateChangeHandler( pCall, LINECALLSTATE_PROCEEDING, 0 );
				
				NdisAcquireSpinLock( &pCall->lockCall );

				//
				// Make sure state was not changed when we released the lock to cancel the timer queue item
				//
				if ( pCall->stateCall != CL_stateSendPadr )
				{
					TRACE( TL_A, TM_Fsm, ("FsmRun: State changed unexpectedly from CL_stateSendPadr") );
					
					break;
				}

				//
				// Fall thru to case CL_stateSendPadr
				//
			}

		case CL_stateSendPadr:

			//
			// In this state, we have received a valid PADO packet, and we need to respond to it
			// with a PADR packet
			//
			{
				
				NDIS_STATUS status;
				PPPOE_PACKET* pPacket = NULL;
				CHAR tagHostUniqueValue[16];
				USHORT tagHostUniqueLength;

				TRACE( TL_N, TM_Fsm, ("FsmRun: CL_stateSendPadr") );

				if ( !fFallThru )
				{
					TRACE( TL_N, TM_Fsm, ("FsmRun: Non fall thru entry into a fall thru state") );

					break;
				}

				CreateUniqueValue( pCall->hdCall,
								   tagHostUniqueValue,
								   &tagHostUniqueLength );

				//
				// Create a PADR packet to send
				//
				status = PacketInitializePADRToSend( pRecvPacket,
													 &pPacket,
													 pCall->nServiceNameLength,
													 pCall->ServiceName,
													 tagHostUniqueLength,
													 tagHostUniqueValue );

				if ( status != NDIS_STATUS_SUCCESS )
				{
					TRACE( TL_A, TM_Fsm, ("FsmRun: Failed to initialize PADR to send") );
					
					fDropCall = TRUE;

					ulLineDisconnectMode = LINEDISCONNECTMODE_UNKNOWN;

					break;
				}

				//
				// Attach packet to call context
				//
				pCall->pSendPacket = pPacket;

				ReferencePacket( pPacket );

				//
				// Reference binding for PrSend()
				//
				ReferenceBinding( pBinding, TRUE );
				
				//
				// Initialize and schedule the timeout handler
				//
				pCall->nNumTimeouts = 0;
				
				TimerQInitializeItem( &pCall->timerTimeout );

				TimerQScheduleItem( &gl_TimerQ,
									&pCall->timerTimeout,
									pCall->pLine->pAdapter->ulSendTimeout,
									FsmSendPADRTimeout,
									(PVOID) pCall );

				//
				// Reference call for the timeout handler
				//
				ReferenceCall( pCall, FALSE );

				//
				// Advance the state to next
				//
				pCall->stateCall = CL_stateWaitPads;

				//
				// Release the lock to send the packet
				//
				NdisReleaseSpinLock( &pCall->lockCall );

				fLockReleased = TRUE;

				//
				// Packet is ready, so send it
				//
				status = PrSend( pBinding, pPacket );

				if ( status != NDIS_STATUS_PENDING )
				{
					if ( status != NDIS_STATUS_SUCCESS )
					{
						//
						// Send operation was not succesful, so drop the call
						//
						TRACE( TL_A, TM_Fsm, ("FsmRun: PrSend() failed to send PADR") );
						
						fDropCall = TRUE;

						ulLineDisconnectMode = LINEDISCONNECTMODE_UNREACHABLE;
					}
					
				}

			}

			break;

		case CL_stateWaitPads:

			//
			// In this state, we have sent a PADR packet and waiting for a PADS packet to establish
			// a session
			//
			
			{
				PPPOE_PACKET* pPacket;

				USHORT usRecvHostUniqueLength;
				USHORT usSendHostUniqueLength;
				CHAR*  pRecvHostUniqueValue = NULL;
				CHAR*  pSendHostUniqueValue = NULL;

				USHORT usRecvServiceNameLength;
				USHORT usSendServiceNameLength;
				CHAR*  pRecvServiceNameValue = NULL;
				CHAR*  pSendServiceNameValue = NULL;

				TRACE( TL_N, TM_Fsm, ("FsmRun: CL_stateWaitPads") );

				//
				// Make sure that we received a packet
				//
				if ( pRecvPacket == NULL )
				{
					TRACE( TL_A, TM_Fsm, ("FsmRun: No packets received") );
					
					break;
				}

				//
				// Make sure that we received a PADO packet
				//
				if ( PacketGetCode( pRecvPacket ) != PACKET_CODE_PADS )
				{
					TRACE( TL_A, TM_Fsm, ("FsmRun: Packet not PADS") );
					
					break;
				}

				//
				// Check for errors
				//
				if ( PacketAnyErrorTagsReceived( pRecvPacket ) )
				{
					PACKET_TAGS tagType;
					USHORT tagLength;
					CHAR* tagValue = NULL;
					
					TRACE( TL_A, TM_Fsm, ("FsmRun: Error tag received in the packet") );
					
					fDropCall = TRUE;

					//
					// Set the line disconnect mode looking at the error tag
					//
					PacketRetrieveErrorTag( pRecvPacket,
											&tagType,
											&tagLength,
											&tagValue );

					switch( tagType ) {

						case tagServiceNameError:
						
									ulLineDisconnectMode = LINEDISCONNECTMODE_BADADDRESS;
									
									break;

						case tagACSystemError:

									ulLineDisconnectMode = LINEDISCONNECTMODE_INCOMPATIBLE;

									break;

						case tagGenericError:

									ulLineDisconnectMode = LINEDISCONNECTMODE_REJECT;

									break;
					}

					break;
				}

				//
				// Verify the host unique tag
				//
				if ( pCall->pSendPacket == NULL )
				{	
					//
					// Something is wrong, the last send packet is freed, just return
					//
					TRACE( TL_A, TM_Fsm, ("FsmRun: Last sent packet is freed") );

					fDropCall = TRUE;

					ulLineDisconnectMode = LINEDISCONNECTMODE_UNKNOWN;
					
					break;
				}

				pPacket = pCall->pSendPacket;

				PacketRetrieveHostUniqueTag( pPacket,
											 &usSendHostUniqueLength,
											 &pSendHostUniqueValue );
											
				PacketRetrieveHostUniqueTag( pRecvPacket,
											 &usRecvHostUniqueLength,
											 &pRecvHostUniqueValue );

				if ( usSendHostUniqueLength != usRecvHostUniqueLength )
				{
					//
					// Lengths of host unique tags mismatch, drop the packet
					//
					TRACE( TL_A, TM_Fsm, ("FsmRun: Host Unique tag lengths mismatch") );
					
					break;
				}

				if ( !NdisEqualMemory( pSendHostUniqueValue, pRecvHostUniqueValue, usSendHostUniqueLength ) )
				{
					//
					// Host unique tag values mismatch, drop the packet
					// 
					TRACE( TL_A, TM_Fsm, ("FsmRun: Host Unique tag values mismatch") );
					
					break;
				}

				//
				// Host unique id is validated, verify the service name
				//
				PacketRetrieveServiceNameTag( pPacket,
											  &usSendServiceNameLength,
											  &pSendServiceNameValue,
											  0,
											  NULL );
											
				PacketRetrieveServiceNameTag( pRecvPacket,
											  &usRecvServiceNameLength,
											  &pRecvServiceNameValue,
											  0,
											  NULL );

				//
				// Make sure we have received a service-name at least
				//
				if ( pRecvServiceNameValue == NULL )
				{
					TRACE( TL_A, TM_Fsm, ("FsmRun: No service-name tag in a received PADS") );
					
					break;
				}

				//
				// Search for the specific service-name we requested
				//
				{
					BOOLEAN fFound = FALSE;

					//
					// We have asked for a specific service name, so let's
					// see if the server responded with it
					//
					while ( usRecvServiceNameLength >= 0 && pRecvServiceNameValue != NULL )
					{
						
						if ( usRecvServiceNameLength == usSendServiceNameLength )
						{

							if ( NdisEqualMemory( pSendServiceNameValue, 
												  pRecvServiceNameValue, 
												  usSendServiceNameLength ) )
							{
								fFound = TRUE;
			
								break;
							}
						}

						PacketRetrieveServiceNameTag( pRecvPacket,
													  &usRecvServiceNameLength,
													  &pRecvServiceNameValue,
													  usRecvServiceNameLength,
													  pRecvServiceNameValue );
						
					}

					if ( !fFound )
					{
						//
						// We could not find a matching service name tag, so drop the packet
						//
						TRACE( TL_A, TM_Fsm, ("FsmRun: PADS does not contain the service-name tag we requested") );
						
						break;
					}
				}

				//
				// Set the session id on the call context
				//
				pCall->usSessionId = PacketGetSessionId( pRecvPacket );

				//
				// As we are done with the last sent packet, free it
				//
				pCall->pSendPacket = NULL;
				
				PacketFree( pPacket );

				//
				// Cancel the timeout handler and attach call to binding
				//
				NdisReleaseSpinLock( &pCall->lockCall );

				fLockReleased = TRUE;

				TimerQCancelItem( &gl_TimerQ, &pCall->timerTimeout );

				//
				// Notify call connect event
				//
				TpCallStateChangeHandler( pCall, LINECALLSTATE_CONNECTED, 0 );

			}

			break;

		case CL_stateRecvdPadr:

			//
			// In this state, we have been received a PADR packet.
			// We will indicate the call to Tapi, and change the state to CL_stateOffering 
			// and wait for the application to answer the call.
			//
			{
				NDIS_STATUS status;
				PPPOE_PACKET* pPacket;

				USHORT usRecvServiceNameLength;
				CHAR*  pRecvServiceNameValue = NULL;

				USHORT usSessionId;

				TRACE( TL_N, TM_Fsm, ("FsmRun: CL_stateWaitPadr") );
				
				//
				// Make sure that we received a packet
				//
				if ( pRecvPacket == NULL )
				{
					TRACE( TL_A, TM_Fsm, ("FsmRun: No packets received") );
					
					break;
				}
				
				//
				// Make sure that we received a PADR packet
				//
				if ( PacketGetCode( pRecvPacket ) != PACKET_CODE_PADR )
				{
					TRACE( TL_A, TM_Fsm, ("FsmRun: Packet not PADR") );
				
					break;
				}

				//
				// Set the dest addr in the call.
				// The source address will be copied on to the call in PrAddCallToBinding() below.
				//
				NdisMoveMemory( pCall->DestAddr, PacketGetSrcAddr( pRecvPacket ), 6 * sizeof( CHAR ) );

				//
				// Retrieve the service name and copy it onto the call context
				//
				PacketRetrieveServiceNameTag( pRecvPacket,
											  &usRecvServiceNameLength,
											  &pRecvServiceNameValue,
											  0,
											  NULL );
				
				pCall->nServiceNameLength = ( MAX_SERVICE_NAME_LENGTH < usRecvServiceNameLength ) ?
											  MAX_SERVICE_NAME_LENGTH : usRecvServiceNameLength;
											  
				NdisMoveMemory( pCall->ServiceName, 
								pRecvServiceNameValue, 
								pCall->nServiceNameLength );

				//
				// Copy the AC-Name onto call context, before connection is established
				//
				pCall->nACNameLength = pCall->pLine->pAdapter->nACNameLength;
				
				NdisMoveMemory( pCall->ACName, 
								pCall->pLine->pAdapter->ACName, 
								pCall->nACNameLength );

				//
				// Retrieve the session id from the call handle and create a PADS packet to send
				//
				usSessionId = RetrieveSessionIdFromHandle( (NDIS_HANDLE) pCall->hdCall );

				status = PacketInitializePADSToSend( pRecvPacket,
													 &pPacket,
													 usSessionId );

				if ( status != NDIS_STATUS_SUCCESS )
				{
					TRACE( TL_A, TM_Fsm, ("FsmRun: Failed to initialize PADS to send") );
					
					fCloseCall = TRUE;

					break;
				}

				//
				// This PADS packet will be sent if application answers the call
				//
				pCall->pSendPacket = pPacket;

				//
				// Proceed to next state
				//
				pCall->stateCall = CL_stateOffering;

				//
				// Initialize and schedule the timeout handler
				//
				pCall->nNumTimeouts = 0;

				TimerQInitializeItem( &pCall->timerTimeout );

				TimerQScheduleItem( &gl_TimerQ,
									&pCall->timerTimeout,
									pCall->pLine->pAdapter->ulRecvTimeout,
									FsmOfferingTimeout,
									(PVOID) pCall );

				//
				// Reference call for the timeout handler
				//
				ReferenceCall( pCall, FALSE );

				//
				// Release the lock
				//
				NdisReleaseSpinLock( &pCall->lockCall );
				
				fLockReleased = TRUE;
				
				//
				// Notify TAPI about the state change
				//
				if ( TpIndicateNewCall( pCall ) )
				{
					//
					// Add call to binding
					//
					PrAddCallToBinding( pBinding, pCall );

					TpCallStateChangeHandler( pCall, LINECALLSTATE_OFFERING, 0 );
				
				}

			}

			break;

		case CL_stateSendPads:

			//
			// In this state, TAPI has accepted the call, so we should send the PADS packet and create 
			// the session.
			//
			{
				NDIS_STATUS status;
				PPPOE_PACKET* pPacket = NULL;

				TRACE( TL_N, TM_Fsm, ("FsmRun: CL_stateSendPads") );

				if ( pRecvPacket != NULL )
				{
					TRACE( TL_A, TM_Fsm, ("FsmRun: Can not process packets in this state") );

					break;
				}

				//
				// Make sure we still have the PADS packet to send
				//
				if ( pCall->pSendPacket == NULL )
				{	
					//
					// Something is wrong, the last send packet is freed, drop the call
					//
					TRACE( TL_A, TM_Fsm, ("FsmRun: Last sent packet is freed") );

					fDropCall = TRUE;

					*pStatus = NDIS_STATUS_FAILURE;
					
					break;
				}

				pPacket = pCall->pSendPacket;

				if ( pCall->pBinding == NULL )
				{
					//
					// Binding is gone, we should drop the call
					//
					TRACE( TL_A, TM_Fsm, ("FsmRun: No binding found") );

					fDropCall = TRUE;

					*pStatus = NDIS_STATUS_FAILURE;					
					
					break;
				}
				
				pBinding = pCall->pBinding;
				
				//
				// Reference packet and binding for PrSend()
				//
				ReferencePacket( pPacket );

				ReferenceBinding( pBinding, TRUE );

				//
				// Set the session id on the call context
				//
				pCall->usSessionId = RetrieveSessionIdFromHandle( (NDIS_HANDLE) pCall->hdCall );

				//
				// Release the lock and send the packet
				//
				NdisReleaseSpinLock( &pCall->lockCall );

				fLockReleased = TRUE;

				//
				// Cancel the timeout handler
				//
				TimerQCancelItem( &gl_TimerQ, &pCall->timerTimeout );
				
				//
				// Packet is ready, so send it
				//
				status = PrSend( pBinding, pPacket );

				if ( status != NDIS_STATUS_PENDING )
				{
					if ( status != NDIS_STATUS_SUCCESS )
					{
						//
						// Send operation was not succesful, so drop the call
						//
						TRACE( TL_A, TM_Fsm, ("FsmRun: PrSend() failed to send PADS") );
						
						fDropCall = TRUE;

						*pStatus = NDIS_STATUS_FAILURE;
						
						break;
						
					}
				}

				//
				// Notify call connect event, since we sent the PADS packet
				//
				TpCallStateChangeHandler( pCall, LINECALLSTATE_CONNECTED, 0 );

				*pStatus = NDIS_STATUS_SUCCESS;

			}

			break;
			
		default:

			TRACE( TL_A, TM_Fsm, ("FsmRun: Ignoring irrelevant state notification") );

			break;
	}

	if ( !fLockReleased )
	{
		NdisReleaseSpinLock( &pCall->lockCall );
	}

	if ( fCloseCall )
	{
		NDIS_TAPI_CLOSE_CALL DummyRequest;

		TRACE( TL_N, TM_Fsm, ("FsmRun: Closing call") );

		DummyRequest.hdCall = pCall->hdCall;
						
		//
		// Close will take care of unbinding and cancelling the timer
		//
		TpCloseCall( pCall->pLine->pAdapter, &DummyRequest, FALSE );
	
	}

	if ( fDropCall )
	{
		NDIS_TAPI_DROP DummyRequest;
				
		TRACE( TL_N, TM_Fsm, ("FsmRun: Dropping call") );

		DummyRequest.hdCall = pCall->hdCall;
						
		//
		// Drop will take care of unbinding and cancelling the timer
		//
		TpDropCall( pCall->pLine->pAdapter, &DummyRequest, ulLineDisconnectMode );

	}

	TRACE( TL_N, TM_Fsm, ("-FsmRun") );
	
}

VOID
FsmSendPADITimeout(
    IN TIMERQITEM* pTqi,
    IN VOID* pContext,
    IN TIMERQEVENT event 
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

	This function is the timeout handler for a sent PADI packet.

	If the timeout period expires before a valid PADO packet is received,
	this function will be called with TE_Expire. In this case we check for 
	a few conditions, and schedule another timeout event if necesarry.
	
	If it was cancelled -because a PADO packet was received - or timer queue 
	is terminating then	it will be called with TE_Cancel and TE_Terminate codes
	respectively. In this case, we do not do anything, just remove the reference
	and return.
	
Parameters:

	pTqi _ A pointer to our timer queue item information structure.

	pContext _ A pointer to a our call information structure.

	event _ Indicates the type of event: TE_Expire, TE_Cancel or TE_Terminate.
	
Return Values:

	None
	
---------------------------------------------------------------------------*/    
{
	CALL* pCall = (CALL*) pContext;
	BOOLEAN fDropCall = FALSE;
	ULONG ulLineDisconnectMode = 0;

	TRACE( TL_N, TM_Fsm, ("+FsmSendPADITimeout") );
	
	switch ( event )
	{

		case TE_Expire:

			//
			// Timeout period expired, take necesarry actions
			//
			{
				NDIS_STATUS status;
				PPPOE_PACKET* pPacket = NULL;
				
				TRACE( TL_N, TM_Fsm, ("FsmSendPADITimeout: Timer expired") );

				NdisAcquireSpinLock( &pCall->lockCall );

				if ( pCall->stateCall != CL_stateWaitPado )
				{
					//
					// State has changed, no need further processing of this event
					//
					TRACE( TL_A, TM_Fsm, ("FsmSendPADITimeout: State already changed") );

					NdisReleaseSpinLock( &pCall->lockCall );

					break;
					
				}

				//
				// Check if we have reached the max number of time outs
				//
				if ( pCall->nNumTimeouts == pCall->pLine->pAdapter->nMaxTimeouts )
				{
					//
					// We did not receive any answers, drop the call
					//
					TRACE( TL_N, TM_Fsm, ("FsmSendPADITimeout: Max number of timeouts reached") );

					NdisReleaseSpinLock( &pCall->lockCall );
					
					fDropCall = TRUE;

					ulLineDisconnectMode = LINEDISCONNECTMODE_NOANSWER;

					break;
				}

				pPacket = pCall->pSendPacket;

				if ( pPacket == NULL )
				{
					//
					// We are probably in a ver small timing window where FsmRun() is also
					// working on the same call, and has just freed the packet, so it probably
					// cancelled the timer, but we did not get the cancel, and instead we were 
					// called with TE_Expire, so let's just act like we were cancelled.
					//
					TRACE( TL_A, TM_Fsm, ("FsmSendPADITimeout: Can not find last sent packet for re-send") );

					NdisReleaseSpinLock( &pCall->lockCall );

					break;
				}

				ReferencePacket( pPacket );

				//
				// Schedule another timeout event
				//
				TimerQInitializeItem( &pCall->timerTimeout );

				TimerQScheduleItem( &gl_TimerQ,
									&pCall->timerTimeout,
									pCall->pLine->pAdapter->ulSendTimeout,
									FsmSendPADITimeout,
									(PVOID) pCall );

				//
				// Reference call for the new timeout handler
				//
				ReferenceCall( pCall, FALSE );

				//
				// Increment the timeout counter
				//
				pCall->nNumTimeouts++;

				NdisReleaseSpinLock( &pCall->lockCall );

				//
				// Packet is ready, so broadcast it
				//
				status = PrBroadcast( pPacket );

				if ( status != NDIS_STATUS_SUCCESS )
				{
					//
					// Broadcast unsuccesfull, drop the call
					//
					TRACE( TL_A, TM_Fsm, ("FsmSendPADITimeout: Broadcast failed") );

					fDropCall = TRUE;

					ulLineDisconnectMode = LINEDISCONNECTMODE_UNREACHABLE;
				}

				DereferencePacket( pPacket );
				
			}

			break;

		case TE_Cancel:
		case TE_Terminate:

			{
				//
				// Reset the timeout counter and reference will be removed below
				//
				TRACE( TL_N, TM_Fsm, ("FsmSendPADITimeout: Timer cancelled or terminated") );
				
				NdisAcquireSpinLock( &pCall->lockCall );
	
				pCall->nNumTimeouts = 0;
	
				NdisReleaseSpinLock( &pCall->lockCall );

			}
			
			break;
	}

	if ( fDropCall )
	{
		NDIS_TAPI_DROP DummyRequest;
				
		TRACE( TL_N, TM_Fsm, ("FsmSendPADITimeout: Dropping call") );

		DummyRequest.hdCall = pCall->hdCall;
						
		//
		// Drop will take care of unbinding and cancelling the timer
		//
		TpDropCall( pCall->pLine->pAdapter, &DummyRequest, ulLineDisconnectMode );

	}

	DereferenceCall( pCall );

	TRACE( TL_N, TM_Fsm, ("-FsmSendPADITimeout") );
	

}

VOID
FsmSendPADRTimeout(
    IN TIMERQITEM* pTqi,
    IN VOID* pContext,
    IN TIMERQEVENT event 
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

	This function is the timeout handler for a sent PADR packet.

	If the timeout period expires before a valid PADS packet is received,
	this function will be called with TE_Expire. In this case we check for 
	a few conditions, and schedule another timeout event if necesarry.
	
	If it was cancelled - because a PADS packet was received - or timer queue 
	is terminating then	it will be called with TE_Cancel and TE_Terminate codes
	respectively. In this case, we do not do anything, just remove the reference
	and return.
	
Parameters:

	pTqi _ A pointer to our timer queue item information structure.

	pContext _ A pointer to a our call information structure.

	event _ Indicates the type of event: TE_Expire, TE_Cancel or TE_Terminate.
	
Return Values:

	None
	
---------------------------------------------------------------------------*/    
{
	CALL* pCall = (CALL*) pContext;
	BOOLEAN fDropCall = FALSE;
	ULONG ulLineDisconnectMode = 0;

	TRACE( TL_N, TM_Fsm, ("+FsmSendPADRTimeout") );
	
	switch ( event )
	{

		case TE_Expire:

			//
			// Timeout period expired, take necesarry actions
			//
			{
				NDIS_STATUS status;
				PPPOE_PACKET* pPacket = NULL;
				BINDING* pBinding = NULL;
				
				TRACE( TL_N, TM_Fsm, ("FsmSendPADRTimeout: Timer expired") );

				NdisAcquireSpinLock( &pCall->lockCall );

				if ( pCall->stateCall != CL_stateWaitPads )
				{
					//
					// State has changed, no need further processing of this event
					//
					TRACE( TL_A, TM_Fsm, ("FsmSendPADRTimeout: State already changed") );

					NdisReleaseSpinLock( &pCall->lockCall );

					break;
					
				}

				//
				// Check if we have reached the max number of time outs
				//
				if ( pCall->nNumTimeouts == pCall->pLine->pAdapter->nMaxTimeouts )
				{
					//
					// We did not receive any answers, drop the call
					//
					TRACE( TL_N, TM_Fsm, ("FsmSendPADRTimeout: Max number of timeouts reached") );

					NdisReleaseSpinLock( &pCall->lockCall );
					
					fDropCall = TRUE;

					ulLineDisconnectMode = LINEDISCONNECTMODE_BUSY;

					break;
				}

				//
				// Save the binding for send operation
				//
				pBinding = pCall->pBinding;

				if ( pBinding == NULL )
				{
					//
					// The binding was removed, drop the call
					//
					TRACE( TL_A, TM_Fsm, ("FsmSendPADRTimeout: Binding not found") );

					NdisReleaseSpinLock( &pCall->lockCall );
					
					fDropCall = TRUE;

					ulLineDisconnectMode = LINEDISCONNECTMODE_UNREACHABLE;

					break;
				}

				//
				// Save the packet for send operation
				//
				pPacket = pCall->pSendPacket;
				
				if ( pPacket == NULL )
				{
					//
					// We are probably in a ver small timing window where FsmRun() is also
					// working on the same call, and has just freed the packet, so it probably
					// cancelled the timer, but we did not get the cancel, and instead we were 
					// called with TE_Expire, so let's just act like we were cancelled.
					//
					TRACE( TL_A, TM_Fsm, ("FsmSendPADRTimeout: Can not find last sent packet for re-send") );
					
					NdisReleaseSpinLock( &pCall->lockCall );

					break;
				}

				//
				// Reference both binding and the packet as PrSend() might pend, in which case
				// PrSendComplete() will remove these references
				//
				ReferenceBinding ( pBinding, TRUE );

				ReferencePacket( pPacket );

				//
				// Schedule another timeout event
				//
				TimerQInitializeItem( &pCall->timerTimeout );

				TimerQScheduleItem( &gl_TimerQ,
									&pCall->timerTimeout,
									pCall->pLine->pAdapter->ulSendTimeout,
									FsmSendPADRTimeout,
									(PVOID) pCall );

				//
				// Reference call for the new timeout handler
				//
				ReferenceCall( pCall, FALSE );

				//
				// Increment the timeout counter
				//
				pCall->nNumTimeouts++;

				NdisReleaseSpinLock( &pCall->lockCall );

				//
				// Send the packet once more
				//
				status = PrSend( pBinding, pPacket );

				if ( status != NDIS_STATUS_PENDING )
				{
					if ( status != NDIS_STATUS_SUCCESS )
					{
						//
						// Send operation was not succesful, so drop the call
						//
						TRACE( TL_A, TM_Fsm, ("FsmSendPADRTimeout: PrSend() failed to send PADR") );

						fDropCall = TRUE;

						ulLineDisconnectMode = LINEDISCONNECTMODE_UNREACHABLE;
					}
					
				}

				
			}

			break;

		case TE_Cancel:
		case TE_Terminate:

			{
				//
				// Reset the timeout counter and reference will be removed below
				//
				TRACE( TL_N, TM_Fsm, ("FsmSendPADRTimeout: Timer cancelled or terminated") );
					
				NdisAcquireSpinLock( &pCall->lockCall );
	
				pCall->nNumTimeouts = 0;
	
				NdisReleaseSpinLock( &pCall->lockCall );

			}
			
			break;
	}

	if ( fDropCall )
	{
		NDIS_TAPI_DROP DummyRequest;
				
		TRACE( TL_N, TM_Fsm, ("FsmSendPADRTimeout: Dropping call") );

		DummyRequest.hdCall = pCall->hdCall;
						
		//
		// Drop will take care of unbinding and cancelling the timer
		//
		TpDropCall( pCall->pLine->pAdapter, &DummyRequest, ulLineDisconnectMode );

	}

	DereferenceCall( pCall );

	TRACE( TL_N, TM_Fsm, ("-FsmSendPADRTimeout") );
}

VOID
FsmOfferingTimeout(
    IN TIMERQITEM* pTqi,
    IN VOID* pContext,
    IN TIMERQEVENT event 
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

	This function is the timeout handler for a received PADI packet.

	The call is in LINECALLSTATE_OFFERING according to TAPI, and we are
	waiting for an OID_TAPI_ACCEPT on the call.

	If the timeout period expires before a TAPI request is received,
	this function will be called with TE_Expire. In this case we check for 
	a few conditions, and schedule another timeout event if necesarry.
	
	If it was cancelled - because a TAPI request was received - or timer queue 
	is terminating then	it will be called with TE_Cancel and TE_Terminate codes
	respectively. In this case, we do not do anything, just remove the reference
	and return.
	
Parameters:

	pTqi _ A pointer to our timer queue item information structure.

	pContext _ A pointer to a our call information structure.

	event _ Indicates the type of event: TE_Expire, TE_Cancel or TE_Terminate.
	
Return Values:

	None
	
---------------------------------------------------------------------------*/    
{
	CALL* pCall = (CALL*) pContext;
	
	BOOLEAN fDropCall = FALSE;

	TRACE( TL_N, TM_Fsm, ("+FsmOfferingTimeout") );
	
	switch ( event )
	{

		case TE_Expire:

			//
			// Timeout period expired, take necesarry actions
			//
			{
				TRACE( TL_N, TM_Fsm, ("FsmOfferingTimeout: Timer expired") );
				
				NdisAcquireSpinLock( &pCall->lockCall );

				if ( pCall->stateCall != CL_stateOffering )
				{
					//
					// State has changed, no need further processing of this event
					//
					TRACE( TL_A, TM_Fsm, ("FsmOfferingTimeout: State already changed") );
					
					NdisReleaseSpinLock( &pCall->lockCall );

					break;
					
				}

				//
				// Check if we have reached the max number of time outs
				//
				if ( pCall->nNumTimeouts == pCall->pLine->pAdapter->nMaxTimeouts )
				{
					//
					// We did not receive any answers, drop the call
					//
					TRACE( TL_N, TM_Fsm, ("FsmOfferingTimeout: Max number of timeouts reached") );
					
					NdisReleaseSpinLock( &pCall->lockCall );
					
					fDropCall = TRUE;

					break;
				}

				//
				// Schedule another timeout event
				//
				TimerQInitializeItem( &pCall->timerTimeout );

				TimerQScheduleItem( &gl_TimerQ,
									&pCall->timerTimeout,
									pCall->pLine->pAdapter->ulRecvTimeout,
									FsmOfferingTimeout,
									(PVOID) pCall );

				//
				// Reference call for the new timeout handler
				//
				ReferenceCall( pCall, FALSE );

				//
				// Increment the timeout counter
				//
				pCall->nNumTimeouts++;

				NdisReleaseSpinLock( &pCall->lockCall );

			}

			break;

		case TE_Cancel:
		case TE_Terminate:

			{
				//
				// Reset the timeout counter and reference will be removed below
				//
				TRACE( TL_N, TM_Fsm, ("FsmOfferingTimeout: Timer cancelled or terminated") );

				NdisAcquireSpinLock( &pCall->lockCall );
	
				pCall->nNumTimeouts = 0;
	
				NdisReleaseSpinLock( &pCall->lockCall );

			}
			
			break;
	}

	if ( fDropCall )
	{
		NDIS_TAPI_DROP DummyRequest;

		TRACE( TL_N, TM_Fsm, ("FsmOfferingTimeout: Dropping call") );
				
		DummyRequest.hdCall = pCall->hdCall;
						
		//
		// Drop will take care of unbinding and cancelling the timer
		//
		TpDropCall( pCall->pLine->pAdapter, &DummyRequest, 0 );

	}

	DereferenceCall( pCall );

	TRACE( TL_N, TM_Fsm, ("-FsmOfferingTimeout") );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ndis\raspppoe\miniport.h ===
#ifndef _MINIPORT_H_
#define _MINIPORT_H_

#define MP_NDIS_MajorVersion    4
#define MP_NDIS_MinorVersion    0

typedef struct _LINE* PLINE;
typedef struct _CALL* PCALL;

/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:
    
   These macros will be called by MpWanSend() and PrSendComplete() 
   functions when a PPPOE_PACKET with references to a packet owned by NDIS is
   created and freed, respectively.
   
---------------------------------------------------------------------------*/   
#define MpPacketOwnedByNdiswanReceived( pM ) \
        NdisInterlockedIncrement( &(pM)->NumPacketsOwnedByNdiswan )

#define MpPacketOwnedByNdiswanReturned( pM ) \
        NdisInterlockedDecrement( &(pM)->NumPacketsOwnedByNdiswan )


typedef struct 
_ADAPTER
{
    //
    // Tag for the adapter control block (used for debugging).
    //
    ULONG tagAdapter;

    //
    // Keeps the number of references on this adapter.
    // References are added and deleted for the following operations:
    //
    // (a) A reference is added when the adapter is initialized and removed when 
    //     it is halted.
    //
    // (b) A reference is added when tapi provider is open, and removed when it is shutdown.
    //
    LONG lRef;

    //
    // Spin lock to synchronize access to shared members.
    //
    NDIS_SPIN_LOCK lockAdapter;

    //
    // This event will be triggered if MPBF_MiniportHaltPending is set and ref count drops to 0.
    //
    NDIS_EVENT eventAdapterHalted;

    //
    // These are the various bit flags to indicate other state information for the adapter:
    // 
    // (a) MPBF_MiniportIdle: Indicates that the miniport is in idle state. 
    //
    // (b) MPBF_MiniportInitialized: Indicates that the miniport is initialized.
    //                               The following pending flags can be set additionally.
    //                               MPBF_MiniportHaltPending
    //
    // (c) MPBF_MiniportHaltPending: Indicates that a miniport halt operation is pending
    //                               on the adappter.
    //
    // (d) MPBF_MiniportHalted: Indicates that miniport has halted completely.
    //                          No other flags can be set at this time.
    //
    ULONG ulMpFlags;
        #define MPBF_MiniportIdle                   0x00000000
        #define MPBF_MiniportInitialized            0x00000001
        #define MPBF_MiniportHaltPending            0x00000002
        #define MPBF_MiniportHalted                 0x00000004
    
    //
    // Handle passed to us in MiniportInitialize(). 
    // We should keep it around and pass it back to NDISWAN
    // in some functions.
    //
    NDIS_HANDLE MiniportAdapterHandle;

    //
    // Number of packets owned by NDISWAN, passed to us and will be returned
    // to Ndiswan
    //
    LONG NumPacketsOwnedByNdiswan;

    //
    // This is the built-in Tapi Provider context.
    // It keeps the tables for lines and calls.
    //
    struct
    {
        //
        // Keeps references on the tapi provider
        // References are added and deleted for the following operations:
        //
        // (a) A reference is added when TapiProvider is initialized and removed when 
        //     it is shutdown.
        //
        // (b) A reference is added when a line open, and removed when line is closed.
        //
        LONG lRef;
    
        //
        // Tapi Provider context flags.
        //
        // (a) TPBF_TapiProvIdle: Indicates that the line is in idle state.
        //
        // (b) TPBF_TapiProvInitialized: Indicates that TAPI provider is initialized.
        //
        // (c) TPBF_TapiProvShutdownPending: Indicates that a TAPI provider shutdown operation
        //                                   is pending.
        //
        // (d) TPBF_TapiProvShutdown: Indicates that TAPI provider is shutdown.
        //
        // (e) LNBF_NotifyNDIS: This flag indicates that an asynchronous completion of a Tapi Provider 
        //                      shutdown request must be communicated to NDIS using NdisMSetInformationComplete().
        //
        ULONG ulTpFlags;
            #define TPBF_TapiProvIdle                   0x00000000
            #define TPBF_TapiProvInitialized            0x00000001
            #define TPBF_TapiProvShutdownPending        0x00000002
            #define TPBF_TapiProvShutdown               0x00000004
            #define TPBF_NotifyNDIS                     0x00000008
    
        //
        // This is supplied by Tapi. 
        // It is the base index for enumeration of line devices on this tapi provider.
        //
        ULONG ulDeviceIDBase;

        //
        // This is the table that holds pointers to active line contexts.
        // (pLine->hdLine is holds the index to this table)
        //
        PLINE* LineTable;
    
        //
        // Current active number of lines
        //
        UINT nActiveLines;

        //
        // This table holds the handles to calls.
        // It's size is pAdapter->nMaxLines * pAdapter->nCallsPerLine.
        // 
        HANDLE_TABLE hCallTable;

    } TapiProv;

    /*++++++++++++++++++++++++++++++++++++++++++++++++++++++
    
        typedef struct _NDIS_WAN_INFO {
            ULONG                  MaxFrameSize; 
            ULONG                  MaxTransmit; 
            ULONG                  HeaderPadding; 
            ULONG                  TailPadding; 
            ULONG                  Endpoints; 
            UINT                   MemoryFlags; 
            NDIS_PHYSICAL_ADDRESS  HighestAcceptableAddress; 
            ULONG                  FramingBits; 
            ULONG                  DesiredACCM; 
        } NDIS_WAN_INFO, *PNDIS_WAN_INFO; 

    -------------------------------------------------------*/
    NDIS_WAN_INFO NdisWanInfo;
    
    /////////////////////////////////////////////////////////
    //
    // Config values read from registry
    //
    /////////////////////////////////////////////////////////

    //
    // Indicates the role of the machine:
    //  - fClientRole is TRUE: Machine acts as a client. 
    //                         Only outgoing calls are connected, and no calls are received.
    //
    //  - fClientRole is FALSE: Machine acts as a server. 
    //                          Only incoming calls are accepted, and no outgoing calls are allowed.
    //
    BOOLEAN fClientRole;

    //
    // This is the string that holds the Service-name this server offers.
    // It must be an UTF-8 string per PPPoE RFC.
    //
    // It is only used for incoming calls.
    //
    #define MAX_COMPUTERNAME_LENGTH             200
    #define SERVICE_NAME_EXTENSION              " PPPoE"
    #define MAX_SERVICE_NAME_LENGTH             256

    CHAR ServiceName[MAX_SERVICE_NAME_LENGTH];

    //
    // Indicates the length of the Service name string 
    //
    USHORT nServiceNameLength;
    
    //
    // This is the string that holds the AC-name for this server.
    // It must be an UTF-8 string per PPPoE RFC.
    //
    // It is only used for incoming calls.
    //
    #define MAX_AC_NAME_LENGTH              256

    CHAR ACName[MAX_AC_NAME_LENGTH];

    //
    // Indicates the length of the AC name string 
    //
    USHORT nACNameLength;

    //
    // Max number of simultaneous calls that can be established between the same
    // client and server
    //
    UINT nClientQuota;

    //
    // Indicates the number of line contexts that will be created.
    //
    UINT nMaxLines;

    //
    // Indicates the number of calls that each individual line will support.
    //
    UINT nCallsPerLine;

    //
    // Indicates the maximum number of timeouts for the PPPoE FSM.
    // When the current number of timeouts , reach this number call will be dropped.
    //
    UINT nMaxTimeouts;

    //
    // This is the timeout period for client side operations (in ms)
    //
    ULONG ulSendTimeout;

    //
    // This is the timeout period for server side operations (in ms)
    //
    ULONG ulRecvTimeout;

    //
    // This shows the maximum number of packets that NDISWAN can pass to us simultaneously.
    // This does not make any sense for us as we do not queue the packets, but send them to
    // peer directly when we receive them from NDISWAN.
    //
    UINT nMaxSendPackets;

    //
    // This is related to the problem where the server does not support the empty service-name.
    // In this case, there is no way for clients to discover the services supported by the server,
    // since the server sends back a PADO packet without the empty service-name attribute, and we drop
    // it (per RFC). So if this value is TRUE, then we break the RFC and do the following:
    // If client asks for the empty service name, then we do not ignore the PADO that does not contain
    // the empty service-name. Instead we try to find the empty service-name field, and request it if its 
    // available. If not, then we request the first service available in the PADO.
    //
    BOOLEAN fAcceptAnyService;
    
}
ADAPTER;

//
// This is our call line context.
// All information pertinent to a line is kept in this context.
//
typedef struct 
_LINE
{
    
    //
    // Tag for the line control block (used for debugging).
    //
    ULONG tagLine;

    //
    // Keeps reference count on the line control block.
    // References are added and deleted for the following operations:
    //
    // (a) A reference is added when a line is opened and removed when 
    //     line is closed.
    //
    // (b) A reference is added when a call context is created on the line,
    //     and removed when call context is cleaned up.
    //
    LONG lRef;

    //
    // Spin lock to synchronize access to shared members
    //
    NDIS_SPIN_LOCK lockLine;

    //
    // These are the various bit flags to indicate other state information for the line:
    //
    // (a) LNBF_LineIdle: Indicates that the line is in idle state. 
    //
    // (b) LNBF_LineOpen: Indicates that the line is in open state. Whan this flag is set,
    //                    only the following pending flags may be set additionally:
    //                    LNBF_LineClosePending
    //
    // (c) LNBF_LineClosePending: This pending flag can be only set only if LNBF_LineOpen is set, 
    //                            and indicates that there is a pending line close operation.
    //
    // (d) LNBF_LineClosed: Indicates that the line is in closed state. When this flag is set,
    //                      no other pending flags can be set.
    //
    // (e) LNBF_NotifyNDIS: This flag indicates that an asynchronous completion of a close line request
    //                      must be communicated to NDIS using NdisMSetInformationComplete().
    //
    // (f) LNBF_MakeOutgoingCalls: This flag is set if line is allowed to make outgoing calls.
    //                             It will be set in TpMakeCall() if machine is acting as a client
    //                             (pAdapter->fClientRole is TRUE).
    //
    // (g) LNBF_AcceptIncomingCalls: This flag is set if TAPI is able to take calls over this line.
    //                               It will be set in TpSetDefaultMediaDetection() if machine is acting as 
    //                               a server (pAdapter->fClientRole is FALSE).
    //
    ULONG ulLnFlags;
        #define LNBF_LineIdle                       0x00000000
        #define LNBF_LineOpen                       0x00000001
        #define LNBF_LineClosed                     0x00000002
        #define LNBF_LineClosePending               0x00000004
        #define LNBF_NotifyNDIS                     0x00000008
        #define LNBF_MakeOutgoingCalls              0x00000010
        #define LNBF_AcceptIncomingCalls            0x00000020

    //
    // Back pointer to owning adapter context
    //
    ADAPTER* pAdapter;

    //
    // Indicates the maximum number of calls that is permitted on this line.
    // Copy of pAdapter->nCallsPerLine.
    //
    UINT nMaxCalls;

    //
    // Indicates the number of current call contexts attached to the line.
    // 
    // It will be incremented when a call context is created and attached to a line,
    // and decremented when such a call context is destroyed.
    //
    UINT nActiveCalls;

    //
    // Link list of calls
    //
    LIST_ENTRY linkCalls;

    //
    // This is the handle assigned by TAPI to the line.
    // We obtain it in TpOpenLine() from TAPI.
    //
    HTAPI_LINE htLine;

    //
    // This is the handle assigned by us to the line.
    // We pass it to TAPI TpOpenLine().
    //
    // It is basically the index of the entry that points 
    // to the line context in pAdapter->TapiProv.LineTable
    //
    HDRV_LINE hdLine;

}
LINE;

typedef enum
_CALLSTATES
{
    //
    // Initial state
    //
    CL_stateIdle = 0,

    //
    // CLIENT states
    //
    CL_stateSendPadi,       // Prepare a PADI packet and broadcast it
    CL_stateWaitPado,       // Wait for a PADO packet; timeout and broadcast PADI again if necesarry
    CL_stateSendPadr,       // PADO packet received and processed, prepare a PADR packet and send it to the peer
    CL_stateWaitPads,       // Wait for a PADS packet; timeout and resend the PADR packet if necesarry

    //
    // SERVER states
    //
    CL_stateRecvdPadr,      // Received a PADR packet from the peer, and processing it.
                            // Once it is processed TAPI will be informed about the call.
                            //
                            
    CL_stateOffering,       // TAPI is informaed about the call and call is waiting for an OID_TAPI_ANSWER
                            // from TAPI. If we do not get a an OID_TAPI_ANSWER in a timely manner, we time out
                            // and drop the call
                            //
                            
    CL_stateSendPads,       // Call received a OID_TAPI_ANSWER from TAPI, so prepare a PADS packet and send it to
                            // the peer.
                            //
    //
    // CLIENT or SERVER states
    //
    CL_stateSessionUp,      // Either sent or received a PADS packet and session is established
    CL_stateDisconnected    // Call is disconnected. Call may proceed to this state from any of the 
                            // above states, it does not need to be connected first.
}
CALLSTATES;

//
// These identify the types of scheduled works:
//
//  - CWT_workFsmMakeCall: This item is scheduled from TpMakeCall() to start making a call.
//
typedef enum
_CALL_WORKTYPE
{
    CWT_workUnknown = 0,
    CWT_workFsmMakeCall
}
CALL_WORKTYPE;

//
// This is our call call context.
// All information pertinent to a call is kept in this context.
//
typedef struct
_CALL
{
    //
    // Points to the next and previous call contexts in a double linked list
    //
    LIST_ENTRY linkCalls;
    
    //
    // Tag for the call control block (used for debugging).
    //
    ULONG tagCall;

    //
    // Keeps reference count on the call control block.
    // References are added and deleted for the following operations:
    //
    // (a) A reference is added for running the initial FSM function for the call.
    //
    // (b) A reference is added for dropping the call, and removed when drop call
    //     is called.
    // 
    // (c) A reference is added for closing the call, and removed when close call
    //     is called.
    //
    // (d) A reference is added when timers are set, and removed if timer expires,
    //     is cancelled or terminated.
    //
    // (e) When a packet is received to be dispatched, adapter context is locked,
    //     call context is found and referenced, adapter is unlocked and FSM function 
    //     is called.
    //
    // (f) For any other operation not listed here, programmer should do as in (e).
    //
    LONG lRef;

    //
    // Spin lock to synchronize access to shared members
    //
    NDIS_SPIN_LOCK lockCall;

    //
    // Indicates the calls PPPoE state
    //
    CALLSTATES stateCall;

    //
    // Indicates that the call is initiated from another machine, and this machine is acting as 
    // a server.
    //
    BOOLEAN fIncoming;

    //
    // These are the various bit flags to indicate other state information for the call:
    //
    // (a) CLBF_CallIdle: This is the initial state of the call.
    //
    // (b) CLBF_CallOpen: This flag is indicates that the call context is opened.
    //                    When a call context is created it is always created with CLBF_CallOpen
    //                    and CLBF_CallConnectPending flags set, then if call connects succesfully,
    //                    CLBF_CallConnectPending flag is reset, and only CLBF_CallOpen is left.
    //
    //                    The following pending flags might be set additionally:
    //                    CLBF_CallConnectPending : If this flag is set the call is still connecting.
    //                                              Otherwise it means that the call is connected, and 
    //                                              can make data over the link.
    //
    // (c) CLBF_CallConnectPending: This flag may be set only if CLBF_CallOpen is set. It means that
    //                              the call is still in connect pending state. You can look at pCall->stateCall
    //                              variable to retrieve the actual state of the call.
    //
    // (d) CLBF_CallDropped: This flag is set when call is dropped (disconnected).
    //                       The following pending flags might be set additionally:
    //                       CLBF_CallClosePending
    //
    // (e) CLBF_CallClosePending: This flag is set after the call is dropped and context is being cleared to 
    //                            be freed.
    //
    // (f) CLBF_CallClosed: This flag is set when call is closed (resources ready to be freed).
    //                      No pending flags might be set when this bit is set.
    //
    //
    //
    // (g) CLBF_NotifyNDIS: This flag indicates that an asynchronous completion of a close call request
    //                      must be communicated to NDIS using NdisMSetInformationComplete().
    //
    // (h) CLBF_CallReceivePacketHandlerScheduled: This flag indicates that the MpIndicateReceivedPackets()
    //                                             is scheduled to indicate packets in the receive queue.
    //
    ULONG ulClFlags;
        #define CLBF_CallIdle                           0x00000000
        #define CLBF_CallOpen                           0x00000001
        #define CLBF_CallConnectPending                 0x00000002
        #define CLBF_CallDropped                        0x00000004
        #define CLBF_CallClosePending                   0x00000008
        #define CLBF_CallClosed                         0x00000010
        #define CLBF_NotifyNDIS                         0x00000020
        #define CLBF_CallReceivePacketHandlerScheduled  0x00000040

    //
    // Back pointer to the owning line context
    //
    LINE* pLine;

    //
    // This is the handle assigned by TAPI to the call.
    // We obtain it in TpMakeCall() or TpAnswerCall() from TAPI.
    //
    HTAPI_CALL htCall;

    //
    // This is the handle assigned by us to the call.
    // We obtain this when we create the call context and pass it back to TAPI
    // either in return from TpMakeCall() or TpReceiveCall().
    //
    // This handle forms of 2 USHORT values appended.
    // The higher 16 bits represent the index to the pAdapter->TapiProv.hCallTable, and
    // the lower 16 bits is just a unique number generated everytime a call handle is created.
    //
    // This ensures the uniqueness of handles to avoid pitfalls that could result due to some weird
    // timing conditions.
    //
    HDRV_CALL hdCall;

    //
    // This gives the link speed. It is obtained from the underlying binding context when 
    // call is attached to the binding.
    //
    ULONG ulSpeed;

    //
    // This is the max frame size for the underlying binding context.
    // Passed to the call context in PrAddCallToBinding().
    //
    ULONG ulMaxFrameSize;

    //
    // This keeps TAPI's states. Its values are from LINECALLSTATE_ constants in SDK.
    //
    // States supported by us are:
    //  - LINECALLSTATE_IDLE
    //  - LINECALLSTATE_OFFERING
    //  - LINECALLSTATE_DIALING
    //  - LINECALLSTATE_PROCEEDING
    //  - LINECALLSTATE_CONNECTED
    //  - LINECALLSTATE_DISCONNECTED
    //
    ULONG ulTapiCallState;
        #define TAPI_LINECALLSTATES_SUPPORTED   ( LINECALLSTATE_IDLE        | \
                                                  LINECALLSTATE_OFFERING    | \
                                                  LINECALLSTATE_DIALING     | \
                                                  LINECALLSTATE_PROCEEDING  | \
                                                  LINECALLSTATE_CONNECTED   | \
                                                  LINECALLSTATE_DISCONNECTED ) 

    /*++++++++++++++++++++++++++++++++++++++++++++++++++++++

        Link info needed by NDISWAN
    
        typedef struct _NDIS_WAN_GET_LINK_INFO { 
            IN  NDIS_HANDLE     NdisLinkHandle; 
            OUT ULONG           MaxSendFrameSize; 
            OUT ULONG           MaxRecvFrameSize; 
            OUT ULONG           HeaderPadding; 
            OUT ULONG           TailPadding; 
            OUT ULONG           SendFramingBits; 
            OUT ULONG           RecvFramingBits; 
            OUT ULONG           SendCompressionBits; 
            OUT ULONG           RecvCompressionBits; 
            OUT ULONG           SendACCM; 
            OUT ULONG           RecvACCM; 
        } NDIS_WAN_GET_LINK_INFO, *PNDIS_WAN_GET_LINK_INFO; 

        typedef struct _NDIS_WAN_SET_LINK_INFO { 
            IN NDIS_HANDLE     NdisLinkHandle; 
            IN ULONG           MaxSendFrameSize; 
            IN ULONG           MaxRecvFrameSize; 
               ULONG           HeaderPadding; 
               ULONG           TailPadding; 
            IN ULONG           SendFramingBits; 
            IN ULONG           RecvFramingBits; 
            IN ULONG           SendCompressionBits; 
            IN ULONG           RecvCompressionBits; 
            IN ULONG           SendACCM; 
            IN ULONG           RecvACCM; 
        } NDIS_WAN_SET_LINK_INFO, *PNDIS_WAN_SET_LINK_INFO; 
 
    -------------------------------------------------------*/
    NDIS_WAN_GET_LINK_INFO NdisWanLinkInfo; 
    
    //
    // This is the string that holds the service-name for the call.
    // It must be an UTF-8 string per PPPoE RFC.
    //
    // We either obtain it in TpMakeCall() as the phone-number to dial, or
    // receive it from the peer for an incoming call.
    //
    CHAR ServiceName[MAX_SERVICE_NAME_LENGTH];

    //
    // Indicates the length of the service name string 
    //
    USHORT nServiceNameLength;

    //
    // This is the string that holds the AC-name for this call.
    // It must be an UTF-8 string per PPPoE RFC.
    //
    // For an outgoing call, we obtain it from the adapter's context,
    // for an incoming call we get it from PADO packet server sends.
    //
    CHAR ACName[MAX_AC_NAME_LENGTH];

    //
    // Indicates the length of the AC name string 
    //
    USHORT nACNameLength;

    //
    // Indicates if ACName was specified by the caller or not
    //
    BOOLEAN fACNameSpecified;

    //
    // Peer's MAC address, obtained either when we receive or send a PADO packet
    //
    CHAR DestAddr[6];

    //
    // Our MAC address, obtained from binding in PrAddCallToBinding()
    //
    CHAR SrcAddr[6];

    //
    // Indicates the session id for the call.
    //
    // As per PPPoE RFC, a call is identified uniquely by the peer's MAC addresses plus a session id.
    // In this implementation, we do not really care about the peer's MAC addresses, so we always
    // make a unique session id. This is partly why we do not support both client and server functionality
    // on the same box at the same time.
    //
    // For an incoming call, session id is selected as the index into pAdapter->TapiProv.hCallTable, and
    // for an outgoing call it is assigned by the peer so we just traverse active calls to identify the
    // correct call (which is very inefficient by the way, but this was a design decision that was discussed
    // and approved by the PMs - the main scenario is that most people will not have many outgoing calls -
    // anyway ).
    //
    USHORT usSessionId;

    //
    // Pointer to the binding context that the call is running over
    //
    BINDING* pBinding;

    //
    // Handle assigned to this peer-to-peer link by NDISWAN.
    // 
    // This value is passed to us in NDIS_MAC_LINE_UP. 
    // We indicate anything to NDISWAN using this handle.
    // 
    NDIS_HANDLE NdisLinkContext;

    //
    // This points to the last PPPoE control packet sent to the peer.
    //
    // This is necesarry for resending the packet on a timeout condition 
    // when we do not get a reply.
    //
    PPPOE_PACKET* pSendPacket;

    //
    // This is a special queue added to fix bug 172298 in Windows Bugs database.
    // The problem is that the payload packets received right after a PADS but before contexts are exchanged
    // with NDISWAN are dropped, and this causes a disturbing user experience.
    //
    // So I decided to change the packet receive mechanism. Instead I will queue up the packets and
    // use a timer to indicate them to NDISWAN. I prefered timers instead of scheduling a work item because
    // timers are more reliable than work items in terms of when to run.
    //
    LIST_ENTRY linkReceivedPackets;

        //
        // The maximum length of the queue
        //
        #define MAX_RECEIVED_PACKETS    100

    //
    // Number of packets in the received packet queue.
    // The value can not exceed MAX_RECEIVED_PACKETS
    //
    ULONG nReceivedPackets;
    
    //
    // This will be used to indicate the packets in the receive queue to NDISWAN
    //
    TIMERQITEM timerReceivedPackets;

        //
        // The maximum number of packets to be indicated from the queue in one function call.
        // If there are more items in the queue, we should schedule another timer.
        //
        #define MAX_INDICATE_RECEIVED_PACKETS   100
        #define RECEIVED_PACKETS_TIMEOUT        1

    //
    // This is the timer queue item we use for this call.
    //
    TIMERQITEM timerTimeout;

    //
    // Indicates the number of timeouts occured.
    // Max number of time outs is kept in pAdapter->nMaxTimeouts and is read from registry.
    //
    UINT nNumTimeouts;

}
CALL;

////////////////////////////////////
//
// Local macros
//
////////////////////////////////////

#define ALLOC_ADAPTER( ppA ) NdisAllocateMemoryWithTag( (PVOID*) ppA, sizeof( ADAPTER ), MTAG_ADAPTER )

#define FREE_ADAPTER( pA )  NdisFreeMemory( (PVOID) pA, sizeof( ADAPTER ), 0 );

#define VALIDATE_ADAPTER( pA ) ( (pA) && (pA->tagAdapter == MTAG_ADAPTER) )

VOID
CreateUniqueValue( 
    IN HDRV_CALL hdCall,
    OUT CHAR* pUniqueValue,
    OUT USHORT* pSize
    );

VOID 
ReferenceAdapter(
    IN ADAPTER* pAdapter,
    IN BOOLEAN fAcquireLock
    );

VOID DereferenceAdapter(
    IN ADAPTER* pAdapter
    );

VOID 
MpNotifyBindingRemoval( 
    BINDING* pBinding 
    );

VOID
MpRecvPacket(
    IN BINDING* pBinding,
    IN PPPOE_PACKET* pPacket
    );  

VOID
MpIndicateReceivedPackets(
    IN TIMERQITEM* pTqi,
    IN VOID* pContext,
    IN TIMERQEVENT event
    );

VOID 
MpScheduleIndicateReceivedPacketsHandler(
    CALL* pCall
    );

NDIS_STATUS
MpWanGetInfo(
    IN ADAPTER* pAdapter,
    IN PNDIS_WAN_INFO pWanInfo
    );
    
NDIS_STATUS
MpWanGetLinkInfo(
    IN ADAPTER* pAdapter,
    IN PNDIS_WAN_GET_LINK_INFO pWanLinkInfo
    );

NDIS_STATUS
MpWanSetLinkInfo(
    IN ADAPTER* pAdapter,
    IN PNDIS_WAN_SET_LINK_INFO pWanLinkInfo
    );
    
//////////////////////////////////////////////////////////////
//
// Interface prototypes: Functions exposed from this module
//
//////////////////////////////////////////////////////////////
NDIS_STATUS
MpRegisterMiniport(
    IN PDRIVER_OBJECT pDriverObject,
    IN PUNICODE_STRING pRegistryPath,
    OUT NDIS_HANDLE* pNdisWrapperHandle
    );

// These basics are not in the DDK headers for some reason.
//
#define min( a, b ) (((a) < (b)) ? (a) : (b))
#define max( a, b ) (((a) > (b)) ? (a) : (b))

#define InsertBefore( pNewL, pL )    \
{                                    \
    (pNewL)->Flink = (pL);           \
    (pNewL)->Blink = (pL)->Blink;    \
    (pNewL)->Flink->Blink = (pNewL); \
    (pNewL)->Blink->Flink = (pNewL); \
}

#define InsertAfter( pNewL, pL )     \
{                                    \
    (pNewL)->Flink = (pL)->Flink;    \
    (pNewL)->Blink = (pL);           \
    (pNewL)->Flink->Blink = (pNewL); \
    (pNewL)->Blink->Flink = (pNewL); \
}

// Pad to the size of the given datatype.  (Borrowed from wdm.h which is not
// otherwise needed)
//
#define ALIGN_DOWN(length, type) \
    ((ULONG)(length) & ~(sizeof(type) - 1))

#define ALIGN_UP(length, type) \
    (ALIGN_DOWN(((ULONG)(length) + sizeof(type) - 1), type))

// Place in a TRACE argument list to correspond with a format of "%d" to print
// a percentage of two integers, or an average of two integers, or those
// values rounded.
//
#define PCTTRACE( n, d ) ((d) ? (((n) * 100) / (d)) : 0)
#define AVGTRACE( t, c ) ((c) ? ((t) / (c)) : 0)
#define PCTRNDTRACE( n, d ) ((d) ? (((((n) * 1000) / (d)) + 5) / 10) : 0)
#define AVGRNDTRACE( t, c ) ((c) ? (((((t) * 10) / (c)) + 5) / 10) : 0)

// All memory allocations and frees are done with these ALLOC_*/FREE_*
// macros/inlines to allow memory management scheme changes without global
// editing.  For example, might choose to lump several lookaside lists of
// nearly equal sized items into a single list for efficiency.
//
// NdisFreeMemory requires the length of the allocation as an argument.  NT
// currently doesn't use this for non-paged memory, but according to JameelH,
// Windows95 does.  These inlines stash the length at the beginning of the
// allocation, providing the traditional malloc/free interface.  The
// stash-area is a ULONGLONG so that all allocated blocks remain ULONGLONG
// aligned as they would be otherwise, preventing problems on Alphas.
//
__inline
VOID*
ALLOC_NONPAGED(
    IN ULONG ulBufLength,
    IN ULONG ulTag )
{
    CHAR* pBuf;

    NdisAllocateMemoryWithTag(
        &pBuf, (UINT )(ulBufLength + MEMORY_ALLOCATION_ALIGNMENT), ulTag );
    if (!pBuf)
    {
        return NULL;
    }

    ((ULONG* )pBuf)[ 0 ] = ulBufLength;
    ((ULONG* )pBuf)[ 1 ] = 0xC0BBC0DE;
    return pBuf + MEMORY_ALLOCATION_ALIGNMENT;
}

__inline
VOID
FREE_NONPAGED(
    IN VOID* pBuf )
{
    ULONG ulBufLen;

    ulBufLen = *((ULONG* )(((CHAR* )pBuf) - MEMORY_ALLOCATION_ALIGNMENT));
    NdisFreeMemory(
        ((CHAR* )pBuf) - MEMORY_ALLOCATION_ALIGNMENT,
        (UINT )(ulBufLen + MEMORY_ALLOCATION_ALIGNMENT),
        0 );
}

#define ALLOC_NDIS_WORK_ITEM( pWorkItemLookasideList ) \
    NdisAllocateFromNPagedLookasideList( pWorkItemLookasideList )
#define FREE_NDIS_WORK_ITEM( pA, pNwi ) \
    NdisFreeToNPagedLookasideList( pWorkItemLookasideList, (pNwi) )



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ndis\raspppoe\ppool.c ===
// Copyright (c) 1997, Microsoft Corporation, all rights reserved
//
// ppool.c
// RAS L2TP WAN mini-port/call-manager driver
// Packet pool management routines
//
// 01/07/97 Steve Cobb, adapted from Gurdeep's WANARP code.

#include <ntddk.h>
#include <ntddndis.h>
#include <ndis.h>
#include <ndiswan.h>
#include <ndistapi.h>
#include <ntverp.h>

#include "debug.h"
#include "timer.h"
#include "bpool.h"
#include "ppool.h"
#include "util.h"
#include "packet.h"
#include "protocol.h"
#include "miniport.h"
#include "tapi.h"

// Debug count of detected double-frees that should not be happening.
//
ULONG g_ulDoublePacketFrees = 0;


//-----------------------------------------------------------------------------
// Local prototypes (alphabetically)
//-----------------------------------------------------------------------------

PACKETHEAD*
AddPacketBlockToPool(
    IN PACKETPOOL* pPool );

VOID
FreeUnusedPacketPoolBlocks(
    IN PACKETPOOL* pPool );


//-----------------------------------------------------------------------------
// Interface routines
//-----------------------------------------------------------------------------

VOID
InitPacketPool(
    OUT PACKETPOOL* pPool,
    IN ULONG ulProtocolReservedLength,
    IN ULONG ulMaxPackets,
    IN ULONG ulPacketsPerBlock,
    IN ULONG ulFreesPerCollection,
    IN ULONG ulTag )

    // Initialize caller's packet pool control block 'pPool'.
    // 'UlProtocolReservedLength' is the size in bytes of the
    // 'ProtocolReserved' array of each individual packet.  'UlMaxPackets' is
    // the maximum number of packets allowed in the entire pool, or 0 for
    // unlimited.  'UlPacketsPerBlock' is the number of packets to include in
    // each block of packets.  'UlFreesPerCollection' is the number of
    // FreePacketToPool calls until the next garbage collect scan, or 0 for
    // default.  'UlTag' is the memory identification tag to use when
    // allocating blocks.
    //
    // IMPORTANT: Caller's 'pPool' packet must be protected from multiple
    //            access during this call.
    //
{
    pPool->ulProtocolReservedLength = ulProtocolReservedLength;
    pPool->ulPacketsPerBlock = ulPacketsPerBlock;
    pPool->ulMaxPackets = ulMaxPackets;
    pPool->ulFreesSinceCollection = 0;
    pPool->ulTag = ulTag;

    if (ulFreesPerCollection)
    {
        pPool->ulFreesPerCollection = ulFreesPerCollection;
    }
    else
    {
        // Calculate default garbage collection trigger.  Don't want to be too
        // aggressive here.
        //
        pPool->ulFreesPerCollection = 200 * pPool->ulPacketsPerBlock;
    }

    TRACE( TL_N, TM_Pool, ( "InitPp tag=$%08x pr=%d cnt=%d",
        pPool->ulTag,
        pPool->ulProtocolReservedLength,
        pPool->ulPacketsPerBlock ) );

    InitializeListHead( &pPool->listBlocks );
    InitializeListHead( &pPool->listFreePackets );
    NdisAllocateSpinLock( &pPool->lock );
}


BOOLEAN
FreePacketPool(
    IN PACKETPOOL* pPool )

    // Free up all resources allocated in packet pool 'pPool'.  This is the
    // inverse of InitPacketPool.
    //
    // Returns true if successful, false if any of the pool could not be freed
    // due to outstanding packets.
    //
{
    BOOLEAN fSuccess;

    TRACE( TL_N, TM_Pool, ( "FreePp" ) );

    NdisAcquireSpinLock( &pPool->lock );
    {
        FreeUnusedPacketPoolBlocks( pPool );
        fSuccess = (pPool->ulCurPackets == 0);
    }
    NdisReleaseSpinLock( &pPool->lock );

    return fSuccess;
}


NDIS_PACKET*
GetPacketFromPool(
    IN PACKETPOOL* pPool,
    OUT PACKETHEAD** ppHead
    )

    // Returns the address of the NDIS_PACKET descriptor allocated from the
    // pool 'pPool'.  The pool is expanded, if necessary, but caller should
    // still check for NULL return since the pool may have been at maximum
    // size.
    //
{
    LIST_ENTRY* pLink;
    PACKETHEAD* pHead;
    NDIS_PACKET* pPacket;

    NdisAcquireSpinLock( &pPool->lock );
    {
        if (IsListEmpty( &pPool->listFreePackets ))
        {
            pLink = NULL;
        }
        else
        {
            pLink = RemoveHeadList( &pPool->listFreePackets );
            InitializeListHead( pLink );
            pHead = CONTAINING_RECORD( pLink, PACKETHEAD, linkFreePackets );
            --pHead->pBlock->ulFreePackets;
        }
    }
    NdisReleaseSpinLock( &pPool->lock );

    if (!pLink)
    {
        // The free list was empty.  Try to expand the pool.
        //
        pHead = AddPacketBlockToPool( pPool );
        if (!pHead)
        {
            TRACE( TL_A, TM_Pool, ( "GetPfP failed?" ) );
            return NULL;
        }
    }

    TRACE( TL_N, TM_Pool,
        ( "GetPfP=$%p/h=$%p, %d free",
        pHead->pNdisPacket, pHead, pHead->pBlock->ulFreePackets ) );

	*ppHead = pHead;
	
    return pHead->pNdisPacket;
}


VOID
FreePacketToPool(
    IN PACKETPOOL* pPool,
    IN PACKETHEAD* pHead,
    IN BOOLEAN fGarbageCollection 
    )

    // Returns 'pPacket' to the pool of unused packets 'pPool'.  'PPacket'
    // must have been previously allocated with GetPacketFromPool.
    // 'FGarbageCollection' is set when the free should be considered for
    // purposes of garbage collection.  This is used by the AddPacketToPool
    // routine to avoid counting the initial "add" frees.  Normal callers
    // should set this flag.
    //
{

    DBG_if (fGarbageCollection)
    {
        TRACE( TL_N, TM_Pool,
            ( "FreePtoP($%p,h=$%p) %d free",
            pHead->pNdisPacket, pHead, pHead->pBlock->ulFreePackets ) );
    }

    NdisAcquireSpinLock( &pPool->lock );
    do
    {
        if (pHead->linkFreePackets.Flink != &pHead->linkFreePackets)
        {
            ASSERT( !"Double free?" );
            ++g_ulDoublePacketFrees;
            break;
        }

        InsertHeadList( &pPool->listFreePackets, &pHead->linkFreePackets );
        ++pHead->pBlock->ulFreePackets;

        if (fGarbageCollection)
        {
            ++pPool->ulFreesSinceCollection;

            if (pPool->ulFreesSinceCollection >= pPool->ulFreesPerCollection)
            {
                // Time to collect garbage, i.e. free any blocks in the pool
                // not in use.
                //
                FreeUnusedPacketPoolBlocks( pPool );
                pPool->ulFreesSinceCollection = 0;
            }
        }
    }
    while (FALSE);
    NdisReleaseSpinLock( &pPool->lock );
}


VOID
CollectPacketPoolGarbage(
    PACKETPOOL* pPool )

    // Force a garbage collection event on the pool 'pPool'.
    //
{
    NdisAcquireSpinLock( &pPool->lock );
    {
        FreeUnusedPacketPoolBlocks( pPool );
        pPool->ulFreesSinceCollection = 0;
    }
    NdisReleaseSpinLock( &pPool->lock );
}


//-----------------------------------------------------------------------------
// Utility routines (alphabetically)
//-----------------------------------------------------------------------------

PACKETHEAD*
AddPacketBlockToPool(
    IN PACKETPOOL* pPool )

    // Allocate a new packet block and add it to the packet pool 'pPool'.
    //
    // Returns the PACKETHEAD allocated from the pool or NULL if none.
    //
{
    NDIS_STATUS status;
    PACKETBLOCKHEAD* pNew;
    ULONG ulSize;
    ULONG ulCount;
    BOOLEAN fOk;
    PACKETHEAD* pReturn;

    TRACE( TL_A, TM_Pool, ( "AddPpBlock(%d+%d)",
        pPool->ulCurPackets, pPool->ulPacketsPerBlock ) );

    fOk = FALSE;
    pNew = NULL;

    NdisAcquireSpinLock( &pPool->lock );
    {
        do
        {
            if (pPool->ulMaxPackets
                && pPool->ulCurPackets >= pPool->ulMaxPackets)
            {
                // No can do.  The pool's already at maximum size.
                //
                TRACE( TL_A, TM_Pool, ( "Pp maxed?" ) );
                break;
            }

            // Calculate the contiguous block's size and the number of packets
            // it will hold.
            //
            ulCount = pPool->ulPacketsPerBlock;
            if (pPool->ulMaxPackets)
            {
                if (ulCount > pPool->ulMaxPackets - pPool->ulCurPackets)
                {
                    ulCount = pPool->ulMaxPackets - pPool->ulCurPackets;
                }
            }
            ulSize = sizeof(PACKETBLOCKHEAD) + (ulCount * sizeof(PACKETHEAD));

            // Allocate the contiguous memory block for the PACKETBLOCK header
            // and the individual PACKETHEADs.
            //
            pNew = ALLOC_NONPAGED( ulSize, pPool->ulTag );
            if (!pNew)
            {
                TRACE( TL_A, TM_Pool, ( "Alloc PB?") );
                break;
            }

            /* Zero only the block header portion.
            */
            NdisZeroMemory( pNew, sizeof(PACKETBLOCKHEAD) );

            // Allocate a pool of NDIS_PACKET descriptors.
            //
            NdisAllocatePacketPool(
                &status,
                &pNew->hNdisPool,
                ulCount,
                pPool->ulProtocolReservedLength );

            if (status != NDIS_STATUS_SUCCESS)
            {
                TRACE( TL_A, TM_Pool, ( "AllocPp=$%x?", status ) );
                break;
            }

            // Fill in the back pointer to the pool.
            //
            pNew->pPool = pPool;

            // Link the new block.  At this point, all the packets are
            // effectively "in use".  They are made available in the loop
            // below.
            //
            pNew->ulPackets = ulCount;
            pPool->ulCurPackets += ulCount;
            InsertHeadList( &pPool->listBlocks, &pNew->linkBlocks );

            fOk = TRUE;
        }
        while (FALSE);
    }
    NdisReleaseSpinLock( &pPool->lock );

    if (!fOk)
    {
        // Bailing, undo whatever succeeded.
        //
        if (pNew)
        {
            if (pNew->hNdisPool)
            {
                NdisFreePacketPool( pNew->hNdisPool );
            }
            FREE_NONPAGED( pNew );
        }

        return NULL;
    }

    // Initialize each individual packet header and add it to the list of free
    // packets.
    //
    {
        ULONG i;
        PACKETHEAD* pHead;

        pReturn = NULL;

        // For each PACKETHEAD of the block...
        //
        for (i = 0, pHead = (PACKETHEAD* )(pNew + 1);
             i < ulCount;
             ++i, ++pHead)
        {
            InitializeListHead( &pHead->linkFreePackets );
            pHead->pBlock = pNew;
            pHead->pNdisPacket = NULL;

            // Associate an NDIS_PACKET descriptor from the pool we
            // allocated above.
            //
            NdisAllocatePacket( &status, &pHead->pNdisPacket, pNew->hNdisPool );

            if (status != NDIS_STATUS_SUCCESS)
            {
                TRACE( TL_A, TM_Pool, ( "AllocP=$%x?", status ) );
                pHead->pNdisPacket = NULL;
                continue;
            }

            if (pReturn)
            {
                // Add the constructed packet to the list of free packets.
                // The 'FALSE' tells the garbage collection algorithm the
                // operation is an "add" rather than a "release" and should be
                // ignored.
                //
                FreePacketToPool( pPool, pHead, FALSE );
            }
            else
            {
                // The first successfully constructed packet is returned by
                // this routine.
                //
                pReturn = pHead;
            }
        }
    }

    return pReturn;
}


VOID
FreeUnusedPacketPoolBlocks(
    IN PACKETPOOL* pPool )

    // Check if any of the blocks in pool 'pPool' are not in use, and if so,
    // free them.
    //
    // IMPORTANT: Caller must hold the pool lock.
    //
    // NOTE: The MSDN doc says that no locks may be held while calling
    // NdisFreePacketXxx, but according to JameelH that is incorrect.
    //
{
    LIST_ENTRY* pLink;

    TRACE( TL_A, TM_Pool, ( "FreeUnusedPpBlocks" ) );

    // For each block in the pool...
    //
    pLink = pPool->listBlocks.Flink;
    while (pLink != &pPool->listBlocks)
    {
        LIST_ENTRY* pLinkNext;
        PACKETBLOCKHEAD* pBlock;

        pLinkNext = pLink->Flink;

        pBlock = CONTAINING_RECORD( pLink, PACKETBLOCKHEAD, linkBlocks );
        if (pBlock->ulFreePackets >= pBlock->ulPackets)
        {
            ULONG i;
            PACKETHEAD* pHead;

            TRACE( TL_A, TM_Pool, ( "FreePpBlock(%d-%d)",
                pPool->ulCurPackets, pPool->ulPacketsPerBlock ) );

            // Found a block with no packets in use.  Walk the packet block
            // removing each packet from the pool's free list and freeing any
            // associated NDIS_PACKET descriptor.
            //
            for (i = 0, pHead = (PACKETHEAD* )(pBlock + 1);
                 i < pBlock->ulPackets;
                 ++i, ++pHead)
            {
                RemoveEntryList( &pHead->linkFreePackets );
                InitializeListHead( &pHead->linkFreePackets );

                if (pHead->pNdisPacket)
                {
                    NdisFreePacket( pHead->pNdisPacket );
                }
            }

            // Remove and release the unused block.
            //
            RemoveEntryList( pLink );
            InitializeListHead( pLink );
            pPool->ulCurPackets -= pBlock->ulPackets;

            if (pBlock->hNdisPool)
            {
                NdisFreePacketPool( pBlock->hNdisPool );
            }

            FREE_NONPAGED( pBlock );
        }

        pLink = pLinkNext;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ndis\raspppoe\packet.h ===
#ifndef _PACKET_H_
#define _PACKET_H_

#ifndef _PPPOE_VERSION
#define _PPPOE_VERSION 1
#endif

typedef struct _ADAPTER* PADAPTER;
typedef struct _BINDING* PBINDING;

//
// Network-to-Host and vice versa conversion macros
//
#if (defined(_M_IX86) && (_MSC_FULL_VER > 13009037)) || ((defined(_M_AMD64) || defined(_M_IA64)) && (_MSC_FULL_VER > 13009175))
#define htons(x) _byteswap_ushort((USHORT)(x))
#define htonl(x) _byteswap_ulong((ULONG)(x))
#else
#define htons( a ) ((((a) & 0xFF00) >> 8) |\
                    (((a) & 0x00FF) << 8))
#define htonl( a ) ((((a) & 0xFF000000) >> 24) | \
                    (((a) & 0x00FF0000) >> 8)  | \
                    (((a) & 0x0000FF00) << 8)  | \
                    (((a) & 0x000000FF) << 24))
#endif
#define ntohs( a ) htons(a)
#define ntohl( a ) htonl(a)

//
// Constants related to packet lengths
//
#define PPPOE_PACKET_BUFFER_SIZE    1514

#define ETHERNET_HEADER_LENGTH      14
#define PPPOE_PACKET_HEADER_LENGTH  20          // Per RFC2156
#define PPPOE_TAG_HEADER_LENGTH     4           // Per RFC2156
#define PPP_MAX_HEADER_LENGTH       14          // maximum possible header length for ppp

#define PPPOE_AC_COOKIE_TAG_LENGTH  6

//
// Offsets for the header members
//
#define PPPOE_PACKET_DEST_ADDR_OFFSET   0           // Per RFC2156
#define PPPOE_PACKET_SRC_ADDR_OFFSET    6           // Per RFC2156
#define PPPOE_PACKET_ETHER_TYPE_OFFSET  12          // Per RFC2156
#define PPPOE_PACKET_VERSION_OFFSET     14          // Per RFC2156
#define PPPOE_PACKET_TYPE_OFFSET        14          // Per RFC2156
#define PPPOE_PACKET_CODE_OFFSET        15          // Per RFC2156
#define PPPOE_PACKET_SESSION_ID_OFFSET  16          // Per RFC2156
#define PPPOE_PACKET_LENGTH_OFFSET      18          // Per RFC2156

//
// Macros to set information in the header of the packet
//
#define PacketSetDestAddr( pP, addr ) \
    NdisMoveMemory( ( pP->pHeader + PPPOE_PACKET_DEST_ADDR_OFFSET ), addr, 6 )

#define PacketSetSrcAddr( pP, addr ) \
    NdisMoveMemory( ( pP->pHeader + PPPOE_PACKET_SRC_ADDR_OFFSET ), addr, 6 )

#define PacketSetEtherType( pP, type ) \
    * ( USHORT UNALIGNED * ) ( pP->pHeader + PPPOE_PACKET_ETHER_TYPE_OFFSET ) = htons( (USHORT) type )

#define PacketSetVersion( pP, ver ) \
    * ( UCHAR UNALIGNED * ) ( pP->pHeader + PPPOE_PACKET_VERSION_OFFSET ) |= ( ( ( (UCHAR) ver ) << 4 ) & PACKET_VERSION_MASK )

#define PacketSetType( pP, type ) \
    * ( UCHAR UNALIGNED * ) ( pP->pHeader + PPPOE_PACKET_TYPE_OFFSET ) |= ( ( (UCHAR) type ) & PACKET_TYPE_MASK )

#define PacketSetCode( pP, code ) \
    * ( UCHAR UNALIGNED * ) ( pP->pHeader + PPPOE_PACKET_CODE_OFFSET ) = ( (UCHAR) code )

#define PacketSetSessionId( pP, ses_id ) \
    * ( USHORT UNALIGNED * ) ( pP->pHeader + PPPOE_PACKET_SESSION_ID_OFFSET ) = htons( (USHORT) ses_id )

#define PacketSetLength( pP, len) \
    * ( USHORT UNALIGNED * ) ( pP->pHeader + PPPOE_PACKET_LENGTH_OFFSET ) = htons( (USHORT) len )

#define PacketSetSendCompletionStatus( pP, s ) \
   ( pP->SendCompletionStatus = s )

//
// Macros to get information from the header of the packet
//
#define PacketGetDestAddr( pP ) \
    ( pP->pHeader + PPPOE_PACKET_DEST_ADDR_OFFSET )

#define PacketGetSrcAddr( pP ) \
    ( pP->pHeader + PPPOE_PACKET_SRC_ADDR_OFFSET )

#define PacketGetEtherType( pP ) \
    ntohs( * ( USHORT UNALIGNED * ) ( pP->pHeader + PPPOE_PACKET_ETHER_TYPE_OFFSET ) )

#define PacketGetVersion( pP ) \
    ( ( ( * ( UCHAR UNALIGNED * ) ( pP->pHeader + PPPOE_PACKET_VERSION_OFFSET ) ) & PACKET_VERSION_MASK ) >> 4 )

#define PacketGetType( pP ) \
    ( ( * ( UCHAR UNALIGNED * ) ( pP->pHeader + PPPOE_PACKET_TYPE_OFFSET ) ) & PACKET_TYPE_MASK ) 

#define PacketGetCode( pP ) \
    ( * ( UCHAR UNALIGNED * ) ( pP->pHeader + PPPOE_PACKET_CODE_OFFSET ) )

#define PacketGetSessionId( pP ) \
    ntohs( * ( USHORT UNALIGNED * ) ( pP->pHeader + PPPOE_PACKET_SESSION_ID_OFFSET ) )

#define PacketGetLength( pP ) \
    ntohs( * ( USHORT UNALIGNED * ) ( pP->pHeader + PPPOE_PACKET_LENGTH_OFFSET ) )

#define PacketGetSendCompletionStatus( pP ) \
   ( pP->SendCompletionStatus )

//
// Macro that returns the Ndis Packet for a PPPoE packet
//
#define PacketGetNdisPacket( pP ) \
    ( pP->pNdisPacket )

//
// This structure is just a map, and it is not actually used in the code
//
typedef struct
_PPPOE_HEADER
{

    CHAR DestAddr[6];
    CHAR SrcAddr[6];
        #define PACKET_BROADCAST_ADDRESS    EthernetBroadcastAddress

    USHORT usEtherType;
        #define PACKET_ETHERTYPE_DISCOVERY  0x8863
        #define PACKET_ETHERTYPE_PAYLOAD    0x8864  

    union 
    {
        //
        // Version field is 4 bits and MUST be set to 0x1 for this version
        //
        CHAR usVersion;
            #define PACKET_VERSION_MASK             0xf0
            #define PACKET_VERSION          (USHORT)0x1
    
        //
        // Type field is 4 bits and MUST be set to 0x1 for this version
        //
        CHAR usType;
            #define PACKET_TYPE_MASK                0x0f
            #define PACKET_TYPE             (USHORT)0x1

    } uVerType;
    
    //
    // Code field is 8 bits and is defined as follows for Version 1
    // Values selected from enumerated type PACKET_CODES (see below)
    //
    CHAR usCode;
        
    //
    // Session Id field is 16 bits and define a unique session combined with
    // the source and destination addresses
    //
    USHORT usSessionId;
        #define PACKET_NULL_SESSION 0x0000
        
    //
    // Length field is 16 bits and indicates the length of the payload field only.
    // The length field excludes the PPPoE header block.
    //
    USHORT usLength;
        //
        // Subtract Header size from Max PADI and MAX payload lengths per RFC2156
        //
        #define PACKET_PADI_MAX_LENGTH          1478        // (1514 - 20 - 16)
        #define PACKET_GEN_MAX_LENGTH           1494        // (1514 - 20)
        #define PACKET_PPP_PAYLOAD_MAX_LENGTH   1480        // (1514 - 20)

}
PPPOE_HEADER;

//
// PACKET CODES defined by RFC2156
//
typedef enum
_PACKET_CODES
{
    PACKET_CODE_PADI = 0x09,
    PACKET_CODE_PADO = 0x07,
    PACKET_CODE_PADR = 0x19,
    PACKET_CODE_PADS = 0x65,
    PACKET_CODE_PADT = 0xa7,
    PACKET_CODE_PAYLOAD = 0x00
}
PACKET_CODES;

//
// TAGS defined by RFC2156
//
typedef enum
_PACKET_TAGS
{
    tagEndOfList        = 0x0000,
    tagServiceName      = 0x0101,
    tagACName           = 0x0102,
    tagHostUnique       = 0x0103,
    tagACCookie         = 0x0104,
    tagVendorSpecific   = 0x0105,

    tagRelaySessionId   = 0x0110,

    tagServiceNameError = 0x0201,
    tagACSystemError    = 0x0202,
    tagGenericError     = 0x0204
}
PACKET_TAGS;

//
// This is the packet context.
//
// CAUTION: Packets are not protected by their own locks, however they must be accessed carefully
//          by using their owner's locks.
//
typedef struct
_PPPOE_PACKET
{
    //
    // Points to the previous and next packet contexts when in a doubly linked list
    //
    LIST_ENTRY linkPackets;

    //
    // Keeps references on the packet
    // References added and removed for the following operations:
    //
    // (a) A reference is added when a packet is created and removed when it is freed.
    //
    // (b) A reference must be added before sending the packet and must be removed when
    //     send operation is completed.
    // 
    LONG lRef;

    //
    // Quick look-up for tags.
    //
    // The value pointers mark the beginning of the tag value in the pPacket->pPayload section.
    // The length values show the lengths of the values (not including the tag header)
    //
    USHORT tagServiceNameLength;
    CHAR*  tagServiceNameValue;

    USHORT tagACNameLength;
    CHAR*  tagACNameValue;

    USHORT tagHostUniqueLength;
    CHAR*  tagHostUniqueValue;

    USHORT tagACCookieLength;
    CHAR*  tagACCookieValue;

    USHORT tagRelaySessionIdLength;
    CHAR*  tagRelaySessionIdValue;

    PACKET_TAGS tagErrorType;
    USHORT tagErrorTagLength;
    CHAR*  tagErrorTagValue;

    //
    // Points to the buffer that holds the header portion of a PPPoE packet in wire format.
    // This points to the buffer portion of pNdisBuffer (see below)
    //
    CHAR* pHeader;

    //
    // Points to the payload portion of a PPPoE packet in wire format.
    // This is calculated and is set as : pPacket->pHeader + PPPOE_PACKET_HEADER_LENGTH
    // 
    CHAR* pPayload;

    //
    // Bit flags that identifies the nature of the buffer and packet
    //
    // (a) PCBF_BufferAllocatedFromNdisBufferPool: Indicates that pNdisBuffer points to a buffer allocated
    //                                             from gl_hNdisBufferpool, and it must be freed to that pool.
    //
    // (b) PCBF_BufferAllocatedFromOurBufferPool: Indicates that pNdisBuffer points to a buffer allocated
    //                                            from gl_poolBuffers, and it must be freed to that pool.
    // 
    // (c) PCBF_PacketAllocatedFromOurPacketPool: Indicates that pNdisPacket points to a packet allocated
    //                                            from gl_poolPackets, and it must be freed to that pool. 
    //
    // (d) PCBF_BufferChainedToPacket: Indicates that the buffer pointed to by pNdisBuffer is chained to
    //                                 the packet pointed to by pNdisPacket, and must be unchained before
    //                                 returning them back to their pools.
    //
    // (e) PCBF_CallNdisReturnPackets: Indicates that the packet was created using PacketCreateFromReceived()
    //                                 and we should call NdisReturnPackets() when we are done with it to
    //                                 return it back to NDIS.
    //
    //
    // (f) PCBF_ErrorTagReceived: This flag is valid only for received packets.
    //                            It indicates that when the packet was processed and a PPPoE packet was created
    //                            some error tags were noticed in the packet.
    //
    ULONG ulFlags;
        #define PCBF_BufferAllocatedFromNdisBufferPool          0x00000001
        #define PCBF_BufferAllocatedFromOurBufferPool           0x00000002
        #define PCBF_PacketAllocatedFromOurPacketPool           0x00000004
        #define PCBF_BufferChainedToPacket                      0x00000008
        #define PCBF_CallNdisReturnPackets                      0x00000010
        #define PCBF_CallNdisMWanSendComplete                   0x00000020
        #define PCBF_ErrorTagReceived                           0x00000040
        #define PCBF_PacketIndicatedIncomplete                  0x00000080

    //
    // Pointer to the NdisBuffer
    //
    NDIS_BUFFER* pNdisBuffer;

    //
    // Points directly to the NDIS_PACKET
    //
    NDIS_PACKET* pNdisPacket;
    //
    // pPacket->pNdisPacket->ProtocolReserved[0 * sizeof(PVOID)] = (PVOID) pPPPoEPacket;
    // pPacket->pNdisPacket->ProtocolReserved[1 * sizeof(PVOID)] = (PVOID) pNdiswanPacket;
    // pPacket->pNdisPacket->ProtocolReserved[2 * sizeof(PVOID)] = (PVOID) miniportAdapter;
    //

    //
    // Points to the PACKETHEAD struct in ppool.h. It contains the pointer to NDIS_PACKET
    //
    PACKETHEAD* pPacketHead;

    //
    // This is needed to dereference the binding when PCBF_CallNdisReturnPackets flag is set. 
    //
    PBINDING pBinding;

    //
    // Send completion status for the packet
    //
    NDIS_STATUS SendCompletionStatus;

}
PPPOE_PACKET;

VOID PacketPoolInit();

VOID PacketPoolUninit();

VOID PacketPoolAlloc();

VOID PacketPoolFree();

PPPOE_PACKET* PacketAlloc();

VOID PacketFree(
    IN PPPOE_PACKET* pPacket
    );
    
VOID ReferencePacket(
    IN PPPOE_PACKET* pPacket 
    );

VOID DereferencePacket(
    IN PPPOE_PACKET* pPacket 
    );

PPPOE_PACKET* 
PacketCreateSimple();

PPPOE_PACKET* 
PacketCreateForReceived(
    PBINDING pBinding,
    PNDIS_PACKET pNdisPacket,
    PNDIS_BUFFER pNdisBuffer,
    PUCHAR pContents
    );

PPPOE_PACKET*
PacketNdis2Pppoe(
    IN PBINDING pBinding,
    IN PNDIS_PACKET pNdisPacket,
    OUT PINT pRefCount
    );

BOOLEAN
PacketFastIsPPPoE(
    IN CHAR* HeaderBuffer,
    IN UINT HeaderBufferSize
    );
    
VOID 
RetrieveTag(
    IN OUT PPPOE_PACKET*    pPacket,
    IN PACKET_TAGS          tagType,
    OUT USHORT*             pTagLength,
    OUT CHAR**              pTagValue,
    IN USHORT               prevTagLength,
    IN CHAR*                prevTagValue,
    IN BOOLEAN              fSetTagInPacket
    );

NDIS_STATUS PacketInsertTag(
    IN  PPPOE_PACKET*   pPacket,
    IN  PACKET_TAGS     tagType,
    IN  USHORT          tagLength,
    IN  CHAR*           tagValue,
    OUT CHAR**          pNewTagValue    
    );

NDIS_STATUS PacketInitializePADIToSend(
    OUT PPPOE_PACKET** ppPacket,
    IN USHORT        tagServiceNameLength,
    IN CHAR*         tagServiceNameValue,
    IN USHORT        tagHostUniqueLength,
    IN CHAR*         tagHostUniqueValue
    );

NDIS_STATUS 
PacketInitializePADOToSend(
    IN  PPPOE_PACKET*   pPADI,
    OUT PPPOE_PACKET**  ppPacket,
    IN CHAR*            pSrcAddr,
    IN USHORT           tagServiceNameLength,
    IN CHAR*            tagServiceNameValue,
    IN USHORT           tagACNameLength,
    IN CHAR*            tagACNameValue,
    IN BOOLEAN          fInsertACCookieTag
    );
    
NDIS_STATUS PacketInitializePADRToSend(
    IN PPPOE_PACKET*    pPADO,
    OUT PPPOE_PACKET**  ppPacket,
    IN USHORT           tagServiceNameLength,
    IN CHAR*            tagServiceNameValue,
    IN USHORT           tagHostUniqueLength,
    IN CHAR*            tagHostUniqueValue
    );

NDIS_STATUS PacketInitializePADSToSend(
    IN PPPOE_PACKET*    pPADR,
    OUT PPPOE_PACKET**  ppPacket,
    IN USHORT           usSessionId
    );

NDIS_STATUS PacketInitializePADTToSend(
    OUT PPPOE_PACKET** ppPacket,
    IN CHAR* pSrcAddr, 
    IN CHAR* pDestAddr,
    IN USHORT usSessionId
    );
    
NDIS_STATUS PacketInitializePAYLOADToSend(
    OUT PPPOE_PACKET** ppPacket,
    IN CHAR* pSrcAddr,
    IN CHAR* pDestAddr,
    IN USHORT usSessionId,
    IN NDIS_WAN_PACKET* pWanPacket,
    IN PADAPTER MiniportAdapter
    );  

NDIS_STATUS PacketInitializeFromReceived(
    IN PPPOE_PACKET* pPacket
    );

BOOLEAN PacketAnyErrorTagsReceived(
    IN PPPOE_PACKET* pPacket
    );

VOID PacketRetrievePayload(
    IN  PPPOE_PACKET*   pPacket,
    OUT CHAR**          ppPayload,
    OUT USHORT*         pusLength
    );

VOID PacketRetrieveServiceNameTag(
    IN PPPOE_PACKET* pPacket,
    OUT USHORT*      pTagLength,
    OUT CHAR**       pTagValue,
    IN USHORT        prevTagLength,
    IN CHAR*         prevTagValue
    );
    
VOID PacketRetrieveHostUniqueTag(
    IN PPPOE_PACKET* pPacket,
    OUT USHORT*      pTagLength,
    OUT CHAR**       pTagValue
    );  

VOID PacketRetrieveACNameTag(
    IN PPPOE_PACKET* pPacket,
    OUT USHORT*      pTagLength,
    OUT CHAR**       pTagValue
    );  

VOID PacketRetrieveACCookieTag(
    IN PPPOE_PACKET* pPacket,
    OUT USHORT*      pTagLength,
    OUT CHAR**       pTagValue
    );

VOID PacketRetrieveErrorTag(
    IN PPPOE_PACKET* pPacket,
    OUT PACKET_TAGS* pTagType,
    OUT USHORT*      pTagLength,
    OUT CHAR**       pTagValue
    );
    
PPPOE_PACKET* PacketGetRelatedPppoePacket(
    IN NDIS_PACKET* pNdisPacket
    );

NDIS_WAN_PACKET* PacketGetRelatedNdiswanPacket(
    IN PPPOE_PACKET* pPacket
    );

PADAPTER PacketGetMiniportAdapter(
    IN PPPOE_PACKET* pPacket
    );

PPPOE_PACKET* PacketMakeClone(
    IN PPPOE_PACKET* pPacket
    );

VOID
PacketGenerateACCookieTag(
    IN PPPOE_PACKET* pPacket,
    IN CHAR tagACCookieValue[ PPPOE_AC_COOKIE_TAG_LENGTH ]
    );

BOOLEAN
PacketValidateACCookieTagInPADR(
    IN PPPOE_PACKET* pPacket
    );  

//////////////////////////////////////////////////////////
//
// Error codes and messages
//
//////////////////////////////////////////////////////////

#define PPPOE_ERROR_BASE                                    0

#define PPPOE_NO_ERROR                                      PPPOE_ERROR_BASE

#define PPPOE_ERROR_SERVICE_NOT_SUPPORTED                   PPPOE_ERROR_BASE + 1
#define PPPOE_ERROR_SERVICE_NOT_SUPPORTED_MSG               "Service not supported"
#define PPPOE_ERROR_SERVICE_NOT_SUPPORTED_MSG_SIZE          ( sizeof( PPPOE_ERROR_SERVICE_NOT_SUPPORTED_MSG ) / sizeof( CHAR ) )

#define PPPOE_ERROR_INVALID_AC_COOKIE_TAG                   PPPOE_ERROR_BASE + 2
#define PPPOE_ERROR_INVALID_AC_COOKIE_TAG_MSG               "AC-Cookie tag is invalid"
#define PPPOE_ERROR_INVALID_AC_COOKIE_TAG_MSG_SIZE          ( sizeof( PPPOE_ERROR_INVALID_AC_COOKIE_TAG_MSG ) / sizeof( CHAR ) )            

#define PPPOE_ERROR_CLIENT_QUOTA_EXCEEDED                   PPPOE_ERROR_BASE + 3
#define PPPOE_ERROR_CLIENT_QUOTA_EXCEEDED_MSG               "Can not accept any more connections from this machine"
#define PPPOE_ERROR_CLIENT_QUOTA_EXCEEDED_MSG_SIZE          ( sizeof( PPPOE_ERROR_CLIENT_QUOTA_EXCEEDED_MSG ) / sizeof( CHAR ) )            


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ndis\raspppoe\packet.c ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Module Name:

    packet.c

Abstract:

    This module contains all the necesarry routines for encapsulating PPPoE
    packets and their related NDIS and NDISWAN packets.

Author:

    Hakan Berk - Microsoft, Inc. (hakanb@microsoft.com) Feb-2000

Environment:

    Windows 2000 kernel mode Miniport driver or equivalent.

Revision History:

---------------------------------------------------------------------------*/

#include <ntddk.h>
#include <ntddndis.h>
#include <ndis.h>
#include <ndiswan.h>
#include <ndistapi.h>
#include <ntverp.h>

#include "debug.h"
#include "timer.h"
#include "bpool.h"
#include "ppool.h"
#include "util.h"
#include "packet.h"
#include "protocol.h"
#include "miniport.h"
#include "tapi.h"

//////////////////////////////////////////////////////////////////////////
//
// Variables local to packet.c
// They are defined global only for debugging purposes.
//
///////////////////////////////////////////////////////////////////////////

//
// Flag that indicates if gl_lockPools is allocated or not
//
BOOLEAN gl_fPoolLockAllocated = FALSE;

//
// Spin lock to synchronize access to gl_ulNumPackets
//
NDIS_SPIN_LOCK gl_lockPools;

//
// Our pool of PPPoE buffer descriptors
//
BUFFERPOOL gl_poolBuffers;

//
// Our pool of PPPoE packet descriptors
//
PACKETPOOL gl_poolPackets;

//
// Ndis pool of buffer descriptors
//
NDIS_HANDLE gl_hNdisBufferPool;

//
// Non-paged lookaside list for PppoePacket structures
//
NPAGED_LOOKASIDE_LIST gl_llistPppoePackets;

//
// This is for debugging purposes. Shows the number of active packets
//
ULONG gl_ulNumPackets = 0;

//
// This defines the broadcast destination address
//
CHAR EthernetBroadcastAddress[6] = { (CHAR) 0xff, 
                                     (CHAR) 0xff, 
                                     (CHAR) 0xff, 
                                     (CHAR) 0xff, 
                                     (CHAR) 0xff, 
                                     (CHAR) 0xff };

VOID 
ReferencePacket(
    IN PPPOE_PACKET* pPacket 
    )           
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function will increment the reference count on the packet object.
    
Parameters:

    pPacket _ A pointer to the packet context.

Return Values:

    None
---------------------------------------------------------------------------*/
{                       
    LONG lRef;
    
    TRACE( TL_V, TM_Pk, ("+ReferencePacket") );

    lRef = NdisInterlockedIncrement( &pPacket->lRef );  

    TRACE( TL_V, TM_Pk, ("-ReferencePacket=$%x",lRef) );
}                                               


VOID 
DereferencePacket(
    IN PPPOE_PACKET* pPacket 
    )                   
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function will decrement the reference count on the packet object.

    When ref count reaches 0, packet is cleaned up.
    
Parameters:

    pPacket _ A pointer to the packet context.

Return Values:

    None
---------------------------------------------------------------------------*/
{       
    LONG lRef;
    
    TRACE( TL_V, TM_Pk, ("+DereferencePacket") );

    lRef = NdisInterlockedDecrement( &pPacket->lRef );

    if ( lRef == 0 )    
    {                                               

        if ( pPacket->ulFlags & PCBF_BufferChainedToPacket )
        {
            //
            // Unchain the buffer before freeing any packets
            //
            TRACE( TL_V, TM_Pk, ("DereferencePacket: Buffer unchained from packet") );
            
            NdisUnchainBufferAtFront( pPacket->pNdisPacket, &pPacket->pNdisBuffer );
        }
        
        if ( pPacket->ulFlags & PCBF_BufferAllocatedFromOurBufferPool )
        {
            //
            // Skipping check for pBuffer == NULL as this should never happen
            // But call NdisAdjustBufferLength() to set the buffer length to original value
            //
            TRACE( TL_V, TM_Pk, ("DereferencePacket: Buffer returned to our pool") );

            NdisAdjustBufferLength( pPacket->pNdisBuffer, PPPOE_PACKET_BUFFER_SIZE );
            
            FreeBufferToPool( &gl_poolBuffers, pPacket->pHeader, TRUE );
        }

        if ( pPacket->ulFlags & PCBF_BufferAllocatedFromNdisBufferPool )
        {
            TRACE( TL_V, TM_Pk, ("DereferencePacket: Buffer returned to ndis pool") );
            
            NdisFreeBuffer( pPacket->pNdisBuffer );
        }
        
        if ( pPacket->ulFlags & PCBF_CallNdisMWanSendComplete )
        {
            //
            // Return packet back to NDISWAN
            //
            TRACE( TL_V, TM_Pk, ("DereferencePacket: Returning packet back to NDISWAN") );

            NdisMWanSendComplete(   PacketGetMiniportAdapter( pPacket )->MiniportAdapterHandle,
                                    PacketGetRelatedNdiswanPacket( pPacket ),
                                    PacketGetSendCompletionStatus( pPacket ) );

            //
            // Indicate to miniport that the packet is returned to NDISWAN
            //
            MpPacketOwnedByNdiswanReturned( PacketGetMiniportAdapter( pPacket ) );

        }

        if ( pPacket->ulFlags & PCBF_PacketAllocatedFromOurPacketPool )
        {
            //
            // Skipping check for pPacketHead == NULL as this should never happen
            //
            TRACE( TL_V, TM_Pk, ("DereferencePacket: Packet returned to our pool") );
            
            NdisReinitializePacket( pPacket->pNdisPacket );
        
            FreePacketToPool( &gl_poolPackets, pPacket->pPacketHead, TRUE );
        }

        if ( pPacket->ulFlags & PCBF_CallNdisReturnPackets )
        {
            //
            // Return packet back to NDIS
            //
            TRACE( TL_V, TM_Pk, ("DereferencePacket: Returning packet back to NDIS") );

            NdisReturnPackets( &pPacket->pNdisPacket, 1 );

            //
            // Indicate to protocol that the packet is returned to NDIS.
            //
            PrPacketOwnedByNdisReturned( pPacket->pBinding );

        }

        //
        // Finally return PppoePacket to the lookaside list
        //
        NdisFreeToNPagedLookasideList( &gl_llistPppoePackets, (PVOID) pPacket );

        NdisAcquireSpinLock( &gl_lockPools );
        
        gl_ulNumPackets--;

        TRACE( TL_V, TM_Pk, ("DereferencePacket: gl_ulNumPacket=$%x", gl_ulNumPackets) );

        NdisReleaseSpinLock( &gl_lockPools );

    }       

    TRACE( TL_V, TM_Pk, ("-DereferencePacket=$%x",lRef) );
}                                                   

VOID 
RetrieveTag(
    IN OUT PPPOE_PACKET*    pPacket,
    IN PACKET_TAGS          tagType,
    OUT USHORT *            pTagLength,
    OUT CHAR**              pTagValue,
    IN USHORT               prevTagLength,
    IN CHAR *               prevTagValue,
    IN BOOLEAN              fSetTagInPacket
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    You can call this function on a received packet processed with one of the 
    PacketInitialize*FromReceived() functions.

    It will not operate on a PAYLOAD packet, although you can call it safely.

    It will retrieve and return the next length - value pair for a specific tag.
    To retrieve the 1st one, pass 0 and NULL for prevTag* parameters.

    If you pass fSetTagInPacket as TRUE, and if the next tag is found and the tag is known 
    to PppoePacket struct, then the fields for the tag in the packet are updated to point
    to the found tag.

    If there are no next tags, then *pTagValue will point to NULL, and *pTagLength 
    will point to '0'.
    
Parameters:

    pPacket _ Pointer to a packet context prepared by a PacketInitializeXXXToSend() 
              function, or PacketInitializeFromReceived().

    tagType _ Type of the tag being searched for.

    pTagLength _ A pointer to a USHORT var that will keep the length of the returned tag.

    pTagValue _ A pointer to the value of the tag which is basically a blob of 
                length *pTagLength.

    prevTagLength _ The length of the value of the previous tag.

    prevTagValue _ Points to the beginning of the value of the previous tag.

    fSetTagInPacket _ Indicates that if a tag is found and is native to PPPoE packet context,
                      then PPPoE packet context must be updated to point to this new tag.

Return Values:

    None
    
---------------------------------------------------------------------------*/   
{
    CHAR*   pBuf = NULL;
    CHAR*   pBufEnd = NULL;

    ASSERT( pPacket != NULL );
    ASSERT( pTagLength != NULL );
    ASSERT( pTagValue != NULL );

    TRACE( TL_V, TM_Pk, ("+RetrieveTag") );

    //
    // Initialize the output parameters
    //
    *pTagLength = (USHORT) 0;
    *pTagValue = NULL;

    //
    // If this is a payload packet, then do not search for any tags
    //
    if ( PacketGetCode( pPacket ) == PACKET_CODE_PAYLOAD )
    {
        TRACE( TL_V, TM_Pk, ("-RetrieveTag: No tags. Payload packet") );

        return;
    }

    //
    // Find the start point to search for the tag
    //
    if ( prevTagValue != NULL )
    {
        //
        // Caller wants the next tag, so make pBuf point to end of the prev tag value
        //
        pBuf = prevTagValue + prevTagLength;
    }
    else
    {
        //
        // Caller wants the first tag in the packet
        //
        pBuf = pPacket->pPayload;
    }
        
    //
    // Find the end point of the tag payload area
    //
    pBufEnd = pPacket->pPayload + PacketGetLength( pPacket );

    //
    // Search for the tag until we step outside the boundaries
    //
    while ( pBuf + PPPOE_TAG_HEADER_LENGTH <= pBufEnd )
    {

        USHORT usTagLength;
        USHORT usTagType;

        usTagType = ntohs( *((USHORT UNALIGNED *) pBuf) ) ;
        ((USHORT*) pBuf)++;

        usTagLength = ntohs( *((USHORT UNALIGNED *) pBuf) ) ;
        ((USHORT*) pBuf)++;
        
        if ( usTagType == tagType )
        {
            //
            // Tag found, retrieve length and values
            //
            TRACE( TL_N, TM_Pk, ("RetrieveTag: Tag found:$%x", *pTagLength) );

            *pTagLength = usTagLength;
            *pTagValue = pBuf;

            break;
        }

        pBuf += usTagLength;

    } 

    //
    // Check if tag was found
    //
    if ( *pTagValue != NULL )
    {
    
        //
        // Tag found. Check if the caller wants to set it in the PppoePacket
        //
        if ( fSetTagInPacket )
        {
            TRACE( TL_V, TM_Pk, ("RetrieveTag: Setting tag in packet") );
            
            switch ( tagType )
            {
    
                case tagEndOfList:

                        break;
                        
                case tagServiceName:

                        pPacket->tagServiceNameLength = *pTagLength;
                        pPacket->tagServiceNameValue  = *pTagValue;
            
                        break;
                        
                case tagACName:

                        pPacket->tagACNameLength = *pTagLength;
                        pPacket->tagACNameValue  = *pTagValue;

                        break;
                        
                case tagHostUnique:

                        pPacket->tagHostUniqueLength = *pTagLength;
                        pPacket->tagHostUniqueValue  = *pTagValue;

                        break;
                        
                case tagACCookie:

                        pPacket->tagACCookieLength = *pTagLength;
                        pPacket->tagACCookieValue  = *pTagValue;

                        break;
                        
                case tagRelaySessionId:

                        pPacket->tagRelaySessionIdLength = *pTagLength;
                        pPacket->tagRelaySessionIdValue  = *pTagValue;
                        
                        break;
        
                case tagServiceNameError:

                        pPacket->tagErrorType   = tagServiceNameError;
                        pPacket->tagErrorTagLength = *pTagLength;
                        pPacket->tagErrorTagValue  = *pTagValue;

                        break;
                        
                case tagACSystemError:

                        pPacket->tagErrorType   = tagACSystemError;
                        pPacket->tagErrorTagLength = *pTagLength;
                        pPacket->tagErrorTagValue  = *pTagValue;

                        break;
                        
                case tagGenericError:

                        pPacket->tagErrorType   = tagGenericError;
                        pPacket->tagErrorTagLength = *pTagLength;
                        pPacket->tagErrorTagValue  = *pTagValue;

                        break;

                default:

                        break;
            }

        }
    }

    TRACE( TL_V, TM_Pk, ("-RetrieveTag") );
}

NDIS_STATUS 
PreparePacketForWire(
    IN OUT PPPOE_PACKET* pPacket
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function prepares the packet for wire.

    It must be called inside a PacketInitializeXXXToSend() function after all
    processing is done with the packet to prepare it to be transmitted over the wire.

    It basically creates and writes the tags into the payload area of the packet,
    and finally adjusts the length of the buffer to let Ndis know the extents of the
    valid data blob.
    
Parameters:

    pPacket _ Pointer to a packet context prepared by a PacketInitializeXXXToSend() 
              function.

Return Values:

    NDIS_STATUS_SUCCESS
    NDIS_STATUS_INVALID_PACKET
    
---------------------------------------------------------------------------*/       
{
    NDIS_STATUS status = NDIS_STATUS_SUCCESS;
    CHAR* pBuf;
    
    ASSERT( pPacket != NULL );

    TRACE( TL_V, TM_Pk, ("+PreparePacketForWire") );

    //
    // Now insert the tags if packet is a Discovery Ethernet packet
    //
    switch ( PacketGetCode( pPacket ) ) 
    {
        case PACKET_CODE_PADI:

                        PacketInsertTag( pPacket, 
                                         tagServiceName, 
                                         pPacket->tagServiceNameLength,
                                         pPacket->tagServiceNameValue,
                                         &pPacket->tagServiceNameValue);

                        if ( pPacket->tagHostUniqueLength > 0 ) 
                        {

                            TRACE( TL_N, TM_Pk, ("PreparePacketForWire: Inserting host unique tag") );
                            
                            PacketInsertTag( pPacket, 
                                             tagHostUnique, 
                                             pPacket->tagHostUniqueLength,
                                             pPacket->tagHostUniqueValue,
                                             &pPacket->tagHostUniqueValue );
                        }
                        
                        break;
        
        case PACKET_CODE_PADO:

                        PacketInsertTag( pPacket, 
                                         tagServiceName, 
                                         pPacket->tagServiceNameLength,
                                         pPacket->tagServiceNameValue,
                                         &pPacket->tagServiceNameValue );
                                         
                        if ( pPacket->tagHostUniqueLength > 0 )     
                        {
                            TRACE( TL_N, TM_Pk, ("PreparePacketForWire: Inserting host unique tag") );
                        
                            PacketInsertTag( pPacket, 
                                             tagHostUnique, 
                                             pPacket->tagHostUniqueLength,
                                             pPacket->tagHostUniqueValue,
                                             &pPacket->tagHostUniqueValue );
                        }

                        if ( pPacket->tagRelaySessionIdLength > 0 )                                      
                        {
                            TRACE( TL_N, TM_Pk, ("PreparePacketForWire: Inserting relay sesion id tag") );
                            
                            PacketInsertTag( pPacket, 
                                             tagRelaySessionId, 
                                             pPacket->tagRelaySessionIdLength,
                                             pPacket->tagRelaySessionIdValue,
                                             &pPacket->tagRelaySessionIdValue );
                        }
                        
                        PacketInsertTag( pPacket, 
                                         tagACName, 
                                         pPacket->tagACNameLength,
                                         pPacket->tagACNameValue,
                                         &pPacket->tagACNameValue );

                        PacketInsertTag( pPacket, 
                                         tagACCookie, 
                                         pPacket->tagACCookieLength,
                                         pPacket->tagACCookieValue,
                                         &pPacket->tagACCookieValue );
                        break;
        
        case PACKET_CODE_PADR:
        
                        PacketInsertTag( pPacket, 
                                         tagServiceName, 
                                         pPacket->tagServiceNameLength,
                                         pPacket->tagServiceNameValue,
                                         &pPacket->tagServiceNameValue );
                                         
                        if ( pPacket->tagHostUniqueLength > 0 ) 
                        {
                            TRACE( TL_N, TM_Pk, ("PreparePacketForWire: Inserting host unique tag") );
                        
                            PacketInsertTag( pPacket, 
                                             tagHostUnique, 
                                             pPacket->tagHostUniqueLength,
                                             pPacket->tagHostUniqueValue,
                                             &pPacket->tagHostUniqueValue );
                        }

                        if ( pPacket->tagRelaySessionIdLength > 0 )                                      
                        {
                            TRACE( TL_N, TM_Pk, ("PreparePacketForWire: Inserting relay sesion id tag") );
                            
                            PacketInsertTag( pPacket, 
                                             tagRelaySessionId, 
                                             pPacket->tagRelaySessionIdLength,
                                             pPacket->tagRelaySessionIdValue,
                                             &pPacket->tagRelaySessionIdValue );
                        }
                                             
                        if ( pPacket->tagACCookieLength > 0 )                                        
                        {
                            TRACE( TL_N, TM_Pk, ("PreparePacketForWire: Inserting ac-ccokie tag") );
                            
                            PacketInsertTag( pPacket, 
                                             tagACCookie, 
                                             pPacket->tagACCookieLength,
                                             pPacket->tagACCookieValue,
                                             &pPacket->tagACCookieValue );
                        }
                        
                        break;
        
        case PACKET_CODE_PADS:

                        PacketInsertTag( pPacket, 
                                         tagServiceName, 
                                         pPacket->tagServiceNameLength,
                                         pPacket->tagServiceNameValue,
                                         &pPacket->tagServiceNameValue );
                                         
                        if ( pPacket->tagHostUniqueLength > 0 ) 
                        {
                            TRACE( TL_N, TM_Pk, ("PreparePacketForWire: Inserting host unique tag") );
                        
                            PacketInsertTag( pPacket, 
                                             tagHostUnique, 
                                             pPacket->tagHostUniqueLength,
                                             pPacket->tagHostUniqueValue,
                                             &pPacket->tagHostUniqueValue );
                        }

                        if ( pPacket->tagRelaySessionIdLength > 0 )     
                        {
                            TRACE( TL_N, TM_Pk, ("PreparePacketForWire: Inserting relay sesion id tag") );
                            
                            PacketInsertTag( pPacket, 
                                             tagRelaySessionId, 
                                             pPacket->tagRelaySessionIdLength,
                                             pPacket->tagRelaySessionIdValue,
                                             &pPacket->tagRelaySessionIdValue );
                        }
                                             
                        break;
                        
        case PACKET_CODE_PADT:

                        break;
                        
        case PACKET_CODE_PAYLOAD:

                        break;
        
        default:
            status = NDIS_STATUS_INVALID_PACKET;
    }

    if ( status == NDIS_STATUS_SUCCESS )
    {
        //
        // Adjust buffer length
        //
        NdisAdjustBufferLength( pPacket->pNdisBuffer, 
                                (UINT) ( PacketGetLength( pPacket ) + PPPOE_PACKET_HEADER_LENGTH ) );
    }

    TRACE( TL_V, TM_Pk, ("-PreparePacketForWire=$%x",status) );

    return status;
}

PPPOE_PACKET* 
PacketCreateSimple()
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function allocates and initializes a simple packet.

    A simple packet is mainly used for control packets to be sent.
    Its buffer, and packet is allocated from our pools, buffer is chained to
    packet.

    On return all following values point to valid places and are safe for use:
    pHeader
    pPayload
    pNdisBuffer
    pNdisPacket
    
Parameters:

    None

Return Values:

    Pointer to an initialized PPPoE packet context.
    
---------------------------------------------------------------------------*/   
{
    PPPOE_PACKET* pPacket = NULL;

    TRACE( TL_V, TM_Pk, ("+PacketCreateSimple") );
    
    //
    // Allocate a packet
    //
    pPacket = PacketAlloc();
    if ( pPacket == NULL )
    {
        TRACE( TL_V, TM_Pk, ("-PacketCreateSimple=$%x",NULL) );

        return NULL;
    }

    //
    // Allocate NdisBuffer from our pool
    //
    pPacket->pHeader = GetBufferFromPool( &gl_poolBuffers );
    
    if ( pPacket->pHeader == NULL )
    {
        TRACE( TL_A, TM_Pk, ("PacketCreateSimple: Could not get buffer from our pool") );

        TRACE( TL_V, TM_Pk, ("-PacketCreateSimple=$%x",NULL) );
        
        PacketFree( pPacket );

        return NULL;
    }

    pPacket->ulFlags |= PCBF_BufferAllocatedFromOurBufferPool;

    //
    // Clean up the buffer area
    //
    NdisZeroMemory( pPacket->pHeader, PPPOE_PACKET_BUFFER_SIZE * sizeof( CHAR ) );

    //
    // Point built-in NDIS buffer pointer to NDIS buffer of buffer from pool
    //
    pPacket->pNdisBuffer = NdisBufferFromBuffer( pPacket->pHeader );

    //
    // Allocate an NDIS packet from our pool
    //
    pPacket->pNdisPacket = GetPacketFromPool( &gl_poolPackets, &pPacket->pPacketHead );

    if ( pPacket->pNdisPacket == NULL ) 
    {
        
        TRACE( TL_A, TM_Pk, ("PacketCreateSimple: Could not get packet from our pool") );

        TRACE( TL_V, TM_Pk, ("-PacketCreateSimple=$%x",NULL) );

        PacketFree( pPacket );

        return NULL;
    }

    pPacket->ulFlags |= PCBF_PacketAllocatedFromOurPacketPool;

    //
    // Chain buffer to packet
    //
    NdisChainBufferAtFront( pPacket->pNdisPacket, pPacket->pNdisBuffer );

    pPacket->ulFlags |= PCBF_BufferChainedToPacket;

    //
    // Set the payload and payload length
    //
    pPacket->pPayload = pPacket->pHeader + PPPOE_PACKET_HEADER_LENGTH; 

    //
    // Set the input NDIS_PACKET to the reserved area so that we can reach it
    // when we have to return this packet back to the upper layer.
    //
    *((PPPOE_PACKET UNALIGNED **)(&pPacket->pNdisPacket->ProtocolReserved[0 * sizeof(PVOID)])) = pPacket;

    TRACE( TL_V, TM_Pk, ("-PacketCreateSimple=$%x",pPacket) );

    return pPacket;
}


PPPOE_PACKET* 
PacketCreateForReceived(
    PBINDING pBinding,
    PNDIS_PACKET pNdisPacket,
    PNDIS_BUFFER pNdisBuffer,
    PUCHAR pContents
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function allocates and initializes a packet from a received packet.

    This function is used for perf optimization. When the received packet has 
    a single buffer that we can pass to the miniport.

    On return all following values point to valid places and are safe for use:
    pHeader
    pPayload
    pNdisBuffer
    pNdisPacket
    
Parameters:

    pBinding _ The binding over which this packet is received. 
    
    pNdisPacket _ Ndis Packet descriptor from the received packet.

    pNdisBuffer _ Ndis Buffer descriptor from the received packet.

    pContents _ Pointer to the contents of the buffer.

Return Values:

    Pointer to an initialized PPPoE packet context.
    
---------------------------------------------------------------------------*/   
{
    PPPOE_PACKET* pPacket = NULL;

    TRACE( TL_V, TM_Pk, ("+PacketCreateForReceived") );
    
    //
    // Allocate a packet
    //
    pPacket = PacketAlloc();
    
    if ( pPacket == NULL )
    {
        TRACE( TL_V, TM_Pk, ("-PacketCreateForReceived=$%x",NULL) );

        return NULL;
    }

    //
    // Mark the packet so we return it to NDIS when it is freed
    //
    pPacket->ulFlags |= PCBF_CallNdisReturnPackets;

    //
    // Save the binding and indicate to protocol such a packet is created using
    // PrPacketOwnedByNdisReceived()
    //
    pPacket->pBinding = pBinding;

    PrPacketOwnedByNdisReceived( pBinding );
    
    //
    // Set the pointers 
    //
    pPacket->pHeader = pContents;
    
    pPacket->pNdisBuffer = pNdisBuffer;

    pPacket->pNdisPacket = pNdisPacket;

    pPacket->pPayload = pPacket->pHeader + PPPOE_PACKET_HEADER_LENGTH; 

    TRACE( TL_V, TM_Pk, ("-PacketCreateForReceived=$%x",pPacket) );

    return pPacket;
}


PPPOE_PACKET*
PacketNdis2Pppoe(
    IN PBINDING pBinding,
    IN PNDIS_PACKET pNdisPacket,
    OUT PINT pRefCount
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function is used to convert only NDIS packets indicated by PrReceivePacket().

    If packet is received by PrReceive() then you should not be using this function.

    We look at the Ndis buffer, and if it has a single flat buffer, then we exploit it
    and use the original Ndis packets buffer descriptors so we do not do any copy,
    otherwise we create our own copy of it as PPPoE packet, and operate on it. 
    ( AliD says, 99% of the time the single flat buffer case will be true. )

    If we use the original Ndis packet, then we return 1 in the pRefCount parameter, 
    otherwise we return 0.
    
    On return all following values point to valid places and are safe for use:
    pHeader
    pPayload
    pNdisBuffer
    pNdisPacket
    
Parameters:

    pBinding _ The binding over which this packet is received. 
    
    pNdisPacket _ Original, unprocessed Ndis packet. 
                  This must be indicated by ProtocolReceivePacket().

    pRefCount _ Reference count to be returned to Ndis from ProtocolReceivePacket().
                We return 1 if we can use the Ndis packet and buffer descriptors, otherwise
                we make our own copy so we won't need the original Ndis packet, so we return 0.

Return Values:

    Pointer to an initialized PPPoE packet context.
    
---------------------------------------------------------------------------*/   
{
    PPPOE_PACKET* pPacket = NULL;

    NDIS_BUFFER* pNdisBuffer = NULL;
    UINT nBufferCount = 0;
    UINT nTotalLength = 0;

    PVOID pBufferContents = NULL;
    UINT nBufferLength;

    UINT nCopiedBufferLength = 0;

    BOOLEAN fReturnPacket = FALSE;

    TRACE( TL_V, TM_Pk, ("+PacketNdis2Pppoe") );

    do
    {
        //
        // Query the packet and get the total length and the pointer to first buffer
        //
        NdisQueryPacket( pNdisPacket,
                         NULL,
                         &nBufferCount,
                         &pNdisBuffer,
                         &nTotalLength );

        //
        // Make sure indicated packet is not larger than expected
        //
        if ( nTotalLength > (UINT) PPPOE_PACKET_BUFFER_SIZE )
        {
            TRACE( TL_A, TM_Pk, ("PacketNdis2Pppoe: Packet larger than expected") );
            
            break;
        }
                         
        if ( nBufferCount == 1 &&
             NDIS_GET_PACKET_STATUS(pNdisPacket) != NDIS_STATUS_RESOURCES)
        {
            //
            // We can handle this case efficiently
            //

            //
            // Since we will be using the original Ndis packet and buffers, make sure
            // length specified in the PPPoE packet does not exceed the total length
            // of the Ndis packet
            //

            USHORT usPppoePacketLength;
            
            NdisQueryBufferSafe( pNdisBuffer,
                                 &pBufferContents,
                                 &nBufferLength,
                                 NormalPagePriority );
    
            if ( pBufferContents == NULL )
            {
                TRACE( TL_A, TM_Pk, ("PacketNdis2Pppoe: System resources low, dropping packet") );

                break;
            }

            if ( nBufferLength < ETHERNET_HEADER_LENGTH )
            {
                TRACE( TL_A, TM_Pk, ("PacketNdis2Pppoe: Packet header smaller than expected") );

                break;
            }

            if ( !PacketFastIsPPPoE( pBufferContents, ETHERNET_HEADER_LENGTH ) ) 
            {
                TRACE( TL_V, TM_Pk, ("PacketNdis2Pppoe: Packet is not PPPoE") );
    
                break;
            }

            usPppoePacketLength = ntohs( * ( USHORT UNALIGNED * ) ( (PUCHAR) pBufferContents + PPPOE_PACKET_LENGTH_OFFSET ) );

            if ( (UINT) usPppoePacketLength > nTotalLength )
            {
                TRACE( TL_A, TM_Pk, ("PacketNdis2Pppoe: PPPoE Packet length larger than Ndis packet length") );

                break;
            }

            //
            // Let's create our PPPoE packet to keep the copy of the received packet
            //
            pPacket = PacketCreateForReceived( pBinding,
                                               pNdisPacket,
                                               pNdisBuffer,
                                               pBufferContents );
        
            if ( pPacket == NULL )
            {
                TRACE( TL_A, TM_Pk, ("PacketNdis2Pppoe: Could not allocate context to copy the packet") );
        
                break;
            }

            fReturnPacket = TRUE;
            
            *pRefCount = 1;                         

        }
        else
        {

            //
            // Since Ndis packet contains multiple buffers, we can not handle this case efficiently.
            // We need to allocate a PPPoE packet, copy the contents of the Ndis packet as a flat
            // buffer to this packet, and then operate on it.
            //

            //
            // Let's create our PPPoE packet to keep the copy of the received packet
            //
            pPacket = PacketCreateSimple();
        
            if ( pPacket == NULL )
            {
                TRACE( TL_A, TM_Pk, ("PacketNdis2Pppoe: Could not allocate context to copy the packet") );
        
                break;
            }
    
            //
            // Retrieve the header and check if the packet is a PPPoE frame or not
            //
            do
            {
                NdisQueryBufferSafe( pNdisBuffer,
                                     &pBufferContents,
                                     &nBufferLength,
                                     NormalPagePriority );
    
                if ( pBufferContents == NULL )
                {
                    TRACE( TL_A, TM_Pk, ("PacketNdis2Pppoe: System resources low, dropping packet") );
    
                    break;
                }
    
                NdisMoveMemory( pPacket->pHeader + nCopiedBufferLength,
                                pBufferContents,
                                nBufferLength );
    
                nCopiedBufferLength += nBufferLength;                                
    
            } while ( nCopiedBufferLength < ETHERNET_HEADER_LENGTH );
    
            if ( nCopiedBufferLength < ETHERNET_HEADER_LENGTH )
            {
                TRACE( TL_A, TM_Pk, ("PacketNdis2Pppoe: Header could not be retrieved") );
    
                break;
            }
            
            if ( !PacketFastIsPPPoE( pPacket->pHeader, ETHERNET_HEADER_LENGTH ) ) 
            {
                TRACE( TL_V, TM_Pk, ("PacketNdis2Pppoe: Packet is not PPPoE") );
    
                break;
            }
    
            //
            // Since we know that the packet is PPPoE, copy the rest of the data to our 
            // own copy of the packet
            //
            NdisGetNextBuffer( pNdisBuffer,
                               &pNdisBuffer );
            
            while ( pNdisBuffer != NULL )
            {
    
                NdisQueryBufferSafe( pNdisBuffer,
                                     &pBufferContents,
                                     &nBufferLength,
                                     NormalPagePriority );
    
                if ( pBufferContents == NULL )
                {
                    TRACE( TL_A, TM_Pk, ("PacketNdis2Pppoe: System resources low, dropping packet") );
    
                    break;
                }
    
                NdisMoveMemory( pPacket->pHeader + nCopiedBufferLength,
                                pBufferContents,
                                nBufferLength );
    
                nCopiedBufferLength += nBufferLength;                                
    
                NdisGetNextBuffer( pNdisBuffer,
                                   &pNdisBuffer );
            } 
    
            //
            // Check if we could copy the whole chain of buffers
            //
            if ( nCopiedBufferLength < nTotalLength )
            {
                TRACE( TL_A, TM_Pk, ("PacketNdis2Pppoe: Failed to copy the whole data from all buffers") );
    
                break;
            }

            fReturnPacket = TRUE;
            
            *pRefCount = 0;                         
        }

    } while ( FALSE );

    if ( !fReturnPacket )
    {
        if ( pPacket )
        {
            PacketFree( pPacket );

            pPacket = NULL;
        }
    }

    TRACE( TL_V, TM_Pk, ("-PacketNdis2Pppoe=$%x", pPacket) );

    return pPacket;

}



BOOLEAN 
PacketIsPPPoE(
    IN PPPOE_PACKET* pPacket
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function is used to understand if the received packet is a PPPoE
    packet or not. If it is then, it should be further processed, otherwise it 
    should be dropped.
             
Parameters:

    pPacket _ Pointer to a packet context prepared.

Return Values:

    Pointer to an initialized PPPoE packet context.
    
---------------------------------------------------------------------------*/   
{
    BOOLEAN fReturn = FALSE;

    TRACE( TL_V, TM_Pk, ("+PacketIsPPPoE") );

    do
    {

        //
        // Check packet ether type
        //
        if ( PacketGetEtherType( pPacket ) != PACKET_ETHERTYPE_DISCOVERY &&
             PacketGetEtherType( pPacket ) != PACKET_ETHERTYPE_PAYLOAD ) 
        {
            TRACE( TL_A, TM_Pk, ("PacketIsPPPoE: Unknown ether type") );

            break;
        }

        //
        // Check packet version
        //
        if ( PacketGetVersion( pPacket ) != PACKET_VERSION )
        {
            TRACE( TL_A, TM_Pk, ("PacketIsPPPoE: Unknown packet version") );

            break;
        }
            
        //
        // Check packet type
        //
        if ( PacketGetType( pPacket ) != PACKET_TYPE )
        {
            TRACE( TL_A, TM_Pk, ("PacketIsPPPoE: Unknown packet type") );

            break;
        }
    
        //
        // Make sure length does not exceed PACKET_GEN_MAX_LENGTH 
        //
        if ( PacketGetLength( pPacket ) > PACKET_GEN_MAX_LENGTH )
        {
            TRACE( TL_A, TM_Pk, ("PacketIsPPPoE: Packet larger than expected") );

            break;
        }

        fReturn = TRUE;
        
    } while ( FALSE );
    
    TRACE( TL_V, TM_Pk, ("-PacketIsPPPoE=$%d",fReturn) );

    return fReturn;
}

BOOLEAN
PacketFastIsPPPoE(
    IN CHAR* HeaderBuffer,
    IN UINT HeaderBufferSize
    )
{
    BOOLEAN fRet = FALSE;
    USHORT usEtherType;
    
    TRACE( TL_V, TM_Pk, ("+PacketFastIsPPPoE") );

    do
    {
    
        if ( HeaderBufferSize != ETHERNET_HEADER_LENGTH )
        {
            //
            // Header is not ethernet, so drop the packet
            //
            TRACE( TL_A, TM_Pk, ("PacketFastIsPPPoE: Bad packet header") );
        
            break;
        }

        //
        // Retrieve the ether type and see if packet of any interest to us
        //
        usEtherType = ntohs( * ( USHORT UNALIGNED * ) (HeaderBuffer + PPPOE_PACKET_ETHER_TYPE_OFFSET ) );

        if ( usEtherType == PACKET_ETHERTYPE_DISCOVERY ||
             usEtherType == PACKET_ETHERTYPE_PAYLOAD )
        {
            //
            // Valid ethertype, so accept the packet
            //
            fRet = TRUE;
        }

    } while ( FALSE );
    
    TRACE( TL_V, TM_Pk, ("-PacketFastIsPPPoE") );

    return fRet;
}
    
VOID
RetrieveErrorTags(
    IN PPPOE_PACKET* pPacket
    )
{
    USHORT tagLength = 0;
    CHAR* tagValue = NULL;


    TRACE( TL_V, TM_Pk, ("+RetrieveErrorTags") );

    RetrieveTag(    pPacket,
                    tagServiceNameError,
                    &tagLength,
                    &tagValue,
                    0,
                    NULL,
                    TRUE );

    if ( tagValue != NULL )
    {
        TRACE( TL_V, TM_Pk, ("RetrieveErrorTags: ServiceNameError tag received") );

        pPacket->ulFlags |= PCBF_ErrorTagReceived;
    }

    if ( !( pPacket->ulFlags & PCBF_ErrorTagReceived ) )
    {

        RetrieveTag(    pPacket,
                        tagACSystemError,
                        &tagLength,
                        &tagValue,
                        0,
                        NULL,
                        TRUE );

        if ( tagValue != NULL )
        {
            TRACE( TL_V, TM_Pk, ("RetrieveErrorTags: ACSystemError tag received") );
    
            pPacket->ulFlags |= PCBF_ErrorTagReceived;
        }

    }

    if ( !( pPacket->ulFlags & PCBF_ErrorTagReceived ) )
    {

        RetrieveTag(    pPacket,
                        tagGenericError,
                        &tagLength,
                        &tagValue,
                        0,
                        NULL,
                        TRUE );
    
        if ( tagValue != NULL )
        {
            TRACE( TL_V, TM_Pk, ("RetrieveErrorTags: GenericError tag received") );
    
            pPacket->ulFlags |= PCBF_ErrorTagReceived;
        }

    }


    TRACE( TL_V, TM_Pk, ("-RetrieveErrorTags") );

}

///////////////////////////////////////////////////////////////////////////
//
// Interface functions  (exposed outside)
//
///////////////////////////////////////////////////////////////////////////

VOID 
PacketPoolInit()
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function initializes or incements the ref count on the this module.

    Both miniport and protocol will call this function in their register routines
    to allocate packet pools. Only then they can call functions from this module.

    We create the packet pools if gl_ulNumPackets is 0, otherwise we just increment
    gl_ulNumPackets, and that reference will be removed when the caller calls
    PacketPoolUninit() later.

Parameters:

    None

Return Values:

    None
    
---------------------------------------------------------------------------*/   
{
    TRACE( TL_N, TM_Pk, ("+PacketPoolInit") );

    //
    // Make sure global lock is allocated 
    //
    if ( !gl_fPoolLockAllocated ) 
    {       
        TRACE( TL_N, TM_Pk, ("PacketPoolInit: First call, allocating global lock") );
        
        //
        // If global lock is not allocated, then this is the first call,
        // so allocate the spin lock
        //
        NdisAllocateSpinLock( &gl_lockPools );

        gl_fPoolLockAllocated = TRUE;
    }

    NdisAcquireSpinLock( &gl_lockPools );
        
    if ( gl_ulNumPackets == 0 )
    {
        PacketPoolAlloc();
    }

    gl_ulNumPackets++;
        
    NdisReleaseSpinLock( &gl_lockPools );

    TRACE( TL_N, TM_Pk, ("-PacketPoolInit") );

}

VOID 
PacketPoolUninit()
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function uninitializes or decrements the ref count on the this module.

    Both miniport and protocol will call this function when they are done with
    this module, and if ref count has dropped to 0, this function will deallocate
    the alloated pools.

Parameters:

    None

Return Values:

    None
    
---------------------------------------------------------------------------*/   
{
    TRACE( TL_N, TM_Pk, ("+PacketPoolUninit") );

    //
    // Make sure global lock is allocated 
    //
    if ( !gl_fPoolLockAllocated ) 
    {
        TRACE( TL_A, TM_Pk, ("PacketPoolUninit: Global not allocated yet") );

        TRACE( TL_N, TM_Pk, ("-PacketPoolUninit") );

        return;
    }

    NdisAcquireSpinLock( &gl_lockPools );

    gl_ulNumPackets--;
    
    if ( gl_ulNumPackets == 0 )
    {
        PacketPoolFree();
    }

    NdisReleaseSpinLock( &gl_lockPools );

    TRACE( TL_N, TM_Pk, ("-PacketPoolUninit") );

}

VOID 
PacketPoolAlloc()
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function wraps the initialization of buffers and packet pools.

    It is called from PacketPoolInit().
    
Parameters:

    None

Return Values:

    None
    
---------------------------------------------------------------------------*/   
{
    NDIS_STATUS status;

    TRACE( TL_N, TM_Pk, ("+PacketPoolAlloc") );

    //
    // Initialize our header pool
    //
    InitBufferPool( &gl_poolBuffers,
                    PPPOE_PACKET_BUFFER_SIZE,
                    0, 10, 0,
                    TRUE,
                    MTAG_BUFFERPOOL );

    //
    // Initialize our packet pool
    //
    InitPacketPool( &gl_poolPackets,
                    3 * sizeof( PVOID ), 0, 30, 0,
                    MTAG_PACKETPOOL );

    //
    // Initialize the Ndis Buffer Pool
    // No need to check for status, as DDK says, 
    // it always returns NDIS_STATUS_SUCCESS
    //
    NdisAllocateBufferPool( &status,
                            &gl_hNdisBufferPool,
                            30 );

    //
    // Initialize the control msg lookaside list
    //
    NdisInitializeNPagedLookasideList(
            &gl_llistPppoePackets,      // IN PNPAGED_LOOKASIDE_LIST  Lookaside,
            NULL,                       // IN PALLOCATE_FUNCTION  Allocate  OPTIONAL,
            NULL,                       // IN PFREE_FUNCTION  Free  OPTIONAL,
            0,                          // IN ULONG  Flags,
            sizeof(PPPOE_PACKET),       // IN ULONG  Size,
            MTAG_PPPOEPACKET,           // IN ULONG  Tag,
            0                           // IN USHORT  Depth
            );

    TRACE( TL_N, TM_Pk, ("-PacketPoolAlloc") );

 }

VOID 
PacketPoolFree()
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function wraps the clean up of buffers and packet pools.

    It is called from PacketPoolUninit() when gl_ulNumPackets reaches 0.
    
Parameters:

    None

Return Values:

    None
    
---------------------------------------------------------------------------*/
{

    TRACE( TL_N, TM_Pk, ("+PacketPoolFree") );

    FreeBufferPool( &gl_poolBuffers );

    FreePacketPool( &gl_poolPackets );

    NdisFreeBufferPool( &gl_hNdisBufferPool );

    NdisDeleteNPagedLookasideList( &gl_llistPppoePackets );

    TRACE( TL_N, TM_Pk, ("-PacketPoolFree") );

}
    
PPPOE_PACKET* 
PacketAlloc()
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function allocates a PPPoE packet context, but it does not create 
    the packet and buffer descriptors.
    
Parameters:

    None

Return Values:

    NULL or a pointer to a new PPPoE packet context.
    
---------------------------------------------------------------------------*/
{
    PPPOE_PACKET* pPacket = NULL;

    TRACE( TL_V, TM_Pk, ("+PacketAlloc") );

    do
    {
        //
        // Allocate a PppoePacket struct from the lookaside list
        //
        pPacket = (PPPOE_PACKET*) NdisAllocateFromNPagedLookasideList( &gl_llistPppoePackets );

        if ( pPacket == NULL )
            break;

        NdisAcquireSpinLock( &gl_lockPools );
        
        gl_ulNumPackets++;

        NdisReleaseSpinLock( &gl_lockPools );

        //
        // Initialize the contents of the PppoePacket that will be returned
        //
        NdisZeroMemory( pPacket, sizeof( PPPOE_PACKET ) );

        InitializeListHead( &pPacket->linkPackets );

        ReferencePacket( pPacket );

    } while ( FALSE );

    TRACE( TL_V, TM_Pk, ("-PacketAlloc=$%x",pPacket) );

    return pPacket;
}

VOID 
PacketFree(
    IN PPPOE_PACKET* pPacket
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function is called to free a packet, but the effect is just decrementing 
    the ref count on the object.
    
Parameters:

    pPacket _ A pointer to the packet to be freed.

Return Values:

    None
    
---------------------------------------------------------------------------*/   
{

    TRACE( TL_V, TM_Pk, ("+PacketFree") );

    ASSERT( pPacket != NULL );

    DereferencePacket( pPacket );

    TRACE( TL_V, TM_Pk, ("-PacketFree") );
}

NDIS_STATUS 
PacketInsertTag(
    IN  PPPOE_PACKET*   pPacket,
    IN  PACKET_TAGS     tagType,
    IN  USHORT          tagLength,
    IN  CHAR*           tagValue,
    OUT CHAR**          pNewTagValue    
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function is used to insert additional tags into a PPPoE packet.
    
Parameters:

    pPacket _ pPacket must be pointing to a packet that was processed using 
              one of the PacketInitialize*ToSend() functions.

Return Values:

    NDIS_STATUS_SUCCESS
    NDIS_STATUS_INVALID_PACKET
    
---------------------------------------------------------------------------*/   
{
    CHAR *pBuf = NULL;
    USHORT usMaxLength = PACKET_GEN_MAX_LENGTH;

    ASSERT( pPacket != NULL );

    TRACE( TL_V, TM_Pk, ("+PacketInsertTag") );

    //
    // Check for length restrictions
    //
    if ( PacketGetCode( pPacket ) == (USHORT) PACKET_CODE_PADI )
        usMaxLength = PACKET_PADI_MAX_LENGTH;

    if ( PacketGetLength( pPacket ) + PPPOE_TAG_HEADER_LENGTH + tagLength > usMaxLength )
    {
        TRACE( TL_A, TM_Pk, ("PacketInsertTag: Can not insert tag, exceeding max packet length") );

        TRACE( TL_V, TM_Pk, ("-PacketInsertTag") );

        return NDIS_STATUS_INVALID_PACKET;
    }

    //
    // Find the end of the payload
    //
    pBuf = pPacket->pPayload + PacketGetLength( pPacket );

    //
    // Insert the length - type - value triplet into the packet
    //
    *((USHORT UNALIGNED *) pBuf) = htons( tagType );
    ((USHORT*) pBuf)++;
    
    *((USHORT UNALIGNED *) pBuf) = htons( tagLength );
    ((USHORT*) pBuf)++;

    if ( tagLength > 0)
        NdisMoveMemory( pBuf, tagValue, tagLength );

    if ( pNewTagValue )
    {
        *pNewTagValue = pBuf;
    }

    //
    // Update the Length field
    //
    PacketSetLength( pPacket, ( PacketGetLength( pPacket ) + PPPOE_TAG_HEADER_LENGTH + tagLength ) ); 

    //
    // Adjust payload buffer length
    //
    NdisAdjustBufferLength( pPacket->pNdisBuffer, 
                            (UINT) PacketGetLength( pPacket ) + PPPOE_PACKET_HEADER_LENGTH );

    TRACE( TL_V, TM_Pk, ("-PacketInsertTag") );

    return NDIS_STATUS_SUCCESS;
}

NDIS_STATUS 
PacketInitializePADIToSend(
    OUT PPPOE_PACKET** ppPacket,
    IN USHORT        tagServiceNameLength,
    IN CHAR*         tagServiceNameValue,
    IN USHORT        tagHostUniqueLength,
    IN CHAR*         tagHostUniqueValue
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function is used to create a PADI packet to send.

    MANDATORY TAGS:
    ===============
    tagServiceName:
        tagServiceNameLength MUST be non-zero
        tagServiceNameValue  MUST be non-NULL

    OPTIONAL TAGS:
    ==============
    tagHostUnique:
        tagHostUniqueLength can be zero
        tagHostUniqueValue can be NULL
    
Parameters:

    ppPacket _ A pointer to a PPPoE packet context pointer.

    tagServiceNameLength _ Length of tagServiceNameValue blob.

    tagServiceNameValue _ A blob that holds a UTF-8 service name string.

    tagHostUniqueLength _ Length of tagHostUniqueValue blob.

    tagHostUniqueValue _ A blob that contains a unique value to identify a packet. 

Return Values:

    NDIS_STATUS_SUCCESS
    NDIS_STATUS_INVALID_PACKET
    NDIS_STATUS_RESOURCES
    
---------------------------------------------------------------------------*/   
{
    PPPOE_PACKET* pPacket = NULL;
    USHORT usLength = 0;
    NDIS_STATUS status;

    TRACE( TL_N, TM_Pk, ("+PacketInitializePADIToSend") );

    ASSERT( ppPacket != NULL );

    //
    // Check if we are safe with length restrictions
    //
    usLength =  tagServiceNameLength + 
                PPPOE_TAG_HEADER_LENGTH +
         
                tagHostUniqueLength + 
                ( (tagHostUniqueLength == 0) ? 0 : PPPOE_TAG_HEADER_LENGTH ) ;

    if ( usLength > PACKET_PADI_MAX_LENGTH )
    {
        TRACE( TL_A, TM_Pk, ("PacketInitializePADIToSend: Can not init PADI to send, exceeding max length") );

        TRACE( TL_N, TM_Pk, ("-PacketInitializePADIToSend=$%x",NDIS_STATUS_INVALID_PACKET) );

        return NDIS_STATUS_INVALID_PACKET;
    }

    pPacket = PacketCreateSimple();

    if ( pPacket == NULL )
    {
        TRACE( TL_A, TM_Pk, ("PacketInitializePADIToSend: Can not init PADI to send, resources unavailable") );

        TRACE( TL_N, TM_Pk, ("-PacketInitializePADIToSend=$%x",NDIS_STATUS_RESOURCES) );

        return NDIS_STATUS_RESOURCES;
    }
        
    //
    // General initialization that applies to all packet codes
    //
    InitializeListHead( &pPacket->linkPackets );

    PacketSetDestAddr( pPacket, EthernetBroadcastAddress );
    
    PacketSetEtherType( pPacket, PACKET_ETHERTYPE_DISCOVERY );

    PacketSetVersion( pPacket, PACKET_VERSION );

    PacketSetType( pPacket, PACKET_TYPE );

    PacketSetCode( pPacket, PACKET_CODE_PADI );

    PacketSetSessionId( pPacket, PACKET_NULL_SESSION );

    PacketSetLength( pPacket, 0 );

    pPacket->tagServiceNameLength = tagServiceNameLength;
    pPacket->tagServiceNameValue  = tagServiceNameValue;

    pPacket->tagHostUniqueLength = tagHostUniqueLength;
    pPacket->tagHostUniqueValue  = tagHostUniqueValue;

    status = PreparePacketForWire( pPacket );
    
    if ( status != NDIS_STATUS_SUCCESS )
    {
        TRACE( TL_A, TM_Pk, ("PacketInitializePADIToSend: PreparePacketForWire() failed:%x",status) );

        PacketFree( pPacket );
        
        pPacket = NULL;
    }

    *ppPacket = pPacket;

    TRACE( TL_N, TM_Pk, ("-PacketInitializePADIToSend=$%x",status) );
    
    return status;
}

NDIS_STATUS 
PacketInitializePADOToSend(
    IN  PPPOE_PACKET*   pPADI,
    OUT PPPOE_PACKET**  ppPacket,
    IN CHAR*            pSrcAddr,
    IN USHORT           tagServiceNameLength,
    IN CHAR*            tagServiceNameValue,
    IN USHORT           tagACNameLength,
    IN CHAR*            tagACNameValue,
    IN BOOLEAN          fInsertACCookieTag
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function is used to create a PADO packet to send as a reply to a received
    PADI packet.

    Note that a PADI packet does not contain the source address information as PADI
    is a broadcast packet. 

    MANDATORY TAGS:
    ===============
    tagServiceName: ()
        tagServiceNameLength MUST be non-zero
        tagServiceNameValue  MUST be non-NULL

    tagACName: 
        tagACNameNameLength MUST be non-zero
        tagACNameNameValue  MUST be non-NULL

    tagACCookie: (This is optional for RFC)
        tagACCookieLength can be zero
        tagACCookieValue can be NULL

    OPTIONAL TAGS:
    ==============
    tagHostUnique: (Obtained from PADI packet)
        tagHostUniqueLength can be zero
        tagHostUniqueValue can be NULL

    tagRelaySessionId: (Obtained from PADI packet)
        tagRelaySessionIdLength can be zero
        tagRelaySessionIdValue can be zero      
    
Parameters:

    pPADI _ Pointer to a PPPoE packet context holding a PADI packet.
    
    ppPacket _ A pointer to a PPPoE packet context pointer.

    pSrcAddr _ Source address for the PADO packet since we can not
               get it from the PADI packet.

    tagServiceNameLength _ Length of tagServiceNameValue blob.

    tagServiceNameValue _ A blob that holds a UTF-8 Service name string.

    tagACNameLength _ Length of tagACNameValue blob.

    tagACNameValue _ A blob that holds a UTF-8 AC name string.

    fInsertACCookieTag _ Indicates we we should also insert an AC Cookie
                         tag into the PADO packet.

Return Values:

    NDIS_STATUS_SUCCESS
    NDIS_STATUS_INVALID_PACKET
    NDIS_STATUS_RESOURCES
    
---------------------------------------------------------------------------*/
{
    PPPOE_PACKET* pPacket = NULL;
    USHORT usLength = 0;
    NDIS_STATUS status;
    CHAR tagACCookieValue[PPPOE_AC_COOKIE_TAG_LENGTH];
    BOOLEAN fCopyServiceNameTag = FALSE;

    TRACE( TL_N, TM_Pk, ("+PacketInitializePADOToSend") );

    ASSERT( pPADI != NULL );
    ASSERT( ppPacket != NULL );

    //
    // Check if we are safe with length restrictions
    //
    usLength =  tagServiceNameLength +
                PPPOE_TAG_HEADER_LENGTH +

                pPADI->tagHostUniqueLength + 
                ( (pPADI->tagHostUniqueLength == 0) ? 0 : PPPOE_TAG_HEADER_LENGTH ) +

                pPADI->tagRelaySessionIdLength + 
                ( (pPADI->tagRelaySessionIdLength == 0) ? 0 : PPPOE_TAG_HEADER_LENGTH ) +

                tagACNameLength + 
                PPPOE_TAG_HEADER_LENGTH +

                ( fInsertACCookieTag ? ( PPPOE_AC_COOKIE_TAG_LENGTH + PPPOE_TAG_HEADER_LENGTH ) : 0 );

    if ( usLength > PACKET_GEN_MAX_LENGTH )
    {
        TRACE( TL_A, TM_Pk, ("PacketInitializePADOToSend: Can not init PADO to send, exceeding max length") );

        TRACE( TL_N, TM_Pk, ("-PacketInitializePADOToSend=$%x",NDIS_STATUS_INVALID_PACKET) );

        return NDIS_STATUS_INVALID_PACKET;
    }

    pPacket = PacketCreateSimple();
    
    if ( pPacket == NULL )
    {
        TRACE( TL_A, TM_Pk, ("PacketInitializePADOToSend: Can not init PADO to send, resources unavailable") );

        TRACE( TL_N, TM_Pk, ("-PacketInitializePADOToSend=$%x",NDIS_STATUS_RESOURCES) );

        return NDIS_STATUS_RESOURCES;
    }
        
    //
    // General initialization that applies to all packet codes
    //
    InitializeListHead( &pPacket->linkPackets );

    PacketSetDestAddr( pPacket, PacketGetSrcAddr( pPADI ) );

    PacketSetSrcAddr( pPacket, pSrcAddr );
    
    PacketSetEtherType( pPacket, PACKET_ETHERTYPE_DISCOVERY );

    PacketSetVersion( pPacket, PACKET_VERSION );

    PacketSetType( pPacket, PACKET_TYPE );

    PacketSetCode( pPacket, PACKET_CODE_PADO );

    PacketSetSessionId( pPacket, PACKET_NULL_SESSION );

    PacketSetLength( pPacket, 0 );

    pPacket->tagServiceNameLength = tagServiceNameLength;
    pPacket->tagServiceNameValue  = tagServiceNameValue;

    pPacket->tagHostUniqueLength = pPADI->tagHostUniqueLength;
    pPacket->tagHostUniqueValue  = pPADI->tagHostUniqueValue;

    pPacket->tagRelaySessionIdLength = pPADI->tagRelaySessionIdLength;
    pPacket->tagRelaySessionIdValue  = pPADI->tagRelaySessionIdValue;

    pPacket->tagACNameLength = tagACNameLength;
    pPacket->tagACNameValue  = tagACNameValue;

    if ( fInsertACCookieTag )
    {
        PacketGenerateACCookieTag( pPADI, tagACCookieValue );
        
        pPacket->tagACCookieLength = PPPOE_AC_COOKIE_TAG_LENGTH;
        pPacket->tagACCookieValue  = tagACCookieValue;
    }
    
    status = PreparePacketForWire( pPacket );
    
    if ( status != NDIS_STATUS_SUCCESS )
    {
        TRACE( TL_A, TM_Pk, ("PacketInitializePADOToSend: PreparePacketForWire() failed:%x",status) );

        PacketFree( pPacket );
        
        pPacket = NULL;
    }

    *ppPacket = pPacket;

    TRACE( TL_N, TM_Pk, ("-PacketInitializePADOToSend=$%x",status) );
    
    return status;
}

NDIS_STATUS 
PacketInitializePADRToSend(
    IN PPPOE_PACKET*    pPADO,
    OUT PPPOE_PACKET**  ppPacket,
    IN USHORT           tagServiceNameLength,
    IN CHAR*            tagServiceNameValue,
    IN USHORT           tagHostUniqueLength,
    IN CHAR*            tagHostUniqueValue
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function is used to create a PADR packet to send as a reply to a received
    PADO packet.

    MANDATORY TAGS:
    ===============
    tagServiceName: 
        tagServiceNameLength MUST be non-zero
        tagServiceNameValue  MUST be non-NULL

    OPTIONAL TAGS:
    ==============
    tagHostUnique: 
        tagHostUniqueLength can be zero
        tagHostUniqueValue can be NULL

    tagACCookie: (Obtained from PADI packet)
        tagHostUniqueLength can be zero
        tagHostUniqueValue can be NULL

    tagRelaySessionId: (Obtained from PADI packet)
        tagRelaySessionIdLength can be zero
        tagRelaySessionIdValue can be NULL      
    
Parameters:

    pPADO _ Pointer to a PPPoE packet context holding a PADO packet.
    
    ppPacket _ A pointer to a PPPoE packet context pointer.

    tagServiceNameLength _ Length of tagServiceNameValue blob.

    tagServiceNameValue _ A blob that holds a UTF-8 service name string.

    tagHostUniqueLength _ Length of tagHostUniqueValue blob.

    tagHostUniqueValue _ A blob that contains a unique value to identify a packet. 

Return Values:

    NDIS_STATUS_SUCCESS
    NDIS_STATUS_INVALID_PACKET
    NDIS_STATUS_RESOURCES
    
---------------------------------------------------------------------------*/
{
    PPPOE_PACKET* pPacket = NULL;
    USHORT usLength = 0;
    NDIS_STATUS status;

    TRACE( TL_N, TM_Pk, ("+PacketInitializePADRToSend") );

    ASSERT( pPADO != NULL );
    ASSERT( ppPacket != NULL );

    //
    // Check if we are safe with length restrictions
    //
    usLength =  tagServiceNameLength + 
                PPPOE_TAG_HEADER_LENGTH +

                tagHostUniqueLength + 
                ( (tagHostUniqueLength == 0) ? 0 : PPPOE_TAG_HEADER_LENGTH ) +

                pPADO->tagRelaySessionIdLength + 
                ( (pPADO->tagRelaySessionIdLength == 0) ? 0 : PPPOE_TAG_HEADER_LENGTH ) +

                pPADO->tagACCookieLength + 
                ( (pPADO->tagACCookieLength == 0) ? 0 : PPPOE_TAG_HEADER_LENGTH ) ;


    if ( usLength > PACKET_GEN_MAX_LENGTH )
    {
        TRACE( TL_A, TM_Pk, ("PacketInitializePADRToSend: Can not init PADR to send, exceeding max length") );

        TRACE( TL_N, TM_Pk, ("-PacketInitializePADRToSend=$%x",NDIS_STATUS_INVALID_PACKET) );

        return NDIS_STATUS_INVALID_PACKET;
    }

    pPacket = PacketCreateSimple();
    
    if ( pPacket == NULL )
    {
        TRACE( TL_A, TM_Pk, ("PacketInitializePADRToSend: Can not init PADR to send, resources unavailable") );

        TRACE( TL_N, TM_Pk, ("-PacketInitializePADRToSend=$%x",NDIS_STATUS_RESOURCES) );

        return NDIS_STATUS_RESOURCES;
    }

    //
    // General initialization that applies to all packet codes
    //
    InitializeListHead( &pPacket->linkPackets );

    PacketSetSrcAddr( pPacket, PacketGetDestAddr( pPADO ) );
    
    PacketSetDestAddr( pPacket, PacketGetSrcAddr( pPADO ) );
    
    PacketSetEtherType( pPacket, PACKET_ETHERTYPE_DISCOVERY );

    PacketSetVersion( pPacket, PACKET_VERSION );

    PacketSetType( pPacket, PACKET_TYPE );

    PacketSetCode( pPacket, PACKET_CODE_PADR );

    PacketSetSessionId( pPacket, PACKET_NULL_SESSION );

    PacketSetLength( pPacket, 0 );

    pPacket->tagServiceNameLength = tagServiceNameLength;
    pPacket->tagServiceNameValue  = tagServiceNameValue;

    pPacket->tagHostUniqueLength = tagHostUniqueLength;
    pPacket->tagHostUniqueValue  = tagHostUniqueValue;

    pPacket->tagRelaySessionIdLength = pPADO->tagRelaySessionIdLength;
    pPacket->tagRelaySessionIdValue  = pPADO->tagRelaySessionIdValue;

    pPacket->tagACCookieLength = pPADO->tagACCookieLength;
    pPacket->tagACCookieValue  = pPADO->tagACCookieValue;

    status = PreparePacketForWire( pPacket );
    
    if ( status != NDIS_STATUS_SUCCESS )
    {
        TRACE( TL_A, TM_Pk, ("PacketInitializePADRToSend: PreparePacketForWire() failed:%x",status) );
        
        PacketFree( pPacket );
        
        pPacket = NULL;
    }

    *ppPacket = pPacket;
    
    TRACE( TL_N, TM_Pk, ("-PacketInitializePADRToSend=$%x",status) );

    return status;
}

//
// This function is used to prepare a PADS packet for a received PADR packet.
// 
// The PADR packet must be processed using PREPARE_PACKET_FROM_WIRE() macro
// before feeding into this function.
//
// The PADS packet should just be a packet without and associated VCs or linked lists.
//
// If you want to insert other tags to a PADI, PADO, or PADS packet, use specific 
// PacketInsertTag() function after calling this function.
//
// MANDATORY TAGS:
// ===============
//  tagServiceName:
//      tagServiceNameLength MUST be non-zero
//      tagServiceNameValue  MUST be non-NULL
//
// OPTIONAL TAGS:
// ==============
//  tagHostUnique: 
//      tagHostUniqueLength can be zero
//      tagHostUniqueValue can be zero
//
//  tagRelaySessionId: (Obtained from PADI packet)
//      tagRelaySessionIdLength can be zero
//      tagRelaySessionIdValue can be zero
//
NDIS_STATUS 
PacketInitializePADSToSend(
    IN PPPOE_PACKET*    pPADR,
    OUT PPPOE_PACKET**  ppPacket,
    IN USHORT           usSessionId
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function is used to create a PADR packet to send as a reply to a received
    PADO packet.

    MANDATORY TAGS:
    ===============
    tagServiceName: (Obtained from PADR packet)
        tagServiceNameLength MUST be non-zero
        tagServiceNameValue  MUST be non-NULL

    OPTIONAL TAGS:
    ==============
    tagHostUnique: (Obtained from PADR packet)
        tagHostUniqueLength can be zero
        tagHostUniqueValue can be NULL

    tagRelaySessionId: (Obtained from PADR packet)
        tagRelaySessionIdLength can be zero
        tagRelaySessionIdValue can be NULL      
    
Parameters:

    pPADR _ Pointer to a PPPoE packet context holding a PADR packet.
    
    ppPacket _ A pointer to a PPPoE packet context pointer.

    usSessionId _ Session id assigned to this session
    
Return Values:

    NDIS_STATUS_SUCCESS
    NDIS_STATUS_INVALID_PACKET
    NDIS_STATUS_RESOURCES
    
---------------------------------------------------------------------------*/   
{
    PPPOE_PACKET* pPacket = NULL;

    USHORT usLength;
    NDIS_STATUS status;

    TRACE( TL_N, TM_Pk, ("+PacketInitializePADSToSend") );

    ASSERT( pPADR != NULL );
    ASSERT( ppPacket != NULL );

    //
    // Check if we are safe with length restrictions
    //
    usLength =  pPADR->tagServiceNameLength + 
                PPPOE_TAG_HEADER_LENGTH +

                pPADR->tagHostUniqueLength + 
                ( (pPADR->tagHostUniqueLength == 0) ? 0 : PPPOE_TAG_HEADER_LENGTH )+

                pPADR->tagRelaySessionIdLength + 
                ( (pPADR->tagRelaySessionIdLength == 0) ? 0 : PPPOE_TAG_HEADER_LENGTH ); 

    if ( usLength > PACKET_GEN_MAX_LENGTH )
    {
        TRACE( TL_A, TM_Pk, ("PacketInitializePADSToSend: Can not init PADS to send, exceeding max length") );

        TRACE( TL_N, TM_Pk, ("-PacketInitializePADSToSend=$%x",NDIS_STATUS_INVALID_PACKET) );

        return NDIS_STATUS_INVALID_PACKET;
    }

    pPacket = PacketCreateSimple();
    
    if ( pPacket == NULL )
    {
        TRACE( TL_A, TM_Pk, ("PacketInitializePADSToSend: Can not init PADS to send, resources unavailable") );

        TRACE( TL_N, TM_Pk, ("-PacketInitializePADSToSend=$%x",NDIS_STATUS_RESOURCES) );

        return NDIS_STATUS_RESOURCES;
    }

    //
    // General initialization that applies to all packet codes
    //
    InitializeListHead( &pPacket->linkPackets );

    PacketSetSrcAddr( pPacket, PacketGetDestAddr( pPADR ) );

    PacketSetDestAddr( pPacket, PacketGetSrcAddr( pPADR ) );
    
    PacketSetEtherType( pPacket, PACKET_ETHERTYPE_DISCOVERY );

    PacketSetVersion( pPacket, PACKET_VERSION );

    PacketSetType( pPacket, PACKET_TYPE );

    PacketSetCode( pPacket, PACKET_CODE_PADS );

    PacketSetSessionId( pPacket, usSessionId );

    PacketSetLength( pPacket, 0 );

    pPacket->tagServiceNameLength = pPADR->tagServiceNameLength;
    pPacket->tagServiceNameValue  = pPADR->tagServiceNameValue;

    pPacket->tagHostUniqueLength = pPADR->tagHostUniqueLength;
    pPacket->tagHostUniqueValue  = pPADR->tagHostUniqueValue;

    pPacket->tagRelaySessionIdLength = pPADR->tagRelaySessionIdLength;
    pPacket->tagRelaySessionIdValue  = pPADR->tagRelaySessionIdValue;

    status = PreparePacketForWire( pPacket );
    
    if ( status != NDIS_STATUS_SUCCESS )
    {
        TRACE( TL_A, TM_Pk, ("PacketInitializePADSToSend: PreparePacketForWire() failed:%x",status) );
        
        PacketFree( pPacket );
        
        pPacket = NULL;
    }

    *ppPacket = pPacket;
    
    TRACE( TL_N, TM_Pk, ("-PacketInitializePADSToSend=$%x",status) );

    return status;
}

NDIS_STATUS 
PacketInitializePADTToSend(
    OUT PPPOE_PACKET** ppPacket,
    IN CHAR* pSrcAddr, 
    IN CHAR* pDestAddr,
    IN USHORT usSessionId
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function is used to create a PADT packet to send to disconnect a session.

    If you want to send additional tags (like error tags), use the PacketInsertTag() 
    function.   

    MANDATORY TAGS:
    ===============
        None
        
    OPTIONAL TAGS:
    ==============
        None
    
Parameters:

    ppPacket _ A pointer to a PPPoE packet context pointer.

    pSrcAddr _ Buffer pointing to the source MAC addr of length 6

    pDestAddr _ Buffer pointing to the dest MAC addr of length 6
    
    usSessionId _ Session id assigned to this session
    
Return Values:

    NDIS_STATUS_SUCCESS
    NDIS_STATUS_INVALID_PACKET
    NDIS_STATUS_RESOURCES
    
---------------------------------------------------------------------------*/   
{
    PPPOE_PACKET* pPacket = NULL;
    USHORT usLength;
    NDIS_STATUS status;

    TRACE( TL_N, TM_Pk, ("+PacketInitializePADTToSend") );

    ASSERT( ppPacket != NULL );
    ASSERT( pDestAddr != NULL );

    pPacket = PacketCreateSimple();
    
    if ( pPacket == NULL )
    {
        TRACE( TL_A, TM_Pk, ("PacketInitializePADTToSend: Can not init PADT to send, resources unavailable") );

        TRACE( TL_N, TM_Pk, ("-PacketInitializePADTToSend=$%x",NDIS_STATUS_RESOURCES) );

        return NDIS_STATUS_RESOURCES;
    }

    //
    // General initialization that applies to all packet codes
    //
    InitializeListHead( &pPacket->linkPackets );

    PacketSetSrcAddr( pPacket, pSrcAddr );

    PacketSetDestAddr( pPacket, pDestAddr );
    
    PacketSetEtherType( pPacket, PACKET_ETHERTYPE_DISCOVERY );

    PacketSetVersion( pPacket, PACKET_VERSION );

    PacketSetType( pPacket, PACKET_TYPE );

    PacketSetCode( pPacket, PACKET_CODE_PADT );

    PacketSetSessionId( pPacket, usSessionId );

    PacketSetLength( pPacket, 0 );


    status = PreparePacketForWire( pPacket );
    
    if ( status != NDIS_STATUS_SUCCESS )
    {
        TRACE( TL_A, TM_Pk, ("PacketInitializePADTToSend: PreparePacketForWire() failed:%x",status) );

        PacketFree( pPacket );

        pPacket = NULL;
    }

    *ppPacket = pPacket;

    TRACE( TL_N, TM_Pk, ("-PacketInitializePADTToSend=$%x",status) );
    
    return status;
}

NDIS_STATUS 
PacketInitializePAYLOADToSend(
    OUT PPPOE_PACKET** ppPacket,
    IN CHAR* pSrcAddr,
    IN CHAR* pDestAddr,
    IN USHORT usSessionId,
    IN NDIS_WAN_PACKET* pWanPacket,
    IN PADAPTER MiniportAdapter
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function is used to create a PAYLOAD packet to send.

    If you want to send additional tags (like error tags), use the PacketInsertTag() 
    function.   

    MANDATORY TAGS:
    ===============
        None
        
    OPTIONAL TAGS:
    ==============
        None
    
Parameters:

    ppPacket _ A pointer to a PPPoE packet context pointer.

    pSrcAddr _ Buffer pointing to the source MAC addr of length 6

    pDestAddr _ Buffer pointing to the dest MAC addr of length 6
    
    usSessionId _ Session id assigned to this session

    pWanPacket _ Pointer to an NDISWAN packet

    MiniportAdapter _ This is the pointer to the miniport adapter.
                      It is used to indicate the completion of async sends back
                      to Ndiswan.
Return Values:

    NDIS_STATUS_SUCCESS
    NDIS_STATUS_INVALID_PACKET
    NDIS_STATUS_RESOURCES
    
---------------------------------------------------------------------------*/   
{
    NDIS_STATUS status = NDIS_STATUS_SUCCESS;
    PPPOE_PACKET* pPacket = NULL;
    USHORT usLength = 0;
    UINT Length;

    TRACE( TL_V, TM_Pk, ("+PacketInitializePAYLOADToSend") );

    ASSERT( ppPacket != NULL );
    ASSERT( pDestAddr != NULL );
    ASSERT( pWanPacket != NULL );

    //
    // Validate NDISWAN packet
    //
    if ( pWanPacket->CurrentLength > PACKET_GEN_MAX_LENGTH )
    {
        TRACE( TL_A, TM_Pk, ("PacketInitializePAYLOADToSend: Can not init PAYLOAD to send, exceeding max length") );

        TRACE( TL_V, TM_Pk, ("-PacketInitializePAYLOADToSend=$%x",NDIS_STATUS_INVALID_PACKET) );

        return NDIS_STATUS_INVALID_PACKET;
    }

    if ( ( pWanPacket->CurrentBuffer - pWanPacket->StartBuffer ) < PPPOE_PACKET_HEADER_LENGTH )
    {
        TRACE( TL_A, TM_Pk, ("PacketInitializePAYLOADToSend: Can not init PAYLOAD to send, not enough front padding") );

        TRACE( TL_V, TM_Pk, ("-PacketInitializePAYLOADToSend=$%x",NDIS_STATUS_INVALID_PACKET) );

        return NDIS_STATUS_INVALID_PACKET;
    }

    //
    // Allocate a packet
    //
    pPacket = PacketAlloc();

    if ( pPacket == NULL )
    {
        TRACE( TL_A, TM_Pk, ("PacketInitializePAYLOADToSend: Can not init PAYLOAD to send, resources unavailable") );

        TRACE( TL_V, TM_Pk, ("-PacketInitializePAYLOADToSend=$%x",NDIS_STATUS_RESOURCES) );

        return NDIS_STATUS_RESOURCES;
    }

    //
    // Allocate NdisBuffer
    //
    //
    // NOTE : Using (pWanPacket->CurrentBuffer - PPPOE_PACKET_HEADER_LENGTH) instead of
    //        pWanPacket->StartBuffer directly gives us the flexibility of handling packets
    //        with different header padding values.
    //
    NdisAllocateBuffer( &status,
                        &pPacket->pNdisBuffer,
                        gl_hNdisBufferPool,
                        pWanPacket->CurrentBuffer - PPPOE_PACKET_HEADER_LENGTH,
                        (UINT) ( PPPOE_PACKET_HEADER_LENGTH + pWanPacket->CurrentLength ) );

    if ( status != NDIS_STATUS_SUCCESS )
    {
        TRACE( TL_A, TM_Pk, ("PacketInitializePAYLOADToSend: NdisAllocateBuffer() failed") );

        PacketFree( pPacket );

        TRACE( TL_V, TM_Pk, ("-PacketInitializePAYLOADToSend=$%x",status) );

        return status;
    }

    pPacket->ulFlags |= PCBF_BufferAllocatedFromNdisBufferPool;

    //
    // Query new buffer descriptor to get hold of the real memory pointer
    //
    pPacket->pHeader = NULL;
    
    NdisQueryBufferSafe( pPacket->pNdisBuffer,
                         &pPacket->pHeader,
                         &Length,
                         NormalPagePriority );

    if ( pPacket->pHeader == NULL )
    {
        
        TRACE( TL_A, TM_Pk, ("PacketInitializePAYLOADToSend: NdisQueryBufferSafe() failed") );

        PacketFree( pPacket );

        TRACE( TL_V, TM_Pk, ("-PacketInitializePAYLOADToSend=$%x",status) );

        return NDIS_STATUS_RESOURCES;
    }

    //
    // Allocate an NDIS packet from our pool
    //
    pPacket->pNdisPacket = GetPacketFromPool( &gl_poolPackets, &pPacket->pPacketHead );

    if ( pPacket->pNdisPacket == NULL ) 
    {
        
        TRACE( TL_A, TM_Pk, ("PacketInitializePAYLOADToSend: GetPacketFromPool() failed") );
        
        PacketFree( pPacket );

        TRACE( TL_V, TM_Pk, ("-PacketInitializePAYLOADToSend=$%x",status) );

        return NDIS_STATUS_RESOURCES;
    }

    pPacket->ulFlags |= PCBF_PacketAllocatedFromOurPacketPool;

    //
    // Chain buffer to packet
    //
    NdisChainBufferAtFront( pPacket->pNdisPacket, pPacket->pNdisBuffer );

    pPacket->ulFlags |= PCBF_BufferChainedToPacket;

    //
    // Set the payload and payload length
    //
    pPacket->pPayload = pPacket->pHeader + PPPOE_PACKET_HEADER_LENGTH; 

    usLength = (USHORT) pWanPacket->CurrentLength;

    //
    // General initialization that applies to all packet codes
    //
    InitializeListHead( &pPacket->linkPackets );

    PacketSetDestAddr( pPacket, pDestAddr );

    PacketSetSrcAddr( pPacket, pSrcAddr );
    
    PacketSetEtherType( pPacket, PACKET_ETHERTYPE_PAYLOAD );

    PacketSetVersion( pPacket, PACKET_VERSION );

    PacketSetType( pPacket, PACKET_TYPE );

    PacketSetCode( pPacket, PACKET_CODE_PAYLOAD );

    PacketSetSessionId( pPacket, usSessionId );

    PacketSetLength( pPacket, usLength );

    //
    // Set the input NDIS_PACKET to the reserved area so that we can reach it
    // when we have to return this packet back to the upper layer.
    //
    *((PPPOE_PACKET UNALIGNED**)(&pPacket->pNdisPacket->ProtocolReserved[0 * sizeof(PVOID)])) = pPacket;
    *((NDIS_WAN_PACKET UNALIGNED**)(&pPacket->pNdisPacket->ProtocolReserved[1 * sizeof(PVOID)])) = pWanPacket;
    *((ADAPTER UNALIGNED **)(&pPacket->pNdisPacket->ProtocolReserved[2 * sizeof(PVOID)])) = MiniportAdapter;

    status = PreparePacketForWire( pPacket );
    
    if ( status != NDIS_STATUS_SUCCESS )
    {
        TRACE( TL_A, TM_Pk, ("PacketInitializePAYLOADToSend: PreparePacketForWire() failed") );

        PacketFree( pPacket );

        TRACE( TL_V, TM_Pk, ("-PacketInitializePAYLOADToSend=$%x",status) );
        
        return status;
    }

    //
    // This must be done here as we do not want to call NdisMWanSendComplete() in PacketFree() if the 
    // PreparePacketForWire() fails.
    //
    pPacket->ulFlags |= PCBF_CallNdisMWanSendComplete;

    MpPacketOwnedByNdiswanReceived( MiniportAdapter );

    *ppPacket = pPacket;
    
    TRACE( TL_V, TM_Pk, ("-PacketInitializePAYLOADToSend=$%x",status) );

    return status;
}

NDIS_STATUS 
PacketInitializeFromReceived(
    IN PPPOE_PACKET* pPacket
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function prepares a PPPoE packet by using the Ndis packet from wire.

    This function will make sure that the packet is a PPPoE packet, and convert
    it to a PPPoE packet context. It tries to do this as efficiently as possible
    by trying to use the buffers of the received packet if possible.

    It will also do all the validation in the packet to make sure it is 
    compliant with the RFC. However, it can not perform the checks that need data 
    from a sent packet. Caller must use various PacketRetrieve*() functions to 
    retrieve the necesarry data and use it to match and validate to a sent packet.
    
Parameters:

    pPacket _ Pointer to a PPPoE packet context. 

Return Values:

    NDIS_STATUS_SUCCESS
    NDIS_STATUS_RESOURCES
    NDIS_STATUS_INVALID_PACKET
    
---------------------------------------------------------------------------*/   
{
    NDIS_STATUS status;

    ASSERT( pPacket != NULL );

    TRACE( TL_V, TM_Pk, ("+PacketInitializeFromReceived") );
    
    if ( !PacketIsPPPoE( pPacket ) )
    {
        status = NDIS_STATUS_INVALID_PACKET;
        
        TRACE( TL_V, TM_Pk, ("-PacketInitializeFromReceived=$%x",status) );
        
        return status;
    }

    do 
    {
        status = NDIS_STATUS_INVALID_PACKET;
        
        //
        // Validate the tag lenghts inside the packet so that we do not 
        // step outside buffer boundaries further processing the packet.
        // Do this only if the packet is not a payload packet!
        //
        if ( PacketGetCode( pPacket ) != PACKET_CODE_PAYLOAD )
        {
            CHAR* pBufStart;
            CHAR* pBufEnd;
            USHORT tagLength;
    
            pBufStart = pPacket->pPayload;
            pBufEnd = pPacket->pPayload + PacketGetLength( pPacket );
        
            while ( pBufStart + PPPOE_TAG_HEADER_LENGTH <= pBufEnd )
            {
                //
                // Skip the tag type field
                //
                ((USHORT*) pBufStart)++;
        
                //
                // Retrieve the tag length, and look at the next tag
                //
                tagLength = ntohs( *((USHORT UNALIGNED *) pBufStart) ) ;
                ((USHORT*) pBufStart)++;
                
                pBufStart += tagLength;
        
            } 
    
            if ( pBufStart != pBufEnd )
                break;          
        }

        status = NDIS_STATUS_SUCCESS;
        
    } while ( FALSE );

    if ( status != NDIS_STATUS_SUCCESS )
    {
        TRACE( TL_A, TM_Pk, ("PacketInitializeFromReceived: Corrupt packet - invalid tags") );
        
        TRACE( TL_V, TM_Pk, ("-PacketInitializeFromReceived=$%x",status) );
        
        return status;
    }
    
    switch ( PacketGetCode( pPacket ) )
    {
        USHORT tagLength;
        CHAR*  tagValue;    
    
        status = NDIS_STATUS_INVALID_PACKET;

        case PACKET_CODE_PADI:

            TRACE( TL_N, TM_Pk, ("PacketInitializeFromReceived: Processing PADI") );

            //
            // Make sure we have received the correct ethertype
            //
            if ( PacketGetEtherType( pPacket ) != PACKET_ETHERTYPE_DISCOVERY )
            {
                TRACE( TL_A, TM_Pk, ("PacketInitializeFromReceived: Invalid ether type") );

                break;
            }

            //
            // Make sure session id is PACKET_NULL_SESSION
            //
            if ( PacketGetSessionId( pPacket ) != PACKET_NULL_SESSION )
            {
                TRACE( TL_A, TM_Pk, ("PacketInitializeFromReceived: Invalid session id") );
                
                break;
            }

            //
            // Extract mandatory tags first
            //
            RetrieveTag(    pPacket,
                            tagServiceName,
                            &tagLength,
                            &tagValue,
                            0,
                            NULL,
                            TRUE );

            if ( tagValue == NULL )
            {
                TRACE( TL_A, TM_Pk, ("PacketInitializeFromReceived: Service name tag not found") );
                
                break;
            }

            //
            // Extract optional tags
            //
            RetrieveTag(    pPacket,
                            tagHostUnique,
                            &tagLength,
                            &tagValue,
                            0,
                            NULL,
                            TRUE );

            //
            // Extract the relay session id tag if it exists
            //
            RetrieveTag(    pPacket,
                            tagRelaySessionId,
                            &tagLength,
                            &tagValue,
                            0,
                            NULL,
                            TRUE );

            TRACE( TL_N, TM_Pk, ("PacketInitializeFromReceived: Processed PADI succesfully") );

            status = NDIS_STATUS_SUCCESS;

            break;
                                
        case PACKET_CODE_PADO:

            TRACE( TL_N, TM_Pk, ("PacketInitializeFromReceived: Processing PADO") );

            //
            // Make sure we have received the correct ethertype
            //
            if ( PacketGetEtherType( pPacket ) != PACKET_ETHERTYPE_DISCOVERY )
            {
                TRACE( TL_A, TM_Pk, ("PacketInitializeFromReceived: Invalid ether type") );

                break;
            }

            //
            // Make sure session id is PACKET_NULL_SESSION
            //
            if ( PacketGetSessionId( pPacket ) != PACKET_NULL_SESSION )
            {
                TRACE( TL_A, TM_Pk, ("PacketInitializeFromReceived: Invalid session id") );
                
                break;
            }

            //
            // Extract mandatory tags first
            //
            RetrieveTag(    pPacket,
                            tagServiceName,
                            &tagLength,
                            &tagValue,
                            0,
                            NULL,
                            TRUE );

            if ( tagValue == NULL )
            {
                TRACE( TL_A, TM_Pk, ("PacketInitializeFromReceived: Service name tag not found") );
                
                break;
            }
            
            RetrieveTag(    pPacket,
                            tagACName,
                            &tagLength,
                            &tagValue,
                            0,
                            NULL,
                            TRUE );

            if ( tagValue == NULL )
            {
                TRACE( TL_A, TM_Pk, ("PacketInitializeFromReceived: AC-Name tag not found") );
                
                break;
            }
            
            //
            // Extract optional tags
            //
            RetrieveTag(    pPacket,
                            tagHostUnique,
                            &tagLength,
                            &tagValue,
                            0,
                            NULL,
                            TRUE );

            RetrieveTag(    pPacket,
                            tagACCookie,
                            &tagLength,
                            &tagValue,
                            0,
                            NULL,
                            TRUE );
                                
            //
            // Extract the relay session id tag if it exists
            //
            RetrieveTag(    pPacket,
                            tagRelaySessionId,
                            &tagLength,
                            &tagValue,
                            0,
                            NULL,
                            TRUE );

            TRACE( TL_N, TM_Pk, ("PacketInitializeFromReceived: Processed PADO succesfully") );
            
            status = NDIS_STATUS_SUCCESS;
            
            break;

        case PACKET_CODE_PADR:
        
            TRACE( TL_N, TM_Pk, ("PacketInitializeFromReceived: Processing PADR") );
            
            //
            // Make sure we have received the correct ethertype
            //
            if ( PacketGetEtherType( pPacket ) != PACKET_ETHERTYPE_DISCOVERY )
            {
                TRACE( TL_A, TM_Pk, ("PacketInitializeFromReceived: Invalid ether type") );

                break;
            }
            
            //
            // Make sure session id is PACKET_NULL_SESSION
            //
            if ( PacketGetSessionId( pPacket ) != PACKET_NULL_SESSION )
            {
                TRACE( TL_A, TM_Pk, ("PacketInitializeFromReceived: Invalid session id") );
                
                break;
            }
            
            //
            // Extract mandatory tags first
            //
            RetrieveTag(    pPacket,
                            tagServiceName,
                            &tagLength,
                            &tagValue,
                            0,
                            NULL,
                            TRUE );

            if ( tagValue == NULL )
            {
                TRACE( TL_A, TM_Pk, ("PacketInitializeFromReceived: Service name tag not found") );
                
                break;
            }
        
            //
            // Extract optional tags
            //
            RetrieveTag(    pPacket,
                            tagHostUnique,
                            &tagLength,
                            &tagValue,
                            0,
                            NULL,
                            TRUE );

            RetrieveTag(    pPacket,
                            tagACCookie,
                            &tagLength,
                            &tagValue,
                            0,
                            NULL,
                            TRUE );

            //
            // Extract the relay session id tag if it exists
            //
            RetrieveTag(    pPacket,
                            tagRelaySessionId,
                            &tagLength,
                            &tagValue,
                            0,
                            NULL,
                            TRUE );

            TRACE( TL_N, TM_Pk, ("PacketInitializeFromReceived: Processed PADR succesfully") );

            status = NDIS_STATUS_SUCCESS;
            
            break;

        case PACKET_CODE_PADS:

            TRACE( TL_N, TM_Pk, ("PacketInitializeFromReceived: Processing PADS") );

            //
            // Make sure we have received the correct ethertype
            //
            if ( PacketGetEtherType( pPacket ) != PACKET_ETHERTYPE_DISCOVERY )
            {
                TRACE( TL_A, TM_Pk, ("PacketInitializeFromReceived: Invalid ether type") );

                break;
            }
            
            //
            // Make sure session id is NOT PACKET_NULL_SESSION.
            // However, if session id is PACKET_NULL_SESSION, then make sure we have
            // a an Error tag received as per RFC 2156.
            //
            if ( PacketGetSessionId( pPacket ) == PACKET_NULL_SESSION )
            {
                RetrieveErrorTags( pPacket );

                if ( !PacketAnyErrorTagsReceived( pPacket ) )
                {
                    TRACE( TL_A, TM_Pk, ("PacketInitializeFromReceived: Invalid session id") );
                    
                    break;
                }
            }

            //
            // Extract mandatory tags first
            //
            RetrieveTag(    pPacket,
                            tagServiceName,
                            &tagLength,
                            &tagValue,
                            0,
                            NULL,
                            TRUE );

            if ( tagValue == NULL )
            {
                TRACE( TL_A, TM_Pk, ("PacketInitializeFromReceived: Service name tag not found") );
                
                break;
            }

            //
            // Extract optional tags
            //
            RetrieveTag(    pPacket,
                            tagHostUnique,
                            &tagLength,
                            &tagValue,
                            0,
                            NULL,
                            TRUE );

            TRACE( TL_N, TM_Pk, ("PacketInitializeFromReceived: Processed PADS succesfully") );

            status = NDIS_STATUS_SUCCESS;

            break;

        case PACKET_CODE_PADT:

            TRACE( TL_N, TM_Pk, ("PacketInitializeFromReceived: Processing PADT") );

            //
            // Make sure we have received the correct ethertype
            //
            if ( PacketGetEtherType( pPacket ) != PACKET_ETHERTYPE_DISCOVERY )
            {
                TRACE( TL_A, TM_Pk, ("PacketInitializeFromReceived: Invalid ether type") );

                break;
            }

            //
            // Make sure session id is not PACKET_NULL_SESSION
            //
            if ( PacketGetSessionId( pPacket ) == PACKET_NULL_SESSION )
            {
                TRACE( TL_A, TM_Pk, ("PacketInitializeFromReceived: Invalid session id") );
                
                break;
            }
                
            TRACE( TL_N, TM_Pk, ("PacketInitializeFromReceived: Processed PADT succesfully") );

            status = NDIS_STATUS_SUCCESS;
            
            break;

        case PACKET_CODE_PAYLOAD:

            TRACE( TL_V, TM_Pk, ("PacketInitializeFromReceived: Processing PAYLOAD") );

            //
            // Make sure we have received the correct ethertype
            //
            if ( PacketGetEtherType( pPacket ) != PACKET_ETHERTYPE_PAYLOAD )
            {
                TRACE( TL_A, TM_Pk, ("PacketInitializeFromReceived: Invalid ether type") );

                break;
            }

            //
            // Make sure session id is not PACKET_NULL_SESSION
            //
            if ( PacketGetSessionId( pPacket ) == PACKET_NULL_SESSION )
            {
                TRACE( TL_A, TM_Pk, ("PacketInitializeFromReceived: Invalid session id") );
                
                break;
            }

            TRACE( TL_V, TM_Pk, ("PacketInitializeFromReceived: Processed PAYLOAD succesfully") );

            status = NDIS_STATUS_SUCCESS;

            break;
            
        default:
            //
            // Unknown packet code
            //
            TRACE( TL_A, TM_Pk, ("PacketInitializeFromReceived: Ignoring unknown packet") );
            
            break;
        
    }

    if ( status != NDIS_STATUS_SUCCESS )
    {

        TRACE( TL_V, TM_Pk, ("-PacketInitializeFromReceived=$%x",status) );

        return status;
    }

    //
    // The packet was processed succesfuly, now check if we received any error tags
    //
    RetrieveErrorTags( pPacket );

    TRACE( TL_V, TM_Pk, ("-PacketInitializeFromReceived=$%x",status) );

    return status;

}

BOOLEAN 
PacketAnyErrorTagsReceived(
    IN PPPOE_PACKET* pPacket
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    After a received packet is first processed by a PacketInitialize*FromReceived() 
    function, one should call this function to understand if an error tag was 
    noticed in the packet.

    If this function yields TRUE, then the caller should call PacketRetrieveErrorTag() 
    get the error type and value.
    
Parameters:

    pPacket _ A pointer to a PPPoE packet context.
    
Return Values:

    TRUE
    FALSE
    
---------------------------------------------------------------------------*/   
{
    ASSERT( pPacket != NULL );

    return( pPacket->ulFlags & PCBF_ErrorTagReceived ) ? TRUE : FALSE;
}   



VOID 
PacketRetrievePayload(
    IN  PPPOE_PACKET*   pPacket,
    OUT CHAR**          ppPayload,
    OUT USHORT*         pusLength
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    After a received packet is first processed by a PacketInitializeFromReceived() 
    function, one should call this function to retrieve the payload portion of the 
    packet if the packet is a PAYLOAD packet.
    
Parameters:

    pPacket _ A pointer to a PPPoE packet context holding a PAYLOAD packet.
    
Return Values:

    None
    
---------------------------------------------------------------------------*/   
{

    ASSERT( pPacket != NULL );
    ASSERT( pusLength != NULL );
    ASSERT( ppPayload != NULL );

    *pusLength = PacketGetLength( pPacket );
    *ppPayload = pPacket->pPayload;

}

VOID 
PacketRetrieveServiceNameTag(
    IN PPPOE_PACKET* pPacket,
    OUT USHORT*      pTagLength,
    OUT CHAR**       pTagValue,
    IN USHORT        prevTagLength,
    IN CHAR*         prevTagValue
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    After a received packet is first processed by a PacketInitializeFromReceived() 
    function, one should call this function to retrieve the service name tag from 
    the packet.

    If prevTagValue and prevTagLength are given, then next service name tag will
    be returned, otherwise the first service name tag will be returned.

    If no such service name tags are found, then 0 and NULL will be returned for
    length and value parameters.

    CAUTION: Note that a service name tag of length 0 is valid, and one should
             check the value of pTagValue to understand if service name tag was
             found in the packet or not.
    
Parameters:

    pPacket _ A pointer to a PPPoE packet context holding a control packet.

    pTagLength _ On return, holds the length of the service name tag found.

    pTagValue _ On return, points to the buffer holding the service name.
                Will be NULL, if no service name tags could be found.

    prevTagLength _ Length of the previously returned service name tag.

    prevTagValue _ Points to the buffer holding the previous service name tag.
    
Return Values:

    None
    
---------------------------------------------------------------------------*/   
{
    ASSERT( pPacket != NULL );
    ASSERT( pTagLength != NULL );
    ASSERT( pTagValue != NULL );

    if ( prevTagLength == 0 &&
         prevTagValue == NULL )
    {
        //
        // Caller asks for the first Service Name Tag, and it should be ready in
        // the reserved field of the PPPOE_PACKET
        //
        *pTagLength = pPacket->tagServiceNameLength;
        *pTagValue  = pPacket->tagServiceNameValue;
    }
    else
    {
        //
        // Caller asks for the next Service Name Tag, so try to find and return it
        //
        RetrieveTag(    pPacket,
                        tagServiceName,
                        pTagLength,
                        pTagValue,
                        prevTagLength,
                        prevTagValue,
                        FALSE );

    }
}

VOID 
PacketRetrieveHostUniqueTag(
    IN PPPOE_PACKET* pPacket,
    OUT USHORT*      pTagLength,
    OUT CHAR**       pTagValue
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    After a received packet is first processed by a PacketInitializeFromReceived() 
    function, one should call this function to retrieve the host unique tag from 
    the packet.

    If no host unique tag is found, then 0 and NULL will be returned for
    length and value parameters.

    CAUTION: Note that a host unique tag of length 0 is valid, and one should
             check the value of pTagValue to understand if host unique tag was
             found in the packet or not.
    
Parameters:

    pPacket _ A pointer to a PPPoE packet context holding a control packet.

    pTagLength _ On return, holds the length of the host unique tag found.

    pTagValue _ On return, points to the buffer holding the host unique value.
                Will be NULL, if no host unique tags could be found.

Return Values:

    None
    
---------------------------------------------------------------------------*/   
{
    ASSERT( pPacket != NULL );
    ASSERT( pTagLength != NULL );
    ASSERT( pTagValue != NULL );

    //
    // Caller asks for the HostUnique, and it should be ready in
    // the reserved field of the PPPOE_PACKET
    //
    *pTagLength = pPacket->tagHostUniqueLength;
    *pTagValue  = pPacket->tagHostUniqueValue;
}

VOID 
PacketRetrieveACNameTag(
    IN PPPOE_PACKET* pPacket,
    OUT USHORT*      pTagLength,
    OUT CHAR**       pTagValue
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    After a received packet is first processed by a PacketInitializeFromReceived() 
    function, one should call this function to retrieve the AC name tag from 
    the packet.

    If no AC name tag is found, then 0 and NULL will be returned for
    length and value parameters.

    CAUTION: Note that an AC name tag of length 0 is valid, and one should
             check the value of pTagValue to understand if AC name tag was
             found in the packet or not.
    
Parameters:

    pPacket _ A pointer to a PPPoE packet context holding a control packet.

    pTagLength _ On return, holds the length of the AC name tag found.

    pTagValue _ On return, points to the buffer holding the AC name.
                Will be NULL, if no AC name tags could be found.

Return Values:

    None
    
---------------------------------------------------------------------------*/   
{
    ASSERT( pPacket != NULL );
    ASSERT( pTagLength != NULL );
    ASSERT( pTagValue != NULL );

    //
    // Caller asks for the AC Name, and it should be ready in
    // the reserved field of the PPPOE_PACKET
    //
    *pTagLength = pPacket->tagACNameLength;
    *pTagValue  = pPacket->tagACNameValue;
}


VOID 
PacketRetrieveACCookieTag(
    IN PPPOE_PACKET* pPacket,
    OUT USHORT*      pTagLength,
    OUT CHAR**       pTagValue
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    After a received packet is first processed by a PacketInitializeFromReceived() 
    function, one should call this function to retrieve the AC cookie tag from 
    the packet.

    If no AC cookie tag is found, then 0 and NULL will be returned for
    length and value parameters.

    CAUTION: Note that an AC cookie tag of length 0 is valid, and one should
             check the value of pTagValue to understand if AC cookie tag was
             found in the packet or not.
    
Parameters:

    pPacket _ A pointer to a PPPoE packet context holding a control packet.

    pTagLength _ On return, holds the length of the AC cookie tag found.

    pTagValue _ On return, points to the buffer holding the AC cookie.
                Will be NULL, if no AC cookie tags could be found.

Return Values:

    None
    
---------------------------------------------------------------------------*/   
    
{
    ASSERT( pPacket != NULL );
    ASSERT( pTagLength != NULL );
    ASSERT( pTagValue != NULL );

    //
    // Caller asks for the AC Cookie, and it should be ready in
    // the reserved field of the PPPOE_PACKET
    //
    *pTagLength = pPacket->tagACCookieLength;
    *pTagValue  = pPacket->tagACCookieValue;
}

VOID 
PacketRetrieveErrorTag(
    IN PPPOE_PACKET* pPacket,
    OUT PACKET_TAGS* pTagType,
    OUT USHORT*      pTagLength,
    OUT CHAR**       pTagValue
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    After a received packet is first processed by a PacketInitializeFromReceived() 
    function, one should call this function to retrieve the error information from 
    the packet.

    If no errors were found, then 0 and NULL will be returned for length and value 
    parameters.

    CAUTION: Note that an error tag of length 0 is valid, and one should
             check the value of pTagValue to understand if an error tag was
             found in the packet or not.
    
Parameters:

    pPacket _ A pointer to a PPPoE packet context holding a control packet.

    pTagType _ On return, holds the type of the error tag found.
    
    pTagLength _ On return, holds the length of the error tag found.

    pTagValue _ On return, points to the buffer holding the error.
                Will be NULL, if no error tags could be found.

Return Values:

    None
    
---------------------------------------------------------------------------*/   
    
{

    ASSERT( pPacket != NULL );
    ASSERT( pTagType != NULL );
    ASSERT( pTagLength != NULL );
    ASSERT( pTagValue != NULL );

    //
    // Caller asks for the received error, and it should be ready in
    // the reserved field of the PPPOE_PACKET
    //
    if ( pPacket->ulFlags & PCBF_ErrorTagReceived )
    {
        *pTagType   = pPacket->tagErrorType;
        *pTagLength = pPacket->tagErrorTagLength;
        *pTagValue  = pPacket->tagErrorTagValue;
    }
    else
    {
        *pTagLength = 0;
        *pTagValue  = NULL;
    }
    
}

PPPOE_PACKET* 
PacketMakeClone(
    IN PPPOE_PACKET* pPacket
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function will be used to make a clone of a packet for sending it
    over multiple bindings.

    CAUTION: This function only clones the NDIS_PACKET portion of PPPOE_PACKET 
             and leaves other fields untouched, so the clone packets should only 
             be used with NdisSend(), and disposed there after.
        
Parameters:

    pPacket _ A pointer to a PPPoE packet context that will be cloned.

Return Values:

    Pointer to the clone packet if succesfull, NULL otherwise.
    
---------------------------------------------------------------------------*/   
{
    PPPOE_PACKET* pClone = NULL;

    TRACE( TL_N, TM_Pk, ("+PacketMakeClone") );

    //
    // Allocate the clone
    //
    pClone = PacketCreateSimple();

    if ( pClone == NULL )
    {
        TRACE( TL_A, TM_Pk, ("PacketMakeClone: Can not make clone, resources unavailable") );

        TRACE( TL_N, TM_Pk, ("-PacketMakeClone=$%x",pClone) );

        return pClone;
    }

    //
    // Copy the clone
    //
    NdisMoveMemory( pClone->pHeader, pPacket->pHeader, PPPOE_PACKET_HEADER_LENGTH );

    NdisMoveMemory( pClone->pPayload, pPacket->pPayload, PACKET_GEN_MAX_LENGTH );

    NdisAdjustBufferLength( pClone->pNdisBuffer, 
                            (UINT) ( PacketGetLength( pPacket ) + PPPOE_PACKET_HEADER_LENGTH ) );

    TRACE( TL_N, TM_Pk, ("-PacketMakeClone=$%x",pClone) );

    return pClone;
}

PPPOE_PACKET* 
PacketGetRelatedPppoePacket(
    IN NDIS_PACKET* pNdisPacket
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function will be used to get the owning PPPoE packet context from an
    Ndis packet.

Parameters:

    pNdisPacket _ A pointer to an Ndis packet that belongs to a PPPoE packet.

Return Values:

    A pointer to the owning PPPoE packet.
    
---------------------------------------------------------------------------*/   
{
    return (*(PPPOE_PACKET**)(&pNdisPacket->ProtocolReserved[0 * sizeof(PVOID)]));
}

NDIS_WAN_PACKET* 
PacketGetRelatedNdiswanPacket(
    IN PPPOE_PACKET* pPacket
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function will be used to get related NDISWAN packet from a PPPoE 
    payload packet that was perpared and sent.

Parameters:

    pPacket _ A pointer to a PPPoE payload packet that was sent.

Return Values:

    A pointer to the related NDISWAN packet.
    
---------------------------------------------------------------------------*/   
{
    return (*(NDIS_WAN_PACKET**)(&pPacket->pNdisPacket->ProtocolReserved[1 * sizeof(PVOID)])) ;
}

PADAPTER
PacketGetMiniportAdapter(
    IN PPPOE_PACKET* pPacket
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function will be used to get miniport adapter set in 
    PacketInitializePAYLOADToSend() function.

Parameters:

    pPacket _ A pointer to a PPPoE payload packet that was sent.

Return Values:

    Miniport adapter 
    
---------------------------------------------------------------------------*/   
{
    return  (*(ADAPTER**)(&pPacket->pNdisPacket->ProtocolReserved[2 * sizeof(PVOID)]));
}

VOID
PacketGenerateACCookieTag(
    IN PPPOE_PACKET* pPacket,
    IN CHAR tagACCookieValue[ PPPOE_AC_COOKIE_TAG_LENGTH ]
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function is used to generate the AC Cookie tag based on the PADI
    packets sources address.

Parameters:

    pPacket _ A pointer to a PADI packet that was received.

Return Values:

    None
    
---------------------------------------------------------------------------*/   
{
    NdisMoveMemory( tagACCookieValue, PacketGetSrcAddr( pPacket ), 6 );
}

BOOLEAN
PacketValidateACCookieTagInPADR(
    IN PPPOE_PACKET* pPacket
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function is used to validate the AC Cookie tag in a received PADR 
    packet.

    It basically uses the source address from the PADR packet to generate the
    original AC Cookie tag and compares them. If they are equal TRUE is returned,
    otherwise FALSE is returned.

Parameters:

    pPacket _ A pointer to a PADR packet that was received.

Return Values:

    None
    
---------------------------------------------------------------------------*/
{
    BOOLEAN fRet = FALSE;
    CHAR tagACCookie[ PPPOE_AC_COOKIE_TAG_LENGTH ];
    CHAR* tagACCookieValue = NULL;
    USHORT tagACCookieLength = 0;

    PacketRetrieveACCookieTag( pPacket,
                               &tagACCookieLength,
                               &tagACCookieValue );

    PacketGenerateACCookieTag( pPacket, tagACCookie );

    if ( NdisEqualMemory( tagACCookie, tagACCookieValue, PPPOE_AC_COOKIE_TAG_LENGTH ) )
    {
        fRet = TRUE;
    }
    
    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ndis\raspppoe\protocol.c ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Module Name:

    protocol.c

Abstract:

    This module contains all the protocol interface routines.  

Author:

    Hakan Berk - Microsoft, Inc. (hakanb@microsoft.com) Feb-2000

Environment:

    Windows 2000 kernel mode Miniport driver or equivalent.

Revision History:

---------------------------------------------------------------------------*/

#include <ntddk.h>
#include <ntddndis.h>
#include <ndis.h>
#include <ndiswan.h>
#include <ndistapi.h>
#include <ntverp.h>

#include <tdikrnl.h> // For TdiCopyLookaheadData()
//
// VOID
// TdiCopyLookaheadData(
//     IN PVOID Destination,
//     IN PVOID Source,
//     IN ULONG Length,
//     IN ULONG ReceiveFlags
//     );
//
/*
#ifdef _M_IX86
#define TdiCopyLookaheadData(_Destination,_Source,_Length,_ReceiveFlags)   \
    RtlCopyMemory(_Destination,_Source,_Length)
#else
#define TdiCopyLookaheadData(_Destination,_Source,_Length,_ReceiveFlags) { \
    if ((_ReceiveFlags) & TDI_RECEIVE_COPY_LOOKAHEAD) {                    \
        RtlCopyMemory(_Destination,_Source,_Length);                       \
    } else {                                                               \
        PUCHAR _Src = (PUCHAR)(_Source);                                   \
        PUCHAR _Dest = (PUCHAR)(_Destination);                             \
        PUCHAR _End = _Dest + (_Length);                                   \
        while (_Dest < _End) {                                             \
            *_Dest++ = *_Src++;                                            \
        }                                                                  \
    }                                                                      \
}
#endif
*/

#include "debug.h"
#include "timer.h"
#include "bpool.h"
#include "ppool.h"
#include "util.h"
#include "packet.h"
#include "protocol.h"
#include "miniport.h"
#include "tapi.h"

extern NPAGED_LOOKASIDE_LIST gl_llistWorkItems;

/////////////////////////////////////////////////////////////////////////////
//
// Variables local to this module
// They are defined as global only for debugging purposes
//
/////////////////////////////////////////////////////////////////////////////

#define INVALID_HANDLE_VALUE                (NDIS_HANDLE) 0

//
// Handle passed to us by NDIS while registering the protocol
//
NDIS_HANDLE gl_hNdisProtocolHandle = INVALID_HANDLE_VALUE;

//
// Controls access for members listed below
//
NDIS_SPIN_LOCK gl_lockProtocol;

//
// List of binding contexts that are bound
//
LIST_ENTRY gl_linkBindings;

//
// Boolean flag to remember if PrUnload() was called previously
//
BOOLEAN gl_fProtocolUnloaded = TRUE;

// Boolean flag to decide if we need to set packet filters at bind time
//
//
BOOLEAN gl_fSetPacketFiltersAtBind = FALSE;

//
// Boolean flag set to tell the protocol it is okay to bind
// This flag is initially FALSE and is only set to true
// when a tapi client either wants to make an outgoing call
// or listen for incoming calls
//
BOOLEAN gl_fBindProtocol = FALSE;


//
// Number of binding contexts in linkBindings
//
ULONG gl_ulNumBindings;

//
// Keeps the minimum of max frame sizes of bindings.
// This value is used by miniport and is passed to NDISWAN
// in OID_WAN_GET_INFO query.
//
ULONG gl_ulMaxFrameSize = 0;


/////////////////////////////////////////////////////////////////////////////
//
//
// Local functions (not exposed) definitions
//
/////////////////////////////////////////////////////////////////////////////
    
NDIS_STATUS 
InitializeProtocol(
    IN NDIS_HANDLE NdisProtocolHandle,
    IN PUNICODE_STRING RegistryPath
)
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function initializes the static protocol members.
    NdisRegisterProtocol() must be called before.

Parameters:

    DriverObject:
        Pointer to the driver object.

    RegistryPath:
        A unicode string that identifies the registry entry. We can use this this retrieve
        value from the registry.
    
Return Values:

    NDIS_STATUS_SUCCESS:
        Protocol initialized.

    NDIS_STATUS_XXX:
        Protocol initialization failed, deregister protocol.
---------------------------------------------------------------------------*/   

{
    NDIS_STATUS status = NDIS_STATUS_SUCCESS;

    TRACE( TL_N, TM_Pr, ("+InitializeProtocol") );

    //
    // Future: Read values from registry here
    //

    //
    // Initialize the NdisProtocolHandle
    //
    gl_hNdisProtocolHandle = NdisProtocolHandle;

    //
    // Allocate the spin lock
    //
    NdisAllocateSpinLock( &gl_lockProtocol );

    //
    // Initialize list of bindings
    //
    NdisInitializeListHead( &gl_linkBindings );

    //
    // Initialize number of allocated bindings
    //
    gl_ulNumBindings = 0;

    //
    // Load the resources
    //
    PrLoad();

    TRACE( TL_N, TM_Pr, ("-InitializeProtocol=$%x",status) );

    return status;
}


VOID
PrLoad()
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function will allocate the resources for the protocol.

    Caller must make sure that PrLoad() and PrUnload() are not called simultaneously, 
    as well as multiple PrLoad()'s are not called simultanesouly.

    It will load the resources if they were unloaded, and do nothing otherwise.

    We need this function because the resources freed by PrUnload() must be loaded
    somehow, and there is no function called prior to PrBindAdapter() once PrUnload()
    is called. So we allocate all the resources for the binding, and once binding is completed,
    we call this function to load the resources if necesarry prior to notifying the completion
    of binding to NDIS.
        
Parameters:

    None
    
Return Values:

    - Pointer to the newly allocated binding context.
    - NULL if allocation fails.
    
---------------------------------------------------------------------------*/   

{

    TRACE( TL_N, TM_Pr, ("+PrLoad") );

    //
    // Make sure we are not trying to initialize resources, 
    // unless they are already freed by PrUnload()
    //
    if ( gl_fProtocolUnloaded )
    {
        TRACE( TL_N, TM_Pr, ("PrLoad: Loading the resources" ) );
    
        ASSERT( gl_ulNumBindings == 0 );
    
        //
        // Allocate packet pool
        //
        PacketPoolInit();

        gl_fProtocolUnloaded = FALSE;
    }

    TRACE( TL_N, TM_Pr, ("-PrLoad") );
}



BINDING* 
AllocBinding()
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function will allocate the resources for the binding context.
        
Parameters:

    pBinding     _ A pointer to our binding information structure.
    
    fAcquireLock _ Flag that indicates if the function needs to acquire the lock
                   or not. If the caller already owns the lock for the binding,
                   then it should be supplied as TRUE, otherwise FALSE.

Return Values:

    - Pointer to the newly allocated binding context.
    - NULL if allocation fails.
    
---------------------------------------------------------------------------*/   
{

    BINDING* pBinding = NULL;

    TRACE( TL_N, TM_Pr, ("+AllocBinding") );

    if ( ALLOC_BINDING( &pBinding ) != NDIS_STATUS_SUCCESS )
    {
        TRACE( TL_A, TM_Pr, ("AllocBinding: Could not allocate context") );

        TRACE( TL_N, TM_Pr, ("-AllocBinding") );

        return NULL;
    }

    NdisZeroMemory( pBinding, sizeof(BINDING) );

    pBinding->tagBinding = MTAG_BINDING;

    pBinding->stateBinding = BN_stateBindPending;

    NdisInitializeEvent( &pBinding->RequestCompleted );

    pBinding->BindAdapterStatus = NDIS_STATUS_FAILURE;

    NdisInitializeEvent( &pBinding->eventFreeBinding );
    
    NdisAllocateSpinLock( &pBinding->lockBinding );

    InitializeListHead( &pBinding->linkPackets );

    TRACE( TL_N, TM_Pr, ("-AllocBinding") );
    
    return pBinding;
}


VOID 
ReferenceBinding(
    IN BINDING* pBinding,
    IN BOOLEAN fAcquireLock
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function will increment the reference count on the binding.
        
Parameters:

    pBinding     _ A pointer ot our binding information structure.
    
    fAcquireLock _ Flag that indicates if the function needs to acquire the lock
                   or not. If the caller already owns the lock for the binding,
                   then it should be supplied as TRUE, otherwise FALSE.

Return Values:

    None
---------------------------------------------------------------------------*/   
{
    LONG lRef;
    
    ASSERT( VALIDATE_BINDING( pBinding ) );

    TRACE( TL_V, TM_Pr, ("+ReferenceBinding") );

    if ( fAcquireLock )
        NdisAcquireSpinLock( &pBinding->lockBinding );

    lRef = ++pBinding->lRef;
    
    if ( fAcquireLock )
        NdisReleaseSpinLock( &pBinding->lockBinding );

    TRACE( TL_V, TM_Pr, ("-ReferenceBinding=$%d",lRef) );
}

VOID 
DereferenceBinding(
    IN BINDING* pBinding
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function will decrement the reference count on the binding.
    If the count reaches 0, it will signal pBinding->eventFreeBinding 
    so that PrUnbindAdapter() function can free the protocol context.

    CAUTION: Caller must not be holding any locks.
    
Parameters:

    pBinding _ A pointer to our binding information structure.

Return Values:

    None
---------------------------------------------------------------------------*/   
{
    BOOLEAN fSignalFreeBindingEvent = FALSE;
    LONG lRef;
    
    ASSERT( VALIDATE_BINDING( pBinding ) );

    TRACE( TL_V, TM_Pr, ("+DereferenceBinding") );

    NdisAcquireSpinLock( &pBinding->lockBinding );

    lRef = --pBinding->lRef;
    
    if ( lRef == 0 )
    {
        fSignalFreeBindingEvent = TRUE;
    }

    NdisReleaseSpinLock( &pBinding->lockBinding );

    if ( fSignalFreeBindingEvent )
        NdisSetEvent( &pBinding->eventFreeBinding );

    TRACE( TL_V, TM_Pr, ("-DereferenceBinding=$%d",lRef) );

}


VOID 
BindingCleanup(
    IN BINDING* pBinding
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function will free the resources allocated for the binding context.
        
Parameters:

    pBinding     _ A pointer to our binding information structure.

Return Values:

    None
---------------------------------------------------------------------------*/   
{
    ASSERT( VALIDATE_BINDING( pBinding ) );

    TRACE( TL_N, TM_Pr, ("+BindingCleanup") );
    
    ASSERT( pBinding->lRef == 0 );
    
    NdisFreeSpinLock( &pBinding->lockBinding );

    FREE_BINDING( pBinding );

    TRACE( TL_N, TM_Pr, ("-BindingCleanup") );
}

VOID
DetermineMaxFrameSize()
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function will be called when a new binding is added or removed.
    It will walk thru all the bindings and select the minimum of max frame
    size values, and set it to gl_ulMaxFrameSize.

    It will be called from 2 places:
    - PrAddBindingToProtocol()
    - PrRemoveBindingFromProtocol()
    
    CAUTION: gl_lockProtocol must be acquired before calling this function.

Parameters:

    None

Return Values:

    None
---------------------------------------------------------------------------*/       
{
    LIST_ENTRY* pLink = NULL;
    
    pLink = gl_linkBindings.Flink;

    //
    // See if we have any bindings
    //
    if ( pLink != &gl_linkBindings )
    {
        ULONG MinOfMaxFrameSizes = 0;
        BINDING* pBinding = NULL;

        //
        // We have at least one binding, so walk thru the list
        // and select the minimum of MaxFrameSize values
        //
        pBinding = ((BINDING*) CONTAINING_RECORD( pLink, BINDING, linkBindings ));

        MinOfMaxFrameSizes = pBinding->ulMaxFrameSize;
    
        //
        // Iterate to the next binding
        //
        pLink = pLink->Flink;
        
        while ( pLink != &gl_linkBindings )
        {
            ULONG MaxFrameSize;

            //
            // Retrieve the MaxFrameSize value of the next binding and 
            // select the minimum
            //
            pBinding = ((BINDING*) CONTAINING_RECORD( pLink, BINDING, linkBindings ));

            MaxFrameSize = pBinding->ulMaxFrameSize;
    
            if ( MinOfMaxFrameSizes > MaxFrameSize )
            {
                MinOfMaxFrameSizes = MaxFrameSize;
            }
    
            //
            // Iterate to the next binding
            //
            pLink = pLink->Flink;
        }

        //
        // Set gl_ulMaxFrameSize to the selected minimum value
        //
        gl_ulMaxFrameSize = MinOfMaxFrameSizes;
    }
    else
    {
        //
        // Binding list is empty, so set it to 0
        //
        gl_ulMaxFrameSize = 0;
    }

}
    

VOID 
AddBindingToProtocol(
    IN BINDING* pBinding
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function will insert a binding to protocols binding table.

    It will also put a reference on the binding which will go away
    when the binding is removed from this table with a call to 
    RemoveBindingFromProtocol().

Parameters:

    pBinding:
        A pointer ot our binding information structure.

Return Values:

    None
---------------------------------------------------------------------------*/       
{

    ASSERT( VALIDATE_BINDING( pBinding ) );

    TRACE( TL_N, TM_Pr, ("+AddBindingToProtocol") );

    NdisAcquireSpinLock( &gl_lockProtocol );

    InsertTailList( &gl_linkBindings, &pBinding->linkBindings );

    gl_ulNumBindings++;

    //
    // Determine the new max frame size value
    //
    DetermineMaxFrameSize();
    
    NdisReleaseSpinLock( &gl_lockProtocol );

    ReferenceBinding( pBinding, TRUE );

    TRACE( TL_N, TM_Pr, ("-AddBindingToProtocol") );
}

VOID 
RemoveBindingFromProtocol(
    IN BINDING* pBinding
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function will remove a binding from protocols binding list. 

    Binding will be dereferenced after removal from the list.

    CAUTION: Caller must not be holding any locks before calling this function.

Parameters:

    pBinding:
        A pointer ot our binding information structure.

Return Values:

    None
---------------------------------------------------------------------------*/       
    
{
    ASSERT( VALIDATE_BINDING( pBinding ) );

    TRACE( TL_N, TM_Pr, ("+RemoveBindingFromProtocol") );
    
    NdisAcquireSpinLock( &gl_lockProtocol );

    RemoveHeadList( pBinding->linkBindings.Blink );

    InitializeListHead( &pBinding->linkBindings );

    gl_ulNumBindings--;

    //
    // Determine the new max frame size value
    //
    DetermineMaxFrameSize();

    NdisReleaseSpinLock( &gl_lockProtocol );

    DereferenceBinding( pBinding );

    TRACE( TL_N, TM_Pr, ("-RemoveBindingFromProtocol") );
}

/////////////////////////////////////////////////////////////////////////////
//
// Interface functions (exposed) definitions
//
/////////////////////////////////////////////////////////////////////////////

VOID
PrUnload(
    VOID 
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    In response to a user request to uninstall a protocol, NDIS calls a protocol's
    ProtocolUnload function if the protocol has registered an entry point for 
    this function in the NDIS_PROTOCOL_CHARACTERISTICS structure that it passed 
    to NdisRegisterProtocol. NDIS calls ProtocolUnload after calling the protocol's
    ProtocolUnbindAdapter function once for each bound adapter.

    ProtocolUnload performs driver-determined cleanup operations. For example, 
    ProtocolUnload could request clients to close handles that they have opened 
    to device objects exported by the protocol. Until all such handles are closed,
    the I/O Manager will not call the DriverUnload function that the protocol 
    registered in the driver object passed to its DriverEntry function. After all 
    the handles are closed, ProtocolUnload could call IoDeleteDevice one or more 
    times to delete device objects created by the protocol.

    ProtocolUnload does not have to close a protocol's open bindings. When a 
    protocol's DriverUnload function calls NdisDeregisterProtocol, NDIS calls the 
    protocol's ProtocolUnbindAdapter function once for each binding that the 
    protocol has open. The ProtocolUnbindAdapter function calls NdisCloseAdapter 
    to close the binding.
    
    ProtocolUnload must be written so that it can run at IRQL PASSIVE_LEVEL.
   
Parameters:

    None
    
Return Values:

    None
        
---------------------------------------------------------------------------*/
{
    TRACE( TL_N, TM_Pr, ("+PrUnload") );

    if ( !gl_fProtocolUnloaded && gl_ulNumBindings == 0 )
    {
        TRACE( TL_N, TM_Pr, ("PrUnload: Unloading the resources" ) );
        
        PacketPoolUninit();

        gl_fProtocolUnloaded = TRUE;
    }

    TRACE( TL_N, TM_Pr, ("-PrUnlooad") );

}

NDIS_STATUS 
PrRegisterProtocol(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath,
    OUT NDIS_HANDLE* pNdisProtocolHandle
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function will register the protocol with NDIS.
    It must be called from DriverEntry() function before any other in this module
    can be called.
        
Parameters:

    DriverObject:
        Pointer to the driver object.

    RegistryPath:
        A unicode string that identifies the registry entry. We can use this this retrieve
        value from the registry.

Return Values:

    NDIS_STATUS_SUCCESS :
        The NDIS library registered the caller as a protocol driver. 

    NDIS_STATUS_BAD_CHARACTERISTICS :
        The CharacteristicsLength is too small for the MajorNdisVersion specified in 
        the buffer at ProtocolCharacteristics. 

    NDIS_STATUS_BAD_VERSION :
        The MajorNdisVersion specified in the buffer at ProtocolCharacteristics is 
        invalid. 

    NDIS_STATUS_RESOURCES :
        A shortage of resources, possibly memory, prevented the NDIS library from 
        registering the caller.
        
---------------------------------------------------------------------------*/   
{
    NDIS_STATUS status = NDIS_STATUS_SUCCESS;
    BOOLEAN fProtocolRegistered = FALSE;
    NDIS_HANDLE NdisProtocolHandle;
    NDIS_PROTOCOL_CHARACTERISTICS npc;
    STRING NameString;
    UNICODE_STRING UnicodeNameString;
    

    TRACE( TL_I, TM_Pr, ("+PrRegisterProtocol") );

    do
    {
    
        NdisZeroMemory( &npc, sizeof(npc) );

        npc.MajorNdisVersion = PR_NDIS_MajorVersion;
        npc.MinorNdisVersion = PR_NDIS_MinorVersion;

        npc.Reserved = NDIS_USE_WAN_WRAPPER;

        npc.OpenAdapterCompleteHandler = PrOpenAdapterComplete;
        npc.CloseAdapterCompleteHandler = PrCloseAdapterComplete;
        npc.SendCompleteHandler = PrSendComplete;
        npc.TransferDataCompleteHandler = PrTransferDataComplete;
        // npc.ResetCompleteHandler = PrResetCompleteHandler;
        npc.RequestCompleteHandler = PrRequestComplete;
        npc.ReceiveHandler = PrReceive;
        npc.ReceiveCompleteHandler = PrReceiveComplete;
        npc.StatusHandler = PrStatus;
        npc.StatusCompleteHandler = PrStatusComplete;

        RtlInitString( &NameString, PR_CHARACTERISTIC_NAME );

        RtlAnsiStringToUnicodeString( &UnicodeNameString,
                                      &NameString,
                                      TRUE );

        npc.Name.Length = UnicodeNameString.Length;
        npc.Name.Buffer = UnicodeNameString.Buffer;

        //
        // MajorNdisVersion must be set to 0x04 or 0x05
        // with any of the following members.
        //
        npc.ReceivePacketHandler = PrReceivePacket;
        npc.BindAdapterHandler = PrBindAdapter;
        npc.UnbindAdapterHandler = PrUnbindAdapter;
        npc.PnPEventHandler = PrPnPEvent;
        npc.UnloadHandler = PrUnload;
        
        //
        // MajorNdisVersion must be set to 0x05 
        // with any of the following members.
        //
        // CoSendCompleteHandler;
        // CoStatusHandler;
        // CoReceivePacketHandler;
        // CoAfRegisterNotifyHandler;

        NdisRegisterProtocol(   &status,
                                &NdisProtocolHandle,
                                &npc,
                                sizeof( NDIS_PROTOCOL_CHARACTERISTICS ) );

        if ( status != NDIS_STATUS_SUCCESS )
            break;

        fProtocolRegistered = TRUE;

        status = InitializeProtocol( NdisProtocolHandle, RegistryPath );

        if ( status != NDIS_STATUS_SUCCESS )
            break;
    
    } while ( FALSE );

    if ( status != NDIS_STATUS_SUCCESS )
    {
        if ( fProtocolRegistered )
        {
            NDIS_STATUS tempStatus;

            NdisDeregisterProtocol( &tempStatus, NdisProtocolHandle );
        }
    }
    else
    {
        *pNdisProtocolHandle = NdisProtocolHandle;
    }

    TRACE( TL_I, TM_Pr, ("-PrRegisterProtocol=$%x",status) );

    return status;
}



VOID
PrBindAdapter(
    OUT PNDIS_STATUS Status,
    IN NDIS_HANDLE  BindContext,
    IN PNDIS_STRING  DeviceName,
    IN PVOID  SystemSpecific1,
    IN PVOID  SystemSpecific2
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function will be called by NDIS when an underlying adapter wants to 
    bind to us.
        
Parameters:

    Status 
        Points to a variable in which ProtocolBindAdapter returns the status of its 
        operation(s), as one of the following: 

            NDIS_STATUS_SUCCESS 
                The driver completed initialization successfully and bound itself to the 
                given NIC driver specified at DeviceName. 

            NDIS_STATUS_PENDING 
                The protocol will complete the bind operation asynchronously with a call to 
                NdisCompleteBindAdapter when it is ready to accept receives from the 
                underlying driver and to send transmit, query, and set requests down to the 
                underlying driver. 

            NDIS_STATUS_XXX or NTSTATUS_XXX 
                The protocol's attempt to set up a binding failed or the protocol could not 
                allocate the resources it needed to carry out network I/O operations. Usually
                , such an error status is propagated from an NdisXxx function or a kernel-
                mode support routine. 
                
    BindContext 
        Specifies a handle, supplied by NDIS, that the protocol passes subsequently 
        to NdisCompleteBindAdapter. 

    DeviceName 
        Points to a buffered Unicode string naming an underlying NIC driver or 
        virtual NIC driver to which ProtocolBindAdapter should bind. 

    SystemSpecific1 
        Specifies a registry path pointer that is a required parameter to 
        NdisOpenProtocolConfiguration. The caller cannot use this pointer for any 
        other purpose. 

    SystemSpecific2 
        Reserved for system use. The caller cannot use this pointer for any purpose. 

Return Values:

    None
---------------------------------------------------------------------------*/   
{
    NDIS_STATUS status = NDIS_STATUS_FAILURE;
    BINDING* pBinding = NULL;

    TRACE( TL_I, TM_Pr, ("+PrBindAdapter") );

    do 
    {
        NdisAcquireSpinLock( &gl_lockProtocol );

        if (gl_fBindProtocol == FALSE) {

            TRACE( TL_I, TM_Pr, ("PrBindAdapter: Not ready to bind!") );

            NdisReleaseSpinLock( &gl_lockProtocol );
            
            status = NDIS_STATUS_FAILURE;
            
            break;
        }

        NdisReleaseSpinLock( &gl_lockProtocol );

        pBinding = AllocBinding();
        
        if ( pBinding == NULL )
        {
            status = NDIS_STATUS_RESOURCES;
            
            break;
        }

        //
        // Load resources
        //
        PrLoad();

        //
        // Open adapter, and query it
        //
        if ( !PrOpenAdapter( pBinding, DeviceName ) )
        {
            break;
        }

        if ( !PrQueryAdapterForCurrentAddress( pBinding ) )
        {
            break;
        }

        //
        // No need to break if this one fails since it is not critical enough
        //
        PrQueryAdapterForLinkSpeed( pBinding );
       
        if ( !PrQueryAdapterForMaxFrameSize( pBinding ) )
        {
            break;
        }

        //
        // Check if we need to set packet filters at bind time 
        //
        if ( gl_fSetPacketFiltersAtBind )
        {
           PrSetPacketFilterForAdapter( pBinding, TRUE);
        }
        
        //
        // Change the state to bound
        //
        pBinding->stateBinding = BN_stateBound;

        // AddBindingToProtocol() will insert the new binding to protocols 
        // binding list, and reference it
        //
        AddBindingToProtocol( pBinding );

        status = NDIS_STATUS_SUCCESS;

    } while ( FALSE);

    if ( pBinding ) 
    {
        pBinding->ulBindingFlags |= BNBF_BindAdapterCompleted;

        pBinding->BindAdapterStatus = status;

        if ( status != NDIS_STATUS_SUCCESS )
        {
           //
           // We did not call NdisCompleteBindAdapter() because
           // somethings went wrong
           //

           //
           // Close the adapter if it was opened succesfully
           //
           if ( ( pBinding->ulBindingFlags & BNBF_OpenAdapterCompleted ) &&
                ( pBinding->OpenAdapterStatus == NDIS_STATUS_SUCCESS ) )
           {
               PrCloseAdapter( pBinding );
           }

           //
           // Clean up the binding context
           //
           BindingCleanup( pBinding );
        }
    }

    *Status = status;

    TRACE( TL_I, TM_Pr, ("-PrBindAdapter=$%x",status) );
}

BOOLEAN 
PrOpenAdapter(
    IN BINDING* pBinding,
    IN PNDIS_STRING  DeviceName
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function is called to open the underlying adapter.

    CAUTION: It must be called from PASSIVE_LEVEL.

Parameters:

    pBinding:
        A pointer ot our binding information structure.

    DeviceName:
        Name of the device to be opened. This is passed to PrBindAdapter()
        by NDIS.

Return Values:
    TRUE:
        If underlying adapter could be opened succesfully.

    FALSE:
        If underlying adapter could not be opened succesfully.
    
---------------------------------------------------------------------------*/    
{
    NDIS_STATUS status;
    NDIS_STATUS openErrorStatus;

    NDIS_MEDIUM arrayNdisMedium[] = { NdisMedium802_3 };
    UINT sizeNdisMediumArray = sizeof( arrayNdisMedium ) / sizeof( NDIS_MEDIUM );

    TRACE( TL_N, TM_Pr, ("+PrOpenAdapter") );

    NdisOpenAdapter( &status,
                     &openErrorStatus,
                     &pBinding->NdisBindingHandle,
                     &pBinding->uintSelectedMediumIndex,
                     arrayNdisMedium,                   
                     sizeNdisMediumArray,               
                     gl_hNdisProtocolHandle,
                     pBinding,
                     DeviceName,
                     0,
                     NULL );

    if ( status != NDIS_STATUS_PENDING )
    {
       //
       // NidsOpenAdapter() completed synchronously, 
       // so call PrOpenAdapterComplete() manually.
       //
       PrOpenAdapterComplete( pBinding,
                              status,
                              openErrorStatus );
    }

    NdisWaitEvent( &pBinding->RequestCompleted, 0 );

    NdisResetEvent( &pBinding->RequestCompleted );
    
    TRACE( TL_N, TM_Pr, ("-PrOpenAdapter") );

    return pBinding->OpenAdapterStatus == NDIS_STATUS_SUCCESS;
}

VOID 
PrOpenAdapterComplete(
    IN NDIS_HANDLE  ProtocolBindingContext,
    IN NDIS_STATUS  Status,
    IN NDIS_STATUS  OpenErrorStatus
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function will be called after the underlying adapter is opened. 

    We save the result of the Open adapter operation and set the RequestCompleted
    member of the binding context to resume the thread waiting for this to complete.

    CAUTION: It can be called from PASSIVE_LEVEL or at DISPATCH_LEVEL.
    
Parameters:

    ProtocolBindingContext:
        A pointer ot our binding information structure.

    Status:
        NDIS_STATUS_SUCCESS:
            Indicates that NdisOpenAdapter() completed succesfully.

        NDIS_XXX:
            Indicates that NdisOpenAdapter() did not complete succesfully.

    OpenErrorStatus:
        Specifies additional information about the reason for a failure if the value 
        at Status is not NDIS_STATUS_SUCCESS and if the underlying driver supplied 
        this information. For example, the driver of a Token Ring NIC might return a 
        ring error that NDIS forwards to ProtocolOpenAdapterComplete. This parameter 
        can be NULL. 
    
Return Values:

    None
---------------------------------------------------------------------------*/
{
    BINDING* pBinding = (BINDING*) ProtocolBindingContext;

    ASSERT( VALIDATE_BINDING( pBinding ) );
    
    TRACE( TL_I, TM_Pr, ("+PrOpenAdapterComplete") );

    TRACE( TL_N, TM_Pr, ("PrOpenAdapterComplete: NdisOpenAdapter() completed=$%x", Status ) );

    pBinding->ulBindingFlags |= BNBF_OpenAdapterCompleted;

    pBinding->OpenAdapterStatus = Status;

    NdisSetEvent( &pBinding->RequestCompleted );
    
    TRACE( TL_I, TM_Pr, ("-PrOpenAdapterComplete") );
}

VOID
PrStatusComplete(
    IN NDIS_HANDLE ProtocolBindingContext
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function is a required driver function that completes a status-change
    operation initiated when the underlying driver calls NdisMIndicateStatus.
    
Parameters:

    ProtocolBindingContext:
        A pointer ot our binding information structure.

Return Values:

    None
---------------------------------------------------------------------------*/
{
    BINDING *pBinding = (BINDING *) ProtocolBindingContext;
}


BOOLEAN
PrQueryAdapterForCurrentAddress(
    IN BINDING* pBinding
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function is called to query the underlying adapter for current MAC
    address oid.

    The underlying adapter must have been opened succesfully prior to calling
    this function.

    We save the result of the request in the binding context and set the 
    RequestCompleted member of the binding context to resume the thread 
    waiting for this to complete.

    CAUTION: It must be called from PASSIVE_LEVEL.
        
Parameters:

    pBinding:
        A pointer ot our binding information structure.

Return Values:

    TRUE:
        If the request was completed succesfully.

    FALSE:
        If the request was not completed succesfully.
---------------------------------------------------------------------------*/
{

    NDIS_STATUS status;
    PNDIS_REQUEST pRequest = &pBinding->Request;

    TRACE( TL_N, TM_Pr, ("+PrQueryAdapterForCurrentAddress") );

    //
    // Generate an NDIS_REQUEST for querying current address oid
    //
    NdisZeroMemory( pRequest, sizeof( NDIS_REQUEST ) );

    pRequest->RequestType = NdisRequestQueryInformation ;

    pRequest->DATA.QUERY_INFORMATION.Oid = OID_802_3_CURRENT_ADDRESS;

    pRequest->DATA.QUERY_INFORMATION.InformationBuffer = pBinding->LocalAddress;

    pRequest->DATA.QUERY_INFORMATION.InformationBufferLength = sizeof( CHAR ) * 6;

    //
    // Request information from the adapter
    //
    NdisRequest( &status,
                 pBinding->NdisBindingHandle,
                 pRequest );

    if ( status != NDIS_STATUS_PENDING )
    {
        //
        // NdisRequest() completed synchronously, call PrRequestComplete()
        // manually.
        //
        PrRequestComplete( pBinding,
                           pRequest,
                           status );
    }

    NdisWaitEvent( &pBinding->RequestCompleted, 0  );

    NdisResetEvent( &pBinding->RequestCompleted );
    
    TRACE( TL_N, TM_Pr, ("-PrQueryAdapterForCurrentAddress") );

    return pBinding->RequestStatus == NDIS_STATUS_SUCCESS;
}

BOOLEAN
PrQueryAdapterForLinkSpeed(
    IN BINDING* pBinding
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function is called to query the underlying adapter for link speed oid.

    The underlying adapter must have been opened succesfully prior to calling
    this function.
        
    We save the result of the request in the binding context and set the 
    RequestCompleted member of the binding context to resume the thread 
    waiting for this to complete.

    CAUTION: It must be called from PASSIVE_LEVEL.
        
Parameters:

    pBinding:
        A pointer ot our binding information structure.

Return Values:

    TRUE:
        If the request was completed succesfully.

    FALSE:
        If the request was not completed succesfully.
---------------------------------------------------------------------------*/
{

    NDIS_STATUS status;
    PNDIS_REQUEST pRequest = &pBinding->Request;

    TRACE( TL_N, TM_Pr, ("+PrQueryAdapterForLinkSpeed") );

    //
    // Generate an NDIS_REQUEST for querying link speed oid
    //
    NdisZeroMemory( pRequest, sizeof( NDIS_REQUEST ) );

    pRequest->RequestType = NdisRequestQueryInformation ;

    pRequest->DATA.QUERY_INFORMATION.Oid = OID_GEN_LINK_SPEED;

    pRequest->DATA.QUERY_INFORMATION.InformationBuffer = &pBinding->ulSpeed;

    pRequest->DATA.QUERY_INFORMATION.InformationBufferLength = sizeof( pBinding->ulSpeed );

    //
    // Request information from the adapter
    //
    NdisRequest( &status,
                 pBinding->NdisBindingHandle,
                 pRequest );

    if ( status != NDIS_STATUS_PENDING )
    {
        //
        // NdisRequest() completed synchronously, call PrRequestComplete()
        // manually.
        //
        PrRequestComplete( pBinding,
                           pRequest,
                           status );
    }

    NdisWaitEvent( &pBinding->RequestCompleted, 0 );

    NdisResetEvent( &pBinding->RequestCompleted );
    
    TRACE( TL_N, TM_Pr, ("-PrQueryAdapterForLinkSpeed") );

    return pBinding->RequestStatus == NDIS_STATUS_SUCCESS;
}

BOOLEAN
PrQueryAdapterForMaxFrameSize(
    IN BINDING* pBinding
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function is called to query the underlying adapter for max frame size
    oid.

    The underlying adapter must have been opened succesfully prior to calling
    this function.
        
    We save the result of the request in the binding context and set the 
    RequestCompleted member of the binding context to resume the thread 
    waiting for this to complete.

    CAUTION: It must be called from PASSIVE_LEVEL.
        
Parameters:

    pBinding:
        A pointer ot our binding information structure.

Return Values:

    TRUE:
        If the request was completed succesfully.

    FALSE:
        If the request was not completed succesfully.
---------------------------------------------------------------------------*/
{

    NDIS_STATUS status;
    PNDIS_REQUEST pRequest = &pBinding->Request;

    TRACE( TL_N, TM_Pr, ("+PrQueryAdapterForMaxFrameSize") );

    //
    // Generate an NDIS_REQUEST for querying link speed oid
    //
    NdisZeroMemory( pRequest, sizeof( NDIS_REQUEST ) );

    pRequest->RequestType = NdisRequestQueryInformation ;

    pRequest->DATA.QUERY_INFORMATION.Oid = OID_GEN_MAXIMUM_FRAME_SIZE;

    pRequest->DATA.QUERY_INFORMATION.InformationBuffer = &pBinding->ulMaxFrameSize;

    pRequest->DATA.QUERY_INFORMATION.InformationBufferLength = sizeof( pBinding->ulMaxFrameSize );

    //
    // Request information from the adapter
    //
    NdisRequest( &status,
                 pBinding->NdisBindingHandle,
                 pRequest );

    if ( status != NDIS_STATUS_PENDING )
    {
        //
        // NdisRequest() completed synchronously, call PrRequestComplete()
        // manually.
        //
        PrRequestComplete( pBinding,
                           pRequest,
                           status );
    }

    NdisWaitEvent( &pBinding->RequestCompleted, 0 );

    NdisResetEvent( &pBinding->RequestCompleted );
    
    TRACE( TL_N, TM_Pr, ("-PrQueryAdapterForMaxFrameSize") );

    return pBinding->RequestStatus == NDIS_STATUS_SUCCESS;
}

BOOLEAN
PrSetPacketFilterForAdapter(
    IN BINDING* pBinding,
    IN BOOLEAN fSet
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function is called to set the current generic packet filter for our
    protocol.

    The underlying adapter must have been opened succesfully prior to calling
    this function.
        
    We save the result of the request in the binding context and set the 
    RequestCompleted member of the binding context to resume the thread 
    waiting for this to complete.

    CAUTION: It must be called from PASSIVE_LEVEL.
        
Parameters:

    pBinding:
        A pointer ot our binding information structure.

    fSet:
        Indicates what the filters will be set to. 
        TRUE means receive packets, FALSE means set it to 0.

Return Values:

    TRUE:
        If the request was completed succesfully.

    FALSE:
        If the request was not completed succesfully.
---------------------------------------------------------------------------*/
{

    NDIS_STATUS status;
    PNDIS_REQUEST pRequest = &pBinding->Request;
    BOOLEAN fPacketFilterAlreadySet = (BOOLEAN) ( pBinding->ulBindingFlags & BNBF_PacketFilterSet );

    TRACE( TL_N, TM_Pr, ("+PrSetPacketFilterForAdapter") );

    //
    // See if we already are in the state the request wants us to be in
    //
    if ( ( fPacketFilterAlreadySet && fSet ) ||
         ( !fPacketFilterAlreadySet && !fSet ) )
    {
       pBinding->RequestStatus = NDIS_STATUS_SUCCESS;

       TRACE( TL_N, TM_Pr, ("PrSetPacketFilterForAdapter: Already in the requested state") );

       TRACE( TL_N, TM_Pr, ("-PrSetPacketFilterForAdapter") );

       return TRUE;
    }
    
    pBinding->ulPacketFilter = ( fSet ) ? (NDIS_PACKET_TYPE_BROADCAST | NDIS_PACKET_TYPE_DIRECTED) : 0;

    //
    // Generate an NDIS_REQUEST for setting current packet filter
    //
    NdisZeroMemory( pRequest, sizeof( NDIS_REQUEST ) );

    pRequest->RequestType = NdisRequestSetInformation;

    pRequest->DATA.SET_INFORMATION.Oid = OID_GEN_CURRENT_PACKET_FILTER;

    pRequest->DATA.SET_INFORMATION.InformationBuffer = &pBinding->ulPacketFilter;

    pRequest->DATA.SET_INFORMATION.InformationBufferLength = sizeof( ULONG );

    //
    // Request set info on the adapter
    //
    NdisRequest( &status,
                 pBinding->NdisBindingHandle,
                 pRequest );

    if ( status != NDIS_STATUS_PENDING )
    {
        //
        // NdisRequest() completed synchronously, call PrRequestComplete()
        // manually.
        //
        PrRequestComplete( pBinding,
                           pRequest,
                           status );
    }

    NdisWaitEvent( &pBinding->RequestCompleted, 0 );

    NdisResetEvent( &pBinding->RequestCompleted );
    
    TRACE( TL_N, TM_Pr, ("-PrSetPacketFilterForAdapter") );

    return pBinding->RequestStatus == NDIS_STATUS_SUCCESS;
}

VOID
PrRequestComplete(
    IN NDIS_HANDLE ProtocolBindingContext,
    IN PNDIS_REQUEST pRequest,
    IN NDIS_STATUS status
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function will be called to indicate that an NDIS request submitted
    previously has completed.

    We submit 2 requests:
    - OID_802_3_CURRENT_ADDRESS: This is submitted from PrQueryAdapterForCurrentAddress()
                                 to obtain the current MAC address for the underlying 
                                 adapter.

    - OID_GEN_LINK_SPEED: This is submitted from PrQueryAdapterForLinkSpeed() to obtain
                          the current link speed of the underlying adapter.

    - OID_GEN_CURRENT_PACKET_FILTER: This is submitted from PrSetPacketFilterForAdapter()
                                     to set the packet types we are interested in to NDIS.


    If the request for MAC address fail, we clean up the binding context and notify
    NDIS that bind adapter failed, otherwise we go ahead and query the adapter for link 
    speed.

    Regardless of the status of request for link speed, we notify NDIS about succesful
    completion of the bind operation as this is not a fatal error.

    Before calling this function, the underlying adapter must have been opened
    succesfully.
        
Parameters:

    ProtocolBindingContext:
        A pointer ot our binding information structure.

    pRequest:
        A pointer to the request submitted previously.

    Status:
        Completion status of the request.

Return Values:

    None
---------------------------------------------------------------------------*/
{
    BINDING* pBinding = (BINDING*) ProtocolBindingContext;
    BOOLEAN fUnknownOid = FALSE;

    ASSERT( VALIDATE_BINDING( pBinding ) );

    TRACE( TL_I, TM_Pr, ("+PrRequestComplete") );
   
    switch ( pRequest->RequestType )
    {

        case NdisRequestQueryInformation:
            {
        
                switch ( pRequest->DATA.QUERY_INFORMATION.Oid )
                {

                    case OID_802_3_CURRENT_ADDRESS:
    
                        TRACE( TL_N, TM_Pr, ("PrRequestComplete: OID_802_3_CURRENT_ADDRESS=$%x",status) );

                        pBinding->ulBindingFlags |= BNBF_CurrentAddressQueryCompleted;

                        break;

                    case OID_GEN_LINK_SPEED:

                        TRACE( TL_N, TM_Pr, ("PrRequestComplete: OID_GEN_LINK_SPEED=$%x",status) );

                        pBinding->ulBindingFlags |= BNBF_LinkSpeedQueryCompleted;
                                
                        break;

                    case OID_GEN_MAXIMUM_FRAME_SIZE:

                        TRACE( TL_N, TM_Pr, ("PrRequestComplete: OID_GEN_MAXIMUM_FRAME_SIZE=$%x",status) );

                        pBinding->ulBindingFlags |= BNBF_MaxFrameSizeQueryCompleted;

                        break;
                        
                    default:

                        TRACE( TL_N, TM_Pr, ("PrRequestComplete: UNKNOWN OID=$%x",pRequest->DATA.QUERY_INFORMATION.Oid) );

                        fUnknownOid = TRUE;
                    
                        break;
                }

            }

            break;

        case NdisRequestSetInformation:
            {
                switch ( pRequest->DATA.SET_INFORMATION.Oid )
                {
            
                    case OID_GEN_CURRENT_PACKET_FILTER:

                        TRACE( TL_N, TM_Pr, ("PrRequestComplete: OID_GEN_CURRENT_PACKET_FILTER=$%x",status) );

                        if ( status == NDIS_STATUS_SUCCESS )
                        {
                           if ( pBinding->ulBindingFlags & BNBF_PacketFilterSet )
                           {
                              //
                              // Packet filter was set, so reset it
                              //
                              pBinding->ulBindingFlags &= ~BNBF_PacketFilterSet;
                           }
                           else
                           {
                              //
                              // Packet filter was reset, so set it
                              //
                              pBinding->ulBindingFlags |= BNBF_PacketFilterSet;
                           }
                        }                           

                        break;
                        
                    default:

                        TRACE( TL_N, TM_Pr, ("PrRequestComplete: UNKNOWN OID=$%x",pRequest->DATA.SET_INFORMATION.Oid) );
                    
                        fUnknownOid = TRUE;
                        
                        break;

                }
            }

            break;

        default:

            TRACE( TL_N, TM_Pr, ("PrRequestComplete: Unknown RequestType=$%x",pRequest->RequestType) );

            fUnknownOid = TRUE;
            
            break;

    }

    if ( !fUnknownOid )
    {
       pBinding->RequestStatus = status;

       NdisSetEvent( &pBinding->RequestCompleted );
    }

    TRACE( TL_I, TM_Pr, ("-PrRequestComplete") );
}

VOID 
PrUnbindAdapter(
    OUT PNDIS_STATUS  Status,
    IN NDIS_HANDLE  ProtocolBindingContext,
    IN NDIS_HANDLE  UnbindContext
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function will be called by NDIS when an underlying adapter wants to 
    unbind from us.

    ArvindM says PrBindAdapter() and PrUnbindAdapter() will be serialized
    by NDIS.

    This function will not be called if PrBindAdapter() did not succeed.

    Also this function will not be called as long as there are outstanding
    PrReceivePacket() calls active.

    However this function may be called while there are outstanding
    PrSend(), PrSendPayload() or PrBroadcast() calls, that's why we keep
    track of such calls with pBinding->nSendPending and wait on the completion
    of these requests. And as we set the state to BN_stateUnbinding, no such
    new requests will be accepted, and pBinding->nSendPending will reach 0
    at some point which will trigger the pBinding->eventSendCompleted.

    This function is called at IRQL_PASSIVE level by default so we can
    safely wait on events.
        
Parameters:

    Status 
        Points to a variable in which ProtocolBindAdapter returns the status of its 
        operation(s), as one of the following: 

            NDIS_STATUS_SUCCESS 
                The driver completed the unbind operation and deallocated the resources. 

            NDIS_STATUS_PENDING 
                The protocol will complete the unbind operation asynchronously with a call to 
                NdisCompleteUnbindAdapter when ProtocolCloseAdapterComplete() is called.
            
    ProtocolBindingContext 
        A pointer to our binding context.

    UnbindContext:
        This handle is supplied by NDIS and should be used if NdisCloseAdapter() pends.
        Then we will get a call to ProtocolCloseAdapterComplete() which will use this
        handle to notify NDIS about the completion of the initial PrUnbindAdapter()
        request.
        
Return Values:

    None
---------------------------------------------------------------------------*/   
    
{
    BINDING* pBinding = (BINDING*) ProtocolBindingContext;

    ASSERT( VALIDATE_BINDING( pBinding ) );

    TRACE( TL_I, TM_Pr, ("+PrUnbindAdapter") );

    NdisAcquireSpinLock( &pBinding->lockBinding );

    //
    // If there is a sleep request pending, wait for it to complete
    //
    while ( pBinding->stateBinding == BN_stateSleepPending )
    {
        NdisReleaseSpinLock( &pBinding->lockBinding );
        
        NdisMSleep( 10000 );
        
        NdisAcquireSpinLock( &pBinding->lockBinding );
    }
    
    //
    // Mark binding as unbind pending
    //
    ASSERT( pBinding->stateBinding == BN_stateSleeping ||
            pBinding->stateBinding == BN_stateBound );

    pBinding->stateBinding = BN_stateUnbindPending;

    NdisReleaseSpinLock( &pBinding->lockBinding );

    //
    // Unbind all the active sessions on this binding
    //
    MpNotifyBindingRemoval( pBinding );
    
    //
    // Remove Binding from protocols binding table
    // 
    RemoveBindingFromProtocol( pBinding );
    
    //
    // Wait for all references to be deleted
    //
    NdisWaitEvent( &pBinding->eventFreeBinding, 0 );

    TRACE( TL_N, TM_Pr, ("PrUnbindAdapter: All references are deleted") );

    //
    // All references have been removed, now wait for all packets owned by NDIS
    // to be returned.
    //
    // Note that no synchronization is necesarry for reading the value of numPacketsOwnedByNdis
    // at this point since it can only be incremented when there is at least 1 reference on the 
    // binding - at this point ref count is 0 -, and because it can not be incremented, it can 
    // only reach 0 once.
    //
    while ( pBinding->NumPacketsOwnedByNdis )
    {
        NdisMSleep( 10000 );
    }

    TRACE( TL_N, TM_Pr, ("PrUnbindAdapter: All NDIS owned packets have been returned") );

    //
    // Since all references have been deleted, we can close the underlying adapter.
    //
    PrCloseAdapter( pBinding );

    //
    // Change the binding state to unbound
    //
    pBinding->stateBinding = BN_stateUnbound;

    //
    // Clean up the binding context
    //
    BindingCleanup( pBinding );

    *Status = NDIS_STATUS_SUCCESS;

    TRACE( TL_I, TM_Pr, ("-PrUnbindAdapter") );
}


VOID
PrCloseAdapter( 
    IN BINDING* pBinding 
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function is called to close the underlying adapter. It must be called
    either from PrBindAdapter() or PrUnbindAdapter().

    CAUTION: It must be called from PASSIVE_LEVEL.

Parameters:

    pBinding:
        Binding context that owns the adapter to close.

Return Values:

    None
---------------------------------------------------------------------------*/   
{
    NDIS_STATUS status;
    
    TRACE( TL_N, TM_Pr, ("+PrCloseAdapter") );

    NdisCloseAdapter( &status, pBinding->NdisBindingHandle );

    if ( status != NDIS_STATUS_PENDING )
    {
        //
        // NdisCloseAdapter() completed synchronously, 
        // complete the request manually
        //      
        PrCloseAdapterComplete( pBinding, status );

    }

    NdisWaitEvent( &pBinding->RequestCompleted, 0 );

    NdisResetEvent( &pBinding->RequestCompleted );

    TRACE( TL_N, TM_Pr, ("-PrCloseAdapter") );
}


VOID 
PrCloseAdapterComplete(
    IN NDIS_HANDLE  ProtocolBindingContext,
    IN NDIS_STATUS  Status
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function can be called from PrCloseAdapter() if NdisCloseAdapter()
    completes synchronously, or it will be called by NDIS at DISPATCH_LEVEL.

    It sets the BNBF_CloseAdapterCompleted flag and sets the RequestCompleted
    member of the binding context to resume the thread waiting on this event.

    CAUTION: It can be called from PASSIVE_LEVEL or DISPATCH_LEVEL.

Parameters:

    ProtocolBindingContext:
        Specifies the handle to a protocol-allocated context area in which the 
        protocol driver maintains per-binding runtime state. The driver supplied this 
        handle when it called NdisOpenAdapter. 

    Status:
        Indicates the final status of the close operation in the underlying driver.     

Return Values:

    None
---------------------------------------------------------------------------*/   
{
    BINDING* pBinding = ProtocolBindingContext;

    ASSERT( VALIDATE_BINDING( pBinding ) );

    TRACE( TL_I, TM_Pr, ("+PrCloseAdapterComplete") );
   
    TRACE( TL_N, TM_Pr, ("PrCloseAdapterComplete: NdisCloseAdapter() completed=$%x", Status ) );

    pBinding->ulBindingFlags |= BNBF_CloseAdapterCompleted;

    NdisSetEvent( &pBinding->RequestCompleted );

    TRACE( TL_I, TM_Pr, ("-PrCloseAdapterComplete") );
}


BOOLEAN 
PrAddCallToBinding(
    IN BINDING* pBinding,
    IN PCALL pCall
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function will put a reference on the binding which will be removed
    when PrRemoveCallFromBinding() is called.

    It will return TRUE if reference is added succesfully, and FALSE if reference
    could not be added.

    Reference will not be added if binding is not in bound state.

    CAUTION: Caller must make sure that the binding is not freed before calling this
             function.

Parameters:

    pBinding:
        A pointer ot our binding information structure.

    pCall:
        A pointer to our call information structure.

Return Values:

    TRUE:
        Binding referenced for the call

    FALSE:
        Binding not reference for the call
        
---------------------------------------------------------------------------*/       
{
    BOOLEAN fResult;

    TRACE( TL_N, TM_Pr, ("+PrAddCallToBinding") );

    //
    // We have to acquire lock of call first to avoid dead locks
    //
    NdisAcquireSpinLock( &pCall->lockCall );

    if ( pCall->ulClFlags & CLBF_CallDropped ||
         pCall->ulClFlags & CLBF_CallClosePending )
    {
        NdisReleaseSpinLock( &pCall->lockCall );

        TRACE( TL_A, TM_Pr, ("PrAddCallToBinding: Call already dropped or close pending") );

        TRACE( TL_N, TM_Pr, ("-PrAddCallToBinding") );

        return FALSE;

    }

    NdisAcquireSpinLock( &pBinding->lockBinding );

    //
    // Check the state of the binding, if it is not bound
    // we can not add the call
    //
    if ( pBinding->stateBinding != BN_stateBound )
    {

        NdisReleaseSpinLock( &pBinding->lockBinding );

        NdisReleaseSpinLock( &pCall->lockCall );

        TRACE( TL_A, TM_Pr, ("PrAddCallToBinding: Binding state not bound") );

        TRACE( TL_N, TM_Pr, ("-PrAddCallToBinding") );

        return FALSE;

    }

    //
    // Both binding and call are ready to be bound
    // Go ahead and add the call
    //

    //
    // Set call's binding context ptr to binding
    //
    pCall->pBinding = pBinding;

    //
    // Copy the local address of the binding
    //
    NdisMoveMemory( pCall->SrcAddr, pBinding->LocalAddress, 6 * sizeof( CHAR ) );

    //
    // Set call's link speed
    //
    pCall->ulSpeed = pBinding->ulSpeed;

    //
    // Pass the MaxFrameSize to call context
    //
    pCall->ulMaxFrameSize = pBinding->ulMaxFrameSize - PPPOE_PACKET_HEADER_LENGTH;
    
    //
    // Make a reference on the binding which will be removed when PrRemoveCallFromBinding()
    // is called
    //
    ReferenceBinding( pBinding, FALSE );

    //
    // Release the locks, and return
    //
    NdisReleaseSpinLock( &pBinding->lockBinding );

    NdisReleaseSpinLock( &pCall->lockCall );

    TRACE( TL_N, TM_Pr, ("-PrAddCallToBinding") );

    return TRUE;
}


VOID 
PrRemoveCallFromBinding(
    IN BINDING* pBinding,
    IN CALL* pCall
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function will be called to remove a reference added by a  PrAddCallToBinding()
    for a call on this binding. 

Parameters:

    pBinding:
        Pointer to the binding context that the will be dereferenced.

    pCall: 
        Pointer to the call context being unbound fromthe binding.

Return Values:

    None
    
---------------------------------------------------------------------------*/       
{
    ASSERT( VALIDATE_BINDING( pBinding ) );
    
    TRACE( TL_N, TM_Pr, ("+PrRemoveCallFromBinding") );

    NdisAcquireSpinLock( &pCall->lockCall );

    pCall->pBinding = NULL;

    pCall->ulSpeed = 0;

    NdisReleaseSpinLock( &pCall->lockCall );

    DereferenceBinding( pBinding );

    TRACE( TL_N, TM_Pr, ("-PrRemoveCallFromBinding") );
}

VOID 
PrSendComplete(
    IN NDIS_HANDLE ProtocolBindingContext,
    IN PNDIS_PACKET pNdisPacket,
    IN NDIS_STATUS Status
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function will be called by NDIS to notify that a previously send operation
    on this packet has been completed.

    It will notify NDISWAN, if packet was a payload packet.

    It will remove the references on the packet and binding added by the PrSendXXX()
    functions.
        
Parameters:

    ProtocolBindingContext:
        A pointer to our binding context.
    
    pNdisPacket:
        Ndis Packet that was send previously.

    Status:
        Status of the send operation.

Return Values:

    None
    
---------------------------------------------------------------------------*/       
{
    BINDING* pBinding = (BINDING*) ProtocolBindingContext;
    PPPOE_PACKET* pPacket = NULL;
    USHORT usCode;

    ASSERT( VALIDATE_BINDING( pBinding ) );

    TRACE( TL_V, TM_Pr, ("+PrSendComplete($%x,$%x,$%x)",pBinding,pNdisPacket,Status) );

    //
    // Retrieve the related PPPoE packet context from the NDIS packet
    //
    pPacket = PacketGetRelatedPppoePacket( pNdisPacket );
    
    ASSERT( pPacket != NULL );
    
    //
    // Set the completion status for the send to be passed back to
    // NDISWAN when the packet is freed (only for Payload packets)
    //
    PacketSetSendCompletionStatus( pPacket, Status );

    //
    // Remove the reference on the packet added by the sending function
    //
    DereferencePacket( pPacket );

    //
    // Remove the reference on the binding
    //
    DereferenceBinding( pBinding );

    TRACE( TL_V, TM_Pr, ("-PrSendComplete($%x,$%x,$%x)",pBinding,pNdisPacket,Status) );
}

INT 
PrReceivePacket(
    IN NDIS_HANDLE  ProtocolBindingContext,
    IN PNDIS_PACKET  Packet
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function is called by NDIS when a packet is received over this binding.

    Packet is converted into a PPPoE packet and notified to Miniport so that miniport
    processes it.
    
Parameters:

    ProtocolBindingContext:
        A pointer to our binding context.
        
    Packet:
        An Ndis packet received over this binding.

Return Values:

    The return value represents the number of references NDIS should wait for
    before freeing his copy of the packet, but we will be done by the NDIS packet
    at the end of the function, we always return 0.
    
---------------------------------------------------------------------------*/       
{
    BINDING* pBinding = (BINDING*) ProtocolBindingContext;

    PPPOE_PACKET* pPacket = NULL;
    INT nRefCount = 0;

    ASSERT( VALIDATE_BINDING( pBinding ) );

    TRACE( TL_V, TM_Pr, ("+PrReceivePacket($%x,$%x)",pBinding,Packet) );

    do
    {
        pPacket = PacketNdis2Pppoe( (PVOID) pBinding,
                                    Packet,
                                    &nRefCount );

        if ( pPacket )
        {

            TRACE( TL_V, TM_Pr, ("PrReceivePacket: Received PPPoE packet=$%x",pPacket) );

            //
            // We have a copy of the packet, insert it into our queue of received packets, 
            // so that it will be consumed by a call to our PrReceiveComplete() function.
            //
            // It will be freed when it is consumed in PrReceiveComplete().
            //
        
            NdisInterlockedInsertTailList( &pBinding->linkPackets,
                                           &pPacket->linkPackets,
                                           &pBinding->lockBinding );
        }
        
    } while ( FALSE );

    TRACE( TL_V, TM_Pr, ("-PrReceivePacket($%x,$%x)",pBinding,Packet) );

    return nRefCount;
}

NDIS_STATUS 
PrBroadcast(
    IN PPPOE_PACKET* pPacket
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function is called by an adapter to broadcast a PADI packet.

    It clones the packet and schedules a send over each binding that's currrently
    active.

    The caller can destroy the packet after return from this function.
    
Parameters:

    pPacket:
        A PPPoE PADI packet ready to be broadcast.

Return Values:

    NDIS_STATUS_SUCCESS:
        At least 1 send operation was scheduled over a binding.

    NDIS_STATUS_FAILURE:
        No sends could be scheduled.
    
---------------------------------------------------------------------------*/       
{
    NDIS_STATUS status = NDIS_STATUS_FAILURE;

    TRACE( TL_N, TM_Pr, ("+PrBroadcast($%x)",pPacket) );

    //
    // Check if we have any bindings
    //
    if ( gl_ulNumBindings == 0 )
    {
        TRACE( TL_N, TM_Pr, ("PrBroadcast($%x): No bindings available",pPacket) );
    
        TRACE( TL_N, TM_Pr, ("-PrBroadcast($%x)=$%x",pPacket,status) );

        return status;
    }

    NdisAcquireSpinLock( &gl_lockProtocol );

    do
    {
        LIST_ENTRY* pHead = NULL;

        //
        // We have to do the same check again, as the first one is to make sure
        // we have allocated the spin lock, and this one is to make sure after we acquired
        // it, we still have some bindings
        //
        if ( gl_ulNumBindings == 0 )
        {
            TRACE( TL_N, TM_Pr, ("PrBroadcast($%x): No bindings available",pPacket) );
    
            break;
        }

        //
        // Get the head of the bindings list
        //
        pHead = gl_linkBindings.Flink;

        //
        // Traverse the bindings list and schedule a PrSend() with a clone of pNdisPacket
        //
        while ( pHead != &gl_linkBindings )
        {
            PPPOE_PACKET* pClone = NULL;
            BINDING* pBinding = (BINDING*) CONTAINING_RECORD( pHead,
                                                              BINDING,
                                                              linkBindings );
            //
            // Do not schedule a send if binding is not bound
            //
            if ( pBinding->stateBinding != BN_stateBound )
            {
                pHead = pHead->Flink;

                continue;
            }

            //
            // Make a clone of the actual packet
            //
            pClone = PacketMakeClone( pPacket );

            if ( pClone != NULL )
            {
                WORKITEM* pWorkItem = NULL;
                PVOID Args[4];

                //
                // Set the source address on the packet to be sent
                //
                PacketSetSrcAddr( pClone, pBinding->LocalAddress );

                //
                // Set the arguements array
                //
                Args[0] = (PVOID) pBinding;
                Args[1] = (PVOID) pClone;

                //
                // Allocate work item
                //
                pWorkItem = AllocWorkItem( &gl_llistWorkItems,
                                           ExecBindingWorkItem,
                                           NULL,
                                           Args,
                                           BWT_workPrSend );
                
                if ( pWorkItem != NULL )
                {

                    ReferenceBinding( pBinding, TRUE );

                    ReferencePacket( pClone );
    
                    //
                    // Schedule the send operation
                    //
                    ScheduleWorkItem( pWorkItem );

                    status = NDIS_STATUS_SUCCESS;

                }

                //
                // We can free the packet since we have put a reference for scheduling it
                //
                PacketFree( pClone );
            }

            pHead = pHead->Flink;
        }
            
    } while ( FALSE );

    NdisReleaseSpinLock( &gl_lockProtocol );

    TRACE( TL_N, TM_Pr, ("-PrBroadcast($%x)=$%x",pPacket,status) );

    return status;
}

VOID 
ExecBindingWorkItem(
    IN PVOID Args[4],
    IN UINT workType
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function executes the scheduled work items for the binding.

    
Parameters:

    Args:
        An array of length 4 keeping PVOIDs

    workType:
        Indicates the type of the work to be executed.
        We use this to understand what we should do in this function.

Return Values:

    None
    
---------------------------------------------------------------------------*/       
{
    TRACE( TL_V, TM_Pr, ("+ExecBindingWorkItem") );

    switch( workType )
    {

        case BWT_workPrStartBinds:
            //
            // Tell NDIS to bind our protocol to any interested miniports.
            // If we need to start an outgoing call then kick that off too.
            //
            {
                ULONG_PTR FilterChangeRequest = (ULONG_PTR) Args[0]; 
                BOOLEAN fSetFilters = (BOOLEAN) ( FilterChangeRequest != BN_ResetFiltersForCloseLine );
               
                switch ( FilterChangeRequest )
                {
                     case BN_SetFiltersForMediaDetection:
                        {   
                             //
                             // This is a set default media detection request so complete it
                             //
                             LINE* pLine = (LINE*) Args[1];
                             PNDIS_TAPI_SET_DEFAULT_MEDIA_DETECTION pRequest = (PNDIS_TAPI_SET_DEFAULT_MEDIA_DETECTION) Args[2];

                             PrReEnumerateBindings();

                             ChangePacketFiltersForAdapters( fSetFilters );

                             TpSetDefaultMediaDetectionComplete( pLine, pRequest );
                        }   
   
                        break;
                          
                     case BN_SetFiltersForMakeCall:
                        {
                             //
                             // This is a make call request so schedule the real work item and complete it
                             //
                             CALL* pCall = (CALL*) Args[1];
                             PNDIS_TAPI_MAKE_CALL pRequest = (PNDIS_TAPI_MAKE_CALL) Args[2];
                             WORKITEM* pWorkItem = (WORKITEM*) Args[3];
                             
                             PrReEnumerateBindings();

                             ChangePacketFiltersForAdapters( fSetFilters );

                             TpMakeCallComplete( pCall, pRequest );
   
                             ScheduleWorkItem( pWorkItem );
                        }                          
   
                        break;
   
                     case BN_ResetFiltersForCloseLine:
                        {
                             //
                             // This is a close line request so dereference it
                             //
                             LINE* pLine = (LINE*) Args[1];

                             ChangePacketFiltersForAdapters( fSetFilters );

                             DereferenceLine( pLine );
                        }
   
                        break;

                     default:
                        {
                             //
                             // Unknown request
                             //
                             ASSERT( FALSE );
                        }                          
   
                        break;
                }
            }
            
            break;

        case BWT_workPrSend:
            //
            // Scheduled from PrBroadcast() to send PADI packets
            //
            {
                NDIS_STATUS status;

                status = PrSend( ( BINDING*) Args[0], (PPPOE_PACKET*) Args[1] );

                TRACE( TL_N, TM_Pr, ("ExecBindingWorkItem: BWT_workSend=$%x",status) );
                
            }

            break;

        case BWT_workPrReceiveComplete:

            //
            // Scheduled from PrReceivePacket() if receive loop on the specific binding is not running
            //
            {
                BINDING* pBinding = ( ( BINDING*) Args[0] );

                PrReceiveComplete( pBinding );

                DereferenceBinding( pBinding );
                
            }

            break;
            
        default:

            break;
    }

    TRACE( TL_V, TM_Pr, ("-ExecBindingWorkItem") );
}


NDIS_STATUS
PrReceive(
    IN NDIS_HANDLE  ProtocolBindingContext,
    IN NDIS_HANDLE  MacReceiveContext,
    IN PVOID  HeaderBuffer,
    IN UINT  HeaderBufferSize,
    IN PVOID  LookaheadBuffer,
    IN UINT  LookaheadBufferSize,
    IN UINT  PacketSize
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function will be called by NDIS to indicate the receipt of a new packet.

    We check if packet is a PPPoE frame, and if it is not, we just return.

    However if it is then we determine if we have received the whole packet or
    not. If we have received the whole packet, we call PrTransferDataComplete()
    manually, otherwise we initiate the data transfer and return. When transfer 
    is completed PrDataTransferComplete() will be called by NDIS.
    
Parameters:

    ProtocolBindingContext:
        Specifies the handle to a protocol-allocated context area in which the 
        protocol driver maintains per-binding runtime state. The driver supplied this 
        handle when it called NdisOpenAdapter. 
        
    MacReceiveContext:
        Specifies a context handle that the underlying NIC driver associates with the 
        packet received from the network. This handle is opaque to the protocol, 
        reserved for use by the underlying driver that made the indication, and a 
        required parameter to NdisTransferData. 
        
    HeaderBuffer:
        Points to the base virtual address of a range containing the buffered packet 
        header. The address is valid only within the current call to ProtocolReceive. 

    HeaderBufferSize:
        Specifies the number of bytes in the packet header. 

    LookAheadBuffer:
        Points to the base virtual address of a range that contains 
        LookaheadBufferSize bytes of buffered network packet data. This address is 
        valid only within the current call to ProtocolReceive. 

    LookaheadBufferSize:
        Specifies the number of bytes of network packet data in the lookahead buffer. 
        The indicating driver ensures this number is at least as large as the size it 
        returned for the protocol's preceding call to NdisRequest with 
        OID_GEN_CURRENT_LOOKAHEAD or the size of the packet, whichever is less. 

        If PacketSize is less than or equal to the given LookaheadBufferSize, the 
        kahead buffer contains the entire packet. If the underlying driver made 
        the indication with NdisMIndicateReceivePacket, the lookahead buffer always 
        contains a full network packet. 

    PacketSize:
        Specifies the size, in bytes, of the network packet data. The length of the 
        packet does not include the length of the header. 
        ProtocolReceive determines whether the protocol must call NdisTransferData by 
        comparing this parameter to the given LookaheadBufferSize. 

Return Values:

    NDIS_STATUS_NOT_ACCEPTED:
        The protocol has no use for the indicated packet, that is, it has no current 
        clients interested in the indicated network data. 
        Returning this status quickly for rejected packets yields higher performance 
        for the protocol and the highest possible network I/O throughput for the 
        system as a whole. 

    NDIS_STATUS_SUCCESS:
        ProtocolReceive has processed the header information and accepted the packet, 
        that is, it has copied the indicated network data from the header and 
        lookahead buffers and, possibly, called NdisTransferData to retrieve the 
        remaining data if less than a full network packet was indicated. 
    
---------------------------------------------------------------------------*/       
{
    NDIS_STATUS status = NDIS_STATUS_NOT_ACCEPTED;
    BINDING* pBinding = (BINDING*) ProtocolBindingContext;
    PPPOE_PACKET *pPacket = NULL;

    ASSERT( VALIDATE_BINDING( pBinding ) );

    TRACE( TL_V, TM_Pr, ("+PrReceive") );

    //
    // Check if the packet is a PPPoE frame or not
    //
    if ( !PacketFastIsPPPoE( (CHAR*) HeaderBuffer, HeaderBufferSize ) ) 
    {
        TRACE( TL_V, TM_Pr, ("-PrReceive=$%x",status) );
        
        return status;
    }

   //
   // Make sure packet is not too large
   //
   if ( HeaderBufferSize + PacketSize > PPPOE_PACKET_BUFFER_SIZE )
   {
      TRACE( TL_A, TM_Pr, ("PrReceive: Packet too large" ) );

        TRACE( TL_V, TM_Pr, ("-PrReceive=$%x",status) );
        
        return status;
    }

    //
    // Let's create our PPPoE packet to keep the copy of the received packet
    //
    pPacket = PacketCreateSimple();

    if ( pPacket == NULL )
    {
        TRACE( TL_A, TM_Pr, ("PrReceive: Could not allocate context to copy the packet") );

        TRACE( TL_V, TM_Pr, ("-PrReceive=$%x",status) );
        
        return status;
    }

    //
    // See if the packet indicated is complete, or not.
    // If it is not the complete packet then we should call NdisTransferData(),
    // otherwise we can do the copy here
    //
    if ( LookaheadBufferSize >= PacketSize )
    {
        TRACE( TL_V, TM_Pr, ("PrReceive: Complete packet indicated, transferring data") );

        //
        // First copy the header portion
        //
        NdisMoveMemory( pPacket->pHeader,
                        HeaderBuffer,
                        HeaderBufferSize );

        //
        // Packet is complete, so let's copy whole data to our own copy
        //
        TdiCopyLookaheadData( pPacket->pHeader + HeaderBufferSize, 
                              (CHAR*) LookaheadBuffer,
                              (ULONG) PacketSize,
                              (ULONG) 0 );

        //
        // Let's call PrTransferDataComplete() manually now.
        //
        PrTransferDataComplete( pBinding,
                                pPacket->pNdisPacket,
                                NDIS_STATUS_SUCCESS,
                                PacketSize );
                                
    }
    else
    {
        UINT nBytesTransferred = 0;
        
        TRACE( TL_V, TM_Pr, ("PrReceive: Partial packet indicated, transferring data") );

      //
      // Mark the packet for incomplete indication
      //
      pPacket->ulFlags |= PCBF_PacketIndicatedIncomplete;
      
        //
        // First copy the header to the end of the packet
      //
        // Note that HeaderBufferSize MUST be equal to ETHERNET_HEADER_LENGTH and
        // this is ensured in PacketIsFastPPPoE().
        //
        NdisMoveMemory( pPacket->pHeader + (PPPOE_PACKET_BUFFER_SIZE - ETHERNET_HEADER_LENGTH),
                            HeaderBuffer,
                         HeaderBufferSize );

        //
        // Lookahead buffer does not contain all the packet, we should call NdisTransferData()
        // to receive the full packet
        //
        NdisTransferData( &status,
                          pBinding->NdisBindingHandle,
                          MacReceiveContext,
                          0,
                          PacketSize,
                          pPacket->pNdisPacket,
                          &nBytesTransferred );
                          
        if ( status != NDIS_STATUS_PENDING )
        {
            //
            // Call PrTransferDataComplete() manually if transfer data completed
            // synchronously
            //
            PrTransferDataComplete( pBinding,
                                    pPacket->pNdisPacket,
                                    status,
                                    nBytesTransferred );
    
        }
    }


    TRACE( TL_V, TM_Pr, ("-PrReceive=$%x",status) );

    return NDIS_STATUS_SUCCESS;
}

    
VOID
PrTransferDataComplete(
    IN NDIS_HANDLE  ProtocolBindingContext,
    IN PNDIS_PACKET  Packet,
    IN NDIS_STATUS  Status,
    IN UINT  BytesTransferred
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function is called to post process a received packet when whole data
    is copied into the packet context.

    It can be called by NDIS, or it can be called manually from inside PrReceive()
    if the indicated packet is a whole packet.

    If the status is succesfull, it will insert the packet to the end of the
    bindings received packets queue, otherwise it will clean up our copy of
    NDIS packet and return.
    
Parameters:

    ProtocolBindingContext 
        Specifies the handle to a protocol-allocated context area in which the 
        protocol driver maintains per-binding runtime state. The driver supplied this 
        handle when it called NdisOpenAdapter. 

    Packet 
        Points to the protocol-allocated packet descriptor the driver originally 
        passed to NdisTransferData. 
        
    Status 
        Specifies the final status of the transfer-data operation. 
    
    BytesTransferred 
        Specifies the number of bytes of data that the NIC driver transferred into 
        the buffers mapped by buffer descriptors chained to the packet descriptor at 
        Packet. The protocol uses this value to determine whether the miniport 
        supplied all the requested data for the originally indicated network packet. 

Return Values:

    None
    
---------------------------------------------------------------------------*/
{
    BINDING* pBinding = (BINDING*) ProtocolBindingContext;
    PPPOE_PACKET* pPacket = NULL;

    ASSERT( VALIDATE_BINDING( pBinding ) );
    
    TRACE( TL_V, TM_Pr, ("+PrTransferDataComplete") );

    do
    {
        //
        // Retrieve the related PPPoE packet first
        //
        pPacket = PacketGetRelatedPppoePacket( Packet );
    
        //
        // Make sure the data transfer suceeded
        //
        if ( Status != NDIS_STATUS_SUCCESS )
        {
            //
            // Transfer of data to our copy of packet failed, so clean up our packet
            //
            PacketFree( pPacket );

            break;
        }

      //
      // Rearrange the data in the packet if the packet was indicated incomplete
      //
      if ( pPacket->ulFlags & PCBF_PacketIndicatedIncomplete )
      {
         CHAR tempHeader[ ETHERNET_HEADER_LENGTH ];

         CHAR* srcPos = pPacket->pHeader + BytesTransferred;

         //
         // Make a copy of the header stored at the end of the packet
         //
         NdisMoveMemory( tempHeader,
                         pPacket->pHeader + (PPPOE_PACKET_BUFFER_SIZE - ETHERNET_HEADER_LENGTH),
                         ETHERNET_HEADER_LENGTH );

         //
         // Move the contents of the packet appropriately to make room
         // for the header (slip contents by ETHERNET_HEADER_LENGTH)
         //
         while ( BytesTransferred > 0 )
         {
            #define TEMP_BUFFER_SIZE 100
            CHAR tempBuffer[ TEMP_BUFFER_SIZE ];

            UINT size = (BytesTransferred < TEMP_BUFFER_SIZE) ? 
                        BytesTransferred : 
                        TEMP_BUFFER_SIZE;

            srcPos -= size;

            NdisMoveMemory( tempBuffer,
                            srcPos,
                            size );

            NdisMoveMemory( srcPos + ETHERNET_HEADER_LENGTH,
                            tempBuffer,
                            size );

            BytesTransferred -= size;
         }

         //
         // Copy the header to the correct position in the packet
         //
         NdisMoveMemory( pPacket->pHeader,
                         tempHeader,
                         ETHERNET_HEADER_LENGTH );

         //
         // Clear the incomplete indication flag
         //
         pPacket->ulFlags &= ~PCBF_PacketIndicatedIncomplete;
      }

        //
        // Data transfer succeeded, insert into our queue of received packets, so that it will
        // be consumed by a call to our PrReceiveComplete() function
        //
        NdisInterlockedInsertTailList( &pBinding->linkPackets,
                                       &pPacket->linkPackets,
                                       &pBinding->lockBinding );
    
    } while ( FALSE );
    
    TRACE( TL_V, TM_Pr, ("-PrTransferDataComplete=$%x",Status) );
}

VOID
PrReceiveComplete(
    IN NDIS_HANDLE ProtocolBindingContext
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function will be called to perform post processing of received packets
    indicated previously. Underlying NIC will call it when it is not busy.

    We need to serialize the indication of packets to the miniport, since this
    is of vital importance for PPP frames. To achieve this, we use the lock 
    protected flag of binding (fRecvLoopRunning).

    When this function is called, it will return immediately if this flag is 
    already set. 

    If flag is not set, then it will set this flag and start processing packets
    from the received queue, and indicate all packets to miniport one by one
    untill all the queue is drained. Then it will reset the flag and return.
    
Parameters:

    ProtocolBindingContext 
        Specifies the handle to a protocol-allocated context area in which the 
        protocol driver maintains per-binding runtime state. The driver supplied this 
        handle when it called NdisOpenAdapter. 

Return Values:

    None
    
---------------------------------------------------------------------------*/   
{
    BINDING* pBinding = (BINDING*) ProtocolBindingContext;
    LIST_ENTRY* pLink = NULL;
    PPPOE_PACKET* pPacket = NULL;
    BOOLEAN fStartRecvLoop = FALSE;

    ASSERT( VALIDATE_BINDING( pBinding ) );
    
    TRACE( TL_V, TM_Pr, ("+PrReceiveComplete") );

    NdisAcquireSpinLock( &pBinding->lockBinding );

    //
    // See if recv loop is already running
    //
    if ( !pBinding->fRecvLoopRunning )
    {
        //
        // Indicate the recv loop has started to run
        //
        pBinding->fRecvLoopRunning = TRUE;

        //
        // Now consume these packet's
        //
        while ( !IsListEmpty( &pBinding->linkPackets ) )
        {
            pLink = RemoveHeadList( &pBinding->linkPackets );

            NdisReleaseSpinLock( &pBinding->lockBinding );
    
            pPacket = (PPPOE_PACKET*) CONTAINING_RECORD( pLink, PPPOE_PACKET, linkPackets );

            InitializeListHead( &pPacket->linkPackets );
    
            if ( PacketInitializeFromReceived( pPacket ) == NDIS_STATUS_SUCCESS )
            {   
                //
                // Indicate the packet to miniport
                //
                MpRecvPacket( pBinding, pPacket );
            }
    
            //
            // Free the packet since we are done with it
            //
            PacketFree( pPacket );

            //
            // Acquire the lock again
            //
            NdisAcquireSpinLock( &pBinding->lockBinding );
        }

        //
        // The queue is drained, so stop the recv loop
        //
        pBinding->fRecvLoopRunning = FALSE;

    }

    NdisReleaseSpinLock( &pBinding->lockBinding );

    TRACE( TL_V, TM_Pr, ("-PrReceiveComplete") );
}


ULONG
PrQueryMaxFrameSize()
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function will be called by the miniport to retrieve the current minimum
    of max frame sizes of the bindings, since this is the value passed to
    NDISWAN in an OID_WAN_GET_INFO query as the MaxFrameSize.

    We adjust the max frame size considering the PPPoE and Ethernet headers.
    
Parameters:

    None
    
Return Values:

    Minimum of max frame sizes
    
---------------------------------------------------------------------------*/   
{
    ULONG ulMaxFrameSize = gl_ulMaxFrameSize;

    if ( ulMaxFrameSize == 0 )
    {
        ulMaxFrameSize = PACKET_PPP_PAYLOAD_MAX_LENGTH;
    }
    else
    {
        ulMaxFrameSize = ulMaxFrameSize - PPPOE_PACKET_HEADER_LENGTH;
    }
    
    return ulMaxFrameSize;
}

NDIS_STATUS
PrSend(
    IN BINDING* pBinding,
    IN PPPOE_PACKET* pPacket
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function will be called to transmit a PPPoE packet.

    The caller must have referenced the packet and binding before calling this
    function. Then the caller can forget about the references, everything will 
    be handled by the protocol. If send operation complets synchrnously then
    the references are removed in the function, otherwise PrSendComplete()
    will be called and references will be removed then.
        
Parameters:

    pBinding _ Binding to send the packet over.

    pPacket _ PPPoE packet to be transmitted.
    
Return Values:

    NDIS_STATUS_SUCCESS
    NDIS_STATUS_PENDING
    NDIS_STATUS_FAILURE
    NDIS_STATUS_XXXXXXX
    
---------------------------------------------------------------------------*/   
{
    NDIS_STATUS status = NDIS_STATUS_FAILURE;

    ASSERT( VALIDATE_BINDING( pBinding ) );

    TRACE( TL_V, TM_Pr, ("+PrSend") );

    //
    // Make sure we are bound before sending the packet.
    //
    // Note: We do not need to acquire the lock here since NDIS should prevent
    //       a crash even if we are unbound, and we already have a reference 
    //       on the binding, so this is not a really strict check..
    //
    if ( pBinding->stateBinding == BN_stateBound )
    {
        //
        // Make sure we are sending a packet not exceeding the max frame size
        // of the underlying NIC
        //
        if ( pBinding->ulMaxFrameSize + ETHERNET_HEADER_LENGTH >= 
            (ULONG) ( PacketGetLength( pPacket ) + PPPOE_PACKET_HEADER_LENGTH ) )
        {
            NdisSend( &status,
                      pBinding->NdisBindingHandle,
                      PacketGetNdisPacket( pPacket ) );
        }
    }

    if ( status != NDIS_STATUS_PENDING )
    {
        //
        // NdisSend() completed synchronously so call PrSendComplete()
        // manually here.
        //
        PrSendComplete( pBinding, PacketGetNdisPacket( pPacket ), status );

    }

    TRACE( TL_V, TM_Pr, ("-PrSend=$%x",status) );

    return status;
}

VOID
PrStatus(
    IN NDIS_HANDLE ProtocolBindingContext,
    IN NDIS_STATUS GeneralStatus,
    IN PVOID StatusBuffer, 
    IN UINT StatusBufferSize
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    ProtocolStatus is a required driver function that handles status-change 
    notifications raised by an underlying connectionless NIC driver or by NDIS. 

    In this driver, we only use this function to receive Media disconnect
    notifications to disconnect the active calls on that NIC.
        
Parameters:

    ProtocolBindingContext:
        Specifies the handle to a protocol-allocated context area in which the 
        protocol driver maintains per-binding runtime state. The driver supplied this 
        handle when it called NdisOpenAdapter. 
    
    GeneralStatus:
        Indicates the general status code, either raised by NDIS or propagated from 
        the underlying driver's call to NdisMIndicateStatus. 

    StatusBuffer:
        Points to a buffer containing medium-specific data that depends on the value 
        of GeneralStatus. 

        For example, if the GeneralStatus argument is NDIS_STATUS_RING_STATUS, this 
        parameter points to a ULONG-sized bitmask and StatusBufferSize is four. As 
        another example, if GeneralStatus is NDIS_STATUS_WAN_LINE_UP, this parameter 
        points to an NDIS_WAN_LINE_UP structure and StatusBufferSize is sizeof(
        NDIS_STATUS_WAN_LINE_UP). 
        
        For some NDIS_STATUS_XXX values, this pointer is NULL and StatusBufferSize is 
        set to zero. 

    StatusBufferSize:
        Specifies the number of bytes at StatusBuffer. 
    
Return Values:

    None
    
---------------------------------------------------------------------------*/   
{
    BINDING* pBinding = (BINDING*) ProtocolBindingContext;

    ASSERT( VALIDATE_BINDING( pBinding ) );

    TRACE( TL_N, TM_Pr, ("+PrStatus") );

    switch ( GeneralStatus )
    {
        case NDIS_STATUS_MEDIA_DISCONNECT:

            //
            // If the underlying media is disconnected, notify miniport of this event.
            // It will appear to the miniport as if the NIC is removed, so it will drop all the 
            // active calls
            //
            TRACE( TL_N, TM_Pr, ("PrStatus: Notifying miniport of media disconnect event") );

            MpNotifyBindingRemoval( pBinding );

            break;

    }
    
    TRACE( TL_N, TM_Pr, ("-PrStatus") );
}

NDIS_STATUS
PrPnPEvent(
    IN NDIS_HANDLE hProtocolBindingContext,
    IN PNET_PNP_EVENT pNetPnPEvent
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:
    
    ProtocolPnPEvent is a required function in any protocol driver to support 
    Plug and Play and/or Power Management. NDIS calls ProtocolPnPEvent to 
    indicate a Plug and Play event or a Power Management event to a protocol 
    bound to a NIC.

    NDIS calls ProtocolPnPEvent to notify a protocol bound to a network NIC that 
    the operating system has issued a Plug and Play or Power Management event to 
    the device object representing the NIC. NDIS calls the ProtocolPnPEvent 
    function of each protocol bound to the NIC.

    The NET_PNP_EVENT structure passed to ProtocolPnPEvent describes the Plug and 
    Play or Power Management event. ProtocolPnPEvent interprets two basic pieces 
    of information in the NET_PNP_EVENT structure: 

    A NetEvent code that describes the Plug and Play or Power Management event. 
    Event-specific information (for example, for a NetEventSetPower, the device 
    power state to which the device is transitioning). 
    The protocol should save the NetPnPEvent pointer. This pointer is a required 
    input parameter to NdisCompletePnPEvent, which the protocol must subsequently 
    call if ProtocolPnPEvent returns NDIS_STATUS_PENDING.

Parameters

    hProtocolBindingContext:
        Specifies the handle to a protocol-allocated context area in which this 
        driver maintains per-binding runtime state. The protocol supplied this handle 
        when it called NdisOpenAdapter. A NetEventXxx indicated on a NULL 
        ProtocolBindingContext pertains to all network bindings. NetEventBindList and 
        NetEventBindsComplete are always indicated on a NULL ProtocolBindingContext. 
        NetEventReconfigure can be indicated on a particular ProtocolBindingContext 
        or a NULL ProtocolBindingContext. 

    pNetPnPEvent:
        Points to a NET_PNP_EVENT structure, which describes the Plug and Play event 
        or Power Management event being indicated to the protocol driver. 

Return Value

    NDIS_STATUS_SUCCESS:
        The protocol successfully handled the indicated Plug and Play or Power 
        Management event. The meaning of this status code depends on the NetEvent 
        code in the buffered NET_PNP_EVENT structure at NetPnPEvent.

    NDIS_STATUS_PENDING 
        The protocol will return its response to the indicated event asynchronously 
        with a call to NdisCompletePnPEvent. 

    NDIS_STATUS_RESOURCES 
        The protocol could not obtain the necessary system resources to satisfy the 
        indicated Plug and Play or Power Management event. 

    NDIS_STATUS_NOT_SUPPORTED 
        A legacy (non-PnP-aware) protocol can return this status in response to a 
        NetEventSetPower to indicate that NDIS should unbind the it from the NIC. 

    NDIS_STATUS_FAILURE 
        The protocol failed the indicated Plug and Play or Power Management event. 
        The meaning of this status code depends on the NetEvent code in the buffered 
        NET_PNP_EVENT structure at NetPnPEvent.

---------------------------------------------------------------------------*/   
{
    NDIS_STATUS status = NDIS_STATUS_NOT_SUPPORTED;
    BINDING *pBinding = (BINDING*) hProtocolBindingContext;

    TRACE( TL_N, TM_Pr, ("+PrPnpEvent") );

    switch ( pNetPnPEvent->NetEvent ) 
    {
    
        case NetEventQueryPower:
        {
            TRACE( TL_N, TM_Pr, ("PrPnpEvent: NetEventQueryPower") );
            
            status = NDIS_STATUS_SUCCESS;
            break;
        }

        case NetEventQueryRemoveDevice:
        {
            TRACE( TL_N, TM_Pr, ("PrPnpEvent: NetEventQueryRemoveDevice") );
            
            status = NDIS_STATUS_SUCCESS;
            break;
        }
        
        case NetEventCancelRemoveDevice:
        {
            TRACE( TL_N, TM_Pr, ("PrPnpEvent: NetEventCancelRemoveDevice") );
            
            status = NDIS_STATUS_SUCCESS;
            break;
        }
            
        case NetEventReconfigure:
        {
            TRACE( TL_N, TM_Pr, ("PrPnpEvent: NetEventReconfigure") );
            
            status = NDIS_STATUS_SUCCESS;
            break;
        }
            
        case NetEventBindsComplete:
        {
            TRACE( TL_N, TM_Pr, ("PrPnpEvent: NetEventBindsComplete") );
            
            status = NDIS_STATUS_SUCCESS;
            break;
        }
            
        case NetEventPnPCapabilities:
        {
            TRACE( TL_N, TM_Pr, ("PrPnpEvent: NetEventPnPCapabilities") );

            status = NDIS_STATUS_SUCCESS;
            break;
        }
    
        case NetEventBindList:
        {
            TRACE( TL_N, TM_Pr, ("PrPnpEvent: NetEventBindList") );

            status = NDIS_STATUS_SUCCESS;
            break;
        }
        
        case NetEventSetPower:
        {
            BOOLEAN fWakeUp = FALSE;
            BOOLEAN fSleep  = FALSE;
            
            TRACE( TL_N, TM_Pr, ("PrPnpEvent: NetEventSetPower") );

            NdisAcquireSpinLock( &pBinding->lockBinding );

            if ( *( (NDIS_DEVICE_POWER_STATE*) pNetPnPEvent->Buffer ) == NdisDeviceStateD0 )
            {
                if ( pBinding->stateBinding == BN_stateSleeping )
                {
                    TRACE( TL_N, TM_Pr, ("PrPnpEvent: NetEventSetPower - Wake up request") );

                    fWakeUp = TRUE;

                    pBinding->stateBinding = BN_stateBound;

                }

            }
            else if ( *( (NDIS_DEVICE_POWER_STATE*) pNetPnPEvent->Buffer ) > NdisDeviceStateD0 )
            {
                if ( pBinding->stateBinding == BN_stateBound )
                {
                    TRACE( TL_N, TM_Pr, ("PrPnpEvent: NetEventSetPower - Sleep request") );
                    
                    fSleep = TRUE;

                    pBinding->stateBinding = BN_stateSleepPending;
                }

            }

            NdisReleaseSpinLock( &pBinding->lockBinding );

            if ( fSleep )
            {
                //
                // Since this NIC is going to sleep, drop all the calls on it
                //
                MpNotifyBindingRemoval( pBinding );

                //
                // Wait for pending operations to be completed
                //
                TRACE( TL_N, TM_Pr, ("PrPnpEvent: NetEventSetPower - Waiting for pending operations to be completed") );

                NdisAcquireSpinLock( &pBinding->lockBinding );
                
                while ( pBinding->lRef > 1 )
                {
                    NdisReleaseSpinLock( &pBinding->lockBinding );

                    NdisMSleep( 10000 );                

                    NdisAcquireSpinLock( &pBinding->lockBinding );
                }

                pBinding->stateBinding = BN_stateSleeping;

                NdisReleaseSpinLock( &pBinding->lockBinding );
            }

            status = NDIS_STATUS_SUCCESS;
            break;
        }
        
        default:
        {
            TRACE( TL_N, TM_Pr, ("PrPnpEvent: Unknown Event - %x", pNetPnPEvent->NetEvent) );

            status = NDIS_STATUS_NOT_SUPPORTED;
            break;
        }
    
    }

    TRACE( TL_N, TM_Pr, ("-PrPnpEvent=$%x", status) );

    return status;
}

VOID
PrReEnumerateBindings(
    VOID
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:
    
    PrReEnumerateBindings causes NDIS to send bind notifications to the pppoe 
    protocol section for each miniport that it needs to bind to.  It is called 
    when a tapi client is interested in either making an outgoing call or 
    listening for an incoming call.  It is expected that when this function
    returns all of the bindings between the protocol and underlying miniports
    will be finished!

   
Parameters

    None
    
Return Value

    None
---------------------------------------------------------------------------*/   
{
    TRACE( TL_N, TM_Pr, ("+PrReEnumerateBindings") );

    NdisAcquireSpinLock( &gl_lockProtocol );

    gl_fBindProtocol = TRUE;

    NdisReleaseSpinLock( &gl_lockProtocol );

    NdisReEnumerateProtocolBindings(gl_hNdisProtocolHandle);

    TRACE( TL_N, TM_Pr, ("-PrReEnumerateBindings") );
}

VOID
ChangePacketFiltersForAdapters(
   BOOLEAN fSet
   )
{
    LIST_ENTRY* pLink = NULL;

    TRACE( TL_N, TM_Pr, ("+ChangePacketFiltersForAdapters") );
    
    NdisAcquireSpinLock( &gl_lockProtocol );

    gl_fSetPacketFiltersAtBind = fSet;

    pLink = gl_linkBindings.Flink;

    //
    // See if we have any bindings
    //
    if ( pLink != &gl_linkBindings )
    {
        
        BINDING* pBinding = NULL;

        TRACE( TL_N, TM_Pr, ("ChangePacketFiltersForAdapters: %s packet filters", ( fSet ) ? "Setting" : "Resetting") );

        //
        // First reference the bindings in the list and mark their 
        // BNBF_ChangePacketFilterInProgress bit
        //
        while ( pLink != &gl_linkBindings )
        {
            //
            // We have at least one binding, so walk thru the list
            // and reference them
            //
            pBinding = ((BINDING*) CONTAINING_RECORD( pLink, BINDING, linkBindings ));

            NdisAcquireSpinLock( &pBinding->lockBinding );
        
            if ( pBinding->stateBinding == BN_stateBound )
            {
               //
               // If the state of the binding is BN_stateBound then 
               // set the BNBF_PacketFilterChangeInProgress bit, 
               // reference 
               // the binding.
               //
               pBinding->ulBindingFlags |= BNBF_PacketFilterChangeInProgress;

               ReferenceBinding( pBinding, FALSE );
            }

            NdisReleaseSpinLock( &pBinding->lockBinding );

           //
           // Iterate to the next binding
           //
           pLink = pLink->Flink;
        }

        //
        // Now make a second pass and shoot the SetPacket filter request for
        // all the marked items
        //
        pLink = gl_linkBindings.Flink;
        
        while ( pLink != &gl_linkBindings )
        {
           //
           // We have at least one binding, so walk thru the list
           // and reference them
           //
           pBinding = ((BINDING*) CONTAINING_RECORD( pLink, BINDING, linkBindings ));

           //
           // Advance to the next item
           //
           pLink = pLink->Flink;

           NdisReleaseSpinLock( &gl_lockProtocol );

           //
           // If we are just marking, check the state of the binding and mark it
           // by setting the BNBF_SetPacketFilterInProgress bit
           //
           if ( pBinding->ulBindingFlags & BNBF_PacketFilterChangeInProgress )
           {
              //
              // This binding is marked by the previous loop so change the filter
              // for this binding
              //
              PrSetPacketFilterForAdapter( pBinding, fSet );

              //
              // Reset what was done in the first pass
              //
              pBinding->ulBindingFlags &= ~BNBF_PacketFilterChangeInProgress;

              DereferenceBinding( pBinding );

           }

           NdisAcquireSpinLock( &gl_lockProtocol );

        }

    }

    NdisReleaseSpinLock( &gl_lockProtocol );

    TRACE( TL_N, TM_Pr, ("-ChangePacketFiltersForAdapters") );
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ndis\raspppoe\protocol.h ===
#ifndef _PROTOCOL_H_
#define _PROTOCOL_H_

#define PR_NDIS_MajorVersion    4
#define PR_NDIS_MinorVersion    0

#define PR_CHARACTERISTIC_NAME  "RasPppoe"

typedef struct _CALL* PCALL;

/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:
    
   These macros will be called by PacketCreateForReceived() and DereferencePacket() 
   functions when a PPPOE_PACKET with references to a packet owned by NDIS is
   created and freed, respectively.
   
---------------------------------------------------------------------------*/   
#define PrPacketOwnedByNdisReceived( pB ) \
        NdisInterlockedIncrement( &(pB)->NumPacketsOwnedByNdis )

#define PrPacketOwnedByNdisReturned( pB ) \
        NdisInterlockedDecrement( &(pB)->NumPacketsOwnedByNdis )

//
// Constants 
//
#define BN_SetFiltersForMediaDetection 0x00000001
#define BN_SetFiltersForMakeCall       0x00000002
#define BN_ResetFiltersForCloseLine    0x00000003

//
// These are the states that a binding can be in.
// They are pretty self explanatory.
//
typedef enum
_BINDING_STATE
{
    BN_stateIdle = 0,           
    BN_stateBindPending,        
    BN_stateBound,
    BN_stateSleepPending,
    BN_stateSleeping,
    BN_stateUnbindPending,
    BN_stateUnbound
}
BINDING_STATE;

//
// These are the schedulable work items for the bindings:
//  
//  - BWT_workPrSend: This work item is scheduled by PrBroadcast() with a copy of a 
//                    packet given to broadcast. When it runs, it sends the clone packet.
//
//  - BWT_PrReceiveComplete: This work item is scheduled by PrReceivePacket() if a packet is received
//                           and there is no PrReceiveComplete() running to drain the receive queue.
//
typedef enum
_BINDING_WORKTYPE
{
    BWT_workUnknown = 0,
    BWT_workPrStartBinds,
    BWT_workPrSend,
    BWT_workPrReceiveComplete
}
BINDING_WORKTYPE;

//
// This is the binding context.
// All information pertinent to our bindings are kept here.
//
typedef struct
_BINDING
{
    //
    // Link to other bindings in the protocols binding list
    //
    LIST_ENTRY linkBindings;

    //
    // Tag that identifies the binding (used for debugging)
    //
    ULONG tagBinding;

    //
    // Keeps reference count on the binding. 
    // References are added and deleted for the following operations:
    //
    // (a) A reference is added in AddBindingToProtocol and removed in RemoveBindingFromProtocol
    //
    // (b) A reference is added when a call is added, and removed when call is removed.
    //
    // (c) A reference is added when a BWT_workPrSend item is scheduled and removed when
    //     work item is executed.
    //
    // (d) A reference must be added before sending a packet, and must be removed if NdisSend()
    //     completes synchronously. Otherwise it will be removed by PrSendComplete() function
    //     when Ndis calls it to notify the completion of the send.
    //
    LONG lRef;

    //
    // (a) BNBF_OpenAdapterCompleted: This flag will be set by PrOpenAdapterComplete().
    //
    // (b) BNBF_CurrentAddressQueryCompleted: This flag will be set by PrRequestComplete().
    //
    // (c) BNBF_LinkSpeedQueryCompleted: This flag will be set by PrRequestComplete().
    //
    // (d) BNBF_MaxFrameSizeQueryCompleted: This flag will be set by PrRequestComplete().
    //
    // (e) BNBF_BindAdapterCompleted: This flag will be set by PrBindAdapter().
    //
    // (f) BNBF_CloseAdapterCompleted: This flag will be set by PrCloseAdapterComplete().
    //
    // (g) BNBF_PacketFilterSet: This flag indicates that the packet filter for the binding is set.
    //                           It will be set and reset in ChangePacketFiltersForBindings().
    //
    // (h) BNBF_PacketFilterChangeInProgress: This flag indicates that the binding is referenced for
    //                                        packet filter change.
    //
    ULONG ulBindingFlags;
        #define BNBF_OpenAdapterCompleted            0x00000001
        #define BNBF_CurrentAddressQueryCompleted    0x00000002
        #define BNBF_LinkSpeedQueryCompleted         0x00000004
        #define BNBF_MaxFrameSizeQueryCompleted      0x00000008
        #define BNBF_BindAdapterCompleted            0x00000010
        #define BNBF_CloseAdapterCompleted           0x00000020
        #define BNBF_PacketFilterSet                 0x00000040
        #define BNBF_PacketFilterChangeInProgress    0x00000080
          
    //
    // Shows the status of the bind adapter operation.
    // Valid only if BNBF_BindAdapterCompleted is set.
    //
    NDIS_STATUS BindAdapterStatus;

    //
    // Shows the status of the open adapter operation.
    // Valid only if BNBF_OpenAdapterCompleted is set.
    //
    NDIS_STATUS OpenAdapterStatus;

    //
    // Shows the status of the latest request made to NDIS.
    //
    NDIS_STATUS RequestStatus;

    //
    // Ndis Request structure passed to the underlying NIC cards
    //
    NDIS_REQUEST Request;

    //
    // Event to be signaled when requests are completed.
    //
    NDIS_EVENT RequestCompleted;

    //
    // Keeps the MAC address of the NIC card represented by this binding.
    // This information is obtained from the underlying by passing it a set of OID queries
    //
    CHAR LocalAddress[6];

    //
    // Keeps the speed of the NIC cards represented by this binding.
    // This information is obtained from the underlying by passing it a set of OID queries
    //
    ULONG ulSpeed;

    //
    // Max frame size of the underlying NIC
    //
    ULONG ulMaxFrameSize;
    
    //
    // Keeps the filter information for this binding.
    //
    ULONG ulPacketFilter;
    
    //
    // This is the handle returned to us by NdisOpenAdapter().
    // It is the handle for accessing the underlying NIC card represented by this binding.
    //
    NDIS_HANDLE NdisBindingHandle;      

    //
    // This is the index of the supported medium by the underlying NIC card.
    //
    UINT uintSelectedMediumIndex;       

    //
    // This is the event that we wait on in PrUnbindAdapter().
    // It will be signaled from DereferenceBinding() when ref count of the binding reaches 0.
    //
    NDIS_EVENT  eventFreeBinding;       

    //
    // Spin lock to synchronize access to shared members
    //
    NDIS_SPIN_LOCK lockBinding;

    //
    // Indicates state information about the binding
    //
    BINDING_STATE stateBinding;

    //
    // Flag that indicates that the receive loop is running.
    // To make sure the serialization of PPP packets, we can not let more than 1 threads
    // making receive indications to NDISWAN
    //
    BOOLEAN fRecvLoopRunning;

    //
    // List of received packets waiting to be processed by ProtocolReceiveComplete()
    //
    LIST_ENTRY linkPackets;

    //
    // This is the number of packets that are received that are owned by NDIS and must
    // be returned back to NDIS.
    //
    LONG NumPacketsOwnedByNdis;

}
BINDING, *PBINDING;

/////////////////////////////////////////////////////////////////////////////
//
//
// Local macros
//
/////////////////////////////////////////////////////////////////////////////

#define ALLOC_BINDING( ppB )    NdisAllocateMemoryWithTag( ppB, sizeof( BINDING ), MTAG_BINDING )

#define FREE_BINDING( pB )      NdisFreeMemory( pB, sizeof( BINDING ), 0 )

#define VALIDATE_BINDING( pB )  ( ( pB ) && ( pB->tagBinding == MTAG_BINDING ) )

NDIS_STATUS 
InitializeProtocol(
    IN NDIS_HANDLE NdisProtocolHandle,
    IN PUNICODE_STRING RegistryPath
    );

VOID
PrLoad(
    VOID 
    );

BINDING* 
AllocBinding();

VOID 
ReferenceBinding(
    IN BINDING* pBinding,
    IN BOOLEAN fAcquireLock
    );

VOID 
DereferenceBinding(
    IN BINDING* pBinding
    );

VOID 
BindingCleanup(
    IN BINDING* pBinding
    );

VOID
DetermineMaxFrameSize();

VOID
ChangePacketFiltersForAdapters(
   BOOLEAN fSet
   );

VOID 
AddBindingToProtocol(
    IN BINDING* pBinding
    );

VOID 
RemoveBindingFromProtocol(
    IN BINDING* pBinding
    );

VOID
PrUnload(
    VOID 
    );

NDIS_STATUS 
PrRegisterProtocol(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath,
    OUT NDIS_HANDLE* pNdisProtocolHandle
    );

VOID
PrBindAdapter(
    OUT PNDIS_STATUS Status,
    IN NDIS_HANDLE  BindContext,
    IN PNDIS_STRING  DeviceName,
    IN PVOID  SystemSpecific1,
    IN PVOID  SystemSpecific2
    );

BOOLEAN 
PrOpenAdapter(
    IN BINDING* pBinding,
    IN PNDIS_STRING  DeviceName
    );

VOID 
PrOpenAdapterComplete(
    IN NDIS_HANDLE  ProtocolBindingContext,
    IN NDIS_STATUS  Status,
    IN NDIS_STATUS  OpenErrorStatus
    );

VOID
PrStatusComplete(
    IN NDIS_HANDLE ProtocolBindingContext
    );

BOOLEAN
PrQueryAdapterForCurrentAddress(
    IN BINDING* pBinding
    );

BOOLEAN
PrQueryAdapterForLinkSpeed(
    IN BINDING* pBinding
    );

BOOLEAN
PrQueryAdapterForMaxFrameSize(
    IN BINDING* pBinding
    );

BOOLEAN
PrSetPacketFilterForAdapter(
    IN BINDING* pBinding,
    IN BOOLEAN fSet
    );
    
VOID
PrRequestComplete(
    IN NDIS_HANDLE ProtocolBindingContext,
    IN PNDIS_REQUEST pRequest,
    IN NDIS_STATUS status
    );

VOID 
PrUnbindAdapter(
    OUT PNDIS_STATUS  Status,
    IN NDIS_HANDLE  ProtocolBindingContext,
    IN NDIS_HANDLE  UnbindContext
    );

VOID
PrCloseAdapter( 
    IN BINDING* pBinding 
    );

VOID 
PrCloseAdapterComplete(
    IN NDIS_HANDLE  ProtocolBindingContext,
    IN NDIS_STATUS  Status
    );

BOOLEAN 
PrAddCallToBinding(
    IN BINDING* pBinding,
    IN PCALL pCall
    );

VOID 
PrRemoveCallFromBinding(
    IN BINDING* pBinding,
    IN PCALL pCall
    );

VOID 
PrSendComplete(
    IN NDIS_HANDLE ProtocolBindingContext,
    IN PNDIS_PACKET pNdisPacket,
    IN NDIS_STATUS Status
    );

INT 
PrReceivePacket(
    IN NDIS_HANDLE  ProtocolBindingContext,
    IN PNDIS_PACKET  Packet
    );

NDIS_STATUS 
PrBroadcast(
    IN PPPOE_PACKET* pPacket
    );

VOID 
ExecBindingWorkItem(
    PVOID Args[4],
    UINT workType
    );  

NDIS_STATUS
PrReceive(
    IN NDIS_HANDLE  ProtocolBindingContext,
    IN NDIS_HANDLE  MacReceiveContext,
    IN PVOID  HeaderBuffer,
    IN UINT  HeaderBufferSize,
    IN PVOID  LookAheadBuffer,
    IN UINT  LookaheadBufferSize,
    IN UINT  PacketSize
    );
    
VOID
PrTransferDataComplete(
    IN NDIS_HANDLE  ProtocolBindingContext,
    IN PNDIS_PACKET  Packet,
    IN NDIS_STATUS  Status,
    IN UINT  BytesTransferred
    );
    
VOID
PrReceiveComplete(
    IN NDIS_HANDLE ProtocolBindingContext
    );

ULONG
PrQueryMaxFrameSize();

NDIS_STATUS
PrSend(
    IN BINDING* pBinding,
    IN PPPOE_PACKET* pPacket
    );

VOID
PrStatus(
    IN NDIS_HANDLE ProtocolBindingContext,
    IN NDIS_STATUS GeneralStatus,
    IN PVOID StatusBuffer, 
    IN UINT StatusBufferSize
    );  

NDIS_STATUS
PrPnPEvent(
    IN NDIS_HANDLE hProtocolBindingContext,
    IN PNET_PNP_EVENT pNetPnPEvent
    );
    
VOID
PrReEnumerateBindings(
    VOID
    );
  
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ndis\raspppoe\ppool.h ===
// Copyright (c) 1997, Microsoft Corporation, all rights reserved
//
// ppool.h
// RAS L2TP WAN mini-port/call-manager driver
// Packet pool management header
//
// 01/07/97 Steve Cobb, adapted from Gurdeep's WANARP code.


#ifndef _PPOOL_H_
#define _PPOOL_H_


//-----------------------------------------------------------------------------
// Data structures
//-----------------------------------------------------------------------------

// Packet pool control block.  A packet pool encapsulates an NDIS packet pool
// handling all pool growth and shrinkage internally.
//
typedef struct
_PACKETPOOL
{
    // Size in bytes of the ProtocolReserved array for each packet in the
    // pool.
    //
    ULONG ulProtocolReservedLength;

    // The optimal number of packets to allocate in each packet block.
    //
    ULONG ulPacketsPerBlock;

    // Maximum number of individual packets that may be allocated in the
    // entire pool, or 0 for unlimited.
    //
    ULONG ulMaxPackets;

    // Current number of individual packets allocated in the entire pool.
    //
    ULONG ulCurPackets;

    // Garbage collection occurs after this many calls to FreePacketToPool.
    //
    ULONG ulFreesPerCollection;

    // Number of calls to FreeBufferToPool since a garbage collection.
    //
    ULONG ulFreesSinceCollection;

    // Memory identification tag for allocated blocks.
    //
    ULONG ulTag;

    // Head of the double linked list of PACKETBLOCKHEADs.  Access to the list
    // is protected with 'lock' in this structure.
    //
    LIST_ENTRY listBlocks;

    // Head of the double linked list of free PACKETHEADs.  Each PACKETHEAD in
    // the list is ready to go, i.e. it already has an NDIS_PACKET associated
    // with it.  Access to the list is prototected by 'lock' in this
    // structure.  Interlocked push/pop is not used because (a) the list of
    // blocks and this list must lock each other and (b) double links are
    // necessary for garbage collection.
    //
    LIST_ENTRY listFreePackets;

    // This lock protects this structure and both the list of blocks and the
    // list of packets.
    //
    NDIS_SPIN_LOCK lock;
}
PACKETPOOL;


// Header of a single block of packets from a packet pool.  The PACKETHEAD of
// the first buffer immediately follows.
//
typedef struct
_PACKETBLOCKHEAD
{
    // Links to the prev/next packet block header in the packet pool's list.
    //
    LIST_ENTRY linkBlocks;

    // NDIS's handle of the pool of NDIS_PACKET descriptors associated with
    // this block, or NULL if none.
    //
    NDIS_HANDLE hNdisPool;

    // Back pointer to the packet pool.
    //
    PACKETPOOL* pPool;

    // Number of individual packets in this block.
    //
    ULONG ulPackets;

    // Number of individual packets in this block on the free list.
    //
    ULONG ulFreePackets;
}
PACKETBLOCKHEAD;


// Control information for an individual packet.  For the packet pool, this
// "header" does not actually preceed anything, but this keeps the terminology
// consistent with the very similar buffer pool routines.
//
typedef struct
_PACKETHEAD
{
    // Link to next packet header in the packet pool's free list.
    //
    LIST_ENTRY linkFreePackets;

    // Back link to owning packet block header.
    //
    PACKETBLOCKHEAD* pBlock;

    // NDIS packet descriptor of this buffer.
    //
    NDIS_PACKET* pNdisPacket;
}
PACKETHEAD;


//-----------------------------------------------------------------------------
// Interface prototypes and inline definitions
//-----------------------------------------------------------------------------

VOID
InitPacketPool(
    OUT PACKETPOOL* pPool,
    IN ULONG ulProtocolReservedLength,
    IN ULONG ulMaxPackets,
    IN ULONG ulPacketsPerBlock,
    IN ULONG ulFreesPerCollection,
    IN ULONG ulTag );

BOOLEAN
FreePacketPool(
    IN PACKETPOOL* pPool );

NDIS_PACKET*
GetPacketFromPool(
    IN PACKETPOOL* pPool,
    OUT PACKETHEAD** ppHead );
	
VOID
FreePacketToPool(
    IN PACKETPOOL* pPool,
    IN PACKETHEAD* pHead,
    IN BOOLEAN fGarbageCollection );

PACKETPOOL*
PacketPoolFromPacketHead(
    IN PACKETHEAD* pHead );

VOID
CollectPacketPoolGarbage(
    PACKETPOOL* pPool );

__inline
PACKETPOOL*
PacketPoolFromPacketHead(
    IN PACKETHEAD* pHead )

    // Returns the address of the pool, given 'pHead', the address of a
    // PACKETHEAD like the one returned from GetPacketFromPool.
    //
{
    return pHead->pBlock->pPool;
}


#endif // PPOOL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ndis\raspppoe\tapi.h ===
#ifndef _TAPI_H_
#define _TAPI_H_

#define ALLOC_LINE( ppL ) NdisAllocateMemoryWithTag( (PVOID*) ppL, sizeof( LINE ), MTAG_LINE )

#define FREE_LINE( pL ) NdisFreeMemory( (PVOID) pL, sizeof( LINE ), 0 );

#define VALIDATE_LINE( pL ) ( (pL) && (pL->tagLine == MTAG_LINE) )

#define ALLOC_CALL( ppC ) NdisAllocateMemoryWithTag( (PVOID*) ppC, sizeof( CALL ), MTAG_CALL )

#define FREE_CALL( pC ) NdisFreeMemory( (PVOID) pC, sizeof( CALL ), 0 );

#define VALIDATE_CALL( pC ) ( (pC) && (pC->tagCall == MTAG_CALL) )

VOID 
ReferenceCall(
	IN CALL* pCall,
	IN BOOLEAN fAcquireLock
	);

VOID 
DereferenceCall(
	IN CALL *pCall
	);

VOID 
ReferenceLine(
	IN LINE* pLine,
	IN BOOLEAN fAcquireLock
	);

VOID 
DereferenceLine(
	IN LINE *pLine
	);

VOID 
ReferenceTapiProv(
	IN ADAPTER* pAdapter,
	IN BOOLEAN fAcquireLock
	);

VOID 
DereferenceTapiProv(
	IN ADAPTER *pAdapter
	);

NDIS_STATUS 
TpProviderInitialize(
	IN ADAPTER* pAdapter,
	IN PNDIS_TAPI_PROVIDER_INITIALIZE pRequest
	);

NDIS_STATUS
TpProviderShutdown(
    IN ADAPTER* pAdapter,
    IN PNDIS_TAPI_PROVIDER_SHUTDOWN pRequest,
    IN BOOLEAN fNotifyNDIS
	);

NDIS_STATUS
TpOpenLine(
    ADAPTER* pAdapter,
    PNDIS_TAPI_OPEN pRequest
    );

NDIS_STATUS 
TpCloseLine(
	IN ADAPTER* pAdapter,
	IN PNDIS_TAPI_CLOSE pRequest,
	IN BOOLEAN fNotifyNDIS
	);

NDIS_STATUS 
TpCloseCall(
	IN ADAPTER* pAdapter,
	IN PNDIS_TAPI_CLOSE_CALL pRequest,
	IN BOOLEAN fNotifyNDIS
	);

NDIS_STATUS
TpDropCall(
	IN ADAPTER* pAdapter,
	IN PNDIS_TAPI_DROP pRequest,
	IN ULONG ulLineDisconnectMode
	);

VOID 
TpCloseCallComplete(
	IN CALL* pCall
	);

VOID 
TpCloseLineComplete(
	IN LINE* pLine
	);

VOID 
TpProviderShutdownComplete(
	IN ADAPTER* pAdapter
	);

VOID 
TpProviderCleanup(
	IN ADAPTER* pAdapter
	);

VOID 
TpLineCleanup(
	IN LINE* pLine
	);

VOID 
TpCallCleanup(
	IN CALL* pCall 
	);

NDIS_STATUS
TpSetDefaultMediaDetection(
    IN ADAPTER* pAdapter,
    IN PNDIS_TAPI_SET_DEFAULT_MEDIA_DETECTION pRequest
    );

VOID
TpSetDefaultMediaDetectionComplete(
   IN LINE* pLine,
   IN PNDIS_TAPI_SET_DEFAULT_MEDIA_DETECTION pRequest   
   );

NDIS_STATUS
TpNegotiateExtVersion(
    IN ADAPTER* pAdapter,
    IN PNDIS_TAPI_NEGOTIATE_EXT_VERSION pRequest
    );

NDIS_STATUS
TpGetExtensionId(
    IN ADAPTER* pAdapter,
    IN PNDIS_TAPI_GET_EXTENSION_ID pRequest
    );

NDIS_STATUS
TpGetAddressStatus(
    IN ADAPTER* pAdapter,
    IN PNDIS_TAPI_GET_ADDRESS_STATUS pRequest
    );

NDIS_STATUS
TpGetId(
    IN ADAPTER* pAdapter,
    IN PNDIS_TAPI_GET_ID pRequest,
    IN ULONG ulRequestLength
    );

NDIS_STATUS
TpGetDevCaps(
    IN ADAPTER* pAdapter,
    IN PNDIS_TAPI_GET_DEV_CAPS pRequest
    );

NDIS_STATUS
TpGetCallStatus(
    IN ADAPTER* pAdapter,
    IN PNDIS_TAPI_GET_CALL_STATUS pRequest
    );

NDIS_STATUS
TpGetCallInfo(
    IN ADAPTER* pAdapter,
    IN PNDIS_TAPI_GET_CALL_INFO pRequest
    );

NDIS_STATUS
TpGetAddressCaps(
    IN ADAPTER* pAdapter,
    IN PNDIS_TAPI_GET_ADDRESS_CAPS pRequest
    );

NDIS_STATUS
TpSetStatusMessages(
    IN ADAPTER* pAdapter,
    IN PNDIS_TAPI_SET_STATUS_MESSAGES pRequest
    );

VOID
TpCallStateChangeHandler(
	IN CALL* pCall,
    IN ULONG ulCallState,
    IN ULONG ulStateParam
	);

NDIS_STATUS
TpMakeCall(
    IN ADAPTER* pAdapter,
    IN PNDIS_TAPI_MAKE_CALL pRequest,
    IN ULONG ulRequestLength
    );

VOID
TpMakeCallComplete(
   IN CALL* pCall,
   IN PNDIS_TAPI_MAKE_CALL pRequest   
   );
    
NDIS_STATUS
TpCallInitialize(
	IN CALL* pCall,
	IN LINE* pLine,
	IN HTAPI_CALL htCall,
	IN BOOLEAN fIncoming
	);
    
NDIS_STATUS
TpAnswerCall(
    IN ADAPTER* pAdapter,
    IN PNDIS_TAPI_ANSWER pRequest
    );	

VOID 
ExecAdapterWorkItem(
	IN PVOID Args[4],
	IN UINT workType
	);

VOID
TpReceiveCall(
	IN ADAPTER* pAdapter,
	IN BINDING* pBinding,
	IN PPPOE_PACKET* pPacket
	);	

BOOLEAN
TpIndicateNewCall(
	IN CALL* pCall
	);	

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ndis\raspppoe\tapi.c ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Module Name:

    tapi.c

Abstract:

    This module contains all the TAPI_OID processing routines.  

Author:

    Hakan Berk - Microsoft, Inc. (hakanb@microsoft.com) Feb-2000

Environment:

    Windows 2000 kernel mode Miniport driver or equivalent.

Revision History:

---------------------------------------------------------------------------*/

#include <ntddk.h>
#include <ntddndis.h>
#include <ndis.h>
#include <ndiswan.h>
#include <ndistapi.h>
#include <ntverp.h>

#include "debug.h"
#include "timer.h"
#include "bpool.h"
#include "ppool.h"
#include "util.h"
#include "packet.h"
#include "protocol.h"
#include "miniport.h"
#include "tapi.h"
#include "fsm.h"

extern TIMERQ gl_TimerQ;

extern NPAGED_LOOKASIDE_LIST gl_llistWorkItems;

///////////////////////////////////////////////////////////////////////////////////
//
// Tapi provider, line and call context functions
//
///////////////////////////////////////////////////////////////////////////////////

VOID 
ReferenceCall(
    IN CALL* pCall,
    IN BOOLEAN fAcquireLock
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function will increment the reference count on the call object.
    
    CAUTION: If fAcquireLock is set, this function will acquire the lock for the
             call, otherwise it will assume the caller owns the lock.
    
Parameters:

    pCall _ A pointer to our call information structure.

    fAcquireLock _ Indicates if the caller already has the lock or not.
                   Caller must set this flag to FALSE if it has the lock, 
                   otherwise it must be supplied as TRUE.

Return Values:

    None
---------------------------------------------------------------------------*/
{
    LONG lRef;
    
    TRACE( TL_V, TM_Tp, ("+ReferenceCall") );

    if ( fAcquireLock )
        NdisAcquireSpinLock( &pCall->lockCall );

    lRef = ++pCall->lRef;

    if ( fAcquireLock )
        NdisReleaseSpinLock( &pCall->lockCall );

    TRACE( TL_V, TM_Tp, ("-ReferenceCall=$%d",lRef) );
}

VOID 
DereferenceCall(
    IN CALL *pCall
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function will decrement the reference count on the call object

    If ref count drops to 0 (which means the call has been closed),
    it will set the CLBF_CallClosed bit. Then it will call TpCloseCallComplete() 
    function which eventually handles destroying the resources allocated for 
    this call context.

    CAUTION: All locks must be released before calling this function because
             it may cause a set of cascading events.

Parameters:

    pCall _ A pointer ot our call information structure.

Return Values:

    None
---------------------------------------------------------------------------*/
{
    BOOLEAN fCallTpCloseCallComplete = FALSE;
    LONG lRef;

    TRACE( TL_V, TM_Tp, ("+DereferenceCall") );

    NdisAcquireSpinLock( &pCall->lockCall );

    lRef = --pCall->lRef;

    if ( lRef == 0 )
    {
        pCall->ulClFlags &= ~CLBF_CallOpen;
        pCall->ulClFlags &= ~CLBF_CallClosePending;
        pCall->ulClFlags |= CLBF_CallClosed;
        
        fCallTpCloseCallComplete = TRUE;
    }

    NdisReleaseSpinLock( &pCall->lockCall );

    if ( fCallTpCloseCallComplete )
        TpCloseCallComplete( pCall );

    TRACE( TL_V, TM_Tp, ("-DereferenceCall=$%d",lRef) );
}


VOID 
ReferenceLine(
    IN LINE* pLine,
    IN BOOLEAN fAcquireLock
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function will increment the reference count on the line object.
    
    CAUTION: If fAcquireLock is set, this function will acquire the lock for the
             line, otherwise it will assume the caller owns the lock.
    
Parameters:

    pLine _ A pointer to our line information structure.

    fAcquireLock _ Indicates if the caller already has the lock or not.
                   Caller must set this flag to FALSE if it has the lock, 
                   otherwise it must be supplied as TRUE.

Return Values:

    None
---------------------------------------------------------------------------*/
{
    LONG lRef;
    
    TRACE( TL_V, TM_Tp, ("+ReferenceLine") );

    if ( fAcquireLock )
        NdisAcquireSpinLock( &pLine->lockLine );

    lRef = ++pLine->lRef;

    if ( fAcquireLock )
        NdisReleaseSpinLock( &pLine->lockLine );

    TRACE( TL_V, TM_Tp, ("-ReferenceLine=$%d",lRef) );
        
}

VOID 
DereferenceLine(
    IN LINE *pLine
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function will decrement the reference count on the line object

    If the ref count drops to 0 (which means the line has been closed),
    it will set the LNBF_CallClosed bit. Then it will call TpCloseLineComplete() 
    function which eventually handles destroying the resources allocated for 
    this line context.

    CAUTION: All locks must be released before calling this function because
             it may cause a set of cascading events.
    
Parameters:

    pLine _ A pointer to our line information structure.

Return Values:

    None
---------------------------------------------------------------------------*/
{
    BOOLEAN fCallTpCloseLineComplete = FALSE;
    LONG lRef;

    TRACE( TL_V, TM_Tp, ("+DereferenceLine") );
    

    NdisAcquireSpinLock( &pLine->lockLine );

    lRef = --pLine->lRef;
    
    if ( lRef == 0 )
    {
        pLine->ulLnFlags &= ~LNBF_LineOpen;
        pLine->ulLnFlags &= ~LNBF_LineClosePending;
        pLine->ulLnFlags |= LNBF_LineClosed;

        fCallTpCloseLineComplete = TRUE;
    }

    NdisReleaseSpinLock( &pLine->lockLine );

    if ( fCallTpCloseLineComplete )
        TpCloseLineComplete( pLine );

    TRACE( TL_V, TM_Tp, ("-DereferenceLine=$%d",lRef) );
}

VOID 
ReferenceTapiProv(
    IN ADAPTER* pAdapter,
    IN BOOLEAN fAcquireLock
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function will increment the reference count on the tapi prov object.
    
    CAUTION: If fAcquireLock is set, this function will acquire the lock for the
             line, otherwise it will assume the caller owns the lock.
    
Parameters:

    pAdapter _ A pointer to our adapter information structure.

    fAcquireLock _ Indicates if the caller already has the lock or not.
                   Caller must set this flag to FALSE if it has the lock, 
                   otherwise it must be supplied as TRUE.

Return Values:

    None
---------------------------------------------------------------------------*/
{
    LONG lRef;
    
    TRACE( TL_V, TM_Tp, ("+ReferenceTapiProv") );

    if ( fAcquireLock )
        NdisAcquireSpinLock( &pAdapter->lockAdapter );

    lRef = ++pAdapter->TapiProv.lRef;

    if ( fAcquireLock )
        NdisReleaseSpinLock( &pAdapter->lockAdapter );

    TRACE( TL_V, TM_Tp, ("-ReferenceTapiProv=$%d",lRef) );
}


VOID 
DereferenceTapiProv(
    IN ADAPTER *pAdapter
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function will decrement the reference count on the tapi prov object

    CAUTION: All locks must be released before calling this function because
             it may cause a set of cascading events.
    
Parameters:

    pAdapter _ A pointer to our adapter line information structure.

Return Values:

    None
---------------------------------------------------------------------------*/
{
    BOOLEAN fCallTpProviderShutdownComplete = FALSE;
    LONG lRef;

    TRACE( TL_V, TM_Tp, ("+DereferenceTapiProv") );

    NdisAcquireSpinLock( &pAdapter->lockAdapter );

    lRef = --pAdapter->TapiProv.lRef;
    
    if ( lRef == 0 )
    {
        pAdapter->TapiProv.ulTpFlags &= ~TPBF_TapiProvInitialized;
        pAdapter->TapiProv.ulTpFlags &= ~TPBF_TapiProvShutdownPending;
        pAdapter->TapiProv.ulTpFlags |= TPBF_TapiProvShutdown;
        
        fCallTpProviderShutdownComplete = TRUE;
    }

    NdisReleaseSpinLock( &pAdapter->lockAdapter );

    if ( fCallTpProviderShutdownComplete )
        TpProviderShutdownComplete( pAdapter );

    TRACE( TL_V, TM_Tp, ("-DereferenceTapiProv=$%d",lRef) );
        
}

NDIS_STATUS 
TpProviderInitialize(
    IN ADAPTER* pAdapter,
    IN PNDIS_TAPI_PROVIDER_INITIALIZE pRequest
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This request initializes the TAPI portion of the miniport.

    It will set Tapi Provider's state to initialize, and reference both the
    owning adapter and tapi provider.

Parameters:

    Adapter _ A pointer ot our adapter information structure.

    Request _ A pointer to the NDIS_TAPI request structure for this call.

    typedef struct _NDIS_TAPI_PROVIDER_INITIALIZE
    {
        IN  ULONG       ulRequestID;
        IN  ULONG       ulDeviceIDBase;
        OUT ULONG       ulNumLineDevs;
        OUT ULONG       ulProviderID;

    } NDIS_TAPI_PROVIDER_INITIALIZE, *PNDIS_TAPI_PROVIDER_INITIALIZE;

Return Values:

    NDIS_STATUS_SUCCESS

---------------------------------------------------------------------------*/
{
    NDIS_STATUS status = NDIS_STATUS_RESOURCES;

    ASSERT( VALIDATE_ADAPTER( pAdapter ) );

    TRACE( TL_N, TM_Tp, ("+TpProviderInitialize") );

    do 
    {
        if ( pRequest == NULL || pAdapter == NULL )
        {
            TRACE( TL_A, TM_Tp, ("TpProviderInitialize: Invalid parameter") );  

            status = NDIS_STATUS_TAPI_INVALPARAM;

            break;
        }

        //
        // Initialize the tapi provider context
        //
        NdisZeroMemory( &pAdapter->TapiProv, sizeof( pAdapter->TapiProv ) );
    
        //
        // Try to allocate resources
        //
        NdisAllocateMemoryWithTag( (PVOID) &pAdapter->TapiProv.LineTable, 
                                   sizeof( LINE* ) * pAdapter->nMaxLines,
                                   MTAG_TAPIPROV );
    
        if ( pAdapter->TapiProv.LineTable == NULL )
        {
            TRACE( TL_A, TM_Tp, ("TpProviderInitialize: Could not allocate line table") );  

            break;
        }

        NdisZeroMemory( pAdapter->TapiProv.LineTable, sizeof( LINE* ) * pAdapter->nMaxLines );

        pAdapter->TapiProv.hCallTable = InitializeHandleTable( pAdapter->nMaxLines * pAdapter->nCallsPerLine );

        if ( pAdapter->TapiProv.hCallTable == NULL )
        {
            TRACE( TL_A, TM_Tp, ("TpProviderInitialize: Could not allocate call handle table") );   

            break;
        }
    
        pAdapter->TapiProv.ulTpFlags = TPBF_TapiProvInitialized;
    
        pAdapter->TapiProv.ulDeviceIDBase = pRequest->ulDeviceIDBase;

        //
        // Do referencing
        //
        ReferenceTapiProv( pAdapter, FALSE );
    
        ReferenceAdapter( pAdapter, TRUE );

        status = NDIS_STATUS_SUCCESS;

    } while ( FALSE );

    if ( status == NDIS_STATUS_SUCCESS )
    {
        //
        // Set output information
        //
        pRequest->ulNumLineDevs = pAdapter->nMaxLines;
    
        pRequest->ulProviderID = (ULONG_PTR) pAdapter->MiniportAdapterHandle;

    }
    else
    {
        //
        // Somethings failed, clean up
        //
        TpProviderCleanup( pAdapter );
    }

    TRACE( TL_N, TM_Tp, ("-TpProviderInitialize=$%x",status) );
    
    return status;
}

NDIS_STATUS
TpProviderShutdown(
    IN ADAPTER* pAdapter,
    IN PNDIS_TAPI_PROVIDER_SHUTDOWN pRequest,
    IN BOOLEAN fNotifyNDIS
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This request shuts down the miniport. The miniport should terminate any 
    activities it has in progress.

    This operation might pend as there might be lines and call contexts still 
    active. So this function marks the tapi provider context as close pending
    and calls TpCloseLine() on all active calls, and removes the reference added
    on the tapi provider in TpProviderInitialize(). 

    When ref count on the tapi provider context reaches 0, TpProviderShutdownComplete()
    will be called to clean up the tapi provider context, and remove the reference 
    on the owning adapter.

Parameters:

    pAdapter _ A pointer to our adapter information structure.

    pRequest _ A pointer to the NDIS_TAPI request structure for this call.
               If supplied as NULL, then we do not need to notify NDIS.

    typedef struct _NDIS_TAPI_PROVIDER_SHUTDOWN
    {
        IN  ULONG       ulRequestID;

    } NDIS_TAPI_PROVIDER_SHUTDOWN, *PNDIS_TAPI_PROVIDER_SHUTDOWN;


    fNotifyNDIS _ Indicates if NDIS needs to be notified about the completion 
                  of this operation

Return Values:

    NDIS_STATUS_SUCCESS:
        Tapi provider shutdown and cleaned up succesfully.
    
    NDIS_STATUS_PENDING
        Shutdown operation is pending. When all shutdown operation completes
        owning adapter context will be dereferenced.

---------------------------------------------------------------------------*/
{
    NDIS_STATUS status;
    BOOLEAN fDereferenceTapiProv = FALSE;
    BOOLEAN fLockAcquired = FALSE;
    
    ASSERT( VALIDATE_ADAPTER( pAdapter ) );

    TRACE( TL_N, TM_Tp, ("+TpProviderShutdown") );

    do
    {
        if ( pRequest == NULL || pAdapter == NULL )
        {
            TRACE( TL_A, TM_Tp, ("TpProviderShutdown: Invalid parameter") );    

            status = NDIS_STATUS_TAPI_INVALPARAM;

            break;
        }

        NdisAcquireSpinLock( &pAdapter->lockAdapter );

        fLockAcquired = TRUE;

        //
        // See if tapi provider was initialized at all
        //
        if ( !( pAdapter->TapiProv.ulTpFlags & TPBF_TapiProvInitialized ) )
        {
            //
            // Tapi provider was not initialized so just return
            //
            status = NDIS_STATUS_SUCCESS;
            
            break;
        }


        //
        // See if we can shutdown immediately
        //
        if ( pAdapter->TapiProv.lRef == 1 )
        {
            //
            // We are holding the only reference, so we can shutdown immediately
            //
            pAdapter->TapiProv.ulTpFlags &= ~TPBF_TapiProvInitialized;
    
            pAdapter->TapiProv.ulTpFlags |= TPBF_TapiProvShutdown;
    
            status = NDIS_STATUS_SUCCESS;
        }
        else
        {
            UINT i;
    
            //
            // Mark Tapi provider as shutdown pending
            //
            pAdapter->TapiProv.ulTpFlags |= TPBF_TapiProvShutdownPending;
            
            //
            // Mark tapi prov if the result of this operation needs to be reported to NDIS
            //
            if ( fNotifyNDIS )
                pAdapter->TapiProv.ulTpFlags |= TPBF_NotifyNDIS;
    
            // 
            // Close all active lines
            //
            for ( i = 0; i < pAdapter->nMaxLines; i++)
            {
                NDIS_TAPI_CLOSE DummyRequest;
            
                LINE* pLine = (LINE*) pAdapter->TapiProv.LineTable[i];
    
                if ( pLine )
                {
                            
                    DummyRequest.hdLine = pLine->hdLine;
    
                    NdisReleaseSpinLock( &pAdapter->lockAdapter );
        
                    TpCloseLine( pAdapter, &DummyRequest, FALSE );
        
                    NdisAcquireSpinLock( &pAdapter->lockAdapter );
                }
    
            }

            status = NDIS_STATUS_PENDING;       
        }

        fDereferenceTapiProv = TRUE;
        
    } while ( FALSE );

    if ( fLockAcquired ) 
    {
        NdisReleaseSpinLock( &pAdapter->lockAdapter );
    }

    if ( fDereferenceTapiProv )
    {
        DereferenceTapiProv( pAdapter );
    }

    TRACE( TL_N, TM_Tp, ("-TpProviderShutdown=$%x",status) );

    return status;
}

#define INVALID_LINE_HANDLE                         (HDRV_LINE) -1

HDRV_LINE
TpGetHdLineFromDeviceId(
               ADAPTER* pAdapter,
               ULONG ulID
               )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function is used to map a Tapi Device Id to the driver's line handle.
    It returns INVALID_LINE_HANDLE if it can not map the device id.

    REMARK: 
      - pAdapter must not be NULL.
      - It must be called from one of the Tp...OidHandler() functions since
        this function relies on this and assumes there won't be any 
        synchronization problems.

Parameters:

    pAdapter _ A pointer to our adapter information structure.

    uldID _ Device Id that identifies a line context
    
Return Values:

    Handle to the line context if device id can be mapped to a valid line context,
    and INVALID_LINE_HANDLE otherwise.
       
---------------------------------------------------------------------------*/
{
    if ( !( pAdapter->TapiProv.ulTpFlags & TPBF_TapiProvShutdownPending ) &&
          ( pAdapter->TapiProv.ulTpFlags & TPBF_TapiProvInitialized ) )
    {
        if ( ( ulID < ( pAdapter->TapiProv.ulDeviceIDBase + pAdapter->nMaxLines ) ) &&                    
             ( ulID >= pAdapter->TapiProv.ulDeviceIDBase ) )                                    
        {
            return (HDRV_LINE) ( ulID - pAdapter->TapiProv.ulDeviceIDBase );
        }
    }

    return INVALID_LINE_HANDLE;
}

LINE* 
TpGetLinePtrFromHdLineEx(
               ADAPTER* pAdapter,
               HDRV_LINE hdLine
               )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function is used to map a driver line handle to the line context ptr.
    It returns NULL if it can not map the handle. This is exactly the same as
    TpGetLinePtrFromHdLine function except that it doesn't check for the
    shutdown state.

    REMARK: 
      - pAdapter must not be NULL.
      - It must be called from one of the Tp...OidHandler() functions since
        this function relies on this and assumes there won't be any 
        synchronization problems. 
        (Basically assumes pAdapter->lock is being held)

Parameters:

    pAdapter _ A pointer to our adapter information structure.

    hdL _ Driver's line handle
    
Return Values:

    Pointer to the Line context associated with the Line handle provided
    if mapping is succesful, and NULL otherwise.
    
---------------------------------------------------------------------------*/
{
    if ( pAdapter->TapiProv.ulTpFlags & TPBF_TapiProvInitialized )
    {
        if ( ( (ULONG) hdLine < (ULONG) pAdapter->nMaxLines ) )
        {
            ASSERT( pAdapter->TapiProv.LineTable != 0 );
            
            return pAdapter->TapiProv.LineTable[ (ULONG) hdLine ];
        }
    }

    return NULL;
}


LINE* 
TpGetLinePtrFromHdLine(
               ADAPTER* pAdapter,
               HDRV_LINE hdLine
               )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function is used to map a driver line handle to the line context ptr.
    It returns NULL if it can not map the handle.

    REMARK: 
      - pAdapter must not be NULL.
      - It must be called from one of the Tp...OidHandler() functions since
        this function relies on this and assumes there won't be any 
        synchronization problems. 
        (Basically assumes pAdapter->lock is being held)

Parameters:

    pAdapter _ A pointer to our adapter information structure.

    hdL _ Driver's line handle
    
Return Values:

    Pointer to the Line context associated with the Line handle provided
    if mapping is succesful, and NULL otherwise.
    
---------------------------------------------------------------------------*/
{
    if ( !( pAdapter->TapiProv.ulTpFlags & TPBF_TapiProvShutdownPending ) &&
          ( pAdapter->TapiProv.ulTpFlags & TPBF_TapiProvInitialized ) )
    {
        if ( ( (ULONG) hdLine < (ULONG) pAdapter->nMaxLines ) )
        {
            ASSERT( pAdapter->TapiProv.LineTable != 0 );
            
            return pAdapter->TapiProv.LineTable[ (ULONG) hdLine ];
        }
    }

    return NULL;
}


NDIS_STATUS
TpOpenLine(
    ADAPTER* pAdapter,
    PNDIS_TAPI_OPEN pRequest
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function opens the line device whose device ID is given, returning
    the miniports handle for the device. The miniport must retain the
    Connection Wrapper's handle for the device for use in subsequent calls to
    the LINE_EVENT callback procedure.

    hdLine returned is the index to the pAdapter->TapiProv.LineTable array
    that holds the pointer to the new line context.

Parameters:

    pAdapter _ A pointer to our adapter information structure.

    pRequest - A pointer to the NDIS_TAPI request structure for this call.

    typedef struct _NDIS_TAPI_OPEN
    {
        IN  ULONG       ulRequestID;
        IN  ULONG       ulDeviceID;
        IN  HTAPI_LINE  htLine;
        OUT HDRV_LINE   hdLine;

    } NDIS_TAPI_OPEN, *PNDIS_TAPI_OPEN;

Return Values:

    NDIS_STATUS_SUCCESS
    NDIS_STATUS_PENDING
    NDIS_STATUS_TAPI_ALLOCATED
    NDIS_STATUS_TAPI_INVALMEDIAMODE
    NDIS_STATUS_FAILURE
    
---------------------------------------------------------------------------*/
{
    NDIS_STATUS status = NDIS_STATUS_FAILURE;
    HDRV_LINE hdLine = INVALID_LINE_HANDLE;
    LINE* pLine = NULL;

    ASSERT( VALIDATE_ADAPTER( pAdapter ) );

    TRACE( TL_N, TM_Tp, ("+TpOpenLine") );

    do
    {
        if ( pRequest == NULL || pAdapter == NULL )
        {
            TRACE( TL_A, TM_Tp, ("TpOpenLine: Invalid parameter") );    

            status = NDIS_STATUS_TAPI_INVALPARAM;

            break;
        }
    
        //
        // Map the device id to an entry in our line table
        //
        hdLine = TpGetHdLineFromDeviceId( pAdapter, pRequest->ulDeviceID );

        if ( hdLine == INVALID_LINE_HANDLE )
        {
            TRACE( TL_N, TM_Tp, ("TpOpenLine: Invalid handle supplied") );  

            break;
        }

        //
        // Make sure the line is not busy already
        //
        if ( TpGetLinePtrFromHdLine( pAdapter, hdLine ) != NULL )
        {
            TRACE( TL_N, TM_Tp, ("TpOpenLine: Line is busy") ); 

            break;
        }

        //
        // Allocate the line context
        //
        if ( ALLOC_LINE( &pLine ) != NDIS_STATUS_SUCCESS )
        {
            TRACE( TL_A, TM_Tp, ("TpOpenLine: Could not allocate context") );   

            break;
        }

        //
        // Initialize line context
        //
        NdisZeroMemory( pLine, sizeof( LINE ) );
        
        pLine->tagLine = MTAG_LINE;

        NdisAllocateSpinLock( &pLine->lockLine );

        pLine->ulLnFlags = LNBF_LineOpen;

        if ( pAdapter->fClientRole )
        {
            pLine->ulLnFlags |= LNBF_MakeOutgoingCalls;
        }

        //
        // Copy related info from adapter context
        //
        pLine->pAdapter = pAdapter;

        pLine->nMaxCalls = pAdapter->nCallsPerLine;

        InitializeListHead( &pLine->linkCalls );

        //
        // Set tapi handles
        //
        pLine->htLine = pRequest->htLine;

        pLine->hdLine = hdLine;
        
        //
        // Insert new line context to line table of tapi provider
        //
        NdisAcquireSpinLock( &pAdapter->lockAdapter );
        
        pAdapter->TapiProv.LineTable[ (ULONG) hdLine ] = pLine;

        pAdapter->TapiProv.nActiveLines++;

        NdisReleaseSpinLock( &pAdapter->lockAdapter );

        //
        // Do referencing
        //
        ReferenceLine( pLine, FALSE );

        ReferenceTapiProv( pAdapter, TRUE );

        status = NDIS_STATUS_SUCCESS;
        
    } while ( FALSE );

    if ( status == NDIS_STATUS_SUCCESS )
    {
        pRequest->hdLine = hdLine;
    }
        
    TRACE( TL_N, TM_Tp, ("-TpOpenLine=$%x",status) );

    return status;
}

NDIS_STATUS 
TpCloseLine(
    IN ADAPTER* pAdapter,
    IN PNDIS_TAPI_CLOSE pRequest,
    IN BOOLEAN fNotifyNDIS
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This request closes the specified open line device after completing or
    aborting all outstanding calls and asynchronous requests on the device.

    It will remove the reference on the line context added in TpOpenLine().

    It will be called from 2 places:
        1. When miniport receives an OID_TAPI_CLOSE.
           In this case, fNotifyNDIS will be set as TRUE.
           
        2. When miniport is halting, TpProviderShutdown() will call
           this function for every active line context.
    
Parameters:

    pAdapter _ A pointer ot our adapter information structure.

    pRequest _ A pointer to the NDIS_TAPI request structure for this call.

    typedef struct _NDIS_TAPI_CLOSE
    {
        IN  ULONG       ulRequestID;
        IN  HDRV_LINE   hdLine;

    } NDIS_TAPI_CLOSE, *PNDIS_TAPI_CLOSE;

    fNotifyNDIS _ Indicates if NDIS needs to be notified about the completion 
                  of this operation
                  
Return Values:

    NDIS_STATUS_SUCCESS: Line context destroyed succesfully.
        
    NDIS_STATUS_PENDING: Close operation is pending. When line is closed, 
                         tapi provider will be dereferenced.
        
    NDIS_STATUS_TAPI_INVALLINEHANDLE: An invalid handle was supplied. 
                                      No operations performed.

---------------------------------------------------------------------------*/
{
    LINE* pLine = NULL;
    BOOLEAN fLockReleased = FALSE;
    NDIS_STATUS status = NDIS_STATUS_SUCCESS;
    
    ASSERT( VALIDATE_ADAPTER( pAdapter ) );

    TRACE( TL_N, TM_Tp, ("+TpCloseLine") );


    do
    {
        if ( pRequest == NULL || pAdapter == NULL )
        {
            TRACE( TL_A, TM_Tp, ("TpCloseLine: Invalid parameter") );   

            status = NDIS_STATUS_TAPI_INVALPARAM;

            break;
        }

        pLine = TpGetLinePtrFromHdLineEx( pAdapter, pRequest->hdLine );


        if ( pLine == NULL )
        {
            TRACE( TL_N, TM_Tp, ("TpCloseLine: Invalid handle supplied") ); 

            status = NDIS_STATUS_TAPI_INVALLINEHANDLE;
            
            break;
        }

        //
        // Remove line context from tapi providers line table
        // and invalidate the handle, as we do not want any more 
        // requests on this line context.
        //
        // The active line counter will be adjusted in TpCloseLineComplete()
        // when we deallocate the line context.
        //
        NdisAcquireSpinLock( &pAdapter->lockAdapter );
    
        pAdapter->TapiProv.LineTable[ (ULONG) pRequest->hdLine ] = NULL;
    
        NdisReleaseSpinLock( &pAdapter->lockAdapter );

        //
        // Now start closing the line
        //
        NdisAcquireSpinLock( &pLine->lockLine );

        //
        // Do not accept any more incoming calls
        //
        pLine->ulLnFlags &= ~LNBF_AcceptIncomingCalls;

        //
        // Mark the line as close pending, so that we do not accept
        // any more requests on it
        //
        pLine->ulLnFlags |= LNBF_LineClosePending;

        if ( fNotifyNDIS )
            pLine->ulLnFlags |= LNBF_NotifyNDIS;

        while ( !IsListEmpty( &pLine->linkCalls ) )
        {
            CALL* pCall = NULL;
            NDIS_TAPI_CLOSE_CALL DummyRequest;
            
            //
            // Retrieve a call context from the head of active call list
            // and close it.
            //
            pCall = (CALL*) CONTAINING_RECORD( pLine->linkCalls.Flink,
                                               CALL,
                                               linkCalls );

            NdisReleaseSpinLock( &pLine->lockLine );

            DummyRequest.hdCall = pCall->hdCall;

            //
            // This will remove the call from the list,
            // so there will be a new call at the head of the list
            // next time we retrieve.
            //
            TpCloseCall( pAdapter, &DummyRequest, FALSE );

            NdisAcquireSpinLock( &pLine->lockLine );
        } 

        status = NDIS_STATUS_PENDING;
        
    } while ( FALSE );

    if ( status == NDIS_STATUS_PENDING )
    {
        BOOLEAN fNotifyTapiOfInternalLineClose = !( pLine->ulLnFlags & LNBF_NotifyNDIS );
    
        NdisReleaseSpinLock( &pLine->lockLine );

        //
        // Check if this is an internal request to close the line, 
        // notify TAPI if it is
        //
        if ( fNotifyTapiOfInternalLineClose )
        {
            NDIS_TAPI_EVENT TapiEvent;

            NdisZeroMemory( &TapiEvent, sizeof( NDIS_TAPI_EVENT ) );
            
            TapiEvent.htLine = pLine->htLine;
            TapiEvent.ulMsg = LINE_CLOSE;

            NdisMIndicateStatus( pLine->pAdapter->MiniportAdapterHandle,
                                 NDIS_STATUS_TAPI_INDICATION,
                                 &TapiEvent,
                                 sizeof( NDIS_TAPI_EVENT ) );   
        }

        if ( pAdapter->TapiProv.nActiveLines == 1 )
        {
            //
            // We are closing the last line so notify protocol about this so
            // it can remove packet filters
            //
            WORKITEM* pWorkItem = NULL;
            PVOID Args[4];

            Args[0] = (PVOID) BN_ResetFiltersForCloseLine;           // Is a reset filters request
            Args[1] = (PVOID) pLine;
       
            //
            // Allocate work item for reenumerating bindings
            //
            pWorkItem = AllocWorkItem( &gl_llistWorkItems,
                                       ExecBindingWorkItem,
                                       NULL,
                                       Args,
                                       BWT_workPrStartBinds );

            if ( pWorkItem ) 
            {
               //
               // Schedule the work item.
               //
               // Note that we need to referencing here, because we do not want TpCloseLineCopmlete()
               // to be called before the work item is executed.
               //
               // This reference will be removed when the work item is executed.
               //
               ReferenceLine( pLine, TRUE );
               
               ScheduleWorkItem( pWorkItem );

               //
               // In this case this request will be completed later
               //
               status = NDIS_STATUS_PENDING;
            }
        }            

        //
        // Remove the reference added in line open
        //
        DereferenceLine( pLine );

    }

    TRACE( TL_N, TM_Tp, ("-TpCloseLine=$%x",status) );

    return status;
}


NDIS_STATUS 
TpCloseCall(
    IN ADAPTER* pAdapter,
    IN PNDIS_TAPI_CLOSE_CALL pRequest,
    IN BOOLEAN fNotifyNDIS
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function is called to close a call.

    It will remove one of the references added in TpMakeCall() on the call
    context.
    
    It will be called from 2 places:
        1. When miniport receives an OID_TAPI_CLOSE_CALL.
           In this case, fNotifyNDIS will be set as TRUE.
           
        2. When miniport is halting, TpCloseLine() will call
           this function for every active call context.
   
Parameters:

    pAdapter _ A pointer to our adapter information structure.
    
    pRequest _ A pointer to the NDIS_TAPI request structure for this call.

    typedef struct _NDIS_TAPI_CLOSE_CALL
    {
        IN  ULONG       ulRequestID;
        IN  HDRV_CALL   hdCall;

    } NDIS_TAPI_CLOSE_CALL, *PNDIS_TAPI_CLOSE_CALL;


    fNotifyNDIS _ Indicates if NDIS needs to be notified about the completion 
                  of this operation
    
Return Values:

    NDIS_STATUS_SUCCESS: Call is succesfully closed and resources are freed.
    
    NDIS_STATUS_PENDING: Call close is pending on active calls.
                         When call is closed the owning line context will be
                         dereferenced.
                         
---------------------------------------------------------------------------*/
    
{
    NDIS_STATUS status = NDIS_STATUS_FAILURE;
    CALL* pCall = NULL;
    BOOLEAN fLockReleased = FALSE;
    BOOLEAN fDereferenceCall = FALSE;

    ASSERT( VALIDATE_ADAPTER( pAdapter ) );

    TRACE( TL_N, TM_Tp, ("+TpCloseCall") );
    
    do
    {
        if ( pRequest == NULL || pAdapter == NULL )
        {
            TRACE( TL_A, TM_Tp, ("TpCloseCall: Invalid parameter") );   

            status = NDIS_STATUS_TAPI_INVALPARAM;

            break;
        }

        pCall = RetrieveFromHandleTable( pAdapter->TapiProv.hCallTable,
                                         (NDIS_HANDLE) pRequest->hdCall );

        if ( pCall == NULL )
        {
            TRACE( TL_N, TM_Tp, ("TpCloseCall: Invalid handle supplied") ); 
        
            break;
        }

        //
        // Now start closing the call
        //
        NdisAcquireSpinLock( &pCall->lockCall );

        /*
        if ( !fNotifyNDIS )
        {
            //
            // Request is not coming from TAPI directly, so see if we have informed TAPI of
            // a new call, because if we have then we can not close the call now, we should 
            // wait for TAPI to close it.
            //
            if ( pCall->htCall )
            {
                TRACE( TL_N, TM_Tp, ("TpCloseCall: Internal close request for a TAPI informed call, can not close now") );

                NdisReleaseSpinLock( &pCall->lockCall );

                status = NDIS_STATUS_FAILURE;

                break;
            }

        }
        */

        //
        // See if call is already closed or closing
        //
        if ( pCall->ulClFlags & CLBF_CallClosePending ||
             pCall->ulClFlags & CLBF_CallClosed )
        {
            TRACE( TL_N, TM_Tp, ("TpCloseCall: Close request on an already closed call") );
            
            NdisReleaseSpinLock( &pCall->lockCall );

            status = NDIS_STATUS_FAILURE;

            break;
        }

        //
        // Mark call if we need to notify NDIS about the completion of close
        //
        if ( fNotifyNDIS )
            pCall->ulClFlags |= CLBF_NotifyNDIS;

        //
        // Mark call as close pending
        //
        pCall->ulClFlags |= CLBF_CallClosePending;
        
        //
        // Drop the call first
        //
        NdisReleaseSpinLock( &pCall->lockCall );

        //
        // Drop will take care of unbinding and cancelling the timer
        //
        {
            NDIS_TAPI_DROP DummyRequest;

            DummyRequest.hdCall = pRequest->hdCall;
            
            TpDropCall( pAdapter, &DummyRequest, 0 );
        }

        status = NDIS_STATUS_PENDING;

    } while ( FALSE );

    if ( status == NDIS_STATUS_SUCCESS ||
         status == NDIS_STATUS_PENDING )
    {
        LINE* pLine = pCall->pLine;
        
        //
        // Remove call from line's active call list, and decrement 
        // active call counter
        //
        NdisAcquireSpinLock( &pLine->lockLine );

        RemoveHeadList( pCall->linkCalls.Blink );
    
        pLine->nActiveCalls--;
        
        NdisReleaseSpinLock( &pLine->lockLine );

        //
        // We should now remove the call from the Tapi provider's call table,
        // and invalidate its' handle
        //
        NdisAcquireSpinLock( &pAdapter->lockAdapter );
    
        RemoveFromHandleTable( pAdapter->TapiProv.hCallTable,
                               (NDIS_HANDLE) pCall->hdCall );
    
        NdisReleaseSpinLock( &pAdapter->lockAdapter );

        //
        // Remove the reference for close call
        //
        DereferenceCall( pCall );
    }

    TRACE( TL_N, TM_Tp, ("-TpCloseCall=$%x",status) );
    
    return status;
}

NDIS_STATUS
TpDropCall(
    IN ADAPTER* pAdapter,
    IN PNDIS_TAPI_DROP pRequest,
    IN ULONG ulLineDisconnectMode
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function will be called from a couple of places:
        1. If miniport receives an OID_TAPI_DROP_CALL request from TAPI.

        2. When NIC for the call is unbound, it will call TpUnbindCall(),
           and if the call is not dropped yet, it will call TpDropCall().

        3. When the call is in connect pending stage but the call needs
           to be dropped.

        4. When session is up and call receives a PADT packet from the peer.

    As this is a synchronous call, we do not need an fNotifyNDIS flag.
    
    CAUTION: All locks must be released before calling this function.
    
Parameters:

    pAdapter _ A pointer to our adaptert information structure.

    pRequest _ A pointer to the NDIS_TAPI request structure for this call.

    typedef struct _NDIS_TAPI_DROP
    {
        IN  ULONG       ulRequestID;
        IN  HDRV_CALL   hdCall;
        IN  ULONG       ulUserUserInfoSize;
        IN  UCHAR       UserUserInfo[1];

    } NDIS_TAPI_DROP, *PNDIS_TAPI_DROP; 

    ulLineDisconnectMode _ Reason for dropping the call. This is reported 
                           back to TAPI in the appropriate state change
                           notification.

Return Values:

    NDIS_STATUS_SUCCESS: Call is succesfully dropped.
    
---------------------------------------------------------------------------*/   
{
    NDIS_STATUS status = NDIS_STATUS_SUCCESS;
    CALL* pCall = NULL;
    BOOLEAN fSendPADT = FALSE;
    BINDING* pBinding = NULL;
    PPPOE_PACKET* pPacket = NULL;
    BOOLEAN fTapiNotifiedOfNewCall = FALSE;

    ASSERT( VALIDATE_ADAPTER( pAdapter ) );

    TRACE( TL_N, TM_Tp, ("+TpDropCall") );


    do
    {
        if ( pRequest == NULL || pAdapter == NULL )
        {
            TRACE( TL_A, TM_Tp, ("TpDropCall: Invalid parameter") );    


            status = NDIS_STATUS_TAPI_INVALPARAM;

            break;
        }

        //
        // Retrieve the pointer to call from the handle table
        //
        pCall = RetrieveFromHandleTable( pAdapter->TapiProv.hCallTable, 
                                         (NDIS_HANDLE) pRequest->hdCall );

        if ( pCall == NULL )
        {
            TRACE( TL_N, TM_Tp, ("TpDropCall: Invalid handle supplied") );  

            break;
        }

        NdisAcquireSpinLock( &pCall->lockCall );

        //
        // Make sure call is not dropped or closed previously
        //
        if ( pCall->ulClFlags & CLBF_CallDropped || pCall->ulClFlags & CLBF_CallClosed)
        {
            //
            // Call already dropped, quit
            //
            NdisReleaseSpinLock( &pCall->lockCall );

            TRACE( TL_N, TM_Tp, ("TpDropCall: Call already dropped or closed") );   

            break;
        }

        // 
        // Then we must be in open state either connected, or connect pending
        //
        ASSERT( pCall->ulClFlags & CLBF_CallOpen );

        pCall->ulClFlags &= ~CLBF_CallOpen;
        pCall->ulClFlags &= ~CLBF_CallConnectPending;
        pCall->ulClFlags |= CLBF_CallDropped;

        if ( pCall->htCall )
        {
            fTapiNotifiedOfNewCall = TRUE;
        }
        
        //
        // Save the binding pointer as we will detach call from it soon
        //
        pBinding = pCall->pBinding;

        if ( pCall->usSessionId && pBinding )
        {
            //
            // Prepare a PADT packet to send if:
            // - A session id is assigned to the call (which is different than fSessionUp)
            //   A session id is assigned to the call when the peer is informed about the session,
            //   however fSessionUp will be TRUE when NDISWAN is notified about the call
            //
            // - A binding exists to send the PADT packet
            //

            status = PacketInitializePADTToSend( &pPacket,
                                                 pCall->SrcAddr,
                                                 pCall->DestAddr,
                                                 pCall->usSessionId );

            if ( status == NDIS_STATUS_SUCCESS )
            {
                //
                // The following references are mandatory as in case PrSend() returns status pending,
                // they will be removed by PrSendComplete()
                //
                ReferencePacket( pPacket );
    
                ReferenceBinding( pBinding, TRUE );
    
                fSendPADT = TRUE;
            }

            //
            // Ignore the current status as this does not affect 
            // the status of the Drop operation.
            //
            status = NDIS_STATUS_SUCCESS;
        }

        //
        // Release the lock to take care of rest of the operation
        //
        NdisReleaseSpinLock( &pCall->lockCall );

        //
        // Cancels the timer if it is set, otherwise it will not have any effect.
        //
        TimerQCancelItem( &gl_TimerQ, &pCall->timerTimeout );

        //
        // Send PADT here if we need to
        //
        if ( fSendPADT )
        {
            NDIS_STATUS SendStatus;

            SendStatus = PrSend( pBinding, pPacket );

            PacketFree( pPacket );
        }

        //
        // This will unbind us from the underlying NIC context if we are bound
        //
        if ( pBinding )
        {
            PrRemoveCallFromBinding( pBinding, pCall );
        }

        //
        // If TAPI was already notified of the call, move it to disconnected state
        //
        if ( fTapiNotifiedOfNewCall )
        {
            TpCallStateChangeHandler( pCall, 
                                      LINECALLSTATE_DISCONNECTED, 
                                      ulLineDisconnectMode );

        }
        
        //
        // Remove the reference added in TpMakeCall() that corresponds 
        // to the drop of the call.
        //
        DereferenceCall( pCall );

    } while ( FALSE );

    TRACE( TL_N, TM_Tp, ("-TpDropCall=$%x",status) );

    return status;
}


VOID 
TpCloseCallComplete(
    IN CALL* pCall
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function will be called only from DereferenceCall().
    It will only be called if ref count of the call drops to 0.

    When this function is called, it will deallocate the call context,
    and dereference the line context.
    
    If call contexts CLBF_NotifyNDIS flag is set, then it will call 
    NdisMQueryInformationComplete().

Parameters:

    pCall    _ A pointer to the call context that will be freed.
    
Return Values:

    None
                             
---------------------------------------------------------------------------*/
    
{
    LINE* pLine = NULL;

    ASSERT( VALIDATE_CALL( pCall ) );

    TRACE( TL_N, TM_Tp, ("+TpCloseCallComplete") );

    //
    // No need to use spin locks here, as our ref count has dropped to 0, and
    // we should not be getting anymore requests on this call
    //
    pLine = pCall->pLine;

    //
    // CAUTION: Give an NDIS_MAC_LINE_DOWN indication here.
    //          It would be better to give this at drop time, but in that case
    //          there is a small timing window where NdisLinkHandle will be invalid 
    //          and although NDISWAN protects itself against invalid handles, it might
    //          assert in checked builds, so instead I will do it here.
    //         
    //          If problems occur with this approach, then I will do it at drop time.
    //
    if ( pCall->stateCall == CL_stateSessionUp )
    {
        NDIS_MAC_LINE_DOWN LineDownInfo;

        //
        // Fill-in the line down structure
        //
        LineDownInfo.NdisLinkContext = pCall->NdisLinkContext;

        //
        // Reflect the change onto the call
        //
        pCall->stateCall = CL_stateDisconnected;

        pCall->NdisLinkContext = 0;

        TRACE( TL_N, TM_Tp, ("TpCloseCallComplete: Indicate NDIS_STATUS_WAN_LINE_DOWN") );

        NdisMIndicateStatus( pCall->pLine->pAdapter->MiniportAdapterHandle,
                             NDIS_STATUS_WAN_LINE_DOWN,
                             &LineDownInfo,
                             sizeof( NDIS_MAC_LINE_DOWN ) );    
         
    }

    if ( pCall->ulClFlags & CLBF_NotifyNDIS )
    {

        TRACE( TL_N, TM_Tp, ("TpCloseCallComplete: Notifying NDIS") );  

        //
        // The close call was a result of OID_TAPI_CLOSE_CALL request so complete the request.
        // There is a small timing window where this call may happen before MpSetInformation()
        // returns NDIS_STATUS_PENDING, but ArvindM says this is not a problem.
        //
        NdisMSetInformationComplete( pLine->pAdapter->MiniportAdapterHandle, NDIS_STATUS_SUCCESS );
    }

    //
    // Clean up the call context
    //
    TpCallCleanup( pCall );

    //
    // Remove the reference on the owning line
    //
    DereferenceLine( pLine );

    TRACE( TL_N, TM_Tp, ("-TpCloseCallComplete") );

}


VOID 
TpCloseLineComplete(
    IN LINE* pLine
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function will be called to indicate that a line has been closed, and 
    the line context can be freed.

    It will only be called from DereferenceLine() if ref count on the line context
    drops to 0.

    It will also remove the reference on the owning tapi provider context.
    
Parameters:

    pLine    _ A pointer to our line information structure that is closed 
               and ready to be deallocated.
               
Return Values:

    None
---------------------------------------------------------------------------*/
{
    IN ADAPTER* pAdapter = NULL;

    ASSERT( VALIDATE_LINE( pLine ) );

    TRACE( TL_N, TM_Tp, ("+TpCloseLineComplete") );

    pAdapter = pLine->pAdapter;

    //
    // Decrement the tapi provider's active line counter
    //
    NdisAcquireSpinLock( &pAdapter->lockAdapter );

    pAdapter->TapiProv.nActiveLines--;
    
    NdisReleaseSpinLock( &pAdapter->lockAdapter );

    //
    // Notify NDIS if necesarry
    //
    if ( pLine->ulLnFlags & LNBF_NotifyNDIS )
    {

        TRACE( TL_N, TM_Tp, ("TpCloseLineComplete: Notifying NDIS") );  

        //
        // Line was closed as a result of OID_TAPI_CLOSE request,
        // so indicate the completion.
        //
        NdisMSetInformationComplete( pAdapter->MiniportAdapterHandle, NDIS_STATUS_SUCCESS );
    }

    //
    // Clean up line context
    //
    TpLineCleanup( pLine );

    //
    // Remove the reference on the owning tapi provider
    //
    DereferenceTapiProv( pAdapter );

    TRACE( TL_N, TM_Tp, ("-TpCloseLineComplete") );
}

VOID 
TpProviderShutdownComplete(
    IN ADAPTER* pAdapter
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function will only be called from DereferenceTapiProv() if ref count
    on the tapi provider object drops to 0.

    It will do the necesarry clean up on the tapi provider context, and dereference
    the owning adapter context.
    
Parameters:

    pAdapter _ A pointer to our adapter information structure.

Return Values:

    None
---------------------------------------------------------------------------*/
{
    ASSERT( VALIDATE_ADAPTER( pAdapter ) );

    TRACE( TL_N, TM_Tp, ("+TpProviderShutdownComplete") );

    //
    // See if we need to notify NDIS about the completion of shut down.
    //
    if ( pAdapter->TapiProv.ulTpFlags & TPBF_NotifyNDIS )
    {

        TRACE( TL_N, TM_Tp, ("TpProviderShutdownComplete: Notifying NDIS") );   

        //
        // Tapi was shut down as a result of OID_TAPI_PROVIDER_SHUTDOWN request,
        // so indicate the completion.
        //
        NdisMSetInformationComplete( pAdapter->MiniportAdapterHandle, NDIS_STATUS_SUCCESS );
    }

    //
    // Clean up tapi provider
    //
    TpProviderCleanup( pAdapter );

    //
    // Remove the reference on the owning adapter context
    //
    DereferenceAdapter( pAdapter );

    TRACE( TL_N, TM_Tp, ("-TpProviderShutdownComplete") );

}

VOID 
TpProviderCleanup(
    IN ADAPTER* pAdapter
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function will do the necesarry clean up on the tapi provider deallocating
    all of its resources.
    
Parameters:

    pAdapter _ A pointer to our adapter information structure.

Return Values:

    None
---------------------------------------------------------------------------*/   
{
    ASSERT( VALIDATE_ADAPTER( pAdapter ) );

    TRACE( TL_N, TM_Tp, ("+TpProviderCleanup") );

    if ( pAdapter )
    {
        NdisAcquireSpinLock( &pAdapter->lockAdapter );
    
        if ( pAdapter->TapiProv.LineTable )
        {
            NdisFreeMemory( pAdapter->TapiProv.LineTable,
                            sizeof( LINE* ) * pAdapter->nMaxLines,
                            0 );
    
            pAdapter->TapiProv.LineTable = NULL;
        }
    
        if ( pAdapter->TapiProv.hCallTable )
        {
            FreeHandleTable( pAdapter->TapiProv.hCallTable );
            
            pAdapter->TapiProv.hCallTable = NULL;
        }
    
        NdisZeroMemory( &pAdapter->TapiProv, sizeof( pAdapter->TapiProv ) );
    
        NdisReleaseSpinLock( &pAdapter->lockAdapter );
    }

    TRACE( TL_N, TM_Tp, ("-TpProviderCleanup") );
}

VOID 
TpLineCleanup(
    IN LINE* pLine
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function will do the necesarry clean up on the line context deallocating
    all of its resources.
    
Parameters:

    pLine _ A pointer to our line information structure.

Return Values:

    None
---------------------------------------------------------------------------*/   
{
    ASSERT( VALIDATE_LINE( pLine ) );

    TRACE( TL_N, TM_Tp, ("+TpLineCleanup") );

    NdisFreeSpinLock( &pLine->lockLine );

    FREE_LINE( pLine );

    TRACE( TL_N, TM_Tp, ("-TpLineCleanup") );
}

VOID 
TpCallCleanup(
    IN CALL* pCall 
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function will do the necesarry clean up on the call context deallocating
    all of its resources.
    
Parameters:

    pCall _ A pointer to our call information structure.

Return Values:

    None
---------------------------------------------------------------------------*/       
{
    PPPOE_PACKET* pPacket = NULL;
    LIST_ENTRY* pLink = NULL;
    
    ASSERT( VALIDATE_CALL( pCall ) );

    TRACE( TL_N, TM_Tp, ("+TpCallCleanup") );

    NdisFreeSpinLock( &pCall->lockCall );

    if ( pCall->pSendPacket )
        PacketFree( pCall->pSendPacket );

    while ( pCall->nReceivedPackets > 0 )
    {
        pLink = RemoveHeadList( &pCall->linkReceivedPackets );

        pCall->nReceivedPackets--;

        pPacket = (PPPOE_PACKET*) CONTAINING_RECORD( pLink, PPPOE_PACKET, linkPackets );

        DereferencePacket( pPacket );
    }
    
    FREE_CALL( pCall );

    TRACE( TL_N, TM_Tp, ("-TpCallCleanup") );
}


NDIS_STATUS
TpSetDefaultMediaDetection(
    IN ADAPTER* pAdapter,
    IN PNDIS_TAPI_SET_DEFAULT_MEDIA_DETECTION pRequest
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This request informs the miniport of the new set of media modes to detect 
    for the indicated line (replacing any previous set).

Parameters:

    pAdapter _ A pointer ot our adapter information structure.

    pRequest _ A pointer to the NDIS_TAPI request structure for this call.

    typedef struct _NDIS_TAPI_SET_DEFAULT_MEDIA_DETECTION
    {
        IN  ULONG       ulRequestID;
        IN  HDRV_LINE   hdLine;
        IN  ULONG       ulMediaModes;

    } NDIS_TAPI_SET_DEFAULT_MEDIA_DETECTION, *
PNDIS_TAPI_SET_DEFAULT_MEDIA_DETECTION;

Return Values:

    NDIS_STATUS_SUCCESS
    NDIS_STATUS_TAPI_INVALLINEHANDLE

---------------------------------------------------------------------------*/
{
    LINE* pLine = NULL;
    NDIS_STATUS status = NDIS_STATUS_SUCCESS;

    ASSERT( VALIDATE_ADAPTER( pAdapter ) );

    TRACE( TL_N, TM_Tp, ("+TpSetDefaultMediaDetection") );

    if ( pRequest == NULL || pAdapter == NULL )
    {
        TRACE( TL_A, TM_Tp, ("TpSetDefaultMediaDetection: Invalid parameter") );    

        TRACE( TL_N, TM_Tp, ("-TpSetDefaultMediaDetection=$%x",NDIS_STATUS_TAPI_INVALPARAM) );

        return NDIS_STATUS_TAPI_INVALPARAM;
    }

    //
    // Retrieve the pointer to line context
    //
    pLine = TpGetLinePtrFromHdLine( pAdapter, pRequest->hdLine );

    if ( pLine == NULL )
    {
        TRACE( TL_N, TM_Tp, ("-TpSetDefaultMediaDetection=$%x",NDIS_STATUS_TAPI_INVALLINEHANDLE) );

        return NDIS_STATUS_TAPI_INVALLINEHANDLE;
    }

    //
    // We only accept this request if we are not in client mode, and digital media
    // is one of the modes proposed
    //
    if ( ( pRequest->ulMediaModes & LINEMEDIAMODE_DIGITALDATA ) && !pAdapter->fClientRole )
    {
        pLine->ulLnFlags |= LNBF_AcceptIncomingCalls;
    }
    else
    {
        pLine->ulLnFlags &= ~LNBF_AcceptIncomingCalls;
    }

    {
        //
        // Schedule a work item to reenumerate bindings
        //
        WORKITEM* pWorkItem = NULL;
        PVOID Args[4];
             
        Args[0] = (PVOID) BN_SetFiltersForMediaDetection;           // Is a set filters request
        Args[1] = (PVOID) pLine;
        Args[2] = (PVOID) pRequest;

        //
        // Allocate work item for reenumerating bindings
        //
        pWorkItem = AllocWorkItem( &gl_llistWorkItems,
                                   ExecBindingWorkItem,
                                   NULL,
                                   Args,
                                   BWT_workPrStartBinds );

        if ( pWorkItem ) 
        {
            //
            // Schedule work item.
            //
            // Note that we do not need to referencing becaue we are not completing
            // the query information request at this point, so nothing can go wrong
            // untill it is completed, and it will be done when the work item is executed.
            //
            ScheduleWorkItem( pWorkItem );
      
            //
            // In this case this request will be completed later
            //
            status = NDIS_STATUS_PENDING;
        }
    }

    TRACE( TL_N, TM_Tp, ("-TpSetDefaultMediaDetection=$%x",status) );

    return status;
}

VOID
TpSetDefaultMediaDetectionComplete(
   IN LINE* pLine,
   IN PNDIS_TAPI_SET_DEFAULT_MEDIA_DETECTION pRequest   
   )
{
   TRACE( TL_N, TM_Tp, ("+TpSetDefaultMediaDetectionComplete") );

   NdisMQueryInformationComplete( pLine->pAdapter->MiniportAdapterHandle,
                                  NDIS_STATUS_SUCCESS );
                                  
   TRACE( TL_N, TM_Tp, ("-TpSetDefaultMediaDetectionComplete=$%x", NDIS_STATUS_SUCCESS) );
}


#define TAPI_EXT_VERSION                0x00010000

NDIS_STATUS
TpNegotiateExtVersion(
    IN ADAPTER* pAdapter,
    IN PNDIS_TAPI_NEGOTIATE_EXT_VERSION pRequest
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This request returns the highest extension version number the service
    provider is willing to operate under for this device given the range of
    possible extension versions.

Parameters:

    pAdapter _ A pointer ot our adapter information structure.

    pRequest _ A pointer to the NDIS_TAPI request structure for this call.

    typedef struct _NDIS_TAPI_NEGOTIATE_EXT_VERSION
    {
        IN  ULONG       ulRequestID;
        IN  ULONG       ulDeviceID;
        IN  ULONG       ulLowVersion;
        IN  ULONG       ulHighVersion;
        OUT ULONG       ulExtVersion;
    } NDIS_TAPI_NEGOTIATE_EXT_VERSION, *PNDIS_TAPI_NEGOTIATE_EXT_VERSION;

Return Values:

    NDIS_STATUS_SUCCESS
    NDIS_STATUS_TAPI_INCOMPATIBLEEXTVERSION

---------------------------------------------------------------------------*/
{
    ASSERT( VALIDATE_ADAPTER( pAdapter ) );

    TRACE( TL_N, TM_Tp, ("+TpNegotiateExtVersion") );

    if ( pRequest == NULL || pAdapter == NULL )
    {
        TRACE( TL_A, TM_Tp, ("TpNegotiateExtVersion: Invalid parameter") ); 

        TRACE( TL_N, TM_Tp, ("-TpNegotiateExtVersion=$%x",NDIS_STATUS_TAPI_INVALPARAM) );

        return NDIS_STATUS_TAPI_INVALPARAM;
    }

    //
    // Make sure the miniport's version number is within the allowable
    // range requested by the caller.  
    //
    // We ignore the ulDeviceID because the version information applies 
    // to all devices on this adapter.
    //
    if ( TAPI_EXT_VERSION < pRequest->ulLowVersion ||
         TAPI_EXT_VERSION > pRequest->ulHighVersion )
    {
        TRACE( TL_N, TM_Tp, ("-TpNegotiateExtVersion=$%x",NDIS_STATUS_TAPI_INCOMPATIBLEEXTVERSION) );
    
        return NDIS_STATUS_TAPI_INCOMPATIBLEEXTVERSION;
    }

    //
    // Looks like we're compatible, so tell the caller what we expect.
    //
    pRequest->ulExtVersion = TAPI_EXT_VERSION;

    TRACE( TL_N, TM_Tp, ("-TpNegotiateExtVersion=$%x",NDIS_STATUS_SUCCESS) );

    return NDIS_STATUS_SUCCESS;
}

NDIS_STATUS
TpGetExtensionId(
    IN ADAPTER* pAdapter,
    IN PNDIS_TAPI_GET_EXTENSION_ID pRequest
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This request returns the extension ID that the miniport supports for the
    indicated line device.

Parameters:

    pAdapter _ A pointer ot our adapter information structure.

    pRequest _ A pointer to the NDIS_TAPI request structure for this call.

    typedef struct _NDIS_TAPI_GET_EXTENSION_ID
    {
        IN  ULONG       ulRequestID;
        IN  ULONG       ulDeviceID;
        OUT LINE_EXTENSION_ID   LineExtensionID;

    } NDIS_TAPI_GET_EXTENSION_ID, *PNDIS_TAPI_GET_EXTENSION_ID;

    typedef struct _LINE_EXTENSION_ID
    {
        ULONG   ulExtensionID0;
        ULONG   ulExtensionID1;
        ULONG   ulExtensionID2;
        ULONG   ulExtensionID3;

    } LINE_EXTENSION_ID, *PLINE_EXTENSION_ID;

Return Values:

    NDIS_STATUS_SUCCESS
    NDIS_STATUS_TAPI_NODRIVER

---------------------------------------------------------------------------*/
{
    HDRV_LINE hdLine = INVALID_LINE_HANDLE;
    
    ASSERT( VALIDATE_ADAPTER( pAdapter ) );

    TRACE( TL_N, TM_Tp, ("+TpGetExtensionId") );

    if ( pRequest == NULL || pAdapter == NULL )
    {
        TRACE( TL_A, TM_Tp, ("TpGetExtensionId: Invalid parameter") );  

        TRACE( TL_N, TM_Tp, ("-TpGetExtensionId=$%x",NDIS_STATUS_TAPI_INVALPARAM) );

        return NDIS_STATUS_TAPI_INVALPARAM;
    }

    //
    // Retrieve the handle to line context
    //
    hdLine = TpGetHdLineFromDeviceId( pAdapter, pRequest->ulDeviceID );
    
    if ( hdLine == INVALID_LINE_HANDLE )
    {
        TRACE( TL_N, TM_Tp, ("-TpGetExtensionId=$%x",NDIS_STATUS_TAPI_NODRIVER) );
        
        return NDIS_STATUS_TAPI_NODRIVER;
    }
    
    //
    // This driver does not support any extensions, so we return zeros.
    //
    pRequest->LineExtensionID.ulExtensionID0 = 0;
    pRequest->LineExtensionID.ulExtensionID1 = 0;
    pRequest->LineExtensionID.ulExtensionID2 = 0;
    pRequest->LineExtensionID.ulExtensionID3 = 0;

    TRACE( TL_N, TM_Tp, ("-TpGetExtensionId=$%x",NDIS_STATUS_SUCCESS) );

    return NDIS_STATUS_SUCCESS;
}

NDIS_STATUS
TpGetAddressStatus(
    IN ADAPTER* pAdapter,
    IN PNDIS_TAPI_GET_ADDRESS_STATUS pRequest
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This request queries the specified address for its current status.

Parameters:

    pAdapter _ A pointer ot our adapter information structure.

    pRequest _ A pointer to the NDIS_TAPI request structure for this call.

    typedef struct _NDIS_TAPI_GET_ADDRESS_STATUS
    {
        IN  ULONG       ulRequestID;
        IN  HDRV_LINE   hdLine;
        IN  ULONG       ulAddressID;
        OUT LINE_ADDRESS_STATUS LineAddressStatus;

    } NDIS_TAPI_GET_ADDRESS_STATUS, *PNDIS_TAPI_GET_ADDRESS_STATUS;

    typedef struct _LINE_ADDRESS_STATUS
    {
        ULONG   ulTotalSize;
        ULONG   ulNeededSize;
        ULONG   ulUsedSize;

        ULONG   ulNumInUse;
        ULONG   ulNumActiveCalls;
        ULONG   ulNumOnHoldCalls;
        ULONG   ulNumOnHoldPendCalls;
        ULONG   ulAddressFeatures;

        ULONG   ulNumRingsNoAnswer;
        ULONG   ulForwardNumEntries;
        ULONG   ulForwardSize;
        ULONG   ulForwardOffset;

        ULONG   ulTerminalModesSize;
        ULONG   ulTerminalModesOffset;

        ULONG   ulDevSpecificSize;
        ULONG   ulDevSpecificOffset;

    } LINE_ADDRESS_STATUS, *PLINE_ADDRESS_STATUS;

Return Values:

    NDIS_STATUS_SUCCESS
    NDIS_STATUS_FAILURE
    NDIS_STATUS_TAPI_INVALLINEHANDLE
    NDIS_STATUS_TAPI_INVALADDRESSID

---------------------------------------------------------------------------*/
{
    LINE* pLine = NULL;

    ASSERT( VALIDATE_ADAPTER( pAdapter ) );

    TRACE( TL_N, TM_Tp, ("+TpGetAddressStatus") );

    if ( pRequest == NULL || pAdapter == NULL )
    {
        TRACE( TL_A, TM_Tp, ("TpGetAddressStatus: Invalid parameter") );    

        TRACE( TL_N, TM_Tp, ("-TpGetAddressStatus=$%x",NDIS_STATUS_TAPI_INVALPARAM) );

        return NDIS_STATUS_TAPI_INVALPARAM;
    }
    
    //
    // Retrieve the pointer to line context
    //
    pLine = TpGetLinePtrFromHdLine( pAdapter, pRequest->hdLine );

    if ( pLine == NULL )
    {
        TRACE( TL_N, TM_Tp, ("-TpGetAddressStatus=$%x",NDIS_STATUS_TAPI_INVALLINEHANDLE) );
    
        return NDIS_STATUS_TAPI_INVALLINEHANDLE;
    }

    pRequest->LineAddressStatus.ulNeededSize = sizeof( LINE_ADDRESS_STATUS );

    if ( pRequest->LineAddressStatus.ulTotalSize < pRequest->LineAddressStatus.ulNeededSize )
    {
        TRACE( TL_N, TM_Tp, ("-TpGetAddressStatus=$%x",NDIS_STATUS_INVALID_LENGTH) );
    
        return NDIS_STATUS_INVALID_LENGTH;
    }

    pRequest->LineAddressStatus.ulUsedSize = pRequest->LineAddressStatus.ulNeededSize;
    
    //
    // Make sure the address is within range - we only support one per line.
    //
    if ( pRequest->ulAddressID > 1 )
    {
        TRACE( TL_N, TM_Tp, ("-TpGetAddressStatus=$%x",NDIS_STATUS_TAPI_INVALADDRESSID) );

        return NDIS_STATUS_TAPI_INVALADDRESSID;
    }

    //
    // Return the current status information for the address
    //
    pRequest->LineAddressStatus.ulNumInUse = ( pLine->nActiveCalls > 0 ) ? 1 : 0;
            
    pRequest->LineAddressStatus.ulNumActiveCalls = pLine->nActiveCalls;
            
    pRequest->LineAddressStatus.ulAddressFeatures = ( pLine->nActiveCalls < pLine->nMaxCalls ) ? 
                                                    LINEADDRFEATURE_MAKECALL : 
                                                    0;
                
    pRequest->LineAddressStatus.ulNumRingsNoAnswer = 999;

    TRACE( TL_N, TM_Tp, ("-TpGetAddressStatus=$%x",NDIS_STATUS_SUCCESS) );

    return NDIS_STATUS_SUCCESS;
}

#define TAPI_DEVICECLASS_NAME        "tapi/line"
#define TAPI_DEVICECLASS_ID          1
#define NDIS_DEVICECLASS_NAME        "ndis"
#define NDIS_DEVICECLASS_ID          2

NDIS_STATUS
TpGetId(
    IN ADAPTER* pAdapter,
    IN PNDIS_TAPI_GET_ID pRequest,
    IN ULONG ulRequestLength
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This request returns a device ID for the specified device class
    associated with the selected line, address or call.

    Currently, there are two types of this request that must be supported by WAN 
    NIC drivers:

    1.  IN DeviceClass = "ndis"                 // case insensitive
        IN ulSelect = LINECALLSELECT_CALL
        IN hdCall = ActiveCallHandle
        OUT DeviceID = ConnectionWrapperID 

        DeviceID should be set to the NdisLinkContext handle returned by NDISWAN in 
        the NDIS_MAC_LINE_UP structure for the initial NDIS_STATUS_WAN_LINE_UP 
        indication to establish the link.
    
        The miniport must make the initial line-up indication to establish a link (or 
        open a data channel on a line) before returning from this request in order to 
        supply this DeviceID value. 
    
    2.  IN DeviceClass = "tapi/line"            // case insensitive
        IN ulSelect = LINECALLSELECT_LINE
        IN hdLine = OpenLineHandle
        OUT DeviceID = ulDeviceID 

        DeviceID will be set to the miniport-determined DeviceID associated with the 
        line handle.

Parameters:

    pAdapter _ A pointer ot our adapter information structure.

    pRequest _ A pointer to the NDIS_TAPI request structure for this call.

    typedef struct _NDIS_TAPI_GET_ID
    {
        IN  ULONG       ulRequestID;
        IN  HDRV_LINE   hdLine;
        IN  ULONG       ulAddressID;
        IN  HDRV_CALL   hdCall;
        IN  ULONG       ulSelect;
        IN  ULONG       ulDeviceClassSize;
        IN  ULONG       ulDeviceClassOffset;
        OUT VAR_STRING  DeviceID;

    } NDIS_TAPI_GET_ID, *PNDIS_TAPI_GET_ID;

    typedef struct _VAR_STRING
    {
        ULONG   ulTotalSize;
        ULONG   ulNeededSize;
        ULONG   ulUsedSize;

        ULONG   ulStringFormat;
        ULONG   ulStringSize;
        ULONG   ulStringOffset;

    } VAR_STRING, *PVAR_STRING;

   ulRequestLength _ Length of the request buffer

Return Values:

    NDIS_STATUS_SUCCESS
    NDIS_STATUS_FAILURE
    NDIS_STATUS_TAPI_INVALDEVICECLASS
    NDIS_STATUS_TAPI_INVALLINEHANDLE
    NDIS_STATUS_TAPI_INVALADDRESSID
    NDIS_STATUS_TAPI_INVALCALLHANDLE
    NDIS_STATUS_TAPI_OPERATIONUNAVAIL

---------------------------------------------------------------------------*/
{
    NDIS_STATUS status = NDIS_STATUS_SUCCESS;
    BOOLEAN fNotifyNDIS = FALSE;
    
    LINE* pLine = NULL;
    CALL* pCall = NULL;

    UINT DeviceClass = 0;

    PUCHAR IDPtr;
    UINT  IDLength = 0;
    ULONG_PTR DeviceID;

    TRACE( TL_N, TM_Tp, ("+TpGetId") );

    if ( pRequest == NULL || pAdapter == NULL )
    {
        TRACE( TL_A, TM_Tp, ("TpGetId: Invalid parameter") );   

        TRACE( TL_N, TM_Tp, ("-TpGetId=$%x",NDIS_STATUS_TAPI_INVALPARAM) );

        return NDIS_STATUS_TAPI_INVALPARAM;
    }

    if ( pRequest->ulDeviceClassOffset + pRequest->ulDeviceClassSize > ulRequestLength )
    {
        TRACE( TL_N, TM_Tp, ("-TpGetId=$%x",NDIS_STATUS_TAPI_INVALPARAM) );

        return NDIS_STATUS_TAPI_INVALPARAM;
    }

    if ( pRequest->ulSelect == LINECALLSELECT_LINE )
    {          

        if ( ( pRequest->ulDeviceClassSize == sizeof(TAPI_DEVICECLASS_NAME) ) &&
              ( _strnicmp(
                         (PCHAR) pRequest + pRequest->ulDeviceClassOffset, 
                         TAPI_DEVICECLASS_NAME, 
                         pRequest->ulDeviceClassSize
                         ) == 0 ) )
        {
            DeviceClass = TAPI_DEVICECLASS_ID;

            //
            // Do the size check up front
            //
            IDLength = sizeof(DeviceID);
            
            pRequest->DeviceID.ulNeededSize = sizeof(VAR_STRING) + IDLength;
            
            if ( pRequest->DeviceID.ulTotalSize < pRequest->DeviceID.ulNeededSize )
            {
                TRACE( TL_N, TM_Tp, ("-TpGetId=$%x",NDIS_STATUS_INVALID_LENGTH) );
     
                return NDIS_STATUS_INVALID_LENGTH;
            }
 
            pRequest->DeviceID.ulUsedSize = pRequest->DeviceID.ulNeededSize;

        }
        else    // UNSUPPORTED DEVICE CLASS
        {
            TRACE( TL_N, TM_Tp, ("-TpGetId=$%x",NDIS_STATUS_TAPI_INVALDEVICECLASS) );
        
            return NDIS_STATUS_TAPI_INVALDEVICECLASS;
        }

    }        
    else if ( pRequest->ulSelect == LINECALLSELECT_CALL )
    {

        if ( ( pRequest->ulDeviceClassSize == sizeof(NDIS_DEVICECLASS_NAME) ) &&
              ( _strnicmp(
                   (PCHAR) pRequest + pRequest->ulDeviceClassOffset, 
                   NDIS_DEVICECLASS_NAME, 
                   pRequest->ulDeviceClassSize
                   ) == 0 ) )
        {
            DeviceClass = NDIS_DEVICECLASS_ID;

            //
            // Do the size check up front
            //
            IDLength = sizeof(DeviceID);
            
            pRequest->DeviceID.ulNeededSize = sizeof(VAR_STRING) + IDLength;
            
            if ( pRequest->DeviceID.ulTotalSize < pRequest->DeviceID.ulNeededSize )
            {
                TRACE( TL_N, TM_Tp, ("-TpGetId=$%x",NDIS_STATUS_INVALID_LENGTH) );
     
                return NDIS_STATUS_INVALID_LENGTH;
            }
 
            pRequest->DeviceID.ulUsedSize = pRequest->DeviceID.ulNeededSize;

        }        
        else    // UNSUPPORTED DEVICE CLASS
        {
            TRACE( TL_N, TM_Tp, ("-TpGetId=$%x",NDIS_STATUS_TAPI_INVALDEVICECLASS) );
        
            return NDIS_STATUS_TAPI_INVALDEVICECLASS;
        }

    }        

    //
    // Find the link structure associated with the request/deviceclass.
    //
    if ( pRequest->ulSelect == LINECALLSELECT_LINE )
    {
        ASSERT( DeviceClass == TAPI_DEVICECLASS_ID );
        ASSERT( IDLength == sizeof( DeviceID ) );    
        //
        // Retrieve the pointer to line context
        //
        pLine = TpGetLinePtrFromHdLine( pAdapter, pRequest->hdLine );
    
        if ( pLine == NULL )
        {
            TRACE( TL_N, TM_Tp, ("-TpGetId=$%x",NDIS_STATUS_TAPI_INVALLINEHANDLE) );
            
            return NDIS_STATUS_TAPI_INVALLINEHANDLE;
        }

        //
        // TAPI just wants the ulDeviceID for this line.
        //
        DeviceID = (ULONG) pLine->hdLine + pAdapter->TapiProv.ulDeviceIDBase ;
        IDPtr = (PUCHAR) &DeviceID;
        
    }
    else if ( pRequest->ulSelect == LINECALLSELECT_ADDRESS )
    {
    
        //
        // Retrieve the pointer to line context
        //
        pLine = TpGetLinePtrFromHdLine( pAdapter, pRequest->hdLine );
    
        if ( pLine == NULL )
        {
            TRACE( TL_N, TM_Tp, ("-TpGetId=$%x",NDIS_STATUS_TAPI_INVALLINEHANDLE) );
            
            return NDIS_STATUS_TAPI_INVALLINEHANDLE;
        }


        if ( pRequest->ulAddressID > 1 )
        {
            TRACE( TL_N, TM_Tp, ("-TpGetId=$%x",NDIS_STATUS_TAPI_INVALADDRESSID) );

            return NDIS_STATUS_TAPI_INVALADDRESSID;
        }
        
        //
        // Currently, there is no defined return value for this case...
        // This is just a place holder for future extensions.
        //
        TRACE( TL_N, TM_Tp, ("-TpGetId=$%x",NDIS_STATUS_TAPI_INVALDEVICECLASS) );
        
        return NDIS_STATUS_TAPI_INVALDEVICECLASS;
        
    }
    else if ( pRequest->ulSelect == LINECALLSELECT_CALL )
    {
        BOOLEAN fCallReferenced = FALSE;
        
        ASSERT( DeviceClass == NDIS_DEVICECLASS_ID );
        ASSERT( IDLength == sizeof( DeviceID ) );    

        //
        // Retrieve the pointer to call context
        //
        pCall = RetrieveFromHandleTable( pAdapter->TapiProv.hCallTable, 
                                         (NDIS_HANDLE) pRequest->hdCall );
    
        if ( pCall == NULL )
        {
            TRACE( TL_N, TM_Tp, ("-TpGetId=$%x",NDIS_STATUS_TAPI_INVALLINEHANDLE) );
            
            return NDIS_STATUS_TAPI_INVALLINEHANDLE;
        }

        //
        // We can only return this if we have a valid NdisLinkContext,
        // and if our session is up, then our link handle must be valid
        //
  
        NdisAcquireSpinLock( &pCall->lockCall );
  
        if ( pCall->ulTapiCallState == LINECALLSTATE_CONNECTED )
        {
            //
            // Give a line-up indication to NDISWAN and obtain its handle
            //
            NDIS_MAC_LINE_UP LineUpInfo;
  
            //
            // Fill-in the line up structure
            //
            NdisZeroMemory( &LineUpInfo, sizeof( LineUpInfo ) );
            
            LineUpInfo.LinkSpeed    = pCall->ulSpeed;
            LineUpInfo.Quality      = NdisWanErrorControl;
            LineUpInfo.SendWindow   = 0;
            
            LineUpInfo.ConnectionWrapperID = (NDIS_HANDLE) pCall->htCall;
            LineUpInfo.NdisLinkHandle      = (NDIS_HANDLE) pCall->hdCall;
            LineUpInfo.NdisLinkContext     = 0;
  
            //
            // Reference the call once and deref it just after indication of status
            // to NDISWAN
            //
            ReferenceCall( pCall, FALSE );
  
            fCallReferenced = TRUE;
  
            NdisReleaseSpinLock( &pCall->lockCall );
  
            TRACE( TL_N, TM_Tp, ("TpGetId: Indicate NDIS_STATUS_WAN_LINE_UP") );
  
            NdisMIndicateStatus( pCall->pLine->pAdapter->MiniportAdapterHandle,
                                 NDIS_STATUS_WAN_LINE_UP,
                                 &LineUpInfo,
                                 sizeof( NDIS_MAC_LINE_UP ) );  
  
            NdisAcquireSpinLock( &pCall->lockCall );                                     
  
            //
            // Set state to indicate that session is established
            //
            pCall->stateCall = CL_stateSessionUp;
  
            //
            // Set link context obtained from NDISWAN on the call context
            //
            pCall->NdisLinkContext = LineUpInfo.NdisLinkContext;
            
            DeviceID = (ULONG_PTR) pCall->NdisLinkContext;
            IDPtr = (PUCHAR) &DeviceID;
  
            //
            // Since the session is up, schedule the MpIndicateReceivedPackets() handler 
            //
            MpScheduleIndicateReceivedPacketsHandler( pCall );
  
            status = NDIS_STATUS_SUCCESS;
        }
        else
        {
            status = NDIS_STATUS_TAPI_OPERATIONUNAVAIL;
        }
  
        NdisReleaseSpinLock( &pCall->lockCall );
  
        if ( fCallReferenced )
        {
           DereferenceCall( pCall );
        }
            
    }
    else // UNSUPPORTED SELECT REQUEST
    {
        TRACE( TL_N, TM_Tp, ("-TpGetId=$%x",NDIS_STATUS_FAILURE) );         
        
        return NDIS_STATUS_FAILURE;
    }    

    if ( status == NDIS_STATUS_SUCCESS )
    {
        //
        // Now we need to place the device ID.
        //
        pRequest->DeviceID.ulStringFormat = STRINGFORMAT_BINARY;
        pRequest->DeviceID.ulStringSize   = IDLength;
        pRequest->DeviceID.ulStringOffset = sizeof(VAR_STRING);
  
        NdisMoveMemory(
                (PCHAR) &pRequest->DeviceID + sizeof(VAR_STRING),
                IDPtr,
                IDLength
                );
    }

    if ( fNotifyNDIS )
    {
        TRACE( TL_N, TM_Tp, ("TpGetId:Completing delayed request") );           

        NdisMQueryInformationComplete( pCall->pLine->pAdapter->MiniportAdapterHandle, status );

    }
    
    TRACE( TL_N, TM_Tp, ("-TpGetId=$%x",status) );          
    
    return status;

}

#define TAPI_PROVIDER_STRING        "VPN\0RASPPPOE"
#define TAPI_LINE_NAME              "RAS PPPoE Line"
#define TAPI_LINE_NUM               "0000"

NDIS_STATUS
TpGetDevCaps(
    IN ADAPTER* pAdapter,
    IN PNDIS_TAPI_GET_DEV_CAPS pRequest
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This request queries a specified line device to determine its telephony
    capabilities. The returned information is valid for all addresses on the
    line device.

Parameters:

    pAdapter _ A pointer ot our adapter information structure.

    pRequest _ A pointer to the NDIS_TAPI request structure for this call.

    typedef struct _NDIS_TAPI_GET_DEV_CAPS
    {
        IN  ULONG       ulRequestID;
        IN  ULONG       ulDeviceID;
        IN  ULONG       ulExtVersion;
        OUT LINE_DEV_CAPS   LineDevCaps;

    } NDIS_TAPI_GET_DEV_CAPS, *PNDIS_TAPI_GET_DEV_CAPS;

    typedef struct _LINE_DEV_CAPS
    {
        ULONG   ulTotalSize;
        ULONG   ulNeededSize;
        ULONG   ulUsedSize;

        ULONG   ulProviderInfoSize;
        ULONG   ulProviderInfoOffset;

        ULONG   ulSwitchInfoSize;
        ULONG   ulSwitchInfoOffset;

        ULONG   ulPermanentLineID;
        ULONG   ulLineNameSize;
        ULONG   ulLineNameOffset;
        ULONG   ulStringFormat;

        ULONG   ulAddressModes;
        ULONG   ulNumAddresses;
        ULONG   ulBearerModes;
        ULONG   ulMaxRate;
        ULONG   ulMediaModes;

        ULONG   ulGenerateToneModes;
        ULONG   ulGenerateToneMaxNumFreq;
        ULONG   ulGenerateDigitModes;
        ULONG   ulMonitorToneMaxNumFreq;
        ULONG   ulMonitorToneMaxNumEntries;
        ULONG   ulMonitorDigitModes;
        ULONG   ulGatherDigitsMinTimeout;
        ULONG   ulGatherDigitsMaxTimeout;

        ULONG   ulMedCtlDigitMaxListSize;
        ULONG   ulMedCtlMediaMaxListSize;
        ULONG   ulMedCtlToneMaxListSize;
        ULONG   ulMedCtlCallStateMaxListSize;

        ULONG   ulDevCapFlags;
        ULONG   ulMaxNumActiveCalls;
        ULONG   ulAnswerMode;
        ULONG   ulRingModes;
        ULONG   ulLineStates;

        ULONG   ulUUIAcceptSize;
        ULONG   ulUUIAnswerSize;
        ULONG   ulUUIMakeCallSize;
        ULONG   ulUUIDropSize;
        ULONG   ulUUISendUserUserInfoSize;
        ULONG   ulUUICallInfoSize;

        LINE_DIAL_PARAMS    MinDialParams;
        LINE_DIAL_PARAMS    MaxDialParams;
        LINE_DIAL_PARAMS    DefaultDialParams;

        ULONG   ulNumTerminals;
        ULONG   ulTerminalCapsSize;
        ULONG   ulTerminalCapsOffset;
        ULONG   ulTerminalTextEntrySize;
        ULONG   ulTerminalTextSize;
        ULONG   ulTerminalTextOffset;

        ULONG   ulDevSpecificSize;
        ULONG   ulDevSpecificOffset;

    } LINE_DEV_CAPS, *PLINE_DEV_CAPS;

    typedef struct _LINE_DIAL_PARAMS
    {
        ULONG   ulDialPause;
        ULONG   ulDialSpeed;
        ULONG   ulDigitDuration;
        ULONG   ulWaitForDialtone;

    } LINE_DIAL_PARAMS, *PLINE_DIAL_PARAMS;

Return Values:

    NDIS_STATUS_SUCCESS
    NDIS_STATUS_TAPI_NODRIVER

---------------------------------------------------------------------------*/
{
    HDRV_LINE hdLine = INVALID_LINE_HANDLE;
    CHAR szTapiLineNum[] = TAPI_LINE_NUM;
    CHAR *pBuf = NULL;
    ULONG ulDeviceId;

    ASSERT( VALIDATE_ADAPTER( pAdapter ) );

    TRACE( TL_N, TM_Tp, ("+TpGetDevCaps") );

    if ( pRequest == NULL || pAdapter == NULL )
    {
        TRACE( TL_A, TM_Tp, ("TpGetDevCaps: Invalid parameter") );  

        TRACE( TL_N, TM_Tp, ("-TpGetDevCaps=$%x",NDIS_STATUS_TAPI_INVALPARAM) );

        return NDIS_STATUS_TAPI_INVALPARAM;
    }
    
    //
    // Retrieve the handle to line context
    //
    hdLine = TpGetHdLineFromDeviceId( pAdapter, pRequest->ulDeviceID );
    
    if ( hdLine == INVALID_LINE_HANDLE )
    {
        TRACE( TL_N, TM_Tp, ("-TpGetDevCaps=$%x",NDIS_STATUS_TAPI_NODRIVER) );
        
        return NDIS_STATUS_TAPI_NODRIVER;
    }

    pRequest->LineDevCaps.ulNeededSize   = sizeof( LINE_DEV_CAPS ) + 
                                           sizeof( TAPI_PROVIDER_STRING ) +
                                           ( sizeof( TAPI_LINE_NAME ) - 1 ) +
                                           sizeof( TAPI_LINE_NUM );

    if ( pRequest->LineDevCaps.ulTotalSize < pRequest->LineDevCaps.ulNeededSize )
    {
        TRACE( TL_N, TM_Tp, ("-TpGetDevCaps=$%x",NDIS_STATUS_INVALID_LENGTH) );
        
        return NDIS_STATUS_INVALID_LENGTH;
    }

    pRequest->LineDevCaps.ulUsedSize = pRequest->LineDevCaps.ulNeededSize;
    
    pRequest->LineDevCaps.ulAddressModes = LINEADDRESSMODE_ADDRESSID |
                                           LINEADDRESSMODE_DIALABLEADDR;

    pRequest->LineDevCaps.ulNumAddresses = 1;

    pRequest->LineDevCaps.ulBearerModes  = LINEBEARERMODE_DATA;

    pRequest->LineDevCaps.ulDevCapFlags  = LINEDEVCAPFLAGS_CLOSEDROP;

    pRequest->LineDevCaps.ulMaxNumActiveCalls = pAdapter->nCallsPerLine;

    pRequest->LineDevCaps.ulAnswerMode   = LINEANSWERMODE_DROP;

    pRequest->LineDevCaps.ulRingModes    = 1;

    pRequest->LineDevCaps.ulPermanentLineID = pRequest->ulDeviceID;

    pRequest->LineDevCaps.ulMaxRate      = 0;

    pRequest->LineDevCaps.ulMediaModes   = LINEMEDIAMODE_DIGITALDATA;

    //
    // Insert the provider string and enumerated line name into line dev caps
    //
    pRequest->LineDevCaps.ulStringFormat = STRINGFORMAT_ASCII;

    {
        INT i;
        
        //
        // Tack on the ProviderString to the end of the LineDevCaps structure
        //
        pRequest->LineDevCaps.ulProviderInfoSize = sizeof( TAPI_PROVIDER_STRING );
    
        pRequest->LineDevCaps.ulProviderInfoOffset = sizeof( pRequest->LineDevCaps );
    
        pBuf = ( (PUCHAR) &pRequest->LineDevCaps ) + pRequest->LineDevCaps.ulProviderInfoOffset;
        
        NdisMoveMemory( pBuf , TAPI_PROVIDER_STRING, sizeof( TAPI_PROVIDER_STRING ) );
    
        //
        // Tack on the LineName after the ProviderString
        //
        pRequest->LineDevCaps.ulLineNameSize = ( sizeof( TAPI_LINE_NAME ) - 1 ) + sizeof( TAPI_LINE_NUM );
    
        pRequest->LineDevCaps.ulLineNameOffset = pRequest->LineDevCaps.ulProviderInfoOffset +
                                                 pRequest->LineDevCaps.ulProviderInfoSize;
                                                 
        pBuf = ( (PUCHAR) &pRequest->LineDevCaps ) + pRequest->LineDevCaps.ulLineNameOffset;
    
        NdisMoveMemory( pBuf , TAPI_LINE_NAME, sizeof( TAPI_LINE_NAME ) );
    
        //
        // Tack on the line enumeration index at the end of the LineName
        //
        ulDeviceId = (ULONG) hdLine;
        
        //
        // Subtract 2: 1 for '\0' and 1 to adjust for array indexing
        //
        i = ( sizeof( TAPI_LINE_NUM ) / sizeof( CHAR ) ) - 2;
    
        while ( i >= 0 && ( ulDeviceId > 0 ) )
        {
                szTapiLineNum[i] = (UCHAR)( ( ulDeviceId % 10 ) + '0' );
                ulDeviceId /= 10;
                i--;
        }
        
        pBuf += ( sizeof( TAPI_LINE_NAME ) - 1 );
    
        NdisMoveMemory( pBuf, szTapiLineNum, sizeof( TAPI_LINE_NUM ) );
    }
    
    TRACE( TL_N, TM_Tp, ("-TpGetDevCaps=$%x",NDIS_STATUS_SUCCESS) );

    return NDIS_STATUS_SUCCESS;
}

NDIS_STATUS
TpGetCallStatus(
    IN ADAPTER* pAdapter,
    IN PNDIS_TAPI_GET_CALL_STATUS pRequest
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This request returns detailed information about the specified call.

Parameters:

    pAdapter _ A pointer ot our adapter information structure.

    pRequest _ A pointer to the NDIS_TAPI request structure for this call.

    typedef struct _NDIS_TAPI_GET_CALL_STATUS
    {
        IN  ULONG       ulRequestID;
        IN  HDRV_CALL   hdCall;
        OUT LINE_CALL_STATUS    LineCallStatus;

    } NDIS_TAPI_GET_CALL_STATUS, *PNDIS_TAPI_GET_CALL_STATUS;

    typedef struct _LINE_CALL_STATUS
    {
        ULONG   ulTotalSize;
        ULONG   ulNeededSize;
        ULONG   ulUsedSize;

        ULONG   ulCallState;
        ULONG   ulCallStateMode;
        ULONG   ulCallPrivilege;
        ULONG   ulCallFeatures;

        ULONG   ulDevSpecificSize;
        ULONG   ulDevSpecificOffset;

    } LINE_CALL_STATUS, *PLINE_CALL_STATUS;

Return Values:

    NDIS_STATUS_SUCCESS
    NDIS_STATUS_FAILURE
    NDIS_STATUS_TAPI_INVALCALLHANDLE

---------------------------------------------------------------------------*/
{
    CALL* pCall = NULL;
    
    ASSERT( VALIDATE_ADAPTER( pAdapter ) );

    TRACE( TL_N, TM_Tp, ("+TpGetCallStatus") );

    if ( pRequest == NULL || pAdapter == NULL )
    {
        TRACE( TL_A, TM_Tp, ("TpGetCallStatus: Invalid parameter") );   

        TRACE( TL_N, TM_Tp, ("-TpGetCallStatus=$%x",NDIS_STATUS_TAPI_INVALPARAM) );

        return NDIS_STATUS_TAPI_INVALPARAM;
    }

    pCall = RetrieveFromHandleTable( pAdapter->TapiProv.hCallTable, 
                                     (NDIS_HANDLE) pRequest->hdCall );

    if ( pCall == NULL )
    {
        TRACE( TL_N, TM_Tp, ("-TpGetCallStatus=$%x",NDIS_STATUS_TAPI_INVALCALLHANDLE) );
    
        return NDIS_STATUS_TAPI_INVALCALLHANDLE;
    }

    pRequest->LineCallStatus.ulNeededSize = sizeof( LINE_CALL_STATUS );

   if ( pRequest->LineCallStatus.ulTotalSize < pRequest->LineCallStatus.ulNeededSize )
   {
        TRACE( TL_N, TM_Tp, ("-TpGetCallStatus=$%x",NDIS_STATUS_INVALID_LENGTH) );
    
        return NDIS_STATUS_INVALID_LENGTH;
   }

    pRequest->LineCallStatus.ulUsedSize = pRequest->LineCallStatus.ulNeededSize;

    pRequest->LineCallStatus.ulCallFeatures = LINECALLFEATURE_ANSWER | LINECALLFEATURE_DROP;
    pRequest->LineCallStatus.ulCallPrivilege = LINECALLPRIVILEGE_OWNER;
    pRequest->LineCallStatus.ulCallState = pCall->ulTapiCallState;

    switch ( pRequest->LineCallStatus.ulCallState )
    {
        case LINECALLSTATE_DIALTONE:
        
            pRequest->LineCallStatus.ulCallStateMode = LINEDIALTONEMODE_NORMAL;

            break;
            
        case LINECALLSTATE_BUSY:
        
            pRequest->LineCallStatus.ulCallStateMode = LINEBUSYMODE_STATION;
            break;
            
        case LINECALLSTATE_DISCONNECTED:
        
            pRequest->LineCallStatus.ulCallStateMode = LINEDISCONNECTMODE_UNKNOWN;
            break;
            
        default:
            break;
    }

    TRACE( TL_N, TM_Tp, ("-TpGetCallStatus=$%x",NDIS_STATUS_SUCCESS) );

    return NDIS_STATUS_SUCCESS;
 }

//
// As we return the MAC addresses for caller and called station id's
// we set their size as 7 although a MAC address occupies 6 bytes.
// This is because TAPI overwrites the last bytes we return in these
// strings with a NULL character destroying the vaulable data.
// See bug: 313295
//
#define TAPI_STATION_ID_SIZE            ( 7 * sizeof( CHAR ) )

NDIS_STATUS
TpGetCallInfo(
    IN ADAPTER* pAdapter,
    IN PNDIS_TAPI_GET_CALL_INFO pRequest
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This request returns detailed information about the specified call.

Parameters:

    pAdapter _ A pointer to our adapter information structure.

    pRequest _ A pointer to the NDIS_TAPI request structure for this call.

    typedef struct _NDIS_TAPI_GET_CALL_INFO
    {
        IN  ULONG       ulRequestID;
        IN  HDRV_CALL   hdCall;
        OUT LINE_CALL_INFO  LineCallInfo;

    } NDIS_TAPI_GET_CALL_INFO, *PNDIS_TAPI_GET_CALL_INFO;

    typedef struct _LINE_CALL_INFO
    {
        ULONG   ulTotalSize;
        ULONG   ulNeededSize;
        ULONG   ulUsedSize;

        ULONG   hLine;
        ULONG   ulLineDeviceID;
        ULONG   ulAddressID;

        ULONG   ulBearerMode;
        ULONG   ulRate;
        ULONG   ulMediaMode;

        ULONG   ulAppSpecific;
        ULONG   ulCallID;
        ULONG   ulRelatedCallID;
        ULONG   ulCallParamFlags;
        ULONG   ulCallStates;

        ULONG   ulMonitorDigitModes;
        ULONG   ulMonitorMediaModes;
        LINE_DIAL_PARAMS    DialParams;

        ULONG   ulOrigin;
        ULONG   ulReason;
        ULONG   ulCompletionID;
        ULONG   ulNumOwners;
        ULONG   ulNumMonitors;

        ULONG   ulCountryCode;
        ULONG   ulTrunk;

        ULONG   ulCallerIDFlags;
        ULONG   ulCallerIDSize;
        ULONG   ulCallerIDOffset;
        ULONG   ulCallerIDNameSize;
        ULONG   ulCallerIDNameOffset;

        ULONG   ulCalledIDFlags;
        ULONG   ulCalledIDSize;
        ULONG   ulCalledIDOffset;
        ULONG   ulCalledIDNameSize;
        ULONG   ulCalledIDNameOffset;

        ULONG   ulConnectedIDFlags;
        ULONG   ulConnectedIDSize;
        ULONG   ulConnectedIDOffset;
        ULONG   ulConnectedIDNameSize;
        ULONG   ulConnectedIDNameOffset;

        ULONG   ulRedirectionIDFlags;
        ULONG   ulRedirectionIDSize;
        ULONG   ulRedirectionIDOffset;
        ULONG   ulRedirectionIDNameSize;
        ULONG   ulRedirectionIDNameOffset;

        ULONG   ulRedirectingIDFlags;
        ULONG   ulRedirectingIDSize;
        ULONG   ulRedirectingIDOffset;
        ULONG   ulRedirectingIDNameSize;
        ULONG   ulRedirectingIDNameOffset;

        ULONG   ulAppNameSize;
        ULONG   ulAppNameOffset;

        ULONG   ulDisplayableAddressSize;
        ULONG   ulDisplayableAddressOffset;

        ULONG   ulCalledPartySize;
        ULONG   ulCalledPartyOffset;

        ULONG   ulCommentSize;
        ULONG   ulCommentOffset;

        ULONG   ulDisplaySize;
        ULONG   ulDisplayOffset;

        ULONG   ulUserUserInfoSize;
        ULONG   ulUserUserInfoOffset;

        ULONG   ulHighLevelCompSize;
        ULONG   ulHighLevelCompOffset;

        ULONG   ulLowLevelCompSize;
        ULONG   ulLowLevelCompOffset;

        ULONG   ulChargingInfoSize;
        ULONG   ulChargingInfoOffset;

        ULONG   ulTerminalModesSize;
        ULONG   ulTerminalModesOffset;

        ULONG   ulDevSpecificSize;
        ULONG   ulDevSpecificOffset;

    } LINE_CALL_INFO, *PLINE_CALL_INFO;

    typedef struct _LINE_DIAL_PARAMS
    {
        ULONG   ulDialPause;
        ULONG   ulDialSpeed;
        ULONG   ulDigitDuration;
        ULONG   ulWaitForDialtone;

    } LINE_DIAL_PARAMS, *PLINE_DIAL_PARAMS;

Return Values:

    NDIS_STATUS_SUCCESS
    NDIS_STATUS_FAILURE
    NDIS_STATUS_TAPI_INVALCALLHANDLE

---------------------------------------------------------------------------*/
{
    CALL* pCall = NULL;
    PLINE_CALL_INFO pLineCallInfo = NULL;
    
    ASSERT( VALIDATE_ADAPTER( pAdapter ) );

    TRACE( TL_N, TM_Tp, ("+TpGetCallInfo") );

    if ( pRequest == NULL || pAdapter == NULL )
    {
        TRACE( TL_A, TM_Tp, ("TpGetCallInfo: Invalid parameter") ); 

        TRACE( TL_N, TM_Tp, ("-TpGetCallInfo=$%x",NDIS_STATUS_TAPI_INVALPARAM) );

        return NDIS_STATUS_TAPI_INVALPARAM;
    }

    pLineCallInfo = &pRequest->LineCallInfo;

    pCall = RetrieveFromHandleTable( pAdapter->TapiProv.hCallTable, 
                                     (NDIS_HANDLE) pRequest->hdCall );

    if ( pCall == NULL )
    {
        TRACE( TL_N, TM_Tp, ("-TpGetCallInfo=$%x",NDIS_STATUS_TAPI_INVALCALLHANDLE) );

        return NDIS_STATUS_TAPI_INVALCALLHANDLE;
    }

    pLineCallInfo->ulNeededSize = sizeof( LINE_CALL_INFO ) +
                                  TAPI_STATION_ID_SIZE  +
                                  TAPI_STATION_ID_SIZE;

    if ( pLineCallInfo->ulTotalSize < pLineCallInfo->ulNeededSize )
    {
        TRACE( TL_N, TM_Tp, ("-TpGetCallInfo=$%x",NDIS_STATUS_INVALID_LENGTH) );

        return NDIS_STATUS_INVALID_LENGTH;
    }

    pLineCallInfo->ulUsedSize = pLineCallInfo->ulNeededSize;

    pLineCallInfo->ulLineDeviceID = (ULONG) pCall->pLine->hdLine + 
                                    pCall->pLine->pAdapter->TapiProv.ulDeviceIDBase;
    pLineCallInfo->ulAddressID = 0;

    pLineCallInfo->ulBearerMode = LINEBEARERMODE_DATA;
    pLineCallInfo->ulRate = pCall->ulSpeed;
    pLineCallInfo->ulMediaMode = LINEMEDIAMODE_DIGITALDATA;

    pLineCallInfo->ulCallParamFlags = LINECALLPARAMFLAGS_IDLE;
    pLineCallInfo->ulCallStates = TAPI_LINECALLSTATES_SUPPORTED;

    pLineCallInfo->ulCallerIDFlags = LINECALLPARTYID_UNAVAIL;
    pLineCallInfo->ulCallerIDSize = 0;
    pLineCallInfo->ulCalledIDOffset = 0;
    pLineCallInfo->ulCalledIDFlags = LINECALLPARTYID_UNAVAIL;
    pLineCallInfo->ulCalledIDSize = 0;

    //
    // Set the caller and called station id information for both
    // incoming and outgoing calls.
    //
    {
        CHAR *pBuf = NULL;

        //
        // Copy the caller id information
        //
        pLineCallInfo->ulCallerIDFlags = LINECALLPARTYID_ADDRESS;
        pLineCallInfo->ulCallerIDSize = TAPI_STATION_ID_SIZE;
        pLineCallInfo->ulCallerIDOffset = sizeof(LINE_CALL_INFO);

        pBuf = ( (PUCHAR) pLineCallInfo ) + pLineCallInfo->ulCallerIDOffset;
        NdisMoveMemory( pBuf, pCall->DestAddr, TAPI_STATION_ID_SIZE - 1 );

        //
        // Copy the called id information
        //
        pLineCallInfo->ulCalledIDFlags = LINECALLPARTYID_ADDRESS;
        pLineCallInfo->ulCalledIDSize = TAPI_STATION_ID_SIZE;
        pLineCallInfo->ulCalledIDOffset = pLineCallInfo->ulCallerIDOffset + 
                                          pLineCallInfo->ulCallerIDSize;

        pBuf = ( (PUCHAR) pLineCallInfo ) + pLineCallInfo->ulCalledIDOffset;
        NdisMoveMemory( pBuf, pCall->SrcAddr, TAPI_STATION_ID_SIZE - 1 );

        pLineCallInfo->ulUsedSize = pLineCallInfo->ulNeededSize;
    }

    TRACE( TL_N, TM_Tp, ("-TpGetCallInfo=$%x",NDIS_STATUS_SUCCESS) );

    return NDIS_STATUS_SUCCESS;
}

#define TAPI_LINE_ADDR_STRING           "PPPoE VPN"

NDIS_STATUS
TpGetAddressCaps(
    IN ADAPTER* pAdapter,
    PNDIS_TAPI_GET_ADDRESS_CAPS pRequest
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This request queries the specified address on the specified line device
    to determine its telephony capabilities.

Parameters:

    pAdapter _ A pointer ot our adapter information structure.

    pRequest _ A pointer to the NDIS_TAPI request structure for this call.

    typedef struct _NDIS_TAPI_GET_ADDRESS_CAPS
    {
        IN  ULONG       ulRequestID;
        IN  ULONG       ulDeviceID;
        IN  ULONG       ulAddressID;
        IN  ULONG       ulExtVersion;
        OUT LINE_ADDRESS_CAPS   LineAddressCaps;

    } NDIS_TAPI_GET_ADDRESS_CAPS, *PNDIS_TAPI_GET_ADDRESS_CAPS;

    typedef struct _LINE_ADDRESS_CAPS
    {
        ULONG   ulTotalSize;
        ULONG   ulNeededSize;
        ULONG   ulUsedSize;

        ULONG   ulLineDeviceID;

        ULONG   ulAddressSize;
        ULONG   ulAddressOffset;

        ULONG   ulDevSpecificSize;
        ULONG   ulDevSpecificOffset;

        ULONG   ulAddressSharing;
        ULONG   ulAddressStates;
        ULONG   ulCallInfoStates;
        ULONG   ulCallerIDFlags;
        ULONG   ulCalledIDFlags;
        ULONG   ulConnectedIDFlags;
        ULONG   ulRedirectionIDFlags;
        ULONG   ulRedirectingIDFlags;
        ULONG   ulCallStates;
        ULONG   ulDialToneModes;
        ULONG   ulBusyModes;
        ULONG   ulSpecialInfo;
        ULONG   ulDisconnectModes;

        ULONG   ulMaxNumActiveCalls;
        ULONG   ulMaxNumOnHoldCalls;
        ULONG   ulMaxNumOnHoldPendingCalls;
        ULONG   ulMaxNumConference;
        ULONG   ulMaxNumTransConf;

        ULONG   ulAddrCapFlags;
        ULONG   ulCallFeatures;
        ULONG   ulRemoveFromConfCaps;
        ULONG   ulRemoveFromConfState;
        ULONG   ulTransferModes;

        ULONG   ulForwardModes;
        ULONG   ulMaxForwardEntries;
        ULONG   ulMaxSpecificEntries;
        ULONG   ulMinFwdNumRings;
        ULONG   ulMaxFwdNumRings;

        ULONG   ulMaxCallCompletions;
        ULONG   ulCallCompletionConds;
        ULONG   ulCallCompletionModes;
        ULONG   ulNumCompletionMessages;
        ULONG   ulCompletionMsgTextEntrySize;
        ULONG   ulCompletionMsgTextSize;
        ULONG   ulCompletionMsgTextOffset;

    } LINE_ADDRESS_CAPS, *PLINE_ADDRESS_CAPS;

Return Values:

    NDIS_STATUS_SUCCESS
    NDIS_STATUS_TAPI_INVALADDRESSID
    NDIS_STATUS_TAPI_INCOMPATIBLEEXTVERSION
    NDIS_STATUS_TAPI_NODRIVER

---------------------------------------------------------------------------*/        
{
    HDRV_LINE hdLine = INVALID_LINE_HANDLE;

    ASSERT( VALIDATE_ADAPTER( pAdapter ) );

    TRACE( TL_N, TM_Tp, ("+TpGetAddressCaps") );

    if ( pRequest == NULL || pAdapter == NULL )
    {
        TRACE( TL_A, TM_Tp, ("TpGetAddressCaps: Invalid parameter") );  

        TRACE( TL_N, TM_Tp, ("-TpGetAddressCaps=$%x",NDIS_STATUS_TAPI_INVALPARAM) );

        return NDIS_STATUS_TAPI_INVALPARAM;
    }
    
    //
    // Retrieve the handle to line context
    //
    hdLine = TpGetHdLineFromDeviceId( pAdapter, pRequest->ulDeviceID );
    
    if ( hdLine == INVALID_LINE_HANDLE )
    {
        TRACE( TL_N, TM_Tp, ("-TpGetAddressCaps=$%x",NDIS_STATUS_TAPI_NODRIVER) );
        
        return NDIS_STATUS_TAPI_NODRIVER;
    }

    //
    // Verify the address id
    //
    if ( pRequest->ulAddressID != 0 )
    {
        TRACE( TL_N, TM_Tp, ("-TpGetAddressCaps=$%x",NDIS_STATUS_TAPI_INVALADDRESSID) );
        
        return NDIS_STATUS_TAPI_INVALADDRESSID;
    }

    //
    // Verify the extension versions
    //
    if ( pRequest->ulExtVersion != 0 &&
         pRequest->ulExtVersion != TAPI_EXT_VERSION)
    {
        TRACE( TL_N, TM_Tp, ("-TpGetAddressCaps=$%x",NDIS_STATUS_TAPI_INCOMPATIBLEEXTVERSION) );
        
        return NDIS_STATUS_TAPI_INCOMPATIBLEEXTVERSION;
    }

    pRequest->LineAddressCaps.ulNeededSize = sizeof( LINE_ADDRESS_CAPS ) +
                                             sizeof( TAPI_LINE_ADDR_STRING );
    
    if ( pRequest->LineAddressCaps.ulTotalSize < pRequest->LineAddressCaps.ulNeededSize )
    {
        TRACE( TL_N, TM_Tp, ("-TpGetAddressCaps=$%x",NDIS_STATUS_INVALID_LENGTH) );

        return NDIS_STATUS_INVALID_LENGTH;
    }

    pRequest->LineAddressCaps.ulUsedSize = pRequest->LineAddressCaps.ulNeededSize;

    pRequest->LineAddressCaps.ulDialToneModes     = LINEDIALTONEMODE_NORMAL;
  
    pRequest->LineAddressCaps.ulSpecialInfo       = LINESPECIALINFO_UNAVAIL;
  
    pRequest->LineAddressCaps.ulDisconnectModes   = LINEDISCONNECTMODE_NORMAL |                                                    
                                                    LINEDISCONNECTMODE_UNKNOWN |
                                                    LINEDISCONNECTMODE_BUSY |
                                                    LINEDISCONNECTMODE_NOANSWER | 
                                                    LINEDISCONNECTMODE_UNREACHABLE |
                                                    LINEDISCONNECTMODE_BADADDRESS |
                                                    LINEDISCONNECTMODE_INCOMPATIBLE |
                                                    LINEDISCONNECTMODE_REJECT | 
                                                    LINEDISCONNECTMODE_NODIALTONE;
  
    pRequest->LineAddressCaps.ulMaxNumActiveCalls = pAdapter->nCallsPerLine;
    
    pRequest->LineAddressCaps.ulMaxNumTransConf   = 1;
    pRequest->LineAddressCaps.ulAddrCapFlags      = LINEADDRCAPFLAGS_DIALED;
  
    pRequest->LineAddressCaps.ulCallFeatures      = LINECALLFEATURE_ACCEPT |
                                                    LINECALLFEATURE_ANSWER |
                                                    LINECALLFEATURE_COMPLETECALL |
                                                    LINECALLFEATURE_DIAL |
                                                    LINECALLFEATURE_DROP;
  
    pRequest->LineAddressCaps.ulLineDeviceID      = pRequest->ulDeviceID;
    pRequest->LineAddressCaps.ulAddressSharing    = LINEADDRESSSHARING_PRIVATE;
    pRequest->LineAddressCaps.ulAddressStates     = 0;
  
    //
    // List of all possible call states.
    //
    pRequest->LineAddressCaps.ulCallStates        = TAPI_LINECALLSTATES_SUPPORTED;
    
    pRequest->LineAddressCaps.ulAddressSize = sizeof( TAPI_LINE_ADDR_STRING );
    pRequest->LineAddressCaps.ulAddressOffset = sizeof( LINE_ADDRESS_CAPS );

    {
        CHAR* pBuf;

        pBuf = ( (PUCHAR) &pRequest->LineAddressCaps ) + sizeof( LINE_ADDRESS_CAPS );
        NdisMoveMemory( pBuf, TAPI_LINE_ADDR_STRING, sizeof( TAPI_LINE_ADDR_STRING ) );
    }

    TRACE( TL_N, TM_Tp, ("-TpGetAddressCaps=$%x",NDIS_STATUS_SUCCESS) );

    return NDIS_STATUS_SUCCESS;
}

NDIS_STATUS
TpSetStatusMessages(
    IN ADAPTER* pAdapter,
    IN PNDIS_TAPI_SET_STATUS_MESSAGES pRequest
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This request enables the Connection Wrapper to specify which notification 
    messages the miniport should generate for events related to status changes 
    for the specified line or any of its addresses. By default, address and 
    line status reporting is initially disabled for a line.

Parameters:

    pAdapter _ A pointer to our adapter information structure.

    pRequest _ A pointer to the NDIS_TAPI request structure for this call.

    typedef struct _NDIS_TAPI_SET_STATUS_MESSAGES
    {
        IN  ULONG       ulRequestID;
        IN  HDRV_LINE   hdLine;
        IN  ULONG       ulLineStates;
        IN  ULONG       ulAddressStates;

    } NDIS_TAPI_SET_STATUS_MESSAGES, *PNDIS_TAPI_SET_STATUS_MESSAGES;

Return Values:

    NDIS_STATUS_SUCCESS
    NDIS_STATUS_TAPI_INVALLINEHANDLE
    NDIS_STATUS_TAPI_INVALLINESTATE
    NDIS_STATUS_TAPI_INVALADDRESSSTATE

---------------------------------------------------------------------------*/
{

    ASSERT( VALIDATE_ADAPTER( pAdapter ) );

    TRACE( TL_N, TM_Tp, ("+TpSetStatusMessages") );
    //
    // We do not send any line or address state change notifications at all,
    // so we do not care about it. 
    // 
    // We care about call notification messages and they are always on by default.
    //

    TRACE( TL_N, TM_Tp, ("-TpSetStatusMessages=$%x",NDIS_STATUS_SUCCESS) );
    
    return NDIS_STATUS_SUCCESS;
}

VOID
TpCallStateChangeHandler(
    IN CALL* pCall,
    IN ULONG ulCallState,
    IN ULONG ulStateParam
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This routine will indicate the given LINECALLSTATE to the Connection
    wrapper if the event has been enabled by the wrapper. Otherwise the state
    information is saved, but no indication is made.


    LINECALLSTATE_ Constants: The LINECALLSTATE_ bit-flag constants describe the
                              call states a call can be in. 

    LINECALLSTATE_ACCEPTED:
        The call was in the offering state and has been accepted. This indicates to 
        other (monitoring) applications that the current owner application has 
        claimed responsibility for answering the call. In ISDN, the accepted state is 
        entered when the called-party equipment sends a message to the switch 
        indicating that it is willing to present the call to the called person. This 
        has the side effect of alerting (ringing) the users at both ends of the call. 
        An incoming call can always be immediately answered without first being 
        separately accepted. 
    
    LINECALLSTATE_BUSY 
        The call is receiving a busy tone. A busy tone indicates that the call cannot 
        be completed either a circuit (trunk) or the remote party's station are in use
        . See LINEBUSYMODE_ Constants. 
        
    LINECALLSTATE_CONFERENCED 
        The call is a member of a conference call and is logically in the connected 
        state. 
        
    LINECALLSTATE_CONNECTED 
        The call has been established and the connection is made. Information is able 
        to flow over the call between the originating address and the destination 
        address. 
        
    LINECALLSTATE_DIALING 
        The originator is dialing digits on the call. The dialed digits are collected 
        by the switch. Note that neither lineGenerateDigits nor 
        TSPI_lineGenerateDigits will place the line into the dialing state. 
        
    LINECALLSTATE_DIALTONE 
        The call is receiving a dial tone from the switch, which means that the 
        switch is ready to receive a dialed number. See LINEDIALTONEMODE_ Constants 
        for identifiers of special dial tones, such as a stutter tone of normal voice 
        mail. 
        
    LINECALLSTATE_DISCONNECTED 
        The remote party has disconnected from the call. 
        
    LINECALLSTATE_IDLE 
        The call exists but has not been connected. No activity exists on the call, 
        which means that no call is currently active. A call can never transition 
        into the idle state. 
        
    LINECALLSTATE_OFFERING 
        The call is being offered to the station, signaling the arrival of a new call
        . The offering state is not the same as causing a phone or computer to ring. 
        In some environments, a call in the offering state does not ring the user 
        until the switch instructs the line to ring. An example use might be where an 
        incoming call appears on several station sets but only the primary address 
        rings. The instruction to ring does not affect any call states. 
        
    LINECALLSTATE_ONHOLD 
        The call is on hold by the switch. This frees the physical line, which allows 
        another call to use the line. 
        
    LINECALLSTATE_ONHOLDPENDCONF 
        The call is currently on hold while it is being added to a conference. 

    LINECALLSTATE_ONHOLDPENDTRANSFER 
        The call is currently on hold awaiting transfer to another number. 

    LINECALLSTATE_PROCEEDING 
        Dialing has completed and the call is proceeding through the switch or 
        telephone network. This occurs after dialing is complete and before the call 
        reaches the dialed party, as indicated by ringback, busy, or answer. 

    LINECALLSTATE_RINGBACK 
        The station to be called has been reached, and the destination's switch is 
        generating a ring tone back to the originator. A ringback means that the 
        destination address is being alerted to the call. 

    LINECALLSTATE_SPECIALINFO 
        The call is receiving a special information signal, which precedes a 
        prerecorded announcement indicating why a call cannot be completed. See 
        LINESPECIALINFO_ Constants. 
        
    LINECALLSTATE_UNKNOWN 
        The call exists, but its state is currently unknown. This may be the result 
        of poor call progress detection by the service provider. A call state message 
        with the call state set to unknown may also be generated to inform the TAPI 
        DLL about a new call at a time when the actual call state of the call is not 
        exactly known. 

Parameters:

    pCall _ A pointer to our call information structure.

    ulCallState _ The LINECALLSTATE event to be posted to TAPI/WAN.

    ulStateParam _ This value depends on the event being posted, and some
                   events will pass in zero if they don't use this parameter.

Return Values:

    None

---------------------------------------------------------------------------*/
{
    BOOLEAN fIndicateStatus = FALSE;
    NDIS_TAPI_EVENT TapiEvent;
    ULONG ulOldCallState;
    
    ASSERT( VALIDATE_CALL( pCall ) );

    TRACE( TL_N, TM_Tp, ("+TpCallStateChangeHandler") );

    NdisAcquireSpinLock( &pCall->lockCall );

    do 
    {
        //
        // Check if we have a valid htCall member, otherwise it means we are already done,
        // so we should not give any more notifications to TAPI about state changes
        //
        if ( pCall->htCall == (HTAPI_CALL) NULL )
        {
            TRACE( TL_N, TM_Tp, ("TpCallStateChangeHandler: No valid htCall") );

            break;
        }

        //
        // A connect notification can come only after a PROCEEDING or OFFERING state
        // is reached
        //
        if ( ulCallState == LINECALLSTATE_CONNECTED && 
             ( pCall->ulTapiCallState != LINECALLSTATE_OFFERING &&
               pCall->ulTapiCallState != LINECALLSTATE_PROCEEDING ) )
        {
            TRACE( TL_N, TM_Tp, ("TpCallStateChangeHandler: Invalid order of state change") );
            
            break;
        }

        //
        // If the new state is the same as old state, just return
        //
        if ( pCall->ulTapiCallState == ulCallState )
        {
            TRACE( TL_N, TM_Tp, ("TpCallStateChangeHandler: No state change") );

            break;
        }

        //
        // Otherwise, change the calls state, and 
        // make a notification to TAPI about the new state
        //
        ulOldCallState = pCall->ulTapiCallState;
        pCall->ulTapiCallState = ulCallState;
        
        TapiEvent.htLine = pCall->pLine->htLine;
        TapiEvent.htCall = pCall->htCall;   
    
        TapiEvent.ulMsg  = LINE_CALLSTATE;
        
        TapiEvent.ulParam1 = ulCallState;
        TapiEvent.ulParam2 = ulStateParam;
        TapiEvent.ulParam3 = LINEMEDIAMODE_DIGITALDATA; 

        fIndicateStatus = TRUE;

        if ( ulCallState == LINECALLSTATE_CONNECTED )
        {
            ADAPTER* pAdapter = pCall->pLine->pAdapter;
            
            //
            // Since the call is connected, reset CLBF_CallConnectPending bit
            //
            pCall->ulClFlags &= ~CLBF_CallConnectPending;

            //
            // Also prepare the WanLinkInfo structure of call context now
            // as right after we indicate line-up to NDISWAN, it will query us
            // for this info.
            //
            NdisZeroMemory( &pCall->NdisWanLinkInfo, sizeof( pCall->NdisWanLinkInfo ) );
            
            pCall->NdisWanLinkInfo.MaxSendFrameSize = pCall->ulMaxFrameSize;
            pCall->NdisWanLinkInfo.MaxRecvFrameSize = pCall->ulMaxFrameSize;
    
            pCall->NdisWanLinkInfo.HeaderPadding = pAdapter->NdisWanInfo.HeaderPadding;
            pCall->NdisWanLinkInfo.TailPadding = pAdapter->NdisWanInfo.TailPadding;
    
            pCall->NdisWanLinkInfo.SendFramingBits = pAdapter->NdisWanInfo.FramingBits;
            pCall->NdisWanLinkInfo.RecvFramingBits = pAdapter->NdisWanInfo.FramingBits;
        
            pCall->NdisWanLinkInfo.SendACCM = 0;
            pCall->NdisWanLinkInfo.RecvACCM = 0;
        
        }
        else if ( ulCallState == LINECALLSTATE_DISCONNECTED )
        {
            TRACE( TL_N, TM_Tp, ("TpCallStateChangeHandler: LINEDISCONNECTMODE: %x", ulStateParam ) );

            //
            // This state change will only occur if TpDropCall() is in progress,
            // so we invalidate the htCall member of call context in order to prevent
            // a possible out of sync state change notification.
            //
            pCall->htCall = (HTAPI_CALL) NULL;
            
        }

    } while ( FALSE) ;
    
    NdisReleaseSpinLock( &pCall->lockCall );

    //
    // Notify state change to TAPI if needed
    //
    if ( fIndicateStatus )
    {
        TRACE( TL_N, TM_Tp, ("TpCallStateChangeHandler: Indicate LINE_CALLSTATE change: %x -> %x",ulOldCallState,ulCallState ) );

        NdisMIndicateStatus( pCall->pLine->pAdapter->MiniportAdapterHandle,
                             NDIS_STATUS_TAPI_INDICATION,
                             &TapiEvent,
                             sizeof( NDIS_TAPI_EVENT ) );   
    }

    TRACE( TL_N, TM_Tp, ("-TpCallStateChangeHandler") );
}


NDIS_STATUS
TpMakeCall(
    IN ADAPTER* pAdapter,
    IN PNDIS_TAPI_MAKE_CALL pRequest,
    IN ULONG ulRequestLength
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This request places a call on the specified line to the specified
    destination address. Optionally, call parameters can be specified if
    anything but default call setup parameters are requested.

Parameters:

    Adapter _ A pointer ot our adapter information structure.

    Request _ A pointer to the NDIS_TAPI request structure for this call.

    typedef struct _NDIS_TAPI_MAKE_CALL
    {
        IN  ULONG       ulRequestID;
        IN  HDRV_LINE   hdLine;
        IN  HTAPI_CALL  htCall;
        OUT HDRV_CALL   hdCall;
        IN  ULONG       ulDestAddressSize;
        IN  ULONG       ulDestAddressOffset;
        IN  BOOLEAN     bUseDefaultLineCallParams;
        IN  LINE_CALL_PARAMS    LineCallParams;

    } NDIS_TAPI_MAKE_CALL, *PNDIS_TAPI_MAKE_CALL;

    typedef struct _LINE_CALL_PARAMS        // Defaults:
    {
        ULONG   ulTotalSize;                // ---------

        ULONG   ulBearerMode;               // voice
        ULONG   ulMinRate;                  // (3.1kHz)
        ULONG   ulMaxRate;                  // (3.1kHz)
        ULONG   ulMediaMode;                // interactiveVoice

        ULONG   ulCallParamFlags;           // 0
        ULONG   ulAddressMode;              // addressID
        ULONG   ulAddressID;                // (any available)

        LINE_DIAL_PARAMS DialParams;        // (0, 0, 0, 0)

        ULONG   ulOrigAddressSize;          // 0
        ULONG   ulOrigAddressOffset;
        ULONG   ulDisplayableAddressSize;
        ULONG   ulDisplayableAddressOffset;

        ULONG   ulCalledPartySize;          // 0
        ULONG   ulCalledPartyOffset;

        ULONG   ulCommentSize;              // 0
        ULONG   ulCommentOffset;

        ULONG   ulUserUserInfoSize;         // 0
        ULONG   ulUserUserInfoOffset;

        ULONG   ulHighLevelCompSize;        // 0
        ULONG   ulHighLevelCompOffset;

        ULONG   ulLowLevelCompSize;         // 0
        ULONG   ulLowLevelCompOffset;

        ULONG   ulDevSpecificSize;          // 0
        ULONG   ulDevSpecificOffset;    
        
    } LINE_CALL_PARAMS, *PLINE_CALL_PARAMS;

    typedef struct _LINE_DIAL_PARAMS
    {
        ULONG   ulDialPause;
        ULONG   ulDialSpeed;
        ULONG   ulDigitDuration;
        ULONG   ulWaitForDialtone;

    } LINE_DIAL_PARAMS, *PLINE_DIAL_PARAMS;

    RequestLength _ Length of the request buffer

Return Values:

    NDIS_STATUS_TAPI_ADDRESSBLOCKED
    NDIS_STATUS_TAPI_BEARERMODEUNAVAIL
    NDIS_STATUS_TAPI_CALLUNAVAIL
    NDIS_STATUS_TAPI_DIALBILLING
    NDIS_STATUS_TAPI_DIALQUIET
    NDIS_STATUS_TAPI_DIALDIALTONE
    NDIS_STATUS_TAPI_DIALPROMPT
    NDIS_STATUS_TAPI_INUSE
    NDIS_STATUS_TAPI_INVALADDRESSMODE
    NDIS_STATUS_TAPI_INVALBEARERMODE
    NDIS_STATUS_TAPI_INVALMEDIAMODE
    NDIS_STATUS_TAPI_INVALLINESTATE
    NDIS_STATUS_TAPI_INVALRATE
    NDIS_STATUS_TAPI_INVALLINEHANDLE
    NDIS_STATUS_TAPI_INVALADDRESS
    NDIS_STATUS_TAPI_INVALADDRESSID
    NDIS_STATUS_TAPI_INVALCALLPARAMS
    NDIS_STATUS_RESOURCES
    NDIS_STATUS_TAPI_OPERATIONUNAVAIL
    NDIS_STATUS_FAILURE
    NDIS_STATUS_TAPI_RESOURCEUNAVAIL
    NDIS_STATUS_TAPI_RATEUNAVAIL
    NDIS_STATUS_TAPI_USERUSERINFOTOOBIG

---------------------------------------------------------------------------*/
{   
    NDIS_STATUS status = NDIS_STATUS_SUCCESS;
    LINE* pLine = NULL;

    CALL* pCall = NULL;
    HDRV_CALL hdCall = (HDRV_CALL) NULL;

    BOOLEAN fCallInsertedToHandleTable = FALSE;

    WORKITEM* pWorkItem = NULL;
    PVOID Args[4];

    BOOLEAN fRenumerationNotScheduled = FALSE;
    
    ASSERT( VALIDATE_ADAPTER( pAdapter ) );

    TRACE( TL_N, TM_Tp, ("+TpMakeCall") );

    if ( pRequest == NULL || pAdapter == NULL )
    {
        TRACE( TL_A, TM_Tp, ("TpMakeCall: Invalid parameter") );    

        TRACE( TL_N, TM_Tp, ("-TpMakeCall=$%x",NDIS_STATUS_TAPI_INVALPARAM) );

        return NDIS_STATUS_TAPI_INVALPARAM;
    }

    //
    // Retrieve a pointer to the line context
    //
    pLine = TpGetLinePtrFromHdLine( pAdapter, pRequest->hdLine );

    if ( pLine == NULL )
    {
        status = NDIS_STATUS_TAPI_INVALLINEHANDLE;

        TRACE( TL_N, TM_Tp, ("-TpMakeCall=$%x",status) );   

        return status;
    }

    //
    // See if we can make calls on this line at all
    //
    if ( ! (pLine->ulLnFlags & LNBF_MakeOutgoingCalls ) )
    {
        status = NDIS_STATUS_TAPI_ADDRESSBLOCKED;
        
        TRACE( TL_N, TM_Tp, ("-TpMakeCall=$%x",status) );   

        return status;
    }

    //
    // See if we can still make calls on this line
    //
    if ( pLine->nActiveCalls == pLine->nMaxCalls )
    {
        status = NDIS_STATUS_TAPI_OPERATIONUNAVAIL;

        TRACE( TL_N, TM_Tp, ("-TpMakeCall=$%x",status) );   

        return status;
    }

    //
    // Make sure the parameters suppied in the request are acceptable
    //
    if ( pRequest->bUseDefaultLineCallParams )
    {
        status = NDIS_STATUS_TAPI_INVALCALLPARAMS;

        TRACE( TL_N, TM_Tp, ("-TpMakeCall=$%x",status) );   

        return status;
    }

    if ( !( pRequest->LineCallParams.ulBearerMode & LINEBEARERMODE_DATA ) )
    {
        status = NDIS_STATUS_TAPI_INVALBEARERMODE;

        TRACE( TL_N, TM_Tp, ("-TpMakeCall=$%x",status) );   

        return status;
    }
    
    if ( !( pRequest->LineCallParams.ulMediaMode & LINEMEDIAMODE_DIGITALDATA ) )
    {
        status = NDIS_STATUS_TAPI_INVALMEDIAMODE;

        TRACE( TL_N, TM_Tp, ("-TpMakeCall=$%x",status) );   

        return status;
    }

    if ( !( pRequest->LineCallParams.ulAddressMode &
         ( LINEADDRESSMODE_ADDRESSID | LINEADDRESSMODE_DIALABLEADDR ) ) )
    {
        status = NDIS_STATUS_TAPI_INVALADDRESSMODE;

        TRACE( TL_N, TM_Tp, ("-TpMakeCall=$%x",status) );   

        return status;
    }
                                           
    if ( pRequest->LineCallParams.ulAddressID > 0 )
    {
        status = NDIS_STATUS_TAPI_INVALADDRESSID;

        TRACE( TL_N, TM_Tp, ("-TpMakeCall=$%x",status) );   

        return status;
    }

    if ( pRequest->ulDestAddressOffset + pRequest->ulDestAddressSize > ulRequestLength )
    {
        status = NDIS_STATUS_TAPI_INVALPARAM;

        TRACE( TL_N, TM_Tp, ("-TpMakeCall=$%x",status) );   

        return status;

    }

    //
    // Create a call context 
    //
    if ( ALLOC_CALL( &pCall ) != NDIS_STATUS_SUCCESS )
    {
        status = NDIS_STATUS_RESOURCES;

        TRACE( TL_N, TM_Tp, ("-TpMakeCall=$%x",status) );   

        return status;
    }

    do
    {
        //
        // Initialize the call context
        //
        status = TpCallInitialize( pCall, pLine, pRequest->htCall, FALSE /* fIncoming */ );
    
        if ( status != NDIS_STATUS_SUCCESS )
            break;

        //
        // Insert the call context into the tapi provider's handle table
        //
        NdisAcquireSpinLock( &pAdapter->lockAdapter );
        
        hdCall = (HDRV_CALL) InsertToHandleTable( pAdapter->TapiProv.hCallTable,
                                                  NO_PREFERED_INDEX,
                                                  pCall );
                            
        NdisReleaseSpinLock( &pAdapter->lockAdapter );

        if ( hdCall == (HDRV_CALL) NULL )
        {
            status = NDIS_STATUS_TAPI_CALLUNAVAIL;

            break;
        }

        fCallInsertedToHandleTable = TRUE;

        //
        // Set the call's hdCall member
        //
        pCall->hdCall = hdCall;

        //
        // Set AC Name and the service name passed in the request.
        // We expect it in the following format:
        // AC Name\Service Name
        //
        // The following examles are all valid:
        // AC Name\                          -> Connect to the default service on the specified AC
        // Service Name                      -> Connect to the specified service on any AC
        // AC Name\Service Name              -> Connect to the specified service on the specified AC
        //                                   -> Connect to the default service on any AC
        //
        // We will also strip off any leading or trailing space chars.
        //
                                                 
        {
            CHAR* pBuf = ( (PUCHAR) pRequest ) + pRequest->ulDestAddressOffset;
            ULONG size = pRequest->ulDestAddressSize;

            ULONG ACNameStartPos, ACNameEndPos;
            ULONG ServiceNameStartPos, ServiceNameEndPos;
            
            //
            // Remove the terminating NULL characters if passed any.
            // 
            for ( ; size > 0 ; size-- )
            {
                if ( pBuf[ size - 1] != '\0' )
                {
                    break;
                }
            }

            //
            // Get the AC Name and service name
            //
            do
            {
               ULONG i = 0;
               CHAR* pTempChar = pBuf;

               ACNameStartPos = ACNameEndPos = 0;
               ServiceNameStartPos = ServiceNameEndPos = 0;

               //
               // Skip leading spaces
               //
               while (i < size)
               {
                  if (*pTempChar != ' ')
                  {
                     break;
                  }
                  
                  i++;
                  
                  pTempChar++;
               }

               if (i == size)
               {
                  break;
               }

               ACNameStartPos = ACNameEndPos = i;
                              
               while (i < size)
               {
                  if (*pTempChar == '\\')
                  {
                     break;
                  }

                  i++;

                  if (*pTempChar != ' ')
                  {
                     //
                     // Mark the beginning of trailing spaces
                     //
                     ACNameEndPos = i;   
                  }

                  pTempChar++;
               }

               if (i == size)
               {
                  //
                  // No AC Name was specified, it was just Service Name 
                  // and we parsed it
                  //
                  ServiceNameStartPos = ACNameStartPos;
                  ServiceNameEndPos = ACNameEndPos;

                  ACNameStartPos = ACNameEndPos = 0;

                  break;
               }

               //
               // Advance 'i' and 'pTempChar' once to skip the '\' character
               //
               i++;
               
               pTempChar++;

               //
               // Skip leading spaces
               //
               while (i < size)
               {
                  if (*pTempChar != ' ')
                  {
                     break;
                  }
                  
                  i++;
                  
                  pTempChar++;
               }

               if (i == size)
               {
                  break;
               }

               ServiceNameStartPos = ServiceNameEndPos = i;

               while (i < size)
               {
                  i++;

                  if (*pTempChar != ' ')
                  {
                     //
                     // Mark the beginning of trailing spaces
                     //
                     ServiceNameEndPos = i;   
                  }

                  pTempChar++;
               }
               
            } while ( FALSE );

            //
            // Retrieve the AC Name information into the call context
            //
            pCall->nACNameLength = (USHORT) ( ( MAX_AC_NAME_LENGTH < ( ACNameEndPos - ACNameStartPos ) ) ?
                                                MAX_AC_NAME_LENGTH : ( ACNameEndPos - ACNameStartPos ) );


            if ( pCall->nACNameLength != 0 )
            {
                NdisMoveMemory( pCall->ACName, &pBuf[ACNameStartPos], pCall->nACNameLength );

                pCall->fACNameSpecified = TRUE;
            }

            //
            // Retrieve the Service Name information into the call context
            //
            pCall->nServiceNameLength = (USHORT) ( ( MAX_SERVICE_NAME_LENGTH < ( ServiceNameEndPos - ServiceNameStartPos ) ) ?
                                                     MAX_SERVICE_NAME_LENGTH : ( ServiceNameEndPos - ServiceNameStartPos ) );


            if ( pCall->nServiceNameLength != 0 )
            {
                NdisMoveMemory( pCall->ServiceName, &pBuf[ServiceNameStartPos], pCall->nServiceNameLength );
            }
        }

        //
        // Allocate a work item for scheduling FsmMakeCall()
        //
        // Set the arguements array
        //
        Args[0] = (PVOID) pCall;

        pWorkItem = AllocWorkItem( &gl_llistWorkItems,
                                   ExecAdapterWorkItem,
                                   NULL,
                                   Args, 
                                   CWT_workFsmMakeCall );

        if ( pWorkItem == NULL ) 
        {
            status = NDIS_STATUS_RESOURCES;

            break;
        }

        {
           //
           // Schedule a work item to reenumerate bindings
           //
            WORKITEM* pCallWorkItem;
            
            Args[0] = (PVOID) BN_SetFiltersForMakeCall;       // Is a set filter request
            Args[1] = (PVOID) pCall;
            Args[2] = (PVOID) pRequest;
            Args[3] = (PVOID) pWorkItem;

            pCallWorkItem = pWorkItem;

            //
            // Allocate work item for the bind
            //
            pWorkItem = AllocWorkItem( &gl_llistWorkItems,
                                       ExecBindingWorkItem,
                                       NULL,
                                       Args,
                                       BWT_workPrStartBinds );

            if ( pWorkItem == NULL ) 
            {
               //
               // We can not allocate the work item for reenumeration of bindings
               // But may be all enumerations are intact, so let the
               // make call request continue
               //

               pWorkItem = pCallWorkItem;

               fRenumerationNotScheduled = TRUE;
            }
        }

        //
        // Insert the call context into the line's active call list
        //
        NdisAcquireSpinLock( &pLine->lockLine );

        InsertHeadList( &pLine->linkCalls, &pCall->linkCalls );

        pLine->nActiveCalls++;

        ReferenceLine( pLine, FALSE );

        NdisReleaseSpinLock( &pLine->lockLine );

        //
        // Reference the call 3 times:
        //  1. For scheduling of FsmMakeCall()
        //  2. For dropping of the call
        //  3. For closing of the call
        //
        NdisAcquireSpinLock( &pCall->lockCall );
        
        ReferenceCall( pCall, FALSE );
        ReferenceCall( pCall, FALSE );
        ReferenceCall( pCall, FALSE );

        NdisReleaseSpinLock( &pCall->lockCall );

        //
        // Schedule the bind operation
        //
        ScheduleWorkItem( pWorkItem );

        status = NDIS_STATUS_SUCCESS;

    } while ( FALSE );

    if ( status == NDIS_STATUS_SUCCESS )
    {
        //
        // If succesfull, return the call handle to TAPI and mark call as TAPI notified
        // of new call
        //
        pRequest->hdCall = hdCall;

        //
        // If we have scheduled a reenumeration work item, then pend this request
        // It will be completed when reenumeration is complete.
        //
        if ( !fRenumerationNotScheduled )
        {
           status = NDIS_STATUS_PENDING;
        }           

    }
    else
    {

        //
        // Somethings failed, do clean up
        //
        
        if ( fCallInsertedToHandleTable )
        {
            NdisAcquireSpinLock( &pAdapter->lockAdapter );
        
            RemoveFromHandleTable( pAdapter->TapiProv.hCallTable, (NDIS_HANDLE) hdCall );

            NdisReleaseSpinLock( &pAdapter->lockAdapter );
        }

        if ( pCall )
        {
            TpCallCleanup( pCall );
        }

    }

    TRACE( TL_N, TM_Tp, ("-TpMakeCall=$%x",status) );

    return status;  
}

VOID
TpMakeCallComplete(
   IN CALL* pCall,
   IN PNDIS_TAPI_MAKE_CALL pRequest   
   )
{
   TRACE( TL_N, TM_Tp, ("+TpMakeCallComplete") );

   NdisMQueryInformationComplete( pCall->pLine->pAdapter->MiniportAdapterHandle,
                                  NDIS_STATUS_SUCCESS );

   TRACE( TL_N, TM_Tp, ("-TpMakeCallComplete=$%x",NDIS_STATUS_SUCCESS) );

}

NDIS_STATUS
TpCallInitialize(
    IN CALL* pCall,
    IN LINE* pLine,
    IN HTAPI_CALL htCall,
    IN BOOLEAN fIncoming
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function makes initialization on the call context.

Parameters:

    pCall _ A pointer to our call information structure.

    pLine _ A pointer to the line information structure that the call belongs.

    htCall _ Handle assigned to the call by TAPI.

    fIncoming _ Flag that indicates if the call is inbound or outbound.

Return Values:

    NDIS_STATUS_SUCCESS
    NDIS_STATUS_FAILURE

---------------------------------------------------------------------------*/   
{

    TRACE( TL_N, TM_Tp, ("+TpCallInitialize") );

    NdisZeroMemory( pCall, sizeof( CALL ) );
    
    InitializeListHead( &pCall->linkCalls );

    pCall->tagCall = MTAG_CALL;

    pCall->ulClFlags = ( CLBF_CallOpen | CLBF_CallConnectPending );

    NdisAllocateSpinLock( &pCall->lockCall );

    pCall->fIncoming = fIncoming;

    pCall->pLine = pLine;

    pCall->htCall = htCall;

    InitializeListHead( &pCall->linkReceivedPackets );

    pCall->ulTapiCallState = LINECALLSTATE_IDLE;

    TRACE( TL_N, TM_Tp, ("-TpCallInitialize") );

    return NDIS_STATUS_SUCCESS;
}

NDIS_STATUS
TpAnswerCall(
    IN ADAPTER* pAdapter,
    IN PNDIS_TAPI_ANSWER pRequest
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This request answers the specified offering call.  It may optionally send
    the specified user-to-user information to the calling party.

Parameters:

    Adapter _ A pointer ot our adapter information structure.

    Request _ A pointer to the NDIS_TAPI request structure for this call.

    typedef struct _NDIS_TAPI_ANSWER
    {
        IN  ULONG       ulRequestID;
        IN  HDRV_CALL   hdCall;
        IN  ULONG       ulUserUserInfoSize;
        IN  UCHAR       UserUserInfo[1];

    } NDIS_TAPI_ANSWER, *PNDIS_TAPI_ANSWER;

Return Values:

    NDIS_STATUS_SUCCESS
    NDIS_STATUS_TAPI_INVALCALLHANDLE

---------------------------------------------------------------------------*/
{
    NDIS_STATUS status = NDIS_STATUS_SUCCESS;
    CALL* pCall = NULL;
    
    ASSERT( VALIDATE_ADAPTER( pAdapter ) );

    TRACE( TL_N, TM_Tp, ("+TpAnswerCall") );

    if ( pRequest == NULL || pAdapter == NULL )
    {
        TRACE( TL_A, TM_Tp, ("TpAnswerCall: Invalid parameter") );  

        TRACE( TL_N, TM_Tp, ("-TpAnswerCall=$%x",NDIS_STATUS_TAPI_INVALPARAM) );

        return NDIS_STATUS_TAPI_INVALPARAM;
    }
    
    
    pCall = RetrieveFromHandleTable( pAdapter->TapiProv.hCallTable, 
                                     (NDIS_HANDLE) pRequest->hdCall );

    if ( pCall == NULL )
    {
        status = NDIS_STATUS_TAPI_INVALCALLHANDLE;

        TRACE( TL_N, TM_Tp, ("-TpAnswerCall=$%x",status) ); 
    
        return status;
    }

    status = FsmAnswerCall( pCall );

    TRACE( TL_N, TM_Tp, ("-TpAnswerCall=$%x",status) ); 
    
    return status;
}

VOID 
ExecAdapterWorkItem(
    IN PVOID Args[4],
    IN UINT workType
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function executes the scheduled work items for the adapter.

    
Parameters:

    Args:
        An array of length 4 keeping PVOIDs

    workType:
        Indicates the type of the work to be executed.
        We use this to understand what we should do in this function.

Return Values:

    None
    
---------------------------------------------------------------------------*/
{

    TRACE( TL_N, TM_Mp, ("+ExecAdapterWorkItem") );

    switch ( workType )
    {

        case CWT_workFsmMakeCall:

            //
            // Scheduled from TpMakeCall() to start an outgoing call
            //
            {
                CALL* pCall = (CALL*) Args[0];
                
                FsmMakeCall( pCall );   

                //
                // Remove the reference due to scheduling of FsmMakeCall()
                //
                DereferenceCall( pCall );

                break;
            }

        default:

            break;


    }

    TRACE( TL_N, TM_Mp, ("-ExecAdapterWorkItem") );

}


VOID
TpReceiveCall(
    IN ADAPTER* pAdapter,
    IN BINDING* pBinding,
    IN PPPOE_PACKET* pPacket
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function will be called by miniport when we receive a PADR packet 
    to initiate a call.
    
Parameters:

    pAdapter:
        A pointer to our adapter information structure.

    pPacket:
        A pointer to the received PADI packet.

Return Values:

    None
    
---------------------------------------------------------------------------*/   
{
    HANDLE_TABLE hCallTable = NULL; 
    UINT hCallTableSize     = 0;
    UINT nIndex             = 0;
    LINE* pLine             = NULL;
    CALL* pCall             = NULL;
    UINT i;
    NDIS_STATUS status;

    BOOLEAN fCallInsertedToHandleTable = FALSE;

    TRACE( TL_N, TM_Tp, ("+TpReceiveCall") );

    NdisAcquireSpinLock( &pAdapter->lockAdapter );

    //
    // Traverse the call handle table and find an empty spot
    //
    hCallTableSize = pAdapter->nMaxLines * pAdapter->nCallsPerLine;
                
    hCallTable = pAdapter->TapiProv.hCallTable;

    for ( nIndex = 0; nIndex < hCallTableSize; nIndex++ )
    {

        if ( RetrieveFromHandleTableByIndex( hCallTable, (USHORT) nIndex ) == NULL )
            break;
            
    }

    if ( nIndex == hCallTableSize )
    {
        //
        // We are already maxed out with current calls, do not respond to the request
        //
        // TODO: We could send a PADO packet with an error tag saying that we can 
        //       not accept calls temporarily.
        //
        TRACE( TL_N, TM_Tp, ("-TpReceiveCall: Can not take calls - Call table full") );
        
        NdisReleaseSpinLock( &pAdapter->lockAdapter );

        return;
    }

    //
    // We have found an empty spot, now see if any of the open lines accept calls
    //
    for ( i = 0; i < pAdapter->nMaxLines; i++ )
    {
        pLine = pAdapter->TapiProv.LineTable[i];

        if ( pLine == NULL )
            continue;

        if ( pLine->nActiveCalls == pAdapter->nCallsPerLine )
        {
            pLine = NULL;
            
            continue;
        }

        if ( !( pLine->ulLnFlags & LNBF_AcceptIncomingCalls ) )
        {
            pLine = NULL;
            
            continue;
        }

        break;
        
    }

    if ( pLine == NULL )
    {
        //
        // We do not have any lines accepting calls right now
        //
        // TODO: We could send a PADO packet with an error tag saying that there are
        //       no active lines accepting calls at the moment.
        //
        TRACE( TL_N, TM_Tp, ("-TpReceiveCall: Can not take calls - No lines taking calls") );

        NdisReleaseSpinLock( &pAdapter->lockAdapter );

        return;

    }

    //
    // We have found a line accepting calls, and we have a free spot in call handle table,
    // so create a call context, add it to TapiProv structures, and notify TAPI of the new
    // call
    //

    do
    {
        HDRV_CALL hdCall;
        
        //
        // Create a call context 
        //
        if ( ALLOC_CALL( &pCall ) != NDIS_STATUS_SUCCESS )
        {
            status = NDIS_STATUS_RESOURCES;

            break;
        }

        //
        // Initialize the call context
        //
        status = TpCallInitialize( pCall, pLine, (HTAPI_CALL) 0, TRUE /* fIncoming */ );
    
        if ( status != NDIS_STATUS_SUCCESS )
            break;

        //
        // Insert the call context into the tapi provider's handle table
        //
        
        hdCall = (HDRV_CALL) InsertToHandleTable( pAdapter->TapiProv.hCallTable,
                                                  (USHORT) nIndex,
                                                  (PVOID) pCall );
                            

        if ( hdCall == (HDRV_CALL) NULL )
        {
            status = NDIS_STATUS_TAPI_CALLUNAVAIL;

            break;
        }

        fCallInsertedToHandleTable = TRUE;

        //
        // Set the call's hdCall member
        //
        pCall->hdCall = hdCall;

        //
        // Insert the call context into the line's active call list
        //
        NdisAcquireSpinLock( &pLine->lockLine );

        InsertHeadList( &pLine->linkCalls, &pCall->linkCalls );

        pLine->nActiveCalls++;

        ReferenceLine( pLine, FALSE );

        NdisReleaseSpinLock( &pLine->lockLine );

        //
        // Reference the call 3 times:
        //  1. For running FsmReceiveCall() below
        //  2. For dropping of the call
        //  3. For closing of the call
        //
        NdisAcquireSpinLock( &pCall->lockCall );

        ReferenceCall( pCall, FALSE );
        ReferenceCall( pCall, FALSE );
        ReferenceCall( pCall, FALSE );

        NdisReleaseSpinLock( &pCall->lockCall );

        status = NDIS_STATUS_SUCCESS;

    } while ( FALSE );

    NdisReleaseSpinLock( &pAdapter->lockAdapter );
    
    //
    // Check the status
    //
    if ( status == NDIS_STATUS_SUCCESS )
    {
    
        //
        // Kick the state machine to start receiving the call
        //
        FsmReceiveCall( pCall, pBinding, pPacket );

        //
        // Remove the reference added above
        //
        DereferenceCall( pCall );

    }
    else
    {
        //
        // If something failed, do clean up
        //  
        
        if ( fCallInsertedToHandleTable )
        {
            NdisAcquireSpinLock( &pAdapter->lockAdapter );
        
            RemoveFromHandleTable( pAdapter->TapiProv.hCallTable, (NDIS_HANDLE) pCall->hdCall );

            NdisReleaseSpinLock( &pAdapter->lockAdapter );
        }

        if ( pCall )
        {
            TpCallCleanup( pCall );
        }

    }

    TRACE( TL_N, TM_Tp, ("-TpReceiveCall=$%x",status) );
}

BOOLEAN
TpIndicateNewCall(
    IN CALL* pCall
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function will be called to indicate the new call context to to TAPI.

    If TAPI can be notified succesfully, then it returns TRUE, otherwise it 
    returns FALSE.
    
Parameters:

    pCall _ New call context to be indicated to TAPI.
    
Return Values:

    TRUE
    FALSE
    
---------------------------------------------------------------------------*/   
{
    NDIS_TAPI_EVENT TapiEvent;
    BOOLEAN fRet = FALSE;

    TRACE( TL_N, TM_Tp, ("+TpIndicateNewCall") );

    NdisAcquireSpinLock( &pCall->lockCall );

    if ( pCall->ulClFlags & CLBF_CallDropped ||
         pCall->ulClFlags & CLBF_CallClosePending )
    {
        TRACE( TL_N, TM_Tp, ("TpIndicateNewCall: Can not indicate new call since call is going down") );

        TRACE( TL_N, TM_Tp, ("-TpIndicateNewCall") );

        //
        // This may happen if call is closed internally due to the FSM timeout handlers
        //
        NdisReleaseSpinLock( &pCall->lockCall );

        return fRet;
    }

    NdisReleaseSpinLock( &pCall->lockCall );
    
    //
    // Indicate the new call to TAPI, retrieve the corresponding TAPI handle (htCall)
    // and set it in the call
    //
    // Future: The casts below between ulParam2. pCall->hdCall and pCall->htCall will
    //         be a problem on 64 bit machines.
    //
    TapiEvent.htLine = pCall->pLine->htLine;
    TapiEvent.htCall = 0;
    TapiEvent.ulMsg  = LINE_NEWCALL;
        
    TapiEvent.ulParam1 = (ULONG) pCall->hdCall;
    TapiEvent.ulParam2 = 0;
    TapiEvent.ulParam3 = 0; 

    TRACE( TL_N, TM_Tp, ("TpIndicateNewCall: Indicate LINE_NEWCALL") );

    NdisMIndicateStatus( pCall->pLine->pAdapter->MiniportAdapterHandle,
                         NDIS_STATUS_TAPI_INDICATION,
                         &TapiEvent,
                         sizeof( NDIS_TAPI_EVENT ) );   

    NdisAcquireSpinLock( &pCall->lockCall );
        
    pCall->htCall = (HTAPI_CALL) TapiEvent.ulParam2;

    fRet = TRUE;

    NdisReleaseSpinLock( &pCall->lockCall );

    TRACE( TL_N, TM_Tp, ("-TpIndicateNewCall") );

    return fRet;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ndis\raspppoe\util.c ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Module Name:

    util.c

Abstract:

    This module contains the routines some helper routines.

    	- Workitems: These routines manage the scheduled work items.
    	- Handle table: There routines manage a handle table that creates unique
    	                handles and stores context pointers into the table that are only
    	                accessible by the unique handle generated.

Author:

    Hakan Berk - Microsoft, Inc. (hakanb@microsoft.com) Feb-2000

Environment:

    Windows 2000 kernel mode Miniport driver or equivalent.

Revision History:

---------------------------------------------------------------------------*/
#include <ntddk.h>
#include <ntddndis.h>
#include <ndis.h>
#include <ndiswan.h>
#include <ndistapi.h>
#include <ntverp.h>

#include "debug.h"
#include "timer.h"
#include "bpool.h"
#include "ppool.h"
#include "util.h"
#include "packet.h"
#include "protocol.h"
#include "miniport.h"
#include "tapi.h"

VOID InitializeWorkItemLookasideList(
	IN PNPAGED_LOOKASIDE_LIST pLookaside,
	IN ULONG tagLookaside
	)
{
	NdisInitializeNPagedLookasideList( pLookaside,
									   NULL,
									   NULL,
									   0,
									   sizeof( WORKITEM ),
									   tagLookaside,
									   0 );
}
	
WORKITEM* AllocWorkItem(
	IN PNPAGED_LOOKASIDE_LIST pLookaside,
	IN WORKITEM_EXEC_ROUTINE pExecRoutine,
	IN WORKITEM_FREE_ROUTINE pFreeRoutine,
	IN PVOID Args[4],
	IN UINT workType
	)
{
	WORKITEM* pWorkItem = NULL;

	//
	// Allocate a binding work item from our pool
	//
	pWorkItem = NdisAllocateFromNPagedLookasideList( pLookaside );

	if ( pWorkItem == NULL )
		return NULL;

	//
	// Clear the memory
	//
	NdisZeroMemory( pWorkItem, sizeof( WORKITEM ) );

	//
	// Initialize the state of the work item
	//
	pWorkItem->workState = WS_NotScheduled;

	//
	// Initialize the type of work
	//
	pWorkItem->workType = workType;

	//
	// Set the lookaside list member
	//
	pWorkItem->pLookaside = pLookaside;

	//
	// Initialize the context for the work item
	//
	NdisMoveMemory( pWorkItem->Args, Args, 4 * sizeof( PVOID ) );

	pWorkItem->pExecRoutine = pExecRoutine;
	pWorkItem->pFreeRoutine = pFreeRoutine;
	
	//
	// As our NDIS_WORK_ITEM structure is embedded into our own work item
	// we can initialize it here.
	//
	NdisInitializeWorkItem( &pWorkItem->ndisWorkItem, 
							&WorkItemExec,
							pWorkItem );

	return pWorkItem;
}

VOID ScheduleWorkItem(
	IN WORKITEM *pWorkItem
	)
{
	//
	// Initialize the state of the work item
	//
	pWorkItem->workState = WS_Scheduled;

	//
	// Schedule the item
	//
	NdisScheduleWorkItem( &pWorkItem->ndisWorkItem );	
}

VOID FreeWorkItem(
	IN WORKITEM *pWorkItem
	)
{
	WORKITEM_FREE_ROUTINE pFreeRoutine = NULL;

	ASSERT( pWorkItem != NULL );

	//
	// Free the associated context information
	//
	if ( pWorkItem->pFreeRoutine != NULL )
		pWorkItem->pFreeRoutine( pWorkItem->Args, pWorkItem->workType );

	//
	// Free the actual work item
	//
	NdisFreeToNPagedLookasideList( pWorkItem->pLookaside, (PVOID) pWorkItem );
}


//
// This is the NDIS_WORK_ITEM handler that we schedule for our BINDING_WORKITEMs.
//
VOID WorkItemExec(
    IN NDIS_WORK_ITEM*  pNdisWorkItem,
    IN PVOID  pvContext
	)
{
	WORKITEM* pWorkItem = NULL;
	
	ASSERT( pNdisWorkItem != NULL );

	pWorkItem = (WORKITEM*) pvContext;

	ASSERT( pWorkItem->workState == WS_Scheduled );
	
	pWorkItem->workState = WS_Executing;

	if ( pWorkItem->pExecRoutine != NULL )
		pWorkItem->pExecRoutine( pWorkItem->Args, pWorkItem->workType );

	pWorkItem->workState = WS_Executed;

	FreeWorkItem( pWorkItem );	
}

HANDLE_TABLE InitializeHandleTable(
	IN UINT nHandleTableSize
	)
{
	NDIS_STATUS status = NDIS_STATUS_RESOURCES;
	HANDLE_TABLE Table = NULL;

	do
	{
		//
		// Allocate the table context
		//
		status = NdisAllocateMemoryWithTag( &Table,
										 	sizeof( HANDLE_TABLE_CB ),
											MTAG_HANDLETABLE );
	
		if ( status != NDIS_STATUS_SUCCESS )
			break;
	
		NdisZeroMemory( Table, sizeof( HANDLE_TABLE_CB ) );
	
		//
		// Allocate the array that holds the handle contexts
		//
		status = NdisAllocateMemoryWithTag( &Table->HandleTable,
											sizeof( HANDLE_CB ) * nHandleTableSize,
											MTAG_HANDLECB );
	
		if ( status != NDIS_STATUS_SUCCESS )
			break;
	
		NdisZeroMemory( Table->HandleTable, sizeof( HANDLE_CB ) * nHandleTableSize );
		
		Table->nTableSize = nHandleTableSize;
	
		Table->nActiveHandles = 0; 
		
		Table->usKeys = 0;

		status = NDIS_STATUS_SUCCESS;

	} while ( FALSE );

	if ( status != NDIS_STATUS_SUCCESS )
		FreeHandleTable( Table );
		
	return Table;				
}

VOID FreeHandleTable(
	IN OUT HANDLE_TABLE Table
	)
{
	if ( Table == NULL )
		return;

	if ( Table->HandleTable )		
	{
		NdisFreeMemory( Table->HandleTable,
						Table->nTableSize * sizeof( HANDLE_CB ),
						0 );
	}

	NdisFreeMemory( Table,
					sizeof( HANDLE_TABLE_CB ),
					0 );
}

NDIS_HANDLE InsertToHandleTable(
	IN HANDLE_TABLE Table,
	IN USHORT usPreferedIndex,
	IN PVOID pContext
	)
{
	ULONG ulHandle;
	USHORT usKey;

	HANDLE_CB* pHandleCB = NULL;

	if ( Table == NULL )
		return (NDIS_HANDLE) NULL;

	if ( usPreferedIndex == NO_PREFERED_INDEX )
	{
		UINT i;
		
		for (i = 0 ; i < Table->nTableSize ; i++ )
			if ( !Table->HandleTable[i].fActive )
				break;

		usPreferedIndex = (USHORT) i;
	}
	else
	{
		if ( Table->HandleTable[ usPreferedIndex ].fActive )
			return NULL;
	}

	if ( usPreferedIndex >= Table->nTableSize )
		return NULL;

	//
	// Generate Handle
	//
	ulHandle = (ULONG) usPreferedIndex;

	usKey = ++Table->usKeys;

	ulHandle = ulHandle << 16;

	ulHandle |= (ULONG) usKey;

	//
	// Update the handle control block
	//
	pHandleCB = &Table->HandleTable[ usPreferedIndex ];

	pHandleCB->fActive = TRUE;

	pHandleCB->pContext = pContext;

	pHandleCB->Handle = (NDIS_HANDLE) ULongToPtr( ulHandle );

	//
	// Increment the active handle counter
	//
	Table->nActiveHandles++;

	return pHandleCB->Handle;
}
	
USHORT RetrieveIndexFromHandle(
	IN NDIS_HANDLE Handle
	)
{
	ULONG_PTR ulHandle = (ULONG_PTR) Handle;
	USHORT usIndex;
	
	usIndex = (USHORT) ( ulHandle >> 16 );

	return usIndex;
}

PVOID RetrieveFromHandleTable(
	IN HANDLE_TABLE Table,
	IN NDIS_HANDLE Handle
	)
{
	USHORT usIndex;
	HANDLE_CB* pHandleCB = NULL;

	if ( Table == NULL )
		return NULL;

	usIndex = RetrieveIndexFromHandle( Handle );

	if ( usIndex >= Table->nTableSize )
		return NULL;

	pHandleCB = &Table->HandleTable[ usIndex ];

	if ( !pHandleCB->fActive )
		return NULL;

	if ( pHandleCB->Handle != Handle )
		return NULL;

	return pHandleCB->pContext;

}

PVOID RetrieveFromHandleTableByIndex(
	IN HANDLE_TABLE Table,
	IN USHORT usIndex
	)
{
	HANDLE_CB* pHandleCB = NULL;

	if ( Table == NULL )
		return NULL;
		
	if ( usIndex >= Table->nTableSize )
		return NULL;

	pHandleCB = &Table->HandleTable[ usIndex ];

	if ( !pHandleCB->fActive )
		return NULL;

	return pHandleCB->pContext;
}

PVOID RetrieveFromHandleTableBySessionId(
	IN HANDLE_TABLE Table,
	IN USHORT usSessionId
	)
{
	USHORT usIndex = usSessionId - 1;

	return RetrieveFromHandleTableByIndex( Table, usIndex );
}

VOID RemoveFromHandleTable(
	IN HANDLE_TABLE Table,
	IN NDIS_HANDLE Handle
	)
{
	USHORT usIndex;

	HANDLE_CB* pHandleCB = NULL;

	if ( Table == NULL )
		return;
		
	usIndex = RetrieveIndexFromHandle( Handle );

	if ( usIndex >= Table->nTableSize )
		return;

	pHandleCB = &Table->HandleTable[ usIndex ];

	if ( !pHandleCB->fActive )
		return;

	if ( pHandleCB->Handle != Handle )
		return;

	NdisZeroMemory( pHandleCB, sizeof( HANDLE_CB ) );

	Table->nActiveHandles--;
}

USHORT RetrieveSessionIdFromHandle(
	IN NDIS_HANDLE Handle
	)
{
	return ( RetrieveIndexFromHandle( Handle ) + 1 );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ndis\raspppoe\timer.c ===
// Copyright (c) 1997, Microsoft Corporation, all rights reserved
//
// timer.c
// RAS L2TP WAN mini-port/call-manager driver
// Timer management routines
//
// 01/07/97 Steve Cobb


#include <ntddk.h>
#include <ntddndis.h>
#include <ndis.h>
#include <ndiswan.h>
#include <ndistapi.h>
#include <ntverp.h>

#include "debug.h"
#include "timer.h"
#include "bpool.h"
#include "ppool.h"
#include "util.h"
#include "packet.h"
#include "protocol.h"
#include "miniport.h"
#include "tapi.h"


//-----------------------------------------------------------------------------
// Local prototypes (alphabetically)
//-----------------------------------------------------------------------------

BOOLEAN
RemoveTqi(
    IN TIMERQ* pTimerQ,
    IN TIMERQITEM* pItem,
    IN TIMERQEVENT event );

VOID
SetTimer(
    IN TIMERQ* pTimerQ,
    IN LONGLONG llCurrentTime );

VOID
TimerEvent(
    IN PVOID SystemSpecific1,
    IN PVOID FunctionContext,
    IN PVOID SystemSpecific2,
    IN PVOID SystemSpecific3 );


//-----------------------------------------------------------------------------
// Interface routines
//-----------------------------------------------------------------------------

VOID
TimerQInitialize(
    IN TIMERQ* pTimerQ )

    // Initializes caller's timer queue context 'pTimerQ'.
    //
{
    TRACE( TL_N, TM_Time, ( "TqInit" ) );

    InitializeListHead( &pTimerQ->listItems );
    NdisAllocateSpinLock( &pTimerQ->lock );
    NdisInitializeTimer( &pTimerQ->timer, TimerEvent, pTimerQ );
    pTimerQ->pHandler = NULL;
    pTimerQ->fTerminating = FALSE;
    pTimerQ->ulTag = MTAG_TIMERQ;
}


VOID
TimerQInitializeItem(
    IN TIMERQITEM* pItem )

    // Initializes caller's timer queue item, 'pItem'.  This should be called
    // before passing 'pItem' to any other TimerQ routine.
    //
{
    InitializeListHead( &pItem->linkItems );
}


VOID
TimerQTerminate(
    IN TIMERQ* pTimerQ,
    IN PTIMERQTERMINATECOMPLETE pHandler,
    IN VOID* pContext )

    // Terminates timer queue 'pTimerQ'.  Each scheduled item is called back
    // with TE_Terminate.  Caller's 'pHandler' is called with 'pTimerQ' and
    // 'pContext' so the 'pTimerQ' can be freed, if necessary.  Caller's
    // 'pTimerQ' must remain accessible until the 'pHandler' callback occurs,
    // which might be after this routine returns.
    //
{
    BOOLEAN fCancelled;
    LIST_ENTRY list;
    LIST_ENTRY* pLink;

    TRACE( TL_N, TM_Time, ( "TqTerm" ) );

    InitializeListHead( &list );

    NdisAcquireSpinLock( &pTimerQ->lock );
    {
        pTimerQ->fTerminating = TRUE;

        // Stop the timer.
        //
        NdisCancelTimer( &pTimerQ->timer, &fCancelled );
        TRACE( TL_N, TM_Time, ( "NdisCancelTimer" ) );

        if (!fCancelled && !IsListEmpty( &pTimerQ->listItems ))
        {
            // No event was cancelled but the list of events is not empty.
            // This means the timer has fired, but our internal handler has
            // not yet been called to process it, though it eventually will
            // be.  The internal handler must be the one to call the terminate
            // complete in this case, because there is no way for it to know
            // it cannot reference 'pTimerQ'.  Indicate this to the handler by
            // filling in the termination handler.
            //
            TRACE( TL_A, TM_Time, ( "Mid-expire Q" ) );
            pTimerQ->pHandler = pHandler;
            pTimerQ->pContext = pContext;
            pHandler = NULL;
        }

        // Move the scheduled events to a temporary list, marking them all
        // "not on queue" so any attempt by user to cancel the item will be
        // ignored.
        //
        while (!IsListEmpty( &pTimerQ->listItems ))
        {
            pLink = RemoveHeadList( &pTimerQ->listItems );
            InsertTailList( &list, pLink );
        }
    }
    NdisReleaseSpinLock( &pTimerQ->lock );

    // Must be careful here.  If 'pHandler' was set NULL above, 'pTimerQ' must
    // not be referenced in the rest of this routine.
    //
    // Call user's "terminate" event handler for each removed item.
    //
    while (!IsListEmpty( &list ))
    {
        TIMERQITEM* pItem;

        pLink = RemoveHeadList( &list );
        InitializeListHead( pLink );
        pItem = CONTAINING_RECORD( pLink, TIMERQITEM, linkItems );
        TRACE( TL_I, TM_Time,
            ( "Flush TQI=$%p, handler=$%p", pItem, pItem->pHandler ) );
        pItem->pHandler( pItem, pItem->pContext, TE_Terminate );
    }

    // Call user's "terminate complete" handler, if it's still our job.
    //
    if (pHandler)
    {
        pTimerQ->ulTag = MTAG_FREED;
        pHandler( pTimerQ, pContext );
    }
}


VOID
TimerQScheduleItem(
    IN TIMERQ* pTimerQ,
    IN OUT TIMERQITEM* pNewItem,
    IN ULONG ulTimeoutMs,
    IN PTIMERQEVENT pHandler,
    IN VOID* pContext )

    // Schedule new timer event 'pNewItem' on timer queue 'pTimerQ'.  When the
    // event occurs in 'ulTimeoutMs' milliseconds, the 'pHandler' routine is
    // called with arguments 'pNewItem', 'pContext', and TE_Expired.  If the
    // item is cancelled or the queue terminated 'pHandler' is called as above
    // but with TE_Cancel or TE_Terminate as appropriate.
    //
{
    TRACE( TL_N, TM_Time, ( "TqSchedItem(ms=%d)", ulTimeoutMs ) );

    pNewItem->pHandler = pHandler;
    pNewItem->pContext = pContext;

    NdisAcquireSpinLock( &pTimerQ->lock );
    {
        LIST_ENTRY* pLink;
        LARGE_INTEGER lrgTime;

        ASSERT( pNewItem->linkItems.Flink == &pNewItem->linkItems );

        // The system time at which the timeout will occur is stored.
        //
        NdisGetCurrentSystemTime( &lrgTime );
        pNewItem->llExpireTime =
            lrgTime.QuadPart + (((LONGLONG )ulTimeoutMs) * 10000);

        // Walk the list of timer items looking for the first item that will
        // expire before the new item.  Do it backwards so the likely case of
        // many timeouts with roughly the same interval is handled
        // efficiently.
        //
        for (pLink = pTimerQ->listItems.Blink;
             pLink != &pTimerQ->listItems;
             pLink = pLink->Blink )
        {
            TIMERQITEM* pItem;

            pItem = CONTAINING_RECORD( pLink, TIMERQITEM, linkItems );

            if (pItem->llExpireTime < pNewItem->llExpireTime)
            {
                break;
            }
        }

        // Link the new item into the timer queue after the found item (or
        // after the head if none was found).
        //
        InsertAfter( &pNewItem->linkItems, pLink );

        if (pTimerQ->listItems.Flink == &pNewItem->linkItems)
        {
            // The new item expires before all other items so need to re-set
            // the NDIS timer.
            //
            SetTimer( pTimerQ, lrgTime.QuadPart );
        }
    }
    NdisReleaseSpinLock( &pTimerQ->lock );
}


BOOLEAN
TimerQCancelItem(
    IN TIMERQ* pTimerQ,
    IN TIMERQITEM* pItem )

    // Remove scheduled timer event 'pItem' from timer queue 'pTimerQ' and
    // call user's handler with event 'TE_Cancel', or nothing if 'pItem' is
    // NULL.
    //
    // Returns true if the timer was cancelled, false if it not, i.e. it was
    // not on the queue, possibly because it expired already.
    //
{
    TRACE( TL_N, TM_Time, ( "TqCancelItem" ) );
    return RemoveTqi( pTimerQ, pItem, TE_Cancel );
}


BOOLEAN
TimerQExpireItem(
    IN TIMERQ* pTimerQ,
    IN TIMERQITEM* pItem )

    // Remove scheduled timer event 'pItem' from timer queue 'pTimerQ' and
    // call user's handler with event 'TE_Expire', or do nothing if 'pItem' is
    // NULL.
    //
    // Returns true if the timer was expired, false if it not, i.e. it was not
    // on the queue, possibly because it expired already.
    //
{
    TRACE( TL_N, TM_Time, ( "TqExpireItem" ) );
    return RemoveTqi( pTimerQ, pItem, TE_Expire );
}


BOOLEAN
TimerQTerminateItem(
    IN TIMERQ* pTimerQ,
    IN TIMERQITEM* pItem )

    // Remove scheduled timer event 'pItem' from timer queue 'pTimerQ', or do
    // nothing if 'pItem' is NULL.
    //
    // Returns true if the timer was terminated, false if it not, i.e. it was not
    // on the queue, possibly because it expired already.
    //
{
    TRACE( TL_N, TM_Time, ( "TqTermItem" ) );
    return RemoveTqi( pTimerQ, pItem, TE_Terminate );
}


#if DBG
CHAR*
TimerQPszFromEvent(
    IN TIMERQEVENT event )

    // Debug utility to convert timer event coode 'event' to a corresponding
    // display string.
    //
{
    static CHAR* aszEvent[ 3 ] =
    {
        "expire",
        "cancel",
        "terminate"
    };

    return aszEvent[ (ULONG )event ];
}
#endif


//-----------------------------------------------------------------------------
// Timer utility routines (alphabetically)
//-----------------------------------------------------------------------------

BOOLEAN
RemoveTqi(
    IN TIMERQ* pTimerQ,
    IN TIMERQITEM* pItem,
    IN TIMERQEVENT event )

    // Remove scheduled timer event 'pItem' from timer queue 'pTimerQ' and
    // call user's handler with event 'event'.  The 'TE_Expire' event handler
    // is not called directly, but rescheduled with a 0 timeout so it occurs
    // immediately, but at DPC when no locks are held just like the original
    // timer had fired..
    //
    // Returns true if the item was on the queue, false otherwise.
    //
{
    BOOLEAN fFirst;
    LIST_ENTRY* pLink;

    if (!pItem)
    {
        TRACE( TL_N, TM_Time, ( "NULL pTqi" ) );
        return FALSE;
    }

    pLink = &pItem->linkItems;

    NdisAcquireSpinLock( &pTimerQ->lock );
    {
        if (pItem->linkItems.Flink == &pItem->linkItems
            || pTimerQ->fTerminating)
        {
            // The item is not on the queue.  Another operation may have
            // already dequeued it, but may not yet have called user's
            // handler.
            //
            TRACE( TL_N, TM_Time, ( "Not scheduled" ) );
            NdisReleaseSpinLock( &pTimerQ->lock );
            return FALSE;
        }

        fFirst = (pLink == pTimerQ->listItems.Flink);
        if (fFirst)
        {
            BOOLEAN fCancelled;

            // Cancelling first item on list, so cancel the NDIS timer.
            //
            NdisCancelTimer( &pTimerQ->timer, &fCancelled );
            TRACE( TL_N, TM_Time, ( "NdisCancelTimer" ) );

            if (!fCancelled)
            {
                // Too late.  The item has expired already but has not yet
                // been removed from the list by the internal handler.
                //
                TRACE( TL_A, TM_Time, ( "Mid-expire e=%d $%p($%p)",
                    event, pItem->pHandler, pItem->pContext ) );
                NdisReleaseSpinLock( &pTimerQ->lock );
                return FALSE;
            }
        }

        // Un-schedule the event and mark the item descriptor "off queue", so
        // any later attempt to cancel will do nothing.
        //
        RemoveEntryList( pLink );
        InitializeListHead( pLink );

        if (fFirst)
        {
            // Re-set the NDIS timer to reflect the timeout of the new first
            // item, if any.
            //
            SetTimer( pTimerQ, 0 );
        }
    }
    NdisReleaseSpinLock( &pTimerQ->lock );

    if (event == TE_Expire)
    {
        TimerQScheduleItem(
            pTimerQ, pItem, 0, pItem->pHandler, pItem->pContext );
    }
    else
    {
        // Call user's event handler.
        //
        pItem->pHandler( pItem, pItem->pContext, event );
    }

    return TRUE;
}


VOID
SetTimer(
    IN TIMERQ* pTimerQ,
    IN LONGLONG llCurrentTime )

    // Sets the NDIS timer to expire when the timeout of the first link, if
    // any, in the timer queue 'pTimerQ' occurs.  Any previously set timeout
    // is "overwritten".  'LlCurrentTime' is the current system time, if
    // known, or 0 if not.
    //
    // IMPORTANT: Caller must hold the TIMERQ lock.
    //
{
    LIST_ENTRY* pFirstLink;
    TIMERQITEM* pFirstItem;
    LONGLONG llTimeoutMs;
    ULONG ulTimeoutMs;

    if (IsListEmpty( &pTimerQ->listItems ))
    {
        return;
    }

    pFirstLink = pTimerQ->listItems.Flink;
    pFirstItem = CONTAINING_RECORD( pFirstLink, TIMERQITEM, linkItems );

    if (llCurrentTime == 0)
    {
        LARGE_INTEGER lrgTime;

        NdisGetCurrentSystemTime( &lrgTime );
        llCurrentTime = lrgTime.QuadPart;
    }

    llTimeoutMs = (pFirstItem->llExpireTime - llCurrentTime) / 10000;
    if (llTimeoutMs <= 0)
    {
        // The timeout interval is negative, i.e. it's already passed.  Set it
        // to zero so it is triggered immediately.
        //
        ulTimeoutMs = 0;
    }
    else
    {
        // The timeout interval is in the future.
        //
        ASSERT( ((LARGE_INTEGER* )&llTimeoutMs)->HighPart == 0 );
        ulTimeoutMs = ((LARGE_INTEGER* )&llTimeoutMs)->LowPart;
    }

    NdisSetTimer( &pTimerQ->timer, ulTimeoutMs );
    TRACE( TL_N, TM_Time, ( "NdisSetTimer(%dms)", ulTimeoutMs ) );
}


VOID
TimerEvent(
    IN PVOID SystemSpecific1,
    IN PVOID FunctionContext,
    IN PVOID SystemSpecific2,
    IN PVOID SystemSpecific3 )

    // NDIS_TIMER_FUNCTION called when a timer expires.
    //
{
    TIMERQ* pTimerQ;
    LIST_ENTRY* pLink;
    TIMERQITEM* pItem;
    PTIMERQTERMINATECOMPLETE pHandler;

    TRACE( TL_N, TM_Time, ( "TimerEvent" ) );

    pTimerQ = (TIMERQ* )FunctionContext;
    if (!pTimerQ || pTimerQ->ulTag != MTAG_TIMERQ)
    {
        // Should not happen.
        //
        TRACE( TL_A, TM_Time, ( "Not TIMERQ?" ) );
        return;
    }

    NdisAcquireSpinLock( &pTimerQ->lock );
    {
        pHandler = pTimerQ->pHandler;
        if (!pHandler)
        {
            // The termination handler is not set, so proceed normally.
            // Remove the first event item, make it un-cancel-able, and re-set
            // the timer for the next event.
            //
            if (IsListEmpty( &pTimerQ->listItems ))
            {
                // Should not happen (but does sometimes on MP Alpha?).
                //
                TRACE( TL_A, TM_Time, ( "No item queued?" ) );
                pItem = NULL;
            }
            else
            {
                pLink = RemoveHeadList( &pTimerQ->listItems );
                InitializeListHead( pLink );
                pItem = CONTAINING_RECORD( pLink, TIMERQITEM, linkItems );
                SetTimer( pTimerQ, 0 );
            }
        }
    }
    NdisReleaseSpinLock( &pTimerQ->lock );

    if (pHandler)
    {
        // The termination handler was set meaning the timer queue has been
        // terminated between this event firing and this handler being called.
        // That means we are the one who calls user's termination handler.
        // 'pTimerQ' must not be referenced after that call.
        //
        TRACE( TL_A, TM_Time, ( "Mid-event case handled" ) );
        pTimerQ->ulTag = MTAG_FREED;
        pHandler( pTimerQ, pTimerQ->pContext );
        return;
    }

    if (pItem)
    {
        // Call user's "expire" event handler.
        //
        pItem->pHandler( pItem, pItem->pContext, TE_Expire );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ndis\raspptp\common\bpool.h ===
// Copyright (c) 1997-1999 Microsoft Corporation
//
// bpool.h
// RAS L2TP WAN mini-port/call-manager driver
// Buffer pool management header
//
// 01/07/97 Steve Cobb, adapted from Gurdeep's WANARP code.


#ifndef _BPOOL_H_
#define _BPOOL_H_


//-----------------------------------------------------------------------------
// Data structures
//-----------------------------------------------------------------------------

// Buffer pool control block.  A buffer pool prevents fragmentation of the
// non-paged memory pool by allocating the memory for a group of buffers in a
// single contiguous block.  At user's option, the buffer pool routines may
// allocate a pool of NDIS_BUFFER buffer descriptors and associate each with
// the memory buffers sliced from the contiguous block.  This allows the
// buffer to be reused while the virtual->physical memory mapping is performed
// only once.  All necessary pool growth and shrinkage is handled internally.
//
typedef struct
_BUFFERPOOL
{
    // Size in bytes of an individual buffer in the pool.
    //
    ULONG ulBufferSize;

    // The optimal number of buffers to allocate in each buffer block.
    //
    ULONG ulBuffersPerBlock;

    // Maximum number of individual buffers that may be allocated in the
    // entire pool or 0 for unlimited.
    //
    ULONG ulMaxBuffers;

    // Current number of individual buffers allocated in the entire pool.
    //
    ULONG ulCurBuffers;

    // Garbage collection occurs after this many calls to FreeBufferToPool.
    //
    ULONG ulFreesPerCollection;

    // Number of calls to FreeBufferToPool since a garbage collection.
    //
    ULONG ulFreesSinceCollection;

    // Indicates an NDIS_BUFFER is to be associated with each individual
    // buffer in the pool.
    //
    BOOLEAN fAssociateNdisBuffer;

    // Memory identification tag for allocated blocks.
    //
    ULONG ulTag;

    // Head of the double linked list of BUFFERBLOCKHEADs.  Access to the list
    // is protected with 'lock' in this structure.
    //
    LIST_ENTRY listBlocks;

    // Head of the double linked list of free BUFFERHEADs.  Each BUFFERHEAD in
    // the list is ready to go, i.e. it preceeds it's already allocated memory
    // buffer and, if appropriate, has an NDIS_BUFFER associated with it.
    // Access to the list is protected by 'lock' in this structure.
    // Interlocked push/pop is not used because (a) the list of blocks and the
    // list of buffers must lock each other and (b) double links are necessary
    // for garbage collection.
    //
    LIST_ENTRY listFreeBuffers;

    // This lock protects this structure and both the list of blocks and the
    // list of buffers.
    //
    NDIS_SPIN_LOCK lock;
}
BUFFERPOOL;


// Header of a single block of buffers from a buffer pool.  The BUFFERHEAD of
// the first buffer immediately follows.
//
typedef struct
_BUFFERBLOCKHEAD
{
    // Link to the prev/next buffer block header in the buffer pool's list.
    //
    LIST_ENTRY linkBlocks;

    // NDIS's handle of the pool of NDIS_BUFFER descriptors associated with
    // this block, or NULL if none.  (Note: With the current NT implementation
    // of NDIS_BUFFER as MDL this is always NULL).
    //
    NDIS_HANDLE hNdisPool;

    // Back pointer to the buffer pool.
    //
    BUFFERPOOL* pPool;

    // Number of individual buffers in this block.
    //
    ULONG ulBuffers;

    // Number of individual buffers in this block on the free list.
    //
    ULONG ulFreeBuffers;
}
BUFFERBLOCKHEAD;


// Header of an individual buffer.  The buffer memory itself immediately
// follows.
//
typedef struct
_BUFFERHEAD
{
    // Links to prev/next buffer header in the buffer pool's free list.
    //
    LIST_ENTRY linkFreeBuffers;

    // Back link to owning buffer block header.
    //
    BUFFERBLOCKHEAD* pBlock;

    // NDIS buffer descriptor of this buffer.  This is NULL unless the pool is
    // initialized with the 'fAssociateNdisBuffer' option.
    //
    NDIS_BUFFER* pNdisBuffer;

}
BUFFERHEAD;


//-----------------------------------------------------------------------------
// Interface prototypes and inline definitions
//-----------------------------------------------------------------------------

VOID
InitBufferPool(
    OUT BUFFERPOOL* pPool,
    IN ULONG ulBufferSize,
    IN ULONG ulMaxBuffers,
    IN ULONG ulBuffersPerBlock,
    IN ULONG ulFreesPerCollection,
    IN BOOLEAN fAssociateNdisBuffer,
    IN ULONG ulTag );

BOOLEAN
FreeBufferPool(
    IN BUFFERPOOL* pPool );

CHAR*
GetBufferFromPool(
    IN BUFFERPOOL* pPool );

VOID
FreeBufferToPool(
    IN BUFFERPOOL* pPool,
    IN CHAR* pBuffer,
    IN BOOLEAN fGarbageCollection );

NDIS_BUFFER*
NdisBufferFromBuffer(
    IN CHAR* pBuffer );

ULONG
BufferSizeFromBuffer(
    IN CHAR* pBuffer );

NDIS_BUFFER*
PoolHandleForNdisCopyBufferFromBuffer(
    IN CHAR* pBuffer );

VOID
CollectBufferPoolGarbage(
    BUFFERPOOL* pPool );


#endif // BPOOL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ndis\raspppoe\timer.h ===
// Copyright (c) 1997, Microsoft Corporation, all rights reserved
//
// timer.h
// RAS L2TP WAN mini-port/call-manager driver
// Timer management header
//
// 01/07/97 Steve Cobb
//
// This interface encapsulates the queuing of multiple timer events onto a
// single NDIS timer.


#ifndef _TIMER_H_
#define _TIMER_H_


//-----------------------------------------------------------------------------
// Data structures
//-----------------------------------------------------------------------------

// Forward declarations.
//
typedef struct _TIMERQ TIMERQ;
typedef struct _TIMERQITEM TIMERQITEM;
typedef enum _TIMERQEVENT TIMERQEVENT;


// Timer queue event handler.  'PTqi' and 'pContext' are the timer event
// descriptor and user context passed to TimerQScheduleItem.  'Event' is the
// timer event code indicating whether the timer expired, was cancelled, or
// the queue was terminated.
//
// The "cancel" event is never generated internally, but only by a user call
// to TimerQCancelItem, thus user may require specific locks be held for
// "cancel" events.  User cannot require than specific locks be held for
// "expire" or "terminate" events as these may be generated internally.  User
// should pay attention to the return codes of TimerQCancelItem and
// TimerQTerminateItem calls, as it will occassionally be impossible to stop
// an "expire" event that has not yet been processed from occurring.
//
typedef
VOID
(*PTIMERQEVENT)(
    IN TIMERQITEM* pTqi,
    IN VOID* pContext,
    IN TIMERQEVENT event );

// Timer queue termination completion handler.  'PTimerQ' is the timer queue
// descriptor.  'PContext' is user's context as passed to TimerQTerminate.
// Caller must not free or reuse the TIMERQ before this routine is called.
//
typedef
VOID
(*PTIMERQTERMINATECOMPLETE)(
    IN TIMERQ* pTimerQ,
    IN VOID* pContext );


// Timer queue descriptor.  All access should be via the TimerQ* interface.
// There is no reason user should look inside.  All necessary locking is
// handled internally.
//
typedef struct
_TIMERQ
{
    // Set to MTAG_TIMERQ when the block is valid and to MTAG_FREED when no
    // longer valid.
    //
    ULONG ulTag;

    // Head of a double-linked list of "ticking" TIMERQITEMs.  The list is
    // sorted by time to expiration with the earliest expiration at the head
    // of the list.  The list is protected by 'lock'.
    //
    LIST_ENTRY listItems;

    // Caller's terminate complete handler as passed to TimerQTerminate.  This
    // is non-NULL only when our internal timer event handler must call it.
    //
    PTIMERQTERMINATECOMPLETE pHandler;

    // User's PTIMERQTERMINATECOMPLETE context passed back to 'pHandler'.
    //
    VOID* pContext;

    // Set when the timer queue is terminating.  No other requests are
    // accepted when this is the case.
    //
    BOOLEAN fTerminating;

    // Spin lock protecting the 'listItems' list.
    //
    NDIS_SPIN_LOCK lock;

    // NDIS timer object.
    //
    NDIS_TIMER timer;
}
TIMERQ;


// Timer queue event descriptor.  All access should be via the TimerQ*
// interface.  There is no reason user should look inside.  This is exposed to
// allow user to efficiently manage allocation of TIMERQITEMS for several
// timers from a large pool.
//
typedef struct
_TIMERQITEM
{
    // Links to the prev/next TIMERQITEM in the owning TIMERQ's chain of
    // pending timer events.  Access is protected by 'lock' in the TIMERQ
    // structure.
    //
    LIST_ENTRY linkItems;

    // System time at which this event should occur.
    //
    LONGLONG llExpireTime;

    // User's routine to handle the timeout event when it occurs.
    //
    PTIMERQEVENT pHandler;

    // User's PTIMERQEVENT context passed back to 'pHandler'.
    //
    VOID* pContext;
}
TIMERQITEM;


// Indicates the event which triggered user's callback to be called.
//
typedef enum
_TIMERQEVENT
{
    // The timeout interval has elapsed or user called TimerQExpireItem.
    //
    TE_Expire,

    // User called TimerQCancelItem.
    //
    TE_Cancel,

    // User called TimerQTerminateItem or called TimerQTerminate while the
    // item was queued.
    //
    TE_Terminate
}
TIMERQEVENT;


//-----------------------------------------------------------------------------
// Interface prototypes
//-----------------------------------------------------------------------------

BOOLEAN
IsTimerQItemScheduled(
    IN TIMERQITEM* pItem );

VOID
TimerQInitialize(
    IN TIMERQ* pTimerQ );

VOID
TimerQInitializeItem(
    IN TIMERQITEM* pItem );

VOID
TimerQTerminate(
    IN TIMERQ* pTimerQ,
    IN PTIMERQTERMINATECOMPLETE pHandler,
    IN VOID* pContext );

VOID
TimerQScheduleItem(
    IN TIMERQ* pTimerQ,
    IN OUT TIMERQITEM* pNewItem,
    IN ULONG ulTimeoutMs,
    IN PTIMERQEVENT pHandler,
    IN VOID* pContext );

BOOLEAN
TimerQCancelItem(
    IN TIMERQ* pTimerQ,
    IN TIMERQITEM* pItem );

BOOLEAN
TimerQExpireItem(
    IN TIMERQ* pTimerQ,
    IN TIMERQITEM* pItem );

CHAR*
TimerQPszFromEvent(
    IN TIMERQEVENT event );

BOOLEAN
TimerQTerminateItem(
    IN TIMERQ* pTimerQ,
    IN TIMERQITEM* pItem );


#endif // TIMER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ndis\raspptp\common\call.c ===
//depot/Lab03_N/Net/rras/ndis/raspptp/common/call.c#7 - edit change 19457 (text)
/*****************************************************************************
*
*   Copyright (c) 1998-1999 Microsoft Corporation
*
*   CALL.C - PPTP Call layer functionality
*
*   Author:     Stan Adermann (stana)
*
*   Created:    7/28/1998
*
*****************************************************************************/

#include "raspptp.h"

#include "call.tmh"

//ULONG ProcCountTx[2] = {0, 0};
//ULONG ProcCountRx[2] = {0, 0};

ULONG CallStateToLineCallStateMap[NUM_CALL_STATES] = {
    LINECALLSTATE_UNKNOWN,              // STATE_CALL_INVALID
    LINECALLSTATE_UNKNOWN,              // STATE_CALL_CLOSED
    LINECALLSTATE_IDLE,                 // STATE_CALL_IDLE
    LINECALLSTATE_IDLE,                 // STATE_CALL_OFFHOOK
    LINECALLSTATE_OFFERING,             // STATE_CALL_OFFERING
    LINECALLSTATE_OFFERING,             // STATE_CALL_PAC_OFFERING
    LINECALLSTATE_OFFERING,             // STATE_CALL_PAC_WAIT
    LINECALLSTATE_DIALING,              // STATE_CALL_DIALING
    LINECALLSTATE_PROCEEDING,           // STATE_CALL_PROCEEDING
    LINECALLSTATE_CONNECTED,            // STATE_CALL_ESTABLISHED
    LINECALLSTATE_CONNECTED,            // STATE_CALL_WAIT_DISCONNECT
    LINECALLSTATE_DISCONNECTED,         // STATE_CALL_CLEANUP
};

ULONG g_CallSerialNumber = 0;

#define RNG_KEY_SIZE    256
#define RNG_THRESHOLD   (1024 * 8)

VOID
CallpRekey(
    IN PPPTP_WORK_ITEM pWorkItem
    )
{
    UCHAR   pBuf[RNG_KEY_SIZE];

    if(pgAdapter->FipsFunctionTable.FIPSGenRandom(pBuf, RNG_KEY_SIZE)) 
    {
        NdisAcquireSpinLock(&pgAdapter->Lock);
        
        // Generate the key control structure.
        rc4_key(&pgAdapter->Rc4KeyData, RNG_KEY_SIZE, pBuf);
        pgAdapter->lRandomCount = 0;
    }
    else
    {
        WPLOG(LL_A, LM_Res, ("Failed to call FIPSGenRandom"));
    
        NdisAcquireSpinLock(&pgAdapter->Lock);
    }

    pgAdapter->bRekeying = FALSE;
        
    NdisReleaseSpinLock(&pgAdapter->Lock);
}

// Assume pAdapter->Lock is held
__inline ULONG CallGetRandomId()
{
    ULONG ulRandomNumber;

    rc4(&pgAdapter->Rc4KeyData, 4, (PUCHAR)&ulRandomNumber);

    ++pgAdapter->lRandomCount;
    if(pgAdapter->lRandomCount > RNG_THRESHOLD && !pgAdapter->bRekeying)
    {
        if(ScheduleWorkItem(CallpRekey, NULL, NULL, 0)==NDIS_STATUS_SUCCESS)
        {
            pgAdapter->bRekeying = TRUE;
        }
    }
    
    return (ulRandomNumber % PptpWanEndpoints);
}

// Assume pAdapter->Lock is held
__inline ULONG CallGetRandomWithRange(ULONG ulRange)
{
    ULONG ulRandomNumber;

    rc4(&pgAdapter->Rc4KeyData, 4, (PUCHAR)&ulRandomNumber);

    ++pgAdapter->lRandomCount;
    if(pgAdapter->lRandomCount > RNG_THRESHOLD && !pgAdapter->bRekeying)
    {
        if(ScheduleWorkItem(CallpRekey, NULL, NULL, 0)==NDIS_STATUS_SUCCESS)
        {
            pgAdapter->bRekeying = TRUE;
        }
    }

    return (ulRandomNumber % ulRange);
}

// Assume pAdapter->Lock is held
__inline VOID CallSetFullCallId(PCALL_SESSION pCall)
{
    if(PptpCallIdMask)
    {
        pCall->FullDeviceId = (CallGetRandomWithRange(MAX_CALL_ID_RANGE) & ~PptpCallIdMask) + pCall->DeviceId;
    }
    else
    {
        pCall->FullDeviceId = PptpBaseCallId + pCall->DeviceId;
    }
}


static PCHAR aszCallStateType[NUM_CALL_STATES+1] =
{
    "INVALID",
    "CLOSED",
    "IDLE",
    "OFFHOOK",
    "OFFERING",
    "PAC_OFFERING",
    "PAC_WAIT",
    "DIALING",
    "PROCEEDING",
    "ESTABLISHED",
    "WAIT_DISCONNECT",
    "CLEANUP",
    "UNKNOWN"
};
                                                                    

__inline PCHAR szCallState(IN CALL_STATE state)
{
    if (state >= 0 && state < NUM_CALL_STATES)
    {
        return aszCallStateType[state];
    }
    else
    {
        return aszCallStateType[NUM_CALL_STATES];
    }
}

VOID
CallpAckTimeout(
    IN PVOID SystemSpecific1,
    IN PVOID Context,
    IN PVOID SystemSpecific2,
    IN PVOID SystemSpecific3
    );

VOID
CallpCloseTimeout(
    IN PVOID SystemSpecific1,
    IN PVOID Context,
    IN PVOID SystemSpecific2,
    IN PVOID SystemSpecific3
    );

VOID
CallpDialTimeout(
    IN PVOID SystemSpecific1,
    IN PVOID Context,
    IN PVOID SystemSpecific2,
    IN PVOID SystemSpecific3
    );

VOID
CallpFinalDeref(IN PCALL_SESSION pCall);

/*++

Routine Description:

    Init FIPS and get the first random RC4 key

Arguments:

    Called at PASSIVE level.

Return Value:
    
    NDIS_STATUS_SUCCESS/NDIS_STATUS_FAILURE

--*/
NTSTATUS
RngInit()
{
    NTSTATUS ntStatus = STATUS_UNSUCCESSFUL;
    UNICODE_STRING DeviceName = { 0 };
    KEVENT kEvent = { 0 };
    PIRP pIrp = NULL;
    IO_STATUS_BLOCK IoStatusBlock = { 0 };
    UCHAR pBuf[RNG_KEY_SIZE];

    RtlInitUnicodeString(&DeviceName, FIPS_DEVICE_NAME);

    do
    {
        if(!pgAdapter)
        {
            break;
        }
    
        //
        // Get pointers to the file and device objects for FIPS.
        //
        ntStatus = IoGetDeviceObjectPointer(
                        &DeviceName,
                        FILE_ALL_ACCESS,
                        &pgAdapter->pFipsFileObject,
                        &pgAdapter->pFipsDeviceObject
                        );
                        
        if(!NT_SUCCESS(ntStatus))
        {
            break;
        }               
    
        //
        // Build the request to send to FIPS to get the library table.
        //
        KeInitializeEvent(&kEvent, SynchronizationEvent, FALSE);
    
        pIrp = IoBuildDeviceIoControlRequest(
                       IOCTL_FIPS_GET_FUNCTION_TABLE,
                       pgAdapter->pFipsDeviceObject,
                       NULL,
                       0,
                       &pgAdapter->FipsFunctionTable,
                       sizeof(FIPS_FUNCTION_TABLE),
                       FALSE,
                       &kEvent,
                       &IoStatusBlock
                       );
    
        if (!pIrp) {
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }
    
        //
        // IoBuildDeviceIoControlRequest queues the IRP it creates in the IRP queue
        // of the current thread. When the thread terminates, it deallocates the
        // IRP's memory.
        //
        ntStatus = IoCallDriver(pgAdapter->pFipsDeviceObject, pIrp);
    
        if (ntStatus == STATUS_PENDING) {
            ntStatus = KeWaitForSingleObject(
                            &kEvent,
                            Executive,
                            KernelMode,
                            FALSE,
                            NULL
                            );
            if (ntStatus == STATUS_SUCCESS) {
                ntStatus = IoStatusBlock.Status;
            }
        }
        
        if(!NT_SUCCESS(ntStatus))
        {
            break;
        }               
        
        if(pgAdapter->FipsFunctionTable.FIPSGenRandom(pBuf, RNG_KEY_SIZE) == FALSE) 
        {
            ntStatus = STATUS_UNSUCCESSFUL;
            break;
        }
    
        //
        // Generate the key control structure.
        //
        rc4_key(&pgAdapter->Rc4KeyData, RNG_KEY_SIZE, pBuf);
        
    } while(FALSE);
    
    if(!NT_SUCCESS(ntStatus))
    {
        if(pgAdapter->pFipsFileObject) 
        {
            ObDereferenceObject(pgAdapter->pFipsFileObject);
            pgAdapter->pFipsFileObject = NULL;
        }
    }

    return (ntStatus);
}

VOID InitCallLayer()
{
    if(!PptpClientSide && !PptpBaseCallId)
    {
        // Get the call id mask
        PptpCallIdMask = 1;
        while(PptpCallIdMask < PptpWanEndpoints)
        {
            PptpCallIdMask = PptpCallIdMask << 1;
        }
        
        --PptpCallIdMask;
        PptpMaxCallId = MAX_CALL_ID_RANGE;
    }
    else
    {
        PptpMaxCallId = PptpBaseCallId + PptpWanEndpoints;
    }
}

VOID
CallAssignSerialNumber(
    PCALL_SESSION pCall
    )
{
    ASSERT(IS_CALL(pCall));
    ASSERT_LOCK_HELD(&pCall->Lock);
    pCall->SerialNumber = (USHORT)NdisInterlockedIncrement(&g_CallSerialNumber);
}


PCALL_SESSION
CallAlloc(PPPTP_ADAPTER pAdapter)
{
    PCALL_SESSION pCall;

    DEBUGMSG(DBG_FUNC, (DTEXT("+CallAlloc\n")));

    pCall = MyMemAlloc(sizeof(CALL_SESSION), TAG_PPTP_CALL);
    if (!pCall)
    {
        WPLOG(LL_A, LM_Res, ("Failed to alloc CALL"));
        return NULL;
    }
    
    NdisZeroMemory(pCall, sizeof(CALL_SESSION));

    pCall->Signature = TAG_PPTP_CALL;
    pCall->pAdapter = pAdapter;
    pCall->Close.Checklist = CALL_CLOSE_COMPLETE;

    NdisAllocateSpinLock(&pCall->Lock);

    NdisInitializeListHead(&pCall->RxPacketList);
    NdisInitializeListHead(&pCall->TxPacketList);
    NdisInitializeListHead(&pCall->TxActivePacketList);

    NdisMInitializeTimer(&pCall->Close.Timer,
                         pAdapter->hMiniportAdapter,
                         CallpCloseTimeout,
                         pCall);

    NdisMInitializeTimer(&pCall->Ack.Timer,
                         pAdapter->hMiniportAdapter,
                         CallpAckTimeout,
                         pCall);

    NdisMInitializeTimer(&pCall->DialTimer,
                         pAdapter->hMiniportAdapter,
                         CallpDialTimeout,
                         pCall);

#if 0
    PptpInitializeDpc(&pCall->ReceiveDpc,
                      pAdapter->hMiniportAdapter,
                      CallProcessRxPackets,
                      pCall);
#endif
    NdisInitializeWorkItem(&pCall->SendWorkItem, CallProcessPackets, pCall);
    NdisInitializeWorkItem(&pCall->RecvWorkItem, CallProcessRxPackets, pCall);

    pCall->Ack.Packet.StartBuffer = pCall->Ack.PacketBuffer;
    pCall->Ack.Packet.EndBuffer = pCall->Ack.PacketBuffer + sizeof(pCall->Ack.PacketBuffer);
    pCall->Ack.Packet.CurrentBuffer = pCall->Ack.Packet.EndBuffer;
    pCall->Ack.Packet.CurrentLength = 0;

    INIT_REFERENCE_OBJECT(pCall, CallpFinalDeref);

    //
    // Instead of calling:
    // CallSetState(pCall, STATE_CALL_CLOSED, 0, UNLOCKED);
    //
    // it is better to set the state manually since the former creates an exception to our locking
    // scheme (First lock call, then lock adapter) exposing a potential deadlock in CallFindAndLock():
    //
    // - CallFindAndLock takes the Call lock then the Adapter lock.
    // - CallFindAndLock takes the adapter lock then calls CallAlloc which calls 
    //   setcallstate which takes the Call lock.
    //
    // Although this is a hypothetical scenario since the deadlock will never occur as the new
    // call context is not in the adapter's call array yet, but let's be consistent.
    //
    pCall->State = STATE_CALL_CLOSED;

    DEBUGMSG(DBG_FUNC|DBG_CALL, (DTEXT("-CallAlloc %08x\n"), pCall));
    return pCall;
}

VOID
CallpCleanup(
    IN PPPTP_WORK_ITEM pWorkItem
    )
{
    PCALL_SESSION pCall = pWorkItem->Context;
    BOOLEAN SignalLineDown = FALSE;
    BOOLEAN Cancelled;
    BOOLEAN FreeNow = FALSE;
    DEBUGMSG(DBG_FUNC|DBG_CALL, (DTEXT("+CallpCleanup %08x\n"), pCall));

    ASSERT(IS_CALL(pCall));
    NdisAcquireSpinLock(&pCall->Lock);
    // Signal CLEANUP state
    if (!(pCall->Close.Checklist&CALL_CLOSE_CLEANUP_STATE))
    {
        if (pCall->State!=STATE_CALL_CLEANUP)
        {
            CallSetState(pCall, STATE_CALL_CLEANUP, 0, LOCKED);
        }
        pCall->Close.Checklist |= CALL_CLOSE_CLEANUP_STATE;
    }
    if (REFERENCE_COUNT(pCall)>2)
    {
        DEBUGMSG(DBG_CALL, (DTEXT("CallpCleanup: too many references (%d)\n"), REFERENCE_COUNT(pCall)));
        goto ccDone;
    }
    
    if (pCall->Close.Expedited)
    {
        if ((pCall->Close.Checklist&CALL_CLOSE_DROP) &&
            !(pCall->Close.Checklist&CALL_CLOSE_DROP_COMPLETE))
        {
            pCall->Close.Checklist |= CALL_CLOSE_DROP_COMPLETE;
            DEBUGMSG(DBG_CALL, (DTEXT("TapiDrop Completed\n")));
            NdisReleaseSpinLock(&pCall->Lock);
            NdisMSetInformationComplete(pCall->pAdapter->hMiniportAdapter, NDIS_STATUS_SUCCESS);
            NdisAcquireSpinLock(&pCall->Lock);
        }
        if (!(pCall->Close.Checklist&CALL_CLOSE_DISCONNECT))
        {
            pCall->Close.Checklist |= CALL_CLOSE_DISCONNECT;
            if (pCall->pCtl)
            {
                NdisReleaseSpinLock(&pCall->Lock);
                CtlDisconnectCall(pCall);
                NdisAcquireSpinLock(&pCall->Lock);
            }
        }
        if (!(pCall->Close.Checklist&CALL_CLOSE_LINE_DOWN) &&
            (pCall->Close.Checklist&CALL_CLOSE_DROP_COMPLETE))
        {
            SignalLineDown = TRUE;
            pCall->Close.Checklist |= CALL_CLOSE_LINE_DOWN;
            NdisReleaseSpinLock(&pCall->Lock);
            TapiLineDown(pCall);
            NdisAcquireSpinLock(&pCall->Lock);
        }
    }
    else // !Expedited
    {
        if (!(pCall->Close.Checklist&CALL_CLOSE_DISCONNECT))
        {
            pCall->Close.Checklist |= CALL_CLOSE_DISCONNECT;
            if (pCall->pCtl)
            {
                NdisReleaseSpinLock(&pCall->Lock);
                CtlDisconnectCall(pCall);
                NdisAcquireSpinLock(&pCall->Lock);
            }
        }
        if (!(pCall->Close.Checklist&CALL_CLOSE_DROP))
        {
            goto ccDone;
        }
        if (!(pCall->Close.Checklist&CALL_CLOSE_DROP_COMPLETE))
        {
            pCall->Close.Checklist |= CALL_CLOSE_DROP_COMPLETE;
            DEBUGMSG(DBG_CALL, (DTEXT("TapiDrop Completed 2\n")));
            NdisReleaseSpinLock(&pCall->Lock);
            NdisMSetInformationComplete(pCall->pAdapter->hMiniportAdapter, NDIS_STATUS_SUCCESS);
            NdisAcquireSpinLock(&pCall->Lock);
        }
        if (!(pCall->Close.Checklist&CALL_CLOSE_LINE_DOWN) &&
            (pCall->Close.Checklist&CALL_CLOSE_DROP_COMPLETE))
        {
            DEBUGMSG(DBG_CALL, (DTEXT("Signalling Line Down 2\n")));
            pCall->Close.Checklist |= CALL_CLOSE_LINE_DOWN;
            NdisReleaseSpinLock(&pCall->Lock);
            TapiLineDown(pCall);
            NdisAcquireSpinLock(&pCall->Lock);
        }
    }

    if ((pCall->Close.Checklist&CALL_CLOSE_COMPLETE)!=CALL_CLOSE_COMPLETE)
    {
        goto ccDone;
    }

    NdisReleaseSpinLock(&pCall->Lock);
    NdisMCancelTimer(&pCall->DialTimer, &Cancelled);
    NdisMCancelTimer(&pCall->Close.Timer, &Cancelled);
    NdisMCancelTimer(&pCall->Ack.Timer, &Cancelled);
    NdisAcquireSpinLock(&pCall->Lock);
    if (Cancelled)
    {
        pCall->Ack.PacketQueued = FALSE;
    }

    pCall->Close.Expedited = FALSE;
    NdisZeroMemory(pCall->CallerId, sizeof(pCall->CallerId));
    NdisZeroMemory(&pCall->Remote, sizeof(pCall->Remote));
    pCall->Packet.SequenceNumber = pCall->Packet.AckNumber = 0;
    CallSetState(pCall, STATE_CALL_IDLE, 0, LOCKED);
    pCall->PendingUse = FALSE;
    DEBUGMSG(DBG_CALL, (DTEXT("Call:%08x Cleanup complete, state==%d\n"),
                        pCall, pCall->State));
    WPLOG(LL_M, LM_CALL, ("Cid %d Cleanup complete", (ULONG)pCall->DeviceId));
                        

#if 0  // Keep these structures and reuse the memory.  They will be cleaned up in AdapterFree()
    if (REFERENCE_COUNT(pCall)==1)
    {
        CallDetachFromAdapter(pCall);
        DEREFERENCE_OBJECT(pCall);  // For the initial reference.
        FreeNow = TRUE;
    }
#endif

ccDone:
    pCall->Close.Scheduled = FALSE;
    NdisReleaseSpinLock(&pCall->Lock);

    DEBUGMSG(DBG_FUNC, (DTEXT("-CallpCleanup Checklist:%08x\n"), pCall->Close.Checklist));

    if (FreeNow)
    {
        CallFree(pCall);
    }
}

VOID
CallCleanup(
    PCALL_SESSION pCall,
    BOOLEAN Locked
    )
{
    DEBUGMSG(DBG_FUNC, (DTEXT("+CallCleanup\n")));
    
    DBGTRACE('U');
    WPLOG(LL_I, LM_CALL, ("Cid %d", (ULONG)pCall->DeviceId));
    
    if (!Locked)
    {
        NdisAcquireSpinLock(&pCall->Lock);
    }
    ASSERT_LOCK_HELD(&pCall->Lock);
    if (!(pCall->Close.Scheduled))
    {
        if(ScheduleWorkItem(CallpCleanup, pCall, NULL, 0)==NDIS_STATUS_SUCCESS)
        {
            pCall->Close.Scheduled = TRUE;
        }
        else
        {
            DBGTRACE('w');
            WPLOG(LL_A, LM_CALL, ("Failed to schedule work item pCall %p, Cid %d", pCall, (ULONG)pCall->DeviceId));
            gCounters.ulCleanupWorkItemFail++;
        }
    }
    if (!Locked)
    {
        NdisReleaseSpinLock(&pCall->Lock);
    }

    DEBUGMSG(DBG_FUNC, (DTEXT("-CallCleanup\n")));
}

// Call lock must be held when calling this.
VOID
CallDetachFromAdapter(PCALL_SESSION pCall)
{
    DEBUGMSG(DBG_FUNC, (DTEXT("+CallDetachFromAdapter %08x\n"), pCall));
    NdisAcquireSpinLock(&pCall->pAdapter->Lock);
    pCall->pAdapter->pCallArray[pCall->DeviceId] = NULL;
    NdisReleaseSpinLock(&pCall->pAdapter->Lock);
    pCall->Open = FALSE;
    DEBUGMSG(DBG_FUNC, (DTEXT("-CallDetachFromAdapter\n")));
}

VOID
CallFree(PCALL_SESSION pCall)
{
    BOOLEAN NotUsed;
    if (!pCall)
    {
        return;
    }
    DEBUGMSG(DBG_FUNC|DBG_CALL, (DTEXT("+CallFree %p\n"), pCall));
    ASSERT(IS_CALL(pCall));

    // This duplicates some of the cleanup code, but attempting to stop
    // the driver without first stopping tapi can result in an ungraceful
    // shutdown.
    NdisMCancelTimer(&pCall->DialTimer, &NotUsed);
    NdisMCancelTimer(&pCall->Close.Timer, &NotUsed);
    NdisMCancelTimer(&pCall->Ack.Timer, &NotUsed);

    ASSERT(pCall->Signature==TAG_PPTP_CALL);
    ASSERT(IsListEmpty(&pCall->RxPacketList));
    ASSERT(IsListEmpty(&pCall->TxPacketList));
    NdisFreeSpinLock(&pCall->Lock);
    MyMemFree(pCall, sizeof(CALL_SESSION));

    DEBUGMSG(DBG_FUNC, (DTEXT("-CallFree\n")));
}

PCALL_SESSION FASTCALL
CallGetCall(
    IN PPPTP_ADAPTER pAdapter,
    IN ULONG_PTR ulDeviceId
    )
{
    PCALL_SESSION pCall = NULL;
    DEBUGMSG(DBG_FUNC, (DTEXT("+CallGetCall %d\n"), ulDeviceId));

    NdisAcquireSpinLock(&pAdapter->Lock);
    if (ulDeviceId >= PptpBaseCallId && ulDeviceId < PptpMaxCallId)
    {
        if(PptpCallIdMask)
        {
            if((ulDeviceId & PptpCallIdMask) < PptpWanEndpoints)
            {
                pCall = pAdapter->pCallArray[ulDeviceId & PptpCallIdMask];
                if(pCall && pCall->FullDeviceId != ulDeviceId)
                {
                    pCall = NULL;
                }
            }
        }
        else
        {
            pCall = pAdapter->pCallArray[ulDeviceId - PptpBaseCallId];
        }
    }
    NdisReleaseSpinLock(&pAdapter->Lock);

    DEBUGMSG(DBG_FUNC, (DTEXT("-CallGetCall %08x\n"), pCall));
    return pCall;
}



PCALL_SESSION
CallFindAndLock(
    IN PPPTP_ADAPTER        pAdapter,
    IN CALL_STATE           State,
    IN ULONG                Flags
    )
{
    PCALL_SESSION pCall = NULL;
    ULONG ulDeviceId;
    LONG i, loopcount;

    DEBUGMSG(DBG_FUNC, (DTEXT("+CallFindAndLock %d\n"), State));

    // Find a call that matches our state or create a call  
    NdisAcquireSpinLock(&pAdapter->Lock);
    
    if(PptpClientSide)
    {
        // Skip the random search, just go upward starting from 0
        loopcount = 1;
        ulDeviceId = -1;    // the first index is 0 as ++(-1)
    }
    else
    {
        // Try to find a call randomly first if it's a server
        loopcount = 0;
        i = 0;
        
        do 
        {
            ulDeviceId = CallGetRandomId();
            
            if (!pAdapter->pCallArray[ulDeviceId])
            {
                if (State==STATE_CALL_IDLE)
                {
                    pCall = CallAlloc(pAdapter);
                    if (pCall)
                    {
                        pAdapter->pCallArray[ulDeviceId] = pCall;
                        pCall->DeviceId = ulDeviceId;
                        CallSetFullCallId(pCall);
                        pCall->State = State;
                        pCall->PendingUse = TRUE;
                        break;
                    }
                }
            }
            else if (pAdapter->pCallArray[ulDeviceId]->State == State && 
                !pAdapter->pCallArray[ulDeviceId]->PendingUse)
            {
                pCall = pAdapter->pCallArray[ulDeviceId];
                pCall->PendingUse = TRUE;
                CallSetFullCallId(pCall);
                
                if(pCall->hTapiCall)
                {
                    gCounters.ulFindCallWithTapiHandle++;
                }
                
                DBGTRACE_INIT(pCall);
                
                break;
            }
        } while(++i < (LONG) PptpWanEndpoints / 2);
    }
    
    // Do sequential search for clint, and server if necessary
    // For client, just go upward
    // For server, starting with the current random id, go downward then upward
    while(!pCall && (loopcount < 2))
    {
        i = (LONG) ulDeviceId;
        
        while((loopcount == 0) ? (--i>=0) : (++i<(LONG)PptpWanEndpoints))
        {
            if(!pAdapter->pCallArray[i])
            {
                if(State==STATE_CALL_IDLE)
                {
                    pCall = CallAlloc(pAdapter);
                    if (pCall)
                    {
                        pAdapter->pCallArray[i] = pCall;
                        pCall->DeviceId = (ULONG)i;
                        CallSetFullCallId(pCall);
                        pCall->State = State;
                        pCall->PendingUse = TRUE;
                        break;
                    }
                }
            }
            else if(pAdapter->pCallArray[i]->State == State &&
                !pAdapter->pCallArray[i]->PendingUse)
            {
                pCall = pAdapter->pCallArray[i];
                pCall->PendingUse = TRUE;
                CallSetFullCallId(pCall);
                
                if(pCall->hTapiCall)
                {
                    gCounters.ulFindCallWithTapiHandle++;
                }
                
                DBGTRACE_INIT(pCall);
                
                break;
            }
        }
        
        loopcount++;
    }
    
    NdisReleaseSpinLock(&pAdapter->Lock);

    if (pCall)
    {
        NdisAcquireSpinLock( &pCall->Lock );
    }
    
    DEBUGMSG(DBG_FUNC, (DTEXT("-CallFindAndLock %08x\n"), pCall));
    return pCall;
}

NDIS_STATUS
CallEventCallClearRequest(
    PCALL_SESSION                       pCall,
    UNALIGNED PPTP_CALL_CLEAR_REQUEST_PACKET *pPacket,
    PCONTROL_TUNNEL pCtl
    )
{
    NDIS_STATUS Status = NDIS_STATUS_SUCCESS;
    PPPTP_CALL_DISCONNECT_NOTIFY_PACKET pReply;
    DEBUGMSG(DBG_FUNC|DBG_CALL, (DTEXT("+CallEventCallClearRequest\n")));

    pReply = CtlAllocPacket(pCall->pCtl, CALL_DISCONNECT_NOTIFY);
    // We don't really care if we fail this allocation because PPTP can clean up
    // along other avenues, and the cleanup just won't be as pretty.
    if (pReply)
    {
        pReply->CallId = htons(pCall->Packet.CallId);
        
        WPLOG(LL_M, LM_TUNNEL, ("SEND CALL_DISCONNECT_NOTIFY -> %!IPADDR!, pCall %p, Cid %d, Pkt-Cid %d", 
            pCtl->Remote.Address.Address[0].Address[0].in_addr,
            pCall, (ULONG)pCall->DeviceId, pCall->Packet.CallId));
        
        Status = CtlSend(pCtl, pReply);
    }
    CallCleanup(pCall, UNLOCKED);

    DEBUGMSG(DBG_FUNC|DBG_ERR(Status), (DTEXT("-CallEventCallClearRequest %08x\n"), Status));
    return Status;
}

NDIS_STATUS
CallEventCallDisconnectNotify(
    PCALL_SESSION                       pCall,
    UNALIGNED PPTP_CALL_DISCONNECT_NOTIFY_PACKET *pPacket
    )
{
    NDIS_STATUS Status = NDIS_STATUS_SUCCESS;
    DEBUGMSG(DBG_FUNC|DBG_CALL, (DTEXT("+CallEventCallDisconnectNotify\n")));

    if (IS_CALL(pCall))
    {
        CallCleanup(pCall, UNLOCKED);
    }

    DEBUGMSG(DBG_FUNC|DBG_ERR(Status), (DTEXT("-CallEventCallDisconnectNotify %08x\n"), Status));
    return Status;
}

NDIS_STATUS
CallEventCallInConnect(
    IN PCALL_SESSION        pCall,
    IN UNALIGNED PPTP_CALL_IN_CONNECT_PACKET *pPacket
    )
{
    DEBUGMSG(DBG_FUNC, (DTEXT("+CallEventCallInConnect\n")));

    ASSERT(IS_CALL(pCall));
    NdisAcquireSpinLock(&pCall->Lock);
    if (pCall->State==STATE_CALL_PAC_WAIT)
    {
        pCall->Speed = htonl(pPacket->ConnectSpeed);
        CallSetState(pCall, STATE_CALL_ESTABLISHED, htonl(pPacket->ConnectSpeed), LOCKED);
    }
    NdisReleaseSpinLock(&pCall->Lock);

    DEBUGMSG(DBG_FUNC, (DTEXT("-CallEventCallInConnect\n")));
    return NDIS_STATUS_SUCCESS;
}

NDIS_STATUS
CallEventCallInRequest(
    IN PPPTP_ADAPTER        pAdapter,
    IN PCONTROL_TUNNEL      pCtl,
    IN UNALIGNED PPTP_CALL_IN_REQUEST_PACKET *pPacket
    )
{
    NDIS_STATUS Status = NDIS_STATUS_SUCCESS;
    PCALL_SESSION pCall;

    DEBUGMSG(DBG_FUNC, (DTEXT("+CallEventCallInRequest\n")));

    pCall = CallFindAndLock(pAdapter, STATE_CALL_IDLE, FIND_INCOMING);

    if (pCall)
    {
        NDIS_TAPI_EVENT TapiEvent;

        // We have a call in idle state, spinlock acquired
        pCall->Inbound = TRUE;
        pCall->Remote.CallId = htons(pPacket->CallId);
        pCall->Remote.Address = pCtl->Remote.Address;
        pCall->Remote.Address.Address[0].Address[0].sin_port = htons(PptpProtocolNumber);
        pCall->SerialNumber = htons(pPacket->SerialNumber);

        pCall->Close.Checklist &= ~(CALL_CLOSE_DISCONNECT | CALL_CLOSE_CLOSE_CALL);
        CallConnectToCtl(pCall, pCtl, TRUE);

        NdisReleaseSpinLock(&pCall->Lock);

        pPacket->DialingNumber[MAX_PHONE_NUMBER_LENGTH-1] = '\0';
        strcpy(pCall->CallerId, pPacket->DialingNumber);

        TapiEvent.htLine = pAdapter->Tapi.hTapiLine;
        TapiEvent.htCall = 0;
        TapiEvent.ulMsg = LINE_NEWCALL;
        TapiEvent.ulParam1 = pCall->FullDeviceId;
        TapiEvent.ulParam2 = 0;
        TapiEvent.ulParam3 = 0;

        NdisMIndicateStatus(pCall->pAdapter->hMiniportAdapter,
                            NDIS_STATUS_TAPI_INDICATION,
                            &TapiEvent,
                            sizeof(TapiEvent));

        NdisAcquireSpinLock(&pCall->Lock);

        if(TapiEvent.ulParam2)
        {
            pCall->hTapiCall = TapiEvent.ulParam2;
            
            DEBUGMSG(DBG_CALL, (DTEXT("NEWCALL: Addr:%08x pCall %p Cid %d pCtl %p htCall %x\n"),
                pCall->Remote.Address.Address[0].Address[0].in_addr, 
                pCall, pCall->DeviceId, pCtl, TapiEvent.ulParam2));
                                
            WPLOG(LL_M, LM_CALL, ("NEWCALL: %!IPADDR! pCall %p Cid %d pCtl %p htCall %Ix", 
                pCall->Remote.Address.Address[0].Address[0].in_addr,
                pCall, (ULONG)pCall->DeviceId, pCtl, TapiEvent.ulParam2));
            
            CallSetState(pCall, STATE_CALL_PAC_OFFERING, 0, LOCKED);
            ASSERT(pCall->PendingUse);
            pCall->PendingUse = FALSE;
        }
        else
        {
            gCounters.ulNewCallNullTapiHandle++;
            pCall->Close.Checklist |= CALL_CLOSE_CLOSE_CALL;
            
            WPLOG(LL_A, LM_CALL, ("NEWCALL: %!IPADDR! pCall %p TapiEvent.ulParam2 == 0!",
                pCall->Remote.Address.Address[0].Address[0].in_addr, pCall));
                
            CallCleanup(pCall, LOCKED);
        }
        
        NdisReleaseSpinLock(&pCall->Lock);
    }
    else
    {
        PPTP_CALL_OUT_REPLY_PACKET *pReply = CtlAllocPacket(pCtl, CALL_IN_REPLY);

        if (pReply)
        {
            pReply->PeerCallId = pPacket->CallId;
            pReply->ResultCode = RESULT_CALL_IN_ERROR;
            pReply->ErrorCode = PPTP_STATUS_INSUFFICIENT_RESOURCES;

            WPLOG(LL_M, LM_TUNNEL, ("SEND CALL_OUT_REPLY (INSUFFICIENT_RESOURCES) -> %!IPADDR! pCtl %p", 
                pCtl->Remote.Address.Address[0].Address[0].in_addr, pCtl));
                                                                  
            // No call was available.  Send a rejection.
            Status = CtlSend(pCtl, pReply);
        }

    }
    DEBUGMSG(DBG_FUNC|DBG_ERR(Status), (DTEXT("-CallEventCallInRequest %08x\n"), Status));
    return Status;
}


NDIS_STATUS
CallEventCallOutRequest(
    IN PPPTP_ADAPTER        pAdapter,
    IN PCONTROL_TUNNEL      pCtl,
    IN UNALIGNED PPTP_CALL_OUT_REQUEST_PACKET *pPacket
    )
{
    NDIS_STATUS Status = NDIS_STATUS_SUCCESS;
    PCALL_SESSION pCall;

    DEBUGMSG(DBG_FUNC|DBG_CALL, (DTEXT("+CallEventCallOutRequest\n")));

    pCall = CallFindAndLock(pAdapter, STATE_CALL_IDLE, FIND_INCOMING);

    if (pCall)
    {
        NDIS_TAPI_EVENT TapiEvent;

        // We have a call in idle state, spinlock acquired
        pCall->Inbound = TRUE;
        pCall->Remote.CallId = htons(pPacket->CallId);
        pCall->Remote.Address = pCtl->Remote.Address;
        pCall->Remote.Address.Address[0].Address[0].sin_port = htons(PptpProtocolNumber);
        pCall->SerialNumber = htons(pPacket->SerialNumber);

        IpAddressToString(htonl(pCtl->Remote.Address.Address[0].Address[0].in_addr), pCall->CallerId);

        pCall->Close.Checklist &= ~(CALL_CLOSE_DISCONNECT | CALL_CLOSE_CLOSE_CALL);
        CallConnectToCtl(pCall, pCtl, TRUE);
        NdisReleaseSpinLock(&pCall->Lock);

        TapiEvent.htLine = pAdapter->Tapi.hTapiLine;
        TapiEvent.htCall = 0;
        TapiEvent.ulMsg = LINE_NEWCALL;
        TapiEvent.ulParam1 = pCall->FullDeviceId;
        TapiEvent.ulParam2 = 0;
        TapiEvent.ulParam3 = 0;

        NdisMIndicateStatus(pCall->pAdapter->hMiniportAdapter,
                            NDIS_STATUS_TAPI_INDICATION,
                            &TapiEvent,
                            sizeof(TapiEvent));

        NdisAcquireSpinLock(&pCall->Lock);
        
        if(TapiEvent.ulParam2)
        {
            pCall->hTapiCall = TapiEvent.ulParam2;
            
            DEBUGMSG(DBG_CALL, (DTEXT("NEWCALL: Addr:%08x pCall %p Cid %d pCtl %p htCall %x\n"),
                pCall->Remote.Address.Address[0].Address[0].in_addr, 
                pCall, pCall->DeviceId, pCtl, TapiEvent.ulParam2));
                                
            WPLOG(LL_M, LM_CALL, ("NEWCALL: %!IPADDR! pCall %p Cid %d pCtl %p hdCall %d htCall %Ix", 
                pCall->Remote.Address.Address[0].Address[0].in_addr,
                pCall, (ULONG)pCall->DeviceId, pCtl, (ULONG)TapiEvent.ulParam1, TapiEvent.ulParam2));
            
            CallSetState(pCall, STATE_CALL_OFFERING, 0, LOCKED);
            ASSERT(pCall->PendingUse);
            pCall->PendingUse = FALSE;
        }
        else
        {
            gCounters.ulNewCallNullTapiHandle++;
            pCall->Close.Checklist |= CALL_CLOSE_CLOSE_CALL;
            
            WPLOG(LL_A, LM_CALL, ("NEWCALL: %!IPADDR! pCall %p TapiEvent.ulParam2 == 0!",
                pCall->Remote.Address.Address[0].Address[0].in_addr, pCall));
            
            CallCleanup(pCall, LOCKED);
        }
        
        NdisReleaseSpinLock(&pCall->Lock);
    }
    else
    {
        PPTP_CALL_OUT_REPLY_PACKET *pReply = CtlAllocPacket(pCtl, CALL_OUT_REPLY);

        if (pReply)
        {
            pReply->PeerCallId = pPacket->CallId;
            pReply->ResultCode = RESULT_CALL_OUT_ERROR;
            pReply->ErrorCode = PPTP_STATUS_INSUFFICIENT_RESOURCES;

            WPLOG(LL_M, LM_TUNNEL, ("SEND CALL_OUT_REPLY (INSUFFICIENT_RESOURCES) -> %!IPADDR! pCtl %p", 
                pCtl->Remote.Address.Address[0].Address[0].in_addr, pCtl));
            
            // No call was available.  Send a rejection.
            Status = CtlSend(pCtl, pReply);
        }
    }

    DEBUGMSG(DBG_FUNC|DBG_ERR(Status), (DTEXT("-CallEventCallOutRequest %08x\n"), Status));
    return Status;
}

NDIS_STATUS
CallEventCallOutReply(
    IN PCALL_SESSION                pCall,
    IN UNALIGNED PPTP_CALL_OUT_REPLY_PACKET *pPacket
    )
{
    NDIS_STATUS Status = NDIS_STATUS_SUCCESS;

    DEBUGMSG(DBG_FUNC|DBG_CALL, (DTEXT("+CallEventCallOutReply\n")));

    ASSERT(IS_CALL(pCall));
    NdisAcquireSpinLock(&pCall->Lock);
    
    if (pPacket->ResultCode != RESULT_CALL_OUT_CONNECTED ||
        pCall->State != STATE_CALL_PROCEEDING ||
        pCall->Packet.CallId != htons(pPacket->PeerCallId))
    {
        // The call fails for some reason.
        Status = NDIS_STATUS_FAILURE;
        
        WPLOG(LL_A, LM_CALL, ("pCall %p Cid %d not CONNECTED. Clean up the call",
            pCall, (ULONG)pCall->DeviceId));
        CallCleanup(pCall, LOCKED);
    }
    else
    {
        pCall->Remote.CallId = htons(pPacket->CallId);
        pCall->Speed = pCall->pCtl->Speed;
        CallSetState(pCall, STATE_CALL_ESTABLISHED, htonl(pPacket->ConnectSpeed), LOCKED);
        
        WPLOG(LL_M, LM_CALL, ("%!IPADDR! pCall %p Cid %d Peer's Cid %d UP",
            pCall->Remote.Address.Address[0].Address[0].in_addr,
            pCall, (ULONG)pCall->DeviceId, pCall->Remote.CallId));
    }
    
    NdisReleaseSpinLock(&pCall->Lock);

    DEBUGMSG(DBG_FUNC, (DTEXT("-CallEventCallOutReply\n")));
    return Status;
}

NDIS_STATUS
CallEventDisconnect(
    PCALL_SESSION                       pCall
    )
{
    NDIS_STATUS Status = NDIS_STATUS_SUCCESS;
    DEBUGMSG(DBG_FUNC|DBG_CALL, (DTEXT("+CallEventDisconnect %08x\n"), pCall));

    ASSERT(IS_CALL(pCall));
    CallCleanup(pCall, UNLOCKED);

    DEBUGMSG(DBG_FUNC|DBG_ERR(Status), (DTEXT("-CallEventDisconnect %08x\n"), Status));
    return Status;
}

NDIS_STATUS
CallEventConnectFailure(
    PCALL_SESSION                       pCall,
    NDIS_STATUS                         FailureReason
    )
{
    NDIS_STATUS Status = NDIS_STATUS_SUCCESS;
    ULONG DisconnectMode;
    DEBUGMSG(DBG_FUNC|DBG_CALL, (DTEXT("+CallEventConnectFailure %08x\n"), FailureReason));

    ASSERT(IS_CALL(pCall));

    switch (FailureReason)
    {
        case STATUS_CONNECTION_REFUSED:
        case STATUS_IO_TIMEOUT:
            DisconnectMode = LINEDISCONNECTMODE_NOANSWER;
            break;
        case STATUS_BAD_NETWORK_PATH:
        case STATUS_NETWORK_UNREACHABLE:
        case STATUS_HOST_UNREACHABLE:
            DisconnectMode = LINEDISCONNECTMODE_UNREACHABLE;
            break;
        case STATUS_CONNECTION_ABORTED:
            DisconnectMode = LINEDISCONNECTMODE_REJECT;
            break;
        case STATUS_REMOTE_NOT_LISTENING:
            DisconnectMode = LINEDISCONNECTMODE_BADADDRESS;
            break;
        default:
            DisconnectMode = LINEDISCONNECTMODE_UNKNOWN;
            break;
    }
    CallSetState(pCall, STATE_CALL_CLEANUP, DisconnectMode, UNLOCKED);
    CallCleanup(pCall, UNLOCKED);

    DEBUGMSG(DBG_FUNC, (DTEXT("-CallEventConnectFailure\n")));
    return Status;
}

NDIS_STATUS
CallEventOutboundTunnelEstablished(
    IN PCALL_SESSION        pCall,
    IN NDIS_STATUS          EventStatus
    )
{
    NDIS_STATUS Status = NDIS_STATUS_SUCCESS;
    
    DEBUGMSG(DBG_FUNC|DBG_CALL, (DTEXT("+CallEventOutboundTunnelEstablished %08x\n"), EventStatus));

    ASSERT(IS_CALL(pCall));
    DEBUGMSG(DBG_CALL, (DTEXT("Tunnel UP Inbound:%d\n"), pCall->Inbound));
                        
    WPLOG(LL_M, LM_TUNNEL, ("%!IPADDR! Tunnel UP Inbound:%d",
        pCall->Remote.Address.Address[0].Address[0].in_addr, pCall->Inbound));  
                    
    if (!pCall->Inbound && pCall->State==STATE_CALL_DIALING)
    {
        PPTP_CALL_OUT_REQUEST_PACKET *pPacket = CtlAllocPacket(pCall->pCtl, CALL_OUT_REQUEST);

        if (!pPacket)
        {
            // Fatal for this call.
            Status = NDIS_STATUS_RESOURCES;
            
            DEBUGMSG(DBG_WARN, (DTEXT("CallEventOutboundTunnelEstablished: Failed to alloc CALL_OUT_REQUEST Cid %d\n"), pCall->DeviceId));
            WPLOG(LL_A, LM_TAPI, ("Failed to alloc CALL_OUT_REQUEST Cid %d", (ULONG)pCall->DeviceId));
            
            CallCleanup(pCall, UNLOCKED);
        }
        else
        {
            BOOLEAN Cancelled;
            USHORT NewCallId;
            NdisAcquireSpinLock(&pCall->Lock);
            CallSetState(pCall, STATE_CALL_PROCEEDING, 0, LOCKED);
            NdisMCancelTimer(&pCall->DialTimer, &Cancelled);

            CallAssignSerialNumber(pCall);
            if(PptpClientSide)
            {
                NewCallId = (USHORT)((pCall->SerialNumber << CALL_ID_INDEX_BITS) + pCall->DeviceId);
                if (pCall->Packet.CallId == NewCallId)
                {
                    // Don't allow a line to have the same CallId twice in a row.
                    NewCallId += (1<<CALL_ID_INDEX_BITS);
                }
            }
            else
            {
                NewCallId = (USHORT)pCall->FullDeviceId;
            }
            
            pCall->Packet.CallId = NewCallId;

            // Our call ID is a function of the serial number (initially random)
            // and the DeviceId.  This is so we can (CallId&0xfff) on incoming packets
            // and instantly have the proper id.

            pPacket->CallId = htons(pCall->Packet.CallId);
            pPacket->SerialNumber = htons(pCall->SerialNumber);
            pPacket->MinimumBPS = htonl(300);
            pPacket->MaximumBPS = htonl(100000000);
            pPacket->BearerType = htonl(BEARER_ANALOG|BEARER_DIGITAL);  // Either
            pPacket->FramingType = htonl(FRAMING_ASYNC|FRAMING_SYNC);  // Either
            pPacket->RecvWindowSize = htons(PPTP_RECV_WINDOW); // ToDo: make configurable
            pPacket->ProcessingDelay = 0;
            pPacket->PhoneNumberLength = htons((USHORT)strlen(pCall->CallerId));
            strcpy(pPacket->PhoneNumber, pCall->CallerId);
            // ToDo: subaddress

            NdisReleaseSpinLock(&pCall->Lock);

            WPLOG(LL_M, LM_TUNNEL, ("SEND CALL_OUT_REQUEST -> %!IPADDR! Cid %d, Pkt-Cid %d", 
                pCall->Remote.Address.Address[0].Address[0].in_addr, (ULONG)pCall->DeviceId, pCall->Packet.CallId));
            
            Status = CtlSend(pCall->pCtl, pPacket);
            if(Status != NDIS_STATUS_PENDING && Status != NDIS_STATUS_SUCCESS)
            {
                CallCleanup(pCall, UNLOCKED);
            }
        }
    }

    DEBUGMSG(DBG_FUNC, (DTEXT("-CallEventOutboundTunnelEstablished\n")));
    return Status;
}



NDIS_STATUS
CallReceiveDatagramCallback(
    IN      PVOID                       pContext,
    IN      PTRANSPORT_ADDRESS          pAddress,
    IN      PUCHAR                      pBuffer,
    IN      ULONG                       ulLength
    )
{
    PPPTP_ADAPTER pAdapter = (PPPTP_ADAPTER)pContext;
    PTA_IP_ADDRESS pIpAddress = (PTA_IP_ADDRESS)pAddress;
    PCALL_SESSION pCall = NULL;
    NDIS_STATUS Status = NDIS_STATUS_SUCCESS;
    PIP4_HEADER pIp = (PIP4_HEADER)pBuffer;
    PGRE_HEADER pGre = (PGRE_HEADER)(pIp + 1);
    PVOID pPayload;
    LONG GreLength, PayloadLength;
    BOOLEAN ReturnBufferNow = TRUE;
    PDGRAM_CONTEXT pDgContext = ALIGN_UP_POINTER(pBuffer+ulLength, ULONG_PTR);

    DEBUGMSG(DBG_FUNC, (DTEXT("+CallReceiveDatagramCallback\n")));

    ASSERT(sizeof(IP4_HEADER)==20);

    DEBUGMEM(DBG_PACKET, pBuffer, ulLength, 1);

    NdisInterlockedIncrement(&gCounters.PacketsReceived);
    // First line of defense against bad packets.

    if (pIp->iph_verlen != IP_VERSION + (sizeof(IP4_HEADER) >> 2) ||
        pIp->iph_protocol!=PptpProtocolNumber ||
        ulLength<sizeof(IP4_HEADER)+sizeof(GRE_HEADER)+sizeof(ULONG) ||
        pIpAddress->TAAddressCount!=1 ||
        pIpAddress->Address[0].AddressLength!=TDI_ADDRESS_LENGTH_IP ||
        pIpAddress->Address[0].AddressType!=TDI_ADDRESS_TYPE_IP)
    {
        DEBUGMSG(DBG_PACKET|DBG_RX, (DTEXT("Rx: IP header invalid\n")));
        Status = NDIS_STATUS_FAILURE;
        goto crdcDone;
    }

    GreLength = sizeof(GRE_HEADER) +
                (pGre->SequenceNumberPresent ? sizeof(ULONG) : 0) +
                (pGre->AckSequenceNumberPresent ? sizeof(ULONG) : 0);

    pPayload = (PUCHAR)pGre + GreLength;
    PayloadLength = (signed)ulLength - sizeof(IP4_HEADER) - GreLength;

    if (ulLength < sizeof(IP4_HEADER) + GreLength ||
        htons(pGre->KeyLength)>PayloadLength ||
        pGre->StrictSourceRoutePresent ||
        pGre->RecursionControl ||
        !pGre->KeyPresent ||
        pGre->RoutingPresent ||
        pGre->ChecksumPresent ||
        pGre->Version!=1 ||
        pGre->Flags ||
        pGre->ProtocolType!=GRE_PROTOCOL_TYPE_NS)
    {
        DEBUGMSG(DBG_PACKET|DBG_RX, (DTEXT("Rx: GRE header invalid\n")));
        DEBUGMEM(DBG_PACKET, pGre, GreLength, 1);
        Status = NDIS_STATUS_FAILURE;
        goto crdcDone;
    }
    else
    {
        // Just in case the datagram is longer than necessary, take only what
        // the GRE header indicates.
        PayloadLength = htons(pGre->KeyLength);
    }

    // Demultiplex the packet
    pCall = CallGetCall(pAdapter, CallIdToDeviceId(htons(pGre->KeyCallId)));

    if (!IS_CALL(pCall))
    {
        Status = NDIS_STATUS_FAILURE;
        goto crdcDone;
    }
    
    if(!PptpValidateAddress || pIpAddress->Address[0].Address[0].in_addr == pCall->Remote.Address.Address[0].Address[0].in_addr)
    {
        pDgContext->pBuffer = pBuffer;
        pDgContext->pGreHeader = pGre;
        pDgContext->hCtdi = pAdapter->hCtdiDg;
    
        if (CallQueueReceivePacket(pCall, pDgContext)==NDIS_STATUS_SUCCESS)
        {
            REFERENCE_OBJECT(pCall);
            ReturnBufferNow = FALSE;
        }
    }
    else
    {
        Status = NDIS_STATUS_FAILURE;
    }

crdcDone:
    if (ReturnBufferNow)
    {
        (void)
        CtdiReceiveComplete(pAdapter->hCtdiDg, pBuffer);
    }
    if (Status!=NDIS_STATUS_SUCCESS)
    {
        NdisInterlockedIncrement(&gCounters.PacketsRejected);
    }

#if 0
    else
    {
        CallProcessRxPackets(pCall);
    }
#endif

    DEBUGMSG(DBG_FUNC|DBG_ERR(Status), (DTEXT("-CallReceiveDatagramCallback %08x\n"), Status));
    return Status;
}


BOOLEAN
CallConnectToCtl(
    IN PCALL_SESSION pCall,
    IN PCONTROL_TUNNEL pCtl,
    IN BOOLEAN CallLocked
    )
{
    BOOLEAN Connected = FALSE;
    DEBUGMSG(DBG_FUNC, (DTEXT("+CallConnectCtl\n")));
    if (!CallLocked)
    {
        NdisAcquireSpinLock(&pCall->Lock);
    }
    ASSERT_LOCK_HELD(&pCall->Lock);
    NdisAcquireSpinLock(&pCall->pAdapter->Lock);
    if (!pCall->pCtl)
    {
        pCall->pCtl = pCtl;
        InsertTailList(&pCtl->CallList, &pCall->ListEntry);
        Connected = TRUE;
        REFERENCE_OBJECT_EX(pCtl, CTL_REF_CALLCONNECT); // Pair in CallDisconnectFromCtl
    }
    NdisReleaseSpinLock(&pCall->pAdapter->Lock);
    if (!CallLocked)
    {
        NdisReleaseSpinLock(&pCall->Lock);
    }
    DEBUGMSG(DBG_FUNC, (DTEXT("-CallConnectCtl %d\n"), Connected));
    return Connected;
}

VOID
CallDisconnectFromCtl(
    IN PCALL_SESSION pCall,
    IN PCONTROL_TUNNEL pCtl
    )
{
    BOOLEAN Deref = FALSE;
    DEBUGMSG(DBG_FUNC, (DTEXT("+CallDisconnectFromCtl\n")));
    NdisAcquireSpinLock(&pCall->Lock);
    NdisAcquireSpinLock(&pCall->pAdapter->Lock);
    ASSERT(pCall->pCtl==pCtl);
    if (pCall->pCtl==pCtl)
    {
        pCall->pCtl = NULL;
        RemoveEntryList(&pCall->ListEntry);
        Deref = TRUE;
    }
    NdisReleaseSpinLock(&pCall->pAdapter->Lock);
    NdisReleaseSpinLock(&pCall->Lock);
    if (Deref)
    {
        DEREFERENCE_OBJECT_EX(pCtl, CTL_REF_CALLCONNECT);
    }
    DEBUGMSG(DBG_FUNC, (DTEXT("-CallDisconnectFromCtl\n")));
}


NDIS_STATUS
CallSetLinkInfo(
    PPPTP_ADAPTER pAdapter,
    IN PNDIS_WAN_SET_LINK_INFO pRequest
    )
{
    PCALL_SESSION pCall;
    PCONTROL_TUNNEL pCtl;
    NDIS_STATUS Status = NDIS_STATUS_SUCCESS;
    PPPTP_SET_LINK_INFO_PACKET pPacket;

    DEBUGMSG(DBG_FUNC, (DTEXT("+CallSetLinkInfo\n")));

    // Verify the ID
    pCall = CallGetCall(pAdapter, LinkHandleToId(pRequest->NdisLinkHandle));

    if (!pCall)
    {
        Status = NDIS_STATUS_FAILURE;
        goto csliDone;
    }

    ASSERT(IS_CALL(pCall));
    NdisAcquireSpinLock(&pCall->Lock);
    pCall->WanLinkInfo = *pRequest;
#if 0
    DBG_X(DBG_NDIS, pCall->WanLinkInfo.MaxSendFrameSize);
    DBG_X(DBG_NDIS, pCall->WanLinkInfo.MaxRecvFrameSize);
    DBG_X(DBG_NDIS, pCall->WanLinkInfo.HeaderPadding);
    DBG_X(DBG_NDIS, pCall->WanLinkInfo.TailPadding);
    DBG_X(DBG_NDIS, pCall->WanLinkInfo.SendACCM);
    DBG_X(DBG_NDIS, pCall->WanLinkInfo.RecvACCM);
#endif

    pCtl = pCall->pCtl;
    NdisReleaseSpinLock(&pCall->Lock);

    // Report the new ACCMs to the peer.
    pPacket = CtlAllocPacket(pCtl, SET_LINK_INFO);
    if (!pPacket)
    {
        Status = NDIS_STATUS_RESOURCES;
    }
    else
    {
        pPacket->PeerCallId = ntohs(pCall->Remote.CallId);
        pPacket->SendAccm = ntohl(pCall->WanLinkInfo.SendACCM);
        pPacket->RecvAccm = ntohl(pCall->WanLinkInfo.RecvACCM);
        
        WPLOG(LL_M, LM_TUNNEL, ("SEND SET_LINK_INFO -> %!IPADDR!", 
            pCtl->Remote.Address.Address[0].Address[0].in_addr));
        
        Status = CtlSend(pCtl, pPacket);
    }

csliDone:
    DEBUGMSG(DBG_FUNC|DBG_ERR(Status), (DTEXT("-CallSetLinkInfo %08x\n"), Status));
    return Status;
}

VOID
CallSetState(
    IN PCALL_SESSION pCall,
    IN CALL_STATE State,
    IN ULONG_PTR StateParam,
    IN BOOLEAN Locked
    )
{
    ULONG OldLineCallState = CallGetLineCallState(pCall->State);
    ULONG NewLineCallState = CallGetLineCallState(State);

    DEBUGMSG(DBG_FUNC, (DTEXT("+CallSetState %d\n"), State));
    
    if (State!=pCall->State)
    {
        DBGTRACE(State);
        WPLOG(LL_M, LM_CALL, ("Cid %d State %s --> %s",
            (ULONG)pCall->DeviceId, szCallState(pCall->State), szCallState(State)));
    }
    ASSERT(IS_CALL(pCall));
    if (!Locked)
    {
        NdisAcquireSpinLock(&pCall->Lock);
    }
    ASSERT_LOCK_HELD(&pCall->Lock);
    pCall->State = State;
    if (!Locked)
    {
        NdisReleaseSpinLock(&pCall->Lock);
    }
    if (OldLineCallState!=NewLineCallState &&
        pCall->hTapiCall)
    {
        NDIS_TAPI_EVENT TapiEvent;

        DEBUGMSG(DBG_TAPI|DBG_NDIS, (DTEXT("PPTP: Indicating new LINE_CALLSTATE %x\n"), NewLineCallState));

        TapiEvent.htLine = pCall->pAdapter->Tapi.hTapiLine;
        TapiEvent.htCall = pCall->hTapiCall;
        TapiEvent.ulMsg = LINE_CALLSTATE;
        TapiEvent.ulParam1 = NewLineCallState;
        TapiEvent.ulParam2 = StateParam;
        TapiEvent.ulParam3 = LINEMEDIAMODE_DIGITALDATA;  // ToDo: is this required?

        if (Locked)
        {
            NdisReleaseSpinLock(&pCall->Lock);
        }
        NdisMIndicateStatus(pCall->pAdapter->hMiniportAdapter,
                            NDIS_STATUS_TAPI_INDICATION,
                            &TapiEvent,
                            sizeof(TapiEvent));
        if (Locked)
        {
            NdisAcquireSpinLock(&pCall->Lock);
        }

    }
    DEBUGMSG(DBG_FUNC, (DTEXT("-CallSetState\n")));
}

GRE_HEADER DefaultGreHeader = {
    0,                          // Recursion control
    0,                          // Strict source route present
    0,                          // Sequence Number present
    1,                          // Key present
    0,                          // Routing present
    0,                          // Checksum present
    1,                          // Version
    0,                          // Flags
    0,                          // Ack present
    GRE_PROTOCOL_TYPE_NS
};

VOID
CallpSendCompleteDeferred(
    IN PPPTP_WORK_ITEM pWorkItem
    )
{
    PCALL_SESSION pCall = pWorkItem->Context;
    PNDIS_WAN_PACKET pPacket = pWorkItem->pBuffer;
    NDIS_STATUS Result = pWorkItem->Length;

    DEBUGMSG(DBG_FUNC, (DTEXT("+CallpSendCompleteDeferred\n")));

    NdisMWanSendComplete(pCall->pAdapter->hMiniportAdapter,
                         pPacket,
                         Result);
    DEREFERENCE_OBJECT(pCall);
    NdisInterlockedIncrement(&gCounters.PacketsSentComplete);
    DEBUGMSG(DBG_FUNC, (DTEXT("-CallpSendCompleteDeferred\n")));
}

VOID
CallpSendComplete(
    IN      PVOID                       pContext,
    IN      PVOID                       pDatagramContext,
    IN      PUCHAR                      pBuffer,
    IN      NDIS_STATUS                 Result
    )
{
    PCALL_SESSION pCall = pContext;
    PNDIS_WAN_PACKET pPacket = pDatagramContext;

    DEBUGMSG(DBG_FUNC|DBG_TX, (DTEXT("+CallpSendComplete pCall=%x, pPacket=%x, Result=%x\n"), pCall, pPacket, Result));

    ASSERT(IS_CALL(pCall));
    if (Result!=NDIS_STATUS_SUCCESS)
    {
        DEBUGMSG(DBG_ERROR, (DTEXT("Failed to send datagram %08x\n"), Result));
        WPLOG(LL_A, LM_CALL, ("Failed to send datagram %08x", Result));
        NdisInterlockedIncrement(&gCounters.PacketsSentError);
    }

    if (pPacket==&pCall->Ack.Packet)
    {
        NdisAcquireSpinLock(&pCall->Lock);
        pCall->Ack.PacketQueued = FALSE;
        NdisReleaseSpinLock(&pCall->Lock);

        NdisInterlockedIncrement(&gCounters.PacketsSentComplete);
    }
    else
    {
        // When we complet packets immediately, we can get into trouble if a
        // packet has recursed.  We need a way to short-circuit a recursing
        // completion so we don't blow the stack.
        // We store a count of times we've completed a packet in the same
        // context and defer to a thread after a certain number of trips through.

        if ((NdisInterlockedIncrement(&pCall->SendCompleteRecursion)<PptpSendRecursionLimit) ||
            ScheduleWorkItem(CallpSendCompleteDeferred, pCall, pPacket, Result)!=NDIS_STATUS_SUCCESS)
        {
            NdisMWanSendComplete(pCall->pAdapter->hMiniportAdapter,
                                 pPacket,
                                 Result);
            DEREFERENCE_OBJECT(pCall);
            NdisInterlockedIncrement(&gCounters.PacketsSentComplete);
        }
        NdisInterlockedDecrement(&pCall->SendCompleteRecursion);
    }

    DEBUGMSG(DBG_FUNC, (DTEXT("-CallpSendComplete\n")));
}

#define TRANSMIT_SEND_SEQ 1
#define TRANSMIT_SEND_ACK 2
#define TRANSMIT_MASK 0x3

ULONG GreSize[4] = {
    sizeof(GRE_HEADER),
    sizeof(GRE_HEADER) + sizeof(ULONG),
    sizeof(GRE_HEADER) + sizeof(ULONG),
    sizeof(GRE_HEADER) + sizeof(ULONG) * 2
};

NDIS_STATUS
CallTransmitPacket(
    PCALL_SESSION       pCall,
    PNDIS_WAN_PACKET    pPacket,
    ULONG               Flags,
    ULONG               SequenceNumber,
    ULONG               Ack
    )
{
    NDIS_STATUS Status = NDIS_STATUS_FAILURE;
    ULONG Length;
    PULONG pSequence, pAck;
    PGRE_HEADER pGreHeader;
    PIP4_HEADER pIp;
    DEBUGMSG(DBG_FUNC, (DTEXT("+CallTransmitPacket\n")));

    if (!IS_CALL(pCall) || pCall->State!=STATE_CALL_ESTABLISHED)
    {
        goto ctpDone;
    }
    
    Length = GreSize[Flags&TRANSMIT_MASK];
    pGreHeader = (PGRE_HEADER) (pPacket->CurrentBuffer - Length);
    pSequence = pAck = (PULONG)(pGreHeader + 1);

    *pGreHeader = DefaultGreHeader;

    if (Flags&TRANSMIT_SEND_SEQ)
    {
        pGreHeader->SequenceNumberPresent = 1;
        *pSequence = htonl(SequenceNumber);
        pAck++;
    }
    pGreHeader->KeyLength = htons((USHORT)pPacket->CurrentLength);
    pGreHeader->KeyCallId = htons(pCall->Remote.CallId);
    if (Flags&TRANSMIT_SEND_ACK)
    {
        pGreHeader->AckSequenceNumberPresent = 1;
        *pAck = htonl(Ack);
    }
    
    pIp = (IP4_HEADER *) ((PUCHAR)pGreHeader - sizeof(IP4_HEADER));
    Length += sizeof(IP4_HEADER);
    
    pIp->iph_verlen = IP_VERSION + (sizeof(IP4_HEADER) >> 2);
    pIp->iph_tos=0;
    pIp->iph_length=htons((USHORT)(pPacket->CurrentLength + Length));
    pIp->iph_id=0;          // filled by TCPIP
    pIp->iph_offset=0;
    pIp->iph_ttl=128;
    pIp->iph_protocol=47;
    pIp->iph_xsum = 0;      // filled by TCPIP
    pIp->iph_src = pCall->pCtl->LocalAddress;
    pIp->iph_dest = pCall->Remote.Address.Address[0].Address[0].in_addr;
    
    NdisInterlockedIncrement(&gCounters.PacketsSent);

    Status = CtdiSendDatagram(pCall->pAdapter->hCtdiDg,
                              CallpSendComplete,
                              pCall,
                              pPacket,
                              (PTRANSPORT_ADDRESS)&pCall->Remote.Address,
                              (PVOID)pIp,
                              pPacket->CurrentLength + Length);


ctpDone:
    DEBUGMSG(DBG_FUNC|DBG_ERR(Status), (DTEXT("-CallTransmitPacket %08x\n"), Status));
    return Status;
}

VOID
CallProcessRxPackets(
    PNDIS_WORK_ITEM pNdisWorkItem,
    PCALL_SESSION   pCall
    )
{

#if 0
VOID
CallProcessRxPackets(
    IN PVOID SystemSpecific1,
    IN PVOID Context,
    IN PVOID SystemSpecific2,
    IN PVOID SystemSpecific3
    )
{
    PCALL_SESSION pCall = Context;
#endif 

    ULONG_PTR ReceiveMax = 50;
    NDIS_STATUS Status;

    DEBUGMSG(DBG_FUNC, (DTEXT("+CallProcessRxPackets\n")));

    ASSERT(IS_CALL(pCall));

    //++ProcCountRx[KeGetCurrentProcessorNumber()];

    NdisAcquireSpinLock(&pCall->Lock);

    // First send up any received packets.
    while (ReceiveMax-- && !IsListEmpty(&pCall->RxPacketList))
    {
        PDGRAM_CONTEXT pDgram;
        PLIST_ENTRY pListEntry = RemoveHeadList(&pCall->RxPacketList);
        pCall->RxPacketsPending--;
        pDgram = CONTAINING_RECORD(pListEntry,
                                   DGRAM_CONTEXT,
                                   ListEntry);
        if (pCall->State==STATE_CALL_ESTABLISHED &&
            htons(pDgram->pGreHeader->KeyCallId)==pCall->Packet.CallId &&
            IS_LINE_UP(pCall))
        {
            LONG GreLength, PayloadLength;
            PVOID pPayload;
            BOOLEAN SetAckTimer = FALSE;
            ULONG Sequence;

            NdisReleaseSpinLock(&pCall->Lock);

            if (pDgram->pGreHeader->SequenceNumberPresent)
            {
                // Call is still in good state, indicate the packet.
                Sequence = htonl(GreSequence(pDgram->pGreHeader));

                pCall->Remote.SequenceNumber = Sequence + 1;

                NdisAcquireSpinLock(&pCall->Lock);
                if (IsListEmpty(&pCall->TxPacketList) && !pCall->Ack.PacketQueued && pDgram->pGreHeader->KeyLength)
                {
                    // We only ack if there aren't already other transmits sent, and this
                    // isn't an ack-only packet.
                    SetAckTimer = pCall->Ack.PacketQueued = TRUE;
                }
                NdisReleaseSpinLock(&pCall->Lock);
            }

            if (!PptpEchoAlways)
            {
                pCall->pCtl->Echo.Needed = FALSE;
            }

            if (SetAckTimer)
            {
                NdisMSetTimer(&pCall->Ack.Timer, 100);
            }
            GreLength = sizeof(GRE_HEADER) +
                        (pDgram->pGreHeader->SequenceNumberPresent ? sizeof(ULONG) : 0) +
                        (pDgram->pGreHeader->AckSequenceNumberPresent ? sizeof(ULONG) : 0);

            pPayload = (PUCHAR)pDgram->pGreHeader + GreLength;
            PayloadLength = htons(pDgram->pGreHeader->KeyLength);
            if (PayloadLength && pDgram->pGreHeader->SequenceNumberPresent)
            {
                NdisMWanIndicateReceive(&Status,
                                        pCall->pAdapter->hMiniportAdapter,
                                        pCall->NdisLinkContext,
                                        pPayload,
                                        PayloadLength);
                if (Status==NDIS_STATUS_SUCCESS)
                {
                    NdisMWanIndicateReceiveComplete(pCall->pAdapter->hMiniportAdapter,
                                                    pCall->NdisLinkContext);
                }
            }
        }
        else if (pCall->State!=STATE_CALL_ESTABLISHED || !IS_LINE_UP(pCall))
        {
            NdisReleaseSpinLock(&pCall->Lock);

            // If this call is being torn down, we want to put priority on
            // clearing out any packets left over.  It should go fast since
            // we're not indicating them up.
            ReceiveMax = 100;
        }

        DEREFERENCE_OBJECT(pCall);
        (void)CtdiReceiveComplete(pDgram->hCtdi, pDgram->pBuffer);
        
        NdisAcquireSpinLock(&pCall->Lock);
    }

    if (IsListEmpty(&pCall->RxPacketList))
    {
        pCall->Receiving = FALSE;
        NdisReleaseSpinLock(&pCall->Lock);
        DEREFERENCE_OBJECT(pCall);      // work item
    }
    else
    {
        NdisScheduleWorkItem(&pCall->RecvWorkItem);
//        PptpQueueDpc(&pCall->ReceiveDpc);
        NdisReleaseSpinLock(&pCall->Lock);
    }

    DEBUGMSG(DBG_FUNC, (DTEXT("-CallProcessRxPackets\n")));
}

VOID
CallProcessPackets(
    PNDIS_WORK_ITEM pNdisWorkItem,
    PCALL_SESSION   pCall
    )
{
    BOOLEAN MorePacketsToTransfer = FALSE;
    ULONG TransmitFlags = 0;
    NDIS_STATUS Status;
    ULONG Ack = 0, Seq = 0;
    ULONG TransferMax = 50;

    PLIST_ENTRY pListEntry;
    PNDIS_WAN_PACKET pPacket;

    DEBUGMSG(DBG_FUNC, (DTEXT("+CallProcessPackets\n")));

    ASSERT(sizeof(GRE_HEADER)==8);
    ASSERT(IS_CALL(pCall));

    //++ProcCountTx[KeGetCurrentProcessorNumber()];

    NdisAcquireSpinLock(&pCall->Lock);

    while (TransferMax-- && !IsListEmpty(&pCall->TxPacketList))
    {
        pListEntry = RemoveHeadList(&pCall->TxPacketList);
        pPacket = CONTAINING_RECORD(pListEntry,
                                    NDIS_WAN_PACKET,
                                    WanPacketQueue);

        if(pCall->Packet.AckNumber != pCall->Remote.SequenceNumber)
        {
            TransmitFlags |= TRANSMIT_SEND_ACK;
            pCall->Packet.AckNumber = pCall->Remote.SequenceNumber;
            // Ack tracks the Remote.SequenceNumber, which is actually the
            // sequence of the NEXT packet, so we need to translate when
            // we prepare to send an ack.
            Ack = pCall->Remote.SequenceNumber - 1;
        }
    
        NdisReleaseSpinLock(&pCall->Lock);

        if (pPacket!=&pCall->Ack.Packet || TransmitFlags&TRANSMIT_SEND_ACK)
        {
            if (pPacket != &pCall->Ack.Packet)
            {
                TransmitFlags |= TRANSMIT_SEND_SEQ;
                Seq = pCall->Packet.SequenceNumber++;
            }

            Status = CallTransmitPacket(pCall, pPacket, TransmitFlags, Seq, Ack);

            if (Status!=NDIS_STATUS_PENDING)
            {
                if (pPacket == &pCall->Ack.Packet)
                {
                    NdisAcquireSpinLock(&pCall->Lock);
                    pCall->Ack.PacketQueued = FALSE;
                    NdisReleaseSpinLock(&pCall->Lock);
                }
                else
                {
                    // We didn't send the packet, so tell NDIS we're done with it.
                    NdisMWanSendComplete(pCall->pAdapter->hMiniportAdapter,
                                         pPacket,
                                         NDIS_STATUS_SUCCESS);  // so I lied.  Sue me.
                    DEREFERENCE_OBJECT(pCall);
                }
            }
        }
        else
        {
            // it was the ack-only packet, and we already sent an ack.
            NdisAcquireSpinLock(&pCall->Lock);
            pCall->Ack.PacketQueued = FALSE;
            NdisReleaseSpinLock(&pCall->Lock);
        }

        TransmitFlags = 0;

        NdisAcquireSpinLock(&pCall->Lock);
    }

    if(IsListEmpty(&pCall->TxPacketList))
    {
        pCall->Transferring = FALSE;
        NdisReleaseSpinLock(&pCall->Lock);
        DEREFERENCE_OBJECT(pCall);      // work item
    }
    else
    {
        NdisScheduleWorkItem(&pCall->SendWorkItem);
        NdisReleaseSpinLock(&pCall->Lock);
    }

    DEBUGMSG(DBG_FUNC, (DTEXT("-CallProcessPackets %d\n"), MorePacketsToTransfer));
    return;
}

VOID
CallpAckTimeout(
    IN PVOID SystemSpecific1,
    IN PVOID Context,
    IN PVOID SystemSpecific2,
    IN PVOID SystemSpecific3
    )
{
    PCALL_SESSION pCall = Context;
    DEBUGMSG(DBG_FUNC, (DTEXT("+CallpAckTimeout\n")));


    if (IS_CALL(pCall))
    {
        if (pCall->State!=STATE_CALL_ESTABLISHED ||
            CallQueueTransmitPacket(pCall, &pCall->Ack.Packet)!=NDIS_STATUS_PENDING)
        {
            NdisAcquireSpinLock(&pCall->Lock);
            pCall->Ack.PacketQueued = FALSE;
            NdisReleaseSpinLock(&pCall->Lock);
        }
    }

    DEBUGMSG(DBG_FUNC, (DTEXT("-CallpAckTimeout\n")));
}

VOID
CallpDialTimeout(
    IN PVOID SystemSpecific1,
    IN PVOID Context,
    IN PVOID SystemSpecific2,
    IN PVOID SystemSpecific3
    )
{
    PCALL_SESSION pCall = Context;
    DEBUGMSG(DBG_FUNC, (DTEXT("+CallpDialTimeout\n")));

    WPLOG(LL_M, LM_CALL, ("pCall %p Cid %d timed out in dialing state",
        pCall, (ULONG)pCall->DeviceId));
        
    ASSERT(IS_CALL(pCall));
    if (pCall->State==STATE_CALL_DIALING)
    {
        CallCleanup(pCall, UNLOCKED);
    }

    DEBUGMSG(DBG_FUNC, (DTEXT("-CallpDialTimeout\n")));
}

VOID
CallpCloseTimeout(
    IN PVOID SystemSpecific1,
    IN PVOID Context,
    IN PVOID SystemSpecific2,
    IN PVOID SystemSpecific3
    )
{
    PCALL_SESSION pCall = Context;
    DEBUGMSG(DBG_FUNC, (DTEXT("+CallpCloseTimeout\n")));

    ASSERT(IS_CALL(pCall));
    pCall->Close.Expedited = TRUE;
    CallCleanup(pCall, UNLOCKED);
    // ToDo: check for failure.

    DEBUGMSG(DBG_FUNC, (DTEXT("-CallpCloseTimeout\n")));
}

VOID CallpFinalDeref(PCALL_SESSION pCall)
{
    DEBUGMSG(DBG_FUNC|DBG_CALL, (DTEXT("+CallpFinalDeref\n")));
}

VOID CallpCleanupLooseEnds(PPPTP_ADAPTER pAdapter)
{
    ULONG i;
    DEBUGMSG(DBG_FUNC, (DTEXT("+CallpCleanupLooseEnds\n")));

    for (i=0; i<pAdapter->Info.Endpoints; i++)
    {
        PCALL_SESSION pCall = pAdapter->pCallArray[i];
        if (IS_CALL(pCall))
        {
            NdisAcquireSpinLock(&pCall->Lock);
            if (pCall->State==STATE_CALL_CLEANUP)
            {
                CallCleanup(pCall, LOCKED);
            }
            NdisReleaseSpinLock(&pCall->Lock);
        }
    }

    DEBUGMSG(DBG_FUNC, (DTEXT("-CallpCleanupLooseEnds\n")));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ndis\raspptp\common\bpool.c ===
// Copyright (c) 1997-1999 Microsoft Corporation
//
// bpool.c
// RAS L2TP WAN mini-port/call-manager driver
// Buffer pool management routines
//
// 01/07/97 Steve Cobb, adapted from Gurdeep's WANARP code.

#include "raspptp.h"
#include "bpool.h"


// Debug count of detected double-frees that should not be happening.
//
ULONG g_ulDoubleBufferFrees = 0;


//-----------------------------------------------------------------------------
// Local prototypes (alphabetically)
//-----------------------------------------------------------------------------

CHAR*
AddBufferBlockToPool(
    IN BUFFERPOOL* pPool );

VOID
FreeUnusedBufferPoolBlocks(
    IN BUFFERPOOL* pPool );


//-----------------------------------------------------------------------------
// Interface routines
//-----------------------------------------------------------------------------

VOID
InitBufferPool(
    OUT BUFFERPOOL* pPool,
    IN ULONG ulBufferSize,
    IN ULONG ulMaxBuffers,
    IN ULONG ulBuffersPerBlock,
    IN ULONG ulFreesPerCollection,
    IN BOOLEAN fAssociateNdisBuffer,
    IN ULONG ulTag )

    // Initialize caller's buffer pool control block 'pPool'.  'UlBufferSize'
    // is the size in bytes of an individual buffer.  'UlMaxBuffers' is the
    // maximum number of buffers allowed in the entire pool or 0 for
    // unlimited.  'UlBuffersPerBlock' is the number of buffers to include in
    // each block of buffers.  'UlFreesPerCollection' is the number of
    // FreeBufferToPool calls until the next garbage collect scan, or 0 for
    // default.  'FAssociateNdisBuffer' is set if an NDIS_BUFFER should be
    // allocated and associated with each individual buffer.  'UlTag' is the
    // memory identification tag to use when allocating blocks.
    //
    // IMPORTANT: Caller's 'pPool' buffer must be protected from multiple
    //            access during this call.
    //
{
    pPool->ulBufferSize = ulBufferSize;
    pPool->ulMaxBuffers = ulMaxBuffers;
    pPool->ulBuffersPerBlock = ulBuffersPerBlock;
    pPool->ulFreesSinceCollection = 0;
    pPool->fAssociateNdisBuffer = fAssociateNdisBuffer;
    pPool->ulTag = ulTag;

    if (ulFreesPerCollection)
    {
        pPool->ulFreesPerCollection = ulFreesPerCollection;
    }
    else
    {
        // Calculate default garbage collection trigger.  Don't want to be too
        // aggressive here.
        //
        pPool->ulFreesPerCollection = 200 * pPool->ulBuffersPerBlock;
    }

    DEBUGMSG(DBG_POOL, (DTEXT("InitBp tag=$%08x buf=%d cnt=%d\n"),
                        pPool->ulTag, pPool->ulBufferSize, pPool->ulBuffersPerBlock ) );

    InitializeListHead( &pPool->listBlocks );
    InitializeListHead( &pPool->listFreeBuffers );
    NdisAllocateSpinLock( &pPool->lock );
}


BOOLEAN
FreeBufferPool(
    IN BUFFERPOOL* pPool )

    // Free up all resources allocated in buffer pool 'pPool'.  This is the
    // inverse of InitBufferPool.
    //
    // Returns true if successful, false if any of the pool could not be freed
    // due to outstanding packets.
    //
{
    BOOLEAN fSuccess;

    DEBUGMSG(DBG_POOL, (DTEXT("FreeBp\n")));

    NdisAcquireSpinLock( &pPool->lock );
    {
        FreeUnusedBufferPoolBlocks( pPool );
        fSuccess = (pPool->ulCurBuffers == 0);
    }
    NdisReleaseSpinLock( &pPool->lock );
    NdisFreeSpinLock( &pPool->lock );

    return fSuccess;
}


CHAR*
GetBufferFromPool(
    IN BUFFERPOOL* pPool )

    // Returns the address of the useable memory in an individual buffer
    // allocated from the pool 'pPool'.  The pool is expanded, if necessary,
    // but caller should still check for NULL return since the pool may have
    // been at maximum size.
    //
{
    LIST_ENTRY* pLink;
    BUFFERHEAD* pHead;
    CHAR* pBuffer;

    NdisAcquireSpinLock( &pPool->lock );
    {
        if (IsListEmpty( &pPool->listFreeBuffers ))
        {
            pLink = NULL;
        }
        else
        {
            pLink = RemoveHeadList( &pPool->listFreeBuffers );
            InitializeListHead( pLink );
            pHead = CONTAINING_RECORD( pLink, BUFFERHEAD, linkFreeBuffers );
            --pHead->pBlock->ulFreeBuffers;
        }
    }
    NdisReleaseSpinLock( &pPool->lock );

    if (pLink)
    {
        pBuffer = (CHAR* )(pHead + 1);
    }
    else
    {
        // The free list was empty.  Try to expand the pool.
        //
        pBuffer = AddBufferBlockToPool( pPool );
    }

    if (pBuffer)
    {
        pHead = (BUFFERHEAD* )(pBuffer - sizeof(BUFFERHEAD));
        DEBUGMSG(DBG_POOL, (DTEXT("GetBfp=$%08x, %d free\n"),
                            pBuffer, pHead->pBlock->ulFreeBuffers));
    }
    else
    {
        DEBUGMSG(DBG_POOL, (DTEXT("GetBfp failed?\n" ) ));
    }

    return pBuffer;
}


VOID
FreeBufferToPool(
    IN BUFFERPOOL* pPool,
    IN CHAR* pBuffer,
    IN BOOLEAN fGarbageCollection )

    // Returns 'pBuffer' to the pool of unused buffers 'pPool'.  'PBuffer'
    // must have been previously allocated with GetBufferFromPool.
    // 'FGarbageCollection' is set when the free should be considered for
    // purposes of garbage collection.  This is used by the AddBufferToPool
    // routine to avoid counting the initial "add" frees.  Normal callers
    // should set this flag.
    //
{
    BUFFERHEAD* pHead;

    pHead = ((BUFFERHEAD* )pBuffer) - 1;

    if (fGarbageCollection)
    {
        DEBUGMSG(DBG_POOL, (DTEXT("FreeBtoP($%08x) %d free\n"),
                            pBuffer, pHead->pBlock->ulFreeBuffers + 1 ) );
    }

    NdisAcquireSpinLock( &pPool->lock );
    do
    {
        if (pHead->linkFreeBuffers.Flink != &pHead->linkFreeBuffers)
        {
            ASSERT( !"Double free?" );
            ++g_ulDoubleBufferFrees;
            break;
        }

        InsertHeadList( &pPool->listFreeBuffers, &pHead->linkFreeBuffers );
        ++pHead->pBlock->ulFreeBuffers;

        if (fGarbageCollection)
        {
            ++pPool->ulFreesSinceCollection;

            if (pPool->ulFreesSinceCollection >= pPool->ulFreesPerCollection)
            {
                // Time to collect garbage, i.e. free any blocks in the
                // pool not in use.
                //
                FreeUnusedBufferPoolBlocks( pPool );
                pPool->ulFreesSinceCollection = 0;
            }
        }
    }
    while (FALSE);
    NdisReleaseSpinLock( &pPool->lock );
}


NDIS_BUFFER*
NdisBufferFromBuffer(
    IN CHAR* pBuffer )

    // Returns the NDIS_BUFFER associated with the buffer 'pBuffer' which was
    // obtained previously with GetBufferFromPool.
    //
{
    BUFFERHEAD* pHead;

    pHead = ((BUFFERHEAD* )pBuffer) - 1;
    return pHead->pNdisBuffer;
}


ULONG
BufferSizeFromBuffer(
    IN CHAR* pBuffer )

    // Returns the original size of the buffer 'pBuffer' which was obtained
    // previously with GetBufferFromPool.  This is useful for undoing
    // NdisAdjustBufferLength.
    //
{
    BUFFERHEAD* pHead;

    pHead = ((BUFFERHEAD* )pBuffer) - 1;
    return pHead->pBlock->pPool->ulBufferSize;
}


NDIS_BUFFER*
PoolHandleForNdisCopyBufferFromBuffer(
    IN CHAR* pBuffer )

    // Returns the handle of the pool from which the NDIS_BUFFER associated
    // with the buffer 'pBuffer' was obtained.  Caller may use the handle to
    // pass to NdisCopyBuffer, one such use per buffer at a time.
    //
{
    BUFFERHEAD* pHead;

    pHead = ((BUFFERHEAD* )pBuffer) - 1;
    return pHead->pBlock->hNdisPool;
}


VOID
CollectBufferPoolGarbage(
    BUFFERPOOL* pPool )

    // Force a garbage collection event on the pool 'pPool'.
    //
{
    NdisAcquireSpinLock( &pPool->lock );
    {
        FreeUnusedBufferPoolBlocks( pPool );
        pPool->ulFreesSinceCollection = 0;
    }
    NdisReleaseSpinLock( &pPool->lock );
}


//-----------------------------------------------------------------------------
// Local utility routines (alphabetically)
//-----------------------------------------------------------------------------

CHAR*
AddBufferBlockToPool(
    IN BUFFERPOOL* pPool )

    // Allocate a new buffer block and add it to the buffer pool 'pPool'.
    //
    // Returns the address of the usable memory of an individual buffer
    // allocated from the pool or NULL if none.
    //
{
    NDIS_STATUS status;
    BUFFERBLOCKHEAD* pNew;
    ULONG ulSize;
    ULONG ulCount;
    BOOLEAN fOk;
    BOOLEAN fAssociateNdisBuffer;
    CHAR* pReturn;

    DEBUGMSG(DBG_POOL, (DTEXT("AddBpBlock(%d+%d)\n"),
                        pPool->ulCurBuffers, pPool->ulBuffersPerBlock ) );

    fOk = FALSE;
    pNew = NULL;

    NdisAcquireSpinLock( &pPool->lock );
    {
        // Save this for reference after the lock is released.
        //
        fAssociateNdisBuffer = pPool->fAssociateNdisBuffer;

        do
        {
            if (pPool->ulMaxBuffers
                && pPool->ulCurBuffers >= pPool->ulMaxBuffers)
            {
                // No can do.  The pool's already at maximum size.
                //
                DEBUGMSG(DBG_POOL, (DTEXT("Bp maxed?\n")));
                break;
            }

            // Calculate the contiguous block's size and the number of buffers
            // it will hold.
            //
            ulCount = pPool->ulBuffersPerBlock;
            if (pPool->ulMaxBuffers)
            {
                if (ulCount > pPool->ulMaxBuffers - pPool->ulCurBuffers)
                {
                    ulCount = pPool->ulMaxBuffers - pPool->ulCurBuffers;
                }
            }
            ulSize = sizeof(BUFFERBLOCKHEAD) +
                (ulCount * (sizeof(BUFFERHEAD) + pPool->ulBufferSize));

            // Allocate the contiguous memory block for the BUFFERBLOCK header
            // and the individual buffers.
            //
            pNew = MyMemAlloc( ulSize, pPool->ulTag );
            if (!pNew)
            {
                DEBUGMSG(DBG_POOL, (DTEXT( "Alloc BB?\n" ) ));
                break;
            }

            // Zero only the block header portion.
            //
            NdisZeroMemory( pNew, sizeof(BUFFERBLOCKHEAD) );

            if (fAssociateNdisBuffer)
            {
                // Allocate a pool of NDIS_BUFFER descriptors.
                //
                // Twice as many descriptors are allocated as buffers so
                // caller can use the PoolHandleForNdisCopyBufferFromBuffer
                // routine to obtain a pool handle to pass to the
                // NdisCopyBuffer used to trim the L2TP header from received
                // packets.  In the current NDIS implmentation on NT this does
                // nothing but return a NULL handle and STATUS_SUCCESS,
                // because NDIS_BUFFER's are just MDL's,
                // NdisAllocateBufferPool is basically a no-op, and for that
                // matter, NdisCopyBuffer doesn't really use the pool handle
                // it's passed.  It's cheap to stay strictly compliant here,
                // though, so we do that.
                //
                NdisAllocateBufferPool(
                    &status, &pNew->hNdisPool, ulCount * 2 );
                if (status != NDIS_STATUS_SUCCESS)
                {
                    DEBUGMSG(DBG_POOL, (DTEXT("AllocBp=$%x?\n"), status ));
                    break;
                }
            }

            // Fill in the back pointer to the pool.
            //
            pNew->pPool = pPool;

            // Link the new block.  At this point, all the buffers are
            // effectively "in use".  They are made available in the loop
            // below.
            //
            pNew->ulBuffers = ulCount;
            pPool->ulCurBuffers += ulCount;
            InsertHeadList( &pPool->listBlocks, &pNew->linkBlocks );

            fOk = TRUE;
        }
        while (FALSE);
    }
    NdisReleaseSpinLock( &pPool->lock );

    if (!fOk)
    {
        // Bailing, undo whatever succeeded.
        //
        if (pNew)
        {
            MyMemFree( pNew, ulSize );
            if (pNew->hNdisPool)
            {
                NdisFreeBufferPool( pNew->hNdisPool );
            }
        }

        return NULL;
    }

    // Initialize each individual buffer slice and add it to the list of free
    // buffers.
    //
    {
        ULONG i;
        CHAR* pBuffer;
        BUFFERHEAD* pHead;

        pReturn = NULL;

        // For each slice of the block, where a slice consists of a BUFFERHEAD
        // and the buffer memory that immediately follows it...
        //
        for (i = 0, pHead = (BUFFERHEAD* )(pNew + 1);
             i < ulCount;
             ++i, pHead = (BUFFERHEAD* )
                      ((CHAR* )(pHead + 1) + pPool->ulBufferSize))
        {
            pBuffer = (CHAR* )(pHead + 1);

            InitializeListHead( &pHead->linkFreeBuffers );
            pHead->pBlock = pNew;
            pHead->pNdisBuffer = NULL;

            if (fAssociateNdisBuffer)
            {
                // Associate an NDIS_BUFFER descriptor from the pool we
                // allocated above.
                //
                NdisAllocateBuffer(
                    &status, &pHead->pNdisBuffer, pNew->hNdisPool,
                    pBuffer, pPool->ulBufferSize );

                if (status != NDIS_STATUS_SUCCESS)
                {
                    DEBUGMSG(DBG_POOL, (DTEXT("AllocB=$%x?\n"), status ) );
                    ASSERT( FALSE );
                    continue;
                }
            }

            if (pReturn)
            {
                // Add the constructed buffer to the list of free buffers.
                // The 'FALSE' tells the garbage collection algorithm the
                // operation is an "add" rather than a "release" and should be
                // ignored.
                //
                FreeBufferToPool( pPool, pBuffer, FALSE );
            }
            else
            {
                // The first successfully constructed buffer is returned by
                // this routine.
                //
                pReturn = pBuffer;
            }
        }
    }

    return pReturn;
}


VOID
FreeUnusedBufferPoolBlocks(
    IN BUFFERPOOL* pPool )

    // Check if any of the blocks in pool 'pPool' are not in use, and if so,
    // free them.
    //
    // IMPORTANT: Caller must hold the pool lock.
    //
{
    LIST_ENTRY* pLink;

    DEBUGMSG(DBG_POOL, (DTEXT("FreeUnusedBpBlocks\n" ) ));

    // For each block in the pool...
    //
    pLink = pPool->listBlocks.Flink;
    while (pLink != &pPool->listBlocks)
    {
        LIST_ENTRY* pLinkNext;
        BUFFERBLOCKHEAD* pBlock;

        pLinkNext = pLink->Flink;

        pBlock = CONTAINING_RECORD( pLink, BUFFERBLOCKHEAD, linkBlocks );
        if (pBlock->ulFreeBuffers >= pBlock->ulBuffers)
        {
            ULONG i;
            BUFFERHEAD* pHead;

            DEBUGMSG(DBG_POOL, (DTEXT("FreeBpBlock(%d-%d)\n"),
                                pPool->ulCurBuffers, pPool->ulBuffersPerBlock ) );

            // Found a block with no buffers in use.  Walk the buffer block
            // removing each buffer from the pool's free list and freeing any
            // associated NDIS_BUFFER descriptor.
            //
            for (i = 0, pHead = (BUFFERHEAD* )(pBlock + 1);
                 i < pBlock->ulBuffers;
                 ++i, pHead = (BUFFERHEAD* )
                      (((CHAR* )(pHead + 1)) + pPool->ulBufferSize))
            {
                RemoveEntryList( &pHead->linkFreeBuffers );
                InitializeListHead( &pHead->linkFreeBuffers );

                if (pHead->pNdisBuffer)
                {
                    NdisFreeBuffer( pHead->pNdisBuffer );
                }
            }

            // Remove and release the unused block.
            //
            RemoveEntryList( pLink );
            InitializeListHead( pLink );
            pPool->ulCurBuffers -= pBlock->ulBuffers;

            if (pBlock->hNdisPool)
            {
                NdisFreeBufferPool( pBlock->hNdisPool );
            }

            MyMemFree( pBlock, sizeof(BUFFERBLOCKHEAD) + (pBlock->ulBuffers * (sizeof(BUFFERHEAD) + pPool->ulBufferSize)));
        }

        pLink = pLinkNext;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ndis\raspppoe\util.h ===
#ifndef _UTIL_H_
#define _UTIL_H_

typedef enum
_WORKSTATE
{
	WS_NotScheduled = 0,
	WS_Scheduled,
	WS_Executing,
	WS_Executed
}
WORKSTATE;

typedef 
VOID 
(*WORKITEM_EXEC_ROUTINE)( 
	IN PVOID Args[4],
	UINT workType 
	);
	
typedef 
VOID 
(*WORKITEM_FREE_ROUTINE)( 
	IN PVOID Args[4],
	IN UINT workType
	);

typedef struct
_WORKITEM
{
	//
	// Indicates the state of the work item
	//
	WORKSTATE workState;

	//
	// Indicates the type of work to be done
	//
	UINT workType;

	//
	// Points to the lookaside list the item was allocated from
	//
	PNPAGED_LOOKASIDE_LIST pLookaside;
	
	//
	// Context to be passed to scheduled item
	//
	PVOID Args[4];

	//
	// Routine to be called to execute the work item
	//
	WORKITEM_EXEC_ROUTINE pExecRoutine; 

	//
	// Routine to be called to free the context for the work item
	//
	WORKITEM_FREE_ROUTINE pFreeRoutine;
	
	//
    // Associated NdisWorkItem 
    //
    NDIS_WORK_ITEM	ndisWorkItem;

}
WORKITEM;

VOID InitializeWorkItemLookasideList(
	IN PNPAGED_LOOKASIDE_LIST pLookaside,
	IN ULONG tagLookaside
	);

WORKITEM* AllocWorkItem(
	IN PNPAGED_LOOKASIDE_LIST pLookaside,
	IN WORKITEM_EXEC_ROUTINE pExecRoutine,
	IN WORKITEM_FREE_ROUTINE pFreeRoutine,
	IN PVOID Args[4],
	IN UINT workType
	);

VOID ScheduleWorkItem(
	IN WORKITEM *pWorkItem
	);

VOID FreeWorkItem(
	IN WORKITEM *pWorkItem
	);

VOID WorkItemExec(
    IN NDIS_WORK_ITEM*  pNdisWorkItem,
    IN PVOID  pvContext
	);	


typedef struct
_HANDLE_CB
{
	//
	// Indicates that the entry contains a valid context pointer
	//
	BOOLEAN fActive;

	//
	// Pointer to the context saved in this entry
	//
	PVOID pContext;

	//
	// Handle value to access this particular entry
	//
	NDIS_HANDLE Handle;
}
HANDLE_CB;

typedef struct
_HANDLE_TABLE_CB
{
	//
	// Points to the table that holds the Handle control blocks.
	//
	HANDLE_CB* HandleTable;

	//
	// Size of the handle table
	//
	UINT nTableSize;

	//
	// Shows the number of active handles
	//
	UINT nActiveHandles;

	//
	// Keeps the unique part of the handle.
	// This is incremented everytime a handle is generated and a context is inserted 
	// into the handle table.
	//
	USHORT usKeys;
}
HANDLE_TABLE_CB, *PHANDLE_TABLE_CB, *HANDLE_TABLE;

#define NO_PREFERED_INDEX 		(USHORT) -1

HANDLE_TABLE InitializeHandleTable(
	IN UINT nHandleTableSize
	);

VOID FreeHandleTable(
	IN OUT HANDLE_TABLE Table
	);

NDIS_HANDLE InsertToHandleTable(
	IN HANDLE_TABLE Table,
	IN USHORT usPreferedIndex,
	IN PVOID pContext
	);

PVOID RetrieveFromHandleTable(
	IN HANDLE_TABLE Table,
	IN NDIS_HANDLE Handle
	);

USHORT RetrieveIndexFromHandle(
	IN NDIS_HANDLE Handle
	);
	
PVOID RetrieveFromHandleTableByIndex(
	IN HANDLE_TABLE Table,
	IN USHORT usIndex
	);

PVOID RetrieveFromHandleTableBySessionId(
	IN HANDLE_TABLE Table,
	IN USHORT usSessionId
	);
	
VOID RemoveFromHandleTable(
	IN HANDLE_TABLE Table,
	IN NDIS_HANDLE Handle
	);	

USHORT RetrieveSessionIdFromHandle(
	IN NDIS_HANDLE Handle
	);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ndis\raspptp\common\control.c ===
/*****************************************************************************
*
*   Copyright (c) 1998-1999 Microsoft Corporation
*
*   CONTROL.C - PPTP Control Layer functionality
*
*   Author:     Stan Adermann (stana)
*
*   Created:    7/28/1998
*
*****************************************************************************/

#include "raspptp.h"

#include "control.tmh"
        
typedef struct {
    LIST_ENTRY  ListEntry;
    ULONG       Length;
} MESSAGE_HEADER, *PMESSAGE_HEADER;

USHORT PptpControlPort = PPTP_TCP_PORT;
USHORT PptpProtocolNumber = PPTP_IP_GRE_PROTOCOL;
ULONG PptpWanEndpoints = OS_DEFAULT_WAN_ENDPOINTS;
BOOLEAN PptpClientSide = TRUE;
ULONG PptpBaseCallId = 0;
ULONG PptpMaxCallId = 0;
ULONG PptpCallIdMask = 0;
ULONG PptpListensPending = OS_LISTENS_PENDING;
BOOLEAN PptpEchoAlways = TRUE;
ULONG PptpEchoTimeout = PPTP_ECHO_TIMEOUT_DEFAULT;
ULONG PptpMessageTimeout = PPTP_MESSAGE_TIMEOUT_DEFAULT;
ULONG PptpMaxTransmit = PPTP_MAX_TRANSMIT;
BOOLEAN PptpInitialized = FALSE;
LONG PptpSendRecursionLimit = PPTP_SEND_RECURSION_LIMIT_DEFAULT;

BOOLEAN PptpAuthenticateIncomingCalls = FALSE;
PCLIENT_ADDRESS g_AcceptClientList = NULL;
ULONG g_ulAcceptClientAddresses = 0;
          
// Added for security
ULONG PptpValidateAddress = TRUE;           // Validate the source ip address
ULONG PptpMaxTunnelsPerIpAddress = -1;      // Maximum tunnels from each source ip address
PCLIENT_ADDRESS g_TrustedClientList = NULL; // Trusted client address list
ULONG g_ulTrustedClientAddresses = 0;

//CHAR PptpHostName[MAX_HOSTNAME_LENGTH];


static ULONG PptpMessageLength_v1[NUM_MESSAGE_TYPES] =
{
    0, // invalid
    sizeof(PPTP_CONTROL_START_PACKET),  // Request
    sizeof(PPTP_CONTROL_START_PACKET),  // Reply
    sizeof(PPTP_CONTROL_STOP_PACKET),   // Request
    sizeof(PPTP_CONTROL_STOP_PACKET),   // Reply
    sizeof(PPTP_CONTROL_ECHO_REQUEST_PACKET),
    sizeof(PPTP_CONTROL_ECHO_REPLY_PACKET),
    sizeof(PPTP_CALL_OUT_REQUEST_PACKET),
    sizeof(PPTP_CALL_OUT_REPLY_PACKET),
    sizeof(PPTP_CALL_IN_REQUEST_PACKET),
    sizeof(PPTP_CALL_IN_REPLY_PACKET),
    sizeof(PPTP_CALL_IN_CONNECT_PACKET),
    sizeof(PPTP_CALL_CLEAR_REQUEST_PACKET),
    sizeof(PPTP_CALL_DISCONNECT_NOTIFY_PACKET),
    sizeof(PPTP_WAN_ERROR_NOTIFY_PACKET),
    sizeof(PPTP_SET_LINK_INFO_PACKET)
};

static PCHAR aszCtlStateType[NUM_CONTROL_STATES+1] =
{
    "INVALID",
    "LISTEN",     
    "DIALING",    
    "WAIT_REQUEST",
    "WAIT_REPLY", 
    "ESTABLISHED",
    "WAIT_STOP",  
    "CLEANUP",    
    "UNKNOWN"
};
                                                                    
__inline PCHAR szCtlState(IN CONTROL_STATE state)
{
    if (state >= 0 && state < NUM_CONTROL_STATES)
    {
        return aszCtlStateType[state];
    }
    else
    {
        return aszCtlStateType[NUM_CONTROL_STATES];
    }
}


VOID
CtlCleanup(
    PCONTROL_TUNNEL pCtl,
    BOOLEAN Locked
    );

VOID
CtlpEchoTimeout(
    IN  PVOID       SystemSpecific1,
    IN  PVOID       pContext,
    IN  PVOID       SystemSpecific2,
    IN  PVOID       SystemSpecific3
    );

VOID
CtlpDeathTimeout(
    IN  PVOID       SystemSpecific1,
    IN  PVOID       pContext,
    IN  PVOID       SystemSpecific2,
    IN  PVOID       SystemSpecific3
    );

CONTROL_STATE
CtlSetState(
    IN PCONTROL_TUNNEL pCtl,
    IN CONTROL_STATE State,
    IN ULONG_PTR StateParam,
    IN BOOLEAN Locked
    );

CHAR *
ControlMsgToString(
    ULONG Message
    );

PCONTROL_TUNNEL
CtlAlloc(
    PPPTP_ADAPTER pAdapter
    )
{
    PCONTROL_TUNNEL pCtl;

    DEBUGMSG(DBG_FUNC, (DTEXT("+CtlAlloc\n")));
    
    pCtl = MyMemAlloc(sizeof(CONTROL_TUNNEL), TAG_PPTP_TUNNEL);
    if(!pCtl)
    {
        WPLOG(LL_A, LM_Res, ("Failed to alloc CONTROL_TUNNEL"));
        return NULL;
    }

#if LIST_CHECKING
    NdisAcquireSpinLock(&pAdapter->Lock);
    ASSERT(!CheckListEntry(&pAdapter->ControlTunnelList, &pCtl->ListEntry)); 
    NdisReleaseSpinLock(&pAdapter->Lock);
#endif
         
    NdisZeroMemory(pCtl, sizeof(CONTROL_TUNNEL));

    pCtl->Signature = TAG_PPTP_TUNNEL;
    pCtl->pAdapter = pAdapter;
    pCtl->PptpMessageLength = PptpMessageLength_v1;

    NdisAllocateSpinLock(&pCtl->Lock);
    NdisInitializeListHead(&pCtl->CallList);
    NdisInitializeListHead(&pCtl->MessageList);
    NdisMInitializeTimer(&pCtl->Echo.Timer,
                         pAdapter->hMiniportAdapter,
                         CtlpEchoTimeout,
                         pCtl);
    NdisMInitializeTimer(&pCtl->WaitTimeout,
                         pAdapter->hMiniportAdapter,
                         CtlpDeathTimeout,
                         pCtl);
    NdisMInitializeTimer(&pCtl->StopTimeout,
                         pAdapter->hMiniportAdapter,
                         CtlpDeathTimeout,
                         pCtl);


    INIT_REFERENCE_OBJECT(pCtl, CtlFree);

    MyInterlockedInsertTailList(&pAdapter->ControlTunnelList,
                                &pCtl->ListEntry,
                                &pAdapter->Lock);
    
    DEBUGMSG(DBG_FUNC, (DTEXT("-CtlAlloc %08x\n"), pCtl));
    return pCtl;
}

VOID
CtlFree(PCONTROL_TUNNEL pCtl)
{
    BOOLEAN NotUsed;

    DEBUGMSG(DBG_FUNC, (DTEXT("+CtlFree %08x\n"), pCtl));

    NdisAcquireSpinLock(&pgAdapter->Lock);
    
#if LIST_CHECKING
    ASSERT(CheckListEntry(&pgAdapter->ControlTunnelList, &pCtl->ListEntry)); 
#endif
        
    if (!IS_CTL(pCtl))
    {
        NdisReleaseSpinLock(&pgAdapter->Lock);
        return;
    }
    
    ASSERT(REFERENCE_COUNT(pCtl) == 0);     
    ASSERT(IsListEmpty(&pCtl->CallList));
    ASSERT(IsListEmpty(&pCtl->MessageList));
    
    pCtl->Signature = TAG_FREE;
    RemoveEntryList(&pCtl->ListEntry);
    InitializeListHead(&pCtl->ListEntry);
    NdisReleaseSpinLock(&pCtl->pAdapter->Lock);
    
    // This duplicates some of the cleanup code, but attempting to stop
    // the driver without first stopping tapi can result in an ungraceful
    // shutdown.
    NdisMCancelTimer(&pCtl->Echo.Timer, &NotUsed);
    NdisMCancelTimer(&pCtl->WaitTimeout, &NotUsed);
    NdisMCancelTimer(&pCtl->StopTimeout, &NotUsed);

    if (pCtl->hCtdi)
    {
        WPLOG(LL_M, LM_TUNNEL, ("TCP disconnecting %!IPADDR!",
            pCtl->Remote.Address.Address[0].Address[0].in_addr));
        CtdiDisconnect(pCtl->hCtdi, FALSE);
        CtdiClose(pCtl->hCtdi);
        pCtl->hCtdi = NULL;
    }
    if (pCtl->hCtdiEndpoint)
    {
        CtdiClose(pCtl->hCtdiEndpoint);
        pCtl->hCtdiEndpoint = NULL;
    }

    NdisFreeSpinLock(&pCtl->Lock);

    MyMemFree(pCtl, sizeof(CONTROL_TUNNEL));

    DEBUGMSG(DBG_FUNC, (DTEXT("-CtlFree\n")));
}

PVOID
CtlpAllocPacketLocked(
    PCONTROL_TUNNEL pCtl,
    PPTP_MESSAGE_TYPE Message
    )
{
    PMESSAGE_HEADER pMsg;
    ULONG PacketLength;
    PPTP_HEADER *pHeader;

    DEBUGMSG(DBG_TUNNEL, (DTEXT("+CtlpAllocPacketLocked %d\n"), Message));

    ASSERT(IS_CTL(pCtl));
    ASSERT(Message>=CONTROL_START_REQUEST && Message<NUM_MESSAGE_TYPES);

    if (pCtl->State == STATE_CTL_CLEANUP)
    {
        WPLOG(LL_A, LM_TUNNEL, ("pCtl %p in CLEANUP state", pCtl));
        return NULL;
    }
    
    PacketLength = pCtl->PptpMessageLength[Message];

    pMsg = MyMemAlloc(sizeof(MESSAGE_HEADER)+PacketLength, TAG_CTL_PACKET);
    if (!pMsg)
    {
        DEBUGMSG(DBG_ERROR, (DTEXT("Failed to alloc control packet\n")));
        WPLOG(LL_A, LM_TUNNEL, ("Failed to alloc control packet"));
        return NULL;
    }
    
    pHeader = (PVOID)&pMsg[1];
    NdisZeroMemory(pMsg, sizeof(MESSAGE_HEADER)+PacketLength);
    pMsg->Length = sizeof(MESSAGE_HEADER)+PacketLength;

    pHeader->Length = htons((USHORT)PacketLength);
    pHeader->PacketType = htons(PPTP_CONTROL_MESSAGE);
    pHeader->Cookie = htonl(PPTP_MAGIC_COOKIE);
    pHeader->MessageType = htons(Message);

    InsertTailList(&pCtl->MessageList, &pMsg->ListEntry);
    REFERENCE_OBJECT_EX(pCtl, CTL_REF_PACKET);      // pair in CtlFreePacket

    DEBUGMSG(DBG_TUNNEL, (DTEXT("-CtlpAllocPacketLocked %08x\n"), &pMsg[1]));
    return &pMsg[1];
}

PVOID
CtlAllocPacket(
    PCONTROL_TUNNEL pCtl,
    PPTP_MESSAGE_TYPE Message
    )
{
    PVOID pPacket = NULL;
    DEBUGMSG(DBG_FUNC, (DTEXT("+CtlAllocPacket\n")));

    if (IS_CTL(pCtl))
    {
        NdisAcquireSpinLock(&pCtl->Lock);
        pPacket = CtlpAllocPacketLocked(pCtl, Message);
        NdisReleaseSpinLock(&pCtl->Lock);
    }

    if(!pPacket)
    {
        gCounters.ulCtlAllocPacketNull++;
    }

    DEBUGMSG(DBG_FUNC, (DTEXT("-CtlAllocPacket\n")));
    return pPacket;
}


VOID
CtlFreePacket(
    PCONTROL_TUNNEL pCtl,
    PVOID pPacket
    )
{
    PMESSAGE_HEADER pMsg = ((PMESSAGE_HEADER)pPacket) - 1;

    DEBUGMSG(DBG_FUNC, (DTEXT("+CtlFreePacket %08x\n"), pPacket));

    ASSERT(IS_CTL(pCtl));
    NdisAcquireSpinLock(&pCtl->Lock);
    RemoveEntryList(&pMsg->ListEntry);
    if (pCtl->State==STATE_CTL_CLEANUP && IsListEmpty(&pCtl->MessageList))
    {
        CtlCleanup(pCtl, LOCKED);
    }
    NdisReleaseSpinLock(&pCtl->Lock);

    MyMemFree(pMsg, pMsg->Length);

    DEREFERENCE_OBJECT_EX(pCtl, CTL_REF_PACKET);        // pair in CtlpAllocPacket

    DEBUGMSG(DBG_FUNC, (DTEXT("-CtlFreePacket\n")));
}


STATIC VOID
CtlpCleanup(
    IN PPPTP_WORK_ITEM pWorkItem
    )
{
    PCONTROL_TUNNEL pCtl = pWorkItem->Context;
    BOOLEAN CleanupComplete = FALSE;
    BOOLEAN TimeoutStopped;
    DEBUGMSG(DBG_FUNC|DBG_TUNNEL, (DTEXT("+CtlpCleanup %08x\n"), pCtl));

    ASSERT(IS_CTL(pCtl));
    NdisAcquireSpinLock(&pCtl->Lock);

    if (!IsListEmpty(&pCtl->CallList))
    {
        ENUM_CONTEXT Enum;
        PCALL_SESSION pCall;
        PLIST_ENTRY pListEntry;

        REFERENCE_OBJECT_EX(pCtl, CTL_REF_ENUM);
        NdisReleaseSpinLock(&pCtl->Lock);
        InitEnumContext(&Enum);
        while (pListEntry = EnumListEntry(&pCtl->CallList, &Enum, &pCtl->pAdapter->Lock))
        {
            pCall = CONTAINING_RECORD(pListEntry,
                                      CALL_SESSION,
                                      ListEntry);
            if (IS_CALL(pCall))
            {
                CallEventDisconnect(pCall);
            }
        }
        EnumComplete(&Enum, &pCtl->pAdapter->Lock);
        DEREFERENCE_OBJECT_EX(pCtl, CTL_REF_ENUM);      // pair above
        NdisAcquireSpinLock(&pCtl->Lock);
        goto ccDone;
    }

    if (!IsListEmpty(&pCtl->MessageList))
    {
        goto ccDone;
    }

    NdisMCancelTimer(&pCtl->Echo.Timer, &TimeoutStopped);

    if (pCtl->Reference.Count!=2 )
    {
        DEBUGMSG(DBG_TUNNEL, (DTEXT("CtlpCleanup %d references held, not cleaning up.\n"),
                              pCtl->Reference.Count));
        goto ccDone;
    }

    NdisMCancelTimer(&pCtl->WaitTimeout, &TimeoutStopped);
    NdisMCancelTimer(&pCtl->StopTimeout, &TimeoutStopped);

    if (pCtl->hCtdi)
    {
        WPLOG(LL_I, LM_TUNNEL, ("TCP disconnecting %!IPADDR!",
            pCtl->Remote.Address.Address[0].Address[0].in_addr));
        CtdiDisconnect(pCtl->hCtdi, FALSE);
        CtdiClose(pCtl->hCtdi);
        pCtl->hCtdi = NULL;
    }
    if (pCtl->hCtdiEndpoint)
    {
        CtdiClose(pCtl->hCtdiEndpoint);
        pCtl->hCtdiEndpoint = NULL;
    }

    CleanupComplete = TRUE;


ccDone:
    if (!CleanupComplete)
    {
        pCtl->Cleanup = FALSE;
    }
    NdisReleaseSpinLock(&pCtl->Lock);
    DEREFERENCE_OBJECT_EX(pCtl, CTL_REF_CLEANUP);  // For this work item.
    if (CleanupComplete)
    {
        //CtdiDeleteHostRoute(&pCtl->Remote.Address);

        DEREFERENCE_OBJECT_EX(pCtl, CTL_REF_INITIAL);  // Should be last one
    }
    DEBUGMSG(DBG_FUNC, (DTEXT("-CtlpCleanup\n")));
}

VOID
CtlCleanup(
    PCONTROL_TUNNEL pCtl,
    BOOLEAN Locked
    )
{
    DEBUGMSG(DBG_FUNC|DBG_TUNNEL, (DTEXT("+CtlCleanup %08x\n"), pCtl));

    if (!Locked)
    {
        NdisAcquireSpinLock(&pCtl->Lock);
    }
    if (!pCtl->Cleanup)
    {
        REFERENCE_OBJECT_EX(pCtl, CTL_REF_CLEANUP);
        pCtl->Cleanup = TRUE;
        if (ScheduleWorkItem(CtlpCleanup, pCtl, NULL, 0)!=NDIS_STATUS_SUCCESS)
        {
            pCtl->Cleanup = FALSE;
            DEREFERENCE_OBJECT_EX(pCtl, CTL_REF_CLEANUP);
        }
    }
    if (!Locked)
    {
        NdisReleaseSpinLock(&pCtl->Lock);
    }
    DEBUGMSG(DBG_FUNC, (DTEXT("-CtlCleanup\n")));
}

VOID
CtlpQueryConnInfoCallback(
    IN      PVOID                       pContext,
    IN      PVOID                       pData,
    IN      NDIS_STATUS                 Result
    )
{
    PCONTROL_TUNNEL pCtl = pContext;
    PTDI_CONNECTION_INFO pInfo = pData;

    DEBUGMSG(DBG_FUNC, (DTEXT("+CtlpQueryConnInfoCallback Result=%x\n"), Result));

    ASSERT(IS_CTL(pCtl));
    if (Result==NDIS_STATUS_SUCCESS && IS_CTL(pCtl) && pCtl->State!=STATE_CTL_CLEANUP)
    {
        pCtl->Speed = (pInfo->Throughput.QuadPart==-1) ? 0 : pInfo->Throughput.LowPart;
        DBG_D(DBG_INIT, pCtl->Speed);
    }
    MyMemFree(pInfo, sizeof(*pInfo));
    DEREFERENCE_OBJECT_EX(pCtl, CTL_REF_QUERYCONNINFO);

    DEBUGMSG(DBG_FUNC, (DTEXT("-CtlpQueryConnInfoCallback\n")));
}

VOID
CtlpQueryAddrInfoCallback(
    IN      PVOID                       pContext,
    IN      PVOID                       pData,
    IN      NDIS_STATUS                 Result
    )
{
    PCONTROL_TUNNEL pCtl = pContext;
    PTDI_ADDRESS_INFO pAddrInfo = pData;
    PTA_IP_ADDRESS pIp = (PTA_IP_ADDRESS)&pAddrInfo->Address;
    
    ASSERT(IS_CTL(pCtl));
    if (Result==NDIS_STATUS_SUCCESS && IS_CTL(pCtl) && pCtl->State!=STATE_CTL_CLEANUP)
    {
        pCtl->LocalAddress = pIp->Address[0].Address[0].in_addr;
    }
    
    MyMemFree(pAddrInfo, sizeof(*pAddrInfo));
    DEREFERENCE_OBJECT_EX(pCtl, CTL_REF_QUERYADDRINFO);

    DEBUGMSG(DBG_FUNC, (DTEXT("-CtlpQueryAddrInfoCallback\n")));
}

STATIC VOID
CtlpEngine(
    IN PCONTROL_TUNNEL pCtl,
    IN PUCHAR pNewData,
    IN ULONG Length
    )
{
    UNALIGNED PPTP_HEADER *pHeader;
    ULONG NeededLength;
    ULONG MessageType;
    BOOLEAN TimerStopped;
    BOOLEAN PacketValid;
    BOOLEAN Shutdown = FALSE;

    DEBUGMSG(DBG_FUNC, (DTEXT("+CtlpEngine\n")));
    // Check to see if we have a full packet yet.

    ASSERT(IS_CTL(pCtl));
    while (Length)
    {
        if (pCtl->BytesInPartialBuffer)
        {
            while (Length && pCtl->BytesInPartialBuffer < sizeof(PPTP_HEADER))
            {
                pCtl->PartialPacketBuffer[pCtl->BytesInPartialBuffer++] = *pNewData++;
                Length--;
            }
            if (pCtl->BytesInPartialBuffer < sizeof(PPTP_HEADER))
            {
                return;
            }
            pHeader = (UNALIGNED PPTP_HEADER*)pCtl->PartialPacketBuffer;
        }
        else if (Length >= sizeof(PPTP_HEADER))
        {
            pHeader = (UNALIGNED PPTP_HEADER*)pNewData;
        }
        else
        {
            // Too little data.  Copy and exit.
            NdisMoveMemory(pCtl->PartialPacketBuffer, pNewData, Length);
            pCtl->BytesInPartialBuffer = Length;
            return;
        }

        // We have the header.  Validate it.
        PacketValid = FALSE;
        
        NeededLength = htons(pHeader->Length);
        MessageType = htons(pHeader->MessageType);

        if (NeededLength <= MAX_CONTROL_PACKET_LENGTH &&
            pHeader->Cookie == htonl(PPTP_MAGIC_COOKIE) &&
            pHeader->PacketType == htons(PPTP_CONTROL_MESSAGE) &&
            MessageType >= CONTROL_START_REQUEST &&
            MessageType < NUM_MESSAGE_TYPES)
        {
            // ToDo: will probably need some v2 code here for the first packet
            if (NeededLength == pCtl->PptpMessageLength[MessageType])
            {
                PacketValid = TRUE;
            }
        }

        if (PacketValid)
        {
            if (pCtl->BytesInPartialBuffer+Length < NeededLength)
            {
                // We don't have the whole packet yet.  Copy and exit.
                NdisMoveMemory(&pCtl->PartialPacketBuffer[pCtl->BytesInPartialBuffer],
                       pNewData,
                       Length);
                pCtl->BytesInPartialBuffer += Length;
                return;
            }

            if (pCtl->BytesInPartialBuffer)
            {
                // Make cetain the entire packet is in our PartialPacketBuffer and process it there.
                NeededLength -= pCtl->BytesInPartialBuffer;
                NdisMoveMemory(&pCtl->PartialPacketBuffer[pCtl->BytesInPartialBuffer],
                       pNewData,
                       NeededLength);

                // We now have one complete packet in the PartialPacketBuffer

                pNewData += NeededLength;
                Length -= NeededLength;

                pHeader = (UNALIGNED PPTP_HEADER *)pCtl->PartialPacketBuffer;

                // We've got the whole packet, and we're about to consume it
                // Clear the var so next time through we start from the buffer
                // beginning
                pCtl->BytesInPartialBuffer = 0;
            }
            else
            {
                // The whole packet is in the new buffer.  Process it there.
                pHeader = (UNALIGNED PPTP_HEADER *)pNewData;
                pNewData += NeededLength;
                Length -= NeededLength;
            }

            switch (ntohs(pHeader->MessageType))
            {
                case CONTROL_START_REQUEST:
                {
                    UNALIGNED PPTP_CONTROL_START_PACKET *pPacket = 
                        (UNALIGNED PPTP_CONTROL_START_PACKET*)pHeader;
                    UNALIGNED PPTP_CONTROL_START_PACKET *pReply;
                    NDIS_STATUS Status;

                    DEBUGMSG(DBG_TUNNEL, (DTEXT("RECV CONTROL_START_REQUEST\n")));
                    WPLOG(LL_M, LM_CMsg, ("RECV CONTROL_START_REQUEST <- %!IPADDR!, pCtl %p, state %d",
                        pCtl->Remote.Address.Address[0].Address[0].in_addr,
                        pCtl, pCtl->State));

                    switch (pCtl->State)
                    {
                        case STATE_CTL_WAIT_REQUEST:
                        {
                            pReply = CtlAllocPacket(pCtl, CONTROL_START_REPLY);

                            if (pReply)
                            {
                                PTDI_CONNECTION_INFO pInfo;
                                PTDI_ADDRESS_INFO pAddrInfo;
                                
                                NdisMCancelTimer(&pCtl->WaitTimeout, &TimerStopped);
                                // Take the pertinent data.

                                pCtl->Remote.Version = htons(pPacket->Version);
                                pCtl->Remote.Framing = htonl(pPacket->FramingCapabilities);
                                pCtl->Remote.Bearer = htonl(pPacket->BearerCapabilities);
                                NdisMoveMemory(pCtl->Remote.HostName, pPacket->HostName, MAX_HOSTNAME_LENGTH);
                                pCtl->Remote.HostName[MAX_HOSTNAME_LENGTH-1] = '\0';
                                NdisMoveMemory(pCtl->Remote.Vendor, pPacket->Vendor, MAX_VENDOR_LENGTH);
                                pCtl->Remote.Vendor[MAX_VENDOR_LENGTH-1] = '\0';

                                pReply->Version = ntohs(PPTP_PROTOCOL_VERSION_1_00);
                                pReply->FramingCapabilities = htonl(FRAMING_SYNC);
                                pReply->BearerCapabilities = htonl(BEARER_ANALOG|BEARER_DIGITAL);
                                pReply->MaxChannels = 0;
                                pReply->FirmwareRevision = htons(PPTP_FIRMWARE_REVISION);
//                                    NdisMoveMemory(pReply->HostName, PptpHostName, MAX_HOSTNAME_LENGTH);
                                NdisMoveMemory(pReply->Vendor, PPTP_VENDOR, min(sizeof(PPTP_VENDOR), MAX_VENDOR_LENGTH));
                                
                                if (pCtl->Remote.Version==PPTP_PROTOCOL_VERSION_1_00)
                                {
                                    pReply->ResultCode = RESULT_CONTROL_START_SUCCESS;
                                    CtlSetState(pCtl, STATE_CTL_ESTABLISHED, 0, UNLOCKED);
                                }
                                else
                                {
                                    WPLOG(LL_A, LM_TUNNEL, ("Bad version %d", pCtl->Remote.Version));
                                    pReply->ResultCode = RESULT_CONTROL_START_VERSION_NOT_SUPPORTED;
                                    Shutdown = TRUE;
                                }
                                
                                WPLOG(LL_M, LM_TUNNEL, ("SEND CONTROL_START_REPLY (SUCCESS) -> %!IPADDR!, pCtl %p", 
                                    pCtl->Remote.Address.Address[0].Address[0].in_addr, pCtl));
                                         
                                Status = CtlSend(pCtl, pReply);
                                if(Status != NDIS_STATUS_PENDING && Status != NDIS_STATUS_SUCCESS)
                                {
                                    Shutdown = TRUE;    
                                }
                                
                                if(!Shutdown)
                                {
                                    pInfo = MyMemAlloc(sizeof(*pInfo), TAG_CTL_CONNINFO);
                                    if (pInfo)
                                    {
                                        REFERENCE_OBJECT_EX(pCtl, CTL_REF_QUERYCONNINFO);
    
                                        // Get the interface speed
                                        Status = CtdiQueryInformation(pCtl->hCtdi,
                                                                      TDI_QUERY_CONNECTION_INFO,
                                                                      pInfo,
                                                                      sizeof(*pInfo),
                                                                      CtlpQueryConnInfoCallback,
                                                                      pCtl);
                                        ASSERT(Status == NDIS_STATUS_PENDING);                                
                                    }
                                    else
                                    {
                                        // Not so harmful, the deault speed is reported if it fails
                                        WPLOG(LL_A, LM_Res, ("Failed to alloc CONNECTION_INFO"));
                                    }
                                    
                                    // Query the local address
                                    pAddrInfo = MyMemAlloc(sizeof(*pAddrInfo)+TDI_ADDRESS_LENGTH_IP, TAG_CTL_CONNINFO);
                                    if (pAddrInfo)
                                    {
                                        REFERENCE_OBJECT_EX(pCtl, CTL_REF_QUERYADDRINFO);
    
                                        // Get the interface speed
                                        Status = CtdiQueryInformation(pCtl->hCtdi,
                                                                      TDI_QUERY_ADDRESS_INFO,
                                                                      pAddrInfo,
                                                                      sizeof(*pAddrInfo)+TDI_ADDRESS_LENGTH_IP,
                                                                      CtlpQueryAddrInfoCallback,
                                                                      pCtl);
                                        ASSERT(Status == NDIS_STATUS_PENDING);                                
                                    }
                                    else
                                    {
                                        WPLOG(LL_A, LM_Res, ("Failed to alloc ADDRESS_INFO"));
                                    }
                                }
                            }
                            else
                            {
                                // Alloc failed.  Do nothing, and timeout will cause cleanup.
                            }

                            break;
                        }
                        case STATE_CTL_CLEANUP:
                            DEBUGMSG(DBG_WARN, (DTEXT("Shutting down tunnel, ignore packet\n")));
                            WPLOG(LL_A, LM_TUNNEL, ("Shutting down tunnel, ignore packet"));
                            break;
                        default:
                            DEBUGMSG(DBG_WARN, (DTEXT("Bad state, shutdown tunnel\n")));
                            WPLOG(LL_A, LM_TUNNEL, ("Bad state, shutdown tunnel"));
                            Shutdown = TRUE;
                            break;
                    }
                    break;
                }
                case CONTROL_START_REPLY:
                {
                    UNALIGNED PPTP_CONTROL_REPLY_PACKET *pPacket = 
                        (UNALIGNED PPTP_CONTROL_REPLY_PACKET*)pHeader;

                    DEBUGMSG(DBG_TUNNEL, (DTEXT("RECV CONTROL_START_REPLY\n")));
                    WPLOG(LL_M, LM_CMsg, ("RECV CONTROL_START_REPLY <- %!IPADDR!, pCtl %p, state %d, RC %d, EC %d",
                        pCtl->Remote.Address.Address[0].Address[0].in_addr,
                        pCtl, pCtl->State, pPacket->ResultCode, pPacket->ErrorCode));

                    switch (pCtl->State)
                    {
                        case STATE_CTL_WAIT_REPLY:
                        {
                            ENUM_CONTEXT Enum;
                            PCALL_SESSION pCall;
                            PLIST_ENTRY pListEntry;

                            NdisMCancelTimer(&pCtl->WaitTimeout, &TimerStopped);

                            // Take the pertinent data.
                            
                            pCtl->Remote.Version = htons(pPacket->Version);
                            pCtl->Remote.Framing = htonl(pPacket->FramingCapabilities);
                            pCtl->Remote.Bearer = htonl(pPacket->BearerCapabilities);
                            NdisMoveMemory(pCtl->Remote.HostName, pPacket->HostName, MAX_HOSTNAME_LENGTH);
                            pCtl->Remote.HostName[MAX_HOSTNAME_LENGTH-1] = '\0';
                            NdisMoveMemory(pCtl->Remote.Vendor, pPacket->Vendor, MAX_VENDOR_LENGTH);
                            pCtl->Remote.Vendor[MAX_VENDOR_LENGTH-1] = '\0';
                            
                            if (pCtl->Remote.Version==PPTP_PROTOCOL_VERSION_1_00 &&
                                pPacket->ResultCode == RESULT_CONTROL_START_SUCCESS && 
                                pPacket->ErrorCode == 0)
                            {
                                CtlSetState(pCtl, STATE_CTL_ESTABLISHED, 0, UNLOCKED);
    
                                // Notify all calls on this session.
                                REFERENCE_OBJECT_EX(pCtl, CTL_REF_ENUM);
                                InitEnumContext(&Enum);
                                while (pListEntry = EnumListEntry(&pCtl->CallList, &Enum, &pCtl->pAdapter->Lock))
                                {
                                    pCall = CONTAINING_RECORD(pListEntry,
                                                              CALL_SESSION,
                                                              ListEntry);
                                    if (IS_CALL(pCall))
                                    {
                                        CallEventOutboundTunnelEstablished(pCall,
                                                                           NDIS_STATUS_SUCCESS);
                                    }
                                }
                                EnumComplete(&Enum, &pCtl->pAdapter->Lock);
                                DEREFERENCE_OBJECT_EX(pCtl, CTL_REF_ENUM);  // pair above
                            }
                            else
                            {
                                Shutdown = TRUE;
                            }

                            break;
                        }
                        default:
                            break;
                    }
                    break;
                }
                case CONTROL_ECHO_REQUEST:
                {
                    UNALIGNED PPTP_CONTROL_ECHO_REQUEST_PACKET *pPacket = 
                        (UNALIGNED PPTP_CONTROL_ECHO_REQUEST_PACKET*)pHeader;
                    UNALIGNED PPTP_CONTROL_ECHO_REPLY_PACKET *pReply;

                    DEBUGMSG(DBG_TUNNEL, (DTEXT("ECHO_REQUEST RECEIVED\n")));
                    WPLOG(LL_V, LM_CMsg, ("RECV Echo-Request <- %!IPADDR!",
                        pCtl->Remote.Address.Address[0].Address[0].in_addr));

                    pCtl->Echo.Needed = FALSE;
                    if (pCtl->Remote.Version==PPTP_PROTOCOL_VERSION_1_00)
                    {
                        pReply = CtlAllocPacket(pCtl, CONTROL_ECHO_REPLY);
                        if (pReply)
                        {
                            pReply->Identifier = pPacket->Identifier;
                            pReply->ResultCode = RESULT_CONTROL_ECHO_SUCCESS;
                            // ToDo: why would we send a ResultCode==failure?
                            CtlSend(pCtl, pReply);  // ToDo: return value?
                        }
                    }

                    break;
                }
                case CALL_OUT_REQUEST:
                {
                    UNALIGNED PPTP_CALL_OUT_REQUEST_PACKET *pPacket = 
                        (UNALIGNED PPTP_CALL_OUT_REQUEST_PACKET*)pHeader;

                    DEBUGMSG(DBG_TUNNEL, (DTEXT("RECV CALL_OUT_REQUEST\n")));
                    WPLOG(LL_M, LM_CMsg, ("RECV CALL_OUT_REQUEST <- %!IPADDR!, pCtl %p, state %d, Peer's Cid %d",
                        pCtl->Remote.Address.Address[0].Address[0].in_addr,
                        pCtl, pCtl->State, htons(pPacket->CallId)));

                    switch (pCtl->State)
                    {
                        case STATE_CTL_ESTABLISHED:
                        {
                            DBG_X(DBG_TUNNEL, htons(pPacket->CallId));
                            DBG_X(DBG_TUNNEL, htons(pPacket->SerialNumber));
                            DBG_D(DBG_TUNNEL, htonl(pPacket->MinimumBPS));
                            DBG_D(DBG_TUNNEL, htonl(pPacket->MaximumBPS));
                            DBG_X(DBG_TUNNEL, htonl(pPacket->BearerType));
                            DBG_X(DBG_TUNNEL, htonl(pPacket->FramingType));
                            DBG_X(DBG_TUNNEL, htons(pPacket->RecvWindowSize));
                            DBG_X(DBG_TUNNEL, htons(pPacket->ProcessingDelay));
                            DBG_X(DBG_TUNNEL, htons(pPacket->PhoneNumberLength));
                            DBG_S(DBG_TUNNEL, pPacket->PhoneNumber);
                            DBG_S(DBG_TUNNEL, pPacket->Subaddress);

                            // It's possible we had just closed our last call & were
                            // waiting for a CONTROL_STOP_REQUEST from the other side.
                            NdisMCancelTimer(&pCtl->StopTimeout, &TimerStopped);
                            CallEventCallOutRequest(pCtl->pAdapter,
                                                    pCtl,
                                                    pPacket);
                            break;
                        }
                        default:
                            // Bogus, but not enough to kill us.  Ignore it.
                            break;
                    }
                    break;
                }
                case CALL_OUT_REPLY:
                {
                    UNALIGNED PPTP_CALL_OUT_REPLY_PACKET *pPacket = 
                        (UNALIGNED PPTP_CALL_OUT_REPLY_PACKET*)pHeader;

                    ULONG PktCallId = htons(pPacket->PeerCallId);
                    ULONG CallId = CallIdToDeviceId(PktCallId);
                                 
                    DEBUGMSG(DBG_TUNNEL, (DTEXT("RECV CALL_OUT_REPLY\n")));
                    WPLOG(LL_M, LM_CMsg, ("RECV CALL_OUT_REPLY, pCtl %p, state %d, Cid %d Pkt-Cid %d, Peer's Cid %d, RC %d, EC %d",
                        pCtl, pCtl->State, CallId, PktCallId, htons(pPacket->CallId), 
                        pPacket->ResultCode, pPacket->ErrorCode));

                    if (pCtl->State==STATE_CTL_ESTABLISHED)
                    {
                        PCALL_SESSION pCall = CallGetCall(pCtl->pAdapter, CallId);

                        if (pCall)
                        {
                            DBG_X(DBG_TUNNEL, htons(pPacket->PeerCallId));
                            DBG_X(DBG_TUNNEL, pPacket->ResultCode);
                            DBG_X(DBG_TUNNEL, pPacket->ErrorCode);
                            DBG_X(DBG_TUNNEL, htons(pPacket->CauseCode));
                            DBG_D(DBG_TUNNEL, htonl(pPacket->ConnectSpeed));
                            DBG_D(DBG_TUNNEL, htons(pPacket->RecvWindowSize));
                            DBG_X(DBG_TUNNEL, htonl(pPacket->PhysicalChannelId));

                            CallEventCallOutReply(pCall, pPacket);
                        }
                        else
                        {
                            DEBUGMSG(DBG_WARN, (DTEXT("Bogus PeerCallId %d\n"), PktCallId));
                            WPLOG(LL_A, LM_TUNNEL, ("Bogus PeerCallId %d", PktCallId));
                        }

                    }
                    else
                    {
                        // Bogus, but not enough to kill us.  Ignore it.
                        WPLOG(LL_A, LM_TUNNEL, ("Tunnel state is not ESTABLISHED!"));
                    }
                    break;
                }
                case CALL_CLEAR_REQUEST:
                {
                    UNALIGNED PPTP_CALL_CLEAR_REQUEST_PACKET *pPacket = 
                        (UNALIGNED PPTP_CALL_CLEAR_REQUEST_PACKET*)pHeader;
                    ULONG CallId = htons(pPacket->CallId);
                                               
                    DEBUGMSG(DBG_TUNNEL, (DTEXT("RECV CALL_CLEAR_REQUEST\n")));
                    WPLOG(LL_M, LM_CMsg, ("RECV CALL_CLEAR_REQUEST <- %!IPADDR!, pCtl %p, state %d Peer's Cid %d",
                        pCtl->Remote.Address.Address[0].Address[0].in_addr,
                        pCtl, pCtl->State, CallId));

                    if (pCtl->State==STATE_CTL_ESTABLISHED)
                    {
                        ENUM_CONTEXT Enum;
                        PCALL_SESSION pCall;
                        PLIST_ENTRY pListEntry;

                        // The peer has given us his own call ID, which does little
                        // good for fast lookup of the call.  Find the associated call.
                        REFERENCE_OBJECT_EX(pCtl, CTL_REF_ENUM);

                        InitEnumContext(&Enum);

                        do
                        {
                            NdisAcquireSpinLock(&pCtl->pAdapter->Lock);
                            pListEntry = EnumListEntry(&pCtl->CallList, &Enum, NULL);
                            if(pListEntry != NULL)
                            {
                                pCall = CONTAINING_RECORD(pListEntry,
                                                          CALL_SESSION,
                                                          ListEntry);
                                if (IS_CALL(pCall) && pCall->pCtl==pCtl && pCall->Remote.CallId==CallId)
                                {
                                    REFERENCE_OBJECT(pCall);
                                    NdisReleaseSpinLock(&pCtl->pAdapter->Lock);
                                    CallEventCallClearRequest(pCall, pPacket, pCtl);
                                    DEREFERENCE_OBJECT(pCall);
                                    break;
                                }
                            }
                            NdisReleaseSpinLock(&pCtl->pAdapter->Lock);
                        
                        } while(pListEntry != NULL);
                        
                        EnumComplete(&Enum, &pCtl->pAdapter->Lock);
                        DEREFERENCE_OBJECT_EX(pCtl, CTL_REF_ENUM);  // pair above
                    }
                    break;
                }
                case CALL_DISCONNECT_NOTIFY:
                {
                    UNALIGNED PPTP_CALL_DISCONNECT_NOTIFY_PACKET *pPacket = 
                        (UNALIGNED PPTP_CALL_DISCONNECT_NOTIFY_PACKET*)pHeader;
                    ULONG CallId = htons(pPacket->CallId);
                                                          
                    DEBUGMSG(DBG_TUNNEL, (DTEXT("RECV CALL_DISCONNECT_NOTIFY\n")));
                    WPLOG(LL_M, LM_CMsg, ("RECV CALL_DISCONNECT_NOTIFY <- %!IPADDR!, pCtl %p, state %d, Peer's Cid %d, RC %d, EC %d",
                        pCtl->Remote.Address.Address[0].Address[0].in_addr,
                        pCtl, pCtl->State, CallId, pPacket->ResultCode, pPacket->ErrorCode));

                    if (pCtl->State==STATE_CTL_ESTABLISHED)
                    {
                        ENUM_CONTEXT Enum;
                        PCALL_SESSION pCall;
                        PLIST_ENTRY pListEntry;

                        // The peer has given us his own call ID, which does little
                        // good for fast lookup of the call.  Find the associated call.
                        REFERENCE_OBJECT_EX(pCtl, CTL_REF_ENUM);

                        InitEnumContext(&Enum);
                        while (pListEntry = EnumListEntry(&pCtl->CallList, &Enum, &pCtl->pAdapter->Lock))
                        {
                            pCall = CONTAINING_RECORD(pListEntry,
                                                      CALL_SESSION,
                                                      ListEntry);
                            if (IS_CALL(pCall) && pCall->pCtl==pCtl && pCall->Remote.CallId==CallId)
                            {
                                DBG_X(DBG_TUNNEL, htons(pPacket->CallId));
                                DBG_X(DBG_TUNNEL, pPacket->ResultCode);
                                DBG_X(DBG_TUNNEL, pPacket->ErrorCode);
                                DBG_X(DBG_TUNNEL, htons(pPacket->CauseCode));

                                CallEventCallDisconnectNotify(pCall, pPacket);
                                break;
                            }
                        }
                        EnumComplete(&Enum, &pCtl->pAdapter->Lock);
                        DEREFERENCE_OBJECT_EX(pCtl, CTL_REF_ENUM);  // pair above

                    }
                    break;
                }
                case CONTROL_STOP_REQUEST:
                {
                    DEBUGMSG(DBG_TUNNEL, (DTEXT("RECV CONTROL_STOP_REQUEST\n")));
                    WPLOG(LL_M, LM_CMsg, ("RECV CONTROL_STOP_REQUEST <- %!IPADDR!, pCtl %p, state %d",
                        pCtl->Remote.Address.Address[0].Address[0].in_addr,
                        pCtl, pCtl->State));
                                          
                    switch (pCtl->State)
                    {
                        case STATE_CTL_WAIT_STOP:
                        {
                            NdisMCancelTimer(&pCtl->StopTimeout, &TimerStopped);
                            // No break
                        }
                        case STATE_CTL_WAIT_REPLY:
                        case STATE_CTL_ESTABLISHED:
                        {
                            UNALIGNED PPTP_CONTROL_STOP_PACKET *pReply;

                            pReply = CtlAllocPacket(pCtl, CONTROL_STOP_REPLY);
                            if (pReply)
                            {
                                pReply->ResultCode = RESULT_CONTROL_STOP_SUCCESS;
                                
                                WPLOG(LL_M, LM_TUNNEL, ("SEND CONTROL_STOP_REPLY (SUCCESS) -> %!IPADDR!", 
                                    pCtl->Remote.Address.Address[0].Address[0].in_addr));
                                
                                CtlSend(pCtl, pReply);
                            }
                            CtlSetState(pCtl, STATE_CTL_CLEANUP, 0, UNLOCKED);
                            CtlCleanup(pCtl, UNLOCKED);
                            break;
                        }
                        default:
                            break;
                    }
                    break;
                }
                case CONTROL_STOP_REPLY:
                {
                    DEBUGMSG(DBG_TUNNEL, (DTEXT("RECV CONTROL_STOP_REPLY\n")));
                    WPLOG(LL_M, LM_CMsg, ("RECV CONTROL_STOP_REPLY <- %!IPADDR!, pCtl %p, state %d",
                        pCtl->Remote.Address.Address[0].Address[0].in_addr,
                        pCtl, pCtl->State));
                                          
                    if (pCtl->State==STATE_CTL_WAIT_STOP)
                    {
                        NdisMCancelTimer(&pCtl->StopTimeout, &TimerStopped);
                        CtlSetState(pCtl, STATE_CTL_CLEANUP, 0, UNLOCKED);
                        CtlCleanup(pCtl, UNLOCKED);
                    }
                    break;
                }
                case SET_LINK_INFO:
                {
                    DEBUGMSG(DBG_TUNNEL, (DTEXT("RECV SET_LINK_INFO\n")));
                    WPLOG(LL_M, LM_CMsg, ("RECV SET_LINK_INFO <- %!IPADDR!, pCtl %p",
                        pCtl->Remote.Address.Address[0].Address[0].in_addr, pCtl));
                    
                    break;
                }
                case CALL_IN_REQUEST:
                {
                    UNALIGNED PPTP_CALL_IN_REQUEST_PACKET *pPacket = 
                        (UNALIGNED PPTP_CALL_IN_REQUEST_PACKET*)pHeader;

                    DEBUGMSG(DBG_TUNNEL, (DTEXT("RECV CALL_IN_REQUEST\n")));
                    WPLOG(LL_M, LM_CMsg, ("RECV CALL_IN_REQUEST <- %!IPADDR!, pCtl %p, state %d",
                        pCtl->Remote.Address.Address[0].Address[0].in_addr,
                        pCtl, pCtl->State));

                    if (pCtl->State==STATE_CTL_ESTABLISHED)
                    {
                        DBG_X(DBG_TUNNEL, htons(pPacket->CallId));
                        DBG_X(DBG_TUNNEL, htons(pPacket->SerialNumber));
                        DBG_X(DBG_TUNNEL, htonl(pPacket->BearerType));
                        DBG_X(DBG_TUNNEL, htonl(pPacket->PhysicalChannelId));
                        DBG_X(DBG_TUNNEL, htons(pPacket->DialedNumberLength));
                        DBG_X(DBG_TUNNEL, htons(pPacket->DialingNumberLength));
                        DBG_S(DBG_TUNNEL, pPacket->DialedNumber);
                        DBG_S(DBG_TUNNEL, pPacket->DialingNumber);
                        DBG_S(DBG_TUNNEL, pPacket->Subaddress);

                        // It's possible we had just closed our last call & were
                        // waiting for a CONTROL_STOP_REQUEST from the other side.
                        NdisMCancelTimer(&pCtl->StopTimeout, &TimerStopped);
                        CallEventCallInRequest(pCtl->pAdapter,
                                               pCtl,
                                               pPacket);
                    }

                    break;
                }
                case CALL_IN_REPLY:
                    DEBUGMSG(DBG_TUNNEL, (DTEXT("RECV CALL_IN_REPLY\n")));
                    WPLOG(LL_M, LM_CMsg, ("RECV CALL_IN_REPLY <- %!IPADDR!, pCtl %p, state %d",
                        pCtl->Remote.Address.Address[0].Address[0].in_addr,
                        pCtl, pCtl->State));
                    
                    
                    // We should never get one of these.
                    break;
                case CALL_IN_CONNECTED:
                {
                    UNALIGNED PPTP_CALL_IN_CONNECT_PACKET *pPacket = 
                        (UNALIGNED PPTP_CALL_IN_CONNECT_PACKET*)pHeader;

                    DEBUGMSG(DBG_TUNNEL, (DTEXT("RECV CALL_IN_CONNECTED\n")));
                    WPLOG(LL_M, LM_CMsg, ("RECV CALL_IN_CONNECTED <- %!IPADDR!, pCtl %p, state %d",
                        pCtl->Remote.Address.Address[0].Address[0].in_addr,
                        pCtl, pCtl->State));

                    if (pCtl->State==STATE_CTL_ESTABLISHED)
                    {
                        ULONG CallId = htons(pPacket->PeerCallId);
                        PCALL_SESSION pCall;

                        DBG_X(DBG_TUNNEL, htons(pPacket->PeerCallId));
                        DBG_X(DBG_TUNNEL, htonl(pPacket->ConnectSpeed));
                        DBG_X(DBG_TUNNEL, htons(pPacket->RecvWindowSize));
                        DBG_X(DBG_TUNNEL, htons(pPacket->ProcessingDelay));
                        DBG_X(DBG_TUNNEL, htonl(pPacket->FramingType));

                        pCall = CallGetCall(pCtl->pAdapter, CallIdToDeviceId(CallId));
                        if (pCall)
                        {
                            CallEventCallInConnect(pCall, pPacket);
                        }
                    }

                    break;
                }
                case CONTROL_ECHO_REPLY:
                    DEBUGMSG(DBG_TUNNEL, (DTEXT("CONTROL_ECHO_REPLY RECEIVED\n")));
                    WPLOG(LL_V, LM_CMsg, ("RECV CONTROL_ECHO_REPLY <- %!IPADDR!",
                        pCtl->Remote.Address.Address[0].Address[0].in_addr));
                    break;
                case WAN_ERROR_NOTIFY:
                    DEBUGMSG(DBG_TUNNEL, (DTEXT("RECV WAN_ERROR_NOTIFY\n")));
                    WPLOG(LL_A, LM_CMsg, ("RECV WAN_ERROR_NOTIFY <- %!IPADDR!",
                        pCtl->Remote.Address.Address[0].Address[0].in_addr));
                    break;
                default:
                    DEBUGMSG(DBG_TUNNEL|DBG_WARN, (DTEXT("UNKNOWN RECEIVED\n")));
                    WPLOG(LL_A, LM_CMsg, ("RECV unknown message %d <- %!IPADDR!",
                        ntohs(pHeader->MessageType),
                        pCtl->Remote.Address.Address[0].Address[0].in_addr));
                    break;
            }
        }
        else // !PacketValid
        {
            Shutdown = TRUE;
            WPLOG(LL_A, LM_TUNNEL, ("RECV Invalid packet <- %!IPADDR!" \
                " NeededLength %d, Cookie 0x%0x, P-Type %d, M-Type %d",
                pCtl->Remote.Address.Address[0].Address[0].in_addr,
                NeededLength, pHeader->Cookie, pHeader->PacketType, MessageType));
        }

        if (Shutdown)
        {
            DEBUGMSG(DBG_TUNNEL|DBG_ERROR, (DTEXT("Tunnel problem, shutting it down.\n")));
            WPLOG(LL_A, LM_TUNNEL, ("Tunnel problem, shutting it down."));
            
            //CtlSetState(pCtl, STATE_CTL_CLEANUP, 0, UNLOCKED);
            //CtlCleanup(pCtl, UNLOCKED);
            
            break;
        }
    }
    DEBUGMSG(DBG_FUNC, (DTEXT("-CtlpEngine\n")));
}

NDIS_STATUS
CtlConnectQueryCallback(
    IN      PVOID               pContext,
    IN      PTRANSPORT_ADDRESS  pAddress,
    IN      HANDLE              hNewCtdi,
    OUT     PVOID               *pNewContext
    )
{
    NDIS_STATUS Status = NDIS_STATUS_SUCCESS;
    PPPTP_ADAPTER pAdapter = pContext;
    PTA_IP_ADDRESS pIp = (PTA_IP_ADDRESS)pAddress;
    PCONTROL_TUNNEL pCtl;
    BOOLEAN Accepting = TRUE;

    DEBUGMSG(DBG_FUNC, (DTEXT("+CtlConnectQueryCallback\n")));

    DEBUGMSG(DBG_TUNNEL, (DTEXT("Request to connect from %d.%d.%d.%d\n"),
                          IPADDR(pIp->Address[0].Address[0].in_addr)));
    WPLOG(LL_M, LM_TUNNEL, ("New TCP connection from %!IPADDR!, pCtdi %p",
        pIp->Address[0].Address[0].in_addr, hNewCtdi));

    if(PptpAuthenticateIncomingCalls)
    {
        ULONG i;
        BOOLEAN bMatch = FALSE;
        for (i=0; i<g_ulAcceptClientAddresses; i++)
        {
            if ((pIp->Address[0].Address[0].in_addr & g_AcceptClientList[i].Mask)==
                (g_AcceptClientList[i].Address & g_AcceptClientList[i].Mask))
            {
                bMatch = TRUE;
                break;
            }
        }
        if (!bMatch)
        {
            DEBUGMSG(DBG_TUNNEL|DBG_WARN, (DTEXT("No match found for IP %d.%d.%d.%d.  Refused.\n"),
                                IPADDR(pIp->Address[0].Address[0].in_addr)));
            WPLOG(LL_A, LM_TUNNEL, ("IP not authenticated %!IPADDR!",
                pIp->Address[0].Address[0].in_addr));
            Accepting = FALSE;
            Status = NDIS_STATUS_FAILURE;
        }
    }
                              
    if (Accepting)
    {
        pCtl = CtlAlloc(pAdapter);

        if (!pCtl)
        {
            Status = NDIS_STATUS_RESOURCES;
        }
        else
        {

            NdisAcquireSpinLock(&pAdapter->Lock);
            CtlSetState(pCtl, STATE_CTL_WAIT_REQUEST, 0, LOCKED);
            pCtl->Inbound = TRUE;
            NdisReleaseSpinLock(&pAdapter->Lock);
            NdisAcquireSpinLock(&pCtl->Lock);
            pCtl->hCtdi = hNewCtdi;
            pCtl->Remote.Address = *pIp;
            NdisMSetTimer(&pCtl->WaitTimeout, PptpMessageTimeout*1000);
            if (PptpEchoTimeout)
            {
                NdisMSetPeriodicTimer(&pCtl->Echo.Timer, PptpEchoTimeout*1000);
                pCtl->Echo.Needed = TRUE;
            }
            NdisReleaseSpinLock(&pCtl->Lock);
            *pNewContext = pCtl;
        }
    }

    DEBUGMSG(DBG_FUNC|DBG_ERR(Status), (DTEXT("-CtlConnectQueryCallback %08x\n"), Status));
    return Status;
}

NDIS_STATUS
CtlConnectCompleteCallback(
    IN      PVOID                       pContext,
    IN      HANDLE                      hNewCtdi,
    IN      NDIS_STATUS                 ConnectStatus
    )
{
    NDIS_STATUS Status = NDIS_STATUS_SUCCESS;
    PCONTROL_TUNNEL pCtl = pContext;
    PPTP_CONTROL_START_PACKET *pPacket = NULL;
    PTDI_CONNECTION_INFO pInfo;
    PTDI_ADDRESS_INFO pAddrInfo;

    DEBUGMSG(DBG_FUNC, (DTEXT("+CtlConnectCompleteCallback\n")));

    if (IS_CTL(pCtl))
    {
        if (pCtl->State!=STATE_CTL_DIALING)
        {
            DEBUGMSG(DBG_TUNNEL|DBG_ERR(Status), (DTEXT("Ctl in wrong state after connect %d\n"), pCtl->State));
            WPLOG(LL_A, LM_CMsg, ("pCtl %p in wrong state after connect %d", 
                pCtl, pCtl->State));
            CtlSetState(pCtl, STATE_CTL_CLEANUP, 0, UNLOCKED);
            CtlCleanup(pCtl, UNLOCKED);
            Status = NDIS_STATUS_FAILURE;
        }
        else if (ConnectStatus==NDIS_STATUS_SUCCESS)
        {
            pPacket = CtlAllocPacket(pCtl, CONTROL_START_REQUEST);
            CtlSetState(pCtl, STATE_CTL_WAIT_REPLY, 0, UNLOCKED);
            NdisAcquireSpinLock(&pCtl->Lock);
            pCtl->hCtdi = hNewCtdi;
            NdisMSetTimer(&pCtl->WaitTimeout, PptpMessageTimeout*1000);
            if (PptpEchoTimeout)
            {
                NdisMSetPeriodicTimer(&pCtl->Echo.Timer, PptpEchoTimeout*1000);
                pCtl->Echo.Needed = TRUE;
            }
            NdisReleaseSpinLock(&pCtl->Lock);

            WPLOG(LL_M, LM_CMsg, ("TCP connection to %!IPADDR! is UP, starting tunnel pCtl %p",
                pCtl->Remote.Address.Address[0].Address[0].in_addr,
                pCtl));
            if (pPacket)
            {
                pPacket->Version = ntohs(PPTP_PROTOCOL_VERSION_1_00);  // ToDo: do v2
                pPacket->FramingCapabilities = ntohl(FRAMING_ASYNC);
                pPacket->BearerCapabilities = ntohl(BEARER_ANALOG);
                pPacket->MaxChannels = 0;
                pPacket->FirmwareRevision = htons(PPTP_FIRMWARE_REVISION);
//                  NdisMoveMemory(pPacket->HostName, PptpHostName, MAX_HOSTNAME_LENGTH);
                NdisMoveMemory(pPacket->Vendor, PPTP_VENDOR, min(sizeof(PPTP_VENDOR), MAX_VENDOR_LENGTH));
                
                WPLOG(LL_M, LM_TUNNEL, ("SEND CONTROL_START_REQUEST -> %!IPADDR!", 
                    pCtl->Remote.Address.Address[0].Address[0].in_addr));
                
                CtlSend(pCtl, pPacket); // ToDo: return value?
            }
            else
            {
                // Allocation failure will be covered by timeout
            }
            
            pInfo = MyMemAlloc(sizeof(*pInfo), TAG_CTL_CONNINFO);
            
            if (pInfo)
            {
                REFERENCE_OBJECT_EX(pCtl, CTL_REF_QUERYCONNINFO);

                Status = CtdiQueryInformation(pCtl->hCtdi,
                                              TDI_QUERY_CONNECTION_INFO,
                                              pInfo,
                                              sizeof(*pInfo),
                                              CtlpQueryConnInfoCallback,
                                              pCtl);
                ASSERT(NT_SUCCESS(Status));
                Status = NDIS_STATUS_SUCCESS;
            }
            else
            {
                WPLOG(LL_A, LM_Res, ("Failed to alloc CTL_CONNINFO"));
            }
            
            // Query the local address                                                  
            pAddrInfo = MyMemAlloc(sizeof(*pAddrInfo)+TDI_ADDRESS_LENGTH_IP, TAG_CTL_CONNINFO);
            
            if (pAddrInfo)
            {
                REFERENCE_OBJECT_EX(pCtl, CTL_REF_QUERYADDRINFO);

                Status = CtdiQueryInformation(pCtl->hCtdi,
                                              TDI_QUERY_ADDRESS_INFO,
                                              pAddrInfo,
                                              sizeof(*pAddrInfo)+TDI_ADDRESS_LENGTH_IP,
                                              CtlpQueryAddrInfoCallback,
                                              pCtl);
                ASSERT(NT_SUCCESS(Status));
                Status = NDIS_STATUS_SUCCESS;
            }
            else
            {
                WPLOG(LL_A, LM_Res, ("Failed to alloc CTL_CONNINFO"));
            }
        }
        else
        {
            ENUM_CONTEXT Enum;
            PCALL_SESSION pCall;
            PLIST_ENTRY pListEntry;

            WPLOG(LL_A, LM_CMsg, ("TCP Connection to %!IPADDR! failed. pCtl %p NDIS Error 0x%x",
                pCtl->Remote.Address.Address[0].Address[0].in_addr,
                pCtl, ConnectStatus));

            REFERENCE_OBJECT_EX(pCtl, CTL_REF_ENUM);
            InitEnumContext(&Enum);
            while (pListEntry = EnumListEntry(&pCtl->CallList, &Enum, &pCtl->pAdapter->Lock))
            {
                pCall = CONTAINING_RECORD(pListEntry,
                                          CALL_SESSION,
                                          ListEntry);
                if (IS_CALL(pCall))
                {
                    CallEventConnectFailure(pCall, ConnectStatus);
                }
            }
            EnumComplete(&Enum, &pCtl->pAdapter->Lock);
            DEREFERENCE_OBJECT_EX(pCtl, CTL_REF_ENUM);  // pair above
            Status = NDIS_STATUS_FAILURE;
        }
        DEREFERENCE_OBJECT_EX(pCtl, CTL_REF_CONNECTCALLBACK);  // pair at call to CtdiConnect
    }
    else
    {
        Status = NDIS_STATUS_FAILURE;
        WPLOG(LL_A, LM_CMsg, ("Invalid pCtl %p", pCtl));
    }

    DEBUGMSG(DBG_FUNC|DBG_ERR(Status), (DTEXT("-CtlConnectCompleteCallback %08x\n"), Status));
    return Status;
}

NDIS_STATUS
CtlDisconnectCallback(
    IN      PVOID                       pContext,
    IN      BOOLEAN                     Abortive
    )
{
    NDIS_STATUS Status = NDIS_STATUS_SUCCESS;
    PCONTROL_TUNNEL pCtl = pContext;
    BOOLEAN Cleanup = TRUE;
    DEBUGMSG(DBG_FUNC, (DTEXT("+CtlDisconnectCallback\n")));

    WPLOG(LL_M, LM_TUNNEL, ("TCP %!IPADDR! is DOWN, pCtl %p pCtdi %p",
        pCtl->Remote.Address.Address[0].Address[0].in_addr,
        pCtl, pCtl->hCtdi));

    NdisAcquireSpinLock(&pCtl->pAdapter->Lock);

    if (pCtl->State!=STATE_CTL_CLEANUP)
    {
        CtlSetState(pCtl, STATE_CTL_CLEANUP, 0, LOCKED);
        Cleanup = TRUE;
    }
    NdisReleaseSpinLock(&pCtl->pAdapter->Lock);

    if (Cleanup)
    {
        CtlCleanup(pCtl, UNLOCKED);
    }

    DEBUGMSG(DBG_FUNC|DBG_ERR(Status), (DTEXT("-CtlDisconnectCallback %08x\n"), Status));
    return Status;
}

NDIS_STATUS
CtlReceiveCallback(
    IN      PVOID                       pContext,
    IN      PUCHAR                      pBuffer,
    IN      ULONG                       ulLength
    )
{
    NDIS_STATUS Status = NDIS_STATUS_SUCCESS;
    PCONTROL_TUNNEL pCtl = pContext;

    DEBUGMSG(DBG_FUNC, (DTEXT("+CtlReceiveCallback\n")));

    // We must copy or consume the data before leaving this function.
    ASSERT(IS_CTL(pCtl));
    CtlpEngine(pCtl, pBuffer, ulLength);

    DEBUGMSG(DBG_FUNC|DBG_ERR(Status), (DTEXT("-CtlReceiveCallback %08x\n"), Status));
    return Status;
}

NDIS_STATUS
CtlConnectCall(
    IN PPPTP_ADAPTER pAdapter,
    IN PCALL_SESSION pCall,
    IN PTA_IP_ADDRESS pTargetAddress
    )
{
    TA_IP_ADDRESS Local;
    PCONTROL_TUNNEL pCtl = NULL;
    NDIS_STATUS Status = NDIS_STATUS_SUCCESS;
    ENUM_CONTEXT Enum;
    PLIST_ENTRY pListEntry;
    BOOLEAN SignalEstablished = FALSE;
    BOOLEAN Connected = FALSE;

    DEBUGMSG(DBG_FUNC, (DTEXT("+CtlConnectCall\n")));

    DEBUGMSG(DBG_CALL, (DTEXT("New Dial request: Call:%p  Addr:%08x\n"),
                        pCall, pTargetAddress->Address[0].Address[0].in_addr));

    WPLOG(LL_M, LM_CALL, ("Dial: %!IPADDR! pCall %p",
        pTargetAddress->Address[0].Address[0].in_addr, pCall));

    InitEnumContext(&Enum);
    NdisAcquireSpinLock(&pAdapter->Lock);
    while (!Connected && (pListEntry = EnumListEntry(&pAdapter->ControlTunnelList, &Enum, NULL)))
    {
    
        pCtl = CONTAINING_RECORD(pListEntry, CONTROL_TUNNEL, ListEntry);
    
        if((pCtl->State>=STATE_CTL_DIALING && pCtl->State<=STATE_CTL_ESTABLISHED) &&
            pTargetAddress->Address[0].Address[0].in_addr==pCtl->Remote.Address.Address[0].Address[0].in_addr)
        {
            DEBUGMSG(DBG_CALL, (DTEXT("Existing tunnel found for call %08x\n"), pCall));
            WPLOG(LL_M, LM_CALL, ("Existing tunnel pCtl %p found for call %p", pCtl, pCall));
    
            REFERENCE_OBJECT_EX(pCtl, CTL_REF_CTLCONNECT);
            NdisReleaseSpinLock(&pAdapter->Lock);
            Connected = CallConnectToCtl(pCall, pCtl, FALSE);
            if (Connected)
            {
                // keep the reference for now
            }
            else
            {
                DEREFERENCE_OBJECT_EX(pCtl, CTL_REF_CTLCONNECT);
            }
            NdisAcquireSpinLock(&pAdapter->Lock);
    
            if (Connected && pCtl->State==STATE_CTL_ESTABLISHED)
            {
                SignalEstablished = TRUE;
            }
        }
    }
    EnumComplete(&Enum, NULL);
    NdisReleaseSpinLock(&pAdapter->Lock);

    if (Connected)
    {
        if (SignalEstablished)
        {
            CallEventOutboundTunnelEstablished(pCall,
                                               NDIS_STATUS_SUCCESS);
        }
        // We found an existing tunnel, for which we have a reference.  Drop it.
        if(pCtl)
        {
            DEREFERENCE_OBJECT_EX(pCtl, CTL_REF_CTLCONNECT);
        }
    }
    else
    {
        HANDLE hCtdiEndpoint;
        pCtl = CtlAlloc(pAdapter);

        if (!pCtl)
        {
            Status = NDIS_STATUS_RESOURCES;
            goto cmcDone;
        }
        
        WPLOG(LL_M, LM_CALL, ("New tunnel pCtl %p created for call %p", pCtl, pCall));

        NdisAcquireSpinLock(&pAdapter->Lock);
        CtlSetState(pCtl, STATE_CTL_DIALING, 0, LOCKED);

        pCtl->Inbound = pCall->Inbound;
        NdisReleaseSpinLock(&pAdapter->Lock);

        Connected = CallConnectToCtl(pCall, pCtl, FALSE);
        if (!Connected)
        {
            Status = NDIS_STATUS_FAILURE;
        }
        else
        {
            NdisZeroMemory(&Local, sizeof(Local));

            Local.TAAddressCount = 1;
            Local.Address[0].AddressLength = TDI_ADDRESS_LENGTH_IP;
            Local.Address[0].AddressType = TDI_ADDRESS_TYPE_IP;
            Local.Address[0].Address[0].sin_port = 0;
            Local.Address[0].Address[0].in_addr = 0;

            Status = CtdiCreateEndpoint(&hCtdiEndpoint,
                                        AF_INET,
                                        SOCK_STREAM,
                                        (PTRANSPORT_ADDRESS)&Local,
                                        0);
            if (Status!=NDIS_STATUS_SUCCESS)
            {
                DEBUGMSG(DBG_ERROR, (DTEXT("CtdiCreateEndpoint (STREAM) failed %08x\n"), Status));
                WPLOG(LL_A, LM_TUNNEL, ("CtdiCreateEndpoint (STREAM) failed %08x", Status));
                goto cmcDone;
            }

            NdisAcquireSpinLock(&pCtl->Lock);
            pCtl->hCtdiEndpoint = hCtdiEndpoint;
            pCtl->Remote.Address = *pTargetAddress;
            REFERENCE_OBJECT_EX(pCtl, CTL_REF_CONNECTCALLBACK);  // Pair in CtlConnectCompleteCallback
            NdisReleaseSpinLock(&pCtl->Lock);

            WPLOG(LL_M, LM_TUNNEL, ("Attempting to set a TCP connection pCtl %p, pCtdi %p",
                pCtl, hCtdiEndpoint));

            Status = CtdiConnect(pCtl->hCtdiEndpoint,
                                 (PTRANSPORT_ADDRESS)pTargetAddress,
                                 CtlConnectCompleteCallback,
                                 CtlReceiveCallback,
                                 CtlDisconnectCallback,
                                 pCtl);
        }
    }

cmcDone:
    if ( (Status!=NDIS_STATUS_SUCCESS && Status!=NDIS_STATUS_PENDING))
    {
        if (IS_CTL(pCtl))
        {
            WPLOG(LL_A, LM_TUNNEL, ("TCP Connection to %!IPADDR! failed immediately NDIS Error 0x%x",
                pCtl->Remote.Address.Address[0].Address[0].in_addr, Status));

            CtlSetState(pCtl, STATE_CTL_CLEANUP, 0, UNLOCKED);
            CtlCleanup(pCtl, UNLOCKED);
        }

    }
    DEBUGMSG(DBG_FUNC|DBG_ERR(Status), (DTEXT("-CtlConnectCall %08x\n"), Status));
    return Status;
}

NDIS_STATUS
CtlDisconnectCall(
    IN PCALL_SESSION pCall
    )
{
    PPPTP_ADAPTER pAdapter = pCall->pAdapter;
    PCONTROL_TUNNEL pCtl = pCall->pCtl;
    BOOLEAN Inbound = pCall->Inbound;
    BOOLEAN CloseTunnelNow = FALSE;
    NDIS_STATUS Status = NDIS_STATUS_SUCCESS;

    DEBUGMSG(DBG_FUNC, (DTEXT("+CtlDisconnectCall\n")));
    ASSERT(IS_CTL(pCtl));
    
    DEBUGMSG(DBG_CALL, (DTEXT("Call:%08x disconnected\n"), pCall));
    REFERENCE_OBJECT_EX(pCtl, CTL_REF_DISCONNECT);
    CallDisconnectFromCtl(pCall, pCtl);

    NdisAcquireSpinLock(&pAdapter->Lock);
    if (IsListEmpty(&pCtl->CallList))
    {
        if (pCtl->State==STATE_CTL_ESTABLISHED)
        {
            if (!pCtl->Inbound)
            {
                CtlSetState(pCtl, STATE_CTL_WAIT_STOP, 0, LOCKED);
                CloseTunnelNow = TRUE;
            }
            else
            {
                NdisMSetTimer(&pCtl->StopTimeout, PptpMessageTimeout*1000);
            }
        }
        else
        {
            // Tunnel is already gone.
            CtlSetState(pCtl, STATE_CTL_CLEANUP, 0, LOCKED);
            NdisReleaseSpinLock(&pAdapter->Lock);
            CtlCleanup(pCtl, UNLOCKED);
            NdisAcquireSpinLock(&pAdapter->Lock);
        }
    }
    NdisReleaseSpinLock(&pAdapter->Lock);

    if (CloseTunnelNow)
    {
        PPPTP_CONTROL_STOP_PACKET pPacket;
        pPacket = CtlAllocPacket(pCtl, CONTROL_STOP_REQUEST);

        if (!pPacket)
        {
            Status = NDIS_STATUS_RESOURCES;
            // Don't attempt to shutdown gracefully.  Just close everything.
            CtlSetState(pCtl, STATE_CTL_CLEANUP, 0, UNLOCKED);
            CtlCleanup(pCtl, UNLOCKED);
        }
        else
        {
            pPacket->Reason = CONTROL_STOP_GENERAL;
            
            WPLOG(LL_M, LM_TUNNEL, ("SEND CONTROL_STOP_REQUEST (STOP_GENERAL) -> %!IPADDR!", 
                pCtl->Remote.Address.Address[0].Address[0].in_addr));
            
            CtlSend(pCtl, pPacket);
            NdisAcquireSpinLock(&pCtl->Lock);
            NdisMSetTimer(&pCtl->StopTimeout, PptpMessageTimeout*1000);
            NdisReleaseSpinLock(&pCtl->Lock);
        }
    }

    DEREFERENCE_OBJECT_EX(pCtl, CTL_REF_DISCONNECT); // Pair above
    DEBUGMSG(DBG_FUNC|DBG_ERR(Status), (DTEXT("-CtlDisconnectCall, %08x\n"), Status));
    return Status;
}

NDIS_STATUS
CtlListen(
    IN PPPTP_ADAPTER pAdapter
    )
{
    NDIS_STATUS Status;
    TA_IP_ADDRESS Ip;

    DEBUGMSG(DBG_FUNC, (DTEXT("+CtlListen\n")));

    if (pAdapter->hCtdiListen)
    {
        // Already listening.  Bail with success.
        Status = NDIS_STATUS_SUCCESS;
        goto clDone;
    }

    NdisZeroMemory(&Ip, sizeof(Ip));
    Ip.TAAddressCount = 1;
    Ip.Address[0].AddressLength = TDI_ADDRESS_LENGTH_IP;
    Ip.Address[0].AddressType = TDI_ADDRESS_TYPE_IP;
    Ip.Address[0].Address[0].sin_port = htons(PptpControlPort);
    Ip.Address[0].Address[0].in_addr = 0;

    Status = CtdiCreateEndpoint(&pAdapter->hCtdiListen,
                                AF_INET,
                                SOCK_STREAM,
                                (PTRANSPORT_ADDRESS)&Ip,
                                0);
    if (Status!=NDIS_STATUS_SUCCESS)
    {
        DEBUGMSG(DBG_ERROR, (DTEXT("CtdiCreateEndpoint (LISTEN) failed %08x\n"), Status));
        WPLOG(LL_A, LM_TUNNEL, ("CtdiCreateEndpoint (LISTEN) failed %08x", Status));
        goto clDone;
    }

    Status = CtdiListen(pAdapter->hCtdiListen,
                        PptpListensPending,
                        CtlConnectQueryCallback,
                        CtlReceiveCallback,
                        CtlDisconnectCallback,
                        pAdapter);
    if (Status!=NDIS_STATUS_SUCCESS)
    {
        DEBUGMSG(DBG_ERROR, (DTEXT("CtdiListen failed %08x\n"), Status));
        WPLOG(LL_A, LM_TUNNEL, ("CtdiListen failed %08x", Status));
        goto clDone;
    }


clDone:
    DEBUGMSG(DBG_FUNC|DBG_ERR(Status), (DTEXT("-CtlListen %08x\n"), Status));
    return Status;
}

STATIC VOID
CtlpSendMessageComplete(
    IN      PVOID                       pContext,
    IN      PVOID                       pDatagramContext,
    IN      PUCHAR                      pBuffer,
    IN      NDIS_STATUS                 Result
    )
{
    PCONTROL_TUNNEL pCtl = pContext;

    UNREFERENCED_PARAMETER(pDatagramContext);

    DEBUGMSG(DBG_FUNC, (DTEXT("+CtlpSendMessageComplete\n")));

    ASSERT(IS_CTL(pCtl));
    
    CtlFreePacket(pCtl, pBuffer);
    
    if (Result!=NDIS_STATUS_SUCCESS)
    {
        DEBUGMSG(DBG_ERROR, (DTEXT("Failed to send control message %08x\n"), Result));
        WPLOG(LL_A, LM_TUNNEL, ("Failed to send control message %08x", Result));
        
        CtlSetState(pCtl, STATE_CTL_CLEANUP, 0, UNLOCKED);
        CtlCleanup(pCtl, UNLOCKED);
    }
    
    DEBUGMSG(DBG_FUNC, (DTEXT("-CtlpSendMessageComplete\n")));
}

NDIS_STATUS
CtlSend(
    IN PCONTROL_TUNNEL pCtl,
    IN PVOID pPacketBuffer
    )
{
    ULONG PacketLength = htons(((UNALIGNED PPTP_HEADER *)pPacketBuffer)->Length);
    NDIS_STATUS Status = NDIS_STATUS_SUCCESS;

    DEBUGMSG(DBG_FUNC, (DTEXT("+CtlSend %08x\n"), pPacketBuffer));

    ASSERT(IS_CTL(pCtl));

    DEBUGMSG(DBG_TUNNEL, (DTEXT("SENDING %s\n"),
        ControlMsgToString( htons(((UNALIGNED PPTP_HEADER *)pPacketBuffer)->MessageType))));

    Status = CtdiSend(pCtl->hCtdi,
                      CtlpSendMessageComplete,
                      pCtl,
                      pPacketBuffer,
                      PacketLength);

    if (Status==NDIS_STATUS_PENDING)
    {
        Status = NDIS_STATUS_SUCCESS;
    }
    
    if (Status!=NDIS_STATUS_SUCCESS)
    {
        gCounters.ulCtlSendFail++;
        WPLOG(LL_A, LM_TUNNEL, ("Failed with status %x", Status));
    }

    DEBUGMSG(DBG_FUNC|DBG_ERR(Status), (DTEXT("-CtlSend %08x\n"), Status));
    return Status;
}

CONTROL_STATE
CtlSetState(
    IN PCONTROL_TUNNEL pCtl,
    IN CONTROL_STATE State,
    IN ULONG_PTR StateParam,
    IN BOOLEAN Locked
    )
{
    CONTROL_STATE PreviousState;
    ASSERT(IS_CTL(pCtl));
    
    DEBUGMSG(DBG_FUNC, (DTEXT("+CtlSetState %p state %d --> %d\n"), pCtl, pCtl->State, State));
    WPLOG(LL_M, LM_TUNNEL, ("pCtl %p state %s --> %s", 
        pCtl, szCtlState(pCtl->State), szCtlState(State)));

    if (!Locked)
    {
        NdisAcquireSpinLock(&pCtl->pAdapter->Lock);
    }
    PreviousState = pCtl->State;
    pCtl->State = State;
    if (!Locked)
    {
        NdisReleaseSpinLock(&pCtl->pAdapter->Lock);
    }
    DEBUGMSG(DBG_FUNC, (DTEXT("-CtlSetState\n")));
    return PreviousState;
}

// StanA: lift some functions from L2TP to convert an IP address to text

VOID
ReversePsz(
    IN OUT CHAR* psz )

    // Reverse the order of the characters in 'psz' in place.
    //
{
    CHAR* pchLeft;
    CHAR* pchRight;

    pchLeft = psz;
    pchRight = psz + strlen( psz ) - 1;

    while (pchLeft < pchRight)
    {
        CHAR ch;

        ch = *pchLeft;
        *pchLeft++ = *pchRight;
        *pchRight-- = ch;
    }
}

VOID
ultoa(
    IN ULONG ul,
    OUT CHAR* pszBuf )

    // Convert 'ul' to null-terminated string form in caller's 'pszBuf'.  It's
    // caller job to make sure 'pszBuf' is long enough to hold the returned
    // string.
    //
{
    CHAR* pch;

    pch = pszBuf;
    do
    {
        *pch++ = (CHAR )((ul % 10) + '0');
        ul /= 10;
    }
    while (ul);

    *pch = '\0';
    ReversePsz( pszBuf );
}

PWCHAR
StringToIpAddressW(
    IN PWCHAR pszIpAddress,
    IN OUT PTA_IP_ADDRESS pAddress,
    OUT PBOOLEAN pValidAddress
    )
// Convert an address of the form #.#.#.#[:#][ \0] to a binary ip address
// [ and optional port ]
// Return a pointer to the end of the address.  If the string is determined
// to not contain an IP address, return the passed-in pszIpAddress unchanged
// ToDo: IPv6
{
    PWCHAR pStartString = pszIpAddress;
    ULONG Octet;
    ULONG NumOctets;
    ULONG IpAddress = IPADDR_ZERO;
    ULONG Port = PptpControlPort;

    *pValidAddress = FALSE;

    // Find the first digit.
    while (*pszIpAddress && (*pszIpAddress<L'0' || *pszIpAddress>L'9'))
    {
        pszIpAddress++;
    }
    if (!*pszIpAddress)
    {
        return pStartString;
    }

    for (NumOctets = 0; NumOctets<4 && *pszIpAddress; NumOctets++)
    {
        Octet = 0;
        while (*pszIpAddress && *pszIpAddress>=L'0' && *pszIpAddress<=L'9')
        {
            Octet = Octet * 10 + *pszIpAddress - L'0';
            if (Octet>0xff)
            {
                return pStartString;
            }
            pszIpAddress++;
        }
        if (NumOctets < 3)
        {
            if (*pszIpAddress!='.' || *(++pszIpAddress) < L'0' || *pszIpAddress > L'9')
            {
                return pStartString;
            }
        }
        IpAddress = (IpAddress << 8) + Octet;
    }

    if (*pszIpAddress==':')
    {
        // They've also specified the port.  Parse it.
        while (*pszIpAddress && *pszIpAddress>=L'0' && *pszIpAddress<=L'9')
        {
            Port = Port * 10 + *pszIpAddress - L'0';
            if (Port>0xffff)
            {
                return pStartString;
            }
            pszIpAddress++;
        }
    }
    
    if(IpAddress != IPADDR_ZERO && IpAddress != IPADDR_BROADCAST && !IPADDR_IS_MULTICAST(IpAddress))
    {
        pAddress->TAAddressCount = 1;
        pAddress->Address[0].AddressLength = TDI_ADDRESS_LENGTH_IP;
        pAddress->Address[0].AddressType = TDI_ADDRESS_TYPE_IP;
        pAddress->Address[0].Address[0].sin_port = htons((USHORT)Port);
        pAddress->Address[0].Address[0].in_addr = htonl(IpAddress);
    
        *pValidAddress = TRUE;
    }       

    return pszIpAddress;
}

PUCHAR
StringToIpAddress(
    IN PUCHAR pszIpAddress,
    IN OUT PTA_IP_ADDRESS pAddress,
    OUT PBOOLEAN pValidAddress
    )
// Convert an address of the form #.#.#.#[:#][ \0] to a binary ip address
// [ and optional port ]
// Return a pointer to the end of the address.  If the string is determined
// to not contain an IP address, return the passed-in pszIpAddress unchanged
// ToDo: IPv6
{
    PUCHAR pStartString = pszIpAddress;
    ULONG Octet;
    ULONG NumOctets;
    ULONG IpAddress = IPADDR_ZERO;
    ULONG Port = PptpControlPort;

    *pValidAddress = FALSE;

    // Find the first digit.
    while (*pszIpAddress && (*pszIpAddress<'0' || *pszIpAddress>'9'))
    {
        pszIpAddress++;
    }
    if (!*pszIpAddress)
    {
        return pStartString;
    }

    for (NumOctets = 0; NumOctets<4 && *pszIpAddress; NumOctets++)
    {
        Octet = 0;
        while (*pszIpAddress && *pszIpAddress>='0' && *pszIpAddress<='9')
        {
            Octet = Octet * 10 + *pszIpAddress - '0';
            if (Octet>0xff)
            {
                return pStartString;
            }
            pszIpAddress++;
        }
        if (NumOctets < 3)
        {
            if (*pszIpAddress!='.' || *(++pszIpAddress) < '0' || *pszIpAddress > '9')
            {
                return pStartString;
            }
        }
        IpAddress = (IpAddress << 8) + Octet;
    }

    if (*pszIpAddress==':')
    {
        // They've also specified the port.  Parse it.
        while (*pszIpAddress && *pszIpAddress>='0' && *pszIpAddress<='9')
        {
            Port = Port * 10 + *pszIpAddress - '0';
            if (Port>0xffff)
            {
                return pStartString;
            }
            pszIpAddress++;
        }
    }

    // Validate the IP address  
    // IpAddress in host byte order     
    if(IpAddress != IPADDR_ZERO && IpAddress != IPADDR_BROADCAST && !IPADDR_IS_MULTICAST(IpAddress))
    {
        pAddress->TAAddressCount = 1;
        pAddress->Address[0].AddressLength = TDI_ADDRESS_LENGTH_IP;
        pAddress->Address[0].AddressType = TDI_ADDRESS_TYPE_IP;
        pAddress->Address[0].Address[0].sin_port = htons((USHORT)Port);
        pAddress->Address[0].Address[0].in_addr = htonl(IpAddress);
    
        *pValidAddress = TRUE;
    }

    return pszIpAddress;
}


VOID
IpAddressToString(
    IN ULONG ulIpAddress,
    OUT CHAR* pszIpAddress )

    // Converts network byte-ordered IP addresss 'ulIpAddress' to a string in
    // the a.b.c.d form and returns same in caller's 'pszIpAddress' buffer.
    // The buffer should be at least 16 characters long.
    //
    // ToDo: IPv6
{
    CHAR szBuf[ 3 + 1 ];

    ULONG ulA = (ulIpAddress & 0xFF000000) >> 24;
    ULONG ulB = (ulIpAddress & 0x00FF0000) >> 16;
    ULONG ulC = (ulIpAddress & 0x0000FF00) >> 8;
    ULONG ulD = (ulIpAddress & 0x000000FF);

    ultoa( ulA, szBuf );
    strcpy( pszIpAddress, szBuf );
    strcat( pszIpAddress, "." );
    ultoa( ulB, szBuf );
    strcat( pszIpAddress, szBuf );
    strcat( pszIpAddress, "." );
    ultoa( ulC, szBuf );
    strcat( pszIpAddress, szBuf );
    strcat( pszIpAddress, "." );
    ultoa( ulD, szBuf );
    strcat( pszIpAddress, szBuf );
}

VOID
CtlpEchoTimeout(
    IN  PVOID       SystemSpecific1,
    IN  PVOID       pContext,
    IN  PVOID       SystemSpecific2,
    IN  PVOID       SystemSpecific3
    )
{
    PCONTROL_TUNNEL pCtl = pContext;
    PPTP_CONTROL_ECHO_REQUEST_PACKET *pPacket;
    DEBUGMSG(DBG_FUNC, (DTEXT("+CtlpEchoTimeout\n")));

    NdisAcquireSpinLock(&pCtl->Lock);
    // Don't take the adapter lock because we're only reading the State
    if (pCtl->State!=STATE_CTL_CLEANUP)
    {
        BOOLEAN DoEcho = pCtl->Echo.Needed;
        LONG Identifier = ++(pCtl->Echo.Identifier);

        pCtl->Echo.Needed = TRUE;

        NdisReleaseSpinLock(&pCtl->Lock);

        if (DoEcho)
        {
            pPacket = CtlAllocPacket(pCtl, CONTROL_ECHO_REQUEST);
            if (pPacket)
            {
                pPacket->Identifier = Identifier;

                // ToDo: deal with V2 stuff
                CtlSend(pCtl, pPacket);
            }
        }
    }
    else
    {
        NdisReleaseSpinLock(&pCtl->Lock);
    }
    DEBUGMSG(DBG_FUNC, (DTEXT("-CtlpEchoTimeout\n")));
}

VOID
CtlpDeathTimeout(
    IN  PVOID       SystemSpecific1,
    IN  PVOID       pContext,
    IN  PVOID       SystemSpecific2,
    IN  PVOID       SystemSpecific3
    )
{
    PCONTROL_TUNNEL pCtl = pContext;
    DEBUGMSG(DBG_FUNC, (DTEXT("+CtlpDeathTimeout\n")));

    WPLOG(LL_A, LM_TUNNEL, ("Fatal timeout on tunnel %!IPADDR!",
        pCtl->Remote.Address.Address[0].Address[0].in_addr));

    CtlSetState(pCtl, STATE_CTL_CLEANUP, 0, UNLOCKED);
    CtlCleanup(pCtl, UNLOCKED);

    DEBUGMSG(DBG_FUNC, (DTEXT("-CtlpDeathTimeout\n")));
}

VOID
CtlpCleanupLooseEnds(
    PPPTP_ADAPTER pAdapter
    )
{
    ENUM_CONTEXT Enum;
    PLIST_ENTRY pListEntry;
    PCONTROL_TUNNEL pCtl;
    DEBUGMSG(DBG_FUNC, (DTEXT("+CtlpCleanupLooseEnds\n")));

    NdisAcquireSpinLock(&pAdapter->Lock);
    InitEnumContext(&Enum);
    while (pListEntry = EnumListEntry(&pAdapter->ControlTunnelList, &Enum, NULL))
    {
        pCtl = CONTAINING_RECORD(pListEntry, CONTROL_TUNNEL, ListEntry);
        if (pCtl->State==STATE_CTL_CLEANUP)
        {
            // REFERENCE the Ctl so it doesn't go away before we call CtlCleanup
            REFERENCE_OBJECT_EX(pCtl, CTL_REF_CLEANUPLOOSEENDS);
            NdisReleaseSpinLock(&pAdapter->Lock);
            CtlCleanup(pCtl, UNLOCKED);
            DEREFERENCE_OBJECT_EX(pCtl, CTL_REF_CLEANUPLOOSEENDS); // Pair above
            NdisAcquireSpinLock(&pAdapter->Lock);
        }
    }
    EnumComplete(&Enum, NULL);
    NdisReleaseSpinLock(&pAdapter->Lock);
    DEBUGMSG(DBG_FUNC, (DTEXT("-CtlpCleanupLooseEnds\n")));
}

NDIS_STATUS
PptpInitialize(
    PPPTP_ADAPTER pAdapter
    )
{
    NDIS_STATUS Status;
    TA_IP_ADDRESS Local;
    HANDLE hCtdi;
    DEBUGMSG(DBG_FUNC, (DTEXT("+PptpInitialize\n")));
    
    if(!PptpClientSide)
    {
        Status = RngInit();
        if (Status!=STATUS_SUCCESS)
        {
            WPLOG(LL_A, LM_Res, ("RngInit failed %08x", Status));
            goto piDone;
        }
    }

    Status = CtdiInitialize(CTDI_FLAG_ENABLE_ROUTING|CTDI_FLAG_NETWORK_HEADER);
    if (Status!=STATUS_SUCCESS)
    {
        DEBUGMSG(DBG_ERROR, (DTEXT("CtdiInitialize failed %08x\n"), Status));
        WPLOG(LL_A, LM_TUNNEL, ("CtdiInitialize failed %08x", Status));
        goto piDone;
    }

    if (!pAdapter->hCtdiDg)
    {
        NdisZeroMemory(&Local, sizeof(Local));
        Local.TAAddressCount = 1;
        Local.Address[0].AddressLength = TDI_ADDRESS_LENGTH_IP;
        Local.Address[0].AddressType = TDI_ADDRESS_TYPE_IP;
        Local.Address[0].Address[0].sin_port = PptpProtocolNumber;
        Local.Address[0].Address[0].in_addr = 0;

        Status = CtdiCreateEndpoint(&hCtdi,
                                    AF_INET,
                                    SOCK_RAW,  //ToDo: RAWIP?
                                    (PTRANSPORT_ADDRESS)&Local,
                                    sizeof(DGRAM_CONTEXT));
        if (Status!=NDIS_STATUS_SUCCESS)
        {
            DEBUGMSG(DBG_ERROR, (DTEXT("CtdiCreateEndpoint (RAW) failed %08x\n"), Status));
            WPLOG(LL_A, LM_TUNNEL, ("CtdiCreateEndpoint (RAW) failed %08x", Status));
            goto piDone;
        }
        
        CtdiEnableIpHdrIncl(hCtdi);

        NdisAcquireSpinLock(&pAdapter->Lock);
        pAdapter->hCtdiDg = hCtdi;
        NdisReleaseSpinLock(&pAdapter->Lock);

        Status = CtdiSetEventHandler(pAdapter->hCtdiDg,
                                     TDI_EVENT_RECEIVE_DATAGRAM,
                                     CallReceiveDatagramCallback,
                                     pAdapter);
        if (Status!=NDIS_STATUS_SUCCESS)
        {
            DEBUGMSG(DBG_ERROR, (DTEXT("CtdiSetEventHandler failed %08x\n"), Status));
            WPLOG(LL_A, LM_TUNNEL, ("CtdiSetEventHandler failed %08x", Status));
            goto piDone;
        }
    }

piDone:
    if (Status==STATUS_SUCCESS)
    {
        PptpInitialized = TRUE;
    }
    DEBUGMSG(DBG_FUNC|DBG_ERR(Status), (DTEXT("-PptpInitialize %08x\n"), Status));
    return Status;
}

CHAR *pControlMessageStrings[] =
{
    "INVALID CONTROL MESSAGE NUMBER",    // 0
    "CONTROL_START_REQUEST",             // 1
    "CONTROL_START_REPLY",               // 2
    "CONTROL_STOP_REQUEST",              // 3
    "CONTROL_STOP_REPLY",                // 4
    "CONTROL_ECHO_REQUEST",              // 5
    "CONTROL_ECHO_REPLY",                // 6

    "CALL_OUT_REQUEST",                  // 7
    "CALL_OUT_REPLY",                    // 8
    "CALL_IN_REQUEST",                   // 9
    "CALL_IN_REPLY",                     // 10
    "CALL_IN_CONNECTED",                 // 11
    "CALL_CLEAR_REQUEST",                // 12
    "CALL_DISCONNECT_NOTIFY",            // 13

    "WAN_ERROR_NOTIFY",                  // 14

    "SET_LINK_INFO",                     // 15
};



CHAR *ControlMsgToString( ULONG Message )
{
    if( Message >= NUM_MESSAGE_TYPES ){
        return pControlMessageStrings[0];
    }else{
        return pControlMessageStrings[Message];
    }
}

VOID 
CtlpCleanupCtls(
    PPPTP_ADAPTER pAdapter
    )
{
    ENUM_CONTEXT Enum;
    PLIST_ENTRY pListEntry;
    PCONTROL_TUNNEL pCtl;

    NdisAcquireSpinLock(&pAdapter->Lock);
    InitEnumContext(&Enum);
    while (pListEntry = EnumListEntry(&pAdapter->ControlTunnelList, &Enum, NULL))
    {
        pCtl = CONTAINING_RECORD(pListEntry, CONTROL_TUNNEL, ListEntry);

        // REFERENCE the Ctl so it doesn't go away before we call CtlCleanup
        REFERENCE_OBJECT_EX(pCtl, CTL_REF_CLEANUPCTLS);
        NdisReleaseSpinLock(&pAdapter->Lock);
        CtlSetState(pCtl, STATE_CTL_CLEANUP, 0, UNLOCKED);
        CtlCleanup(pCtl, UNLOCKED);
        DEREFERENCE_OBJECT_EX(pCtl, CTL_REF_CLEANUPCTLS); // Pair above
        NdisAcquireSpinLock(&pAdapter->Lock);
    }
    EnumComplete(&Enum, NULL);
    NdisReleaseSpinLock(&pAdapter->Lock);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ndis\raspptp\common\debug.h ===
/*****************************************************************************
*
*   Copyright (c) 1998-1999 Microsoft Corporation
*
*   DEBUG.H - debugging macros, etc.
*
*   Author:     Stan Adermann (stana)
*
*   Created:    9/2/1998
*
*****************************************************************************/
#ifndef DEBUG_H
#define DEBUG_H

#include "dbgapi.h"

// Compile time debug flags

#ifndef MEM_CHECKING
#if DBG
#define MEM_CHECKING 1
#else
#define MEM_CHECKING 0
#endif
#endif

#ifndef LIST_CHECKING
#if DBG
#define LIST_CHECKING 1
#else
#define LIST_CHECKING 0
#endif
#endif

#ifndef LOCK_CHECKING
#define LOCK_CHECKING 0
#endif

#define DBG_ERR(Status)   (((Status)!=NDIS_STATUS_SUCCESS && (Status)!=NDIS_STATUS_PENDING)? DBG_ERROR : 0)

#define DBG_ERROR       DEBUGZONE(0)
#define DBG_WARN        DEBUGZONE(1)
#define DBG_FUNC        DEBUGZONE(2)
#define DBG_INIT        DEBUGZONE(3)

#define DBG_TX          DEBUGZONE(4)
#define DBG_RX          DEBUGZONE(5)
#define DBG_TDI         DEBUGZONE(6)
#define DBG_TUNNEL      DEBUGZONE(7)

#define DBG_CALL        DEBUGZONE(8)
#define DBG_PACKET      DEBUGZONE(9)
#define DBG_NDIS        DEBUGZONE(10)
#define DBG_TAPI        DEBUGZONE(11)

#define DBG_THREAD      DEBUGZONE(12)
#define DBG_POOL        DEBUGZONE(13)
#define DBG_REF         DEBUGZONE(14)
#define DBG_LOG         DEBUGZONE(15)


#define DBG_X(dbgs, x)  DEBUGMSG(dbgs, (DTEXT(#x"==0x%x\n"), (x)))
#define DBG_D(dbgs, d)  DEBUGMSG(dbgs, (DTEXT(#d"==%d\n"), (d)))
#define DBG_S(dbgs, s)  DEBUGMSG(dbgs, (DTEXT(#s"==\"%hs\"\n"), (s)))

#if LOCK_CHECKING
typedef struct MY_SPIN_LOCK {
    NDIS_SPIN_LOCK;
    CHAR File[12];
    ULONG Line;
} MY_SPIN_LOCK, *PMY_SPIN_LOCK;
VOID FASTCALL _MyAcquireSpinLock(PMY_SPIN_LOCK pLock, PUCHAR file, UINT line);
#define MyAcquireSpinLock(Lock) _MyAcquireSpinLock((Lock), __FILE__, __LINE__)
#define MyReleaseSpinLock(Lock) NdisReleaseSpinLock((PNDIS_SPIN_LOCK)(Lock))
#else
typedef NDIS_SPIN_LOCK MY_SPIN_LOCK, *PMY_SPIN_LOCK;
#define MyAcquireSpinLock NdisAcquireSpinLock
#define MyReleaseSpinLock NdisReleaseSpinLock
#endif

#if MEM_CHECKING
#define MyMemAlloc(size, tag) _MyMemAlloc((size), (tag), __FILE__,__LINE__)
PVOID _MyMemAlloc(UINT, ULONG, PUCHAR, UINT);
VOID InitMemory();
VOID DeinitMemory();
#else
#define InitMemory()
#define DeinitMemory()
PVOID
MyMemAlloc(UINT size, ULONG tag);
#endif

VOID
MyMemFree(
    PVOID memptr,
    UINT size);

PLIST_ENTRY FASTCALL MyInterlockedInsertHeadList(PLIST_ENTRY Head, PLIST_ENTRY Entry, PNDIS_SPIN_LOCK SpinLock);
PLIST_ENTRY FASTCALL MyInterlockedInsertTailList(PLIST_ENTRY Head, PLIST_ENTRY Entry, PNDIS_SPIN_LOCK SpinLock);
PLIST_ENTRY FASTCALL MyInterlockedRemoveHeadList(PLIST_ENTRY Head, PNDIS_SPIN_LOCK SpinLock);

#if LIST_CHECKING
VOID FASTCALL CheckList(PLIST_ENTRY ListHead);
BOOLEAN FASTCALL CheckListEntry(PLIST_ENTRY ListHead, PLIST_ENTRY Entry);
#define CheckedRemoveEntryList(Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_Flink;\
    PLIST_ENTRY _EX_Entry;\
    CheckList(Entry);\
    _EX_Entry = (Entry);\
    _EX_Flink = _EX_Entry->Flink;\
    _EX_Blink = _EX_Entry->Blink;\
    _EX_Blink->Flink = _EX_Flink;\
    _EX_Flink->Blink = _EX_Blink;\
    _EX_Entry->Flink = _EX_Entry->Blink = NULL; \
    }
#ifdef RemoveEntryList
#undef RemoveEntryList
#endif
#define RemoveEntryList CheckedRemoveEntryList

#define CheckedInsertHeadList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Flink;\
    PLIST_ENTRY _EX_ListHead;\
    CheckList(ListHead);\
    _EX_ListHead = (ListHead);\
    _EX_Flink = _EX_ListHead->Flink;\
    (Entry)->Flink = _EX_Flink;\
    (Entry)->Blink = _EX_ListHead;\
    _EX_Flink->Blink = (Entry);\
    _EX_ListHead->Flink = (Entry);\
    CheckList(ListHead);\
    }
#ifdef InsertHeadList
#undef InsertHeadList
#endif
#define InsertHeadList CheckedInsertHeadList

#define CheckedInsertTailList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_ListHead;\
    CheckList(ListHead);\
    _EX_ListHead = (ListHead);\
    _EX_Blink = _EX_ListHead->Blink;\
    (Entry)->Flink = _EX_ListHead;\
    (Entry)->Blink = _EX_Blink;\
    _EX_Blink->Flink = (Entry);\
    _EX_ListHead->Blink = (Entry);\
    CheckList(ListHead);\
    }
#ifdef InsertTailList
#undef InsertTailList
#endif
#define InsertTailList CheckedInsertTailList

#define CheckedRemoveHeadList(ListHead) \
    (ListHead)->Flink;\
    if(!IsListEmpty(ListHead)){ \
        RemoveEntryList((ListHead)->Flink);\
        CheckList(ListHead);\
    }
#ifdef RemoveHeadList
#undef RemoveHeadList
#endif
#define RemoveHeadList CheckedRemoveHeadList

#define CheckedRemoveTailList(ListHead) \
    (ListHead)->Blink;\
    if(!IsListEmpty(ListHead)){ \
        RemoveEntryList((ListHead)->Blink);\
        CheckList(ListHead);\
    }
#ifdef RemoveTailList
#undef RemoveTailList
#endif
#define RemoveTailList CheckedRemoveTailList

#else // ! LIST_CHECKING
#define CheckList(h)
#define CheckListEntry(h, e)
#endif

#define MyInterlockedRemoveEntryList(Entry, Lock)       \
    {                                                   \
        NdisAcquireSpinLock(Lock);                      \
        RemoveEntryList(Entry);                         \
        NdisReleaseSpinLock(Lock);                      \
    }

#if DBG
    char *ControlStateToString(ULONG State);
    char *CallStateToString(ULONG State);
#endif

#if DBG
#define DBGTRACE(_a) \
    if(pCall->TraceIndex < 60) \
    { \
        pCall->DbgTrace[pCall->TraceIndex] = _a; \
        ++pCall->TraceIndex; \
    }

#define DBGTRACE_INIT(_pcall) \
    NdisZeroMemory(_pcall->DbgTrace, 64); \
    _pcall->TraceIndex = 0
    
#else
#define DBGTRACE(_a)
#define DBGTRACE_INIT(_pcall)

#endif

//-----------------------------------------------------------------------------
// WPP Tracing
//-----------------------------------------------------------------------------

#define LL_A    1
#define LL_M    2
#define LL_I    3
#define LL_V    4

#define WPP_CONTROL_GUIDS \
    WPP_DEFINE_CONTROL_GUID(CtlGuid,(d58c126f, b309, 11d1, 969e, 0000f875a5bc),  \
        WPP_DEFINE_BIT(LM_Res) \
        WPP_DEFINE_BIT(LM_CMsg) \
        WPP_DEFINE_BIT(LM_TDI) \
        WPP_DEFINE_BIT(LM_TUNNEL) \
        WPP_DEFINE_BIT(LM_CALL)  \
        WPP_DEFINE_BIT(LM_PACKET) \
        WPP_DEFINE_BIT(LM_NDIS) \
        WPP_DEFINE_BIT(LM_TAPI) \
        WPP_DEFINE_BIT(LM_POOL) \
        WPP_DEFINE_BIT(LM_REF) )

#define WPP_LEVEL_FLAGS_LOGGER(lvl,flags) WPP_LEVEL_LOGGER(flags)
#define WPP_LEVEL_FLAGS_ENABLED(lvl, flags) (WPP_LEVEL_ENABLED(flags) && WPP_CONTROL(WPP_BIT_ ## flags).Level >= lvl)


#endif //DEBUG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ndis\raspptp\common\debug.c ===
/*****************************************************************************
*
*   Copyright (c) 1998-1999 Microsoft Corporation
*
*   DEBUG.C - debugging functions, etc.
*
*   Author:     Stan Adermann (stana)
*
*   Created:    9/2/1998
*
*****************************************************************************/

#include "raspptp.h"

#include "debug.tmh"

#if MEM_CHECKING
typedef struct MEM_HDR {
    LIST_ENTRY  ListEntry;
    ULONG       Size;
    CHAR        File[16];
    ULONG       Line;
} MEM_HDR;

LIST_ENTRY leAlloc;
NDIS_SPIN_LOCK slAlloc;

VOID InitMemory()
{
    NdisAllocateSpinLock(&slAlloc);
    NdisInitializeListHead(&leAlloc);
}

VOID DeinitMemory()
{
    PLIST_ENTRY ListEntry;

    NdisAcquireSpinLock(&slAlloc);
    for (ListEntry=leAlloc.Flink;
         ListEntry!=&leAlloc;
         ListEntry = ListEntry->Flink)
    {
        MEM_HDR *Hdr = (MEM_HDR*)ListEntry;
        DEBUGMSG(DBG_ERROR, (DTEXT("PPTP Unfreed Memory:%p size:%X <%s:%d>\n"),
                             &Hdr[1], Hdr->Size, Hdr->File, Hdr->Line));
        WPLOG(LL_A, LM_Res, ("PPTP Unfreed Memory:%p size:%X <%s:%d>",
            &Hdr[1], Hdr->Size, Hdr->File, Hdr->Line));
                             

    }
    NdisReleaseSpinLock(&slAlloc);
    NdisFreeSpinLock(&slAlloc);
}
#endif

#if MEM_CHECKING
PVOID
_MyMemAlloc(UINT size, ULONG tag, PUCHAR file, UINT line)
#else
PVOID
MyMemAlloc(UINT size, ULONG tag)
#endif
{
    PVOID                 memptr;
    NDIS_STATUS           status;

#if MEM_CHECKING
    status = NdisAllocateMemoryWithTag(&memptr, size+sizeof(MEM_HDR), tag);
#else
    status = NdisAllocateMemoryWithTag(&memptr, size, tag);
#endif

    if (status != NDIS_STATUS_SUCCESS)
    {
        DEBUGMSG(DBG_ERROR, (DTEXT("Memory allocation failed <%s:%d>.\n"),
                             file, line));
        WPLOG(LL_A, LM_Res, ("Memory allocation failed size %d tag %x", size, tag));
                             
        memptr = NULL;
        
        gCounters.ulMemAllocFail++;
    }
#if MEM_CHECKING
    else
    {
        MEM_HDR *Hdr = memptr;
        UINT FileNameLen = strlen(file);

        Hdr->Size = size;
        Hdr->Line = line;
        if (FileNameLen>sizeof(Hdr->File)-1)
            strcpy(Hdr->File, &file[FileNameLen-sizeof(Hdr->File)+1]);
        else
            strcpy(Hdr->File, file);
        MyInterlockedInsertHeadList(&leAlloc, &Hdr->ListEntry, &slAlloc);
        memptr = &Hdr[1];
    }
#endif

    return memptr;
}


VOID
MyMemFree(
    PVOID memptr,
    UINT size
    )
{
#if MEM_CHECKING
    PLIST_ENTRY ListEntry;
    MEM_HDR *Hdr = (MEM_HDR*)((PUCHAR)memptr-sizeof(MEM_HDR));

    NdisAcquireSpinLock(&slAlloc);
    for (ListEntry = leAlloc.Flink;
         ListEntry != &leAlloc;
         ListEntry = ListEntry->Flink)
    {
        if (ListEntry==&Hdr->ListEntry)
        {
            RemoveEntryList(&Hdr->ListEntry);
            break;
        }
    }
    if (ListEntry==&leAlloc)
    {
        DEBUGMSG(DBG_ERROR, (DTEXT("PPTP: Freeing memory not owned %p\n"), memptr));
        WPLOG(LL_A, LM_Res, ("PPTP: Freeing memory not owned %p", memptr));
    }
    NdisReleaseSpinLock(&slAlloc);

    NdisFreeMemory(Hdr, size+sizeof(MEM_HDR), 0);
#else
    NdisFreeMemory(memptr, size, 0);
#endif
}

#if LIST_CHECKING
VOID FASTCALL CheckList(PLIST_ENTRY ListHead)
{
    PLIST_ENTRY ListEntry, PrevListEntry;

    if (ListHead->Flink==ListHead)
    {
        if (ListHead->Blink!=ListHead)
        {
            DEBUGMSG(DBG_ERROR|DBG_BREAK,(DTEXT("PPTP: Corrupt list head:%p Flink:%p Blink:%p\n"), ListHead, ListHead->Flink, ListHead->Blink));
            WPLOG(LL_A, LM_Res, ("PPTP: Corrupt list head:%p Flink:%p Blink:%p", ListHead, ListHead->Flink, ListHead->Blink));
        }
    }
    else
    {
        ListEntry = ListHead;

        do
        {
            PrevListEntry = ListEntry;
            ListEntry = ListEntry->Flink;

            if (ListEntry->Blink!=PrevListEntry)
            {
                DEBUGMSG(DBG_ERROR|DBG_BREAK, (DTEXT("PPTP: Corrupt LIST_ENTRY Head:%p %p->Flink==%p %p->Blink==%p\n"),
                                              ListHead, PrevListEntry, PrevListEntry->Flink, ListEntry, ListEntry->Blink));
                WPLOG(LL_A, LM_Res, ("PPTP: Corrupt LIST_ENTRY Head:%p %p->Flink==%p %p->Blink==%p",
                                              ListHead, PrevListEntry, PrevListEntry->Flink, ListEntry, ListEntry->Blink));
            }
        } while (ListEntry!=ListHead);
    }
}

// Check if the entry exists in the list                 
BOOLEAN FASTCALL CheckListEntry(PLIST_ENTRY ListHead, PLIST_ENTRY Entry)
{
    PLIST_ENTRY ListEntry;
    
    ListEntry = ListHead->Flink;
    
    while(ListEntry != ListHead)
    {
        if(ListEntry == Entry)
        {
            return TRUE;
        }
        
        ListEntry = ListEntry->Flink;
    }
    
    return FALSE;
}

#endif


PLIST_ENTRY FASTCALL MyInterlockedInsertHeadList(PLIST_ENTRY Head, PLIST_ENTRY Entry, PNDIS_SPIN_LOCK SpinLock)
{
    PLIST_ENTRY RetVal;

    NdisAcquireSpinLock(SpinLock);
    if (IsListEmpty(Head))
        RetVal = NULL;
    else
        RetVal = Head->Flink;
    InsertHeadList(Head, Entry);
    NdisReleaseSpinLock(SpinLock);

    return RetVal;
}

PLIST_ENTRY FASTCALL MyInterlockedInsertTailList(PLIST_ENTRY Head, PLIST_ENTRY Entry, PNDIS_SPIN_LOCK SpinLock)
{
    PLIST_ENTRY RetVal;

    NdisAcquireSpinLock(SpinLock);
    if (IsListEmpty(Head))
        RetVal = NULL;
    else
        RetVal = Head->Blink;
    InsertTailList(Head, Entry);
    NdisReleaseSpinLock(SpinLock);

    return RetVal;
}

PLIST_ENTRY FASTCALL MyInterlockedRemoveHeadList(PLIST_ENTRY Head, PNDIS_SPIN_LOCK SpinLock)
{
    PLIST_ENTRY RetVal;
    NdisAcquireSpinLock(SpinLock);
    //RemoveHeadList uses RemoveEntryList, which is redefined to call CheckList in DEBUG.H
    RetVal = RemoveHeadList(Head);
    
    if (RetVal==Head)
        RetVal = NULL;
    else
        RetVal->Flink = RetVal->Blink = NULL;
    NdisReleaseSpinLock(SpinLock);

    return RetVal;
}


#define CASE_RETURN_NAME(x)   case x: return DTEXT(#x)

#ifdef DBG

char *ControlStateToString(ULONG State)
{
    switch( State ){
      CASE_RETURN_NAME(STATE_CTL_INVALID);
      CASE_RETURN_NAME(STATE_CTL_LISTEN);
      CASE_RETURN_NAME(STATE_CTL_DIALING);
      CASE_RETURN_NAME(STATE_CTL_WAIT_REQUEST);
      CASE_RETURN_NAME(STATE_CTL_WAIT_REPLY);
      CASE_RETURN_NAME(STATE_CTL_ESTABLISHED);
      CASE_RETURN_NAME(STATE_CTL_WAIT_STOP);
      CASE_RETURN_NAME(STATE_CTL_CLEANUP);
      default:
        return DTEXT("UNKNOWN CONTROL STATE");
   }    
}


char *CallStateToString(ULONG State)
{
    switch( State ){
      CASE_RETURN_NAME(STATE_CALL_INVALID);
      CASE_RETURN_NAME(STATE_CALL_CLOSED);
      CASE_RETURN_NAME(STATE_CALL_IDLE);
      CASE_RETURN_NAME(STATE_CALL_OFFHOOK);
      CASE_RETURN_NAME(STATE_CALL_OFFERING);
      CASE_RETURN_NAME(STATE_CALL_PAC_OFFERING);
      CASE_RETURN_NAME(STATE_CALL_PAC_WAIT);
      CASE_RETURN_NAME(STATE_CALL_DIALING);
      CASE_RETURN_NAME(STATE_CALL_PROCEEDING);
      CASE_RETURN_NAME(STATE_CALL_ESTABLISHED);
      CASE_RETURN_NAME(STATE_CALL_WAIT_DISCONNECT);
      CASE_RETURN_NAME(STATE_CALL_CLEANUP);
      default:
        return DTEXT("UNKNOWN CALL STATE");
    }   
}

#endif


#if LOCK_CHECKING
VOID FASTCALL
_MyAcquireSpinLock(
    PMY_SPIN_LOCK pLock,
    PUCHAR file,
    UINT line
    )
{
    UINT FileNameLen = strlen(file);
    NdisAcquireSpinLock((PNDIS_SPIN_LOCK)pLock);
    if (FileNameLen>sizeof(pLock->File)-1)
        strcpy(pLock->File, &file[FileNameLen-sizeof(pLock->File)+1]);
    else
        strcpy(pLock->File, file);
    pLock->Line = line;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ndis\raspptp\common\miniport.c ===
/*****************************************************************************
*
*   Copyright (c) 1998-1999 Microsoft Corporation
*
*   MINIPORT.C - NDIS support for PPTP
*
*   Author:     Stan Adermann (stana)
*
*   Created:    7/28/1998
*
*****************************************************************************/

#include "raspptp.h"

PPPTP_ADAPTER pgAdapter = NULL;

NDIS_OID SupportedOids[] = {
    OID_GEN_CURRENT_LOOKAHEAD,
    OID_GEN_DRIVER_VERSION,
    OID_GEN_HARDWARE_STATUS,
    OID_GEN_LINK_SPEED,
    OID_GEN_MAC_OPTIONS,
    OID_GEN_MAXIMUM_LOOKAHEAD,
    OID_GEN_MAXIMUM_FRAME_SIZE,
    OID_GEN_MAXIMUM_TOTAL_SIZE,
    OID_GEN_MEDIA_SUPPORTED,
    OID_GEN_MEDIA_IN_USE,
    OID_GEN_RCV_ERROR,
    OID_GEN_RCV_OK,
    OID_GEN_RECEIVE_BLOCK_SIZE,
    OID_GEN_RECEIVE_BUFFER_SPACE,
    OID_GEN_SUPPORTED_LIST,
    OID_GEN_TRANSMIT_BLOCK_SIZE,
    OID_GEN_TRANSMIT_BUFFER_SPACE,
    OID_GEN_VENDOR_DESCRIPTION,
    OID_GEN_VENDOR_ID,
    OID_GEN_XMIT_ERROR,
    OID_GEN_XMIT_OK,

    OID_PNP_CAPABILITIES,
    OID_PNP_SET_POWER,
    OID_PNP_QUERY_POWER,
    OID_PNP_ENABLE_WAKE_UP,

    OID_TAPI_CLOSE,
    OID_TAPI_DROP,
    OID_TAPI_GET_ADDRESS_CAPS,
    OID_TAPI_GET_CALL_INFO,
    OID_TAPI_GET_CALL_STATUS,
    OID_TAPI_GET_DEV_CAPS,
    OID_TAPI_GET_EXTENSION_ID,
    OID_TAPI_MAKE_CALL,
    OID_TAPI_NEGOTIATE_EXT_VERSION,
    OID_TAPI_OPEN,
    OID_TAPI_PROVIDER_INITIALIZE,

    OID_WAN_CURRENT_ADDRESS,
    OID_WAN_GET_BRIDGE_INFO,
    OID_WAN_GET_COMP_INFO,
    OID_WAN_GET_INFO,
    OID_WAN_GET_LINK_INFO,
    OID_WAN_GET_STATS_INFO,
    OID_WAN_HEADER_FORMAT,
    OID_WAN_LINE_COUNT,
    OID_WAN_MEDIUM_SUBTYPE,
    OID_WAN_PERMANENT_ADDRESS,
    OID_WAN_PROTOCOL_TYPE,
    OID_WAN_QUALITY_OF_SERVICE,
    OID_WAN_SET_BRIDGE_INFO,
    OID_WAN_SET_COMP_INFO,
    OID_WAN_SET_LINK_INFO
};

#if DBG
PUCHAR
GetOidString(
    NDIS_OID Oid
    )
{
    PUCHAR OidName = NULL;
    #define OID_CASE(oid) case (oid): OidName = #oid; break
    switch (Oid)
    {
        OID_CASE(OID_GEN_CURRENT_LOOKAHEAD);
        OID_CASE(OID_GEN_DRIVER_VERSION);
        OID_CASE(OID_GEN_HARDWARE_STATUS);
        OID_CASE(OID_GEN_LINK_SPEED);
        OID_CASE(OID_GEN_MAC_OPTIONS);
        OID_CASE(OID_GEN_MAXIMUM_LOOKAHEAD);
        OID_CASE(OID_GEN_MAXIMUM_FRAME_SIZE);
        OID_CASE(OID_GEN_MAXIMUM_TOTAL_SIZE);
        OID_CASE(OID_GEN_MEDIA_CONNECT_STATUS);
        OID_CASE(OID_GEN_MEDIA_SUPPORTED);
        OID_CASE(OID_GEN_MEDIA_IN_USE);
        OID_CASE(OID_GEN_RECEIVE_BLOCK_SIZE);
        OID_CASE(OID_GEN_RECEIVE_BUFFER_SPACE);
        OID_CASE(OID_GEN_SUPPORTED_GUIDS);
        OID_CASE(OID_GEN_SUPPORTED_LIST);
        OID_CASE(OID_GEN_TRANSMIT_BLOCK_SIZE);
        OID_CASE(OID_GEN_TRANSMIT_BUFFER_SPACE);
        OID_CASE(OID_GEN_VENDOR_DESCRIPTION);
        OID_CASE(OID_GEN_VENDOR_ID);
        OID_CASE(OID_PNP_CAPABILITIES);
        OID_CASE(OID_PNP_SET_POWER);
        OID_CASE(OID_PNP_QUERY_POWER);
        OID_CASE(OID_PNP_ENABLE_WAKE_UP);
        OID_CASE(OID_TAPI_ACCEPT);
        OID_CASE(OID_TAPI_ANSWER);
        OID_CASE(OID_TAPI_CLOSE);
        OID_CASE(OID_TAPI_CLOSE_CALL);
        OID_CASE(OID_TAPI_CONDITIONAL_MEDIA_DETECTION);
        OID_CASE(OID_TAPI_CONFIG_DIALOG);
        OID_CASE(OID_TAPI_DEV_SPECIFIC);
        OID_CASE(OID_TAPI_DIAL);
        OID_CASE(OID_TAPI_DROP);
        OID_CASE(OID_TAPI_GET_ADDRESS_CAPS);
        OID_CASE(OID_TAPI_GET_ADDRESS_ID);
        OID_CASE(OID_TAPI_GET_ADDRESS_STATUS);
        OID_CASE(OID_TAPI_GET_CALL_ADDRESS_ID);
        OID_CASE(OID_TAPI_GET_CALL_INFO);
        OID_CASE(OID_TAPI_GET_CALL_STATUS);
        OID_CASE(OID_TAPI_GET_DEV_CAPS);
        OID_CASE(OID_TAPI_GET_DEV_CONFIG);
        OID_CASE(OID_TAPI_GET_EXTENSION_ID);
        OID_CASE(OID_TAPI_GET_ID);
        OID_CASE(OID_TAPI_GET_LINE_DEV_STATUS);
        OID_CASE(OID_TAPI_MAKE_CALL);
        OID_CASE(OID_TAPI_NEGOTIATE_EXT_VERSION);
        OID_CASE(OID_TAPI_OPEN);
        OID_CASE(OID_TAPI_PROVIDER_INITIALIZE);
        OID_CASE(OID_TAPI_PROVIDER_SHUTDOWN);
        OID_CASE(OID_TAPI_SECURE_CALL);
        OID_CASE(OID_TAPI_SELECT_EXT_VERSION);
        OID_CASE(OID_TAPI_SEND_USER_USER_INFO);
        OID_CASE(OID_TAPI_SET_APP_SPECIFIC);
        OID_CASE(OID_TAPI_SET_CALL_PARAMS);
        OID_CASE(OID_TAPI_SET_DEFAULT_MEDIA_DETECTION);
        OID_CASE(OID_TAPI_SET_DEV_CONFIG);
        OID_CASE(OID_TAPI_SET_MEDIA_MODE);
        OID_CASE(OID_TAPI_SET_STATUS_MESSAGES);
        OID_CASE(OID_WAN_CURRENT_ADDRESS);
        OID_CASE(OID_WAN_GET_BRIDGE_INFO);
        OID_CASE(OID_WAN_GET_COMP_INFO);
        OID_CASE(OID_WAN_GET_INFO);
        OID_CASE(OID_WAN_GET_LINK_INFO);
        OID_CASE(OID_WAN_GET_STATS_INFO);
        OID_CASE(OID_WAN_HEADER_FORMAT);
        OID_CASE(OID_WAN_LINE_COUNT);
        OID_CASE(OID_WAN_MEDIUM_SUBTYPE);
        OID_CASE(OID_WAN_PERMANENT_ADDRESS);
        OID_CASE(OID_WAN_PROTOCOL_TYPE);
        OID_CASE(OID_WAN_QUALITY_OF_SERVICE);
        OID_CASE(OID_WAN_SET_BRIDGE_INFO);
        OID_CASE(OID_WAN_SET_COMP_INFO);
        OID_CASE(OID_WAN_SET_LINK_INFO);
        default:
            OidName = "Unknown OID";
            break;
    }
    return OidName;
}
#endif

STATIC NDIS_STATUS
MpReadConfig(
    NDIS_HANDLE WrapperConfigurationContext
    )
{
    NDIS_STATUS Status, ReturnStatus = NDIS_STATUS_SUCCESS;
    PNDIS_CONFIGURATION_PARAMETER Value;
    NDIS_HANDLE hConfig;

    NdisOpenConfiguration(&ReturnStatus, &hConfig, WrapperConfigurationContext);

    if (ReturnStatus==NDIS_STATUS_SUCCESS)
    {
        OsReadConfig(hConfig);
        NdisCloseConfiguration(hConfig);
    }
    
#if 0
    OsGetFullHostName();
#endif  
    
    return ReturnStatus;
}

NDIS_STATUS
MiniportInitialize(
    OUT PNDIS_STATUS OpenErrorStatus,
    OUT PUINT        SelectedMediumIndex,
    IN  PNDIS_MEDIUM MediumArray,
    IN  UINT         MediumArraySize,
    IN  NDIS_HANDLE  NdisAdapterHandle,
    IN  NDIS_HANDLE  WrapperConfigurationContext
    )
{
    ULONG i;
    NDIS_STATUS Status;
    PPPTP_ADAPTER pAdapter = NULL;

    DbgMsgInit();
    InitMemory();
    Status = MpReadConfig(WrapperConfigurationContext);
    if(Status != NDIS_STATUS_SUCCESS)
    {
        goto miDone;
    }
    
    Status = InitThreading( NdisAdapterHandle );
    if(Status != NDIS_STATUS_SUCCESS)
    {
        goto miDone;
    }

    InitCallLayer();
    
    DEBUGMSG(DBG_FUNC, (DTEXT("+MiniportInitialize\n")));

    // Find our medium

    for (i=0; i<MediumArraySize; i++)
    {
        if (MediumArray[i]==NdisMediumWan)
        {
            break;
        }
    }

    // Did we find a medium?
    if (i<MediumArraySize)
    {
        *SelectedMediumIndex = i;
    }
    else
    {
        DEBUGMSG(DBG_ERROR, (DTEXT("PPTP-ERROR: Medium not found\n")));

        Status = NDIS_STATUS_UNSUPPORTED_MEDIA;
        goto miDone;
    }

    ASSERT(!pgAdapter);
    pgAdapter = pAdapter = AdapterAlloc(NdisAdapterHandle);

    if (pAdapter==NULL)
    {
        Status = NDIS_STATUS_RESOURCES;
        goto miDone;
    }

    NdisMSetAttributesEx(NdisAdapterHandle,
                         (NDIS_HANDLE)pAdapter,
                         0,
                         NDIS_ATTRIBUTE_IGNORE_PACKET_TIMEOUT |
                         NDIS_ATTRIBUTE_IGNORE_REQUEST_TIMEOUT |
                         NDIS_ATTRIBUTE_NO_HALT_ON_SUSPEND |
                         NDIS_ATTRIBUTE_DESERIALIZE,
                         NdisInterfaceInternal
                         );

    NdisZeroMemory(&gCounters, sizeof(gCounters));
    
miDone:

    if (Status!=NDIS_STATUS_SUCCESS)
    {
        DEBUGMSG(DBG_ERROR, (DTEXT("-MiniportInitialize returning failure %x\n"), Status));

        if (pAdapter)
        {
            AdapterFree(pAdapter);
            pgAdapter = NULL;
        }
        DeinitThreading();
        DeinitMemory();
        DbgMsgUninit();
    }
    DEBUGMSG(DBG_FUNC, (DTEXT("-MiniportInitialize\n")));
    return Status;
}

VOID
MiniportHalt(
    IN NDIS_HANDLE MiniportAdapterContext
    )
{
    PPPTP_ADAPTER pAdapter = (PPPTP_ADAPTER)MiniportAdapterContext;
    ULONG i;
    DEBUGMSG(DBG_FUNC, (DTEXT("+MiniportHalt\n")));

    // There are several ways the driver can be brought down.  Check for
    // lingering calls.
    for (i=0; i<pAdapter->Info.Endpoints; i++)
    {
        PCALL_SESSION pCall = pAdapter->pCallArray[i];

        if (IS_CALL(pCall))
        {
            NdisAcquireSpinLock(&pCall->Lock);
            if (pCall->State>STATE_CALL_IDLE && pCall->State<STATE_CALL_CLEANUP)
            {
                CallSetState(pCall, STATE_CALL_CLEANUP, LINEDISCONNECTMODE_NORMAL, LOCKED);
                CallDetachFromAdapter(pCall);
                CallCleanup(pCall, LOCKED);
            }
            NdisReleaseSpinLock(&pCall->Lock);
        }
    }

    PptpAuthenticateIncomingCalls = FALSE;
    if (g_AcceptClientList)
    {
        MyMemFree(g_AcceptClientList, sizeof(CLIENT_ADDRESS)*g_ulAcceptClientAddresses);
        g_AcceptClientList = NULL;
    }
    g_ulAcceptClientAddresses = 0;
    
    if (g_TrustedClientList)
    {
        MyMemFree(g_TrustedClientList, sizeof(CLIENT_ADDRESS)*g_ulTrustedClientAddresses);
        g_TrustedClientList = NULL;
    }
    g_ulTrustedClientAddresses = 0;
    
    if (pAdapter->hCtdiDg)
    {
        CtdiClose(pAdapter->hCtdiDg);
        pAdapter->hCtdiDg = NULL;
    }

    if (pAdapter->hCtdiListen)
    {
        CtdiClose(pAdapter->hCtdiListen);
        pAdapter->hCtdiListen = NULL;
    }

    for (i=0; i<10; i++)
    {
        if (IsListEmpty(&pAdapter->ControlTunnelList))
        {
            break;
        }
        // Give the Ctl and Tdi layers a chance to clean up.
        NdisMSleep(50*1000);
    }
    
    CtdiShutdown();
    
    // Deinit FIPS                                
    if (pAdapter->pFipsFileObject) 
    {
        ObDereferenceObject(pAdapter->pFipsFileObject);
        pAdapter->pFipsFileObject = NULL;
    }
    
    AdapterFree(pAdapter);
    pgAdapter = NULL;

    DeinitThreading();
    DeinitMemory();
    DbgMsgUninit();
    DEBUGMSG(DBG_FUNC, (DTEXT("-MiniportHalt\n")));
}

NDIS_STATUS
MiniportReset(
    OUT PBOOLEAN    AddressingReset,
    IN  NDIS_HANDLE MiniportAdapterContext
    )
{
    ASSERTMSG(0,(DTEXT("MiniportReset not implemented")));
    return (NDIS_STATUS_FAILURE);
}

#ifndef WIN95_BUILD // ToDo: Win98PNP
NDIS_PNP_CAPABILITIES PnpCaps =
{
    0, // Flags
    {
        NdisDeviceStateUnspecified,
        NdisDeviceStateUnspecified,
        NdisDeviceStateUnspecified
    }
};
#endif

// CHECK_TAPI_SIZE forces the internal tapi size values to conform to the size
// passed in the MiniportQueryInformation call
#define CHECK_TAPI_SIZE(ptr, size, type1, struct2) \
        (((size)>=sizeof(type1)) &&                \
        ((((type1 *)(ptr))->struct2.ulTotalSize)=(size)-FIELD_OFFSET(type1, struct2)))

#define TAPI_USED_SIZE(ptr, type1, struct2) \
        (((type1 *)(ptr))->struct2.ulUsedSize+FIELD_OFFSET(type1, struct2))

#define TAPI_NEEDED_SIZE(ptr, type1, struct2) \
        (((type1 *)(ptr))->struct2.ulNeededSize+FIELD_OFFSET(type1, struct2))

// Repeated code, make a macro
#define HANDLE_TAPI_OID(type1, struct2, TapiFunc)                       \
        {                                                               \
            DoCopy = FALSE;                                             \
            if (CHECK_TAPI_SIZE(InformationBuffer,                      \
                                InformationBufferLength,                \
                                type1,                                  \
                                struct2))                               \
            {                                                           \
                Status = TapiFunc(pAdapter, InformationBuffer);         \
                UsedLength = TAPI_USED_SIZE(InformationBuffer,          \
                                            type1,                      \
                                            struct2);                   \
                NeededLength = TAPI_NEEDED_SIZE(InformationBuffer,      \
                                                type1,                  \
                                                struct2);               \
                if (NeededLength>UsedLength)                            \
                {                                                       \
                    PartialReturn = TRUE;                               \
                }                                                       \
            }                                                           \
            else                                                        \
            {                                                           \
                UsedLength = sizeof(type1);                             \
            }                                                           \
        }

NDIS_STATUS
MiniportQueryInformation(
    IN NDIS_HANDLE MiniportAdapterContext,
    IN NDIS_OID Oid,
    IN PVOID InformationBuffer,
    IN ULONG InformationBufferLength,
    OUT PULONG BytesWritten,
    OUT PULONG BytesNeeded
    )
{
    PPPTP_ADAPTER pAdapter = (PPPTP_ADAPTER)MiniportAdapterContext;
    NDIS_STATUS Status = NDIS_STATUS_SUCCESS;
    ULONG_PTR GenericUlong = 0;
    PVOID SourceBuffer = (PVOID) &GenericUlong;
    ULONG UsedLength = sizeof(ULONG);
    ULONG NeededLength = 0;        // Used when returning part of all required info
    BOOLEAN DoCopy = TRUE;
    BOOLEAN PartialReturn = FALSE;

    UCHAR PptpWanAddress[6] = {'P','P','T','P','0','0'};  // This is the address returned by OID_WAN_*_ADDRESS.

    DEBUGMSG(DBG_FUNC|DBG_NDIS, (DTEXT("+MiniportQueryInformation Oid==0x%08X %hs\n"),
                                 Oid, GetOidString(Oid)));

    switch (Oid)
    {
        case OID_GEN_MAC_OPTIONS:
        {
            // Believe these to be pretty much ignored.
            GenericUlong = NDIS_MAC_OPTION_RECEIVE_SERIALIZED |
                           NDIS_MAC_OPTION_TRANSFERS_NOT_PEND;
            break;
        }
        case OID_GEN_MAXIMUM_LOOKAHEAD:
        {
            GenericUlong = PPTP_MAX_LOOKAHEAD;
            break;
        }
        case OID_GEN_SUPPORTED_LIST:
        {
            SourceBuffer = (PVOID) SupportedOids;
            UsedLength = sizeof(SupportedOids);
            break;
        }

        case OID_GEN_RCV_ERROR:
        {
            GenericUlong = gCounters.PacketsRejected + gCounters.PacketsMissed;
            break;
        }

        case OID_GEN_RCV_OK:
        {
            GenericUlong = gCounters.PacketsReceived;
            break;
        }

        case OID_GEN_XMIT_ERROR:
        {
            GenericUlong = gCounters.PacketsSentError;
            break;
        }

        case OID_GEN_XMIT_OK:
        {
            GenericUlong = gCounters.PacketsSent - gCounters.PacketsSentError;
            break;
        }

        case OID_TAPI_GET_ADDRESS_CAPS:
        {
            HANDLE_TAPI_OID(NDIS_TAPI_GET_ADDRESS_CAPS,
                            LineAddressCaps,
                            TapiGetAddressCaps);
            break;
        }

        case OID_TAPI_GET_CALL_INFO:
        {
            // If the buffer isn't large enough at all, the size of all the
            // data including strings is returned. If the buffer is big enough
            // for the data structure but not the strings, then only the data
            // structure is returned.

            // Get the length needed, including strings
            NeededLength = 0;
            Status = TapiGetCallInfo(pAdapter, InformationBuffer, &NeededLength);
            UsedLength = NeededLength;
            if( Status == NDIS_STATUS_SUCCESS )
            {
                if (sizeof(NDIS_TAPI_GET_CALL_INFO)<=InformationBufferLength)
                {
                    if( NeededLength > InformationBufferLength )
                    {
                        UsedLength = sizeof(NDIS_TAPI_GET_CALL_INFO);
                        PartialReturn = TRUE;
                    }else{
                        // Used=Needed = the entire thing inluding strings
                    }

                    Status = TapiGetCallInfo(pAdapter,
                                             InformationBuffer,
                                             NULL);
                    // NULL in the second call makes it fill in the structure,
                    // which it doesn't do on the first call.
                }
            }
            DoCopy = FALSE;
            break;
        }

        case OID_TAPI_GET_CALL_STATUS:
        {
            HANDLE_TAPI_OID(NDIS_TAPI_GET_CALL_STATUS,
                            LineCallStatus,
                            TapiGetCallStatus);
            break;
        }

        case OID_TAPI_GET_DEV_CAPS:
        {
            HANDLE_TAPI_OID(NDIS_TAPI_GET_DEV_CAPS,
                            LineDevCaps,
                            TapiGetDevCaps);
            if (NeededLength < TAPI_DEV_CAPS_SIZE)
            {
                NeededLength = TAPI_DEV_CAPS_SIZE;
            }
            break;
        }

        case OID_TAPI_GET_ID:
        {
            PNDIS_TAPI_GET_ID pRequest = (PNDIS_TAPI_GET_ID)InformationBuffer;
            UsedLength = sizeof(NDIS_TAPI_GET_ID);
                         
            if (UsedLength<=InformationBufferLength)
            {
                if(pRequest->ulDeviceClassOffset < sizeof(NDIS_TAPI_GET_ID) ||
                    pRequest->ulDeviceClassOffset >= InformationBufferLength ||
                    pRequest->ulDeviceClassSize > InformationBufferLength - pRequest->ulDeviceClassOffset)
                {
                    Status = NDIS_STATUS_FAILURE;
                    break;
                }
                
                HANDLE_TAPI_OID(NDIS_TAPI_GET_ID,
                                DeviceID,
                                TapiGetId);
            }
            
            break;
        }

        case OID_TAPI_GET_ADDRESS_STATUS:
        {
            HANDLE_TAPI_OID(NDIS_TAPI_GET_ADDRESS_STATUS,
                            LineAddressStatus,
                            TapiGetAddressStatus);
            break;
        }

        case OID_TAPI_GET_EXTENSION_ID:
        {
            UsedLength = sizeof(NDIS_TAPI_GET_EXTENSION_ID);
            if (UsedLength<=InformationBufferLength)
            {
                DoCopy = FALSE;
                Status = TapiGetExtensionId(pAdapter, InformationBuffer);
            }
            break;
        }

        case OID_TAPI_MAKE_CALL:
        {
            PNDIS_TAPI_MAKE_CALL pRequest = (PNDIS_TAPI_MAKE_CALL)InformationBuffer;
            UsedLength = sizeof(NDIS_TAPI_MAKE_CALL);

            if (UsedLength<=InformationBufferLength)
            {
                if (pRequest->ulDestAddressSize < 2 ||
                    pRequest->ulDestAddressOffset < sizeof(NDIS_TAPI_MAKE_CALL) ||
                    pRequest->ulDestAddressOffset >= InformationBufferLength ||
                    pRequest->ulDestAddressSize > InformationBufferLength - pRequest->ulDestAddressOffset)
                {
                    // Bogus input data
                    DBG_D(DBG_ERROR, pRequest->ulDestAddressOffset);
                    Status = NDIS_STATUS_FAILURE;
                }
                else
                {
                    UsedLength = pRequest->ulDestAddressSize + pRequest->ulDestAddressOffset;
                }
                
                if (Status == NDIS_STATUS_SUCCESS)
                {
                    DoCopy = FALSE;
                    Status = TapiMakeCall(pAdapter, InformationBuffer);
                }
            }
            break;
        }

        case OID_TAPI_NEGOTIATE_EXT_VERSION:
        {
            UsedLength = sizeof(NDIS_TAPI_NEGOTIATE_EXT_VERSION);
            if (UsedLength<=InformationBufferLength)
            {
                DoCopy = FALSE;
                Status = TapiNegotiateExtVersion(pAdapter, InformationBuffer);
            }
            break;
        }

        case OID_TAPI_OPEN:
        {
            UsedLength = sizeof(NDIS_TAPI_OPEN);
            if (UsedLength<=InformationBufferLength)
            {
                DoCopy = FALSE;
                Status = TapiOpen(pAdapter, InformationBuffer);
            }
            break;
        }

        case OID_TAPI_PROVIDER_INITIALIZE:
        {
            UsedLength = sizeof(NDIS_TAPI_PROVIDER_INITIALIZE);
            if (UsedLength<=InformationBufferLength)
            {
                DoCopy = FALSE;
                Status = TapiProviderInitialize(pAdapter, InformationBuffer);
            }
            break;
        }

        case OID_WAN_GET_INFO:
        {
            SourceBuffer = &pAdapter->Info;
            UsedLength = sizeof(pAdapter->Info);
            break;
        }
        case OID_WAN_MEDIUM_SUBTYPE:
        {
            GenericUlong = OS_SPECIFIC_NDIS_WAN_MEDIUM_TYPE;
            break;
        }
        case OID_WAN_CURRENT_ADDRESS:
        case OID_WAN_PERMANENT_ADDRESS:
        {
            SourceBuffer = PptpWanAddress;
            UsedLength = sizeof(PptpWanAddress);
            break;
        }

#ifndef WIN95_BUILD // ToDo: Win98PNP
        case OID_PNP_CAPABILITIES:
        {
            SourceBuffer = &PnpCaps;
            UsedLength = sizeof(PnpCaps);
            break;
        }
#endif
        case OID_PNP_SET_POWER:
            // Just success
            break;

        case OID_PNP_QUERY_POWER:
            // Just success
            break;

        case OID_PNP_ENABLE_WAKE_UP:
            // Just success
            break;


        case OID_GEN_CURRENT_LOOKAHEAD:
        case OID_GEN_DRIVER_VERSION:
        case OID_GEN_HARDWARE_STATUS:
        case OID_GEN_LINK_SPEED:
        case OID_GEN_MAXIMUM_FRAME_SIZE:
        case OID_GEN_MAXIMUM_TOTAL_SIZE:
        case OID_GEN_MEDIA_SUPPORTED:
        case OID_GEN_MEDIA_IN_USE:
        case OID_GEN_RECEIVE_BLOCK_SIZE:
        case OID_GEN_RECEIVE_BUFFER_SPACE:
        case OID_GEN_TRANSMIT_BLOCK_SIZE:
        case OID_GEN_TRANSMIT_BUFFER_SPACE:
        case OID_GEN_VENDOR_DESCRIPTION:
        case OID_GEN_VENDOR_ID:

        case OID_WAN_GET_BRIDGE_INFO:
        case OID_WAN_GET_LINK_INFO:
        case OID_WAN_GET_STATS_INFO:
        case OID_WAN_HEADER_FORMAT:
        case OID_WAN_LINE_COUNT:
        case OID_WAN_PROTOCOL_TYPE:
        case OID_WAN_QUALITY_OF_SERVICE:
        case OID_WAN_SET_BRIDGE_INFO:
        case OID_WAN_SET_COMP_INFO:
        case OID_WAN_SET_LINK_INFO:
            DEBUGMSG(DBG_ERROR, (DTEXT("OID Not Implemented %hs\n"), GetOidString(Oid)));
        case OID_WAN_GET_COMP_INFO:  // never supported
        default:
        {
            UsedLength = NeededLength = 0;
            Status = NDIS_STATUS_NOT_SUPPORTED;
            break;
        }
    }

    if (!PartialReturn)
    {
        NeededLength = UsedLength;
    }

    if (Status == NDIS_STATUS_SUCCESS || Status == NDIS_STATUS_PENDING)
    {
        if (InformationBufferLength < UsedLength)
        {
            Status = NDIS_STATUS_INVALID_LENGTH;
            *BytesNeeded = UsedLength;
        }
        else
        {
            *BytesNeeded = NeededLength;
            *BytesWritten = UsedLength;
            if (DoCopy)
            {
                NdisMoveMemory(InformationBuffer, SourceBuffer, UsedLength);
            }
        }
    }

    DEBUGMSG(DBG_FUNC|DBG_ERR(Status), (DTEXT("-MiniportQueryInformation %08X\n"), Status));
    return Status;
}

NDIS_STATUS
MiniportSetInformation(
   IN NDIS_HANDLE MiniportAdapterContext,
   IN NDIS_OID Oid,
   IN PVOID InformationBuffer,
   IN ULONG InformationBufferLength,
   OUT PULONG BytesRead,
   OUT PULONG BytesNeeded
   )
{
    PPPTP_ADAPTER pAdapter = (PPPTP_ADAPTER)MiniportAdapterContext;
    NDIS_STATUS Status = NDIS_STATUS_SUCCESS;
    ULONG_PTR GenericUlong = 0;
    ULONG UsedLength = sizeof(ULONG);

    DEBUGMSG(DBG_FUNC|DBG_NDIS, (DTEXT("+MiniportSetInformation Oid==0x%08X %hs\n"),
                                 Oid, GetOidString(Oid)));

    switch (Oid)
    {
        case OID_TAPI_ANSWER:
        {
            UsedLength = sizeof(NDIS_TAPI_ANSWER);
            if (UsedLength<=InformationBufferLength)
            {
                Status = TapiAnswer(pAdapter, InformationBuffer);
            }
            break;
        }

        case OID_TAPI_CLOSE:
        {
            UsedLength = sizeof(NDIS_TAPI_CLOSE);
            if (UsedLength<=InformationBufferLength)
            {
                Status = TapiClose(pAdapter, InformationBuffer);
            }
            break;
        }

        case OID_TAPI_CLOSE_CALL:
        {
            UsedLength = sizeof(NDIS_TAPI_CLOSE_CALL);
            if (UsedLength<=InformationBufferLength)
            {
                Status = TapiCloseCall(pAdapter, InformationBuffer);
            }
            break;
        }

        case OID_TAPI_DROP:
        {
            UsedLength = sizeof(NDIS_TAPI_DROP);
            if (UsedLength<=InformationBufferLength)
            {
                // We don't use the UserUserInfo
                Status = TapiDrop(pAdapter, InformationBuffer);
            }
            break;
        }

        case OID_TAPI_PROVIDER_SHUTDOWN:
        {
            UsedLength = sizeof(NDIS_TAPI_PROVIDER_SHUTDOWN);
            if (UsedLength<=InformationBufferLength)
            {
                // We don't use the UserUserInfo
                Status = TapiProviderShutdown(pAdapter, InformationBuffer);
            }
            break;
        }

        case OID_TAPI_SET_DEFAULT_MEDIA_DETECTION:
        {
            UsedLength = sizeof(NDIS_TAPI_SET_DEFAULT_MEDIA_DETECTION);
            if (UsedLength<=InformationBufferLength)
            {
                Status = TapiSetDefaultMediaDetection(pAdapter, InformationBuffer);
            }
            break;
        }

        case OID_TAPI_SET_STATUS_MESSAGES:
        {
            UsedLength = sizeof(NDIS_TAPI_SET_STATUS_MESSAGES);
            if (UsedLength<=InformationBufferLength)
            {
                Status = TapiSetStatusMessages(pAdapter, InformationBuffer);
            }
            break;
        }

        case OID_WAN_SET_LINK_INFO:
        {
            UsedLength = sizeof(NDIS_WAN_SET_LINK_INFO);
            if (UsedLength<=InformationBufferLength)
            {
                Status = CallSetLinkInfo(pAdapter, InformationBuffer);
            }
            break;
        }

        case OID_PNP_SET_POWER:
        case OID_PNP_ENABLE_WAKE_UP:
            UsedLength = 0;
            // Success
            break;

        default:
            DEBUGMSG(DBG_ERROR, (DTEXT("SetInformation OID Not Implemented %hs\n"), GetOidString(Oid)));
            // No break
        case OID_TAPI_ACCEPT:
            Status = NDIS_STATUS_INVALID_OID;
            break;
    }

    *BytesNeeded = UsedLength;
    if (Status==NDIS_STATUS_SUCCESS || Status == NDIS_STATUS_PENDING)
    {
        if (UsedLength>InformationBufferLength)
        {
            *BytesRead = 0;
            Status = NDIS_STATUS_INVALID_LENGTH;
        }
        else
        {
            *BytesRead = UsedLength;
        }
    }

    DEBUGMSG(DBG_FUNC|DBG_ERR(Status), (DTEXT("-MiniportSetInformation %08X\n"), Status));
    return Status;
}

NDIS_STATUS
MiniportWanSend(
   IN NDIS_HANDLE MiniportAdapterContext,
   IN NDIS_HANDLE NdisLinkHandle,
   IN PNDIS_WAN_PACKET WanPacket
   )
{
    PPPTP_ADAPTER pAdapter = (PPPTP_ADAPTER)MiniportAdapterContext;
    PCALL_SESSION pCall;
    NDIS_STATUS Status = NDIS_STATUS_SUCCESS;

    DEBUGMSG(DBG_FUNC, (DTEXT("+MiniportWanSend NdisLinkHandle=%x, WanPacket=%x\n"),
                NdisLinkHandle, WanPacket));

    pCall = CallGetCall(pAdapter, LinkHandleToId(NdisLinkHandle));
    if (!IS_CALL(pCall) || pCall->State!=STATE_CALL_ESTABLISHED)
    {
        // Just say success, don't send.
        goto mwsDone;
    }

    DEBUGMSG(DBG_TX, (DTEXT("TxPacket: %08x  Call: %08x\n"), WanPacket, pCall));

    REFERENCE_OBJECT(pCall);
    Status = CallQueueTransmitPacket(pCall, WanPacket);

    if (Status!=NDIS_STATUS_PENDING)
    {
        DEREFERENCE_OBJECT(pCall);
    }

mwsDone:
    DEBUGMSG(DBG_FUNC|DBG_ERR(Status), (DTEXT("-MiniportWanSend %08x\n"), Status));
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ndis\raspptp\common\ctdi.h ===
/*****************************************************************************
*
*   Copyright (c) 1998-1999 Microsoft Corporation
*
*   CTDI.H - Common TDI API and data types.
*
*   Author:     Stan Adermann (stana)
*
*   Created:    8/4/1998
*
*****************************************************************************/

#ifndef CTDI_H
#define CTDI_H

#include "ctdios.h"

#define CTDI_FLAG_ENABLE_ROUTING        0x00000001
#define CTDI_FLAG_NETWORK_HEADER        0x00000002
#define IPADDR(x) (x & 0x000000ff),((x>>8) & 0x000000ff), ((x>>16) & 0x000000ff), ((x>>24) & 0x000000ff)


typedef NDIS_STATUS
(*CTDI_EVENT_DISCONNECT)(
    IN      PVOID                       pContext,
    IN      BOOLEAN                     Abortive
    );

typedef NDIS_STATUS
(*CTDI_EVENT_CONNECT_QUERY)(
    IN      PVOID                       pContext,
    IN      PTRANSPORT_ADDRESS          pAddress,
    IN      HANDLE                      hNewCtdi,
    OUT     PVOID                      *pNewContext
    );

typedef NDIS_STATUS
(*CTDI_EVENT_CONNECT_COMPLETE)(
    IN      PVOID                       pContext,
    IN      HANDLE                      hNewCtdi,
    IN      NDIS_STATUS                 ConnectStatus
    );

typedef NDIS_STATUS
(*CTDI_EVENT_RECEIVE)(
    IN      PVOID                       pContext,
    IN      PUCHAR                      pBuffer,
    IN      ULONG                       ulLength
    );

typedef NDIS_STATUS
(*CTDI_EVENT_RECEIVE_DATAGRAM)(
    IN      PVOID                       pContext,
    IN      PTRANSPORT_ADDRESS          pAddress,
    IN      PUCHAR                      pBuffer,
    IN      ULONG                       ulLength
    );

typedef VOID
(*CTDI_EVENT_SEND_COMPLETE)(
    IN      PVOID                       pContext,
    IN      PVOID                       pDatagramContext,
    IN      PUCHAR                      pBuffer,
    IN      NDIS_STATUS                 Result
    );

typedef VOID
(*CTDI_EVENT_QUERY_COMPLETE)(
    IN      PVOID                       pContext,
    IN      PVOID                       pData,
    IN      NDIS_STATUS                 Result
    );

typedef VOID
(*CTDI_EVENT_SET_COMPLETE)(
    IN      PVOID                       pContext,
    IN      PVOID                       pData,
    IN      NDIS_STATUS                 Result
    );

NDIS_STATUS
CtdiInitialize(
    IN      ULONG                       ulFlags
    );

NDIS_STATUS
CtdiClose(
    IN      HANDLE                      hCtdi
    );

NDIS_STATUS
CtdiListen(
    IN      HANDLE                      hCtdi,
    IN      ULONG_PTR                   NumListen,
    IN      CTDI_EVENT_CONNECT_QUERY    pConnectQueryHandler,
    IN      CTDI_EVENT_RECEIVE          pReceiveHandler,
    IN      CTDI_EVENT_DISCONNECT       pDisconnectHandler,
    IN      PVOID                       pContext
    );

NDIS_STATUS
CtdiConnect(
    IN      HANDLE                      hCtdi,
    IN      PTRANSPORT_ADDRESS          pAddress,
    IN      CTDI_EVENT_CONNECT_COMPLETE pConnectCompleteHandler,
    IN      CTDI_EVENT_RECEIVE          pReceiveHandler,
    IN      CTDI_EVENT_DISCONNECT       pDisconnectHandler,
    IN      PVOID                       pContext
    );

NDIS_STATUS
CtdiDisconnect(
    IN      HANDLE                      hCtdi,
    IN      BOOLEAN                     Abort
    );

NDIS_STATUS
CtdiReceiveComplete(
    IN      HANDLE                      hCtdi,
    IN      PUCHAR                      pBuffer
    );

NDIS_STATUS
CtdiSend(
    IN      HANDLE                      hCtdi,
    IN      CTDI_EVENT_SEND_COMPLETE    pSendCompleteHandler,
    IN      PVOID                       pContext,
    IN      PVOID                       pvBuffer,
    IN      ULONG                       ulLength
    );

NDIS_STATUS
CtdiSendDatagram(
    IN      HANDLE                      hCtdi,
    IN      CTDI_EVENT_SEND_COMPLETE    pSendCompleteHandler,
    IN      PVOID                       pContext,
    IN      PVOID                       pDatagramContext,
    IN      PTRANSPORT_ADDRESS          pDestination,
    IN      PUCHAR                      pBuffer,
    IN      ULONG                       ulLength
    );

NDIS_STATUS
CtdiCreateEndpoint(
    OUT     PHANDLE                     phCtdi,
    IN      ULONG_PTR                   ulAddressFamily,
    IN      ULONG_PTR                   ulType,
    IN      PTRANSPORT_ADDRESS          pAddress,
    IN      ULONG_PTR                   ulRxPadding
    );

NDIS_STATUS
CtdiSetEventHandler(
    IN      HANDLE                      hCtdi,
    IN      ULONG                       ulEventType,
    IN      PVOID                       pEventHandler,
    IN      PVOID                       pContext
    );

NDIS_STATUS
CtdiSetInformation(
    IN      HANDLE                      hCtdi,
    IN      ULONG_PTR                   ulSetType,
    IN      PTDI_CONNECTION_INFORMATION pConnectionInformation,
    IN      CTDI_EVENT_SET_COMPLETE     pSetCompleteHandler,
    IN      PVOID                       pContext
    );

NDIS_STATUS
CtdiQueryInformation(
    IN      HANDLE                      hCtdi,
    IN      ULONG                       ulQueryType,
    IN OUT  PVOID                       pBuffer,
    IN      ULONG                       Length,
    IN      CTDI_EVENT_QUERY_COMPLETE   pQueryCompleteHandler,
    IN      PVOID                       pContext
    );

VOID CtdiShutdown();

VOID CtdiSetRequestPending(
    IN      HANDLE                      hCtdi
    );
    
VOID CtdiEnableIpHdrIncl(
    IN  HANDLE  hCtdi);

#endif // CTDI_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ndis\raspptp\common\protocol.h ===
/*****************************************************************************
*
*   Copyright (c) 1998-1999 Microsoft Corporation
*
*   PROTOCOL.H - PPTP and GRE Protocol data types and constants
*
*   Author:     Stan Adermann (stana)
*
*   Created:    7/23/1998
*
*****************************************************************************/

#ifndef PROTOCOL_H
#define PROTOCOL_H

/* IP ----------------------------------------------------------------------*/

#define IP_VERSION              0x40

typedef struct {
    UCHAR       iph_verlen;             // Version and length.
    UCHAR       iph_tos;                // Type of service.
    USHORT      iph_length;             // Total length of datagram.
    USHORT      iph_id;                 // Identification.
    USHORT      iph_offset;             // Flags and fragment offset.
    UCHAR       iph_ttl;                // Time to live.
    UCHAR       iph_protocol;           // Protocol.
    USHORT      iph_xsum;               // Header checksum.
    ULONG       iph_src;                // Source address.
    ULONG       iph_dest;               // Destination address.
} IP4_HEADER, *PIP4_HEADER;

/* GRE ---------------------------------------------------------------------*/

typedef struct {
    UCHAR           RecursionControl            : 3;
    UCHAR           StrictSourceRoutePresent    : 1;
    UCHAR           SequenceNumberPresent       : 1;
    UCHAR           KeyPresent                  : 1;
    UCHAR           RoutingPresent              : 1;
    UCHAR           ChecksumPresent             : 1;
    UCHAR           Version                     : 3;
    UCHAR           Flags                       : 4;
    UCHAR           AckSequenceNumberPresent    : 1;

    USHORT          ProtocolType;

#define     GRE_PROTOCOL_TYPE           0x880B
#define     GRE_PROTOCOL_TYPE_NS        0x0B88

    USHORT          KeyLength;
    USHORT          KeyCallId;
} GRE_HEADER, *PGRE_HEADER;

#define GreSequence(g) (*(PULONG)(((PUCHAR)(g)) + sizeof(GRE_HEADER)))
#define GreAckSequence(g)                                                       \
    ((g)->SequenceNumberPresent ?                                               \
        (*(PULONG)(((PUCHAR)(g)) + sizeof(GRE_HEADER) + sizeof(ULONG))) :       \
        GreSequence(g))

/* PPTP --------------------------------------------------------------------*/

#define PPTP_TCP_PORT                           1723
#define PPTP_IP_GRE_PROTOCOL                    47
#define PPTP_PROTOCOL_VERSION_1_00              0x100
#define PPTP_PROTOCOL_SECURE_VERSION            0x200
#define PPTP_MAGIC_COOKIE                       0x1A2B3C4D

// host byte order        
#define IPADDR_ZERO                             0
#define IPADDR_BROADCAST                        0xffffffff
#define IPADDR_IS_MULTICAST(_addr)              (((_addr) & 0xf0000000) == 0xe0000000)

#define MAX_HOSTNAME_LENGTH                     64
#define MAX_VENDOR_LENGTH                       64
#define MAX_PHONE_NUMBER_LENGTH                 64
#define MAX_SUBADDRESS_LENGTH                   64
#define MAX_CALL_STATS_LENGTH                   128

#define PPTP_MAX_PACKET_SIZE                    1532
#define PPTP_MAX_LOOKAHEAD                      PPTP_MAX_PACKET_SIZE
#define PPTP_MAX_TRANSMIT                       32
#define PPTP_MAX_RECEIVE_SIZE                   (1614+20+12+8) // To allow for PPP padding, etc.

#define PPTP_RECV_WINDOW                        64

#define PPTP_STATUS_SUCCESS                     0
#define PPTP_STATUS_NOT_CONNECTED               1
#define PPTP_STATUS_BAD_FORMAT                  2
#define PPTP_STATUS_BAD_VALUE                   3
#define PPTP_STATUS_INSUFFICIENT_RESOURCES      4
#define PPTP_STATUS_BAD_CALL_ID                 5
#define PPTP_STATUS_PAC_ERROR                   6


typedef enum {
    PPTP_CONTROL_MESSAGE = 1
} PPTP_PACKET_TYPE;

typedef enum {
    CONTROL_START_REQUEST = 1,
    CONTROL_START_REPLY,
    CONTROL_STOP_REQUEST,
    CONTROL_STOP_REPLY,
    CONTROL_ECHO_REQUEST,
    CONTROL_ECHO_REPLY,

    CALL_OUT_REQUEST,
    CALL_OUT_REPLY,
    CALL_IN_REQUEST,
    CALL_IN_REPLY,
    CALL_IN_CONNECTED,
    CALL_CLEAR_REQUEST,
    CALL_DISCONNECT_NOTIFY,

    WAN_ERROR_NOTIFY,

    SET_LINK_INFO,

    NUM_MESSAGE_TYPES
} PPTP_MESSAGE_TYPE;

typedef struct {
    USHORT          Length;
    USHORT          PacketType;
    ULONG           Cookie;
    USHORT          MessageType;
    USHORT          Reserved0;
} PPTP_HEADER, *PPPTP_HEADER;

typedef struct {
    PPTP_HEADER;
    USHORT          Version;

    union {
        USHORT          Reserved1;
        struct {
            UCHAR           ResultCode;

                #define     RESULT_CONTROL_START_SUCCESS               1
                #define     RESULT_CONTROL_START_ERROR                 2
                #define     RESULT_CONTROL_START_ALREADY_CONNECTED     3
                #define     RESULT_CONTROL_START_UNAUTHORIZED          4
                #define     RESULT_CONTROL_START_VERSION_NOT_SUPPORTED 5

            UCHAR           ErrorCode;
        };
    };

    ULONG           FramingCapabilities;

        #define     FRAMING_ASYNC   BIT(0)
        #define     FRAMING_SYNC    BIT(1)

    ULONG           BearerCapabilities;

        #define     BEARER_ANALOG   BIT(0)
        #define     BEARER_DIGITAL  BIT(1)

    USHORT          MaxChannels;
    USHORT          FirmwareRevision;

    UCHAR           HostName[MAX_HOSTNAME_LENGTH];
    UCHAR           Vendor[MAX_VENDOR_LENGTH];
} PPTP_CONTROL_START_PACKET, PPTP_CONTROL_REPLY_PACKET, *PPPTP_CONTROL_START_PACKET, *PPPTP_CONTROL_REPLY_PACKET;

typedef struct {
    PPTP_HEADER;

    union {
        struct {
            UCHAR   Reason;

                #define     CONTROL_STOP_GENERAL                1
                #define     CONTROL_STOP_VERSION                2
                #define     CONTROL_STOP_LOCAL                  3

            UCHAR   Reserved1;
        };
        struct {
            UCHAR   ResultCode;

                #define     RESULT_CONTROL_STOP_SUCCESS                1
                #define     RESULT_CONTROL_STOP_ERROR                  2

            UCHAR   ErrorCode;
        };
    };

    USHORT Reserved2;
} PPTP_CONTROL_STOP_PACKET, *PPPTP_CONTROL_STOP_PACKET;

typedef struct {
    PPTP_HEADER;
    ULONG           Identifier;
} PPTP_CONTROL_ECHO_REQUEST_PACKET, *PPPTP_CONTROL_ECHO_REQUEST_PACKET;

typedef struct {
    PPTP_HEADER;
    ULONG           Identifier;
    UCHAR           ResultCode;

        #define     RESULT_CONTROL_ECHO_SUCCESS    1
        #define     RESULT_CONTROL_ECHO_FAILURE    2

    UCHAR           ErrorCode;
    USHORT          Reserved1;
} PPTP_CONTROL_ECHO_REPLY_PACKET, *PPPTP_CONTROL_ECHO_REPLY_PACKET;

typedef struct {
    PPTP_HEADER;
    USHORT          CallId;
    USHORT          SerialNumber;
    ULONG           MinimumBPS;
    ULONG           MaximumBPS;
    ULONG           BearerType;
    ULONG           FramingType;
    USHORT          RecvWindowSize;
    USHORT          ProcessingDelay;
    USHORT          PhoneNumberLength;
    USHORT          Reserved1;
    UCHAR           PhoneNumber[MAX_PHONE_NUMBER_LENGTH];
    UCHAR           Subaddress[MAX_SUBADDRESS_LENGTH];
} PPTP_CALL_OUT_REQUEST_PACKET, *PPPTP_CALL_OUT_REQUEST_PACKET;

typedef struct {
    PPTP_HEADER;
    USHORT          CallId;
    USHORT          PeerCallId;
    UCHAR           ResultCode;

        #define     RESULT_CALL_OUT_CONNECTED      1
        #define     RESULT_CALL_OUT_ERROR          2
        #define     RESULT_CALL_OUT_NO_CARRIER     3
        #define     RESULT_CALL_OUT_BUSY           4
        #define     RESULT_CALL_OUT_NO_DIAL_TONE   5
        #define     RESULT_CALL_OUT_TIMEOUT        6
        #define     RESULT_CALL_OUT_REFUSED        7

    UCHAR           ErrorCode;
    USHORT          CauseCode;
    ULONG           ConnectSpeed;
    USHORT          RecvWindowSize;
    USHORT          ProcessingDelay;
    ULONG           PhysicalChannelId;
} PPTP_CALL_OUT_REPLY_PACKET, *PPPTP_CALL_OUT_REPLY_PACKET;

typedef struct {
    PPTP_HEADER;
    USHORT          CallId;
    USHORT          SerialNumber;
    ULONG           BearerType;
    ULONG           PhysicalChannelId;
    USHORT          DialedNumberLength;
    USHORT          DialingNumberLength;
    UCHAR           DialedNumber[MAX_PHONE_NUMBER_LENGTH];
    UCHAR           DialingNumber[MAX_PHONE_NUMBER_LENGTH];
    UCHAR           Subaddress[MAX_SUBADDRESS_LENGTH];
} PPTP_CALL_IN_REQUEST_PACKET, *PPPTP_CALL_IN_REQUEST_PACKET;

typedef struct {
    PPTP_HEADER;
    USHORT          CallId;
    USHORT          PeerCallId;
    UCHAR           ResultCode;

        #define     RESULT_CALL_IN_CONNECTED       1
        #define     RESULT_CALL_IN_ERROR           2
        #define     RESULT_CALL_IN_REFUSED         3

    UCHAR           ErrorCode;
    USHORT          RecvWindowSize;
    USHORT          ProcessingDelay;
    USHORT          Reserved1;
} PPTP_CALL_IN_REPLY_PACKET, *PPPTP_CALL_IN_REPLY_PACKET;

typedef struct {
    PPTP_HEADER;
    USHORT          PeerCallId;
    USHORT          Reserved1;
    ULONG           ConnectSpeed;
    USHORT          RecvWindowSize;
    USHORT          ProcessingDelay;
    ULONG           FramingType;
} PPTP_CALL_IN_CONNECT_PACKET, *PPPTP_CALL_IN_CONNECT_PACKET;

typedef struct {
    PPTP_HEADER;
    USHORT          CallId;
    USHORT          Reserved1;
} PPTP_CALL_CLEAR_REQUEST_PACKET, *PPPTP_CALL_CLEAR_REQUEST_PACKET;

typedef struct {
    PPTP_HEADER;
    USHORT          CallId;
    UCHAR           ResultCode;

        #define     RESULT_CALL_DISCONNECT_LOST_CARRIER    1
        #define     RESULT_CALL_DISCONNECT_ERROR           2
        #define     RESULT_CALL_DISCONNECT_ADMIN           3
        #define     RESULT_CALL_DISCONNECT_REQUEST         4

    UCHAR           ErrorCode;
    USHORT          CauseCode;
    USHORT          Reserved1;
    UCHAR           CallStatistics[MAX_CALL_STATS_LENGTH];
} PPTP_CALL_DISCONNECT_NOTIFY_PACKET, *PPPTP_CALL_DISCONNECT_NOTIFY_PACKET;

typedef struct {
    PPTP_HEADER;
    USHORT          PeerCallId;
    USHORT          Reserved1;
    ULONG           CrcErrors;
    ULONG           FramingErrors;
    ULONG           HardwareOverruns;
    ULONG           BufferOverruns;
    ULONG           TimeoutErrors;
    ULONG           AlignmentErrors;
} PPTP_WAN_ERROR_NOTIFY_PACKET, *PPPTP_WAN_ERROR_NOTIFY_PACKET;

typedef struct {
    PPTP_HEADER;
    USHORT          PeerCallId;
    USHORT          Reserved1;
    ULONG           SendAccm;
    ULONG           RecvAccm;
} PPTP_SET_LINK_INFO_PACKET, *PPPTP_SET_LINK_INFO_PACKET;

#define MAX_CONTROL_PACKET_LENGTH sizeof(PPTP_CALL_IN_REQUEST_PACKET)

#endif //PROTOCOL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ndis\raspptp\common\raspptp.c ===
//depot/Lab03_N/Net/rras/ndis/raspptp/common/raspptp.c#4 - edit change 19457 (text)
/*****************************************************************************
*
*   Copyright (c) 1998-1999 Microsoft Corporation
*
*   RASPPTP.C - RASPPTP driver main module (DriverEntry, etc.)
*
*   Author:     Stan Adermann (stana)
*
*   Created:    7/28/1998
*
*****************************************************************************/

#include "raspptp.h"

#include "raspptp.tmh"

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT pDriverObject,
    IN PUNICODE_STRING pRegistryPath
    );

#pragma NDIS_INIT_FUNCTION(DriverEntry)

NDIS_HANDLE ghNdisWrapper;
PDRIVER_OBJECT gDriverObject;
COUNTERS gCounters;

#if DBG
ULONG PptpTraceMask = 0xffffffff;
#else
ULONG PptpTraceMask = 0;
#endif

VOID MiniportUnload(PVOID DriverObject)
{
    if(gDriverObject != NULL)
    {
        WPP_CLEANUP(gDriverObject);
    }
}


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT pDriverObject,
    IN PUNICODE_STRING pRegistryPath
    )
{
    NDIS_MINIPORT_CHARACTERISTICS Characteristics;
    NDIS_STATUS Status;

    DEFAULT_DEBUG_OPTIONS(
                          DBG_ERROR |
                          DBG_WARN |
                          //DBG_FUNC |
                          DBG_INIT |
                          //DBG_TX |
                          //DBG_RX |
                          DBG_TDI |
                          DBG_TUNNEL |
                          DBG_CALL |
                          DBG_NDIS |
                          DBG_TAPI |
                          //DBG_THREAD |
                          //DBG_POOL |
                          //DBG_REF |
                          //DBG_LOG |
                          0
                          );

    DEBUGMSG(DBG_INIT|DBG_FUNC, (DTEXT("+DriverEntry\n")));

    // Standard NDIS initiailization:
    //      InitializeWrapper
    //      Fill in the characteristics
    //      Register the miniport

    NdisMInitializeWrapper(&ghNdisWrapper,
                           pDriverObject,
                           pRegistryPath,
                           NULL
                           );

    NdisZeroMemory(&Characteristics, sizeof(NDIS_MINIPORT_CHARACTERISTICS));
    
    Characteristics.MajorNdisVersion        = NDIS_MAJOR_VERSION;
    Characteristics.MinorNdisVersion        = NDIS_MINOR_VERSION;

    Characteristics.Reserved                = NDIS_USE_WAN_WRAPPER;
    Characteristics.InitializeHandler       = MiniportInitialize;
    Characteristics.HaltHandler             = MiniportHalt;
    Characteristics.ResetHandler            = MiniportReset;
    Characteristics.QueryInformationHandler = MiniportQueryInformation;
    Characteristics.SetInformationHandler   = MiniportSetInformation;
    Characteristics.WanSendHandler          = MiniportWanSend;
    // ToDo: Characteristics.ReturnPacketHandler     = MpReturnPacket;

    Status = NdisMRegisterMiniport(ghNdisWrapper,
                                   &Characteristics,
                                   sizeof(Characteristics));

    if (Status!=NDIS_STATUS_SUCCESS)
    {
        DEBUGMSG(DBG_ERROR, (DTEXT("PPTP: NdisMRegisterMiniport failed %x\n"), Status));
        NdisTerminateWrapper(ghNdisWrapper, NULL);
        return STATUS_UNSUCCESSFUL;
    }
    
    // WPP tracing support
    NdisMRegisterUnloadHandler(ghNdisWrapper, MiniportUnload);

    gDriverObject = pDriverObject;
    WPP_INIT_TRACING(pDriverObject, pRegistryPath);

    DEBUGMSG(DBG_INIT|DBG_FUNC, (DTEXT("-DriverEntry\n")));
    return STATUS_SUCCESS;
}


VOID
AdapterCleanup(
    IN  PVOID       SystemSpecific1,
    IN  PVOID       pContext,
    IN  PVOID       SystemSpecific2,
    IN  PVOID       SystemSpecific3
    )
{
    PPPTP_ADAPTER pAdapter = pContext;
    extern VOID CtlpCleanupLooseEnds(PPPTP_ADAPTER pAdapter);
    extern VOID CallpCleanupLooseEnds(PPPTP_ADAPTER pAdapter);
    extern VOID CtdiCleanupLooseEnds(VOID);
    DEBUGMSG(DBG_FUNC, (DTEXT("+AdapterCleanup\n")));

    CtdiCleanupLooseEnds();
    CtlpCleanupLooseEnds(pAdapter);
    CallpCleanupLooseEnds(pAdapter);

    DEBUGMSG(DBG_FUNC, (DTEXT("-AdapterCleanup\n")));
}
PPPTP_ADAPTER
AdapterAlloc(NDIS_HANDLE NdisAdapterHandle)
{
    PPPTP_ADAPTER pAdapter;
    NDIS_PHYSICAL_ADDRESS HighestAcceptableAddress = NDIS_PHYSICAL_ADDRESS_CONST(-1,-1);
    UINT i;

    DEBUGMSG(DBG_FUNC, (DTEXT("+AdapterAlloc\n")));

    pAdapter = MyMemAlloc(sizeof(PPTP_ADAPTER), TAG_PPTP_ADAPTER);
    if (!pAdapter)
    {
        DEBUGMSG(DBG_FUNC|DBG_ERROR, (DTEXT("-AdapterAlloc NULL\n")));
        return NULL;
    }

    NdisZeroMemory(pAdapter, sizeof(PPTP_ADAPTER));

    pAdapter->hMiniportAdapter = NdisAdapterHandle;
    NdisAllocateSpinLock(&pAdapter->Lock);

    // Fill the NDIS_WAN_INFO structure.

    pAdapter->Info.MaxFrameSize     = 1400;
    pAdapter->Info.MaxTransmit      = PptpMaxTransmit;
    pAdapter->Info.HeaderPadding    = sizeof(GRE_HEADER) + sizeof(ULONG)*2 + sizeof(IP4_HEADER);
    pAdapter->Info.TailPadding      = 0;
    pAdapter->Info.Endpoints        = PptpWanEndpoints;
    pAdapter->Info.MemoryFlags      = 0;
    pAdapter->Info.HighestAcceptableAddress = HighestAcceptableAddress;
    pAdapter->Info.FramingBits      = PPP_FRAMING |
                                      PPP_COMPRESS_ADDRESS_CONTROL |
                                      PPP_COMPRESS_PROTOCOL_FIELD |
                                      TAPI_PROVIDER;
    pAdapter->Info.DesiredACCM      = 0;

    pAdapter->pCallArray = MyMemAlloc(sizeof(PCALL_SESSION)*pAdapter->Info.Endpoints, TAG_PPTP_CALL_LIST);
    if (!pAdapter->pCallArray)
    {
        AdapterFree(pAdapter);
        DEBUGMSG(DBG_FUNC|DBG_ERROR, (DTEXT("-AdapterAlloc Call NULL\n")));
        return NULL;
    }
    NdisZeroMemory(pAdapter->pCallArray, sizeof(PCALL_SESSION)*pAdapter->Info.Endpoints);

    for (i=0; i<pAdapter->Info.Endpoints; i++)
    {
        // Allocate the call on TapiOpen
        //pAdapter->pCallArray[i] = CallAlloc(pAdapter);
        pAdapter->pCallArray[i] = NULL;
    }

    NdisInitializeListHead(&pAdapter->ControlTunnelList);

    NdisMInitializeTimer(&pAdapter->CleanupTimer,
                         pAdapter->hMiniportAdapter,
                         AdapterCleanup,
                         pAdapter);
    NdisMSetPeriodicTimer(&pAdapter->CleanupTimer, 60000); // 60 second intervals

    DEBUGMSG(DBG_FUNC, (DTEXT("-AdapterAlloc %08x\n"), pAdapter));
    return pAdapter;
}

VOID
AdapterFree(PPPTP_ADAPTER pAdapter)
{
    ULONG i;
    BOOLEAN NotUsed;
    if (!pAdapter)
    {
        return;
    }
    DEBUGMSG(DBG_FUNC, (DTEXT("+AdapterFree\n")));
    ASSERT(IsListEmpty(&pAdapter->ControlTunnelList));
    if (pAdapter->pCallArray)
    {
        for (i=0; i<pAdapter->Info.Endpoints; i++)
        {
            CallFree(pAdapter->pCallArray[i]);
        }
        MyMemFree(pAdapter->pCallArray, sizeof(PCALL_SESSION)*pAdapter->Info.Endpoints);
        
        // We init and start Cleanup timer after we alloc pCallArray hence use this as a flag.
        NdisMCancelTimer(&pAdapter->CleanupTimer, &NotUsed);
    }
    
    NdisFreeSpinLock(&pAdapter->Lock);
    MyMemFree(pAdapter, sizeof(PPTP_ADAPTER));

    DEBUGMSG(DBG_FUNC, (DTEXT("-AdapterFree\n")));
}

PLIST_ENTRY FASTCALL
EnumListEntry(
    IN PLIST_ENTRY pHead,
    IN PENUM_CONTEXT pEnum,
    IN PNDIS_SPIN_LOCK pLock
    )
{
    PLIST_ENTRY pEntry = NULL;
    DEBUGMSG(DBG_FUNC, (DTEXT("+EnumListEntry\n")));

    ASSERT(pEnum->Signature==ENUM_SIGNATURE);

    if (pLock)
    {
        NdisAcquireSpinLock(pLock);
    }
    do
    {
        if (pEnum->ListEntry.Flink==NULL)
        {
            // First call
            if (!IsListEmpty(pHead))
            {
                pEntry = pHead->Flink;
                InsertHeadList(pEntry, &pEnum->ListEntry);
            }
        }
        else
        {
            if (pEnum->ListEntry.Flink!=pHead)
            {
                pEntry = pEnum->ListEntry.Flink;
                RemoveEntryList(&pEnum->ListEntry);
                InsertHeadList(pEntry, &pEnum->ListEntry);
            }
            else
            {
                RemoveEntryList(&pEnum->ListEntry);
                pEnum->ListEntry.Flink = pEnum->ListEntry.Blink = NULL;
                pEntry = NULL;
            }
        }
    } while ( pEntry &&
              ((PENUM_CONTEXT)pEntry)->Signature==ENUM_SIGNATURE );
    if (pLock)
    {
        NdisReleaseSpinLock(pLock);
    }
    DEBUGMSG(DBG_FUNC, (DTEXT("-EnumListEntry %08x\n"), pEntry));
    return pEntry;
}

VOID
EnumComplete(
    IN PENUM_CONTEXT pEnum,
    IN PNDIS_SPIN_LOCK pLock
    )
{
    DEBUGMSG(DBG_FUNC, (DTEXT("+EnumComplete\n")));
    if (pEnum->ListEntry.Flink)
    {
        if (pLock)
        {
            NdisAcquireSpinLock(pLock);
        }
        RemoveEntryList(&pEnum->ListEntry);
        pEnum->ListEntry.Flink = pEnum->ListEntry.Blink = NULL;
        if (pLock)
        {
            NdisReleaseSpinLock(pLock);
        }
    }
    DEBUGMSG(DBG_FUNC, (DTEXT("-EnumComplete\n")));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ndis\raspptp\common\raspptp.h ===
//depot/Lab03_N/Net/rras/ndis/raspptp/common/raspptp.h#7 - edit change 19457 (text)
/*****************************************************************************
*
*   Copyright (c) 1998-1999 Microsoft Corporation
*
*   RASPPTP.H - RASPPTP includes, defines, structures and prototypes
*
*   Author:     Stan Adermann (stana)
*
*   Created:    7/28/1998
*
*****************************************************************************/

#ifndef RASPPTP_H
#define RASPPTP_H

#include "osinc.h"

#ifdef STATIC
#undef STATIC
#endif
#define STATIC

#include "debug.h"
#include "protocol.h"
#include "ctdi.h"

#include <rc4.h>
#include <fipsapi.h>


//
// NDIS version compatibility in OSINC.H
//

// TAPI version compatibility

#define TAPI_EXT_VERSION            0x00010000

// Registry values
extern ULONG PptpMaxTransmit;
extern ULONG PptpWanEndpoints;
extern ULONG PptpBaseCallId;
extern ULONG PptpMaxCallId;
extern ULONG PptpCallIdMask;
extern BOOLEAN PptpClientSide;

extern ULONG PptpEchoTimeout;
extern BOOLEAN PptpEchoAlways;
extern USHORT PptpControlPort;
extern USHORT PptpProtocolNumber;
extern LONG PptpSendRecursionLimit;
extern ULONG PptpValidateAddress;
#define PPTP_SEND_RECURSION_LIMIT_DEFAULT 5
//extern CHAR PptpHostName[MAX_HOSTNAME_LENGTH];

#define CONFIG_INITIATE_UDP         BIT(0)
#define CONFIG_ACCEPT_UDP           BIT(1)
#define CONFIG_DONT_ACCEPT_GRE      BIT(2)

// trace the various pended tx lists
extern ULONG PptpTraceMask;
#define PPTP_TRACE_TX_PKT           BIT(0)
#define PPTP_TRACE_TX_IRP           BIT(1)

typedef struct {
    ULONG   Address;
    ULONG   Mask;
} CLIENT_ADDRESS, *PCLIENT_ADDRESS;

extern ULONG CtdiTcpDisconnectTimeout;
extern ULONG CtdiTcpConnectTimeout;

extern BOOLEAN PptpAuthenticateIncomingCalls;
extern PCLIENT_ADDRESS g_AcceptClientList;
extern ULONG g_ulAcceptClientAddresses;

extern ULONG PptpMaxTunnelsPerIpAddress;
extern PCLIENT_ADDRESS g_TrustedClientList;
extern ULONG g_ulTrustedClientAddresses;

#define TAPI_MAX_LINE_ADDRESS_LENGTH 32
#define TAPI_ADDR_PER_LINE          1
#define TAPI_ADDRESSID              0
#define TAPI_DEVICECLASS_NAME       "tapi/line"
#define TAPI_DEVICECLASS_ID         1
#define NDIS_DEVICECLASS_NAME       "ndis"
#define NDIS_DEVICECLASS_ID         2

#define PPTP_CLOSE_TIMEOUT          1000 // ms

#define MAX_TARGET_ADDRESSES        16

#define CALL_STATES_MASK            (LINECALLSTATE_UNKNOWN |        \
                                     LINECALLSTATE_IDLE |           \
                                     LINECALLSTATE_OFFERING |       \
                                     LINECALLSTATE_DIALING |        \
                                     LINECALLSTATE_PROCEEDING |     \
                                     LINECALLSTATE_CONNECTED |      \
                                     LINECALLSTATE_DISCONNECTED)

// Memory allocation tags
#define TAG(v)  ((((v)&0xff)<<24) | (((v)&0xff00)<<8) | (((v)&0xff0000)>>8) | (((v)&0xff000000)>>24))
#define TAG_PPTP_ADAPTER        TAG('PTPa')
#define TAG_PPTP_TUNNEL         TAG('PTPT')
#define TAG_PPTP_TIMEOUT        TAG('PTPt')
#define TAG_PPTP_CALL           TAG('PTPC')
#define TAG_PPTP_CALL_LIST      TAG('PTPc')
#define TAG_PPTP_ADDR_LIST      TAG('PTPL')
#define TAG_CTDI_DATA           TAG('PTCD')
#define TAG_CTDI_CONNECT_INFO   TAG('PTCN')
#define TAG_CTDI_DGRAM          TAG('PTCG')
#define TAG_CTDI_ROUTE          TAG('PTCR')
#define TAG_CTDI_IRP            TAG('PTCI')
#define TAG_CTDI_MESSAGE        TAG('PTCM')
#define TAG_CTL_PACKET          TAG('PTTP')
#define TAG_CTL_CONNINFO        TAG('PTTI')
#define TAG_WORK_ITEM           TAG('PTWI')
#define TAG_THREAD              TAG('PTTH')
#define TAG_REG                 TAG('PTRG')

#define TAG_FREE                TAG('FREE')


#define BIT(b)   (1<<(b))

#define LOCKED TRUE
#define UNLOCKED FALSE

/* Types and structs -------------------------------------------------------*/

typedef void (*FREEFUNC)(PVOID);
typedef struct {
    LONG                Count;
    FREEFUNC            FreeFunction;
} REFERENCE_COUNT;

#define INIT_REFERENCE_OBJECT(o,freefunc)                   \
    {                                                       \
        (o)->Reference.FreeFunction = (freefunc);           \
        (o)->Reference.Count = 1;                           \
        DEBUGMSG(DBG_REF, (DTEXT("INIT REF   (%08x, %d) %s\n"), (o), (o)->Reference.Count, #o)); \
    }

#if DBG
#define REFERENCE_OBJECT(o)                                                         \
    {                                                                               \
        LONG Ref;                                                                   \
        Ref = NdisInterlockedIncrement(&(o)->Reference.Count);                      \
        ASSERT(Ref != 1);                                                           \
        DEBUGMSG(DBG_REF, (DTEXT("REFERENCE  (%08x, %d) %s %d\n"), (o), (o)->Reference.Count, #o, __LINE__)); \
    }
#else
#define REFERENCE_OBJECT(o)                                                         \
    {                                                                               \
        NdisInterlockedIncrement(&(o)->Reference.Count);                            \
        DEBUGMSG(DBG_REF, (DTEXT("REFERENCE  (%08x, %d) %s %d\n"), (o), (o)->Reference.Count, #o, __LINE__)); \
    }
#endif      

#define DEREFERENCE_OBJECT(o)                                                                   \
    {                                                                                           \
        ULONG Ref = NdisInterlockedDecrement(&(o)->Reference.Count);                            \
        DEBUGMSG(DBG_REF, (DTEXT("DEREFERENCE(%08x, %d) %s %d\n"), (o), (o)->Reference.Count, #o, __LINE__));   \
        if (Ref==0)                                                                             \
        {                                                                                       \
            ASSERT((o)->Reference.FreeFunction);                                                \
            DEBUGMSG(DBG_REF, (DTEXT("Last reference released, freeing %08x\n"), (o)));         \
            (o)->Reference.FreeFunction(o);                                                     \
        }                                                                                       \
    }
    
#if DBG

#define REFERENCE_OBJECT_EX(o, index)                                                       \
    {                                                                                       \
        NdisInterlockedIncrement(&(o)->arrRef[index]);                                      \
        REFERENCE_OBJECT(o);                                                                \
    }

#define DEREFERENCE_OBJECT_EX(o, index)                                                     \
    {                                                                                       \
        NdisInterlockedDecrement(&(o)->arrRef[index]);                                      \
        DEREFERENCE_OBJECT(o);                                                              \
    }
    
#else

#define REFERENCE_OBJECT_EX(o, index)                                                       \
    {                                                                                       \
        REFERENCE_OBJECT(o);                                                                \
    }

#define DEREFERENCE_OBJECT_EX(o, index)                                                     \
    {                                                                                       \
        DEREFERENCE_OBJECT(o);                                                              \
    }

#endif  
    
    
#define REFERENCE_COUNT(o) ((o)->Reference.Count)

#define IS_CALL(call) ((call) && (call)->Signature==TAG_PPTP_CALL)
#define IS_CTL(ctl)  ((ctl) && (ctl)->Signature==TAG_PPTP_TUNNEL)
#define IS_LINE_UP(call) (!((call)->Close.Checklist&CALL_CLOSE_LINE_DOWN))

// If you change this enum then be sure to change ControlStateToString() also.
typedef enum {
    STATE_CTL_INVALID = 0,
    STATE_CTL_LISTEN,
    STATE_CTL_DIALING,
    STATE_CTL_WAIT_REQUEST,
    STATE_CTL_WAIT_REPLY,
    STATE_CTL_ESTABLISHED,
    STATE_CTL_WAIT_STOP,
    STATE_CTL_CLEANUP,
    NUM_CONTROL_STATES
} CONTROL_STATE;

// If you change this enum then be sure to change CallStateToString() also.
typedef enum {
    STATE_CALL_INVALID = 0,
    STATE_CALL_CLOSED,
    STATE_CALL_IDLE,
    STATE_CALL_OFFHOOK,
    STATE_CALL_OFFERING,
    STATE_CALL_PAC_OFFERING,
    STATE_CALL_PAC_WAIT,
    STATE_CALL_DIALING,
    STATE_CALL_PROCEEDING,
    STATE_CALL_ESTABLISHED,
    STATE_CALL_WAIT_DISCONNECT,
    STATE_CALL_CLEANUP,
    NUM_CALL_STATES
} CALL_STATE;

typedef struct PPTP_ADAPTER *PPPTP_ADAPTER;

typedef enum {
    CTL_REF_INITIAL = 0,
    CTL_REF_PACKET,
    CTL_REF_ENUM,
    CTL_REF_CLEANUP,
    CTL_REF_QUERYCONNINFO,
    CTL_REF_QUERYADDRINFO,
    CTL_REF_CALLCONNECT,
    CTL_REF_CTLCONNECT,
    CTL_REF_CONNECTCALLBACK,
    CTL_REF_DISCONNECT,
    CTL_REF_CLEANUPLOOSEENDS,
    CTL_REF_CLEANUPCTLS,
    CTL_REF_MAX
} CTL_REF;


typedef struct CONTROL_TUNNEL {
    LIST_ENTRY          ListEntry;
    // Used to attach this control connection to the miniport context.

    REFERENCE_COUNT     Reference;
    // Not protected by spinlock

    ULONG               Signature;
    // PTPT

    PPPTP_ADAPTER       pAdapter;
    // The associated adapter

    CONTROL_STATE       State;
    // State of this control connection

    LIST_ENTRY          CallList;
    // List of calls supported by this control connection.
    // Protected by adapter lock

    BOOLEAN             Inbound;
    // Indicates whether this tunnel originated here or elsewhere

    UCHAR               Padding[sizeof(ULONG_PTR)];
    // We pad to protect the portions of the struct protected by different locks
    // from alpha alignment problems.

    // ^^^^^^ Protected by Adapter->Lock^^^^^^^^
    //===================================================================
    NDIS_SPIN_LOCK      Lock;
    // vvvvvv Protected by Ctl->Lock vvvvvvvvvvv

    BOOLEAN             Cleanup;
    // True means a cleanup has been scheduled or is active.

    LIST_ENTRY          MessageList;
    // Each entry represents a pptp message that has been sent and
    // is awaiting a response or at least waiting to be acknowledged
    // by the transport

    HANDLE              hCtdiEndpoint;
    // Handle for the tunnel local endpoint.  The connection must be closed first.

    HANDLE              hCtdi;
    // Handle for control tunnel TCP connection.

    UCHAR               PartialPacketBuffer[MAX_CONTROL_PACKET_LENGTH];
    ULONG               BytesInPartialBuffer;
    // TCP data received that does not constitute a full packet.

    struct {
        TA_IP_ADDRESS   Address;
        ULONG           Version;
        ULONG           Framing;
        ULONG           Bearer;
        UCHAR           HostName[MAX_HOSTNAME_LENGTH];
        UCHAR           Vendor[MAX_VENDOR_LENGTH];
    } Remote;
    // Information provided by the remote.
    
    ULONG               LocalAddress;   

    PULONG              PptpMessageLength;
    // Points to an array of precalculated packet lengths, based on version

    struct {
        NDIS_MINIPORT_TIMER Timer;
        ULONG           Identifier;
        BOOLEAN         Needed;

        #define         PPTP_ECHO_TIMEOUT_DEFAULT   60

    } Echo;

    #define             PPTP_MESSAGE_TIMEOUT_DEFAULT 30

    NDIS_MINIPORT_TIMER WaitTimeout;
    NDIS_MINIPORT_TIMER StopTimeout;

    ULONG               Speed;
    // Contains line speed of this connect in BPS

#if DBG
    ULONG               arrRef[CTL_REF_MAX];
#endif

} CONTROL_TUNNEL, *PCONTROL_TUNNEL;


typedef struct CALL_SESSION {
    LIST_ENTRY          ListEntry;
    // Used to attach a call session to a control connection

    ULONG               Signature;
    // PTPC

    PPPTP_ADAPTER       pAdapter;
    // The associated adapter

    LIST_ENTRY          TxListEntry;
    // If we have packets to send, this connects us to the queue of the transmitting thread.

    PCONTROL_TUNNEL     pCtl;
    // Pointer to this call's control connection.

    UCHAR               Padding[sizeof(ULONG_PTR)];
    // We pad to protect the portions of the struct protected by different locks
    // from alpha alignment problems.

    // ^^^^^^^^^^ Protected by Adapter->Lock ^^^^^^^^^^^^^^
    // ============================================================================

    REFERENCE_COUNT     Reference;
    // Not protected by spinlock

    NDIS_SPIN_LOCK      Lock;
    // vvvvvvvvvv Protected by Call->Lock vvvvvvvvvvvvvvvvv

    CALL_STATE          State;
    // State of this call.
    
    LIST_ENTRY          TxPacketList;
    // Context for each send currently queued

    LIST_ENTRY          TxActivePacketList;
    // Context for each send currently active in transport

    LIST_ENTRY          RxPacketList;
    // Context for each datagram received but not processed

    ULONG_PTR           RxPacketsPending;
    // Count of RxPackets in RxPacketList
    
    BOOLEAN             PendingUse;
    // This call is being used though it's in STATE_CALL_IDLE

    BOOLEAN             Inbound;
    // TRUE indicates call did not originate here

    BOOLEAN             Open;
    // Open has been called, but not close

    BOOLEAN             Transferring;
    // TRUE means we are on the queue to transmit or receive packets.

    HTAPI_CALL          hTapiCall;
    // Tapi's handle to the specific call

    ULONG_PTR           DeviceId;
    // The ID of this call, essentially the index in the call array
    
    ULONG_PTR           FullDeviceId;
    // The ID used in PPTP call id field and used as TAPI hdCall
    
    USHORT              SerialNumber;
    // Unique for this call

    NDIS_HANDLE         NdisLinkContext;
    // Ndis's handle, used in MiniportReceive, etc.

    NDIS_WAN_SET_LINK_INFO WanLinkInfo;

    struct {
        ULONG               SequenceNumber;
        // Last received GRE sequence number

        ULONG               AckNumber;
        // Last received GRE Ack number

        TA_IP_ADDRESS       Address;
        // Remote address for datagrams

        ULONG               TxAccm;
        ULONG               RxAccm;
        // PPP configuration

        USHORT              CallId;
        // Peer ID as used in GRE packet

    } Remote;
    
    struct {

        USHORT              CallId;
        // My ID as used in GRE packet

        ULONG               SequenceNumber;
        // Next GRE Sequence number to send

        ULONG               AckNumber;
        // Last sent GRE Ack number

    } Packet;
    // Struct for items used in creating/processing packets

    ULONG               MediaModeMask;
    // Indicates what types of Tapi calls we accept,
    // set by OID_TAPI_SET_DEFAULT_MEDIA_DETECTION

    ULONG_PTR           LineStateMask;
    // This is the list of line states tapi is interested in.
    // set by OID_TAPI_SET_STATUS_MESSAGES

    UCHAR               CallerId[MAX_PHONE_NUMBER_LENGTH];
    // This is the remote phone number or IP if we recieved the call,
    // and the IP or phone number we dialed if we placed the call.

    struct {
        NDIS_MINIPORT_TIMER Timer;
        BOOLEAN             Expedited;
        BOOLEAN             Scheduled;
        ULONG               Checklist;

        #define             CALL_CLOSE_CLEANUP_STATE    BIT(0)
        #define             CALL_CLOSE_LINE_DOWN        BIT(1)
        #define             CALL_CLOSE_DROP             BIT(2)
        #define             CALL_CLOSE_DROP_COMPLETE    BIT(3)
        #define             CALL_CLOSE_DISCONNECT       BIT(4)
        #define             CALL_CLOSE_CLOSE_CALL       BIT(5)
        #define             CALL_CLOSE_CLOSE_LINE       BIT(6)
        #define             CALL_CLOSE_RESET            BIT(7)

        #define             CALL_CLOSE_COMPLETE \
                                (CALL_CLOSE_CLEANUP_STATE  |\
                                 CALL_CLOSE_DROP           |\
                                 CALL_CLOSE_DROP_COMPLETE  |\
                                 CALL_CLOSE_DISCONNECT     |\
                                 CALL_CLOSE_CLOSE_CALL     |\
                                 CALL_CLOSE_LINE_DOWN      |\
                                 CALL_CLOSE_CLOSE_LINE     |\
                                 CALL_CLOSE_RESET)

    } Close;

    ULONG               Speed;
    // Connection speed

    struct {
        NDIS_MINIPORT_TIMER Timer;
        BOOLEAN             PacketQueued;
        ULONG_PTR           Padding;
        NDIS_WAN_PACKET     Packet;
        ULONG_PTR           Padding2;
        UCHAR               PacketBuffer[sizeof(GRE_HEADER)+sizeof(ULONG)*2];
        ULONG_PTR           Padding3;
        // When we want to send just an ack, we actually create a packet of
        // 0 bytes out of this buffer and pass it down.  This buffer is touched
        // out of our control, so we pad it to protect us from alpha alignment
        // problems.
    } Ack;

    UCHAR               LineAddress[TAPI_MAX_LINE_ADDRESS_LENGTH];

    LONG                SendCompleteRecursion;

    NDIS_MINIPORT_TIMER DialTimer;

    PPTP_DPC            ReceiveDpc;
    BOOLEAN             Receiving;

    struct {
        BOOLEAN         Cleanup;
        UCHAR           CleanupReason[80];
        CALL_STATE      FinalState;
        NDIS_STATUS     FinalError;
        ULONG           Event;

        #define         CALL_EVENT_TAPI_ANSWER          BIT(0)
        #define         CALL_EVENT_TAPI_CLOSE_CALL      BIT(1)
        #define         CALL_EVENT_TAPI_DROP            BIT(2)
        #define         CALL_EVENT_TAPI_LINE_UP         BIT(3)
        #define         CALL_EVENT_TAPI_LINE_DOWN       BIT(4)
        #define         CALL_EVENT_TAPI_GET_CALL_INFO   BIT(5)
        #define         CALL_EVENT_TAPI_MAKE_CALL       BIT(6)
        #define         CALL_EVENT_PPTP_CLEAR_REQUEST   BIT(7)
        #define         CALL_EVENT_PPTP_DISCONNECT      BIT(8)
        #define         CALL_EVENT_PPTP_OUT_REQUEST     BIT(9)
        #define         CALL_EVENT_PPTP_OUT_REPLY       BIT(10)
        #define         CALL_EVENT_TCP_DISCONNECT       BIT(11)
        #define         CALL_EVENT_TCP_NO_ANSWER        BIT(12)
        #define         CALL_EVENT_TUNNEL_ESTABLISHED   BIT(13)
    } History;

    NDIS_WORK_ITEM      SendWorkItem;
    NDIS_WORK_ITEM      RecvWorkItem;
    
#if DBG
    ULONG               TraceIndex;         
    UCHAR               DbgTrace[64];
#endif  
    
} CALL_SESSION, *PCALL_SESSION;

typedef struct PPTP_ADAPTER {
    NDIS_HANDLE     hMiniportAdapter;
    // NDIS context

    NDIS_SPIN_LOCK  Lock;

    REFERENCE_COUNT Reference;

    PCALL_SESSION  *pCallArray;
    // Array of all call sessions.
    // Size of array is MaxOutboundCalls+MaxInboundCalls

    LIST_ENTRY      ControlTunnelList;
    // List of all active control connections.

    HANDLE          hCtdiListen;
    // This is the one listening handle

    HANDLE          hCtdiDg;
    // Ctdi handle for PPTP datagram sends/recvs

    NDIS_WAN_INFO   Info;
    // NdisWan related info
    // Info.Endpoint should equal MaxOutboundCalls+MaxInboundCalls

    struct {
        ULONG           DeviceIdBase;
        ULONG_PTR       LineStateMask;
        // This is the list of line states tapi is interested in.
        // set by OID_TAPI_SET_STATUS_MESSAGES

        BOOLEAN         Open;

        HTAPI_LINE      hTapiLine;
        // Tapi's handle to the line device, for status callbacks

        ULONG           NumActiveCalls;
    } Tapi;
    // Struct to track Tapi specific info.

    NDIS_MINIPORT_TIMER CleanupTimer;
    
    // FIPS structures for random data generation                                         
    FIPS_FUNCTION_TABLE FipsFunctionTable;
    PFILE_OBJECT        pFipsFileObject;
    PDEVICE_OBJECT      pFipsDeviceObject;
    RC4_KEYSTRUCT       Rc4KeyData;
    LONG                lRandomCount;
    BOOLEAN             bRekeying;  
    
} PPTP_ADAPTER, *PPPTP_ADAPTER;

typedef struct {
    NDIS_SPIN_LOCK  Lock;
    ULONG           InboundConnectAttempts;
    ULONG           InboundConnectComplete;
    ULONG           OutboundConnectAttempts;
    ULONG           OutboundConnectComplete;
    ULONG           TunnelsMade;
    ULONG           TunnelsAccepted;
    ULONG           CallsMade;
    ULONG           CallsAccepted;
    ULONG           PacketsSent;
    ULONG           PacketsSentComplete;
    ULONG           PacketsSentError;
    ULONG           PacketsReceived;
    ULONG           PacketsRejected;
    ULONG           PacketsMissed;
    
    ULONG           ulNewCallNullTapiHandle;
    
    ULONG           ulAnswerNullRequest;
    ULONG           ulAnswerNullCall;
    ULONG           ulAnswerNullControl;
    ULONG           ulAnswerNullReply;
    ULONG           ulAnswerCtlSendFail;
    ULONG           ulAnswerNotOffering;
          
    ULONG           ulDropNullRequest;
    ULONG           ulDropNullCall;
    ULONG           ulDropNullControl;
    ULONG           ulDropNullPacket;
    ULONG           ulDropCtlSendFail;
          
    ULONG           ulCloseCallNullRequest;
    ULONG           ulCloseCallNullCall;
          
    ULONG           ulCleanupWorkItemFail;
          
    ULONG           ulCtlAllocPacketNull;
    ULONG           ulCtlSendFail;
          
    ULONG           ulWorkItemFail;
    ULONG           ulMemAllocFail;
    ULONG           ulFindCallWithTapiHandle;
    
    ULONG           ulIoAllocateIrpFail;
    ULONG           ulIoBuildIrpFail;
    ULONG           ulIoAllocateMdlFail;
} COUNTERS;

typedef struct {
    LIST_ENTRY          ListEntry;
    PVOID               pBuffer;
    PGRE_HEADER         pGreHeader;
    HANDLE              hCtdi;
} DGRAM_CONTEXT, *PDGRAM_CONTEXT;

extern PPPTP_ADAPTER pgAdapter;

extern COUNTERS gCounters;

/* Prototypes --------------------------------------------------------------*/

PPPTP_ADAPTER
AdapterAlloc(NDIS_HANDLE NdisAdapterHandle);

VOID
AdapterFree(PPPTP_ADAPTER pAdapter);

NTSTATUS RngInit();

PCALL_SESSION
CallAlloc(PPPTP_ADAPTER pAdapter);

VOID
CallAssignSerialNumber(PCALL_SESSION pCall);

VOID
CallCleanup(
    PCALL_SESSION pCall,
    BOOLEAN Locked
    );

VOID
CallDetachFromAdapter(PCALL_SESSION pCall);

PCALL_SESSION
CallFindAndLock(
    IN PPPTP_ADAPTER        pAdapter,
    IN CALL_STATE           State,
    IN ULONG                Flags
    );
#define FIND_INCOMING   BIT(0)
#define FIND_OUTGOING   BIT(1)

VOID
CallFree(PCALL_SESSION pCall);

NDIS_STATUS
CallEventCallClearRequest(
    PCALL_SESSION                       pCall,
    UNALIGNED PPTP_CALL_CLEAR_REQUEST_PACKET *pPacket,
    PCONTROL_TUNNEL pCtl
    );

NDIS_STATUS
CallEventCallDisconnectNotify(
    PCALL_SESSION                       pCall,
    UNALIGNED PPTP_CALL_DISCONNECT_NOTIFY_PACKET *pPacket
    );

NDIS_STATUS
CallEventCallInConnect(
    IN PCALL_SESSION        pCall,
    IN UNALIGNED PPTP_CALL_IN_CONNECT_PACKET *pPacket
    );

NDIS_STATUS
CallEventCallInRequest(
    IN PPPTP_ADAPTER        pAdapter,
    IN PCONTROL_TUNNEL      pCtl,
    IN UNALIGNED PPTP_CALL_IN_REQUEST_PACKET *pPacket
    );

NDIS_STATUS
CallEventCallOutReply(
    IN PCALL_SESSION                pCall,
    IN UNALIGNED PPTP_CALL_OUT_REPLY_PACKET *pPacket
    );

NDIS_STATUS
CallEventCallOutRequest(
    IN PPPTP_ADAPTER        pAdapter,
    IN PCONTROL_TUNNEL      pCtl,
    IN UNALIGNED PPTP_CALL_OUT_REQUEST_PACKET *pPacket
    );

NDIS_STATUS
CallEventDisconnect(
    PCALL_SESSION                       pCall
    );

NDIS_STATUS
CallEventConnectFailure(
    PCALL_SESSION                       pCall,
    NDIS_STATUS                         FailureReason
    );

NDIS_STATUS
CallEventOutboundTunnelEstablished(
    IN PCALL_SESSION        pCall,
    IN NDIS_STATUS          EventStatus
    );

PCALL_SESSION FASTCALL
CallGetCall(
    IN PPPTP_ADAPTER pAdapter,
    IN ULONG_PTR ulDeviceId
    );

#define CallIsValidCall(pAdapter, id) (pAdapter->Tapi.DeviceIdBase == id ? TRUE : FALSE)

#define DeviceIdToIndex(pAdapter, id) ((id)-(pAdapter)->Tapi.DeviceIdBase)

#define CallGetLineCallState(State)  (((ULONG)(State)<NUM_CALL_STATES) ? CallStateToLineCallStateMap[State] : LINECALLSTATE_UNKNOWN)

extern ULONG CallStateToLineCallStateMap[];

#define CALL_ID_INDEX_BITS          14
#define CallIdToDeviceId(CallId)  PptpClientSide ? ((CallId)&((1<<CALL_ID_INDEX_BITS)-1)) : ((ULONG)(CallId))

NDIS_STATUS
CallReceiveDatagramCallback(
    IN      PVOID                       pContext,
    IN      PTRANSPORT_ADDRESS          pAddress,
    IN      PUCHAR                      pBuffer,
    IN      ULONG                       ulLength
    );

NDIS_STATUS
CallQueueReceivePacket(
    PCALL_SESSION       pCall,
    PDGRAM_CONTEXT      pDgContext
    );

NDIS_STATUS
CallQueueTransmitPacket(
    PCALL_SESSION       pCall,
    PNDIS_WAN_PACKET    pWanPacket
    );
// CallQueueTransmitPacket is OS-specific and not found in COMMON directory

BOOLEAN
CallConnectToCtl(
    IN PCALL_SESSION pCall,
    IN PCONTROL_TUNNEL pCtl,
    IN BOOLEAN CallLocked
    );

VOID
CallDisconnectFromCtl(
    IN PCALL_SESSION pCall,
    IN PCONTROL_TUNNEL pCtl
    );

NDIS_STATUS
CallSetLinkInfo(
    PPPTP_ADAPTER pAdapter,
    IN PNDIS_WAN_SET_LINK_INFO pRequest
    );

VOID
CallSetState(
    IN PCALL_SESSION pCall,
    IN CALL_STATE State,
    IN ULONG_PTR StateParam,
    IN BOOLEAN Locked
    );

VOID
CallProcessPackets(
    PNDIS_WORK_ITEM pNdisWorkItem,
    PCALL_SESSION   pCall
    );

VOID
CallProcessRxPackets(
    PNDIS_WORK_ITEM pNdisWorkItem,
    PCALL_SESSION   pCall
    );

#if 0
VOID
CallProcessRxPackets(
    IN PVOID SystemSpecific1,
    IN PVOID Context,
    IN PVOID SystemSpecific2,
    IN PVOID SystemSpecific3
    );
#endif

PCONTROL_TUNNEL
CtlAlloc(
    PPPTP_ADAPTER pAdapter
    );

PVOID
CtlAllocPacket(
    PCONTROL_TUNNEL pCtl,
    PPTP_MESSAGE_TYPE Message
    );

VOID
CtlFree(PCONTROL_TUNNEL pCtl);

VOID
CtlFreePacket(
    PCONTROL_TUNNEL pCtl,
    PVOID pPacket
    );

NDIS_STATUS
CtlListen(
    IN PPPTP_ADAPTER pAdapter
    );

VOID
CtlCleanup(
    PCONTROL_TUNNEL pCtl,
    BOOLEAN Locked
    );

NDIS_STATUS
CtlConnectCall(
    IN PPPTP_ADAPTER pAdapter,
    IN PCALL_SESSION pCall,
    IN PTA_IP_ADDRESS pTargetAddress
    );

NDIS_STATUS
CtlDisconnectCall(
    IN PCALL_SESSION pCall
    );

NDIS_STATUS
CtlSend(
    IN PCONTROL_TUNNEL pCtl,
    IN PVOID pPacketBuffer
    );

VOID 
CtlpCleanupCtls(
    PPPTP_ADAPTER pAdapter
    );

#define FreeWorkItem(_pptp_item) MyMemFree((PVOID)(_pptp_item), sizeof(PPTP_WORK_ITEM))

NDIS_STATUS
InitThreading(
    IN NDIS_HANDLE hMiniportAdapter
    );

VOID
DeinitThreading();

VOID 
InitCallLayer();

VOID
IpAddressToString(
    IN ULONG ulIpAddress,
    OUT CHAR* pszIpAddress );

VOID
MiniportHalt(
    IN NDIS_HANDLE MiniportAdapterContext
    );

NDIS_STATUS
MiniportInitialize(
    OUT PNDIS_STATUS OpenErrorStatus,
    OUT PUINT        SelectedMediumIndex,
    IN  PNDIS_MEDIUM MediumArray,
    IN  UINT         MediumArraySize,
    IN  NDIS_HANDLE  NdisAdapterHandle,
    IN  NDIS_HANDLE  WrapperConfigurationContext
    );

NDIS_STATUS
MiniportQueryInformation(
    IN NDIS_HANDLE MiniportAdapterContext,
    IN NDIS_OID Oid,
    IN PVOID InformationBuffer,
    IN ULONG InformationBufferLength,
    OUT PULONG BytesWritten,
    OUT PULONG BytesNeeded
    );

NDIS_STATUS
MiniportReset(
    OUT PBOOLEAN    AddressingReset,
    IN  NDIS_HANDLE MiniportAdapterContext
    );

NDIS_STATUS
MiniportSetInformation(
   IN NDIS_HANDLE MiniportAdapterContext,
   IN NDIS_OID Oid,
   IN PVOID InformationBuffer,
   IN ULONG InformationBufferLength,
   OUT PULONG BytesRead,
   OUT PULONG BytesNeeded
   );

NDIS_STATUS
MiniportWanSend(
   IN NDIS_HANDLE MiniportAdapterContext,
   IN NDIS_HANDLE NdisLinkHandle,
   IN PNDIS_WAN_PACKET WanPacket
   );


VOID
OsGetTapiLineAddress(ULONG Index, PUCHAR s, ULONG Length);

VOID
OsReadConfig(
    NDIS_HANDLE hConfig
    );

#if 0
VOID OsGetFullHostName(VOID);
#endif

NDIS_STATUS
OsSpecificTapiGetDevCaps(
    ULONG_PTR ulDeviceId,
    IN OUT PNDIS_TAPI_GET_DEV_CAPS pRequest
    );

extern BOOLEAN PptpInitialized;

NDIS_STATUS
PptpInitialize(
    PPPTP_ADAPTER pAdapter
    );
    
NDIS_STATUS
ScheduleWorkItem(
    WORK_PROC         Callback,
    PVOID             Context,
    PVOID             InfoBuf,
    ULONG             InfoBufLen
    );

PUCHAR
StringToIpAddress(
    IN PUCHAR pszIpAddress,
    IN OUT PTA_IP_ADDRESS pAddress,
    OUT PBOOLEAN pValidAddress
    );

PWCHAR
StringToIpAddressW(
    IN PWCHAR pszIpAddress,
    IN OUT PTA_IP_ADDRESS pAddress,
    OUT PBOOLEAN pValidAddress
    );

NDIS_STATUS
TapiAnswer(
    IN PPPTP_ADAPTER pAdapter,
    IN PNDIS_TAPI_ANSWER pRequest
    );

NDIS_STATUS
TapiClose(
    IN PPPTP_ADAPTER pAdapter,
    IN PNDIS_TAPI_CLOSE pRequest
    );

NDIS_STATUS
TapiCloseCall(
    IN PPPTP_ADAPTER pAdapter,
    IN PNDIS_TAPI_CLOSE_CALL pRequest
    );

NDIS_STATUS
TapiDrop(
    IN PPPTP_ADAPTER pAdapter,
    IN PNDIS_TAPI_DROP pRequest
    );

NDIS_STATUS
TapiGetAddressCaps(
    IN PPPTP_ADAPTER pAdapter,
    IN OUT PNDIS_TAPI_GET_ADDRESS_CAPS pRequest
    );

NDIS_STATUS
TapiGetAddressStatus(
    IN PPPTP_ADAPTER pAdapter,
    IN OUT PNDIS_TAPI_GET_ADDRESS_STATUS pExtIdQuery
    );

NDIS_STATUS
TapiGetCallInfo(
    IN PPPTP_ADAPTER pAdapter,
    IN OUT PNDIS_TAPI_GET_CALL_INFO pRequest,
    IN OUT PULONG pRequiredLength
    );

NDIS_STATUS
TapiGetCallStatus(
    IN PPPTP_ADAPTER pAdapter,
    IN OUT PNDIS_TAPI_GET_CALL_STATUS pRequest
    );

NDIS_STATUS
TapiGetDevCaps(
    IN PPPTP_ADAPTER pAdapter,
    IN OUT PNDIS_TAPI_GET_DEV_CAPS pRequest
    );

NDIS_STATUS
TapiGetExtensionId(
    IN PPPTP_ADAPTER pAdapter,
    IN OUT PNDIS_TAPI_GET_EXTENSION_ID pExtIdQuery
    );

NDIS_STATUS
TapiGetId(
    IN PPPTP_ADAPTER pAdapter,
    IN OUT PNDIS_TAPI_GET_ID pRequest
    );

#define TapiLineHandleToId(h)  ((h)&0x7fffffff)
#define TapiIdToLineHandle(id) ((id)|0x80000000)
#define LinkHandleToId(h)  ((ULONG_PTR)(((ULONG_PTR)(h))&0x7fffffff))
#define DeviceIdToLinkHandle(id) ((id)|0x80000000)

VOID
TapiLineDown(
    PCALL_SESSION pCall
    );

VOID
TapiLineUp(
    PCALL_SESSION pCall
    );

NDIS_STATUS
TapiMakeCall(
    IN PPPTP_ADAPTER pAdapter,
    IN OUT PNDIS_TAPI_MAKE_CALL pRequest
    );

NDIS_STATUS
TapiNegotiateExtVersion(
    IN PPPTP_ADAPTER pAdapter,
    IN OUT PNDIS_TAPI_NEGOTIATE_EXT_VERSION pExtVersion
    );

NDIS_STATUS
TapiOpen(
    IN PPPTP_ADAPTER pAdapter,
    IN OUT PNDIS_TAPI_OPEN pRequest
    );

NDIS_STATUS
TapiProviderInitialize(
    IN PPPTP_ADAPTER pAdapter,
    IN OUT PNDIS_TAPI_PROVIDER_INITIALIZE pInitData
    );

NDIS_STATUS
TapiProviderShutdown(
    IN PPPTP_ADAPTER pAdapter,
    IN OUT PNDIS_TAPI_PROVIDER_SHUTDOWN pRequest
    );

NDIS_STATUS
TapiSetDefaultMediaDetection(
    IN PPPTP_ADAPTER pAdapter,
    IN OUT PNDIS_TAPI_SET_DEFAULT_MEDIA_DETECTION pRequest
    );

NDIS_STATUS
TapiSetStatusMessages(
    IN PPPTP_ADAPTER pAdapter,
    IN OUT PNDIS_TAPI_SET_STATUS_MESSAGES pRequest
    );

// Enum

#define ENUM_SIGNATURE TAG('ENUM')

typedef struct {
    LIST_ENTRY  ListEntry;
    ULONG       Signature;
} ENUM_CONTEXT, *PENUM_CONTEXT;

#define InitEnumContext(e)                                  \
    {                                                           \
        (e)->ListEntry.Flink = (e)->ListEntry.Blink = NULL;     \
        (e)->Signature = ENUM_SIGNATURE;                        \
    }

PLIST_ENTRY FASTCALL
EnumListEntry(
    IN PLIST_ENTRY pHead,
    IN PENUM_CONTEXT pEnum,
    IN PNDIS_SPIN_LOCK pLock
    );

VOID
EnumComplete(
    IN PENUM_CONTEXT pEnum,
    IN PNDIS_SPIN_LOCK pLock
    );

#endif // RASPPTP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ndis\raspptp\common\tapi.c ===
/*****************************************************************************
*
*   Copyright (c) 1998-1999 Microsoft Corporation
*
*   TAPI.C - TAPI handling functions
*
*   Author:     Stan Adermann (stana)
*
*   Created:    9/17/1998
*
*****************************************************************************/

#include "raspptp.h"

#include "tapi.tmh"

NDIS_STATUS
TapiAnswer(
    IN PPPTP_ADAPTER pAdapter,
    IN PNDIS_TAPI_ANSWER pRequest
    )
{
    PCALL_SESSION pCall = NULL;
    PCONTROL_TUNNEL pCtl;
    BOOLEAN LockHeld = FALSE;
    NDIS_STATUS Status = NDIS_STATUS_SUCCESS;

    DEBUGMSG(DBG_FUNC, (DTEXT("+TapiAnswer\n")));
    
    if ( pRequest == NULL || pAdapter == NULL )
    {
        gCounters.ulAnswerNullRequest++;
        
        DEBUGMSG(DBG_ERROR|DBG_FUNC, (DTEXT("-TapiAnswer NDIS_STATUS_TAPI_INVALPARAM\n")));
        WPLOG(LL_A, LM_TAPI, ("-NDIS_STATUS_TAPI_INVALPARAM"));
        return NDIS_STATUS_TAPI_INVALPARAM;
    }

    pCall = CallGetCall(pAdapter, pRequest->hdCall);
    
    // Verify the ID
    if (!pCall)
    {
        gCounters.ulAnswerNullCall++;
        
        DEBUGMSG(DBG_ERROR|DBG_FUNC, (DTEXT("-TapiAnswer NDIS_STATUS_TAPI_INVALCALLHANDLE\n")));
        WPLOG(LL_A, LM_TAPI, ("-NDIS_STATUS_TAPI_INVALCALLHANDLE"));
        return NDIS_STATUS_TAPI_INVALCALLHANDLE;
    }

    DBGTRACE('A');
    WPLOG(LL_I, LM_TAPI, ("Answer Cid %d", (ULONG)pCall->DeviceId));

    NdisAcquireSpinLock(&pCall->Lock);
    LockHeld = TRUE;
    
    pCtl = pCall->pCtl;

    if (!pCtl)
    {
        DBGTRACE('t');
        gCounters.ulAnswerNullControl++;
    
        DEBUGMSG(DBG_WARN, (DTEXT("TapiAnswer: No control tunnel Cid %d\n"), pCall->DeviceId));
        WPLOG(LL_A, LM_TAPI, ("No control tunnel Cid %d", (ULONG)pCall->DeviceId));
        Status = NDIS_STATUS_FAILURE;
    }
    else if (pCall->State==STATE_CALL_OFFERING)
    {
        USHORT NewCallId;
        PPTP_CALL_OUT_REPLY_PACKET *pReply = CtlAllocPacket(pCtl, CALL_OUT_REPLY);

        CallAssignSerialNumber(pCall);
        if(PptpClientSide)
        {
            NewCallId = (USHORT)((pCall->SerialNumber << CALL_ID_INDEX_BITS) + pCall->DeviceId);
            if (pCall->Packet.CallId == NewCallId)
            {
                // Don't allow a line to have the same CallId twice in a row.
                NewCallId += (1<<CALL_ID_INDEX_BITS);
            }
        }
        else
        {
            NewCallId = (USHORT)pCall->FullDeviceId;
        }
        pCall->Packet.CallId = NewCallId;

        if (!pReply)
        {
            DBGTRACE('r');
            gCounters.ulAnswerNullReply++;
            
            DEBUGMSG(DBG_WARN, (DTEXT("TapiAnswer: Failed to alloc a reply packet Cid %d\n"), pCall->DeviceId));
            WPLOG(LL_A, LM_TAPI, ("Failed to alloc a reply packet Cid %d", (ULONG)pCall->DeviceId));
                                                  
            Status = NDIS_STATUS_RESOURCES;
        }
        else
        {
            pCall->Close.Checklist &= ~(CALL_CLOSE_DROP|
                                        CALL_CLOSE_DROP_COMPLETE|
                                        CALL_CLOSE_CLEANUP_STATE);
                                        
            CallSetState(pCall, STATE_CALL_ESTABLISHED, 0, LockHeld);

            pCall->Speed = pCtl->Speed;
            // pCtl is safe to touch because it can't be released from the call
            // without the call spinlock.

            NdisReleaseSpinLock(&pCall->Lock);
            LockHeld = FALSE;

            pReply->PeerCallId = htons(pCall->Remote.CallId);
            pReply->CallId = htons(pCall->Packet.CallId);
            pReply->ResultCode = RESULT_CALL_OUT_CONNECTED;
            pReply->RecvWindowSize = PPTP_RECV_WINDOW;
            pReply->ConnectSpeed = pCall->Speed;
            pReply->ProcessingDelay = 0;
            pReply->PhysicalChannelId = 0;
            
            WPLOG(LL_M, LM_TUNNEL, ("SEND CALL_OUT_REPLY -> %!IPADDR! Cid %d, Pkt-Cid %d, Peer's Cid %d", 
                pCall->Remote.Address.Address[0].Address[0].in_addr, 
                (ULONG)pCall->DeviceId, pCall->Packet.CallId, pCall->Remote.CallId));
            
            Status = CtlSend(pCtl, pReply);
            if (Status!=NDIS_STATUS_SUCCESS)
            {
                DBGTRACE('s');
                gCounters.ulAnswerCtlSendFail++;
            
                DEBUGMSG(DBG_WARN, (DTEXT("TapiAnswer: Failed to send CALL_OUT_REPLY Cid %d\n"), pCall->DeviceId));
                WPLOG(LL_A, LM_TAPI, ("Failed to send CALL_OUT_REPLY Cid %d", (ULONG)pCall->DeviceId));
                
                CallSetState(pCall, STATE_CALL_CLEANUP, LINEDISCONNECTMODE_NORMAL, LockHeld);
                CallCleanup(pCall, LockHeld);
            }
        }
    }
    else if (pCall->State==STATE_CALL_PAC_OFFERING)
    {
        USHORT NewCallId;
        PPTP_CALL_OUT_REPLY_PACKET *pReply = CtlAllocPacket(pCtl, CALL_IN_REPLY);

        CallAssignSerialNumber(pCall);
        if(PptpClientSide)
        {
            NewCallId = (USHORT)((pCall->SerialNumber << CALL_ID_INDEX_BITS) + pCall->DeviceId);
            if (pCall->Packet.CallId == NewCallId)
            {
                // Don't allow a line to have the same CallId twice in a row.
                NewCallId += (1<<CALL_ID_INDEX_BITS);
            }
        }
        else
        {
            NewCallId = (USHORT)pCall->FullDeviceId;
        }
        pCall->Packet.CallId = NewCallId;

        if (!pReply)
        {
            DBGTRACE('r');
            gCounters.ulAnswerNullReply++;
            
            DEBUGMSG(DBG_WARN, (DTEXT("TapiAnswer: Failed to alloc a reply packet Cid %d\n"), pCall->DeviceId));
            WPLOG(LL_A, LM_TAPI, ("Failed to alloc a reply packet Cid %d", (ULONG)pCall->DeviceId));
                
            Status = NDIS_STATUS_RESOURCES;
        }
        else
        {
            pCall->Close.Checklist &= ~(CALL_CLOSE_DROP|
                                        CALL_CLOSE_DROP_COMPLETE|
                                        CALL_CLOSE_CLEANUP_STATE);
            CallSetState(pCall, STATE_CALL_PAC_WAIT, 0, LockHeld);
            
            NdisReleaseSpinLock(&pCall->Lock);
            LockHeld = FALSE;
            
            pReply->PeerCallId = htons(pCall->Remote.CallId);
            pReply->CallId = htons(pCall->Packet.CallId);
            pReply->ResultCode = RESULT_CALL_IN_CONNECTED;
            pReply->RecvWindowSize = PPTP_RECV_WINDOW;
            pReply->ProcessingDelay = 0;
            Status = CtlSend(pCtl, pReply);
            if (Status!=NDIS_STATUS_SUCCESS)
            {
                CallSetState(pCall, STATE_CALL_CLEANUP, LINEDISCONNECTMODE_NORMAL, LockHeld);
                CallCleanup(pCall, LockHeld);
            }
        }
    }
    else
    {
        DEBUGMSG(DBG_WARN, (DTEXT("Wrong state for TapiAnswer %d\n"), pCall->State));
        WPLOG(LL_A, LM_TAPI, ("Wrong state for TapiAnswer %d", pCall->State));
        Status = NDIS_STATUS_FAILURE;
    }

    if (LockHeld)
    {
        NdisReleaseSpinLock(&pCall->Lock);
    }
                
    DEBUGMSG(DBG_FUNC|DBG_ERR(Status), (DTEXT("-TapiAnswer %08x\n"), Status));
    return Status;
}

NDIS_STATUS
TapiClose(
    IN PPPTP_ADAPTER pAdapter,
    IN PNDIS_TAPI_CLOSE pRequest
    )
{
    PCALL_SESSION pCall;
    NDIS_STATUS Status = NDIS_STATUS_SUCCESS;

    DEBUGMSG(DBG_FUNC, (DTEXT("+TapiClose\n")));
    WPLOG(LL_I, LM_TAPI, ("enter"));

    if ( pRequest == NULL || pAdapter == NULL )
    {
        DEBUGMSG(DBG_ERROR|DBG_FUNC, (DTEXT("-TapiClose NDIS_STATUS_TAPI_INVALPARAM\n")));
        WPLOG(LL_A, LM_TAPI, ("-NDIS_STATUS_TAPI_INVALPARAM"));
        return NDIS_STATUS_TAPI_INVALPARAM;
    }

    if (!CallIsValidCall(pAdapter, TapiLineHandleToId(pRequest->hdLine)))
    {
        DEBUGMSG(DBG_ERROR|DBG_FUNC, (DTEXT("-TapiClose NDIS_STATUS_TAPI_INVALLINEHANDLE\n")));
        WPLOG(LL_A, LM_TAPI, ("-NDIS_STATUS_TAPI_INVALLINEHANDLE"));
        return NDIS_STATUS_TAPI_INVALLINEHANDLE;
    }

    NdisAcquireSpinLock(&pAdapter->Lock);
    pAdapter->Tapi.Open = FALSE;
    NdisReleaseSpinLock(&pAdapter->Lock);
    if (pAdapter->hCtdiListen)
    {
        // We have to pend this request until the listen endpoint is closed
        CtdiSetRequestPending(pAdapter->hCtdiListen);
        CtdiClose(pAdapter->hCtdiListen);
        pAdapter->hCtdiListen = NULL;
        Status = NDIS_STATUS_PENDING;
    }

    DEBUGMSG(DBG_FUNC, (DTEXT("-TapiClose\n")));
    WPLOG(LL_I, LM_TAPI, ("exit"));
    return Status;
}

NDIS_STATUS
TapiCloseCall(
    IN PPPTP_ADAPTER pAdapter,
    IN PNDIS_TAPI_CLOSE_CALL pRequest
    )
{
    PCALL_SESSION pCall;
    DEBUGMSG(DBG_FUNC, (DTEXT("+TapiCloseCall\n")));

    if ( pRequest == NULL || pAdapter == NULL )
    {
        gCounters.ulCloseCallNullRequest++;
    
        DEBUGMSG(DBG_ERROR|DBG_FUNC, (DTEXT("-TapiCloseCall NDIS_STATUS_TAPI_INVALPARAM\n")));
        WPLOG(LL_A, LM_TAPI, ("-NDIS_STATUS_TAPI_INVALPARAM"));
        return NDIS_STATUS_TAPI_INVALPARAM;
    }

    // Verify the ID
    pCall = CallGetCall(pAdapter, pRequest->hdCall);

    if (!pCall)
    {
        gCounters.ulCloseCallNullCall++;
    
        DEBUGMSG(DBG_FUNC|DBG_ERROR, (DTEXT("-TapiCloseCall NDIS_STATUS_TAPI_INVALCALLHANDLE\n")));
        WPLOG(LL_A, LM_TAPI, ("-NDIS_STATUS_TAPI_INVALCALLHANDLE"));
        return NDIS_STATUS_TAPI_INVALLINEHANDLE;
    }
    
    DBGTRACE('C');
    WPLOG(LL_M, LM_TAPI, ("Cid %d", (ULONG)pCall->DeviceId));
    
    NdisAcquireSpinLock(&pCall->Lock);
    pCall->Close.Checklist |= CALL_CLOSE_CLOSE_CALL;
    pCall->hTapiCall = 0;
    CallCleanup(pCall, LOCKED);
    NdisReleaseSpinLock(&pCall->Lock);

    DEBUGMSG(DBG_FUNC, (DTEXT("-TapiCloseCall\n")));
    return NDIS_STATUS_SUCCESS;
}

NDIS_STATUS
TapiDrop(
    IN PPPTP_ADAPTER pAdapter,
    IN PNDIS_TAPI_DROP pRequest
    )
{
    PCALL_SESSION pCall;
    PCONTROL_TUNNEL pCtl;
    NDIS_STATUS Status = NDIS_STATUS_SUCCESS;
    BOOLEAN CleanupNow = FALSE;

    DEBUGMSG(DBG_FUNC, (DTEXT("+TapiDrop\n")));
        
    if ( pRequest == NULL || pAdapter == NULL )
    {
        gCounters.ulDropNullRequest++;
    
        DEBUGMSG(DBG_ERROR|DBG_FUNC, (DTEXT("-TapiDrop NDIS_STATUS_TAPI_INVALPARAM\n")));
        WPLOG(LL_A, LM_TAPI, ("-NDIS_STATUS_TAPI_INVALPARAM"));
        return NDIS_STATUS_TAPI_INVALPARAM;
    }
    
    // Verify the ID
    pCall = CallGetCall(pAdapter, pRequest->hdCall);

    if (!pCall)
    {
        gCounters.ulDropNullCall++;
    
        DEBUGMSG(DBG_FUNC|DBG_ERROR, (DTEXT("-TapiDrop NDIS_STATUS_TAPI_INVALCALLHANDLE\n")));
        WPLOG(LL_A, LM_TAPI, ("-NDIS_STATUS_TAPI_INVALCALLHANDLE"));
        return NDIS_STATUS_TAPI_INVALCALLHANDLE;
    }

    DBGTRACE('D');
    WPLOG(LL_M, LM_TAPI, ("Drop pCall %p, Cid %d, pCtl %p",
        pCall, (ULONG)pCall->DeviceId, pCall->pCtl));
        
    NdisAcquireSpinLock(&pCall->Lock);

    //ASSERT(!(pCall->Close.Checklist&CALL_CLOSE_DROP));

    pCtl = pCall->pCtl;

    if (!pCtl)
    {
        DBGTRACE('t');
        gCounters.ulDropNullControl++;
    
        DEBUGMSG(DBG_WARN, (DTEXT("TapiDrop: No control tunnel Cid %d\n"), pCall->DeviceId));
        WPLOG(LL_I, LM_TAPI, ("No control tunnel Cid %d", (ULONG)pCall->DeviceId));
        Status = NDIS_STATUS_FAILURE;
    }
    else if (pCall->State==STATE_CALL_ESTABLISHED)
    {
        PPPTP_CALL_CLEAR_REQUEST_PACKET pPacket = CtlAllocPacket(pCtl, CALL_CLEAR_REQUEST);

        if (!pPacket)
        {
            DBGTRACE('p');
            gCounters.ulDropNullPacket++;
        
            DEBUGMSG(DBG_WARN, (DTEXT("TapiDrop: Failed to alloc CALL_CLEAR_REQUEST Cid %d\n"), pCall->DeviceId));
            WPLOG(LL_A, LM_TAPI, ("Failed to alloc CALL_CLEAR_REQUEST Cid %d", (ULONG)pCall->DeviceId));
            Status = NDIS_STATUS_RESOURCES;
        }
        else
        {
            CallSetState(pCall, STATE_CALL_WAIT_DISCONNECT, 0, LOCKED);
            pPacket->CallId = htons(pCall->Packet.CallId);

            NdisReleaseSpinLock(&pCall->Lock);
            
            WPLOG(LL_M, LM_TUNNEL, ("SEND CALL_CLEAR_REQUEST -> %!IPADDR! pCall %p, Cid %d, Pkt-Cid %d", 
                pCtl->Remote.Address.Address[0].Address[0].in_addr, 
                pCall, (ULONG)pCall->DeviceId, pCall->Packet.CallId));
            
            Status = CtlSend(pCtl, pPacket);
            if (Status==NDIS_STATUS_SUCCESS)
            {
                Status = NDIS_STATUS_PENDING;
            }
            else             
            {
                DBGTRACE('s');
                gCounters.ulDropCtlSendFail++;
                DEBUGMSG(DBG_WARN, (DTEXT("TapiDrop: Failed to send CALL_CLEAR_REQUEST Cid %d\n"), pCall->DeviceId));
                WPLOG(LL_A, LM_TAPI, ("Failed to send CALL_CLEAR_REQUEST Cid %d", (ULONG)pCall->DeviceId));
                
            }
            if (Status==NDIS_STATUS_PENDING)
            {
                NdisMSetTimer(&pCall->Close.Timer, PPTP_CLOSE_TIMEOUT);
            }
            NdisAcquireSpinLock(&pCall->Lock);
        }
    }
    else if (pCall->State!=STATE_CALL_CLEANUP)
    {
        CallSetState(pCall, STATE_CALL_CLEANUP, 0, LOCKED);
        CleanupNow = TRUE;
    }

    pCall->Close.Checklist |= CALL_CLOSE_DROP;
    if (Status==NDIS_STATUS_PENDING)
    {
        pCall->Close.Checklist &= ~CALL_CLOSE_DROP_COMPLETE;
    }
    else
    {
        pCall->Close.Checklist |= CALL_CLOSE_DROP_COMPLETE;
    }
    if (CleanupNow)
    {
        CallCleanup(pCall, LOCKED);
    }
    NdisReleaseSpinLock(&pCall->Lock);

    DEBUGMSG(DBG_FUNC|DBG_ERR(Status), (DTEXT("-TapiDrop %08x\n"), Status));
    return Status;
}

NDIS_STATUS
TapiGetAddressCaps(
    IN PPPTP_ADAPTER pAdapter,
    IN OUT PNDIS_TAPI_GET_ADDRESS_CAPS pRequest
    )
{
    BOOLEAN ValidCall;
    CHAR LineAddress[TAPI_MAX_LINE_ADDRESS_LENGTH];
    DEBUGMSG(DBG_FUNC, (DTEXT("+TapiGetAddressCaps\n")));

    if ( pRequest == NULL || pAdapter == NULL )
    {
        DEBUGMSG(DBG_ERROR|DBG_FUNC, (DTEXT("-TapiGetAddressCaps NDIS_STATUS_TAPI_INVALPARAM\n")));
        WPLOG(LL_A, LM_TAPI, ("-NDIS_STATUS_TAPI_INVALPARAM"));
        return NDIS_STATUS_TAPI_INVALPARAM;
    }

    ValidCall = CallIsValidCall(pAdapter, pRequest->ulDeviceID);

    if (!ValidCall)
    {
        DEBUGMSG(DBG_ERROR|DBG_FUNC, (DTEXT("-TapiGetAddressCaps NDIS_STATUS_TAPI_NODRIVER\n")));
        WPLOG(LL_A, LM_TAPI, ("-NDIS_STATUS_TAPI_NODRIVER"));
        return NDIS_STATUS_TAPI_NODRIVER;
    }

    if (pRequest->ulAddressID >= TAPI_ADDR_PER_LINE)
    {
        DEBUGMSG(DBG_FUNC|DBG_ERROR, (DTEXT("-TapiGetAddressCaps NDIS_STATUS_TAPI_INVALADDRESSID\n")));
        WPLOG(LL_A, LM_TAPI, ("-NDIS_STATUS_TAPI_INVALADDRESSID"));
        return NDIS_STATUS_TAPI_INVALADDRESSID;

    }

    if (pRequest->ulExtVersion!=0 &&
        pRequest->ulExtVersion!=TAPI_EXT_VERSION)
    {
        DEBUGMSG(DBG_FUNC|DBG_ERROR, (DTEXT("-TapiGetAddressCaps NDIS_STATUS_TAPI_INCOMPATIBLEEXTVERSION\n")));
        WPLOG(LL_A, LM_TAPI, ("-NDIS_STATUS_TAPI_INCOMPATIBLEEXTVERSION"));
        return NDIS_STATUS_TAPI_INCOMPATIBLEEXTVERSION;
    }

    pRequest->LineAddressCaps.ulDialToneModes     = LINEDIALTONEMODE_NORMAL;
    pRequest->LineAddressCaps.ulSpecialInfo       = LINESPECIALINFO_UNAVAIL;

    pRequest->LineAddressCaps.ulDisconnectModes   = LINEDISCONNECTMODE_NORMAL |
                                                    LINEDISCONNECTMODE_UNKNOWN |
                                                    LINEDISCONNECTMODE_BUSY |
                                                    LINEDISCONNECTMODE_NOANSWER;

    pRequest->LineAddressCaps.ulMaxNumActiveCalls = pAdapter->Info.Endpoints;
    pRequest->LineAddressCaps.ulMaxNumTransConf   = 1;
    pRequest->LineAddressCaps.ulAddrCapFlags      = LINEADDRCAPFLAGS_DIALED;

    pRequest->LineAddressCaps.ulCallFeatures      = LINECALLFEATURE_ACCEPT |
                                                    LINECALLFEATURE_ANSWER |
                                                    LINECALLFEATURE_COMPLETECALL |
                                                    LINECALLFEATURE_DIAL |
                                                    LINECALLFEATURE_DROP;

    pRequest->LineAddressCaps.ulLineDeviceID      = pRequest->ulDeviceID;
    pRequest->LineAddressCaps.ulAddressSharing    = LINEADDRESSSHARING_PRIVATE;
    pRequest->LineAddressCaps.ulAddressStates     = 0;

    // List of all possible call states.

    pRequest->LineAddressCaps.ulCallStates        = LINECALLSTATE_IDLE |
                                                    LINECALLSTATE_OFFERING |
                                                    LINECALLSTATE_DIALING |
                                                    LINECALLSTATE_PROCEEDING |
                                                    LINECALLSTATE_CONNECTED |
                                                    LINECALLSTATE_DISCONNECTED;

    OsGetTapiLineAddress(DeviceIdToIndex(pAdapter, pRequest->ulDeviceID),
                         LineAddress,
                         sizeof(LineAddress));

    pRequest->LineAddressCaps.ulNeededSize = sizeof(pRequest->LineAddressCaps) +
                                             strlen(LineAddress) + 1;

    if (pRequest->LineAddressCaps.ulTotalSize<pRequest->LineAddressCaps.ulNeededSize)
    {
        pRequest->LineAddressCaps.ulUsedSize = 0;
        DEBUGMSG(DBG_FUNC|DBG_ERROR, (DTEXT("-TapiGetAddressCaps NDIS_STATUS_INVALID_LENGTH\n")));
        WPLOG(LL_A, LM_TAPI, ("-NDIS_STATUS_INVALID_LENGTH"));
        return NDIS_STATUS_INVALID_LENGTH;
    }

    pRequest->LineAddressCaps.ulAddressSize = strlen(LineAddress) + 1;
    pRequest->LineAddressCaps.ulAddressOffset = sizeof(pRequest->LineAddressCaps);
    strcpy((PUCHAR)((&pRequest->LineAddressCaps) + 1), LineAddress);

    pRequest->LineAddressCaps.ulUsedSize = pRequest->LineAddressCaps.ulNeededSize;

    DEBUGMSG(DBG_FUNC, (DTEXT("-TapiGetAddressCaps\n")));
    return NDIS_STATUS_SUCCESS;
}

NDIS_STATUS
TapiGetAddressStatus(
    IN PPPTP_ADAPTER pAdapter,
    IN OUT PNDIS_TAPI_GET_ADDRESS_STATUS pRequest
    )
{
    PCALL_SESSION pCall = NULL;
    BOOLEAN fReady;

    DEBUGMSG(DBG_FUNC, (DTEXT("+TapiGetAddressStatus\n")));

    if ( pRequest == NULL || pAdapter == NULL )
    {
        DEBUGMSG(DBG_ERROR|DBG_FUNC, (DTEXT("-TapiGetAddressStatus NDIS_STATUS_TAPI_INVALPARAM\n")));
        WPLOG(LL_A, LM_TAPI, ("-NDIS_STATUS_TAPI_INVALPARAM"));
        return NDIS_STATUS_TAPI_INVALPARAM;
    }

    
    DEBUGMSG(DBG_TAPI, (DTEXT("TapiGetAddressStatus: hdLine=%Xh, ulAddressID=%d\n"),
               pRequest->hdLine, pRequest->ulAddressID));


    if (!CallIsValidCall(pAdapter, TapiLineHandleToId(pRequest->hdLine)))
    {
        DEBUGMSG(DBG_FUNC|DBG_ERROR, (DTEXT("-TapiGetAddressStatus NDIS_STATUS_TAPI_INVALCALLHANDLE\n")));
        WPLOG(LL_A, LM_TAPI, ("-NDIS_STATUS_TAPI_INVALCALLHANDLE"));
        return NDIS_STATUS_TAPI_INVALCALLHANDLE;
    }

    if (pRequest->ulAddressID >= TAPI_ADDR_PER_LINE)
    {
        DEBUGMSG(DBG_FUNC|DBG_ERROR, (DTEXT("-TapiGetAddressStatus NDIS_STATUS_TAPI_INVALADDRESSID\n")));
        WPLOG(LL_A, LM_TAPI, ("-NDIS_STATUS_TAPI_INVALADDRESSID"));
        return NDIS_STATUS_TAPI_INVALADDRESSID;
    }

    pRequest->LineAddressStatus.ulNeededSize =
    pRequest->LineAddressStatus.ulUsedSize = sizeof(pRequest->LineAddressStatus);

    pRequest->LineAddressStatus.ulNumInUse = 1;
    pRequest->LineAddressStatus.ulNumActiveCalls = 1;
    pRequest->LineAddressStatus.ulAddressFeatures = LINEADDRFEATURE_MAKECALL;
    pRequest->LineAddressStatus.ulNumRingsNoAnswer = 999;

    DEBUGMSG(DBG_FUNC, (DTEXT("-TapiGetAddressStatus\n")));
    return NDIS_STATUS_SUCCESS;

}


NDIS_STATUS
TapiGetCallInfo(
    IN PPPTP_ADAPTER pAdapter,
    IN OUT PNDIS_TAPI_GET_CALL_INFO pRequest,
    IN OUT PULONG pRequiredLength
    )
{
    PCALL_SESSION pCall;
    LINE_CALL_INFO *pLineCallInfo = NULL;
    ULONG CallerIdLength;

    DEBUGMSG(DBG_FUNC, (DTEXT("+TapiGetCallInfo\n")));

    if ( pRequest == NULL || pAdapter == NULL )
    {
        DEBUGMSG(DBG_ERROR|DBG_FUNC, (DTEXT("-TapiGetCallInfo NDIS_STATUS_TAPI_INVALPARAM\n")));
        WPLOG(LL_A, LM_TAPI, ("-NDIS_STATUS_TAPI_INVALPARAM"));
        return NDIS_STATUS_TAPI_INVALPARAM;
    }
    
    pLineCallInfo = &pRequest->LineCallInfo;

    // Verify the ID
    pCall = CallGetCall(pAdapter, pRequest->hdCall);

    if (!pCall)
    {
        DEBUGMSG(DBG_FUNC, (DTEXT("-TapiGetCallInfo NDIS_STATUS_TAPI_INVALCALLHANDLE\n")));
        WPLOG(LL_A, LM_TAPI, ("-NDIS_STATUS_TAPI_INVALCALLHANDLE"));
        return NDIS_STATUS_TAPI_INVALCALLHANDLE;
    }

    CallerIdLength = strlen(pCall->CallerId);
    if( CallerIdLength ){
        CallerIdLength += 1; // Add one for null terminator
    }
    if( pRequiredLength ){
        // Note: This returns NDIS struct size not LineCallInfo Size
        *pRequiredLength = sizeof(NDIS_TAPI_GET_CALL_INFO) + CallerIdLength;
        DEBUGMSG(DBG_FUNC, (DTEXT("-TapiGetCallInfo NDIS_STATUS_SUCCESS - Returning Length Only Len=0x%X\n"), *pRequiredLength));
        return NDIS_STATUS_SUCCESS;
    }

    pLineCallInfo->ulNeededSize = sizeof(pRequest->LineCallInfo) + CallerIdLength;

    if( pLineCallInfo->ulTotalSize < sizeof(pRequest->LineCallInfo) ){
        pLineCallInfo->ulUsedSize = 0;
        DEBUGMSG(DBG_FUNC|DBG_ERROR, (DTEXT("-TapiGetCallInfo NDIS_STATUS_INVALID_LENGTH\n")));
        WPLOG(LL_A, LM_TAPI, ("-NDIS_STATUS_INVALID_LENGTH"));
        return NDIS_STATUS_INVALID_LENGTH;
    }

    pLineCallInfo->ulUsedSize = sizeof(pRequest->LineCallInfo);

    pLineCallInfo->hLine = (ULONG)pCall->DeviceId;
    pLineCallInfo->ulLineDeviceID = (ULONG)pCall->DeviceId;
    pLineCallInfo->ulAddressID = TAPI_ADDRESSID;

    pLineCallInfo->ulBearerMode = LINEBEARERMODE_DATA;
    pLineCallInfo->ulRate = pCall->Speed;
    pLineCallInfo->ulMediaMode = pCall->MediaModeMask;

    pLineCallInfo->ulCallParamFlags = LINECALLPARAMFLAGS_IDLE;
    pLineCallInfo->ulCallStates = CALL_STATES_MASK;

    pLineCallInfo->ulCallerIDFlags = LINECALLPARTYID_UNAVAIL;
    pLineCallInfo->ulCallerIDSize = 0;
    pLineCallInfo->ulCalledIDOffset = 0;
    pLineCallInfo->ulCalledIDFlags = LINECALLPARTYID_UNAVAIL;
    pLineCallInfo->ulCalledIDSize = 0;

    if( CallerIdLength ){
        if (pLineCallInfo->ulTotalSize >= pLineCallInfo->ulNeededSize)
        {
            PUCHAR pCallerId = (PUCHAR)(pLineCallInfo + 1);

            strcpy(pCallerId, pCall->CallerId);
            if (pCall->Inbound)
            {
                pLineCallInfo->ulCallerIDFlags = LINECALLPARTYID_ADDRESS;
                pLineCallInfo->ulCallerIDSize = CallerIdLength;
                pLineCallInfo->ulCallerIDOffset = sizeof(LINE_CALL_INFO);
            }
            else
            {
                pLineCallInfo->ulCalledIDFlags = LINECALLPARTYID_ADDRESS;
                pLineCallInfo->ulCalledIDSize = CallerIdLength;
                pLineCallInfo->ulCalledIDOffset = sizeof(LINE_CALL_INFO);
            }

            pLineCallInfo->ulUsedSize = pLineCallInfo->ulNeededSize;

        }else{
            DEBUGMSG(DBG_FUNC|DBG_WARN, (DTEXT("-TapiGetCallInfo NDIS_STATUS_SUCCESS without CallerID string\n")));
            WPLOG(LL_I, LM_TAPI, ("-NDIS_STATUS_SUCCESS without CallerID string"));
            return NDIS_STATUS_SUCCESS;
        }
    }

    DEBUGMSG(DBG_FUNC, (DTEXT("-TapiGetCallInfo\n")));
    return NDIS_STATUS_SUCCESS;
}

NDIS_STATUS
TapiGetCallStatus(
    IN PPPTP_ADAPTER pAdapter,
    IN OUT PNDIS_TAPI_GET_CALL_STATUS pRequest
    )
{
    PCALL_SESSION pCall;

    DEBUGMSG(DBG_FUNC, (DTEXT("+TapiGetCallStatus\n")));

    if ( pRequest == NULL || pAdapter == NULL )
    {
        DEBUGMSG(DBG_ERROR|DBG_FUNC, (DTEXT("-TapiGetCallStatus NDIS_STATUS_TAPI_INVALPARAM\n")));
        WPLOG(LL_A, LM_TAPI, ("-NDIS_STATUS_TAPI_INVALPARAM"));
        return NDIS_STATUS_TAPI_INVALPARAM;
    }

    // Verify the ID
    pCall = CallGetCall(pAdapter, pRequest->hdCall);

    if (!pCall)
    {
        DEBUGMSG(DBG_FUNC|DBG_ERROR, (DTEXT("-TapiGetCallStatus NDIS_STATUS_TAPI_INVALCALLHANDLE\n")));
        WPLOG(LL_A, LM_TAPI, ("-NDIS_STATUS_TAPI_INVALCALLHANDLE"));
        return NDIS_STATUS_TAPI_INVALCALLHANDLE;
    }

    pRequest->LineCallStatus.ulNeededSize =
        pRequest->LineCallStatus.ulUsedSize = sizeof(LINE_CALL_STATUS);

    pRequest->LineCallStatus.ulCallFeatures = LINECALLFEATURE_ANSWER | LINECALLFEATURE_DROP;
    pRequest->LineCallStatus.ulCallPrivilege = LINECALLPRIVILEGE_OWNER;
    pRequest->LineCallStatus.ulCallState = CallGetLineCallState(pCall->State);

    DBG_X(DBG_TAPI, pRequest->LineCallStatus.ulCallState);

    switch (pRequest->LineCallStatus.ulCallState)
    {
        case LINECALLSTATE_DIALTONE:
            pRequest->LineCallStatus.ulCallStateMode = LINEDIALTONEMODE_NORMAL;
            break;
        case LINECALLSTATE_BUSY:
            pRequest->LineCallStatus.ulCallStateMode = LINEBUSYMODE_STATION;
            break;
        case LINECALLSTATE_DISCONNECTED:
            pRequest->LineCallStatus.ulCallStateMode = LINEDISCONNECTMODE_UNKNOWN;
            break;
        default:
            break;
    }
    DEBUGMSG(DBG_FUNC, (DTEXT("-TapiGetCallStatus\n")));
    return NDIS_STATUS_SUCCESS;
}

NDIS_STATUS
TapiGetDevCaps(
    IN PPPTP_ADAPTER pAdapter,
    IN OUT PNDIS_TAPI_GET_DEV_CAPS pRequest
    )
{
    BOOLEAN ValidCall;
    NDIS_STATUS Status;

    DEBUGMSG(DBG_FUNC, (DTEXT("+TapiGetDevCaps\n")));

    if ( pRequest == NULL || pAdapter == NULL )
    {
        DEBUGMSG(DBG_ERROR|DBG_FUNC, (DTEXT("-TapiGetDevCaps NDIS_STATUS_TAPI_INVALPARAM\n")));
        WPLOG(LL_A, LM_TAPI, ("-NDIS_STATUS_TAPI_INVALPARAM"));
        return NDIS_STATUS_TAPI_INVALPARAM;
    }

    // Verify the ID
    ValidCall = CallIsValidCall(pAdapter, pRequest->ulDeviceID);

    if (!ValidCall)
    {
        DEBUGMSG(DBG_ERROR|DBG_FUNC, (DTEXT("-TapiGetDevCaps NDIS_STATUS_TAPI_NODRIVER\n")));
        WPLOG(LL_A, LM_TAPI, ("-NDIS_STATUS_TAPI_NODRIVER"));
        return NDIS_STATUS_TAPI_NODRIVER;
    }

    pRequest->LineDevCaps.ulUsedSize = sizeof(pRequest->LineDevCaps);

    pRequest->LineDevCaps.ulAddressModes = LINEADDRESSMODE_ADDRESSID |
                                           LINEADDRESSMODE_DIALABLEADDR;
    pRequest->LineDevCaps.ulNumAddresses = 1;
    pRequest->LineDevCaps.ulBearerModes  = LINEBEARERMODE_DATA;

    pRequest->LineDevCaps.ulDevCapFlags  = LINEDEVCAPFLAGS_CLOSEDROP;
    pRequest->LineDevCaps.ulMaxNumActiveCalls = pAdapter->Info.Endpoints;
    pRequest->LineDevCaps.ulAnswerMode   = LINEANSWERMODE_DROP;
    pRequest->LineDevCaps.ulRingModes    = 1;

    pRequest->LineDevCaps.ulPermanentLineID = pRequest->ulDeviceID + 1;
    pRequest->LineDevCaps.ulMaxRate      = 0;
    pRequest->LineDevCaps.ulMediaModes   = LINEMEDIAMODE_DIGITALDATA;

    Status = OsSpecificTapiGetDevCaps( pRequest->ulDeviceID, pRequest );

    DEBUGMSG(DBG_FUNC, (DTEXT("-TapiGetDevCaps\n")));
    return Status;
}

NDIS_STATUS
TapiGetExtensionId(
    IN PPPTP_ADAPTER pAdapter,
    IN OUT PNDIS_TAPI_GET_EXTENSION_ID pRequest
    )
{
    BOOLEAN ValidCall;
    DEBUGMSG(DBG_FUNC, (DTEXT("+TapiGetExtensionId\n")));

    if ( pRequest == NULL || pAdapter == NULL )
    {
        DEBUGMSG(DBG_ERROR|DBG_FUNC, (DTEXT("-TapiGetExtensionId NDIS_STATUS_TAPI_INVALPARAM\n")));
        WPLOG(LL_A, LM_TAPI, ("-NDIS_STATUS_TAPI_INVALPARAM"));
        return NDIS_STATUS_TAPI_INVALPARAM;
    }

    // Verify the ID
    ValidCall = CallIsValidCall(pAdapter, pRequest->ulDeviceID);
    if (!ValidCall)
    {
        DEBUGMSG(DBG_ERROR|DBG_FUNC, (DTEXT("-TapiGetExtensionId NDIS_STATUS_TAPI_NODRIVER\n")));
        WPLOG(LL_A, LM_TAPI, ("-NDIS_STATUS_TAPI_NODRIVER"));
        return NDIS_STATUS_TAPI_NODRIVER;
    }

    // No extensions supported.
    pRequest->LineExtensionID.ulExtensionID0 = 0;
    pRequest->LineExtensionID.ulExtensionID1 = 0;
    pRequest->LineExtensionID.ulExtensionID2 = 0;
    pRequest->LineExtensionID.ulExtensionID3 = 0;

    DEBUGMSG(DBG_FUNC, (DTEXT("-TapiGetExtensionId\n")));
    return NDIS_STATUS_SUCCESS;
}

#define PPTP_DEVICE_TYPE_STR "PPTP"

NDIS_STATUS
TapiGetId(
    IN PPPTP_ADAPTER pAdapter,
    IN OUT PNDIS_TAPI_GET_ID pRequest
    )
{
    PCALL_SESSION pCall;
    ULONG_PTR DeviceID;
    BOOLEAN IsNdisClass;

    DEBUGMSG(DBG_FUNC, (DTEXT("+TapiGetId\n")));

    if ( pRequest == NULL || pAdapter == NULL )
    {
        DEBUGMSG(DBG_ERROR|DBG_FUNC, (DTEXT("-TapiGetId NDIS_STATUS_TAPI_INVALPARAM\n")));
        WPLOG(LL_A, LM_TAPI, ("-NDIS_STATUS_TAPI_INVALPARAM"));
        return NDIS_STATUS_TAPI_INVALPARAM;
    }

    // Make sure this is a tapi or ndis request.
    if (pRequest->ulDeviceClassSize == sizeof(NDIS_DEVICECLASS_NAME) &&
        _strnicmp((PCHAR) pRequest + pRequest->ulDeviceClassOffset,
                  NDIS_DEVICECLASS_NAME, pRequest->ulDeviceClassSize) == 0)
    {
        IsNdisClass = TRUE;
    }
    else if (pRequest->ulDeviceClassSize == sizeof(TAPI_DEVICECLASS_NAME) && 
        _strnicmp((PCHAR) pRequest + pRequest->ulDeviceClassOffset,
                  TAPI_DEVICECLASS_NAME, pRequest->ulDeviceClassSize) == 0)
    {
        IsNdisClass = FALSE;
    }
    else
    {
        DEBUGMSG(DBG_ERROR|DBG_FUNC, (DTEXT("-TapiGetId NDIS_STATUS_TAPI_INVALDEVICECLASS\n")));
        WPLOG(LL_A, LM_TAPI, ("-NDIS_STATUS_TAPI_INVALDEVICECLASS"));
        return NDIS_STATUS_TAPI_INVALDEVICECLASS;
    }
    

    DBG_D(DBG_TAPI, pRequest->ulSelect);

#if DBG    

    if(pRequest->ulDeviceClassSize != 0)
    {
        DBG_S(DBG_TAPI, (PCHAR) pRequest + pRequest->ulDeviceClassOffset);
    }
    
#endif    

    switch (pRequest->ulSelect) {
        case LINECALLSELECT_LINE:
            if (!CallIsValidCall(pAdapter, TapiLineHandleToId(pRequest->hdLine)))
            {
                DEBUGMSG(DBG_ERROR|DBG_FUNC, (DTEXT("-TapiGetId NDIS_STATUS_TAPI_INVALLINEHANDLE\n")));
                WPLOG(LL_A, LM_TAPI, ("-NDIS_STATUS_TAPI_INVALLINEHANDLE"));
                return NDIS_STATUS_TAPI_INVALLINEHANDLE;
            }
            DeviceID = 0;

            break;

        case LINECALLSELECT_ADDRESS:
            if (!CallIsValidCall(pAdapter, TapiLineHandleToId(pRequest->hdLine)))
            {
                DEBUGMSG(DBG_ERROR|DBG_FUNC, (DTEXT("-TapiGetId NDIS_STATUS_TAPI_INVALLINEHANDLE\n")));
                WPLOG(LL_A, LM_TAPI, ("-NDIS_STATUS_TAPI_INVALLINEHANDLE"));
                return NDIS_STATUS_TAPI_INVALLINEHANDLE;
            }
            if (pRequest->ulAddressID >= TAPI_ADDR_PER_LINE)
            {
                DEBUGMSG(DBG_ERROR|DBG_FUNC, (DTEXT("-TapiGetId NDIS_STATUS_TAPI_INVALADDRESSID\n")));
                WPLOG(LL_A, LM_TAPI, ("-NDIS_STATUS_TAPI_INVALADDRESSID"));
                return NDIS_STATUS_TAPI_INVALADDRESSID;
            }
            DeviceID = 0;
            break;

        case LINECALLSELECT_CALL:
            pCall = CallGetCall(pAdapter, pRequest->hdCall);

            if (pCall == NULL)
            {
                DEBUGMSG(DBG_ERROR|DBG_FUNC, (DTEXT("-TapiGetId NDIS_STATUS_TAPI_INVALLINEHANDLE\n")));
                WPLOG(LL_A, LM_TAPI, ("-NDIS_STATUS_TAPI_INVALLINEHANDLE"));
                return NDIS_STATUS_TAPI_INVALLINEHANDLE;
            }
            TapiLineUp(pCall);

            DeviceID = (ULONG_PTR)pCall->NdisLinkContext;

            break;

        default:
            DEBUGMSG(DBG_ERROR|DBG_FUNC, (DTEXT("-TapiGetId NDIS_STATUS_FAILURE ulSelect=%d\n"), pRequest->ulSelect));
            WPLOG(LL_A, LM_TAPI, ("-NDIS_STATUS_FAILURE ulSelect=%d", pRequest->ulSelect));
            return (NDIS_STATUS_FAILURE);

    }

    // Default to the minimum amount of data we will return.
    pRequest->DeviceID.ulUsedSize = sizeof(VAR_STRING);

    if( IsNdisClass ){
        // The format of the DeviceID for the "ndis" class is:
        struct _NDIS_CLASS {
            ULONG_PTR   hDevice;
            CHAR        szDeviceType[1];
        } *pNDISClass;

        pRequest->DeviceID.ulNeededSize =sizeof(VAR_STRING) + sizeof(PVOID) + 
            sizeof(DeviceID) + sizeof(PPTP_DEVICE_TYPE_STR);

        if (pRequest->DeviceID.ulTotalSize >= pRequest->DeviceID.ulNeededSize)
        {
            pRequest->DeviceID.ulUsedSize = pRequest->DeviceID.ulNeededSize;
            pRequest->DeviceID.ulStringFormat = STRINGFORMAT_BINARY;
            pRequest->DeviceID.ulStringSize   = sizeof(DeviceID) + sizeof(PPTP_DEVICE_TYPE_STR);

            pNDISClass = (struct _NDIS_CLASS *)
                ((PUCHAR)((&pRequest->DeviceID) + 1) + sizeof(PVOID));

            (ULONG_PTR)pNDISClass &=
                ~((ULONG_PTR)sizeof(PVOID) - 1);

            pRequest->DeviceID.ulStringOffset = (ULONG)
                ((PUCHAR)pNDISClass - (PUCHAR)(&pRequest->DeviceID));

            pNDISClass->hDevice = DeviceID;

            DBG_X(DBG_TAPI, pNDISClass->hDevice);
            NdisMoveMemory(pNDISClass->szDeviceType, PPTP_DEVICE_TYPE_STR, sizeof(PPTP_DEVICE_TYPE_STR));
        }

    }else{
        // Now we need to adjust the variable field to place the device ID.

        pRequest->DeviceID.ulNeededSize = sizeof(VAR_STRING) + sizeof(DeviceID);
        if (pRequest->DeviceID.ulTotalSize >= pRequest->DeviceID.ulNeededSize)
        {
            pRequest->DeviceID.ulUsedSize = pRequest->DeviceID.ulNeededSize;
            pRequest->DeviceID.ulStringFormat = STRINGFORMAT_BINARY;
            pRequest->DeviceID.ulStringSize   = sizeof(DeviceID);
            pRequest->DeviceID.ulStringOffset = sizeof(VAR_STRING);

            *(PULONG_PTR)((&pRequest->DeviceID) + 1) = DeviceID;
        }
    }

    //DEBUGMEM(DBG_TAPI, &pRequest->DeviceID, pRequest->DeviceID.ulUsedSize, 1);

    DEBUGMSG(DBG_FUNC, (DTEXT("-TapiGetId\n")));
    return NDIS_STATUS_SUCCESS;
}

VOID
TapiLineDown(
    PCALL_SESSION pCall
    )
{
    NDIS_MAC_LINE_DOWN LineDownInfo;
    DEBUGMSG(DBG_FUNC|DBG_CALL|DBG_TAPI, (DTEXT("+TapiLineDown %08x\n"), pCall->NdisLinkContext));

    if (pCall->NdisLinkContext)
    {
        LineDownInfo.NdisLinkContext = pCall->NdisLinkContext;

        WPLOG(LL_M, LM_TAPI, ("LINE_DOWN %!IPADDR! pCall %p, Cid %d\n",
            pCall->Remote.Address.Address[0].Address[0].in_addr,
            pCall, (ULONG)pCall->DeviceId));
        /*
        * Indicate the event to the WAN wrapper.
        */
        NdisMIndicateStatus(pCall->pAdapter->hMiniportAdapter,
                            NDIS_STATUS_WAN_LINE_DOWN,
                            &LineDownInfo,
                            sizeof(LineDownInfo));
        pCall->NdisLinkContext = NULL;
    }
    else
    {
        WPLOG(LL_A, LM_TAPI, ("LINE_DOWN %!IPADDR! pCall %p, Cid %d - No NdisLinkContext",
            pCall->Remote.Address.Address[0].Address[0].in_addr,
            pCall, (ULONG)pCall->DeviceId));
    }
    DEBUGMSG(DBG_FUNC, (DTEXT("-TapiLineDown\n")));
}

VOID
TapiLineUp(
    PCALL_SESSION pCall
    )
{
    NDIS_MAC_LINE_UP LineUpInfo;

    DEBUGMSG(DBG_FUNC|DBG_CALL|DBG_TAPI, (DTEXT("+TapiLineUp %08x\n"), pCall));

    NdisAcquireSpinLock(&pCall->Lock);
    pCall->Close.Checklist &= ~CALL_CLOSE_LINE_DOWN;
    NdisReleaseSpinLock(&pCall->Lock);
    /*
    * Initialize the LINE_UP event packet.
    */
    LineUpInfo.LinkSpeed = pCall->Speed / 100;
    LineUpInfo.Quality             = NdisWanErrorControl;
    LineUpInfo.SendWindow          = 0;

    // Jeff says Win98 needs the DeviceID as the connection wrapper ID, but
    // TonyBe says NT needs an absolutely unique ID, which hTapiCall is.
    // hTapiCall is probably more correct according to Tapi rules, but we make
    // allowances.

    LineUpInfo.ConnectionWrapperID = OS_CONNECTION_WRAPPER_ID;
    LineUpInfo.NdisLinkHandle      = (NDIS_HANDLE) DeviceIdToLinkHandle(pCall->FullDeviceId);
    LineUpInfo.NdisLinkContext     = pCall->NdisLinkContext;

    WPLOG(LL_M, LM_TAPI, ("LINE_UP %!IPADDR! pCall %p, Cid %d",
        pCall->Remote.Address.Address[0].Address[0].in_addr,
        pCall, (ULONG)pCall->DeviceId));
    /*
    * Indicate the event to the WAN wrapper.
    */
    NdisMIndicateStatus(pCall->pAdapter->hMiniportAdapter,
                        NDIS_STATUS_WAN_LINE_UP,
                        &LineUpInfo,
                        sizeof(LineUpInfo));

    NdisAcquireSpinLock(&pCall->Lock);
    pCall->NdisLinkContext = LineUpInfo.NdisLinkContext;
    NdisReleaseSpinLock(&pCall->Lock);
    DBG_X(DBG_TAPI, LineUpInfo.NdisLinkContext);

    DEBUGMSG(DBG_FUNC, (DTEXT("-TapiLineUp\n")));
}

typedef struct {
    TA_IP_ADDRESS   TargetAddress[MAX_TARGET_ADDRESSES];
    ULONG           NumAddresses;
    ULONG           CurrentAddress;
} MAKE_CALL_CONTEXT, *PMAKE_CALL_CONTEXT;

VOID
TapipParseIpAddressesAndCallerId(
    IN      PUCHAR  pAddressList,
    IN      ULONG   ListLength,
    IN      PCALL_SESSION pCall,
    IN OUT  PTA_IP_ADDRESS TargetAddress,
    IN OUT  PULONG  pulCountAddresses
    )
{
    BOOLEAN ValidAddress = FALSE;
    ULONG NumTargetAddresses = 0;
    PUCHAR pEndAddressList;
    ULONG MaxTargetAddresses = *pulCountAddresses;

    DEBUGMSG(DBG_FUNC, (DTEXT("+TapipParseAddresses\n")));

    // TAPI gives us an address of the following forms:
    //
    // [ IP Address ... IP Address ] [ Phone Number ]
    //
    // It begins with a list of addresses to try, and an optional phone number
    // if the remote device is an access concentrator.

    NdisZeroMemory(TargetAddress, sizeof(TA_IP_ADDRESS) * MaxTargetAddresses);
    *pulCountAddresses = 0;

    pEndAddressList = pAddressList + ListLength;
    
    if(ListLength < 2)
    {
        return;         // invalid length
    }
    
    // Make sure it's null terminated
    if(pAddressList[ListLength - 1] != '\0')
    {
        pAddressList[ListLength - 1] = '\0';
    }

    ValidAddress = TRUE;
    while (ValidAddress && pAddressList<pEndAddressList)
    {
        pAddressList = StringToIpAddress(pAddressList,
                                     &TargetAddress[NumTargetAddresses],
                                     &ValidAddress);

        if (ValidAddress)
        {
            if (++NumTargetAddresses==MaxTargetAddresses)
            {
                // We've hit the limit of what we'll take.  Throw the rest.
                while (ValidAddress && pAddressList<pEndAddressList)
                {
                    TA_IP_ADDRESS ThrowAway;
                    pAddressList = StringToIpAddress(pAddressList,
                                                     &ThrowAway,
                                                     &ValidAddress);
                }
            }
        }
    }
    
    // We've got the addresses.  Now nab the phone #
    {
        ULONG Digits = 0;
        while (pAddressList<pEndAddressList && *pAddressList && (*pAddressList==' ' || *pAddressList=='\t'))
        {
            pAddressList++;
        }
        while (pAddressList<pEndAddressList && *pAddressList &&
               Digits<MAX_PHONE_NUMBER_LENGTH-1)
        {
            pCall->CallerId[Digits++] = *pAddressList++;
        }
        pCall->CallerId[Digits] = '\0';
#if 0
        // This apparently breaks Alcatel
        if (!Digits)
        {
            IpAddressToString(htonl(pCall->Remote.Address.Address[0].Address[0].in_addr), pCall->CallerId);
        }
#endif
        DEBUGMSG(DBG_CALL, (DTEXT("Dialing %hs\n"), pCall->CallerId));
    }
    
    *pulCountAddresses = NumTargetAddresses;

    DEBUGMSG(DBG_FUNC, (DTEXT("-TapipParseAddresses\n")));
}

VOID
TapipMakeCallCallback(
    PPPTP_WORK_ITEM pWorkItem
    )
{
    PCALL_SESSION pCall;
    PPPTP_ADAPTER pAdapter = pWorkItem->Context;
    PNDIS_TAPI_MAKE_CALL pRequest = pWorkItem->pBuffer;
    NDIS_STATUS Status;

    DEBUGMSG(DBG_FUNC, (DTEXT("+TapipMakeCallCallback\n")));

    pCall = CallGetCall(pAdapter, pRequest->hdCall);

    if (!pCall)
    {
        DEBUGMSG(DBG_ERROR|DBG_FUNC, (DTEXT("-TapipMakeCallCallback NDIS_STATUS_TAPI_INUSE\n")));
        WPLOG(LL_A, LM_TAPI, ("-NDIS_STATUS_TAPI_INUSE"));
        NdisMQueryInformationComplete(pAdapter->hMiniportAdapter, NDIS_STATUS_TAPI_INUSE);
        return;
    }

    NdisAcquireSpinLock(&pCall->Lock);

    CallSetState(pCall, STATE_CALL_DIALING, 0, LOCKED);
    NdisMSetTimer(&pCall->DialTimer, 60*1000);
   
    pCall->Close.Checklist &= ~(CALL_CLOSE_DROP|CALL_CLOSE_DROP_COMPLETE|CALL_CLOSE_CLOSE_CALL);
    pCall->Close.Checklist &= ~(CALL_CLOSE_DISCONNECT|CALL_CLOSE_CLEANUP_STATE);

    NdisReleaseSpinLock(&pCall->Lock);

    Status = CtlConnectCall(pAdapter, pCall, &pCall->Remote.Address);
    NdisAcquireSpinLock(&pCall->Lock);
    if (Status==NDIS_STATUS_PENDING)
    {
        Status = NDIS_STATUS_SUCCESS;
    }
    else if (Status!=NDIS_STATUS_SUCCESS)
    {
        // We weren't successful, so we won't be getting these calls from tapi
        pCall->Close.Checklist |= (CALL_CLOSE_DROP|CALL_CLOSE_DROP_COMPLETE|CALL_CLOSE_CLOSE_CALL);
    }

    pCall->Remote.Address.Address[0].Address[0].sin_port = htons(PptpProtocolNumber);
    NdisReleaseSpinLock(&pCall->Lock);
    NdisMQueryInformationComplete(pAdapter->hMiniportAdapter, Status);

    DEBUGMSG(DBG_FUNC, (DTEXT("-TapipMakeCallCallback\n")));
}

NDIS_STATUS
TapiMakeCall(
    IN PPPTP_ADAPTER pAdapter,
    IN OUT PNDIS_TAPI_MAKE_CALL pRequest
    )
{
    PCALL_SESSION pCall;
    NDIS_STATUS Status;
    
    ULONG NumAddresses = 1;
    PUCHAR pAddressList = (PUCHAR)pRequest + pRequest->ulDestAddressOffset;

    DEBUGMSG(DBG_FUNC, (DTEXT("+TapiMakeCall\n")));

    if ( pRequest == NULL || pAdapter == NULL )
    {
        DEBUGMSG(DBG_ERROR|DBG_FUNC, (DTEXT("-TapiMakeCall NDIS_STATUS_TAPI_INVALPARAM\n")));
        WPLOG(LL_A, LM_TAPI, ("-NDIS_STATUS_TAPI_INVALPARAM"));
        return NDIS_STATUS_TAPI_INVALPARAM;
    }
    
    if(!pAdapter->Tapi.Open)
    {
        DEBUGMSG(DBG_ERROR|DBG_FUNC, (DTEXT("-TapiMakeCall NDIS_STATUS_TAPI_NODEVICE\n")));
        WPLOG(LL_A, LM_TAPI, ("-NDIS_STATUS_TAPI_NODEVICE"));
        return NDIS_STATUS_TAPI_NODEVICE;
    }

    if (!CallIsValidCall(pAdapter, TapiLineHandleToId(pRequest->hdLine)))
    {
        DEBUGMSG(DBG_ERROR|DBG_FUNC, (DTEXT("-TapiMakeCall NDIS_STATUS_TAPI_INVALLINEHANDLE\n")));
        WPLOG(LL_A, LM_TAPI, ("-NDIS_STATUS_TAPI_INVALLINEHANDLE"));
        return NDIS_STATUS_TAPI_INVALLINEHANDLE;
    }

    pCall = CallFindAndLock(pAdapter, STATE_CALL_IDLE, FIND_OUTGOING);

    if (!pCall)
    {
        DEBUGMSG(DBG_ERROR, (DTEXT("-TapiMakeCall NDIS_STATUS_TAPI_INUSE\n")));
        WPLOG(LL_A, LM_TAPI, ("-NDIS_STATUS_TAPI_INUSE"));
        return NDIS_STATUS_TAPI_INUSE;
    }

    if (pCall->State != STATE_CALL_IDLE)
    {
        NdisReleaseSpinLock(&pCall->Lock);
        DEBUGMSG(DBG_ERROR, (DTEXT("-TapiMakeCall NDIS_STATUS_TAPI_INUSE\n")));
        WPLOG(LL_A, LM_TAPI, ("-NDIS_STATUS_TAPI_INUSE"));
        return NDIS_STATUS_TAPI_INUSE;
    }

    // Save the handle tapi provides
    ASSERT(!pCall->hTapiCall);
    pCall->hTapiCall = pRequest->htCall;
    pCall->Inbound = FALSE;

    // our handle for tapi to this call is the device id
    pRequest->hdCall = pCall->FullDeviceId;
    
    WPLOG(LL_M, LM_TAPI, ("MAKECALL pCall %p, Cid %d, hTapiCall %Ix, hdCall %d",
        pCall, (ULONG)pCall->DeviceId, pCall->hTapiCall, (ULONG)pRequest->hdCall));    

    CallSetState(pCall, STATE_CALL_OFFHOOK, 0, LOCKED);
    pCall->PendingUse = FALSE;

    NdisReleaseSpinLock(&pCall->Lock);

    // We currently support one IP address only
    TapipParseIpAddressesAndCallerId(pAddressList,
                          pRequest->ulDestAddressSize,
                          pCall,
                          &pCall->Remote.Address,
                          &NumAddresses);
                          
    if(NumAddresses != 1)
    {
        DEBUGMSG(DBG_ERROR|DBG_FUNC, (DTEXT("-TapipMakeCall NDIS_STATUS_TAPI_INVALCALLPARAMS\n")));
        WPLOG(LL_A, LM_TAPI, ("-NDIS_STATUS_TAPI_INVALCALLPARAMS"));
        Status = NDIS_STATUS_TAPI_INVALCALLPARAMS;
    }
    else
    {
        // We got a valid IP address.
        // Schedule a work item so we can issue a CtlCreateCall at passive level.
        Status = ScheduleWorkItem(TapipMakeCallCallback,
                                  pAdapter,
                                  pRequest,
                                  0);
    }
    
    if (Status==NDIS_STATUS_SUCCESS)
    {
        // Keep the pRequest around until the callback.
        Status = NDIS_STATUS_PENDING;
    }
    else
    {
        CallSetState(pCall, STATE_CALL_CLEANUP, LINEDISCONNECTMODE_UNKNOWN, UNLOCKED);
        CallCleanup(pCall, UNLOCKED);
    }

    DEBUGMSG(DBG_FUNC, (DTEXT("-TapiMakeCall %08x\n"), Status));
    return Status;
}

NDIS_STATUS
TapiNegotiateExtVersion(
    IN PPPTP_ADAPTER pAdapter,
    IN OUT PNDIS_TAPI_NEGOTIATE_EXT_VERSION pRequest
    )
{
    DEBUGMSG(DBG_FUNC, (DTEXT("+TapiNegotiateExtVersion Low=%08x Hi=%08x\n"),
                        pRequest ? pRequest->ulLowVersion : 0, pRequest ? pRequest->ulHighVersion : 0));

    if ( pRequest == NULL || pAdapter == NULL )
    {
        DEBUGMSG(DBG_ERROR|DBG_FUNC, (DTEXT("-TapiNegotiateExtVersion NDIS_STATUS_TAPI_INVALPARAM\n")));
        WPLOG(LL_A, LM_TAPI, ("-TapiNegotiateExtVersion NDIS_STATUS_TAPI_INVALPARAM"));
        return NDIS_STATUS_TAPI_INVALPARAM;
    }

    if (pRequest->ulLowVersion < TAPI_EXT_VERSION ||
        pRequest->ulHighVersion > TAPI_EXT_VERSION)
    {
        DEBUGMSG(DBG_ERROR|DBG_FUNC, (DTEXT("-TapiNegotiateExtVersion NDIS_STATUS_TAPI_INCOMPATIBLEEXTVERSION\n")));
        WPLOG(LL_A, LM_TAPI, ("-TapiNegotiateExtVersion NDIS_STATUS_TAPI_INCOMPATIBLEEXTVERSION"));
        return NDIS_STATUS_TAPI_INCOMPATIBLEEXTVERSION;
    }

    DEBUGMSG(DBG_FUNC, (DTEXT("-TapiNegotiateExtVersion\n")));
    return NDIS_STATUS_SUCCESS;
}

VOID
TapipPassiveOpen(
    PPPTP_WORK_ITEM pWorkItem
    )
{
    PPPTP_ADAPTER pAdapter = pWorkItem->Context;
    DEBUGMSG(DBG_FUNC, (DTEXT("+TapipPassiveOpen\n")));

    // We only come here if PptpInitialized = FALSE;
    // It's a mechanism to defer opening tcp handles until tcp is
    // actually available, as it may not always be during startup/setup
    PptpInitialize(pAdapter);
    
    NdisMQueryInformationComplete(pAdapter->hMiniportAdapter, NDIS_STATUS_SUCCESS);
    DEBUGMSG(DBG_FUNC, (DTEXT("-TapipPassiveOpen\n")));
}

NDIS_STATUS
TapiOpen(
    IN PPPTP_ADAPTER pAdapter,
    IN OUT PNDIS_TAPI_OPEN pRequest
    )
{
    PCALL_SESSION pCall;
    DEBUGMSG(DBG_FUNC, (DTEXT("+TapiOpen\n")));

    if ( pRequest == NULL || pAdapter == NULL )
    {
        DEBUGMSG(DBG_ERROR|DBG_FUNC, (DTEXT("-TapiOpen NDIS_STATUS_TAPI_INVALPARAM\n")));
        WPLOG(LL_A, LM_TAPI, ("-NDIS_STATUS_TAPI_INVALPARAM"));
        return NDIS_STATUS_TAPI_INVALPARAM;
    }

    if (!CallIsValidCall(pAdapter, pRequest->ulDeviceID))
    {
        DEBUGMSG(DBG_ERROR|DBG_FUNC, (DTEXT("-TapiOpen NDIS_STATUS_TAPI_NODRIVER\n")));
        WPLOG(LL_A, LM_TAPI, ("-NDIS_STATUS_TAPI_NODRIVER"));
        return NDIS_STATUS_TAPI_NODRIVER;
    }

    NdisAcquireSpinLock(&pAdapter->Lock);

    if (pAdapter->Tapi.Open)
    {
        NdisReleaseSpinLock(&pAdapter->Lock);
        return NDIS_STATUS_TAPI_ALLOCATED;
    }

    pAdapter->Tapi.Open = TRUE;
    pAdapter->Tapi.hTapiLine = pRequest->htLine;

    pRequest->hdLine = TapiIdToLineHandle(pRequest->ulDeviceID);

    NdisReleaseSpinLock(&pAdapter->Lock);

    if (!PptpInitialized)
    {
        if (ScheduleWorkItem(TapipPassiveOpen, pAdapter, NULL, 0)==NDIS_STATUS_SUCCESS)
        {
            DEBUGMSG(DBG_FUNC, (DTEXT("-TapiOpen PENDING\n")));
            return NDIS_STATUS_PENDING;
        }
    }

    DEBUGMSG(DBG_FUNC, (DTEXT("-TapiOpen\n")));
    return NDIS_STATUS_SUCCESS;
}

VOID
TapipPassiveProviderInitialize(
    PPPTP_WORK_ITEM pWorkItem
    )
{
    PPPTP_ADAPTER pAdapter = pWorkItem->Context;

    DEBUGMSG(DBG_FUNC, (DTEXT("+TapipPassiveProviderInitialize\n")));

    // We initialize this here because TCP may not be available in MiniportInitialize
    // We don't uninit until MiniportHalt.  CtdiInitialize will just return quietly
    // if it's already initialized, so we can come through here several times
    // safely.

    PptpInitialize(pAdapter); // Ignore the return status.

    NdisMQueryInformationComplete(pAdapter->hMiniportAdapter, NDIS_STATUS_SUCCESS);

    DEBUGMSG(DBG_FUNC, (DTEXT("-TapipPassiveProviderInitialize\n")));
}

NDIS_STATUS
TapiProviderInitialize(
    IN PPPTP_ADAPTER pAdapter,
    IN OUT PNDIS_TAPI_PROVIDER_INITIALIZE pRequest
    )
{
    NDIS_STATUS Status = NDIS_STATUS_SUCCESS;

    DEBUGMSG(DBG_FUNC, (DTEXT("+TapiProviderInitialize\n")));

    if ( pRequest == NULL || pAdapter == NULL )
    {
        DEBUGMSG(DBG_ERROR|DBG_FUNC, (DTEXT("-TapiProviderInitialize NDIS_STATUS_TAPI_INVALPARAM\n")));
        WPLOG(LL_A, LM_TAPI, ("-NDIS_STATUS_TAPI_INVALPARAM"));
        return NDIS_STATUS_TAPI_INVALPARAM;
    }

    pAdapter->Tapi.DeviceIdBase = pRequest->ulDeviceIDBase;
    pRequest->ulNumLineDevs = 1;
    pRequest->ulProviderID = (ULONG_PTR)pAdapter;
    
    if (!PptpInitialized)
    {
        Status = ScheduleWorkItem(TapipPassiveProviderInitialize, pAdapter, NULL, 0);
        if (Status==NDIS_STATUS_SUCCESS)
        {
            // Keep the pRequest around until the callback.
            Status = NDIS_STATUS_PENDING;
        }
    }

    DEBUGMSG(DBG_FUNC, (DTEXT("-TapiProviderInitialize %08x\n"), Status));
    return Status;
}

VOID
TapipPassiveProviderShutdown(
    PPPTP_WORK_ITEM pWorkItem
    )
{
    PPPTP_ADAPTER pAdapter = pWorkItem->Context;
    ULONG i;
    DEBUGMSG(DBG_FUNC|DBG_TAPI, (DTEXT("+TapipPassiveProviderShutdown\n")));

    NdisAcquireSpinLock(&pAdapter->Lock);
    pAdapter->Tapi.Open = FALSE;
    NdisReleaseSpinLock(&pAdapter->Lock);

    for (i=0; i<pAdapter->Info.Endpoints; i++)
    {
//        PCALL_SESSION pCall = CallGetCall(pAdapter, i);
        PCALL_SESSION pCall = pAdapter->pCallArray[i];

        if (IS_CALL(pCall))
        {
            NdisAcquireSpinLock(&pCall->Lock);
            if (pCall->State>STATE_CALL_IDLE && pCall->State<=STATE_CALL_CLEANUP)
            {
                pCall->Open = FALSE;
                CallSetState(pCall, STATE_CALL_CLEANUP, LINEDISCONNECTMODE_NORMAL, LOCKED);
                // CALL_SESSION will be reused
                // CallDetachFromAdapter(pCall);
                pCall->Close.Checklist |= (CALL_CLOSE_DROP|CALL_CLOSE_DROP_COMPLETE|CALL_CLOSE_CLOSE_CALL);
                CallCleanup(pCall, LOCKED);
            }
            NdisReleaseSpinLock(&pCall->Lock);

        }
    }

    if (pAdapter->hCtdiDg)
    {
        CtdiClose(pAdapter->hCtdiDg);
        pAdapter->hCtdiDg = NULL;
    }

    if (pAdapter->hCtdiListen)
    {
        CtdiClose(pAdapter->hCtdiListen);
        pAdapter->hCtdiListen = NULL;
    }
    
    PptpInitialized = FALSE;

    NdisMSetInformationComplete(pAdapter->hMiniportAdapter, NDIS_STATUS_SUCCESS);

    DEBUGMSG(DBG_FUNC, (DTEXT("-TapipPassiveProviderShutdown\n")));
}


NDIS_STATUS
TapiProviderShutdown(
    IN PPPTP_ADAPTER pAdapter,
    IN OUT PNDIS_TAPI_PROVIDER_SHUTDOWN pRequest
    )
{
    NDIS_STATUS Status;

    DEBUGMSG(DBG_FUNC, (DTEXT("+TapiProviderShutdown\n")));

    if ( pRequest == NULL || pAdapter == NULL )
    {
        DEBUGMSG(DBG_ERROR|DBG_FUNC, (DTEXT("-TapiProviderShutdown NDIS_STATUS_TAPI_INVALPARAM\n")));
        WPLOG(LL_A, LM_TAPI, ("-NDIS_STATUS_TAPI_INVALPARAM"));
        return NDIS_STATUS_TAPI_INVALPARAM;
    }
    
    Status = ScheduleWorkItem(TapipPassiveProviderShutdown, pAdapter, NULL, 0);
    if (Status==NDIS_STATUS_SUCCESS)
    {
        Status = NDIS_STATUS_PENDING;
    }
    DEBUGMSG(DBG_FUNC|DBG_ERR(Status), (DTEXT("-TapiProviderShutdown %08x\n"), Status));
    return Status;
}

VOID
TapipSetDefaultMediaDetectionCallback(
    PPPTP_WORK_ITEM pWorkItem
    )
{
    PPPTP_ADAPTER pAdapter = pWorkItem->Context;
    PNDIS_TAPI_SET_DEFAULT_MEDIA_DETECTION pRequest = pWorkItem->pBuffer;
    NDIS_STATUS Status = NDIS_STATUS_SUCCESS;

    DEBUGMSG(DBG_FUNC, (DTEXT("+TapipSetDefaultMediaDetectionCallback\n")));

    if (pRequest->ulMediaModes&LINEMEDIAMODE_DIGITALDATA)
    {
        Status = CtlListen(pAdapter);
    }
    else if (pAdapter->hCtdiListen)
    {
        CtdiClose(pAdapter->hCtdiListen);
        pAdapter->hCtdiListen = NULL;
    }

    NdisMSetInformationComplete(pAdapter->hMiniportAdapter, Status);

    DEBUGMSG(DBG_FUNC, (DTEXT("-TapipSetDefaultMediaDetectionCallback\n")));
}

NDIS_STATUS
TapiSetDefaultMediaDetection(
    IN PPPTP_ADAPTER pAdapter,
    IN OUT PNDIS_TAPI_SET_DEFAULT_MEDIA_DETECTION pRequest
    )
{
    NDIS_STATUS Status = NDIS_STATUS_SUCCESS;
    DEBUGMSG(DBG_FUNC, (DTEXT("+TapiSetDefaultMediaDetection\n")));

    if ( pRequest == NULL || pAdapter == NULL )
    {
        DEBUGMSG(DBG_ERROR|DBG_FUNC, (DTEXT("-TapiSetDefaultMediaDetection NDIS_STATUS_TAPI_INVALPARAM\n")));
        WPLOG(LL_A, LM_TAPI, ("-TapiSetDefaultMediaDetection NDIS_STATUS_TAPI_INVALPARAM"));
        return NDIS_STATUS_TAPI_INVALPARAM;
    }

    // Verify the ID
    if (!CallIsValidCall(pAdapter, TapiLineHandleToId(pRequest->hdLine)))
    {
        DEBUGMSG(DBG_ERROR|DBG_FUNC, (DTEXT("-TapiSetDefaultMediaDetection NDIS_STATUS_TAPI_INVALLINEHANDLE\n")));
        WPLOG(LL_A, LM_TAPI, ("-TapiSetDefaultMediaDetection NDIS_STATUS_TAPI_INVALLINEHANDLE"));
        return NDIS_STATUS_TAPI_INVALLINEHANDLE;
    }

    // This is the OID to make us start accepting calls.

    DEBUGMSG(DBG_TAPI, (DTEXT("MediaModes: %x\n"), pRequest->ulMediaModes));

    // Schedule a work item so we can issue a CtlListen at passive level.
    Status = ScheduleWorkItem(TapipSetDefaultMediaDetectionCallback,
                              pAdapter,
                              pRequest,
                              0);
    if (Status==NDIS_STATUS_SUCCESS)
    {
        Status = NDIS_STATUS_PENDING;
    }

    DEBUGMSG(DBG_FUNC, (DTEXT("-TapiSetDefaultMediaDetection %08x\n"), Status));
    return NDIS_STATUS_PENDING;
}

NDIS_STATUS
TapiSetStatusMessages(
    IN PPPTP_ADAPTER pAdapter,
    IN OUT PNDIS_TAPI_SET_STATUS_MESSAGES pRequest
    )
{
    DEBUGMSG(DBG_FUNC, (DTEXT("+TapiSetStatusMessages\n")));

    if ( pRequest == NULL || pAdapter == NULL )
    {
        DEBUGMSG(DBG_ERROR|DBG_FUNC, (DTEXT("-TapiSetStatusMessages NDIS_STATUS_TAPI_INVALPARAM\n")));
        WPLOG(LL_A, LM_TAPI, ("-NDIS_STATUS_TAPI_INVALPARAM"));
        return NDIS_STATUS_TAPI_INVALPARAM;
    }

    if (!CallIsValidCall(pAdapter, TapiLineHandleToId(pRequest->hdLine)))
    {
        DEBUGMSG(DBG_ERROR|DBG_FUNC, (DTEXT("-TapiSetDefaultMediaDetection NDIS_STATUS_TAPI_INVALLINEHANDLE\n")));
        WPLOG(LL_A, LM_TAPI, ("-NDIS_STATUS_TAPI_INVALLINEHANDLE"));
        return NDIS_STATUS_TAPI_INVALLINEHANDLE;
    }

    pAdapter->Tapi.LineStateMask = pRequest->ulLineStates;

    DEBUGMSG(DBG_FUNC, (DTEXT("-TapiSetStatusMessages\n")));
    return NDIS_STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ndis\raspptp\nt\dbgapi.c ===
/*****************************************************************************
*
*   Copyright (c) 1998-1999 Microsoft Corporation
*
*   DBGAPI.C - NT specific debugging macros, etc.
*
*   Author:     Stan Adermann (stana)
*
*   Created:    9/3/1998
*
*****************************************************************************/

#if DBG

#include "raspptp.h"
#include <ntddk.h>
#include <cxport.h>
#include <stdio.h>
#include <stdarg.h>
#include <string.h>
#include "dbgapi.h"

#define UNICODE_STRING_CONST(x) {sizeof(L##x)-2, sizeof(L##x), L##x}

ULONG DbgSettings = 0;
ULONG DbgOutput = DBG_OUTPUT_BUFFER;

CHAR         DbgMsgs[DBG_MSG_CNT][MAX_MSG_LEN];
ULONG        First, Last;
CTETimer     DbgTimer;
BOOLEAN      TimerRunning;
CTELock      DbgLock;
PIRP         pDbgIrp;
UCHAR        *IrpBuf;
ULONG        IrpBufLen;
ULONG        IrpBufWritten;
UCHAR        CharTable[256];

VOID DbgTimerExp(CTEEvent *Event, void *Arg);

VOID
DbgMsgInit()
{
    ULONG i;

    pDbgIrp = NULL;
    First = 0;
    Last = 0;
    TimerRunning = FALSE;

    for (i=0; i<256; i++)
    {
        CharTable[i] = (UCHAR)((i>=' ') ? i : '.');
    }
    CharTable[0xfe] = '.'; // Debugger seems to get stuck when we print this.

    CTEInitLock(&DbgLock);

    CTEInitTimer(&DbgTimer);
}

VOID
DbgMsgUninit()
{
    CTELockHandle   LockHandle;
    KIRQL           Irql;

    CTEGetLock(&DbgLock, &LockHandle);

    if (pDbgIrp)
    {
        IoAcquireCancelSpinLock(&Irql);

        IoSetCancelRoutine(pDbgIrp, NULL);

        IoReleaseCancelSpinLock(Irql);

        pDbgIrp->IoStatus.Information = 0;
        pDbgIrp->IoStatus.Status = STATUS_UNSUCCESSFUL;

DbgPrint("Complete irp!\n");
        IoCompleteRequest(pDbgIrp, IO_NO_INCREMENT);

        pDbgIrp = NULL;
    }

    CTEFreeLock(&DbgLock, LockHandle);
}
VOID
DbgMsg(CHAR *Format, ...)
{
    va_list         Args;
    CTELockHandle   LockHandle;
    CHAR            Temp[MAX_MSG_LEN];

    va_start(Args, Format);

    vsprintf(Temp, Format, Args);

    if (DbgOutput & DBG_OUTPUT_DEBUGGER)
    {
        DbgPrint("RASPPTP: ");
        DbgPrint(Temp);
    }

    if (DbgOutput & DBG_OUTPUT_BUFFER)
    {
        CTEGetLock(&DbgLock, &LockHandle);

        strcpy(DbgMsgs[Last], Temp);

        Last++;

        if (Last == DBG_MSG_CNT)
            Last = 0;

        if (First == Last)
        {
            First++;
            if (First == DBG_MSG_CNT)
                First = 0;
        }

        if (pDbgIrp && !TimerRunning)
        {
            CTEStartTimer(&DbgTimer, DBG_TIMER_INTERVAL,
                      DbgTimerExp, NULL);
            TimerRunning = TRUE;
        }

        CTEFreeLock(&DbgLock, LockHandle);
    }

    va_end(Args);
}

NTSTATUS
FillDbgIrp(UCHAR Msg[])
{
    NTSTATUS Status = STATUS_PENDING;
    ULONG i;

    if ((IrpBufLen - IrpBufWritten) < MAX_MSG_LEN)
    {
        Status = STATUS_SUCCESS;
    }
    else
    {
        Msg[MAX_MSG_LEN - 1] = 0; // just to be sure

        i = 0;

        while (1)
        {
            IrpBuf[IrpBufWritten++] = Msg[i];

            if (Msg[i] == 0)
                break;
            i++;
        }
    }

    return Status;
}

VOID CancelDbgIrp(
    PDEVICE_OBJECT DeviceObject,
    PIRP pIrp)
{
//    DbgPrint("CancelDbgIrp %x\n", pIrp);

    pDbgIrp = NULL;

    IoReleaseCancelSpinLock(pIrp->CancelIrql);

    pIrp->IoStatus.Status = STATUS_CANCELLED;
    pIrp->IoStatus.Information = 0;

    IoCompleteRequest(pIrp, IO_NO_INCREMENT);
}

NTSTATUS
DbgMsgIrp(
    PIRP                pIrp,
    PIO_STACK_LOCATION  pIrpSp)
{
    CTELockHandle   LockHandle;
    NTSTATUS        Status = STATUS_PENDING;

    if (pDbgIrp != NULL)
        return STATUS_DEVICE_BUSY;

    CTEGetLock(&DbgLock, &LockHandle);

    IrpBufLen = pIrpSp->Parameters.DeviceIoControl.OutputBufferLength;
    IrpBufWritten = 0;

    if (IrpBufLen < MAX_MSG_LEN)
    {
        CTEFreeLock(&DbgLock, LockHandle);
        return STATUS_BUFFER_OVERFLOW;
    }

    IrpBuf = pIrp->AssociatedIrp.SystemBuffer;

    while (First != Last)
    {
        Status = FillDbgIrp(DbgMsgs[First]);

        if (Status == STATUS_SUCCESS)
            break;

        First++;
        if (First == DBG_MSG_CNT)
            First = 0;
    }


    if (Status == STATUS_SUCCESS)
    {
        pIrp->IoStatus.Information = IrpBufWritten;
    }
    else if (Status == STATUS_PENDING)
    {
        KIRQL           Irql;
        PDRIVER_CANCEL  PrevCancel;

        pDbgIrp = pIrp;

        IoMarkIrpPending(pIrp);

        IoAcquireCancelSpinLock(&Irql);

        PrevCancel = IoSetCancelRoutine(pIrp, CancelDbgIrp);

        CTEAssert(PrevCancel == NULL);

        IoReleaseCancelSpinLock(Irql);

        if (IrpBufWritten != 0)
        {
            CTEStartTimer(&DbgTimer, DBG_TIMER_INTERVAL,
                      DbgTimerExp, NULL);

            TimerRunning = TRUE;
        }
    }

    CTEFreeLock(&DbgLock, LockHandle);

    //DbgPrint("DbgIrp status %x, bw %d, irp %x\n", Status, IrpBufWritten, pIrp);
    return Status;
}

VOID
DbgTimerExp(CTEEvent *Event, void *Arg)
{
    CTELockHandle   LockHandle;
    PIRP            pIrp;
    KIRQL           Irql;

//DbgPrint("Texp\n");

    if (pDbgIrp == NULL)
    {
        DbgPrint("DbgIrp is null\n");
        return;
    }

    IoAcquireCancelSpinLock(&Irql);

    IoSetCancelRoutine(pDbgIrp, NULL);

    IoReleaseCancelSpinLock(Irql);

    if (pDbgIrp->Cancel)
    {
        DbgPrint("DbgIrp is being canceled\n");
        pDbgIrp = NULL;
        return;
    }


    CTEGetLock(&DbgLock, &LockHandle);

    TimerRunning = FALSE;

    while (First != Last)
    {
        if (FillDbgIrp(DbgMsgs[First]) == STATUS_SUCCESS)
            break;

        First++;
        if (First == DBG_MSG_CNT)
            First = 0;
    }

    pIrp = pDbgIrp;

    pDbgIrp = NULL;

    CTEFreeLock(&DbgLock, LockHandle);

    pIrp->IoStatus.Information = IrpBufWritten;
    pIrp->IoStatus.Status = STATUS_SUCCESS;

  //  DbgPrint("Comp bw %d, irp %x\n", IrpBufWritten, pIrp);

    IoCompleteRequest(pIrp, IO_NO_INCREMENT);
}

VOID DbgMemory(PVOID pMemory, ULONG Length, ULONG WordSize)
{
    ULONG i, j;
    UCHAR AsciiData[17];

    for (i=0; i<Length; )
    {
        DbgMsg("%08x: ", pMemory);
        for (j=0; j<16 && i+j<Length; j++)
        {
            AsciiData[j] = CharTable[((PUCHAR)pMemory)[j]];
        }
        AsciiData[j] = '\0';
        for (j=0; j<16; j+=WordSize, i+=WordSize)
        {
            if (i<Length)
            {
                switch (WordSize)
                {
                    case 1:
                        DbgMsg("%02x ", *(PUCHAR)pMemory);
                        break;
                    case 2:
                        DbgMsg("%04x ", *(PUSHORT)pMemory);
                        break;
                    case 4:
                        DbgMsg("%08x ", *(PULONG)pMemory);
                        break;
                }
            }
            else
            {
                DbgMsg("%*s ", WordSize*2, "");
            }
            pMemory = (PUCHAR)pMemory + WordSize;
        }
        DbgMsg("   %s\n", AsciiData);
    }
}

VOID DbgRegInit(PUNICODE_STRING pRegistryPath, ULONG DefaultDebug)
{
    struct {
        KEY_VALUE_PARTIAL_INFORMATION Value;
        ULONG_PTR Filler;
    } DwordValue;
    ULONG InformationLength;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE hReg;
    NTSTATUS Status;
    UNICODE_STRING DbgSettingsString =  UNICODE_STRING_CONST("DbgSettings");
    UNICODE_STRING DbgOutputString =    UNICODE_STRING_CONST("DbgOutput");
    UNICODE_STRING PromptString =       UNICODE_STRING_CONST("Prompt");

    InitializeObjectAttributes(&ObjectAttributes,
                               pRegistryPath,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    Status = ZwOpenKey(&hReg, MAXIMUM_ALLOWED, &ObjectAttributes);

    if (Status==STATUS_SUCCESS)
    {
        Status = ZwQueryValueKey(hReg,
                                 &DbgSettingsString,
                                 KeyValuePartialInformation,
                                 &DwordValue,
                                 sizeof(DwordValue),
                                 &InformationLength);
        if (Status==STATUS_SUCCESS)
        {
            DbgSettings = *(PULONG)DwordValue.Value.Data;
        }
        else
        {
            DbgSettings = DefaultDebug;
        }

        Status = ZwQueryValueKey(hReg,
                                 &DbgOutputString,
                                 KeyValuePartialInformation,
                                 &DwordValue,
                                 sizeof(DwordValue),
                                 &InformationLength);
        if (Status==STATUS_SUCCESS)
        {
            DbgOutput = *(PULONG)DwordValue.Value.Data;
        }

        ZwClose(hReg);
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ndis\raspptp\nt\ctdi.c ===
//depot/Lab03_N/Net/rras/ndis/raspptp/nt/ctdi.c#10 - edit change 19457 (text)
/*******************************************************************
*
*   Copyright (c) 1998-1999 Microsoft Corporation
*
*    DESCRIPTION: CTDI.C - Common TDI layer, for NT
*
*    AUTHOR: Stan Adermann (StanA)
*
*    DATE:9/29/1998
*
*******************************************************************/

/** include files **/

#include "raspptp.h"
#include "bpool.h"

#include "tcpinfo.h"

#include "ctdi.tmh"

#if VER_PRODUCTVERSION_W >= 0x0500
#define IP_ROUTE_REFCOUNT
#endif
/** local definitions **/

typedef enum {
    CTDI_REF_CONNECT = 0,
    CTDI_REF_ASSOADDR,
    CTDI_REF_SETEVENT,
    CTDI_REF_ADDRREF,
    CTDI_REF_LIST,
    CTDI_REF_REPLENISH,
    CTDI_REF_DISASSO,
    CTDI_REF_DISCONNECT,
    CTDI_REF_RECVDG,
    CTDI_REF_SEND,
    CTDI_REF_SENDDG,
    CTDI_REF_QUERY,
    CTDI_REF_INLISTEN,
    CTDI_REF_INITIAL,
    CTDI_REF_UNKNOWN,
    CTDI_REF_MAX
} CTDI_REF;

#if DBG

#define CTDI_F_BUILD_ASSOCADDR                  0x00000001
#define CTDI_F_ASSOCADDR_CALLBACK               0x00000002
#define CTDI_F_ACCEPT                           0x00000004
#define CTDI_F_CONNECTCOMP_CALLBACK             0x00000008

#define CTDI_F_DISCONNECT_CALLBACK              0x00000010
#define CTDI_F_DISCONNECT                       0x00000020
#define CTDI_F_BUILD_DISCONNECT_1               0x00000040
#define CTDI_F_BUILD_DISCONNECT_2               0x00000080

#define CTDI_F_DISCONNECTCOMP_CALLBACK          0x00000100
#define CTDI_F_DISCONNECT_CLEANUP               0x00000200

#define CTDI_F_BUILD_DISASSOC                   0x00001000
#define CTDI_F_DISASSOC_CALLBACK                0x00002000   

#endif
    

#define CTDI_SIGNATURE      'IDTC'
#define NUM_TCP_LISTEN      5

#define CTDI_UNKNOWN            'NKNU'
#define CTDI_ENDPOINT           'PDNE'
#define CTDI_DATAGRAM           'MRGD'
#define CTDI_LISTEN             'TSIL'
#define CTDI_CONNECTION         'NNOC'

#define PROBE 0

#define IS_CTDI(c) ((c) && (c)->Signature==CTDI_SIGNATURE)

typedef struct CTDI_DATA * PCTDI_DATA;

typedef struct CTDI_DATA {
    LIST_ENTRY                      ListEntry;
    ULONG                           Signature;
    ULONG                           Type;
    REFERENCE_COUNT                 Reference;
    HANDLE                          hFile;
    PFILE_OBJECT                    pFileObject;
    NDIS_SPIN_LOCK                  Lock;
    BOOLEAN                         Closed;
    BOOLEAN                         CloseReqPending;

    CTDI_EVENT_CONNECT_QUERY        ConnectQueryCallback;
    CTDI_EVENT_CONNECT_COMPLETE     ConnectCompleteCallback;
    CTDI_EVENT_DISCONNECT           DisconnectCallback;
    CTDI_EVENT_RECEIVE              RecvCallback;
    PVOID                           RecvContext;
    CTDI_EVENT_RECEIVE_DATAGRAM     RecvDatagramCallback;
    CTDI_EVENT_SEND_COMPLETE        SendCompleteCallback;
    CTDI_EVENT_QUERY_COMPLETE       QueryCompleteCallback;
    CTDI_EVENT_SET_COMPLETE         SetCompleteCallback;

    union {
        struct {
            PVOID                   Context;
            LIST_ENTRY              ConnectList;
            ULONG                   NumConnection;
        } Listen;
        struct {
            PVOID                   Context;
            PCTDI_DATA              LocalEndpoint;
            PVOID                   ConnectInfo;
            TA_IP_ADDRESS           RemoteAddress;
            LIST_ENTRY              ListEntry;
            ULONG                   DisconnectCount;
            union {
                BOOLEAN             Disconnect;
                ULONG_PTR           Padding1;
            };
            union {
                BOOLEAN             Abort;
                ULONG_PTR           Padding2;
            };
        } Connection;
        struct {
            BUFFERPOOL              RxPool;
        } Datagram;
    };

    LIST_ENTRY                      TxActiveIrpList;

#if DBG
    ULONG                           arrRef[16];
    ULONG                           DbgFlags;
    BOOLEAN                         bRef;
#endif

} CTDI_DATA, *PCTDI_DATA;

#if DBG
#define SET_DBGFLAG(_p, _f)  (_p)->DbgFlags |= (_f)
#else
#define SET_DBGFLAG(_p, _f)
#endif

typedef struct {
    PVOID                           Context;
    CTDI_EVENT_SEND_COMPLETE        pSendCompleteCallback;
} CTDI_SEND_CONTEXT, *PCTDI_SEND_CONTEXT;

typedef struct {
    PVOID                           Context;
    CTDI_EVENT_QUERY_COMPLETE       pQueryCompleteCallback;
} CTDI_QUERY_CONTEXT, *PCTDI_QUERY_CONTEXT;

typedef struct {
    PVOID                           Context;
    PVOID                           DatagramContext;
    CTDI_EVENT_SEND_COMPLETE        pSendCompleteCallback;
    TDI_CONNECTION_INFORMATION      TdiConnectionInfo;
    TA_IP_ADDRESS                   Ip;
} CTDI_SEND_DATAGRAM_CONTEXT, *PCTDI_SEND_DATAGRAM_CONTEXT;

#define BLOCKS_NEEDED_FOR_SIZE(BlockSize, Size) ((Size)/(BlockSize) + ((((Size)/(BlockSize))*(BlockSize) < (Size)) ? 1 : 0 ))

#define NUM_STACKS_FOR_CONTEXT(ContextSize) \
    BLOCKS_NEEDED_FOR_SIZE(sizeof(IO_STACK_LOCATION), (ContextSize))

STATIC PVOID __inline
GetContextArea(
    PIRP pIrp,
    ULONG ContextSize
    )
{
#if 0
    ULONG i;
    for (i=0; i<BLOCKS_NEEDED_FOR_SIZE(sizeof(IO_STACK_LOCATION), ContextSize); i++)
        IoSetNextIrpStackLocation(pIrp);
#else
    ULONG NumStacks = BLOCKS_NEEDED_FOR_SIZE(sizeof(IO_STACK_LOCATION), ContextSize);
    pIrp->CurrentLocation -= (CHAR)NumStacks;
    pIrp->Tail.Overlay.CurrentStackLocation -= NumStacks;
#endif
    ASSERT(BLOCKS_NEEDED_FOR_SIZE(sizeof(IO_STACK_LOCATION), ContextSize)<=2);
    return IoGetCurrentIrpStackLocation(pIrp);
}

#define GET_CONTEXT(Irp, Context) (Context*)GetContextArea((Irp), sizeof(Context))

STATIC VOID __inline
ReleaseContextArea(
    PIRP pIrp,
    ULONG ContextSize
    )
{
    ULONG NumStacks = BLOCKS_NEEDED_FOR_SIZE(sizeof(IO_STACK_LOCATION), ContextSize) - 1;
    pIrp->CurrentLocation += (CHAR)NumStacks;
    pIrp->Tail.Overlay.CurrentStackLocation += NumStacks;
}

#define RELEASE_CONTEXT(Irp, Context) ReleaseContextArea((Irp), sizeof(Context))

typedef struct {
    LIST_ENTRY                      ListEntry;
    REFERENCE_COUNT                 Reference;
    ULONG                           IpAddress;
    BOOLEAN                         ExternalRoute;
} CTDI_ROUTE, *PCTDI_ROUTE;

typedef struct {
    LIST_ENTRY                      ListEntry;
    IPNotifyData                    Data;
} CTDI_ROUTE_NOTIFY, *PCTDI_ROUTE_NOTIFY;
/* default settings */

/** external functions **/

/** external data **/

/** public data **/

LIST_ENTRY CtdiList;
LIST_ENTRY CtdiFreeList;
LIST_ENTRY CtdiRouteList;
//LIST_ENTRY CtdiRouteNotifyList;
NDIS_SPIN_LOCK  CtdiListLock;
HANDLE hTcp = 0;
PFILE_OBJECT pFileTcp = NULL;
HANDLE hIp = 0;
PFILE_OBJECT pFileIp = NULL;

ULONG CtdiTcpDisconnectTimeout = 30;  // Seconds
ULONG CtdiTcpConnectTimeout = 30;

/** private data **/
BOOLEAN fCtdiInitialized = FALSE;

CSHORT CtdiMdlFlags = 0;

/** private functions **/

NDIS_STATUS
CtdiAddHostRoute(
    IN      PTA_IP_ADDRESS              pIpAddress
    );

NDIS_STATUS
CtdiDeleteHostRoute(
    IN      PTA_IP_ADDRESS              pIpAddress
    );

STATIC VOID
CtdipIpRequestRoutingNotification(
    IN ULONG IpAddress
    );

STATIC VOID
CtdipCloseProtocol(
    HANDLE  hFile,
    PFILE_OBJECT pFileObject
    )
{
    NTSTATUS NtStatus;
    DEBUGMSG(DBG_FUNC, (DTEXT("+CtdipCloseProtocol\n")));

    ASSERT(KeGetCurrentIrql()<DISPATCH_LEVEL);
    if (pFileObject)
    {
        ObDereferenceObject(pFileObject);
    }
    NtStatus = ZwClose(hFile);
    if (NtStatus!=STATUS_SUCCESS)
    {
        DEBUGMSG(DBG_ERROR, (DTEXT("ZwClose(hFile) failed %08x\n"), NtStatus));
        WPLOG(LL_A, LM_TDI, ("ZwClose(hFile) failed %08x", NtStatus));
    }

    DEBUGMSG(DBG_FUNC, (DTEXT("-CtdipCloseProtocol\n")));
}

STATIC VOID
CtdipDataFreeWorker(
    IN      PPPTP_WORK_ITEM             pWorkItem
    )
{
    PCTDI_DATA pCtdi;
    NTSTATUS NtStatus;
    PLIST_ENTRY ListEntry;
    BOOLEAN FoundEntry = FALSE;
    DEBUGMSG(DBG_FUNC, (DTEXT("+CtdipDataFreeWorker\n")));

    while (ListEntry = MyInterlockedRemoveHeadList(&CtdiFreeList, &CtdiListLock))
    {
        pCtdi = CONTAINING_RECORD(ListEntry, CTDI_DATA, ListEntry);
        if (pCtdi->Type==CTDI_DATAGRAM)
        {
            FreeBufferPool(&pCtdi->Datagram.RxPool);
        }

        if (pCtdi->hFile)
        {
            CtdipCloseProtocol(pCtdi->hFile, pCtdi->pFileObject);
            pCtdi->pFileObject = NULL;
            pCtdi->hFile = NULL;
        }

        NdisFreeSpinLock(&pCtdi->Lock);
        pCtdi->Signature = 0;

        if(pCtdi->Type == CTDI_LISTEN)
        {
            if(pCtdi->CloseReqPending)
            {
                // TapiClose pended this request, complete it now
                DEBUGMSG(DBG_TDI, (DTEXT("Complete TapiClose request\n")));
                ASSERT(pgAdapter);
                NdisMSetInformationComplete(pgAdapter->hMiniportAdapter, NDIS_STATUS_SUCCESS);
            }
        }
        MyMemFree(pCtdi, sizeof(CTDI_DATA));
    }

    DEBUGMSG(DBG_FUNC, (DTEXT("-CtdipDataFreeWorker\n")));
}

STATIC VOID
CtdipDataFree(
    PCTDI_DATA pCtdi
    )
// This should only be called by DEREFERENCE_OBJECT
{
    DEBUGMSG(DBG_FUNC, (DTEXT("+CtdipDataFree\n")));
    NdisAcquireSpinLock(&CtdiListLock);
    RemoveEntryList(&pCtdi->ListEntry);
    InsertTailList(&CtdiFreeList, &pCtdi->ListEntry);

    pCtdi->Signature = 0;
    NdisReleaseSpinLock(&CtdiListLock);
    ScheduleWorkItem(CtdipDataFreeWorker, NULL, NULL, 0);
    DEBUGMSG(DBG_FUNC, (DTEXT("-CtdipDataFree\n")));
}

STATIC PCTDI_DATA
CtdipDataAlloc()
{
    PCTDI_DATA pCtdi;

    DEBUGMSG(DBG_FUNC, (DTEXT("+CtdipDataAlloc\n")));
            
    pCtdi = MyMemAlloc(sizeof(CTDI_DATA), TAG_CTDI_DATA);
    if (!pCtdi)
    {
        WPLOG(LL_A, LM_Res, ("Failed to alloc CTDI"));
        return NULL;
    }
    
    NdisZeroMemory(pCtdi, sizeof(CTDI_DATA));
    pCtdi->Signature = CTDI_SIGNATURE;
    pCtdi->Type = CTDI_UNKNOWN;
    INIT_REFERENCE_OBJECT(pCtdi, CtdipDataFree);  // pair in CtdiClose
    NdisInitializeListHead(&pCtdi->TxActiveIrpList);
    NdisAllocateSpinLock(&pCtdi->Lock);
    MyInterlockedInsertHeadList(&CtdiList, &pCtdi->ListEntry, &CtdiListLock);

    DEBUGMSG(DBG_FUNC, (DTEXT("-CtdipDataAlloc %08x\n"), pCtdi));
    return pCtdi;
}

STATIC NDIS_STATUS
CtdipIpQueryRouteTable(
    OUT IPRouteEntry **ppQueryBuffer,
    OUT PULONG pQuerySize,
    OUT PULONG pNumRoutes
    )
{
    NDIS_STATUS Status = NDIS_STATUS_SUCCESS;
    ULONG NumRoutes = 20;
    ULONG QuerySize = 0;
    TCP_REQUEST_QUERY_INFORMATION_EX QueryRoute;
    IPRouteEntry *pQueryBuffer = NULL;
    PIO_STACK_LOCATION IrpSp;
    IO_STATUS_BLOCK IoStatusBlock;
    PIRP pIrp;
    KEVENT  Event;

    DEBUGMSG(DBG_FUNC, (DTEXT("+CtdipIpQueryRouteTable\n")));

    if (!fCtdiInitialized)
    {
        Status = NDIS_STATUS_FAILURE;
        goto ciqrtDone;
    }

    // Query TCPfor the current routing table

    QueryRoute.ID.toi_entity.tei_entity = CL_NL_ENTITY;
    QueryRoute.ID.toi_entity.tei_instance = 0;
    QueryRoute.ID.toi_class = INFO_CLASS_PROTOCOL;
    QueryRoute.ID.toi_type = INFO_TYPE_PROVIDER;

    do
    {

        QuerySize = sizeof(IPRouteEntry) * NumRoutes;
        QueryRoute.ID.toi_id = IP_MIB_RTTABLE_ENTRY_ID;
        NdisZeroMemory(&QueryRoute.Context, CONTEXT_SIZE);

        pQueryBuffer = MyMemAlloc(QuerySize, TAG_CTDI_ROUTE);
        if (!pQueryBuffer)
        {
            // ToDo: free the new pRoute
            WPLOG(LL_A, LM_Res, ("Failed to alloc query CTDI_ROUTE size %d", QuerySize));
            Status = NDIS_STATUS_RESOURCES;
            goto ciqrtDone;
        }

        KeInitializeEvent(&Event, SynchronizationEvent, FALSE);

        pIrp = IoBuildDeviceIoControlRequest(IOCTL_TCP_QUERY_INFORMATION_EX,
                                             pFileTcp->DeviceObject,
                                             &QueryRoute,
                                             sizeof(QueryRoute),
                                             pQueryBuffer,
                                             QuerySize,
                                             FALSE,
                                             &Event,
                                             &IoStatusBlock);

        if (!pIrp)
        {
            WPLOG(LL_A, LM_Res, ("Failed to build TCP_QUERY_INFORMATION IRP"));
            gCounters.ulIoBuildIrpFail++;
            Status = NDIS_STATUS_RESOURCES;
            goto ciqrtDone;
        }

        IrpSp = IoGetNextIrpStackLocation(pIrp);
        IrpSp->FileObject = pFileTcp;

        Status = IoCallDriver(pFileTcp->DeviceObject, pIrp);

        if (Status == STATUS_PENDING) {
            KeWaitForSingleObject(&Event,
                                  Executive,
                                  KernelMode,
                                  FALSE,
                                  NULL);
            Status = IoStatusBlock.Status;
        }

        if (Status==STATUS_BUFFER_OVERFLOW)
        {
            // We have no idea of the size of the routing table and no good
            // way to find out, so we just loop, increasing our buffer until
            // we win or die
            MyMemFree(pQueryBuffer, QuerySize);
            pQueryBuffer = NULL;
            NumRoutes *= 2;
        }
        else if (Status!=STATUS_SUCCESS)
        {
            DEBUGMSG(DBG_TDI, (DTEXT("Failed to query complete routing table %08x\n"), Status));
            WPLOG(LL_A, LM_TDI, ("Failed to query complete routing table %08x", Status));
            goto ciqrtDone;
        }

    } while ( Status==STATUS_BUFFER_OVERFLOW );

    NumRoutes = (ULONG)(IoStatusBlock.Information / sizeof(IPRouteEntry));

ciqrtDone:
    if (Status == NDIS_STATUS_SUCCESS)
    {
        ASSERT(pQueryBuffer);
        *ppQueryBuffer = pQueryBuffer;
        *pNumRoutes = NumRoutes;
        *pQuerySize = QuerySize;
    }
    else
    {
        if (pQueryBuffer)
        {
            MyMemFree(pQueryBuffer, QuerySize);
        }
        
        *ppQueryBuffer = NULL;
        *pNumRoutes = 0;
        *pQuerySize = 0;
    }
    DEBUGMSG(DBG_FUNC, (DTEXT("-CtdipIpQueryRouteTable\n")));
    return Status;
}

// Code not used     
#if 0
NTSTATUS
CtdipRouteChangeEvent(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp,
    IN PVOID pContext
    )
{
    NDIS_STATUS Status;
    PCTDI_ROUTE_NOTIFY pNotify = pContext;
    ENUM_CONTEXT Enum;
    PLIST_ENTRY pListEntry;
    PCTDI_DATA pCtdi;
    ULONG IpAddress = pNotify->Data.Add;
    KIRQL Irql;
    IPRouteEntry *pQueryBuffer = NULL;
    ULONG NumRoutes = 20;
    ULONG QuerySize = 0;
    ULONG i;
    BOOLEAN RouteWentAway = TRUE;
    DEBUGMSG(DBG_FUNC, (DTEXT("+CtdipRouteChangeEvent\n")));

    DEBUGMSG(DBG_TDI, (DTEXT("Route change irp for %d.%d.%d.%d completed with status %08x\n"),
                       IPADDR(IpAddress), pIrp->IoStatus.Status));

    NdisAcquireSpinLock(&CtdiListLock);
    RemoveEntryList(&pNotify->ListEntry);
    NdisReleaseSpinLock(&CtdiListLock);

    if (!fCtdiInitialized)
    {
        goto crceDone;
    }
    if (pIrp->IoStatus.Status==STATUS_SUCCESS)
    {
        Status = CtdipIpQueryRouteTable(&pQueryBuffer, &QuerySize, &NumRoutes);
        if (Status!=NDIS_STATUS_SUCCESS)
        {
            goto crceDone;
        }

        for (i=0; i<NumRoutes; i++)
        {
            if (pQueryBuffer[i].ire_dest == IpAddress &&
                pQueryBuffer[i].ire_proto == IRE_PROTO_NETMGMT &&
                pQueryBuffer[i].ire_mask == 0xFFFFFFFF)
            {
                RouteWentAway = FALSE;
                break;
            }
        }
        MyMemFree(pQueryBuffer, QuerySize);

        if (RouteWentAway)
        {
            InitEnumContext(&Enum);
            while (pListEntry = EnumListEntry(&CtdiList, &Enum, &CtdiListLock))
            {
                pCtdi = CONTAINING_RECORD(pListEntry,
                                          CTDI_DATA,
                                          ListEntry);
                if (IS_CTDI(pCtdi) &&
                    pCtdi->Type==CTDI_CONNECTION &&
                    !pCtdi->Closed &&
                    pCtdi->Connection.RemoteAddress.Address[0].Address[0].in_addr==IpAddress &&
                    pCtdi->DisconnectCallback)
                {
                    DEBUGMSG(DBG_TDI, (DTEXT("Disconnecting Ctdi:%08x due to route change.\n"),
                                       pCtdi));
                    pCtdi->DisconnectCallback(pCtdi->Connection.Context, TRUE);
                }
            }
            EnumComplete(&Enum, &CtdiListLock);
        }
        else
        {
            CtdipIpRequestRoutingNotification(IpAddress);
        }
    }

crceDone:
    RELEASE_CONTEXT(pIrp, CTDI_ROUTE_NOTIFY);
    IoFreeIrp(pIrp);

    DEBUGMSG(DBG_FUNC, (DTEXT("-CtdipRouteChangeEvent\n")));
    return STATUS_MORE_PROCESSING_REQUIRED;
}

STATIC VOID
CtdipIpRequestRoutingNotification(
    IN ULONG IpAddress
    )
{
    PLIST_ENTRY pListEntry;
    PIRP pIrp = NULL;
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;
    PIO_STACK_LOCATION IrpSp;
    PCTDI_ROUTE_NOTIFY pNotify = NULL;
    BOOLEAN NotifyActive = FALSE;
    BOOLEAN LockHeld;

    DEBUGMSG(DBG_FUNC, (DTEXT("-CtdipIpRequestRoutingNotification\n")));

    if (!fCtdiInitialized)
    {
        return;
    }
    NdisAcquireSpinLock(&CtdiListLock);
    LockHeld = TRUE;
    for (pListEntry = CtdiRouteNotifyList.Flink;
         pListEntry!=&CtdiRouteNotifyList;
         pListEntry = pListEntry->Flink)
    {
        pNotify = CONTAINING_RECORD(pListEntry,
                                   CTDI_ROUTE_NOTIFY,
                                   ListEntry);

        if (IpAddress==pNotify->Data.Add)
        {
            DEBUGMSG(DBG_TDI, (DTEXT("Routing notification already active on %d.%d.%d.%d\n"),
                               IPADDR(IpAddress)));
            NotifyActive = TRUE;
        }
    }
    if (!NotifyActive)
    {
        DEBUGMSG(DBG_TDI, (DTEXT("Requesting routing notification on %d.%d.%d.%d\n"),
                           IPADDR(IpAddress)));

        pIrp = IoAllocateIrp((CCHAR)(pFileIp->DeviceObject->StackSize +
                                     NUM_STACKS_FOR_CONTEXT(sizeof(CTDI_ROUTE_NOTIFY))),
                             FALSE);
        if (!pIrp)
        {
            WPLOG(LL_A, LM_Res, ("Failed to alloc IRP"));
            gCounters.ulIoAllocateIrpFail++;
            Status = NDIS_STATUS_RESOURCES;
            goto crrnDone;
        }

        pNotify = GET_CONTEXT(pIrp, CTDI_ROUTE_NOTIFY);

        //
        // Setup IRP stack location to forward IRP to IP
        // Must be METHOD_BUFFERED or we are not setting it up correctly
        //

        ASSERT ( (IOCTL_IP_RTCHANGE_NOTIFY_REQUEST & 0x03)==METHOD_BUFFERED );
        pIrp->AssociatedIrp.SystemBuffer = &pNotify->Data;

        IrpSp = IoGetNextIrpStackLocation(pIrp);
        IrpSp->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
        IrpSp->MinorFunction = 0;
        IrpSp->Flags = 0;
        IrpSp->Control = 0;
        IrpSp->FileObject = pFileIp;
        IrpSp->DeviceObject = pFileIp->DeviceObject;
        IrpSp->Parameters.DeviceIoControl.InputBufferLength = sizeof(IPNotifyData);
        IrpSp->Parameters.DeviceIoControl.OutputBufferLength = 0;
        IrpSp->Parameters.DeviceIoControl.IoControlCode = IOCTL_IP_RTCHANGE_NOTIFY_REQUEST;
        IrpSp->Parameters.DeviceIoControl.Type3InputBuffer = NULL;

        IoSetCompletionRoutine(pIrp, CtdipRouteChangeEvent, pNotify, TRUE, TRUE, TRUE);

        pNotify->Data.Version = 0;
        pNotify->Data.Add = IpAddress;

        InsertTailList(&CtdiRouteNotifyList, &pNotify->ListEntry);
        LockHeld = FALSE;
        NdisReleaseSpinLock(&CtdiListLock);
        (void)IoCallDriver(pFileIp->DeviceObject, pIrp);
        pIrp = NULL;
    }

crrnDone:
    if (LockHeld)
    {
        NdisReleaseSpinLock(&CtdiListLock);
    }
    if (pIrp)
    {
        IoFreeIrp(pIrp);
    }
    DEBUGMSG(DBG_FUNC, (DTEXT("+CtdipIpRequestRoutingNotification\n")));
}
#endif


STATIC VOID
CtdipScheduleAddHostRoute(
    PPPTP_WORK_ITEM pWorkItem
    )
{
    PCTDI_DATA pCtdi = pWorkItem->Context;
    DEBUGMSG(DBG_FUNC, (DTEXT("+CtdipScheduleAddHostRoute\n")));

    CtdiAddHostRoute(&pCtdi->Connection.RemoteAddress);

    DEBUGMSG(DBG_FUNC, (DTEXT("-CtdipScheduleAddHostRoute\n")));
}

STATIC NTSTATUS
CtdipConnectCompleteCallback(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp,
    IN PVOID Context
    )
{
    PCTDI_DATA pCtdi = Context;
    NDIS_STATUS NdisStatus;

    PTDI_CONNECTION_INFORMATION pRequestInfo = NULL; 
    PTA_IP_ADDRESS pRequestAddress = NULL; 
    PTDI_CONNECTION_INFORMATION pReturnInfo = NULL; 
    PTA_IP_ADDRESS pReturnAddress = NULL; 
    PBOOLEAN pInboundFlag = NULL; 
    
    DEBUGMSG(DBG_FUNC, (DTEXT("+CtdipConnectCompleteCallback %08x\n"), pIrp->IoStatus.Status));

    SET_DBGFLAG(pCtdi, CTDI_F_CONNECTCOMP_CALLBACK);

    pRequestInfo = pCtdi->Connection.ConnectInfo;

    pRequestAddress = 
        (PTA_IP_ADDRESS)((PUCHAR)(pRequestInfo + 1) + sizeof(PVOID));
    
    (ULONG_PTR)pRequestAddress &=
        ~((ULONG_PTR)sizeof(PVOID) - 1);

    pReturnInfo = 
        (PTDI_CONNECTION_INFORMATION)
        ((PUCHAR)(pRequestAddress + 1) + sizeof(PVOID));

    (ULONG_PTR)pReturnInfo &=
        ~((ULONG_PTR)sizeof(PVOID) - 1);

    pReturnAddress = 
        (PTA_IP_ADDRESS)((PUCHAR)(pReturnInfo + 1) + sizeof(PVOID));

    (ULONG_PTR)pReturnAddress &=
        ~((ULONG_PTR)sizeof(PVOID) - 1);

    pInboundFlag = (PBOOLEAN)(pReturnAddress + 1);

    // Connection complete.  Tell the client.
    if (pIrp->IoStatus.Status==STATUS_SUCCESS)
    {
        pCtdi->Connection.RemoteAddress = *pReturnAddress;
        ScheduleWorkItem(CtdipScheduleAddHostRoute, pCtdi, NULL, 0);

        if (*pInboundFlag)
        {
            NdisInterlockedIncrement(&gCounters.InboundConnectComplete);
        }
        else
        {
            NdisInterlockedIncrement(&gCounters.OutboundConnectComplete);
        }
    }

    MyMemFree(pRequestInfo,
             2*(sizeof(TDI_CONNECTION_INFORMATION)+sizeof(TA_IP_ADDRESS)) + 
             sizeof(BOOLEAN) + 3*sizeof(PVOID) );
    
    pCtdi->Connection.ConnectInfo = NULL;

    if (pCtdi->ConnectCompleteCallback)
    {
        // Report status and give them the new handle if we succeeded.
        NdisStatus = pCtdi->ConnectCompleteCallback(pCtdi->Connection.Context,
                                                    (pIrp->IoStatus.Status ? 0 : (HANDLE)pCtdi),
                                                    pIrp->IoStatus.Status);
        if (NdisStatus!=NDIS_STATUS_SUCCESS || pIrp->IoStatus.Status!=STATUS_SUCCESS)
        {
            CtdiDisconnect(pCtdi, FALSE);
            CtdiClose(pCtdi);
        }
    }
    else
    {
        // We assume that if there's no ConnectCompleteCallback, that this is
        // probably a listen, we've already given the handle for this, and
        // we don't want to close it ourselves.  Instead, we'll do a disconnect
        // indication and allow the upper layer to clean up.
        if (pIrp->IoStatus.Status!=STATUS_SUCCESS &&
            !pCtdi->Closed &&
            pCtdi->DisconnectCallback)
        {
            WPLOG(LL_A, LM_TDI, ("Refused. pCtdi %p Failed IRP status 0x%0x", pCtdi, pIrp->IoStatus.Status));
            pCtdi->DisconnectCallback(pCtdi->Connection.Context, TRUE);
        }
    }

    IoFreeIrp(pIrp);

    DEREFERENCE_OBJECT_EX(pCtdi, CTDI_REF_CONNECT);  // Pair in CtdiConnect

    DEBUGMSG(DBG_FUNC, (DTEXT("-CtdipConnectCompleteCallback\n")));
    return STATUS_MORE_PROCESSING_REQUIRED;
}

STATIC NTSTATUS
CtdipAssociateAddressCallback(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp,
    IN PVOID Context
    )
{
    PCTDI_DATA pConnect = Context;
    DEBUGMSG(DBG_FUNC, (DTEXT("+CtdipAssociateAddressCallback\n")));

    DEBUGMSG(DBG_TDI, (DTEXT("TDI_ASSOCIATE_ADDRESS Sts:%08x\n"), pIrp->IoStatus.Status));

    // ToDo: What cleanup do we need to do if this fails?

    SET_DBGFLAG(pConnect, CTDI_F_ASSOCADDR_CALLBACK);
    //ASSERT(NT_SUCCESS(pIrp->IoStatus.Status));

    IoFreeIrp(pIrp);
    DEREFERENCE_OBJECT_EX(pConnect, CTDI_REF_ASSOADDR);  // Pair in CtdipAddListenConnection and also in CtdiConnect
    DEBUGMSG(DBG_FUNC, (DTEXT("-CtdipAssociateAddressCallback\n")));
    return STATUS_MORE_PROCESSING_REQUIRED;
}

// This function expects the CtdiListLock to be held.
PCTDI_ROUTE
CtdipFindRoute(
    ULONG           IpAddress
    )
{
    PCTDI_ROUTE pRoute = NULL;
    PLIST_ENTRY pListEntry;

    DEBUGMSG(DBG_FUNC, (DTEXT("+CtdipFindRoute\n")));

    for (pListEntry = CtdiRouteList.Flink;
         pListEntry != &CtdiRouteList;
         pListEntry = pListEntry->Flink)
    {
        pRoute = CONTAINING_RECORD(pListEntry,
                                   CTDI_ROUTE,
                                   ListEntry);
        if (pRoute->IpAddress==IpAddress)
        {
            // Found the route, return it.
            goto cfrDone;
        }
    }
    pRoute = NULL;

cfrDone:
    DEBUGMSG(DBG_FUNC, (DTEXT("-CtdipFindRoute %08x\n"), pRoute));
    return pRoute;
}

STATIC NTSTATUS
CtdipSetEventCallback(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp,
    IN PVOID Context
    )
{
    PCTDI_DATA pConnect = Context;
    DEBUGMSG(DBG_FUNC, (DTEXT("+CtdipSetEventCallback\n")));

    DEBUGMSG(DBG_TDI, (DTEXT("TDI_SET_EVENT_HANDLER Sts:%08x\n"), pIrp->IoStatus.Status));

    // ToDo: What cleanup do we need to do if this fails?

    IoFreeIrp(pIrp);
    DEREFERENCE_OBJECT_EX(pConnect, CTDI_REF_SETEVENT);  // Pair in CtdipSetEventHandler
    DEBUGMSG(DBG_FUNC, (DTEXT("-CtdipSetEventCallback\n")));
    return STATUS_MORE_PROCESSING_REQUIRED;
}

STATIC NDIS_STATUS
CtdipSetEventHandler(
    IN      PCTDI_DATA                  pCtdi,
    IN      ULONG                       ulEventType,
    IN      PVOID                       pEventHandler
    )
{
    PIRP pIrp;
    NDIS_STATUS ReturnStatus = NDIS_STATUS_SUCCESS;
    NTSTATUS NtStatus;

    DEBUGMSG(DBG_FUNC, (DTEXT("+CtdipSetEventHandler\n")));
    if (!IS_CTDI(pCtdi))
    {
        DEBUGMSG(DBG_ERROR, (DTEXT("Ctdi: Bad handle %p\n"), pCtdi));
        WPLOG(LL_A, LM_TDI, ("Ctdi: Bad handle %p", pCtdi));
        ReturnStatus = NDIS_STATUS_FAILURE;
        goto cpsehDone;
    }

    // This should be the Address context ToDo: is this always true?

    pIrp = IoAllocateIrp(pCtdi->pFileObject->DeviceObject->StackSize, FALSE);
    if (!pIrp)
    {
        WPLOG(LL_A, LM_Res, ("Failed to alloc IRP"));
        gCounters.ulIoAllocateIrpFail++;
        ReturnStatus = NDIS_STATUS_RESOURCES;
        goto cpsehDone;
    }

    REFERENCE_OBJECT_EX(pCtdi, CTDI_REF_SETEVENT);  // Pair in CtdipSetEventCallback
    TdiBuildSetEventHandler(pIrp,
                            pCtdi->pFileObject->DeviceObject,
                            pCtdi->pFileObject,
                            CtdipSetEventCallback,
                            pCtdi,
                            ulEventType,
                            pEventHandler,
                            pCtdi);

    DEBUGMSG(DBG_TDI, (DTEXT("IoCallDriver TDI_SET_EVENT_HANDLER\n")));

    // Completion handler always called, don't care on return value.
    (void)IoCallDriver(pCtdi->pFileObject->DeviceObject, pIrp);

    ReturnStatus = STATUS_SUCCESS;

cpsehDone:
    DEBUGMSG(DBG_FUNC|DBG_ERR(ReturnStatus), (DTEXT("-CtdipSetEventHandler\n")));
    return ReturnStatus;
}

STATIC NDIS_STATUS
CtdipAddListenConnection(
    IN      PCTDI_DATA                  pEndpoint
    )
{
    NTSTATUS NtStatus;
    OBJECT_ATTRIBUTES ObjectAttributes;
    IO_STATUS_BLOCK IoStatusBlock;
    PIRP pIrp;
    UNICODE_STRING DeviceName;

    UCHAR EaBuffer[sizeof(FILE_FULL_EA_INFORMATION) +
                   TDI_CONNECTION_CONTEXT_LENGTH +
                   sizeof(PVOID)];
    PFILE_FULL_EA_INFORMATION pEa = (PFILE_FULL_EA_INFORMATION)EaBuffer;
    PVOID UNALIGNED *ppContext;

    NDIS_STATUS ReturnStatus = NDIS_STATUS_SUCCESS;
    PCTDI_DATA pConnect;

    DEBUGMSG(DBG_FUNC, (DTEXT("+CtdipAddListenConnection\n")));

    pConnect = CtdipDataAlloc();
    if (!pConnect)
    {
        ReturnStatus = NDIS_STATUS_RESOURCES;
        goto calcDone;
    }

    pConnect->Type = CTDI_CONNECTION;
    pConnect->Connection.LocalEndpoint = pEndpoint;

    pConnect->RecvCallback = pEndpoint->RecvCallback;
    pConnect->DisconnectCallback = pEndpoint->DisconnectCallback;

    DeviceName.Length = sizeof(DD_TCP_DEVICE_NAME) - sizeof(WCHAR);
    DeviceName.Buffer = DD_TCP_DEVICE_NAME;

    InitializeObjectAttributes(&ObjectAttributes,
                               &DeviceName,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    NdisZeroMemory(pEa, sizeof(EaBuffer));
    pEa->EaNameLength = TDI_CONNECTION_CONTEXT_LENGTH;
    pEa->EaValueLength = sizeof(PVOID);
    NdisMoveMemory(pEa->EaName, TdiConnectionContext, TDI_CONNECTION_CONTEXT_LENGTH);

    ppContext = (PVOID UNALIGNED*)
        (pEa->EaName + TDI_CONNECTION_CONTEXT_LENGTH + 1);

    *ppContext = pConnect;

    NdisZeroMemory(&IoStatusBlock, sizeof(IoStatusBlock));

    NtStatus =
        ZwCreateFile(&pConnect->hFile,                 /* FileHandle */
                     FILE_READ_DATA | FILE_WRITE_DATA, /* Desired Access */
                     &ObjectAttributes,                /* Object Attributes */
                     &IoStatusBlock,                   /* IO Status Block */
                     NULL,                             /* Allocation Size */
                     FILE_ATTRIBUTE_NORMAL,            /* File Attributes */
                     0,                                /* Share Access */
                     FILE_OPEN,                        /* Create Disposition */
                     0,                                /* Create Options */
                     pEa,                              /* EaBuffer */
                     sizeof(EaBuffer)                  /* EaLength */
                     );

    if (NtStatus!=STATUS_SUCCESS)
    {
        WPLOG(LL_A, LM_TDI, ("ZwCreateFile failed"));
        ReturnStatus = NtStatus;
        goto calcDone;
    }

    // Convert the address file handle to a FILE_OBJECT

    NtStatus =
        ObReferenceObjectByHandle(pConnect->hFile,            /* Handle */
                                  0,                          /* DesiredAccess */
                                  NULL,                       /* ObjectType */
                                  KernelMode,                 /* AccessMode */
                                  &pConnect->pFileObject,     /* Object */
                                  NULL                        /* HandleInfo */
                                  );


    if (NtStatus != STATUS_SUCCESS)
    {
        WPLOG(LL_A, LM_TDI, ("ObReferenceObjectByHandle failed"));
        ReturnStatus = NtStatus;
        goto calcDone;
    }

    // Make an irp to associate the endpoint and connection.
    pIrp = IoAllocateIrp(pConnect->pFileObject->DeviceObject->StackSize, FALSE);
    if (!pIrp)
    {
        WPLOG(LL_A, LM_Res, ("Failed to alloc IRP"));
        gCounters.ulIoAllocateIrpFail++;
        ReturnStatus = NDIS_STATUS_RESOURCES;
        goto calcDone;
    }

    REFERENCE_OBJECT_EX(pConnect, CTDI_REF_ASSOADDR);  // Pair in CtdipAssociateAddressCallback
    TdiBuildAssociateAddress(pIrp,
                             pConnect->pFileObject->DeviceObject,
                             pConnect->pFileObject,
                             CtdipAssociateAddressCallback,
                             pConnect,
                             pEndpoint->hFile);

    DEBUGMSG(DBG_TDI, (DTEXT("IoCallDriver TDI_ASSOCIATE_ADDRESS\n")));

    // Completion handler always called, don't care on return value.
    (void)IoCallDriver(pConnect->pFileObject->DeviceObject, pIrp);

    // Associate address creates a reference from the connection to the endpoint.
    REFERENCE_OBJECT_EX(pEndpoint, CTDI_REF_ADDRREF);  // Pair in CtdipDisassociateAddressCallback

    SET_DBGFLAG(pConnect, CTDI_F_BUILD_ASSOCADDR);  
#if DBG
    pConnect->bRef = TRUE;  
#endif

    // It's ready.  Put it on the list.
    REFERENCE_OBJECT_EX(pEndpoint, CTDI_REF_LIST);  //Pair in CtdipConnectCallback
    REFERENCE_OBJECT_EX(pConnect, CTDI_REF_LIST);   //Pair in CtdipConnectCallback
    MyInterlockedInsertTailList(&pEndpoint->Listen.ConnectList, &pConnect->Connection.ListEntry, &pEndpoint->Lock);

    NdisInterlockedIncrement(&pEndpoint->Listen.NumConnection);
    // This pConnect should now be an active TCP listen.
calcDone:
    if (NT_SUCCESS(ReturnStatus))
    {
        WPLOG(LL_M, LM_TDI, ("New pCtdi %p added for listen", pConnect));
    }
    else
    {
        if (pConnect)
        {
            // Any failure means no associate address.  don't disassociate.
            // It also means it's not attached to the listen.
            CtdiClose(pConnect);
        }
        WPLOG(LL_A, LM_TDI, ("Failed to add CTDI for listen"));
    }
    DEBUGMSG(DBG_FUNC|DBG_ERR(ReturnStatus), (DTEXT("-CtdipAddListenConnection %08x\n"), ReturnStatus));
    return ReturnStatus;
}

STATIC VOID
CtdipReplenishListens(
    IN      PPPTP_WORK_ITEM             pWorkItem
    )
{
    PCTDI_DATA pEndpoint = pWorkItem->Context;
    ULONG i;
    DEBUGMSG(DBG_FUNC, (DTEXT("+CtdipReplenishListens\n")));

    for (i=pEndpoint->Listen.NumConnection; i<NUM_TCP_LISTEN; i++)
    {
        CtdipAddListenConnection(pEndpoint);
    }

    DEREFERENCE_OBJECT_EX(pEndpoint, CTDI_REF_REPLENISH); // Pair in CtdipConnectCallback
    DEBUGMSG(DBG_FUNC, (DTEXT("-CtdipReplenishListens\n")));
}

STATIC NTSTATUS
CtdipConnectCallback(
   IN PVOID TdiEventContext,
   IN LONG RemoteAddressLength,
   IN PVOID RemoteAddress,
   IN LONG UserDataLength,
   IN PVOID UserData,
   IN LONG OptionsLength,
   IN PVOID Options,
   OUT CONNECTION_CONTEXT *ConnectionContext,
   OUT PIRP *AcceptIrp
   )
{
    NTSTATUS Status = STATUS_MORE_PROCESSING_REQUIRED;
    NDIS_STATUS NdisStatus;
    PTRANSPORT_ADDRESS pAddress = (PTRANSPORT_ADDRESS)RemoteAddress;
    PCTDI_DATA pCtdi = (PCTDI_DATA)TdiEventContext;
    PCTDI_DATA pConnect = NULL;
    UINT i;
    PIRP pIrp = NULL;
    PTDI_CONNECTION_INFORMATION pRequestInfo = NULL;
    PTDI_CONNECTION_INFORMATION pReturnInfo = NULL;
    PTA_IP_ADDRESS pRemoteAddress;
    PVOID pNewContext;
    PLIST_ENTRY pListEntry = NULL;
    PBOOLEAN pInboundFlag;
    BOOLEAN bTrusted;

    DEBUGMSG(DBG_FUNC, (DTEXT("+CtdipConnectCallback\n")));

    NdisInterlockedIncrement(&gCounters.InboundConnectAttempts);

    if (RemoteAddressLength<sizeof(TA_IP_ADDRESS) ||
        !RemoteAddress ||
        pCtdi->Closed)
    {
        Status = STATUS_CONNECTION_REFUSED;
        WPLOG(LL_A, LM_TDI, ("Refused. Incorrect remote address."));
        goto cccDone;
    }

    ASSERT(UserDataLength==0);
    ASSERT(OptionsLength==0);
    
    if(PptpMaxTunnelsPerIpAddress == -1)
    {
        // By default, we trust all IP addresses.
        bTrusted = TRUE;
    }
    else
    {
        bTrusted = FALSE;
        
        // Does this come from a trusted IP address?
        if (g_ulTrustedClientAddresses)
        {
            for (i=0; i<g_ulTrustedClientAddresses; i++)
            {
                if ((((PTA_IP_ADDRESS)pAddress)->Address[0].Address[0].in_addr & g_TrustedClientList[i].Mask) ==
                    (g_TrustedClientList[i].Address & g_TrustedClientList[i].Mask))
                {
                    bTrusted = TRUE;
                    
                    WPLOG(LL_A, LM_TDI, ("Trusted IP address %!IPADDR!.", 
                        ((PTA_IP_ADDRESS)pAddress)->Address[0].Address[0].in_addr));
                    
                    break;
                }
            }
        }
        
        // If it's not from a trusted ip address, we need to check the number of TCP connections.
        if(!bTrusted)
        {
            PCTDI_DATA pCtdiTemp;
            ULONG ulFoundTcpConnections = 0;
            
            NdisAcquireSpinLock(&CtdiListLock);
            for (pListEntry = CtdiList.Flink;
                 pListEntry != &CtdiList;
                 pListEntry = pListEntry->Flink)
            {
                pCtdiTemp = CONTAINING_RECORD(pListEntry,
                                          CTDI_DATA,
                                          ListEntry);
                if (IS_CTDI(pCtdiTemp) &&
                    pCtdiTemp->Type == CTDI_CONNECTION &&
                    pCtdiTemp->Connection.RemoteAddress.Address[0].Address[0].in_addr == 
                        ((PTA_IP_ADDRESS)pAddress)->Address[0].Address[0].in_addr)
                
                {
                    ulFoundTcpConnections++;
                }
            }
            NdisReleaseSpinLock(&CtdiListLock);
            
            if(ulFoundTcpConnections >= PptpMaxTunnelsPerIpAddress)
            {
                Status = STATUS_CONNECTION_REFUSED;
                WPLOG(LL_A, LM_TDI, ("Refused. %d connections from %!IPADDR! exceeded the limit.", 
                    ulFoundTcpConnections, ((PTA_IP_ADDRESS)pAddress)->Address[0].Address[0].in_addr));
                    
                goto cccDone;
            }
        }
    }
    
    // Do all the allocation we'll need at one shot.

    pIrp = IoAllocateIrp(pCtdi->pFileObject->DeviceObject->StackSize, FALSE);
    if(!pIrp)
    {
        WPLOG(LL_A, LM_Res, ("Failed to alloc IRP"));
        gCounters.ulIoAllocateIrpFail++;
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto cccDone;
    }

    // No sign saying we can't allocate the request info, return info and address buffers
    // in one shot.
    pRequestInfo = MyMemAlloc(2*(sizeof(TDI_CONNECTION_INFORMATION)+
                                 sizeof(TA_IP_ADDRESS)) +
                              3*sizeof(PVOID) + sizeof(BOOLEAN),
                              TAG_CTDI_CONNECT_INFO);
    if (!pRequestInfo)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        WPLOG(LL_A, LM_Res, ("Refused. Insufficient resources."));
        goto cccDone;
    }

    pListEntry = MyInterlockedRemoveHeadList(&pCtdi->Listen.ConnectList,
                                             &pCtdi->Lock);
    if (!pListEntry)
    {
        DEBUGMSG(DBG_ERROR, (DTEXT("No listen connections available.\n")));
        WPLOG(LL_A, LM_TDI, ("Refused. No listen connections available."));
        Status = STATUS_CONNECTION_REFUSED;

        REFERENCE_OBJECT_EX(pCtdi, CTDI_REF_REPLENISH); // pair in CtdipReplenishListens
        if (ScheduleWorkItem(CtdipReplenishListens, pCtdi, NULL, 0)!=NDIS_STATUS_SUCCESS)
        {
            DEREFERENCE_OBJECT_EX(pCtdi, CTDI_REF_REPLENISH); // pair for above if Schedule fails
        }
        goto cccDone;
    }
    NdisInterlockedDecrement(&pCtdi->Listen.NumConnection);

    pConnect = CONTAINING_RECORD(pListEntry,
                                 CTDI_DATA,
                                 Connection.ListEntry);

    // We have a double reference when an object is on the list of another object,
    // and we want to release them both when we remove the item from the list,
    // but in this case we also want to take a reference on the connection object,
    // so one of them cancels out.
    //REFERENCE_OBJECT(pConnect);  // Pair in CtdiDisconnect
    //DEREFERENCE_OBJECT(pConnect);   // Pair in CtdipAddListenConnection
    DEREFERENCE_OBJECT_EX(pCtdi, CTDI_REF_LIST);      // Pair in CtdipAddListenConnection

    if (!pCtdi->ConnectQueryCallback || pCtdi->Closed)
    {
        Status = STATUS_CONNECTION_REFUSED;
        WPLOG(LL_A, LM_TDI, ("Refused. pCtdi %p in wrong state.", pCtdi));
        goto cccDone;
    }
    NdisStatus = pCtdi->ConnectQueryCallback(pCtdi->Listen.Context,
                                             pAddress,
                                             pConnect,
                                             &pNewContext);
    if (NdisStatus!=NDIS_STATUS_SUCCESS)
    {
        Status = STATUS_CONNECTION_REFUSED;
        WPLOG(LL_A, LM_TDI, ("Refused. QueryCallback failed NdisStatus %x", NdisStatus));
        goto cccDone;
    }


    // We've got the go-ahead to accept this connection, at the TCP level.

    pConnect->Connection.ConnectInfo = pRequestInfo;
    pConnect->Connection.Context = pNewContext;
    pConnect->Connection.RemoteAddress = *(PTA_IP_ADDRESS)pAddress;

    NdisZeroMemory(pRequestInfo,
                   2*(sizeof(TDI_CONNECTION_INFORMATION)+sizeof(TA_IP_ADDRESS))
                   + sizeof(BOOLEAN) + 3*sizeof(PVOID));

    pRequestInfo->RemoteAddressLength = sizeof(TA_IP_ADDRESS);

    pRemoteAddress =
        (PTA_IP_ADDRESS)((PUCHAR)(pRequestInfo + 1) + sizeof(PVOID));
    
    (ULONG_PTR)pRemoteAddress &=
        ~((ULONG_PTR)sizeof(PVOID) - 1);

    pRequestInfo->RemoteAddress = pRemoteAddress;

    *pRemoteAddress = *(PTA_IP_ADDRESS)pAddress;

    pReturnInfo = 
        (PTDI_CONNECTION_INFORMATION)
        ((PUCHAR)(pRemoteAddress + 1) + sizeof(PVOID));

    (ULONG_PTR)pReturnInfo &=
        ~((ULONG_PTR)sizeof(PVOID) - 1);

    pReturnInfo->RemoteAddressLength = sizeof(TA_IP_ADDRESS);

    pRemoteAddress = 
        (PTA_IP_ADDRESS)((PUCHAR)(pReturnInfo + 1) + sizeof(PVOID));

    (ULONG_PTR)pRemoteAddress &=
        ~((ULONG_PTR)sizeof(PVOID) - 1);

    pReturnInfo->RemoteAddress = pRemoteAddress;

    pInboundFlag = (PBOOLEAN)(pRemoteAddress + 1);
    *pInboundFlag = TRUE;

    // ToDo: the old PPTP driver filled in the ReturnInfo remote address.
    // 
    pRemoteAddress->TAAddressCount = 1;
    pRemoteAddress->Address[0].AddressLength = TDI_ADDRESS_LENGTH_IP;
    pRemoteAddress->Address[0].AddressType = TDI_ADDRESS_TYPE_IP;

    SET_DBGFLAG(pConnect, CTDI_F_ACCEPT);

    TdiBuildAccept(pIrp,
                   pConnect->pFileObject->DeviceObject,
                   pConnect->pFileObject,
                   CtdipConnectCompleteCallback,
                   pConnect,                // Context
                   pRequestInfo,
                   pReturnInfo);

    IoSetNextIrpStackLocation(pIrp);

    *ConnectionContext = pConnect;
    *AcceptIrp = pIrp;

    REFERENCE_OBJECT_EX(pConnect->Connection.LocalEndpoint, CTDI_REF_REPLENISH); // pair in CtdipReplenishListens
    if (ScheduleWorkItem(CtdipReplenishListens, pConnect->Connection.LocalEndpoint, NULL, 0)!=NDIS_STATUS_SUCCESS)
    {
        DEREFERENCE_OBJECT_EX(pConnect->Connection.LocalEndpoint, CTDI_REF_REPLENISH); // pair for above if Schedule fails
    }

cccDone:
    if (Status!=STATUS_MORE_PROCESSING_REQUIRED)
    {
        // We lose.  Clean up.
        if (pConnect)
        {
            // We haven't used this connection, so it is still valid.  return it
            // to the list, and reapply the references.
            REFERENCE_OBJECT_EX(pCtdi, CTDI_REF_LIST);
            //REFERENCE_OBJECT(pConnect);
            MyInterlockedInsertTailList(&pCtdi->Listen.ConnectList,
                                        &pConnect->Connection.ListEntry,
                                        &pCtdi->Lock);
            NdisInterlockedIncrement(&pCtdi->Listen.NumConnection);
        }
        if (pIrp)
        {
            IoFreeIrp(pIrp);
        }
        if (pRequestInfo)
        {
            MyMemFree(pRequestInfo,
                      2*(sizeof(TDI_CONNECTION_INFORMATION)+sizeof(TA_IP_ADDRESS)));
        }
    }


    DEBUGMSG(DBG_FUNC|DBG_ERR(Status), (DTEXT("-CtdipConnectCallback %08x\n"), Status));
    return Status;
}

STATIC NTSTATUS
CtdipDisassociateAddressCallback(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp,
    IN PVOID Context
    )
{
    PCTDI_DATA pConnect = Context;
    PCTDI_DATA pEndpoint;
    DEBUGMSG(DBG_FUNC, (DTEXT("+CtdipDisassociateAddressCallback\n")));

    DEBUGMSG(DBG_TDI, (DTEXT("TDI_DISASSOCIATE_ADDRESS Sts:%08x\n"), pIrp->IoStatus.Status));

    // ToDo: What cleanup do we need to do if this fails?
    SET_DBGFLAG(pConnect, CTDI_F_DISASSOC_CALLBACK);

    IoFreeIrp(pIrp);
    pEndpoint = pConnect->Connection.LocalEndpoint;
    DEREFERENCE_OBJECT_EX(pConnect, CTDI_REF_DISASSO);  // Pair in CtdipDisconnectCleanup
    DEREFERENCE_OBJECT_EX(pEndpoint, CTDI_REF_ADDRREF);  // Pair in CtdipAddListenConnection and CtdiConnect
    DEBUGMSG(DBG_FUNC, (DTEXT("-CtdipDisassociateAddressCallback\n")));
    return STATUS_MORE_PROCESSING_REQUIRED;
}

STATIC VOID
CtdipDisconnectCleanup(
    IN PPPTP_WORK_ITEM pWorkItem
    )
{
    PCTDI_DATA pConnect = pWorkItem->Context;
    PIRP pIrp = NULL;
    NTSTATUS Status;
    DEBUGMSG(DBG_FUNC, (DTEXT("+CtdipDisconnectCleanup\n")));

    SET_DBGFLAG(pConnect, CTDI_F_DISCONNECT_CLEANUP);

    pIrp = IoAllocateIrp(pConnect->pFileObject->DeviceObject->StackSize, FALSE);
    if (!pIrp)
    {
        PCTDI_DATA pEndpoint = pConnect->Connection.LocalEndpoint;
    
        WPLOG(LL_A, LM_Res, ("Failed to alloc IRP"));
        gCounters.ulIoAllocateIrpFail++;
        
        DEREFERENCE_OBJECT_EX(pEndpoint, CTDI_REF_ADDRREF);  // Pair in CtdipAddListenConnection and CtdiConnect
    }
    else
    {
        // Normally we would reference pConnect for making an irp, but we already
        // have one for this work item, & we'll just keep it.
    
        SET_DBGFLAG(pConnect, CTDI_F_BUILD_DISASSOC);
    
        TdiBuildDisassociateAddress(pIrp,
                                    pConnect->pFileObject->DeviceObject,
                                    pConnect->pFileObject,
                                    CtdipDisassociateAddressCallback,
                                    pConnect);
        DEBUGMSG(DBG_TDI, (DTEXT("IoCallDriver TDI_DISASSOCIATE_ADDRESS\n")));
        REFERENCE_OBJECT_EX(pConnect, CTDI_REF_DISASSO);
    
        // Completion handler always called, don't care on return value.
        (void)IoCallDriver(pConnect->pFileObject->DeviceObject, pIrp);
    }

    CtdiDeleteHostRoute(&pConnect->Connection.RemoteAddress);

    if (!pConnect->Closed && pConnect->DisconnectCallback)
    {
        pConnect->DisconnectCallback(pConnect->Connection.Context,
                                     pConnect->Connection.Abort);
    }

    DEREFERENCE_OBJECT_EX(pConnect, CTDI_REF_DISCONNECT);  // Pair CtdipDisconnectCallback and CtdiDisconnect

    DEBUGMSG(DBG_FUNC, (DTEXT("-CtdipDisconnectCleanup\n")));
}

STATIC NTSTATUS
CtdipDisconnectCompleteCallback(
    PDEVICE_OBJECT pDeviceObject,
    PIRP pIrp,
    PVOID Context
    )
{
    PCTDI_DATA pConnect = Context;
    PIO_STACK_LOCATION pIrpSp = IoGetNextIrpStackLocation(pIrp);
    PTDI_REQUEST_KERNEL pRequest = (PTDI_REQUEST_KERNEL)&pIrpSp->Parameters;
    BOOLEAN CleanupNow = FALSE;

    DEBUGMSG(DBG_FUNC, (DTEXT("+CtdipDisconnectCompleteCallback %08x\n"), pIrp->IoStatus.Status));

    if (pRequest->RequestConnectionInformation)
    {
        // We don't do anything with this info yet
    }
    if (pRequest->ReturnConnectionInformation)
    {
        // We don't do anything with this info yet
    }
    if (pRequest->RequestSpecific)
    {
        // Allocated as part of irp, don't free it.
    }

    if (IS_CTDI(pConnect))
    {

        SET_DBGFLAG(pConnect, CTDI_F_DISCONNECTCOMP_CALLBACK);

        // Possible to do a release AND and abort, so we'll get called here twice.
        // We only want to cleanup once.
        NdisAcquireSpinLock(&pConnect->Lock);
        CleanupNow = ((--pConnect->Connection.DisconnectCount)==0) ? TRUE : FALSE;
        NdisReleaseSpinLock(&pConnect->Lock);

        if (!CleanupNow ||
            ScheduleWorkItem(CtdipDisconnectCleanup, pConnect, NULL, 0)!=NDIS_STATUS_SUCCESS)
        {
            DEREFERENCE_OBJECT_EX(pConnect, CTDI_REF_DISCONNECT);  // Pair CtdipDisconnectCallback and CtdiDisconnect
        }
    }

    IoFreeIrp(pIrp);

    DEBUGMSG(DBG_FUNC, (DTEXT("-CtdipDisconnectCompleteCallback\n")));
    return STATUS_MORE_PROCESSING_REQUIRED;
}

STATIC NTSTATUS
CtdipDisconnectCallback(
   IN PVOID TdiEventContext,
   IN CONNECTION_CONTEXT ConnectionContext,
   IN LONG DisconnectDataLength,
   IN PVOID DisconnectData,
   IN LONG DisconnectInformationLength,
   IN PVOID DisconnectInformation,
   IN ULONG DisconnectFlags
   )
{
    PCTDI_DATA pConnect = (PCTDI_DATA)ConnectionContext;
    PCTDI_DATA pEndpoint;
    PIRP pIrp = NULL;
    PTIME pTimeout = NULL;
    PTDI_CONNECTION_INFORMATION pConnectInfo = NULL;
    NTSTATUS Status = STATUS_SUCCESS;

    DEBUGMSG(DBG_FUNC, (DTEXT("+CtdipDisconnectCallback\n")));
    
    if (!IS_CTDI(pConnect))
    {
        DEBUGMSG(DBG_ERROR, (DTEXT("pConnect: Bad handle %p\n"), pConnect));
        WPLOG(LL_A, LM_TDI, ("pConnect: Bad handle %p", pConnect));
        Status = NDIS_STATUS_FAILURE;
        goto cdcDone;
    }
    
    SET_DBGFLAG(pConnect, CTDI_F_DISCONNECT_CALLBACK);
    
    if (DisconnectFlags==0)
    {
        DisconnectFlags = TDI_DISCONNECT_ABORT;
    }
    ASSERT(DisconnectFlags==TDI_DISCONNECT_RELEASE || DisconnectFlags==TDI_DISCONNECT_ABORT);

    NdisAcquireSpinLock(&pConnect->Lock);
    if (DisconnectFlags==TDI_DISCONNECT_ABORT)
    {
        BOOLEAN CleanupNow;

        WPLOG(LL_M, LM_TDI, ("pCtdi %p, Flags ABORT", pConnect));
                                         
        pConnect->Connection.Disconnect = TRUE;
        pConnect->Connection.Abort = TRUE;
        CleanupNow = (pConnect->Connection.DisconnectCount==0) ? TRUE : FALSE;
        REFERENCE_OBJECT_EX(pConnect, CTDI_REF_DISCONNECT);  // Pair in CtdipDisconnectCleanup
        NdisReleaseSpinLock(&pConnect->Lock);
        if (CleanupNow)
        {
            if (ScheduleWorkItem(CtdipDisconnectCleanup, pConnect, NULL, 0)!=NDIS_STATUS_SUCCESS)
            {
                // Schedule failed, deref now
                DEREFERENCE_OBJECT_EX(pConnect, CTDI_REF_DISCONNECT);  // Pair above
            }
        }
        else
        {
            DEREFERENCE_OBJECT_EX(pConnect, CTDI_REF_DISCONNECT);  // Pair above
        }
    }
    else
    {
        WPLOG(LL_I, LM_TDI, ("pCtdi %p, Flags %d", pConnect, DisconnectFlags));
    
        if (pConnect->Connection.Disconnect)
        {
            // We've already disconnected.  Ignore.
            NdisReleaseSpinLock(&pConnect->Lock);
        }
        else
        {
            pConnect->Connection.Disconnect = TRUE;
            pConnect->Connection.DisconnectCount++;

            REFERENCE_OBJECT_EX(pConnect, CTDI_REF_DISCONNECT);  // Pair in CtdipDisconnectCompleteCallback
            NdisReleaseSpinLock(&pConnect->Lock);

            pIrp = IoAllocateIrp((CCHAR)(pConnect->pFileObject->DeviceObject->StackSize +
                                         NUM_STACKS_FOR_CONTEXT(sizeof(TIME)+sizeof(TDI_CONNECTION_INFORMATION))),
                                 FALSE);

            if (!pIrp)
            {
                WPLOG(LL_A, LM_Res, ("Failed to alloc IRP"));
                gCounters.ulIoAllocateIrpFail++;
                Status = STATUS_INSUFFICIENT_RESOURCES;
                DEREFERENCE_OBJECT_EX(pConnect, CTDI_REF_DISCONNECT);  // Pair above
                goto cdcDone;
            }

            pTimeout = (PTIME)GetContextArea(pIrp, sizeof(TIME)+sizeof(TDI_CONNECTION_INFORMATION));
            pConnectInfo = (PTDI_CONNECTION_INFORMATION)(pTimeout + 1);

            pTimeout->LowPart = CtdiTcpDisconnectTimeout * -10000000L;
            pTimeout->HighPart = (pTimeout->LowPart) ? -1 : 0;

            // Responding to a controlled disconnect, we don't provide
            // TDI_CONNECTION_INFORMATION, but we request it from the peer.
            
            SET_DBGFLAG(pConnect, CTDI_F_BUILD_DISCONNECT_1);

            TdiBuildDisconnect(pIrp,
                               pConnect->pFileObject->DeviceObject,
                               pConnect->pFileObject,
                               CtdipDisconnectCompleteCallback,
                               pConnect,
                               pTimeout,
                               TDI_DISCONNECT_RELEASE,
                               NULL,
                               pConnectInfo);


            // Completion handler always called, don't care on return value.
            (void)IoCallDriver(pConnect->pFileObject->DeviceObject, pIrp);
        }
    }

cdcDone:
    if (!NT_SUCCESS(Status))
    {
        if (pIrp)
        {
            IoFreeIrp(pIrp);
        }
    }
    DEBUGMSG(DBG_FUNC, (DTEXT("-CtdipDisconnectCallback\n")));
    return STATUS_SUCCESS;
}

STATIC NTSTATUS
CtdipOpenProtocol(
    IN      PUNICODE_STRING             pDeviceName,
    IN      PTRANSPORT_ADDRESS          pAddress,
    OUT     PHANDLE                     phFile,
    OUT     PFILE_OBJECT               *ppFileObject
    )
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    UCHAR EaBuffer[sizeof(FILE_FULL_EA_INFORMATION) +
                   TDI_TRANSPORT_ADDRESS_LENGTH +
                   sizeof(TA_IP_ADDRESS)];
    PFILE_FULL_EA_INFORMATION pEa = (PFILE_FULL_EA_INFORMATION)EaBuffer;
    TA_IP_ADDRESS UNALIGNED *pEaTaIp;
    IO_STATUS_BLOCK IoStatusBlock;
    OBJECT_ATTRIBUTES ObjectAttributes;

    DEBUGMSG(DBG_FUNC, (DTEXT("+CtdipOpenProtocol %wZ\n"), pDeviceName));

    *phFile = 0;
    *ppFileObject = NULL;

    InitializeObjectAttributes(&ObjectAttributes,
                               pDeviceName,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    NdisZeroMemory(pEa, sizeof(EaBuffer));
    pEa->EaNameLength = TDI_TRANSPORT_ADDRESS_LENGTH;
    pEa->EaValueLength = sizeof(TA_IP_ADDRESS);
    NdisMoveMemory(pEa->EaName, TdiTransportAddress, TDI_TRANSPORT_ADDRESS_LENGTH);

    pEaTaIp = (TA_IP_ADDRESS UNALIGNED*)
        (pEa->EaName + TDI_TRANSPORT_ADDRESS_LENGTH + 1);

    *pEaTaIp = *(PTA_IP_ADDRESS)pAddress;

    DEBUGMSG(DBG_TDI, (DTEXT("Endpoint: sin_port = %Xh in_addr = %Xh\n"),
        pEaTaIp->Address[0].Address[0].sin_port,
        pEaTaIp->Address[0].Address[0].in_addr));

    NdisZeroMemory(&IoStatusBlock, sizeof(IoStatusBlock));

    NtStatus =
        ZwCreateFile(
        phFile,                           /* FileHandle */
        FILE_READ_DATA | FILE_WRITE_DATA, /* Desired Access */
        &ObjectAttributes,                /* Object Attributes */
        &IoStatusBlock,                   /* IO Status Block */
        NULL,                             /* Allocation Size */
        FILE_ATTRIBUTE_NORMAL,            /* File Attributes */
        0,                                /* Share Access */
        FILE_OPEN,                        /* Create Disposition */
        0,                                /* Create Options */
        pEa,                              /* EaBuffer */
        sizeof(EaBuffer)                  /* EaLength */
        );

    if (NtStatus!=STATUS_SUCCESS)
    {
        DEBUGMSG(DBG_ERROR, (DTEXT("ZwCreateFile failed %08x\n"), NtStatus));
        goto copDone;
    }

    // Convert the address file handle to a FILE_OBJECT

    NtStatus =
        ObReferenceObjectByHandle(
            *phFile,                    /* Handle */
            0,                          /* DesiredAccess */
            NULL,                       /* ObjectType */
            KernelMode,                 /* AccessMode */
            ppFileObject,               /* Object */
            NULL                        /* HandleInfo */
            );

copDone:
    if (NtStatus!=STATUS_SUCCESS && *phFile)
    {
        WPLOG(LL_A, LM_TDI, ("Failed %08x", NtStatus));
        ZwClose(*phFile);
        *phFile = 0;
        *ppFileObject = NULL;
    }
    DEBUGMSG(DBG_FUNC|DBG_ERR(NtStatus), (DTEXT("-CtdipOpenProtocol %08x\n"), NtStatus));
    return NtStatus;
}

STATIC NTSTATUS
CtdipReceiveCompleteCallback(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp,
    IN PVOID Context
    )
{
    PCTDI_DATA pCtdi = Context;
    PUCHAR pData;
    ULONG Length;
    DEBUGMSG(DBG_FUNC, (DTEXT("+CtdipReceiveCompleteCallback\n")));

    pData = MmGetMdlVirtualAddress(pIrp->MdlAddress);
    Length = MmGetMdlByteCount(pIrp->MdlAddress);
    if (pIrp->IoStatus.Status==STATUS_SUCCESS && pCtdi->RecvCallback && !pCtdi->Closed)
    {
        pCtdi->RecvCallback(pCtdi->Connection.Context, pData, Length);
    }

#if PROBE
    MmUnlockPages(pIrp->MdlAddress);
#endif
    IoFreeMdl(pIrp->MdlAddress);
    MyMemFree(pData, Length);
    IoFreeIrp(pIrp);

    DEBUGMSG(DBG_FUNC, (DTEXT("-CtdipReceiveCompleteCallback\n")));
    return STATUS_MORE_PROCESSING_REQUIRED;
}

STATIC NTSTATUS
CtdipReceiveCallback(
   IN PVOID TdiEventContext,
   IN CONNECTION_CONTEXT ConnectionContext,
   IN ULONG ReceiveFlags,
   IN ULONG BytesIndicated,
   IN ULONG BytesAvailable,
   OUT ULONG *BytesTaken,
   IN PVOID Tsdu,
   OUT PIRP *IoRequestPacket
   )
{
    PCTDI_DATA pCtdi = ConnectionContext;
    NTSTATUS NtStatus = STATUS_DATA_NOT_ACCEPTED;
    NDIS_STATUS Status;
    DEBUGMSG(DBG_FUNC, (DTEXT("+CtdipReceiveCallback\n")));

    if (pCtdi->RecvCallback && !pCtdi->Closed)
    {
        if (ReceiveFlags&TDI_RECEIVE_ENTIRE_MESSAGE ||
            BytesIndicated==BytesAvailable)
        {
            Status = pCtdi->RecvCallback(pCtdi->Connection.Context,
                                         Tsdu,
                                         BytesIndicated);
            // Data must be used in this call
            ASSERT(Status==NDIS_STATUS_SUCCESS);
            NtStatus = STATUS_SUCCESS;
            *BytesTaken = BytesIndicated;
        }
        else
        {
            // We need an irp to receive all the data.
            PIRP pIrp;
            PUCHAR pBuffer;
            PMDL pMdl = NULL;

            pIrp = IoAllocateIrp(pCtdi->pFileObject->DeviceObject->StackSize, FALSE);
            if(!pIrp)
            {
                WPLOG(LL_A, LM_Res, ("Failed to alloc IRP"));
                gCounters.ulIoAllocateIrpFail++;
                return NtStatus;
            }
            
            pBuffer = MyMemAlloc(BytesAvailable, TAG_CTDI_MESSAGE);
            if(!pBuffer)
            {
                WPLOG(LL_A, LM_Res, ("Failed to alloc breceive buffer"));
            }
            else
            {
                pMdl = IoAllocateMdl(pBuffer, BytesAvailable, FALSE, FALSE, pIrp);
                if (!pMdl)
                {
                    WPLOG(LL_A, LM_Res, ("Failed to alloc MDL"));
                    gCounters.ulIoAllocateMdlFail++;
                }
                else
                {
#if PROBE
                    __try
                    {
                        MmProbeAndLockPages(pMdl, KernelMode, IoReadAccess);
                    }
                    __except (EXCEPTION_EXECUTE_HANDLER)
                    {
                        IoFreeMdl(pMdl);
                        pMdl = NULL;
                    }
#else
                    MmBuildMdlForNonPagedPool(pMdl);
#endif
                }
            }

            if (pMdl)
            {
                TdiBuildReceive(pIrp,
                                pCtdi->pFileObject->DeviceObject,
                                pCtdi->pFileObject,
                                CtdipReceiveCompleteCallback,
                                pCtdi,
                                pMdl,
                                0,
                                BytesAvailable);

                // We're not calling IoCallDriver, so we need to set the proper
                // stack location.
                IoSetNextIrpStackLocation(pIrp);

                *IoRequestPacket = pIrp;

                *BytesTaken = 0;
                NtStatus = STATUS_MORE_PROCESSING_REQUIRED;
            }
            else
            {
                // Some alloc failure occurred, free everything.
                WPLOG(LL_A, LM_Res, ("Failed to alloc memory"));
                NtStatus = STATUS_DATA_NOT_ACCEPTED;
                *BytesTaken = 0;
                if (pBuffer)
                {
                    MyMemFree(pBuffer, BytesAvailable);
                }
                if (pIrp)
                {
                    IoFreeIrp(pIrp);
                }
            }
        }
    }


    DEBUGMSG(DBG_FUNC|DBG_ERR(NtStatus), (DTEXT("-CtdipReceiveCallback %08x\n"), NtStatus));
    return NtStatus;
}

typedef struct {
    TA_IP_ADDRESS       SourceAddress;
    ULONG               Length;
    PVOID               pBuffer;
} RECV_DATAGRAM_CONTEXT, *PRECV_DATAGRAM_CONTEXT;

STATIC NTSTATUS
CtdipReceiveDatagramCompleteCallback(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp,
    IN PVOID Context
    )
{
    PRECV_DATAGRAM_CONTEXT pRecvContext;
    PCTDI_DATA pCtdi = Context;
    NDIS_STATUS Status = (NDIS_STATUS)pIrp->IoStatus.Status;
    PNDIS_BUFFER pNdisBuffer;

    DEBUGMSG(DBG_FUNC, (DTEXT("+CtdipReceiveDatagramCompleteCallback\n")));

    pRecvContext = (PRECV_DATAGRAM_CONTEXT)IoGetCurrentIrpStackLocation(pIrp);

    pNdisBuffer = NdisBufferFromBuffer(pRecvContext->pBuffer);
    ASSERT(MmGetMdlVirtualAddress(pNdisBuffer)==pRecvContext->pBuffer);

    if (pCtdi->RecvDatagramCallback && !pCtdi->Closed && Status==NDIS_STATUS_SUCCESS)
    {
        // We took a reference for the buffer when we created the irp.
        (void)// ToDo: We don't care about the return value?
        pCtdi->RecvDatagramCallback(pCtdi->RecvContext,
                                    (PTRANSPORT_ADDRESS)&pRecvContext->SourceAddress,
                                    pRecvContext->pBuffer,
                                    pRecvContext->Length);

        // The above layer owns the buffer now.
    }
    else
    {
        FreeBufferToPool(&pCtdi->Datagram.RxPool, pRecvContext->pBuffer, TRUE);
        DEREFERENCE_OBJECT_EX(pCtdi, CTDI_REF_RECVDG);
    }


    RELEASE_CONTEXT(pIrp, RECV_DATAGRAM_CONTEXT);
    IoFreeIrp(pIrp);


    DEBUGMSG(DBG_FUNC, (DTEXT("-CtdipReceiveDatagramCompleteCallback\n")));
    return STATUS_MORE_PROCESSING_REQUIRED;
}

NTSTATUS
CtdipReceiveDatagramCallback(
    IN PVOID TdiEventContext,
    IN LONG SourceAddressLength,
    IN PVOID SourceAddress,
    IN LONG OptionsLength,
    IN PVOID Options,
    IN ULONG ReceiveDatagramFlags,
    IN ULONG BytesIndicated,
    IN ULONG BytesAvailable,
    OUT ULONG* BytesTaken,
    IN PVOID Tsdu,
    OUT PIRP* IoRequestPacket )
{
    PUCHAR pBuffer = NULL;
    PNDIS_BUFFER pNdisBuffer;
    PCTDI_DATA pCtdi = TdiEventContext;
    NTSTATUS NtStatus = STATUS_SUCCESS;

    DEBUGMSG(DBG_FUNC, (DTEXT("+CtdipReceiveDatagramCallback\n")));
    if (pCtdi->RecvDatagramCallback==NULL)
    {
        DEBUGMSG(DBG_ERROR, (DTEXT("Datagram received, no handler registered.  Drop it\n")));
        WPLOG(LL_A, LM_TDI, ("Datagram received, no handler registered.  Drop it"));
        NtStatus = STATUS_DATA_NOT_ACCEPTED;
        goto crdcDone;
    }

    pBuffer = GetBufferFromPool(&pCtdi->Datagram.RxPool);
    if (!pBuffer)
    {
        DEBUGMSG(DBG_ERROR, (DTEXT("No buffers, dropping datagram\n")));
        WPLOG(LL_A, LM_TDI, ("No buffers, dropping datagram"));
        NtStatus = STATUS_DATA_NOT_ACCEPTED;
        goto crdcDone;
    }

    pNdisBuffer = NdisBufferFromBuffer(pBuffer);

    if (pCtdi->RecvDatagramCallback && !pCtdi->Closed)
    {
        if (BytesAvailable>PPTP_MAX_RECEIVE_SIZE)
        {
            DEBUGMSG(DBG_ERROR, (DTEXT("WAY too many bytes received. %d\n"), BytesAvailable));
            WPLOG(LL_A, LM_TDI, ("WAY too many bytes received. %d", BytesAvailable));
            NtStatus = STATUS_DATA_NOT_ACCEPTED;
            ASSERT(BytesAvailable<PPTP_MAX_RECEIVE_SIZE);
        }
        else if (ReceiveDatagramFlags&TDI_RECEIVE_ENTIRE_MESSAGE ||
                 BytesAvailable==BytesIndicated)
        {
            ULONG BytesCopied;

            // Let's just do a copy here.
            TdiCopyBufferToMdl(Tsdu,
                               0,
                               BytesIndicated,
                               pNdisBuffer,
                               0,
                               &BytesCopied);

            ASSERT(BytesCopied==BytesIndicated);

            REFERENCE_OBJECT_EX(pCtdi, CTDI_REF_RECVDG);  // pair in CtdiReceiveComplete
            (void)// ToDo: We don't care about the return value?
            pCtdi->RecvDatagramCallback(pCtdi->RecvContext,
                                        SourceAddress,
                                        pBuffer,
                                        BytesIndicated);

            // We've handed the buffer to the layer above.  Clear the var so we don't
            // free it when we leave here.
            pBuffer = NULL;
            *BytesTaken = BytesIndicated;
        }
        else
        {
            PRECV_DATAGRAM_CONTEXT pContext;
            PIRP pIrp = IoAllocateIrp((CCHAR)(pCtdi->pFileObject->DeviceObject->StackSize +
                                              NUM_STACKS_FOR_CONTEXT(sizeof(RECV_DATAGRAM_CONTEXT))),
                                      FALSE);

            if (!pIrp)
            {
                WPLOG(LL_A, LM_Res, ("Failed to alloc IRP"));
                NtStatus = STATUS_DATA_NOT_ACCEPTED;
                gCounters.ulIoAllocateIrpFail++;
            }
            else
            {
                pContext = GET_CONTEXT(pIrp, RECV_DATAGRAM_CONTEXT);

                pContext->SourceAddress = *(PTA_IP_ADDRESS)SourceAddress;
                pContext->Length        = BytesAvailable;
                pContext->pBuffer       = pBuffer;

                TdiBuildReceiveDatagram(pIrp,
                                        pCtdi->pFileObject->DeviceObject,
                                        pCtdi->pFileObject,
                                        CtdipReceiveDatagramCompleteCallback,
                                        pCtdi,
                                        pNdisBuffer,
                                        PPTP_MAX_RECEIVE_SIZE,
                                        NULL,
                                        NULL,
                                        0);

                IoSetNextIrpStackLocation(pIrp);  // Required by TDI
                *BytesTaken = 0;
                *IoRequestPacket = pIrp;
                NtStatus = STATUS_MORE_PROCESSING_REQUIRED;
                pBuffer = NULL; // to keep us from freeing it here.
                REFERENCE_OBJECT_EX(pCtdi, CTDI_REF_RECVDG);  // pair in CtdipReceiveDatagramCompleteCallback
            }
        }
    }
    else
    {
        NtStatus = STATUS_DATA_NOT_ACCEPTED;
    }

crdcDone:
    if (pBuffer)
    {
        FreeBufferToPool(&pCtdi->Datagram.RxPool, pBuffer, TRUE);
    }
    DEBUGMSG(DBG_FUNC, (DTEXT("-CtdipReceiveDatagramCallback %08x\n"), NtStatus));
    return NtStatus;
}


STATIC NTSTATUS
CtdipSendCallback(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp,
    IN PVOID Context
    )
{
    PCTDI_DATA pCtdi = Context;
    PVOID pData = NULL;
    NDIS_STATUS Status = (NDIS_STATUS)pIrp->IoStatus.Status;
    PCTDI_SEND_CONTEXT pSendContext;
    CTDI_EVENT_SEND_COMPLETE pSendCompleteCallback;
    PVOID CtdiContext;

    DEBUGMSG(DBG_FUNC, (DTEXT("+CtdipSendCallback %08x\n"), Status));

    pSendContext = (PCTDI_SEND_CONTEXT)IoGetCurrentIrpStackLocation(pIrp);
    CtdiContext = pSendContext->Context;
    pSendCompleteCallback = pSendContext->pSendCompleteCallback;

    // ToDo: take action if the irp returns failure.
    if (!pIrp->MdlAddress)
    {
        DEBUGMSG(DBG_WARN, (DTEXT("MdlAddress NULL\n")));
        WPLOG(LL_A, LM_TDI, ("pIrp %p MdlAddress NULL", pIrp));
    }
    else
    {
        ASSERT(pIrp->MdlAddress->Next == NULL);
        pData = MmGetMdlVirtualAddress(pIrp->MdlAddress);
#if PROBE
        MmUnlockPages(pIrp->MdlAddress);
#endif
        IoFreeMdl(pIrp->MdlAddress);
    }
    RELEASE_CONTEXT(pIrp, CTDI_SEND_CONTEXT);
    IoFreeIrp(pIrp);

    pSendCompleteCallback(CtdiContext, NULL, pData, Status);

    DEREFERENCE_OBJECT_EX(pCtdi, CTDI_REF_SEND);  // Pair in CtdiSend
    DEBUGMSG(DBG_FUNC, (DTEXT("-CtdipSendCallback\n")));
    return STATUS_MORE_PROCESSING_REQUIRED;
}

STATIC NTSTATUS
CtdipSendDatagramCallback(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp,
    IN PVOID Context
    )
{
    PCTDI_DATA pCtdi = Context;
    PVOID pData = NULL;
    NDIS_STATUS Status = (NDIS_STATUS)pIrp->IoStatus.Status;
    PCTDI_SEND_DATAGRAM_CONTEXT pSendContext;
    CTDI_EVENT_SEND_COMPLETE pSendCompleteCallback;
    PVOID CtdiContext, DatagramContext;

    DEBUGMSG(DBG_FUNC, (DTEXT("+CtdipSendDatagramCallback %08x\n"), Status));

    pSendContext = (PCTDI_SEND_DATAGRAM_CONTEXT)IoGetCurrentIrpStackLocation(pIrp);
    CtdiContext = pSendContext->Context;
    DatagramContext = pSendContext->DatagramContext;
    pSendCompleteCallback = pSendContext->pSendCompleteCallback;

    // ToDo: take action if the irp returns failure.
    if (!pIrp->MdlAddress)
    {
        DEBUGMSG(DBG_WARN, (DTEXT("MdlAddress NULL\n")));
        WPLOG(LL_A, LM_TDI, ("pIrp %p MdlAddress NULL", pIrp));
    }
    else
    {
        ASSERT(pIrp->MdlAddress->Next == NULL);
        pData = MmGetMdlVirtualAddress(pIrp->MdlAddress);
#if PROBE
        MmUnlockPages(pIrp->MdlAddress);
#endif
        IoFreeMdl(pIrp->MdlAddress);
    }
    RELEASE_CONTEXT(pIrp, CTDI_SEND_DATAGRAM_CONTEXT);
    IoFreeIrp(pIrp);

    if (pSendCompleteCallback)
    {
        pSendCompleteCallback(CtdiContext, DatagramContext, pData, Status);
    }
    else
    {
        ASSERT(!"No SendCompleteHandler for datagram");
    }

    DEREFERENCE_OBJECT_EX(pCtdi, CTDI_REF_SENDDG);  // Pair in CtdiSendDatagram
    DEBUGMSG(DBG_FUNC, (DTEXT("-CtdipSendDatagramCallback\n")));
    return STATUS_MORE_PROCESSING_REQUIRED;
}

/** public functions **/

NDIS_STATUS
CtdiInitialize(
    IN      ULONG                       ulFlags
    )
{
    TA_IP_ADDRESS Local;
    UNICODE_STRING DeviceName;
    NTSTATUS Status = STATUS_SUCCESS;
    DEBUGMSG(DBG_FUNC|DBG_TDI, (DTEXT("+CtdiInitialize\n")));

    if( fCtdiInitialized ){
        goto ciDone;
    }

    InitializeListHead(&CtdiList);
    InitializeListHead(&CtdiFreeList);
    InitializeListHead(&CtdiRouteList);
//    InitializeListHead(&CtdiRouteNotifyList);
    NdisAllocateSpinLock(&CtdiListLock);
    
    fCtdiInitialized = TRUE;

    if (ulFlags&CTDI_FLAG_NETWORK_HEADER)
    {
        CtdiMdlFlags |= MDL_NETWORK_HEADER;
    }

    if (ulFlags&CTDI_FLAG_ENABLE_ROUTING)
    {
        NdisZeroMemory(&Local, sizeof(Local));

        Local.TAAddressCount = 1;
        Local.Address[0].AddressLength = TDI_ADDRESS_LENGTH_IP;
        Local.Address[0].AddressType = TDI_ADDRESS_TYPE_IP;
        Local.Address[0].Address[0].sin_port = 0;
        Local.Address[0].Address[0].in_addr = 0;

        RtlInitUnicodeString(&DeviceName, DD_TCP_DEVICE_NAME);

        Status = CtdipOpenProtocol(&DeviceName,
                                   (PTRANSPORT_ADDRESS)&Local,
                                   &hTcp,
                                   &pFileTcp);

        if (Status!=STATUS_SUCCESS)
        {
            goto ciDone;
        }
        RtlInitUnicodeString(&DeviceName, DD_IP_DEVICE_NAME);

        Status = CtdipOpenProtocol(&DeviceName,
                                   (PTRANSPORT_ADDRESS)&Local,
                                   &hIp,
                                   &pFileIp);

        if (Status!=STATUS_SUCCESS)
        {
            goto ciDone;
        }

    }

ciDone:
    if (Status!=STATUS_SUCCESS)
    {
        if (hTcp)
        {
            CtdipCloseProtocol(hTcp, pFileTcp);
            hTcp = 0;
            pFileTcp = NULL;
        }
        if (hIp)
        {
            CtdipCloseProtocol(hIp, pFileIp);
            hIp = 0;
            pFileIp = NULL;
        }
        NdisFreeSpinLock(&CtdiListLock);
        fCtdiInitialized = FALSE;
    }
    DEBUGMSG(DBG_FUNC|DBG_ERR(Status), (DTEXT("-CtdiInitialize %08x\n"), Status));
    return (NDIS_STATUS)Status;
}

VOID
CtdiShutdown(
    )
{
    HANDLE h;
    PFILE_OBJECT pFile;
    UINT i;

    DEBUGMSG(DBG_FUNC|DBG_TDI, (DTEXT("+CtdiShutdown\n")));
    if (fCtdiInitialized)
    {
        fCtdiInitialized = FALSE;
        NdisMSleep(30000);
        // Allow code using these handles on other processors to complete
        // before we close them.
        if (hIp || pFileIp)
        {
            h = hIp;
            hIp = 0;
            pFile = pFileIp;
            pFileIp = NULL;
            CtdipCloseProtocol(h, pFile);
        }
        if (hTcp || pFileTcp)
        {
            h = hTcp;
            hTcp = 0;
            pFile = pFileTcp;
            pFileTcp = NULL;
            CtdipCloseProtocol(h, pFile);
        }
        // Some irps seem very slow to be cancelled by TCP.
        for (i=0; i<300; i++)
        {
            if (IsListEmpty(&CtdiList) &&
                IsListEmpty(&CtdiRouteList) &&
//                IsListEmpty(&CtdiRouteNotifyList) &&
                IsListEmpty(&CtdiFreeList))
            {
                break;
            }
            NdisMSleep(10000);
            // Small window to allow irps to complete after closing their handles.
        }
        ASSERT(IsListEmpty(&CtdiList));
        ASSERT(IsListEmpty(&CtdiRouteList));
//        ASSERT(IsListEmpty(&CtdiRouteNotifyList));
        NdisFreeSpinLock(&CtdiListLock);
    }

    DEBUGMSG(DBG_FUNC, (DTEXT("-CtdiShutdown\n")));
}

NDIS_STATUS
CtdiClose(
    IN      HANDLE                      hCtdi
    )
{
    PCTDI_DATA pCtdi = (PCTDI_DATA)hCtdi;

    DEBUGMSG(DBG_FUNC, (DTEXT("+CtdiClose\n")));

    if (!IS_CTDI(pCtdi))
    {
        return NDIS_STATUS_SUCCESS;
    }

    WPLOG(LL_I, LM_TDI, ("pCtdi %p", pCtdi));

    NdisAcquireSpinLock(&pCtdi->Lock);
    if (!pCtdi->Closed)
    {
        pCtdi->Closed = TRUE;
        switch (pCtdi->Type)
        {
            case CTDI_ENDPOINT:
            case CTDI_CONNECTION:
            {
                break;
            }
            case CTDI_LISTEN:
            {
                while (!IsListEmpty(&pCtdi->Listen.ConnectList))
                {
                    PLIST_ENTRY pListEntry;
                    PCTDI_DATA pConnect;
                    PIRP pIrp;

                    pListEntry = RemoveHeadList(&pCtdi->Listen.ConnectList);
                    pConnect = CONTAINING_RECORD(pListEntry,
                                                 CTDI_DATA,
                                                 Connection.ListEntry);

                    NdisReleaseSpinLock(&pCtdi->Lock);

                    // these derefs are for the double references placed when these are placed on
                    // the list
                    DEREFERENCE_OBJECT_EX(pCtdi, CTDI_REF_LIST);
                    DEREFERENCE_OBJECT_EX(pConnect, CTDI_REF_LIST);

                    pIrp = IoAllocateIrp(pConnect->pFileObject->DeviceObject->StackSize, FALSE);
                    if (pIrp)
                    {
                        // Normally we would take a reference to pConnect for this irp, but
                        // these handles won't be getting a close from above, which means they
                        // are in need of one extra dereference.

                        SET_DBGFLAG(pConnect, CTDI_F_BUILD_DISASSOC);

                        TdiBuildDisassociateAddress(pIrp,
                                                    pConnect->pFileObject->DeviceObject,
                                                    pConnect->pFileObject,
                                                    CtdipDisassociateAddressCallback,
                                                    pConnect);
                        DEBUGMSG(DBG_TDI, (DTEXT("IoCallDriver TDI_DISASSOCIATE_ADDRESS\n")));

                        // Completion handler always called, don't care on return value.
                        (void)IoCallDriver(pConnect->pFileObject->DeviceObject, pIrp);
                    }
                    else
                    {
                        WPLOG(LL_A, LM_TDI, ("Failed to alloc IRP"));
                        gCounters.ulIoAllocateIrpFail++;
                        DEREFERENCE_OBJECT_EX(pConnect, CTDI_REF_DISASSO);
                        DEREFERENCE_OBJECT_EX(pCtdi, CTDI_REF_ADDRREF);     // Pair in CtdipAddListenConnection
                    }
                    NdisAcquireSpinLock(&pCtdi->Lock);

                }

                CtlpCleanupCtls(pgAdapter);
                break;
            }
            default:
                break;
        }
        NdisReleaseSpinLock(&pCtdi->Lock);
        DEREFERENCE_OBJECT_EX(pCtdi, CTDI_REF_INITIAL);  // This derefs the initial reference
    }
    else
    {
        NdisReleaseSpinLock(&pCtdi->Lock);
    }

    DEBUGMSG(DBG_FUNC, (DTEXT("-CtdiClose\n")));
    return NDIS_STATUS_SUCCESS;
}

NDIS_STATUS
CtdiListen(
    IN      HANDLE                      hCtdi,
    IN      ULONG_PTR                   NumListen,
    IN      CTDI_EVENT_CONNECT_QUERY    pConnectQueryHandler,
    IN      CTDI_EVENT_RECEIVE          pReceiveHandler,
    IN      CTDI_EVENT_DISCONNECT       pDisconnectHandler,
    IN      PVOID                       pContext
    )
{
    UINT i;
    NDIS_STATUS ReturnStatus = NDIS_STATUS_SUCCESS;
    PCTDI_DATA pCtdi = (PCTDI_DATA)hCtdi;
    BOOLEAN Reference = FALSE;

    DEBUGMSG(DBG_FUNC, (DTEXT("+CtdiListen\n")));

    if (!IS_CTDI(pCtdi))
    {
        DEBUGMSG(DBG_ERROR, (DTEXT("Ctdi: Bad handle %p\n"), pCtdi));
        WPLOG(LL_A, LM_TDI, ("Ctdi: Bad handle %p", pCtdi));
        ReturnStatus = NDIS_STATUS_FAILURE;
        goto clDone;
    }

    NdisAcquireSpinLock(&pCtdi->Lock);

    pCtdi->Type = CTDI_LISTEN;
    pCtdi->Listen.Context = pContext;

    pCtdi->RecvCallback = pReceiveHandler;
    pCtdi->ConnectQueryCallback = pConnectQueryHandler;
    pCtdi->DisconnectCallback = pDisconnectHandler;

    InitializeListHead(&pCtdi->Listen.ConnectList);

    REFERENCE_OBJECT_EX(pCtdi, CTDI_REF_INLISTEN);  // Pair in this func.
    Reference = TRUE;
    NdisReleaseSpinLock(&pCtdi->Lock);


    for (i=0; i<NumListen; i++)
    {
        ReturnStatus = CtdipAddListenConnection(pCtdi);
        if (ReturnStatus!=NDIS_STATUS_SUCCESS)
        {
            goto clDone;
        }
    }

    ReturnStatus = CtdipSetEventHandler(pCtdi,
                                        TDI_EVENT_CONNECT,
                                        CtdipConnectCallback);
    if (ReturnStatus!=NDIS_STATUS_SUCCESS)
    {
        DEBUGMSG(DBG_ERROR, (DTEXT("CtdiSetEventHandler TDI_EVENT_CONNECT failed\n")));
        WPLOG(LL_A, LM_TDI, ("CtdiSetEventHandler TDI_EVENT_CONNECT failed"));
        goto clDone;
    }

    ReturnStatus = CtdipSetEventHandler(pCtdi,
                                        TDI_EVENT_RECEIVE,
                                        CtdipReceiveCallback);
    if (ReturnStatus!=NDIS_STATUS_SUCCESS)
    {
        DEBUGMSG(DBG_ERROR, (DTEXT("CtdiSetEventHandler TDI_EVENT_RECEIVE failed\n")));
        WPLOG(LL_A, LM_TDI, ("CtdiSetEventHandler TDI_EVENT_RECEIVE failed"));
        goto clDone;
    }

    ReturnStatus = CtdipSetEventHandler(pCtdi,
                                        TDI_EVENT_DISCONNECT,
                                        CtdipDisconnectCallback);
    if (ReturnStatus!=NDIS_STATUS_SUCCESS)
    {
        DEBUGMSG(DBG_ERROR, (DTEXT("CtdiSetEventHandler TDI_EVENT_DISCONNECT failed\n")));
        WPLOG(LL_A, LM_TDI, ("CtdiSetEventHandler TDI_EVENT_DISCONNECT failed"));
        goto clDone;
    }

clDone:
    if (Reference)
    {
        DEREFERENCE_OBJECT_EX(pCtdi, CTDI_REF_INLISTEN);  // Pair in this func.
    }
    if (ReturnStatus!=NDIS_STATUS_SUCCESS)
    {
        // ToDo: cleanup on failure.
        // Figure out how to undo address association, if necessary.
    }

    DEBUGMSG(DBG_FUNC|DBG_ERR(ReturnStatus), (DTEXT("-CtdiListen %08x\n"), ReturnStatus));
    return ReturnStatus;
}

NDIS_STATUS
CtdiConnect(
    IN      HANDLE                      hCtdi,
    IN      PTRANSPORT_ADDRESS          pAddress,
    IN      CTDI_EVENT_CONNECT_COMPLETE pConnectCompleteHandler,
    IN      CTDI_EVENT_RECEIVE          pReceiveHandler,
    IN      CTDI_EVENT_DISCONNECT       pDisconnectHandler,
    IN      PVOID                       pContext
    )
{
    UNICODE_STRING DeviceName;
    OBJECT_ATTRIBUTES ObjectAttributes;
    NDIS_STATUS ReturnStatus = NDIS_STATUS_SUCCESS;
    NTSTATUS NtStatus;
    PTIME pTimeout = NULL;
    PIRP pIrp = NULL;
    IO_STATUS_BLOCK IoStatusBlock;
    PCTDI_DATA pEndpoint = (PCTDI_DATA)hCtdi;
    PCTDI_DATA pConnect = NULL;
    PTDI_CONNECTION_INFORMATION pRequestInfo = NULL;
    PTDI_CONNECTION_INFORMATION pReturnInfo = NULL;
    PTA_IP_ADDRESS pRemoteAddress;
    PBOOLEAN pInboundFlag;
    BOOLEAN CloseConnection = FALSE;

    UCHAR EaBuffer[sizeof(FILE_FULL_EA_INFORMATION) +
                   TDI_CONNECTION_CONTEXT_LENGTH +
                   sizeof(PVOID)];
    PFILE_FULL_EA_INFORMATION pEa = (PFILE_FULL_EA_INFORMATION)EaBuffer;
    PVOID *ppContext = (PVOID*)(pEa->EaName + TDI_CONNECTION_CONTEXT_LENGTH + 1);

    DEBUGMSG(DBG_FUNC, (DTEXT("+CtdiConnect\n")));

    ASSERT(KeGetCurrentIrql()<DISPATCH_LEVEL);

    if (!IS_CTDI(pEndpoint))
    {
        DEBUGMSG(DBG_ERROR, (DTEXT("Ctdi: Bad handle %p\n"), pEndpoint));
        WPLOG(LL_A, LM_TDI, ("Ctdi: Bad handle %p", pEndpoint));
        ReturnStatus = NDIS_STATUS_FAILURE;
        goto ccDone;
    }

    pConnect = CtdipDataAlloc();
    if (!pConnect)
    {
        return NDIS_STATUS_RESOURCES;
    }

    pConnect->Type = CTDI_CONNECTION;
    pConnect->Connection.Context = pContext;
    pConnect->Connection.LocalEndpoint = pEndpoint;
    pConnect->ConnectCompleteCallback = pConnectCompleteHandler;
    pConnect->RecvCallback = pReceiveHandler;
    pConnect->DisconnectCallback = pDisconnectHandler;

    DeviceName.Length = sizeof(DD_TCP_DEVICE_NAME) - sizeof(WCHAR);
    DeviceName.Buffer = DD_TCP_DEVICE_NAME;

    InitializeObjectAttributes(&ObjectAttributes,
                               &DeviceName,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    NdisZeroMemory(pEa, sizeof(EaBuffer));
    pEa->EaNameLength = TDI_CONNECTION_CONTEXT_LENGTH;
    pEa->EaValueLength = sizeof(PVOID);
    NdisMoveMemory(pEa->EaName, TdiConnectionContext, TDI_CONNECTION_CONTEXT_LENGTH);

    *ppContext = pConnect;

    NdisZeroMemory(&IoStatusBlock, sizeof(IoStatusBlock));

    NtStatus =
        ZwCreateFile(&pConnect->hFile,                 /* FileHandle */
                     FILE_READ_DATA | FILE_WRITE_DATA, /* Desired Access */
                     &ObjectAttributes,                /* Object Attributes */
                     &IoStatusBlock,                   /* IO Status Block */
                     NULL,                             /* Allocation Size */
                     FILE_ATTRIBUTE_NORMAL,            /* File Attributes */
                     0,                                /* Share Access */
                     FILE_OPEN,                        /* Create Disposition */
                     0,                                /* Create Options */
                     pEa,                              /* EaBuffer */
                     sizeof(EaBuffer)                  /* EaLength */
                     );

    if (NtStatus!=STATUS_SUCCESS)
    {
        WPLOG(LL_A, LM_TDI, ("ZwCreateFile failed %08x", NtStatus));
        ReturnStatus = NtStatus;
        goto ccDone;
    }

    // Convert the address file handle to a FILE_OBJECT

    NtStatus =
        ObReferenceObjectByHandle(pConnect->hFile,            /* Handle */
                                  0,                          /* DesiredAccess */
                                  NULL,                       /* ObjectType */
                                  KernelMode,                 /* AccessMode */
                                  &pConnect->pFileObject,     /* Object */
                                  NULL                        /* HandleInfo */
                                  );


    if (NtStatus != STATUS_SUCCESS)
    {
        WPLOG(LL_A, LM_TDI, ("ObReferenceObjectByHandle failed %08x", NtStatus));
        ReturnStatus = NtStatus;
        goto ccDone;
    }

    // Make an irp to associate the endpoint and connection.
    pIrp = IoAllocateIrp(pConnect->pFileObject->DeviceObject->StackSize, FALSE);
    if (!pIrp)
    {
        WPLOG(LL_A, LM_Res, ("Failed to alloc IRP"));
        gCounters.ulIoAllocateIrpFail++;
        ReturnStatus = NDIS_STATUS_RESOURCES;
        goto ccDone;
    }

    REFERENCE_OBJECT_EX(pConnect, CTDI_REF_ASSOADDR);  // Pair in CtdipAssociateAddressCallback
    TdiBuildAssociateAddress(pIrp,
                             pConnect->pFileObject->DeviceObject,
                             pConnect->pFileObject,
                             CtdipAssociateAddressCallback,
                             pConnect,
                             pEndpoint->hFile);
    // Associate address creates a reference from the connection to the endpoint.
    REFERENCE_OBJECT_EX(pEndpoint, CTDI_REF_ADDRREF);  // Pair in CtdipDisassociateAddressCallback

    DEBUGMSG(DBG_TDI, (DTEXT("IoCallDriver TDI_ASSOCIATE_ADDRESS\n")));

    // Completion handler always called, don't care on return value.
    (void)IoCallDriver(pConnect->pFileObject->DeviceObject, pIrp);


    ReturnStatus = CtdipSetEventHandler(pEndpoint,
                                        TDI_EVENT_RECEIVE,
                                        CtdipReceiveCallback);
    if (ReturnStatus!=NDIS_STATUS_SUCCESS)
    {
        DEBUGMSG(DBG_ERROR, (DTEXT("CtdiSetEventHandler TDI_EVENT_RECEIVE failed\n")));
        WPLOG(LL_A, LM_TDI, ("CtdiSetEventHandler TDI_EVENT_RECEIVE failed"));
        goto ccDone;
    }

    ReturnStatus = CtdipSetEventHandler(pEndpoint,
                                        TDI_EVENT_DISCONNECT,
                                        CtdipDisconnectCallback);
    if (ReturnStatus!=NDIS_STATUS_SUCCESS)
    {
        DEBUGMSG(DBG_ERROR, (DTEXT("CtdiSetEventHandler TDI_EVENT_DISCONNECT failed\n")));
        WPLOG(LL_A, LM_TDI, ("CtdiSetEventHandler TDI_EVENT_DISCONNECT failed"));
        goto ccDone;
    }

    // Make an irp to establish the connection
    pIrp = IoAllocateIrp(pConnect->pFileObject->DeviceObject->StackSize, FALSE);
    if(!pIrp)
    {
        WPLOG(LL_A, LM_Res, ("Failed to alloc IRP"));
        gCounters.ulIoAllocateIrpFail++;
        ReturnStatus = NDIS_STATUS_RESOURCES;
        goto ccDone;
    }

    // No sign saying we can't allocate the request info, return info and address buffers
    // in one shot.
    pRequestInfo = MyMemAlloc(2*(sizeof(TDI_CONNECTION_INFORMATION)+
                                 sizeof(TA_IP_ADDRESS)) +
                              3*sizeof(PVOID) + sizeof(BOOLEAN),
                              TAG_CTDI_CONNECT_INFO);
    if (!pRequestInfo)
    {
        WPLOG(LL_A, LM_Res, ("Failed to alloc memory"));
        IoFreeIrp(pIrp);
        pIrp = NULL;
        ReturnStatus = NDIS_STATUS_RESOURCES;
        goto ccDone;
    }

    NdisZeroMemory(pRequestInfo,
                   2*(sizeof(TDI_CONNECTION_INFORMATION)+sizeof(TA_IP_ADDRESS))
                   + sizeof(BOOLEAN) + 3*sizeof(PVOID));

    pConnect->Connection.ConnectInfo = pRequestInfo;

    pRequestInfo->RemoteAddressLength = sizeof(TA_IP_ADDRESS);

    pRemoteAddress = 
        (PTA_IP_ADDRESS)((PUCHAR)(pRequestInfo + 1) + sizeof(PVOID));
    
    (ULONG_PTR)pRemoteAddress &=
        ~((ULONG_PTR)sizeof(PVOID) - 1);

    pRequestInfo->RemoteAddress = pRemoteAddress;

    *pRemoteAddress = *(PTA_IP_ADDRESS)pAddress;

    pReturnInfo = 
        (PTDI_CONNECTION_INFORMATION)
        ((PUCHAR)(pRemoteAddress + 1) + sizeof(PVOID));

    (ULONG_PTR)pReturnInfo &=
        ~((ULONG_PTR)sizeof(PVOID) - 1);

    pReturnInfo->RemoteAddressLength = sizeof(TA_IP_ADDRESS);

    pRemoteAddress = 
        (PTA_IP_ADDRESS)((PUCHAR)(pReturnInfo + 1) + sizeof(PVOID));

    (ULONG_PTR)pRemoteAddress &=
        ~((ULONG_PTR)sizeof(PVOID) - 1);

    pReturnInfo->RemoteAddress = pRemoteAddress;

    pInboundFlag = (PBOOLEAN)(pRemoteAddress + 1);
    *pInboundFlag = FALSE;

    pRemoteAddress->TAAddressCount = 1;
    pRemoteAddress->Address[0].AddressLength = TDI_ADDRESS_LENGTH_IP;
    pRemoteAddress->Address[0].AddressType = TDI_ADDRESS_TYPE_IP;

    REFERENCE_OBJECT_EX(pConnect, CTDI_REF_CONNECT);  // Pair in CtdipConnectCompleteCallback
    TdiBuildConnect(pIrp,
                    pConnect->pFileObject->DeviceObject,
                    pConnect->pFileObject,
                    CtdipConnectCompleteCallback,
                    pConnect,
                    NULL,                   // ToDo: allow them to specify timeout
                    pRequestInfo,
                    pReturnInfo);

    DEBUGMSG(DBG_TDI, (DTEXT("IoCallDriver TDI_CONNECT\n")));

    // Completion handler always called, don't care on return value.
    (void)IoCallDriver(pConnect->pFileObject->DeviceObject, pIrp);
    ReturnStatus = STATUS_PENDING;

    NdisInterlockedIncrement(&gCounters.OutboundConnectAttempts);

ccDone:;
    if (!NT_SUCCESS(ReturnStatus))
    {
        if(pConnectCompleteHandler)
        {
            pConnectCompleteHandler(pContext, 0, ReturnStatus);
            ReturnStatus = NDIS_STATUS_PENDING;
        }
        CtdiDisconnect(pConnect, TRUE);
        CtdiClose(pConnect);
    }
    DEBUGMSG(DBG_FUNC|DBG_ERR(ReturnStatus), (DTEXT("-CtdiConnect %08x\n"), ReturnStatus));
    return ReturnStatus;
}

NDIS_STATUS
CtdiDisconnect(
    IN      HANDLE                      hCtdi,
    IN      BOOLEAN                     Abort
    )
{
    PCTDI_DATA pCtdi = (PCTDI_DATA)hCtdi;
    NDIS_STATUS Status;
    PIRP pIrp = NULL;
    PTIME pTimeout;
    PTDI_CONNECTION_INFORMATION pConnectInfo;
    BOOLEAN Disconnected = FALSE;

    DEBUGMSG(DBG_FUNC, (DTEXT("+CtdiDisconnect\n")));

    if (!IS_CTDI(pCtdi))
    {
        Status = NDIS_STATUS_SUCCESS;
        goto cdDone;
    }

    SET_DBGFLAG(pCtdi, CTDI_F_DISCONNECT);

    NdisAcquireSpinLock(&pCtdi->Lock);
    if ((Abort && pCtdi->Connection.Abort) ||
        (!Abort && pCtdi->Connection.Disconnect))
    {
        // Already disconnecting, bail out.
        NdisReleaseSpinLock(&pCtdi->Lock);
        Status = NDIS_STATUS_SUCCESS;
        goto cdDone;
    }
    if (Abort)
    {
        pCtdi->Connection.Abort = TRUE;
    }
    pCtdi->Connection.Disconnect = TRUE;
    pCtdi->Connection.DisconnectCount++;
    if (pCtdi->pFileObject)
    {
        pIrp = IoAllocateIrp((CCHAR)(pCtdi->pFileObject->DeviceObject->StackSize +
                                     NUM_STACKS_FOR_CONTEXT(sizeof(TIME)+sizeof(TDI_CONNECTION_INFORMATION))),
                             FALSE);
    }
    NdisReleaseSpinLock(&pCtdi->Lock);

    if (!pIrp)
    {
        WPLOG(LL_A, LM_Res, ("Failed to alloc IRP"));
        gCounters.ulIoAllocateIrpFail++;
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto cdDone;
    }

    pTimeout = (PTIME)GetContextArea(pIrp, sizeof(TIME)+sizeof(TDI_CONNECTION_INFORMATION));
    pConnectInfo = (PTDI_CONNECTION_INFORMATION)(pTimeout + 1);

    pTimeout->LowPart = CtdiTcpDisconnectTimeout * -10000000L;
    pTimeout->HighPart = (pTimeout->LowPart) ? -1 : 0;

    // Responding to a controlled disconnect, we don't provide
    // TDI_CONNECTION_INFORMATION, but we request it from the peer.

    SET_DBGFLAG(pCtdi, CTDI_F_BUILD_DISCONNECT_2);

    REFERENCE_OBJECT_EX(pCtdi, CTDI_REF_DISCONNECT);  // Pair in CtdipDisconnectCompleteCallback
    TdiBuildDisconnect(pIrp,
                       pCtdi->pFileObject->DeviceObject,
                       pCtdi->pFileObject,
                       CtdipDisconnectCompleteCallback,
                       pCtdi,
                       pTimeout,
                       (Abort ? TDI_DISCONNECT_ABORT : TDI_DISCONNECT_RELEASE),
                       NULL,
                       pConnectInfo);


    // Completion handler always called, don't care on return value.
    (void)IoCallDriver(pCtdi->pFileObject->DeviceObject, pIrp);

    Status = NDIS_STATUS_SUCCESS;

cdDone:
    if (!NT_SUCCESS(Status))
    {
        if (pIrp)
        {
            IoFreeIrp(pIrp);
        }
    }
    DEBUGMSG(DBG_FUNC|DBG_ERR(Status), (DTEXT("-CtdiDisconnect %08x\n"), Status));
    return Status;
}

NDIS_STATUS
CtdiReceiveComplete(
    IN      HANDLE                      hCtdi,
    IN      PUCHAR                      pBuffer
    )
{
    PCTDI_DATA pCtdi = (PCTDI_DATA)hCtdi;
    DEBUGMSG(DBG_FUNC, (DTEXT("+CtdiReceiveComplete\n")));
    FreeBufferToPool(&pCtdi->Datagram.RxPool, pBuffer, TRUE);
    DEREFERENCE_OBJECT_EX(pCtdi, CTDI_REF_RECVDG);  // Pair in CtdiReceiveComplete
    DEBUGMSG(DBG_FUNC, (DTEXT("-CtdiReceiveComplete\n")));
    return NDIS_STATUS_SUCCESS;
}

NDIS_STATUS
CtdiSend(
    IN      HANDLE                      hCtdi,
    IN      CTDI_EVENT_SEND_COMPLETE    pSendCompleteHandler,
    IN      PVOID                       pContext,
    IN      PVOID                       pvBuffer,
    IN      ULONG                       ulLength
    )
// We require that pBuffer not be temporary storage, as we will use it to send
// the data in an async call.
{
    PCTDI_DATA pCtdi = (PCTDI_DATA)hCtdi;
    NDIS_STATUS Status = NDIS_STATUS_SUCCESS;
    PIRP pIrp = NULL;
    PMDL pMdl = NULL;
    PUCHAR pBuffer = pvBuffer;
    PCTDI_SEND_CONTEXT pSendContext;

    DEBUGMSG(DBG_FUNC, (DTEXT("+CtdiSend\n")));
    if (!IS_CTDI(pCtdi))
    {
        DEBUGMSG(DBG_ERROR, (DTEXT("Ctdi: Bad handle %p\n"), pCtdi));
        WPLOG(LL_A, LM_TDI, ("Ctdi: Bad handle %p", pCtdi));
        Status = NDIS_STATUS_FAILURE;
        goto csDone;
    }

    // Allocate one extra stack location for context data.
    pIrp = IoAllocateIrp((CCHAR)(pCtdi->pFileObject->DeviceObject->StackSize +
                                 NUM_STACKS_FOR_CONTEXT(sizeof(CTDI_SEND_CONTEXT))), FALSE);
    if (!pIrp)
    {
        WPLOG(LL_A, LM_TDI, ("Failed to alloc IRP"));
        gCounters.ulIoAllocateIrpFail++;
        Status = NDIS_STATUS_RESOURCES;
        goto csDone;
    }
                                 
    pMdl = IoAllocateMdl(pBuffer,
                         ulLength,
                         FALSE,
                         FALSE,
                         pIrp);

    if (!pMdl)
    {
        WPLOG(LL_A, LM_TDI, ("Failed to alloc MDL"));
        gCounters.ulIoAllocateMdlFail++;
        Status = NDIS_STATUS_RESOURCES;
        goto csDone;
    }

#if PROBE
    __try
    {
        MmProbeAndLockPages(pMdl, KernelMode, IoReadAccess);
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        IoFreeMdl(pMdl);
        pMdl = NULL;
    }
#else
    MmBuildMdlForNonPagedPool(pMdl);
#endif

    // Get the first stack location for our own context use
    pSendContext = GET_CONTEXT(pIrp, CTDI_SEND_CONTEXT);

    pSendContext->Context = pContext;
    pSendContext->pSendCompleteCallback = pSendCompleteHandler;

    TdiBuildSend(pIrp,
                 pCtdi->pFileObject->DeviceObject,
                 pCtdi->pFileObject,
                 CtdipSendCallback,
                 pCtdi,
                 pMdl,
                 0,
                 ulLength);

    REFERENCE_OBJECT_EX(pCtdi, CTDI_REF_SEND);  // pair in CtdipSendCallback

    // Completion handler always called, don't care on return value.
    (void)IoCallDriver(pCtdi->pFileObject->DeviceObject, pIrp);

    Status = STATUS_PENDING;
csDone:
    if (!NT_SUCCESS(Status))
    {
        if(pSendCompleteHandler)
        {
            pSendCompleteHandler(pContext, NULL, pBuffer, Status);
            Status = NDIS_STATUS_PENDING;
        }
        if (pMdl)
        {
            IoFreeMdl(pMdl);
        }
        if (pIrp)
        {
            IoFreeIrp(pIrp);
        }
    }
    DEBUGMSG(DBG_FUNC|DBG_ERR(Status), (DTEXT("-CtdiSend %08x\n"), Status));
    return Status;
}

NDIS_STATUS
CtdiSendDatagram(
    IN      HANDLE                      hCtdi,
    IN      CTDI_EVENT_SEND_COMPLETE    pSendCompleteHandler,
    IN      PVOID                       pContext,
    IN      PVOID                       pDatagramContext,
    IN      PTRANSPORT_ADDRESS          pDestination,
    IN      PUCHAR                      pBuffer,
    IN      ULONG                       ulLength
    )
{
    PCTDI_DATA pCtdi = (PCTDI_DATA)hCtdi;
    NDIS_STATUS Status = NDIS_STATUS_SUCCESS;
    PIRP pIrp = NULL;
    PMDL pMdl = NULL;
    CTDI_SEND_DATAGRAM_CONTEXT *pSendContext;

    DEBUGMSG(DBG_FUNC, (DTEXT("+CtdiSendDatagram\n")));

    if (!IS_CTDI(pCtdi) || pCtdi->Closed)
    {
        Status = NDIS_STATUS_CLOSED;
        goto csdDone;
    }

    pIrp = IoAllocateIrp((CCHAR)(pCtdi->pFileObject->DeviceObject->StackSize +
                                 NUM_STACKS_FOR_CONTEXT(sizeof(CTDI_SEND_DATAGRAM_CONTEXT))), FALSE);
    if (!pIrp)
    {
        WPLOG(LL_A, LM_TDI, ("Failed to alloc IRP"));
        gCounters.ulIoAllocateIrpFail++;
        Status = NDIS_STATUS_RESOURCES;
        goto csdDone;
    }
                                 
    ASSERT(pCtdi->pFileObject->DeviceObject->StackSize + NUM_STACKS_FOR_CONTEXT(sizeof(CTDI_SEND_DATAGRAM_CONTEXT))<7);

    pMdl = IoAllocateMdl(pBuffer,
                         ulLength,
                         FALSE,
                         FALSE,
                         NULL);
    if (!pMdl)
    {
        WPLOG(LL_A, LM_TDI, ("Failed to alloc MDL"));
        gCounters.ulIoAllocateMdlFail++;
        Status = NDIS_STATUS_RESOURCES;
        goto csdDone;
    }
                         
#if PROBE
    __try
    {
        MmProbeAndLockPages(pMdl, KernelMode, IoReadAccess);
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        IoFreeMdl(pMdl);
        pMdl = NULL;
    }
#else
    MmBuildMdlForNonPagedPool(pMdl);
#endif

    pMdl->MdlFlags |= CtdiMdlFlags;

    // Get the first stack location for our own context use
    pSendContext = GET_CONTEXT(pIrp, CTDI_SEND_DATAGRAM_CONTEXT);

    NdisZeroMemory(pSendContext, sizeof(CTDI_SEND_DATAGRAM_CONTEXT));

    pSendContext->pSendCompleteCallback = pSendCompleteHandler;
    pSendContext->Context = pContext;
    pSendContext->DatagramContext = pDatagramContext;

    pSendContext->TdiConnectionInfo.RemoteAddressLength = sizeof(pSendContext->Ip);
    pSendContext->TdiConnectionInfo.RemoteAddress = &pSendContext->Ip;

    pSendContext->Ip = *(PTA_IP_ADDRESS)pDestination;

    if (pSendContext->Ip.Address[0].AddressLength!=TDI_ADDRESS_LENGTH_IP ||
        pSendContext->Ip.Address[0].AddressType!=TDI_ADDRESS_TYPE_IP)
    {
        DEBUGMSG(DBG_WARN, (DTEXT("Misformed transmit address on %p\n"), pCtdi));
        WPLOG(LL_A, LM_TDI, ("Misformed transmit address on %p", pCtdi));
    }

    TdiBuildSendDatagram(pIrp,
                         pCtdi->pFileObject->DeviceObject,
                         pCtdi->pFileObject,
                         CtdipSendDatagramCallback,
                         pCtdi,
                         pMdl,
                         ulLength,
                         &pSendContext->TdiConnectionInfo);

    REFERENCE_OBJECT_EX(pCtdi, CTDI_REF_SENDDG);  // Pair in CtdipSendDatagramCallback

    // Completion handler always called, don't care on return value.
    (void)IoCallDriver(pCtdi->pFileObject->DeviceObject, pIrp);

    Status = STATUS_PENDING;
csdDone:
    if (!NT_SUCCESS(Status))
    {
        if (pSendCompleteHandler)
        {
            pSendCompleteHandler(pContext, pDatagramContext, pBuffer, Status);
            Status = NDIS_STATUS_PENDING;
        }
        if (pMdl)
        {
            IoFreeMdl(pMdl);
        }
        if (pIrp)
        {
            IoFreeIrp(pIrp);
        }
    }

    DEBUGMSG(DBG_FUNC|DBG_ERR(Status), (DTEXT("-CtdiSendDatagram %08x\n"), Status));
    return Status;
}

STATIC VOID
CtdipDeleteHostRoute(
    PCTDI_ROUTE pRoute
    )
{
    PFILE_OBJECT pFileObject = pFileTcp;
    BOOLEAN NewRoute = FALSE;
    NDIS_STATUS Status = NDIS_STATUS_SUCCESS;
    IPRouteEntry *pQueryBuffer = NULL;
    IPRouteEntry *pNewRoute = NULL;
    IPRouteEntry BestRoute;
    BOOLEAN BestRouteFound = FALSE;
    PIRP pIrp;
    IO_STATUS_BLOCK IoStatusBlock;
    PIO_STACK_LOCATION IrpSp;
    TCP_REQUEST_QUERY_INFORMATION_EX QueryRoute;
    TCP_REQUEST_SET_INFORMATION_EX *pSetRoute = NULL;
    ULONG NumRoutes = 20;
    ULONG Size = 0, QuerySize = 0;
    ULONG i;
    KEVENT  Event;
#ifdef IP_ROUTE_REFCOUNT
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE IpFileHandle = 0;
#endif

    DEBUGMSG(DBG_FUNC, (DTEXT("+CtdipDeleteHostRoute\n")));

    if (!fCtdiInitialized)
    {
        Status = NDIS_STATUS_FAILURE;
        goto cdhrDone;
    }
    if (!pRoute->ExternalRoute)
    {
        // Query TCPfor the current routing table

        Status = CtdipIpQueryRouteTable(&pQueryBuffer, &QuerySize, &NumRoutes);
        if (Status!=NDIS_STATUS_SUCCESS)
        {
            goto cdhrDone;
        }

        BestRoute.ire_mask = 0;
        BestRoute.ire_metric1 = (ULONG)-1;

        for (i=0; i<NumRoutes; i++)
        {
            DEBUGMSG(DBG_TDI, (DTEXT("Route %d.%d.%d.%d Type %d NextHop %d.%d.%d.%d Mask %d.%d.%d.%d Metric %d Index %d\n"),
                               IPADDR(pQueryBuffer[i].ire_dest),
                               pQueryBuffer[i].ire_type,
                               IPADDR(pQueryBuffer[i].ire_nexthop),
                               IPADDR(pQueryBuffer[i].ire_mask),
                               pQueryBuffer[i].ire_metric1,
                               pQueryBuffer[i].ire_index));
            if (pQueryBuffer[i].ire_dest == pRoute->IpAddress &&
                pQueryBuffer[i].ire_proto == IRE_PROTO_NETMGMT)
            {
                BestRoute = pQueryBuffer[i];
                BestRouteFound = TRUE;
                break;
            }
        }

        // We've taken what we need from the route list.  Free it.

        MyMemFree(pQueryBuffer, QuerySize);
        pQueryBuffer = NULL;

        if (BestRouteFound)
        {

#ifdef IP_ROUTE_REFCOUNT
            Size = sizeof(IPRouteEntry);
            pNewRoute = MyMemAlloc(Size, TAG_CTDI_ROUTE);
            pSetRoute = (PVOID)pNewRoute;
            if (!pNewRoute)
            {
                WPLOG(LL_A, LM_Res, ("Failed to alloc CTDI_ROUTE"));
                Status = NDIS_STATUS_RESOURCES;
                goto cdhrDone;
            }
            NdisZeroMemory(pNewRoute, Size);
#else
            Size = sizeof(TCP_REQUEST_SET_INFORMATION_EX) + sizeof(IPRouteEntry);
            pSetRoute = MyMemAlloc(Size, TAG_CTDI_ROUTE);
            if (!pSetRoute)
            {
                WPLOG(LL_A, LM_Res, ("Failed to alloc CTDI_ROUTE"));
                Status = NDIS_STATUS_RESOURCES;
                goto cdhrDone;
            }

            NdisZeroMemory(pSetRoute, Size);

            pSetRoute->ID.toi_entity.tei_entity = CL_NL_ENTITY;
            pSetRoute->ID.toi_entity.tei_instance = 0;
            pSetRoute->ID.toi_class = INFO_CLASS_PROTOCOL;
            pSetRoute->ID.toi_type = INFO_TYPE_PROVIDER;
            pSetRoute->ID.toi_id = IP_MIB_RTTABLE_ENTRY_ID;
            pSetRoute->BufferSize = sizeof(IPRouteEntry);

            pNewRoute = (IPRouteEntry*)&pSetRoute->Buffer[0];
#endif
            *pNewRoute = BestRoute;

            pNewRoute->ire_type = IRE_TYPE_INVALID;

            DEBUGMSG(DBG_TDI, (DTEXT("DeleteHostRoute %d.%d.%d.%d Type %d NextHop %d.%d.%d.%d Index %d\n"),
                               IPADDR(pNewRoute->ire_dest), pNewRoute->ire_type,
                               IPADDR(pNewRoute->ire_nexthop), pNewRoute->ire_index));

            KeInitializeEvent(&Event, SynchronizationEvent, FALSE);

#ifdef IP_ROUTE_REFCOUNT
            pFileObject = pFileIp;

            pIrp = IoBuildDeviceIoControlRequest(
                IOCTL_IP_SET_ROUTEWITHREF,
                pFileObject->DeviceObject,
                pNewRoute,
                Size,
                NULL,
                0,
                FALSE,
                &Event,
                &IoStatusBlock);
#else
            pIrp = IoBuildDeviceIoControlRequest(
                IOCTL_TCP_SET_INFORMATION_EX,
                pFileObject->DeviceObject,
                pSetRoute,
                Size,
                NULL,
                0,
                FALSE,
                &Event,
                &IoStatusBlock);
#endif
            if (!pIrp ) {
                WPLOG(LL_A, LM_Res, ("Failed to build IP_SET_ROUTEWITHREF IRP"));
                gCounters.ulIoBuildIrpFail++;
                goto cdhrDone;
            }

            IrpSp = IoGetNextIrpStackLocation(pIrp);
            IrpSp->FileObject = pFileObject;

            Status = IoCallDriver(pFileObject->DeviceObject, pIrp);

            if (Status == STATUS_PENDING) {
                KeWaitForSingleObject(&Event, 
                                      Executive,
                                      KernelMode,
                                      FALSE,
                                      NULL);
                Status = IoStatusBlock.Status;

            }

            if (Status != STATUS_SUCCESS) {
                DEBUGMSG(DBG_TDI, (DTEXT("Create host route failed %08x\n"), Status));
                goto cdhrDone;
            }
        }
    }

cdhrDone:
    if (pRoute)
    {
        MyInterlockedRemoveEntryList(&pRoute->ListEntry, &CtdiListLock);
        MyMemFree(pRoute, sizeof(CTDI_ROUTE));
    }
    if (pSetRoute)
    {
        MyMemFree(pSetRoute, Size);
    }
    if (pQueryBuffer)
    {
        MyMemFree(pQueryBuffer, QuerySize);
    }
    DEBUGMSG(DBG_FUNC, (DTEXT("-CtdipDeleteHostRoute\n")));
}

NDIS_STATUS
CtdiAddHostRoute(
    IN      PTA_IP_ADDRESS              pIpAddress
    )
{
    PFILE_OBJECT pFileObject = pFileTcp;
    PCTDI_ROUTE pRoute = NULL;
    BOOLEAN NewRoute = FALSE;
    NDIS_STATUS Status = NDIS_STATUS_SUCCESS;
    IPRouteEntry *pQueryBuffer = NULL;
    IPRouteEntry *pNewRoute = NULL;
    IPRouteEntry BestRoute;
    BOOLEAN BestRouteFound = FALSE;
    PIRP pIrp = NULL;
    IO_STATUS_BLOCK IoStatusBlock;
    PIO_STACK_LOCATION IrpSp;
    TCP_REQUEST_QUERY_INFORMATION_EX QueryRoute;
    TCP_REQUEST_SET_INFORMATION_EX *pSetRoute = NULL;
    ULONG NumRoutes = 20;
    ULONG Size = 0, QuerySize = 0;
    ULONG i;
    KEVENT  Event;

    DEBUGMSG(DBG_FUNC, (DTEXT("+CtdiAddHostRoute %d.%d.%d.%d\n"),
                        IPADDR(pIpAddress->Address[0].Address[0].in_addr)));

    NdisAcquireSpinLock(&CtdiListLock);
    pRoute = CtdipFindRoute(pIpAddress->Address[0].Address[0].in_addr);
    if (pRoute)
    {
        REFERENCE_OBJECT(pRoute);  // Pair in CtdiDeleteHostRoute
        pRoute = NULL;
    }
    else
    {
        NewRoute = TRUE;
        pRoute = MyMemAlloc(sizeof(CTDI_ROUTE), TAG_CTDI_ROUTE);
        if (!pRoute)
        {
            WPLOG(LL_A, LM_Res, ("Failed to alloc CTDI_ROUTE"));
            Status = NDIS_STATUS_RESOURCES;
            NdisReleaseSpinLock(&CtdiListLock);
            goto cahrDone;
        }
        NdisZeroMemory(pRoute, sizeof(CTDI_ROUTE));
        pRoute->IpAddress = pIpAddress->Address[0].Address[0].in_addr;
        INIT_REFERENCE_OBJECT(pRoute, CtdipDeleteHostRoute); // Pair in CtdiDeleteHostRoute
        InsertTailList(&CtdiRouteList, &pRoute->ListEntry);
    }
    NdisReleaseSpinLock(&CtdiListLock);

    if (NewRoute)
    {
        // Query TCPfor the current routing table

        Status = CtdipIpQueryRouteTable(&pQueryBuffer, &QuerySize, &NumRoutes);
        if (Status!=NDIS_STATUS_SUCCESS)
        {
            goto cahrDone;
        }


        BestRoute.ire_mask = 0;
        BestRoute.ire_metric1 = (ULONG)-1;

        for (i=0; i<NumRoutes; i++)
        {
            DEBUGMSG(DBG_TDI, (DTEXT("Route %d.%d.%d.%d Type %d NextHop %d.%d.%d.%d Mask %d.%d.%d.%d Metric %d Index %d\n"),
                               IPADDR(pQueryBuffer[i].ire_dest),
                               pQueryBuffer[i].ire_type,
                               IPADDR(pQueryBuffer[i].ire_nexthop),
                               IPADDR(pQueryBuffer[i].ire_mask),
                               pQueryBuffer[i].ire_metric1,
                               pQueryBuffer[i].ire_index));
            if (pQueryBuffer[i].ire_dest == (pIpAddress->Address[0].Address[0].in_addr &
                                             pQueryBuffer[i].ire_mask))
            {
                if ((BestRoute.ire_mask == pQueryBuffer[i].ire_mask &&
                     BestRoute.ire_metric1 > pQueryBuffer[i].ire_metric1) ||
                    ntohl(pQueryBuffer[i].ire_mask) > ntohl(BestRoute.ire_mask))
                {
                    BestRoute = pQueryBuffer[i];
                    BestRouteFound = TRUE;
                }
            }
        }

        // We've taken what we need from the route list.  Free it.

        MyMemFree(pQueryBuffer, QuerySize);
        pQueryBuffer = NULL;

        if (!BestRouteFound)
        {
            DEBUGMSG(DBG_WARN, (DTEXT("Add host route.  No route found\n")));
            WPLOG(LL_A, LM_TDI, ("Add host route.  No route found"));
        }
        else
        {
            // If we're using the IP refcounts, always add and delete the route.
#ifndef IP_ROUTE_REFCOUNT
            if (BestRoute.ire_dest == pIpAddress->Address[0].Address[0].in_addr &&
                BestRoute.ire_mask == 0xFFFFFFFF) {
                //
                // A route already exists so don't add
                //
                pRoute->ExternalRoute = TRUE;
                Status = NDIS_STATUS_SUCCESS;
                goto cahrDone;
            }
#endif

#ifdef IP_ROUTE_REFCOUNT
            Size = sizeof(IPRouteEntry);
            pNewRoute = MyMemAlloc(Size, TAG_CTDI_ROUTE);
            pSetRoute = (PVOID)pNewRoute;
            if (!pNewRoute)
            {
                WPLOG(LL_A, LM_Res, ("Failed to alloc CTDI_ROUTE"));
                Status = NDIS_STATUS_RESOURCES;
                goto cahrDone;
            }
            NdisZeroMemory(pNewRoute, Size);
#else
            Size = sizeof(TCP_REQUEST_SET_INFORMATION_EX) + sizeof(IPRouteEntry);
            pSetRoute = MyMemAlloc(Size, TAG_CTDI_ROUTE);
            if (!pSetRoute)
            {
                WPLOG(LL_A, LM_Res, ("Failed to alloc CTDI_ROUTE"));
                Status = NDIS_STATUS_RESOURCES;
                goto cahrDone;
            }

            NdisZeroMemory(pSetRoute, Size);

            pSetRoute->ID.toi_entity.tei_entity = CL_NL_ENTITY;
            pSetRoute->ID.toi_entity.tei_instance = 0;
            pSetRoute->ID.toi_class = INFO_CLASS_PROTOCOL;
            pSetRoute->ID.toi_type = INFO_TYPE_PROVIDER;
            pSetRoute->ID.toi_id = IP_MIB_RTTABLE_ENTRY_ID;
            pSetRoute->BufferSize = sizeof(IPRouteEntry);

            pNewRoute = (IPRouteEntry*)&pSetRoute->Buffer[0];
#endif
            *pNewRoute = BestRoute;

            pNewRoute->ire_dest = pIpAddress->Address[0].Address[0].in_addr;
            pNewRoute->ire_mask = 0xFFFFFFFF;
            pNewRoute->ire_proto = IRE_PROTO_NETMGMT;

            // Check DIRECT/INDIRECT only if this is not a host route
            if(BestRoute.ire_mask != 0xFFFFFFFF)
            {
                if ((BestRoute.ire_mask & pIpAddress->Address[0].Address[0].in_addr) ==
                    (BestRoute.ire_mask & BestRoute.ire_nexthop))
                {
                    pNewRoute->ire_type = IRE_TYPE_DIRECT;
                }
                else
                {
                    pNewRoute->ire_type = IRE_TYPE_INDIRECT;
                }
            }

            DEBUGMSG(DBG_TDI, (DTEXT("AddHostRoute %d.%d.%d.%d Type %d NextHop %d.%d.%d.%d Index %d\n"),
                               IPADDR(pNewRoute->ire_dest), pNewRoute->ire_type,
                               IPADDR(pNewRoute->ire_nexthop), pNewRoute->ire_index));

            KeInitializeEvent(&Event, SynchronizationEvent, FALSE);

#ifdef IP_ROUTE_REFCOUNT
            pFileObject = pFileIp;

            pIrp = IoBuildDeviceIoControlRequest(
                IOCTL_IP_SET_ROUTEWITHREF,
                pFileObject->DeviceObject,
                pNewRoute,
                Size,
                NULL,
                0,
                FALSE,
                &Event,
                &IoStatusBlock);
#else
            pIrp = IoBuildDeviceIoControlRequest(
                IOCTL_TCP_SET_INFORMATION_EX,
                pFileObject->DeviceObject,
                pSetRoute,
                Size,
                NULL,
                0,
                FALSE,
                &Event,
                &IoStatusBlock);
#endif
            if (!pIrp) {
                WPLOG(LL_A, LM_Res, ("Failed to build IP_SET_ROUTEWITHREF IRP"));
                gCounters.ulIoBuildIrpFail++;
                goto cahrDone;
            }

            IrpSp = IoGetNextIrpStackLocation(pIrp);
            IrpSp->FileObject = pFileObject;

            Status = IoCallDriver(pFileObject->DeviceObject, pIrp);

            if (Status == STATUS_PENDING) {
                KeWaitForSingleObject(&Event, 
                                      Executive,
                                      KernelMode,
                                      FALSE,
                                      NULL);
                Status = IoStatusBlock.Status;
            }

            if (Status != STATUS_SUCCESS) {
                DEBUGMSG(DBG_TDI, (DTEXT("Create host route failed %08x\n"), Status));
                goto cahrDone;
            }

            //CtdipIpRequestRoutingNotification(pIpAddress->Address[0].Address[0].in_addr);

            // The route's a keeper.  Set the var to null so we don't free it
            pRoute = NULL;
        }
    }

cahrDone:
    if (pRoute)
    {
        MyInterlockedRemoveEntryList(&pRoute->ListEntry, &CtdiListLock);
        MyMemFree(pRoute, sizeof(CTDI_ROUTE));
    }
    if (pSetRoute)
    {
        MyMemFree(pSetRoute, Size);
    }
    if (pQueryBuffer)
    {
        MyMemFree(pQueryBuffer, QuerySize);
    }
    DEBUGMSG(DBG_FUNC|DBG_ERR(Status), (DTEXT("-CtdiAddHostRoute %08x\n"), Status));
    return Status;
}


NDIS_STATUS
CtdiDeleteHostRoute(
    IN      PTA_IP_ADDRESS              pIpAddress
    )
{
    PCTDI_ROUTE pRoute = NULL;
    DEBUGMSG(DBG_FUNC, (DTEXT("+CtdiDeleteHostRoute\n")));
    NdisAcquireSpinLock(&CtdiListLock);
    pRoute = CtdipFindRoute(pIpAddress->Address[0].Address[0].in_addr);
    NdisReleaseSpinLock(&CtdiListLock);
    if (pRoute)
    {
        DEREFERENCE_OBJECT(pRoute);  // Pair in CtdiAddHostRoute
    }
    DEBUGMSG(DBG_FUNC, (DTEXT("-CtdiDeleteHostRoute\n")));
    return NDIS_STATUS_SUCCESS;
}

NDIS_STATUS
CtdiCreateEndpoint(
    OUT     PHANDLE                     phCtdi,
    IN      ULONG_PTR                   ulAddressFamily,
    IN      ULONG_PTR                   ulType,
    IN      PTRANSPORT_ADDRESS          pAddress,
    IN      ULONG_PTR                   ulRxPadding
    )
{
    UNICODE_STRING DeviceName;
    OBJECT_ATTRIBUTES ObjectAttributes;
    NDIS_STATUS ReturnStatus = NDIS_STATUS_SUCCESS;
    NTSTATUS NtStatus;
    IO_STATUS_BLOCK IoStatusBlock;
    PCTDI_DATA  pCtdi = NULL;

    DEBUGMSG(DBG_FUNC, (DTEXT("+CtdiCreateEndpoint\n")));
    DBG_D(DBG_TAPI, KeGetCurrentIrql());

    // Validate TDI initialized
    if ( !fCtdiInitialized ) {
        DEBUGMSG(DBG_ERROR | DBG_TDI, (DTEXT("CtdiCreateEndpoint: TDI interface hasn't been initialized!\n")));
        WPLOG(LL_A, LM_TDI, ("CtdiCreateEndpoint: TDI interface hasn't been initialized!"));
        ReturnStatus = NDIS_STATUS_FAILURE;
        goto cceDone;
    }

    ASSERT(ulAddressFamily==AF_INET);
    if (ulAddressFamily!=AF_INET)
    {
        DEBUGMSG(DBG_ERROR|DBG_TDI, (DTEXT("unsupported family\n")));
        WPLOG(LL_A, LM_TDI, ("unsupported family"));
        ReturnStatus = NDIS_STATUS_OPEN_FAILED;
        goto cceDone;
    }

    // Alloc our endpoint structure.
    pCtdi = CtdipDataAlloc();
    if (!pCtdi)
    {
        ReturnStatus = NDIS_STATUS_RESOURCES;
        goto cceDone;
    }

    pCtdi->Type = CTDI_ENDPOINT;

    switch (ulType)
    {
        case SOCK_RAW:
        {
            WCHAR DeviceNameBuffer[sizeof(DD_RAW_IP_DEVICE_NAME) + 16];
            WCHAR ProtocolNumberBuffer[8];
            UNICODE_STRING ProtocolNumber;
            TA_IP_ADDRESS TmpAddress = *(PTA_IP_ADDRESS)pAddress;

            pCtdi->Type = CTDI_DATAGRAM;

            InitBufferPool(&pCtdi->Datagram.RxPool,
                           ALIGN_UP(PPTP_MAX_RECEIVE_SIZE+ulRxPadding, ULONG_PTR),
                           0,                   // MaxBuffers, no limit
                           10,                  // Buffers per block
                           0,                   // Frees per collection
                           TRUE,                // These are MDLs
                           TAG_CTDI_DGRAM);

            NdisZeroMemory(DeviceNameBuffer, sizeof(DeviceNameBuffer));
            DeviceName.Buffer = DeviceNameBuffer;
            DeviceName.MaximumLength = sizeof(DeviceNameBuffer);
            DeviceName.Length = 0;

            RtlAppendUnicodeToString(&DeviceName, DD_RAW_IP_DEVICE_NAME);
            RtlAppendUnicodeToString(&DeviceName, L"\\");

            ProtocolNumber.Buffer = ProtocolNumberBuffer;
            ProtocolNumber.MaximumLength = sizeof(ProtocolNumberBuffer);
            ProtocolNumber.Length = 0;

            RtlIntegerToUnicodeString(((PTA_IP_ADDRESS)pAddress)->Address[0].Address[0].sin_port,
                                      10,
                                      &ProtocolNumber);
            RtlAppendUnicodeStringToString(&DeviceName, &ProtocolNumber);

            TmpAddress.Address[0].Address[0].sin_port = 0;
            TmpAddress.Address[0].Address[0].in_addr = 0;
            NdisZeroMemory(TmpAddress.Address[0].Address[0].sin_zero,
                           sizeof(TmpAddress.Address[0].Address[0].sin_zero));

            NtStatus = CtdipOpenProtocol(&DeviceName,
                                         pAddress,
                                         &pCtdi->hFile,
                                         &pCtdi->pFileObject);

            if (NtStatus!=STATUS_SUCCESS)
            {
                ReturnStatus = NtStatus;
                goto cceDone;
            }

            break;
        }
        case SOCK_DGRAM:  // for UDP
        {
            DeviceName.Length = sizeof(DD_UDP_DEVICE_NAME) - sizeof(WCHAR);
            DeviceName.Buffer = DD_UDP_DEVICE_NAME;

            pCtdi->Type = CTDI_DATAGRAM;

            InitBufferPool(&pCtdi->Datagram.RxPool,
                           ALIGN_UP(PPTP_MAX_RECEIVE_SIZE+ulRxPadding, ULONG_PTR),
                           0,                   // MaxBuffers, no limit
                           10,                  // Buffers per block
                           0,                   // Frees per collection
                           TRUE,                // These are MDLs
                           TAG_CTDI_DGRAM);

            NtStatus = CtdipOpenProtocol(&DeviceName,
                                         pAddress,
                                         &pCtdi->hFile,
                                         &pCtdi->pFileObject);

            if (NtStatus!=STATUS_SUCCESS)
            {
                ReturnStatus = NtStatus;
                goto cceDone;
            }

            break;
        }
        case SOCK_STREAM:
        {
            RtlInitUnicodeString(&DeviceName, DD_TCP_DEVICE_NAME);

            NtStatus = CtdipOpenProtocol(&DeviceName,
                                         pAddress,
                                         &pCtdi->hFile,
                                         &pCtdi->pFileObject);

            if (NtStatus!=STATUS_SUCCESS)
            {
                ReturnStatus = NtStatus;
                goto cceDone;
            }

            break;
        }
        default:
            DEBUGMSG(DBG_ERROR|DBG_TDI, (DTEXT("unsupported Type\n")));
            WPLOG(LL_A, LM_TDI, ("unsupported Type"));
            ReturnStatus = NDIS_STATUS_OPEN_FAILED;
            goto cceDone;
    }

cceDone:
    if (ReturnStatus!=NDIS_STATUS_SUCCESS)
    {
        if (pCtdi)
        {
            CtdipDataFree(pCtdi);
            pCtdi = NULL;
        }
    }

    // Return the CTDI_DATA as a handle.
    *phCtdi = (HANDLE)pCtdi;

    DEBUGMSG(DBG_FUNC|DBG_ERR(ReturnStatus), (DTEXT("-CtdiCreateEndpoint Sts:%08x hCtdi:%08x\n"), ReturnStatus, pCtdi));
    return ReturnStatus;
}

NDIS_STATUS
CtdiSetEventHandler(
    IN      HANDLE                      hCtdi,
    IN      ULONG                       ulEventType,
    IN      PVOID                       pEventHandler,
    IN      PVOID                       pContext
    )
{
    NDIS_STATUS Status = NDIS_STATUS_SUCCESS;
    PCTDI_DATA pCtdi = (PCTDI_DATA)hCtdi;
    PVOID PrivateCallback = NULL;

    DEBUGMSG(DBG_FUNC, (DTEXT("+CtdiSetEventHandler Type:%d\n"), ulEventType));

    switch (ulEventType)
    {
        case TDI_EVENT_RECEIVE_DATAGRAM:
        {
            if (pCtdi->Type==CTDI_DATAGRAM)
            {
                PrivateCallback = CtdipReceiveDatagramCallback;
                pCtdi->RecvDatagramCallback = pEventHandler;
                pCtdi->RecvContext = pContext;
            }
            else
            {
                DEBUGMSG(DBG_ERROR, (DTEXT("Tried to register RecvDgram handler on wrong handle.\n")));
                WPLOG(LL_A, LM_TDI, ("Tried to register RecvDgram handler on wrong handle."));
                Status = NDIS_STATUS_FAILURE;
            }
            break;
        }
        default:
            Status = NDIS_STATUS_NOT_SUPPORTED;
            break;
    }

    if (Status==NDIS_STATUS_SUCCESS && PrivateCallback!=NULL)
    {
        Status = CtdipSetEventHandler(pCtdi,
                                      ulEventType,
                                      PrivateCallback);
    }

    DEBUGMSG(DBG_FUNC, (DTEXT("+CtdiSetEventHandler %08x\n"), Status));
    return Status;
}


NDIS_STATUS
CtdiSetInformation(
    IN      HANDLE                      hCtdi,
    IN      ULONG_PTR                   ulSetType,
    IN      PTDI_CONNECTION_INFORMATION pConnectionInformation,
    IN      CTDI_EVENT_SET_COMPLETE     pSetCompleteHandler,
    IN      PVOID                       pContext
    )
{
    DEBUGMSG(DBG_FUNC, (DTEXT("+CtdiSetInformation\n")));
    DEBUGMSG(DBG_FUNC, (DTEXT("-CtdiSetInformation\n")));
    return NDIS_STATUS_FAILURE;
}

STATIC NTSTATUS
CtdipQueryInformationCallback(
    PDEVICE_OBJECT pDeviceObject,
    PIRP pIrp,
    PVOID Context
    )
{
    PCTDI_DATA pCtdi = Context;
    NDIS_STATUS Status = (NDIS_STATUS)pIrp->IoStatus.Status;
    PCTDI_QUERY_CONTEXT pQuery;
    CTDI_EVENT_QUERY_COMPLETE pQueryCompleteCallback;
    PVOID CtdiContext;
    PVOID pBuffer;

    DEBUGMSG(DBG_FUNC, (DTEXT("+CtdipQueryInformationCallback\n")));

    pQuery = (PCTDI_QUERY_CONTEXT)IoGetCurrentIrpStackLocation(pIrp);
    CtdiContext = pQuery->Context;
    pQueryCompleteCallback = pQuery->pQueryCompleteCallback;

    pBuffer = MmGetMdlVirtualAddress(pIrp->MdlAddress);
#if PROBE
    MmUnlockPages(pIrp->MdlAddress);
#endif
    IoFreeMdl(pIrp->MdlAddress);
    RELEASE_CONTEXT(pIrp, CTDI_QUERY_CONTEXT);
    IoFreeIrp(pIrp);

    pQueryCompleteCallback(CtdiContext, pBuffer, Status);

    DEREFERENCE_OBJECT_EX(pCtdi, CTDI_REF_QUERY);

    DEBUGMSG(DBG_FUNC, (DTEXT("-CtdipQueryInformationCallback\n")));
    return STATUS_MORE_PROCESSING_REQUIRED;
}

NDIS_STATUS
CtdiQueryInformation(
    IN      HANDLE                      hCtdi,
    IN      ULONG                       ulQueryType,
    IN OUT  PVOID                       pBuffer,
    IN      ULONG                       Length,
    IN      CTDI_EVENT_QUERY_COMPLETE   pQueryCompleteHandler,
    IN      PVOID                       pContext
    )
{
    PIRP pIrp = NULL;
    PMDL pMdl = NULL;
    PCTDI_DATA pCtdi = (PCTDI_DATA) hCtdi;
    NDIS_STATUS Status = NDIS_STATUS_PENDING;
    PCTDI_QUERY_CONTEXT pQuery;
    DEBUGMSG(DBG_FUNC, (DTEXT("+CtdiQueryInformation\n")));

    pIrp = IoAllocateIrp((CCHAR)(pCtdi->pFileObject->DeviceObject->StackSize +
                                 NUM_STACKS_FOR_CONTEXT(sizeof(CTDI_QUERY_CONTEXT))),
                         FALSE);
    if (!pIrp)
    {
        WPLOG(LL_A, LM_Res, ("Failed to alloc IRP"));
        gCounters.ulIoAllocateIrpFail++;
        Status = NDIS_STATUS_RESOURCES;
        goto cqiDone;
    }
    
    pMdl = IoAllocateMdl(pBuffer, Length, FALSE, FALSE, pIrp);
    if (!pMdl)
    {
        IoFreeIrp(pIrp);
        WPLOG(LL_A, LM_Res, ("Failed to alloc MDL"));
        gCounters.ulIoAllocateMdlFail++;
        Status = NDIS_STATUS_RESOURCES;
        goto cqiDone;
    }
    
#if PROBE
    __try
    {
        MmProbeAndLockPages(pMdl, KernelMode, IoReadAccess);
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        IoFreeMdl(pMdl);
        pMdl = NULL;
        Status = NDIS_STATUS_RESOURCES;
    }
#else
    MmBuildMdlForNonPagedPool(pMdl);
#endif

    pQuery = GET_CONTEXT(pIrp, CTDI_QUERY_CONTEXT);
    pQuery->Context = pContext;
    pQuery->pQueryCompleteCallback = pQueryCompleteHandler;

    TdiBuildQueryInformation(pIrp,
                             pCtdi->pFileObject->DeviceObject,
                             pCtdi->pFileObject,
                             CtdipQueryInformationCallback,
                             pCtdi,
                             ulQueryType,
                             pMdl);
    REFERENCE_OBJECT_EX(pCtdi, CTDI_REF_QUERY);

    // Completion handler always called, don't care on return value.
    (void)IoCallDriver(pCtdi->pFileObject->DeviceObject, pIrp);

cqiDone:
    if (pQueryCompleteHandler && !NT_SUCCESS(Status))
    {
        pQueryCompleteHandler(pContext, pBuffer, Status);
        Status = NDIS_STATUS_PENDING;
    }
    DEBUGMSG(DBG_FUNC|DBG_ERR(Status), (DTEXT("-CtdiQueryInformation %08x\n"), Status));
    return Status;
}


VOID CtdiCleanupLooseEnds()
{
    PLIST_ENTRY ListEntry;

    if (!fCtdiInitialized)
    {
        return;
    }

    DEBUGMSG(DBG_FUNC, (DTEXT("+CtdiCleanupLooseEnds\n")));

    if (!IsListEmpty(&CtdiFreeList))
    {
        ScheduleWorkItem(CtdipDataFreeWorker, NULL, NULL, 0);
    }
    DEBUGMSG(DBG_FUNC, (DTEXT("-CtdiCleanupLooseEnds\n")));
}

VOID CtdiSetRequestPending(
    IN      HANDLE                      hCtdi
    )
{
    PCTDI_DATA pCtdi = (PCTDI_DATA) hCtdi;
    pCtdi->CloseReqPending = TRUE;
}

NTSTATUS
CtdiSetTdiAOOption(
    IN FILE_OBJECT* pAddress,
    IN ULONG ulOption,
    IN ULONG ulValue)

    // Turn off UDP checksums on open UDP address object 'pAddress'.
    //
{
    NTSTATUS status;
    PDEVICE_OBJECT pDeviceObject;
    PIO_STACK_LOCATION pIrpSp;
    IO_STATUS_BLOCK iosb;
    PIRP pIrp;
    TCP_REQUEST_SET_INFORMATION_EX* pInfo;
    CHAR achBuf[ sizeof(*pInfo) + sizeof(ULONG) ];

    pInfo = (TCP_REQUEST_SET_INFORMATION_EX* )achBuf;
    pInfo->ID.toi_entity.tei_entity = CL_TL_ENTITY;
    pInfo->ID.toi_entity.tei_instance = 0;
    pInfo->ID.toi_class = INFO_CLASS_PROTOCOL;
    pInfo->ID.toi_type = INFO_TYPE_ADDRESS_OBJECT;
    pInfo->ID.toi_id = ulOption;

    NdisMoveMemory( pInfo->Buffer, &ulValue, sizeof(ulValue) );
    pInfo->BufferSize = sizeof(ulValue);

    pDeviceObject = IoGetRelatedDeviceObject( pAddress );

    pIrp = IoBuildDeviceIoControlRequest(
        IOCTL_TCP_WSH_SET_INFORMATION_EX,
        pDeviceObject,
        (PVOID )pInfo,
        sizeof(*pInfo) + sizeof(ulValue),
        NULL,
        0,
        FALSE,
        NULL,
        &iosb );

    if (!pIrp)
    {
        DEBUGMSG(DBG_ERROR, (DTEXT("TdixSetTdiAOOption Irp?\n")));
        WPLOG( LL_A, LM_TDI, ( "TdixSetTdiAOOption Irp?" ) );
        return NDIS_STATUS_RESOURCES;
    }

    pIrpSp = IoGetNextIrpStackLocation( pIrp );
    pIrpSp->FileObject = pAddress;

    status = IoCallDriver( pDeviceObject, pIrp );

    if(NT_SUCCESS(status))
    {
        status = iosb.Status;
    }

    return status;
}

VOID
CtdiEnableIpHdrIncl(
    IN  HANDLE  hCtdi)
    
    // Turn on IP_HDRINCL on raw IP address object.
    //
{
    NTSTATUS status;
    PCTDI_DATA pCtdi = (PCTDI_DATA) hCtdi;

    status = CtdiSetTdiAOOption(pCtdi->pFileObject, AO_OPTION_IP_HDRINCL, TRUE);

    ASSERT(status == STATUS_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ndis\raspptp\nt\dbgapi.h ===
/*****************************************************************************
*
*   Copyright (c) 1998-1999 Microsoft Corporation
*
*   DBGAPI.H - NT specific debugging macros, etc.
*
*   Author:     Stan Adermann (stana)
*
*   Created:    9/3/1998
*
*****************************************************************************/
#ifndef DBGAPI_H
#define DBGAPI_H

#define DBG_MSG_CNT         512
#define MAX_MSG_LEN         128
#define DBG_TIMER_INTERVAL  400

extern ULONG DbgSettings;

#define DBG_OUTPUT_DEBUGGER     1
#define DBG_OUTPUT_BUFFER       2



#define DEBUGZONE(bit)    (1<<(bit))

#define DBG_BREAK       DEBUGZONE(31)

#if DBG

#define DEBUGMSG(dbgs,format)                               \
    if ((dbgs)&DbgSettings)                                 \
    {                                                       \
        DbgMsg format;                                      \
        if ((dbgs)&DbgSettings&DBG_BREAK)                   \
        {                                                   \
            DbgBreakPoint();                                \
        }                                                   \
    }

#define DEBUGMEM(dbgs, data, length, size)                  \
    if ((dbgs)&DbgSettings)                                 \
    {                                                       \
        DbgMemory((data), (length), (size));                \
    }


VOID        DbgMsgInit();
VOID        DbgMsgUninit();
VOID        DbgMsg(CHAR *Format, ...);
NTSTATUS    DbgMsgIrp(PIRP pIrp, PIO_STACK_LOCATION  pIrpSp);
VOID        DbgMemory(PVOID pMemory, ULONG Length, ULONG WordSize);
VOID        DbgRegInit(PUNICODE_STRING pRegistryPath, ULONG DefaultDebug);

#define DEFAULT_DEBUG_OPTIONS(x)        \
    {                                   \
        DbgRegInit(pRegistryPath, (x)); \
    }


#else

#define RETAILMSG(cond,printf_exp) 0
#define DEBUGMSG(cond,printf_exp) 0
#define DBGCHK(module,exp) 0
#define DEBUGCHK(exp) 0
#define DEBUGREGISTER(hMod) 0

#define DbgMsgInit()    0
#define DbgMsgUninit()  0
#define DEFAULT_DEBUG_OPTIONS(x)
#define DEBUGMEM(dbgs, data, length, size) 0

#endif

#define DTEXT

#endif //DBGAPI_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ndis\raspptp\nt\ctdios.h ===
/*******************************************************************
*
*   Copyright (c) 1998-1999 Microsoft Corporation
*
*    DESCRIPTION: CTDIOS.H - Commond TDI layer, for NT specific
*
*    AUTHOR: Stan Adermann (StanA)
*
*    DATE:9/29/1998
*
*******************************************************************/

#ifndef CTDIOS_H
#define CTDIOS_H

#include <tdi.h>
#include <tdikrnl.h>
#include <tdiinfo.h>
#include <ipinfo.h>
#include <ntddip.h>
#include <ntddtcp.h>

// Borrow some defines from WINSOCK.
#define AF_INET         2               /* internetwork: UDP, TCP, etc. */
#define SOCK_STREAM     1               /* stream socket */
#define SOCK_DGRAM      2               /* datagram socket */
#define SOCK_RAW        3               /* raw-protocol interface */

// Winsock-ish host/network byte order converters for short and long integers.
//
#if (defined(_M_IX86) && (_MSC_FULL_VER > 13009037)) || ((defined(_M_AMD64) || defined(_M_IA64)) && (_MSC_FULL_VER > 13009175))
#define htons(x) _byteswap_ushort((USHORT)(x))
#define htonl(x) _byteswap_ulong((ULONG)(x))
#else
#define htons( a ) ((((a) & 0xFF00) >> 8) |\
                    (((a) & 0x00FF) << 8))
#define htonl( a ) ((((a) & 0xFF000000) >> 24) | \
                    (((a) & 0x00FF0000) >> 8)  | \
                    (((a) & 0x0000FF00) << 8)  | \
                    (((a) & 0x000000FF) << 24))
#endif
#define ntohs( a ) htons(a)
#define ntohl( a ) htonl(a)


#endif // CTDIOS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ndis\raspptp\nt\osinc.h ===
/*****************************************************************************
*
*   Copyright (c) 1998-1999 Microsoft Corporation
*
*   OSINC.H - includes OS specific headers
*
*   Author:     Stan Adermann (stana)
*
*   Created:    9/2/1998
*
*****************************************************************************/

#ifndef OSINC_H
#define OSINC_H

#define BINARY_COMPATIBLE 0

#include <ntddk.h>

#include <ndis.h>
#include <ndiswan.h>
#include <ndistapi.h>
#include <ntverp.h>

#define PPTP_VENDOR "Microsoft"

#define PPTP_FIRMWARE_REVISION VER_PRODUCTBUILD

#define TAPI_LINE_NAME_STRING       "RAS VPN Line"
extern ANSI_STRING TapiLineName;
#define TAPI_PROVIDER_STRING        "VPN\0RASPPTP"
#define TAPI_DEV_CAPS_SIZE          (sizeof(TAPI_PROVIDER_STRING)+ \
                                     TapiLineName.Length + sizeof(UCHAR) * 6 +\
                                     sizeof(NDIS_TAPI_GET_DEV_CAPS))

#define TAPI_LINE_ADDR_STRING       "PPTP VPN"

#define OS_SPECIFIC_NDIS_WAN_MEDIUM_TYPE NdisWanMediumPPTP
// OS_CONNECTION_WRAPPER_ID should only be used in one location, TapiLineUp()
#define OS_CONNECTION_WRAPPER_ID ((NDIS_HANDLE) pCall->hTapiCall)

// Other OS's that don't risk blowing the stack or don't have this mechanism
// should just define this TRUE or FALSE.
#define OS_COMPLETE_SEND_NOW(Call)   (IoGetRemainingStackSize()>1024)


//
// NDIS version compatibility.
//

#define NDIS_MAJOR_VERSION 4
#define NDIS_MINOR_VERSION 0

#define MAX_CALL_ID_RANGE   ((ULONG)0x10000)

#define OS_RANGE_CHECK_ENDPOINTS(ep, baseid)    \
    if ((unsigned)(ep)>(1<<CALL_ID_INDEX_BITS))            \
    {                                   \
        (ep) = (1<<CALL_ID_INDEX_BITS);                    \
    } \
    if (((ep) + (baseid)) > MAX_CALL_ID_RANGE) \
    { \
        baseid = MAX_CALL_ID_RANGE - (ep); \
    } \
    if(baseid != 0 || (ep) != OS_CLIENT_WAN_ENDPOINTS) \
        PptpClientSide = FALSE;
        

#define OS_RANGE_CHECK_MAX_TRANSMIT(mt) \
    if ((unsigned)(mt)<1) (mt) = 1;     \
    if ((unsigned)(mt)>1024) (mt) = 1024;

#define OS_DEFAULT_WAN_ENDPOINTS 5
#define OS_CLIENT_WAN_ENDPOINTS 32
#define OS_LISTENS_PENDING 5

#define LOGHDRS    ":::%d:%08x:%08x:%d.%d.%d.%d:"

#define LOGHDR(id, ip) (id), Time.HighPart, Time.LowPart, IPADDR(ip)


typedef VOID    (*WORK_PROC)(struct _PPTP_WORK_ITEM *);

typedef struct _PPTP_WORK_ITEM
{
    LIST_ENTRY          ListEntry;
    WORK_PROC           Callback;
    PVOID               Context;
    PVOID               pBuffer;
    ULONG               Length;
} PPTP_WORK_ITEM, *PPPTP_WORK_ITEM;

#ifndef PPTP_DPC_USES_NDIS
#define PPTP_DPC_USES_NDIS 0
#endif
#if PPTP_DPC_USES_NDIS

// WARNING:  There's a difference in behavior between NdisMSetTimer and
// KeInsertQueueDpc.  NdisMSetTimer resets the timer if it's already
// queued, KeInsertQueueDpc does not.
// We purposely wrote the code that uses these macros
// to be agnostic about this behavior.  Anyone using these macros should
// study how they are used here to avoid problems with them.

#define PPTP_DPC NDIS_MINIPORT_TIMER
#define PptpInitializeDpc(Dpc, hAdapter, DeferredRoutine, DeferredContext) \
        NdisMInitializeTimer((Dpc), (hAdapter), (PNDIS_TIMER_FUNCTION)(DeferredRoutine), (DeferredContext))
#define PptpQueueDpc(Dpc) NdisMSetTimer((Dpc), 1)
#define PptpCancelDpc(Dpc, pCancelled) NdisMCancelTimer((Dpc), (pCancelled))

#else

#define PPTP_DPC KDPC
#define PptpInitializeDpc(Dpc, AdapterHandle, DeferredRoutine, DeferredContext) \
        KeInitializeDpc((Dpc), (PKDEFERRED_ROUTINE)(DeferredRoutine), (DeferredContext))
#define PptpQueueDpc(Dpc) \
        {                                               \
            ASSERT(KeGetCurrentIrql()>=DISPATCH_LEVEL); \
            KeInsertQueueDpc((Dpc), NULL, NULL);        \
        }
#define PptpCancelDpc(Dpc, pCancelled) KeRemoveQueueDpc(Dpc)    \
        {                                                       \
            *(PBOOLEAN)(pCancelled) = KeRemoveQueueDpc(Dpc);    \
        }

#endif

typedef
VOID
(*PPPTP_DPC_FUNCTION) (
    IN  PVOID                   SystemSpecific1,
    IN  PVOID                   FunctionContext,
    IN  PVOID                   SystemSpecific2,
    IN  PVOID                   SystemSpecific3
    );


#define ASSERT_LOCK_HELD(pNdisLock) ASSERT(KeNumberProcessors==1 || (pNdisLock)->SpinLock!=0)

#ifndef VER_PRODUCTVERSION_W
#error "No VER_PRODUCTVERSION_W"
#endif
#if VER_PRODUCTVERSION_W < 0x0400
#error "VER_PRODUCTVERSION_W < 0x0400"
#endif

#if VER_PRODUCTVERSION_W < 0x0500

// Recreate all the stuff in NT5 that didn't exist in NT4.

typedef ULONG ULONG_PTR, *PULONG_PTR;

//
// Define alignment macros to align structure sizes and pointers up and down.
//

#ifndef ALIGN_DOWN
#define ALIGN_DOWN(length, type) \
    ((ULONG)(length) & ~(sizeof(type) - 1))
#endif

#ifndef ALIGN_UP
#define ALIGN_UP(length, type) \
    (ALIGN_DOWN(((ULONG)(length) + sizeof(type) - 1), type))
#endif

#ifndef ALIGN_DOWN_POINTER
#define ALIGN_DOWN_POINTER(address, type) \
    ((PVOID)((ULONG_PTR)(address) & ~((ULONG_PTR)sizeof(type) - 1)))
#endif

#ifndef ALIGN_UP_POINTER
#define ALIGN_UP_POINTER(address, type) \
    (ALIGN_DOWN_POINTER(((ULONG_PTR)(address) + sizeof(type) - 1), type))
#endif

//
//  PnP and PM OIDs
//
#ifndef OID_PNP_CAPABILITIES
#define OID_PNP_CAPABILITIES                    0xFD010100
#endif
#ifndef OID_PNP_SET_POWER
#define OID_PNP_SET_POWER                       0xFD010101
#endif
#ifndef OID_PNP_QUERY_POWER
#define OID_PNP_QUERY_POWER                     0xFD010102
#endif
#ifndef OID_PNP_ADD_WAKE_UP_PATTERN
#define OID_PNP_ADD_WAKE_UP_PATTERN             0xFD010103
#endif
#ifndef OID_PNP_REMOVE_WAKE_UP_PATTERN
#define OID_PNP_REMOVE_WAKE_UP_PATTERN          0xFD010104
#endif
#ifndef OID_PNP_WAKE_UP_PATTERN_LIST
#define OID_PNP_WAKE_UP_PATTERN_LIST            0xFD010105
#endif
#ifndef OID_PNP_ENABLE_WAKE_UP
#define OID_PNP_ENABLE_WAKE_UP                  0xFD010106
#endif
#ifndef OID_GEN_SUPPORTED_GUIDS
#define OID_GEN_SUPPORTED_GUIDS                 0x00010117
#endif
#ifndef NDIS_ATTRIBUTE_NO_HALT_ON_SUSPEND
#define NDIS_ATTRIBUTE_NO_HALT_ON_SUSPEND       0 // So it can't mess up NDIS
#endif
typedef enum _NDIS_DEVICE_POWER_STATE
{
    NdisDeviceStateUnspecified = 0,
    NdisDeviceStateD0,
    NdisDeviceStateD1,
    NdisDeviceStateD2,
    NdisDeviceStateD3,
    NdisDeviceStateMaximum
} NDIS_DEVICE_POWER_STATE, *PNDIS_DEVICE_POWER_STATE;
typedef struct _NDIS_PM_WAKE_UP_CAPABILITIES
{
    NDIS_DEVICE_POWER_STATE MinMagicPacketWakeUp;
    NDIS_DEVICE_POWER_STATE MinPatternWakeUp;
    NDIS_DEVICE_POWER_STATE MinLinkChangeWakeUp;
} NDIS_PM_WAKE_UP_CAPABILITIES, *PNDIS_PM_WAKE_UP_CAPABILITIES;
typedef struct _NDIS_PNP_CAPABILITIES
{
    ULONG                           Flags;
    NDIS_PM_WAKE_UP_CAPABILITIES    WakeUpCapabilities;
} NDIS_PNP_CAPABILITIES, *PNDIS_PNP_CAPABILITIES;

#define NdisWanMediumPPTP NdisWanMediumSerial

#endif


#endif //OSINC_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ndis\raspptp\nt\thread.c ===
//depot/Lab03_N/Net/rras/ndis/raspptp/nt/thread.c#6 - edit change 19457 (text)
/*******************************************************************
*
*   Copyright (c) 1998-1999 Microsoft Corporation
*
*    DESCRIPTION: THREAD.C - Thread handling routines, for NT
*                 Also implements work items.
*
*    AUTHOR: Stan Adermann (StanA)
*
*    DATE:10/20/1998
*
*******************************************************************/

#include "raspptp.h"
#include <stdarg.h>
#include <stdio.h>

extern struct PPTP_ADAPTER * pgAdapter;

//ULONG ProcCountTxQ[2] = {0, 0};
//ULONG ProcCountRxQ[2] = {0, 0};

HANDLE          hPassiveThread = NULL;
KEVENT          EventPassiveThread;
KEVENT          EventKillThread;
LIST_ENTRY      WorkItemList;
NDIS_SPIN_LOCK  GlobalThreadLock;

BOOLEAN ThreadingInitialized = FALSE;

NDIS_STATUS
ScheduleWorkItem(
    WORK_PROC         Callback,
    PVOID             Context,
    PVOID             InfoBuf,
    ULONG             InfoBufLen)
{
    PPPTP_WORK_ITEM pWorkItem;
    NDIS_STATUS Status = NDIS_STATUS_FAILURE;

    DEBUGMSG(DBG_FUNC, (DTEXT("+ScheduleWorkItem\n")));

    ASSERT(ThreadingInitialized);
    pWorkItem = MyMemAlloc(sizeof(PPTP_WORK_ITEM), TAG_WORK_ITEM);

    if (pWorkItem != NULL)
    {
        pWorkItem->Context      = Context;
        pWorkItem->pBuffer      = InfoBuf;
        pWorkItem->Length       = InfoBufLen;

        /*
        ** This interface was designed to use NdisScheduleWorkItem(), which
        ** would be good except that we're really only supposed to use that
        ** interface during startup and shutdown, due to the limited pool of
        ** threads available to service NdisScheduleWorkItem().  Therefore,
        ** instead of scheduling real work items, we simulate them, and use
        ** our own thread to process the calls.  This also makes it easy to
        ** expand the size of our own thread pool, if we wish.
        **
        ** Our version is slightly different from actual NDIS_WORK_ITEMs,
        ** because that is an NDIS 5.0 structure, and we want people to
        ** (at least temporarily) build this with NDIS 4.0 headers.
        */

        pWorkItem->Callback = Callback;

        /*
        ** Our worker thread checks this list for new jobs, whenever its event
        ** is signalled.
        */

        MyInterlockedInsertTailList(&WorkItemList,
                                    &pWorkItem->ListEntry,
                                    &GlobalThreadLock);

        // Wake up our thread.

        KeSetEvent(&EventPassiveThread, 0, FALSE);
        Status = NDIS_STATUS_SUCCESS;
    }
    else
    {
        gCounters.ulWorkItemFail++;
    
    }

    return Status;
}

STATIC VOID
MainPassiveLevelThread(
    IN OUT PVOID Context
    )
{
    NDIS_STATUS Status;
    NTSTATUS    NtStatus;
    PLIST_ENTRY pListEntry;
    PKEVENT EventList[2];

    DEBUGMSG(DBG_FUNC, (DTEXT("+MainPassiveLevelThread\n")));

    //KeSetPriorityThread(KeGetCurrentThread(), LOW_REALTIME_PRIORITY);

    EventList[0] = &EventPassiveThread;
    EventList[1] = &EventKillThread;

    for (;;)
    {
        //
        // The EventPassiveThread is an auto-clearing event, so
        // we don't need to reset the event.
        //

        NtStatus = KeWaitForMultipleObjects(2,
                                            EventList,
                                            WaitAny,
                                            Executive,
                                            KernelMode,
                                            FALSE,
                                            NULL,
                                            NULL);

        if (NtStatus==0) // The first event, for a work item, was signalled
        {
            while (pListEntry = MyInterlockedRemoveHeadList(&WorkItemList,
                                                            &GlobalThreadLock))
            {
                PPPTP_WORK_ITEM pWorkItem = CONTAINING_RECORD(pListEntry,
                                                              PPTP_WORK_ITEM,
                                                              ListEntry);

                ASSERT(KeGetCurrentIrql()<DISPATCH_LEVEL);
                pWorkItem->Callback(pWorkItem);
                ASSERT(KeGetCurrentIrql()<DISPATCH_LEVEL);
                FreeWorkItem(pWorkItem);
            }
        }
        else
        {
            // A kill event was received.

            DEBUGMSG(DBG_THREAD, (DTEXT("Thread: HALT %08x\n"), NtStatus));

            // Free any pending requests

            while (pListEntry = MyInterlockedRemoveHeadList(&WorkItemList,
                                                            &GlobalThreadLock))
            {
                PPPTP_WORK_ITEM pWorkItem = CONTAINING_RECORD(pListEntry,
                                                              PPTP_WORK_ITEM,
                                                              ListEntry);

                DEBUGMSG(DBG_WARN, (DTEXT("Releasing work item %08x\n"), pWorkItem));
                FreeWorkItem(pWorkItem);
            }

            hPassiveThread = NULL;
            DEBUGMSG(DBG_FUNC, (DTEXT("PsTerminateSystemThread MainPassiveLevelThread\n")));
            PsTerminateSystemThread(STATUS_SUCCESS);

            break;
        }
    }

    DEBUGMSG(DBG_FUNC, (DTEXT("-MainPassiveLevelThread\n")));
}


NDIS_STATUS
CallQueueTransmitPacket(
    PCALL_SESSION       pCall,
    PNDIS_WAN_PACKET    pWanPacket
    )
{
    NDIS_STATUS Status = NDIS_STATUS_PENDING;

    DEBUGMSG(DBG_FUNC, (DTEXT("+CallQueueTransmitPacket\n")));

    //++ProcCountTxQ[KeGetCurrentProcessorNumber()];

    if (!IS_CALL(pCall) || pCall->State!=STATE_CALL_ESTABLISHED)
    {
        // Drop the packet.
        Status = NDIS_STATUS_SUCCESS;
        goto cqtpDone;
    }

    NdisAcquireSpinLock(&pCall->Lock);

    InsertTailList(&pCall->TxPacketList, &pWanPacket->WanPacketQueue);

    if (!pCall->Transferring)
    {
        pCall->Transferring = TRUE;
        REFERENCE_OBJECT(pCall);
        NdisScheduleWorkItem(&pCall->SendWorkItem);
    }

    NdisReleaseSpinLock(&pCall->Lock);

cqtpDone:

    DEBUGMSG(DBG_FUNC, (DTEXT("-CallQueueTransmitPacket\n")));
    return Status;
}

NDIS_STATUS
CallQueueReceivePacket(
    PCALL_SESSION       pCall,
    PDGRAM_CONTEXT      pDgContext
    )
{
    NDIS_STATUS Status = NDIS_STATUS_SUCCESS;
    PGRE_HEADER pGre = pDgContext->pGreHeader;
    ULONG_PTR ProcNum = 0;
    PULONG pSequence;
    ULONG Sequence;

    DEBUGMSG(DBG_FUNC, (DTEXT("+CallQueueReceivePacket\n")));

    //++ProcCountRxQ[KeGetCurrentProcessorNumber()];

    if(!pGre->SequenceNumberPresent)
    {
        return NDIS_STATUS_FAILURE;
    }

    NdisAcquireSpinLock(&pCall->Lock);
    if (pCall->RxPacketsPending > 256 ||
        htons(pGre->KeyCallId)!=pCall->Packet.CallId ||
        pCall->State!=STATE_CALL_ESTABLISHED ||
        !IS_LINE_UP(pCall))
    {
        NdisReleaseSpinLock(&pCall->Lock);

        DEBUGMSG(DBG_PACKET|DBG_RX, (DTEXT("Rx: GRE CallId invalid or call in wrong state\n")));
        Status = NDIS_STATUS_FAILURE;
        goto cqrpDone;
    }

    // The packet has passed all of our tests.

    if (IsListEmpty(&pCall->RxPacketList))
    {
        InsertTailList(&pCall->RxPacketList, &pDgContext->ListEntry);
        pCall->RxPacketsPending++;
    }
    else
    {
        // There are packets already queued.  Put this one in order.
        pSequence = (PULONG)(pGre + 1);
        Sequence = htonl(*pSequence);

        // We don't check the sequence # anymore, just put it on the queue in order
        {

            // There are packets already queued.  Put this one in order.
            // The sequence # is the one we want soon to be the one we want.
            PLIST_ENTRY pListEntry;
            BOOLEAN OnList = FALSE;
    
            for (pListEntry = pCall->RxPacketList.Flink;
                 pListEntry != &pCall->RxPacketList;
                 pListEntry = pListEntry->Flink)
            {
                PDGRAM_CONTEXT pListDg = CONTAINING_RECORD(pListEntry,
                                                           DGRAM_CONTEXT,
                                                           ListEntry);
    
                if ((signed)htonl(GreSequence(pListDg->pGreHeader)) - (signed)Sequence > 0)
                {
                    // The one on the list is newer!  Put this one before it.
                    InsertTailList(&pListDg->ListEntry, &pDgContext->ListEntry);
                    pCall->RxPacketsPending++;
                    OnList = TRUE;
                    break;
                }
            }
            if (!OnList)
            {
                // There were no packets on this list with a greater sequence.
                // Put this at the end.
                InsertTailList(&pCall->RxPacketList, &pDgContext->ListEntry);
                pCall->RxPacketsPending++;
            }
        }
    }
    
    if (!pCall->Receiving)
    {
        pCall->Receiving = TRUE;
        REFERENCE_OBJECT(pCall);
        NdisScheduleWorkItem(&pCall->RecvWorkItem);

//        PptpQueueDpc(&pCall->ReceiveDpc);
    }

    NdisReleaseSpinLock(&pCall->Lock);

cqrpDone:
    DEBUGMSG(DBG_FUNC, (DTEXT("-CallQueueReceivePacket\n")));
    return Status;
}


NDIS_STATUS
InitThreading(
    NDIS_HANDLE hMiniportAdapter
    )
{
    NDIS_STATUS Status = NDIS_STATUS_SUCCESS;
    NTSTATUS NtStatus;

    UNREFERENCED_PARAMETER(hMiniportAdapter);

    DEBUGMSG(DBG_FUNC, (DTEXT("+InitializeThreading\n")));

    if (ThreadingInitialized)
    {
       ASSERT(!"Threading initialized twice");
       goto itDone;
    }

    NdisInitializeListHead(&WorkItemList);
    NdisAllocateSpinLock(&GlobalThreadLock);

    KeInitializeEvent(
                &EventPassiveThread,
                SynchronizationEvent, // auto-clearing event
                FALSE                 // event initially non-signalled
                );

    KeInitializeEvent(
                &EventKillThread,
                SynchronizationEvent, // auto-clearing event
                FALSE                 // event initially non-signalled
                );

    NtStatus = PsCreateSystemThread(&hPassiveThread,
                                    (ACCESS_MASK) 0L,
                                    NULL,
                                    NULL,
                                    NULL,
                                    MainPassiveLevelThread,
                                    NULL);
                                    
                                    
    if (NtStatus == STATUS_SUCCESS)
    {
        ThreadingInitialized = TRUE;
    }
    else
    {
        DEBUGMSG(DBG_ERROR, (DTEXT("PsCreateSystemThread failed. %08x\n"), Status));
        Status = NDIS_STATUS_FAILURE;

        goto itDone;
    }

itDone:
    DEBUGMSG(DBG_FUNC, (DTEXT("-InitializeThreading %08x\n"), Status));
    return Status;
}

VOID STATIC WaitForThreadToDieAndCloseIt(HANDLE hThread, PRKEVENT pKillEvent)
{
    PVOID pThread = NULL;
    NTSTATUS Status;
    
    DEBUGMSG(DBG_FUNC, (DTEXT("+WaitForThreadToDie\n")));

    if ( hThread != NULL && pKillEvent != NULL )
    {

        Status = ObReferenceObjectByHandle(hThread, 0, NULL, KernelMode, &pThread, NULL);
        if (Status==STATUS_SUCCESS)
        {
            KeSetEvent(pKillEvent, 0, FALSE);
    
            KeWaitForSingleObject(pThread, Executive, KernelMode, FALSE, NULL);
            ObDereferenceObject(pThread);
        }
        ZwClose(hThread);
    }
    
    DEBUGMSG(DBG_FUNC, (DTEXT("-WaitForThreadToDie\n")));
}

VOID
DeinitThreading()
{
    DEBUGMSG(DBG_FUNC, (DTEXT("+DeinitThreading\n")));
    
    ThreadingInitialized = FALSE;
    
    WaitForThreadToDieAndCloseIt( hPassiveThread, 
                                  &EventKillThread );

    DEBUGMSG(DBG_FUNC, (DTEXT("-DeinitThreading\n")));
}


UCHAR TapiLineNameBuffer[64] =  TAPI_LINE_NAME_STRING;
ANSI_STRING TapiLineName = {
    sizeof(TAPI_LINE_NAME_STRING),
    sizeof(TapiLineNameBuffer),
    TapiLineNameBuffer
};
typedef UCHAR TAPI_CHAR_TYPE;

ANSI_STRING TapiLineAddrList = { 0, 0, NULL };

#define READ_NDIS_REG_ULONG(hConfig, Var, Value) \
    {                                                                                   \
        PNDIS_CONFIGURATION_PARAMETER RegValue;                                         \
        NDIS_STATUS Status;                                                             \
        NDIS_STRING String = NDIS_STRING_CONST(Value);                                  \
                                                                                        \
        NdisReadConfiguration(&Status,                                                  \
                              &RegValue,                                                \
                              hConfig,                                                  \
                              &String,                                                  \
                              NdisParameterInteger);                                    \
        if (Status==NDIS_STATUS_SUCCESS)                                                \
        {                                                                               \
            (Var) = RegValue->ParameterData.IntegerData;                                \
            DEBUGMSG(DBG_INIT, (DTEXT(#Var"==%d\n"), (Var)));                           \
        }                                                                               \
        else                                                                            \
        {                                                                               \
            DEBUGMSG(DBG_INIT, (DTEXT(Value", default==%d\n"), (Var)));\
        }                                                                               \
    }

#define READ_NDIS_REG_USHORT(hConfig, Var, Value) \
    {                                                                                   \
        PNDIS_CONFIGURATION_PARAMETER RegValue;                                         \
        NDIS_STATUS Status;                                                             \
        NDIS_STRING String = NDIS_STRING_CONST(Value);                                  \
                                                                                        \
        NdisReadConfiguration(&Status,                                                  \
                              &RegValue,                                                \
                              hConfig,                                                  \
                              &String,                                                  \
                              NdisParameterInteger);                                    \
        if (Status==NDIS_STATUS_SUCCESS)                                                \
        {                                                                               \
            (Var) = (USHORT)(RegValue->ParameterData.IntegerData&0xffff);               \
            DEBUGMSG(DBG_INIT, (DTEXT(#Var"==%d\n"), (Var)));                           \
        }                                                                               \
        else                                                                            \
        {                                                                               \
            DEBUGMSG(DBG_INIT, (DTEXT(Value", default==%d\n"), (Var)));\
        }                                                                               \
    }

#define READ_NDIS_REG_BOOL(hConfig, Var, Value) \
    {                                                                                   \
        PNDIS_CONFIGURATION_PARAMETER RegValue;                                         \
        NDIS_STATUS Status;                                                             \
        NDIS_STRING String = NDIS_STRING_CONST(Value);                                  \
                                                                                        \
        NdisReadConfiguration(&Status,                                                  \
                              &RegValue,                                                \
                              hConfig,                                                  \
                              &String,                                                  \
                              NdisParameterInteger);                                    \
        if (Status==NDIS_STATUS_SUCCESS)                                                \
        {                                                                               \
            (Var) = RegValue->ParameterData.IntegerData ? TRUE : FALSE;                 \
            DEBUGMSG(DBG_INIT, (DTEXT(#Var"==%d\n"), (Var)));                           \
        }                                                                               \
        else                                                                            \
        {                                                                               \
            DEBUGMSG(DBG_INIT, (DTEXT(Value", default==%d\n"), (Var)));\
        }                                                                               \
    }
    

ULONG ReadClientAddressAndMaskList(
    IN NDIS_HANDLE hConfig,
    IN PNDIS_STRING IpAddressesString,
    IN PNDIS_STRING IpMasksString,
    IN OUT PCLIENT_ADDRESS *pClientAddressList
    )
    //
    // Read the IP addresses and masks in multi string formats
    //
{
    NDIS_STATUS Status = NDIS_STATUS_FAILURE;
    PNDIS_CONFIGURATION_PARAMETER Value = NULL;
    ULONG ulNumIpAddresses = 0;
    PCLIENT_ADDRESS ClientList = NULL;
    
    *pClientAddressList = NULL;

    NdisReadConfiguration(&Status,  // Not required value
                          &Value,
                          hConfig,
                          IpAddressesString,
                          NdisParameterMultiString);
    if (Status==NDIS_STATUS_SUCCESS)
    {
    
        ULONG i, ulAddressIndex = 0;
        BOOLEAN InEntry, ValidAddress;
        PWCHAR AddressList = Value->ParameterData.StringData.Buffer;
        TA_IP_ADDRESS Address;

        // Loop and count the addresses, so we can allocate proper size to hold them.
        for (i=0, InEntry=FALSE; i<(Value->ParameterData.StringData.Length/sizeof(WCHAR))-1; i++)
        {
            if (!InEntry)
            {
                if (AddressList[i]!=L'\0')
                {
                    InEntry = TRUE;
                    StringToIpAddressW(&AddressList[i],
                                       &Address,
                                       &ValidAddress);
                    if (ValidAddress)
                    {
                        ulAddressIndex++;
                    }
                }
            }
            else
            {
                if (AddressList[i]==L'\0')
                {
                    InEntry = FALSE;
                }
            }
        }
        
        ulNumIpAddresses = ulAddressIndex;
        
        if (ulNumIpAddresses)
        {
            ClientList = MyMemAlloc(sizeof(CLIENT_ADDRESS)*ulNumIpAddresses, TAG_PPTP_ADDR_LIST);
            if (ClientList)
            {
                ulAddressIndex = 0;
                for (i=0, InEntry=FALSE; 
                    i<(Value->ParameterData.StringData.Length/sizeof(WCHAR))-1 && (ulAddressIndex < ulNumIpAddresses); 
                    i++)
                {
                    if (!InEntry)
                    {
                        if (AddressList[i]!=L'\0')
                        {
                            InEntry = TRUE;
                            StringToIpAddressW(&AddressList[i],
                                               &Address,
                                               &ValidAddress);
                            if (ValidAddress)
                            {
                                ClientList[ulAddressIndex].Address = Address.Address[0].Address[0].in_addr;
                                ClientList[ulAddressIndex].Mask = 0xFFFFFFFF;
                                ulAddressIndex++;
                            }
                        }
                    }
                    else
                    {
                        if (AddressList[i]==L'\0')
                        {
                            InEntry = FALSE;
                        }
                    }
                }
                
                NdisReadConfiguration(&Status,      // Not required value
                                      &Value,
                                      hConfig,
                                      IpMasksString,
                                      NdisParameterMultiString);
                if (Status==NDIS_STATUS_SUCCESS)
                {
                    AddressList = Value->ParameterData.StringData.Buffer;
                    ulAddressIndex = 0;
                    for (i=0, InEntry=FALSE;
                         i<(Value->ParameterData.StringData.Length/sizeof(WCHAR))-1 && (ulAddressIndex < ulNumIpAddresses);
                         i++)
                    {
                        if (!InEntry)
                        {
                            if (AddressList[i]!=L'\0')
                            {
                                InEntry = TRUE;
                                StringToIpAddressW(&AddressList[i],
                                                   &Address,
                                                   &ValidAddress);
                                if (ValidAddress)
                                {
                                    ClientList[ulAddressIndex].Mask = Address.Address[0].Address[0].in_addr;
                                    ulAddressIndex++;
                                }
                            }
                        }
                        else
                        {
                            if (AddressList[i]==L'\0')
                            {
                                InEntry = FALSE;
                            }
                        }
                    }
                }
                
                for (i=0; i<ulNumIpAddresses; i++)
                {
                    DEBUGMSG(DBG_INIT, (DTEXT("Client Address:%d.%d.%d.%d  Mask:%d.%d.%d.%d\n"),
                                        IPADDR(ClientList[i].Address), IPADDR(ClientList[i].Mask)));
                }
            }
            else
            {
                ulNumIpAddresses = 0;
            }
        }
    }
    
    if(ulNumIpAddresses)
    {
        *pClientAddressList = ClientList;
    }
    else
    {
        ASSERT(ClientList == NULL);
    }
    
    return ulNumIpAddresses;
}

    

VOID
OsReadConfig(
    NDIS_HANDLE hConfig
    )
{
    NDIS_STATUS Status = NDIS_STATUS_SUCCESS;
    PNDIS_CONFIGURATION_PARAMETER Value;
    
    NDIS_STRING TapiLineNameString = NDIS_STRING_CONST("TapiLineName");
#if VER_PRODUCTVERSION_W < 0x0500
    NDIS_STRING TapiLineAddrString = NDIS_STRING_CONST("AddressList");
#endif
    NDIS_STRING PeerClientIpAddressString = NDIS_STRING_CONST("ClientIpAddresses");
    NDIS_STRING PeerClientIpMaskString = NDIS_STRING_CONST("ClientIpMasks");
    
    NDIS_STRING TrustedIpAddressString = NDIS_STRING_CONST("TrustedIpAddresses");
    NDIS_STRING TrustedIpMaskString = NDIS_STRING_CONST("TrustedIpMasks");
                                                              
    DEBUGMSG(DBG_FUNC, (DTEXT("+OsReadConfig\n")));

    READ_NDIS_REG_USHORT(hConfig, PptpControlPort,                  "TcpPortNumber");
    READ_NDIS_REG_ULONG (hConfig, PptpWanEndpoints,                 "MaxWanEndpoints");
    READ_NDIS_REG_ULONG (hConfig, PptpBaseCallId,                   "BaseCallId");
    READ_NDIS_REG_ULONG (hConfig, PptpMaxTransmit,                  "MaxTransmit");
    READ_NDIS_REG_ULONG (hConfig, PptpEchoTimeout,                  "InactivityIdleSeconds");
    READ_NDIS_REG_BOOL  (hConfig, PptpEchoAlways,                   "AlwaysEcho");
    READ_NDIS_REG_ULONG (hConfig, CtdiTcpDisconnectTimeout,         "TcpDisconnectTimeout");
    READ_NDIS_REG_ULONG (hConfig, CtdiTcpConnectTimeout,            "TcpConnectTimeout");
    READ_NDIS_REG_BOOL  (hConfig, PptpAuthenticateIncomingCalls,    "AuthenticateIncomingCalls");
    READ_NDIS_REG_ULONG (hConfig, PptpTraceMask,                    "PptpTraceMask");
    READ_NDIS_REG_ULONG (hConfig, PptpValidateAddress,              "ValidateAddress");
    READ_NDIS_REG_ULONG (hConfig, PptpMaxTunnelsPerIpAddress,       "MaxTunnelsPerIpAddress");
    
    // Validate some reg values
    if(PptpWanEndpoints == 0)
    {
        PptpWanEndpoints = OS_DEFAULT_WAN_ENDPOINTS;
    }
    if(PptpMaxTunnelsPerIpAddress > PptpWanEndpoints)
    {
        PptpMaxTunnelsPerIpAddress = -1;
    }

    OS_RANGE_CHECK_ENDPOINTS(PptpWanEndpoints, PptpBaseCallId);
    OS_RANGE_CHECK_MAX_TRANSMIT(PptpMaxTransmit);

    // Read client IP addresses/masks to accept (old behavior)  
    if(PptpAuthenticateIncomingCalls)
    {
        DEBUGMSG(DBG_INIT, (DTEXT("Accept IP Addresses/Masks\n")));
        g_ulAcceptClientAddresses = ReadClientAddressAndMaskList(
                hConfig,
                &PeerClientIpAddressString,
                &PeerClientIpMaskString,
                &g_AcceptClientList);
    }
    
    // Read trusted client IP addresses/masks
    DEBUGMSG(DBG_INIT, (DTEXT("Trsuted IP Addresses/Masks\n")));
    g_ulTrustedClientAddresses = ReadClientAddressAndMaskList(
        hConfig,
        &TrustedIpAddressString,
        &TrustedIpMaskString,
        &g_TrustedClientList);
            
    NdisReadConfiguration(&Status,  // Not required value
                          &Value,
                          hConfig,
                          &TapiLineNameString,
                          NdisParameterString);
    if (Status==NDIS_STATUS_SUCCESS)
    {
        RtlUnicodeStringToAnsiString(&TapiLineName, &Value->ParameterData.StringData, FALSE);
        *(TAPI_CHAR_TYPE*)(TapiLineName.Buffer+TapiLineName.MaximumLength-sizeof(TAPI_CHAR_TYPE)) = (TAPI_CHAR_TYPE)0;
    }

#if VER_PRODUCTVERSION_W < 0x0500
    NdisReadConfiguration(&Status,  // Not required value
                          &Value,
                          hConfig,
                          &TapiLineAddrString,
                          NdisParameterMultiString);
    if (Status==NDIS_STATUS_SUCCESS)
    {
        RtlInitAnsiString( &TapiLineAddrList, NULL );
        if (RtlUnicodeStringToAnsiString(&TapiLineAddrList, &Value->ParameterData.StringData, TRUE)==NDIS_STATUS_SUCCESS)
        {
            // NT4 doesn't have the same registry value to tell us how many lines to publish.
            // We work around that by counting the number of address strings here

            PUCHAR p = TapiLineAddrList.Buffer;

            DEBUGMEM(DBG_TAPI, TapiLineAddrList.Buffer, TapiLineAddrList.Length, 1);
            PptpWanEndpoints = 0;
            if (p)
            {
                // Count the valid MULTI_SZ entries.
                while (*p++)
                {
                    PptpWanEndpoints++;
                    while (*p++);  // This also skips the first NULL
                }
            }
            DBG_D(DBG_INIT, PptpWanEndpoints);
        }

    }
#endif

    DEBUGMSG(DBG_FUNC, (DTEXT("-OsReadConfig\n")));
}

#if 0
VOID OsGetFullHostName(VOID)
{
    NTSTATUS status;
    OBJECT_ATTRIBUTES objattr;
    UNICODE_STRING uni;
    HANDLE hParams;
    KEY_VALUE_PARTIAL_INFORMATION* pNameValue;
    ULONG ulAllocSize, ulSize, ulIndex, ulDomainIndex;

    hParams = NULL;
    pNameValue = NULL;
    
    NdisZeroMemory(PptpHostName, MAX_HOSTNAME_LENGTH);

    do
    {
        // Get a handle to the TCPIP Parameters registry key.
        RtlInitUnicodeString(
            &uni,
            L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\Tcpip\\Parameters" );
        InitializeObjectAttributes(
            &objattr, &uni, OBJ_CASE_INSENSITIVE, NULL, NULL );

        status = ZwOpenKey(&hParams, KEY_QUERY_VALUE, &objattr);
        if (status != STATUS_SUCCESS)
        {
            break;
        }

        ulAllocSize = sizeof(KEY_VALUE_PARTIAL_INFORMATION) + MAX_HOSTNAME_LENGTH * 2;
        // Query the "Hostname" registry value.
        pNameValue = MyMemAlloc(ulAllocSize, TAG_REG);
        if (!pNameValue)
        {
            break;
        }

        RtlInitUnicodeString( &uni, L"Hostname");
        status = ZwQueryValueKey(
            hParams, &uni, KeyValuePartialInformation,
            pNameValue, ulAllocSize, &ulSize );
        if (status != STATUS_SUCCESS || pNameValue->Type != REG_SZ || pNameValue->DataLength < sizeof(WCHAR) * 2)
        {
            break;
        }
        
        // Convert host unicode to ASCII, put it in PptpHostName;
        ulSize = min(pNameValue->DataLength/2, MAX_HOSTNAME_LENGTH);
        for(ulIndex = 0; ulIndex < ulSize; ulIndex++)
        {
            PptpHostName[ulIndex] = pNameValue->Data[ulIndex*2];
        }
        
        // Query the "Domain" registry value.
        RtlInitUnicodeString( &uni, L"Domain");
        status = ZwQueryValueKey(
            hParams, &uni, KeyValuePartialInformation,
            pNameValue, ulAllocSize, &ulSize );

        // Convert domain unicode to ASCII, append it in PptpHostName;
        if (status == STATUS_SUCCESS
            && pNameValue->Type == REG_SZ
            && pNameValue->DataLength > sizeof(WCHAR)
            && ((WCHAR* )pNameValue->Data)[ 0 ] != L'\0')
        {
            PptpHostName[--ulIndex] = '.';
            ++ulIndex;
            
            for(ulDomainIndex = 0; 
                ulIndex < MAX_HOSTNAME_LENGTH && ulDomainIndex < pNameValue->DataLength/2; 
                ulIndex++, ulDomainIndex++)
            {
                PptpHostName[ulIndex] = pNameValue->Data[ulDomainIndex*2];
            }
        }
        
        PptpHostName[MAX_HOSTNAME_LENGTH -1] = '\0';
    }
    while (FALSE);

    if(hParams)
    {
        ZwClose(hParams);
    }

    if(pNameValue)
    {
        MyMemFree(pNameValue, sizeof(KEY_VALUE_PARTIAL_INFORMATION) + MAX_HOSTNAME_LENGTH * 2);
    }
}

#endif

VOID
OsGetTapiLineAddress(ULONG Index, PUCHAR s, ULONG Length)
{
    ASSERT(Length);

#if VER_PRODUCTVERSION_W < 0x0500
    PUCHAR pAddr = TapiLineAddrList.Buffer;

    *s = 0;

    if (pAddr)
    {
        UINT i;

        for (i=0; i<Index; i++)
        {
            if (!*pAddr)
            {
                // No string at index
                return;
            }
            while (*pAddr) pAddr++;
            pAddr++;
        }
        strncpy(s, pAddr, Length);
        s[Length-1] = 0;
    }
#else // VER_PRODUCTVERSION_W >= 0x0500
    strncpy(s, TAPI_LINE_ADDR_STRING, Length);
    s[Length-1] = 0;
#endif
}

NDIS_STATUS
OsSpecificTapiGetDevCaps(
    ULONG_PTR ulDeviceId,
    IN OUT PNDIS_TAPI_GET_DEV_CAPS pRequest
    )
{
    PUCHAR pTmp, pTmp2;
    ULONG_PTR Index;

    DEBUGMSG(DBG_FUNC, (DTEXT("+OsSpecificTapiGetDevCaps\n")));

    // Convert to our internal index
    ulDeviceId -= pgAdapter->Tapi.DeviceIdBase;

    pRequest->LineDevCaps.ulStringFormat = STRINGFORMAT_ASCII;


    // The *6 at the end adds enough space for " 9999"
    pRequest->LineDevCaps.ulNeededSize   = sizeof(pRequest->LineDevCaps) +
                                           sizeof(TAPI_PROVIDER_STRING) +
                                           TapiLineName.Length +
                                           sizeof(TAPI_CHAR_TYPE) * 6;

    if (pRequest->LineDevCaps.ulTotalSize<pRequest->LineDevCaps.ulNeededSize)
    {
        DEBUGMSG(DBG_FUNC|DBG_WARN, (DTEXT("-TapiGetDevCaps NDIS_STATUS_SUCCESS without PROVIDER or LINE_NAME strings\n")));
        return NDIS_STATUS_SUCCESS;
    }

    // Tack the provider string to the end of the LineDevCaps structure.

    pRequest->LineDevCaps.ulProviderInfoSize = sizeof(TAPI_PROVIDER_STRING);
    pRequest->LineDevCaps.ulProviderInfoOffset = sizeof(pRequest->LineDevCaps);

    pTmp = ((PUCHAR)&pRequest->LineDevCaps) + sizeof(pRequest->LineDevCaps);
    NdisMoveMemory(pTmp, TAPI_PROVIDER_STRING, sizeof(TAPI_PROVIDER_STRING));

    pTmp += sizeof(TAPI_PROVIDER_STRING);

    // Tack on the LineName after the provider string.

    pRequest->LineDevCaps.ulLineNameSize = TapiLineName.Length + sizeof(TAPI_CHAR_TYPE);
    pRequest->LineDevCaps.ulLineNameOffset = pRequest->LineDevCaps.ulProviderInfoOffset +
                                             pRequest->LineDevCaps.ulProviderInfoSize;
    NdisMoveMemory(pTmp, TapiLineName.Buffer, TapiLineName.Length+sizeof(TAPI_CHAR_TYPE));

    while (*pTmp) pTmp++; // Find the NULL

    *pTmp++ = ' ';
    pRequest->LineDevCaps.ulLineNameSize++;

    // Put a number at the end of the string.

    if (ulDeviceId==0)
    {
        *pTmp++ = '0';
        *pTmp++ = '\0';
        pRequest->LineDevCaps.ulLineNameSize += 2;
    }
    else
    {
        Index = ulDeviceId;
        ASSERT(Index<100000);
        if(Index >= 100000)
        {
            // Index value is usually small, but just make sure it's within boundary
            Index = 99999;
        }
        pTmp2 = pTmp;
        while (Index)
        {
            *pTmp2++ = (UCHAR)((Index%10) + '0');
            Index /= 10;
            pRequest->LineDevCaps.ulLineNameSize++;
        }
        *pTmp2-- = '\0'; // Null terminate and point to the last digit.
        pRequest->LineDevCaps.ulLineNameSize++;
        // We put the number in backwards, now reverse it.
        while (pTmp<pTmp2)
        {
            UCHAR t = *pTmp;
            *pTmp++ = *pTmp2;
            *pTmp2-- = t;
        }
    }

    pRequest->LineDevCaps.ulUsedSize     = pRequest->LineDevCaps.ulNeededSize;

    DEBUGMSG(DBG_FUNC, (DTEXT("-OsSpecificTapiGetDevCaps\n")));
    return NDIS_STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ndis\raspti\bpool.h ===
// Copyright (c) 1997, Microsoft Corporation, all rights reserved
//
// bpool.h
// RAS L2TP WAN mini-port/call-manager driver
// Buffer pool management header
//
// 01/07/97 Steve Cobb, adapted from Gurdeep's WANARP code.


#ifndef _BPOOL_H_
#define _BPOOL_H_


//-----------------------------------------------------------------------------
// Data structures
//-----------------------------------------------------------------------------

// Buffer pool control block.  A buffer pool prevents fragmentation of the
// non-paged memory pool by allocating the memory for a group of buffers in a
// single contiguous block.  At user's option, the buffer pool routines may
// allocate a pool of NDIS_BUFFER buffer descriptors and associate each with
// the memory buffers sliced from the contiguous block.  This allows the
// buffer to be reused while the virtual->physical memory mapping to be
// performed once.  All necessary pool growth and shrinkage is handled
// internally.
//
typedef struct
_BUFFERPOOL
{
    // Size in bytes of an individual buffer in the pool.
    //
    ULONG ulBufferSize;

    // The optimal number of buffers to allocate in each buffer block.
    //
    ULONG ulBuffersPerBlock;

    // Maximum number of individual buffers that may be allocated in the
    // entire pool or 0 for unlimited.
    //
    ULONG ulMaxBuffers;

    // Current number of individual buffers allocated in the entire pool.
    //
    ULONG ulCurBuffers;

    // Garbage collection occurs after this many calls to FreeBufferToPool.
    //
    ULONG ulFreesPerCollection;

    // Number of calls to FreeBufferToPool since a garbage collection.
    //
    ULONG ulFreesSinceCollection;

    // Indicates an NDIS_BUFFER is to be associated with each individual
    // buffer in the pool.
    //
    BOOLEAN fAssociateNdisBuffer;

    // Memory identification tag for allocated blocks.
    //
    ULONG ulTag;

    // Head of the double linked list of BUFFERBLOCKHEADs.  Access to the list
    // is protected with 'lock' in this structure.
    //
    LIST_ENTRY listBlocks;

    // Head of the double linked list of free BUFFERHEADs.  Each BUFFERHEAD in
    // the list is ready to go, i.e. it preceeds it's already allocated memory
    // buffer and, if appropriate, has an NDIS_BUFFER associated with it.
    // Access to the list is protected by 'lock' in this structure.
    // Interlocked push/pop is not used because (a) the list of blocks and the
    // list of buffers must lock each other and (b) double links are necessary
    // for garbage collection.
    //
    LIST_ENTRY listFreeBuffers;

    // This lock protects this structure and both the list of blocks and the
    // list of buffers.
    //
    NDIS_SPIN_LOCK lock;
}
BUFFERPOOL;


// Header of a single block of buffers from a buffer pool.  The BUFFERHEAD of
// the first buffer immediately follows.
//
typedef struct
_BUFFERBLOCKHEAD
{
    // Link to the prev/next buffer block header in the buffer pool's list.
    //
    LIST_ENTRY linkBlocks;

    // NDIS's handle of the pool of NDIS_BUFFER descriptors associated with
    // this block, or NULL if none.  (Note: With the current NT implementation
    // of NDIS_BUFFER as MDL this is always NULL).
    //
    NDIS_HANDLE hNdisPool;

    // Back pointer to the buffer pool.
    //
    BUFFERPOOL* pPool;

    // Number of individual buffers in this block.
    //
    ULONG ulBuffers;

    // Number of individual buffers in this block on the free list.
    //
    ULONG ulFreeBuffers;
}
BUFFERBLOCKHEAD;


// Header of an individual buffer.  The buffer memory itself immediately
// follows.
//
typedef struct
_BUFFERHEAD
{
    // Links to prev/next buffer header in the buffer pool's free list.
    //
    LIST_ENTRY linkFreeBuffers;

    // Back link to owning buffer block header.
    //
    BUFFERBLOCKHEAD* pBlock;

    // NDIS buffer descriptor of this buffer.  This is NULL unless the pool is
    // initialized with the 'fAssociateNdisBuffer' option.
    //
    NDIS_BUFFER* pNdisBuffer;
}
BUFFERHEAD;


//-----------------------------------------------------------------------------
// Interface prototypes and inline definitions
//-----------------------------------------------------------------------------

VOID
InitBufferPool(
    OUT BUFFERPOOL* pPool,
    IN ULONG ulBufferSize,
    IN ULONG ulMaxBuffers,
    IN ULONG ulBuffersPerBlock,
    IN ULONG ulFreesPerCollection,
    IN BOOLEAN fAssociateNdisBuffer,
    IN ULONG ulTag );

BOOLEAN
FreeBufferPool(
    IN BUFFERPOOL* pPool );

CHAR*
GetBufferFromPool(
    IN BUFFERPOOL* pPool );

VOID
FreeBufferToPool(
    IN BUFFERPOOL* pPool,
    IN CHAR* pBuffer,
    IN BOOLEAN fGarbageCollection );

NDIS_BUFFER*
NdisBufferFromBuffer(
    IN CHAR* pBuffer );

ULONG
BufferSizeFromBuffer(
    IN CHAR* pBuffer );

NDIS_BUFFER*
PoolHandleForNdisCopyBufferFromBuffer(
    IN CHAR* pBuffer );


#endif // BPOOL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ndis\raspti\bpool.c ===
// Copyright (c) 1997, Microsoft Corporation, all rights reserved
//
// bpool.c
// RAS L2TP WAN mini-port/call-manager driver
// Buffer pool management routines
//
// 01/07/97 Steve Cobb, adapted from Gurdeep's WANARP code.


#include "ptiwan.h"


//-----------------------------------------------------------------------------
// Local prototypes (alphabetically)
//-----------------------------------------------------------------------------

CHAR*
AddBufferBlockToPool(
    IN BUFFERPOOL* pPool );

VOID
FreeUnusedBufferPoolBlocks(
    IN BUFFERPOOL* pPool );


//-----------------------------------------------------------------------------
// Interface routines
//-----------------------------------------------------------------------------

VOID
InitBufferPool(
    OUT BUFFERPOOL* pPool,
    IN ULONG ulBufferSize,
    IN ULONG ulMaxBuffers,
    IN ULONG ulBuffersPerBlock,
    IN ULONG ulFreesPerCollection,
    IN BOOLEAN fAssociateNdisBuffer,
    IN ULONG ulTag )

    // Initialize caller's buffer pool control block 'pPool'.  'UlBufferSize'
    // is the size in bytes of an individual buffer.  'UlMaxBuffers' is the
    // maximum number of buffers allowed in the entire pool or 0 for
    // unlimited.  'UlBuffersPerBlock' is the number of buffers to include in
    // each block of buffers.  'UlFreesPerCollection' is the number of
    // FreeBufferToPool calls until the next garbage collect scan, or 0 for
    // default.  'FAssociateNdisBuffer' is set if an NDIS_BUFFER should be
    // allocated and associated with each individual buffer.  'UlTag' is the
    // memory identification tag to use when allocating blocks.
    //
    // IMPORTANT: Caller's 'pPool' buffer must be protected from multiple
    //            access during this call.
    //
{
    pPool->ulBufferSize = ulBufferSize;
    pPool->ulMaxBuffers = ulMaxBuffers;
    pPool->ulBuffersPerBlock = ulBuffersPerBlock;
    pPool->ulFreesSinceCollection = 0;
    pPool->fAssociateNdisBuffer = fAssociateNdisBuffer;
    pPool->ulTag = ulTag;

    if (ulFreesPerCollection)
    {
        pPool->ulFreesPerCollection = ulFreesPerCollection;
    }
    else
    {
        // Calculate default garbage collection trigger.  Don't want to be too
        // aggressive here.
        //
        pPool->ulFreesPerCollection = 50 * pPool->ulBuffersPerBlock;
    }

    TRACE( TL_N, TM_Pool, ( "InitBp tag=$%08x buf=%d cnt=%d",
        pPool->ulTag, pPool->ulBufferSize, pPool->ulBuffersPerBlock ) );

    InitializeListHead( &pPool->listBlocks );
    InitializeListHead( &pPool->listFreeBuffers );
    NdisAllocateSpinLock( &pPool->lock );
}


BOOLEAN
FreeBufferPool(
    IN BUFFERPOOL* pPool )

    // Free up all resources allocated in buffer pool 'pPool'.  This is the
    // inverse of InitBufferPool.
    //
    // Returns true if successful, false if any of the pool could not be freed
    // due to outstanding packets.
    //
{
    BOOLEAN fSuccess;

    TRACE( TL_N, TM_Pool, ( "FreeBp" ) );

    NdisAcquireSpinLock( &pPool->lock );
    {
        FreeUnusedBufferPoolBlocks( pPool );
        fSuccess = (pPool->ulCurBuffers == 0);
    }
    NdisReleaseSpinLock( &pPool->lock );

    return fSuccess;
}


CHAR*
GetBufferFromPool(
    IN BUFFERPOOL* pPool )

    // Returns the address of the useable memory in an individual buffer
    // allocated from the pool 'pPool'.  The pool is expanded, if necessary,
    // but caller should still check for NULL return since the pool may have
    // been at maximum size.
    //
{
    LIST_ENTRY* pLink;
    BUFFERHEAD* pHead;
    CHAR* pBuffer;

    NdisAcquireSpinLock( &pPool->lock );
    {
        if (IsListEmpty( &pPool->listFreeBuffers ))
        {
            pLink = NULL;
        }
        else
        {
            pLink = RemoveHeadList( &pPool->listFreeBuffers );
            pHead = CONTAINING_RECORD( pLink, BUFFERHEAD, linkFreeBuffers );
            --pHead->pBlock->ulFreeBuffers;
        }
    }
    NdisReleaseSpinLock( &pPool->lock );

    if (pLink)
    {
        pBuffer = (CHAR* )(pHead + 1);
    }
    else
    {
        // The free list was empty.  Try to expand the pool.
        //
        pBuffer = AddBufferBlockToPool( pPool );
    }

    DBG_if (pBuffer)
    {
        pHead = (BUFFERHEAD* )(pBuffer - sizeof(BUFFERHEAD));
        TRACE( TL_N, TM_Pool, ( "GetBfp=$%p, %d free",
            pBuffer, pHead->pBlock->ulFreeBuffers ) );
    }
    DBG_else
    {
        TRACE( TL_A, TM_Pool, ( "GetBfp failed?" ) );
    }

    return pBuffer;
}


VOID
FreeBufferToPool(
    IN BUFFERPOOL* pPool,
    IN CHAR* pBuffer,
    IN BOOLEAN fGarbageCollection )

    // Returns 'pBuffer' to the pool of unused buffers 'pPool'.  'PBuffer'
    // must have been previously allocated with GetBufferFromPool.
    // 'FGarbageCollection' is set when the free should be considered for
    // purposes of garbage collection.  This is used by the AddBufferToPool
    // routine to avoid counting the initial "add" frees.  Normal callers
    // should set this flag.
    //
{
    BUFFERHEAD* pHead;

    pHead = ((BUFFERHEAD* )pBuffer) - 1;

    DBG_if (fGarbageCollection)
    {
        TRACE( TL_N, TM_Pool, ( "FreeBtoP($%0x) %d free",
            pBuffer, pHead->pBlock->ulFreeBuffers + 1 ) );
    }


    NdisAcquireSpinLock( &pPool->lock );
    {
        InsertHeadList( &pPool->listFreeBuffers, &pHead->linkFreeBuffers );
        ++pHead->pBlock->ulFreeBuffers;

        if (fGarbageCollection)
        {
            ++pPool->ulFreesSinceCollection;

            if (pPool->ulFreesSinceCollection >= pPool->ulFreesPerCollection)
            {
                // Time to collect garbage, i.e. free any blocks in the pool
                // not in use.
                //
                FreeUnusedBufferPoolBlocks( pPool );
                pPool->ulFreesSinceCollection = 0;
            }
        }
    }
    NdisReleaseSpinLock( &pPool->lock );
}


NDIS_BUFFER*
NdisBufferFromBuffer(
    IN CHAR* pBuffer )

    // Returns the NDIS_BUFFER associated with the buffer 'pBuffer' which was
    // obtained previously with GetBufferFromPool.
    //
{
    BUFFERHEAD* pHead;

    pHead = ((BUFFERHEAD* )pBuffer) - 1;
    return pHead->pNdisBuffer;
}


ULONG
BufferSizeFromBuffer(
    IN CHAR* pBuffer )

    // Returns the original size of the buffer 'pBuffer' which was obtained
    // previously with GetBufferFromPool.  This is useful for undoing
    // NdisAdjustBufferLength.
    //
{
    BUFFERHEAD* pHead;

    pHead = ((BUFFERHEAD* )pBuffer) - 1;
    return pHead->pBlock->pPool->ulBufferSize;
}


NDIS_BUFFER*
PoolHandleForNdisCopyBufferFromBuffer(
    IN CHAR* pBuffer )

    // Returns the handle of the pool from which the NDIS_BUFFER associated
    // with the buffer 'pBuffer' was obtained.  Caller may use the handle to
    // pass to NdisCopyBuffer, one such use per buffer at a time.
    //
{
    BUFFERHEAD* pHead;

    pHead = ((BUFFERHEAD* )pBuffer) - 1;
    return pHead->pBlock->hNdisPool;
}


//-----------------------------------------------------------------------------
// Local utility routines (alphabetically)
//-----------------------------------------------------------------------------

CHAR*
AddBufferBlockToPool(
    IN BUFFERPOOL* pPool )

    // Allocate a new buffer block and add it to the buffer pool 'pPool'.
    //
    // Returns the address of the usable memory of an individual buffer
    // allocated from the pool or NULL if none.
    //
{
    NDIS_STATUS status;
    BUFFERBLOCKHEAD* pNew;
    ULONG ulSize;
    ULONG ulCount;
    BOOLEAN fOk;
    BOOLEAN fAssociateNdisBuffer;
    CHAR* pReturn;

    TRACE( TL_A, TM_Pool, ( "AddBpBlock(%d+%d)",
        pPool->ulCurBuffers, pPool->ulBuffersPerBlock ) );

    fOk = FALSE;
    pNew = NULL;

    NdisAcquireSpinLock( &pPool->lock );
    {
        // Save this for reference after the lock is released.
        //
        fAssociateNdisBuffer = pPool->fAssociateNdisBuffer;

        do
        {
            if (pPool->ulMaxBuffers
                && pPool->ulCurBuffers >= pPool->ulMaxBuffers)
            {
                // No can do.  The pool's already at maximum size.
                //
                TRACE( TL_A, TM_Pool, ( "Bp maxed?" ) );
                break;
            }

            // Calculate the contiguous block's size and the number of buffers
            // it will hold.
            //
            ulCount = pPool->ulBuffersPerBlock;
            if (pPool->ulMaxBuffers)
            {
                if (ulCount > pPool->ulMaxBuffers - pPool->ulCurBuffers)
                    ulCount = pPool->ulMaxBuffers - pPool->ulCurBuffers;
            }
            ulSize = sizeof(BUFFERBLOCKHEAD) +
                (ulCount * (sizeof(BUFFERHEAD) + pPool->ulBufferSize));

            // Allocate the contiguous memory block for the BUFFERBLOCK header
            // and the individual buffers.
            //
            pNew = ALLOC_NONPAGED( ulSize, pPool->ulTag );
            if (!pNew)
            {
                TRACE( TL_A, TM_Pool, ( "Alloc BB?" ) );
                break;
            }

            /* Zero only the block header portion.
            */
            NdisZeroMemory( pNew, sizeof(BUFFERBLOCKHEAD) );

            if (fAssociateNdisBuffer)
            {
                // Allocate a pool of NDIS_BUFFER descriptors.
                //
                // Twice as many descriptors are allocated as buffers so
                // caller can use the PoolHandleForNdisCopyBufferFromBuffer
                // routine to obtain a pool handle to pass to the
                // NdisCopyBuffer used to trim the L2TP header from received
                // packets.  In the current NDIS implmentation on NT this does
                // nothing but return a NULL handle and STATUS_SUCCESS,
                // because NDIS_BUFFER's are just MDL's,
                // NdisAllocateBufferPool is basically a no-op, and for that
                // matter, NdisCopyBuffer doesn't really use the pool handle
                // it's passed.  It's cheap to stay strictly compliant here,
                // though, so we do that.
                //
                NdisAllocateBufferPool(
                    &status, &pNew->hNdisPool, ulCount * 2 );
                if (status != NDIS_STATUS_SUCCESS)
                {
                    TRACE( TL_A, TM_Pool, ( "AllocBp=$%p?", status ) );
                    break;
                }
            }

            // Fill in the back pointer to the pool.
            //
            pNew->pPool = pPool;

            // Link the new block.  At this point, all the buffers are
            // effectively "in use".  They are made available in the loop
            // below.
            //
            pNew->ulBuffers = ulCount;
            pPool->ulCurBuffers += ulCount;
            InsertHeadList( &pPool->listBlocks, &pNew->linkBlocks );

            fOk = TRUE;
        }
        while (FALSE);
    }
    NdisReleaseSpinLock( &pPool->lock );

    if (!fOk)
    {
        // Bailing, undo whatever succeeded.
        //
        if (pNew)
        {
            FREE_NONPAGED( pNew );
            if (pNew->hNdisPool)
            {
                NdisFreeBufferPool( pNew->hNdisPool );
            }
        }

        return NULL;
    }

    // Initialize each individual buffer slice and add it to the list of free
    // buffers.
    //
    {
        ULONG i;
        CHAR* pBuffer;
        BUFFERHEAD* pHead;

        pReturn = NULL;

        // For each slice of the block, where a slice consists of a BUFFERHEAD
        // and the buffer memory that immediately follows it...
        //
        for (i = 0, pHead = (BUFFERHEAD* )(pNew + 1);
             i < ulCount;
             ++i, pHead = (BUFFERHEAD* )
                      ((CHAR* )(pHead + 1) + pPool->ulBufferSize))
        {
            pBuffer = (CHAR* )(pHead + 1);

            InitializeListHead( &pHead->linkFreeBuffers );
            pHead->pBlock = pNew;
            pHead->pNdisBuffer = NULL;

            if (fAssociateNdisBuffer)
            {
                // Associate an NDIS_BUFFER descriptor from the pool we
                // allocated above.
                //
                NdisAllocateBuffer(
                    &status, &pHead->pNdisBuffer, pNew->hNdisPool,
                    pBuffer, pPool->ulBufferSize );

                if (status != NDIS_STATUS_SUCCESS)
                {
                    TRACE( TL_A, TM_Pool, ( "AllocB=$%p?", status ) );
                    continue;
                }
            }

            if (pReturn)
            {
                // Add the constructed buffer to the list of free buffers.
                // The 'FALSE' tells the garbage collection algorithm the
                // operation is an "add" rather than a "release" and should be
                // ignored.
                //
                FreeBufferToPool( pPool, pBuffer, FALSE );
            }
            else
            {
                // The first successfully constructed buffer is returned by
                // this routine.
                //
                pReturn = pBuffer;
            }
        }
    }

    return pReturn;
}


VOID
FreeUnusedBufferPoolBlocks(
    IN BUFFERPOOL* pPool )

    // Check if any of the blocks in pool 'pPool' are not in use, and if so,
    // free them.
    //
    // IMPORTANT: Caller must hold the pool lock.
    //
    // The MSDN doc says that no locks may be held while calling
    // NdisFreePacketXxx, but according to JameelH that is incorrect.
    //
{
    LIST_ENTRY* pLink;

    TRACE( TL_A, TM_Pool, ( "FreeUnusedBpBlocks" ) );

    // For each block in the pool...
    //
    pLink = pPool->listBlocks.Flink;
    while (pLink != &pPool->listBlocks)
    {
        LIST_ENTRY* pLinkNext;
        BUFFERBLOCKHEAD* pBlock;

        pLinkNext = pLink->Flink;

        pBlock = CONTAINING_RECORD( pLink, BUFFERBLOCKHEAD, linkBlocks );
        if (pBlock->ulFreeBuffers >= pBlock->ulBuffers)
        {

#if 1 // Assume all buffers are free at time of call.

            ULONG i;
            BUFFERHEAD* pHead;

            TRACE( TL_A, TM_Pool, ( "FreeBpBlock(%d-%d)",
                pPool->ulCurBuffers, pPool->ulBuffersPerBlock ) );

            // Found a block with no buffers in use.  Walk the buffer block
            // removing each buffer from the pool's free list and freeing any
            // associated NDIS_BUFFER descriptor.
            //
            for (i = 0, pHead = (BUFFERHEAD* )(pBlock + 1);
                 i < pBlock->ulBuffers;
                 ++i, pHead = (BUFFERHEAD* )
                      (((CHAR* )(pHead + 1)) + pPool->ulBufferSize))
            {
                RemoveEntryList( &pHead->linkFreeBuffers );

                if (pHead->pNdisBuffer)
                {
                    NdisFreeBuffer( pHead->pNdisBuffer );
                }
            }

#else  // Assume some buffers may not be free at time of call.

            LIST_ENTRY* pLink2;

            // Found a block with no buffers in use.  Walk the pool's free
            // list looking for buffers from this block.
            //
            TRACE( TL_A, TM_Pool, ( "FreeBpBlock(%d-%d)",
                pPool->ulCurBuffers, pPool->ulBuffersPerBlock ) );

            pLink2 = pPool->listFreeBuffers.Flink;
            while (pLink2 != &pPool->listFreeBuffers)
            {
                LIST_ENTRY* pLink2Next;
                BUFFERHEAD* pHead;

                pLink2Next = pLink2->Flink;

                pHead = CONTAINING_RECORD( pLink2, BUFFERHEAD, linkFreeBuffers );
                if (pHead->pBlock == pBlock)
                {
                    // Found a buffer from the unused block.  Remove it.
                    //
                    RemoveEntryList( pLink2 );
                    --pBlock->ulFreeBuffers;

                    if (pHead->pNdisBuffer)
                    {
                        NdisFreeBuffer( pHead->pNdisBuffer );
                    }
                }

                pLink2 = pLink2Next;
            }

            ASSERT( pBlock->ulFreeBuffers == 0 );
#endif

            // Remove and release the unused block.
            //
            RemoveEntryList( pLink );
            pPool->ulCurBuffers -= pBlock->ulBuffers;

            if (pBlock->hNdisPool)
            {
                NdisFreeBufferPool( pBlock->hNdisPool );
            }

            FREE_NONPAGED( pBlock );
        }

        pLink = pLinkNext;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ndis\raspptp\pptpkdx\pptpkdx.c ===
#define SRVDBG 1
#define SRVKD 1
#define NDIS40_MINIPORT 1
#define NDIS_MINIPORT_DRIVER 1
#define NT

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntverp.h>
#include <windef.h>
#include <winbase.h>
#include <ntosp.h>
#include <wdbgexts.h>
#include <stdlib.h>

#include <raspptp.h>
#include <bpool.h>

typedef struct CTDI_DATA *PCTDI_DATA;

typedef struct CTDI_DATA {
    LIST_ENTRY                      ListEntry;
    ULONG                           Signature;
    ULONG                           Type;
    REFERENCE_COUNT                 Reference;
    HANDLE                          hFile;
    PFILE_OBJECT                    pFileObject;
    NDIS_SPIN_LOCK                  Lock;
    BOOLEAN                         Closed;

    CTDI_EVENT_CONNECT_QUERY        ConnectQueryCallback;
    CTDI_EVENT_CONNECT_COMPLETE     ConnectCompleteCallback;
    CTDI_EVENT_DISCONNECT           DisconnectCallback;
    CTDI_EVENT_RECEIVE              RecvCallback;
    PVOID                           RecvContext;
    CTDI_EVENT_RECEIVE_DATAGRAM     RecvDatagramCallback;
    CTDI_EVENT_SEND_COMPLETE        SendCompleteCallback;
    CTDI_EVENT_QUERY_COMPLETE       QueryCompleteCallback;
    CTDI_EVENT_SET_COMPLETE         SetCompleteCallback;

    union {
        struct {
            PVOID                   Context;
            LIST_ENTRY              ConnectList;
            ULONG                   NumConnection;
        } Listen;
        struct {
            PVOID                   Context;
            PCTDI_DATA              LocalEndpoint;
            PVOID                   ConnectInfo;
            TA_IP_ADDRESS           RemoteAddress;
            LIST_ENTRY              ListEntry;
            ULONG                   DisconnectCount;
            union {
                BOOLEAN             Disconnect;
                ULONG_PTR           Padding1;
            };
            union {
                BOOLEAN             Abort;
                ULONG_PTR           Padding2;
            };
        } Connection;
        struct {
            BUFFERPOOL              RxPool;
        } Datagram;
    };
} CTDI_DATA, *PCTDI_DATA;

#define CTDI_UNKNOWN            'NKNU'
#define CTDI_ENDPOINT           'PDNE'
#define CTDI_DATAGRAM           'MRGD'
#define CTDI_LISTEN             'TSIL'
#define CTDI_CONNECTION         'NNOC'


WINDBG_EXTENSION_APIS ExtensionApis;
EXT_API_VERSION ApiVersion = { 5, 0, EXT_API_VERSION_NUMBER, 0 };

#define    ERRPRT     dprintf

#define    NL      1
#define    NONL    0

USHORT SavedMajorVersion;
USHORT SavedMinorVersion;
BOOL   ChkTarget;            // is debuggee a CHK build?


typedef struct
{
    char    Name[16];
    int     Val;
} DBG_LEVEL;



/*
 * Print out an optional message, an ANSI_STRING, and maybe a new-line
 */
BOOL
PrintStringA( IN LPSTR msg OPTIONAL, IN PANSI_STRING pStr, IN BOOL nl )
{
    PCHAR    StringData;
    ULONG    BytesRead;

    if( msg )
        dprintf( msg );

    if( pStr->Length == 0 ) {
        if( nl )
            dprintf( "\n" );
        return TRUE;
    }

    StringData = (PCHAR)LocalAlloc( LPTR, pStr->Length + 1 );

    if( StringData == NULL ) {
        ERRPRT( "Out of memory!\n" );
        return FALSE;
    }

    ReadMemory((ULONG)((ULONG_PTR) pStr->Buffer),
               StringData,
               pStr->Length,
               &BytesRead );

    if ( BytesRead ) {
        StringData[ pStr->Length ] = '\0';
        dprintf("%s%s", StringData, nl ? "\n" : "" );
    }

    LocalFree((HLOCAL)StringData);

    return BytesRead;
}

/*
 * Get 'size' bytes from the debuggee program at 'dwAddress' and place it
 * in our address space at 'ptr'.  Use 'type' in an error printout if necessary
 */
BOOL
GetData( IN LPVOID ptr, IN DWORD_PTR dwAddress, IN ULONG size, IN PCSTR type )
{
    BOOL b;
    ULONG BytesRead;
    ULONG count = size;

    while( size > 0 ) {

    if (count >= 3000)
        count = 3000;

        b = ReadMemory((ULONG) dwAddress, ptr, count, &BytesRead );

        if (!b || BytesRead != count ) {
            ERRPRT( "Unable to read %u bytes at %X, for %s\n", size, dwAddress, type );
            return FALSE;
        }

        dwAddress += count;
        size -= count;
        ptr = (LPVOID)((ULONG_PTR)ptr + count);
    }

    return TRUE;
}

/*
 * Follow a LIST_ENTRY list beginning with a head at dwListHeadAddr in the debugee's
 * address space.  For each element in the list, print out the pointer value at 'offset'
 */
BOOL
PrintListEntryList( IN DWORD dwListHeadAddr, IN LONG offset )
{
    LIST_ENTRY    ListEntry;
    ULONG i=0;
    BOOL retval = TRUE;
    ULONG count = 20;

    if( !GetData( &ListEntry, dwListHeadAddr, sizeof( ListEntry ), "LIST_ENTRY" ) )
        return FALSE;

    while( count-- ) {

        if( (DWORD_PTR)ListEntry.Flink == dwListHeadAddr || (DWORD_PTR)ListEntry.Flink == 0 )
            break;

        if( !GetData( &ListEntry, (DWORD_PTR)ListEntry.Flink, (ULONG)sizeof( ListEntry ), "ListEntry" ) ) {
            retval = FALSE;
            break;
        }

        dprintf( "%16X%s", (DWORD_PTR)ListEntry.Flink + offset, (i && !(i&3)) ? "\n" : "" );
        i++;
    }


    if( count == 0 && (DWORD_PTR)ListEntry.Flink != dwListHeadAddr && ListEntry.Flink ) {
        dprintf( "\nTruncated list dump\n" );

    } else if( ! ( i && !(i&3) ) ) {
        dprintf( "\n" );
    }

    return retval;
}



/*
 * Print out a single HEX character
 */
VOID
PrintHexChar( IN UCHAR c )
{
    dprintf( "%c%c", "0123456789abcdef"[ (c>>4)&0xf ], "0123456789abcdef"[ c&0xf ] );
}

/*
 * Print out 'buf' of 'cbuf' bytes as HEX characters
 */
VOID
PrintHexBuf( IN PUCHAR buf, IN ULONG cbuf )
{
    while( cbuf-- ) {
        PrintHexChar( *buf++ );
        dprintf( " " );
    }
}


/*
 * Fetch the null terminated UNICODE string at dwAddress into buf
 */
BOOL
GetString( IN DWORD_PTR dwAddress, IN LPSTR buf, IN ULONG MaxChars )
{
    do {
        if( !GetData( buf, dwAddress, sizeof( *buf ), "Character" ) )
            return FALSE;

        dwAddress += sizeof( *buf );

    } while( --MaxChars && *buf++ != '\0' );

    return TRUE;
}

char *mystrtok ( char *string, char * control )
{
    static unsigned char *str;
    char *p, *s;

    if( string )
        str = string;

    if( str == NULL || *str == '\0' )
        return NULL;

    //
    // Skip leading delimiters...
    //
    for( ; *str; str++ ) {
        for( s=control; *s; s++ ) {
            if( *str == *s )
                break;
        }
        if( *s == '\0' )
            break;
    }

    //
    // Was it was all delimiters?
    //
    if( *str == '\0' ) {
        str = NULL;
        return NULL;
    }

    //
    // We've got a string, terminate it at first delimeter
    //
    for( p = str+1; *p; p++ ) {
        for( s = control; *s; s++ ) {
            if( *p == *s ) {
                s = str;
                *p = '\0';
                str = p+1;
                return s;
            }
        }
    }

    //
    // We've got a string that ends with the NULL
    //
    s = str;
    str = NULL;
    return s;
}

DECLARE_API( help )
{
    int i;

    dprintf("PPTP extenstions:\n");

    dprintf("   version\n");
    dprintf("   ctdi                        dump tdi handles\n");
    dprintf("   calls [start [end]]         dump call handles\n");
    dprintf("   ctls                        dump ctl handles\n");
    dprintf("   dbgmsgs                     dump debug log\n");
    dprintf("   mem                         dump allocations\n");
}

DECLARE_API( dbgmsgs )
{
    DWORD   p;
    DWORD   Last, First;
    char    DbgMsg[MAX_MSG_LEN];
    ULONG   Read;
    char    *DbgMsgs;

    if (!GetData(&Last,
                 GetExpression("raspptp!Last"),
                 sizeof(Last), "DWORD"))
    {
        dprintf("error\n");
        return;
    }


    if (!GetData(&First,
                 GetExpression("raspptp!First"),
                 sizeof(Last), "DWORD"))
    {
        dprintf("error\n");
        return;
    }



    DbgMsgs = (char *) GetExpression("raspptp!dbgmsgs");

    dprintf("\n\n");

    while (First != Last)
    {
       if (!GetString((DWORD_PTR) (DbgMsgs + First * MAX_MSG_LEN),
                  DbgMsg, MAX_MSG_LEN))
            break;
        /*
        ReadMemory((ULONG) (DbgMsgs + First * MAX_MSG_LEN),
                    DbgMsg, MAX_MSG_LEN, &Read); */
        dprintf("%s", DbgMsg);
        First++;
        if (First == DBG_MSG_CNT)
            First = 0;
    }
}

DECLARE_API( ctdi )
{
    LIST_ENTRY ListEntry;
    PLIST_ENTRY ListHead;
    ULONG Count = 20;
    char argbuf[ MAX_PATH ];

    ListHead = (PLIST_ENTRY)GetExpression("raspptp!CtdiList");

    if (!GetData(&ListEntry,
                 (ULONG_PTR)ListHead,
                 sizeof(LIST_ENTRY),
                 "LIST_ENTRY"))
    {
        dprintf("error\n");
        return;
    }

    while (Count-- && ListHead!=ListEntry.Flink)
    {
        CTDI_DATA Ctdi;
        UCHAR TypeStr[sizeof(ULONG)+1];
        if (!GetData(&Ctdi,
                     (ULONG_PTR)ListEntry.Flink,
                     sizeof(CTDI_DATA),
                     "CTDI_DATA"))
        {
            dprintf("error\n");
            return;
        }
        memcpy(TypeStr, &Ctdi.Type, sizeof(ULONG));
        TypeStr[sizeof(ULONG)] = 0;

        dprintf("CTDI:%08x Sig:%08x  Type:%s  Refs:%d  Handle:%08x  FileObj:%08x  Closed:%d\n",
                ListEntry.Flink, Ctdi.Signature, TypeStr, Ctdi.Reference.Count, Ctdi.hFile, Ctdi.pFileObject, Ctdi.Closed);
        switch (Ctdi.Type)
        {
            case CTDI_CONNECTION:
                dprintf("      Context:%08x  Endpoint:%08x  Disconnect/Abort:%x/%x\n",
                        Ctdi.Connection.Context, Ctdi.Connection.LocalEndpoint,
                        Ctdi.Connection.Disconnect, Ctdi.Connection.Abort);
                break;
            case CTDI_LISTEN:
                dprintf("      Context:%08x  NumConn:%d\n",
                        Ctdi.Listen.Context, Ctdi.Listen.NumConnection);
                break;
            default:
                break;
        }
        ListEntry = Ctdi.ListEntry;
    }
}

typedef struct MEM_HDR {
    LIST_ENTRY  ListEntry;
    ULONG       Size;
    CHAR        File[12];
    ULONG       Line;
} MEM_HDR;

DECLARE_API( mem )
{
    LIST_ENTRY ListEntry;
    PLIST_ENTRY ListHead;
    ULONG TotalMem = 0;
    char argbuf[ MAX_PATH ];

    ListHead = (PLIST_ENTRY)GetExpression("raspptp!leAlloc");

    if (!GetData(&ListEntry,
                 (ULONG_PTR)ListHead,
                 sizeof(LIST_ENTRY),
                 "LIST_ENTRY"))
    {
        dprintf("error\n");
        return;
    }

    while (ListHead!=ListEntry.Flink)
    {
        MEM_HDR Mem;
        UCHAR TypeStr[sizeof(ULONG)+1];
        if (!GetData(&Mem,
                     (ULONG_PTR)ListEntry.Flink,
                     sizeof(MEM_HDR),
                     "MEM_HDR"))
        {
            dprintf("error\n");
            return;
        }

        dprintf("MEM:%08x  Len:%5d  File:%-15s  Line:%d\n",
                ListEntry.Flink, Mem.Size, Mem.File, Mem.Line);
        TotalMem += Mem.Size;
        ListEntry = Mem.ListEntry;
    }
    dprintf("MEM: Total %d bytes\n", TotalMem);
}

PUCHAR CallState[] =
{
    "STATE_CALL_INVALID",
    "STATE_CALL_CLOSED",
    "STATE_CALL_IDLE",
    "STATE_CALL_OFFHOOK",
    "STATE_CALL_OFFERING",
    "STATE_CALL_PAC_OFFERING",
    "STATE_CALL_PAC_WAIT",
    "STATE_CALL_DIALING",
    "STATE_CALL_PROCEEDING",
    "STATE_CALL_ESTABLISHED",
    "STATE_CALL_WAIT_DISCONNECT",
    "STATE_CALL_CLEANUP"
};

DECLARE_API( calls )
{
    PPTP_ADAPTER Adapter;
    CALL_SESSION Call;
    ULONG_PTR pCall;
    ULONG_PTR pAdapter = GetExpression("raspptp!pgAdapter");
    ULONG i, StartCall=0, EndCall=0xffff;
    char argbuf[MAX_PATH];
    char arglist[2][MAX_PATH];

    if (args && *args)
    {
        char                   *p;

        strcpy(argbuf, args);

        i = 0;
        //parsing the arguments
        for (p = mystrtok( argbuf, " \t,;" );
         p && *p && i<2;
         p = mystrtok(NULL, " \t,;"))
        {
         strcpy(&arglist[i++][0],p);
        }
        if (i>0)
        {
            StartCall = EndCall = atoi(arglist[0]);
        }
        if (i>1)
        {
            EndCall = atoi(arglist[1]);
        }
    }

    if (!GetData(&pAdapter,
                 pAdapter,
                 sizeof(pAdapter),
                 "PPTP_ADAPTER*"))
    {
        dprintf("error\n");
        return;
    }
    if (!pAdapter)
    {
        dprintf("no adapter\n");
        return;
    }
    if (!GetData(&Adapter,
                 pAdapter,
                 sizeof(Adapter),
                 "PPTP_ADAPTER"))
    {
        dprintf("error\n");
        return;
    }

    dprintf("Adapter:%08x  %d calls\n", pAdapter, Adapter.Info.Endpoints);
    for (i=StartCall; i<Adapter.Info.Endpoints && i<=EndCall; i++)
    {
        if (!GetData(&pCall,
                     ((ULONG_PTR)Adapter.pCallArray)+i*sizeof(ULONG_PTR),
                     sizeof(pCall),
                     "CALL_SESSION*"))
        {
            dprintf("error\n");
            return;
        }
        if (pCall)
        {
            if (!GetData(&Call,
                         pCall,
                         sizeof(Call),
                         "CALL_SESSION"))
            {
                dprintf("error\n");
                return;
            }
            dprintf("Call %d:%08x  Ctl:%08x  State:%s  Inbound:%d  Open:%d\n",
                    i, pCall, Call.pCtl, CallState[Call.State], Call.Inbound, Call.Open);
            dprintf("        htCall:%08x  DeviceId:%d  SN:%d  Link:%08x\n",
                    Call.hTapiCall, Call.DeviceId,  Call.SerialNumber, Call.NdisLinkContext);
            dprintf("        Remote->ID:%04x  Seq:%08x  Ack:%08x  Addr:%08x\n",
                    Call.Remote.CallId,
                    Call.Remote.SequenceNumber,
                    Call.Remote.AckNumber,
                    Call.Remote.Address.Address[0].Address[0].in_addr);
            dprintf("        Packet->ID:%04x  Seq:%08x  Ack:%08x\n",
                    Call.Packet.CallId,
                    Call.Packet.SequenceNumber,
                    Call.Packet.AckNumber);
            dprintf("        Close->Expedited:%d  Checklist:%x\n",
                    Call.Close.Expedited, Call.Close.Checklist);
        }
        else
        {
            dprintf("Call %d:freed\n", i);
        }
    }
}

PUCHAR CtlState[] =
{
    "STATE_CTL_INVALID",
    "STATE_CTL_LISTEN",
    "STATE_CTL_DIALING",
    "STATE_CTL_WAIT_REQUEST",
    "STATE_CTL_WAIT_REPLY",
    "STATE_CTL_ESTABLISHED",
    "STATE_CTL_WAIT_STOP",
    "STATE_CTL_CLEANUP"
};

DECLARE_API( ctls )
{
    PPTP_ADAPTER Adapter;
    LIST_ENTRY ListEntry;
    PLIST_ENTRY ListHead;
    char argbuf[ MAX_PATH ];
    ULONG_PTR pAdapter = GetExpression("raspptp!pgAdapter");

    if (!GetData(&pAdapter,
                 pAdapter,
                 sizeof(pAdapter),
                 "PPTP_ADAPTER*"))
    {
        dprintf("error\n");
        return;
    }
    if (!pAdapter)
    {
        dprintf("no adapter\n");
        return;
    }
    if (!GetData(&Adapter,
                 pAdapter,
                 sizeof(Adapter),
                 "PPTP_ADAPTER"))
    {
        dprintf("error\n");
        return;
    }

    ListHead = (PLIST_ENTRY)(((ULONG_PTR)&Adapter.ControlTunnelList) - ((ULONG_PTR)&Adapter) + pAdapter);
    ListEntry = Adapter.ControlTunnelList;

    while (ListHead!=ListEntry.Flink)
    {
        CONTROL_TUNNEL Ctl;
        if (!GetData(&Ctl,
                     (ULONG_PTR)ListEntry.Flink,
                     sizeof(CONTROL_TUNNEL),
                     "CONTROL_TUNNEL"))
        {
            dprintf("error\n");
            return;
        }

        dprintf("CTL:%08x  Sig:%08x  State:%s  Refs:%d  Cleanup:%x  Inbound:%d\n",
                ListEntry.Flink, Ctl.Signature, CtlState[Ctl.State], Ctl.Reference.Count, Ctl.Cleanup, Ctl.Inbound);
        ListEntry = Ctl.ListEntry;
    }
}

VOID
DumpIrpList(LIST_ENTRY *pIrpList)
{
    LIST_ENTRY          IrpList, *pListEntry, ListEntry;
    IRP                 *pIrp;

    if (!GetData(&IrpList,
                 (DWORD_PTR) pIrpList,
                 sizeof(LIST_ENTRY), "LIST_ENTRY"))
    {
        return;
    }

    for (pListEntry = IrpList.Flink;
         pListEntry != pIrpList;
         pListEntry = ListEntry.Flink)
    {

        if (!GetData(&ListEntry,
                 (DWORD_PTR) pListEntry,
                 sizeof(LIST_ENTRY), "LIST_ENTRY"))
        {
            return;
        }

        pIrp = CONTAINING_RECORD(pListEntry, IRP, Tail.Overlay.ListEntry);

        dprintf("  %x\n", pIrp);
    }
}

VOID
WinDbgExtensionDllInit(
    PWINDBG_EXTENSION_APIS lpExtensionApis,
    USHORT MajorVersion,
    USHORT MinorVersion
    )
{
    ExtensionApis = *lpExtensionApis;

    SavedMajorVersion = MajorVersion;
    SavedMinorVersion = MinorVersion;
    ChkTarget = SavedMajorVersion == 0x0c ? TRUE : FALSE;
}

DECLARE_API( version )
{
#if    DBG
    PCSTR kind = "Checked";
#else
    PCSTR kind = "Free";
#endif

    dprintf(
        "%s SMB Extension dll for Build %d debugging %s kernel for Build %d\n",
        kind,
        VER_PRODUCTBUILD,
        SavedMajorVersion == 0x0c ? "Checked" : "Free",
        SavedMinorVersion
    );
}

VOID
CheckVersion(
    VOID
    )
{
#if DBG
    if ((SavedMajorVersion != 0x0c) || (SavedMinorVersion != VER_PRODUCTBUILD)) {
        dprintf("\r\n*** Extension DLL(%d Checked) does not match target system(%d %s)\r\n\r\n",
                VER_PRODUCTBUILD, SavedMinorVersion, (SavedMajorVersion==0x0f) ? "Free" : "Checked" );
    }
#else
    if ((SavedMajorVersion != 0x0f) || (SavedMinorVersion != VER_PRODUCTBUILD)) {
        dprintf("\r\n*** Extension DLL(%d Free) does not match target system(%d %s)\r\n\r\n",
                VER_PRODUCTBUILD, SavedMinorVersion, (SavedMajorVersion==0x0f) ? "Free" : "Checked" );
    }
#endif
}

LPEXT_API_VERSION
ExtensionApiVersion(
    VOID
    )
{
    return &ApiVersion;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ndis\raspti\debug.c ===
// Copyright (c) 1997, Microsoft Corporation, all rights reserved
// Copyright (c) 1997, Parallel Technologies, Inc., all rights reserved
//
// debug.c
// DirectParallel WAN mini-port/call-manager driver
// Debug utilities and globals
//
// 01/07/97 Steve Cobb
// 09/15/97 Jay Lowe, Parallel Technologies, Inc.

#include "ptiwan.h"

//-----------------------------------------------------------------------------
// Global data definitions
//-----------------------------------------------------------------------------

#ifdef TESTMODE
#pragma message( "TESTMODE defined, building private spew" )
#define DEFAULTTRACELEVEL TL_N
#define DEFAULTTRACEMASK  TM_Base
#else
#define DEFAULTTRACELEVEL TL_None
#define DEFAULTTRACEMASK  TM_Base
#endif

// Active debug trace level and active trace set mask.  Set these variables
// with the debugger at startup to enable and filter the debug output.  All
// messages with (TL_*) level less than or equal to 'g_ulTraceLevel' are
// displayed.  All messages from any (TM_*) set(s) present in 'g_ulTraceMask'
// are displayed.
//
ULONG g_ulTraceLevel = DEFAULTTRACELEVEL;
ULONG g_ulTraceMask = DEFAULTTRACEMASK;


//-----------------------------------------------------------------------------
// Routines
//-----------------------------------------------------------------------------


#if DBG
VOID
CheckList(
    IN LIST_ENTRY* pList,
    IN BOOLEAN fShowLinks )

    // Tries to detect corruption in list 'pList', printing verbose linkage
    // output if 'fShowLinks' is set.
    //
{
    LIST_ENTRY* pLink;
    ULONG ul;

    ul = 0;
    for (pLink = pList->Flink;
         pLink != pList;
         pLink = pLink->Flink)
    {
        if (fShowLinks)
        {
            DbgPrint( "RASPTI: CheckList($%p) Flink(%d)=$%p\n",
                pList, ul, pLink );
        }
        ++ul;
    }

    for (pLink = pList->Blink;
         pLink != pList;
         pLink = pLink->Blink)
    {
        if (fShowLinks)
        {
            DbgPrint( "RASPTI: CheckList($%p) Blink(%d)=$%p\n",
                pList, ul, pLink );
        }
        --ul;
    }

    if (ul)
    {
        DbgBreakPoint();
    }
}
#endif


#if DBG
VOID
Dump(
    IN CHAR* p,
    IN ULONG cb,
    IN BOOLEAN fAddress,
    IN ULONG ulGroup )

    // Hex dump 'cb' bytes starting at 'p' grouping 'ulGroup' bytes together.
    // For example, with 'ulGroup' of 1, 2, and 4:
    //
    // 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 |................|
    // 0000 0000 0000 0000 0000 0000 0000 0000 |................|
    // 00000000 00000000 00000000 00000000 |................|
    //
    // If 'fAddress' is true, the memory address dumped is prepended to each
    // line.
    //
{
    while (cb)
    {
        INT cbLine;

        cbLine = (cb < DUMP_BytesPerLine) ? cb : DUMP_BytesPerLine;
        DumpLine( p, cbLine, fAddress, ulGroup );
        cb -= cbLine;
        p += cbLine;
    }
}
#endif


#if DBG
VOID
DumpLine(
    IN CHAR* p,
    IN ULONG cb,
    IN BOOLEAN fAddress,
    IN ULONG ulGroup )
{
    CHAR* pszDigits = "0123456789ABCDEF";
    CHAR szHex[ ((2 + 1) * DUMP_BytesPerLine) + 1 ];
    CHAR* pszHex = szHex;
    CHAR szAscii[ DUMP_BytesPerLine + 1 ];
    CHAR* pszAscii = szAscii;
    ULONG ulGrouped = 0;

    if (fAddress)
        DbgPrint( "RASPTI: %p: ", p );
    else
        DbgPrint( "RASPTI: " );

    while (cb)
    {
        *pszHex++ = pszDigits[ ((UCHAR )*p) / 16 ];
        *pszHex++ = pszDigits[ ((UCHAR )*p) % 16 ];

        if (++ulGrouped >= ulGroup)
        {
            *pszHex++ = ' ';
            ulGrouped = 0;
        }

        *pszAscii++ = (*p >= 32 && *p < 128) ? *p : '.';

        ++p;
        --cb;
    }

    *pszHex = '\0';
    *pszAscii = '\0';

    DbgPrint(
        "%-*s|%-*s|\n",
        (2 * DUMP_BytesPerLine) + (DUMP_BytesPerLine / ulGroup), szHex,
        DUMP_BytesPerLine, szAscii );
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ndis\raspti\cm.c ===
// Copyright (c) 1997, Microsoft Corporation, all rights reserved
// Copyright (c) 1997, Parallel Technologies, Inc., all rights reserved
//
// cm.c
// RAS DirectParallel WAN mini-port/call-manager driver
// Call Manager routines
//
// 01/07/97 Steve Cobb
// 09/15/97 Jay Lowe, Parallel Technologies, Inc.

#include "ptiwan.h"
#include "ptilink.h"


//-----------------------------------------------------------------------------
// Local prototypes (alphabetically)
//-----------------------------------------------------------------------------

VOID
CallSetupComplete(
    IN VCCB* pVc );

VOID
InactiveCallCleanUp(
    IN VCCB* pVc );

ULONG
LineIdAdd(
    IN ADAPTERCB* pAdapter,
    IN ULONG LineId );

ULONG
LineIdPortLookup(
    IN ADAPTERCB* pAdapter,
    IN ULONG LineId );

VOID
OpenAfPassive(
    IN NDIS_WORK_ITEM* pWork,
    IN VOID* pContext );

NDIS_STATUS
PtiOpenPtiLink(
    IN VCCB* pVc,
    IN ULONG ParallelPortIndex);

NDIS_STATUS
PtiClosePtiLink(
    IN VCCB* pVc );

NDIS_STATUS
QueryCmInformation(
    IN ADAPTERCB* pAdapter,
    IN VCCB* pVc,
    IN NDIS_OID Oid,
    IN PVOID InformationBuffer,
    IN ULONG InformationBufferLength,
    OUT PULONG BytesWritten,
    OUT PULONG BytesNeeded );

VOID
QueryPtiPorts(
    IN ADAPTERCB* pAdapter );

VOID
SetupVcComplete(
    IN VCCB* pVc );

VOID
WriteEndpointsToRegistry(
    IN ULONG ulVcs );


//-----------------------------------------------------------------------------
// Call-manager handlers and completers
//-----------------------------------------------------------------------------

NDIS_STATUS
PtiCmOpenAf(
    IN NDIS_HANDLE CallMgrBindingContext,
    IN PCO_ADDRESS_FAMILY AddressFamily,
    IN NDIS_HANDLE NdisAfHandle,
    OUT PNDIS_HANDLE CallMgrAfContext )

    // Standard 'CmOpenAfHandler' routine called by NDIS when the a client
    // requests to open an address family.  See DDK doc.
    //
{
    ADAPTERCB* pAdapter;
    NDIS_HANDLE hExistingAf;
    NDIS_STATUS status;

    TRACE( TL_I, TM_Cm,
        ( "PtiCmOpenAf: AF=$%p", AddressFamily->AddressFamily ) );

    pAdapter = (ADAPTERCB* )CallMgrBindingContext;
    if (pAdapter->ulTag != MTAG_ADAPTERCB)
    {
        ASSERT( !"Atag?" );
        return NDIS_STATUS_INVALID_DATA;
    }

    if (AddressFamily->AddressFamily != CO_ADDRESS_FAMILY_TAPI_PROXY
        || AddressFamily->MajorVersion != NDIS_MajorVersion
        || AddressFamily->MinorVersion != NDIS_MinorVersion)
    {
        TRACE( TL_A, TM_Cm, ( "PtiCmOpenAf: Bad AF or NDIS version" ) );
        return NDIS_STATUS_BAD_VERSION;
    }

    // Save NDIS's AF handle in the adapter control block.  Interlock just in
    // case multiple clients attempt to open the AF, though don't expect this.
    //
    hExistingAf =
        InterlockedCompareExchangePointer(
            &pAdapter->NdisAfHandle, NdisAfHandle, NULL );
    if (hExistingAf)
    {
        // Our AF has already been opened and it doesn't make any sense to
        // accept another since there is no way to distinguish which should
        // receive incoming calls.
        //
        ASSERT( !"AF exists?" );
        return NDIS_STATUS_FAILURE;
    }

    ReferenceAdapter( pAdapter );
    ReferenceAf( pAdapter );

    // Since we support only a single address family, just return the adapter
    // as the address family context.
    //
    *CallMgrAfContext = CallMgrBindingContext;

    // If this is the first reference then schedule work to stall around
    // waiting for PARPORT to initialize the parallel ports.  Unfortunately,
    // according to Doug Fritz there is no way in the PnP model to know when
    // all ports that are coming have come.
    //
    TRACE( TL_I, TM_Cm, ( "PtiCmOpenAf sched delay" ) );
    status = ScheduleWork( pAdapter, OpenAfPassive, pAdapter );

    if (status != NDIS_STATUS_SUCCESS)
    {
        TRACE( TL_I, TM_Cm, ( "PtiCmOpenAf: Sched fail" ) );
        return status;
    }

    TRACE( TL_V, TM_Cm, ( "PtiCmOpenAf: pend" ) );
    return NDIS_STATUS_PENDING;
}


VOID
OpenAfPassive(
    IN NDIS_WORK_ITEM* pWork,
    IN VOID* pContext )

    // An NDIS_PROC routine to complete the Address Family open begun in
    // LcmCmOpenAf.
{
    ADAPTERCB* pAdapter;

    // Unpack context information then free the work item.
    //
    pAdapter = (ADAPTERCB* )pContext;
    ASSERT( pAdapter->ulTag == MTAG_ADAPTERCB );
    FREE_NDIS_WORK_ITEM( pAdapter, pWork );

    if (pAdapter->lAfRef <= 1)
    {
        if (pAdapter->ulParportDelayMs > 0)
        {
            TRACE( TL_I, TM_Cm, ( "NdisMSleep(openAF)" ) );
            NdisMSleep( pAdapter->ulParportDelayMs * 1000 );
            TRACE( TL_I, TM_Cm, ( "NdisMSleep(openAF) done" ) );
        }

        // Count the actual number of VCs we must be able to provide and write
        // the result to the registry.
        //
        QueryPtiPorts( pAdapter );
        if (pAdapter->ulActualVcs == 0 && pAdapter->ulExtraParportDelayMs > 0)
        {
            // No ports were found,but a secondary wait is configured.  Wait,
            // then count the ports again.
            //
            TRACE( TL_I, TM_Cm, ( "NdisMSleep(openAFx)" ) );
            NdisMSleep( pAdapter->ulExtraParportDelayMs * 1000 );
            TRACE( TL_I, TM_Cm, ( "NdisMSleep(openAFx) done" ) );

            QueryPtiPorts( pAdapter );
        }

        WriteEndpointsToRegistry( pAdapter->ulActualVcs );
    }

    TRACE( TL_I, TM_Cm, ( "NdisMCmOpenAddressFamilyComplete" ) );
    NdisMCmOpenAddressFamilyComplete(
        NDIS_STATUS_SUCCESS, pAdapter->NdisAfHandle, (NDIS_HANDLE )pAdapter );
    TRACE( TL_I, TM_Cm, ( "NdisMCmOpenAddressFamilyComplete done" ) );
}


NDIS_STATUS
PtiCmCreateVc(
    IN NDIS_HANDLE ProtocolAfContext,
    IN NDIS_HANDLE NdisVcHandle,
    OUT PNDIS_HANDLE ProtocolVcContext )

    // Standard 'CmCreateVc' routine called by NDIS in response to a
    // client's request to create a virtual circuit.  This
    // call must return synchronously.
    //
{
    NDIS_STATUS status;
    ADAPTERCB* pAdapter;
    VCCB* pVc;

    TRACE( TL_I, TM_Cm, ( "PtiCmCreateVc" ) );

    pAdapter = (ADAPTERCB* )ProtocolAfContext;
    if (pAdapter->ulTag != MTAG_ADAPTERCB)
    {
        ASSERT( !"Atag?" );
        return NDIS_STATUS_INVALID_DATA;
    }

    // Allocate and zero a VC control block, then make any non-zero
    // initializations.
    //
    pVc = ALLOC_VCCB( pAdapter );
    if (!pVc)
    {
        ASSERT( !"Alloc VC?" );
        return NDIS_STATUS_RESOURCES;
    }

    NdisZeroMemory( pVc, sizeof(*pVc) );

    // Set a marker for easier memory dump browsing.
    //
    pVc->ulTag = MTAG_VCCB;

    // Save a back pointer to the adapter for use in PtiCmDeleteVc later.
    //
    pVc->pAdapter = pAdapter;
    ReferenceAdapter( pAdapter );

    // Initialize the VC and call spinlock and send/receive lists.
    //
    NdisAllocateSpinLock( &pVc->lockV );
    NdisAllocateSpinLock( &pVc->lockCall );

    // Save the NDIS handle of this VC for use in indications to NDIS later.
    //
    pVc->NdisVcHandle = NdisVcHandle;

    // Initialize link capabilities to the defaults for the adapter, except
    // for the ACCM mask which defaults to "all stuffed" per PPP spec.  We
    // desire no stuffing so 0 what is in the adapter block, and passed up to
    // NDISWAN, but can't use that until/unless it's negotiated and passed
    // back down to us in an OID_WAN_CO_SET_LINK_INFO.
    //
    {
        NDIS_WAN_CO_INFO* pwci = &pAdapter->info;
        NDIS_WAN_CO_GET_LINK_INFO* pwcgli = &pVc->linkinfo;

        NdisZeroMemory( &pVc->linkinfo, sizeof(pVc->linkinfo) );
        pwcgli->MaxSendFrameSize = pwci->MaxFrameSize;
        pwcgli->MaxRecvFrameSize = pwci->MaxFrameSize;
        pwcgli->SendFramingBits = pwci->FramingBits;
        pwcgli->RecvFramingBits = pwci->FramingBits;
        pwcgli->SendACCM = (ULONG )-1;
        pwcgli->RecvACCM = (ULONG )-1;
    }

    // The VC control block's address is the VC context we return to NDIS.
    //
    *ProtocolVcContext = (NDIS_HANDLE )pVc;

    // Add a reference to the control block and the associated address family
    // that is removed by LmpCoDeleteVc.
    //
    ReferenceVc( pVc );
    ReferenceAf( pAdapter );

    TRACE( TL_V, TM_Mp, ( "PtiCmCreateVc: Exit: pVc=$%p", pVc ) );
    return NDIS_STATUS_SUCCESS;
}


NDIS_STATUS
PtiCmDeleteVc(
    IN NDIS_HANDLE ProtocolVcContext )

    // Standard 'CmDeleteVc' routine called by NDIS in response to a
    // client's request to delete a virtual circuit.  This
    // call must return synchronously.
    //
{
    VCCB* pVc;

    TRACE( TL_I, TM_Cm, ( "PtiCmDelVc: pVc=$%p", ProtocolVcContext ) );

    pVc = (VCCB* )ProtocolVcContext;
    if (pVc->ulTag != MTAG_VCCB)
    {
        ASSERT( !"Vtag?" );
        return NDIS_STATUS_INVALID_DATA;
    }

    // Remove the references added by PtiCmCreateVc.
    //
    DereferenceAf( pVc->pAdapter );
    DereferenceVc( pVc );

    TRACE( TL_V, TM_Cm, ( "PtiCmDelVc: Exit, pVc=$%p", pVc ) );
    return NDIS_STATUS_SUCCESS;
}


NDIS_STATUS
PtiCmRegisterSap(
    IN NDIS_HANDLE CallMgrAfContext,
    IN PCO_SAP Sap,
    IN NDIS_HANDLE NdisSapHandle,
    OUT PNDIS_HANDLE CallMgrSapContext )

    // Standard 'CmRegisterSapHandler' routine called by NDIS when the
    // client registers a service access point.  See DDK doc.
    //
{
    NDIS_STATUS status;
    ADAPTERCB* pAdapter;
    VCCB* pVc;
    BOOLEAN fSapExists;
    BOOLEAN fBadSapPort;
    BOOLEAN fBadSapLength;
    CO_AF_TAPI_SAP* pSap;

    TRACE( TL_I, TM_Cm, ( "PtiCmRegSap" ) );

    pAdapter = (ADAPTERCB* )CallMgrAfContext;

    // Our SAP context is just the address of the owning adapter control
    // block.  Set it now before scheduling work as NDIS doesn't handle the
    // case of SAP completion correctly otherwise (though it should).
    //
    *CallMgrSapContext = (NDIS_HANDLE )pAdapter;

    if (pAdapter->ulTag != MTAG_ADAPTERCB)
    {
        ASSERT( !"Atag?" );
        return NDIS_STATUS_INVALID_DATA;
    }

    fSapExists = FALSE;
    fBadSapLength = FALSE;
    fBadSapPort = FALSE;
    NdisAcquireSpinLock( &pAdapter->lockSap );
    do
    {
        ULONG ulSapPort;

        if (pAdapter->NdisSapHandle)
        {
            fSapExists = TRUE;
            break;
        }

        if (Sap->SapLength != sizeof(CO_AF_TAPI_SAP))
        {
            fBadSapLength = TRUE;
            break;
        }

        pSap = (CO_AF_TAPI_SAP* )&Sap->Sap[ 0 ];
        if (pSap->ulLineID >= pAdapter->ulActualVcs)
        {
            fBadSapPort = TRUE;
            break;
        }

        // Save NDIS's SAP handle in the adapter control block.  Extract
        // "listen" port from SAP parameters.
        //
        ulSapPort = LineIdPortLookup( pAdapter, pSap->ulLineID );
        if (ulSapPort >= NPORTS)
        {
            fBadSapPort = TRUE;
            break;
        }

        pAdapter->NdisSapHandle = NdisSapHandle;
        pAdapter->ulSapPort = ulSapPort;
    }
    while (FALSE);
    NdisReleaseSpinLock( &pAdapter->lockSap );

    if (fSapExists)
    {
        TRACE( TL_A, TM_Cm, ( "SAP exists?" ) );
        return NDIS_STATUS_SAP_IN_USE;
    }

    if (fBadSapLength)
    {
        ASSERT( !"Bad SAP length?" );
        return NDIS_STATUS_INVALID_DATA;
    }

    if (fBadSapPort)
    {
        ASSERT( !"Bad SAP port?" );
        return NDIS_STATUS_INVALID_DATA;
    }

    // Allocate and zero a VC control block, then make any non-zero
    // initializations.
    //
    pVc = ALLOC_VCCB( pAdapter );
    if (!pVc)
    {
        ASSERT( !"Alloc VC?" );
        return NDIS_STATUS_RESOURCES;
    }
    NdisZeroMemory( pVc, sizeof(*pVc) );
    ReferenceVc( pVc );
    pVc->ulTag = MTAG_VCCB;
    pVc->pAdapter = pAdapter;
    ReferenceAdapter( pAdapter );

    // Now we have a temporary "Vc" to listen on ... save it
    //
    pAdapter->pListenVc = pVc;

    // PtiOpen must be called at PASSIVE IRQL so schedule an APC to do it.
    //
    status = ScheduleWork( pAdapter, RegisterSapPassive, pAdapter );
    if (status != NDIS_STATUS_SUCCESS)
    {
        DereferenceVc( pAdapter->pListenVc );
        pAdapter->pListenVc = NULL;

        NdisAcquireSpinLock( &pAdapter->lockSap );
        {
            pAdapter->NdisSapHandle = NULL;
            pAdapter->ulSapPort = 0;
        }
        NdisReleaseSpinLock( &pAdapter->lockSap );

        return status;
    }

    TRACE( TL_V, TM_Cm, ( "PtiCmRegSap: Exit: pListenVc=$%p", pVc ) );
    return NDIS_STATUS_PENDING;
}


VOID
RegisterSapPassive(
    IN NDIS_WORK_ITEM* pWork,
    IN VOID* pContext )

    // An NDIS_PROC procedure to complete the registering of a SAP begun in
    // PtiCmRegisterSap.
    //
{
    NDIS_STATUS status;
    ADAPTERCB* pAdapter;
    NDIS_HANDLE hSap;

    TRACE( TL_N, TM_Cm, ( "RegSapPassive" ) );

    // Unpack context information then free the work item.
    //
    pAdapter = (ADAPTERCB* )pContext;
    ASSERT( pAdapter->ulTag == MTAG_ADAPTERCB );
    FREE_NDIS_WORK_ITEM( pAdapter, pWork );

    // Start listening ...
    //
    TRACE( TL_I, TM_Cm,
        ( "PtiCmRegSap: New SAP, Port=$%x", pAdapter->ulSapPort ) );
    status = PtiOpenPtiLink( pAdapter->pListenVc, pAdapter->ulSapPort );

    NdisAcquireSpinLock( &pAdapter->lockSap );
    {
        hSap = pAdapter->NdisSapHandle;

        if (NT_SUCCESS( status ))
        {
            // Mark the SAP active allowing references to be taken, and take
            // the initial reference for SAP registry, plus those for address
            // family and adapter.
            //
            SetFlags( &pAdapter->ulFlags, ACBF_SapActive );
            ASSERT( pAdapter->lSapRef == 0 );
            TRACE( TL_N, TM_Ref, ( "RefSap-ish to 1" ) );
            pAdapter->lSapRef = 1;
            ReferenceAdapter( pAdapter );
            ReferenceAf( pAdapter );
        }
        else
        {
            // Failed to get TDI set up, so NULL the SAP handle in the adapter
            // control block.
            //
            TRACE( TL_A, TM_Cm,
                 ( "PtiCmRegSap: Error: Open failed: status=$%x", status ) );

            DereferenceVc( pAdapter->pListenVc );
            pAdapter->pListenVc = NULL;
            pAdapter->NdisSapHandle = NULL;
            pAdapter->ulSapPort = 0;
            status = NDIS_STATUS_FAILURE;
        }
    }
    NdisReleaseSpinLock( &pAdapter->lockSap );

    if (status != STATUS_SUCCESS)
    {
        // Remove the NdisSapHandle reference since we NULLed it above while
        // locks were held.
        //
        DereferenceAdapter( pAdapter );
    }

    // Remove the reference for scheduled work.  Must occur before telling
    // NDIS because it could call Halt and unload the driver before we ever
    // get control again resulting in a C4 bugcheck.  (Yes, this actually
    // happened)
    //
    DereferenceAdapter( pAdapter );

    // Report result to client.
    //
    TRACE( TL_I, TM_Cm, ( "NdisMCmRegSapComp=$%08x", status ) );
    NdisMCmRegisterSapComplete( status, hSap, (NDIS_HANDLE )pAdapter );
    TRACE( TL_I, TM_Cm, ( "NdisMCmRegSapComp done" ) );
}


NDIS_STATUS
PtiCmDeregisterSap(
    NDIS_HANDLE CallMgrSapContext )

    // Standard 'CmDeregisterSapHandler' routine called by NDIS when the a
    // client has requested to de-register a service access point.  See DDK
    // doc.
    //
{
    NDIS_STATUS status;
    ADAPTERCB* pAdapter;

    TRACE( TL_I, TM_Cm, ( "PtiCmDeregSap" ) );

    pAdapter = (ADAPTERCB* )CallMgrSapContext;
    if (pAdapter->ulTag != MTAG_ADAPTERCB)
    {
        ASSERT( !"Atag?" );
        return NDIS_STATUS_INVALID_DATA;
    }

    NdisAcquireSpinLock( &pAdapter->lockSap );
    {
        if (ReadFlags( &pAdapter->ulFlags ) & ACBF_SapActive)
        {
            ASSERT( pAdapter->NdisSapHandle );
            ClearFlags( &pAdapter->ulFlags, ACBF_SapActive );
            status = NDIS_STATUS_PENDING;
        }
        else
        {
            ASSERT( !"No SAP active?" );
            status = NDIS_STATUS_FAILURE;
        }
    }
    NdisReleaseSpinLock( &pAdapter->lockSap );

    if (status == NDIS_STATUS_PENDING)
    {
        // Remove the reference for SAP registry.  Eventually, the SAP
        // references will fall to 0 and DereferenceSap will call
        // DeregisterSapWork to complete the de-registry.
        //
        DereferenceSap( pAdapter );
    }

    TRACE( TL_V, TM_Cm, ( "PtiCmDeregSap=$%x", status ) );
    return status;
}


VOID
DeregisterSapPassive(
    IN NDIS_WORK_ITEM* pWork,
    IN VOID* pContext )

    // An NDIS_PROC routine to complete the de-registering of a SAP begun in
    // PtiCmDeregisterSap.
    //
{
    ADAPTERCB* pAdapter;
    NDIS_HANDLE hOldSap;
    VCCB* pVc;

    TRACE( TL_I, TM_Cm, ( "DeregSapPassive" ) );

    // Unpack context information then free the work item.
    //
    pAdapter = (ADAPTERCB* )pContext;
    ASSERT( pAdapter->ulTag == MTAG_ADAPTERCB );
    FREE_NDIS_WORK_ITEM( pAdapter, pWork );

    // Stop receiving datagrams (at least on behalf of this SAP) and
    // deregister the SAP.
    //
    NdisAcquireSpinLock( &pAdapter->lockSap );
    {
        pVc = pAdapter->pListenVc;
        pAdapter->pListenVc = NULL;
        hOldSap = pAdapter->NdisSapHandle;
        pAdapter->NdisSapHandle = NULL;
        pAdapter->ulSapPort = 0;
    }
    NdisReleaseSpinLock( &pAdapter->lockSap );

    if (pVc)
    {
        TRACE( TL_I, TM_Cm,
            ( "PtiCmDeregSapPassive: Closing link for Dereg SAP" ) );
        PtiClosePtiLink( pVc );
        DereferenceVc( pVc );
    }
    else
    {
        TRACE( TL_A, TM_Cm, ( "PtiCmDeregSapPassive: !pListenVc?" ) );
    }

    // Remove the adapter references for the NdisSapHandle and for scheduled
    // work.  Remove the address family reference for the NdisSapHandle.  Do
    // all this before telling NDIS the deregister is complete as it may call
    // Halt and unload the driver before we run again, giving C4 bugcheck.
    //
    DereferenceAdapter( pAdapter );
    DereferenceAdapter( pAdapter );
    DereferenceAf( pAdapter );

    // Report result to client.
    //
    TRACE( TL_I, TM_Cm, ( "NdisMCmDeregSapComp" ) );
    NdisMCmDeregisterSapComplete( NDIS_STATUS_SUCCESS, hOldSap );
    TRACE( TL_I, TM_Cm, ( "NdisMCmDeregSapComp done" ) );
}


NDIS_STATUS
PtiCmMakeCall(
    IN NDIS_HANDLE CallMgrVcContext,
    IN OUT PCO_CALL_PARAMETERS CallParameters,
    IN NDIS_HANDLE NdisPartyHandle,
    OUT PNDIS_HANDLE CallMgrPartyContext )

    // Standard 'CmMakeCallHandler' routine called by NDIS when the a client
    // has requested to connect to a remote end-point.  See DDK doc.
    //
{
    NDIS_STATUS status;
    CO_SPECIFIC_PARAMETERS* pMSpecifics;
    CO_AF_TAPI_MAKE_CALL_PARAMETERS UNALIGNED* pTmParams;
    VCCB* pVc;
    ADAPTERCB* pAdapter;
    ULONG ulIpAddress;

    TRACE( TL_I, TM_Cm, ( "PtiCmMakeCall" ) );

    pVc = (VCCB* )CallMgrVcContext;
    if (pVc->ulTag != MTAG_VCCB)
    {
        ASSERT( !"Vtag?" );
        return NDIS_STATUS_INVALID_DATA;
    }

    ReferenceVc( pVc );
    pAdapter = pVc->pAdapter;

    // PTI has no concept of point-to-multi-point "parties".
    //
    if (CallMgrPartyContext)
    {
        *CallMgrPartyContext = NULL;
    }

    // Validate call parameters.
    //
    do
    {
        // PTI provides switched VCs only.
        //
        if (CallParameters->Flags &
                (PERMANENT_VC | BROADCAST_VC | MULTIPOINT_VC))
        {
            status = NDIS_STATUS_NOT_SUPPORTED;
            break;
        }

        // Make sure caller provided the TAPI call parameters we expect.
        // Currently, the only parameter in the TAPI call parameters actually
        // used is the 'ulLineID' identifying the LPTx port.  No validating of
        // the LINE_CALL_PARAMS is done at all as we choose not to be picky
        // about arguments we intend to ignore.
        //
        if (!CallParameters->MediaParameters)
        {
            status = NDIS_STATUS_INVALID_DATA;
            break;
        }

        pMSpecifics = &CallParameters->MediaParameters->MediaSpecific;
        if (pMSpecifics->Length < sizeof(CO_AF_TAPI_MAKE_CALL_PARAMETERS))
        {
            status = NDIS_STATUS_INVALID_LENGTH;
            break;
        }

        pTmParams = (CO_AF_TAPI_MAKE_CALL_PARAMETERS* )&pMSpecifics->Parameters;
        if (pTmParams->ulLineID >= pAdapter->ulActualVcs)
        {
            status = NDIS_STATUS_INVALID_DATA;
            break;
        }

        status = NDIS_STATUS_SUCCESS;
    }
    while (FALSE);

    if (status != NDIS_STATUS_SUCCESS)
    {
        DereferenceVc( pVc );
        return status;
    }

    // Simultaneous MakeCalls on the same VC is a client error, but it's easy
    // to guard against so do that here.
    //
    if (InterlockedCompareExchangePointer(
        &pVc->pMakeCall, CallParameters, NULL ))
    {
        ASSERT( !"Double MakeCall?" );
        DereferenceVc( pVc );
        return NDIS_STATUS_CALL_ACTIVE;
    }

    pVc->pTmParams = pTmParams;

    // Mark that the call is in a state where close requests can be accepted,
    // but incoming packets should not trigger a new incoming call.  Mark the
    // call that an open is pending.
    //
    SetFlags( &pVc->ulFlags,
        (VCBF_ClientOpenPending
         | VCBF_CallClosableByClient
         | VCBF_CallClosableByPeer
         | VCBF_CallInProgress) );

    status = ScheduleWork( pAdapter, MakeCallPassive, pVc );
    if (status != NDIS_STATUS_SUCCESS)
    {
        ASSERT( !"SchedWork?" );
        CallCleanUp( pVc );
        DereferenceVc( pVc );
        return status;
    }

    // The VC reference will be removed by MakeCallPassive.
    //
    TRACE( TL_V, TM_Cm, ( "PtiCmMakeCall pending" ) );
    return NDIS_STATUS_PENDING;
}


VOID
MakeCallPassive(
    IN NDIS_WORK_ITEM* pWork,
    IN VOID* pContext )

    // An NDIS_PROC routine to complete the call initiation begun in
    // LcmCmMakeCall.
    //
{
    ADAPTERCB* pAdapter;
    VCCB* pVc;
    NTSTATUS PtiLinkStatus;
    ULONG PortIndex;

    TRACE( TL_I, TM_Cm, ( "MakeCallPassive" ) );

    // Unpack context information then free the work item.
    //
    pVc = (VCCB* )pContext;
    ASSERT( pVc->ulTag == MTAG_VCCB );
    pAdapter = pVc->pAdapter;
    FREE_NDIS_WORK_ITEM( pAdapter, pWork );

    // Make the call...
    //
    TRACE( TL_N, TM_Cm,
         ( "PtiCmMakeCall: Make Call on TAPI Line Id $%x ...",
           pVc->pTmParams->ulLineID ) );

    // Map TAPI Line Id to Port Index
    //
    PortIndex = LineIdPortLookup( pAdapter, pVc->pTmParams->ulLineID );

    if ( PortIndex > NPORTS )
    {
        TRACE( TL_A, TM_Cm,
             ( "PtiCmMakeCall: Cannot find Port for Line Id",
               pVc->pTmParams->ulLineID ) );

        pVc->status = NDIS_STATUS_TAPI_INVALLINEHANDLE;
        return;
    }

    TRACE( TL_N, TM_Cm,
         ( "PtiCmMakeCall: Making Call on Port $%x ...",
           PortIndex ) );

    PtiLinkStatus = PtiOpenPtiLink( pVc, PortIndex );

    if (ReferenceSap( pAdapter ))
    {
        // Listen VC mechanism-dependent.
        //
        SetFlags( &pAdapter->pListenVc->ulFlags, VCBF_CallInProgress );
        DereferenceSap( pAdapter );
    }

    if (IsWin9xPeer( pVc ))
    {
        SendClientString( pVc->PtiExtension );
    }

    pVc->status = PtiLinkStatus;
    CompleteVc( pVc );

    DereferenceVc( pVc );

    // Remove the reference for scheduled work.
    //
    DereferenceAdapter( pAdapter );

    TRACE( TL_V, TM_Cm,
        ( "PtiCmMakeCall: Exit: Link Status=$%x", PtiLinkStatus ) );
}


NDIS_STATUS
PtiCmCloseCall(
    IN NDIS_HANDLE CallMgrVcContext,
    IN NDIS_HANDLE CallMgrPartyContext,
    IN PVOID CloseData,
    IN UINT Size )

    // Standard 'CmCloseCallHandler' routine called by NDIS when the a client
    // has requested to tear down a call.  See DDK doc.
    //
{
    NDIS_STATUS status;
    ADAPTERCB* pAdapter;
    VCCB* pVc;
    ULONG ulFlags;
    BOOLEAN fCallClosable;

    TRACE( TL_I, TM_Cm, ( "PtiCmCloseCall: pVc=$%p", CallMgrVcContext ) );

    pVc = (VCCB* )CallMgrVcContext;
    if (pVc->ulTag != MTAG_VCCB)
    {
        ASSERT( !"Vtag?" );
        return NDIS_STATUS_INVALID_DATA;
    }
    ReferenceVc( pVc );

    status = NDIS_STATUS_SUCCESS;

    pAdapter = pVc->pAdapter;

    NdisAcquireSpinLock( &pVc->lockV );
    {
        ulFlags = ReadFlags( &pVc->ulFlags );

        if (ulFlags & VCBF_CallClosableByClient)
        {
            fCallClosable = TRUE;

            // Accepting this close makes the call no longer closable by
            // client or peer.  Any peer operation that was pending is
            // cleared, and a client close becomes pending.  It is possible to
            // have both a client open and close pending at the same time.
            //
            ClearFlags( &pVc->ulFlags,
                (VCBF_CallClosableByClient
                 | VCBF_CallClosableByPeer
                 | VCBF_PeerClosePending
                 | VCBF_PeerOpenPending) );
            SetFlags( &pVc->ulFlags, VCBF_ClientClosePending );

            // If a client open is pending, it fails.
            //
            if (ulFlags & VCBF_ClientOpenPending)
            {
                pVc->status = NDIS_STATUS_TAPI_DISCONNECTMODE_NORMAL;
            }
        }
        else
        {
            TRACE( TL_A, TM_Cm, ( "Call not closable" ) );
            fCallClosable = FALSE;
        }
    }
    NdisReleaseSpinLock( &pVc->lockV );

    if (fCallClosable)
    {
        // Close the call, being graceful if possible.
        //
        status = ScheduleWork( pAdapter, CloseCallPassive, pVc );
    }

    if (status != NDIS_STATUS_SUCCESS)
    {
        DereferenceVc( pVc );
        return status;
    }

    TRACE( TL_V, TM_Cm, ( "PtiCmCloseCall: Exit: Pending" ) );
    return NDIS_STATUS_PENDING;
}



VOID
PtiCmIncomingCallComplete(
    IN NDIS_STATUS Status,
    IN NDIS_HANDLE CallMgrVcContext,
    IN PCO_CALL_PARAMETERS CallParameters )

    // Standard 'CmIncomingCallCompleteHandler' routine called by NDIS when
    // a client has responded to the call-managers's previously dispatched
    // incoming call.  See DDK doc.
    //
{
    VCCB* pVc;

    TRACE( TL_I, TM_Cm,
        ( "PtiCmInCallComp, pVc=$%p, Status=$%08x",
        CallMgrVcContext, Status ) );

    pVc = (VCCB* )CallMgrVcContext;
    if (pVc->ulTag != MTAG_VCCB)
    {
        ASSERT( !"Vtag?" );
        return;
    }

    ReferenceVc( pVc );

    if (Status != NDIS_STATUS_SUCCESS)
    {
        pVc->status = Status;

        // Turn off the "call NdisMCmDispatchIncomingCloseCall if peer
        // terminates the call" flag.  It was turned on even though peer
        // pended, per JameelH.
        //
        ClearFlags( &pVc->ulFlags, VCBF_VcDispatched );
    }

    SetupVcComplete( pVc );

    DereferenceVc( pVc );

    TRACE( TL_V, TM_Cm, ( "PtiCmInCallComp: Exit" ) );
}


VOID
PtiCmActivateVcComplete(
    IN NDIS_STATUS Status,
    IN NDIS_HANDLE CallMgrVcContext,
    IN PCO_CALL_PARAMETERS CallParameters )

    // Standard 'CmActivateVcCompleteHandler' routine called by NDIS when the
    // mini-port has completed the call-manager's previous request to activate
    // a virtual circuit.  See DDK doc.
    //
{
    ASSERT( !"PtiCmActVcComp?" );
}


VOID
PtiCmDeactivateVcComplete(
    IN NDIS_STATUS Status,
    IN NDIS_HANDLE CallMgrVcContext )

    // Standard 'CmDeactivateVcCompleteHandler' routine called by NDIS when
    // the mini-port has completed the call-manager's previous request to
    // de-activate a virtual circuit.  See DDK doc.
    //
{
    ASSERT( !"PtiCmDeactVcComp?" );
}


NDIS_STATUS
PtiCmModifyCallQoS(
    IN NDIS_HANDLE CallMgrVcContext,
    IN PCO_CALL_PARAMETERS CallParameters )

    // Standard 'CmModifyQoSCallHandler' routine called by NDIS when a client
    // requests a modification in the quality of service provided by the
    // virtual circuit.  See DDK doc.
    //
{
    TRACE( TL_N, TM_Cm, ( "PtiCmModQoS" ) );

    // There is no useful concept of quality of service for DirectParallel.
    //
    return NDIS_STATUS_NOT_SUPPORTED;
}


NDIS_STATUS
PtiCmRequest(
    IN NDIS_HANDLE CallMgrAfContext,
    IN NDIS_HANDLE CallMgrVcContext,
    IN NDIS_HANDLE CallMgrPartyContext,
    IN OUT PNDIS_REQUEST NdisRequest )

    // Standard 'CmRequestHandler' routine called by NDIS in response to a
    // client's request for information from the mini-port.
    //
{
    ADAPTERCB* pAdapter;
    VCCB* pVc;
    NDIS_STATUS status;

    TRACE( TL_I, TM_Cm, ( "PtiCmReq" ) );

    pAdapter = (ADAPTERCB* )CallMgrAfContext;
    if (pAdapter->ulTag != MTAG_ADAPTERCB)
    {
        ASSERT( !"Atag?" );
        return NDIS_STATUS_INVALID_DATA;
    }

    pVc = (VCCB* )CallMgrVcContext;
    if (pVc && pVc->ulTag != MTAG_VCCB)
    {
        ASSERT( !"Vtag?" );
        return NDIS_STATUS_INVALID_DATA;
    }

    switch (NdisRequest->RequestType)
    {
        case NdisRequestQueryInformation:
        {
            status = QueryCmInformation(
                pAdapter,
                pVc,
                NdisRequest->DATA.QUERY_INFORMATION.Oid,
                NdisRequest->DATA.QUERY_INFORMATION.InformationBuffer,
                NdisRequest->DATA.QUERY_INFORMATION.InformationBufferLength,
                &NdisRequest->DATA.QUERY_INFORMATION.BytesWritten,
                &NdisRequest->DATA.QUERY_INFORMATION.BytesNeeded );
            break;
        }

        case NdisRequestSetInformation:
        {
            TRACE( TL_A, TM_Cm,
               ( "CmSetOID=%d?", NdisRequest->DATA.SET_INFORMATION.Oid ) );
            status = NDIS_STATUS_NOT_SUPPORTED;
            break;
        }

        default:
        {
            status = NDIS_STATUS_NOT_SUPPORTED;
            TRACE( TL_A, TM_Cm, ( "CmType=%d?", NdisRequest->RequestType ) );
            break;
        }
    }

    return status;
}


//-----------------------------------------------------------------------------
// Call utility routines (almost alphabetically)
// Some are used externally
//-----------------------------------------------------------------------------


NDIS_STATUS
PtiOpenPtiLink(
    IN VCCB* pVc,
    IN ULONG ulPort)

    // Opens the PTILINK device
    //
    // IMPORTANT: Must only be called at PASSIVE IRQL.
    //
{
    UNICODE_STRING      name, prefix, digits;
    WCHAR               nameBuffer[40], digitsBuffer[10];
    NTSTATUS            ntStatus;
    OBJECT_ATTRIBUTES   oa;
    IO_STATUS_BLOCK     iosb;
    LONG                lRef;
    ADAPTERCB*          pAdapter;

    TRACE( TL_N, TM_Cm, ( "PtiOpenPtiLink: Port=$%x", ulPort ) );

    if ( pVc->ulTag != MTAG_VCCB )
    {
        ASSERT( !"Vtag?" );
        return NDIS_STATUS_INVALID_DATA;
    }
    pAdapter = pVc->pAdapter;

    // If PtiLink[ulPort] is already open, do nothing
    //   It may have already been opened by SAP actions

    if ( pAdapter->hPtiLinkTable[ulPort] == 0 )
    {
        TRACE( TL_V, TM_Cm, ( "PtiOpenPtiLink: Making name for Port=$%x", ulPort ) );

        // convert integer port number into unicode string
        //
        RtlZeroMemory( digitsBuffer, sizeof(digitsBuffer) );
        digits.Length = 0;
        digits.MaximumLength = 20;
        digits.Buffer = digitsBuffer;
        ntStatus = RtlIntegerToUnicodeString( ulPort + 1, 10, &digits );

        if ( !NT_SUCCESS(ntStatus) )
        {
            TRACE( TL_A, TM_Cm, ( "PtiOpenPtiLink: Port=$%x invalid?", ulPort ) );
            return NDIS_STATUS_INVALID_DATA;
        }

        RtlZeroMemory( nameBuffer, sizeof(nameBuffer) );
        name.Length = 0;
        name.MaximumLength = 80;
        name.Buffer = nameBuffer;
        TRACE( TL_V, TM_Cm, ( "PtiOpenPtiLink: Name should be NULL: %wZ", &name ) );

        RtlInitUnicodeString( &prefix, L"\\DosDevices\\PTILINK" );
        TRACE( TL_V, TM_Cm, ( "PtiOpenPtiLink: Prefix part        : %wZ", &prefix ) );
        TRACE( TL_V, TM_Cm, ( "PtiOpenPtiLink: Digits part        : %wZ", &digits ) );

        RtlAppendUnicodeStringToString( &name, &prefix );
        TRACE( TL_V, TM_Cm, ( "PtiOpenPtiLink: Name with prefix   : %wZ", &name ) );

        RtlAppendUnicodeStringToString( &name, &digits );
        TRACE( TL_V, TM_Cm, ( "PtiOpenPtiLink: Name with digits   : %wZ", &name ) );

        InitializeObjectAttributes(
            &oa, &name, OBJ_CASE_INSENSITIVE, NULL, NULL );

        // Open the link device
        //
        TRACE( TL_V, TM_Cm, ( "PtiOpenPtiLink: Opening %wZ", &name ) );

        ntStatus = ZwCreateFile(
                        &pVc->hPtiLink,             // pointer to desired handle
                        FILE_READ_DATA | FILE_WRITE_DATA,
                        &oa,
                        &iosb,
                        NULL,
                        FILE_ATTRIBUTE_NORMAL,
                        0,
                        FILE_OPEN,
                        0,
                        NULL,
                        0 );

        if ( !NT_SUCCESS( ntStatus ) )
        {
            TRACE( TL_A, TM_Cm, ( "PtiOpenPtiLink: %wZ Open Failure = $%x",
                                    &name, ntStatus ) );
            return NDIS_STATUS_RESOURCES;
        }

        // save a copy of the PtiLink handle in ADAPTERCB
        //
        pAdapter->hPtiLinkTable[ulPort] = pVc->hPtiLink;
        TRACE( TL_N, TM_Cm, ( "PtiOpenPtilink: h=$%p",
            pAdapter->hPtiLinkTable[ulPort] ) );

        RtlInitUnicodeString( &name, NULL );
    }

    // Init the PtiLink API ... getting the extension pointers
    //
    pVc->ulVcParallelPort = ulPort;
    ntStatus = PtiInitialize( ulPort,
                              &pVc->Extension,
                              &pVc->PtiExtension);          // get PTILINKx extension
                                                            //  also fires ECPdetect
                                                            //  and enables port IRQ

    TRACE( TL_V, TM_Cm, ( "PtiOpenPtilink: PtiLink Init: Ext=$%p, PtiExt=$%p",
                           pVc->Extension,
                           pVc->PtiExtension ) );

    if ( (pVc->Extension == NULL) || (pVc->PtiExtension == NULL) )
    {
        TRACE( TL_A, TM_Cm, (
            "PtiOpenPtiLink: Null Pointer Detected: Ext=$%p, PtiExt=$%p",
                pVc->Extension,
                pVc->PtiExtension ) );

        return NDIS_STATUS_RESOURCES;
    }

    if ( !NT_SUCCESS( ntStatus ) )
    {
        TRACE( TL_V, TM_Cm, ( "PtiInitialize Failure = $%08x", ntStatus ) );
        return NDIS_STATUS_RESOURCES;
    }

    // Register our callbacks with PtiLink
    //
    TRACE( TL_V, TM_Cm, ( "PtiOpenPtiLink: RegCb pV=$%p", pVc ) );
    PtiRegisterCallbacks(pVc->Extension,                    // the PTILINKx extension
                         PtiCbGetReadBuffer,                // our get buffer routine
                         PtiRx,                             // our receive complete routine
                         PtiCbLinkEventHandler,             // our link event handler
                         pVc);                              // our context

    // Zero the counters
    //
    pVc->ulTotalPackets = 0;

    TRACE( TL_V, TM_Cm, ( "PtiOpenPtiLink: Exit" ) );
    return NDIS_STATUS_SUCCESS;
}


NDIS_STATUS
PtiClosePtiLink(
    IN VCCB* pVc )

    // Closes the PTILINK device
    //
    // IMPORTANT: This routine must only be called at PASSIVE IRQL.
    //
{
    NTSTATUS ntStatus;
    ADAPTERCB* pAdapter;

    if (pVc->ulTag != MTAG_VCCB)
    {
        ASSERT( !"Vtag?" );
        return NDIS_STATUS_INVALID_DATA;
    }
    pAdapter = pVc->pAdapter;

    TRACE( TL_N, TM_Cm, ( "PtiClosePtiLink: pVc=$%p, Port$%x, h=$%p",
        pVc, pVc->ulVcParallelPort,
        pAdapter->hPtiLinkTable[ pVc->ulVcParallelPort ] ));

    // dispose of the connection
    //
    ntStatus = ZwClose( pAdapter->hPtiLinkTable[ pVc->ulVcParallelPort ] );
    pVc->hPtiLink = NULL;
    pAdapter->hPtiLinkTable[ pVc->ulVcParallelPort ] = NULL;
    pVc->ulVcParallelPort = 0;

    if (ReferenceSap( pAdapter ))
    {
        pAdapter->pListenVc->hPtiLink = NULL;
        DereferenceSap( pAdapter );
    }

    if ( !NT_SUCCESS( ntStatus ) )
    {
        // close failed
        TRACE( TL_V, TM_Cm,
            ( "PtiClosePtiLink: Error: CloseFailure=$%08x", ntStatus ) );
        return ntStatus;
    }

    TRACE( TL_V, TM_Cm, ( "PtiClosePtiLink: Exit" ) );
    return NDIS_STATUS_SUCCESS;
}


VOID
CallCleanUp(
    IN VCCB* pVc )

    // De-associates the VC from the tunnel, preparing for and de-activating
    // the call.
    //
{
    NDIS_STATUS status;
    ULONG ulFlags;

    ulFlags = ReadFlags( &pVc->ulFlags );

    TRACE( TL_A, TM_Cm,
         ( "CallCleanUp: pVc=$%p, fActivated=%x",
            pVc,
            ulFlags & VCBF_VcActivated ) );

    ASSERT( pVc->ulTag == MTAG_VCCB );

    // Client initiated close completed.
    //
    if (ulFlags & VCBF_VcActivated)
    {
        TRACE( TL_I, TM_Recv, ( "NdisMCmDeactVc" ) );
        status = NdisMCmDeactivateVc( pVc->NdisVcHandle );
        TRACE( TL_I, TM_Recv, ( "NdisMCmDeactVc=$%x", status ) );
        ASSERT( status == NDIS_STATUS_SUCCESS );

        ClearFlags( &pVc->ulFlags, VCBF_VcActivated );
        DereferenceCall( pVc );

        // The above actions lead to the call reference eventually going to 0,
        // at which time clean up resumes in DereferenceCall.
        //
    }
    else
    {
        InactiveCallCleanUp( pVc );
    }
}


VOID
CallSetupComplete(
    IN VCCB* pVc )

    // Clean up 'pVc' allocations used only at call setup.
    //
{
    if (InterlockedExchangePointer( &pVc->pMakeCall, NULL ))
    {
        ASSERT( pVc->pTmParams );
        pVc->pTmParams = NULL;
    }

    if (pVc->pInCall)
    {
        FREE_NONPAGED( pVc->pInCall );
        pVc->pInCall = NULL;
        pVc->pTiParams = NULL;
    }
}


VOID
CallTransitionComplete(
    IN VCCB* pVc )

    // Sets 'pVc's state to it's idle state and sets up for reporting the
    // result to the client after the lock is released.
    //
    // IMPORTANT: Caller must hold 'pVc->lockV'.
    //
{
    ULONG ulFlags;

    ulFlags = ReadFlags( &pVc->ulFlags );
    if (!(ulFlags & VCBM_Pending))
    {
        if (ulFlags & VCBF_CallClosableByPeer)
        {
            // Nothing else was pending and the call is closable so either
            // peer initiated a close or some fatal error occurred which will
            // be cleaned up as if peer initiated a close.
            //
            ASSERT( pVc->status != NDIS_STATUS_SUCCESS );
            SetFlags( &pVc->ulFlags, VCBF_PeerClosePending );
            ClearFlags( &pVc->ulFlags, VCBF_CallClosableByPeer );
        }
        else
        {
            // Nothing was pending and the call's not closable, so there's no
            // action required for this transition.
            //
            TRACE( TL_A, TM_Fsm, ( "Call not closable" ) );
            return;
        }
    }
    else if (ulFlags & VCBF_ClientOpenPending)
    {
        if (pVc->status != NDIS_STATUS_SUCCESS)
        {
            // A pending client open just failed and will bring down the call.
            // From this point on we will fail new attempts to close the call
            // from both client and peer.
            //
            ClearFlags( &pVc->ulFlags,
                (VCBF_CallClosableByClient | VCBF_CallClosableByPeer ));
        }
    }
    else if (ulFlags & VCBF_PeerOpenPending)
    {
        if (pVc->status != NDIS_STATUS_SUCCESS)
        {
            // A pending peer open just failed and will bring down the call.
            // From this point on we will fail new attempts to close the call
            // from the peer.  Client closes must be accepted because of the
            // way CoNDIS loops dispatched close calls back to the CM's close
            // handler.
            //
            ClearFlags( &pVc->ulFlags, VCBF_CallClosableByPeer );
        }
    }
}


VOID
CloseCallPassive(
    IN NDIS_WORK_ITEM* pWork,
    IN VOID* pContext )

    // An NDIS_PROC routine to complete the call close begun in
    // LcmCmCloseCall.
    //
{
    ADAPTERCB* pAdapter;
    VCCB* pVc;
    NTSTATUS PtiLinkStatus;

    // Unpack context information then free the work item.
    //
    pVc = (VCCB* )pContext;
    ASSERT( pVc->ulTag == MTAG_VCCB );
    pAdapter = pVc->pAdapter;
    FREE_NDIS_WORK_ITEM( pAdapter, pWork );

    TRACE( TL_I, TM_Cm, ( "CloseCallPassive: Closing link for Close Call" ) );
    PtiClosePtiLink( pVc );
    if (ReferenceSap( pAdapter ))
    {
        TRACE( TL_N, TM_Cm, ( "CloseCall: reOpening link, SAP exists" ) );
        PtiOpenPtiLink( pAdapter->pListenVc, pAdapter->ulSapPort );
        DereferenceSap( pAdapter );
    }

    NdisAcquireSpinLock( &pVc->lockV );
    {
        CallTransitionComplete( pVc );
    }
    NdisReleaseSpinLock( &pVc->lockV );

    CompleteVc( pVc );

    // Remove the reference added by PtiCmCloseCall.
    //
    DereferenceVc( pVc );

    // Remove the reference for scheduled work.
    //
    DereferenceAdapter( pAdapter );
    TRACE( TL_V, TM_Cm, ( "CloseCall: Exit" ) );
}


VOID
CompleteVc(
    IN VCCB* pVc )

    // Complete the pending operation for a specific VC
    //
{
    NDIS_STATUS status;
    ADAPTERCB* pAdapter;
    LIST_ENTRY* pLink;

    ULONG ulFlags;

    pAdapter = pVc->pAdapter;

    TRACE( TL_V, TM_Recv, ( "CompleteVc: pVc=$%p", pVc ) );

    NdisAcquireSpinLock( &pVc->lockV );
    {
        // Note the pending flags then clear them, to ensure that all
        // pending operations are completed exactly once.  This is
        // necessary since ClientOpen and ClientClose events may be
        // pending simultaneously.  (Thanks a lot NDIS guys).
        //
        ulFlags = ReadFlags( &pVc->ulFlags );
        ClearFlags( &pVc->ulFlags, VCBM_Pending );

        // Convert client close pending to client close completion,
        // for reference later when call references reach zero.  The
        // flag determines if NdisMCmCloseCallComplete must be called.
        //
        if (ulFlags & VCBF_ClientClosePending)
        {
            SetFlags( &pVc->ulFlags, VCBF_ClientCloseCompletion );
        }
    }
    NdisReleaseSpinLock( &pVc->lockV );

    if (ulFlags & VCBF_PeerOpenPending)
    {
        TRACE( TL_N, TM_Recv,
            ( "CompleteVc: PeerOpen complete, Status=$%x", pVc->status ) );

        if (pVc->status == NDIS_STATUS_SUCCESS)
        {
            // Peer initiated call succeeded.
            //
            ASSERT( ulFlags & VCBF_VcDispatched );
            TRACE( TL_I, TM_Recv, ( "CompleteVc: NdisMCmDispCallConn" ) );
            NdisMCmDispatchCallConnected( pVc->NdisVcHandle );
            TRACE( TL_I, TM_Recv, ( "CompleteVc: NdisMCmDispCallConn done" ) );

            CallSetupComplete( pVc );
        }
        else
        {
            // Peer initiated call failed.
            //
            if (ulFlags & VCBF_VcDispatched)
            {
                ClearFlags( &pVc->ulFlags, VCBF_VcDispatched );

                TRACE( TL_I, TM_Recv,
                    ( "CompleteVc: NdisMCmDispInCloseCall: status=$%x", pVc->status ) );
                NdisMCmDispatchIncomingCloseCall(
                    pVc->status, pVc->NdisVcHandle, NULL, 0 );
                TRACE( TL_I, TM_Recv,
                    ( "CompleteVc: NdisMCmDispInCloseCall done" ) );

                // Client will call NdisClCloseCall which will get our
                // PtiCloseCall handler called to clean up call setup,
                // de-activate and delete the VC, as necessary.
                //
            }
            else
            {
                // Return the VC to "just created" state.
                //
                CallCleanUp( pVc );
            }
        }
    }
    else if (ulFlags & VCBF_ClientOpenPending)
    {

        TRACE( TL_N, TM_Recv,
            ( "CompleteVc: ClientOpen complete: status=$%x", pVc->status ) );

        // Pick the call parameters out of the VC block now.  See non-success
        // case below.
        //

        //
        // Set our flowspec params based on the actual
        // connection speed
        //
        {
            CO_CALL_PARAMETERS* pCp;
            CO_CALL_MANAGER_PARAMETERS* pCmp;
            LINE_CALL_INFO* pLci;
            CO_MEDIA_PARAMETERS* pMp;
            CO_AF_TAPI_MAKE_CALL_PARAMETERS* pTi;
            LINE_CALL_PARAMS* pLcp;

            ASSERT( pVc->pMakeCall );

            pCp = pVc->pMakeCall;
            pCmp = pCp->CallMgrParameters;

            //
            // Might want to make this report the actual
            // connection speed in the future
            //
            pCmp->Transmit.TokenRate =
            pCmp->Transmit.PeakBandwidth =
            pCmp->Receive.TokenRate =
            pCmp->Receive.PeakBandwidth = PTI_LanBps/8;

            pMp = pCp->MediaParameters;

            pTi = (CO_AF_TAPI_MAKE_CALL_PARAMETERS*)
                &pMp->MediaSpecific.Parameters[0];

            pLcp = (LINE_CALL_PARAMS*)
                ((ULONG_PTR)pTi->LineCallParams.Offset +
                 (ULONG_PTR)pTi);

            //
            // Might want to make this report the actual
            // connection speed in the future
            //
            pLcp->ulMinRate =
            pLcp->ulMaxRate = PTI_LanBps/8;

        }

        if (pVc->status == NDIS_STATUS_SUCCESS)
        {
            // Client initiated open, i.e. MakeCall, succeeded.
            //
            // Activating the VC is a CoNDIS preliminary to reporting the
            // MakeCall complete.  For L2TP, all it does is get the NDIS
            // state flags set correctly.
            //
            TRACE( TL_I, TM_Recv, ( "CompleteVc: NdisMCmActivateVc" ) );
            ASSERT( pVc->pMakeCall );
            status = NdisMCmActivateVc(
                pVc->NdisVcHandle, pVc->pMakeCall );
            TRACE( TL_I, TM_Recv, ( "CompleteVc: NdisMCmActivateVc: status=$%x", status ) );
            ASSERT( status == NDIS_STATUS_SUCCESS );

            SetFlags( &pVc->ulFlags, VCBF_VcActivated );
            ReferenceCall( pVc );
        }
        else
        {
            // Clean up the call parameters before calling MakeCallComplete
            // because they must not be referenced after that call.
            //
            CallSetupComplete( pVc );
        }

        TRACE( TL_I, TM_Recv, ( "CompleteVc: NdisMCmMakeCallComp, status=$%x",
            pVc->status ) );
        NdisMCmMakeCallComplete(
            pVc->status, pVc->NdisVcHandle, NULL, NULL, pVc->pMakeCall );
        TRACE( TL_I, TM_Recv, ( "CompleteVc: NdisMCmMakeCallComp done" ) );

        if (pVc->status != NDIS_STATUS_SUCCESS)
        {
            // Return the VC to "just created" state.
            //
            InactiveCallCleanUp( pVc );
        }
    }
    else if (ulFlags & VCBF_PeerClosePending )
    {
        TRACE( TL_N, TM_Recv, ( "CompleteVc: PeerClose complete, status=$%x", pVc->status ) );

        // Peer initiated close completed.
        //
        TRACE( TL_I, TM_Recv, ( "CompleteVc: NdisMCmDispInCloseCall, status=$%x",
            pVc->status ) );
        NdisMCmDispatchIncomingCloseCall(
            pVc->status, pVc->NdisVcHandle, NULL, 0 );
        TRACE( TL_I, TM_Recv, ( "CompleteVc: NdisMCmDispInCloseCall done" ) );

        // Client will call NdisClCloseCall while processing the above
        // which will get our PtiCloseCall handler called to de-activate
        // and delete the VC, as necessary.
        //
    }
    else if (ulFlags & VCBF_ClientClosePending)
    {
        // This section eventually runs for all successful unclosed
        // calls, whether peer or client initiated or closed.
        //
        TRACE( TL_N, TM_Recv,
            ( "CompleteVc: ClientClose complete, status=$%x", pVc->status ) );

        // Deactivate the VC and return all sent packets to the client above.
        // These events will eventually lead to the call being dereferenced to
        // zero, at which time the close is completed, and if peer initiated,
        // the VC is deleted.
        //
        // Note: When MakeCall is cancelled by a Close request, these actions
        //       occur during the InactiveCallCleanUp in the ClientOpenPending
        //       completion code handling, rather than the CallCleanUp (which
        //       leads to InactiveCallCleanUp) here.  In this case, this block
        //       does NOT run even though the ClientClosePending flag is set.
        //       Consider this before adding code here.
        //
        CallCleanUp( pVc );
    }

    TRACE( TL_N, TM_Recv,( "CompleteVc: Exit" ) );
}


VOID
DereferenceAf(
    IN ADAPTERCB* pAdapter )

    // Removes a reference from the address family of adapter control block
    // 'pAdapter', and when frees the block when the last reference is
    // removed.
    //
{
    LONG lRef;

    lRef = NdisInterlockedDecrement( &pAdapter->lAfRef );

    TRACE( TL_N, TM_Ref, ( "DerefAf to %d", lRef ) );
    ASSERT( lRef >= 0 );

    if (lRef == 0)
    {
        HANDLE h;

        // Remove the reference for the NdisAfHandle.  Must do this *before*
        // telling NDIS the close succeeded as it may Halt and unload the
        // driver before we run again here, giving C4 bugcheck.
        //
        h = pAdapter->NdisAfHandle;
        InterlockedExchangePointer( &pAdapter->NdisAfHandle, NULL );
        DereferenceAdapter( pAdapter );

        // Tell NDIS it's close is complete.
        //
        TRACE( TL_I, TM_Cm, ( "NdisMCmCloseAfComp" ) );
        NdisMCmCloseAddressFamilyComplete( NDIS_STATUS_SUCCESS, h );
        TRACE( TL_I, TM_Cm, ( "NdisMCmCloseAfComp done" ) );
    }
}


VOID
DereferenceCall(
    IN VCCB* pVc )

    // Removes a reference from the call active on 'pVc', invoking call clean
    // up when the value reaches zero.
    //
{
    LONG lRef;
    NDIS_STATUS status;
    ADAPTERCB* pAdapter;
    LIST_ENTRY* pLink;

    pAdapter = pVc->pAdapter;

    NdisAcquireSpinLock( &pVc->lockCall );
    {
        lRef = --pVc->lCallRef;
        TRACE( TL_N, TM_Ref, ( "DerefCall to %d", pVc->lCallRef ) );
    }
    NdisReleaseSpinLock( &pVc->lockCall );

    if (lRef == 0)
    {
        CallCleanUp( pVc );
    }
}


VOID
DereferenceSap(
    IN ADAPTERCB* pAdapter )

    // Removes a reference from the SAP active on 'pAdapter', invoking
    // Deregiter SAP completion handling when the value reaches zero.
    //
{
    LONG lRef;
    NDIS_STATUS status;

    NdisAcquireSpinLock( &pAdapter->lockSap );
    {
        lRef = --pAdapter->lSapRef;
        TRACE( TL_N, TM_Ref, ( "DerefSap to %d", pAdapter->lSapRef ) );
    }
    NdisReleaseSpinLock( &pAdapter->lockSap );

    if (lRef == 0)
    {
        status = ScheduleWork( pAdapter, DeregisterSapPassive, pAdapter );
        ASSERT( status == NDIS_STATUS_SUCCESS );
    }
}


VOID
InactiveCallCleanUp(
    IN VCCB* pVc )

    // Cleans up a deactivated call.  To clean up a call that might be active,
    // use CallCleanUp instead.  Returns the VC to "just created" state, in
    // case client decides to make another call without deleting the VC.
    //
{
    ULONG ulFlags;
    BOOLEAN fVcCreated;
    ADAPTERCB* pAdapter;
    LIST_ENTRY* pLink;

    TRACE( TL_N, TM_Cm, ( "InactiveCallCleanUp, pVc=$%p", pVc ) );

    pAdapter = pVc->pAdapter;

    // Release any call parameter allocations and disable receives.
    //
    CallSetupComplete( pVc );
    ClearFlags( &pVc->ulFlags, VCBF_CallInProgress );

    ulFlags = ReadFlags( &pVc->ulFlags );

#if 0
    if (ulFlags & VCBF_PeerInitiatedCall)
    {
        DereferenceSap( pAdapter );
    }
#endif

    // Return the VC to "just created" state.
    //
    ClearFlags( &pVc->ulFlags, 0xFFFFFFFF );
    pVc->status = NDIS_STATUS_SUCCESS;
    pVc->usResult = 0;
    pVc->usError = 0;
    pVc->ulConnectBps = 0;

    if (ulFlags & VCBF_ClientCloseCompletion)
    {
        TRACE( TL_I, TM_Recv, ( "NdisMCmCloseCallComp(OK)" ) );
        NdisMCmCloseCallComplete(
            NDIS_STATUS_SUCCESS, pVc->NdisVcHandle, NULL );
        TRACE( TL_I, TM_Recv, ( "NdisMCmCloseCallComp done" ) );

        // Careful, if this was a client created VC, client may have deleted
        // it, so 'pVc' must not be referenced hereafter in that case.
        //
    }

    // When peer initiates the call, we create the VC and so delete it
    // here.  Otherwise, client created it and we leave it to him to
    // delete it when he's ready.
    //
    if (ulFlags & VCBF_VcCreated)
    {
        NDIS_STATUS status;

        TRACE( TL_I, TM_Recv, ( "InactiveCallCleanUp: NdisMCmDelVc" ) );
        status = NdisMCmDeleteVc( pVc->NdisVcHandle );
        TRACE( TL_I, TM_Recv, ( "InactiveCallCleanUp: NdisMCmDelVc: status=$%x", status ) );
        ASSERT( status == NDIS_STATUS_SUCCESS );
        PtiCmDeleteVc( pVc );

        // Careful, 'pVc' has been deleted and must not be referenced
        // hereafter.
        //
    }
}

#if 0
ULONG
LineIdAdd(
    IN ADAPTERCB* pAdapter,
    IN ULONG LineId )

    // Insert the LineId in the first available slot in ulLineIds
    // Return the port index associated with the new LineId,
    //   or an invalid port index if the LineId cannot be added
    //
{
    ULONG   ulPortIndex;

    for (ulPortIndex = 0; ulPortIndex < NPORTS; ulPortIndex++)
    {
        // If the port exists and has no assigned LineId
        //
        if ( ( pAdapter->ulPtiLinkState[ulPortIndex] & PLSF_PortExists ) &&
             !( pAdapter->ulPtiLinkState[ulPortIndex] & PLSF_LineIdValid))
        {
            // assign the TAPI Line Id to this port
            // and return the port index
            //
            pAdapter->ulLineIds[ulPortIndex] = LineId;
            pAdapter->ulPtiLinkState[ulPortIndex] |= PLSF_LineIdValid;
            break;
        }
    }

    return ulPortIndex;
}
#endif

ULONG
LineIdPortLookup(
    IN ADAPTERCB* pAdapter,
    IN ULONG LineId )

    // Find the LineId in ulLineIds
    // Return the port index associated with the LineId,
    //   or an invalid port index if the LineId cannot be found
    //
{
    ULONG   ulPortIndex;

    for (ulPortIndex = 0; ulPortIndex < NPORTS; ulPortIndex++)
    {
        // If the port exists and
        //
        if ( ( pAdapter->ulPtiLinkState[ulPortIndex] & PLSF_PortExists ) &&
             ( pAdapter->ulPtiLinkState[ulPortIndex] & PLSF_LineIdValid) &&
             ( LineId == pAdapter->ulLineIds[ulPortIndex] ))
        {
            // return the port index
            //
            break;
        }
    }

    return ulPortIndex;
}


NDIS_STATUS
QueryCmInformation(
    IN ADAPTERCB* pAdapter,
    IN VCCB* pVc,
    IN NDIS_OID Oid,
    IN PVOID InformationBuffer,
    IN ULONG InformationBufferLength,
    OUT PULONG BytesWritten,
    OUT PULONG BytesNeeded )

    // Handle Call Manager QueryInformation requests.  Arguments are as for
    // the standard NDIS 'MiniportQueryInformation' handler except this
    // routine does not count on being serialized with respect to other
    // requests.
    //
{
    #define PTI_PORT_NAME_LEN 4

    typedef struct
    PTI_CO_TAPI_LINE_CAPS
    {
        CO_TAPI_LINE_CAPS caps;
        WCHAR achLineName[ MAXLPTXNAME + 1 ];
    }
    PTI_CO_TAPI_LINE_CAPS;

    NDIS_STATUS status;
    ULONG ulInfo;
    VOID* pInfo;
    ULONG ulInfoLen;
    ULONG extension;
    ULONG ulPortIndex;
    CO_TAPI_CM_CAPS cmcaps;
    PTI_CO_TAPI_LINE_CAPS pticaps;
    CO_TAPI_ADDRESS_CAPS addrcaps;
    CO_TAPI_CALL_DIAGNOSTICS diags;

    status = NDIS_STATUS_SUCCESS;

    // The cases in this switch statement find or create a buffer containing
    // the requested information and point 'pInfo' at it, noting it's length
    // in 'ulInfoLen'.  Since many of the OIDs return a ULONG, a 'ulInfo'
    // buffer is set up as the default.
    //
    ulInfo = 0;
    pInfo = &ulInfo;
    ulInfoLen = sizeof(ulInfo);

    switch (Oid)
    {
        case OID_CO_TAPI_CM_CAPS:
        {
            TRACE( TL_N, TM_Cm, ( "QCm(OID_CO_TAPI_CM_CAPS)" ) );

            NdisZeroMemory( &cmcaps, sizeof(cmcaps) );

            // Assumes that the LINE and ADDRESS CAPS OIDs will be requested
            // after this one.  TAPI LineIDs are associated with LPTx ports at
            // that time.  This should be OK since named ports cannot
            // reasonably be chosen based on an arbitrary LineID.
            //
            cmcaps.ulCoTapiVersion = CO_TAPI_VERSION;
            cmcaps.ulNumLines = pAdapter->ulActualVcs;
            cmcaps.ulFlags = CO_TAPI_FLAG_PER_LINE_CAPS;
            pInfo = &cmcaps;
            ulInfoLen = sizeof(cmcaps);
            break;
        }

        case OID_CO_TAPI_LINE_CAPS:
        {
            CO_TAPI_LINE_CAPS* pInCaps;
            LINE_DEV_CAPS* pldc;
            ULONG ulPortForLineId;

            TRACE( TL_N, TM_Cm, ( "QCm(OID_CO_TAPI_LINE_CAPS)" ) );

            if (InformationBufferLength < sizeof(PTI_CO_TAPI_LINE_CAPS))
            {
                status = NDIS_STATUS_INVALID_DATA;
                ulInfoLen = 0;
                break;
            }

            ASSERT( InformationBuffer );
            pInCaps = (CO_TAPI_LINE_CAPS* )InformationBuffer;

            NdisZeroMemory( &pticaps, sizeof(pticaps) );
            pldc = &pticaps.caps.LineDevCaps;

            // get the LineId from the incoming pInCaps (CO_TAPI_LINE_CAPS)
            //
            pticaps.caps.ulLineID = pInCaps->ulLineID;

            // Find the LineId in the ulLineIds table (Replaces LineIdAdd as
            // part of the STATIC LINEID workaround)
            //
            ulPortForLineId =
                LineIdPortLookup( pAdapter, pticaps.caps.ulLineID );

            if ( ulPortForLineId >= NPORTS )
            {
                status = NDIS_STATUS_TAPI_INVALLINEHANDLE;
                ulInfoLen = 0;
                break;
            }

            pldc->ulTotalSize = pInCaps->LineDevCaps.ulTotalSize;
            pldc->ulNeededSize = (ULONG )
                ((CHAR* )(&pticaps + 1) - (CHAR* )(&pticaps.caps.LineDevCaps));
            pldc->ulUsedSize = pldc->ulNeededSize;

            // pldc->ulProviderInfoSize = 0;
            // pldc->ulProviderInfoOffset = 0;
            // pldc->ulSwitchInfoSize = 0;
            // pldc->ulSwitchInfoOffset = 0;

            pldc->ulPermanentLineID = pticaps.caps.ulLineID;

            StrCpyW( pticaps.achLineName,
                pAdapter->szPortName[ ulPortForLineId ] );
            pldc->ulLineNameSize =
                StrLenW( pticaps.achLineName ) * sizeof(WCHAR);
            pldc->ulLineNameOffset = (ULONG )
                ((CHAR* )pticaps.achLineName - (CHAR* )pldc);

            pldc->ulStringFormat = STRINGFORMAT_ASCII;

            // pldc->ulAddressModes = 0;

            pldc->ulNumAddresses = 1;
            pldc->ulBearerModes = LINEBEARERMODE_DATA;
            pldc->ulMaxRate = PTI_LanBps;
            pldc->ulMediaModes = LINEMEDIAMODE_UNKNOWN | LINEMEDIAMODE_DIGITALDATA;

            // pldc->ulGenerateToneModes = 0;
            // pldc->ulGenerateToneMaxNumFreq = 0;
            // pldc->ulGenerateDigitModes = 0;
            // pldc->ulMonitorToneMaxNumFreq = 0;
            // pldc->ulMonitorToneMaxNumEntries = 0;
            // pldc->ulMonitorDigitModes = 0;
            // pldc->ulGatherDigitsMinTimeout = 0;
            // pldc->ulGatherDigitsMaxTimeout = 0;
            // pldc->ulMedCtlDigitMaxListSize = 0;
            // pldc->ulMedCtlMediaMaxListSize = 0;
            // pldc->ulMedCtlToneMaxListSize = 0;
            // pldc->ulMedCtlCallStateMaxListSize = 0;
            // pldc->ulDevCapFlags = 0;

            pldc->ulMaxNumActiveCalls = 1;

            // pldc->ulAnswerMode = 0;
            // pldc->ulRingModes = 0;
            // pldc->ulLineStates = 0;
            // pldc->ulUUIAcceptSize = 0;
            // pldc->ulUUIAnswerSize = 0;
            // pldc->ulUUIMakeCallSize = 0;
            // pldc->ulUUIDropSize = 0;
            // pldc->ulUUISendUserUserInfoSize = 0;
            // pldc->ulUUICallInfoSize = 0;
            // pldc->MinDialParams = 0;
            // pldc->MaxDialParams = 0;
            // pldc->DefaultDialParams = 0;
            // pldc->ulNumTerminals = 0;
            // pldc->ulTerminalCapsSize = 0;
            // pldc->ulTerminalCapsOffset = 0;
            // pldc->ulTerminalTextEntrySize = 0;
            // pldc->ulTerminalTextSize = 0;
            // pldc->ulTerminalTextOffset = 0;
            // pldc->ulDevSpecificSize = 0;
            // pldc->ulDevSpecificOffset = 0;
            // pldc->ulLineFeatures;
            // pldc->ulSettableDevStatus;
            // pldc->ulDeviceClassesSize;
            // pldc->ulDeviceClassesOffset;
            // pldc->PermanentLineGuid;

            pldc->ulAddressTypes = LINEADDRESSTYPE_IPADDRESS;

            // pldc->ProtocolGuid;
            // pldc->ulAvailableTracking;

            pInfo = &pticaps;
            ulInfoLen = sizeof(pticaps);
            break;
        }

        case OID_CO_TAPI_ADDRESS_CAPS:
        {
            CO_TAPI_ADDRESS_CAPS* pInCaps;
            LINE_ADDRESS_CAPS* plac;

            TRACE( TL_N, TM_Cm, ( "QCm(OID_CO_TAPI_ADDRESS_CAPS)" ) );

            if (InformationBufferLength < sizeof(CO_TAPI_ADDRESS_CAPS))
            {
                status = NDIS_STATUS_INVALID_DATA;
                ulInfoLen = 0;
                break;
            }

            ASSERT( InformationBuffer );
            pInCaps = (CO_TAPI_ADDRESS_CAPS* )InformationBuffer;

            NdisZeroMemory( &addrcaps, sizeof(addrcaps) );

            addrcaps.ulLineID = pInCaps->ulLineID;
            addrcaps.ulAddressID = pInCaps->ulAddressID;

            plac = &addrcaps.LineAddressCaps;

            plac->ulTotalSize = sizeof(LINE_ADDRESS_CAPS);
            plac->ulNeededSize = sizeof(LINE_ADDRESS_CAPS);
            plac->ulUsedSize = sizeof(LINE_ADDRESS_CAPS);
            plac->ulLineDeviceID = addrcaps.ulLineID;
            // plac->ulAddressSize = 0;
            // plac->ulAddressOffset = 0;
            // plac->ulDevSpecificSize = 0;
            // plac->ulDevSpecificOffset = 0;
            // plac->ulAddressSharing = 0;
            // plac->ulAddressStates = 0;
            // plac->ulCallInfoStates = 0;
            // plac->ulCallerIDFlags = 0;
            // plac->ulCalledIDFlags = 0;
            // plac->ulConnectedIDFlags = 0;
            // plac->ulRedirectionIDFlags = 0;
            // plac->ulRedirectingIDFlags = 0;
            // plac->ulCallStates = 0;
            // plac->ulDialToneModes = 0;
            // plac->ulBusyModes = 0;
            // plac->ulSpecialInfo = 0;
            // plac->ulDisconnectModes = 0;

            plac->ulMaxNumActiveCalls = 1;

            // plac->ulMaxNumOnHoldCalls = 0;
            // plac->ulMaxNumOnHoldPendingCalls = 0;
            // plac->ulMaxNumConference = 0;
            // plac->ulMaxNumTransConf = 0;
            // plac->ulAddrCapFlags = 0;
            // plac->ulCallFeatures = 0;
            // plac->ulRemoveFromConfCaps = 0;
            // plac->ulRemoveFromConfState = 0;
            // plac->ulTransferModes = 0;
            // plac->ulParkModes = 0;
            // plac->ulForwardModes = 0;
            // plac->ulMaxForwardEntries = 0;
            // plac->ulMaxSpecificEntries = 0;
            // plac->ulMinFwdNumRings = 0;
            // plac->ulMaxFwdNumRings = 0;
            // plac->ulMaxCallCompletions = 0;
            // plac->ulCallCompletionConds = 0;
            // plac->ulCallCompletionModes = 0;
            // plac->ulNumCompletionMessages = 0;
            // plac->ulCompletionMsgTextEntrySize = 0;
            // plac->ulCompletionMsgTextSize = 0;
            // plac->ulCompletionMsgTextOffset = 0;

            pInfo = &addrcaps;
            ulInfoLen = sizeof(addrcaps);
            break;
        }

        case OID_CO_TAPI_GET_CALL_DIAGNOSTICS:
        {
            TRACE( TL_N, TM_Cm, ( "QCm(OID_CO_TAPI_GET_CALL_DIAGS)" ) );

            if (!pVc)
            {
                status = NDIS_STATUS_INVALID_DATA;
                ulInfoLen = 0;
                break;
            }

            NdisZeroMemory( &diags, sizeof(diags) );

            diags.ulOrigin =
                (ReadFlags( &pVc->ulFlags ) & VCBF_PeerInitiatedCall)
                    ? LINECALLORIGIN_EXTERNAL
                    : LINECALLORIGIN_OUTBOUND;
            diags.ulReason = LINECALLREASON_DIRECT;

            pInfo = &diags;
            ulInfoLen = sizeof(diags);
            break;
        }

        default:
        {
            TRACE( TL_A, TM_Cm, ( "QCm-OID=$%08x?", Oid ) );
            status = NDIS_STATUS_NOT_SUPPORTED;
            ulInfoLen = 0;
            break;
        }
    }

    if (ulInfoLen > InformationBufferLength)
    {
        // Caller's buffer is too small.  Tell him what he needs.
        //
        *BytesNeeded = ulInfoLen;
        status = NDIS_STATUS_INVALID_LENGTH;
    }
    else
    {
        // Copy the found result to caller's buffer.
        //
        if (ulInfoLen > 0)
        {
            NdisMoveMemory( InformationBuffer, pInfo, ulInfoLen );
            DUMPDW( TL_N, TM_Mp, pInfo, ulInfoLen );
        }

        *BytesNeeded = *BytesWritten = ulInfoLen;
    }

    return status;
}


VOID
QueryPtiPorts(
    IN ADAPTERCB* pAdapter )

    // Query which PTI ports are available and fill in the count and status of
    // each in the adapter context block 'pAdapter'.
    //
{
    ULONG ulPortIndex;
    ULONG ulLineId;
    PTI_EXTENSION* pPtiExtension;
    NTSTATUS statusDevice;

    // Ask PtiLink which devices exist.
    //
    pAdapter->ulActualVcs = 0;
    ulLineId = 0;
    for (ulPortIndex = 0; ulPortIndex < NPORTS; ++ulPortIndex)
    {
        TRACE( TL_V, TM_Mp,
             ( "PtiQueryDeviceStatus(%d)", ulPortIndex ) );

        statusDevice = PtiQueryDeviceStatus(
            ulPortIndex, pAdapter->szPortName[ ulPortIndex ] );
        if (NT_SUCCESS( statusDevice ))
        {
            // An actual parallel port device object exists for this
            // logical port.  Increment the available VCs and set
            // ulPtiLinkState which will be used in the CAPS OIDs to
            // associate a TAPI LineId.
            //
            pAdapter->ulActualVcs++;
            pAdapter->ulPtiLinkState[ulPortIndex] = PLSF_PortExists;
            pAdapter->ulLineIds[ ulPortIndex ] = ulLineId;
            ++ulLineId;
            pAdapter->ulPtiLinkState[ ulPortIndex ] |= PLSF_LineIdValid;
        }

        TRACE( TL_N, TM_Mp,
             ( "PtiQueryDeviceStatus(%d), status=$%x, port=%S",
                ulPortIndex,
                statusDevice,
                pAdapter->szPortName[ ulPortIndex ] ) );
    }
}


VOID
ReferenceAf(
    IN ADAPTERCB* pAdapter )

    // Adds areference to the address family of adapter block, 'pAdapter'.
    //
{
    LONG lRef;

    lRef = NdisInterlockedIncrement( &pAdapter->lAfRef );

    TRACE( TL_N, TM_Ref, ( "RefAf to %d", lRef ) );
}


BOOLEAN
ReferenceCall(
    IN VCCB* pVc )

    // Returns true if a reference is added to the active call on VC control
    // block, 'pVc', or false if no reference was added because no call is
    // active.
    //
{
    BOOLEAN fActive;

    NdisAcquireSpinLock( &pVc->lockCall );
    {
        if (ReadFlags( &pVc->ulFlags ) & VCBF_VcActivated)
        {
            fActive = TRUE;
            ++pVc->lCallRef;
            TRACE( TL_N, TM_Ref, ( "RefCall to %d", pVc->lCallRef ) );
        }
        else
        {
            TRACE( TL_N, TM_Ref, ( "RefCall denied" ) );
            fActive = FALSE;
        }
    }
    NdisReleaseSpinLock( &pVc->lockCall );

    return fActive;
}


BOOLEAN
ReferenceSap(
    IN ADAPTERCB* pAdapter )

    // Returns true if a reference is added to the active SAP on adapter
    // 'pAdapter', or false if no reference was added because no SAP is
    // active.
    //
{
    BOOLEAN fActive;

    NdisAcquireSpinLock( &pAdapter->lockSap );
    {
        if (ReadFlags( &pAdapter->ulFlags ) & ACBF_SapActive)
        {
            fActive = TRUE;
            ++pAdapter->lSapRef;
            TRACE( TL_N, TM_Ref, ( "RefSap to %d", pAdapter->lSapRef ) );
        }
        else
        {
            TRACE( TL_N, TM_Ref, ( "RefSap denied" ) );
            fActive = FALSE;
        }
    }
    NdisReleaseSpinLock( &pAdapter->lockSap );

    return fActive;
}


VOID
SetupVcAsynchronously(
    IN ADAPTERCB* pAdapter )

    // Called by ReceiveControl to set up a VC for the incoming call
    // using the necessary asynchronous CoNdis calls.
    //
{
    NDIS_STATUS status;
    VCCB* pVc;
    NDIS_HANDLE NdisVcHandle;
    ULONG ulMask;

    TRACE( TL_V, TM_Misc, ( "SetupVcAsync" ) );

    // Call our own CreateVc handler directly to allocate and
    // initialize the incoming call's VC.
    //
    status = PtiCmCreateVc( pAdapter, NULL, &pVc );
    TRACE( TL_V, TM_Misc, ( "SetupVcAsync: PtiCmCreateVc: Vc Created: pVc=$%p", pVc ) );

    if (status != NDIS_STATUS_SUCCESS)
    {
        ASSERT( !"CreateVc?" );

        // ??? Add code to intiate protocol to terminate link

        return;
    }

    // Allocate an "incoming call setup" context and initialize it from the
    // receive buffer information arguments.
    //
    {
        CHAR* pCallParamBuf;
        ULONG ulCallParamLength;
        CO_CALL_PARAMETERS* pCp;
        CO_CALL_MANAGER_PARAMETERS* pCmp;
        CO_MEDIA_PARAMETERS* pMp;
        CO_AF_TAPI_INCOMING_CALL_PARAMETERS* pTi;
        LINE_CALL_INFO* pLci;

        ulCallParamLength =
            sizeof(CO_CALL_PARAMETERS)
            + sizeof(CO_CALL_MANAGER_PARAMETERS)
            + sizeof(CO_MEDIA_PARAMETERS)
            + sizeof(CO_AF_TAPI_INCOMING_CALL_PARAMETERS)
            + sizeof(LINE_CALL_INFO);

        pCallParamBuf = ALLOC_NONPAGED( ulCallParamLength, MTAG_INCALLBUF );
        if (!pCallParamBuf)
        {
            ASSERT( !"Alloc pCpBuf?" );
            PtiCmDeleteVc( pVc );
            return;
        }

        NdisZeroMemory( pCallParamBuf, ulCallParamLength );

        pCp = (CO_CALL_PARAMETERS* )pCallParamBuf;
        pCmp = (CO_CALL_MANAGER_PARAMETERS* )(pCp + 1);
        pCp->CallMgrParameters = pCmp;

        //
        // Might want to make this report the actual
        // connection speed in the future
        //
        pCmp->Transmit.TokenRate =
        pCmp->Transmit.PeakBandwidth =
        pCmp->Receive.TokenRate =
        pCmp->Receive.PeakBandwidth = PTI_LanBps/8;

        pMp = (CO_MEDIA_PARAMETERS* )(pCmp + 1);
        pCp->MediaParameters = pMp;
        pMp->ReceiveSizeHint = PTI_MaxFrameSize;
        pMp->MediaSpecific.Length =
            sizeof(CO_AF_TAPI_INCOMING_CALL_PARAMETERS)
            + sizeof(LINE_CALL_INFO);
        pTi = (CO_AF_TAPI_INCOMING_CALL_PARAMETERS* )
            pMp->MediaSpecific.Parameters;
        pTi->ulLineID = pAdapter->ulSapPort;
        pTi->ulAddressID = CO_TAPI_ADDRESS_ID_UNSPECIFIED;
        pTi->ulFlags = CO_TAPI_FLAG_INCOMING_CALL;
        pTi->LineCallInfo.Length = sizeof(LINE_CALL_INFO);
        pTi->LineCallInfo.MaximumLength = sizeof(LINE_CALL_INFO);
        pTi->LineCallInfo.Offset = sizeof(pTi->LineCallInfo);
        pLci = (LINE_CALL_INFO* )(pTi + 1);
        pLci->ulTotalSize = sizeof(LINE_CALL_INFO);
        pLci->ulNeededSize = sizeof(LINE_CALL_INFO);
        pLci->ulUsedSize = sizeof(LINE_CALL_INFO);
        pLci->ulLineDeviceID = pTi->ulLineID;
        pLci->ulBearerMode = LINEBEARERMODE_DATA;
        pLci->ulMediaMode = LINEMEDIAMODE_DIGITALDATA;

        //
        // Might want to make this report the actual
        // connection speed in the future
        //
        pLci->ulRate = PTI_LanBps;

        pVc->pTiParams = pTi;
        pVc->pInCall = pCp;

    }

    // Mark the call as initiated by the peer so we know which notifications
    // to give when the result is known.
    //
    ulMask = (VCBF_PeerInitiatedCall | VCBF_PeerOpenPending);

    SetFlags( &pVc->ulFlags, ulMask );

    ASSERT( !(ReadFlags( &pVc->ulFlags ) & VCBM_VcState) );

    // Check if the request has a chance of succeeding before getting the
    // client involved.
    //
    if (!pAdapter->NdisAfHandle || !pAdapter->NdisSapHandle)
    {
        TRACE( TL_A, TM_Misc, ( "No AF or SAP" ) );
        pVc->status = NDIS_STATUS_INVALID_SAP;
        SetupVcComplete( pVc );
        return;
    }

    // Tell NDIS to notify the client of the new VC and give us it's handle.
    //
    TRACE( TL_I, TM_Recv, ( "SetupVcAsynch: NdisMCmCreateVc: pVc=$%p", pVc ) );
    status = NdisMCmCreateVc(
        pAdapter->MiniportAdapterHandle,
        pAdapter->NdisAfHandle,
        pVc,
        &pVc->NdisVcHandle );
    TRACE( TL_I, TM_Recv,
         ( "SetupVcAsynch: NdisMCmCreateVc: Get VcHandle: pVc=$%p VcHandle=$%p, status=$%x",
            pVc,
            pVc->NdisVcHandle,
            status ) );

    if (status != NDIS_STATUS_SUCCESS)
    {
        pVc->status = status;
        SetupVcComplete( pVc );
        return;
    }
    SetFlags( &pVc->ulFlags, VCBF_VcCreated );

    // Tell NDIS the VC is active.
    //
    TRACE( TL_I, TM_Recv,
        ( "SetupVcAsynch: NdisMCmActivateVc, VcHandle=$%p",
        pVc->NdisVcHandle) );
    status = NdisMCmActivateVc(
        pVc->NdisVcHandle, pVc->pInCall );
    TRACE( TL_I, TM_Recv,
        ( "SetupVcAsynch: NdisMCmActivateVc: status=$%x", status ) );

    if (status != NDIS_STATUS_SUCCESS )
    {
        pVc->status = status;
        TRACE( TL_I, TM_Recv, ( "SetupVcAsynch: Error: NoAccept" ) );
        SetupVcComplete( pVc );
        return;
    }

    //  Activate the call
    //
    SetFlags( &pVc->ulFlags,
        (VCBF_VcActivated
         | VCBF_CallClosableByClient
         | VCBF_CallClosableByPeer) );
    ReferenceCall( pVc );
    if (!ReferenceSap( pAdapter ))
    {
        pVc->status = NDIS_STATUS_INVALID_SAP;
        TRACE( TL_I, TM_Recv, ( "SetupVcAsynch: Error: NoSap" ) );
        SetupVcComplete( pVc );
        return;
    }

    // Tell NDIS to tell the client about the call.  The dispatched flag is
    // set here rather in the completion because, according to JameelH, it is
    // valid to call NdisMCmDispatchIncomingCloseCall even if client pends on
    // the dispatch.
    //
    TRACE( TL_I, TM_Recv, ( "SetupVcAsynch: NdisMCmDispInCall" ) );
    status = NdisMCmDispatchIncomingCall(
        pAdapter->NdisSapHandle,
        pVc->NdisVcHandle,
        pVc->pInCall );
    TRACE( TL_I, TM_Recv,
        ( "SetupVcAsynch: NdisMCmDispInCall: status=$%x", status ) );

    DereferenceSap( pAdapter );

    if (status != NDIS_STATUS_PENDING)
    {
        PtiCmIncomingCallComplete( status, pVc, pVc->pInCall );
    }
    SetFlags( &pVc->ulFlags, VCBF_VcDispatched );

    // Next stop is our PtiIncomingCallComplete handler which will call
    // SetupVcComplete with clients reported status.
    //
    TRACE( TL_I, TM_Recv, ( "SetupVcAsynch: Exit" ) );
}


VOID
SetupVcComplete(
    IN VCCB* pVc )

    // Called when the asynchronous incoming call VC setup result is known.
    // 'pVc' is the non-NULL set up VC, with 'status' field indicating the
    // status thus far.
    //
{
    NDIS_STATUS status;
    NTSTATUS ntStatus;
    BOOLEAN fCallerFreesBuffer;
    LIST_ENTRY list;
    CHAR* pBuffer;
    ADAPTERCB* pAdapter;


    TRACE( TL_N, TM_Cm, ( "SetupVcComp: pVc=%p, Port=$%x, status=$%x",
                            pVc, pVc->ulVcParallelPort, pVc->status ) );

    pAdapter = pVc->pAdapter;

    do
    {
        if (pVc->status != NDIS_STATUS_SUCCESS)
        {
            break;
        }

        // Initialize the PtiLink API getting the extension pointers.  Get
        // PTILINKx extension also fires ECPdetect and enables port IRQ.
        //
        ntStatus = PtiInitialize( pAdapter->ulSapPort,
                                  &pVc->Extension,
                                  &pVc->PtiExtension);

        TRACE( TL_V, TM_Cm, ( "SetupVcComp: PtiLink Init: Ext=$%p, PtiExt=$%p",
                               pVc->Extension,
                               pVc->PtiExtension ) );

        if ( (pVc->Extension == NULL) ||
             (pVc->PtiExtension == NULL) )
        {
            pVc->status = NDIS_STATUS_FAILURE;
            TRACE( TL_V, TM_Cm, ( "SetupVcComplete: Error: PtiInitialize Returned NULL Pointer", ntStatus ) );
            break;
        }

        if ( !NT_SUCCESS( ntStatus ) )
        {
            pVc->status = NDIS_STATUS_FAILURE;
            TRACE( TL_V, TM_Cm, ( "SetupVcComplete: Error: PtiInitialize=%x", ntStatus ) );
            break;
        }

        SetFlags( &pVc->ulFlags, VCBF_CallInProgress );
        pVc->ulVcParallelPort = pAdapter->ulSapPort;

        // now "privatize" the PtiLink Api ... making it's upper edge link to us
        //   this may have been done before
        //   in this case, we are associating a new Vc context with receives
        //
        TRACE( TL_V, TM_Cm, ( "SetupVcComplete: RegCb pV=$%p", pVc ) );
        PtiRegisterCallbacks(pVc->Extension,                    // the PTILINKx extension
                             PtiCbGetReadBuffer,                // our get buffer routine
                             PtiRx,                             // our receive complete routine
                             PtiCbLinkEventHandler,             // our link event handler
                             pVc);                              // our context
    }
    while (FALSE);

    // With no locks held, perform and VC completion processing including
    // indications to client.
    //
    CompleteVc( pVc );

    TRACE( TL_V, TM_Misc, ( "SetupVcComp: Exit" ) );

}


VOID
WriteEndpointsToRegistry(
    IN ULONG ulVcs )

    // Set the value of the "WanEndpoints", "MinWanEndpoints", and
    // "MaxWanEndpoints" registry values to the 'ulVcs' value.
    //
{
    NTSTATUS status;
    OBJECT_ATTRIBUTES objattr;
    UNICODE_STRING uni;
    HANDLE hNet;
    HANDLE hAdapter;
    ULONG i;
    WCHAR szPath[ 256 ];

    #define PSZ_NetAdapters L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\Class\\{4D36E972-E325-11CE-BFC1-08002BE10318}"

    TRACE( TL_I, TM_Cm, ( "WriteEndpointsToRegistry(%d)", ulVcs ) );

    hNet = NULL;
    hAdapter = NULL;

    do
    {
        // Get a handle to the network adapters registry key.
        //
        StrCpyW( szPath, PSZ_NetAdapters );
        RtlInitUnicodeString( &uni, szPath );
        InitializeObjectAttributes(
            &objattr, &uni, OBJ_CASE_INSENSITIVE, NULL, NULL );

        status = ZwOpenKey(
            &hNet,
            KEY_ENUMERATE_SUB_KEYS | KEY_QUERY_VALUE | KEY_SET_VALUE,
            &objattr );
        if (status != STATUS_SUCCESS)
        {
            TRACE( TL_A, TM_Cm, ( "ZwOpenKey(net)=$%08x?", status ) );
            break;
        }

        // Walk the adapter subkeys looking for the RASPTI adapter.
        //
        for (i = 0; ; ++i)
        {
            CHAR szBuf[ 512 ];
            KEY_BASIC_INFORMATION* pKey;
            KEY_VALUE_PARTIAL_INFORMATION* pValue;
            WCHAR* pch;
            ULONG ulSize;

            // Find the name of the next adapter subkey.
            //
            status = ZwEnumerateKey(
                hNet, i, KeyBasicInformation,
                szBuf, sizeof(szBuf), &ulSize );
            if (status != STATUS_SUCCESS)
            {
                DBG_if (status != STATUS_NO_MORE_ENTRIES)
                {
                    TRACE( TL_A, TM_Cm, ( "ZwEnumKey=$%08x?", status ) );
                }
                break;
            }

            // Open the adapter subkey.
            //
            pKey = (KEY_BASIC_INFORMATION* )szBuf;
            StrCpyW( szPath, PSZ_NetAdapters );
            pch = &szPath[ StrLenW( szPath ) ];
            *pch = L'\\';
            ++pch;
            NdisMoveMemory( pch, pKey->Name, pKey->NameLength );
            pch += pKey->NameLength / sizeof(WCHAR);
            *pch = L'\0';
            RtlInitUnicodeString( &uni, szPath );

            InitializeObjectAttributes(
                &objattr, &uni, OBJ_CASE_INSENSITIVE, NULL, NULL );

            status = ZwOpenKey(
                &hAdapter,
                KEY_QUERY_VALUE | KEY_SET_VALUE,
                &objattr );
            if (status != STATUS_SUCCESS)
            {
                TRACE( TL_A, TM_Cm, ( "ZwOpenKey(adapter)=$%08x?", status ) );
                break;
            }

            // Query the "ComponentID" value.
            //
            RtlInitUnicodeString( &uni, L"ComponentId" );
            status = ZwQueryValueKey(
                hAdapter, &uni, KeyValuePartialInformation,
                szBuf, sizeof(szBuf), &ulSize );

            if (status != STATUS_SUCCESS)
            {
                ZwClose( hAdapter );
                hAdapter = NULL;
                TRACE( TL_A, TM_Cm, ( "ZwQValueKey=$%08x?", status ) );
                continue;
            }

            pValue = (KEY_VALUE_PARTIAL_INFORMATION* )szBuf;
            if (pValue->Type != REG_SZ
                || StrCmpW( (WCHAR* )pValue->Data, L"ms_ptiminiport" ) != 0)
            {
                ZwClose( hAdapter );
                hAdapter = NULL;
                continue;
            }

            // Found it. 'HAdapter' contains it's adapter key handle.
            //
            TRACE( TL_I, TM_Cm, ( "PTI adapter key found" ) );

            // Write the "actual VC" count to the 3 endpoint registry values.
            //
            RtlInitUnicodeString( &uni, L"WanEndpoints" );
            status = ZwSetValueKey(
                hAdapter, &uni, 0, REG_DWORD, &ulVcs, sizeof(ulVcs) );
            if (status != STATUS_SUCCESS)
            {
                TRACE( TL_A, TM_Cm,
                    ( "ZwSetValueKey(WE)=$%08x?", status ) );
            }

            RtlInitUnicodeString( &uni, L"MinWanEndpoints" );
            status = ZwSetValueKey(
                hAdapter, &uni, 0, REG_DWORD, &ulVcs, sizeof(ulVcs) );
            if (status != STATUS_SUCCESS)
            {
                TRACE( TL_A, TM_Cm,
                    ( "ZwSetValueKey(MinWE)=$%08x?", status ) );
            }

            RtlInitUnicodeString( &uni, L"MaxWanEndpoints" );
            status = ZwSetValueKey(
                hAdapter, &uni, 0, REG_DWORD, &ulVcs, sizeof(ulVcs) );
            if (status != STATUS_SUCCESS)
            {
                TRACE( TL_A, TM_Cm,
                    ( "ZwSetValueKey(MaxWE)=$%08x?", status ) );
            }
        }
    }
    while (FALSE);

    if (hAdapter)
    {
        ZwClose( hAdapter );
    }

    if (hNet)
    {
        ZwClose( hNet );
    }
}


NDIS_STATUS
PtiCmCloseAf(
    IN NDIS_HANDLE CallMgrAfContext )

    // Standard 'CmCloseAfHandler' routine called by NDIS when a client
    // requests to close an address family.  See DDK doc.
    //
{
    ADAPTERCB* pAdapter;

    TRACE( TL_I, TM_Cm, ( "PtiCmCloseAf" ) );

    pAdapter = (ADAPTERCB* )CallMgrAfContext;
    if (pAdapter->ulTag != MTAG_ADAPTERCB)
    {
        ASSERT( !"Atag?" );
        return NDIS_STATUS_INVALID_DATA;
    }

    // This dereference will eventually lead to us calling
    // NdisMCmCloseAfComplete.
    //
    DereferenceAf( pAdapter );

    TRACE( TL_V, TM_Cm, ( "PtiCmCloseAf: Exit" ) );
    return NDIS_STATUS_PENDING;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ndis\raspti\debug.h ===
// Copyright (c) 1997, Microsoft Corporation, all rights reserved
// Copyright (c) 1997, Parallel Technologies, Inc., all rights reserved
//
//
// debug.h
// DirectParallel WAN mini-port/call-manager driver
// Debug helper header
//
// 01/07/97 Steve Cobb
// 09/15/97 Jay Lowe, Parallel Technologies, Inc.

#ifndef _DEBUG_H_
#define _DEBUG_H_


//-----------------------------------------------------------------------------
// Debug constants
//-----------------------------------------------------------------------------

// Memory tags used with NdisAllocateMemoryWithTag to identify allocations
// made by the L2TP driver.  Also, several context blocks define a first field
// of 'ulTag' set to these values for ASSERT sanity checking and eased memory
// dump browsing.  Such tags are set to MTAG_FREED just before NdisFreeMemory
// is called.
//
#define MTAG_FREED      'fITP'
#define MTAG_ADAPTERCB  'aITP'
#define MTAG_VCCB       'vITP'
#define MTAG_UTIL       'uITP'
#define MTAG_VCTABLE    'tITP'
#define MTAG_PTIPARAMS  'pITP'
#define MTAG_PACKETPOOL 'pITP'
#define MTAG_FBUFPOOL   'bITP'
#define MTAG_INCALLBUF  'iITP'
#define MTAG_WORKITEM   'wITP'

// Trace levels.
//
#define TL_None 0    // Trace disabled
#define TL_A    0x10 // Alert
#define TL_I    0x20 // Interface
#define TL_N    0x30 // Normal
#define TL_V    0x40 // Verbose

// Trace mask bits.
//
#define TM_Cm   0x00000001 // Call manager general
#define TM_Mp   0x00000002 // Mini-port general
#define TM_Send 0x00000004 // Send path
#define TM_Recv 0x00000008 // Receive path
#define TM_Fsm  0x00000010 // Finite state machines
#define TM_Init 0x00000020 // Initialization
#define TM_Misc 0x00000040 // Miscellaneous
#define TM_Msg  0x00000100 // Messages
#define TM_Ref  0x00010000 // References
#define TM_Data 0x00020000 // Dump data under TESTMODE
#define TM_Pool 0x00080000 // Buffer and packet pooling
#define TM_MDmp 0x10000000 // Message dumps
#define TM_Dbg  0x80000000 // Debug corruption checks
#define TM_Spec 0x01000000 // Special

#define TM_Wild 0xFFFFFFFF // Everything
#define TM_All  0x7FFFFFFF // Everything except corruption checks
#define TM_Test 0x0001FFF3 // Base w/ messages and references
#define TM_Base 0x000000F3 // Base w/o send and receive

// Bytes to appear on each line of dump output.
//
#define DUMP_BytesPerLine 16


//-----------------------------------------------------------------------------
// Debug global declarations (defined in debug.c)
//-----------------------------------------------------------------------------

// Active debug trace level and active trace set mask.  Set these variables
// with the debugger at startup to enable and filter the debug output.  All
// messages with (TL_*) level less than or equal to 'g_ulTraceLevel' and from
// any (TM_*) set(s) present in 'g_ulTraceMask' are displayed.
//
extern ULONG g_ulTraceLevel;
extern ULONG g_ulTraceMask;


//-----------------------------------------------------------------------------
// Debug macros
//-----------------------------------------------------------------------------

#if DBG

// TRACE sends printf style output to the kernel debugger.  Caller indicates a
// "verbosity" level with the 'ulLevel' argument and associates the trace with
// one or more trace sets with the 'ulMask' bit mask argument.  Notice that
// the variable count printf arguments 'Args' must be parenthesized.  For
// example...
//
// A "leave" routine message:
//     TRACE( TL_N, TM_Init, ( "DriverEntry=$%x", status ) );
// An error condition occurred:
//     TRACE( TL_E, TM_Init, ( "NdisMRegisterMiniport=$%x", status ) );
//
//
#define TRACE(ulLevel,ulMask,Args)                             \
{                                                              \
    if (ulLevel <= g_ulTraceLevel && (g_ulTraceMask & ulMask)) \
    {                                                          \
        DbgPrint( "RASPTI: " );                                \
        DbgPrint Args;                                         \
        DbgPrint( "\n" );                                      \
    }                                                          \
}

// ASSERT checks caller's assertion expression and if false, prints a kernel
// debugger message and breaks.
//
#undef ASSERT
#define ASSERT(x)                                           \
{                                                           \
    if (!(x))                                               \
    {                                                       \
        DbgPrint( "RASPTI: !ASSERT( %s ) at line %d of %s\n", \
            #x, __LINE__, __FILE__ );                       \
        DbgBreakPoint();                                    \
    }                                                       \
}

// DUMP prints to the kernel debugger a hex dump of 'cb' bytes starting at 'p'
// in groups of 'ul'.  If 'f' is set the address of each line in shown before
// the dump.  DUMPB, DUMPW, and DUMPDW are BYTE, WORD, and DWORD dumps
// respectively.  Note that the multi-byte dumps do not reflect little-endian
// (Intel) byte order.  The 'ulLevel' and 'ulMask' are described for TRACE.
//
#define DUMP(ulLevel,ulMask,p,cb,f,ul)                         \
{                                                              \
    if (ulLevel <= g_ulTraceLevel && (g_ulTraceMask & ulMask)) \
    {                                                          \
        Dump( (CHAR* )p, cb, f, ul );                          \
    }                                                          \
}

#define DUMPB(ulLevel,ulMask,p,cb)                             \
{                                                              \
    if (ulLevel <= g_ulTraceLevel && (g_ulTraceMask & ulMask)) \
    {                                                          \
        Dump( (CHAR* )p, cb, 0, 1 );                           \
    }                                                          \
}

#define DUMPW(ulLevel,ulMask,p,cb)                             \
{                                                              \
    if (ulLevel <= g_ulTraceLevel && (g_ulTraceMask & ulMask)) \
    {                                                          \
        Dump( (CHAR* )p, cb, 0, 2 );                           \
    }                                                          \
}

#define DUMPDW(ulLevel,ulMask,p,cb)                            \
{                                                              \
    if (ulLevel <= g_ulTraceLevel && (g_ulTraceMask & ulMask)) \
    {                                                          \
        Dump( (CHAR* )p, cb, 0, 4 );                           \
    }                                                          \
}


// Double-linked list corruption detector.  Runs the test if 'ulMask' is
// enabled, with TM_Dbg a suggested setting.  Shows verbose output if
// 'ulLevel' is at or above the current trace threshold.
//
#define CHECKLIST(ulMask,p,ulLevel)                            \
{                                                              \
    if (g_ulTraceMask & ulMask)                                \
    {                                                          \
        CheckList( p, (BOOLEAN )(ulLevel <= g_ulTraceLevel) ); \
    }                                                          \
}


// DBG_if can be used to put in TRACE/DUMPs conditional on an expression that
// need not be evaluated in non-DBG builds, e.g the statements below generate
// no code in a non-DBG build, but in DBG builds print the TRACE if x<y and
// asserts otherwise.
//
//     DBG_if (x < y)
//         TRACE( TL_N, TM_Misc, ( "x < y" ) );
//     DBG_else
//         ASSERT( FALSE );
//
//
#define DBG_if(x) if (x)
#define DBG_else  else


#else // !DBG

// Debug macros compile out of non-DBG builds.
//
#define TRACE(ulLevel,ulMask,Args)
#undef ASSERT
#define ASSERT(x)
#define DUMP(ulLevel,ulMask,p,cb,f,dw)
#define DUMPB(ulLevel,ulMask,p,cb)
#define DUMPW(ulLevel,ulMask,p,cb)
#define DUMPDW(ulLevel,ulMask,p,cb)
#define CHECKLIST(ulMask,p,ulLevel)
#define DBG_if(x)
#define DBG_else

#endif


//-----------------------------------------------------------------------------
// Prototypes
//-----------------------------------------------------------------------------

VOID
CheckList(
    IN LIST_ENTRY* pList,
    IN BOOLEAN fShowLinks );

VOID
Dump(
    CHAR* p,
    ULONG cb,
    BOOLEAN fAddress,
    ULONG ulGroup );

VOID
DumpLine(
    CHAR* p,
    ULONG cb,
    BOOLEAN  fAddress,
    ULONG ulGroup );


#endif // _DEBUG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ndis\raspti\main.c ===
// Copyright (c) 1997, Microsoft Corporation, all rights reserved
// Copyright (c) 1997, Parallel Technologies, Inc., all rights reserved
//
// main.c
// RAS DirectParallel mini-port/call-manager driver
// Main routine (DriverEntry) and global data definitions
//
// 01/07/97 Steve Cobb
// 09/15/97 Jay Lowe, Parallel Technologies, Inc.

#include "ptiwan.h"


//-----------------------------------------------------------------------------
// Local prototypes
//-----------------------------------------------------------------------------

NDIS_STATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath );

// Mark routine to be unloaded after initialization.
//
#pragma NDIS_INIT_FUNCTION(DriverEntry)


//-----------------------------------------------------------------------------
// Routines
//-----------------------------------------------------------------------------

NDIS_STATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath )

    // Standard 'DriverEntry' driver initialization entrypoint called by the
    // I/0 system at IRQL PASSIVE_LEVEL before any other call to the driver.
    //
    // On NT, 'DriverObject' is the driver object created by the I/0 system
    // and 'RegistryPath' specifies where driver specific parameters are
    // stored.  These arguments are opaque to this driver (and should remain
    // so for portability) which only forwards them to the NDIS wrapper.
    //
    // Returns the value returned by NdisMRegisterMiniport, per the doc on
    // "DriverEntry of NDIS Miniport Drivers".
    //
{
    NDIS_STATUS status;
    NDIS_MINIPORT_CHARACTERISTICS nmc;
    NDIS_HANDLE NdisWrapperHandle;

    TRACE( TL_N, TM_Init, ( "DriverEntry" ) );

#ifdef TESTMODE
    TRACE( TL_N, TM_Init, ( "DriverEntry: g_ulTraceLevel = $%x", &g_ulTraceLevel ) );
    TRACE( TL_N, TM_Init, ( "DriverEntry: g_ulTraceMask  = $%x", &g_ulTraceMask ) );
#endif


    // Register  this driver with the NDIS wrapper.  This call must occur
    // before any other NdisXxx calls.
    //
    NdisMInitializeWrapper(
        &NdisWrapperHandle, DriverObject, RegistryPath, NULL );

    // Set up the mini-port characteristics table that tells NDIS how to call
    // our mini-port.
    //
    NdisZeroMemory( &nmc, sizeof(nmc) );

    nmc.MajorNdisVersion = NDIS_MajorVersion;
    nmc.MinorNdisVersion = NDIS_MinorVersion;
    nmc.Reserved = NDIS_USE_WAN_WRAPPER;
    // no CheckForHangHandler
    // no DisableInterruptHandler
    // no EnableInterruptHandler
    nmc.HaltHandler = PtiHalt;
    // no HandleInterruptHandler
    nmc.InitializeHandler = PtiInit;
    // no ISRHandler
    // no QueryInformationHandler (see CoRequestHandler)
    nmc.ResetHandler = PtiReset;
    // no SendHandler (see CoSendPacketsHandler)
    // no WanSendHandler (see CoSendPacketsHandler)
    // no SetInformationHandler (see CoRequestHandler)
    // no TransferDataHandler
    // no WanTransferDataHandler
    nmc.ReturnPacketHandler = PtiReturnPacket;
    // no SendPacketsHandler (see CoSendPacketsHandler)
    // no AllocateCompleteHandler
    // no CoCreateVcHandler
    // no CoDeleteVcHandler
    nmc.CoActivateVcHandler = PtiCoActivateVc;
    nmc.CoDeactivateVcHandler = PtiCoDeactivateVc;
    nmc.CoSendPacketsHandler = PtiCoSendPackets;
    nmc.CoRequestHandler = PtiCoRequest;

    // Register this driver as the DirectParallel mini-port.  This will result in NDIS
    // calling back at PtiInit
    //
    TRACE( TL_V, TM_Init, ( "NdisMRegMp" ) );
    status = NdisMRegisterMiniport( NdisWrapperHandle, &nmc, sizeof(nmc) );
    TRACE( TL_A, TM_Init, ( "NdisMRegMp=$%x", status ) );

    if (status != NDIS_STATUS_SUCCESS)
    {
        NdisTerminateWrapper( NdisWrapperHandle, NULL );
    }

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ndis\raspti\mp.c ===
// Copyright (c) 1997, Microsoft Corporation, all rights reserved
// Copyright (c) 1997, Parallel Technologies, Inc., all rights reserved
//
// mp.c
// RAS DirectParallel WAN mini-port/call-manager driver
// Mini-port routines
//
// 01/07/97 Steve Cobb
// 09/15/97 Jay Lowe, Parallel Technologies, Inc.


#include "ptiwan.h"
#include "ptilink.h"

// The adapter control block address is recorded in this global as a debugging
// aid.  This global must not be read by any code.
//
ADAPTERCB* g_pDebugAdapter;

// Default settings for the NDIS_WAN_CO_INFO capabilities of an adapter.
//
static NDIS_WAN_CO_INFO g_infoDefaults =
{
    PTI_MaxFrameSize,                   // MaxFrameSize
    1,                                  // MaxSendWindow (placeholder)
    PPP_FRAMING                         // FramingBits
        | PPP_COMPRESS_ADDRESS_CONTROL
        | PPP_COMPRESS_PROTOCOL_FIELD,
    0,                                  // DesiredACCM
};

// String constants for Win9x UNIMODEM emulation
//
CHAR g_szClient[] = "CLIENT";
#define CLIENTLEN 6
CHAR g_szClientServer[] = "CLIENTSERVER";
#define CLIENTSERVERLEN 12

// Async framing definitions.
//
#define PPPFLAGBYTE 0x7E
#define PPPESCBYTE  0x7D

#if DBG
BOOLEAN g_fAssumeWin9x = FALSE;
BOOLEAN g_fNoAccmFastPath = FALSE;
#endif

NDIS_PNP_CAPABILITIES PnpCaps =
{
    0, // Flags
    {
        NdisDeviceStateUnspecified,
        NdisDeviceStateUnspecified,
        NdisDeviceStateUnspecified
    }
};

//-----------------------------------------------------------------------------
// Local prototypes (alphabetically)
//-----------------------------------------------------------------------------

VOID
AsyncFromHdlcFraming(
    IN UCHAR* pInBuf,
    IN ULONG ulInBufLen,
    OUT UCHAR* pOutBuf,
    OUT ULONG* pulOutBufLen,
    IN ULONG ulAccmMask );

USHORT
CalculatePppFcs(
    IN UCHAR* pBuf,
    IN ULONG ulBufLen );

VOID
FreeAdapter(
    IN ADAPTERCB* pAdapter );

NDIS_STATUS
RegistrySettings(
    IN OUT ADAPTERCB* pAdapter,
    IN NDIS_HANDLE WrapperConfigurationContext );

BOOLEAN
HdlcFromAsyncFraming(
    IN UCHAR* pInBuf,
    IN ULONG ulInBufLen,
    OUT UCHAR* pOutBuf,
    OUT ULONG* pulOutBufLen );

NDIS_STATUS
QueryInformation(
    IN ADAPTERCB* pAdapter,
    IN VCCB* pLink,
    IN NDIS_OID Oid,
    IN PVOID InformationBuffer,
    IN ULONG InformationBufferLength,
    OUT PULONG BytesWritten,
    OUT PULONG BytesNeeded );

NDIS_STATUS
SetInformation(
    IN ADAPTERCB* pAdapter,
    IN VCCB* pLink,
    IN NDIS_OID Oid,
    IN PVOID InformationBuffer,
    IN ULONG InformationBufferLength,
    OUT PULONG BytesRead,
    OUT PULONG BytesNeeded );


//-----------------------------------------------------------------------------
// Mini-port handlers
//-----------------------------------------------------------------------------

NDIS_STATUS
PtiInit(
    OUT PNDIS_STATUS OpenErrorStatus,
    OUT PUINT SelectedMediumIndex,
    IN PNDIS_MEDIUM MediumArray,
    IN UINT MediumArraySize,
    IN NDIS_HANDLE MiniportAdapterHandle,
    IN NDIS_HANDLE WrapperConfigurationContext )

    // Standard 'MiniportInitialize' routine called by NDIS to initialize a
    // new WAN adapter.  See DDK doc.  The driver will receive no requests
    // until this initialization has completed.
    //
{
    NDIS_STATUS status;
    ADAPTERCB* pAdapter;

    TRACE( TL_N, TM_Init, ( "PtiInit" ) );

#ifdef TESTMODE
    DbgBreakPoint();
#endif

    status = *OpenErrorStatus = NDIS_STATUS_SUCCESS;

    // Find the medium index in the array of media, looking for the only one
    // we support, 'NdisMediumCoWan'.
    //
    {
        UINT i;

        for (i = 0; i < MediumArraySize; ++i)
        {
            if (MediumArray[ i ] == NdisMediumCoWan)
            {
                break;
            }
        }

        if (i >= MediumArraySize)
        {
            TRACE( TL_A, TM_Init, ( "medium?" ) );
            return NDIS_STATUS_FAILURE;
        }

        *SelectedMediumIndex = i;
    }

    // Allocate and zero a control block for the new adapter.
    //
    pAdapter = ALLOC_NONPAGED( sizeof(*pAdapter), MTAG_ADAPTERCB );
    TRACE( TL_N, TM_Init, ( "PtiInit: pAdapter=$%p", pAdapter ) );
    if (!pAdapter)
    {
        return NDIS_STATUS_RESOURCES;
    }
    NdisZeroMemory( pAdapter, sizeof(*pAdapter) );

    // The adapter control block address is recorded in 'g_pDebugAdapter' as a
    // debugging aid only.  This global is not to be read by any code.
    //
    g_pDebugAdapter = pAdapter;

    // Set a marker for easier memory dump browsing and future assertions.
    //
    pAdapter->ulTag = MTAG_ADAPTERCB;

    // Save the NDIS handle associated with this adapter for use in future
    // NdixXxx calls.
    //
    pAdapter->MiniportAdapterHandle = MiniportAdapterHandle;

    // Copy defaults NDISWAN information.  Some of these are updated below.
    //
    NdisMoveMemory( &pAdapter->info, &g_infoDefaults, sizeof(pAdapter->info) );

    do
    {
        // Read/write this adapter's registry settings.
        //
        status = RegistrySettings(
            pAdapter,
            WrapperConfigurationContext );

        if (status != NDIS_STATUS_SUCCESS)
        {
            // Set 'usMaxVcs' to 0 as an indication to FreeAdapter that the
            // lookaside lists and pools were not initialized.
            //
            pAdapter->usMaxVcs = 0;
            break;
        }

        // Initialize lookaside lists, buffer pools, and packet pool.  On NT,
        // lookaside depths are optimized by the system based on usage
        // regardless of the depth set, but choose something reasonable
        // anyway.
        //
        {
            NdisInitializeNPagedLookasideList(
                &pAdapter->llistWorkItems,
                NULL, NULL, 0,
                sizeof(NDIS_WORK_ITEM),
                MTAG_WORKITEM,
                4 );

            NdisInitializeNPagedLookasideList(
                &pAdapter->llistVcs,
                NULL, NULL, 0,
                sizeof(VCCB),
                MTAG_VCCB,
                4 );

            InitBufferPool(
                &pAdapter->poolFrameBuffers,
                PTI_FrameBufferSize,
                0, 10, 0,
                TRUE, MTAG_FBUFPOOL );

            InitPacketPool(
                &pAdapter->poolPackets,
                0, 0, 10, 0,
                MTAG_PACKETPOOL );
        }

        // Inform NDIS of the attributes of our adapter.  Set the
        // 'MiniportAdapterContext' returned to us by NDIS when it calls our
        // handlers to the address of our adapter control block.  Turn off
        // hardware oriented timeouts.
        //
        NdisMSetAttributesEx(
            MiniportAdapterHandle,
            (NDIS_HANDLE)pAdapter,
            (UINT)-1,
            NDIS_ATTRIBUTE_IGNORE_PACKET_TIMEOUT
                | NDIS_ATTRIBUTE_IGNORE_REQUEST_TIMEOUT,
            NdisInterfaceInternal );

        // Register the address family of our call manager with NDIS for the
        // newly bound adapter.  We use the mini-port form of
        // RegisterAddressFamily instead of the protocol form, though that
        // would also work.  With the protocol form, our internal call manager
        // would have to go thru NDIS to talk to the mini-port instead of just
        // calling directly.  Since the DirectParallel call manager is not
        // useful with anything but the DirectParallel mini-port, this would be a waste.
        // The mini-port form also causes the call manager VC context to
        // automatically map to the mini-port VC context, which is exactly
        // what we want.
        //
        // NDIS notifies all call manager clients of the new family we
        // register.  The TAPI proxy is the only client expected to be
        // interested.  NDISWAN will receive the notification, but ignore it
        // and wait for the TAPI proxy to notify it of the proxied version.
        //
        {
            NDIS_CALL_MANAGER_CHARACTERISTICS ncmc;
            CO_ADDRESS_FAMILY family;

            NdisZeroMemory( &family, sizeof(family) );
            family.MajorVersion = NDIS_MajorVersion;
            family.MinorVersion = NDIS_MinorVersion;
            family.AddressFamily = CO_ADDRESS_FAMILY_TAPI_PROXY;

            NdisZeroMemory( &ncmc, sizeof(ncmc) );
            ncmc.MajorVersion = NDIS_MajorVersion;
            ncmc.MinorVersion = NDIS_MinorVersion;
            ncmc.CmCreateVcHandler = PtiCmCreateVc;
            ncmc.CmDeleteVcHandler = PtiCmDeleteVc;
            ncmc.CmOpenAfHandler = PtiCmOpenAf;
            ncmc.CmCloseAfHandler = PtiCmCloseAf;
            ncmc.CmRegisterSapHandler = PtiCmRegisterSap;
            ncmc.CmDeregisterSapHandler = PtiCmDeregisterSap;
            ncmc.CmMakeCallHandler = PtiCmMakeCall;
            ncmc.CmCloseCallHandler = PtiCmCloseCall;
            ncmc.CmIncomingCallCompleteHandler = PtiCmIncomingCallComplete;
            // no CmAddPartyHandler
            // no CmDropPartyHandler
            ncmc.CmActivateVcCompleteHandler = PtiCmActivateVcComplete;
            ncmc.CmDeactivateVcCompleteHandler = PtiCmDeactivateVcComplete;
            ncmc.CmModifyCallQoSHandler = PtiCmModifyCallQoS;
            ncmc.CmRequestHandler = PtiCmRequest;

            TRACE( TL_I, TM_Mp, ( "PtiInit: NdisMCmRegAf" ) );
            status = NdisMCmRegisterAddressFamily(
                MiniportAdapterHandle, &family, &ncmc, sizeof(ncmc) );
            TRACE( TL_I, TM_Mp, ( "PtiInit: NdisMCmRegAf=$%x", status ) );
        }
    }
    while (FALSE);

    if (status == NDIS_STATUS_SUCCESS)
    {
        // Add a reference that will eventually be removed by an NDIS call to
        // the LmpHalt handler.
        //
        ReferenceAdapter( pAdapter );
    }
    else
    {
        // Failed, so undo whatever portion succeeded.
        //
        if (pAdapter)
        {
            FreeAdapter( pAdapter );
        }
    }

    TRACE( TL_V, TM_Init, ( "PtiInit: Exit: status=$%x", status ) );
    return status;
}


VOID
PtiHalt(
    IN NDIS_HANDLE MiniportAdapterContext )

    // Standard 'MiniportHalt' routine called by NDIS to deallocate all
    // resources attached to the adapter.  NDIS does not make any other calls
    // for this mini-port adapter during or after this call.  NDIS will not
    // call this routine when packets indicated as received have not been
    // returned, or when any VC is created and known to NDIS.  Runs at PASSIVE
    // IRQL.
    //
{
    ADAPTERCB* pAdapter;

    TRACE( TL_N, TM_Mp, ( "PtiHalt" ) );

    pAdapter = (ADAPTERCB* )MiniportAdapterContext;
    if (pAdapter->ulTag != MTAG_ADAPTERCB)
    {
        ASSERT( !"Atag?" );
        return;
    }

    DereferenceAdapter( pAdapter );

    TRACE( TL_V, TM_Mp, ( "PtiHalt: Exit" ) );
}


NDIS_STATUS
PtiReset(
    OUT PBOOLEAN AddressingReset,
    IN NDIS_HANDLE MiniportAdapterContext )

    // Standard 'MiniportReset' routine called by NDIS to reset the driver's
    // software state.
    //
{
    TRACE( TL_N, TM_Mp, ( "PtiReset" ) );
    return NDIS_STATUS_NOT_RESETTABLE;
}


VOID
PtiReturnPacket(
    IN NDIS_HANDLE MiniportAdapterContext,
    IN PNDIS_PACKET Packet )

    // Standard 'MiniportReturnPacket' routine called by NDIS when a packet
    // used to indicate a receive has been released by the driver above.
    //
{
    VCCB* pVc;
    CHAR* pBuffer;
    ADAPTERCB* pAdapter;
    NDIS_BUFFER* pTrimmedBuffer;
    PACKETHEAD* pHead;
    PACKETPOOL* pPool;

    TRACE( TL_V, TM_Recv, ( "PtiReturnPacket" ) );

    // Unpack the context information we stashed earlier.
    //
    pHead = *((PACKETHEAD** )(&Packet->MiniportReserved[ 0 ]));
    pBuffer = *((CHAR** )(&Packet->MiniportReserved[ sizeof(VOID*) ]));

    // Find the adapter from the PACKETHEAD address.
    //
    pPool = PacketPoolFromPacketHead( pHead );
    pAdapter = CONTAINING_RECORD( pPool, ADAPTERCB, poolPackets );
    ASSERT( pAdapter->ulTag == MTAG_ADAPTERCB );

    // Free the descriptor created by NdisCopyBuffer.
    //
    NdisUnchainBufferAtFront( Packet, &pTrimmedBuffer );
    if (pTrimmedBuffer)
    {
        NdisFreeBuffer( pTrimmedBuffer );
    }

    // Free the buffer and packet back to the pools.
    //
    FreeBufferToPool( &pAdapter->poolFrameBuffers, pBuffer, TRUE );
    FreePacketToPool( &pAdapter->poolPackets, pHead, TRUE );

    TRACE( TL_V, TM_Recv, ( "PtiReturnPacket: Exit" ) );
}


NDIS_STATUS
PtiCoActivateVc(
    IN NDIS_HANDLE MiniportVcContext,
    IN OUT PCO_CALL_PARAMETERS CallParameters )

    // Standard 'MiniportCoActivateVc' routine called by NDIS in response to a
    // protocol's request to activate a virtual circuit.
    //
{
    ASSERT( !"PtiCoActVc?" );
    return NDIS_STATUS_SUCCESS;
}


NDIS_STATUS
PtiCoDeactivateVc(
    IN NDIS_HANDLE MiniportVcContext )

    // Standard 'MiniportCoDeactivateVc' routine called by NDIS in response to
    // a protocol's request to de-activate a virtual circuit.
    //
{
    ASSERT( !"PtiCoDeactVc?" );
    return NDIS_STATUS_SUCCESS;
}


VOID
PtiCoSendPackets(
    IN NDIS_HANDLE MiniportVcContext,
    IN PPNDIS_PACKET PacketArray,
    IN UINT NumberOfPackets )

    // Standard 'MiniportCoSendPackets' routine called by NDIS in response to
    // a protocol's request to send packets on a virtual circuit.
    //
{
    UINT i;
    NDIS_STATUS status;
    NDIS_PACKET** ppPacket;
    VCCB* pVc;
    ADAPTERCB* pAdapter;
    ULONG ulLength;
    PNDIS_BUFFER pBuffer;
    PVOID pFrameVirtualAddress;
    KIRQL oldIrql;


    TRACE( TL_V, TM_Send,
        ( "PtiCoSendPackets: pVc=$%p, nPackets=$%x",
        MiniportVcContext, NumberOfPackets ) );

    pVc = (VCCB* )MiniportVcContext;
    ASSERT( pVc->ulTag == MTAG_VCCB );
    pAdapter = pVc->pAdapter;

    ReferenceVc( pVc );

    for (i = 0, ppPacket = PacketArray;
         i < NumberOfPackets;
         ++i, ++ppPacket)
    {
        NDIS_PACKET* pPacket = *ppPacket;

        if (ReferenceCall( pVc ))
        {
            // Send the packet and call NdisMCoSendComplete to notify caller
            //
            NDIS_SET_PACKET_STATUS( pPacket, NDIS_STATUS_PENDING );

            // Request the first buffer descriptor
            //
            NdisQueryPacket( pPacket, NULL, NULL, &pBuffer, NULL );

            // While pBuffer <> NULL
            do
            {
                UCHAR* pAsyncBuf;
                ULONG ulAsyncLen;

                //   request buffer address and length
                //
                NdisQueryBuffer( pBuffer,
                                 &pFrameVirtualAddress,
                                 &ulLength );

                if (IsWin9xPeer( pVc ))
                {
                    pAsyncBuf = (UCHAR* )
                        GetBufferFromPool( &pAdapter->poolFrameBuffers );

                    if (!pAsyncBuf)
                    {
                        status = NDIS_STATUS_FAILURE;
                        TRACE( TL_A, TM_Send, ( "PtiSP: !pAsyncBuf" ) );
                        break;
                    }

                    AsyncFromHdlcFraming(
                        pFrameVirtualAddress, ulLength,
                        pAsyncBuf, &ulAsyncLen,
                        pVc->linkinfo.SendACCM );

                    pFrameVirtualAddress = pAsyncBuf;
                    ulLength = ulAsyncLen;
                }
                else
                {
                    pAsyncBuf = NULL;
                }

                //   send the buffer
                //
                KeRaiseIrql(DISPATCH_LEVEL, &oldIrql);
                status = (NDIS_STATUS) PtiWrite( pVc->PtiExtension,
                                                 pFrameVirtualAddress,
                                                 ulLength,
                                                 PID_STANDARD );
                KeLowerIrql(oldIrql);

                TRACE( TL_N, TM_Send,
                     ( "PtiCoSendPackets=%x: $%x bytes", status, ulLength ) );

#ifdef TESTMODE
                if ( g_ulTraceMask & TM_Data )
                {
                    if (pFrameVirtualAddress != NULL) {
                        Dump( pFrameVirtualAddress, ulLength, 0, TRUE );
                    }
                }
#endif
                if (pAsyncBuf)
                {
                    FreeBufferToPool(
                        &pAdapter->poolFrameBuffers, pAsyncBuf, TRUE );
                }

                if (!NT_SUCCESS(status)){
                    break;
                }

                //   get next pBuffer
                //
                NdisGetNextBuffer( pBuffer, &pBuffer );

                // With current NDISWAN behavior only one NDIS_BUFFER will
                // ever be received.  If multiples are received, we need to
                // coalesce the chained buffers into an input buffer for the
                // call to AsyncFromHdlcFraming above.  For that matter, this
                // would send partial PPP frames, which, it seems to me, would
                // be discarded as fragments on the other end.  Tony, am I
                // wrong?  To avoid a useless copy, we will skip that for now,
                // but acknowledge here that the current code is not strictly
                // correct.  (SLC)
                //
                ASSERT( !pBuffer );
            }
            while ( pBuffer != NULL );

            NDIS_SET_PACKET_STATUS( pPacket, status );
            TRACE( TL_V, TM_Send,
                ( "PtiCoSendPackets: NdisMCoSendComp: status=$%x", status ) );
            NdisMCoSendComplete( status, pVc->NdisVcHandle, pPacket );
            TRACE( TL_V, TM_Send,
                ( "PtiCoSendPackets: NdisMCoSendComp done" ) );
            
            pVc->ulTotalPackets++;
            DereferenceCall( pVc );
        }
        else
        {
            TRACE( TL_A, TM_Send, ( "Send to inactive call ignored" ) );
            NDIS_SET_PACKET_STATUS( pPacket, NDIS_STATUS_FAILURE );
            NdisMCoSendComplete( status, pVc->NdisVcHandle, pPacket );
        }
    }

    DereferenceVc( pVc );
    TRACE( TL_V, TM_Send, ( "PtiCoSendPackets: Exit" ) );
}


NDIS_STATUS
PtiCoRequest(
    IN NDIS_HANDLE MiniportAdapterContext,
    IN NDIS_HANDLE MiniportVcContext,
    IN OUT PNDIS_REQUEST NdisRequest )

    // Standard 'MiniportCoRequestHandler' routine called by NDIS in response
    // to a protocol's request information from the mini-port.  Unlike the
    // Query/SetInformation handlers that this routine obsoletes, requests are
    // not serialized.
    //
{
    ADAPTERCB* pAdapter;
    VCCB* pVc;
    NDIS_STATUS status;

    TRACE( TL_N, TM_Mp, ( "PtiCoReq" ) );

    pAdapter = (ADAPTERCB* )MiniportAdapterContext;
    if (pAdapter->ulTag != MTAG_ADAPTERCB)
    {
        ASSERT( !"Atag?" );
        return NDIS_STATUS_INVALID_DATA;
    }

    pVc = (VCCB* )MiniportVcContext;
    if (pVc && pVc->ulTag != MTAG_VCCB)
    {
        ASSERT( !"Vtag?" );
        return NDIS_STATUS_INVALID_DATA;
    }

    switch (NdisRequest->RequestType)
    {
        case NdisRequestQueryInformation:
        {
            status = QueryInformation(
                pAdapter,
                pVc,
                NdisRequest->DATA.QUERY_INFORMATION.Oid,
                NdisRequest->DATA.QUERY_INFORMATION.InformationBuffer,
                NdisRequest->DATA.QUERY_INFORMATION.InformationBufferLength,
                &NdisRequest->DATA.QUERY_INFORMATION.BytesWritten,
                &NdisRequest->DATA.QUERY_INFORMATION.BytesNeeded );
            break;
        }

        case NdisRequestSetInformation:
        {
            status = SetInformation(
                pAdapter,
                pVc,
                NdisRequest->DATA.SET_INFORMATION.Oid,
                NdisRequest->DATA.SET_INFORMATION.InformationBuffer,
                NdisRequest->DATA.SET_INFORMATION.InformationBufferLength,
                &NdisRequest->DATA.SET_INFORMATION.BytesRead,
                &NdisRequest->DATA.SET_INFORMATION.BytesNeeded );
            break;
        }

        default:
        {
            status = NDIS_STATUS_NOT_SUPPORTED;
            TRACE( TL_A, TM_Mp, ( "PtiCoReq: type=%d unsupported", NdisRequest->RequestType ) );
            break;
        }
    }

    TRACE( TL_V, TM_Mp, ( "PtiCoReq: Exit: $%x", status ) );
    return status;
}


//-----------------------------------------------------------------------------
// Callback routines ... called by the PtiLink layer below
//-----------------------------------------------------------------------------


PVOID
PtiCbGetReadBuffer(
    IN  PVOID   Context,
    OUT PULONG  BufferSize,
    OUT PVOID*  RequestContext )

    // PtiLink is requesting a read buffer, get one and return it
    // This is a the start of a receive event ...
{
    VCCB* pVc;
    ADAPTERCB* pAdapter;
    PCHAR pBuffer;  

    TRACE( TL_V, TM_Spec, ( "PtiCbGetReadBuffer: pVc=$%p", Context ) );

    pVc = (VCCB* )Context;
    if (pVc->ulTag != MTAG_VCCB)
    {
        ASSERT( !"Vtag?" );
        return NULL;
    }

    pAdapter = pVc->pAdapter;

    // the pVc is our context for use of this buffer
    //
    *RequestContext = pVc;

    // Give caller the length of this buffer
    //
    *BufferSize = PTI_FrameBufferSize;

    // ask for a buffer, caller must check for NULL
    //
    pBuffer = GetBufferFromPool( &pAdapter->poolFrameBuffers );

    TRACE( TL_V, TM_Spec,
        ( "PtiCbGetReadBuffer: Exit: Issuing pBuffer=$%p", pBuffer ) );

    // return the buffer to the caller
    // this is a raw system va
    //
    return pBuffer;
}


VOID
PtiRx(
    IN  PVOID       Context,
    IN  PVOID       pBuffer,
    IN  NTSTATUS    Status,
    IN  ULONG       ulLength,
    IN  PVOID       RequestContext )

    // Ptilink has completed a read, i.e., receive complete
    //   buffer now belongs to this layer
    //
    //  Context --  is the pVC
    //
    //  pBuffer --  is the pointer to buffer previously allocated
    //              to the PtiLink driver via the PtiCbGetReadBuffer function
    //
    //  Status  --  one of: NT_SUCCESS      = good packet received
    //                      DATA_OVERRUN    = header failure
    //                      BUFFER_TOO_SMALL= pBuffer is too small to receive packet
    //
    //  ulLength -  packet length
    //
    //  RequestContext -- don't care
    //
    // General Note: PtiLink below us sends and receives link manangement
    // packets using the Our and His structures ... link management packets to
    // not flow through here.  Link events are announced to us via our
    // registered callback (PtiCbLinkEventHandler) below.  We have nothing to
    // do with Tx/Rx of link pkts.
    //
{
    VCCB* pVc;
    ADAPTERCB* pAdapter;
    NDIS_STATUS status;
    NDIS_STATUS writestatus;
    NDIS_PACKET* pPacket;
    NDIS_BUFFER* pNdisBuffer;
    PACKETHEAD* pHead;
    ULONGLONG ullTimeReceived;
    KIRQL oldIrql;
    UCHAR* pHdlcBuf;
    ULONG ulHdlcLen;
    UCHAR* pTmp;

    TRACE( TL_N, TM_Recv, ( "PtiRx=%x: bytes=$%x", Status, ulLength ) );
    TRACE( TL_V, TM_Recv, ( "PtiRx=%x, pVc=$%p, pBuf=$%p, bytes=$%x",
           Status, Context, pBuffer, ulLength ) );

    pVc = (VCCB* )Context;
    if (pVc->ulTag != MTAG_VCCB)
    {
        ASSERT( !"Vtag?" );
        return;
    }
    ReferenceVc( pVc );

    pAdapter = pVc->pAdapter;

    // NOT A REAL DATA PACKET
    //   return any buffers used for non-data or losing reads
    //
    if ( !NT_SUCCESS( Status ) ){
        TRACE( TL_A, TM_Pool, ( "PtiRx: Status != SUCCESS, freeing buffer", Status ) );

        if ( pBuffer != NULL ) {
            FreeBufferToPool( &pAdapter->poolFrameBuffers, pBuffer, TRUE );
        }

        DereferenceVc( pVc );
        return;
    }

#ifdef TESTMODE
    if ( g_ulTraceMask & TM_Data )
    {
        if (pBuffer != NULL) {
            Dump( pBuffer, ulLength, 0, TRUE );
        }
    }
#endif

    // INCOMING CALL ... NO VC EXISTS YET for this incoming data packet
    //
    if (ReferenceSap( pAdapter ))
    {
        if (!(ReadFlags( &pAdapter->pListenVc->ulFlags ) & VCBF_CallInProgress))
        {
            // Setting in Listen VC here.
            //
            SetFlags( &pAdapter->pListenVc->ulFlags, VCBF_CallInProgress );

            // This is the start of an incoming call which may also start via
            //   LINK_OPEN event to PtiCbLinkEventHandler
            //
            // Ignore this packet and proceed to dispatch an incoming call
            //
            TRACE( TL_V, TM_Recv, ( "PtiRx: Incoming call", Status ) );

            // Free the buffer associated with this read ... we throw away the
            // data thus losing one packet off the front of an attempt to
            // connect, unless the LPKT_OPEN function beats us (a LPKT_OPEN
            // notification occurs before first data packet is received ... it
            // could happen either way.)
            //
            if (pBuffer != NULL ) {
                FreeBufferToPool( &pAdapter->poolFrameBuffers, pBuffer, TRUE );
            }

            // set up a VC for the incoming call
            //
            SetupVcAsynchronously( pAdapter );
            DereferenceVc( pVc );
            DereferenceSap( pAdapter );
            return;
        }

        DereferenceSap( pAdapter );
    }

    // NOW HAVE A REAL DATA PACKET

    if (ReferenceCall( pVc ))
    {
        do
        {
            if (IsWin9xPeer( pVc ))
            {
                if (pVc->ulTotalPackets < 4)
                {
                    // If packet matches "CLIENT", we emit one saying
                    // "CLIENTSERVER"
                    //
                    // If packet matches "CLIENTSERVER", throw it away
                    //
                    // This hack emulates the Win9x UNIMODEM behavior which is
                    // required to allow Win9x systems to connect to us.
                    //
                    // Also, it appears that sending the "CLIENT" packet up
                    // the stack causes RasTapi to disconnect us immediately.
                    // It wants to see PPP?
                    //

                    if ( StrCmp(
                             pBuffer, g_szClientServer, CLIENTSERVERLEN ) == 0 )
                    {
                        // throw away packets containing "CLIENTSERVER"
                        //
                        FreeBufferToPool(
                            &pAdapter->poolFrameBuffers, pBuffer, TRUE );
                        TRACE( TL_V, TM_Recv,
                            ( "PtiRx: CLIENTSERVER ignored", Status ) );
                        pVc->ulTotalPackets++;
                        break;
                    }
                    else if ( StrCmp(
                                 pBuffer, g_szClient, CLIENTLEN ) == 0 )
                    {
                        // when we see "CLIENT", throw away and respond
                        // "CLIENTSERVER".
                        //
                        TRACE( TL_V, TM_Recv, ( "PtiRx: See CLIENT", Status ) );

                        KeRaiseIrql(DISPATCH_LEVEL, &oldIrql);
                        writestatus = (NDIS_STATUS) PtiWrite(
                            pVc->PtiExtension,
                            g_szClientServer,
                            CLIENTSERVERLEN,
                            PID_STANDARD );
                        KeLowerIrql(oldIrql);

                        FreeBufferToPool(
                            &pAdapter->poolFrameBuffers, pBuffer, TRUE );
                        TRACE( TL_V, TM_Recv,
                            ( "PtiRx: CLIENTSERVER sent", Status ) );
                        pVc->ulTotalPackets++;
                        break;
                    }
                }

                // Un-byte-stuff the received buffer into a second buffer,
                // then swap it with the received buffer.
                //
                pHdlcBuf = (UCHAR* )
                    GetBufferFromPool( &pAdapter->poolFrameBuffers );
                if (!pHdlcBuf)
                {
                    FreeBufferToPool(
                        &pAdapter->poolFrameBuffers, pBuffer, TRUE );
                    TRACE( TL_A, TM_Recv, ( "PtiRx: !Alloc HDLC" ) );
                    break;
                }

                HdlcFromAsyncFraming(
                    pBuffer, ulLength, pHdlcBuf, &ulHdlcLen );

                pTmp = pBuffer;
                pBuffer = pHdlcBuf;
                ulLength = ulHdlcLen;
                FreeBufferToPool( &pAdapter->poolFrameBuffers, pTmp, TRUE );
            }

            // Note the time if client's call parameters indicated interest in
            // time received.
            //
            if (ReadFlags( &pVc->ulFlags ) & VCBF_IndicateTimeReceived)
            {
                NdisGetCurrentSystemTime( (LARGE_INTEGER* )&ullTimeReceived );
            }
            else
            {
                ullTimeReceived = 0;
            }

            TRACE( TL_V, TM_Recv,
                ( "PtiRx: Rx Packet: nBytes=$%x", ulLength ) );

            // Get a packet from the packet pool
            //
            pPacket = GetPacketFromPool( &pAdapter->poolPackets, &pHead );
            if (!pPacket)
            {
                // Packet descriptor pool is maxed.
                //
                ASSERT( !"GetPfP?" );
                break;
            }

            // Hook the NDIS_BUFFER to the packet.  The "copy" here refers to
            // descriptor information only.  The packet data is not copied.
            //
            NdisCopyBuffer(
                &status,
                &pNdisBuffer,
                PoolHandleForNdisCopyBufferFromBuffer( pBuffer ),
                NdisBufferFromBuffer( pBuffer ),
                0,
                ulLength );

            if (status != STATUS_SUCCESS)
            {
                // Can't get a MDL which likely means the system is toast.
                //
                FreePacketToPool( &pAdapter->poolPackets, pHead, TRUE );
                TRACE( TL_A, TM_Recv, ( "NdisCopyBuffer=%08x?", status ) );
                break;
            }

            NdisChainBufferAtFront( pPacket, pNdisBuffer );

            // Stash the time the packet was received in the packet.
            //
            NDIS_SET_PACKET_TIME_RECEIVED( pPacket, ullTimeReceived );

            // Pre-set the packet to success, since a random value of
            // NDIS_STATUS_RESOURCES would prevent our ReturnPackets handler
            // from getting called.
            //
            NDIS_SET_PACKET_STATUS( pPacket, NDIS_STATUS_SUCCESS );

            // Stash our context information with the packet for clean-up use
            // in PtiReturnPacket, then indicate the packet to NDISWAN.
            //
            *((PACKETHEAD** )(&pPacket->MiniportReserved[ 0 ])) = pHead;
            *((CHAR** )(&pPacket->MiniportReserved[ sizeof(VOID*) ])) = pBuffer;

            TRACE( TL_V, TM_Recv,
                ( "PtiRx: NdisMCoIndRecPkt: hVc=$%p, pPacket=$%p, len=$%x",
                pVc->NdisVcHandle, pPacket, ulLength ) );

            NdisMCoIndicateReceivePacket( pVc->NdisVcHandle, &pPacket, 1 );

            TRACE( TL_V, TM_Recv, ( "PtiRx: NdisMCoIndRecPkt done" ) );

            // Tell NDIS our "receive process" is complete.  Since we deal
            // with one packet at a time and NDISWAN does also, this doesn't
            // accomplish anything, but the consensus is it's bad form to omit
            // it.
            //
            TRACE( TL_V, TM_Recv, ( "PtiRx: NdisMCoRecComp" ) );
            NdisMCoReceiveComplete( pAdapter->MiniportAdapterHandle );
            TRACE( TL_V, TM_Recv, ( "PtiRx: NdisMCoRecComp done" ) );
            pVc->ulTotalPackets++;
        }
        while (FALSE);

        DereferenceCall( pVc );
    }
    else
    {
        TRACE( TL_A, TM_Recv, ( "Receive on inactive call ignored" ) );
    }

    DereferenceVc( pVc );
    return;
}


VOID
PtiCbLinkEventHandler(
    IN  PVOID       Context,
    IN  ULONG       PtiLinkEventId,
    IN  ULONG       PtiLinkEventData )

    // Ptilink is reporting a link management event (Link up or down)
    //
{
    VCCB* pVc;
    ADAPTERCB* pAdapter;

    pVc = (VCCB* )Context;
    if (pVc->ulTag != MTAG_VCCB)
    {
        ASSERT( !"Vtag?" );
        return;
    }

    pAdapter = pVc->pAdapter;

    switch (PtiLinkEventId)
    {
        case PTILINK_LINK_UP:
        {
            TRACE( TL_A, TM_Cm, ( "LinkEvent: LINK UP, pVc=$%p", pVc ) );

            // peer is initiating a call (also happens in PtiRx)
            //
            break;
        }

        case PTILINK_LINK_DOWN:
        {
            TRACE( TL_A, TM_Cm, ( "LinkEvent: LINK DOWN, pVc=$%p", pVc ) );

            // peer is closing a call
            //
            if (pVc == pAdapter->pListenVc)
            {
                TRACE( TL_A, TM_Cm,
                    ( "LinkEvent: LINK DOWN on ListenVc ignored" ) );
                break;
            }

            NdisAcquireSpinLock( &pVc->lockV );
            {
                pVc->status = NDIS_STATUS_TAPI_DISCONNECTMODE_NORMAL;
                CallTransitionComplete( pVc );
            }
            NdisReleaseSpinLock( &pVc->lockV );

            TRACE( TL_A, TM_Cm, ( "LinkEvent: LINK DOWN causing disconnect" ) );

            CompleteVc( pVc );
            break;
        }

        default:
        {
            TRACE( TL_A, TM_Cm,
                ( "LinkEvent: Bad LinkEvent = %d", PtiLinkEventId ) );
            break;
        }
    }
}


//-----------------------------------------------------------------------------
// Mini-port utility routines (alphabetically)
// Some are used externally
//-----------------------------------------------------------------------------

VOID
AsyncFromHdlcFraming(
    IN UCHAR* pInBuf,
    IN ULONG ulInBufLen,
    OUT UCHAR* pOutBuf,
    OUT ULONG* pulOutBufLen,
    IN ULONG ulAccmMask )

    // Make a copy of PPP HDLC framed data buffer 'pInBuf' of length
    // 'ulInBufLen' bytes in caller's 'pOutBuf' buffer, converting to
    // byte-stuffed asynchronous PPP framed format in the process.
    // 'POutBufLen' is the length in bytes of the returned output buffer.  Due
    // to the byte stuffing, caller must allow for up to twice the length of
    // 'pInfBuf'.  'UlAccmMask' is the bitmask of characters to be byte
    // stuffed.
    //
    // With current implementation, user must allow 2 extra bytes at the end
    // of the input buffer for stashing the FCS during byte-stuffing.
    //
    // This routine is adapted from the ASYNCMAC AssemblePppFrame routine, as
    // is the following description, which in turn was lifted from RFC 1331
    // (May 1992).  The PPP frame NDISWAN passes us for sends is the data from
    // the Address field through the Information field inclusive, without any
    // byte stuffing, of course.
    //
    // Asynchronously framed PPP packet:
    //
    //  +----------+----------+----------+----------+------------...
    //  |   Flag   | Address  | Control  | Protocol | Information
    //  | 01111110 | 11111111 | 00000011 | 16 bits  |      *
    //  +----------+----------+----------+----------+------------...
    //  ...---+----------+----------+-----------------
    //      |   FCS    |   Flag   | Inter-frame Fill
    //      | 16 bits  | 01111110 | or next Address
    //  ...---+----------+----------+-----------------
    //
    // Frame Check Sequence (FCS) Field
    //
    //   The Frame Check Sequence field is normally 16 bits (two octets).  The
    //   use of other FCS lengths may be defined at a later time, or by prior
    //   agreement.
    //
    //   The FCS field is calculated over all bits of the Address, Control,
    //   Protocol and Information fields not including any start and stop bits
    //   (asynchronous) and any bits (synchronous) or octets (asynchronous)
    //   inserted for transparency.  This does not include the Flag Sequences
    //   or the FCS field itself.  The FCS is transmitted with the coefficient
    //   of the highest term first.
    //
    //      Note: When octets are received which are flagged in the Async-
    //      Control-Character-Map, they are discarded before calculating the
    //      FCS.  See the description in Appendix A.
    //
    //      On asynchronous links, a character stuffing procedure is used.
    //      The Control Escape octet is defined as binary 01111101
    //      (hexadecimal 0x7d) where the bit positions are numbered 87654321
    //      (not 76543210, BEWARE).
    //
    //      After FCS computation, the transmitter examines the entire frame
    //      between the two Flag Sequences.  Each Flag Sequence, Control
    //      Escape octet and octet with value less than hexadecimal 0x20 which
    //      is flagged in the Remote Async-Control-Character-Map is replaced
    //      by a two octet sequence consisting of the Control Escape octet and
    //      the original octet with bit 6 complemented (i.e., exclusive-or'd
    //      with hexadecimal 0x20).
    //
    //      Prior to FCS computation, the receiver examines the entire frame
    //      between the two Flag Sequences.  Each octet with value less than
    //      hexadecimal 0x20 is checked.  If it is flagged in the Local
    //      Async-Control-Character-Map, it is simply removed (it may have
    //      been inserted by intervening data communications equipment).  For
    //      each Control Escape octet, that octet is also removed, but bit 6
    //      of the following octet is complemented.  A Control Escape octet
    //      immediately preceding the closing Flag Sequence indicates an
    //      invalid frame.
    //
    //         Note: The inclusion of all octets less than hexadecimal 0x20
    //         allows all ASCII control characters [10] excluding DEL (Delete)
    //         to be transparently communicated through almost all known data
    //         communications equipment.
    //
    //
    //      The transmitter may also send octets with value in the range 0x40
    //      through 0xff (except 0x5e) in Control Escape format.  Since these
    //      octet values are not negotiable, this does not solve the problem
    //      of receivers which cannot handle all non-control characters.
    //      Also, since the technique does not affect the 8th bit, this does
    //      not solve problems for communications links that can send only 7-
    //      bit characters.
    //
    //      A few examples may make this more clear.  Packet data is
    //      transmitted on the link as follows:
    //
    //         0x7e is encoded as 0x7d, 0x5e.
    //         0x7d is encoded as 0x7d, 0x5d.
    //
    //         0x01 is encoded as 0x7d, 0x21.
    //
    //      Some modems with software flow control may intercept outgoing DC1
    //      and DC3 ignoring the 8th (parity) bit.  This data would be
    //      transmitted on the link as follows:
    //
    //         0x11 is encoded as 0x7d, 0x31.
    //         0x13 is encoded as 0x7d, 0x33.
    //         0x91 is encoded as 0x7d, 0xb1.
    //         0x93 is encoded as 0x7d, 0xb3.
    //
{
    USHORT usFcs;
    UCHAR* pIn;
    UCHAR* pOut;
    ULONG ulInBytesLeft;

    pIn = pInBuf;
    ulInBytesLeft = ulInBufLen;
    pOut = pOutBuf;

    // Calculate the frame check sequence on the data.
    //
    TRACE( TL_I, TM_Data, ( "AfromH (send) dump:" ) );
    DUMPB( TL_I, TM_Data, pInBuf, ulInBufLen );
    usFcs = CalculatePppFcs( pInBuf, ulInBufLen );
    usFcs ^= 0xFFFF;

    // Add the calculated FCS.  Added to the input buffer for convenience as
    // it must be byte-stuffed along with the other data, though this uglies
    // the interface a bit.
    //
    pIn[ ulInBytesLeft ] = (UCHAR )usFcs;
    ++ulInBytesLeft;
    pIn[ ulInBytesLeft ] = (UCHAR )(usFcs >> 8);
    ++ulInBytesLeft;

    // Add the initial flag byte.
    //
    *pOut = PPPFLAGBYTE;
    ++pOut;

    // Because an empty control character mask is common, an optimized loop is
    // provided in that case.
    //
    if (ulAccmMask
#ifdef TESTMODE
        || g_fNoAccmFastPath
#endif
       )
    {
        // Have bitmask...slower path.
        //
        while (ulInBytesLeft--)
        {
            UCHAR uch;

            uch = *pIn;
            ++pIn;

            if (((uch < 0x20) && ((1 << uch) & ulAccmMask))
                || (uch == PPPESCBYTE) || (uch == PPPFLAGBYTE))
            {
                // Byte stuff the character.
                //
                *pOut = PPPESCBYTE;
                ++pOut;
                *pOut = uch ^ 0x20;
                ++pOut;
            }
            else
            {
                // Copy the character as is.
                //
                *pOut = uch;
                ++pOut;
            }
        }
    }
    else
    {
        // No bitmask...fast path.
        //
        while (ulInBytesLeft--)
        {
            UCHAR uch;

            uch = *pIn;
            ++pIn;

            if ((uch == PPPESCBYTE) || (uch == PPPFLAGBYTE))
            {
                // Byte stuff the character.
                //
                *pOut = PPPESCBYTE;
                ++pOut;
                *pOut = uch ^ 0x20;
                ++pOut;
            }
            else
            {
                // Copy the character as is.
                //
                *pOut = uch;
                ++pOut;
            }
        }
    }

    // Add the trailing flag byte.
    //
    *pOut = PPPFLAGBYTE;
    ++pOut;

    // Calculate length of output.
    //
    *pulOutBufLen = (ULONG )(pOut - pOutBuf);
}


USHORT
CalculatePppFcs(
    IN UCHAR* pBuf,
    IN ULONG ulBufLen )

    // Return the PPP Frame Check Sequence on 'ulBufLen' bytes starting at
    // 'pBuf'.
    //
    // (Taken from ASYNCMAC)
    //
{
    static USHORT ausFcsTable[ 256 ] =
    {
        0x0000, 0x1189, 0x2312, 0x329b, 0x4624, 0x57ad, 0x6536, 0x74bf,
        0x8c48, 0x9dc1, 0xaf5a, 0xbed3, 0xca6c, 0xdbe5, 0xe97e, 0xf8f7,
        0x1081, 0x0108, 0x3393, 0x221a, 0x56a5, 0x472c, 0x75b7, 0x643e,
        0x9cc9, 0x8d40, 0xbfdb, 0xae52, 0xdaed, 0xcb64, 0xf9ff, 0xe876,
        0x2102, 0x308b, 0x0210, 0x1399, 0x6726, 0x76af, 0x4434, 0x55bd,
        0xad4a, 0xbcc3, 0x8e58, 0x9fd1, 0xeb6e, 0xfae7, 0xc87c, 0xd9f5,
        0x3183, 0x200a, 0x1291, 0x0318, 0x77a7, 0x662e, 0x54b5, 0x453c,
        0xbdcb, 0xac42, 0x9ed9, 0x8f50, 0xfbef, 0xea66, 0xd8fd, 0xc974,
        0x4204, 0x538d, 0x6116, 0x709f, 0x0420, 0x15a9, 0x2732, 0x36bb,
        0xce4c, 0xdfc5, 0xed5e, 0xfcd7, 0x8868, 0x99e1, 0xab7a, 0xbaf3,
        0x5285, 0x430c, 0x7197, 0x601e, 0x14a1, 0x0528, 0x37b3, 0x263a,
        0xdecd, 0xcf44, 0xfddf, 0xec56, 0x98e9, 0x8960, 0xbbfb, 0xaa72,
        0x6306, 0x728f, 0x4014, 0x519d, 0x2522, 0x34ab, 0x0630, 0x17b9,
        0xef4e, 0xfec7, 0xcc5c, 0xddd5, 0xa96a, 0xb8e3, 0x8a78, 0x9bf1,
        0x7387, 0x620e, 0x5095, 0x411c, 0x35a3, 0x242a, 0x16b1, 0x0738,
        0xffcf, 0xee46, 0xdcdd, 0xcd54, 0xb9eb, 0xa862, 0x9af9, 0x8b70,
        0x8408, 0x9581, 0xa71a, 0xb693, 0xc22c, 0xd3a5, 0xe13e, 0xf0b7,
        0x0840, 0x19c9, 0x2b52, 0x3adb, 0x4e64, 0x5fed, 0x6d76, 0x7cff,
        0x9489, 0x8500, 0xb79b, 0xa612, 0xd2ad, 0xc324, 0xf1bf, 0xe036,
        0x18c1, 0x0948, 0x3bd3, 0x2a5a, 0x5ee5, 0x4f6c, 0x7df7, 0x6c7e,
        0xa50a, 0xb483, 0x8618, 0x9791, 0xe32e, 0xf2a7, 0xc03c, 0xd1b5,
        0x2942, 0x38cb, 0x0a50, 0x1bd9, 0x6f66, 0x7eef, 0x4c74, 0x5dfd,
        0xb58b, 0xa402, 0x9699, 0x8710, 0xf3af, 0xe226, 0xd0bd, 0xc134,
        0x39c3, 0x284a, 0x1ad1, 0x0b58, 0x7fe7, 0x6e6e, 0x5cf5, 0x4d7c,
        0xc60c, 0xd785, 0xe51e, 0xf497, 0x8028, 0x91a1, 0xa33a, 0xb2b3,
        0x4a44, 0x5bcd, 0x6956, 0x78df, 0x0c60, 0x1de9, 0x2f72, 0x3efb,
        0xd68d, 0xc704, 0xf59f, 0xe416, 0x90a9, 0x8120, 0xb3bb, 0xa232,
        0x5ac5, 0x4b4c, 0x79d7, 0x685e, 0x1ce1, 0x0d68, 0x3ff3, 0x2e7a,
        0xe70e, 0xf687, 0xc41c, 0xd595, 0xa12a, 0xb0a3, 0x8238, 0x93b1,
        0x6b46, 0x7acf, 0x4854, 0x59dd, 0x2d62, 0x3ceb, 0x0e70, 0x1ff9,
        0xf78f, 0xe606, 0xd49d, 0xc514, 0xb1ab, 0xa022, 0x92b9, 0x8330,
        0x7bc7, 0x6a4e, 0x58d5, 0x495c, 0x3de3, 0x2c6a, 0x1ef1, 0x0f78
    };

    register USHORT usFcs;

    usFcs = 0xFFFF;
    while (ulBufLen--)
    {
        usFcs = (usFcs >> 8) ^ ausFcsTable[ (usFcs ^ (USHORT )*pBuf) & 0xFF ];
        ++pBuf;
    }

    return usFcs;
}


VOID
DereferenceAdapter(
    IN ADAPTERCB* pAdapter )

    // Removes a reference from the adapter control block 'pAdapter', and when
    // frees the adapter resources when the last reference is removed.
    //
{
    LONG lRef;

    lRef = NdisInterlockedDecrement( &pAdapter->lRef );

    TRACE( TL_N, TM_Ref, ( "DerefA to %d", lRef ) );
    ASSERT( lRef >= 0 );

    if (lRef == 0)
    {
        FreeAdapter( pAdapter );
    }
}


VOID
DereferenceVc(
    IN VCCB* pVc )

    // Removes a reference to the VC control block 'pVc', and when frees the
    // block when the last reference is removed.
    //
{
    LONG lRef;

    lRef = NdisInterlockedDecrement( &pVc->lRef );

    TRACE( TL_N, TM_Ref, ( "DerefVc to %d", lRef ) );
    ASSERT( lRef >= 0 );

    if (lRef == 0)
    {
        ADAPTERCB* pAdapter;

        // now for an interesting bit ...
        //
        // if we have a listenVc allocated, then revert to using that
        //
        pAdapter = pVc->pAdapter;
        if (pAdapter->ulTag != MTAG_ADAPTERCB)
        {
            ASSERT( !"Atag?" );
            return;
        }

        if (pAdapter->pListenVc && pAdapter->pListenVc->hPtiLink)
        {
            TRACE( TL_V, TM_Mp,
                ( "DerefVc: Reverting to pVc=$%p", pAdapter->pListenVc ) );

            ClearFlags( &pAdapter->pListenVc->ulFlags, VCBF_CallInProgress );

            // reregister using the listen Vc
            //
            TRACE( TL_V, TM_Mp, ( "DerefVc: RegCb pLV=$%p",
                pAdapter->pListenVc ) );
            PtiRegisterCallbacks(pAdapter->pListenVc->Extension,    // the PTILINKx extension
                                 PtiCbGetReadBuffer,                // our get buffer routine
                                 PtiRx,                             // our receive complete routine
                                 PtiCbLinkEventHandler,             // our link event handler
                                 pAdapter->pListenVc);              // our new context
        }

        // Can make these assumptions because NDIS will not call the delete-VC
        // handler while the VC is active.  All the nasty VC clean up occurs
        // before the VC is deactivated and the call closed.
        //
        pVc->ulTag = MTAG_FREED;
        FREE_VCCB( pAdapter, pVc );
        DereferenceAdapter( pAdapter );
        TRACE( TL_I, TM_Mp, ( "pVc=$%p freed", pVc ) );
    }
}


VOID
FreeAdapter(
    IN ADAPTERCB* pAdapter )

    // Frees all resources allocated for adapter 'pAdapter', including
    // 'pAdapter' itself.
    //
{
    BOOLEAN fSuccess;

    // Setting 'usMaxVcs' to 0 is PtiInitialize's way of telling us that the
    // lookaside lists and pools were not initialized.
    //
    if (pAdapter->usMaxVcs)
    {
        NdisDeleteNPagedLookasideList( &pAdapter->llistWorkItems );
        NdisDeleteNPagedLookasideList( &pAdapter->llistVcs );
    }

    TRACE( TL_V, TM_Mp, ( "FreeAdapter" ) );

    pAdapter->ulTag = MTAG_FREED;
    FREE_NONPAGED( pAdapter );
}


NDIS_STATUS
RegistrySettings(
    IN OUT ADAPTERCB* pAdapter,
    IN NDIS_HANDLE WrapperConfigurationContext )

    // Read this mini-port's registry settings into 'pAdapter' fields.  Also
    // writes registry values read by RASTAPI, overriding SETUPs.
    // 'WrapperConfigurationContext' is the handle to passed to
    // MiniportInitialize.
    //
{
    NDIS_STATUS status;
    NDIS_HANDLE hCfg;
    NDIS_CONFIGURATION_PARAMETER* pncp;

    NdisOpenConfiguration( &status, &hCfg, WrapperConfigurationContext );
    if (status != NDIS_STATUS_SUCCESS)
    {
        return status;
    }

    do
    {
        // The delay in milliseconds to wait for PARPORT to initialize all the
        // parallel ports.  With PnP there is no deterministic time at which
        // to do this.
        //
        {
            NDIS_STRING nstr = NDIS_STRING_CONST( "ParportDelayMs" );

            NdisReadConfiguration(
                &status, &pncp, hCfg, &nstr, NdisParameterInteger );

            if (status == NDIS_STATUS_SUCCESS)
            {
                pAdapter->ulParportDelayMs = pncp->ParameterData.IntegerData;
            }
            else
            {
                // Default is 3 seconds.
                //
                pAdapter->ulParportDelayMs = 3000;
                status = NDIS_STATUS_SUCCESS;
            }
        }

        // The secondary delay in milliseconds to wait for PARPORT to
        // initialize all the parallel ports, if there are no ports after the
        // initial delay above.
        //
        {
            NDIS_STRING nstr = NDIS_STRING_CONST( "ExtraParportDelayMs" );

            NdisReadConfiguration(
                &status, &pncp, hCfg, &nstr, NdisParameterInteger );

            if (status == NDIS_STATUS_SUCCESS)
            {
                pAdapter->ulExtraParportDelayMs =
                    pncp->ParameterData.IntegerData;
            }
            else
            {
                // Default is 30 seconds.
                //
                pAdapter->ulExtraParportDelayMs = 30000;
                status = NDIS_STATUS_SUCCESS;
            }
        }

        // The number of VCs we must be able to provide.
        //
        {
#if 0
            NDIS_STRING nstr = NDIS_STRING_CONST( "MaxVcs" );

            NdisReadConfiguration(
                &status, &pncp, hCfg, &nstr, NdisParameterInteger );

            if (status == NDIS_STATUS_SUCCESS)
            {
                pAdapter->usMaxVcs = (USHORT )pncp->ParameterData.IntegerData;

                // Make sure it's a valid value.
                //
                if (pAdapter->usMaxVcs < 1)
                {
                    status = NDIS_STATUS_INVALID_DATA;
                    break;
                }
            }
            else
            {
                pAdapter->usMaxVcs = 1;
                status = NDIS_STATUS_SUCCESS;
            }
#else
            // Registry value is currently ignored, and hard-coded maximum
            // used.
            //
            pAdapter->usMaxVcs = NPORTS;
#endif
        }
    }
    while (FALSE);

    NdisCloseConfiguration( hCfg );

    TRACE( TL_N, TM_Init,
        ( "Reg: vcs=%d ppd=%d",
        (UINT )pAdapter->usMaxVcs,
        (UINT )pAdapter->ulParportDelayMs ) );

    return status;
}


BOOLEAN
HdlcFromAsyncFraming(
    IN UCHAR* pInBuf,
    IN ULONG ulInBufLen,
    OUT UCHAR* pOutBuf,
    OUT ULONG* pulOutBufLen )

    // Make a copy of asynchronously framed PPP data buffer 'pInBuf' of length
    // 'ulInBufLen' bytes in caller's 'pOutBuf' buffer, converting to PPP HDLC
    // framed format in the process.  'POutBufLen' is the length in bytes of
    // the returned output buffer.  Caller must allow for up to the length of
    // 'pInBuf' in 'pOutBuf'.
    //
    // Returns true if the packet is valid, false if corrupt.
    //
    // Adapted from ASYNCMAC's AsyncPPPCompletionRoutine.
    //
{
    UCHAR* pIn;
    UCHAR* pInEnd;
    UCHAR* pOut;
    USHORT usFcs;

    if (ulInBufLen < 5)
    {
        // Expecting at least 2 flag bytes, 1 data byte, and the FCS.
        //
        TRACE( TL_A, TM_Mp, ( "HfA: frame too short=%d", ulInBufLen ) );
        return FALSE;
    }

    if (pInBuf[ 0 ] != PPPFLAGBYTE)
    {
        TRACE( TL_A, TM_Mp, ( "HfA: No head flag" ) );
        return FALSE;
    }

    if (pInBuf[ ulInBufLen - 1 ] != PPPFLAGBYTE)
    {
        TRACE( TL_A, TM_Mp, ( "HfA: No tail flag" ) );
        return FALSE;
    }

    pIn = pInBuf + 1;
    pInEnd = pInBuf + ulInBufLen - 1;
    pOut = pOutBuf;

    while (pIn < pInEnd)
    {
        if (*pIn == PPPESCBYTE)
        {
            ++pIn;
            *pOut = *pIn ^ 0x20;
        }
        else
        {
            *pOut = *pIn;
        }

        ++pOut;
        ++pIn;
    }

    *pulOutBufLen = (ULONG )(pOut - pOutBuf - 2);

    {
        USHORT usCalcFcs;

        usFcs = (USHORT )(pOut[ -2 ]) + (USHORT )(pOut[ -1 ] << 8);
        usFcs ^= 0xFFFF;

        TRACE( TL_I, TM_Data, ( "HfromA (recv) dump:" ) );
        DUMPB( TL_I, TM_Data, pOutBuf, *pulOutBufLen );
        usCalcFcs = CalculatePppFcs( pOutBuf, *pulOutBufLen );
        if (usFcs != usCalcFcs)
        {
            TRACE( TL_A, TM_Mp, (
                "HfA: FCS mismatch, R=$%04x C=$%04x, L=%d",
                (INT )usFcs, (INT )usCalcFcs, *pulOutBufLen ) );
            return FALSE;
        }
#if 0
#ifdef TESTMODE
        else
        {
            TRACE( TL_A, TM_Mp, (
                "HfA: Good FCS, R=$%04x C=$%04x, L=%d",
                (INT )usFcs, (INT )usCalcFcs, *pulOutBufLen ) );
        }
#endif
#endif

    }

    return TRUE;
}


BOOLEAN
IsWin9xPeer(
    IN VCCB* pVc )

    // Returns true if the link level has determined that the VC's peer is a
    // Win9x box, false otherwise.
    //
{
    ULONG Platform;
    PPTI_EXTENSION pPtiExtension;

#ifdef TESTMODE
    if (g_fAssumeWin9x)
    {
        return TRUE;
    }
#endif

    pPtiExtension = (PPTI_EXTENSION )pVc->PtiExtension;

    // try to check the validity of the PtiExtension pointer
    //
    if ( pPtiExtension == NULL )
    {
        TRACE( TL_A, TM_Recv, ( "PtiRx: pPtiExtension is NULL!" ) );
        return FALSE;
    }

    Platform = (ULONG) pPtiExtension->His.VerPlat;

    TRACE( TL_V, TM_Recv, ( "IsWin9xPeer: far platform=$%x", Platform ) );

    if (Platform == PLAT_WIN9X)
    {
        // Win9x -- we reformat the asynch framing used by Win9x DCC
        // and also play the CLIENT->CLIENTSERVER game
        //
        return TRUE;
    }

    // WinNT (or DOS maybe)
    //
    return FALSE;
}


NDIS_STATUS
QueryInformation(
    IN ADAPTERCB* pAdapter,
    IN VCCB* pVc,
    IN NDIS_OID Oid,
    IN PVOID InformationBuffer,
    IN ULONG InformationBufferLength,
    OUT PULONG BytesWritten,
    OUT PULONG BytesNeeded )

    // Handle QueryInformation requests.  Arguments are as for the standard
    // NDIS 'MiniportQueryInformation' handler except this routine does not
    // count on being serialized with respect to other requests.
    //
{
    NDIS_STATUS status;
    ULONG ulInfo;
    VOID* pInfo;
    ULONG ulInfoLen;

    status = NDIS_STATUS_SUCCESS;

    // The cases in this switch statement find or create a buffer containing
    // the requested information and point 'pInfo' at it, noting it's length
    // in 'ulInfoLen'.  Since many of the OIDs return a ULONG, a 'ulInfo'
    // buffer is set up as the default.
    //
    ulInfo = 0;
    pInfo = &ulInfo;
    ulInfoLen = sizeof(ulInfo);

    switch (Oid)
    {
        case OID_GEN_MAXIMUM_LOOKAHEAD:
        {
            // Report the maximum number of bytes we can always provide as
            // lookahead data on receive indications.  We always indicate full
            // packets so this is the same as the receive block size.  And
            // since we always allocate enough for a full packet, the receive
            // block size is the same as the frame size.
            //
            TRACE( TL_N, TM_Mp, ( "QInfo(OID_GEN_MAXIMUM_LOOKAHEAD)" ) );
            ulInfo = PTI_MaxFrameSize;
            break;
        }

        case OID_GEN_MAC_OPTIONS:
        {
            // Report a bitmask defining optional properties of the driver.
            //
            // NDIS_MAC_OPTION_COPY_LOOKAHEAD_DATA promises that our receive
            // buffer is not on a device-specific card.
            //
            // NDIS_MAC_OPTION_TRANSFERS_NOT_PEND promises we won't return
            // NDIS_STATUS_PENDING from our TransferData handler which is true
            // since we don't have one.
            //
            TRACE( TL_N, TM_Mp, ( "QInfo(OID_GEN_MAC_OPTIONS)" ) );
            ulInfo = NDIS_MAC_OPTION_COPY_LOOKAHEAD_DATA
                     | NDIS_MAC_OPTION_TRANSFERS_NOT_PEND;
            break;
        }

        case OID_WAN_MEDIUM_SUBTYPE:
        {
            // Report the media subtype we support.  NDISWAN may use this in
            // the future (doesn't now) to provide framing differences for
            // different media.
            //
            TRACE( TL_N, TM_Mp, ( "QInfo(OID_WAN_MEDIUM_SUBTYPE)" ) );
            ulInfo = NdisWanMediumParallel;
            break;
        }

        case OID_WAN_CO_GET_INFO:
        {
            // Report the capabilities of the adapter.
            //
            TRACE( TL_N, TM_Mp, ( "QInfo(OID_WAN_CO_GET_INFO)" ) );
            pInfo = &pAdapter->info;
            ulInfoLen = sizeof(NDIS_WAN_CO_INFO);
            break;
        }

        case OID_WAN_CO_GET_LINK_INFO:
        {
            // Report the current state of the link.
            //
            TRACE( TL_N, TM_Mp, ( "QInfo(OID_WAN_CO_GET_LINK_INFO)" ) );

            if (!pVc)
                return NDIS_STATUS_INVALID_DATA;
            pInfo = &pVc->linkinfo;
            ulInfoLen = sizeof(NDIS_WAN_CO_GET_LINK_INFO);
            break;
        }

        case OID_WAN_CO_GET_COMP_INFO:
        {
            // Report the type of compression we provide, which is none.
            //
            TRACE( TL_N, TM_Mp, ( "QInfo(OID_WAN_CO_GET_COMP_INFO)" ) );
            status = NDIS_STATUS_NOT_SUPPORTED;
            ulInfoLen = 0;
            break;
        }

        case OID_WAN_CO_GET_STATS_INFO:
        {
            // Because DirectParallel doesn't do compression, NDISWAN will use
            // it's own statistics and not query ours.
            //
            ASSERT( !"OID_WAN_CO_GET_STATS_INFO?" );
            status = NDIS_STATUS_NOT_SUPPORTED;
            ulInfoLen = 0;
            break;
        }

        case OID_GEN_SUPPORTED_LIST:
        {
            static ULONG aulSupportedOids[] = {
                OID_GEN_SUPPORTED_LIST,
                OID_GEN_MAXIMUM_LOOKAHEAD,
                OID_GEN_MAC_OPTIONS,
                OID_WAN_MEDIUM_SUBTYPE,
                OID_WAN_CO_GET_INFO,
                OID_WAN_CO_GET_LINK_INFO,
                OID_WAN_CO_SET_LINK_INFO,
                OID_CO_TAPI_CM_CAPS,
                OID_CO_TAPI_LINE_CAPS,
                OID_CO_TAPI_ADDRESS_CAPS,
                OID_CO_TAPI_GET_CALL_DIAGNOSTICS
            };

            TRACE( TL_N, TM_Mp, ( "QInfo(OID_GEN_SUPPORTED_LIST)" ) );
            pInfo = aulSupportedOids;
            ulInfoLen = sizeof(aulSupportedOids);
            break;
        }

        case OID_PNP_CAPABILITIES:
        {
            pInfo = &PnpCaps;
            ulInfoLen = sizeof(PnpCaps);
            break;
        }

        case OID_PNP_SET_POWER:
            break;
        case OID_PNP_QUERY_POWER:
            break;
        case OID_PNP_ENABLE_WAKE_UP:
            break;

#if 0
        // These OIDs are mandatory according to current doc, but since
        // NDISWAN never requests them they are omitted.
        //
        case OID_GEN_HARDWARE_STATUS:
        case OID_GEN_MEDIA_SUPPORTED:
        case OID_GEN_MEDIA_IN_USE:
        case OID_GEN_MEDIA_IN_USE:
        case OID_GEN_MAXIMUM_FRAME_SIZE:
        case OID_GEN_LINK_SPEED:
        case OID_GEN_TRANSMIT_BUFFER_SPACE:
        case OID_GEN_RECEIVE_BUFFER_SPACE:
        case OID_GEN_TRANSMIT_BLOCK_SIZE:
        case OID_GEN_RECEIVE_BLOCK_SIZE:
        case OID_GEN_VENDOR_ID:
        case OID_GEN_VENDOR_DESCRIPTION:
        case OID_GEN_VENDOR_DRIVER_VERSION:
        case OID_GEN_CURRENT_PACKET_FILTER:
        case OID_GEN_CURRENT_LOOKAHEAD:
        case OID_GEN_DRIVER_VERSION:
        case OID_GEN_MAXIMUM_TOTAL_SIZE:
        case OID_GEN_MAC_OPTIONS:
        case OID_GEN_MEDIA_CONNECT_STATUS:
        case OID_GEN_MAXIMUM_SEND_PACKETS:
        case OID_WAN_PERMANENT_ADDRESS:
        case OID_WAN_CURRENT_ADDRESS:
        case OID_WAN_QUALITY_OF_SERVICE:
        case OID_WAN_LINE_COUNT:
#endif
        default:
        {
            TRACE( TL_A, TM_Mp, ( "QueryInfo: Oid=$%08x?", Oid ) );
            status = NDIS_STATUS_NOT_SUPPORTED;         // JAY per SLC
            ulInfoLen = 0;
            break;
        }
    }

    if (ulInfoLen > InformationBufferLength)
    {
        // Caller's buffer is too small.  Tell him what he needs.
        //
        *BytesNeeded = ulInfoLen;
        status = NDIS_STATUS_INVALID_LENGTH;
    }
    else
    {
        // Copy the found result to caller's buffer.
        //
        if (ulInfoLen > 0)
        {
            NdisMoveMemory( InformationBuffer, pInfo, ulInfoLen );
            DUMPDW( TL_N, TM_Mp, pInfo, ulInfoLen );
        }

        *BytesNeeded = *BytesWritten = ulInfoLen;
    }

    return status;
}


VOID
ReferenceAdapter(
    IN ADAPTERCB* pAdapter )

    // Adds areference to the adapter block, 'pAdapter'.
    //
{
    LONG lRef;

    lRef = NdisInterlockedIncrement( &pAdapter->lRef );

    TRACE( TL_N, TM_Ref, ( "RefA to %d", lRef ) );
}


VOID
ReferenceVc(
    IN VCCB* pVc )

    // Adds a reference to the VC control block 'pVc'.
    //
{
    LONG lRef;

    lRef = NdisInterlockedIncrement( &pVc->lRef );

    TRACE( TL_N, TM_Ref, ( "RefVc to %d", lRef ) );
}


VOID
SendClientString(
    IN PVOID pPtiExtension )

    // Send "CLIENT" so Win9x, which views us as a NULL modem, is happy.
    //
{
    KIRQL oldIrql;

    KeRaiseIrql(DISPATCH_LEVEL, &oldIrql);
    PtiWrite( pPtiExtension, g_szClient, CLIENTLEN, PID_STANDARD );
    KeLowerIrql(oldIrql);
}


NDIS_STATUS
SetInformation(
    IN ADAPTERCB* pAdapter,
    IN VCCB* pVc,
    IN NDIS_OID Oid,
    IN PVOID InformationBuffer,
    IN ULONG InformationBufferLength,
    OUT PULONG BytesRead,
    OUT PULONG BytesNeeded )

    // Handle SetInformation requests.  Arguments are as for the standard NDIS
    // 'MiniportQueryInformation' handler except this routine does not count
    // on being serialized with respect to other requests.
    //
{
    NDIS_STATUS status;

    status = NDIS_STATUS_SUCCESS;

    switch (Oid)
    {
        case OID_WAN_CO_SET_LINK_INFO:
        {
            // Read new link state settings.
            //
            TRACE( TL_N, TM_Mp, ( "SInfo(OID_WAN_CO_SET_LINK_INFO)" ) );
            if (InformationBufferLength < sizeof(NDIS_WAN_CO_SET_LINK_INFO))
            {
                status = NDIS_STATUS_INVALID_LENGTH;
                *BytesRead = 0;
            }
            else
            {
                if (!pVc)
                {
                    return NDIS_STATUS_INVALID_DATA;
                }

                ASSERT( sizeof(pVc->linkinfo)
                    == sizeof(NDIS_WAN_CO_SET_LINK_INFO) );

                NdisMoveMemory( &pVc->linkinfo, InformationBuffer,
                    sizeof(pVc->linkinfo) );
                DUMPB( TL_N, TM_Mp, &pVc->linkinfo, sizeof(pVc->linkinfo) );

                *BytesRead = sizeof(NDIS_WAN_CO_SET_LINK_INFO);
            }

            *BytesNeeded = sizeof(NDIS_WAN_CO_SET_LINK_INFO);
        }
        break;

        case OID_WAN_CO_SET_COMP_INFO:
        {
            // DirectParallel doesn't provide compression.
            //
            TRACE( TL_N, TM_Mp, ( "SInfo(OID_WAN_CO_SET_COMP_INFO)" ) );
            status = NDIS_STATUS_NOT_SUPPORTED;
            *BytesRead = *BytesNeeded = 0;
            break;
        }

#if 0
        // These OIDs are mandatory according to current doc, but since
        // NDISWAN never requests them they are omitted.
        //
        case OID_GEN_CURRENT_PACKET_FILTER:
        case OID_GEN_CURRENT_LOOKAHEAD:
        case OID_GEN_PROTOCOL_OPTIONS:
        case OID_WAN_PROTOCOL_TYPE:
        case OID_WAN_HEADER_FORMAT:
#endif
        default:
        {
            TRACE( TL_A, TM_Mp, ( "SetInfo: Oid=$%08x?", Oid ) );
            status = NDIS_STATUS_NOT_SUPPORTED;                 // JAY per SLC
            *BytesRead = *BytesNeeded = 0;
            break;
        }
    }

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ndis\raspti\ppool.h ===
// Copyright (c) 1997, Microsoft Corporation, all rights reserved
//
// ppool.h
// RAS L2TP WAN mini-port/call-manager driver
// Packet pool management header
//
// 01/07/97 Steve Cobb, adapted from Gurdeep's WANARP code.


#ifndef _PPOOL_H_
#define _PPOOL_H_


//-----------------------------------------------------------------------------
// Data structures
//-----------------------------------------------------------------------------

// Packet pool control block.  A packet pool encapsulates an NDIS packet pool
// handling all pool growth and shrinkage internally.
//
typedef struct
_PACKETPOOL
{
    // Size in bytes of the ProtocolReserved array for each packet in the
    // pool.
    //
    ULONG ulProtocolReservedLength;

    // The optimal number of packets to allocate in each packet block.
    //
    ULONG ulPacketsPerBlock;

    // Maximum number of individual packets that may be allocated in the
    // entire pool, or 0 for unlimited.
    //
    ULONG ulMaxPackets;

    // Current number of individual packets allocated in the entire pool.
    //
    ULONG ulCurPackets;

    // Garbage collection occurs after this many calls to FreePacketToPool.
    //
    ULONG ulFreesPerCollection;

    // Number of calls to FreeBufferToPool since a garbage collection.
    //
    ULONG ulFreesSinceCollection;

    // Memory identification tag for allocated blocks.
    //
    ULONG ulTag;

    // Head of the double linked list of PACKETBLOCKHEADs.  Access to the list
    // is protected with 'lock' in this structure.
    //
    LIST_ENTRY listBlocks;

    // Head of the double linked list of free PACKETHEADs.  Each PACKETHEAD in
    // the list is ready to go, i.e. it already has an NDIS_PACKET associated
    // with it.  Access to the list is prototected by 'lock' in this
    // structure.  Interlocked push/pop is not used because (a) the list of
    // blocks and this list must lock each other and (b) double links are
    // necessary for garbage collection.
    //
    LIST_ENTRY listFreePackets;

    // This lock protects this structure and both the list of blocks and the
    // list of packets.
    //
    NDIS_SPIN_LOCK lock;
}
PACKETPOOL;


// Header of a single block of packets from a packet pool.  The PACKETHEAD of
// the first buffer immediately follows.
//
typedef struct
_PACKETBLOCKHEAD
{
    // Links to the prev/next packet block header in the packet pool's list.
    //
    LIST_ENTRY linkBlocks;

    // NDIS's handle of the pool of NDIS_PACKET descriptors associated with
    // this block, or NULL if none.
    //
    NDIS_HANDLE hNdisPool;

    // B