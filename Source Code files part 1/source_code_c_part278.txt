e.Type.Terminal:
                        context.HasNodeMatched = (((InternalNode)cnode.ParentNode).LeftNode == cnode) ? 1 : 2;
                        context.CurrentNode = cnode.ParentNode;
                        context.HasMatched = (cnode.ParentNode == endNode);
                        if (cnode.NodeType == ContentNode.Type.Any) {
                            processContents = ((AnyNode)cnode).ProcessContents;
                        }
                        return;

                    case ContentNode.Type.Sequence:
                        inNode = (InternalNode)cnode;
                        if (NodeMatched == 0) {
                            if (inNode.LeftNode.Accepts(qname)) {
                                cnode = inNode.LeftNode;
                                break;
                            }
                            else if (inNode.LeftNode.Nullable()) {
                                NodeMatched = 1;
                            }
                            else {
                                goto error;
                            }
                        }

                        if (NodeMatched == 1) {
                            if (inNode.RightNode.Accepts(qname)) {
                                NodeMatched = 0;
                                cnode = inNode.RightNode;
                                break;
                            }
                            else if (inNode.RightNode.Nullable()) {
                                NodeMatched = 2;
                            }
                            else {
                                goto error;
                            }
                        }

                        if (NodeMatched == 2) {
                            if (cnode.ParentNode != null) {
                                if (((InternalNode)cnode.ParentNode).LeftNode == cnode)
                                    NodeMatched = 1;
                                cnode = cnode.ParentNode;
                                break;
                            }
                            else {
                                goto error;
                            }
                        }
                        break;

                    case ContentNode.Type.Choice:
                        inNode = (InternalNode)cnode;
                        if (NodeMatched != 0) {
                            NodeMatched = (((InternalNode)cnode.ParentNode).LeftNode == cnode) ? 1 : 2;
                            cnode = cnode.ParentNode;
                        }
                        else if (inNode.LeftNode.Accepts(qname)) {
                            NodeMatched = 0;
                            cnode = inNode.LeftNode;
                        }
                        else if (inNode.RightNode.Accepts(qname)) {
                            NodeMatched = 0;
                            cnode = inNode.RightNode;
                        }
                        else {
                            goto error;
                        }
                        break;

                    case ContentNode.Type.Qmark:
                        inNode = (InternalNode)cnode;
                        if (NodeMatched != 0) {
                            NodeMatched = (((InternalNode)cnode.ParentNode).LeftNode == cnode) ? 1 : 2;
                            cnode = cnode.ParentNode;
                        }
                        else if (inNode.LeftNode.Accepts(qname)) {
                            cnode = inNode.LeftNode;
                        }
                        else {
                            goto error;
                        }
                        break;

                    case ContentNode.Type.Star:
                    case ContentNode.Type.Plus:
                        inNode = (InternalNode)cnode;
                        if (inNode.LeftNode.Accepts(qname)) {
                            NodeMatched = 0;
                            cnode = inNode.LeftNode;
                        }
                        else {
                            NodeMatched = (((InternalNode)cnode.ParentNode).LeftNode == cnode) ? 1 : 2;
                            cnode = cnode.ParentNode;
                        }
                        break;

                    case ContentNode.Type.MinMax:
                        inNode = (InternalNode)cnode;
                        ln = (MinMaxNode)cnode;
                        mm = null;
                        if (context.MinMaxValues != null)
                            mm = (MinMaxValues)context.MinMaxValues[ln];
                        else
                            context.MinMaxValues = new Hashtable();
                        if (mm == null) {
                            // new minmaxnode and add it to minmaxnodes hashtable
                            mm = new MinMaxValues(ln.Min, ln.Max);
                            context.MinMaxValues.Add(ln, mm);
                        }

                        if (mm.Max == 0) {
                            NodeMatched = (((InternalNode)cnode.ParentNode).LeftNode == cnode) ? 1 : 2;
                            cnode = cnode.ParentNode;
                            mm.Max = ln.Max;
                            mm.Min = ln.Min;
                        }
                        else if (inNode.LeftNode.Accepts(qname)) {
                            mm.Max -= 1;
                            mm.Min -= 1;
                            NodeMatched = 0;
                            cnode = inNode.LeftNode;
                        }
                        else {
                            if (mm.Min > 0)
                                goto error;
                            NodeMatched = (((InternalNode)cnode.ParentNode).LeftNode == cnode) ? 1 : 2;
                            cnode = cnode.ParentNode;
                            mm.Max = ln.Max;
                            mm.Min = ln.Min;
                        }
                        break;
                } // switch
            } // while (true)

            error:
            context.NeedValidateChildren = false;
            ArrayList v = ExpectedXsdElements(context.CurrentNode, NodeMatched);
            if (v == null) {
                throw new XmlSchemaException(Res.Sch_InvalidContent, context.Name.ToString());
            }
            else {
                throw new XmlSchemaException(Res.Sch_InvalidContentExpecting,  new string[] { context.Name.ToString(), v.ToString() });
            }
        }

        /*private bool Accepts(ContentNode node, XmlQualifiedName qname, int positions, Object index) {
            if (index != null) {
                BitSet first = node.Firstpos(positions);
                for (int i = 0; i < first.Count; i++) {
                    if (first.Get(i) && qname.Equals(((TerminalNode)terminalNodes[i]).Name))
                        return true;
                }
                return false;
            }
            else {
                return node.Accepts(qname);
            }
        }*/

        private void CheckXsdDeterministic(ValidationEventHandler eventHandler) {
            ContentNode cnode = ((InternalNode)contentNode).LeftNode;
            BitSet set = null;
            NamespaceList any = null;
            //
            //note: only need to callback once per non-deterministic content model so we use try catch here
            //
            try {
                cnode.CheckXsdDeterministic(terminalNodes, out set, out any);
            }
            catch (XmlSchemaException e) {
                if (eventHandler != null) {
                    eventHandler(this, new ValidationEventArgs(new XmlSchemaException(Res.Sch_NonDeterministicAny)));
                }
                else {
                    throw e;
                }
            }
        }

        /*
         *  returns names of all legal elements following the specified state
         */
         internal ArrayList ExpectedElements(int state, BitSet allElementsSet) {
            ArrayList names = new ArrayList();

            if (IsAllElements) {
                for (int i = 0; i < allElementsSet.Count; i++) {
                    if (!allElementsSet.Get(i)) {
                        names.Add(symbols[i]);
                    }
                }
            }
            else {
                if (IsCompiled) {
                    int[] t = null;
                    if (dtrans != null)
                        t = (int[])dtrans[state];
                    if (t!=null) {
                        for (int i = 0; i < terminalNodes.Count; i++) {
                            XmlQualifiedName n = ((TerminalNode)terminalNodes[i]).Name;
                            if (!n.IsEmpty) {
                                string name = n.ToString();
                                if (!names.Contains(name)) {
                                    Object lookup = symbolTable[n];
                                    if ((lookup != null) && (t[(int)lookup] != -1)) {
                                        names.Add(name);
                                    }
                                }
                            }
                        }
                    }
                }
                else {
                    //need to deal with not compiled content model
                }
            }
            return names;
        }

        /*
         *  returns names of all legal elements following the specified state
         */
        private ArrayList ExpectedXsdElements(ContentNode cnode, int NodeMatched) {
            return null;
        }

        private TerminalNode NewTerminalNode(XmlQualifiedName qname) {
            TerminalNode t = new TerminalNode(qname);
            t.Pos = terminalNodes.Count;
            terminalNodes.Add(t);
            if (!qname.IsEmpty && symbolTable[qname] == null) {
                symbolTable.Add(qname, symbols.Count);
                symbols.Add(qname);
            }
            return t;
        }

    };

    internal sealed class MinMaxValues {
        internal int min;
        internal int max;

        internal MinMaxValues(int min, int max) {
            this.min = min;
            this.max = max;
        }

        internal int Min {
            get { return min;}
            set { min = value;}
        }

        internal int Max {
            get { return max;}
            set { max = value;}
        }
    };

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\schema\namespacelist.cs ===
//------------------------------------------------------------------------------
// <copyright file="NamespaceList.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------


namespace System.Xml.Schema {
    using System.Collections;
    using System.Text;
    using System.Diagnostics;

    internal class NamespaceList {
        public enum ListType {
            Any,
            Other,
            Set
        };

        private ListType type = ListType.Any;
        private Hashtable set = null;
        private string targetNamespace;

        public NamespaceList() {
        }

        static readonly char[] whitespace = new char[] {' ', '\t', '\n', '\r'};
        public NamespaceList(string namespaces, string targetNamespace) {
            Debug.Assert(targetNamespace != null);
            this.targetNamespace = targetNamespace;
            namespaces = namespaces.Trim();
            if (namespaces == "##any") {
                type = ListType.Any;
            }
            else if (namespaces == "##other") {
                type = ListType.Other;
            }
            else {
                type = ListType.Set;
                set = new Hashtable();
                foreach(string ns in namespaces.Split(whitespace)) {
                    if (ns == string.Empty) {
                        continue;
                    }
                    if (ns == "##local") {
                        set[string.Empty] = string.Empty;
                    } 
                    else if (ns == "##targetNamespace") {
                        set[targetNamespace] = targetNamespace;
                    }
                    else {
                        XmlConvert.ToUri(ns); // can throw
                        set[ns] = ns;
                    }
                }
            }
        }

        private NamespaceList Clone() {
            NamespaceList nsl = (NamespaceList)MemberwiseClone();
            if (type == ListType.Set) {
                Debug.Assert(set != null);
                nsl.set = (Hashtable)(set.Clone());
            }
            return nsl;
        }

        public bool Allows(XmlQualifiedName qname) {
            return Allows(qname.Namespace);
        }

        public bool Allows(string ns) {
            switch (type) {
                case ListType.Any: 
                    return true;
                case ListType.Other:
                    return ns != targetNamespace;
                case ListType.Set:
                    return set[ns] != null;
            }
            Debug.Assert(false);
            return false;
        } 

        public override string ToString() {
            switch (type) {
                case ListType.Any: 
                    return "##any";
                case ListType.Other:
                    return "##other";
                case ListType.Set:
                    StringBuilder sb = new StringBuilder();
                    bool first = true;
                    foreach(string s in set.Keys) {
                        if (first) {
                            first = false;
                        }
                        else {
                            sb.Append(" ");
                        }
                        if (s == targetNamespace) {
                            sb.Append("##targetNamespace");
                        }
                        else if (s == string.Empty) {
                            sb.Append("##local");
                        }
                        else {
                            sb.Append(s);
                        }
                    }
                    return sb.ToString();
            }
            Debug.Assert(false);
            return string.Empty;
        }

        public static bool IsSubset(NamespaceList sub, NamespaceList super) {
            if (super.type == ListType.Any) {
                return true;
            }
            else if (sub.type == ListType.Other && super.type == ListType.Other) {
                return super.targetNamespace == sub.targetNamespace;
            }
            else  if (sub.type == ListType.Set) {
                if (super.type == ListType.Other) {
                    return !sub.set.Contains(super.targetNamespace);
                }
                else {
                    Debug.Assert(super.type == ListType.Set);
                    foreach (string ns in sub.set.Keys) {
                        if (!super.set.Contains(ns)) {
                            return false;
                        }
                    }
                    return true;
                }           
            }
            return false;
        }

        public static NamespaceList Union(NamespaceList o1, NamespaceList o2) {
            NamespaceList nslist = null;
            if (o1.type == ListType.Any) {
                nslist = new NamespaceList();
            }
            else if (o2.type == ListType.Any) {
                nslist = new NamespaceList();
            }
            else if (o1.type == ListType.Other && o2.type == ListType.Other) {
                if (o1.targetNamespace == o2.targetNamespace) {
                    nslist = o1.Clone();
                }
            }
            else if (o1.type == ListType.Set && o2.type == ListType.Set) {
                nslist = o1.Clone();
                foreach (string ns in o2.set.Keys) {
                    nslist.set[ns] = ns;
                }
            }
            else if (o1.type == ListType.Set && o2.type == ListType.Other) {
                if (o1.set.Contains(o2.targetNamespace)) {
                    nslist = new NamespaceList();
                }
            }
            else if (o2.type == ListType.Set && o1.type == ListType.Other) {
                if (o2.set.Contains(o2.targetNamespace)) {
                    nslist = new NamespaceList();
                }
                else {
                    nslist = o1.Clone();
                }
            }
            return nslist;
        }

        public static NamespaceList Intersection(NamespaceList o1, NamespaceList o2) { 
            NamespaceList nslist = null;
            if (o1.type == ListType.Any) {
                nslist = o2.Clone();
            }
            else if (o2.type == ListType.Any) {
                nslist = o1.Clone();
            }
            else if (o1.type == ListType.Other && o2.type == ListType.Other) {
                if (o1.targetNamespace == o2.targetNamespace) {
                    nslist = o1.Clone();
                }
            }
            else if (o1.type == ListType.Set && o2.type == ListType.Set) {
                nslist =  o1.Clone();
                nslist = new NamespaceList();
                nslist.type = ListType.Set;
                nslist.set = new Hashtable();
                foreach(string ns in o1.set.Keys) {
                    if (o2.set.Contains(ns)) {
                        nslist.set.Add(ns, ns);
                    }
                }
            }
            else if (o1.type == ListType.Set && o2.type == ListType.Other) {
                nslist = o1.Clone();
                if (nslist.set[o2.targetNamespace] != null) {
                    nslist.set.Remove(o2.targetNamespace);
                }
            }
            else if (o2.type == ListType.Set && o1.type == ListType.Other) {
                nslist = o2.Clone();
                if (nslist.set[o1.targetNamespace] != null) {
                    nslist.set.Remove(o1.targetNamespace);
                }
            }
            return nslist;
        }

        public bool IsEmpty() {
            return ((type == ListType.Set) && ((set == null) || set.Count == 0));
        }

    };
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\schema\contentnode.cs ===
//------------------------------------------------------------------------------
// <copyright file="ContentNode.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Schema {

    using System.Diagnostics;
    using System.Collections;
    using System.Text;

    internal abstract class ContentNode {

        internal enum Type {
            Terminal,
            Sequence,
            Choice,
            Qmark,
            Star,
            Plus,
            MinMax,
            Any,
        };

        protected Type          contentType;    // Node type
        protected BitSet        first;   // firstpos    
        protected BitSet        last;    // lastpos
        protected ContentNode   parent;  // parent node

        internal abstract bool Nullable();
        internal abstract BitSet Firstpos(int positions);
        internal abstract BitSet Lastpos(int positions);
        internal virtual void CalcFollowpos(BitSet[] followpos) {
        }

        internal Type NodeType {
            get { return contentType;}
            set { contentType = value;}
        }

        [System.Diagnostics.Conditional("DEBUG")]          
        internal abstract void Dump(StringBuilder bb);

        internal ContentNode ParentNode {
            get { return parent;}
            set { parent = value;}
        }

        internal abstract bool Accepts(XmlQualifiedName qname);

        internal abstract void CheckXsdDeterministic(ArrayList terminalNodes, out BitSet set, out NamespaceList any);

        internal virtual bool CanSkip() {
            return Nullable();
        }
    };


    internal sealed class TerminalNode : ContentNode {
        private int    pos;     // numbering the node   
        private XmlQualifiedName  name;    // name it refers to

        internal int Pos {
            get { return pos;}
            set { pos = value;}
        }

        internal XmlQualifiedName Name {
            get { return name;}
            set { name = value;}
        }

        internal TerminalNode(XmlQualifiedName qname) {
            name = qname;
            contentType = Type.Terminal;
        }

        internal override bool Nullable() {
            if (name.IsEmpty)
                return true;
            else
                return false;
        }

        internal override bool Accepts(XmlQualifiedName qname) {
            return qname.Equals(name);
        }

        internal override void CheckXsdDeterministic(ArrayList terminalNodes, out BitSet set, out NamespaceList any) {
            set = Firstpos(terminalNodes.Count);
            any = null;
        }

        internal override BitSet Firstpos(int positions) {
            if (first == null) {
                first = new BitSet(positions);
                first.Set(pos);
            }

            return first;
        }

        internal override BitSet Lastpos(int positions) {
            if (last == null) {
                last = new BitSet(positions);
                last.Set(pos);
            }

            return last;
        }

        internal override void Dump(StringBuilder bb) {
            bb.Append("[" + Name + "]");
        }

    };


    internal class InternalNode : ContentNode {
        protected ContentNode left;    // left node  
        protected ContentNode right;   // right node
                                        // if node type is QMark, Closure, or Type.Plus, right node is NULL

        internal InternalNode(ContentNode l, ContentNode r, ContentNode.Type t) {
            left = l;
            right = r;
            contentType = t;
        }

        internal ContentNode LeftNode {
            get { return left;}
            set { left = value;}
        }

        internal ContentNode RightNode {
            get { return right;}
            set { right = value;}
        }

        internal override bool Nullable() {
            switch (contentType) {
                case Type.Sequence:    
                    return left.Nullable() && right.Nullable();
                case Type.Choice:      
                    return left.Nullable() || right.Nullable();
                case Type.Plus:        
                    return left.Nullable();
                default:          
                    return true;  // Type.Qmark, or Type.Star                              
            }
        }

        internal override bool Accepts(XmlQualifiedName qname) {
            switch (contentType) {
                case Type.Sequence:    
                    return left.Accepts(qname) || (left.Nullable() && right.Accepts(qname) );
                case Type.Choice:      
                    return left.Accepts(qname) || right.Accepts(qname);     
                default:          
                    return left.Accepts(qname);                           
            }
        }

        internal override void CheckXsdDeterministic(ArrayList terminalNodes, out BitSet set, out NamespaceList any) {
            BitSet lset = null, rset = null; 
            NamespaceList lany = null, rany = null;
                        
            switch (contentType) {
                case Type.Sequence:    
                    left.CheckXsdDeterministic(terminalNodes, out lset, out lany);
                    right.CheckXsdDeterministic(terminalNodes, out rset, out rany);
                    if (left.CanSkip()) {
                        Join(terminalNodes, lset, lany, rset, rany, out set, out any);                            
                    }
                    else {
                        set = lset;
                        any = lany;
                    }
                    break;
                case Type.Choice:      
                    left.CheckXsdDeterministic(terminalNodes, out lset, out lany);
                    right.CheckXsdDeterministic(terminalNodes, out rset, out rany);
                    Join(terminalNodes, lset, lany, rset, rany, out set, out any);                   
                    break;
                default:          
                    left.CheckXsdDeterministic(terminalNodes, out set, out any);                            
                    break; 
            }
            return;
       }

        private void Join(ArrayList terminalNodes, BitSet lset, NamespaceList lany, BitSet rset, NamespaceList rany, out BitSet set, out NamespaceList any) {
            if (lset != null) {
                if (rset != null) {
                    set = lset.Clone();
                    set.And(rset);
                    if (!set.IsEmpty) {
                        goto error;
                    }
                    set.Or(lset);
                    set.Or(rset);
                }
                else {
                    set = lset;
                }
            }
            else {
                set = rset;                
            }

            if (lany != null) {
                if (rany != null) {
                    NamespaceList list = NamespaceList.Intersection(rany, lany);
                    if (list == null ||  list.IsEmpty()) { 
                        any = NamespaceList.Union(rany, lany);
                    }                
                    else {
                        goto error;
                    }
                }
                else {
                    any = lany;
                }                        
            }
            else {
               any = rany;     
            } 

            if (any != null && set != null) {
                for (int i = 0; i < set.Count; i++) {
                    if (set.Get(i) && any.Allows(((TerminalNode)terminalNodes[i]).Name)) {
                        goto error;
                    }
                }
            }
            return;

            error:
                throw new XmlSchemaException(Res.Sch_NonDeterministicAny);
        }

        internal override BitSet Firstpos(int positions) {
            if (first == null) {
                if ((contentType == Type.Sequence && left.Nullable()) || contentType == Type.Choice) {
                    first = (BitSet)left.Firstpos(positions).Clone();
                    first.Or(right.Firstpos(positions));
                }
                else {
                    first = left.Firstpos(positions);      
                }
            }

            return first;
        }

        internal override BitSet Lastpos(int positions) {
            if (last == null) {
                if (contentType == Type.Sequence && !right.Nullable()) {
                    last = right.Lastpos(positions);
                }
                else if (contentType == Type.Choice || contentType == Type.Sequence) {
                    last = (BitSet)left.Lastpos(positions).Clone();
                    last.Or(right.Lastpos(positions));
                }
                else { // Type.Qmark, Type.Star, or Type.Plus
                    last = left.Lastpos(positions);
                }
            }

            return last;
        }

        internal override void CalcFollowpos(BitSet[] followpos) {
            int i, l;
            BitSet lp, fp;

            switch (contentType) {
                case Type.Sequence:
                    left.CalcFollowpos(followpos);
                    right.CalcFollowpos(followpos);

                    l = followpos.Length;        
                    lp = left.Lastpos(l);
                    fp = right.Firstpos(l);        
                    for (i = followpos.Length - 1; i >= 0; i--) {
                        if (lp.Get(i)) {
                            followpos[i].Or(fp);
                        }
                    }
                    break;
                case Type.Choice:
                    left.CalcFollowpos(followpos);
                    right.CalcFollowpos(followpos);
                    break;
                case Type.Qmark:
                    left.CalcFollowpos(followpos);
                    break;
                case Type.Star:
                case Type.Plus:
                    left.CalcFollowpos(followpos);

                    l = followpos.Length;        
                    Lastpos(l);
                    Firstpos(l);        

                    for (i = followpos.Length - 1; i >= 0; i--) {
                        if (last.Get(i)) {
                            followpos[i].Or(first);
                        }
                    }
                    break;
                default:
                    throw new XmlException(Res.Xml_InternalError, string.Empty);
            }
        }

        internal override void Dump(StringBuilder bb) {
            switch (contentType) {
                case Type.Sequence:
                    bb.Append("(");
                    left.Dump(bb);
                    bb.Append(", ");
                    right.Dump(bb);
                    bb.Append(")");
                    break;
                case Type.Choice:
                    bb.Append("(");
                    left.Dump(bb);
                    bb.Append(" | ");
                    right.Dump(bb);
                    bb.Append(")");
                    break;
                case Type.Qmark:
                    left.Dump(bb);
                    bb.Append("? ");
                    break;
                case Type.Star:
                    left.Dump(bb);
                    bb.Append("* ");
                    break;
                case Type.Plus:
                    left.Dump(bb);
                    bb.Append("+ ");
                    break;
                default:
                    throw new XmlException(Res.Xml_InternalError, string.Empty);
            }
        }
    };


    internal sealed class MinMaxNode : InternalNode {
        internal int min;
        internal int max;

        internal MinMaxNode(ContentNode l, decimal min, decimal max) : base(l, null, Type.MinMax) {
            if (min > int.MaxValue) {
                this.min = int.MaxValue;
            }
            else {
                this.min = (int)min;
            }
            if (max > int.MaxValue) {
                this.max = int.MaxValue;
            }
            else {
                this.max = (int)max;
            }
        }

        internal override bool Nullable() {
            if (min == 0) {
                return true;
            }
            else {
                return left.Nullable();
            }
        }

        internal override bool CanSkip() {
            return Nullable() || (min < max);
        }

        internal int Max {
            get { return max;}
        }

        internal int Min {
            get { return min;}
        }

        internal override void Dump(StringBuilder bb) {
            left.Dump(bb);
            bb.Append("{" + Convert.ToString(min) +", " + Convert.ToString(max) + "}");
        }
    };


    internal sealed class AnyNode : ContentNode {
        XmlSchemaAny any;

        internal AnyNode(XmlSchemaAny any) {
            this.any = any;
            contentType = Type.Any;
        }

        internal override bool Nullable() {
            return false;
        }

        internal override BitSet Firstpos(int positions) {
            if (first == null) {
                first = new BitSet(positions);
            }
            return first;
        }

        internal override BitSet Lastpos(int positions) {
            if (last == null) {
                last = new BitSet(positions);
            }
            return last;
        }

        internal override bool Accepts(XmlQualifiedName qname) {
            return any.NamespaceList.Allows(qname);
        }

        internal override void CheckXsdDeterministic(ArrayList terminalNodes, out BitSet set, out NamespaceList any) {
            set = null;
            any = this.any.NamespaceList;
        }

        internal XmlSchemaContentProcessing ProcessContents {
            get { return any.ProcessContentsCorrect; }
        }

        internal override void Dump(StringBuilder bb) {
            if (any.NamespaceList != null) {
                bb.Append("[" + any.NamespaceList.ToString() + "]");
            }
            else {
                bb.Append("[any]");
            }
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\schema\parser.cs ===
//------------------------------------------------------------------------------
// <copyright file="Parser.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Schema {

    using System;
    using System.Collections;
    using System.Text;
    using System.IO;
    using System.Diagnostics;
    using System.ComponentModel;

    internal sealed class Parser {
        private XmlSchemaCollection SchemaCollection;
        private XmlNameTable nameTable;
        private SchemaNames schemaNames; 
        private ValidationEventHandler validationEventHandler;
        private XmlNamespaceManager namespaceManager;
        private XmlReader reader;
        PositionInfo positionInfo;
        private bool isProcessNamespaces;
        private int schemaXmlDepth = 0;
        private int markupDepth;
        private StringWriter stringWriter;
        private XmlTextWriter writer;

        private SchemaBuilder builder;
        private XmlSchema schema;
        XmlResolver xmlResolver = null; //to be used only by XDRBuilder


        internal Parser(XmlSchemaCollection schemaCollection, XmlNameTable nameTable, SchemaNames schemaNames, ValidationEventHandler eventhandler) {
            this.SchemaCollection = schemaCollection;
            this.nameTable = nameTable;
            this.schemaNames = schemaNames;
            this.validationEventHandler += eventhandler;
            this.xmlResolver = new XmlUrlResolver();
        }

		internal XmlSchema Parse(XmlReader reader, string targetNamespace, SchemaInfo schemaInfo) {
	        StartParsing(reader, targetNamespace, schemaInfo);
            while(ParseReaderNode() && this.reader.Read()) {}
            return FinishParsing();
		}

        internal XmlResolver XmlResolver {
            set {
                xmlResolver = value;
            }
        }

        internal void StartParsing(XmlReader reader, string targetNamespace, SchemaInfo schemaInfo) {
            this.reader = reader;
            positionInfo = PositionInfo.GetPositionInfo(reader);
            this.namespaceManager = reader.NamespaceManager;
            if (this.namespaceManager == null) {
                this.namespaceManager = new XmlNamespaceManager(this.nameTable);
                this.isProcessNamespaces = true;
            } 
            else {
                this.isProcessNamespaces = false;
            }
            while (this.reader.NodeType != XmlNodeType.Element && this.reader.Read()) {}

            this.markupDepth = int.MaxValue;
			this.schemaXmlDepth = reader.Depth;
            XmlQualifiedName qname = new XmlQualifiedName(this.reader.LocalName, XmlSchemaDatatype.XdrCanonizeUri(this.reader.NamespaceURI, this.nameTable, this.schemaNames));
            if (this.schemaNames.IsXDRRoot(qname)) {
                Debug.Assert(schemaInfo != null);
                schemaInfo.SchemaType = SchemaType.XDR;
                this.schema = null;
                this.builder = new XdrBuilder(reader, this.namespaceManager, schemaInfo, targetNamespace, this.nameTable, this.schemaNames, this.validationEventHandler);
                ((XdrBuilder)builder).XmlResolver = xmlResolver;
            }
            else if (this.schemaNames.IsXSDRoot(qname)) {
                if (schemaInfo != null) {
                    schemaInfo.SchemaType = SchemaType.XSD;
                }
                this.schema = new XmlSchema();
                this.schema.BaseUri = reader.BaseURI;
                this.builder = new XsdBuilder(reader, this.namespaceManager, this.schema, this.nameTable, this.schemaNames, this.validationEventHandler);
            }
            else { 
                throw new XmlSchemaException(Res.Sch_SchemaRootExpected, reader.BaseURI, positionInfo.LineNumber, positionInfo.LinePosition);
            }
                
        }

        internal XmlSchema FinishParsing() {
            return schema;
        }

        internal bool ParseReaderNode() {
            if (reader.Depth > markupDepth) {
                if (writer != null) { // ProcessMarkup
                    switch (reader.NodeType) {
                    case XmlNodeType.Element: 
                        writer.WriteStartElement(reader.Prefix, reader.LocalName, reader.NamespaceURI);
                        writer.WriteAttributes(reader, false);
                        if (reader.IsEmptyElement) {
                            writer.WriteEndElement();
                        }
                        break;
                    case XmlNodeType.Text:
                        writer.WriteString(reader.Value);
                        break;
                    case XmlNodeType.SignificantWhitespace:                                 
                        writer.WriteWhitespace(reader.Value);
                        break;
                    case XmlNodeType.CDATA:
                        writer.WriteCData(reader.Value);
                        break;
                    case XmlNodeType.EntityReference:
                        writer.WriteEntityRef(reader.Name);
                        break;
                    case XmlNodeType.Comment:
                        writer.WriteComment(reader.Value);
                        break;
                    case XmlNodeType.EndElement:
                        writer.WriteFullEndElement();
                        break;
                    }
                }
                return true;
            }
            if (reader.NodeType == XmlNodeType.Element) {
                if (builder.ProcessElement(reader.Prefix, reader.LocalName, reader.NamespaceURI)) {
                    namespaceManager.PushScope();
                    if (reader.MoveToFirstAttribute()) {
                        do {
                            builder.ProcessAttribute(reader.Prefix, reader.LocalName, reader.NamespaceURI, reader.Value);
                            if (Ref.Equal(reader.NamespaceURI, schemaNames.NsXmlNs) && isProcessNamespaces) {                        
                                namespaceManager.AddNamespace(reader.Prefix == string.Empty ? string.Empty : reader.LocalName, reader.Value);
                            }
                        }
                        while (reader.MoveToNextAttribute());
                        reader.MoveToElement(); // get back to the element
                    }
                    builder.StartChildren();
                    if (reader.IsEmptyElement) {
                        namespaceManager.PopScope();
                        builder.EndChildren();
                    } 
                    else if (!builder.IsContentParsed()) {
                        markupDepth = reader.Depth;
                        stringWriter = new StringWriter();
                        writer = new XmlTextWriter(stringWriter);
                        writer.WriteStartElement(reader.LocalName);
                    }
                } 
                else if (!reader.IsEmptyElement) {
                    markupDepth = reader.Depth;
                    writer = null;
                }
            } 
            else if (reader.NodeType == XmlNodeType.Text || 
                reader.NodeType == XmlNodeType.EntityReference ||
                reader.NodeType == XmlNodeType.SignificantWhitespace ||
                reader.NodeType == XmlNodeType.CDATA) {
                builder.ProcessCData(reader.Value);
            } 
            else if (reader.NodeType == XmlNodeType.EndElement) {
                if (reader.Depth == markupDepth) {
                    if (writer != null) { // processUnparsedContent
                        writer.WriteEndElement();
                        writer.Close();
                        writer = null;
                        XmlDocument doc = new XmlDocument();
                        doc.Load(new XmlTextReader( new StringReader( stringWriter.ToString() ) ));
                        XmlNodeList list = doc.DocumentElement.ChildNodes;
                        XmlNode[] markup = new XmlNode[list.Count];
                        for (int i = 0; i < list.Count; i ++) {
                            markup[i] = list[i];
                        }
                        builder.ProcessMarkup(markup);
                        namespaceManager.PopScope();
                        builder.EndChildren();
                    }
                    markupDepth = int.MaxValue;
                } 
                else {
                    namespaceManager.PopScope();
                    builder.EndChildren();
                }
                if(reader.Depth == schemaXmlDepth) {
                    return false; // done
                }
            }
            return true;
        }
    };

} // namespace System.Xml
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\schema\dtdparser.cs ===
//------------------------------------------------------------------------------
// <copyright file="dtdparser.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

namespace System.Xml.Schema {
    using System;
    using System.Collections;
    using System.Text;
    using System.Net;
    using System.IO;
    using System.Configuration.Assemblies;
    using System.Diagnostics;
    using System.ComponentModel;
    using System.Globalization;
    

    internal sealed class DtdParser {
        private const int STACK_INCREMENT = 10;

        // consts used by content model parsing
        private const byte   EMPTY  = 0;
        private const byte   AND    = 1;
        private const byte   OR     = 2;


        private enum DtdFunctionIndex {
            ParseDocTypeDecl        = 0,
            ParseExternalID         = 1,
            ParseDtdContent         = 2,
            ParseTextDecl           = 3,
            ParseElementDecl        = 4,
            ParseAttlist            = 5,
            ParseEntity             = 6,
            ParseNotation           = 7,
            ParseConditionalSect    = 8,
            ParseElementContent     = 9,
            ParseOp                 = 10,
            ParseAttType            = 11,
            ParseAttDefaultDecl     = 12,
            ParseAttDefaultValue    = 13,
            GetEntityValue          = 14,
            GetLiteral              = 15
        };


        private sealed class DtdParseState {
            internal DtdFunctionIndex   _FuncIndex;
            internal int                _State;
        };


        private sealed class GroupState {
            internal int          _Level;
            internal byte         _Op;
        };


        private sealed class DtdScannerState {
            internal XmlScanner   _Scanner;
            internal SchemaEntity _En;
            internal bool         _IsInternal;
            internal int          _L;
            internal int          _IgnoreDepth;
            internal int          _IncludeDepth;
            internal Uri          _BaseUri;
        };

        private HWStack             _ScannerStack;
        private XmlScanner          _Scanner;
        private XmlScanner          _XmlScanner;

        private bool                _IsInternal;
        private bool                _IsParEntity;
        private bool                _HasSeenContent;
        private bool                _HasTerminal;
        private bool                _HasSeenWhiteSpace;

        private bool                _IsIgnore;
        private bool                _IsPubid;
        private string              _PubidLiteral;
        private string              _SystemLiteral;
        private bool                _HasExternalID;

        private string              _InternalDTD;
        private int                 _InternalDTDStart = 0;
        private int                 _InternalDTDEnd = 0;
        private string              _DocPublicLiteral;
        private string              _DocSystemLiteral;
        private string              _DocBaseUri;
        private int                 _DTDNameStartPosition;
        private int                 _DTDNameStartLine;
        private bool                _DocHasExternalDTD;
        private bool                _IsLoadingExternalDTD;
        private string              _ExternalDTDBaseUri;

        private bool                _Finished;
        private SchemaInfo          _SchemaInfo;
        private int                 _Token;
        private char                _Ch;
        private string              _Text;
        private StringBuilder       _StringBuilder;
        private int                 _SubState;
        private DtdFunctionIndex    _DtdFuncIndex;
        private HWStack             _ParseStack;

        private SchemaElementDecl   _ElementDecl;
        private SchemaEntity        _Entity;
        private SchemaNotation      _Notation;
        private SchemaAttDef        _AttDef;

        private byte                _Op;
        private int                 _L;
        private int                 _LL;
        private int                 _IgnoreDepth;
        private int                 _IncludeDepth;
        private int                 _Level;

        private SchemaDeclBase.Use  _Presence;
        private HWStack             _GroupStack;
        private CompiledContentModel  _ContentModel;

        private bool                _HasVersion;
        private bool                _HasEncoding;

        private XmlNameTable        _NameTable;
        private SchemaNames         _SchemaNames;
        private XmlNamespaceManager _NsMgr;
        private XmlResolver         _XmlResolver;
        private XmlReader           _Reader;
        private string              _Prefix;
        private HWStack             _AttValueScannerStack;
        private Uri                 _BaseUri;
        private bool                _Namespaces;
        internal const string      s_System="SYSTEM";
        internal const string      s_Public="PUBLIC";

        Hashtable _UndeclaredElements = new Hashtable();
        private ValidationEventHandler  _ValidationEventHandler;
        private ValidationEventHandler  _InternalValidationEventHandler;
        
        private bool                _Normalization;
        XmlNormalizer               _AttributeNormalizer;

        internal DtdParser(XmlScanner pScanner,
                           XmlReader reader,
                           XmlResolver res,
                           XmlNameTable nameTable,
                           ValidationEventHandler validationEventHandler,
                           bool namespaces) {
            _NameTable = nameTable;
            _SchemaNames = new SchemaNames(nameTable);
            _NsMgr = new XmlNamespaceManager(_NameTable);
            _Scanner = _XmlScanner = pScanner;
            _Scanner.InDTD = true;
            _XmlResolver = res;
            _Namespaces = namespaces;

            _Reader = reader;
            _ValidationEventHandler = validationEventHandler;
            _InternalValidationEventHandler = new ValidationEventHandler(InternalValidationCallback);
            _SchemaInfo = new SchemaInfo(_SchemaNames);
            _SchemaInfo.SchemaType = SchemaType.DTD;
            _DtdFuncIndex = DtdFunctionIndex.ParseDocTypeDecl;
            _IsInternal = true;
            _ParseStack = new HWStack(STACK_INCREMENT);
            _ScannerStack = new HWStack(STACK_INCREMENT);
            _GroupStack = new HWStack(STACK_INCREMENT);
            _StringBuilder = new StringBuilder();
            _L = -2;
            if (_XmlResolver != null && reader.BaseURI != string.Empty) {
                _BaseUri = _XmlResolver.ResolveUri(null, reader.BaseURI);
                _DocBaseUri = XmlUrlResolver.UnEscape(_BaseUri.ToString());
            }
            Push(DtdFunctionIndex.ParseDocTypeDecl);

            XmlTextReader xmlTextReader = reader as XmlTextReader;
            if ( xmlTextReader != null && xmlTextReader.Normalization ) {
                _Normalization = true;
                _AttributeNormalizer = new XmlAttributeCDataNormalizer( _StringBuilder );
            }
            else {
                _Normalization = false;
                _AttributeNormalizer = new XmlNonNormalizer( _StringBuilder );
            }
        }

        internal SchemaInfo GetSchemaInfo() {
            return _SchemaInfo;
        }


        internal void SetSchemaInfo(SchemaInfo s) {
            _SchemaInfo = s;
        }

        internal ValidationEventHandler  ValidationEventHandler {
           get { return _ValidationEventHandler; }
           set { _ValidationEventHandler = value; }
        }

        internal int DTDNameStartPosition {
            get { return _DTDNameStartPosition; }
        }

        internal int DTDNameStartLine {
            get { return _DTDNameStartLine; }
        }

        internal string InternalDTD {
            get {
                if (_InternalDTD == null) {
                    _InternalDTD = new string(_XmlScanner.InternalBuffer, _InternalDTDStart - _XmlScanner.AbsoluteOffset, _InternalDTDEnd - _InternalDTDStart);
                }
                return _InternalDTD;
            }
        }
        internal XmlResolver Resolver {
            set { _XmlResolver = value; }
        }

        internal void Parse() {
#if DEBUG
            Debug.WriteLineIf(CompModSwitches.XmlSchema.TraceVerbose, "DtdParser.Parse()");
#endif
            while (!_Finished) {
                switch (_DtdFuncIndex) {
                    case DtdFunctionIndex.ParseDocTypeDecl:
                        ParseDocTypeDecl();
                        break;
                    case DtdFunctionIndex.ParseExternalID:
                        ParseExternalID();
                        break;
                    case DtdFunctionIndex.ParseDtdContent:
                        ParseDtdContent();
                        break;
                    case DtdFunctionIndex.ParseTextDecl:
                        ParseTextDecl();
                        break;
                    case DtdFunctionIndex.ParseElementDecl:
                        ParseElementDecl();
                        break;
                    case DtdFunctionIndex.ParseAttlist:
                        ParseAttlist();
                        break;
                    case DtdFunctionIndex.ParseEntity:
                        ParseEntity();
                        break;
                    case DtdFunctionIndex.ParseNotation:
                        ParseNotation();
                        break;
                    case DtdFunctionIndex.ParseConditionalSect:
                        ParseConditionalSect();
                        break;
                    case DtdFunctionIndex.ParseElementContent:
                        ParseElementContent();
                        break;
                    case DtdFunctionIndex.ParseOp:
                        ParseOp();
                        break;
                    case DtdFunctionIndex.ParseAttType:
                        ParseAttType();
                        break;
                    case DtdFunctionIndex.ParseAttDefaultDecl:
                        ParseAttDefaultDecl();
                        break;
                    case DtdFunctionIndex.ParseAttDefaultValue:
                        ParseAttDefaultValue();
                        break;
                    case DtdFunctionIndex.GetEntityValue:
                        GetEntityValue();
                        break;
                    case DtdFunctionIndex.GetLiteral:
                        GetLiteral();
                        break;
                    default:
                        Debug.Assert(false, "unhandled dtd function");
                        break;
                }
            }

            if (_Finished) {
                  //add any undeclared elements to schemainfo now
                  foreach (XmlQualifiedName edName in _UndeclaredElements.Keys){
                        _SchemaInfo.UndeclaredElementDecls.Add(edName, _UndeclaredElements[edName]);
                  }
                _XmlScanner.InDTD = false;
            }
        }


        private void ParseDocTypeDecl() {
#if DEBUG
            Debug.WriteLineIf(CompModSwitches.XmlSchema.TraceVerbose, "DtdParser.ParseDocTypeDecl()");
#endif
            while (true) {
                switch (_SubState) {
                    case 0:
                        _Scanner.ScanToken(XmlToken.NAME);
                        if (_Scanner.IsToken(XmlToken.DOCTYPE)) {
                            _SubState = 1;
                        }
                        else {
                            throw new XmlException(Res.Xml_UnexpectedToken, XmlToken.ToString(XmlToken.DOCTYPE), _Scanner.StartLineNum, _Scanner.StartLinePos);
                        }
                        break;

                    case 1:
                        GetToken(); // doctype name;
                        _SchemaInfo.DocTypeName = GetName(_Token, _Namespaces);
                        _DTDNameStartPosition = _Scanner.LinePos - _Scanner.TextLength;
                        _DTDNameStartLine     = _Scanner.LineNum;
                        _SubState = 2;
                        break;

                    case 2:
                        _Token = _Scanner.ScanDtdMarkup();
                        if (_Token != XmlToken.TAGEND) {
                            _SubState = 3;
                            Push(DtdFunctionIndex.ParseExternalID);
                            ParseExternalID();
                        }
                        else {
                            _SubState = 5;
                        }
                        break;

                    case 3:
                        if (_HasExternalID) {
                            _DocHasExternalDTD = true;
                            _DocSystemLiteral = _SystemLiteral;
                            _DocPublicLiteral = _PubidLiteral;
                            _Token = _Scanner.ScanDtdMarkup();
                        }

                        if (_Token == XmlToken.LSQB) { // Internal DTD
                            _SubState = 4;
                            _InternalDTDStart = _XmlScanner.CurrentPos;
                            Push(DtdFunctionIndex.ParseDtdContent);
                            ParseDtdContent();
                        }
                        else if (_Token != XmlToken.TAGEND) {
                            if (_HasExternalID)
                                throw new XmlException(Res.Xml_ExpectSubOrClose, _Scanner.StartLineNum, _Scanner.StartLinePos);
                            else
                                throw new XmlException(Res.Xml_ExpectExternalOrClose, _Scanner.StartLineNum, _Scanner.StartLinePos);
                        }
                        else {
                            _SubState = 5;
                        }
                        break;

                    case 4:
                        _Scanner.ScanToken(XmlToken.TAGEND);
                        _SubState = 5;
                        break;

                    case 5:
                        _SubState = 6;
                        if (_DocHasExternalDTD && _XmlResolver != null) {
                            Uri uri;
                            Stream stm;

							if (_DocPublicLiteral == null || _DocPublicLiteral == string.Empty) {
                                uri = _XmlResolver.ResolveUri(_BaseUri, _DocSystemLiteral);
                                stm = (Stream)_XmlResolver.GetEntity(uri, null, null);
                            }
                            else {
                                try {
                                    uri = _XmlResolver.ResolveUri(_BaseUri, _DocPublicLiteral);
                                    stm = (Stream)_XmlResolver.GetEntity(uri, null, null);
                                }
                                catch (Exception) {
                                    uri = _XmlResolver.ResolveUri(_BaseUri, _DocSystemLiteral);
                                    stm = (Stream)_XmlResolver.GetEntity(uri, null, null);
                                }
                            }

                            _L = -2;
                            PushScanner(new XmlScanner(new XmlStreamReader(stm), _NameTable), null, uri);
                            _IsInternal = false;
                            _HasSeenContent = false;
                            _IsLoadingExternalDTD = true;
                            _ExternalDTDBaseUri =  XmlUrlResolver.UnEscape(uri.ToString());
                            Push(DtdFunctionIndex.ParseDtdContent);
                            ParseDtdContent();
                        }
                        break;

                    case 6:
                        if (_Token == XmlToken.CDATAEND) {
                            throw new XmlException(Res.Xml_UnexpectedCDataEnd, _Scanner.StartLineNum, _Scanner.StartLinePos);
                        }
                        if (_ValidationEventHandler != null) {
                            _SchemaInfo.CheckForwardRefs(_InternalValidationEventHandler);
                        }
                        _Finished = true;
                        return;
                }
            } // while
        }


        private void ParseDtdContent() {
            while (true) {
                switch (_SubState) {
                    case 0:
                        _L = -1;
                        _Level = _ScannerStack.Length;
                        ScanDtdContent();
                        switch (_Token) {
                            case XmlToken.EOF: {
                                    _L = -2;
                                    int lineNum = _Scanner.StartLineNum;
                                    int linePos = _Scanner.LinePos;
                                    PopScanner();
                                    if (_Scanner == null) {
                                        throw new XmlException(Res.Xml_UnexpectedEOF, XmlToken.ToString(XmlToken.RSQB), lineNum, linePos);
                                    }
                                    if (_IsLoadingExternalDTD && (_ScannerStack.Length == 0)) {
                                        _IsLoadingExternalDTD = false;
                                        goto done;
                                    }
                                }
                                break;

                            case XmlToken.PI:
                                if (_Scanner.IsToken("xml")) {
                                    if (!_IsInternal && !_HasSeenContent) {
                                        _HasVersion = false;
                                        _HasEncoding = false;
                                        Push(DtdFunctionIndex.ParseTextDecl);
                                        ParseTextDecl();
                                    }
                                    else {
                                        throw new XmlException(Res.Xml_InvalidTextDecl, _Scanner.StartLineNum, _Scanner.StartLinePos);
                                    }
                                }
                                else {
                                    _SubState = 1;
                                }
                                break;

                            case XmlToken.COMMENT:
                                _Scanner.Advance(3);
                                break;

                            case XmlToken.ELEMENT:
                                Push(DtdFunctionIndex.ParseElementDecl);
                                ParseElementDecl();
                                break;

                            case XmlToken.ATTLIST:
                                Push(DtdFunctionIndex.ParseAttlist);
                                ParseAttlist();
                                break;

                            case XmlToken.ENTITY:
                                Push(DtdFunctionIndex.ParseEntity);
                                ParseEntity();
                                break;

                            case XmlToken.NOTATION:
                                Push(DtdFunctionIndex.ParseNotation);
                                ParseNotation();
                                break;

                            case XmlToken.CONDSTART:
                                if (!_IsInternal) {
                                    _L = -2;
                                    Push(DtdFunctionIndex.ParseConditionalSect);
                                    ParseConditionalSect();
                                }
                                else {
                                    throw new XmlException(Res.Xml_InvalidConditionalSection, _Scanner.StartLineNum, _Scanner.StartLinePos);
                                }
                                break;

                            case XmlToken.PENTITYREF:
                                _L = -2;
                                HandlePERef();
                                break;

                            case XmlToken.RSQB:
                                if (_IsInternal) {
                                    if (_ScannerStack.Length != 0) {
                                        SendValidationEvent(Res.Sch_ParEntityRefNesting, null);
                                    }
                                    _InternalDTDEnd = _XmlScanner.CurrentPos;
                                    _Scanner.Advance();
                                    goto done;
                                }
                                else {
                                    throw new XmlException(Res.Xml_ExpectDtdMarkup, _Scanner.StartLineNum, _Scanner.StartLinePos);
                                }

                            case XmlToken.CDATAEND:
                                if (_IsInternal)
                                    throw new XmlException(Res.Xml_UnexpectedCDataEnd, _Scanner.StartLineNum, _Scanner.StartLinePos);
                                goto done;

                            default:
                                throw new XmlException(Res.Xml_ExpectDtdMarkup, _Scanner.StartLineNum, _Scanner.StartLinePos);
                        }

                        if (_Token != XmlToken.PENTITYREF) {
                            _HasSeenContent = true;
                        }
                        break;

                    case 1: //PI name
                        XmlQualifiedName name = GetName(XmlToken.NAME, false);
                        if (string.Compare(name.Name, "xml", true, CultureInfo.InvariantCulture) == 0)
                            throw new XmlException(Res.Xml_InvalidPIName, name.Name, _Scanner.StartLineNum, _Scanner.StartLinePos);
                        _LL = _Scanner.CurrentPos;
                        _SubState = 2;
                        break;

                    case 2: //PI body
                        _Scanner.ScanPI();
                        if (_LL == _Scanner.StartPos && _LL != _Scanner.CurrentPos) {
                            throw new XmlException(Res.Xml_UnexpectedToken, XmlToken.ToString(XmlToken.WHITESPACE), _Scanner.StartLineNum, _Scanner.StartLinePos);
                        }
                        _Scanner.Advance(2);
                        _SubState = 0;
                        break;
                }
            }

            done:
            _L = -2;
            Pop();
        }


        private     void ParseElementDecl() {
            XmlQualifiedName name = XmlQualifiedName.Empty;

            while (true) {
                switch (_SubState) {
                    case 0:
                        _HasSeenWhiteSpace = false;
                        GetToken();
                        name = GetName(_Token, _Namespaces);

                        _ElementDecl = (SchemaElementDecl)_SchemaInfo.ElementDecls[name];
                        if (_ElementDecl != null) {
                            SendValidationEvent(Res.Sch_DupElementDecl, _Scanner.GetText());
                        }
                        else {
                            _ElementDecl = (SchemaElementDecl)_UndeclaredElements[name];
                            if (_ElementDecl != null) {
                                _UndeclaredElements.Remove(name);
                            }
                            else {
                                _ElementDecl = new SchemaElementDecl(name, name.Namespace, SchemaType.DTD, _SchemaNames);
                            }
                            _SchemaInfo.ElementDecls.Add(name, _ElementDecl);
                        }
                        _ElementDecl.IsDeclaredInExternal = !_IsInternal;
                        _SubState = 1;
                        break;

                    case 1:
                        if (!_HasSeenWhiteSpace) {
                            SkipWhitespace(true);
                        }
                        _SubState = 2;
                        break;

                    case 2:
                        GetToken();
                        _ContentModel = _ElementDecl.Content;

                        if (_Token == XmlToken.NAME) {
                            if (_Scanner.IsToken(XmlToken.ANY)) {
                                _ContentModel.ContentType  = CompiledContentModel.Type.Any;
                                _SubState = 12;
                            }
                            else if (_Scanner.IsToken(XmlToken.EMPTY)) {
                                _ContentModel.ContentType  = CompiledContentModel.Type.Empty;
                                _SubState = 12;
                            }
                            else {
                                _SubState = 15; // error;
                            }
                        }
                        else if (_Token == XmlToken.LPAREN) {
                            _ContentModel.Start();
                            _ContentModel.OpenGroup();
                            PushGroup();
                            _SubState = 3;
                            _L = 0;
                            _HasTerminal = false;
                        }
                        else {
                            _SubState = 15; // error
                        }
                        break;

                    case 3:
                        GetToken();
                        if (_Token == XmlToken.HASH) {
                            _SubState = 4;
                        }
                        else {
                            _ContentModel.ContentType  = CompiledContentModel.Type.ElementOnly;
                            _HasTerminal = false;
                            _SubState = 13;
                            Push(DtdFunctionIndex.ParseElementContent);
                            ParseElementContent();
                        }
                        break;

                    case 4:
                        _HasSeenWhiteSpace = SkipWhitespace(false);
                        _SubState = 5;
                        break;

                    case 5:
                        GetToken();
                        if (_HasSeenWhiteSpace || !_Scanner.IsToken(XmlToken.PCDATA))
                            throw new XmlException(Res.Xml_ExpectPcData, _Scanner.StartLineNum, _Scanner.StartLinePos);

                        _ContentModel.AddTerminal( _SchemaNames.QnPCData, null, _InternalValidationEventHandler);
                        _HasTerminal = true;
                        _SubState = 6;
                        break;

                    case 6:
                        _HasSeenWhiteSpace = false;
                        GetToken();
                        if (_Token == XmlToken.RPAREN) {
                            _ContentModel.ContentType  = CompiledContentModel.Type.Text;
                            _ContentModel.CloseGroup();
                            _ContentModel.Finish(_InternalValidationEventHandler, true);
                            PopGroup();
                            _L = -1;
                            _SubState = 14;
                            _HasSeenWhiteSpace = false;
                        }
                        else {
                            _ContentModel.ContentType  = CompiledContentModel.Type.Mixed;
                            _SubState = 7;
                        }
                        break;

                    case 7:
                        if (_Token == XmlToken.OR) {
                            _ContentModel.AddChoice();
                            _HasTerminal = false;
                            _SubState = 8;
                        }
                        else if (_Token == XmlToken.RPAREN) {
                            PopGroup();
                            _L = -1;
                            _HasSeenWhiteSpace = false;
                            _SubState = 10;
                        }
                        else {
                            _SubState = 15; // error
                        }
                        break;

                    case 8:
                        GetToken();
                        _ContentModel.AddTerminal(GetName(_Token, _Namespaces), _Prefix, _InternalValidationEventHandler);
                        _HasTerminal = true;
                        _SubState = 9;
                        break;

                    case 9:
                        _HasSeenWhiteSpace = false;
                        GetToken();
                        _SubState = 7;
                        break;

                    case 10:
                        if (!_HasSeenWhiteSpace) {
                            _HasSeenWhiteSpace = SkipWhitespace(false);
                        }
                        _SubState = 11;
                        break;

                    case 11:
                        GetToken(XmlToken.ASTERISK);
                        if (_HasSeenWhiteSpace)
                            throw new XmlException(Res.Xml_UnexpectedToken, "*", _Scanner.StartLineNum, _Scanner.StartLinePos);
                        _ContentModel.CloseGroup();
                        _ContentModel.Star();
                        _ContentModel.Finish(_InternalValidationEventHandler, true);
                        _SubState = 12;
                        break;

                    case 12:
                        GetToken();
                        _SubState = 13;
                        break;

                    case 13:
                        CheckTagend(_Token);
                        Pop();
                        return;

                    case 14:
                        _HasSeenWhiteSpace = SkipWhitespace(false);
                        GetToken();
                        if (_Token == XmlToken.ASTERISK) {
                            if (_HasSeenWhiteSpace)
                                throw new XmlException(Res.Xml_UnexpectedToken, "*", _Scanner.StartLineNum, _Scanner.StartLinePos);
                            _SubState = 12;
                        }
                        else {
                            _SubState = 13;
                        }
                        break;

                    case 15:
                        throw new XmlException(Res.Xml_InvalidContentModel, _Scanner.StartLineNum, _Scanner.StartLinePos);

                } // switch
            } // while
        }


        private void ParseElementContent() {
            while (true) {
                switch (_SubState) {
                    case 0:
                        switch (_Token) {
                            case XmlToken.NAME:
                                if (!_HasTerminal) {
                                    _ContentModel.AddTerminal(GetName(_Token, _Namespaces), _Prefix, _InternalValidationEventHandler);
                                    _HasTerminal = true;
                                    Push(DtdFunctionIndex.ParseOp);
                                    ParseOp();
                                }
                                else {
                                    _SubState = 3; // error
                                }
                                break;

                            case XmlToken.LPAREN:
                                if (!_HasTerminal) {
                                    _L++;
                                    PushGroup();
                                    _ContentModel.OpenGroup();
                                    _HasTerminal = false;
                                    _SubState = 1;
                                }
                                else {
                                    _SubState = 3; // error
                                }
                                break;

                            case XmlToken.RPAREN:
                                if (_HasTerminal) {
                                    _L--;
                                    PopGroup();
                                    _ContentModel.CloseGroup();
                                    _SubState = 2;
                                    Push(DtdFunctionIndex.ParseOp);
                                    ParseOp();
                                }
                                else {
                                    _SubState = 3;
                                }
                                break;

                            case XmlToken.COMMA:
                                if (_HasTerminal && _Op != OR) {
                                    _ContentModel.AddSequence();
                                    _HasTerminal = false;
                                    if (_Op == EMPTY)
                                        _Op = AND;
                                    _SubState = 1;
                                }
                                else {
                                    _SubState = 3; //error
                                }
                                break;

                            case XmlToken.OR:
                                if (_HasTerminal && _Op != AND) {
                                    _ContentModel.AddChoice();
                                    _HasTerminal = false;
                                    if (_Op == EMPTY)
                                        _Op = OR;
                                    _SubState = 1;
                                }
                                else {
                                    _SubState = 3; //error
                                }
                                break;

                            default:
                                _SubState = 3; //error
                break;
                        }
                        break;

                    case 1:
                        GetToken();
                        _SubState = 0;
                        break;

                    case 2:
                        _HasTerminal = true;
                        if (_L < 0) {
                            _ContentModel.Finish(_InternalValidationEventHandler, true);
                            Pop();
                            return;
                        }
                        _SubState = 0;
                        break;

                    case 3:
                        throw new XmlException(Res.Xml_InvalidContentModel, _Scanner.StartLineNum, _Scanner.StartLinePos);

                } // switch
            } // while
        }


        private void ParseOp() {
            bool fOp;

            while (true) {
                switch (_SubState) {
                    case 0:
                        _HasSeenWhiteSpace = SkipWhitespace(false);
                        _SubState = 1;
                        break;

                    case 1:
                        GetToken();
                        fOp = true;
                        switch (_Token) {
                            case XmlToken.ENDPI: //special treat for '?>'
                                _ContentModel.QuestionMark();
                                _Scanner.Advance(-1);
                                break;
                            case XmlToken.QMARK:
                                _ContentModel.QuestionMark();
                                break;
                            case XmlToken.ASTERISK:
                                _ContentModel.Star();
                                break;
                            case XmlToken.PLUS:
                                _ContentModel.Plus();
                                break;
                            default:
                                fOp = false;
                                break;
                        }

                        if (fOp) {
                            if (_HasSeenWhiteSpace)
                                throw new XmlException(Res.Xml_ExpectOp, _Scanner.StartLineNum, _Scanner.StartLinePos);
                            GetToken();
                        }

                        Pop();
                        return;
                }
            }
        }


        private     void ParseAttlist() {
            XmlQualifiedName    name = XmlQualifiedName.Empty;
            int lineNum = 0;
            int linePos = 0;


            while (true) {
                switch (_SubState) {
                    case 0:
                        _HasSeenWhiteSpace = false;
                        GetToken(XmlToken.NAME);
                        name = GetName(_Token, _Namespaces);
                        _ElementDecl = (SchemaElementDecl)_SchemaInfo.ElementDecls[name];
                        if (_ElementDecl == null) {
                            _ElementDecl = (SchemaElementDecl)_UndeclaredElements[name];
                            if (_ElementDecl == null) {
                                _ElementDecl = new SchemaElementDecl(name, name.Namespace, SchemaType.DTD, _SchemaNames);
                                _UndeclaredElements.Add(name, _ElementDecl);
                            }
                        }
                        _SubState = 1;
                        break;

                    case 1:
                        if (!_HasSeenWhiteSpace) {
                            _HasSeenWhiteSpace = SkipWhitespace(false);
                        }
                        _SubState = 2;
                        break;

                    case 2:
                        lineNum = _Scanner.LineNum;
                        linePos = _Scanner.LinePos;
                        GetToken();
                        if (_Token == XmlToken.NAME) {
                            if (!_HasSeenWhiteSpace)
                                throw new XmlException(Res.Xml_UnexpectedToken, XmlToken.ToString(XmlToken.WHITESPACE), _Scanner.StartLineNum, _Scanner.StartLinePos);

                            name = GetName(_Token, _Namespaces);
                            if (Ref.Equal(name.Namespace, _SchemaNames.NsXmlNs)) {
                                if (IsReservedNameSpace(name.Name)) {
                                    SendValidationEvent(Res.Sch_ReservedNsDecl, name.Name);
                                }
                            }
                            _AttDef = new SchemaAttDef(name, name.Namespace);
                            _AttDef.LineNum = lineNum;
                            _AttDef.LinePos = linePos;
                            if (_ElementDecl.GetAttDef(name) == null) {
                                _ElementDecl.AddAttDef(_AttDef);
                                _AttDef.IsDeclaredInExternal = !_IsInternal;
                            }
                            _SubState = 3;
                        }
                        else {
                            _SubState = 5;
                        }
                        break;

                    case 3:
                        _HasSeenWhiteSpace = SkipWhitespace(false);
                        _SubState = 4;
                        // attType
                        Push(DtdFunctionIndex.ParseAttType);
                        ParseAttType();
                        break;

                    case 4:
                        _HasSeenWhiteSpace = SkipWhitespace(false);
                        _SubState = 1;
                        // defaultDecl
                        Push(DtdFunctionIndex.ParseAttDefaultDecl);
                        ParseAttDefaultDecl();
                        _HasSeenWhiteSpace = SkipWhitespace(false);
                        break;

                    case 5:
                        CheckTagend(_Token);

                        // check xml:space amd xml:lang
                        if (_AttDef != null) {
                            if (Ref.Equal(_AttDef.Prefix, _SchemaNames.QnXml.Name)) {
                                if (_AttDef.Name.Name == "space") {
                                    _AttDef.Reserved = SchemaAttDef.Reserve.XmlSpace;
                                    if(_AttDef.Datatype.TokenizedType != XmlTokenizedType.ENUMERATION) {
                                        throw new XmlException(Res.Xml_EnumerationRequired, _AttDef.LineNum, _AttDef.LinePos);
                                    }
                                    if (_ValidationEventHandler != null)
                                        _AttDef.CheckXmlSpace(_InternalValidationEventHandler);
                                }
                                else if (_AttDef.Name.Name == "lang") {
                                    _AttDef.Reserved = SchemaAttDef.Reserve.XmlLang;
                                    if (_ValidationEventHandler != null)
                                        _AttDef.CheckXmlLang(_InternalValidationEventHandler);
                                }
                            }

                            if (_AttDef.Presence == SchemaDeclBase.Use.Required) {
                                _ElementDecl.HasRequiredAttribute = true;
                            }
                        }

                        Pop();
                        return;
                }
            }
        }

        private void    ParseAttType() {
            string code = null;
            string msg = null;
            char    ch;
            XmlTokenizedType ttype = XmlTokenizedType.None;
            string name;

            while (true) {
                switch (_SubState) {
                    case 0:
                        GetToken();
                        _SubState = 5;
                        if (_Token == XmlToken.NAME) {
                            ch = _Scanner.GetStartChar();
                            switch (ch) {
                                case 'E':
                                    if (_Scanner.IsToken(XmlToken.ENTITY))
                                        ttype = XmlTokenizedType.ENTITY;
                                    else if (_Scanner.IsToken(XmlToken.ENTITIES))
                                        ttype = XmlTokenizedType.ENTITIES;
                                    break;
                                case 'C':
                                    if (_Scanner.IsToken(XmlToken.CDATA))
                                        ttype = XmlTokenizedType.CDATA;
                                    break;
                                case 'I':
                                    if (_Scanner.IsToken(XmlToken.ID)) {
                                        ttype = XmlTokenizedType.ID;
                                        if (!_ElementDecl.IsIdDeclared) {
                                            _ElementDecl.IsIdDeclared = true;
                                        }
                                        else {
                                            SendValidationEvent(Res.Sch_IdAttrDeclared, _ElementDecl.Name.ToString());
                                        }
                                    }
                                    else if (_Scanner.IsToken(XmlToken.IDREF))
                                        ttype = XmlTokenizedType.IDREF;
                                    else if (_Scanner.IsToken(XmlToken.IDREFS))
                                        ttype = XmlTokenizedType.IDREFS;
                                    break;
                                case 'N':
                                    if (_Scanner.IsToken(XmlToken.NMTOKEN))
                                        ttype = XmlTokenizedType.NMTOKEN;
                                    else if (_Scanner.IsToken(XmlToken.NMTOKENS))
                                        ttype = XmlTokenizedType.NMTOKENS;
                                    else if (_Scanner.IsToken(XmlToken.NOTATION)) {
                                        if (!_ElementDecl.IsNotationDeclared) {
                                            if (_ElementDecl.Content.ContentType == CompiledContentModel.Type.Empty) {
                                                SendValidationEvent(Res.Sch_NotationAttributeOnEmptyElement, _ElementDecl.Name.ToString());
                                            }
                                            _ElementDecl.IsNotationDeclared = true;
                                        }
                                        else {
                                            SendValidationEvent(Res.Sch_DupNotationAttribute, _ElementDecl.Name.ToString());
                                        }
                                        _HasSeenWhiteSpace = false;
                                        ttype = XmlTokenizedType.NOTATION;
                                        _SubState = 1;
                                    }
                                    break;
                            }
                        }
                        else if (_Token == XmlToken.LPAREN) {
                            if (!_HasSeenWhiteSpace) {
                                code = Res.Xml_UnexpectedToken;
                                msg = XmlToken.ToString(XmlToken.WHITESPACE);
                                goto error;
                            }

                            ttype = XmlTokenizedType.ENUMERATION;
                            _L = -4;
                            _SubState = 3;
                        }
                        if (ttype != XmlTokenizedType.None) {
                            _AttDef.Datatype = XmlSchemaDatatype.FromXmlTokenizedType(ttype);
                        }
                        else {
                            code = Res.Xml_InvalidAttributeType;
                            msg = _Scanner.GetText();
                            goto error;
                        }
                        break;

                    case 1:
                        if (!_HasSeenWhiteSpace) {
                            SkipWhitespace(true);
                            _HasSeenWhiteSpace = false;
                        }
                        _SubState = 2;
                        break;

                    case 2:
                        GetToken(XmlToken.LPAREN);
                        _L = -4;
                        _SubState = 3;
                        break;

                    case 3:
                        GetToken();
                        if (_Token == XmlToken.NMTOKEN)
                            _Token = XmlToken.NAME;
                        name = GetNmtoken(_Token);
                        if (_AttDef.Datatype.TokenizedType == XmlTokenizedType.NOTATION &&
                            _SchemaInfo.Notations[name] == null) {
                            _SchemaInfo.AddForwardRef(name, string.Empty, name,
                                                      _Scanner.LineNum, _Scanner.LinePos,
                                                      false, ForwardRef.Type.NOTATION);
                        }
                        _AttDef.AddValue(name);
                        _SubState = 4;
                        break;

                    case 4:
                        GetToken();
                        if (_Token == XmlToken.OR) {
                            _SubState = 3;
                        }
                        else if (_Token == XmlToken.RPAREN) {
                            _L = -1;
                            _SubState = 5;
                        }
                        else {
                            code = Res.Xml_UnexpectedToken1;
                            msg = null;
                            goto error;
                        }
                        break;

                    case 5:
                        Pop();
                        return;

                } // switch
            } // while

            error:
            Debug.Assert(code != null);
            throw new XmlException(code, msg, _Scanner.StartLineNum, _Scanner.StartLinePos);
        }

        private void    ParseAttDefaultDecl() {
            char ch;

            while (true) {
                switch (_SubState) {
                    case 0:
                        GetToken();
                        if (!_HasSeenWhiteSpace)
                            throw new XmlException(Res.Xml_UnexpectedToken, XmlToken.ToString(XmlToken.WHITESPACE), _Scanner.StartLineNum, _Scanner.StartLinePos);
                        _Presence = SchemaDeclBase.Use.Default;
                        _Text = null;
                        if (_Token == XmlToken.HASH)
                            _SubState = 1;
                        else
                            _SubState = 4;
                        break;

                    case 1:
                        _HasSeenWhiteSpace = SkipWhitespace(false);
                        _SubState = 2;
                        break;

                    case 2:
                        GetToken();
                        if (!_HasSeenWhiteSpace && _Token == XmlToken.NAME) {
                            ch = _Scanner.GetStartChar();
                            switch (ch) {
                                case 'R':
                                    if (_Scanner.IsToken(XmlToken.REQUIRED)) {
                                        _Presence = SchemaDeclBase.Use.Required;
                                        _SubState = 5;
                                    }
                                    break;
                                case 'I':
                                    if (_Scanner.IsToken(XmlToken.IMPLIED)) {
                                        _Presence = SchemaDeclBase.Use.Implied;
                                        _SubState = 5;
                                    }
                                    break;
                                case 'F':
                                    if (_Scanner.IsToken(XmlToken.FIXED)) {
                                        _Presence = SchemaDeclBase.Use.Fixed;
                                        _SubState = 3;
                                    }
                                    break;
                            }
                        }

                        if (_Presence == SchemaDeclBase.Use.Default) {
                            _SubState = 6; //error
                        }
                        break;

                    case 3:
                        GetToken();
                        _SubState = 4;
                        break;

                    case 4:
                        _AttDef.ValueLineNum = _Scanner.LineNum;
                        _AttDef.ValueLinePos = _Scanner.LinePos - 1;
                        if (_Token == XmlToken.QUOTE) {
                            if (_AttDef.Datatype.TokenizedType == XmlTokenizedType.ID) {
                                SendValidationEvent(Res.Sch_AttListPresence, null);
                            }

                            _SubState = 5;
                            _L = -3;
                            Push(DtdFunctionIndex.ParseAttDefaultValue);
                            ParseAttDefaultValue();
                        }
                        else {
                            _SubState = 6; // error
                        }
                        break;

                    case 5:
                        _L = -1;
                        _AttDef.Presence = _Presence;
                        if (_Text != null) {
                            bool fEntityRef = false;
                            _AttDef.DefaultValueRaw = _Text;
                            _AttDef.DefaultValueExpanded = ExpandAttValue(_Text, ref fEntityRef, _AttDef.ValueLineNum, _AttDef.ValueLinePos + 1);
                            Validator.CheckDefaultValue(_AttDef.DefaultValueExpanded, _AttDef,
                                                              _SchemaInfo, _NsMgr, _NameTable, _Reader, _InternalValidationEventHandler);
                            _AttDef.HasEntityRef = fEntityRef;
                        }
                        Pop();
                        return;

                    case 6:
                        throw new XmlException(Res.Xml_ExpectAttType, _Scanner.StartLineNum, _Scanner.StartLinePos);
                }
            }
        }


        private     void ParseAttDefaultValue() {
            while (true) {
                switch (_SubState) {
                    case 0:
                        _Token = _Scanner.ScanLiteral(false, false, true, false);
                        if (_Token != XmlToken.ENDQUOTE) {
                            _SubState = 1;
                            _Text = _Scanner.GetText();
                        }
                        else {
                            _Text = string.Empty;
                            _SubState = 2;
                        }
                        break;

                    case 1:
                        _Scanner.ScanLiteral(false, false, true, false);
                        _SubState = 2;
                        break;

                    case 2:
                        _Scanner.Advance(); // skip quote char
                        Pop();
                        return;
                }
            }
        }


        private     void ParseEntity() {
            while (true) {
                switch (_SubState) {
                    case 0:
                        SkipWhitespace(true);
                        _SubState = 1;
                        break;

                    case 1:
                        GetToken();
                        if (_Token == XmlToken.PERCENT) {
                            _IsParEntity = true;
                            _SubState = 2;
                        }
                        else {
                            _IsParEntity = false;
                            _SubState = 4;
                        }
                        break;

                    case 2:
                        SkipWhitespace(true);
                        _SubState = 3;
                        break;

                    case 3:
                        GetToken();
                        _SubState = 4;
                        break;

                    case 4:
                        _Entity = new SchemaEntity(GetName(_Token, false), _IsParEntity);
                        if (_BaseUri != null) {
                            _Entity.BaseURI = XmlUrlResolver.UnEscape(_BaseUri.ToString());
                        }
                        if (_IsLoadingExternalDTD) {
                            _Entity.DeclaredURI = _ExternalDTDBaseUri;
                        } else {
                            _Entity.DeclaredURI = _DocBaseUri;
                        }

                        if (_Entity.IsParEntity) {
                            if (_SchemaInfo.ParameterEntities[_Entity.Name] == null) {
                                _SchemaInfo.ParameterEntities.Add(_Entity.Name, _Entity);
                            }
                        }
                        else {
                            if (_SchemaInfo.GeneralEntities[_Entity.Name] == null) {
                                _SchemaInfo.GeneralEntities.Add(_Entity.Name, _Entity);
                            }
                        }
                        _Entity.DeclaredInExternal = !_IsInternal;
                        _Entity.IsProcessed = true;
                        _SubState = 5;
                        break;

                    case 5:
                        GetToken();
                        if (_Token == XmlToken.QUOTE) { // EntityValue
                            //grab line number position for entity value
                            _Entity.Line = _Scanner.LineNum;
                            _Entity.Pos = _Scanner.LinePos - 1;

                            _SubState = 6;
                            Push(DtdFunctionIndex.GetEntityValue);
                            GetEntityValue();
                        }
                        else {
                            _SubState = 7;
                            Push(DtdFunctionIndex.ParseExternalID);
                            ParseExternalID();
                        }
                        break;

                    case 6:
                        GetToken();
                        _SubState = 11;
                        break;

                    case 7:
                        if (_HasExternalID) {
                            _SubState = 8;
                            _HasSeenWhiteSpace = SkipWhitespace(false);
                        }
                        else {
                            throw new XmlException(Res.Xml_ExpectExternalIdOrEntityValue, _Scanner.StartLineNum, _Scanner.StartLinePos);
                        }
                        break;

                    case 8:
                        GetToken();
                        _Entity.IsExternal = true;
                        _Entity.Url = _SystemLiteral;
                        _Entity.Pubid = _PubidLiteral;

                        if (!_IsParEntity && _Token == XmlToken.NAME && _Scanner.IsToken(XmlToken.NDATA)) {
                            if (!_HasSeenWhiteSpace)
                                throw new XmlException(Res.Xml_UnexpectedToken, XmlToken.ToString(XmlToken.WHITESPACE), _Scanner.StartLineNum, _Scanner.StartLinePos);

                            _SubState = 9;
                        }
                        else {
                            _SubState = 11;
                        }
                        break;

                    case 9:
                        GetToken(XmlToken.NAME);
                        _Entity.NData = GetName(XmlToken.NAME, false);
                        if (_SchemaInfo.Notations[_Entity.NData.Name] == null) {
                            _SchemaInfo.AddForwardRef(_Entity.NData.Name, _Entity.NData.Namespace, _Entity.NData.Name,
                                                      _Scanner.LineNum, _Scanner.LinePos,
                                                      false, ForwardRef.Type.NOTATION);
                        }
                        _SubState = 10;
                        break;

                    case 10:
                        GetToken();
                        _SubState = 11;
                        break;

                    case 11:
                        CheckTagend(_Token);
                        _Entity.IsProcessed = false;
                        Pop();
                        return;
                }
            }
        }


        private     void GetEntityValue() {
            char ch;
            int errorLine = 0;
            int errorPos = 0;
            string code = null;
            string msg = null;

            while (true) {
                switch (_SubState) {
                    case 0:
                        _StringBuilder.Length = 0;
                        _L = -3;
                        _LL = _ScannerStack.Length;
                        _SubState = 1;
                        break;

                    case 1:
                        _Token = _Scanner.ScanLiteral(true, true, _ScannerStack.Length == _LL, true);
                        _SubState = 2;
                        break;

                    case 2:
                        _SubState = 1;
                        switch (_Token) {
                            case XmlToken.EOF:
                                errorLine = _Scanner.LineNum;
                                errorPos = _Scanner.LinePos;
                                PopScanner();
                                _LL--;
                                if (_Scanner == null) {
                                    code = Res.Xml_UnexpectedEOF;
                                    msg = "entity value";
                                    goto error;
                                }
                                break;

                            case XmlToken.PENTITYREF:
                                if (_IsInternal) {
                                    // well-formness error, see xml spec 4.4.4
                                    throw new XmlException(Res.Xml_InvalidParEntityRef, _Scanner.StartLineNum, _Scanner.StartLinePos);
                                }
                                if (HandlePERef()) {
                                    _LL++;
                                }
                                break;

                            case XmlToken.ENTITYREF:
                                _Scanner.InDTD = false;
                                ch = _Scanner.ScanNamedEntity();
                                _Scanner.InDTD = true;
                                _StringBuilder.Append('&');
                                if (ch == 0) {
                                    XmlQualifiedName name = new XmlQualifiedName(_Scanner.GetTextAtom());
                                    _Scanner.Advance();
                                    SchemaEntity en = (SchemaEntity)_SchemaInfo.GeneralEntities[name];
                                    if (en != null && !en.NData.IsEmpty) {
                                        // well-formness error, see xml spec [68]
                                        code = Res.Xml_UnparsedEntity;
                                        msg = name.Name;
                                        errorLine = _Scanner.StartLineNum;
                                        errorPos = _Scanner.StartLinePos;

                                        goto error;
                                    }
                                    _StringBuilder.Append(name.Name);
                                }
                                else {
                                    _StringBuilder.Append(_Scanner.GetText());
                                    _Scanner.Advance();
                                }
                                _StringBuilder.Append(';');
                                break;

                            case XmlToken.NUMENTREF:
                                _StringBuilder.Append(_Scanner.ScanDecEntity());
                                break;

                            case XmlToken.HEXENTREF:
                                _StringBuilder.Append(_Scanner.ScanHexEntity());
                                break;

                            case XmlToken.TEXT:
                                if ( _Normalization )
                                    _StringBuilder.Append( XmlComplianceUtil.EndOfLineNormalization(_Scanner.InternalBuffer, 
                                                                                                    _Scanner.StartPos - _Scanner.AbsoluteOffset, 
                                                                                                    _Scanner.CurrentPos - _Scanner.StartPos));
                                else
                                    _StringBuilder.Append(_Scanner.GetText());
                                break;

                            case XmlToken.ENDQUOTE:
                                _Scanner.Advance(); // skip quote char
                                _Entity.Text = _StringBuilder.ToString();
                                _L = -1;
                                Pop();
                                return;

                            default:
                                code = Res.Xml_UnexpectedToken;
                                errorLine = _Scanner.StartLineNum;
                                errorPos = _Scanner.StartLinePos;

                                goto error;
                        }
                        break;
                }
            }

            error:
            Debug.Assert(code != null);
            throw new XmlException(code, msg, errorLine, errorPos);
        }


        private     void ParseNotation() {
            while (true) {
                switch (_SubState) {
                    case 0:
                        GetToken();
                        _Notation = new SchemaNotation(GetName(_Token, false));
                        _SchemaInfo.AddNotation(_Notation, _InternalValidationEventHandler);
                        _SubState = 1;
                        break;

                    case 1:
                        GetToken();
                        _SubState = 2;
                        _IsPubid = true;
                        Push(DtdFunctionIndex.ParseExternalID);
                        ParseExternalID();
                        break;

                    case 2:
                        if (_HasExternalID) {
                            if (_SystemLiteral != null) {
                                GetToken();
                                _Notation.SystemLiteral = _SystemLiteral;
                            }

                            _Notation.Pubid = _PubidLiteral;
                            _IsPubid = false;
                            _SubState = 3;
                        }
                        else {
                            throw new XmlException(Res.Xml_ExpectExternalOrPublicId, _Scanner.StartLineNum, _Scanner.StartLinePos);
                        }
                        break;

                    case 3:
                        CheckTagend(_Token);
                        Pop();
                        return;
                }
            }
        }


        private void    ParseConditionalSect() {
            while (true) {
                switch (_SubState) {
                    case 0:
                        GetToken();
                        if (_Scanner.IsToken(XmlToken.IGNORE)) {
                            _IsIgnore = true;
                        }
                        else if (_Scanner.IsToken(XmlToken.INCLUDE)) {
                            _IsIgnore = false;
                        }
                        else {
                            throw new XmlException(Res.Xml_ExpectIgnoreOrInclude, _Scanner.StartLineNum, _Scanner.StartLinePos);
                        }
                        _SubState = 1;
                        break;

                    case 1:
                        GetToken(XmlToken.LSQB);
                        if (_IsIgnore) {
                            _SubState = 2;
                            _IgnoreDepth = 1;
                        }
                        else {
                            _IncludeDepth++;
                            _SubState = 3;
                            Push(DtdFunctionIndex.ParseDtdContent);
                            ParseDtdContent();
                        }
                        break;

                    case 2:
                        _Token = _Scanner.ScanIgnoreSect();
                        if (_Token == XmlToken.CONDSTART) {
                            _IgnoreDepth++;
                        }
                        else { //if (_Token == XmlToken.CDATAEND)
                            _IgnoreDepth--;
                            if (_IgnoreDepth == 0) {
                                _SubState = 4;
                            }
                        }
                        break;

                    case 3:
                        if (_Token != XmlToken.CDATAEND) {
                            throw new XmlException(Res.Xml_UnexpectedToken, XmlToken.ToString(XmlToken.CDATAEND), _Scanner.StartLineNum, _Scanner.StartLinePos);
                        }
                        _IncludeDepth--;
                        _SubState = 4;
                        break;

                    case 4:
                        Pop();
                        return;
                }
            }
        }


        private     void ParseExternalID() {
            int systemLineNum = 0;
            int systemLinePos = 0;
            int systemLiteralLineNum = 0;
            int systemLiteralLinePos = 0;

            int publicLineNum = 0;
            int publicLinePos = 0;
            int publicLiteralLineNum = 0;
            int publicLiteralLinePos = 0;

            while (true) {
                switch (_SubState) {
                    case 0:

                        _Ch = _Scanner.GetStartChar();
                        if ( _Ch == 'P' ) {

                            publicLineNum = _Scanner.LineNum;
                            publicLinePos = _Scanner.LinePos - 6;

                        }
                        else {

                            systemLineNum = _Scanner.LineNum;
                            systemLinePos = _Scanner.LinePos - 6;
                        }

                        if (_Ch == 'P' && _Scanner.IsToken(XmlToken.PUBLIC)) {
                            _SubState = 1;
                        }
                        else {
                            _SubState = 3;
                        }
                        _HasExternalID = false;
                        _PubidLiteral = null;
                        _SystemLiteral = null;
                        _Text = null;
                        break;

                    case 1:
                        GetToken();
                        if (_Token == XmlToken.QUOTE) {
                            _SubState = 2;
                            _L = -3;

                            publicLiteralLineNum = _Scanner.LineNum;
                            publicLiteralLinePos = _Scanner.LinePos - 1;

                            Push(DtdFunctionIndex.GetLiteral);
                            GetLiteral();
                        }
                        else {
                            throw new XmlException(Res.Xml_UnexpectedToken, XmlToken.ToString(XmlToken.QUOTE), _Scanner.StartLineNum, _Scanner.StartLinePos);
                        }
                        break;

                    case 2:
                        if (!_IsPubid)
                            SkipWhitespace(true);
                        _L = -1;
                        _HasExternalID = true;

                        // verify it
                        for (int i = 0; i < _Text.Length; i ++) {
                            if (!XmlCharType.IsPubidChar(_Text[i]))
                                throw new XmlException(Res.Xml_InvalidCharacter, XmlException.BuildCharExceptionStr(_Text[i]));
                        }
                        _PubidLiteral = _Text;
                        _Text = null;
                        _SubState = 3;
                        break;

                    case 3:
                        if (_HasExternalID || (_Ch == 'S' && _Scanner.IsToken(XmlToken.SYSTEM))) {
                            _SubState = 4;
                        }
                        else {
                            _SubState = 5;
                        }
                        break;

                    case 4:
                        // SkipWhitespace(false);
                        GetToken();
                        _SubState = 5;
                        if (_Token == XmlToken.QUOTE) {
                            _L = -3;

                            systemLiteralLineNum = _Scanner.LineNum;
                            systemLiteralLinePos = _Scanner.LinePos - 1;

                            Push(DtdFunctionIndex.GetLiteral);
                            GetLiteral();
                        }
                        else if (!_HasExternalID || !_IsPubid) {
                            throw new XmlException(Res.Xml_UnexpectedToken, XmlToken.ToString(XmlToken.QUOTE), _Scanner.StartLineNum, _Scanner.StartLinePos);
                        }
                        break;

                    case 5:
                        if (_Text != null) {
                            if (_Text.IndexOf('#') >= 0) {
                                throw new XmlException(Res.Xml_FragmentId, new string[] { _Text.Substring( _Text.IndexOf('#') ), _Text}, systemLiteralLineNum, systemLiteralLinePos + 1);
                            }
                            _SystemLiteral = _Text;
                            if (!_HasExternalID)
                                _HasExternalID = true;
                        }
                        _L = -1;
                        Pop();
                        if (( ( DtdParseState ) _ParseStack.Peek())._FuncIndex == DtdFunctionIndex.ParseDocTypeDecl && _Reader is XmlTextReader) {
                            XmlTextReader r = (XmlTextReader) _Reader;

                            if (_PubidLiteral != null) {
                                r.SetAttributeValues(s_Public, _PubidLiteral, publicLineNum, publicLinePos, publicLiteralLineNum, publicLiteralLinePos);

                                //There is no system keyword
                                systemLiteralLineNum = systemLineNum;
                                systemLiteralLinePos = systemLinePos;
                            }
                            if (_SystemLiteral != null)
                                r.SetAttributeValues(s_System, _SystemLiteral, systemLineNum, systemLinePos, systemLiteralLineNum, systemLiteralLinePos);

                        }
                        return;
                }
            }
        }

        private void    GetLiteral() {
            while (true) {
                switch (_SubState) {
                    case 0:
                        _Token = _Scanner.ScanLiteral(false, false, true, false);
                        if (_Token != XmlToken.ENDQUOTE) {
                            _SubState = 1;
                            _Text = _Scanner.GetText();
                        }
                        else {
                            _Text = string.Empty;
                            _SubState = 2;
                        }
                        break;

                    case 1:
                        _Scanner.ScanLiteral(false, false, true, false);
                        _SubState = 2;
                        break;

                    case 2:
                        _Scanner.Advance(); // skip quote char
                        Pop();
                        return;
                }
            }
        }


        private     void ParseTextDecl() {
            string code = null;
            string msg = null;

            while (true) {
                switch (_SubState) {
                    case 0:
                        _Token = _Scanner.ScanDtdMarkup();
                        if (_Token == XmlToken.ENDPI) {
                            if (!_HasEncoding) {
                                code = Res.Xml_InvalidTextDecl;
                                goto error;
                            }
                            Pop();
                            return;
                        }

                        if (_Scanner.IsToken("version")) {
                            if (_HasVersion || _HasEncoding) {
                                code = Res.Xml_InvalidTextDecl;
                                goto error;
                            }
                            _HasVersion = true;
                        }
                        else if (_Scanner.IsToken("encoding")) {
                            if (_HasEncoding) {
                                code = Res.Xml_InvalidTextDecl;
                                goto error;
                            }
                            _HasEncoding = true;
                        }
                        else {
                            code = Res.Xml_UnexpectedToken;
                            msg = "version or encoding";
                            goto error;
                        }
                        _SubState = 1;
                        break;

                    case 1:
                        _Scanner.ScanToken(XmlToken.EQUALS);
                        _SubState = 2;
                        break;

                    case 2:
                        _Scanner.ScanToken(XmlToken.QUOTE);
                        _SubState = 3;
                        break;

                    case 3:
                        _Token = _Scanner.ScanLiteral(false, false, true, false);
                        if (_Token == XmlToken.TEXT) {
                            string text = _Scanner.GetText();
                            if (_HasEncoding) {
                                _Scanner.SwitchEncoding(text);
                            }
                         }
                        _SubState = 4;
                        break;

                    case 4:
                        if (_Scanner.ScanLiteral(false, false, true, false) != XmlToken.ENDQUOTE) {
                            code = Res.Xml_UnexpectedToken;
                            msg = XmlToken.ToString(XmlToken.ENDQUOTE);
                            goto error;
                        }
                        _Scanner.Advance();
                        _SubState = 0;
                        break;
                }
            }

            error:
            Debug.Assert(code != null);
            throw new XmlException(code, msg, _Scanner.StartLineNum, _Scanner.StartLinePos);
        }


        private string ExpandAttValue(string s, ref bool fEntityRef, int lineNum, int linePos) {
            if (s.Length == 0)
                return s;

            string code = null;
            string msg = null;
            char ch;
            XmlScanner scanner = _Scanner;

            _Scanner = new XmlScanner(s.ToCharArray(), _NameTable, lineNum, linePos);

            _AttributeNormalizer.Reset();
            int entityDepth = 0;

            while (true) {
                _Token = _Scanner.ScanLiteral(true, false, false, false);
                switch (_Token) {
                    case XmlToken.EOF:
                        PopAttValueScanner();
                        entityDepth--;
                        if (_Scanner == null) {
                            _Scanner = scanner;
                            return _AttributeNormalizer.ToString();
                        }
                        break;

                    case XmlToken.ENTITYREF:
                        fEntityRef = true;
                        _Scanner.InDTD = false;
                        ch = _Scanner.ScanNamedEntity();
                        _Scanner.InDTD = true;
                        if (ch == 0) {
                            XmlQualifiedName name = new XmlQualifiedName(_Scanner.GetTextAtom());
                            _Scanner.Advance();
                            SchemaEntity en = (SchemaEntity)_SchemaInfo.GeneralEntities[name];
                            if (en != null) {
                                if (!en.IsExternal) {
                                    if (!en.IsProcessed) {
                                        if (en.Text != null && en.Text != string.Empty) {
                                            PushAttValueScanner(_Scanner, en);
                                            _Scanner = new XmlScanner(en.Text.ToCharArray(), _NameTable, en.Line, en.Pos + 1);
                                            entityDepth++;
                                        }
                                    }
                                    else {
                                        // well-formness error, see xml spec [68]
                                        code = Res.Xml_RecursiveGenEntity;
                                        msg = name.Name;
                                        goto error;
                                    }
                                }
                                else {
                                    // well-formness error, see xml spec [68]
                                    code = Res.Xml_ExternalEntityInAttValue;
                                    msg = name.Name;
                                    goto error;
                                }
                            }
                            else {
                                // well-formness error, see xml spec [68]
                                code = Res.Xml_UndeclaredEntity;
                                msg = name.Name;

                                if(_IsInternal) {
                                    goto error;
                                }
                                else {
                                    SendValidationEvent(code, msg);
                                }
                           }
                        }
                        else {
                            _Scanner.Advance();
                            _AttributeNormalizer.AppendCharEntity(ch);
                        }
                        break;

                    case XmlToken.NUMENTREF:
                        fEntityRef = true;
                        _AttributeNormalizer.AppendCharEntity(_Scanner.ScanDecEntity());
                        break;

                    case XmlToken.HEXENTREF:
                        fEntityRef = true;
                        _AttributeNormalizer.AppendCharEntity(_Scanner.ScanHexEntity());
                        break;

                    case XmlToken.TEXT:
                        if ( entityDepth == 0 )
                            _AttributeNormalizer.AppendTextWithEolNormalization(_Scanner.InternalBuffer, 
                                                                                _Scanner.StartPos - _Scanner.AbsoluteOffset,
                                                                                _Scanner.CurrentPos - _Scanner.StartPos );
                        else
                            _AttributeNormalizer.AppendText(_Scanner.GetText()); // already eol-normalized
                        break;

                    default:
                        code = Res.Xml_UnexpectedToken;
                        goto error;
                }
            }

            error:
    Debug.Assert(code != null);
            throw new XmlException(code, msg, _Scanner.StartLineNum , _Scanner.StartLinePos);
        }

        private void    ScanDtdContent() {
            try {
                _Token = _Scanner.ScanDtdContent();
            }
            catch (XmlException xe) {
                if ((xe.ErrorCode == Res.Xml_UnexpectedEOF) &&
                    ((_ScannerStack.Length > 1) || ((_ScannerStack.Length == 1) && _IsInternal))) {
                    SendValidationEvent(Res.Sch_ParEntityRefNesting, null);
		    _Token = XmlToken.EOF;	
                }
                else {
                    throw;
                }
            }
        }


        private void    GetToken() {
            _Token = _Scanner.ScanDtdMarkup();

            while (_Token == XmlToken.PENTITYREF || _Token == XmlToken.EOF) {
                if (_Token == XmlToken.PENTITYREF) {
                    if (_IsInternal) {
                        // well-formness error, see xml spec 4.4.4
                        throw new XmlException(Res.Xml_InvalidParEntityRef, _Scanner.StartLineNum, _Scanner.StartLinePos);
                    }
                    HandlePERef();
                }
                else {
                    int errorLineNum = _Scanner.LineNum;
                    int errorLinePos = _Scanner.LinePos;
                    PopScanner();
                    if (_Scanner == null) {
                        throw new XmlException(Res.Xml_IncompleteDtdContent, errorLineNum, errorLinePos );
                    }
                }
                _Token = _Scanner.ScanDtdMarkup();
            }
        }

        private void    GetToken(int expected) {
            GetToken();
            if (_Token != expected) {
                throw new XmlException(Res.Xml_UnexpectedToken, XmlToken.ToString(expected), _Scanner.StartLineNum, _Scanner.StartLinePos);
            }
        }




        private bool    SkipWhitespace(bool fRequired) {
            bool fSeenWhitespace = _Scanner.ScanWhitespace();
            if (fRequired && !fSeenWhitespace)
                throw new XmlException(Res.Xml_UnexpectedToken, XmlToken.ToString(XmlToken.WHITESPACE), _Scanner.StartLineNum, _Scanner.StartLinePos);
            return fSeenWhitespace;
        }


        private void    CheckTagend(int token) {
            if (token != XmlToken.TAGEND)
                throw new XmlException(Res.Xml_UnexpectedToken, XmlToken.ToString(XmlToken.TAGEND), _Scanner.StartLineNum, _Scanner.StartLinePos);
            if (_ScannerStack.Length != _Level) {
                SendValidationEvent(Res.Sch_ParEntityRefNesting, null);
            }
        }


        // must aleady got a NAME token before calling this method
        private XmlQualifiedName    GetName(int token, bool fNamespace) {
            if (token != XmlToken.NAME)
                throw new XmlException(Res.Xml_UnexpectedToken, XmlToken.ToString(XmlToken.NAME), _Scanner.StartLineNum, _Scanner.StartLinePos);
            string name = _Scanner.GetText();
            _Prefix = string.Empty;

            int pos = _Scanner.Colon();

            if (pos >= 0) {
                if (fNamespace) {
                    _Prefix = _NameTable.Add(name.Substring(0, pos));
                    name = name.Substring(pos+1);
                }
                else if (_Namespaces) {
                    throw new XmlException(Res.Xml_ColonInLocalName, name, _Scanner.StartLineNum, _Scanner.StartLinePos);
                }
            }

            name = _NameTable.Add(name);
            return new XmlQualifiedName(name, _Prefix);
        }

        private string GetNmtoken(int token) {
            if (token != XmlToken.NAME)
                throw new XmlException(Res.Xml_UnexpectedToken, XmlToken.ToString(XmlToken.NAME), _Scanner.StartLineNum, _Scanner.StartLinePos);
            return _NameTable.Add(_Scanner.GetText());
        }

        private    void Push(DtdFunctionIndex func) {
            DtdParseState s = (DtdParseState)_ParseStack.Push();
            if (s == null) {
                s = new DtdParseState();
                _ParseStack[_ParseStack.Length-1] = s;
            }

            // save the current function and its substate on the stack
            s._FuncIndex = _DtdFuncIndex;
            s._State = _SubState;

            // new dtd function and substate in the function
            _DtdFuncIndex = func;
            _SubState = 0;
        }


        private    void Pop() {
            DtdParseState s = (DtdParseState)_ParseStack.Pop();

            // restore the previous function and its state
            _DtdFuncIndex = s._FuncIndex;
            _SubState = s._State;
        }


	private void CheckOptionalTextDecl() {
		bool noException = true;
		try {
		    ScanDtdContent();
		}
		catch {
		    noException = false;
		}
		if (_Token == XmlToken.PI && _Scanner.IsToken("xml") && noException) {
		    _HasVersion = false;
		    _HasEncoding = false;
	            Push(DtdFunctionIndex.ParseTextDecl);
                    ParseTextDecl();                
		}
		else {
		    // reset
		    _Scanner.StartPos = 0;
		    _Scanner.CurrentPos = 0;        
		}
	}	

        private     bool HandlePERef() {
            SchemaEntity en = (SchemaEntity)_SchemaInfo.ParameterEntities[GetName(XmlToken.NAME, false)];
            _Scanner.Advance(); //skip ';'

            if (en != null) {
                if (!en.IsProcessed) {
                    Uri uri = _BaseUri;
                    XmlScanner scanner = null;
                    if (en.IsExternal) {
                        if (_XmlResolver != null) {
                            uri = _XmlResolver.ResolveUri(_BaseUri, en.Url);
                            Stream stm = (Stream)_XmlResolver.GetEntity(uri, null, null);
                            scanner = new XmlScanner(new XmlStreamReader(stm), _NameTable);
                        }
                    }
                    else if (en.Text != string.Empty) {
                        scanner = new XmlScanner(en.Text.ToCharArray(), _NameTable, en.Line, en.Pos + 1);
                    }

		    if (scanner != null) {
                       	PushScanner(scanner, en, uri);
			if (en.IsExternal) {
			    CheckOptionalTextDecl();	
			}
                        return true;
                    }
                }
                else {
                    // well-formness error, see xml spec [68]
                    throw new XmlException(Res.Xml_RecursiveParEntity, en.Name.Name, _Scanner.StartLineNum, _Scanner.StartLinePos);
                }
            }
            else {
                // Validtion error, see xml spec [68]
                SendValidationEvent(Res.Xml_UndeclaredParEntity, _Scanner.GetText());
            }

            return false;
        }

        private    void PushScanner(XmlScanner scanner, SchemaEntity en, Uri baseUrl) {
            DtdScannerState s;

            if (en != null && _L >= 0 && _HasTerminal) {
                SendValidationEvent(Res.Sch_ParEntityRefNesting, null);
            }

            s = (DtdScannerState)_ScannerStack.Push();
            if (s == null) {
                s = new DtdScannerState();
                _ScannerStack[_ScannerStack.Length-1] = s;
            }
            s._Scanner = _Scanner;
            s._En = en;
            s._IsInternal = _IsInternal;
            s._L = _L;
            s._IncludeDepth = _IncludeDepth;
            s._IgnoreDepth = _IgnoreDepth;
            s._BaseUri = _BaseUri;
            _Scanner = scanner;
            _Scanner.InDTD = true;
            _BaseUri = baseUrl;
            if (en != null) {
                _HasSeenWhiteSpace = en.IsParEntity;
                en.IsProcessed = true;
                if (_IsInternal)
                    _IsInternal = !en.IsExternal;
                _HasSeenContent = !en.IsExternal;
            }
        }


        private    void PopScanner() {
            _Scanner.Close();

            DtdScannerState s = (DtdScannerState)_ScannerStack.Pop();

            if (s != null) {
                if (s._IgnoreDepth != _IgnoreDepth ||
                    s._IncludeDepth != _IncludeDepth ||
                    s._L != _L ||
                    (_L >= 0 && !_HasTerminal)) {
                    SendValidationEvent(Res.Sch_ParEntityRefNesting, null);
                }
                _Scanner = s._Scanner;
                _IsInternal = s._IsInternal;
                _BaseUri = s._BaseUri;
                if (s._En != null) {
                    _HasSeenWhiteSpace = s._En.IsParEntity;
                    s._En.IsProcessed = false;
                }
            }
            else {
                _Scanner = null;
            }
        }


        private    void PushAttValueScanner(XmlScanner scanner, SchemaEntity en) {
            if (_AttValueScannerStack == null) {
                _AttValueScannerStack = new HWStack(STACK_INCREMENT);
            }

            DtdScannerState s = (DtdScannerState)_AttValueScannerStack.Push();
            if (s == null) {
                s = new DtdScannerState();
                _AttValueScannerStack[_AttValueScannerStack.Length-1] = s;
            }
            s._Scanner = _Scanner;
            s._En = en;
            en.IsProcessed = true;
        }


        private    void PopAttValueScanner() {
            _Scanner.Close();

            if (_AttValueScannerStack != null) {
                DtdScannerState s = (DtdScannerState)_AttValueScannerStack.Pop();
                if (s != null) {
                    s._En.IsProcessed = false;
                    _Scanner = s._Scanner;
                }
                else {
                    _Scanner = null;
                }
            }
            else {
                _Scanner = null;
            }
        }


        private    void PushGroup() {
            GroupState s = (GroupState)_GroupStack.Push();
            if (s == null) {
                s = new GroupState();
                _GroupStack[_GroupStack.Length-1] = s;
            }
            s._Level = _ScannerStack.Length;
            s._Op = _Op;
            _Op = EMPTY;
        }


        private    void PopGroup() {
            GroupState s = (GroupState)_GroupStack.Pop();
            if (s._Level != _ScannerStack.Length) {
                SendValidationEvent(Res.Sch_ParEntityRefNesting, null);
            }
            _Op = s._Op;
        }

        private bool IsReservedNameSpace(string ns) {
            return(ns.Length >= 3) && (string.Compare(_SchemaNames.QnXml.Name, 0, ns, 0, 3, true, CultureInfo.InvariantCulture) == 0);
        }

        private void SendValidationEvent(string code, string msg) {
            if (_ValidationEventHandler != null) {
                _ValidationEventHandler(this, new ValidationEventArgs(new XmlSchemaException(code, msg, (_BaseUri == null? string.Empty : XmlUrlResolver.UnEscape(_BaseUri.ToString())), _Scanner.StartLineNum, _Scanner.StartLinePos)));
            }
        }

        internal string BaseUri
        {
            get
            {
                return _BaseUri == null? string.Empty : XmlUrlResolver.UnEscape(_BaseUri.ToString());
            }
        }

        private void InternalValidationCallback(object sender, ValidationEventArgs e ) {
            e.Exception.SetSource(_BaseUri == null? string.Empty : XmlUrlResolver.UnEscape(_BaseUri.ToString()), _Scanner.StartLineNum, _Scanner.StartLinePos);
            if (_ValidationEventHandler != null) {
                _ValidationEventHandler(this, new ValidationEventArgs(e.Exception));
            }
            else {
                throw e.Exception;
            }
        }

    };

} // namespace System.DTD.XML
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\schema\schemaattdef.cs ===
//------------------------------------------------------------------------------
// <copyright file="SchemaAttDef.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Schema {

    using System;
    using System.Diagnostics;

    /*
     * This class describes an attribute type and potential values.
     * This encapsulates the information for one Attdef * in an
     * Attlist in a DTD as described below:
     */
    internal sealed class SchemaAttDef : SchemaDeclBase {
        public enum Reserve {
            None,
            XmlSpace,
            XmlLang
        };

        private Reserve reserved;     // indicate the attribute type, such as xml:lang or xml:space   
        private String defExpanded;  // default value in its expanded form
        private bool   hasEntityRef;  // whether there is any entity reference in the default value

        int     lineNum;
        int     linePos;
        int     valueLineNum;
        int     valueLinePos;

        public static readonly SchemaAttDef Empty = new SchemaAttDef();

        public SchemaAttDef(XmlQualifiedName name, String prefix) : base(name, prefix) {
            reserved = Reserve.None;
        }

        private SchemaAttDef() {}

        public SchemaAttDef Clone() {
            return (SchemaAttDef) MemberwiseClone();
        }

        internal  int LinePos {
            get {
                return linePos;
            }
            set {
                linePos = value;
            }
        }

        internal  int LineNum {
            get {
                return lineNum;
            }
            set {
                lineNum = value;
            }
        }

        internal  int ValueLinePos {
            get {
                return valueLinePos;
            }
            set {
                valueLinePos = value;
            }
        }

        internal  int ValueLineNum {
            get {
                return valueLineNum;
            }
            set {
                valueLineNum = value;
            }
        }

        public String DefaultValueExpanded {
            get { return(defExpanded != null) ? defExpanded : String.Empty;}
            set { defExpanded = value;}
        }

        public Reserve Reserved {
            get { return reserved;}
            set { reserved = value;}
        }

        public bool HasEntityRef {
            get { return hasEntityRef;}
            set { hasEntityRef = value;}
        }

        public void CheckXmlSpace(ValidationEventHandler eventhandler) {
            if (datatype.TokenizedType == XmlTokenizedType.ENUMERATION &&      
                (values != null) &&
                (values.Count <= 2)) {
                String s1 = values[0].ToString();

                if (values.Count == 2) {
                    String s2 = values[1].ToString();

                    if ((s1 == "default" || s2 == "default") &&
                        (s1 == "preserve" || s2 == "preserve")) {
                        return; 
                    }
                }
                else {
                    if (s1 == "default" || s1 == "preserve") {
                        return;
                    }
                }
            }
            eventhandler(this, new ValidationEventArgs(new XmlSchemaException(Res.Sch_XmlSpace)));
        }

        public void CheckXmlLang(ValidationEventHandler eventhandler) {
            if (defaultValueTyped != null) {
                String s = defaultValueTyped.ToString();
                if (!XmlComplianceUtil.IsValidLanguageID(s.ToCharArray(), 0, s.Length)) {
                    eventhandler(this, new ValidationEventArgs(new XmlSchemaException(Res.Sch_InvalidLanguageId, s)));
                }
            }
        }
    };

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\schema\schemabuilder.cs ===
//------------------------------------------------------------------------------
// <copyright file="SchemaBuilder.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Schema {

    internal abstract class SchemaBuilder {
        internal abstract bool ProcessElement(string prefix, string name, string ns);
        internal abstract void ProcessAttribute(string prefix, string name, string ns, string value);
        internal abstract bool IsContentParsed();
        internal abstract void ProcessMarkup(XmlNode[] markup);
        internal abstract void ProcessCData(string value);
        internal abstract void StartChildren();
        internal abstract void EndChildren();
    }; // class SchemaBuilder

} // namespace System.Xml
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\schema\compiler.cs ===
//------------------------------------------------------------------------------
// <copyright file="Compiler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Schema {

    using System;
    using System.Collections;
    using System.Text; 
    using System.Diagnostics;
    using System.ComponentModel;

    internal sealed class Compiler {
        enum Compositor {
            Root,
            Include,
            Import
        };

        XmlNameTable nameTable;
        SchemaNames schemaNames; 
        XmlSchema schema;
        SchemaInfo schemaInfo;
        string targetNamespace;
        XmlSchemaForm elementFormDefault;
        XmlSchemaForm attributeFormDefault;
        XmlSchemaDerivationMethod blockDefault;
        XmlSchemaDerivationMethod finalDefault;
        XmlNamespaceManager namespaceManager;
        Stack complexTypeStack;
        Hashtable repeatAttributes;
        Hashtable ids;
        XmlSchemaObjectTable identityConstraints;
        ValidationEventHandler validationEventHandler;
        bool compileContentModel;
        Hashtable referenceNamespaces;

        const XmlSchemaDerivationMethod schemaBlockDefaultAllowed   = XmlSchemaDerivationMethod.Restriction | XmlSchemaDerivationMethod.Extension | XmlSchemaDerivationMethod.Substitution;
        const XmlSchemaDerivationMethod schemaFinalDefaultAllowed   = XmlSchemaDerivationMethod.Restriction | XmlSchemaDerivationMethod.Extension | XmlSchemaDerivationMethod.List | XmlSchemaDerivationMethod.Union;
        const XmlSchemaDerivationMethod elementBlockAllowed         = XmlSchemaDerivationMethod.Restriction | XmlSchemaDerivationMethod.Extension | XmlSchemaDerivationMethod.Substitution;
        const XmlSchemaDerivationMethod elementFinalAllowed         = XmlSchemaDerivationMethod.Restriction | XmlSchemaDerivationMethod.Extension;
        const XmlSchemaDerivationMethod simpleTypeFinalAllowed      = XmlSchemaDerivationMethod.Restriction | XmlSchemaDerivationMethod.List | XmlSchemaDerivationMethod.Union;
        const XmlSchemaDerivationMethod complexTypeBlockAllowed     = XmlSchemaDerivationMethod.Restriction | XmlSchemaDerivationMethod.Extension;
        const XmlSchemaDerivationMethod complexTypeFinalAllowed     = XmlSchemaDerivationMethod.Restriction | XmlSchemaDerivationMethod.Extension;

        internal Compiler(XmlNameTable nameTable, SchemaNames schemaNames, ValidationEventHandler eventhandler, bool compileContentModel) {
            this.nameTable = nameTable;
            this.schemaNames = schemaNames;
            this.validationEventHandler += eventhandler;
            this.compileContentModel = compileContentModel;
        }

        internal void Compile(XmlSchema schema, string targetNamespace, SchemaInfo schemaInfo) {
            //CompModSwitches.XmlSchema.Level = TraceLevel.Error;
            schema.ErrorCount = 0;
            Preprocess(schema, targetNamespace);
            if (schema.ErrorCount == 0) {
                CompileTo(schemaInfo);
            }
        }

        internal void Preprocess(XmlSchema schema, string targetNamespace) {          
            this.namespaceManager = new XmlNamespaceManager(this.nameTable);
            this.schema = schema;
            this.ids = schema.Ids;
            this.identityConstraints = schema.IdentityConstraints;
            ValidateIdAttribute(schema);
            Preprocess(schema, targetNamespace, Compositor.Root);
        }

        internal static void Cleanup(XmlSchema schema) {
            foreach(XmlSchemaExternal include in schema.Includes) {
                if (include.Schema != null) {
                    Cleanup(include.Schema);
                }

                if(include is XmlSchemaRedefine) {
                    XmlSchemaRedefine rdef = include as XmlSchemaRedefine;
                    rdef.AttributeGroups.Clear();
                    rdef.Groups.Clear();
                    rdef.SchemaTypes.Clear();
                                
                 foreach(object item in rdef.Items) {
                    if (item is XmlSchemaAttribute) {
                        CleanupAttribute((XmlSchemaAttribute)item);
                    } 
                    else if (item is XmlSchemaAttributeGroup) {
                        CleanupAttributeGroup((XmlSchemaAttributeGroup)item);
                    } 
                    else if (item is XmlSchemaComplexType) {
                        CleanupComplexType((XmlSchemaComplexType)item);
                    } 
                    else if (item is XmlSchemaSimpleType) {
                        CleanupSimpleType((XmlSchemaSimpleType)item);
                    } 
                    else if (item is XmlSchemaElement) {
                        CleanupElement((XmlSchemaElement)item);
                    } 
                    else if (item is XmlSchemaGroup) {
                        CleanupGroup((XmlSchemaGroup)item);
                    } 
                 }
                }
                
            }

            foreach(object item in schema.Items) {
                if (item is XmlSchemaAttribute) {
                    CleanupAttribute((XmlSchemaAttribute)item);
                } 
                else if (item is XmlSchemaAttributeGroup) {
                    CleanupAttributeGroup((XmlSchemaAttributeGroup)item);
                } 
                else if (item is XmlSchemaComplexType) {
                    CleanupComplexType((XmlSchemaComplexType)item);
                } 
                else if (item is XmlSchemaSimpleType) {
                    CleanupSimpleType((XmlSchemaSimpleType)item);
                } 
                else if (item is XmlSchemaElement) {
                    CleanupElement((XmlSchemaElement)item);
                } 
                else if (item is XmlSchemaGroup) {
                    CleanupGroup((XmlSchemaGroup)item);
                } 
            }
            schema.Attributes.Clear();
            schema.AttributeGroups.Clear();
            schema.SchemaTypes.Clear();
            schema.Elements.Clear();
            schema.Groups.Clear();
            schema.Notations.Clear();
            schema.Examplars.Clear();
            schema.Ids.Clear();
            schema.IdentityConstraints.Clear();
        }

        private void BuildRefNamespaces(XmlSchema schema) {
            referenceNamespaces = new Hashtable();
            XmlSchemaImport import;
            string ns;

            //Add XSD namespace
            referenceNamespaces.Add(XmlReservedNs.NsXsd,XmlReservedNs.NsXsd);
            referenceNamespaces.Add(string.Empty, string.Empty);            
            
            foreach(XmlSchemaExternal include in schema.Includes) {
                if(include is XmlSchemaImport) {
                    import = include as XmlSchemaImport;
                    ns = import.Namespace;
                    if(ns != null && referenceNamespaces[ns] == null) 
                      referenceNamespaces.Add(ns,ns);
                }
            }
            
            //Add the schema's targetnamespace 
            if(schema.TargetNamespace != null && referenceNamespaces[schema.TargetNamespace] == null)
                referenceNamespaces.Add(schema.TargetNamespace,schema.TargetNamespace);
           
        }

        private void Preprocess(XmlSchema schema, string targetNamespace, Compositor compositor) {
            if (schema.TargetNamespace != null) {
                schema.TargetNamespace = nameTable.Add(schema.TargetNamespace);
                try {
                    XmlConvert.ToUri(schema.TargetNamespace);  // can throw
                } 
                catch {
                    SendValidationEvent(Res.Sch_InvalidNamespace, schema.TargetNamespace, schema);
                }
            }
            if (schema.Version != null) {
                try {
                    XmlConvert.VerifyTOKEN(schema.Version); // can throw
                } 
                catch {
                    SendValidationEvent(Res.Sch_AttributeValueDataType, "version", schema);
                }
            }
            switch (compositor) {
            case Compositor.Root:
                if (targetNamespace == null && schema.TargetNamespace != null) { // not specified
                    targetNamespace = schema.TargetNamespace;
                }
                else if (targetNamespace == string.Empty && schema.TargetNamespace == null) { // no namespace schema
                    targetNamespace = null;
                }
                if (targetNamespace != schema.TargetNamespace) {
                    SendValidationEvent(Res.Sch_MismatchTargetNamespace, schema);
                }
                break;
            case Compositor.Import:
                if (targetNamespace != schema.TargetNamespace) {
                    SendValidationEvent(Res.Sch_MismatchTargetNamespace, schema);
                }
                break;
            case Compositor.Include:
                if (schema.TargetNamespace != null) {
                    if (targetNamespace != schema.TargetNamespace) {
                        SendValidationEvent(Res.Sch_MismatchTargetNamespace, schema);
                    }
                }
                break;
            }
            foreach(XmlSchemaExternal include in schema.Includes) {
                string loc = include.SchemaLocation;
                if (loc != null) {
                    try {
                        XmlConvert.ToUri(loc); // can throw
                    } 
                    catch {
                        SendValidationEvent(Res.Sch_InvalidSchemaLocation, loc, include);
                    }
                }
				else if((include is XmlSchemaRedefine || include is XmlSchemaInclude) && include.Schema == null) {
					SendValidationEvent(Res.Sch_MissRequiredAttribute, "schemaLocation", include);
				}	
                if (include.Schema != null) {
                    if (include is XmlSchemaRedefine) {
                        Preprocess(include.Schema, schema.TargetNamespace, Compositor.Include);
                    }
                    else if (include is XmlSchemaImport) {
                        if (((XmlSchemaImport)include).Namespace == null && schema.TargetNamespace == null) {
                            SendValidationEvent(Res.Sch_ImportTargetNamespaceNull, include);
                        }
                        else if (((XmlSchemaImport)include).Namespace == schema.TargetNamespace) {
                            SendValidationEvent(Res.Sch_ImportTargetNamespace, include);
                        }
                        Preprocess(include.Schema, ((XmlSchemaImport)include).Namespace, Compositor.Import);
                    }
                    else {
                        Preprocess(include.Schema, schema.TargetNamespace, Compositor.Include);
                    }
                }
                else if (include is XmlSchemaImport) {
                    string ns = ((XmlSchemaImport)include).Namespace;
                    if (ns != null) {
                        try {
                            XmlConvert.ToUri(ns); //can throw
                        } 
                        catch {
                            SendValidationEvent(Res.Sch_InvalidNamespace, ns, include);
                        }
                    }
                }
            }

            //Begin processing the current schema passed to preprocess
            //Build the namespaces that can be referenced in the current schema
            BuildRefNamespaces(schema);

            this.targetNamespace = targetNamespace == null ? string.Empty : targetNamespace;

            if (schema.BlockDefault == XmlSchemaDerivationMethod.All) {
                this.blockDefault = XmlSchemaDerivationMethod.All;
            }
            else if (schema.BlockDefault == XmlSchemaDerivationMethod.None) {
                this.blockDefault = XmlSchemaDerivationMethod.Empty;
            }
            else {
                if ((schema.BlockDefault & ~schemaBlockDefaultAllowed) != 0) {
                    SendValidationEvent(Res.Sch_InvalidBlockDefaultValue, schema);
                }
                this.blockDefault = schema.BlockDefault & schemaBlockDefaultAllowed;
            }
            if (schema.FinalDefault == XmlSchemaDerivationMethod.All) {
                this.finalDefault = XmlSchemaDerivationMethod.All;
            }
            else if (schema.FinalDefault == XmlSchemaDerivationMethod.None) {
                this.finalDefault = XmlSchemaDerivationMethod.Empty;
            }
            else {
                if ((schema.FinalDefault & ~schemaFinalDefaultAllowed) != 0) {
                    SendValidationEvent(Res.Sch_InvalidFinalDefaultValue, schema);
                }
                this.finalDefault = schema.FinalDefault & schemaFinalDefaultAllowed;
            }
            this.elementFormDefault = schema.ElementFormDefault;
            if (this.elementFormDefault == XmlSchemaForm.None) {
                this.elementFormDefault = XmlSchemaForm.Unqualified;
            }
            this.attributeFormDefault = schema.AttributeFormDefault;
            if (this.attributeFormDefault == XmlSchemaForm.None) {
                this.attributeFormDefault = XmlSchemaForm.Unqualified;
            }
            foreach(XmlSchemaExternal include in schema.Includes) {
                if (include is XmlSchemaRedefine) {
                    XmlSchemaRedefine redefine = (XmlSchemaRedefine)include;
                    if (include.Schema != null) {
                        PreprocessRedefine(redefine);
                    }
                    else {
                        foreach(XmlSchemaObject item in redefine.Items) {
                            if (!(item is XmlSchemaAnnotation)) {
                                SendValidationEvent(Res.Sch_RedefineNoSchema, redefine);
                                break;
                            }
                        }

                    }
                }
                if (include.Schema != null) {
                    foreach (DictionaryEntry entry in include.Schema.Elements) {
                        AddToTable(schema.Elements, (XmlQualifiedName)entry.Key, (XmlSchemaObject)entry.Value);
                    }
                    foreach (DictionaryEntry entry in include.Schema.Attributes) {
                        AddToTable(schema.Attributes, (XmlQualifiedName)entry.Key, (XmlSchemaObject)entry.Value);
                    }
                    foreach (DictionaryEntry entry in include.Schema.Groups) {
                        AddToTable(schema.Groups, (XmlQualifiedName)entry.Key, (XmlSchemaObject)entry.Value);
                    }
                    foreach (DictionaryEntry entry in include.Schema.AttributeGroups) {
                        AddToTable(schema.AttributeGroups, (XmlQualifiedName)entry.Key, (XmlSchemaObject)entry.Value);
                    }
                    foreach (DictionaryEntry entry in include.Schema.SchemaTypes) {
                        AddToTable(schema.SchemaTypes, (XmlQualifiedName)entry.Key, (XmlSchemaObject)entry.Value);
                    }
                    foreach (DictionaryEntry entry in include.Schema.Notations) {
                        AddToTable(schema.Notations, (XmlQualifiedName)entry.Key, (XmlSchemaObject)entry.Value);
                    }
                } 
                ValidateIdAttribute(include);
            }
			ArrayList removeItemsList = new ArrayList();
            foreach(object item in schema.Items) {
                if (item is XmlSchemaAttribute) {
                    XmlSchemaAttribute attribute = (XmlSchemaAttribute)item;
                    PreprocessAttribute(attribute);
                    AddToTable(schema.Attributes, attribute.QualifiedName, attribute);
                } 
                else if (item is XmlSchemaAttributeGroup) {
                    XmlSchemaAttributeGroup attributeGroup = (XmlSchemaAttributeGroup)item;
                    PreprocessAttributeGroup(attributeGroup);
                    AddToTable(schema.AttributeGroups, attributeGroup.QualifiedName, attributeGroup);
                } 
                else if (item is XmlSchemaComplexType) {
                    XmlSchemaComplexType complexType = (XmlSchemaComplexType)item;
                    PreprocessComplexType(complexType, false);
                    AddToTable(schema.SchemaTypes, complexType.QualifiedName, complexType);
                } 
                else if (item is XmlSchemaSimpleType) {
                    XmlSchemaSimpleType simpleType = (XmlSchemaSimpleType)item;
                    PreprocessSimpleType(simpleType, false);
                    AddToTable(schema.SchemaTypes, simpleType.QualifiedName, simpleType);
                } 
                else if (item is XmlSchemaElement) {
                    XmlSchemaElement element = (XmlSchemaElement)item;
                    PreprocessElement(element);
                    AddToTable(schema.Elements, element.QualifiedName, element);
                } 
                else if (item is XmlSchemaGroup) {
                    XmlSchemaGroup group = (XmlSchemaGroup)item;
                    PreprocessGroup(group);
                    AddToTable(schema.Groups, group.QualifiedName, group);
                } 
                else if (item is XmlSchemaNotation) {
                    XmlSchemaNotation notation = (XmlSchemaNotation)item;
                    PreprocessNotation(notation);
                    AddToTable(schema.Notations, notation.QualifiedName, notation);
                }
                else if(!(item is XmlSchemaAnnotation)) {
                    SendValidationEvent(Res.Sch_InvalidCollection,(XmlSchemaObject)item);
					removeItemsList.Add(item);
                }
            }
			foreach(XmlSchemaObject item in removeItemsList) {
				schema.Items.Remove(item);			
			}
        }

        private void PreprocessRedefine(XmlSchemaRedefine redefine) {
            foreach(XmlSchemaObject item in redefine.Items) {
                if (item is XmlSchemaGroup) {
                    XmlSchemaGroup group = (XmlSchemaGroup)item;
                    PreprocessGroup(group);
                    if (redefine.Groups[group.QualifiedName] != null) {
                        SendValidationEvent(Res.Sch_GroupDoubleRedefine, group);
                    }
                    else {
                        AddToTable(redefine.Groups, group.QualifiedName, group);
                        group.Redefined = (XmlSchemaGroup)redefine.Schema.Groups[group.QualifiedName];
                        if (group.Redefined != null) {
                            CheckRefinedGroup(group);
                        }
                        else {
                            SendValidationEvent(Res.Sch_GroupRedefineNotFound, group);
                        }
                    }
                } 
                else if (item is XmlSchemaAttributeGroup) {
                    XmlSchemaAttributeGroup attributeGroup = (XmlSchemaAttributeGroup)item;
                    PreprocessAttributeGroup(attributeGroup);
                    if (redefine.AttributeGroups[attributeGroup.QualifiedName] != null) {
                        SendValidationEvent(Res.Sch_AttrGroupDoubleRedefine, attributeGroup);
                    }
                    else {
                        AddToTable(redefine.AttributeGroups, attributeGroup.QualifiedName, attributeGroup);
                        attributeGroup.Redefined = (XmlSchemaAttributeGroup)redefine.Schema.AttributeGroups[attributeGroup.QualifiedName];
                        if (attributeGroup.Redefined != null) {
                            CheckRefinedAttributeGroup(attributeGroup);
                        }
                        else  {
                            SendValidationEvent(Res.Sch_AttrGroupRedefineNotFound, attributeGroup);
                        }
                    }
                } 
                else if (item is XmlSchemaComplexType) {
                    XmlSchemaComplexType complexType = (XmlSchemaComplexType)item;
                    PreprocessComplexType(complexType, false);
                    if (redefine.SchemaTypes[complexType.QualifiedName] != null) {
                        SendValidationEvent(Res.Sch_ComplexTypeDoubleRedefine, complexType);
                    }
                    else {
                        AddToTable(redefine.SchemaTypes, complexType.QualifiedName, complexType);
                        XmlSchemaType type = (XmlSchemaType)redefine.Schema.SchemaTypes[complexType.QualifiedName];
                        if (type != null) {
                            if (type is XmlSchemaComplexType) {
                                complexType.Redefined = type;
                                CheckRefinedComplexType(complexType);
                            }
                            else {
                                SendValidationEvent(Res.Sch_SimpleToComplexTypeRedefine, complexType);
                            }
                        }
                        else {
                            SendValidationEvent(Res.Sch_ComplexTypeRedefineNotFound, complexType);
                        }
                    }
                } 
                else if (item is XmlSchemaSimpleType) {
                    XmlSchemaSimpleType simpleType = (XmlSchemaSimpleType)item;
                    PreprocessSimpleType(simpleType, false);
                    if (redefine.SchemaTypes[simpleType.QualifiedName] != null) {
                        SendValidationEvent(Res.Sch_SimpleTypeDoubleRedefine, simpleType);
                    }
                    else {
                        AddToTable(redefine.SchemaTypes, simpleType.QualifiedName, simpleType);
                        XmlSchemaType type = (XmlSchemaType)redefine.Schema.SchemaTypes[simpleType.QualifiedName];
                        if (type != null) {
                            if (type is XmlSchemaSimpleType) {
                                simpleType.Redefined = type;
                                CheckRefinedSimpleType(simpleType);
                            }
                            else {
                                SendValidationEvent(Res.Sch_ComplexToSimpleTypeRedefine, simpleType);
                            }
                        }
                        else {
                            SendValidationEvent(Res.Sch_SimpleTypeRedefineNotFound, simpleType);
                        }
                    }
                }
            }

            foreach (DictionaryEntry entry in redefine.Groups) {
                redefine.Schema.Groups.Insert((XmlQualifiedName)entry.Key, (XmlSchemaObject)entry.Value);
            }
            foreach (DictionaryEntry entry in redefine.AttributeGroups) {
                redefine.Schema.AttributeGroups.Insert((XmlQualifiedName)entry.Key, (XmlSchemaObject)entry.Value);
            }
            foreach (DictionaryEntry entry in redefine.SchemaTypes) {
                redefine.Schema.SchemaTypes.Insert((XmlQualifiedName)entry.Key, (XmlSchemaObject)entry.Value);
            }
        }


        private int CountGroupSelfReference(XmlSchemaObjectCollection items, XmlQualifiedName name) {
            int count = 0;
            foreach (XmlSchemaParticle particle in items) {
                if (particle is XmlSchemaGroupRef) {
                    XmlSchemaGroupRef groupRef = (XmlSchemaGroupRef)particle;
                    if (groupRef.RefName == name) {
                        if (groupRef.MinOccurs != decimal.One || groupRef.MaxOccurs != decimal.One) {
                            SendValidationEvent(Res.Sch_MinMaxGroupRedefine, groupRef);
                        }
                        count ++;
                    }
                }
                else if (particle is XmlSchemaGroupBase) {
                    count += CountGroupSelfReference(((XmlSchemaGroupBase)particle).Items, name);
                }
                if (count > 1) {
                    break;
                }
            }
            return count;

        }

        private void CheckRefinedGroup(XmlSchemaGroup group) {
            int count = 0;
            if (group.Particle != null) {
                count = CountGroupSelfReference(group.Particle.Items, group.QualifiedName);            
            }            
            if (count > 1) {
                SendValidationEvent(Res.Sch_MultipleGroupSelfRef, group);
            }
        }

        private void CheckRefinedAttributeGroup(XmlSchemaAttributeGroup attributeGroup) {
            int count = 0;
            foreach (object obj in attributeGroup.Attributes) {
                if (obj is XmlSchemaAttributeGroupRef && ((XmlSchemaAttributeGroupRef)obj).RefName == attributeGroup.QualifiedName) {
                    count++;
                }
            }           
            if (count > 1) {
                SendValidationEvent(Res.Sch_MultipleAttrGroupSelfRef, attributeGroup);
            }            
        }

        private void CheckRefinedSimpleType(XmlSchemaSimpleType stype) {
            if (stype.Content != null && stype.Content is XmlSchemaSimpleTypeRestriction) {
                XmlSchemaSimpleTypeRestriction restriction = (XmlSchemaSimpleTypeRestriction)stype.Content;
                if (restriction.BaseTypeName == stype.QualifiedName) {
                    return;
                }
            }
            SendValidationEvent(Res.Sch_InvalidTypeRedefine, stype);
        }

        private void CheckRefinedComplexType(XmlSchemaComplexType ctype) {
            if (ctype.ContentModel != null) {
                XmlQualifiedName baseName;
                if (ctype.ContentModel is XmlSchemaComplexContent) {
                    XmlSchemaComplexContent content = (XmlSchemaComplexContent)ctype.ContentModel;
                    if (content.Content is XmlSchemaComplexContentRestriction) {
                        baseName = ((XmlSchemaComplexContentRestriction)content.Content).BaseTypeName;
                    }
                    else {
                        baseName = ((XmlSchemaComplexContentExtension)content.Content).BaseTypeName;
                    }
                }
                else {
                    XmlSchemaSimpleContent content = (XmlSchemaSimpleContent)ctype.ContentModel;
                    if (content.Content is XmlSchemaSimpleContentRestriction) {
                        baseName = ((XmlSchemaSimpleContentRestriction)content.Content).BaseTypeName;
                    }
                    else {
                        baseName = ((XmlSchemaSimpleContentExtension)content.Content).BaseTypeName;
                    }
                }
                if (baseName == ctype.QualifiedName) {
                    return;
                }
            }
            SendValidationEvent(Res.Sch_InvalidTypeRedefine, ctype);            
        }

        private void AddToTable(XmlSchemaObjectTable table, XmlQualifiedName qname, XmlSchemaObject item) {
            if (qname.Name == string.Empty) {
                return;
            } 
            else if (table[qname] != null) {
                string code = Res.Sch_DupGlobalAttribute;
                if (item is XmlSchemaAttributeGroup) {
                    code = Res.Sch_DupAttributeGroup;
                } 
                else if (item is XmlSchemaComplexType) {
                    code = Res.Sch_DupComplexType;
                } 
                else if (item is XmlSchemaSimpleType) {
                    code = Res.Sch_DupSimpleType;
                } 
                else if (item is XmlSchemaElement) {
                    code = Res.Sch_DupGlobalElement;
                } 
                else if (item is XmlSchemaGroup) {
                    code = Res.Sch_DupGroup;
                } 
                else if (item is XmlSchemaNotation) {
                    code = Res.Sch_DupNotation;
                }
                SendValidationEvent(code, qname.ToString(), item);
            } 
            else {
                table.Add(qname, item);
            }
        }

        private void PreprocessAttribute(XmlSchemaAttribute attribute) {
            if (attribute.Name != null) { 
                ValidateNameAttribute(attribute);
                attribute.SetQualifiedName(new XmlQualifiedName(attribute.Name, this.targetNamespace));
            } 
            else {
                SendValidationEvent(Res.Sch_MissRequiredAttribute, "name", attribute);
            }
            if (attribute.Use != XmlSchemaUse.None) {
                SendValidationEvent(Res.Sch_ForbiddenAttribute, "use", attribute);
            }
            if (attribute.Form != XmlSchemaForm.None) {
                SendValidationEvent(Res.Sch_ForbiddenAttribute, "form", attribute);
            }
            PreprocessAttributeContent(attribute);
            ValidateIdAttribute(attribute);
        }

        private void PreprocessLocalAttribute(XmlSchemaAttribute attribute) {
            if (attribute.Name != null) { // name
                ValidateNameAttribute(attribute);
                PreprocessAttributeContent(attribute);
                attribute.SetQualifiedName(new XmlQualifiedName(attribute.Name, (attribute.Form == XmlSchemaForm.Qualified || (attribute.Form == XmlSchemaForm.None && this.attributeFormDefault == XmlSchemaForm.Qualified)) ? this.targetNamespace : null));
            } 
            else { // ref
                if (attribute.RefName.IsEmpty) {
                    SendValidationEvent(Res.Sch_AttributeNameRef, "???", attribute);
                }
                else {
                    ValidateQNameAttribute(attribute, "ref", attribute.RefName);
                }
                if (!attribute.SchemaTypeName.IsEmpty || 
                    attribute.SchemaType != null || 
                    attribute.Form != XmlSchemaForm.None /*||
                    attribute.DefaultValue != null ||
                    attribute.FixedValue != null*/
                ) {
                    SendValidationEvent(Res.Sch_InvalidAttributeRef, attribute);
                }
                attribute.SetQualifiedName(attribute.RefName);
            }
            ValidateIdAttribute(attribute);
        }

        private void PreprocessAttributeContent(XmlSchemaAttribute attribute) {
            if (schema.TargetNamespace == schemaNames.NsXsi) {
                SendValidationEvent(Res.Sch_TargetNamespaceXsi, attribute);
            }
            if (!attribute.RefName.IsEmpty) {
                SendValidationEvent(Res.Sch_ForbiddenAttribute, "ref", attribute);
            } 
            if (attribute.DefaultValue != null && attribute.FixedValue != null) {
                SendValidationEvent(Res.Sch_DefaultFixedAttributes, attribute);
            }
            if (attribute.DefaultValue != null && attribute.Use != XmlSchemaUse.Optional && attribute.Use != XmlSchemaUse.None) {
                SendValidationEvent(Res.Sch_OptionalDefaultAttribute, attribute);
            }
            if (attribute.Name == this.schemaNames.QnXmlNs.Name) {
                SendValidationEvent(Res.Sch_XmlNsAttribute, attribute);
            }
            if (attribute.SchemaType != null) {
                if (!attribute.SchemaTypeName.IsEmpty) {
                    SendValidationEvent(Res.Sch_TypeMutualExclusive, attribute);
                } 
                PreprocessSimpleType(attribute.SchemaType, true);
            }
            if (!attribute.SchemaTypeName.IsEmpty) {
                ValidateQNameAttribute(attribute, "type", attribute.SchemaTypeName);
            } 
        }

        private void PreprocessAttributeGroup(XmlSchemaAttributeGroup attributeGroup) {
            if (attributeGroup.Name != null) { 
                ValidateNameAttribute(attributeGroup);
                attributeGroup.QualifiedName = new XmlQualifiedName(attributeGroup.Name, this.targetNamespace);
            }
            else {
                SendValidationEvent(Res.Sch_MissRequiredAttribute, "name", attributeGroup);
            }
            PreprocessAttributes(attributeGroup.Attributes, attributeGroup.AnyAttribute);
            ValidateIdAttribute(attributeGroup);
        }

        private void PreprocessElement(XmlSchemaElement element) {
            if (element.Name != null) {
                ValidateNameAttribute(element);
                element.SetQualifiedName(new XmlQualifiedName(element.Name, this.targetNamespace));
            }
            else {
                SendValidationEvent(Res.Sch_MissRequiredAttribute, "name", element);
            }
            PreprocessElementContent(element);

            if (element.Final == XmlSchemaDerivationMethod.All) {
                element.SetFinalResolved(XmlSchemaDerivationMethod.All);
            }
            else if (element.Final == XmlSchemaDerivationMethod.None) {
                if (this.finalDefault == XmlSchemaDerivationMethod.All) {
                    element.SetFinalResolved(XmlSchemaDerivationMethod.All);
                }
                else {
                    element.SetFinalResolved(this.finalDefault & elementFinalAllowed);
                }
            }
            else {
                if ((element.Final & ~elementFinalAllowed) != 0) {
                    SendValidationEvent(Res.Sch_InvalidElementFinalValue, element);
                }
                element.SetFinalResolved(element.Final & elementFinalAllowed);
            }
            if (element.Form != XmlSchemaForm.None) {
                SendValidationEvent(Res.Sch_ForbiddenAttribute, "form", element);
            }
            if (element.MinOccursString != null) {
                SendValidationEvent(Res.Sch_ForbiddenAttribute, "minOccurs", element);
            }
            if (element.MaxOccursString != null) {
                SendValidationEvent(Res.Sch_ForbiddenAttribute, "maxOccurs", element);
            }
            if (!element.SubstitutionGroup.IsEmpty) {
                ValidateQNameAttribute(element, "type", element.SubstitutionGroup);
                XmlSchemaSubstitutionGroup substitutionGroup = (XmlSchemaSubstitutionGroup)this.schema.Examplars[element.SubstitutionGroup];
                if (substitutionGroup == null) {
                    substitutionGroup = new XmlSchemaSubstitutionGroup();
                    substitutionGroup.Examplar = element.SubstitutionGroup;
                    this.schema.Examplars.Add(element.SubstitutionGroup, substitutionGroup);
                }
                if (substitutionGroup.Members[element.QualifiedName] == null) {
                    substitutionGroup.Members.Add(element.QualifiedName, element);
                }
            }
            ValidateIdAttribute(element);
        }

        private void PreprocessLocalElement(XmlSchemaElement element) {
            if (element.Name != null) { // name
                ValidateNameAttribute(element);
                PreprocessElementContent(element);
                element.SetQualifiedName(new XmlQualifiedName(element.Name, (element.Form == XmlSchemaForm.Qualified || (element.Form == XmlSchemaForm.None && this.elementFormDefault == XmlSchemaForm.Qualified))? this.targetNamespace : null));
            } 
            else { // ref
                if (element.RefName.IsEmpty) {
                    SendValidationEvent(Res.Sch_ElementNameRef, element);
                }
                else {
                    ValidateQNameAttribute(element, "ref", element.RefName);
                }
                if (!element.SchemaTypeName.IsEmpty || 
                    element.IsAbstract ||
                    element.Block != XmlSchemaDerivationMethod.None ||
                    element.SchemaType != null ||
                    element.HasConstraints ||
                    element.DefaultValue != null ||
                    element.Form != XmlSchemaForm.None ||
                    element.FixedValue != null ||
                    element.HasNillableAttribute) {
                    SendValidationEvent(Res.Sch_InvalidElementRef, element);
                }
                if (element.DefaultValue != null && element.FixedValue != null) {     
                    SendValidationEvent(Res.Sch_DefaultFixedAttributes, element);
                }
                element.SetQualifiedName(element.RefName);
            }
            if (element.MinOccurs > element.MaxOccurs) {
                element.MinOccurs = decimal.Zero;
                SendValidationEvent(Res.Sch_MinGtMax, element);
            }
            if(element.IsAbstract) {
                SendValidationEvent(Res.Sch_ForbiddenAttribute, "abstract", element);
            }
            if (element.Final != XmlSchemaDerivationMethod.None) {
                SendValidationEvent(Res.Sch_ForbiddenAttribute, "final", element);
            }
            if (!element.SubstitutionGroup.IsEmpty) {
                SendValidationEvent(Res.Sch_ForbiddenAttribute, "substitutionGroup", element);
            }
            ValidateIdAttribute(element);
        }

        private void PreprocessElementContent(XmlSchemaElement element) {
            if (!element.RefName.IsEmpty) {
                SendValidationEvent(Res.Sch_ForbiddenAttribute, "ref", element);
            } 
            if (element.Block == XmlSchemaDerivationMethod.All) {
                element.SetBlockResolved(XmlSchemaDerivationMethod.All);
            }
            else if (element.Block == XmlSchemaDerivationMethod.None) {
                if (this.blockDefault == XmlSchemaDerivationMethod.All) {
                    element.SetBlockResolved(XmlSchemaDerivationMethod.All);
                }
                else {
                    element.SetBlockResolved(this.blockDefault & elementBlockAllowed);
                }
            }
            else {
                if ((element.Block & ~elementBlockAllowed) != 0) {
                    SendValidationEvent(Res.Sch_InvalidElementBlockValue, element);
                }
                element.SetBlockResolved(element.Block & elementBlockAllowed);
            }
            if (element.SchemaType != null) {
                if (!element.SchemaTypeName.IsEmpty) {
                    SendValidationEvent(Res.Sch_TypeMutualExclusive, element);
                } 
                if (element.SchemaType is XmlSchemaComplexType) {
                    PreprocessComplexType((XmlSchemaComplexType)element.SchemaType, true);
                } 
                else {
                    PreprocessSimpleType((XmlSchemaSimpleType)element.SchemaType, true);
                }
            }
            if (!element.SchemaTypeName.IsEmpty) {
                ValidateQNameAttribute(element, "type", element.SchemaTypeName);
            } 
            if (element.DefaultValue != null && element.FixedValue != null) {
                SendValidationEvent(Res.Sch_DefaultFixedAttributes, element);
            }
            foreach(XmlSchemaIdentityConstraint identityConstraint in element.Constraints) {
                PreprocessIdentityConstraint(identityConstraint);
            }
        }

        private void PreprocessIdentityConstraint(XmlSchemaIdentityConstraint constraint) {
            bool valid = true;
            if (constraint.Name != null) {
                ValidateNameAttribute(constraint);
                constraint.SetQualifiedName(new XmlQualifiedName(constraint.Name, this.targetNamespace));
            }
            else {
                SendValidationEvent(Res.Sch_MissRequiredAttribute, "name", constraint);
                valid = false;
            }

            if (this.identityConstraints[constraint.QualifiedName] != null) {
                SendValidationEvent(Res.Sch_DupIdentityConstraint, constraint.QualifiedName.ToString(), constraint);
                valid = false;
            }
            else {
                this.identityConstraints.Add(constraint.QualifiedName, constraint);
            }

            if (constraint.Selector == null) {
                SendValidationEvent(Res.Sch_IdConstraintNoSelector, constraint);
                valid = false;
            }
            if (constraint.Fields.Count == 0) {
                SendValidationEvent(Res.Sch_IdConstraintNoFields, constraint);
                valid = false;
            }
            if (constraint is XmlSchemaKeyref) {
                XmlSchemaKeyref keyref = (XmlSchemaKeyref)constraint;
                if (keyref.Refer.IsEmpty) {
                    SendValidationEvent(Res.Sch_IdConstraintNoRefer, constraint);
                    valid = false;
                }
                else {
                    ValidateQNameAttribute(keyref, "refer", keyref.Refer);
                }
            }
            if (valid) {
                ValidateIdAttribute(constraint);
                ValidateIdAttribute(constraint.Selector);
                foreach (XmlSchemaXPath field in constraint.Fields) {
                    ValidateIdAttribute(field);
                }
            }
        }

        private void PreprocessSimpleType(XmlSchemaSimpleType simpleType, bool local) {
            if (local) {
                if (simpleType.Name != null) {
                    SendValidationEvent(Res.Sch_ForbiddenAttribute, "name", simpleType);
                }
            }
            else {
                if (simpleType.Name != null) {
                    ValidateNameAttribute(simpleType);
                    simpleType.SetQualifiedName(new XmlQualifiedName(simpleType.Name, this.targetNamespace));
                }
                else {
                    SendValidationEvent(Res.Sch_MissRequiredAttribute, "name", simpleType);
                }

                if (simpleType.Final == XmlSchemaDerivationMethod.All) {
                    simpleType.SetFinalResolved(XmlSchemaDerivationMethod.All);
                }
                else if (simpleType.Final == XmlSchemaDerivationMethod.None) {
                    if (this.finalDefault == XmlSchemaDerivationMethod.All) {
                        simpleType.SetFinalResolved(XmlSchemaDerivationMethod.All);
                    }
                    else {
                        simpleType.SetFinalResolved(this.finalDefault & simpleTypeFinalAllowed);
                    }
                }
                else {
                    if ((simpleType.Final & ~simpleTypeFinalAllowed) != 0) {
                        SendValidationEvent(Res.Sch_InvalidSimpleTypeFinalValue, simpleType);
                    }
                    simpleType.SetFinalResolved(simpleType.Final & simpleTypeFinalAllowed);
                }
            }

            if (simpleType.Content == null) {
                SendValidationEvent(Res.Sch_NoSimpleTypeContent, simpleType);
            } 
            else if (simpleType.Content is XmlSchemaSimpleTypeRestriction) {
                XmlSchemaSimpleTypeRestriction restriction = (XmlSchemaSimpleTypeRestriction)simpleType.Content;
                if (restriction.BaseType != null) {
                    if (!restriction.BaseTypeName.IsEmpty) {
                        SendValidationEvent(Res.Sch_SimpleTypeRestRefBase, restriction);
                    }
                    PreprocessSimpleType(restriction.BaseType, true);
                } 
                else {
                    if (restriction.BaseTypeName.IsEmpty) {
                        SendValidationEvent(Res.Sch_SimpleTypeRestRefBase, restriction);
                    }
                    else {
                        ValidateQNameAttribute(restriction, "base", restriction.BaseTypeName);
                    }
                }
                ValidateIdAttribute(restriction);
            } 
            else if (simpleType.Content is XmlSchemaSimpleTypeList) {
                XmlSchemaSimpleTypeList list = (XmlSchemaSimpleTypeList)simpleType.Content;
                if (list.ItemType != null) {
                    if (!list.ItemTypeName.IsEmpty) {
                        SendValidationEvent(Res.Sch_SimpleTypeListRefBase, list);
                    }
                    PreprocessSimpleType(list.ItemType, true);
                } 
                else {
                    if (list.ItemTypeName.IsEmpty) {
                        SendValidationEvent(Res.Sch_SimpleTypeListRefBase, list);
                    }
                    else {
                        ValidateQNameAttribute(list, "itemType", list.ItemTypeName);
                    }
                }
                ValidateIdAttribute(list);
            } 
            else { // union
                XmlSchemaSimpleTypeUnion union1 = (XmlSchemaSimpleTypeUnion)simpleType.Content;
                int baseTypeCount = union1.BaseTypes.Count;
                if (union1.MemberTypes != null) {
                    baseTypeCount += union1.MemberTypes.Length;
                    foreach(XmlQualifiedName qname in union1.MemberTypes) {
                        ValidateQNameAttribute(union1, "memberTypes", qname);
                    }
                }
                if (baseTypeCount == 0) {
                    SendValidationEvent(Res.Sch_SimpleTypeUnionNoBase, union1);
                }
                foreach(XmlSchemaSimpleType type in union1.BaseTypes) {
                    PreprocessSimpleType(type, true);
                }
                ValidateIdAttribute(union1);
            }
            ValidateIdAttribute(simpleType);
        }

        private void PreprocessComplexType(XmlSchemaComplexType complexType, bool local) {
            if (local) {
                if (complexType.Name != null) {
                    SendValidationEvent(Res.Sch_ForbiddenAttribute, "name", complexType);
                }
            }
            else {
                if (complexType.Name != null) {
                    ValidateNameAttribute(complexType);
                    complexType.SetQualifiedName(new XmlQualifiedName(complexType.Name, this.targetNamespace));
                }
                else {
                    SendValidationEvent(Res.Sch_MissRequiredAttribute, "name", complexType);
                }
                if (complexType.Block == XmlSchemaDerivationMethod.All) {
                    complexType.SetBlockResolved(XmlSchemaDerivationMethod.All);
                }
                else if (complexType.Block == XmlSchemaDerivationMethod.None) {
                    complexType.SetBlockResolved(this.blockDefault & complexTypeBlockAllowed);
                }
                else {
                    if ((complexType.Block & ~complexTypeBlockAllowed) != 0) {
                        SendValidationEvent(Res.Sch_InvalidComplexTypeBlockValue, complexType);
                    }
                    complexType.SetBlockResolved(complexType.Block & complexTypeBlockAllowed);
                }
                if (complexType.Final == XmlSchemaDerivationMethod.All) {
                    complexType.SetFinalResolved(XmlSchemaDerivationMethod.All);
                }
                else if (complexType.Final == XmlSchemaDerivationMethod.None) {
                    if (this.finalDefault == XmlSchemaDerivationMethod.All) {
                        complexType.SetFinalResolved(XmlSchemaDerivationMethod.All);
                    }
                    else {
                        complexType.SetFinalResolved(this.finalDefault & complexTypeFinalAllowed);
                    }
                }
                else {
                    if ((complexType.Final & ~complexTypeFinalAllowed) != 0) {
                        SendValidationEvent(Res.Sch_InvalidComplexTypeFinalValue, complexType);
                    }
                    complexType.SetFinalResolved(complexType.Final & complexTypeFinalAllowed);
                }

            }

            if (complexType.ContentModel != null) {
                if (complexType.Particle != null || complexType.Attributes != null) {
                    // this is illigal
                }
                if (complexType.ContentModel is XmlSchemaSimpleContent) {
                    XmlSchemaSimpleContent content = (XmlSchemaSimpleContent)complexType.ContentModel;
                    if (content.Content == null) {
                        SendValidationEvent(Res.Sch_NoRestOrExt, complexType);
                    } 
                    else if (content.Content is XmlSchemaSimpleContentExtension) {
                        XmlSchemaSimpleContentExtension contentExtension = (XmlSchemaSimpleContentExtension)content.Content;
                        if (contentExtension.BaseTypeName.IsEmpty) {
                            SendValidationEvent(Res.Sch_MissAttribute, "base", contentExtension);
                        }
                        else {
                            ValidateQNameAttribute(contentExtension, "base", contentExtension.BaseTypeName);
                        }
                        PreprocessAttributes(contentExtension.Attributes, contentExtension.AnyAttribute);
                        ValidateIdAttribute(contentExtension);
                    } 
                    else { //XmlSchemaSimpleContentRestriction
                        XmlSchemaSimpleContentRestriction contentRestriction = (XmlSchemaSimpleContentRestriction)content.Content;
                        if (contentRestriction.BaseTypeName.IsEmpty) {
                            SendValidationEvent(Res.Sch_MissAttribute, "base", contentRestriction);
                        }
                        else {
                            ValidateQNameAttribute(contentRestriction, "base", contentRestriction.BaseTypeName);
                        }
                        if (contentRestriction.BaseType != null) {
                            PreprocessSimpleType(contentRestriction.BaseType, true);
                        } 
                        PreprocessAttributes(contentRestriction.Attributes, contentRestriction.AnyAttribute);
                        ValidateIdAttribute(contentRestriction);
                    }
                    ValidateIdAttribute(content);
                } 
                else { // XmlSchemaComplexContent
                    XmlSchemaComplexContent content = (XmlSchemaComplexContent)complexType.ContentModel;
                    if (content.Content == null) {
                        SendValidationEvent(Res.Sch_NoRestOrExt, complexType);
                    } 
                    else {
                        if ( !content.HasMixedAttribute && complexType.IsMixed) {
                            content.IsMixed = true; // fixup
                        }
                        if (content.Content is XmlSchemaComplexContentExtension) {
                            XmlSchemaComplexContentExtension contentExtension = (XmlSchemaComplexContentExtension)content.Content;
                            if (contentExtension.BaseTypeName.IsEmpty) {
                                SendValidationEvent(Res.Sch_MissAttribute, "base", contentExtension);
                            }
                            else {
                                ValidateQNameAttribute(contentExtension, "base", contentExtension.BaseTypeName);
                            }
                            if (contentExtension.Particle != null) {
                                PreprocessParticle(contentExtension.Particle);
                            }
                            PreprocessAttributes(contentExtension.Attributes, contentExtension.AnyAttribute);
                            ValidateIdAttribute(contentExtension);
                        } 
                        else { // XmlSchemaComplexContentRestriction
                            XmlSchemaComplexContentRestriction contentRestriction = (XmlSchemaComplexContentRestriction)content.Content;
                            if (contentRestriction.BaseTypeName.IsEmpty) {
                                SendValidationEvent(Res.Sch_MissAttribute, "base", contentRestriction);
                            }
                            else {
                                ValidateQNameAttribute(contentRestriction, "base", contentRestriction.BaseTypeName);
                            }
                            if (contentRestriction.Particle != null) {
                                PreprocessParticle(contentRestriction.Particle);
                            }
                            PreprocessAttributes(contentRestriction.Attributes, contentRestriction.AnyAttribute);
                            ValidateIdAttribute(contentRestriction);
                        }
                        ValidateIdAttribute(content);
                    }
                }
            } 
            else {
                if (complexType.Particle != null) {
                    PreprocessParticle(complexType.Particle);
                }
                PreprocessAttributes(complexType.Attributes, complexType.AnyAttribute);
            }
            ValidateIdAttribute(complexType);
        }

        private void PreprocessGroup(XmlSchemaGroup group) {
            if (group.Name != null) { 
                ValidateNameAttribute(group);
                group.QualifiedName = new XmlQualifiedName(group.Name, this.targetNamespace);
            }
            else {
                SendValidationEvent(Res.Sch_MissRequiredAttribute, "name", group);
            }
            if (group.Particle == null) {
                SendValidationEvent(Res.Sch_NoGroupParticle, group);
                return;
            }
            if (group.Particle.MinOccursString != null) {
                SendValidationEvent(Res.Sch_ForbiddenAttribute, "minOccurs", group.Particle);
            }
            if (group.Particle.MaxOccursString != null) {
                SendValidationEvent(Res.Sch_ForbiddenAttribute, "maxOccurs", group.Particle);
            }

            PreprocessParticle(group.Particle);
            ValidateIdAttribute(group);
        }

        private void PreprocessNotation(XmlSchemaNotation notation) {
            if (notation.Name != null) { 
                ValidateNameAttribute(notation);
                notation.QualifiedName = new XmlQualifiedName(notation.Name, this.targetNamespace);
            }
            else {
                SendValidationEvent(Res.Sch_MissRequiredAttribute, "name", notation);
            }
            if (notation.Public != null) { 
                try {
                    XmlConvert.ToUri(notation.Public); // can throw
                } 
                catch {
                    SendValidationEvent(Res.Sch_InvalidPublicAttribute, notation.Public, notation);
                }
            }
            else {
                SendValidationEvent(Res.Sch_MissRequiredAttribute, "public", notation);
            }
            if (notation.System != null) {
                try {
                    XmlConvert.ToUri(notation.System); // can throw
                } 
                catch {
                    SendValidationEvent(Res.Sch_InvalidSystemAttribute, notation.System, notation);
                }    
            }

            ValidateIdAttribute(notation);
        }

        
        private void PreprocessParticle(XmlSchemaParticle particle) {
            if (particle is XmlSchemaAll) {
                if (particle.MinOccurs != decimal.Zero && particle.MinOccurs != decimal.One) {
                    particle.MinOccurs = decimal.One;
                    SendValidationEvent(Res.Sch_InvalidAllMin, particle);
                }
                if (particle.MaxOccurs != decimal.One) {
                    particle.MaxOccurs = decimal.One;
                    SendValidationEvent(Res.Sch_InvalidAllMax, particle);
                }
                foreach(XmlSchemaElement element in ((XmlSchemaAll)particle).Items) {
                    if (element.MaxOccurs != decimal.Zero && element.MaxOccurs != decimal.One) {
                        element.MaxOccurs = decimal.One;
                        SendValidationEvent(Res.Sch_InvalidAllElementMax, element);
                    }
                    PreprocessLocalElement(element);
                }
            } 
            else {
                if (particle.MinOccurs > particle.MaxOccurs) {
                    particle.MinOccurs = particle.MaxOccurs;
                    SendValidationEvent(Res.Sch_MinGtMax, particle);
                }
                if (particle is XmlSchemaChoice) {
                    foreach(object item in ((XmlSchemaChoice)particle).Items) {
                        if (item is XmlSchemaElement) {
                            PreprocessLocalElement((XmlSchemaElement)item);
                        } 
                        else {
                            PreprocessParticle((XmlSchemaParticle)item);
                        }
                    }
                } 
                else if (particle is XmlSchemaSequence) {
                    foreach(object item in ((XmlSchemaSequence)particle).Items) {
                        if (item is XmlSchemaElement) {
                            PreprocessLocalElement((XmlSchemaElement)item);
                        } 
                        else {
                            PreprocessParticle((XmlSchemaParticle)item);
                        }
                    }
                } 
                else if (particle is XmlSchemaGroupRef) {
                    XmlSchemaGroupRef groupRef = (XmlSchemaGroupRef)particle;
                    if (groupRef.RefName.IsEmpty) {
                        SendValidationEvent(Res.Sch_MissAttribute, "ref", groupRef);
                    }
                    else {
                        ValidateQNameAttribute(groupRef, "ref", groupRef.RefName);
                    }
                } 
                else if (particle is XmlSchemaAny) {
                    try {
                        ((XmlSchemaAny)particle).BuildNamespaceList(this.targetNamespace);
                    } 
                    catch {
                        SendValidationEvent(Res.Sch_InvalidAny, particle);
                    }
                }
            }
            ValidateIdAttribute(particle);
        }

        private void PreprocessAttributes(XmlSchemaObjectCollection attributes, XmlSchemaAnyAttribute anyAttribute) {
            foreach (XmlSchemaAnnotated obj in attributes) {
                if (obj is XmlSchemaAttribute) {
                    PreprocessLocalAttribute((XmlSchemaAttribute)obj);
                } 
                else { // XmlSchemaAttributeGroupRef
                    XmlSchemaAttributeGroupRef attributeGroupRef = (XmlSchemaAttributeGroupRef)obj;
                    if (attributeGroupRef.RefName.IsEmpty) {
                        SendValidationEvent(Res.Sch_MissAttribute, "ref", attributeGroupRef);
                    }
                    else {
                        ValidateQNameAttribute(attributeGroupRef, "ref", attributeGroupRef.RefName);
                    }
                    ValidateIdAttribute(obj);
                }
            }
            if (anyAttribute != null) {
                try {
                    anyAttribute.BuildNamespaceList(this.targetNamespace);
                } 
                catch {
                    SendValidationEvent(Res.Sch_InvalidAnyAttribute, anyAttribute);
                }
                ValidateIdAttribute(anyAttribute);
            }
        }

        private void ValidateIdAttribute(XmlSchemaObject xso) {
            if (xso.IdAttribute != null) {
                try {
                    xso.IdAttribute = nameTable.Add(XmlConvert.VerifyNCName(xso.IdAttribute));
                    if (this.ids[xso.IdAttribute] != null) {
                        SendValidationEvent(Res.Sch_DupIdAttribute, xso);
                    }
                    else {
                        this.ids.Add(xso.IdAttribute, xso);
                    }
                } 
                catch (Exception ex){
                    SendValidationEvent(Res.Sch_InvalidIdAttribute, ex.Message, xso);
                }
            }
        }

        private void ValidateNameAttribute(XmlSchemaObject xso) {
            try {
                xso.NameAttribute = nameTable.Add(XmlConvert.VerifyNCName(xso.NameAttribute));
            } 
            catch (Exception ex){
                SendValidationEvent(Res.Sch_InvalidNameAttribute, ex.Message, xso);
            }
        }

        private void ValidateQNameAttribute(XmlSchemaObject xso, string attributeName, XmlQualifiedName value) {
            try {
                value.Verify();
                value.Atomize(nameTable);
                if(referenceNamespaces[value.Namespace] == null) {
                    SendValidationEvent(Res.Sch_UnrefNS,value.Namespace,xso, XmlSeverityType.Warning);
                }
            } 
            catch (Exception ex){
                SendValidationEvent(Res.Sch_InvalidAttribute, attributeName, ex.Message, xso);
            }
        }

        private void CompileTo(SchemaInfo schemaInfo) {
            this.schema.SchemaTypes.Insert(this.schemaNames.QnXsdAnyType, XmlSchemaComplexType.AnyType);
            this.schemaInfo = schemaInfo;
            this.complexTypeStack = new Stack();
            this.repeatAttributes = new Hashtable();

            foreach (XmlSchemaSubstitutionGroup sgroup in this.schema.Examplars.Values) {
                CompileSubstitutionGroup(sgroup);
            }

            foreach (XmlSchemaGroup group in this.schema.Groups.Values) {
                CompileGroup(group);
            }

            foreach (XmlSchemaAttributeGroup attributeGroup in this.schema.AttributeGroups.Values) {
                CompileAttributeGroup(attributeGroup);
            }

            foreach (XmlSchemaType type in this.schema.SchemaTypes.Values) {
                if (type is XmlSchemaComplexType) {
                    CompileComplexType((XmlSchemaComplexType)type);
                }
                else {
                    CompileSimpleType((XmlSchemaSimpleType)type);
                }
            }

            foreach (XmlSchemaElement element in this.schema.Elements.Values) {
                if (element.ElementDecl == null) {
                    CompileElement(element);
                }
            }

            foreach (XmlSchemaAttribute attribute in this.schema.Attributes.Values) {
                if (attribute.AttDef == null) {
                    CompileAttribute(attribute);
                }
            }    

            foreach (XmlSchemaIdentityConstraint identityConstraint in this.identityConstraints.Values) {
                if (identityConstraint.CompiledConstraint == null) {
                    CompileIdentityConstraint(identityConstraint);
                }
            }    

            while (this.complexTypeStack.Count > 0) {
                XmlSchemaComplexType type = (XmlSchemaComplexType)this.complexTypeStack.Pop();
                CompileCompexTypeElements(type);
            }

            foreach (XmlSchemaType type in this.schema.SchemaTypes.Values) {
                if (type is XmlSchemaComplexType) {
                    CheckParticleDerivation((XmlSchemaComplexType)type);
                }
            }

            foreach (XmlSchemaElement element in this.schema.Elements.Values) {
                if (element.ElementType is XmlSchemaComplexType && element.SchemaTypeName == XmlQualifiedName.Empty) { // only local types
                    CheckParticleDerivation((XmlSchemaComplexType)element.ElementType);
                }
            }

            foreach (XmlSchemaSubstitutionGroup sgroup in this.schema.Examplars.Values) {
                CheckSubstitutionGroup(sgroup);
            }


            if (this.schema.ErrorCount == 0) {
                foreach (XmlSchemaElement element in this.schema.Elements.Values) {
                    this.schemaInfo.ElementDecls.Add(element.QualifiedName, element.ElementDecl);
                }
                foreach (XmlSchemaAttribute attribute in this.schema.Attributes.Values) {
                    this.schemaInfo.AttributeDecls.Add(attribute.QualifiedName, attribute.AttDef);
                }    
                foreach (XmlSchemaType type in this.schema.SchemaTypes.Values) {
                     XmlSchemaComplexType complexType = type as XmlSchemaComplexType;
                     if (complexType == null || (!complexType.IsAbstract && type != XmlSchemaComplexType.AnyType)) {
                        this.schemaInfo.ElementDeclsByType.Add(type.QualifiedName, type.ElementDecl);
                     }
                }
                foreach (DictionaryEntry entry in this.schema.Notations) {
                    XmlSchemaNotation notation = (XmlSchemaNotation)entry.Value;
                    SchemaNotation no = new SchemaNotation((XmlQualifiedName)entry.Key);
                    no.SystemLiteral = notation.System;
                    no.Pubid = notation.Public;
                    this.schemaInfo.AddNotation(no, this.validationEventHandler);
                }
            }
            this.schema.SchemaTypes.Remove(this.schemaNames.QnXsdAnyType);
        }

        private void CompileSubstitutionGroup(XmlSchemaSubstitutionGroup substitutionGroup) {
            if (substitutionGroup.Validating) {
                foreach (XmlSchemaElement element in substitutionGroup.Members.Values) {
                    SendValidationEvent(Res.Sch_SubstitutionCircularRef, element);
                    return;
                }
            }
            if (substitutionGroup.Members[substitutionGroup.Examplar] != null) {// already checked
                return;
            }
            substitutionGroup.Validating = true; 
            XmlSchemaElement examplar = (XmlSchemaElement)this.schema.Elements[substitutionGroup.Examplar];
            if (examplar != null) {
                if (examplar.FinalResolved == XmlSchemaDerivationMethod.All) {
                    SendValidationEvent(Res.Sch_InvalidExamplar, examplar);
                }
                foreach (XmlSchemaElement element in substitutionGroup.Members.Values) {
                    XmlSchemaSubstitutionGroup g = (XmlSchemaSubstitutionGroup)this.schema.Examplars[element.QualifiedName];
                    if (g != null) {
                        CompileSubstitutionGroup(g);
                        foreach (XmlSchemaElement element1 in g.Choice.Items) {
                            substitutionGroup.Choice.Items.Add(element1);
                        }
                    }
                    else {
                        substitutionGroup.Choice.Items.Add(element);
                    }
                }
                substitutionGroup.Choice.Items.Add(examplar);
                substitutionGroup.Members.Add(examplar.QualifiedName, examplar); // Compiled mark
            }
            else {
                foreach (XmlSchemaElement element in substitutionGroup.Members.Values) {
                    SendValidationEvent(Res.Sch_NoExamplar, element);
                    break;
                }
            }
           substitutionGroup.Validating = false;              
        }

        private void CheckSubstitutionGroup(XmlSchemaSubstitutionGroup substitutionGroup) {
            XmlSchemaElement examplar = (XmlSchemaElement)this.schema.Elements[substitutionGroup.Examplar];
            if (examplar != null) {
                foreach (XmlSchemaElement element in substitutionGroup.Members.Values) {
                    if (element != examplar) {
                        if (!XmlSchemaType.IsDerivedFrom(element.ElementType, examplar.ElementType, examplar.FinalResolved)) {
                            SendValidationEvent(Res.Sch_InvalidSubstitutionMember, (element.QualifiedName).ToString(), (examplar.QualifiedName).ToString(), element);
                        }
                    }
                }
            }            
        }

        private void CompileGroup(XmlSchemaGroup group) {
            if (group.Validating) {
                SendValidationEvent(Res.Sch_GroupCircularRef, group);
                group.CanonicalParticle = XmlSchemaParticle.Empty;
            } 
            else {
                group.Validating = true;
                if (group.CanonicalParticle == null) { 
                    group.CanonicalParticle = CannonicalizeParticle(group.Particle, true, true); 
                }
                Debug.Assert(group.CanonicalParticle != null);
                group.Validating = false;
            }
        }

        private void CompileSimpleType(XmlSchemaSimpleType simpleType) {
            if (simpleType.Validating) {
                throw new XmlSchemaException(Res.Sch_TypeCircularRef, simpleType);
            }
            if (simpleType.ElementDecl != null) { // already compiled
                return;
            }
            simpleType.Validating = true;
            try {
                if (simpleType.Content is XmlSchemaSimpleTypeList) {
                    XmlSchemaSimpleTypeList list = (XmlSchemaSimpleTypeList)simpleType.Content;
                    XmlSchemaDatatype datatype;
                    simpleType.SetBaseSchemaType(XmlSchemaDatatype.AnySimpleType);
                    if (list.ItemTypeName.IsEmpty) {
                        CompileSimpleType(list.ItemType);
                        datatype = list.ItemType.Datatype;
                    }
                    else {
                        datatype = GetDatatype(list.ItemTypeName);
                        if (datatype == null) {
                            XmlSchemaSimpleType type = GetSimpleType(list.ItemTypeName);
                            if (type != null) {
                                if ((type.FinalResolved & XmlSchemaDerivationMethod.List) != 0) {
                                    SendValidationEvent(Res.Sch_BaseFinalList, simpleType);
                                }
                                datatype = type.Datatype;
                            }
                            else {
                                throw new XmlSchemaException(Res.Sch_UndeclaredSimpleType, list.ItemTypeName.ToString(), simpleType);   
                            }
                        }
                    }
                    simpleType.SetDatatype(datatype.DeriveByList());
                    simpleType.SetDerivedBy(XmlSchemaDerivationMethod.List);
                }
                else if (simpleType.Content is XmlSchemaSimpleTypeRestriction) {
                    XmlSchemaSimpleTypeRestriction restriction = (XmlSchemaSimpleTypeRestriction)simpleType.Content;
                    XmlSchemaDatatype datatype;
                    if (restriction.BaseTypeName.IsEmpty) {
                        CompileSimpleType(restriction.BaseType);
                        simpleType.SetBaseSchemaType(restriction.BaseType);
                        datatype = restriction.BaseType.Datatype;
                    }
                    else if (simpleType.Redefined != null && restriction.BaseTypeName == simpleType.Redefined.QualifiedName) {
                        CompileSimpleType((XmlSchemaSimpleType)simpleType.Redefined);
                        simpleType.SetBaseSchemaType(simpleType.Redefined.BaseSchemaType);
                        datatype = simpleType.Redefined.Datatype;
                    }
                    else {
			if (restriction.BaseTypeName.Name == "anySimpleType" && restriction.BaseTypeName.Namespace == this.schemaNames.NsXsd) {
                            throw new XmlSchemaException(Res.Sch_InvalidSimpleTypeRestriction, restriction.BaseTypeName.ToString(), simpleType);   
                        }
                        datatype = GetDatatype(restriction.BaseTypeName);
                        if (datatype != null) {
                            simpleType.SetBaseSchemaType(datatype);
                        }
                        else {
                            XmlSchemaSimpleType type = GetSimpleType(restriction.BaseTypeName);
                            if (type != null) {
                                if ((type.FinalResolved & XmlSchemaDerivationMethod.Restriction) != 0) {
                                    SendValidationEvent(Res.Sch_BaseFinalRestriction, simpleType);
                                }
                                simpleType.SetBaseSchemaType(type);
                                datatype = type.Datatype;
                            }
                            else {
                                throw new XmlSchemaException(Res.Sch_UndeclaredSimpleType, restriction.BaseTypeName.ToString(), simpleType);   
                            }
                        }
                    }
                    simpleType.SetDatatype(datatype.DeriveByRestriction(restriction.Facets, this.nameTable));
                    simpleType.SetDerivedBy(XmlSchemaDerivationMethod.Restriction);
                }
                else { //simpleType.Content is XmlSchemaSimpleTypeUnion
                    XmlSchemaSimpleTypeUnion union1 = (XmlSchemaSimpleTypeUnion)simpleType.Content;
                    int baseTypeCount = 0;
                    ArrayList expandedMembers = new ArrayList();
                    ArrayList expandedBaseTypes = new ArrayList();

                    MemberTypesList(union1.MemberTypes, ref expandedMembers, ref expandedBaseTypes);
                    BaseTypesList(union1.BaseTypes, ref expandedBaseTypes, ref expandedMembers);
                    baseTypeCount = expandedMembers.Count;
                    baseTypeCount += expandedBaseTypes.Count;

                    object[] baseTypes = new object[baseTypeCount];
                    XmlSchemaDatatype[] baseDatatypes = new XmlSchemaDatatype[baseTypeCount];
                    int idx = 0;
                    
                    foreach (XmlQualifiedName qname in expandedMembers) {
                        XmlSchemaDatatype datatype = GetDatatype(qname);
                        if (datatype != null) {
                            baseTypes[idx] = datatype;
                            baseDatatypes[idx ++] = datatype;
                        }
                        else {
                            XmlSchemaSimpleType type = GetSimpleType(qname);
                            if (type != null) {
                                if ((type.FinalResolved & XmlSchemaDerivationMethod.Union) != 0) {
                                    SendValidationEvent(Res.Sch_BaseFinalUnion, simpleType);
                                }
                                baseTypes[idx] = type;
                                baseDatatypes[idx ++] = type.Datatype;
                            }
                            else {
                                throw new XmlSchemaException(Res.Sch_UndeclaredSimpleType, qname.ToString(), simpleType);   
                            }
                        }
                    }
                    
                    foreach (XmlSchemaSimpleType st in expandedBaseTypes) {
                        CompileSimpleType(st);
                        baseTypes[idx] = st;
                        baseDatatypes[idx ++] = st.Datatype;
                    }
                    simpleType.SetBaseSchemaType(XmlSchemaDatatype.AnySimpleType);
                    simpleType.SetDatatype(XmlSchemaDatatype.DeriveByUnion(baseDatatypes));
                    simpleType.SetDerivedBy(XmlSchemaDerivationMethod.Union);
                }
            } 
            catch (XmlSchemaException e) {
                if (e.SourceSchemaObject == null) {
                    e.SetSource(simpleType);
                }
                SendValidationEvent(e);
                simpleType.SetDatatype(XmlSchemaDatatype.AnyType);
            } 
            finally {
                SchemaElementDecl decl = new SchemaElementDecl();
                decl.Content = new CompiledContentModel(this.schemaNames);
                decl.Content.ContentType = CompiledContentModel.Type.Text;
                decl.SchemaType = simpleType;
                decl.Datatype = simpleType.Datatype;
                simpleType.ElementDecl = decl;
                simpleType.Validating = false;
            }
        }

	private void MemberTypesList(Array mainMemberTypes, ref ArrayList allMemberTypes, ref ArrayList allBaseTypes) {
            if (mainMemberTypes != null) {
                foreach (XmlQualifiedName qname in mainMemberTypes) {
                    XmlSchemaSimpleType type = GetSimpleType(qname);
                    if (type != null && type.Content is XmlSchemaSimpleTypeUnion) {
                        XmlSchemaSimpleTypeUnion union2 = (XmlSchemaSimpleTypeUnion)type.Content;
                        if(union2.BaseTypes != null) {
                            BaseTypesList(union2.BaseTypes, ref allBaseTypes, ref allMemberTypes);
                        }
                        MemberTypesList(union2.MemberTypes, ref allMemberTypes, ref allBaseTypes);

                    }
                    else {
                        if(!allMemberTypes.Contains(qname))
                            allMemberTypes.Add(qname);
                    }
                   
                }
            }
        }

        private void BaseTypesList(XmlSchemaObjectCollection mainBaseTypes, ref ArrayList allBaseTypes, ref ArrayList allMemberTypes) {
            if (mainBaseTypes != null) {
                foreach (XmlSchemaSimpleType st in mainBaseTypes) {
                    if (st.Content != null && st.Content is XmlSchemaSimpleTypeUnion) {
                        XmlSchemaSimpleTypeUnion union3 = (XmlSchemaSimpleTypeUnion)st.Content;
                        if (union3.MemberTypes != null) {
                            MemberTypesList(union3.MemberTypes, ref allMemberTypes, ref allBaseTypes);
                        }
                        BaseTypesList(union3.BaseTypes, ref allBaseTypes, ref allMemberTypes);
                    }
                    else {
                        if(!allBaseTypes.Contains(st))
                            allBaseTypes.Add(st);
                    }
                }
            }
        }

        private void CompileComplexType(XmlSchemaComplexType complexType) {
            if (complexType.ElementDecl != null) { //already compiled
                return;
            }
            if (complexType.Validating) {
                SendValidationEvent(Res.Sch_TypeCircularRef, complexType);
                return;
            }
            complexType.Validating = true;

            CompiledContentModel compiledContentModel = new CompiledContentModel(this.schemaNames);
            if (complexType.ContentModel != null) { //simpleContent or complexContent
                if (complexType.ContentModel is XmlSchemaSimpleContent) {
                    XmlSchemaSimpleContent simpleContent = (XmlSchemaSimpleContent)complexType.ContentModel;
                    complexType.SetContentType(XmlSchemaContentType.TextOnly);
                    if (simpleContent.Content is XmlSchemaSimpleContentExtension) {
                        CompileSimpleContentExtension(complexType, (XmlSchemaSimpleContentExtension)simpleContent.Content);
                    }
                    else { //simpleContent.Content is XmlSchemaSimpleContentRestriction
                        CompileSimpleContentRestriction(complexType, (XmlSchemaSimpleContentRestriction)simpleContent.Content);
                    }
                }
                else { // complexType.ContentModel is XmlSchemaComplexContent
                    XmlSchemaComplexContent complexContent = (XmlSchemaComplexContent)complexType.ContentModel;
                    if (complexContent.Content is XmlSchemaComplexContentExtension) {
                        CompileComplexContentExtension(complexType, complexContent, (XmlSchemaComplexContentExtension)complexContent.Content);
                    }
                    else { // complexContent.Content is XmlSchemaComplexContentRestriction
                        CompileComplexContentRestriction(complexType, complexContent, (XmlSchemaComplexContentRestriction)complexContent.Content);
                    }
                    CompileComplexContent(complexType, compiledContentModel);
                }
            }
            else { //equals XmlSchemaComplexContent with baseType is anyType
                complexType.SetBaseSchemaType(XmlSchemaComplexType.AnyType);
                CompileLocalAttributes(XmlSchemaComplexType.AnyType, complexType, complexType.Attributes, complexType.AnyAttribute, XmlSchemaDerivationMethod.Restriction);
                complexType.SetDerivedBy(XmlSchemaDerivationMethod.Restriction);
                complexType.SetContentTypeParticle(CompileContentTypeParticle(complexType.Particle, true));
                complexType.SetContentType(GetSchemaContentType(complexType, null, complexType.ContentTypeParticle));
                CompileComplexContent(complexType, compiledContentModel);
            }
            bool hasID = false;
            foreach(XmlSchemaAttribute attribute in complexType.AttributeUses.Values) {
                if (attribute.Use != XmlSchemaUse.Prohibited) {
                    XmlSchemaDatatype datatype = attribute.Datatype;
                    if (datatype != null && datatype.TokenizedType == XmlTokenizedType.ID) {
                        if (hasID) {
                            SendValidationEvent(Res.Sch_TwoIdAttrUses, complexType);
                        }
                        else {
                            hasID = true;
                        }
                    }
                }
            }

            SchemaElementDecl decl = new SchemaElementDecl();
            decl.Content = compiledContentModel;
            decl.Content = compiledContentModel;
            decl.SchemaType = complexType;
            decl.Datatype = complexType.Datatype;
            decl.Block = complexType.BlockResolved;
            switch (complexType.ContentType) {
                case XmlSchemaContentType.TextOnly :    decl.Content.ContentType = CompiledContentModel.Type.Text;          break;
                case XmlSchemaContentType.Empty :       decl.Content.ContentType = CompiledContentModel.Type.Empty;         break;
                case XmlSchemaContentType.ElementOnly : decl.Content.ContentType = CompiledContentModel.Type.ElementOnly;   break;
                default:                                decl.Content.ContentType = CompiledContentModel.Type.Mixed;         break;
            }
            decl.AnyAttribute = complexType.AttributeWildcard;
            foreach(XmlSchemaAttribute attribute in complexType.AttributeUses.Values) {
                if (attribute.Use == XmlSchemaUse.Prohibited) {
                    if (decl.ProhibitedAttributes[attribute.QualifiedName] == null) {
                        decl.ProhibitedAttributes.Add(attribute.QualifiedName, attribute.QualifiedName);
                    }
                }
                else {
                    if (decl.AttDefs[attribute.QualifiedName] == null && attribute.AttDef != null && attribute.AttDef.Name != XmlQualifiedName.Empty && attribute.AttDef != SchemaAttDef.Empty) {
                        decl.AddAttDef(attribute.AttDef);
                    }
                }
            }
            complexType.ElementDecl = decl;

            complexType.Validating = false;
        }


        private void CompileSimpleContentExtension(XmlSchemaComplexType complexType, XmlSchemaSimpleContentExtension simpleExtension) {
            XmlSchemaComplexType baseType = null;
            if (complexType.Redefined != null && simpleExtension.BaseTypeName == complexType.Redefined.QualifiedName) {
                baseType = (XmlSchemaComplexType)complexType.Redefined;
                CompileComplexType(baseType);
                complexType.SetBaseSchemaType(baseType);
                complexType.SetDatatype(baseType.Datatype);
            }
            else {
                XmlSchemaDatatype datatype = null;
                object bto = GetAnySchemaType(simpleExtension.BaseTypeName, out datatype);
                if (bto == null || datatype == null) {
                    SendValidationEvent(Res.Sch_UndeclaredType, simpleExtension.BaseTypeName.ToString(), complexType);   
                } 
                else {
                    complexType.SetBaseSchemaType(bto);
                    complexType.SetDatatype(datatype);
                }
                baseType = bto as XmlSchemaComplexType;
            }
            if (baseType != null) {
                if ((baseType.FinalResolved & XmlSchemaDerivationMethod.Extension) != 0) {
                    SendValidationEvent(Res.Sch_BaseFinalExtension, complexType);
                }
                if (baseType.ContentType != XmlSchemaContentType.TextOnly) {
                    SendValidationEvent(Res.Sch_NotSimpleContent, complexType);
                }
            } 
            complexType.SetDerivedBy(XmlSchemaDerivationMethod.Extension);
            CompileLocalAttributes(baseType, complexType, simpleExtension.Attributes, simpleExtension.AnyAttribute, XmlSchemaDerivationMethod.Extension);
        }

        private void CompileSimpleContentRestriction(XmlSchemaComplexType complexType, XmlSchemaSimpleContentRestriction simpleRestriction) {
            XmlSchemaComplexType baseType = null;
            XmlSchemaDatatype datatype = null;
            if (complexType.Redefined != null && simpleRestriction.BaseTypeName == complexType.Redefined.QualifiedName) {
                baseType = (XmlSchemaComplexType)complexType.Redefined;
                CompileComplexType(baseType);
                datatype = baseType.Datatype;
            }
            else {
                baseType = GetComplexType(simpleRestriction.BaseTypeName);
                if (baseType == null) {
                    SendValidationEvent(Res.Sch_UndefBaseRestriction, simpleRestriction.BaseTypeName.ToString(), simpleRestriction);
                    return;
                }
                if (baseType.ContentType == XmlSchemaContentType.TextOnly) {
                    if (simpleRestriction.BaseType == null) { 
                        datatype = baseType.Datatype;
                    }
                    else {
                        CompileSimpleType(simpleRestriction.BaseType);
                        if(!XmlSchemaType.IsDerivedFrom(simpleRestriction.BaseType, baseType.Datatype, XmlSchemaDerivationMethod.None)) {
                           SendValidationEvent(Res.Sch_DerivedNotFromBase, simpleRestriction);
                        }
                        datatype = simpleRestriction.BaseType.Datatype;
                    }
                }
                else if (baseType.ContentType == XmlSchemaContentType.Mixed && baseType.ElementDecl.Content.IsEmptiable) {
                    if (simpleRestriction.BaseType != null) {
                        CompileSimpleType(simpleRestriction.BaseType);
                        complexType.SetBaseSchemaType(simpleRestriction.BaseType);
                        datatype = simpleRestriction.BaseType.Datatype;
                    }
                    else {
                        SendValidationEvent(Res.Sch_NeedSimpleTypeChild, simpleRestriction);
                    }
                }
                else {
                    SendValidationEvent(Res.Sch_NotSimpleContent, complexType);
                }
            }
            if (baseType != null && baseType.ElementDecl != null) {
                if ((baseType.FinalResolved & XmlSchemaDerivationMethod.Restriction) != 0) {
                    SendValidationEvent(Res.Sch_BaseFinalRestriction, complexType);
                }
            }
            complexType.SetBaseSchemaType(baseType);
            if (datatype != null) {
                try {
                    complexType.SetDatatype(datatype.DeriveByRestriction(simpleRestriction.Facets, this.nameTable));
                }
                catch (XmlSchemaException e) {
                    if (e.SourceSchemaObject == null) {
                        e.SetSource(complexType);
                    }
                    SendValidationEvent(e);
                    complexType.SetDatatype(XmlSchemaDatatype.AnyType);
                } 
            }
            complexType.SetDerivedBy(XmlSchemaDerivationMethod.Restriction);
            CompileLocalAttributes(baseType, complexType, simpleRestriction.Attributes, simpleRestriction.AnyAttribute, XmlSchemaDerivationMethod.Restriction);
        }

        private void CompileComplexContentExtension(XmlSchemaComplexType complexType, XmlSchemaComplexContent complexContent, XmlSchemaComplexContentExtension complexExtension) {
            XmlSchemaComplexType baseType = null;
            if (complexType.Redefined != null && complexExtension.BaseTypeName == complexType.Redefined.QualifiedName) {
                baseType = (XmlSchemaComplexType)complexType.Redefined;
                CompileComplexType(baseType);
            }
            else {
                baseType = GetComplexType(complexExtension.BaseTypeName);
                if (baseType == null) {
                    SendValidationEvent(Res.Sch_UndefBaseExtension, complexExtension.BaseTypeName.ToString(), complexExtension);   
                    return;
                }
            }
            if (baseType != null && baseType.ElementDecl != null) {
                if (baseType.ContentType == XmlSchemaContentType.TextOnly) {
                    SendValidationEvent(Res.Sch_NotComplexContent, complexType);
                }
            }
            complexType.SetBaseSchemaType(baseType);
            if ((baseType.FinalResolved & XmlSchemaDerivationMethod.Extension) != 0) {
                SendValidationEvent(Res.Sch_BaseFinalExtension, complexType);
            }
            CompileLocalAttributes(baseType, complexType, complexExtension.Attributes, complexExtension.AnyAttribute, XmlSchemaDerivationMethod.Extension);

            XmlSchemaParticle baseParticle = baseType.ContentTypeParticle;
            XmlSchemaParticle extendedParticle = CannonicalizeParticle(complexExtension.Particle, true, true);
            if (baseParticle != XmlSchemaParticle.Empty) {
                if (extendedParticle != XmlSchemaParticle.Empty) {
                    XmlSchemaSequence compiledParticle = new XmlSchemaSequence();
                    compiledParticle.Items.Add(baseParticle);
                    compiledParticle.Items.Add(extendedParticle);
                    complexType.SetContentTypeParticle(CompileContentTypeParticle(compiledParticle, false));
                }
                else {
                    complexType.SetContentTypeParticle(baseParticle);
                }
                complexType.SetContentType(GetSchemaContentType(complexType, complexContent, complexType.ContentTypeParticle));
                if (complexType.ContentType != baseType.ContentType) {
                    SendValidationEvent(Res.Sch_DifContentType, complexType);
                }
            }
            else {
                complexType.SetContentTypeParticle(extendedParticle);
                complexType.SetContentType(GetSchemaContentType(complexType, complexContent, complexType.ContentTypeParticle));
            }
            complexType.SetDerivedBy(XmlSchemaDerivationMethod.Extension);
        }

        private void CompileComplexContentRestriction(XmlSchemaComplexType complexType, XmlSchemaComplexContent complexContent, XmlSchemaComplexContentRestriction complexRestriction) {
            XmlSchemaComplexType baseType = null;
            if (complexType.Redefined != null && complexRestriction.BaseTypeName == complexType.Redefined.QualifiedName) {
                baseType = (XmlSchemaComplexType)complexType.Redefined;
                CompileComplexType(baseType);
            }
            else {
                baseType = GetComplexType(complexRestriction.BaseTypeName);
                if (baseType == null) {
                    SendValidationEvent(Res.Sch_UndefBaseRestriction, complexRestriction.BaseTypeName.ToString(), complexRestriction);   
                    return;
                }
            } 
            if (baseType != null && baseType.ElementDecl != null) {
                if (baseType.ContentType == XmlSchemaContentType.TextOnly) {
                    SendValidationEvent(Res.Sch_NotComplexContent, complexType);
                }
            }
            complexType.SetBaseSchemaType(baseType);
            if ((baseType.FinalResolved & XmlSchemaDerivationMethod.Restriction) != 0) {
                SendValidationEvent(Res.Sch_BaseFinalRestriction, complexType);
            }
            CompileLocalAttributes(baseType, complexType, complexRestriction.Attributes, complexRestriction.AnyAttribute, XmlSchemaDerivationMethod.Restriction);
            
            complexType.SetContentTypeParticle(CompileContentTypeParticle(complexRestriction.Particle, true));
            complexType.SetContentType(GetSchemaContentType(complexType, complexContent, complexType.ContentTypeParticle));
            if (complexType.ContentType == XmlSchemaContentType.Empty) {
                if (baseType.ElementDecl != null && !baseType.ElementDecl.Content.IsEmptiable) {
                    SendValidationEvent(Res.Sch_InvalidContentRestriction, complexType);
                }
            }
            complexType.SetDerivedBy(XmlSchemaDerivationMethod.Restriction);
        }

        private void CheckParticleDerivation(XmlSchemaComplexType complexType) {
            XmlSchemaComplexType baseType = complexType.BaseSchemaType as XmlSchemaComplexType;
            if (baseType != null && baseType != XmlSchemaComplexType.AnyType && complexType.DerivedBy == XmlSchemaDerivationMethod.Restriction) {
                if (!IsValidRestriction(complexType.ContentTypeParticle, baseType.ContentTypeParticle)) {
#if DEBUG
                    if(complexType.ContentTypeParticle != null && baseType.ContentTypeParticle != null) {
                        string position = string.Empty;
                        if (complexType.SourceUri != null) {
                            position = " in " + complexType.SourceUri + "(" + complexType.LineNumber + ", " + complexType.LinePosition + ")";
                        }
                        Debug.WriteLineIf(CompModSwitches.XmlSchema.TraceError, "Invalid complexType content restriction" + position);
                        Debug.WriteLineIf(CompModSwitches.XmlSchema.TraceError, "     Base    " + DumpContentModel(baseType.ContentTypeParticle));
                        Debug.WriteLineIf(CompModSwitches.XmlSchema.TraceError, "     Derived " + DumpContentModel(complexType.ContentTypeParticle));
                    }
#endif
                    SendValidationEvent(Res.Sch_InvalidParticleRestriction, complexType);
                }
            }
        }

        private XmlSchemaParticle CompileContentTypeParticle(XmlSchemaParticle particle, bool substitution) {
            XmlSchemaParticle ctp = CannonicalizeParticle(particle, true, substitution);
            XmlSchemaChoice choice = ctp as XmlSchemaChoice;
            if (choice != null && choice.Items.Count == 0) {
                if (choice.MinOccurs != decimal.Zero) {
                    SendValidationEvent(Res.Sch_EmptyChoice, choice, XmlSeverityType.Warning);
                }
                return XmlSchemaParticle.Empty;
            }
            return ctp;
        }

        private XmlSchemaParticle CannonicalizeParticle(XmlSchemaParticle particle, bool root, bool substitution) {
            if (particle == null || particle.IsEmpty) {
                return XmlSchemaParticle.Empty;
            }
            else if (particle is XmlSchemaElement) {
                return CannonicalizeElement((XmlSchemaElement)particle, substitution);
            }
            else if (particle is XmlSchemaGroupRef) {
                return CannonicalizeGroupRef((XmlSchemaGroupRef)particle, root, substitution);
            }
            else if (particle is XmlSchemaAll) {
                return CannonicalizeAll((XmlSchemaAll)particle, root, substitution);
            }
            else if (particle is XmlSchemaChoice) {
                return CannonicalizeChoice((XmlSchemaChoice)particle, root, substitution);
            }
            else if (particle is XmlSchemaSequence) {
                return CannonicalizeSequence((XmlSchemaSequence)particle, root, substitution);
            }
            else {
                return particle;
            }
        }

        private XmlSchemaParticle CannonicalizeElement(XmlSchemaElement element, bool substitution) {
            if (!element.RefName.IsEmpty && substitution && (element.BlockResolved & XmlSchemaDerivationMethod.Substitution) == 0) {
                XmlSchemaSubstitutionGroup substitutionGroup = (XmlSchemaSubstitutionGroup)this.schema.Examplars[element.QualifiedName];
                if (substitutionGroup == null) {
                    return element;
                }
                else { 
                    XmlSchemaChoice choice = substitutionGroup.Choice.Clone();
                    choice.MinOccurs = element.MinOccurs;
                    choice.MaxOccurs = element.MaxOccurs;
                    return choice;
                }
            }
            else {
                return element;
            }
        }

        private XmlSchemaParticle CannonicalizeGroupRef(XmlSchemaGroupRef groupRef, bool root,  bool substitution) {
            XmlSchemaGroup group;
            if (groupRef.Redefined != null) {
                group = groupRef.Redefined;
            }
            else {
                group = (XmlSchemaGroup)this.schema.Groups[groupRef.RefName];
            }
            if (group == null) {
                SendValidationEvent(Res.Sch_UndefGroupRef, groupRef.RefName.ToString(), groupRef);
                return XmlSchemaParticle.Empty;
            }
            if (group.CanonicalParticle == null) {
                CompileGroup(group);
            }
            if (group.CanonicalParticle == XmlSchemaParticle.Empty) {
                return XmlSchemaParticle.Empty;
            }
            XmlSchemaGroupBase groupBase = (XmlSchemaGroupBase)group.CanonicalParticle;
            if (groupBase is XmlSchemaAll) {
                if (!root) {
                    SendValidationEvent(Res.Sch_AllRefNotRoot, "", groupRef);
                    return XmlSchemaParticle.Empty;
                }
                if (groupRef.MinOccurs != decimal.One || groupRef.MaxOccurs != decimal.One) {
                    SendValidationEvent(Res.Sch_AllRefMinMax, groupRef);
                    return XmlSchemaParticle.Empty;
                }
            }
            else if (groupBase is XmlSchemaChoice && groupBase.Items.Count == 0) {
                if (groupRef.MinOccurs != decimal.Zero) {
                    SendValidationEvent(Res.Sch_EmptyChoice, groupRef, XmlSeverityType.Warning);
                }
                return XmlSchemaParticle.Empty;
            }
            XmlSchemaGroupBase groupRefBase = (
                (groupBase is XmlSchemaSequence) ? (XmlSchemaGroupBase)new XmlSchemaSequence() :
                (groupBase is XmlSchemaChoice)   ? (XmlSchemaGroupBase)new XmlSchemaChoice() :
                                                   (XmlSchemaGroupBase)new XmlSchemaAll()
            );
            groupRefBase.MinOccurs = groupRef.MinOccurs;
            groupRefBase.MaxOccurs = groupRef.MaxOccurs;
            foreach (XmlSchemaParticle particle in groupBase.Items) {
                groupRefBase.Items.Add(particle);
            }
            groupRef.SetParticle(groupRefBase);
            return groupRefBase;
        }

        private XmlSchemaParticle CannonicalizeAll(XmlSchemaAll all, bool root, bool substitution) {
            if (all.Items.Count > 0) {
                XmlSchemaAll newAll = new XmlSchemaAll();
                newAll.MinOccurs = all.MinOccurs;
                newAll.MaxOccurs = all.MaxOccurs;
                newAll.SourceUri = all.SourceUri; // all is the only one that might need and error message
                newAll.LineNumber = all.LineNumber;
                newAll.LinePosition = all.LinePosition;
                foreach (XmlSchemaElement e in all.Items) {
                    XmlSchemaParticle p = CannonicalizeParticle(e, false, substitution);
                    if (p != XmlSchemaParticle.Empty) {
                        newAll.Items.Add(p);
                    }
                }
                all = newAll;
            }
            if (all.Items.Count == 0) {
                return XmlSchemaParticle.Empty;
            }
            else if (root && all.Items.Count == 1) {
                XmlSchemaSequence newSequence = new XmlSchemaSequence();
                newSequence.MinOccurs = all.MinOccurs;
                newSequence.MaxOccurs = all.MaxOccurs;
                newSequence.Items.Add((XmlSchemaParticle)all.Items[0]);
                return newSequence;
            }
            else if (!root && all.Items.Count == 1 && all.MinOccurs == decimal.One && all.MaxOccurs == decimal.One) {
                return (XmlSchemaParticle)all.Items[0];
            }
            else if (!root) {
                SendValidationEvent(Res.Sch_NotAllAlone, all);
                return XmlSchemaParticle.Empty;
            }
            else {
                return all;
            }
        }

        private XmlSchemaParticle CannonicalizeChoice(XmlSchemaChoice choice, bool root, bool substitution) {
            XmlSchemaChoice oldChoice = choice;
            if (choice.Items.Count > 0) {
                XmlSchemaChoice newChoice = new XmlSchemaChoice();
                newChoice.MinOccurs = choice.MinOccurs;
                newChoice.MaxOccurs = choice.MaxOccurs;
                foreach (XmlSchemaParticle p in choice.Items) {
                    XmlSchemaParticle p1 = CannonicalizeParticle(p, false, substitution);
                    if (p1 != XmlSchemaParticle.Empty) {
                        if (p1.MinOccurs == decimal.One && p1.MaxOccurs == decimal.One && p1 is XmlSchemaChoice) {
                            foreach (XmlSchemaParticle p2 in ((XmlSchemaChoice)p1).Items) {
                                newChoice.Items.Add(p2);
                            }
                        }
                        else {
                            newChoice.Items.Add(p1);
                        }
                    }
                }
                choice = newChoice;
            }
            if (!root && choice.Items.Count == 0) {
                if (choice.MinOccurs != decimal.Zero) {
                    SendValidationEvent(Res.Sch_EmptyChoice, oldChoice, XmlSeverityType.Warning);
                }
                return XmlSchemaParticle.Empty;
            }
            else if (!root && choice.Items.Count == 1 && choice.MinOccurs == decimal.One && choice.MaxOccurs == decimal.One) {
                return (XmlSchemaParticle)choice.Items[0];
            }
            else {
                return choice;
            }
        }

        private XmlSchemaParticle CannonicalizeSequence(XmlSchemaSequence sequence, bool root, bool substitution) {
            if (sequence.Items.Count > 0) {
                XmlSchemaSequence newSequence = new XmlSchemaSequence();
                newSequence.MinOccurs = sequence.MinOccurs;
                newSequence.MaxOccurs = sequence.MaxOccurs;
                foreach (XmlSchemaParticle p in sequence.Items) {
                    XmlSchemaParticle p1 = CannonicalizeParticle(p, false, substitution);
                    if (p1 != XmlSchemaParticle.Empty) {
                        if (p1.MinOccurs == decimal.One && p1.MaxOccurs == decimal.One && p1 is XmlSchemaSequence) {
                            foreach (XmlSchemaParticle p2 in ((XmlSchemaSequence)p1).Items) {
                                newSequence.Items.Add(p2);
                            }
                        }
                        else {
                            newSequence.Items.Add(p1);
                        }
                    }
                }
                sequence = newSequence;
            }
            if (sequence.Items.Count == 0) {
                return XmlSchemaParticle.Empty;
            }
            else if (!root && sequence.Items.Count == 1 && sequence.MinOccurs == decimal.One && sequence.MaxOccurs == decimal.One) {
                return (XmlSchemaParticle)sequence.Items[0];
            }
            else {
                return sequence;
            }
        }

        private bool IsValidRestriction(XmlSchemaParticle derivedParticle, XmlSchemaParticle baseParticle) {
            if (derivedParticle == baseParticle) {
                return true;
            }
            else if (derivedParticle == null || derivedParticle == XmlSchemaParticle.Empty) {
                return IsParticleEmptiable(baseParticle);
            }
            else if (baseParticle == null || baseParticle == XmlSchemaParticle.Empty) {
                return false;
            }
            if (baseParticle is XmlSchemaElement) {
                if (derivedParticle is XmlSchemaElement) {
                    return IsElementFromElement((XmlSchemaElement)derivedParticle, (XmlSchemaElement)baseParticle);
                }
                else {
                    return false;
                }
            }
            else if (baseParticle is XmlSchemaAny) {
                if (derivedParticle is XmlSchemaElement) {
                    return IsElementFromAny((XmlSchemaElement)derivedParticle, (XmlSchemaAny)baseParticle);
                }
                else if (derivedParticle is XmlSchemaAny) {
                    return IsAnyFromAny((XmlSchemaAny)derivedParticle, (XmlSchemaAny)baseParticle);
                }
                else {
                    return IsGroupBaseFromAny((XmlSchemaGroupBase)derivedParticle, (XmlSchemaAny)baseParticle);
                }
            }
            else if (baseParticle is XmlSchemaAll) {
                if (derivedParticle is XmlSchemaElement) {
                    return IsElementFromGroupBase((XmlSchemaElement)derivedParticle, (XmlSchemaGroupBase)baseParticle, true);
                }
                else if (derivedParticle is XmlSchemaAll) {
                    return IsGroupBaseFromGroupBase((XmlSchemaGroupBase)derivedParticle, (XmlSchemaGroupBase)baseParticle, true);
                }
                else if (derivedParticle is XmlSchemaSequence) {
                    return IsSequenceFromAll((XmlSchemaSequence)derivedParticle, (XmlSchemaAll)baseParticle);
                }
            }
            else if (baseParticle is XmlSchemaChoice ) {
                if (derivedParticle is XmlSchemaElement) {
                    return IsElementFromGroupBase((XmlSchemaElement)derivedParticle, (XmlSchemaGroupBase)baseParticle, false);
                }
                else if (derivedParticle is XmlSchemaChoice) {
                    return IsGroupBaseFromGroupBase((XmlSchemaGroupBase)derivedParticle, (XmlSchemaGroupBase)baseParticle, false);
                }
                else if (derivedParticle is XmlSchemaSequence) {
                    return IsSequenceFromChoice((XmlSchemaSequence)derivedParticle, (XmlSchemaChoice)baseParticle);
                }
            }
            else if (baseParticle is XmlSchemaSequence) {
                if (derivedParticle is XmlSchemaElement) {
                    return IsElementFromGroupBase((XmlSchemaElement)derivedParticle, (XmlSchemaGroupBase)baseParticle, true);
                }
                else if (derivedParticle is XmlSchemaSequence) {
                    return IsGroupBaseFromGroupBase((XmlSchemaGroupBase)derivedParticle, (XmlSchemaGroupBase)baseParticle, true);
                }
            }
            else {
                Debug.Assert(false);
            }

            return false;
        }

        private bool IsElementFromElement(XmlSchemaElement derivedElement, XmlSchemaElement baseElement) {
            return  (derivedElement.QualifiedName == baseElement.QualifiedName) &&
                    (derivedElement.IsNillable == baseElement.IsNillable) &&
                    IsValidOccurrenceRangeRestriction(derivedElement, baseElement) &&
                    (baseElement.FixedValue == null || baseElement.FixedValue == derivedElement.FixedValue) &&
                    ((derivedElement.BlockResolved | baseElement.BlockResolved) ==  derivedElement.BlockResolved) &&
                    (derivedElement.ElementType != null) && (baseElement.ElementType != null) &&
                    XmlSchemaType.IsDerivedFrom(derivedElement.ElementType, baseElement.ElementType, ~XmlSchemaDerivationMethod.Restriction);
        }

        private bool IsElementFromAny(XmlSchemaElement derivedElement, XmlSchemaAny baseAny) {
            return baseAny.Allows(derivedElement.QualifiedName) &&
                IsValidOccurrenceRangeRestriction(derivedElement, baseAny);
        }

        private bool IsAnyFromAny(XmlSchemaAny derivedAny, XmlSchemaAny baseAny) {
            return IsValidOccurrenceRangeRestriction(derivedAny, baseAny) &&
                NamespaceList.IsSubset(derivedAny.NamespaceList, baseAny.NamespaceList);
        }

        private bool IsGroupBaseFromAny(XmlSchemaGroupBase derivedGroupBase, XmlSchemaAny baseAny) {
            decimal minOccurs, maxOccurs;
            CalculateEffectiveTotalRange(derivedGroupBase, out minOccurs, out maxOccurs);
            if (!IsValidOccurrenceRangeRestriction(minOccurs, maxOccurs, baseAny.MinOccurs, baseAny.MaxOccurs)) {
                return false;
            }
            // eliminate occurrance range check
            string minOccursAny = baseAny.MinOccursString;
            baseAny.MinOccurs = decimal.Zero;

            foreach (XmlSchemaParticle p in derivedGroupBase.Items) {
                if (!IsValidRestriction(p, baseAny)) {
                    baseAny.MinOccursString = minOccursAny;
                    return false;
                }
            }
            baseAny.MinOccursString = minOccursAny;
            return true;
        }

        private bool IsElementFromGroupBase(XmlSchemaElement derivedElement, XmlSchemaGroupBase baseGroupBase,  bool skipEmptableOnly) {
            bool isMatched = false;
            foreach(XmlSchemaParticle baseParticle in baseGroupBase.Items) {
                if (!isMatched) {
                    string minOccursElement = baseParticle.MinOccursString;
                    string maxOccursElement = baseParticle.MaxOccursString;
                    baseParticle.MinOccurs *= baseGroupBase.MinOccurs;
                    if ( baseParticle.MaxOccurs != decimal.MaxValue) {
                        if (baseGroupBase.MaxOccurs == decimal.MaxValue)
                             baseParticle.MaxOccurs = decimal.MaxValue;
                        else 
                             baseParticle.MaxOccurs *= baseGroupBase.MaxOccurs;
                    }
                    isMatched  = IsValidRestriction(derivedElement, baseParticle);
                    baseParticle.MinOccursString = minOccursElement;
                    baseParticle.MaxOccursString = maxOccursElement;
                }
                else if (skipEmptableOnly && !IsParticleEmptiable(baseParticle)) {
                    return false;
                }
            }
            return isMatched;
        }

        private bool IsGroupBaseFromGroupBase(XmlSchemaGroupBase derivedGroupBase, XmlSchemaGroupBase baseGroupBase,  bool skipEmptableOnly) {
            if (!IsValidOccurrenceRangeRestriction(derivedGroupBase, baseGroupBase) || derivedGroupBase.Items.Count > baseGroupBase.Items.Count) {
                return false;
            }
            int count = 0;
            foreach(XmlSchemaParticle baseParticle in baseGroupBase.Items) {
                if ((count < derivedGroupBase.Items.Count) && IsValidRestriction((XmlSchemaParticle)derivedGroupBase.Items[count], baseParticle)) {
                    count ++;
                }
                else if (skipEmptableOnly && !IsParticleEmptiable(baseParticle)) {
                    return false;
                }
            }
            if (count < derivedGroupBase.Items.Count) {
                return false;
            }
            return true;
        }

        private bool IsSequenceFromAll(XmlSchemaSequence derivedSequence, XmlSchemaAll baseAll) {
            if (!IsValidOccurrenceRangeRestriction(derivedSequence, baseAll) || derivedSequence.Items.Count > baseAll.Items.Count) {
                return false;
            }
            BitSet map = new BitSet(baseAll.Items.Count);
            foreach (XmlSchemaParticle p in derivedSequence.Items) {
                int i = GetMappingParticle(p, baseAll.Items);
                if (i >= 0) {
                    if (map.Get(i)) {
                        return false;
                    }
                    else {
                        map.Set(i);
                    }
                }
                else {
                    return false;
                }
            }
            for (int i = 0; i < baseAll.Items.Count; i++) {
                if (!map.Get(i) && !IsParticleEmptiable((XmlSchemaParticle)baseAll.Items[i])) {
                    return false;
                }
            }
            return true;
        }

        private bool IsSequenceFromChoice(XmlSchemaSequence derivedSequence, XmlSchemaChoice baseChoice) {
            decimal minOccurs, maxOccurs;
            CalculateSequenceRange(derivedSequence, out minOccurs, out maxOccurs);
            if (!IsValidOccurrenceRangeRestriction(minOccurs, maxOccurs, baseChoice.MinOccurs, baseChoice.MaxOccurs) || derivedSequence.Items.Count > baseChoice.Items.Count) {
                return false;
            }
            foreach (XmlSchemaParticle particle in derivedSequence.Items) {
                if (GetMappingParticle(particle, baseChoice.Items) < 0)
                    return false;
            }
            return true;
        }

        private void CalculateSequenceRange(XmlSchemaSequence sequence, out decimal minOccurs, out decimal maxOccurs) {
            minOccurs = decimal.Zero; maxOccurs = decimal.Zero;
            foreach (XmlSchemaParticle p in sequence.Items) {
                minOccurs += p.MinOccurs;
                if (p.MaxOccurs == decimal.MaxValue)
                    maxOccurs = decimal.MaxValue;
                else if (maxOccurs != decimal.MaxValue)
                    maxOccurs += p.MaxOccurs;
            }
            minOccurs *= sequence.MinOccurs;
            if (sequence.MaxOccurs == decimal.MaxValue) {
                maxOccurs = decimal.MaxValue;
            }
            else if (maxOccurs != decimal.MaxValue) {
                maxOccurs *= sequence.MaxOccurs;
            }
        }

        private bool IsValidOccurrenceRangeRestriction(XmlSchemaParticle derivedParticle, XmlSchemaParticle baseParticle) {
            return IsValidOccurrenceRangeRestriction(derivedParticle.MinOccurs, derivedParticle.MaxOccurs, baseParticle.MinOccurs, baseParticle.MaxOccurs);
        }

        private bool IsValidOccurrenceRangeRestriction(decimal minOccurs, decimal maxOccurs, decimal baseMinOccurs, decimal baseMaxOccurs) {
            return (baseMinOccurs <= minOccurs) && (maxOccurs <= baseMaxOccurs);
        }

        private int GetMappingParticle(XmlSchemaParticle particle, XmlSchemaObjectCollection collection) {
            for (int i = 0; i < collection.Count; i++) {
                if (IsValidRestriction(particle, (XmlSchemaParticle)collection[i]))
                    return i;
            }
            return -1;
        }

        private bool IsParticleEmptiable(XmlSchemaParticle particle) {
            decimal minOccurs, maxOccurs;
            CalculateEffectiveTotalRange(particle, out minOccurs, out maxOccurs);
            return minOccurs == decimal.Zero;
        }

        private void CalculateEffectiveTotalRange(XmlSchemaParticle particle, out decimal minOccurs, out decimal maxOccurs) {
            if (particle is XmlSchemaElement || particle is XmlSchemaAny) {
                minOccurs = particle.MinOccurs;
                maxOccurs = particle.MaxOccurs;
            }
            else if (particle is XmlSchemaChoice) {
                if (((XmlSchemaChoice)particle).Items.Count == 0) {
                    minOccurs = maxOccurs = decimal.Zero;
                }
                else {
                    minOccurs = decimal.MaxValue;
                    maxOccurs = decimal.Zero;
                    foreach (XmlSchemaParticle p in ((XmlSchemaChoice)particle).Items) {
                        decimal min, max;
                        CalculateEffectiveTotalRange(p, out min, out max);
                        if (min < minOccurs) {
                            minOccurs = min;
                        }
                        if (max > maxOccurs) {
                            maxOccurs = max;
                        }
                    }
                    minOccurs *= particle.MinOccurs;
                    if (maxOccurs != decimal.MaxValue) {
                        if (particle.MaxOccurs == decimal.MaxValue)
                            maxOccurs = decimal.MaxValue;
                        else 
                            maxOccurs *= particle.MaxOccurs;
                    }
                }
            }
            else {
                XmlSchemaObjectCollection collection = ((XmlSchemaGroupBase)particle).Items;
                if (collection.Count == 0) {
                    minOccurs = maxOccurs = decimal.Zero;
                }
                else {
                    minOccurs = 0;
                    maxOccurs = 0;
                    foreach (XmlSchemaParticle p in collection) {
                        decimal min, max;
                        CalculateEffectiveTotalRange(p, out min, out max);
                        minOccurs += min;
                        if (maxOccurs != decimal.MaxValue) {
                            if (max == decimal.MaxValue)
                                maxOccurs = decimal.MaxValue;
                            else 
                                maxOccurs += max;
                        }
                    }
                    minOccurs *= particle.MinOccurs;
                    if (maxOccurs != decimal.MaxValue) {
                        if (particle.MaxOccurs == decimal.MaxValue)
                            maxOccurs = decimal.MaxValue;
                        else 
                            maxOccurs *= particle.MaxOccurs;
                    }
                }
            }
        }

        private void PushComplexType(XmlSchemaComplexType complexType) {
            this.complexTypeStack.Push(complexType);
        }

        private XmlSchemaContentType GetSchemaContentType(XmlSchemaComplexType complexType, XmlSchemaComplexContent complexContent, XmlSchemaParticle particle) {
            if ((complexContent != null && complexContent.IsMixed) ||
                (complexContent == null && complexType.IsMixed)) {
                return XmlSchemaContentType.Mixed;      
            }
            else if (particle != null && !particle.IsEmpty) {
                return XmlSchemaContentType.ElementOnly;
            }
            else {                            
                return XmlSchemaContentType.Empty;                            
            }
        }

        private void CompileAttributeGroup(XmlSchemaAttributeGroup attributeGroup) {
            if (attributeGroup.Validating) {
                SendValidationEvent(Res.Sch_AttributeGroupCircularRef, attributeGroup);
                return;
            }
            if (attributeGroup.AttributeUses.Count > 0) {// already checked
                return;
            }
            attributeGroup.Validating = true;
            XmlSchemaAnyAttribute anyAttribute = attributeGroup.AnyAttribute;
            foreach (XmlSchemaObject obj in attributeGroup.Attributes) {
                if (obj is XmlSchemaAttribute) {
                    XmlSchemaAttribute attribute = (XmlSchemaAttribute)obj;
                    if (attribute.Use != XmlSchemaUse.Prohibited) {
                        CompileAttribute(attribute);
                    }
                    if (attributeGroup.AttributeUses[attribute.QualifiedName] == null) {
                        attributeGroup.AttributeUses.Add(attribute.QualifiedName, attribute);
                    }
                    else  {
                        SendValidationEvent(Res.Sch_DupAttributeUse, attribute.QualifiedName.ToString(), attribute);
                    }
                }
                else { // XmlSchemaAttributeGroupRef
                    XmlSchemaAttributeGroupRef attributeGroupRef = (XmlSchemaAttributeGroupRef)obj;
                    XmlSchemaAttributeGroup attributeGroupResolved;
                    if (attributeGroup.Redefined != null && attributeGroupRef.RefName == attributeGroup.Redefined.QualifiedName) {
                        attributeGroupResolved = (XmlSchemaAttributeGroup)attributeGroup.Redefined;
                    }
                    else {
                        attributeGroupResolved = (XmlSchemaAttributeGroup)this.schema.AttributeGroups[attributeGroupRef.RefName];
                    }
                    if (attributeGroupResolved != null) {
                        CompileAttributeGroup(attributeGroupResolved);
                        foreach (XmlSchemaAttribute attribute in attributeGroupResolved.AttributeUses.Values) {
                            if (attributeGroup.AttributeUses[attribute.QualifiedName] == null) {
                                attributeGroup.AttributeUses.Add(attribute.QualifiedName, attribute);
                            }
                            else {
                                SendValidationEvent(Res.Sch_DupAttributeUse, attribute.QualifiedName.ToString(), attribute);
                            }
                        }
                        anyAttribute = CompileAnyAttributeIntersection(anyAttribute, attributeGroupResolved.AttributeWildcard);
                    }
                    else {
                        SendValidationEvent(Res.Sch_UndefAttributeGroupRef, attributeGroupRef.RefName.ToString(), attributeGroupRef);
                    }
                }
            }          
            attributeGroup.AttributeWildcard = anyAttribute;
            attributeGroup.Validating = false;

        }


        private void CompileLocalAttributes(XmlSchemaComplexType baseType, XmlSchemaComplexType derivedType, XmlSchemaObjectCollection attributes, XmlSchemaAnyAttribute anyAttribute, XmlSchemaDerivationMethod derivedBy) {
            XmlSchemaAnyAttribute baseAttributeWildcard = baseType != null ? baseType.AttributeWildcard : null;       
            foreach (XmlSchemaObject obj in attributes) {
                if (obj is XmlSchemaAttribute) {
                    XmlSchemaAttribute attribute = (XmlSchemaAttribute)obj;
                    if (attribute.Use != XmlSchemaUse.Prohibited) {
                        CompileAttribute(attribute);
                    }
                    if (attribute.Use != XmlSchemaUse.Prohibited || 
                        (attribute.Use == XmlSchemaUse.Prohibited && derivedBy == XmlSchemaDerivationMethod.Restriction && baseType != XmlSchemaComplexType.AnyType)) {

                        if (derivedType.AttributeUses[attribute.QualifiedName] == null) {
                            derivedType.AttributeUses.Add(attribute.QualifiedName, attribute);
                        }
                        else  {
                            SendValidationEvent(Res.Sch_DupAttributeUse, attribute.QualifiedName.ToString(), attribute);
                        }
                    }
                    else {
                        SendValidationEvent(Res.Sch_AttributeIgnored, attribute.QualifiedName.ToString(), attribute, XmlSeverityType.Warning);
                    }
                }
                else { // is XmlSchemaAttributeGroupRef
                    XmlSchemaAttributeGroupRef attributeGroupRef = (XmlSchemaAttributeGroupRef)obj;
                    XmlSchemaAttributeGroup attributeGroup = (XmlSchemaAttributeGroup)this.schema.AttributeGroups[attributeGroupRef.RefName];
                    if (attributeGroup != null) {
                        CompileAttributeGroup(attributeGroup);
                        foreach (XmlSchemaAttribute attribute in attributeGroup.AttributeUses.Values) {
                          if (attribute.Use != XmlSchemaUse.Prohibited || 
                             (attribute.Use == XmlSchemaUse.Prohibited && derivedBy == XmlSchemaDerivationMethod.Restriction && baseType != XmlSchemaComplexType.AnyType)) {
                            if (derivedType.AttributeUses[attribute.QualifiedName] == null) {
                                derivedType.AttributeUses.Add(attribute.QualifiedName, attribute);
                            }
                            else {
                                SendValidationEvent(Res.Sch_DupAttributeUse, attribute.QualifiedName.ToString(), attributeGroupRef);
                            }
                          }
                          else {
                            SendValidationEvent(Res.Sch_AttributeIgnored, attribute.QualifiedName.ToString(), attribute, XmlSeverityType.Warning);
                          }
                        }
                        anyAttribute = CompileAnyAttributeIntersection(anyAttribute, attributeGroup.AttributeWildcard);
                    }
                    else {
                        SendValidationEvent(Res.Sch_UndefAttributeGroupRef, attributeGroupRef.RefName.ToString(), attributeGroupRef);
                    }
                }
            }
            
            // check derivation rules
            if (baseType != null) {
                if (derivedBy == XmlSchemaDerivationMethod.Extension) {
                    derivedType.SetAttributeWildcard(CompileAnyAttributeUnion(anyAttribute, baseAttributeWildcard));
                    foreach(XmlSchemaAttribute attributeBase in baseType.AttributeUses.Values) {
                        XmlSchemaAttribute attribute = (XmlSchemaAttribute)derivedType.AttributeUses[attributeBase.QualifiedName];
                        if (attribute != null) {
                            Debug.Assert(attribute.Use != XmlSchemaUse.Prohibited);
                            if (attribute.AttributeType != attributeBase.AttributeType || attributeBase.Use == XmlSchemaUse.Prohibited) {
                                SendValidationEvent(Res.Sch_InvalidAttributeExtension, attribute);
                            }
                        }
                        else {
                            derivedType.AttributeUses.Add(attributeBase.QualifiedName, attributeBase);
                        }
                    }
                }
                else {  // derivedBy == XmlSchemaDerivationMethod.Restriction
                    // Schema Component Constraint: Derivation Valid (Restriction, Complex)
                    if ((anyAttribute != null) && (baseAttributeWildcard == null || !XmlSchemaAnyAttribute.IsSubset(anyAttribute, baseAttributeWildcard))) {
                        SendValidationEvent(Res.Sch_InvalidAnyAttributeRestriction, derivedType);
                    }
                    else {
                        derivedType.SetAttributeWildcard(anyAttribute); //complete wildcard
                    }

                    // Add form the base
                    foreach(XmlSchemaAttribute attributeBase in baseType.AttributeUses.Values) {
                        XmlSchemaAttribute attribute = (XmlSchemaAttribute)derivedType.AttributeUses[attributeBase.QualifiedName];
                        if (attribute == null) {
                            derivedType.AttributeUses.Add(attributeBase.QualifiedName, attributeBase);
                        } 
                        else {
                            if (attributeBase.Use == XmlSchemaUse.Prohibited && attribute.Use != XmlSchemaUse.Prohibited) {
#if DEBUG
                                string position = string.Empty;
                                if (derivedType.SourceUri != null) {
                                    position = " in " + derivedType.SourceUri + "(" + derivedType.LineNumber + ", " + derivedType.LinePosition + ")";
                                }
                                Debug.WriteLineIf(CompModSwitches.XmlSchema.TraceError, "Invalid complexType attributes restriction" + position);
                                Debug.WriteLineIf(CompModSwitches.XmlSchema.TraceError, "     Base    " + DumpAttributes(baseType.AttributeUses, baseType.AttributeWildcard));
                                Debug.WriteLineIf(CompModSwitches.XmlSchema.TraceError, "     Derived " + DumpAttributes(derivedType.AttributeUses, derivedType.AttributeWildcard));
#endif
                                SendValidationEvent(Res.Sch_AttributeRestrictionProhibited, attribute);
                            } 
                            else if (attribute.Use == XmlSchemaUse.Prohibited) {
                                continue;
                            }
                            else if (attributeBase.AttributeType == null || attribute.AttributeType == null || !XmlSchemaType.IsDerivedFrom(attribute.AttributeType, attributeBase.AttributeType, XmlSchemaDerivationMethod.Empty)) {
                                SendValidationEvent(Res.Sch_AttributeRestrictionInvalid, attribute);
                            }
                        }
                    }

                    // Check additional ones are valid restriction of base's wildcard
                    foreach(XmlSchemaAttribute attribute in derivedType.AttributeUses.Values) {
                        XmlSchemaAttribute attributeBase = (XmlSchemaAttribute)baseType.AttributeUses[attribute.QualifiedName];
                        if (attributeBase != null) {
                            continue;
                        }
                        if (baseAttributeWildcard == null || !baseAttributeWildcard.Allows(attribute.QualifiedName)) {
#if DEBUG
                            string position = string.Empty;
                            if (derivedType.SourceUri != null) {
                                position = " in " + derivedType.SourceUri + "(" + derivedType.LineNumber + ", " + derivedType.LinePosition + ")";
                            }
                            Debug.WriteLineIf(CompModSwitches.XmlSchema.TraceError, "Invalid complexType attributes restriction" + position);
                            Debug.WriteLineIf(CompModSwitches.XmlSchema.TraceError, "     Base    " + DumpAttributes(baseType.AttributeUses, baseType.AttributeWildcard));
                            Debug.WriteLineIf(CompModSwitches.XmlSchema.TraceError, "     Derived " + DumpAttributes(derivedType.AttributeUses, derivedType.AttributeWildcard));
#endif
                            SendValidationEvent(Res.Sch_AttributeRestrictionInvalidFromWildcard, attribute);
                        }
                    }
                }
            }
            else {
                derivedType.SetAttributeWildcard(anyAttribute);
            }
        }

        

#if DEBUG
        private string DumpAttributes(XmlSchemaObjectTable attributeUses, XmlSchemaAnyAttribute attributeWildcard) {
            StringBuilder sb = new StringBuilder();
            sb.Append("[");
            bool first = true;
            foreach (XmlSchemaAttribute attribute in attributeUses.Values) {
                if (attribute.Use != XmlSchemaUse.Prohibited) {
                    if (first) {
                        first = false;
                    }
                    else {
                        sb.Append(" ");
                    }
                    sb.Append(attribute.QualifiedName.Name);       
                    if (attribute.Use == XmlSchemaUse.Optional) {
                        sb.Append("?");                                                                  
                    }
                }
            }
            if (attributeWildcard != null) {
                if (attributeUses.Count != 0) {
                    sb.Append(" ");                                                                  
                }
                sb.Append("<");
                sb.Append(attributeWildcard.NamespaceList.ToString());
                sb.Append(">");
            }
            sb.Append("] - [");
            first = true;
            foreach (XmlSchemaAttribute attribute in attributeUses.Values) {
                if (attribute.Use == XmlSchemaUse.Prohibited) {
                    if (first) {
                        first = false;
                    }
                    else {
                        sb.Append(" ");
                    }
                    sb.Append(attribute.QualifiedName.Name);       
                }
            }
            sb.Append("]");
            return sb.ToString();
        }
#endif

        private XmlSchemaAnyAttribute CompileAnyAttributeUnion(XmlSchemaAnyAttribute a, XmlSchemaAnyAttribute b) {
            if (a == null) {
                return b;
            }
            else if (b == null) {
                return a;
            }
            else {
                XmlSchemaAnyAttribute attribute = XmlSchemaAnyAttribute.Union(a, b);
                if (attribute == null) {
                    SendValidationEvent(Res.Sch_UnexpressibleAnyAttribute, a);
                }
                return attribute;
            }

        }

        private XmlSchemaAnyAttribute CompileAnyAttributeIntersection(XmlSchemaAnyAttribute a, XmlSchemaAnyAttribute b) {
            if (a == null) {
                return b;
            }
            else if (b == null) {
                return a;
            }
            else {
                XmlSchemaAnyAttribute attribute = XmlSchemaAnyAttribute.Intersection(a, b);
                if (attribute == null) {
                    SendValidationEvent(Res.Sch_UnexpressibleAnyAttribute, a);
                }
                return attribute;
            }
        }

         private void CompileAttribute(XmlSchemaAttribute xa) {
            if (xa.Validating) {
                SendValidationEvent(Res.Sch_AttributeCircularRef, xa);
                return;
            }
            if (xa.AttDef != null) { //already compiled?
                return;
            }
            xa.Validating = true;
            SchemaAttDef decl = null;
            try {
                if (!xa.RefName.IsEmpty) {
                    XmlSchemaAttribute a = (XmlSchemaAttribute)this.schema.Attributes[xa.RefName];
                    if (a == null) {
                        throw new XmlSchemaException(Res.Sch_UndeclaredAttribute, xa.RefName.ToString(), xa);
                    }     
                    CompileAttribute(a);
                    if (a.AttDef == null) {
                        throw new XmlSchemaException(Res.Sch_RefInvalidAttribute, xa.RefName.ToString(), xa);
                    }
                    decl = a.AttDef.Clone();
		            if(decl.Datatype != null) {
                        if(a.FixedValue != null) {
                            if(xa.DefaultValue != null) {
                                throw new XmlSchemaException(Res.Sch_FixedDefaultInRef, xa.RefName.ToString(), xa);
                            }
                            else if(xa.FixedValue != null ) {
                                if (xa.FixedValue != a.FixedValue) {
                                    throw new XmlSchemaException(Res.Sch_FixedInRef, xa.RefName.ToString(), xa);
                                }
                            }
                            else {
                                decl.Presence = SchemaDeclBase.Use.Fixed; 
                                decl.DefaultValueRaw = decl.DefaultValueExpanded = a.FixedValue;
                                decl.DefaultValueTyped = decl.Datatype.ParseValue(decl.DefaultValueRaw, this.nameTable, this.namespaceManager);
                            }
                        }
                        else if (a.DefaultValue != null) {
                            if(xa.DefaultValue == null && xa.FixedValue == null) {
                                decl.Presence = SchemaDeclBase.Use.Default; 
                                decl.DefaultValueRaw = decl.DefaultValueExpanded = a.DefaultValue;
                                decl.DefaultValueTyped = decl.Datatype.ParseValue(decl.DefaultValueRaw, this.nameTable, this.namespaceManager);
                            }
                        }
		            }	
                    xa.SetAttributeType(a.AttributeType);
                }
                else {
                    decl = new SchemaAttDef(xa.QualifiedName, xa.Prefix);
                    if (xa.SchemaType != null) {
                        CompileSimpleType(xa.SchemaType);
                        xa.SetAttributeType(xa.SchemaType);
                        decl.SchemaType = xa.SchemaType;
                        decl.Datatype = xa.SchemaType.Datatype;
                    }
                    else if (!xa.SchemaTypeName.IsEmpty) {
                        XmlSchemaDatatype datatype = GetDatatype(xa.SchemaTypeName);
                        if (datatype != null) {
                            xa.SetAttributeType(datatype);
                            decl.Datatype = datatype;
                        }
                        else {
                            XmlSchemaSimpleType type = GetSimpleType(xa.SchemaTypeName);
                            if (type != null) {
                                xa.SetAttributeType(type);
                                decl.SchemaType = type;
                                decl.Datatype = type.Datatype;
                            }
                            else {
                                throw new XmlSchemaException(Res.Sch_UndeclaredSimpleType, xa.SchemaTypeName.ToString(), xa);   
                            }
                        }
                    }
                    else {
                        decl.Datatype = XmlSchemaDatatype.AnyType;
                        xa.SetAttributeType(XmlSchemaDatatype.AnyType);
                    }
                }
                if (decl.Datatype != null) {
                    decl.Datatype.VerifySchemaValid(this.schema, xa);
                }
                if (xa.DefaultValue != null || xa.FixedValue != null) {
                    if (xa.DefaultValue != null) {
                        decl.Presence = SchemaDeclBase.Use.Default; 
                        decl.DefaultValueRaw = decl.DefaultValueExpanded = xa.DefaultValue;
                    }
                    else {
                        decl.Presence = SchemaDeclBase.Use.Fixed; 
                        decl.DefaultValueRaw = decl.DefaultValueExpanded = xa.FixedValue;
                    }
                    if(decl.Datatype != null) {
                        decl.DefaultValueTyped = decl.Datatype.ParseValue(decl.DefaultValueRaw, this.nameTable, this.namespaceManager);
                    }

                }
                else {
                    switch (xa.Use) {
                        case XmlSchemaUse.None: 
                        case XmlSchemaUse.Optional: 
                            decl.Presence = SchemaDeclBase.Use.Implied; 
                            break;
                        case XmlSchemaUse.Required: 
                            decl.Presence = SchemaDeclBase.Use.Required; 
                            break;
                        case XmlSchemaUse.Prohibited:
                            break;
                    }
                }
                xa.AttDef = decl;
            } 
            catch (XmlSchemaException e) {
                if (e.SourceSchemaObject == null) {
                    e.SetSource(xa);
                }
                SendValidationEvent(e);
                xa.AttDef = SchemaAttDef.Empty;
            } 
            finally {
                xa.Validating = false;
            }
        }

        private void CompileIdentityConstraint (XmlSchemaIdentityConstraint xi) { 
            if (xi.Validating) {
                xi.CompiledConstraint = CompiledIdentityConstraint.Empty;       
                SendValidationEvent(Res.Sch_IdentityConstraintCircularRef, xi);
                return;
            }

            if (xi.CompiledConstraint != null) {
                return;
            }
            
            xi.Validating = true;
            CompiledIdentityConstraint compic = null;
            try {
                SchemaNamespaceManager xnmgr = new SchemaNamespaceManager(xi);
                compic = new CompiledIdentityConstraint(xi, xnmgr);
                if (xi is XmlSchemaKeyref) {
                    XmlSchemaIdentityConstraint ic = (XmlSchemaIdentityConstraint)this.identityConstraints[((XmlSchemaKeyref)xi).Refer];
                    if (ic == null) {
                        throw new XmlSchemaException(Res.Sch_UndeclaredIdentityConstraint, ((XmlSchemaKeyref)xi).Refer.ToString(), xi);
                    }     
                    CompileIdentityConstraint(ic);
                    if (ic.CompiledConstraint == null) {
                        throw new XmlSchemaException(Res.Sch_RefInvalidIdentityConstraint, ((XmlSchemaKeyref)xi).Refer.ToString(), xi);
                    }
                    // keyref has the different cardinality with the key it referred
                    if (ic.Fields.Count != xi.Fields.Count) {
                        throw new XmlSchemaException(Res.Sch_RefInvalidCardin, xi.QualifiedName.ToString(), xi);
                    }
                    // keyref can only refer to key/unique
                    if (ic.CompiledConstraint.Role == CompiledIdentityConstraint.ConstraintRole.Keyref) {
                        throw new XmlSchemaException(Res.Sch_ReftoKeyref, xi.QualifiedName.ToString(), xi);
                    }
                }
                xi.CompiledConstraint = compic;
            }
            catch (XmlSchemaException e) {
                if (e.SourceSchemaObject == null) {
                    e.SetSource(xi);
                }
                SendValidationEvent(e);
                xi.CompiledConstraint = CompiledIdentityConstraint.Empty;       
                // empty is better than null here, stop quickly when circle referencing
            } 
            finally {
                xi.Validating = false;
            }

        }

        private void CompileElement(XmlSchemaElement xe) {
            if (xe.Validating) {
                SendValidationEvent(Res.Sch_ElementCircularRef, xe);
                return;
            }
            if (xe.ElementDecl != null) {
                return;
            }
            xe.Validating = true;
            SchemaElementDecl decl = null;
            try {
                if (!xe.RefName.IsEmpty) {
                    XmlSchemaElement e = (XmlSchemaElement)this.schema.Elements[xe.RefName];
                    if (e == null) {
                        throw new XmlSchemaException(Res.Sch_UndeclaredElement, xe.RefName.ToString(), xe);
                    }  
                    CompileElement(e);
                    if (e.ElementDecl == null) {
                        throw new XmlSchemaException(Res.Sch_RefInvalidElement, xe.RefName.ToString(), xe);
                    }
                    xe.SetElementType(e.ElementType);
                    decl = e.ElementDecl.Clone();
                }
                else {
                    if (xe.SchemaType != null) {
                        xe.SetElementType(xe.SchemaType);
                    }
                    else if (!xe.SchemaTypeName.IsEmpty) {
                        XmlSchemaDatatype datatype;
                        xe.SetElementType(GetAnySchemaType(xe.SchemaTypeName, out datatype));
                        if (xe.ElementType == null) {
                            throw new XmlSchemaException(Res.Sch_UndeclaredType, xe.SchemaTypeName.ToString(), xe);   
                        }
                    }
                    else  if (!xe.SubstitutionGroup.IsEmpty) {
                        XmlSchemaElement examplar = (XmlSchemaElement)this.schema.Elements[xe.SubstitutionGroup];
                        if (examplar == null) {
                            throw new XmlSchemaException(Res.Sch_UndeclaredEquivClass, xe.SubstitutionGroup.Name.ToString(), xe);   
                        }
                        CompileElement(examplar);
                        xe.SetElementType(examplar.ElementType);
                        decl = examplar.ElementDecl.Clone();
                    }
                    else {
                        xe.SetElementType(XmlSchemaComplexType.AnyType);
                        decl = XmlSchemaComplexType.AnyType.ElementDecl.Clone();
                    }
            
                    if (decl == null) {
                        Debug.Assert(xe.ElementType != null);
                        if (xe.ElementType is XmlSchemaComplexType) {
                            XmlSchemaComplexType complexType = (XmlSchemaComplexType)xe.ElementType;
                            CompileComplexType(complexType);
                            if (complexType.ElementDecl != null) {
                                decl = complexType.ElementDecl.Clone();
                                decl.LocalElements = complexType.LocalElementDecls;
                            }
                        } 
                        else if (xe.ElementType is XmlSchemaSimpleType) {
                            XmlSchemaSimpleType simpleType = (XmlSchemaSimpleType)xe.ElementType;
                            CompileSimpleType(simpleType);
                            if (simpleType.ElementDecl != null) {
                                decl = simpleType.ElementDecl.Clone();
                            }
                        } 
                        else {
                            decl = new SchemaElementDecl((XmlSchemaDatatype)xe.ElementType, this.schemaNames);
                        }
                    }
                    decl.Name = xe.QualifiedName;
                    decl.IsAbstract = xe.IsAbstract;
                    XmlSchemaComplexType ct = xe.ElementType as XmlSchemaComplexType;
                    if (ct != null) {
                        decl.IsAbstract |= ct.IsAbstract; 
                    }
                    decl.IsNillable = xe.IsNillable;
                    decl.Block |= xe.BlockResolved;
                }
                if (decl.Datatype != null) {
                    decl.Datatype.VerifySchemaValid(this.schema, xe);
                }

                if (xe.DefaultValue != null || xe.FixedValue != null) {
                    if (decl.Content != null) {
                        if (decl.Content.ContentType == CompiledContentModel.Type.Text) {
                            if (xe.DefaultValue != null) {
                                decl.Presence = SchemaDeclBase.Use.Default;
                                decl.DefaultValueRaw = xe.DefaultValue;
                            }
                            else {
                                decl.Presence = SchemaDeclBase.Use.Fixed; 
                                decl.DefaultValueRaw = xe.FixedValue;
                            }
                            if (decl.Datatype != null) {
                                decl.DefaultValueTyped = decl.Datatype.ParseValue(decl.DefaultValueRaw, this.nameTable, this.namespaceManager);
                            }
                        }
                        else if (decl.Content.ContentType != CompiledContentModel.Type.Mixed || !decl.Content.IsEmptiable) {
                            throw new XmlSchemaException(Res.Sch_ElementCannotHaveValue, xe);
                        }
                    }
                }
                if (xe.HasConstraints) {
                    XmlSchemaObjectCollection constraints = xe.Constraints;
                    CompiledIdentityConstraint[] compiledConstraints = new CompiledIdentityConstraint[constraints.Count];
                    int idx = 0;
                    foreach(XmlSchemaIdentityConstraint constraint in constraints) {
                        CompileIdentityConstraint (constraint);
                        compiledConstraints[idx ++] = constraint.CompiledConstraint;
                    }
                    decl.Constraints = compiledConstraints;
                }
                xe.ElementDecl = decl;
            } 
            catch (XmlSchemaException e) {
                if (e.SourceSchemaObject == null) {
                    e.SetSource(xe);
                }
                SendValidationEvent(e);
                xe.ElementDecl = SchemaElementDecl.Empty;
            } 
            finally {
                xe.Validating = false;
            }
        }

        private void CompileComplexContent(XmlSchemaComplexType complexType, CompiledContentModel compiledContentModel) {
            compiledContentModel.Start();
            XmlSchemaParticle particle = complexType.ContentTypeParticle;
            if (particle != null && compiledContentModel.ContentType != CompiledContentModel.Type.Empty) {
#if DEBUG
                string name = complexType.Name != null ? complexType.Name : string.Empty;
                Debug.WriteLineIf(CompModSwitches.XmlSchema.TraceVerbose, "CompileComplexContent: "+ name  + DumpContentModel(particle));
#endif
                if (particle != XmlSchemaParticle.Empty) {
                    CompileContentModel(compiledContentModel, particle);
                }
            }
            try {
                compiledContentModel.Finish(null, this.compileContentModel);                         
            }
            catch(XmlSchemaException e) {
                e.SetSource(complexType);
                SendValidationEvent(e);
            }
            PushComplexType(complexType);
        }

#if DEBUG
        private string DumpContentModel(XmlSchemaParticle particle) {
            StringBuilder sb = new StringBuilder();
            DumpContentModelTo(sb, particle);
            return sb.ToString();
        }

        private void DumpContentModelTo(StringBuilder sb, XmlSchemaParticle particle) {
            if (particle is XmlSchemaElement) {
                sb.Append(((XmlSchemaElement)particle).QualifiedName);       
            }
            else if (particle is XmlSchemaAny) {
                sb.Append("<");
                sb.Append(((XmlSchemaAny)particle).NamespaceList.ToString());
                sb.Append(">");
            }
            else if (particle is XmlSchemaAll) {
                XmlSchemaAll all = (XmlSchemaAll)particle;
                sb.Append("[");       
                bool first = true;
                foreach (XmlSchemaElement localElement in all.Items) {
                    if (first) {
                        first = false;
                    }
                    else {
                        sb.Append(", ");
                    }
                    sb.Append(localElement.QualifiedName.Name);       
                    if (localElement.MinOccurs == decimal.Zero) {
                        sb.Append("?");                                                                  
                    }
                }    
                sb.Append("]");                                
            }
            else if (particle is XmlSchemaGroupBase) {
                XmlSchemaGroupBase gb = (XmlSchemaGroupBase)particle;
                sb.Append("(");
                string delimeter = (particle is XmlSchemaChoice) ? " | " : ", ";
                bool first = true;
                foreach (XmlSchemaParticle p in gb.Items) {
                    if (first) {
                        first = false;
                    }
                    else {
                        sb.Append(delimeter);
                    }
                    DumpContentModelTo(sb, p);
                }
                sb.Append(")");
            } else {
                Debug.Assert(particle == XmlSchemaParticle.Empty);
                sb.Append("<>");
            }
            if (particle.MinOccurs == decimal.One && particle.MaxOccurs == decimal.One) {
                // nothing
            }
            else if (particle.MinOccurs == decimal.Zero && particle.MaxOccurs == decimal.One) {
                sb.Append("?");
            }
            else if (particle.MinOccurs == decimal.Zero && particle.MaxOccurs == decimal.MaxValue) {
                sb.Append("*");
            }
            else if (particle.MinOccurs == decimal.One && particle.MaxOccurs == decimal.MaxValue) {
                sb.Append("+");
            }
            else {
                sb.Append("{" + particle.MinOccurs.ToString() +", " + particle.MaxOccurs.ToString() + "}");
            }
        }
#endif

        private void CompileContentModel(CompiledContentModel compiledContentModel, XmlSchemaParticle particle) {
            if (particle is XmlSchemaElement) {
                compiledContentModel.AddTerminal(((XmlSchemaElement)particle).QualifiedName, null, this.validationEventHandler);       
            }
            else if (particle is XmlSchemaAny) {
                compiledContentModel.AddAny((XmlSchemaAny)particle);
            }
            else if (particle is XmlSchemaGroupRef) {
                XmlSchemaParticle realParticle = ((XmlSchemaGroupRef)particle).Particle;
                Debug.Assert(realParticle != null && !realParticle.IsEmpty);
                compiledContentModel.OpenGroup();
                CompileContentModel(compiledContentModel, realParticle);              
                compiledContentModel.CloseGroup();
            }
            else if (particle is XmlSchemaAll) {
                XmlSchemaAll all = (XmlSchemaAll)particle;
                compiledContentModel.StartAllElements(all.Items.Count);
                foreach (XmlSchemaElement localElement in all.Items) {
                    if (!compiledContentModel.AddAllElement(localElement.QualifiedName, (localElement.MinOccurs == decimal.One ))) {
                       SendValidationEvent(Res.Sch_DupElement, localElement.QualifiedName.ToString(), localElement);
                    }
                }              
            }
            else if (particle is XmlSchemaGroupBase) {
                XmlSchemaObjectCollection particles = ((XmlSchemaGroupBase)particle).Items;
                bool isChoice = particle is XmlSchemaChoice;
                compiledContentModel.OpenGroup();
                bool first = true;
                foreach (XmlSchemaParticle p in particles) {
                    if (first) {
                        first = false;
                    }
                    else if (isChoice) {
                        compiledContentModel.AddChoice();  
                    }
                    else {
                        compiledContentModel.AddSequence();
                    }
                    Debug.Assert(!p.IsEmpty);
                    CompileContentModel(compiledContentModel, p);
                }
                compiledContentModel.CloseGroup();
            }
            else {
                Debug.Assert(false);
            }
            if (particle.MinOccurs == decimal.One && particle.MaxOccurs == decimal.One) {
                // nothing
            }
            else if (particle.MinOccurs == decimal.Zero && particle.MaxOccurs == decimal.One) {
                compiledContentModel.QuestionMark();
            }
            else if (particle.MinOccurs == decimal.Zero && particle.MaxOccurs == decimal.MaxValue) {
                compiledContentModel.Star();
            }
            else if (particle.MinOccurs == decimal.One && particle.MaxOccurs == decimal.MaxValue) {
                compiledContentModel.Plus();
            }
            else {
                compiledContentModel.MinMax(particle.MinOccurs, particle.MaxOccurs);
            }
        }

        private void CompileParticleElements(XmlSchemaComplexType complexType, XmlSchemaParticle particle) {
            if (particle is XmlSchemaElement) {
                XmlSchemaElement localElement = (XmlSchemaElement)particle;
                CompileElement(localElement); 
                if (complexType != null) {
                    if (complexType.LocalElements[localElement.QualifiedName] == null) {
                        complexType.LocalElements.Add(localElement.QualifiedName, localElement);
                        complexType.LocalElementDecls.Add(localElement.QualifiedName, localElement.ElementDecl);
                    }
                    else {
                        XmlSchemaElement element = (XmlSchemaElement)complexType.LocalElements[localElement.QualifiedName];
                        if (element.ElementType != localElement.ElementType) {
                            SendValidationEvent(Res.Sch_ElementTypeCollision, particle);
                        }
                    }                 
                }               
            }
/* never happens
            else if (particle is XmlSchemaGroupRef) {
                XmlSchemaGroupRef groupRef = (XmlSchemaGroupRef)particle;
                XmlSchemaGroup group;
                if (groupRef.Redefined != null) {
                    group = groupRef.Redefined;
                }
                else {
                    group = (XmlSchemaGroup)this.schema.Groups[groupRef.RefName];
                }
                if (group != null) {
                    if (group.Validating) {
                        SendValidationEvent(Res.Sch_GroupCircularRef, group);      
                        return;
                    }
                    group.Validating = true;
                    CompileParticleElements(complexType, group.Particle);
                    group.Validating = false;
                }
                else {
                    SendValidationEvent(Res.Sch_UndefGroupRef, groupRef.RefName.ToString(), groupRef);
                }                
            }
*/
            else if (particle is XmlSchemaGroupBase) {
                XmlSchemaObjectCollection particles = ((XmlSchemaGroupBase)particle).Items;
                foreach (XmlSchemaParticle p in particles) {
                    CompileParticleElements(complexType, p);
                }
            }
        }

        private void CompileCompexTypeElements(XmlSchemaComplexType complexType) {
            if (complexType.Validating) {
                SendValidationEvent(Res.Sch_TypeCircularRef, complexType);
                return;
            }
            complexType.Validating = true;
            if (complexType.ContentTypeParticle != XmlSchemaParticle.Empty) {
                CompileParticleElements(complexType, complexType.ContentTypeParticle);
            }
            complexType.ElementDecl.LocalElements = complexType.LocalElementDecls;
            complexType.Validating = false;
        }

        private static void CleanupAttribute(XmlSchemaAttribute attribute) {
            if (attribute.SchemaType != null) {
                CleanupSimpleType((XmlSchemaSimpleType)attribute.SchemaType);
            }
            attribute.AttDef = null;
        }
        
        private static void CleanupAttributeGroup(XmlSchemaAttributeGroup attributeGroup) {
            CleanupAttributes(attributeGroup.Attributes);
            attributeGroup.AttributeUses.Clear();
            attributeGroup.AttributeWildcard = null;
        }
        
        private static void CleanupComplexType(XmlSchemaComplexType complexType) {
            if (complexType.ContentModel != null) { //simpleContent or complexContent
                if (complexType.ContentModel is XmlSchemaSimpleContent) {
                    XmlSchemaSimpleContent simpleContent = (XmlSchemaSimpleContent)complexType.ContentModel;
                    if (simpleContent.Content is XmlSchemaSimpleContentExtension) {
                        XmlSchemaSimpleContentExtension simpleExtension = (XmlSchemaSimpleContentExtension)simpleContent.Content;
                        CleanupAttributes(simpleExtension.Attributes);
                    }
                    else { //simpleContent.Content is XmlSchemaSimpleContentRestriction
                        XmlSchemaSimpleContentRestriction simpleRestriction = (XmlSchemaSimpleContentRestriction)simpleContent.Content;
                        CleanupAttributes(simpleRestriction.Attributes);
                    }
                }
                else { // complexType.ContentModel is XmlSchemaComplexContent
                    XmlSchemaComplexContent complexContent = (XmlSchemaComplexContent)complexType.ContentModel;
                    if (complexContent.Content is XmlSchemaComplexContentExtension) {
                        XmlSchemaComplexContentExtension complexExtension = (XmlSchemaComplexContentExtension)complexContent.Content;
                        CleanupParticle(complexExtension.Particle);
                        CleanupAttributes(complexExtension.Attributes);

                    }
                    else { //XmlSchemaComplexContentRestriction
                        XmlSchemaComplexContentRestriction complexRestriction = (XmlSchemaComplexContentRestriction)complexContent.Content;
                        CleanupParticle(complexRestriction.Particle);
                        CleanupAttributes(complexRestriction.Attributes);
                    }
                }
            }
            else { //equals XmlSchemaComplexContent with baseType is anyType
                CleanupParticle(complexType.Particle);
                CleanupAttributes(complexType.Attributes);
            }
            complexType.LocalElements.Clear();
            complexType.LocalElementDecls.Clear();
            complexType.AttributeUses.Clear();
            complexType.SetAttributeWildcard(null);
            complexType.SetContentTypeParticle(null);
            complexType.ElementDecl = null;
        }
        
        private static void CleanupSimpleType(XmlSchemaSimpleType simpleType) {
            simpleType.ElementDecl = null;
        }
        
        private static void CleanupElement(XmlSchemaElement element) {
            if (element.SchemaType != null) {
                XmlSchemaComplexType complexType = element.SchemaType as XmlSchemaComplexType;
                if (complexType != null) {
                    CleanupComplexType(complexType);
                }
                else {
                    CleanupSimpleType((XmlSchemaSimpleType)element.SchemaType);
                }
            }
            element.ElementDecl = null;
        }
        
        private static void CleanupAttributes(XmlSchemaObjectCollection attributes) {
            foreach (XmlSchemaObject obj in attributes) {
                if (obj is XmlSchemaAttribute) {
                    CleanupAttribute((XmlSchemaAttribute)obj);
                }
            }        
        }

        private static void CleanupGroup(XmlSchemaGroup group) {
            CleanupParticle(group.Particle);
            group.CanonicalParticle = null;
        }

        private static void CleanupParticle(XmlSchemaParticle particle) {
            if (particle is XmlSchemaElement) {
                CleanupElement((XmlSchemaElement)particle);
            }
            else if (particle is XmlSchemaGroupBase) {
                foreach(XmlSchemaParticle p in ((XmlSchemaGroupBase)particle).Items) {
                    CleanupParticle(p);
                }
            }
        }

        private XmlSchemaDatatype GetDatatype(XmlQualifiedName qname) {
            XmlSchemaDatatype datatype = null;
            if (qname.Namespace == this.schemaNames.NsXsd) {
                datatype = XmlSchemaDatatype.FromTypeName(qname.Name);
            }
            return datatype;
        }

        private XmlSchemaSimpleType GetSimpleType(XmlQualifiedName name) {
            XmlSchemaSimpleType type = this.schema.SchemaTypes[name] as XmlSchemaSimpleType;
            if (type != null) {
                CompileSimpleType(type);
            }
            return type;
        }

        private XmlSchemaComplexType GetComplexType(XmlQualifiedName name) {
            XmlSchemaComplexType type = this.schema.SchemaTypes[name] as XmlSchemaComplexType;
            if (type != null) {
                CompileComplexType(type);
            }
            return type;
        }

        private object GetAnySchemaType(XmlQualifiedName name, out XmlSchemaDatatype datatype) {
            XmlSchemaType type = (XmlSchemaType)this.schema.SchemaTypes[name];
            if (type != null) {
                if (type is XmlSchemaComplexType) {
                    CompileComplexType((XmlSchemaComplexType)type);
                }
                else {
                    CompileSimpleType((XmlSchemaSimpleType)type);  
                }
                datatype = type.Datatype;
                return type;
            }
            else {
                datatype = GetDatatype(name);
                return datatype;
            }
        }

        private void SendValidationEvent(string code, XmlSchemaObject source) {
            SendValidationEvent(new XmlSchemaException(code, source), XmlSeverityType.Error);
        }

        private void SendValidationEvent(string code, string msg, XmlSchemaObject source) {
            SendValidationEvent(new XmlSchemaException(code, msg, source), XmlSeverityType.Error);
        }

        private void SendValidationEvent(string code, string msg, XmlSchemaObject source, XmlSeverityType severity) {
            SendValidationEvent(new XmlSchemaException(code, msg, source), severity);
        }

        private void SendValidationEvent(string code, string msg1, string msg2, XmlSchemaObject source) {
            SendValidationEvent(new XmlSchemaException(code, new string[] { msg1, msg2 }, source), XmlSeverityType.Error);
        }

        private void SendValidationEvent(string code, XmlSchemaObject source, XmlSeverityType severity) {
            SendValidationEvent(new XmlSchemaException(code, source), severity);
        }

        private void SendValidationEvent(XmlSchemaException e) {
            SendValidationEvent(e, XmlSeverityType.Error);
        }

        private void SendValidationEvent(XmlSchemaException e, XmlSeverityType severity) {
            if (severity == XmlSeverityType.Error) {
                this.schema.ErrorCount ++;
            }
            
            if (validationEventHandler != null) {
                validationEventHandler(null, new ValidationEventArgs(e, severity));
            }
            else if (severity == XmlSeverityType.Error) {
                throw e;
            }
        }
    };

} // namespace System.Xml
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\schema\schemaentity.cs ===
//------------------------------------------------------------------------------
// <copyright file="SchemaEntity.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Schema {

    using System;
    using System.Diagnostics;
    using System.Net;

    internal sealed class SchemaEntity {
        private XmlQualifiedName  name;               // Name of entity
        private String url;                // Url for external entity (system id)
        private String pubid;              // Pubid for external entity
        private String text;               // Text for internal entity
        private XmlQualifiedName  ndata = XmlQualifiedName.Empty;              // NDATA identifier
        private int    lineNumber;               // line number
        private int    linePosition;                // character postion
        private bool   isParameter;          // parameter entity flag
        private bool   isExternal;           // external entity flag
        private bool   isProcessed;          // whether entity is being Processed. (infinite recurrsion check)
        private bool   isDeclaredInExternal; // declared in external markup or not
        private string baseURI;
        private string declaredURI;

        internal SchemaEntity(XmlQualifiedName name, bool isParameter) {
            this.name = name;
            this.isParameter = isParameter;
        }

        internal static bool IsPredefinedEntity(String n) {
            return(n == "lt" ||
                   n == "gt" ||
                   n == "amp" ||
                   n == "apos" ||
                   n == "quot");
        }

        internal XmlQualifiedName Name {
            get { return name;}
        }

        internal String Url {
            get { return url;}
            set { url = value; isExternal = true;} 
        }

        internal String Pubid {
            get { return pubid;}
            set { pubid = value;}
        }

        internal bool IsProcessed {
            get { return isProcessed;}
            set { isProcessed = value;}
        }

        internal bool IsExternal {
            get { return isExternal;}
            set { isExternal = value;}
        }

        internal bool DeclaredInExternal {
            get { return isDeclaredInExternal;}
            set { isDeclaredInExternal = value;}
        }

        internal bool IsParEntity {
            get { return isParameter;}
            set { isParameter = value;}
        }

        internal XmlQualifiedName NData {
            get { return ndata;}
            set { ndata = value;}
        }

        internal String Text {
            get { return text;}
            set { text = value; isExternal = false;}
        }

        internal int Line {
            get { return lineNumber;}
            set { lineNumber = value;}    
        }

        internal int Pos {
            get { return linePosition;}
            set { linePosition = value;}
        }

        internal String BaseURI {
            get { return (baseURI == null) ? String.Empty : baseURI; }
            set { baseURI = value; }
        }

        internal String DeclaredURI {
            get { return (declaredURI == null) ? String.Empty : declaredURI; }
            set { declaredURI = value; }
        }
    };

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\schema\schemaelementdecl.cs ===
//------------------------------------------------------------------------------
// <copyright file="SchemaElementDecl.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Schema {

    using System;
    using System.Collections;
    using System.Diagnostics;

    internal sealed class SchemaElementDecl : SchemaDeclBase {
        CompiledContentModel content;      
        Hashtable attdefs = new Hashtable(); 
        Hashtable prohibitedAttributes = new Hashtable(); 
        Hashtable localElements;
        bool isAbstract = false;
        bool isNillable = false;
        XmlSchemaDerivationMethod block;
        bool isIdDeclared;
        bool isNotationDeclared;
        bool hasRequiredAttribute = false;
        XmlSchemaAnyAttribute anyAttribute;
        CompiledIdentityConstraint[] constraints;

		public static readonly SchemaElementDecl Empty = new SchemaElementDecl();

        public SchemaElementDecl() {
        }

        internal SchemaElementDecl(XmlSchemaDatatype dtype, SchemaNames names) {
            Datatype = dtype;
            Content = new CompiledContentModel(names);
            Content.ContentType = CompiledContentModel.Type.Text;
        }

        public SchemaElementDecl(XmlQualifiedName name, String prefix, SchemaType schemaType, SchemaNames names) 
        : base(name, prefix) {
                content = new CompiledContentModel(names);
        }

        public static SchemaElementDecl CreateAnyTypeElementDecl() {
            SchemaElementDecl anyTypeElementDecl = new SchemaElementDecl();
            anyTypeElementDecl.Content = new CompiledContentModel(null);
            anyTypeElementDecl.Content.ContentType = CompiledContentModel.Type.Any;
            anyTypeElementDecl.Datatype = XmlSchemaDatatype.AnyType;
            return anyTypeElementDecl;
        }

        public SchemaElementDecl Clone() {
            return (SchemaElementDecl) MemberwiseClone();
        }

        public bool IsAbstract {
            get { return isAbstract;}
            set { isAbstract = value;}
        }

        public bool IsNillable {
            get { return isNillable;}
            set { isNillable = value;}
        }

        public XmlSchemaDerivationMethod Block {
             get { return block; }
             set { block = value; }
        }

        public bool IsIdDeclared {
            get { return isIdDeclared;}
            set { isIdDeclared = value;}
        }

        public bool IsNotationDeclared {
            get { return isNotationDeclared; }
            set { isNotationDeclared = value; }
        }

        public bool HasRequiredAttribute {
            get { return hasRequiredAttribute; }
            set { hasRequiredAttribute = value; }
        }

        public CompiledContentModel Content {
            get { return content;}
            set { content = value;}
        }

        internal XmlSchemaAnyAttribute AnyAttribute {
            get { return anyAttribute; }
            set { anyAttribute = value; }
        }

        public CompiledIdentityConstraint[] Constraints {
            get { return constraints; }
            set { constraints = value; }
        }

        // add a new SchemaAttDef to the SchemaElementDecl
        public void AddAttDef(SchemaAttDef attdef) {
            attdefs.Add(attdef.Name, attdef);
            if (attdef.Presence == SchemaDeclBase.Use.Required) {
                hasRequiredAttribute = true;
            }
        }

        /*
         * Retrieves the attribute definition of the named attribute.
         * @param name  The name of the attribute.
         * @return  an attribute definition object; returns null if it is not found.
         */
        public SchemaAttDef GetAttDef(XmlQualifiedName qname) {
            return (SchemaAttDef)attdefs[qname];
        }

        public Hashtable AttDefs {
            get { return attdefs; }
        }

        public Hashtable ProhibitedAttributes {
            get { return prohibitedAttributes; }
        }

        public Hashtable LocalElements {
            get { return localElements; }
            set { localElements = value; }
        }

        public void CheckAttributes(Hashtable presence, bool standalone) {
            foreach(SchemaAttDef attdef in attdefs.Values) {
                if (presence[attdef.Name] == null) {
                    if (attdef.Presence == SchemaDeclBase.Use.Required) {
                        throw new XmlSchemaException(Res.Sch_MissRequiredAttribute, attdef.Name.ToString());
                    }
                    else if (standalone && attdef.IsDeclaredInExternal && (attdef.Presence == SchemaDeclBase.Use.Default || attdef.Presence == SchemaDeclBase.Use.Fixed)) {
                        throw new XmlSchemaException(Res.Sch_StandAlone);
                    }
                }
            }
        }

        public bool AllowText() {
            return (content.ContentType != CompiledContentModel.Type.ElementOnly && 
                    content.ContentType != CompiledContentModel.Type.Empty); 
        }
/*
        public void CopyAttDefs(Hashtable attdefs) {
            foreach (SchemaAttDef attdef in attdefs.Values) {            
                AddAttDef(attdef);
            }
        }

        public void CopyProhibitedAttributes(Hashtable attributes) {
            foreach (XmlQualifiedName attribute in attributes.Values) {            
                prohibitedAttributes.Add(attribute, attribute);
            }
        }
*/
    };

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\schema\schemainfo.cs ===
//------------------------------------------------------------------------------
// <copyright file="SchemaInfo.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Schema {

    using System;
    using System.Collections;
    using System.Diagnostics;
    using System.ComponentModel;

    internal class SchemaInfo {
        SchemaType schemaType;
        Hashtable elementDecls = new Hashtable();
        Hashtable undeclaredElementDecls = new Hashtable();
        Hashtable elementDeclsByType = new Hashtable();
        Hashtable attributeDecls = new Hashtable();
        Hashtable generalEntities = new Hashtable();
        Hashtable parameterEntities = new Hashtable();
        Hashtable notations = new Hashtable();
        XmlQualifiedName docTypeName = XmlQualifiedName.Empty;
        SchemaNames schemaNames;
        ForwardRef forwardRefs;
        Hashtable schemaURNs = new Hashtable();
        String currentSchemaNamespace;
        int errorCount;

        internal SchemaInfo( SchemaNames names ) {
            schemaType = SchemaType.None;
            schemaNames = names;
        }

        internal SchemaType SchemaType {
            get { return schemaType;}
            set { schemaType = value;}
        }

        internal Hashtable ElementDecls {
            get { return elementDecls; }
        }

        internal Hashtable UndeclaredElementDecls {
            get { return undeclaredElementDecls; }
        }
        
        internal Hashtable ElementDeclsByType {
            get { return elementDeclsByType; }
        }

        internal Hashtable AttributeDecls {
            get { return attributeDecls; }
        }

        internal Hashtable GeneralEntities {
            get { return generalEntities; }
        }

        internal Hashtable ParameterEntities {
            get { return parameterEntities; }
        }

        internal Hashtable Notations {
            get { return notations; }
        }

        internal XmlQualifiedName DocTypeName {
            get { return docTypeName;}
            set { docTypeName = value;}
        }

        internal int ErrorCount {
            get { return errorCount; }
            set { errorCount = value; }
        }

        internal String CurrentSchemaNamespace {
            get { return currentSchemaNamespace; }
            set { currentSchemaNamespace = value; }
        }

        internal SchemaElementDecl GetElementDecl(XmlQualifiedName qname, SchemaElementDecl ed) {
            SchemaElementDecl ed1 = null;
            if ((ed != null) && (ed.LocalElements != null)) {
                ed1 = (SchemaElementDecl)ed.LocalElements[qname];
            }
            if (ed1 == null && elementDecls != null) {
                ed1 = (SchemaElementDecl)elementDecls[qname];
            }
            return ed1;
        }

        internal bool HasSchema(string ns) {
            return schemaURNs[ns] != null;
        }

        internal bool IsSchema() {
            return schemaType == SchemaType.XDR || schemaType == SchemaType.XSD;
        }

        internal SchemaAttDef GetAttribute(SchemaElementDecl ed, XmlQualifiedName qname, ref bool skip) {
            SchemaAttDef attdef = null;
            if (ed != null) { // local attribute or XSD
		skip = false;
                attdef = ed.GetAttDef(qname);
                if (attdef == null) {
                    // In DTD, every attribute must be declared.
                    if (schemaType == SchemaType.DTD) {
                        throw new XmlSchemaException(Res.Sch_UndeclaredAttribute, qname.ToString());
                    }
                    else if (schemaType == SchemaType.XDR) {
                        if (ed.Content.IsOpen) {
                            attdef = (SchemaAttDef)attributeDecls[qname];
                            if ((attdef == null) && ((qname.Namespace == String.Empty) || HasSchema(qname.Namespace))) {
                                throw new XmlSchemaException(Res.Sch_UndeclaredAttribute, qname.ToString());
                            }
                        }
                        else {
                            throw new XmlSchemaException(Res.Sch_UndeclaredAttribute, qname.ToString());
                        }
                    }
                    else { //XML Schema
                        XmlSchemaAnyAttribute any = ed.AnyAttribute;
                        if (any != null) {
                            if (any.NamespaceList.Allows(qname)) {
                                if (any.ProcessContentsCorrect != XmlSchemaContentProcessing.Skip) {
                                    attdef = (SchemaAttDef)attributeDecls[qname];
                                    if (attdef == null && any.ProcessContentsCorrect == XmlSchemaContentProcessing.Strict) {
                                        throw new XmlSchemaException(Res.Sch_UndeclaredAttribute, qname.ToString());
                                    }
                                }
                                else {
                                    skip = true;
                                }
                            }
                            else {
                                throw new XmlSchemaException(Res.Sch_ProhibitedAttribute, qname.ToString());
                            }
                        }
                        else if (ed.ProhibitedAttributes[qname] != null) {
                            throw new XmlSchemaException(Res.Sch_ProhibitedAttribute, qname.ToString());
                        }
                        else {
                            throw new XmlSchemaException(Res.Sch_UndeclaredAttribute, qname.ToString());
                        }
                    }
                }
            }
            else { // global attribute
		if (!skip) {
                	attdef = (SchemaAttDef)attributeDecls[qname];
	                if ((attdef == null) && HasSchema(qname.Namespace)) {
        	            throw new XmlSchemaException(Res.Sch_UndeclaredAttribute, qname.ToString());
                	}
		}
            }
            return attdef;
        }

        internal void AddNotation(SchemaNotation notation, ValidationEventHandler eventhandler) {
            if (notations[notation.Name.Name] == null)
                notations.Add(notation.Name.Name, notation);
            else if (eventhandler != null) {
                eventhandler(this, new ValidationEventArgs(new XmlSchemaException(Res.Sch_DupNotation, notation.Name.Name)));
            }
        }

        internal void AddForwardRef(String name, String prefix, String id, int line, int col, bool implied, ForwardRef.Type type) {
            forwardRefs = new ForwardRef(forwardRefs, name, prefix, id, line, col, implied, type);
        }

        internal void CheckForwardRefs(ValidationEventHandler eventhandler) {
            ForwardRef next = forwardRefs;

            while (next != null) {
                next.Check(this, null, eventhandler);
                ForwardRef ptr = next.Next;
                next.Next = null; // unhook each object so it is cleaned up by Garbage Collector
                next = ptr;
            }

            // not needed any more.
            forwardRefs = null;
        }

        internal void Add(string targetNamespace, SchemaInfo sinfo, ValidationEventHandler eventhandler) {
            if (schemaType == SchemaType.None || sinfo.SchemaType == schemaType) {
                schemaType = sinfo.SchemaType;
            }
            else {
                if (eventhandler != null) {
                    eventhandler(this, new ValidationEventArgs(new XmlSchemaException(Res.Sch_MixSchemaTypes)));
                }
                return;
            }

            schemaURNs.Add(targetNamespace, targetNamespace);
            //
            // elements
            //
            foreach(DictionaryEntry entry in sinfo.elementDecls) {
                if (elementDecls[entry.Key] == null) {
                    elementDecls.Add(entry.Key, entry.Value);
                }
            }
            foreach(DictionaryEntry entry in sinfo.elementDeclsByType) {
                if (elementDeclsByType[entry.Key] == null) {
                    elementDeclsByType.Add(entry.Key, entry.Value);
                }
            }

            //
            // attributes
            //
            foreach (SchemaAttDef attdef in sinfo.AttributeDecls.Values) {
                if (attributeDecls[attdef.Name] == null) {
                    attributeDecls.Add(attdef.Name, attdef);
                }
            }
            //
            // notations
            //
            foreach (SchemaNotation notation in sinfo.Notations.Values) {
                AddNotation(notation, eventhandler);
            }

        }

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\schema\schemadeclbase.cs ===
//------------------------------------------------------------------------------
// <copyright file="SchemaDeclBase.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * @(#) schemadeclbase.cs 1.0 10/28/1999
 * 
 * A base class for schemaattdef and schemaelementdecl.
 *
 * Copyright (c) 1999 Microsoft, Corp. All Rights Reserved.
 * 
 */


namespace System.Xml.Schema {

    using System;
    using System.Collections;
    using System.Diagnostics;

    internal abstract class SchemaDeclBase {
        public enum Use {
            Default,
            Required,
            Implied,
            Fixed
        };

        protected XmlQualifiedName  name = XmlQualifiedName.Empty;
        protected string            prefix;
        protected ArrayList         values;    // array of values for enumerated and notation types

        protected XmlSchemaType     schemaType;
        protected XmlSchemaDatatype datatype;
        protected bool              isDeclaredInExternal = false;
        protected Use               presence;     // the presence, such as fixed, implied, etc

        protected string            defaultValueRaw;       // default value in its original form
        protected object            defaultValueTyped;       

        protected long               maxLength; // dt:maxLength
        protected long               minLength; // dt:minLength


        protected SchemaDeclBase(XmlQualifiedName name, string prefix) {
            this.name = name;
            this.prefix = prefix;
            maxLength = -1;
            minLength = -1;
        }

        protected SchemaDeclBase() {
        }

        public XmlQualifiedName Name {
            get { return name;}
            set { name = value;}
        }

        public string Prefix {
            get { return(prefix == null) ? string.Empty : prefix;}
            set { prefix = value;}
        }

        public void  AddValue(string value) {
            if (values == null) {
                values = new ArrayList();
            }
            values.Add(value);
        }

        public ArrayList Values {
            get { return values;}
            set { values = value;}
        }

        public Use Presence {
            get { return presence;}
            set { presence = value;}
        }

        public long MaxLength {
            get { return maxLength;}
            set { maxLength = value;}
        }

        public long MinLength {
            get { return minLength;}
            set { minLength = value;}
        }

        public bool IsDeclaredInExternal {
            get { return isDeclaredInExternal;}
            set { isDeclaredInExternal = value;}
        }

        public XmlSchemaType SchemaType {
            get { return schemaType;}
            set { schemaType = value;}
        }

        public XmlSchemaDatatype Datatype {
            get { return datatype;}
            set { datatype = value;}
        }

        public string DefaultValueRaw {
            get { return(defaultValueRaw != null) ? defaultValueRaw : string.Empty;}
            set { defaultValueRaw = value;}
        }

        public object DefaultValueTyped {
            get { return defaultValueTyped;}
            set { defaultValueTyped = value;}
        }

        public bool CheckEnumeration(object pVal) {
            return (datatype.TokenizedType != XmlTokenizedType.NOTATION && datatype.TokenizedType != XmlTokenizedType.ENUMERATION) || values.Contains(pVal.ToString());
        }

        public bool CheckValue(Object pVal) {
            return presence != Use.Fixed || (defaultValueTyped != null && datatype.IsEqual(pVal, defaultValueTyped));
        }

    };

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\schema\schemanames.cs ===
//------------------------------------------------------------------------------
// <copyright file="SchemaNames.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Schema {

    using System;
    using System.Collections;
    using System.Text;
    using System.Configuration.Assemblies;
    using System.Diagnostics;

    internal sealed class SchemaNames {
        internal string NsDataType;
        internal string NsDataTypeAlias;
        internal string NsDataTypeOld;
        internal string NsXml;
        internal string NsXmlNs;
        internal string NsXdr;
        internal string NsXdrAlias;
        internal string NsXsd;
        internal string NsXsi;
        internal string XsiType;
        internal string XsiNil;
        internal string XsiSchemaLocation;
        internal string XsiNoNamespaceSchemaLocation;

        internal XmlQualifiedName QnPCData;
        internal XmlQualifiedName QnXml;
        internal XmlQualifiedName QnXmlNs;
        internal XmlQualifiedName QnDtDt;
        internal XmlQualifiedName QnXmlLang;

        internal XmlQualifiedName QnName;
        internal XmlQualifiedName QnType;
        internal XmlQualifiedName QnMaxOccurs;
        internal XmlQualifiedName QnMinOccurs;
        internal XmlQualifiedName QnInfinite;
        internal XmlQualifiedName QnModel;
        internal XmlQualifiedName QnOpen;
        internal XmlQualifiedName QnClosed;
        internal XmlQualifiedName QnContent;
        internal XmlQualifiedName QnMixed;
        internal XmlQualifiedName QnEmpty;
        internal XmlQualifiedName QnEltOnly;
        internal XmlQualifiedName QnTextOnly;
        internal XmlQualifiedName QnOrder;
        internal XmlQualifiedName QnSeq;
        internal XmlQualifiedName QnOne;
        internal XmlQualifiedName QnMany;
        internal XmlQualifiedName QnRequired;
        internal XmlQualifiedName QnYes;
        internal XmlQualifiedName QnNo;
        internal XmlQualifiedName QnString;
        internal XmlQualifiedName QnID;
        internal XmlQualifiedName QnIDRef;
        internal XmlQualifiedName QnIDRefs;
        internal XmlQualifiedName QnEntity;
        internal XmlQualifiedName QnEntities;
        internal XmlQualifiedName QnNmToken;
        internal XmlQualifiedName QnNmTokens;
        internal XmlQualifiedName QnEnumeration;
        internal XmlQualifiedName QnDefault;
        internal XmlQualifiedName QnXdrSchema;
        internal XmlQualifiedName QnXdrElementType;
        internal XmlQualifiedName QnXdrElement;
        internal XmlQualifiedName QnXdrGroup;
        internal XmlQualifiedName QnXdrAttributeType;
        internal XmlQualifiedName QnXdrAttribute;
        internal XmlQualifiedName QnXdrDataType;
        internal XmlQualifiedName QnXdrDescription;
        internal XmlQualifiedName QnXdrExtends;
        internal XmlQualifiedName QnXdrAliasSchema;
        internal XmlQualifiedName QnDtType;
        internal XmlQualifiedName QnDtValues;
        internal XmlQualifiedName QnDtMaxLength;
        internal XmlQualifiedName QnDtMinLength;
        internal XmlQualifiedName QnDtMax;
        internal XmlQualifiedName QnDtMin;
        internal XmlQualifiedName QnDtMinExclusive;
        internal XmlQualifiedName QnDtMaxExclusive;
        // For XSD Schema
        internal XmlQualifiedName QnTargetNamespace;
        internal XmlQualifiedName QnVersion;
        internal XmlQualifiedName QnFinalDefault;
        internal XmlQualifiedName QnBlockDefault;
        internal XmlQualifiedName QnFixed;
        internal XmlQualifiedName QnAbstract;
        internal XmlQualifiedName QnBlock;
        internal XmlQualifiedName QnSubstitutionGroup;
        internal XmlQualifiedName QnFinal;
        internal XmlQualifiedName QnNillable;
        internal XmlQualifiedName QnRef;
        internal XmlQualifiedName QnBase;
        internal XmlQualifiedName QnDerivedBy;
        internal XmlQualifiedName QnNamespace;
        internal XmlQualifiedName QnProcessContents;
        internal XmlQualifiedName QnRefer;
        internal XmlQualifiedName QnPublic;
        internal XmlQualifiedName QnSystem;
        internal XmlQualifiedName QnSchemaLocation;
        internal XmlQualifiedName QnValue;
        internal XmlQualifiedName QnUse;
        internal XmlQualifiedName QnForm;
        internal XmlQualifiedName QnElementFormDefault;
        internal XmlQualifiedName QnAttributeFormDefault;
        internal XmlQualifiedName QnItemType;
        internal XmlQualifiedName QnMemberTypes;
        internal XmlQualifiedName QnXPath;
        internal XmlQualifiedName QnXsdSchema;
        internal XmlQualifiedName QnXsdAnnotation;
        internal XmlQualifiedName QnXsdInclude;
        internal XmlQualifiedName QnXsdImport;
        internal XmlQualifiedName QnXsdElement;
        internal XmlQualifiedName QnXsdAttribute;
        internal XmlQualifiedName QnXsdAttributeGroup;
        internal XmlQualifiedName QnXsdAnyAttribute;
        internal XmlQualifiedName QnXsdGroup;
        internal XmlQualifiedName QnXsdAll;
        internal XmlQualifiedName QnXsdChoice;
        internal XmlQualifiedName QnXsdSequence ;
        internal XmlQualifiedName QnXsdAny;
        internal XmlQualifiedName QnXsdNotation;
        internal XmlQualifiedName QnXsdSimpleType;
        internal XmlQualifiedName QnXsdComplexType;
        internal XmlQualifiedName QnXsdUnique;
        internal XmlQualifiedName QnXsdKey;
        internal XmlQualifiedName QnXsdKeyRef;
        internal XmlQualifiedName QnXsdSelector;
        internal XmlQualifiedName QnXsdField;
        internal XmlQualifiedName QnXsdMinExclusive;
        internal XmlQualifiedName QnXsdMinInclusive;
        internal XmlQualifiedName QnXsdMaxInclusive;
        internal XmlQualifiedName QnXsdMaxExclusive;
        internal XmlQualifiedName QnXsdTotalDigits;
        internal XmlQualifiedName QnXsdFractionDigits;
        internal XmlQualifiedName QnXsdLength;
        internal XmlQualifiedName QnXsdMinLength;
        internal XmlQualifiedName QnXsdMaxLength;
        internal XmlQualifiedName QnXsdEnumeration;
        internal XmlQualifiedName QnXsdPattern;
        internal XmlQualifiedName QnXsdDocumentation;
        internal XmlQualifiedName QnXsdAppinfo;
        internal XmlQualifiedName QnSource;
        internal XmlQualifiedName QnXsdComplexContent;
        internal XmlQualifiedName QnXsdSimpleContent;
        internal XmlQualifiedName QnXsdRestriction;
        internal XmlQualifiedName QnXsdExtension;
        internal XmlQualifiedName QnXsdUnion;
        internal XmlQualifiedName QnXsdList;
        internal XmlQualifiedName QnXsdWhiteSpace;
        internal XmlQualifiedName QnXsdRedefine;
        internal XmlQualifiedName QnXsdAnyType;

        private XmlNameTable NameTable;

        internal SchemaNames( XmlNameTable nt ) {
            NameTable = nt;

            NsDataType = nt.Add(XmlReservedNs.NsDataType);
            NsDataTypeAlias = nt.Add(XmlReservedNs.NsDataTypeAlias);
            NsDataTypeOld = nt.Add(XmlReservedNs.NsDataTypeOld);
            NsXml = nt.Add(XmlReservedNs.NsXml);
            NsXmlNs = nt.Add(XmlReservedNs.NsXmlNs);       
            NsXdr = nt.Add(XmlReservedNs.NsXdr);
            NsXdrAlias = nt.Add(XmlReservedNs.NsXdrAlias);
            NsXsd = nt.Add(XmlReservedNs.NsXsd);
            NsXsi = nt.Add(XmlReservedNs.NsXsi);
            XsiType = nt.Add("type");
            XsiNil = nt.Add("nil");
            XsiSchemaLocation = nt.Add("schemaLocation");
            XsiNoNamespaceSchemaLocation = nt.Add("noNamespaceSchemaLocation");


            QnPCData = new XmlQualifiedName( nt.Add("#PCDATA") );
            QnXml = new XmlQualifiedName( nt.Add("xml") );
            QnXmlNs = new XmlQualifiedName( nt.Add("xmlns"), NsXmlNs );
            QnDtDt = new XmlQualifiedName( nt.Add("dt"), NsDataType );
            QnXmlLang= new XmlQualifiedName( nt.Add("lang"), NsXml);            
            
            // Empty namespace
            QnName = new XmlQualifiedName( nt.Add("name") );
            QnType = new XmlQualifiedName( nt.Add("type") );
            QnMaxOccurs = new XmlQualifiedName( nt.Add("maxOccurs") );
            QnMinOccurs = new XmlQualifiedName( nt.Add("minOccurs") );
            QnInfinite = new XmlQualifiedName( nt.Add("*") );
            QnModel = new XmlQualifiedName( nt.Add("model") );
            QnOpen = new XmlQualifiedName( nt.Add("open") );
            QnClosed = new XmlQualifiedName( nt.Add("closed") );
            QnContent = new XmlQualifiedName( nt.Add("content") );
            QnMixed = new XmlQualifiedName( nt.Add("mixed") );
            QnEmpty = new XmlQualifiedName( nt.Add("empty") );
            QnEltOnly = new XmlQualifiedName( nt.Add("eltOnly") );
            QnTextOnly = new XmlQualifiedName( nt.Add("textOnly") );
            QnOrder = new XmlQualifiedName( nt.Add("order") );
            QnSeq = new XmlQualifiedName( nt.Add("seq") );
            QnOne = new XmlQualifiedName( nt.Add("one") );
            QnMany = new XmlQualifiedName( nt.Add("many") );
            QnRequired = new XmlQualifiedName( nt.Add("required") );
            QnYes = new XmlQualifiedName( nt.Add("yes") );
            QnNo = new XmlQualifiedName( nt.Add("no") );
            QnString = new XmlQualifiedName( nt.Add("string") );
            QnID = new XmlQualifiedName( nt.Add("id") );
            QnIDRef = new XmlQualifiedName( nt.Add("idref") );
            QnIDRefs = new XmlQualifiedName( nt.Add("idrefs") );
            QnEntity = new XmlQualifiedName( nt.Add("entity") );
            QnEntities = new XmlQualifiedName( nt.Add("entities") );
            QnNmToken = new XmlQualifiedName( nt.Add("nmtoken") );
            QnNmTokens = new XmlQualifiedName( nt.Add("nmtokens") );
            QnEnumeration = new XmlQualifiedName( nt.Add("enumeration") );
            QnDefault = new XmlQualifiedName( nt.Add("default") );
            //For XSD Schema
            QnTargetNamespace = new XmlQualifiedName( nt.Add("targetNamespace") );
            QnVersion = new XmlQualifiedName( nt.Add("version") );
            QnFinalDefault = new XmlQualifiedName( nt.Add("finalDefault") );
            QnBlockDefault = new XmlQualifiedName( nt.Add("blockDefault") );
            QnFixed = new XmlQualifiedName( nt.Add("fixed") );
            QnAbstract = new XmlQualifiedName( nt.Add("abstract") );
            QnBlock = new XmlQualifiedName( nt.Add("block") );
            QnSubstitutionGroup = new XmlQualifiedName( nt.Add("substitutionGroup") );
            QnFinal = new XmlQualifiedName( nt.Add("final") );
            QnNillable = new XmlQualifiedName( nt.Add("nillable") );
            QnRef = new XmlQualifiedName( nt.Add("ref") );
            QnBase = new XmlQualifiedName( nt.Add("base") );
            QnDerivedBy = new XmlQualifiedName( nt.Add("derivedBy") );
            QnNamespace = new XmlQualifiedName( nt.Add("namespace") );
            QnProcessContents = new XmlQualifiedName( nt.Add("processContents") );
            QnRefer = new XmlQualifiedName( nt.Add("refer") );
            QnPublic = new XmlQualifiedName( nt.Add("public") );
            QnSystem = new XmlQualifiedName( nt.Add("system") );
            QnSchemaLocation = new XmlQualifiedName( nt.Add("schemaLocation") );
            QnValue = new XmlQualifiedName( nt.Add("value") );
            QnUse = new XmlQualifiedName( nt.Add("use") );
            QnForm = new XmlQualifiedName( nt.Add("form") );
            QnAttributeFormDefault = new XmlQualifiedName( nt.Add("attributeFormDefault") );
            QnElementFormDefault = new XmlQualifiedName( nt.Add("elementFormDefault") );
            QnSource = new XmlQualifiedName( nt.Add("source") );
            QnMemberTypes = new XmlQualifiedName( nt.Add("memberTypes"));
            QnItemType = new XmlQualifiedName( nt.Add("itemType"));
            QnXPath = new XmlQualifiedName( nt.Add("xpath"));

            // XDR namespace
            string nsXDR = nt.Add("urn:schemas-microsoft-com:xml-data");
            QnXdrSchema = new XmlQualifiedName( nt.Add("Schema"), nsXDR );
            QnXdrElementType = new XmlQualifiedName( nt.Add("ElementType"), nsXDR );
            QnXdrElement = new XmlQualifiedName( nt.Add("element"), nsXDR );
            QnXdrGroup = new XmlQualifiedName( nt.Add("group"), nsXDR );
            QnXdrAttributeType = new XmlQualifiedName( nt.Add("AttributeType"), nsXDR );
            QnXdrAttribute = new XmlQualifiedName( nt.Add("attribute"), nsXDR );
            QnXdrDataType = new XmlQualifiedName( nt.Add("datatype"), nsXDR );
            QnXdrDescription = new XmlQualifiedName( nt.Add("description"), nsXDR );
            QnXdrExtends = new XmlQualifiedName( nt.Add("extends"), nsXDR );

            // XDR alias namespace
            QnXdrAliasSchema = new XmlQualifiedName( nt.Add("Schema"), NsDataTypeAlias );

            // DataType namespace
            QnDtType = new XmlQualifiedName( nt.Add("type"), NsDataType );
            QnDtValues = new XmlQualifiedName( nt.Add("values"), NsDataType );
            QnDtMaxLength = new XmlQualifiedName( nt.Add("maxLength"), NsDataType );
            QnDtMinLength = new XmlQualifiedName( nt.Add("minLength"), NsDataType );
            QnDtMax = new XmlQualifiedName( nt.Add("max"), NsDataType );
            QnDtMin = new XmlQualifiedName( nt.Add("min"), NsDataType );
            QnDtMinExclusive = new XmlQualifiedName( nt.Add("minExclusive"), NsDataType );
            QnDtMaxExclusive = new XmlQualifiedName( nt.Add("maxExclusive"), NsDataType );


            // XSD namespace
            QnXsdSchema = new XmlQualifiedName( nt.Add("schema"), NsXsd );
            QnXsdAnnotation= new XmlQualifiedName( nt.Add("annotation"), NsXsd );
            QnXsdInclude= new XmlQualifiedName( nt.Add("include"), NsXsd );
            QnXsdImport= new XmlQualifiedName( nt.Add("import"), NsXsd );
            QnXsdElement = new XmlQualifiedName( nt.Add("element"), NsXsd );
            QnXsdAttribute = new XmlQualifiedName( nt.Add("attribute"), NsXsd );
            QnXsdAttributeGroup = new XmlQualifiedName( nt.Add("attributeGroup"), NsXsd );
            QnXsdAnyAttribute = new XmlQualifiedName( nt.Add("anyAttribute"), NsXsd );
            QnXsdGroup = new XmlQualifiedName( nt.Add("group"), NsXsd );
            QnXsdAll = new XmlQualifiedName( nt.Add("all"), NsXsd );
            QnXsdChoice = new XmlQualifiedName( nt.Add("choice"), NsXsd );
            QnXsdSequence = new XmlQualifiedName( nt.Add("sequence"), NsXsd );
            QnXsdAny = new XmlQualifiedName( nt.Add("any"), NsXsd );
            QnXsdNotation = new XmlQualifiedName( nt.Add("notation"), NsXsd );
            QnXsdSimpleType = new XmlQualifiedName( nt.Add("simpleType"), NsXsd );
            QnXsdComplexType = new XmlQualifiedName( nt.Add("complexType"), NsXsd );
            QnXsdUnique = new XmlQualifiedName( nt.Add("unique"), NsXsd );
            QnXsdKey = new XmlQualifiedName( nt.Add("key"), NsXsd );
            QnXsdKeyRef = new XmlQualifiedName( nt.Add("keyref"), NsXsd );
            QnXsdSelector= new XmlQualifiedName( nt.Add("selector"), NsXsd );
            QnXsdField= new XmlQualifiedName( nt.Add("field"), NsXsd );
            QnXsdMinExclusive= new XmlQualifiedName( nt.Add("minExclusive"), NsXsd );
            QnXsdMinInclusive= new XmlQualifiedName( nt.Add("minInclusive"), NsXsd );
            QnXsdMaxInclusive= new XmlQualifiedName( nt.Add("maxInclusive"), NsXsd );
            QnXsdMaxExclusive= new XmlQualifiedName( nt.Add("maxExclusive"), NsXsd );
            QnXsdTotalDigits= new XmlQualifiedName( nt.Add("totalDigits"), NsXsd );
            QnXsdFractionDigits= new XmlQualifiedName( nt.Add("fractionDigits"), NsXsd );
            QnXsdLength= new XmlQualifiedName( nt.Add("length"), NsXsd );
            QnXsdMinLength= new XmlQualifiedName( nt.Add("minLength"), NsXsd );
            QnXsdMaxLength= new XmlQualifiedName( nt.Add("maxLength"), NsXsd );
            QnXsdEnumeration= new XmlQualifiedName( nt.Add("enumeration"), NsXsd );
            QnXsdPattern= new XmlQualifiedName( nt.Add("pattern"), NsXsd );
            QnXsdDocumentation= new XmlQualifiedName( nt.Add("documentation"), NsXsd );
            QnXsdAppinfo= new XmlQualifiedName( nt.Add("appinfo"), NsXsd );
            QnXsdComplexContent= new XmlQualifiedName( nt.Add("complexContent"), NsXsd );
            QnXsdSimpleContent= new XmlQualifiedName( nt.Add("simpleContent"), NsXsd );
            QnXsdRestriction= new XmlQualifiedName( nt.Add("restriction"), NsXsd );
            QnXsdExtension= new XmlQualifiedName( nt.Add("extension"), NsXsd );
            QnXsdUnion= new XmlQualifiedName( nt.Add("union"), NsXsd );
            QnXsdList= new XmlQualifiedName( nt.Add("list"), NsXsd );
            QnXsdWhiteSpace= new XmlQualifiedName( nt.Add("whiteSpace"), NsXsd );
            QnXsdRedefine= new XmlQualifiedName( nt.Add("redefine"), NsXsd );
            QnXsdAnyType= new XmlQualifiedName( nt.Add("anyType"), NsXsd );
        }


        internal bool IsXDRRoot(XmlQualifiedName name) {
            return QnXdrSchema == name || QnXdrAliasSchema == name;
        }

        internal bool IsXSDRoot(XmlQualifiedName name) {
            return QnXsdSchema == name;
        }
        
        internal bool IsSchemaRoot(XmlQualifiedName name) {
            return QnXsdSchema == name || QnXdrSchema == name || QnXdrAliasSchema == name;
        }

        internal enum ID {
            EMPTY,
            SCHEMA_NAME,
            SCHEMA_TYPE,
            SCHEMA_MAXOCCURS,
            SCHEMA_MINOCCURS,
            SCHEMA_INFINITE,
            SCHEMA_MODEL,
            SCHEMA_OPEN,
            SCHEMA_CLOSED,
            SCHEMA_CONTENT,
            SCHEMA_MIXED,
            SCHEMA_EMPTY,
            SCHEMA_ELTONLY,
            SCHEMA_TEXTONLY,
            SCHEMA_ORDER,
            SCHEMA_SEQ,
            SCHEMA_ONE,
            SCHEMA_MANY,
            SCHEMA_REQUIRED,
            SCHEMA_YES,
            SCHEMA_NO,
            SCHEMA_STRING,
            SCHEMA_ID,
            SCHEMA_IDREF,
            SCHEMA_IDREFS,
            SCHEMA_ENTITY,
            SCHEMA_ENTITIES,
            SCHEMA_NMTOKEN,
            SCHEMA_NMTOKENS,
            SCHEMA_ENUMERATION,
            SCHEMA_DEFAULT,
            XDR_ROOT,
            XDR_ELEMENTTYPE,
            XDR_ELEMENT,
            XDR_GROUP,
            XDR_ATTRIBUTETYPE,
            XDR_ATTRIBUTE,
            XDR_DATATYPE,
            XDR_DESCRIPTION,
            XDR_EXTENDS,
            SCHEMA_XDRROOT_ALIAS,
            SCHEMA_DTTYPE,
            SCHEMA_DTVALUES,
            SCHEMA_DTMAXLENGTH,
            SCHEMA_DTMINLENGTH,
            SCHEMA_DTMAX,
            SCHEMA_DTMIN,
            SCHEMA_DTMINEXCLUSIVE,
            SCHEMA_DTMAXEXCLUSIVE,
            SCHEMA_TARGETNAMESPACE,
            SCHEMA_VERSION,
            SCHEMA_FINALDEFAULT,
            SCHEMA_BLOCKDEFAULT,
            SCHEMA_FIXED,
            SCHEMA_ABSTRACT,
            SCHEMA_BLOCK,
            SCHEMA_SUBSTITUTIONGROUP,
            SCHEMA_FINAL,
            SCHEMA_NILLABLE,
            SCHEMA_REF,
            SCHEMA_BASE,
            SCHEMA_DERIVEDBY,
            SCHEMA_NAMESPACE,
            SCHEMA_PROCESSCONTENTS,
            SCHEMA_REFER,
            SCHEMA_PUBLIC,
            SCHEMA_SYSTEM,
            SCHEMA_SCHEMALOCATION,
            SCHEMA_VALUE,
            SCHEMA_SOURCE,
            SCHEMA_ATTRIBUTEFORMDEFAULT,
            SCHEMA_ELEMENTFORMDEFAULT,
            SCHEMA_USE,
            SCHEMA_FORM,
            XSD_SCHEMA,
            XSD_ANNOTATION,
            XSD_INCLUDE,
            XSD_IMPORT,
            XSD_ELEMENT,
            XSD_ATTRIBUTE,
            XSD_ATTRIBUTEGROUP,
            XSD_ANYATTRIBUTE,
            XSD_GROUP,
            XSD_ALL,
            XSD_CHOICE,
            XSD_SEQUENCE,
            XSD_ANY,
            XSD_NOTATION,
            XSD_SIMPLETYPE,
            XSD_COMPLEXTYPE,
            XSD_UNIQUE,
            XSD_KEY,
            XSD_KEYREF,
            XSD_SELECTOR,
            XSD_FIELD,
            XSD_MINEXCLUSIVE,
            XSD_MININCLUSIVE,
            XSD_MAXEXCLUSIVE,
            XSD_MAXINCLUSIVE,
            XSD_TOTALDIGITS,
            XSD_FRACTIONDIGITS,
            XSD_LENGTH,
            XSD_MINLENGTH,
            XSD_MAXLENGTH,
            XSD_ENUMERATION,
            XSD_PATTERN,
            XSD_DOCUMENTATION,
            XSD_APPINFO,
            XSD_COMPLEXCONTENT,
            XSD_COMPLEXCONTENTEXTENSION,
            XSD_COMPLEXCONTENTRESTRICTION,
            XSD_SIMPLECONTENT,
            XSD_SIMPLECONTENTEXTENSION,
            XSD_SIMPLECONTENTRESTRICTION,
            XSD_SIMPLETYPELIST,
            XSD_SIMPLETYPERESTRICTION,
            XSD_SIMPLETYPEUNION,
            XSD_WHITESPACE,
            XSD_REDEFINE,
            SCHEMA_ITEMTYPE,
            SCHEMA_MEMBERTYPES,
            SCHEMA_XPATH,
            XMLLANG
        };
        

        internal XmlQualifiedName GetName( SchemaNames.ID name ) {
            switch (name) {
                case ID.SCHEMA_NAME:
                    return QnName;
                case ID.SCHEMA_TYPE:
                    return QnType;
                case ID.SCHEMA_MAXOCCURS:
                    return QnMaxOccurs;
                case ID.SCHEMA_MINOCCURS:
                    return QnMinOccurs;
                case ID.SCHEMA_INFINITE:
                    return QnInfinite;
                case ID.SCHEMA_MODEL:
                    return QnModel;
                case ID.SCHEMA_OPEN:
                    return QnOpen;
                case ID.SCHEMA_CLOSED:
                    return QnClosed;
                case ID.SCHEMA_CONTENT:
                    return QnContent;
                case ID.SCHEMA_MIXED:
                    return QnMixed;
                case ID.SCHEMA_EMPTY:
                    return QnEmpty;
                case ID.SCHEMA_ELTONLY:
                    return QnEltOnly;
                case ID.SCHEMA_TEXTONLY:
                    return QnTextOnly;
                case ID.SCHEMA_ORDER:
                    return QnOrder;
                case ID.SCHEMA_SEQ:
                    return QnSeq;
                case ID.SCHEMA_ONE:
                    return QnOne;
                case ID.SCHEMA_MANY:
                    return QnMany;
                case ID.SCHEMA_REQUIRED:
                    return QnRequired;
                case ID.SCHEMA_YES:
                    return QnYes;
                case ID.SCHEMA_NO:
                    return QnNo;
                case ID.SCHEMA_STRING:
                    return QnString;
                case ID.SCHEMA_ID:
                    return QnID;
                case ID.SCHEMA_IDREF:
                    return QnIDRef;
                case ID.SCHEMA_IDREFS:
                    return QnIDRefs;
                case ID.SCHEMA_ENTITY:
                    return QnEntity;
                case ID.SCHEMA_ENTITIES:
                    return QnEntities;
                case ID.SCHEMA_NMTOKEN:
                    return QnNmToken;
                case ID.SCHEMA_NMTOKENS:
                    return QnNmTokens;
                case ID.SCHEMA_ENUMERATION:
                    return QnEnumeration;
                case ID.SCHEMA_DEFAULT:
                    return QnDefault;
                case ID.XDR_ROOT:
                    return QnXdrSchema;
                case ID.XDR_ELEMENTTYPE:
                    return QnXdrElementType;
                case ID.XDR_ELEMENT:
                    return QnXdrElement;
                case ID.XDR_GROUP:
                    return QnXdrGroup;
                case ID.XDR_ATTRIBUTETYPE:
                    return QnXdrAttributeType;
                case ID.XDR_ATTRIBUTE:
                    return QnXdrAttribute;
                case ID.XDR_DATATYPE:
                    return QnXdrDataType;
                case ID.XDR_DESCRIPTION:
                    return QnXdrDescription;
                case ID.XDR_EXTENDS:
                    return QnXdrExtends;
                case ID.SCHEMA_XDRROOT_ALIAS:
                    return QnXdrAliasSchema;
                case ID.SCHEMA_DTTYPE:
                    return QnDtType;
                case ID.SCHEMA_DTVALUES:
                    return QnDtValues;
                case ID.SCHEMA_DTMAXLENGTH:
                    return QnDtMaxLength;
                case ID.SCHEMA_DTMINLENGTH:
                    return QnDtMinLength;
                case ID.SCHEMA_DTMAX:
                    return QnDtMax;
                case ID.SCHEMA_DTMIN:
                    return QnDtMin;
                case ID.SCHEMA_DTMINEXCLUSIVE:
                    return QnDtMinExclusive;
                case ID.SCHEMA_DTMAXEXCLUSIVE:
                    return QnDtMaxExclusive;
                case ID.SCHEMA_TARGETNAMESPACE:
                    return QnTargetNamespace;
                case ID.SCHEMA_VERSION:
                    return QnVersion;
                case ID.SCHEMA_FINALDEFAULT:
                    return QnFinalDefault;
                case ID.SCHEMA_BLOCKDEFAULT:
                    return QnBlockDefault;
                case ID.SCHEMA_FIXED:
                    return QnFixed;
                case ID.SCHEMA_ABSTRACT:
                    return QnAbstract;
                case ID.SCHEMA_BLOCK:
                    return QnBlock;
                case ID.SCHEMA_SUBSTITUTIONGROUP:
                    return QnSubstitutionGroup;
                case ID.SCHEMA_FINAL:
                    return QnFinal;
                case ID.SCHEMA_NILLABLE:
                    return QnNillable;
                case ID.SCHEMA_REF:
                    return QnRef;
                case ID.SCHEMA_BASE:
                    return QnBase;
                case ID.SCHEMA_DERIVEDBY:
                    return QnDerivedBy;
                case ID.SCHEMA_NAMESPACE:
                    return QnNamespace;
                case ID.SCHEMA_PROCESSCONTENTS:
                    return QnProcessContents;
                case ID.SCHEMA_REFER:
                    return QnRefer;
                case ID.SCHEMA_PUBLIC:
                    return QnPublic;
                case ID.SCHEMA_SYSTEM:
                    return QnSystem;
                case ID.SCHEMA_SCHEMALOCATION:
                    return QnSchemaLocation;
                case ID.SCHEMA_VALUE:
                    return QnValue;
                case ID.SCHEMA_ITEMTYPE:
                    return QnItemType;
                case ID.SCHEMA_MEMBERTYPES:
                    return QnMemberTypes;
                case ID.SCHEMA_XPATH:
                    return QnXPath;
                case ID.XSD_SCHEMA:
                    return QnXsdSchema;
                case ID.XSD_ANNOTATION:
                    return QnXsdAnnotation;
                case ID.XSD_INCLUDE:
                    return QnXsdInclude;
                case ID.XSD_IMPORT:
                    return QnXsdImport;
                case ID.XSD_ELEMENT:
                    return QnXsdElement;
                case ID.XSD_ATTRIBUTE:
                    return QnXsdAttribute;
                case ID.XSD_ATTRIBUTEGROUP:
                    return QnXsdAttributeGroup;
                case ID.XSD_ANYATTRIBUTE:
                    return QnXsdAnyAttribute;
                case ID.XSD_GROUP:
                    return QnXsdGroup;
                case ID.XSD_ALL:
                    return QnXsdAll;
                case ID.XSD_CHOICE:
                    return QnXsdChoice;
                case ID.XSD_SEQUENCE:
                    return QnXsdSequence;
                case ID.XSD_ANY:
                    return QnXsdAny;
                case ID.XSD_NOTATION:
                    return QnXsdNotation;
                case ID.XSD_SIMPLETYPE:
                    return QnXsdSimpleType;
                case ID.XSD_COMPLEXTYPE:
                    return QnXsdComplexType;
                case ID.XSD_UNIQUE:
                    return QnXsdUnique;
                case ID.XSD_KEY:
                    return QnXsdKey;
                case ID.XSD_KEYREF:
                    return QnXsdKeyRef;
                case ID.XSD_SELECTOR:
                    return QnXsdSelector;
                case ID.XSD_FIELD:
                    return QnXsdField;
                case ID.XSD_MINEXCLUSIVE:
                    return QnXsdMinExclusive;
                case ID.XSD_MININCLUSIVE:
                    return QnXsdMinInclusive;
                case ID.XSD_MAXEXCLUSIVE:
                    return QnXsdMaxExclusive;
                case ID.XSD_MAXINCLUSIVE:
                    return QnXsdMaxInclusive;
                case ID.XSD_TOTALDIGITS:
                    return QnXsdTotalDigits;
                case ID.XSD_FRACTIONDIGITS:
                    return QnXsdFractionDigits;
                case ID.XSD_LENGTH:
                    return QnXsdLength;
                case ID.XSD_MINLENGTH:
                    return QnXsdMinLength;
                case ID.XSD_MAXLENGTH:
                    return QnXsdMaxLength;
                case ID.XSD_ENUMERATION:
                    return QnXsdEnumeration;
                case ID.XSD_PATTERN:
                    return QnXsdPattern;
                case ID.XSD_WHITESPACE:
                    return QnXsdWhiteSpace;
                case ID.XSD_DOCUMENTATION:
                    return QnXsdDocumentation;
                case ID.XSD_APPINFO:
                    return QnXsdAppinfo;
                case ID.XSD_COMPLEXCONTENT:
                    return QnXsdComplexContent;
                case ID.XSD_COMPLEXCONTENTRESTRICTION:
                case ID.XSD_SIMPLECONTENTRESTRICTION:
                case ID.XSD_SIMPLETYPERESTRICTION:
                    return QnXsdRestriction;
                case ID.XSD_COMPLEXCONTENTEXTENSION:
                case ID.XSD_SIMPLECONTENTEXTENSION:
                    return QnXsdExtension;
                case ID.XSD_SIMPLECONTENT:
                    return QnXsdSimpleContent;
                case ID.XSD_SIMPLETYPEUNION:
                    return QnXsdUnion;
                case ID.XSD_SIMPLETYPELIST:
                    return QnXsdList;
                case ID.XSD_REDEFINE:
                    return QnXsdRedefine;
                case ID.SCHEMA_SOURCE:
                    return QnSource;
                case ID.SCHEMA_USE:
                    return QnUse;
                case ID.SCHEMA_FORM:
                    return QnForm;
                case ID.SCHEMA_ELEMENTFORMDEFAULT:
                    return QnElementFormDefault;
                case ID.SCHEMA_ATTRIBUTEFORMDEFAULT:
                    return QnAttributeFormDefault;
                case ID.XMLLANG:
                    return QnXmlLang;
                default:
                    Debug.Assert(false);
                    return XmlQualifiedName.Empty;
            }
        }

    };

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\schema\schemaforwardref.cs ===
//------------------------------------------------------------------------------
// <copyright file="schemaforwardref.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Schema {

    using System;
    using System.Collections;
    using System.Diagnostics;

    internal sealed class ForwardRef {
        public enum Type {
            ID,
            NOTATION
        };

        internal String             Name;
        internal String             Prefix;
        internal String             ID;
        internal int                Line;
        internal int                Col;
        internal bool               Implied;
        internal ForwardRef.Type    RefType;
        internal ForwardRef         Next;


        internal ForwardRef(ForwardRef next, String name, String prefix, String id, int line, int col, bool implied, ForwardRef.Type type) {
            Next = next;
            Name = name;
            Prefix = prefix;
            ID = id;
            Line = line;
            Col = col;
            Implied = implied;
            RefType = type;
        }

        internal void Check(SchemaInfo sinfo, Validator validator, ValidationEventHandler eventhandler) {
            Object o = null;
            string code = null;

            switch (RefType) {
            case ForwardRef.Type.ID:
                o = validator.FindID(ID);
                code = Res.Sch_UndeclaredId;
                break;
            case ForwardRef.Type.NOTATION:
                o = sinfo.Notations[ID];
                code = Res.Sch_UndeclaredNotation;
                break;
            }

            if (o == null) {
                string baseuri = (null != validator && null != validator.BaseUri ? validator.BaseUri.AbsolutePath : string.Empty);
                eventhandler(this, new ValidationEventArgs(new XmlSchemaException(code, ID, baseuri, Line, Col)));
            }
        }
    };

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\schema\schemanamespacemanager.cs ===
//------------------------------------------------------------------------------
// <copyright file="SchemaNamespaceManager.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Schema {
    using System;
    using System.Collections;

    internal class SchemaNamespaceManager : XmlNamespaceManager {
        XmlSchemaObject node;

        public SchemaNamespaceManager(XmlSchemaObject node){
            this.node = node;
        }

        public override string LookupNamespace(string prefix) {
            for (XmlSchemaObject current = node; current != null; current = current.Parent) {
                Hashtable namespaces = current.Namespaces.Namespaces;
                if (namespaces != null && namespaces.Count > 0) {
                    object uri = namespaces[prefix];
                    if (uri != null)
                        return (string)uri;
                }
            }
            return prefix == string.Empty ? string.Empty : null;
        }
  }; //SchemaNamespaceManager

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\schema\schemanotation.cs ===
//------------------------------------------------------------------------------
// <copyright file="SchemaNotation.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Schema {

    using System;
    using System.Diagnostics;

    internal sealed class SchemaNotation {
        internal const int   SYSTEM = 0;
        internal const int   PUBLIC = 1;

        private XmlQualifiedName  name;
        private String systemLiteral;   // System literal
        private String pubid;    // pubid literal

        internal SchemaNotation(XmlQualifiedName name) {
            this.name = name;
        }

        internal XmlQualifiedName Name {
            get { return name;}
        }

        internal String SystemLiteral {
            get { return systemLiteral;}
            set { systemLiteral = value;}
        }

        internal String Pubid {
            get { return pubid;}
            set { pubid = value;}
        }

    };

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\schema\schematype.cs ===
//------------------------------------------------------------------------------
// <copyright file="SchemaType.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Schema {

    internal enum SchemaType {
        None,
        DTD,
        XDR,
        XSD
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\schema\validationeventhandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="ValidationEventHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Schema {
    /// <include file='doc\ValidationEventHandler.uex' path='docs/doc[@for="ValidationEventHandler"]/*' />
    /// <devdoc>
    /// </devdoc>
    public delegate void ValidationEventHandler( object sender, ValidationEventArgs e );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\schema\validationeventargs.cs ===
//------------------------------------------------------------------------------
// <copyright file="ValidationEventArgs.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Schema {
    /// <include file='doc\ValidationEventArgs.uex' path='docs/doc[@for="ValidationEventArgs"]/*' />
    /// <devdoc>
    ///    Returns detailed information relating to
    ///    the ValidationEventhandler.
    /// </devdoc>
    public sealed class ValidationEventArgs : EventArgs {
        XmlSchemaException ex;
        XmlSeverityType severity;

        internal ValidationEventArgs( XmlSchemaException ex ) : base() {
            this.ex = ex; 
            severity = XmlSeverityType.Error;
        }
 
        internal ValidationEventArgs( XmlSchemaException ex , XmlSeverityType severity ) : base() {
            this.ex = ex; 
            this.severity = severity;
        }

        //UE Attention
        /// <include file='doc\ValidationEventArgs.uex' path='docs/doc[@for="ValidationEventArgs.Severity"]/*' />
        public XmlSeverityType Severity {
            get { return severity;}
        }

        //UE Attention
        /// <include file='doc\ValidationEventArgs.uex' path='docs/doc[@for="ValidationEventArgs.Exception"]/*' />
        public XmlSchemaException Exception {
            get { return ex;}
        }

        /// <include file='doc\ValidationEventArgs.uex' path='docs/doc[@for="ValidationEventArgs.Message"]/*' />
        /// <devdoc>
        ///    <para>Gets the text description corresponding to the
        ///       validation error.</para>
        /// </devdoc>
        public String Message {
            get { return ex.Message;}
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\schema\validationstate.cs ===
//------------------------------------------------------------------------------
// <copyright file="validationstate.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Schema {
    using System;
    using System.Collections;

    internal sealed class ValidationState {
        public bool              HasMatched;       // whether the element has been verified correctly
        public SchemaElementDecl ElementDecl;            // ElementDecl
        public bool              IsNill;
        public int               Depth;         // The validation state  
        public int               State;         // state of the content model checking
        public bool              NeedValidateChildren;  // whether need to validate the children of this element   
        public XmlQualifiedName  Name;
        public string            Prefix;
        public ContentNode       CurrentNode;
        public Hashtable         MinMaxValues;
        public int               HasNodeMatched;
        public BitSet            AllElementsSet;
        public XmlSchemaContentProcessing ProcessContents;
        public ConstraintStruct[] Constr;
    };

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\schema\xdrbuilder.cs ===
//------------------------------------------------------------------------------
// <copyright file="XdrBuilder.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Schema {

    using System;
    using System.IO;
    using System.Collections;
    using System.Diagnostics; 
    using System.ComponentModel;
    using System.Globalization;
    
    /*
     * The XdrBuilder class parses the XDR Schema and 
     * builds internal validation information 
     */
    internal sealed class XdrBuilder : SchemaBuilder {
        private const int XDR_SCHEMA              = 1;
        private const int XDR_ELEMENTTYPE         = 2; 
        private const int XDR_ATTRIBUTETYPE       = 3;
        private const int XDR_ELEMENT             = 4;
        private const int XDR_ATTRIBUTE           = 5;
        private const int XDR_GROUP               = 6;
        private const int XDR_ELEMENTDATATYPE     = 7;
        private const int XDR_ATTRIBUTEDATATYPE   = 8;

        private const int SCHEMA_FLAGS_NS         = 0x0100;

        private const int STACK_INCREMENT         = 10;


        private const int SCHEMA_ORDER_NONE       = 0;
        private const int SCHEMA_ORDER_MANY       = 1;
        private const int SCHEMA_ORDER_SEQUENCE   = 2;
        private const int SCHEMA_ORDER_CHOICE     = 3;
        private const int SCHEMA_ORDER_ALL        = 4;

        private const int SCHEMA_CONTENT_NONE     = 0;
        private const int SCHEMA_CONTENT_EMPTY    = 1;
        private const int SCHEMA_CONTENT_TEXT     = 2;
        private const int SCHEMA_CONTENT_MIXED    = 3;
        private const int SCHEMA_CONTENT_ELEMENT  = 4;


        private sealed class DeclBaseInfo {
            // used for <element... or <attribute...
            internal XmlQualifiedName        _Name;
            internal string       _Prefix;
            internal XmlQualifiedName        _TypeName;
            internal string       _TypePrefix;
            internal object       _Default;
            internal object       _Revises;
            internal uint         _MaxOccurs;
            internal uint         _MinOccurs;

            // used for checking undeclared attribute type
            internal bool              _Checking;
            internal SchemaElementDecl _ElementDecl;
            internal SchemaAttDef      _Attdef;
            internal DeclBaseInfo      _Next;

            internal DeclBaseInfo() {
                Reset();
            }

            internal void Reset() {
                _Name = XmlQualifiedName.Empty;
                _Prefix = null;
				_TypeName = XmlQualifiedName.Empty;
                _TypePrefix = null;
                _Default = null;
                _Revises = null;
                _MaxOccurs = 1;
                _MinOccurs = 1;
                _Checking = false;
                _ElementDecl = null;
                _Next = null;
                _Attdef = null;
            }
        };

        private sealed class GroupContent {
            internal uint             _MinVal;
            internal uint             _MaxVal;
            internal bool            _HasMaxAttr;
            internal bool            _HasMinAttr;
            internal int             _Order;              

            internal static void Copy(GroupContent from, GroupContent to) {
                to._MinVal = from._MinVal;
                to._MaxVal = from._MaxVal;
                to._Order = from._Order;
            }

            internal static GroupContent Copy(GroupContent other) {
                GroupContent g = new GroupContent();
                Copy(other, g);
                return g;
            }
        };

        private sealed class ElementContent {
            // for <ElementType ...
            internal SchemaElementDecl   _ElementDecl;          // Element Information

            internal int             _ContentAttr;              // content attribute
            internal int             _OrderAttr;                // order attribute

            internal bool            _MasterGroupRequired;      // In a situation like <!ELEMENT root (e1)> e1 has to have a ()
            internal bool            _ExistTerminal;            // when there exist a terminal, we need to addOrder before
            // we can add another terminal
            internal bool            _AllowDataType;            // must have textOnly if we have datatype
            internal bool            _HasDataType;              // got data type

            // for <element ...
            internal bool            _HasType;                  // user must have a type attribute in <element ...
            internal bool            _EnumerationRequired;
            internal uint             _MinVal;
            internal uint             _MaxVal;                   // -1 means infinity

            internal uint             _MaxLength;                // dt:maxLength
            internal uint             _MinLength;                // dt:minLength

            internal Hashtable       _AttDefList;               // a list of current AttDefs for the <ElementType ...
            // only the used one will be added
        };

        private sealed class AttributeContent {
            // used for <AttributeType ...
            internal SchemaAttDef    _AttDef;

            // used to store name & prefix for the AttributeType
            internal XmlQualifiedName           _Name;
            internal string          _Prefix;  
            internal bool            _Required;                  // true:  when the attribute required="yes"

            // used for both AttributeType and attribute
            internal uint             _MinVal;
            internal uint             _MaxVal;                   // -1 means infinity

            internal uint             _MaxLength;                 // dt:maxLength
            internal uint             _MinLength;                 // dt:minLength

            // used for datatype 
            internal bool            _EnumerationRequired;       // when we have dt:value then we must have dt:type="enumeration"
            internal bool            _HasDataType;

            // used for <attribute ...
            internal bool            _Global;

            internal object          _Default;
        };

        private delegate void XdrBuildFunction(XdrBuilder builder, object obj, string prefix);
        private delegate void XdrInitFunction(XdrBuilder builder, object obj);
        private delegate void XdrBeginChildFunction(XdrBuilder builder);
        private delegate void XdrEndChildFunction(XdrBuilder builder);

        private sealed class XdrAttributeEntry {
            internal SchemaNames.ID        _Attribute;     // possible attribute names
            internal int                   _SchemaFlags;
            internal XmlSchemaDatatype     _Datatype;     
            internal XdrBuildFunction      _BuildFunc;     // Corresponding build functions for attribute value

            internal XdrAttributeEntry(SchemaNames.ID a, XmlTokenizedType ttype, XdrBuildFunction build) {
                _Attribute = a;
                _Datatype = XmlSchemaDatatype.FromXmlTokenizedType(ttype);
                _SchemaFlags = 0;
                _BuildFunc = build;
            }
            internal XdrAttributeEntry(SchemaNames.ID a, XmlTokenizedType ttype, int schemaFlags, XdrBuildFunction build) {
                _Attribute = a;
                _Datatype = XmlSchemaDatatype.FromXmlTokenizedType(ttype);
                _SchemaFlags = schemaFlags;
                _BuildFunc = build;
            }
        };

        //
        // XdrEntry controls the states of parsing a schema document
        // and calls the corresponding "init", "end" and "build" functions when necessary
        //
        private sealed class XdrEntry {
            internal SchemaNames.ID         _Name;               // the name of the object it is comparing to
            internal int[]                  _NextStates;         // possible next states
            internal XdrAttributeEntry[]    _Attributes;         // allowed attributes
            internal XdrInitFunction        _InitFunc;           // "init" functions in XdrBuilder
            internal XdrBeginChildFunction  _BeginChildFunc;     // "begin" functions in XdrBuilder for BeginChildren
            internal XdrEndChildFunction    _EndChildFunc;       // "end" functions in XdrBuilder for EndChildren
            internal bool                   _AllowText;          // whether text content is allowed  

            internal XdrEntry(SchemaNames.ID n, 
                              int[] states, 
                              XdrAttributeEntry[] attributes, 
                              XdrInitFunction init, 
                              XdrBeginChildFunction begin, 
                              XdrEndChildFunction end, 
                              bool fText) {
                _Name = n;
                _NextStates = states;
                _Attributes = attributes;
                _InitFunc = init;
                _BeginChildFunc = begin;
                _EndChildFunc = end;
                _AllowText = fText; 
            }
        };


        /////////////////////////////////////////////////////////////////////////////
        // Data structures for XML-Data Reduced (XDR Schema)
        //

        //
        // Elements
        //
        private static readonly int[] S_XDR_Root_Element = {XDR_SCHEMA};
        private static readonly int[] S_XDR_Root_SubElements = {XDR_ELEMENTTYPE, XDR_ATTRIBUTETYPE};
        private static readonly int[] S_XDR_ElementType_SubElements = {XDR_ELEMENT, XDR_GROUP, XDR_ATTRIBUTETYPE, XDR_ATTRIBUTE, XDR_ELEMENTDATATYPE};
        private static readonly int[] S_XDR_AttributeType_SubElements = {XDR_ATTRIBUTEDATATYPE};
        private static readonly int[] S_XDR_Group_SubElements = {XDR_ELEMENT, XDR_GROUP};

        //
        // Attributes
        //
        private static readonly XdrAttributeEntry[] S_XDR_Root_Attributes = 
        {
            new XdrAttributeEntry(SchemaNames.ID.SCHEMA_NAME, XmlTokenizedType.CDATA, new XdrBuildFunction(XDR_BuildRoot_Name) ),
            new XdrAttributeEntry(SchemaNames.ID.SCHEMA_ID,   XmlTokenizedType.QName, new XdrBuildFunction(XDR_BuildRoot_ID) )
        };

        private static readonly XdrAttributeEntry[] S_XDR_ElementType_Attributes =
        {
            new XdrAttributeEntry(SchemaNames.ID.SCHEMA_NAME,        XmlTokenizedType.QName, SCHEMA_FLAGS_NS,  new XdrBuildFunction(XDR_BuildElementType_Name) ),
            new XdrAttributeEntry(SchemaNames.ID.SCHEMA_CONTENT,     XmlTokenizedType.QName,    new XdrBuildFunction(XDR_BuildElementType_Content) ),
            new XdrAttributeEntry(SchemaNames.ID.SCHEMA_MODEL,       XmlTokenizedType.QName,    new XdrBuildFunction(XDR_BuildElementType_Model) ),
            new XdrAttributeEntry(SchemaNames.ID.SCHEMA_ORDER,       XmlTokenizedType.QName,    new XdrBuildFunction(XDR_BuildElementType_Order) ),
            new XdrAttributeEntry(SchemaNames.ID.SCHEMA_DTTYPE,      XmlTokenizedType.CDATA,    new XdrBuildFunction(XDR_BuildElementType_DtType) ),
            new XdrAttributeEntry(SchemaNames.ID.SCHEMA_DTVALUES,    XmlTokenizedType.NMTOKENS, new XdrBuildFunction(XDR_BuildElementType_DtValues) ),
            new XdrAttributeEntry(SchemaNames.ID.SCHEMA_DTMAXLENGTH, XmlTokenizedType.CDATA,    new XdrBuildFunction(XDR_BuildElementType_DtMaxLength) ),
            new XdrAttributeEntry(SchemaNames.ID.SCHEMA_DTMINLENGTH, XmlTokenizedType.CDATA,    new XdrBuildFunction(XDR_BuildElementType_DtMinLength) )
        };

        private static readonly XdrAttributeEntry[] S_XDR_AttributeType_Attributes =
        {
            new XdrAttributeEntry(SchemaNames.ID.SCHEMA_NAME,        XmlTokenizedType.QName,     new XdrBuildFunction(XDR_BuildAttributeType_Name) ),
            new XdrAttributeEntry(SchemaNames.ID.SCHEMA_REQUIRED,    XmlTokenizedType.QName,     new XdrBuildFunction(XDR_BuildAttributeType_Required) ),
            new XdrAttributeEntry(SchemaNames.ID.SCHEMA_DEFAULT,     XmlTokenizedType.CDATA,     new XdrBuildFunction(XDR_BuildAttributeType_Default) ),
            new XdrAttributeEntry(SchemaNames.ID.SCHEMA_DTTYPE,      XmlTokenizedType.QName,     new XdrBuildFunction(XDR_BuildAttributeType_DtType) ),
            new XdrAttributeEntry(SchemaNames.ID.SCHEMA_DTVALUES,    XmlTokenizedType.NMTOKENS,  new XdrBuildFunction(XDR_BuildAttributeType_DtValues) ),
            new XdrAttributeEntry(SchemaNames.ID.SCHEMA_DTMAXLENGTH, XmlTokenizedType.CDATA,     new XdrBuildFunction(XDR_BuildAttributeType_DtMaxLength) ),
            new XdrAttributeEntry(SchemaNames.ID.SCHEMA_DTMINLENGTH, XmlTokenizedType.CDATA,     new XdrBuildFunction(XDR_BuildAttributeType_DtMinLength) )
        };

        private static readonly XdrAttributeEntry[] S_XDR_Element_Attributes = 
        {
            new XdrAttributeEntry(SchemaNames.ID.SCHEMA_TYPE,      XmlTokenizedType.QName, SCHEMA_FLAGS_NS,  new XdrBuildFunction(XDR_BuildElement_Type) ),
            new XdrAttributeEntry(SchemaNames.ID.SCHEMA_MINOCCURS, XmlTokenizedType.CDATA,     new XdrBuildFunction(XDR_BuildElement_MinOccurs) ),
            new XdrAttributeEntry(SchemaNames.ID.SCHEMA_MAXOCCURS, XmlTokenizedType.CDATA,     new XdrBuildFunction(XDR_BuildElement_MaxOccurs) )
        };

        private static readonly XdrAttributeEntry[] S_XDR_Attribute_Attributes =
        {
            new XdrAttributeEntry(SchemaNames.ID.SCHEMA_TYPE,      XmlTokenizedType.QName,   new XdrBuildFunction(XDR_BuildAttribute_Type) ),
            new XdrAttributeEntry(SchemaNames.ID.SCHEMA_REQUIRED,  XmlTokenizedType.QName,   new XdrBuildFunction(XDR_BuildAttribute_Required) ),
            new XdrAttributeEntry(SchemaNames.ID.SCHEMA_DEFAULT,   XmlTokenizedType.CDATA,   new XdrBuildFunction(XDR_BuildAttribute_Default) )
        };

        private static readonly XdrAttributeEntry[] S_XDR_Group_Attributes =
        {
            new XdrAttributeEntry(SchemaNames.ID.SCHEMA_ORDER,     XmlTokenizedType.QName,   new XdrBuildFunction(XDR_BuildGroup_Order) ),
            new XdrAttributeEntry(SchemaNames.ID.SCHEMA_MINOCCURS, XmlTokenizedType.CDATA,   new XdrBuildFunction(XDR_BuildGroup_MinOccurs) ),
            new XdrAttributeEntry(SchemaNames.ID.SCHEMA_MAXOCCURS, XmlTokenizedType.CDATA,   new XdrBuildFunction(XDR_BuildGroup_MaxOccurs) )
        };

        private static readonly XdrAttributeEntry[] S_XDR_ElementDataType_Attributes = 
        {
            new XdrAttributeEntry(SchemaNames.ID.SCHEMA_DTTYPE,       XmlTokenizedType.CDATA,    new XdrBuildFunction(XDR_BuildElementType_DtType) ),
            new XdrAttributeEntry(SchemaNames.ID.SCHEMA_DTVALUES,     XmlTokenizedType.NMTOKENS, new XdrBuildFunction(XDR_BuildElementType_DtValues) ),
            new XdrAttributeEntry(SchemaNames.ID.SCHEMA_DTMAXLENGTH,  XmlTokenizedType.CDATA,    new XdrBuildFunction(XDR_BuildElementType_DtMaxLength) ),
            new XdrAttributeEntry(SchemaNames.ID.SCHEMA_DTMINLENGTH,  XmlTokenizedType.CDATA,    new XdrBuildFunction(XDR_BuildElementType_DtMinLength) ) 
        };

        private static readonly XdrAttributeEntry[] S_XDR_AttributeDataType_Attributes =
        {
            new XdrAttributeEntry(SchemaNames.ID.SCHEMA_DTTYPE,       XmlTokenizedType.QName,    new XdrBuildFunction(XDR_BuildAttributeType_DtType) ),
            new XdrAttributeEntry(SchemaNames.ID.SCHEMA_DTVALUES,     XmlTokenizedType.NMTOKENS, new XdrBuildFunction(XDR_BuildAttributeType_DtValues) ),
            new XdrAttributeEntry(SchemaNames.ID.SCHEMA_DTMAXLENGTH,  XmlTokenizedType.CDATA,    new XdrBuildFunction(XDR_BuildAttributeType_DtMaxLength) ),
            new XdrAttributeEntry(SchemaNames.ID.SCHEMA_DTMINLENGTH,  XmlTokenizedType.CDATA,    new XdrBuildFunction(XDR_BuildAttributeType_DtMinLength) )
            
        };
        //
        // Schema entries
        //
        private static readonly XdrEntry[] S_SchemaEntries =
        {
            new XdrEntry( SchemaNames.ID.EMPTY,     S_XDR_Root_Element, null, 
                          null, 
                          null, 
                          null,
                          false),
            new XdrEntry( SchemaNames.ID.XDR_ROOT,     S_XDR_Root_SubElements, S_XDR_Root_Attributes, 
                          new XdrInitFunction(XDR_InitRoot), 
                          new XdrBeginChildFunction(XDR_BeginRoot),
                          new XdrEndChildFunction(XDR_EndRoot),
                          false),
            new XdrEntry( SchemaNames.ID.XDR_ELEMENTTYPE,    S_XDR_ElementType_SubElements, S_XDR_ElementType_Attributes, 
                          new XdrInitFunction(XDR_InitElementType),    
                          new XdrBeginChildFunction(XDR_BeginElementType),   
                          new XdrEndChildFunction(XDR_EndElementType),
                          false),
            new XdrEntry( SchemaNames.ID.XDR_ATTRIBUTETYPE,  S_XDR_AttributeType_SubElements, S_XDR_AttributeType_Attributes, 
                          new XdrInitFunction(XDR_InitAttributeType),  
                          new XdrBeginChildFunction(XDR_BeginAttributeType), 
                          new XdrEndChildFunction(XDR_EndAttributeType),
                          false),
            new XdrEntry( SchemaNames.ID.XDR_ELEMENT,        null, S_XDR_Element_Attributes, 
                          new XdrInitFunction(XDR_InitElement),        
                          null,                               
                          new XdrEndChildFunction(XDR_EndElement),
                          false),
            new XdrEntry( SchemaNames.ID.XDR_ATTRIBUTE,      null, S_XDR_Attribute_Attributes, 
                          new XdrInitFunction(XDR_InitAttribute),      
                          new XdrBeginChildFunction(XDR_BeginAttribute),                               
                          new XdrEndChildFunction(XDR_EndAttribute),
                          false),
            new XdrEntry( SchemaNames.ID.XDR_GROUP,          S_XDR_Group_SubElements, S_XDR_Group_Attributes, 
                          new XdrInitFunction(XDR_InitGroup),
                          null,     
                          new XdrEndChildFunction(XDR_EndGroup),
                          false), 
            new XdrEntry( SchemaNames.ID.XDR_DATATYPE,       null, S_XDR_ElementDataType_Attributes, 
                          new XdrInitFunction(XDR_InitElementDtType),       
                          null,                               
                          new XdrEndChildFunction(XDR_EndElementDtType),
                          true),
            new XdrEntry( SchemaNames.ID.XDR_DATATYPE,       null, S_XDR_AttributeDataType_Attributes, 
                          new XdrInitFunction(XDR_InitAttributeDtType),       
                          null,                               
                          new XdrEndChildFunction(XDR_EndAttributeDtType),
                          true)
        };

        private SchemaInfo        _SchemaInfo;
        private string            _TargetNamespace;
        private XmlReader         _reader;
        private PositionInfo       positionInfo;
       
        private XdrEntry          _CurState;
        private XdrEntry          _NextState;

        private HWStack           _StateHistory;
        private HWStack           _GroupStack;
        private string            _XdrName;
        private string            _XdrPrefix;

        private ElementContent    _ElementDef;
        private GroupContent      _GroupDef;
        private AttributeContent  _AttributeDef;

        private DeclBaseInfo      _UndefinedAttributeTypes;
        private DeclBaseInfo      _BaseDecl;

        private XmlNameTable      _NameTable;
        private SchemaNames       _SchemaNames;

        private XmlNamespaceManager   _CurNsMgr;
        private string            _Text;

        private ValidationEventHandler validationEventHandler;
        Hashtable _UndeclaredElements = new Hashtable();

        private const string     x_schema = "x-schema:";

        private XmlResolver xmlResolver = null;


        internal XdrBuilder(
                           XmlReader reader,
                           XmlNamespaceManager curmgr, 
                           SchemaInfo sinfo, 
                           string targetNamspace,
                           XmlNameTable nameTable,
                           SchemaNames schemaNames,
                           ValidationEventHandler eventhandler
                           ) {
            _SchemaInfo = sinfo;
            _TargetNamespace = targetNamspace;
            _reader = reader;
            _CurNsMgr = curmgr;
            validationEventHandler = eventhandler;
            _StateHistory = new HWStack(STACK_INCREMENT);
            _ElementDef = new ElementContent();
            _AttributeDef = new AttributeContent();
            _GroupStack = new HWStack(STACK_INCREMENT);
            _GroupDef = new GroupContent();
            _NameTable = nameTable;
            _SchemaNames = schemaNames;
            _CurState = S_SchemaEntries[0];
            positionInfo = PositionInfo.GetPositionInfo(_reader);
            xmlResolver = new XmlUrlResolver();
        }

        internal override bool ProcessElement(string prefix, string name, string ns) {
            XmlQualifiedName qname = new XmlQualifiedName(name, XmlSchemaDatatype.XdrCanonizeUri(ns, _NameTable, _SchemaNames));
            if (GetNextState(qname)) {
                Push();
                if (_CurState._InitFunc != null) {
                    (this._CurState._InitFunc)(this, qname);
                }
                return true;
            }
            else {
                if (!IsSkipableElement(qname)) {
                    SendValidationEvent(Res.Sch_UnsupportedElement, XmlQualifiedName.ToString(name, prefix));
                }
                return false;
            }
        }

        internal override void ProcessAttribute(string prefix, string name, string ns, string value) {
            XmlQualifiedName qname = new XmlQualifiedName(name, XmlSchemaDatatype.XdrCanonizeUri(ns, _NameTable, _SchemaNames));
            for (int i = 0; i < _CurState._Attributes.Length; i++) {
                XdrAttributeEntry a = _CurState._Attributes[i];
                if (_SchemaNames.GetName(a._Attribute).Equals(qname)) {
                    XdrBuildFunction buildFunc = a._BuildFunc;
                    if (a._Datatype.TokenizedType == XmlTokenizedType.QName) {
                        string prefixValue;
                        XmlQualifiedName qnameValue = XmlQualifiedName.Parse(value, _NameTable, _CurNsMgr, out prefixValue);
                        if (prefixValue != string.Empty) {
                            if (a._Attribute != SchemaNames.ID.SCHEMA_TYPE) {    // <attribute type= || <element type= 
                                throw new XmlException(Res.Xml_UnexpectedToken, XmlToken.ToString(XmlToken.NAME));
                            }
                        }
                        else if (IsGlobal(a._SchemaFlags)) {
                            qnameValue = new XmlQualifiedName(qnameValue.Name, _TargetNamespace);
                        }
                        else {
                            qnameValue = new XmlQualifiedName(qnameValue.Name);
                        }
                        buildFunc(this, qnameValue, prefixValue);
                    } else {
                        buildFunc(this, a._Datatype.ParseValue(value, _NameTable, _CurNsMgr), string.Empty);
                    }
                    return;
                }
            }

            if ((object)ns == (object)_SchemaNames.NsXmlNs && IsXdrSchema(value)) {
                LoadSchema(value);
                return;
            }

            // Check non-supported attribute
            if (!IsSkipableAttribute(qname) ) {
                SendValidationEvent(Res.Sch_UnsupportedAttribute, 
                                    XmlQualifiedName.ToString(qname.Name, prefix));
            }
        }

        internal XmlResolver XmlResolver {
            set {
                xmlResolver = value;
            }
        }
        

        private bool LoadSchema(string uri) {
            if (xmlResolver == null) {
                return false;
            }

            uri = _NameTable.Add(uri);
            if (_SchemaInfo.HasSchema(uri)) {
                return false;
            }
            SchemaInfo schemaInfo = null;
            Uri _baseUri = xmlResolver.ResolveUri(null,_reader.BaseURI);
            XmlReader reader = null;
            try {
                
                Uri ruri = xmlResolver.ResolveUri(_baseUri, uri.Substring(x_schema.Length));
                Stream stm = (Stream)xmlResolver.GetEntity(ruri,null,null);
                reader = new XmlTextReader(ruri.ToString(), stm, _NameTable);
                schemaInfo = new SchemaInfo(_SchemaNames);
		Parser parser = new Parser(null, _NameTable, _SchemaNames, validationEventHandler);
		parser.XmlResolver = xmlResolver;
                parser.Parse(reader, uri, schemaInfo);
            }
            catch(XmlException e) {
                SendValidationEvent(Res.Sch_CannotLoadSchema, new string[] {uri, e.Message}, XmlSeverityType.Warning);
                schemaInfo = null;
            }
            finally {
                if (reader != null) {
                    reader.Close();
                }
            }
            if (schemaInfo != null && schemaInfo.ErrorCount == 0) {
                _SchemaInfo.Add(uri, schemaInfo, validationEventHandler);
                return true;
            }
            return false;
        }

        private bool IsXdrSchema(string uri) {
            return uri.Length >= x_schema.Length &&
                   0 == string.Compare(uri, 0, x_schema, 0, x_schema.Length, false, CultureInfo.InvariantCulture) &&
                   !uri.StartsWith("x-schema:#");
        }

        internal override bool IsContentParsed() {
            return true;
        }

        internal override void ProcessMarkup(XmlNode[] markup) {
            throw new InvalidOperationException(Res.GetString(Res.Xml_InvalidOperation)); // should never be called
        }

        internal override void ProcessCData(string value) {
            if (_CurState._AllowText) {
                _Text = value;
            }
            else {
                SendValidationEvent(Res.Sch_TextNotAllowed, value);
            }
        }

        internal override void StartChildren() {
            if (_CurState._BeginChildFunc != null) {
                (this._CurState._BeginChildFunc)(this);
            }
        }

        internal override void EndChildren() {
            if (_CurState._EndChildFunc != null) {
                (this._CurState._EndChildFunc)(this);
            }

            Pop();
        }

        //
        // State stack push & pop
        //
        private void Push() {
            _StateHistory.Push();
            _StateHistory[_StateHistory.Length - 1] = _CurState;
            _CurState = _NextState;
        }

        private void Pop() {
            _CurState = (XdrEntry)_StateHistory.Pop();
        }


        //
        // Group stack push & pop
        //
        private void PushGroupInfo() {
            _GroupStack.Push();
            _GroupStack[_GroupStack.Length - 1] = GroupContent.Copy(_GroupDef);
        }

        private void PopGroupInfo() {
            _GroupDef = (GroupContent)_GroupStack.Pop();
            Debug.Assert(_GroupDef != null);
        }

        //
        // XDR Schema
        //
        private static void XDR_InitRoot(XdrBuilder builder, object obj) {
            builder._SchemaInfo.SchemaType = SchemaType.XDR;
            builder._ElementDef._ElementDecl = null;
            builder._ElementDef._AttDefList = null;
            builder._AttributeDef._AttDef = null;
        }

        private static void XDR_BuildRoot_Name(XdrBuilder builder, object obj, string prefix) {
            builder._XdrName = (string) obj;
            builder._XdrPrefix = prefix;
        }

        private static void XDR_BuildRoot_ID(XdrBuilder builder, object obj, string prefix) {

        }

        private static void XDR_BeginRoot(XdrBuilder builder) {
            if (builder._TargetNamespace == null) { // inline xdr schema
                if (builder._XdrName != null) {
                    builder._TargetNamespace = builder._NameTable.Add("x-schema:#" + builder._XdrName);
                }
                else {
                    builder._TargetNamespace = String.Empty;
                }
            }
            builder._SchemaInfo.CurrentSchemaNamespace = builder._TargetNamespace;
        }

        private static void XDR_EndRoot(XdrBuilder builder) {
            //
            // check undefined attribute types
            // We already checked local attribute types, so only need to check global attribute types here 
            //
            while (builder._UndefinedAttributeTypes != null) {
                XmlQualifiedName gname = builder._UndefinedAttributeTypes._TypeName;

                // if there is no URN in this name then the name is local to the
                // schema, but the global attribute was still URN qualified, so
                // we need to qualify this name now.
                if (gname.Namespace == string.Empty) {
                    gname = new XmlQualifiedName(gname.Name, builder._TargetNamespace);
                }
                SchemaAttDef ad = (SchemaAttDef)builder._SchemaInfo.AttributeDecls[gname];
                if (ad != null) {
                    builder._UndefinedAttributeTypes._Attdef = (SchemaAttDef)ad.Clone();
                    builder._UndefinedAttributeTypes._Attdef.Name = gname;
                    builder.XDR_CheckAttributeDefault(builder._UndefinedAttributeTypes, builder._UndefinedAttributeTypes._Attdef);
                }
                else {
                    builder.SendValidationEvent(Res.Sch_UndeclaredAttribute, gname.Name);
                }
                builder._UndefinedAttributeTypes = builder._UndefinedAttributeTypes._Next;
            }

            foreach (SchemaElementDecl ed in builder._UndeclaredElements.Values) {
                builder.SendValidationEvent(Res.Sch_UndeclaredElement, XmlQualifiedName.ToString(ed.Name.Name, ed.Prefix));
            }



        }


        //
        // XDR ElementType
        //

        private static void XDR_InitElementType(XdrBuilder builder, object obj) {
            builder._ElementDef._ElementDecl = new SchemaElementDecl(); 
            builder._ElementDef._ElementDecl.Content = new CompiledContentModel(builder._SchemaNames);
            builder._ElementDef._ElementDecl.Content.Start();
            builder._ElementDef._ElementDecl.Content.IsOpen = true;

            builder._ElementDef._ContentAttr = SCHEMA_CONTENT_NONE;
            builder._ElementDef._OrderAttr = SCHEMA_ORDER_NONE;
            builder._ElementDef._MasterGroupRequired = false; 
            builder._ElementDef._ExistTerminal = false;
            builder._ElementDef._AllowDataType = true;
            builder._ElementDef._HasDataType = false;
            builder._ElementDef._EnumerationRequired= false;
            builder._ElementDef._AttDefList = new Hashtable();
            builder._ElementDef._MaxLength = uint.MaxValue;
            builder._ElementDef._MinLength = uint.MaxValue;

            //        builder._AttributeDef._HasDataType = false;
            //        builder._AttributeDef._Default = null;
        }

        private static void XDR_BuildElementType_Name(XdrBuilder builder, object obj, string prefix) {
            XmlQualifiedName qname = (XmlQualifiedName) obj;

            if (builder._SchemaInfo.ElementDecls[qname] != null) {
                builder.SendValidationEvent(Res.Sch_DupElementDecl, XmlQualifiedName.ToString(qname.Name, prefix));
            }
            builder._ElementDef._ElementDecl.Name = qname;
            builder._ElementDef._ElementDecl.Prefix = prefix;
            builder._SchemaInfo.ElementDecls.Add(qname, builder._ElementDef._ElementDecl);
            if (builder._UndeclaredElements[qname] != null) {
                builder._UndeclaredElements.Remove(qname);
            }
        }

        private static void XDR_BuildElementType_Content(XdrBuilder builder, object obj, string prefix) {
            builder._ElementDef._ContentAttr = builder.GetContent((XmlQualifiedName)obj);
        }

        private static void XDR_BuildElementType_Model(XdrBuilder builder, object obj, string prefix) {
            builder._ElementDef._ElementDecl.Content.IsOpen = builder.GetModel((XmlQualifiedName)obj);
        }

        private static void XDR_BuildElementType_Order(XdrBuilder builder, object obj, string prefix) {
            builder._ElementDef._OrderAttr = builder._GroupDef._Order = builder.GetOrder((XmlQualifiedName)obj);
        }

        private static void XDR_BuildElementType_DtType(XdrBuilder builder, object obj, string prefix) {
            builder._ElementDef._HasDataType = true;
            string s = ((string)obj).Trim();
            if (s.Length == 0) {
                builder.SendValidationEvent(Res.Sch_MissDtvalue);
            }
            else {
                XmlSchemaDatatype dtype = XmlSchemaDatatype.FromXdrName(s);
                if (dtype == null) {
                    builder.SendValidationEvent(Res.Sch_UnknownDtType, s);
                }
                builder._ElementDef._ElementDecl.Datatype = dtype;
            }
        }

        private static void XDR_BuildElementType_DtValues(XdrBuilder builder, object obj, string prefix) {
            builder._ElementDef._EnumerationRequired = true;
            builder._ElementDef._ElementDecl.Values = new ArrayList((string[]) obj); 
        }

        private static void XDR_BuildElementType_DtMaxLength(XdrBuilder builder, object obj, string prefix) {
            ParseDtMaxLength(ref builder._ElementDef._MaxLength, obj, builder);
        }

        private static void XDR_BuildElementType_DtMinLength(XdrBuilder builder, object obj, string prefix) {
            ParseDtMinLength(ref builder._ElementDef._MinLength, obj, builder);
        }

        private static void XDR_BeginElementType(XdrBuilder builder) {
            string code = null;
            string msg = null;

            //
            // check name attribute
            //
            if (builder._ElementDef._ElementDecl.Name.IsEmpty) {
                code = Res.Sch_MissAttribute;
                msg = "name";
                goto cleanup;
            }

            //
            // check dt:type attribute
            //
            if (builder._ElementDef._HasDataType) {
                if (!builder._ElementDef._AllowDataType) {
                    code = Res.Sch_DataTypeTextOnly;
                    goto cleanup;
                }
                else {
                    builder._ElementDef._ContentAttr = SCHEMA_CONTENT_TEXT;
                }
            }
            else if (builder._ElementDef._ContentAttr == SCHEMA_CONTENT_NONE) {
                switch (builder._ElementDef._OrderAttr) {
                    case SCHEMA_ORDER_NONE:
                        builder._ElementDef._ContentAttr = SCHEMA_CONTENT_MIXED;
                        builder._ElementDef._OrderAttr = SCHEMA_ORDER_MANY;
                        break;
                    case SCHEMA_ORDER_SEQUENCE:
                        builder._ElementDef._ContentAttr = SCHEMA_CONTENT_ELEMENT;
                        break;
                    case SCHEMA_ORDER_CHOICE:
                        builder._ElementDef._ContentAttr = SCHEMA_CONTENT_ELEMENT;
                        break;
                    case SCHEMA_ORDER_MANY:
                        builder._ElementDef._ContentAttr = SCHEMA_CONTENT_MIXED;
                        break;
                }
            }


            //
            // check content model
            //
            if (builder._ElementDef._ContentAttr != SCHEMA_CONTENT_EMPTY) {
                ElementContent def = builder._ElementDef;
                CompiledContentModel content = def._ElementDecl.Content;

                def._MasterGroupRequired = true;
                content.OpenGroup();

                switch (def._ContentAttr) {
                    case SCHEMA_CONTENT_MIXED:
                        if (def._OrderAttr == SCHEMA_ORDER_NONE || def._OrderAttr == SCHEMA_ORDER_MANY) {
                            builder._GroupDef._Order = SCHEMA_ORDER_MANY;
                        }
                        else {
                            code = Res.Sch_MixedMany;
                            goto cleanup;
                        }                       

                        content.ContentType = CompiledContentModel.Type.Mixed;
                        content.AddTerminal(builder._SchemaNames.QnPCData, null, builder.validationEventHandler);
                        def._ExistTerminal = true;
                        break;

                    case SCHEMA_CONTENT_ELEMENT:
                        if (def._OrderAttr == SCHEMA_ORDER_NONE) {
                            builder._GroupDef._Order = SCHEMA_ORDER_SEQUENCE;
                        }

                        content.ContentType = CompiledContentModel.Type.ElementOnly;
                        break;

                    case SCHEMA_CONTENT_TEXT:        
                        content.AddTerminal(builder._SchemaNames.QnPCData, null, builder.validationEventHandler);
                        content.ContentType = CompiledContentModel.Type.Text;
                        builder._GroupDef._Order = SCHEMA_ORDER_MANY;
                        def._ExistTerminal = true;
                        break;
                }
            } 
            else {//(builder._ElementDef._ContentAttr == SCHEMA_CONTENT_EMPTY)
                ElementContent def = builder._ElementDef;
                CompiledContentModel content = def._ElementDecl.Content;
                content.ContentType = CompiledContentModel.Type.Empty;
            }
            
            cleanup:
            if (code != null) {
                builder.SendValidationEvent(code, msg);
            }
        }

        private static void XDR_EndElementType(XdrBuilder builder) {
            SchemaElementDecl ed = builder._ElementDef._ElementDecl;
            CompiledContentModel content = ed.Content;

            // check undefined attribute types first
            if (builder._UndefinedAttributeTypes != null && builder._ElementDef._AttDefList != null) {
                DeclBaseInfo patt = builder._UndefinedAttributeTypes;
                DeclBaseInfo p1 = patt;

                while (patt != null) {
                    SchemaAttDef pAttdef = null;

                    if (patt._ElementDecl == ed) {
                        XmlQualifiedName pName = patt._TypeName;
                        pAttdef = (SchemaAttDef)builder._ElementDef._AttDefList[pName];
                        if (pAttdef != null) {
                            patt._Attdef = (SchemaAttDef)pAttdef.Clone();
                            patt._Attdef.Name = pName;
                            builder.XDR_CheckAttributeDefault(patt, pAttdef);

                            // remove it from _pUndefinedAttributeTypes
                            if (patt == builder._UndefinedAttributeTypes) {
                                patt = builder._UndefinedAttributeTypes = patt._Next;
                                p1 = patt;
                            }
                            else {
                                p1._Next = patt._Next;
                                patt = p1._Next;
                            }
                        }
                    }

                    if (pAttdef == null) {
                        if (patt != builder._UndefinedAttributeTypes)
                            p1 = p1._Next;
                        patt = patt._Next;
                    }
                }
            }

            if (builder._ElementDef._MasterGroupRequired) {
                if (!builder._ElementDef._ExistTerminal) {
                    if (content.IsOpen) {
                        content.ContentType = CompiledContentModel.Type.Any;
                        // must have something here, since we opened up a group...  since when we have no elements
                        // and content="eltOnly" model="open"  we can have anything here...
                        content.AddTerminal(builder._SchemaNames.QnPCData, null, null);
                    }
                    else {
                        // we must have elements when we say content="eltOnly" model="close"
                        builder.SendValidationEvent(Res.Sch_ElementMissing);
                    }
                }

                // if the content is mixed, there is a group that need to be closed
                content.CloseGroup();

                if (builder._GroupDef._Order == SCHEMA_ORDER_MANY) {
                    content.Star();
                }
            }
            if (ed.Datatype != null) {
                XmlTokenizedType ttype = ed.Datatype.TokenizedType;
                if (ttype == XmlTokenizedType.ENUMERATION && 
                    !builder._ElementDef._EnumerationRequired) {
                    builder.SendValidationEvent(Res.Sch_MissDtvaluesAttribute);
                }

                if (ttype != XmlTokenizedType.ENUMERATION && 
                    builder._ElementDef._EnumerationRequired) {
                    builder.SendValidationEvent(Res.Sch_RequireEnumeration);
                }
            }
            CompareMinMaxLength(builder._ElementDef._MinLength, builder._ElementDef._MaxLength, builder);
            ed.MaxLength = (long)builder._ElementDef._MaxLength;
            ed.MinLength = (long)builder._ElementDef._MinLength;

            content.Finish(builder.validationEventHandler, true);

            builder._ElementDef._ElementDecl = null;
            builder._ElementDef._AttDefList = null;
        }


        //
        // XDR AttributeType
        // 

        private static void XDR_InitAttributeType(XdrBuilder builder, object obj) {
            AttributeContent ad = builder._AttributeDef;
            ad._AttDef = new SchemaAttDef(XmlQualifiedName.Empty, null);

            ad._Required = false;
            ad._Prefix = null;

            ad._Default = null;
            ad._MinVal = 0; // optional by default.
            ad._MaxVal = 1;

            // used for datatype
            ad._EnumerationRequired = false;
            ad._HasDataType = false;
            ad._Global = (builder._StateHistory.Length == 2);

            ad._MaxLength = uint.MaxValue;
            ad._MinLength = uint.MaxValue;
        }

        private static void XDR_BuildAttributeType_Name(XdrBuilder builder, object obj, string prefix) {
            XmlQualifiedName qname = (XmlQualifiedName) obj;

            builder._AttributeDef._Name = qname;
            builder._AttributeDef._Prefix = prefix;
            builder._AttributeDef._AttDef.Name = qname;

            if (builder._ElementDef._ElementDecl != null) {  // Local AttributeType
                if (builder._ElementDef._AttDefList[qname] == null) {
                    builder._ElementDef._AttDefList.Add(qname, builder._AttributeDef._AttDef);
                }
                else {
                    builder.SendValidationEvent(Res.Sch_DupAttribute, XmlQualifiedName.ToString(qname.Name, prefix));
                }
            }
            else {  // Global AttributeType
                // Global AttributeTypes are URN qualified so that we can look them up across schemas.
                qname = new XmlQualifiedName(qname.Name, builder._TargetNamespace);
                builder._AttributeDef._AttDef.Name = qname;
                if (builder._SchemaInfo.AttributeDecls[qname] == null) {
                    builder._SchemaInfo.AttributeDecls.Add(qname, builder._AttributeDef._AttDef);
                }
                else {
                    builder.SendValidationEvent(Res.Sch_DupAttribute, XmlQualifiedName.ToString(qname.Name, prefix));
                }
            }
        }

        private static void XDR_BuildAttributeType_Required(XdrBuilder builder, object obj, string prefix) {
            builder._AttributeDef._Required = IsYes(obj, builder);
        }

        private static void XDR_BuildAttributeType_Default(XdrBuilder builder, object obj, string prefix) {
            builder._AttributeDef._Default = obj;
        }

        private static void XDR_BuildAttributeType_DtType(XdrBuilder builder, object obj, string prefix) {
            XmlQualifiedName qname = (XmlQualifiedName)obj;
            builder._AttributeDef._HasDataType = true;
            builder._AttributeDef._AttDef.Datatype = builder.CheckDatatype(qname.Name);
        }

        private static void XDR_BuildAttributeType_DtValues(XdrBuilder builder, object obj, string prefix) {
            builder._AttributeDef._EnumerationRequired = true;
            builder._AttributeDef._AttDef.Values = new ArrayList((string[]) obj);
        }

        private static void XDR_BuildAttributeType_DtMaxLength(XdrBuilder builder, object obj, string prefix) {
            ParseDtMaxLength(ref builder._AttributeDef._MaxLength, obj, builder);
        }

        private static void XDR_BuildAttributeType_DtMinLength(XdrBuilder builder, object obj, string prefix) {
            ParseDtMinLength(ref builder._AttributeDef._MinLength, obj, builder);
        }

        private static void XDR_BeginAttributeType(XdrBuilder builder) {
            if (builder._AttributeDef._Name.IsEmpty) {
                builder.SendValidationEvent(Res.Sch_MissAttribute);
            }
        }

        private static void XDR_EndAttributeType(XdrBuilder builder) {
            string code = null;
            if (builder._AttributeDef._HasDataType && builder._AttributeDef._AttDef.Datatype != null) {
                XmlTokenizedType ttype = builder._AttributeDef._AttDef.Datatype.TokenizedType;

                if (ttype == XmlTokenizedType.ENUMERATION && !builder._AttributeDef._EnumerationRequired) {
                    code = Res.Sch_MissDtvaluesAttribute;
                    goto cleanup;
                }

                if (ttype != XmlTokenizedType.ENUMERATION && builder._AttributeDef._EnumerationRequired) {
                    code = Res.Sch_RequireEnumeration;
                    goto cleanup;
                }

                // a attributes of type id is not supposed to have a default value
                if (builder._AttributeDef._Default != null && ttype ==  XmlTokenizedType.ID) {
                    code = Res.Sch_DefaultIdValue;
                    goto cleanup;
                }
            } 
            else {
                builder._AttributeDef._AttDef.Datatype = XmlSchemaDatatype.FromXmlTokenizedType(XmlTokenizedType.CDATA);
            }

            //
            // constraints
            //
            CompareMinMaxLength(builder._AttributeDef._MinLength, builder._AttributeDef._MaxLength, builder);
            builder._AttributeDef._AttDef.MaxLength = builder._AttributeDef._MaxLength;
            builder._AttributeDef._AttDef.MinLength = builder._AttributeDef._MinLength;

            //
            // checkAttributeType 
            //
            if (builder._AttributeDef._Default != null) {
                builder._AttributeDef._AttDef.DefaultValueRaw = builder._AttributeDef._AttDef.DefaultValueExpanded =  (string)builder._AttributeDef._Default;
                builder.CheckDefaultAttValue(builder._AttributeDef._AttDef);
            }

            builder.SetAttributePresence(builder._AttributeDef._AttDef, builder._AttributeDef._Required);

            cleanup:
            if (code != null) {
                builder.SendValidationEvent(code);
            }
        }


        //
        // XDR Element
        //

        private static void XDR_InitElement(XdrBuilder builder, object obj) {
            if (builder._ElementDef._HasDataType ||
                (builder._ElementDef._ContentAttr == SCHEMA_CONTENT_EMPTY) ||
                (builder._ElementDef._ContentAttr == SCHEMA_CONTENT_TEXT)) {
                builder.SendValidationEvent(Res.Sch_ElementNotAllowed);
            }

            builder._ElementDef._AllowDataType = false;

            builder._ElementDef._HasType = false;
            builder._ElementDef._MinVal = 1;
            builder._ElementDef._MaxVal = 1;
        }

        private static void XDR_BuildElement_Type(XdrBuilder builder, object obj, string prefix) {
            XmlQualifiedName qname = (XmlQualifiedName) obj;

            if (builder._SchemaInfo.ElementDecls[qname] == null) {
                SchemaElementDecl ed = (SchemaElementDecl)builder._UndeclaredElements[qname];
                if (ed == null) {
                    ed = new SchemaElementDecl(qname, prefix, SchemaType.DTD, builder._SchemaNames);
                    builder._UndeclaredElements.Add(qname, ed);
                }
            }

            builder._ElementDef._HasType = true;  
            if (builder._ElementDef._ExistTerminal)
                builder.AddOrder();
            else
                builder._ElementDef._ExistTerminal = true;

            builder._ElementDef._ElementDecl.Content.AddTerminal(qname, prefix, builder.validationEventHandler);  
        }

        private static void XDR_BuildElement_MinOccurs(XdrBuilder builder, object obj, string prefix) {
            builder._ElementDef._MinVal = ParseMinOccurs(obj, builder);
        }

        private static void XDR_BuildElement_MaxOccurs(XdrBuilder builder, object obj, string prefix) {
            builder._ElementDef._MaxVal = ParseMaxOccurs(obj, builder);
        }


        //    private static void XDR_BeginElement(XdrBuilder builder)
        //  {
        //
        //  }


        private static void XDR_EndElement(XdrBuilder builder) {
            if (builder._ElementDef._HasType) {
                HandleMinMax(builder._ElementDef._ElementDecl.Content,
                             builder._ElementDef._MinVal, 
                             builder._ElementDef._MaxVal);
            }
            else {
                builder.SendValidationEvent(Res.Sch_MissAttribute);
            }
        }


        //
        // XDR Attribute
        //

        private static void XDR_InitAttribute(XdrBuilder builder, object obj) {
            if (builder._BaseDecl == null)
                builder._BaseDecl = new DeclBaseInfo();
            builder._BaseDecl._MinOccurs = 0;
        }

        private static void XDR_BuildAttribute_Type(XdrBuilder builder, object obj, string prefix) {
            builder._BaseDecl._TypeName = (XmlQualifiedName)obj;
            builder._BaseDecl._Prefix = prefix;
        }

        private static void XDR_BuildAttribute_Required(XdrBuilder builder, object obj, string prefix) {
            if (IsYes(obj, builder)) {
                builder._BaseDecl._MinOccurs = 1;
            }
        }

        private static void XDR_BuildAttribute_Default(XdrBuilder builder, object obj, string prefix) {
            builder._BaseDecl._Default = obj;
        }

        private static void XDR_BeginAttribute(XdrBuilder builder) {
            if (builder._BaseDecl._TypeName.IsEmpty) {
                builder.SendValidationEvent(Res.Sch_MissAttribute);
            }

            SchemaAttDef attdef = null;
            XmlQualifiedName qname = builder._BaseDecl._TypeName;
            string prefix = builder._BaseDecl._Prefix;

            // local?
            if (builder._ElementDef._AttDefList != null) {
                attdef = (SchemaAttDef)builder._ElementDef._AttDefList[qname];
            }

            // global?
            if (attdef == null) {
                // if there is no URN in this name then the name is local to the
                // schema, but the global attribute was still URN qualified, so
                // we need to qualify this name now.
                XmlQualifiedName gname = qname;
                if (prefix == string.Empty)
                    gname = new XmlQualifiedName(qname.Name, builder._TargetNamespace);
                SchemaAttDef ad = (SchemaAttDef)builder._SchemaInfo.AttributeDecls[gname];
                if (ad != null) {
                    attdef = (SchemaAttDef)ad.Clone();
                    attdef.Name = qname;
                }
                else if (prefix != string.Empty) {
                    builder.SendValidationEvent(Res.Sch_UndeclaredAttribute, XmlQualifiedName.ToString(qname.Name, prefix));
                }
            }

            if (attdef != null) {
                builder.XDR_CheckAttributeDefault(builder._BaseDecl, attdef);
            }
            else {
                // will process undeclared types later
                attdef = new SchemaAttDef(qname, prefix);
                DeclBaseInfo decl = new DeclBaseInfo();
                decl._Checking = true;
                decl._Attdef = attdef;
                decl._TypeName = builder._BaseDecl._TypeName;
                decl._ElementDecl = builder._ElementDef._ElementDecl;
                decl._MinOccurs = builder._BaseDecl._MinOccurs;
                decl._Default = builder._BaseDecl._Default;

                // add undefined attribute types
                decl._Next = builder._UndefinedAttributeTypes;
                builder._UndefinedAttributeTypes = decl;
            }

            builder._ElementDef._ElementDecl.AddAttDef(attdef);
        }

        private static void XDR_EndAttribute(XdrBuilder builder) {
            builder._BaseDecl.Reset();
        }


        //
        // XDR Group
        //

        private static void XDR_InitGroup(XdrBuilder builder, object obj) {
            if (builder._ElementDef._ContentAttr == SCHEMA_CONTENT_EMPTY ||
                builder._ElementDef._ContentAttr == SCHEMA_CONTENT_TEXT ) {
                builder.SendValidationEvent(Res.Sch_GroupDisabled);
            }

            builder.PushGroupInfo();

            builder._GroupDef._MinVal = 1;
            builder._GroupDef._MaxVal = 1;
            builder._GroupDef._HasMaxAttr = false;
            builder._GroupDef._HasMinAttr = false;

            if (builder._ElementDef._ExistTerminal)
                builder.AddOrder();

            // now we are in a group so we reset fExistTerminal
            builder._ElementDef._ExistTerminal = false;

            builder._ElementDef._ElementDecl.Content.OpenGroup();
        }

        private static void XDR_BuildGroup_Order(XdrBuilder builder, object obj, string prefix) {
            builder._GroupDef._Order = builder.GetOrder((XmlQualifiedName)obj);
            if (builder._ElementDef._ContentAttr == SCHEMA_CONTENT_MIXED && builder._GroupDef._Order != SCHEMA_ORDER_MANY) {
                builder.SendValidationEvent(Res.Sch_MixedMany);
            }
        }

        private static void XDR_BuildGroup_MinOccurs(XdrBuilder builder, object obj, string prefix) {
            builder._GroupDef._MinVal = ParseMinOccurs(obj, builder);
            builder._GroupDef._HasMinAttr = true;
        }

        private static void XDR_BuildGroup_MaxOccurs(XdrBuilder builder, object obj, string prefix) {
            builder._GroupDef._MaxVal = ParseMaxOccurs(obj, builder);
            builder._GroupDef._HasMaxAttr = true;
        }


        //    private static void XDR_BeginGroup(XdrBuilder builder)
        //    {
        //
        //    }


        private static void XDR_EndGroup(XdrBuilder builder) {
            if (!builder._ElementDef._ExistTerminal) {
                builder.SendValidationEvent(Res.Sch_ElementMissing);
            }

            builder._ElementDef._ElementDecl.Content.CloseGroup();

            if (builder._GroupDef._Order == SCHEMA_ORDER_MANY) {
                    builder._ElementDef._ElementDecl.Content.Star();
            }
            
            if (SCHEMA_ORDER_MANY == builder._GroupDef._Order &&
                builder._GroupDef._HasMaxAttr &&
                builder._GroupDef._MaxVal != uint.MaxValue) {
                builder.SendValidationEvent(Res.Sch_ManyMaxOccurs);
            }

            HandleMinMax(builder._ElementDef._ElementDecl.Content,
                         builder._GroupDef._MinVal, 
                         builder._GroupDef._MaxVal);

            builder.PopGroupInfo();
        }


        //
        // DataType
        //

        private static void XDR_InitElementDtType(XdrBuilder builder, object obj) {
            if (builder._ElementDef._HasDataType) {
                builder.SendValidationEvent(Res.Sch_DupDtType);
            }

            if (!builder._ElementDef._AllowDataType) {
                builder.SendValidationEvent(Res.Sch_DataTypeTextOnly);
            }
        }

        private static void XDR_EndElementDtType(XdrBuilder builder) {
            if (!builder._ElementDef._HasDataType) {
                builder.SendValidationEvent(Res.Sch_MissAttribute);
            }

            builder._ElementDef._ElementDecl.Content.ContentType = CompiledContentModel.Type.Text;
            builder._ElementDef._ContentAttr = SCHEMA_CONTENT_TEXT;
        }

        private static void XDR_InitAttributeDtType(XdrBuilder builder, object obj) {
            if (builder._AttributeDef._HasDataType) {
                builder.SendValidationEvent(Res.Sch_DupDtType);
            }
        }

        private static void XDR_EndAttributeDtType(XdrBuilder builder) {
            string code = null;

            if (!builder._AttributeDef._HasDataType) {
                code = Res.Sch_MissAttribute;
            } 
            else {
                if(builder._AttributeDef._AttDef.Datatype != null) {
                    XmlTokenizedType ttype = builder._AttributeDef._AttDef.Datatype.TokenizedType;

                    if (ttype == XmlTokenizedType.ENUMERATION && !builder._AttributeDef._EnumerationRequired) {
                        code = Res.Sch_MissDtvaluesAttribute;
                    }
                    else if (ttype != XmlTokenizedType.ENUMERATION && builder._AttributeDef._EnumerationRequired) {
                        code = Res.Sch_RequireEnumeration;
                    }
                }
            }
            if (code != null) {
                builder.SendValidationEvent(code);
            }
        }

        //
        // private utility methods
        //

        private bool GetNextState(XmlQualifiedName qname) {
            if (_CurState._NextStates != null) {
                for (int i = 0; i < _CurState._NextStates.Length; i ++) {
                    if (_SchemaNames.GetName(S_SchemaEntries[_CurState._NextStates[i]]._Name).Equals(qname)) {
                        _NextState = S_SchemaEntries[_CurState._NextStates[i]];
                        return true;
                    }
                }
            }

            return false;
        }

        private bool IsSkipableElement(XmlQualifiedName qname) {
            string ns = qname.Namespace;
            if (ns != null && ! Ref.Equal(ns, _SchemaNames.NsXdr))
                return true;

            // skip description && extends
            if (_SchemaNames.GetName(SchemaNames.ID.XDR_DESCRIPTION).Equals(qname) ||
                _SchemaNames.GetName(SchemaNames.ID.XDR_EXTENDS).Equals(qname))
                return true;

            return false;
        }

        private bool IsSkipableAttribute(XmlQualifiedName qname) {
            string ns = qname.Namespace;
            if (
                ns != string.Empty &&
                ! Ref.Equal(ns, _SchemaNames.NsXdr) && 
                ! Ref.Equal(ns, _SchemaNames.NsDataType)
             ) {
                return true;
            }

            if (Ref.Equal(ns, _SchemaNames.NsDataType) && 
                _CurState._Name == SchemaNames.ID.XDR_DATATYPE &&
                (_SchemaNames.QnDtMax.Equals(qname) ||
                 _SchemaNames.QnDtMin.Equals(qname) ||
                 _SchemaNames.QnDtMaxExclusive.Equals(qname) ||
                 _SchemaNames.QnDtMinExclusive.Equals(qname) )) {
                return true;
            }

            return false;
        }

        private int GetOrder(XmlQualifiedName qname) {
            int order = 0;
            if (_SchemaNames.GetName(SchemaNames.ID.SCHEMA_SEQ).Equals(qname)) {
                order = SCHEMA_ORDER_SEQUENCE;
            }
            else if (_SchemaNames.GetName(SchemaNames.ID.SCHEMA_ONE).Equals(qname)) {
                order = SCHEMA_ORDER_CHOICE;
            }
            else if (_SchemaNames.GetName(SchemaNames.ID.SCHEMA_MANY).Equals(qname)) {
                order = SCHEMA_ORDER_MANY;
            }
            else {
                SendValidationEvent(Res.Sch_UnknownOrder, qname.Name);
            }

            return order;
        }

        private void AddOrder() {
            // additional order can be add on by changing the setOrder and addOrder
            switch (_GroupDef._Order) {
                case SCHEMA_ORDER_SEQUENCE:
                    _ElementDef._ElementDecl.Content.AddSequence();
                    break;
                case SCHEMA_ORDER_CHOICE:
                case SCHEMA_ORDER_MANY:
                    _ElementDef._ElementDecl.Content.AddChoice();
                    break;
                default: 
                case SCHEMA_ORDER_ALL:             
                    throw new XmlException(Res.Xml_UnexpectedToken, XmlToken.ToString(XmlToken.NAME));
                    //                _ElementDef._ElementDecl.Content.AddSequence();
            }
        }

        private static bool IsYes(object obj, XdrBuilder builder) {
            XmlQualifiedName qname = (XmlQualifiedName)obj;
            bool fYes = false;

            if (qname.Name == "yes") {
                fYes = true;
            }
            else if (qname.Name != "no") {
                builder.SendValidationEvent(Res.Sch_UnknownRequired);
            }

            return fYes;
        }

        private static uint ParseMinOccurs(object obj, XdrBuilder builder) {
            uint cVal = 1;

            if (!ParseInteger((string) obj, ref cVal) || (cVal != 0 && cVal != 1)) {
                builder.SendValidationEvent(Res.Sch_MinOccursInvalid);
            }
            return cVal;
        }

        private static uint ParseMaxOccurs(object obj, XdrBuilder builder) {
            uint cVal = uint.MaxValue;
            string s = (string)obj;

            if (!s.Equals("*") &&
                (!ParseInteger(s, ref cVal) || (cVal != uint.MaxValue && cVal != 1))) {
                builder.SendValidationEvent(Res.Sch_MaxOccursInvalid);
            }
            return cVal;
        }

        private static void HandleMinMax(CompiledContentModel pContent, uint cMin, uint cMax) {
            if (cMax == uint.MaxValue) {
                if (cMin == 0)
                    pContent.Star();           // minOccurs="0" and maxOccurs="infinite"
                else
                    pContent.Plus();           // minOccurs="1" and maxOccurs="infinite"
            }
            else if (cMin == 0) {                 // minOccurs="0" and maxOccurs="1")
                pContent.QuestionMark();
            }
        }

        private static void ParseDtMaxLength(ref uint cVal, object obj, XdrBuilder builder) {
            if (uint.MaxValue != cVal) {
                builder.SendValidationEvent(Res.Sch_DupDtMaxLength);
            }

            if (!ParseInteger((string) obj, ref cVal) || cVal < 0) {
                builder.SendValidationEvent(Res.Sch_DtMaxLengthInvalid, obj.ToString());
            }
        }

        private static void ParseDtMinLength(ref uint cVal, object obj, XdrBuilder builder) {
            if (uint.MaxValue != cVal) {
                builder.SendValidationEvent(Res.Sch_DupDtMinLength);
            }

            if (!ParseInteger((string)obj, ref cVal) || cVal < 0) {
                builder.SendValidationEvent(Res.Sch_DtMinLengthInvalid, obj.ToString());
            }
        }

        private static void CompareMinMaxLength(uint cMin, uint cMax, XdrBuilder builder) {
            if (cMin != uint.MaxValue && cMax != uint.MaxValue && cMin > cMax) {
                builder.SendValidationEvent(Res.Sch_DtMinMaxLength);
            }
        }

        private static bool ParseInteger(string str, ref uint n) {
            try {
                n = UInt32.Parse(str);
            }
            catch (Exception) {
                return false;
            }
            return true;
        }

        private void XDR_CheckAttributeDefault(DeclBaseInfo decl, SchemaAttDef pAttdef) {
            if (decl._Default != null || pAttdef.DefaultValueTyped != null) {
                if (decl._Default != null) {
                    pAttdef.DefaultValueRaw = pAttdef.DefaultValueExpanded = (string)decl._Default;                    
                    CheckDefaultAttValue(pAttdef);
                }
            }

            SetAttributePresence(pAttdef, 1 == decl._MinOccurs);
        }

        private void SetAttributePresence(SchemaAttDef pAttdef, bool fRequired) {
            if (SchemaDeclBase.Use.Fixed != pAttdef.Presence) {
                if (fRequired || SchemaDeclBase.Use.Required == pAttdef.Presence) {
                    // If it is required and it has a default value then it is a FIXED attribute.
                    if (pAttdef.DefaultValueTyped != null)
                        pAttdef.Presence = SchemaDeclBase.Use.Fixed;
                    else
                        pAttdef.Presence = SchemaDeclBase.Use.Required;
                }
                else if (pAttdef.DefaultValueTyped != null) {
                    pAttdef.Presence = SchemaDeclBase.Use.Default;
                }
                else {
                    pAttdef.Presence = SchemaDeclBase.Use.Implied;
                }
            }
        }

        private int GetContent(XmlQualifiedName qname) {
            int content = 0;
            if (_SchemaNames.GetName(SchemaNames.ID.SCHEMA_EMPTY).Equals(qname)) {
                content = SCHEMA_CONTENT_EMPTY;
                _ElementDef._AllowDataType = false;
            }
            else if (_SchemaNames.GetName(SchemaNames.ID.SCHEMA_ELTONLY).Equals(qname)) {
                content = SCHEMA_CONTENT_ELEMENT;
                _ElementDef._AllowDataType = false;
            }
            else if (_SchemaNames.GetName(SchemaNames.ID.SCHEMA_MIXED).Equals(qname)) {
                content = SCHEMA_CONTENT_MIXED;
                _ElementDef._AllowDataType = false;
            }
            else if (_SchemaNames.GetName(SchemaNames.ID.SCHEMA_TEXTONLY).Equals(qname)) {
                content = SCHEMA_CONTENT_TEXT;
            }
            else {
                SendValidationEvent(Res.Sch_UnknownContent, qname.Name);
            }
            return content;
        }

        private bool GetModel(XmlQualifiedName qname) {
            bool fOpen = false;
            if (_SchemaNames.GetName(SchemaNames.ID.SCHEMA_OPEN).Equals(qname))
                fOpen = true;
            else if (_SchemaNames.GetName(SchemaNames.ID.SCHEMA_CLOSED).Equals(qname))
                fOpen = false;
            else
                SendValidationEvent(Res.Sch_UnknownModel, qname.Name);
            return fOpen;
        }

        private XmlSchemaDatatype CheckDatatype(string str) {
            XmlSchemaDatatype dtype = XmlSchemaDatatype.FromXdrName(str);
            if (dtype == null) {
                SendValidationEvent(Res.Sch_UnknownDtType, str);
            } 
            else if (dtype.TokenizedType == XmlTokenizedType.ID) {
                if (! _AttributeDef._Global) {
                    if (_ElementDef._ElementDecl.IsIdDeclared) {
                        SendValidationEvent(Res.Sch_IdAttrDeclared, 
                                            XmlQualifiedName.ToString(_ElementDef._ElementDecl.Name.Name, _ElementDef._ElementDecl.Prefix));
                    }
                    _ElementDef._ElementDecl.IsIdDeclared = true;
                }
            }

            return dtype;
        }

        private void CheckDefaultAttValue(SchemaAttDef attDef) {
            string str = (attDef.DefaultValueRaw).Trim();
            Validator.CheckDefaultValue(str, attDef, _SchemaInfo, _CurNsMgr, _NameTable, null, validationEventHandler);
        }

        private bool IsGlobal(int flags) {
            return flags == SCHEMA_FLAGS_NS;
        }

        private void SendValidationEvent(string code, string[] args, XmlSeverityType severity) {
            SendValidationEvent(new XmlSchemaException(code, args, this._reader.BaseURI, this.positionInfo.LineNumber, this.positionInfo.LinePosition), severity);
        }

        private void SendValidationEvent(string code) {
            SendValidationEvent(code, string.Empty);
        }

        private void SendValidationEvent(string code, string msg) {
            SendValidationEvent(new XmlSchemaException(code, msg, this._reader.BaseURI, this.positionInfo.LineNumber, this.positionInfo.LinePosition), XmlSeverityType.Error);
        }

        private void SendValidationEvent(XmlSchemaException e, XmlSeverityType severity) {
            _SchemaInfo.ErrorCount ++;
            if (validationEventHandler != null) {
                validationEventHandler(this, new ValidationEventArgs(e, severity));
            }
            else if (severity == XmlSeverityType.Error) {
                throw e;
            }
        }


    }; // class XdrBuilder

} // namespace System.Xml
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\schema\xmlschemaall.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlSchemaAll.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Schema {

    using System.Collections;
    using System.ComponentModel;
    using System.Xml.Serialization;

    /// <include file='doc\XmlSchemaAll.uex' path='docs/doc[@for="XmlSchemaAll"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public class XmlSchemaAll : XmlSchemaGroupBase {
        XmlSchemaObjectCollection items = new XmlSchemaObjectCollection();

        /// <include file='doc\XmlSchemaAll.uex' path='docs/doc[@for="XmlSchemaAll.Items"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlElement("element", typeof(XmlSchemaElement))]
        public override XmlSchemaObjectCollection Items {
            get { return items; }
        }

        internal override bool IsEmpty {
            get { return  base.IsEmpty || items.Count == 0; }
        } 
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\schema\xmlschema.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlSchema.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Schema {

    using System.Collections;
    using System.IO;
    using System;
    using System.ComponentModel;
    using System.Xml;
    using System.Xml.Serialization;

    /// <include file='doc\XmlSchema.uex' path='docs/doc[@for="XmlSchema"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [XmlRoot("schema", Namespace=XmlSchema.Namespace)]
    public class XmlSchema : XmlSchemaObject {

        /// <include file='doc\XmlSchema.uex' path='docs/doc[@for="XmlSchema.Namespace"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public const string Namespace = XmlReservedNs.NsXsd;
        /// <include file='doc\XmlSchema.uex' path='docs/doc[@for="XmlSchema.InstanceNamespace"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public const string InstanceNamespace = XmlReservedNs.NsXsi;

        XmlSchemaForm attributeFormDefault = XmlSchemaForm.None;
        XmlSchemaForm elementFormDefault = XmlSchemaForm.None;
        XmlSchemaDerivationMethod blockDefault = XmlSchemaDerivationMethod.None;
        XmlSchemaDerivationMethod finalDefault = XmlSchemaDerivationMethod.None;
        string targetNs;
        string version;
        XmlSchemaObjectCollection includes = new XmlSchemaObjectCollection();
        XmlSchemaObjectCollection items = new XmlSchemaObjectCollection();
        string id;
        XmlAttribute[] moreAttributes;

        // compiled info
        bool buildinIncluded = false;
        bool needCleanup = false;
        bool isCompiled = false;
        bool isPreprocessed = false;
        int errorCount = 0;
        XmlSchemaObjectTable attributes = new XmlSchemaObjectTable();
        XmlSchemaObjectTable attributeGroups = new XmlSchemaObjectTable();
        XmlSchemaObjectTable elements = new XmlSchemaObjectTable();
        XmlSchemaObjectTable types = new XmlSchemaObjectTable();
        XmlSchemaObjectTable groups = new XmlSchemaObjectTable();
        XmlSchemaObjectTable notations = new XmlSchemaObjectTable();
        XmlSchemaObjectTable identityConstraints = new XmlSchemaObjectTable();
        
        // internal info
        string baseUri;
        Hashtable ids = new Hashtable();
        Hashtable schemaLocations = new Hashtable();
        Hashtable examplars = new Hashtable();
        XmlDocument document;
        XmlNameTable nameTable;

	XmlResolver xmlResolver = null; //set this before calling Compile
        
        /// <include file='doc\XmlSchema.uex' path='docs/doc[@for="XmlSchema.XmlSchema"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public XmlSchema() {}

        /// <include file='doc\XmlSchema.uex' path='docs/doc[@for="XmlSchema.Read"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static XmlSchema Read(TextReader reader, ValidationEventHandler validationEventHandler) {
            return Read(new XmlTextReader(reader), validationEventHandler);
        }

        /// <include file='doc\XmlSchema.uex' path='docs/doc[@for="XmlSchema.Read1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static XmlSchema Read(Stream stream, ValidationEventHandler validationEventHandler) {
            return Read(new XmlTextReader(stream), validationEventHandler);
        }

        /// <include file='doc\XmlSchema.uex' path='docs/doc[@for="XmlSchema.Read2"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static XmlSchema Read(XmlReader reader, ValidationEventHandler validationEventHandler) {
            XmlNameTable nameTable = reader.NameTable;
            SchemaNames schemaNames = new SchemaNames(nameTable);
            return new Parser(null, nameTable, schemaNames, validationEventHandler).Parse(reader, null, new SchemaInfo(schemaNames));
        }

        /// <include file='doc\XmlSchema.uex' path='docs/doc[@for="XmlSchema.Write"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void Write(Stream stream) {
            Write(stream, null);
        }

        /// <include file='doc\XmlSchema.uex' path='docs/doc[@for="XmlSchema.Write1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void Write(Stream stream, XmlNamespaceManager namespaceManager) {
            XmlTextWriter xmlWriter = new XmlTextWriter(stream, null);
            xmlWriter.Formatting = Formatting.Indented;
            Write(xmlWriter, namespaceManager);
        }

        /// <include file='doc\XmlSchema.uex' path='docs/doc[@for="XmlSchema.Write2"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void Write(TextWriter writer) {
            Write(writer, null);
        }

        /// <include file='doc\XmlSchema.uex' path='docs/doc[@for="XmlSchema.Write3"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void Write(TextWriter writer, XmlNamespaceManager namespaceManager) {
            XmlTextWriter xmlWriter = new XmlTextWriter(writer);
            xmlWriter.Formatting = Formatting.Indented;
            Write(xmlWriter, namespaceManager);
        }

        /// <include file='doc\XmlSchema.uex' path='docs/doc[@for="XmlSchema.Write4"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void Write(XmlWriter writer) {
            Write(writer, null);
        }

        /// <include file='doc\XmlSchema.uex' path='docs/doc[@for="XmlSchema.Write5"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void Write(XmlWriter writer, XmlNamespaceManager namespaceManager) {
            XmlSerializer serializer = new XmlSerializer(typeof(XmlSchema));
            XmlSerializerNamespaces ns = new XmlSerializerNamespaces();
            if (namespaceManager != null) {
                foreach(string prefix in namespaceManager) {
                    if (prefix != "xml" && prefix != "xmlns") {
                        ns.Add(prefix, namespaceManager.LookupNamespace(prefix));
                    }
                }

            } else if (this.Namespaces != null && this.Namespaces.Count > 0) {
                ns = this.Namespaces;
            }
            else {
                ns.Add("xs", XmlSchema.Namespace);
                if (targetNs != null && targetNs != string.Empty) {
                    ns.Add("tns", targetNs);
                }
            }
            serializer.Serialize(writer, this, ns);
        }

        /// <include file='doc\XmlSchema.uex' path='docs/doc[@for="XmlSchema.Compile"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void Compile(ValidationEventHandler validationEventHandler) {
            SchemaNames sn = new SchemaNames(NameTable);
            Compile(null, NameTable, sn, validationEventHandler, null, new SchemaInfo(sn), false, new XmlUrlResolver());
        }

	/// <include file='doc\XmlSchema.uex' path='docs/doc[@for="XmlSchema.Compile1"]/*' />
	public void Compile(ValidationEventHandler validationEventHandler, XmlResolver resolver) {
            SchemaNames sn = new SchemaNames(NameTable);
            Compile(null, NameTable, sn, validationEventHandler, null, new SchemaInfo(sn), false, resolver);
        }

        internal void Compile(XmlSchemaCollection collection, XmlNameTable nameTable, SchemaNames schemaNames, 
			      ValidationEventHandler validationEventHandler, string targetNamespace, 
			      SchemaInfo schemaInfo, bool compileContentModel, XmlResolver resolver) {
            errorCount = 0;
	    xmlResolver = resolver;
            if (needCleanup) {
                schemaLocations.Clear();
                Compiler.Cleanup(this);
            }
            needCleanup = true;
            isPreprocessed = false;
            isCompiled = false;
            if (baseUri != null) {
                schemaLocations.Add(baseUri, baseUri);
            }
	    if (xmlResolver != null) {
            	LoadExternals(collection, nameTable, schemaNames, validationEventHandler, this);
	    }
            if (errorCount == 0) {
                new Compiler(nameTable, schemaNames, validationEventHandler, compileContentModel).Compile(this, targetNamespace, schemaInfo);
                if (errorCount == 0) {
                    isPreprocessed = true;
                    isCompiled = true;

                    foreach(XmlSchemaExternal include in Includes) {
                        if (include.Schema != null) {
                            include.Schema.isPreprocessed = true;
                            include.Schema.isCompiled = true;
                            include.Schema.LineNumber = include.LineNumber;
                            include.Schema.LinePosition = include.LinePosition;
                            include.Schema.SourceUri = include.SchemaLocation;
                        }
                    }
                }
            }
        }

        private void LoadExternals(XmlSchemaCollection schemaCollection, XmlNameTable nameTable, SchemaNames schemaNames, ValidationEventHandler validationEventHandler, XmlSchema schema) {
            foreach(XmlSchemaExternal include in schema.Includes) {
                string fullPath = null;
                if (include.Schema != null) {
                    // already loaded
                    fullPath = include.FullPath;
                    if (fullPath != null) {
                        this.schemaLocations.Add(fullPath, fullPath);
                    }
                    LoadExternals(schemaCollection, nameTable, schemaNames, validationEventHandler, include.Schema);
                    continue;
                }
                string schemaLocation = include.SchemaLocation;
                if (schemaCollection != null && include is XmlSchemaImport) {
                    include.Schema = schemaCollection[((XmlSchemaImport)include).Namespace];
                    if (include.Schema != null) {
                        include.Schema = include.Schema.Clone();
                        continue;
                    }
                }
                if (include is XmlSchemaImport && ((XmlSchemaImport)include).Namespace == XmlReservedNs.NsXml) {
                    if (!buildinIncluded) {
                        buildinIncluded = true;
                        include.Schema = GetBuildInSchema(nameTable);
                    }
                    continue;
                }
                if (schemaLocation == null) {
                    continue;
                }
                Stream stream = ResolveSchemaLocation(schema, schemaLocation, out fullPath);
                if (stream != null) {
                    include.FullPath = fullPath;
                    if (this.schemaLocations[fullPath] == null) {
                        this.schemaLocations.Add(fullPath, fullPath);
                        XmlTextReader reader = new XmlTextReader(fullPath, stream, nameTable);
                        try {
                            reader.XmlResolver = xmlResolver;
                            include.Schema =  new Parser(schemaCollection, nameTable, schemaNames, validationEventHandler).Parse(reader, null, null);
                            while(reader.Read());// wellformness check

                            this.errorCount += include.Schema.ErrorCount;
                            LoadExternals(schemaCollection, nameTable, schemaNames, validationEventHandler, include.Schema);
                        }
                        catch(XmlSchemaException e) {
                            if (validationEventHandler != null) {
                                validationEventHandler(null, new ValidationEventArgs(
                                    new XmlSchemaException(Res.Sch_CannotLoadSchema, new string[] {schemaLocation, e.Message}), XmlSeverityType.Error
                                ));
                            }
                        }
                        catch(Exception) {
                            if (validationEventHandler != null) {
                                validationEventHandler(null, new ValidationEventArgs(
                                    new XmlSchemaException(Res.Sch_InvalidIncludeLocation, include), XmlSeverityType.Warning
                                ));
                            }
                        }
                        finally {
                            reader.Close();
                        }
                    }
                    else {
                        stream.Close();
                    }
                }
                else {
                    if (validationEventHandler != null) {
                        validationEventHandler(null, new ValidationEventArgs(
                            new XmlSchemaException(Res.Sch_InvalidIncludeLocation, include), XmlSeverityType.Warning
                        ));
                    }
                }
            }
        }

        private static XmlSchema GetBuildInSchema(XmlNameTable nt) {
            XmlSchema schema = new XmlSchema();
            schema.TargetNamespace = XmlReservedNs.NsXml;
        
            XmlSchemaAttribute lang = new XmlSchemaAttribute();
            lang.Name = "lang";
            lang.SchemaTypeName = new XmlQualifiedName("language", nt.Add(XmlReservedNs.NsXsd));
            schema.Items.Add(lang);
                
            XmlSchemaAttribute space = new XmlSchemaAttribute();
            space.Name = "space";
                XmlSchemaSimpleType type = new XmlSchemaSimpleType();
                XmlSchemaSimpleTypeRestriction r = new XmlSchemaSimpleTypeRestriction();
                r.BaseTypeName = new XmlQualifiedName("NCName", nt.Add(XmlReservedNs.NsXsd));
                XmlSchemaEnumerationFacet space_default = new XmlSchemaEnumerationFacet();
                space_default.Value = "default";
                r.Facets.Add(space_default);
                XmlSchemaEnumerationFacet space_preserve = new XmlSchemaEnumerationFacet();
                space_preserve.Value = "preserve";
                r.Facets.Add(space_preserve);
                type.Content = r;
                space.SchemaType = type;
            space.DefaultValue = "preserve";
            schema.Items.Add(space);
                
            XmlSchemaAttributeGroup attributeGroup = new XmlSchemaAttributeGroup();
            attributeGroup.Name = "specialAttrs";
            XmlSchemaAttribute langRef = new XmlSchemaAttribute();
            langRef.RefName = new XmlQualifiedName("lang", XmlReservedNs.NsXml);
            attributeGroup.Attributes.Add(langRef);
            XmlSchemaAttribute spaceRef = new XmlSchemaAttribute();
            spaceRef.RefName = new XmlQualifiedName("space", XmlReservedNs.NsXml);
            attributeGroup.Attributes.Add(spaceRef);
            schema.Items.Add(attributeGroup);
            return schema;
        }


        private Stream ResolveSchemaLocation(XmlSchema enclosingSchema, string location, out string fullPath) {
            Stream stream;
            fullPath = null;
            try {
                string baseUri = enclosingSchema.BaseUri;
                Uri baseUriOb = ( baseUri == string.Empty || baseUri == null ) ? null : xmlResolver.ResolveUri(null, baseUri);
                Uri ruri = xmlResolver.ResolveUri( baseUriOb, location );
                stream = (Stream)xmlResolver.GetEntity( ruri, null, null );
                fullPath = ruri.ToString();
            }
            catch {
                return null;
            }
            return stream;
        }

        internal void Preprocess(ValidationEventHandler eventhandler) {
            errorCount = 0;
            Compiler.Cleanup(this);
            isPreprocessed = false;
            SchemaNames sn = new SchemaNames(NameTable);
            new Compiler(NameTable, sn, eventhandler, true).Preprocess(this, null);
            if (errorCount == 0) {
                isPreprocessed = true;
                foreach(XmlSchemaExternal include in Includes) {
                    if (include.Schema != null) {
                        include.Schema.isPreprocessed = true;
                    }
                }
            }
        }

        /// <include file='doc\XmlSchema.uex' path='docs/doc[@for="XmlSchema.AttributeFormDefault"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlAttribute("attributeFormDefault"), DefaultValue(XmlSchemaForm.None)]
        public XmlSchemaForm AttributeFormDefault {
             get { return attributeFormDefault; }
             set { attributeFormDefault = value; }
        }

        /// <include file='doc\XmlSchema.uex' path='docs/doc[@for="XmlSchema.BlockDefault"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlAttribute("blockDefault"), DefaultValue(XmlSchemaDerivationMethod.None)]
        public XmlSchemaDerivationMethod BlockDefault {
             get { return blockDefault; }
             set { blockDefault = value; }
        }

        /// <include file='doc\XmlSchema.uex' path='docs/doc[@for="XmlSchema.FinalDefault"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlAttribute("finalDefault"), DefaultValue(XmlSchemaDerivationMethod.None)]
        public XmlSchemaDerivationMethod FinalDefault {
             get { return finalDefault; }
             set { finalDefault = value; }
        }

        /// <include file='doc\XmlSchema.uex' path='docs/doc[@for="XmlSchema.ElementFormDefault"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlAttribute("elementFormDefault"), DefaultValue(XmlSchemaForm.None)]
        public XmlSchemaForm ElementFormDefault {
             get { return elementFormDefault; }
             set { elementFormDefault = value; }
        }

        /// <include file='doc\XmlSchema.uex' path='docs/doc[@for="XmlSchema.TargetNamespace"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlAttribute("targetNamespace", DataType="anyURI")]
        public string TargetNamespace {
             get { return targetNs; }
             set { targetNs = value; }
        }

        /// <include file='doc\XmlSchema.uex' path='docs/doc[@for="XmlSchema.Version"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlAttribute("version", DataType="token")]
        public string Version {
             get { return version; }
             set { version = value; }
        }

        /// <include file='doc\XmlSchema.uex' path='docs/doc[@for="XmlSchema.Includes"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlElement("include", typeof(XmlSchemaInclude)),
         XmlElement("import", typeof(XmlSchemaImport)),
         XmlElement("redefine", typeof(XmlSchemaRedefine))]
        public XmlSchemaObjectCollection Includes {
            get { return includes; }
        }

        /// <include file='doc\XmlSchema.uex' path='docs/doc[@for="XmlSchema.Items"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlElement("annotation", typeof(XmlSchemaAnnotation)),
         XmlElement("attribute", typeof(XmlSchemaAttribute)),
         XmlElement("attributeGroup", typeof(XmlSchemaAttributeGroup)),
         XmlElement("complexType", typeof(XmlSchemaComplexType)),
         XmlElement("simpleType", typeof(XmlSchemaSimpleType)),
         XmlElement("element", typeof(XmlSchemaElement)),
         XmlElement("group", typeof(XmlSchemaGroup)),
         XmlElement("notation", typeof(XmlSchemaNotation))]
        public XmlSchemaObjectCollection Items {
            get { return items; }
        }

        // Compiled info
        /// <include file='doc\XmlSchema.uex' path='docs/doc[@for="XmlSchema.IsCompiled"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlIgnore]
        public bool IsCompiled {
            get { return isCompiled; }
        }

        [XmlIgnore]
        internal bool IsPreprocessed {
            get { return isPreprocessed; }
        }
        
        /// <include file='doc\XmlSchema.uex' path='docs/doc[@for="XmlSchema.Attributes"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlIgnore]
        public XmlSchemaObjectTable Attributes {
            get { return attributes; }
        }

        /// <include file='doc\XmlSchema.uex' path='docs/doc[@for="XmlSchema.AttributeGroups"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlIgnore]
        public XmlSchemaObjectTable AttributeGroups {
            get { return attributeGroups; }
        }

        /// <include file='doc\XmlSchema.uex' path='docs/doc[@for="XmlSchema.SchemaTypes"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlIgnore]
        public XmlSchemaObjectTable SchemaTypes {
            get { return types; }
        }

        /// <include file='doc\XmlSchema.uex' path='docs/doc[@for="XmlSchema.Elements"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlIgnore]
        public XmlSchemaObjectTable Elements {
            get { return elements; }
        }

        /// <include file='doc\XmlSchema.uex' path='docs/doc[@for="XmlSchema.Id"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlAttribute("id", DataType="ID")]
        public string Id {
            get { return id; }
            set { id = value; }
        }

        /// <include file='doc\XmlSchema.uex' path='docs/doc[@for="XmlSchema.UnhandledAttributes"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlAnyAttribute]
        public XmlAttribute[] UnhandledAttributes {
            get { return moreAttributes; }
            set { moreAttributes = value; }
        }

        /// <include file='doc\XmlSchema.uex' path='docs/doc[@for="XmlSchema.Groups"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlIgnore]
        public XmlSchemaObjectTable Groups {
            get { return groups; }
        }

        /// <include file='doc\XmlSchema.uex' path='docs/doc[@for="XmlSchema.Notations"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlIgnore]
        public XmlSchemaObjectTable Notations {
            get { return notations; }
        }

        [XmlIgnore]
        internal XmlSchemaObjectTable IdentityConstraints { 
            get { return identityConstraints; }
        }

        [XmlIgnore]
        internal string BaseUri {
            get { return baseUri; }
            set { baseUri = value; }
        }

        [XmlIgnore]
        internal Hashtable Ids {
            get { return ids; }
        }

        [XmlIgnore]
        internal Hashtable Examplars {
            get { return examplars; }
        }

        [XmlIgnore]
        internal XmlDocument Document {
            get { if (document == null) document = new XmlDocument(); return document; }
        }

        [XmlIgnore]
        internal XmlNameTable NameTable {
            get { if (nameTable == null) nameTable = new System.Xml.NameTable(); return nameTable; }
        }

        [XmlIgnore]
        internal int ErrorCount {
            get { return errorCount; }
            set { errorCount = value; }
        }

        internal XmlSchema Clone() {
            XmlSchema that = new XmlSchema();
            that.attributeFormDefault   = this.attributeFormDefault;
            that.elementFormDefault     = this.elementFormDefault;
            that.blockDefault           = this.blockDefault;
            that.finalDefault           = this.finalDefault;
            that.targetNs               = this.targetNs;
            that.version                = this.version;
            that.includes               = this.includes;
            that.items                  = this.items;
            Compiler.Cleanup(that);
            return that;
        }

        [XmlIgnore]
        internal override string IdAttribute {
            get { return Id; }
            set { Id = value; }
        }

        internal override void SetUnhandledAttributes(XmlAttribute[] moreAttributes) {
            this.moreAttributes = moreAttributes;
        }
        internal override void AddAnnotation(XmlSchemaAnnotation annotation) {
            items.Add(annotation);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\schema\xmlschemaannotated.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlSchemaAnnotated.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Schema {

    using System.Collections;
    using System.ComponentModel;
    using System.Xml.Serialization;

    /// <include file='doc\XmlSchemaAnnotated.uex' path='docs/doc[@for="XmlSchemaAnnotated"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public class XmlSchemaAnnotated : XmlSchemaObject {
        string id;
        XmlSchemaAnnotation annotation;
        XmlAttribute[] moreAttributes;

        /// <include file='doc\XmlSchemaAnnotated.uex' path='docs/doc[@for="XmlSchemaAnnotated.Id"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlAttribute("id", DataType="ID")]
        public string Id {
            get { return id; }
            set { id = value; }
        }

        /// <include file='doc\XmlSchemaAnnotated.uex' path='docs/doc[@for="XmlSchemaAnnotated.Annotation"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlElement("annotation", typeof(XmlSchemaAnnotation))]
        public XmlSchemaAnnotation Annotation {
            get { return annotation; }
            set { annotation = value; }
        }

        /// <include file='doc\XmlSchemaAnnotated.uex' path='docs/doc[@for="XmlSchemaAnnotated.UnhandledAttributes"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlAnyAttribute]
        public XmlAttribute[] UnhandledAttributes {
            get { return moreAttributes; }
            set { moreAttributes = value; }
        }

        [XmlIgnore]
        internal override string IdAttribute {
            get { return Id; }
            set { Id = value; }
        }

        internal override void SetUnhandledAttributes(XmlAttribute[] moreAttributes) {
            this.moreAttributes = moreAttributes;
        }
        internal override void AddAnnotation(XmlSchemaAnnotation annotation) {
            this.annotation = annotation;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\schema\xmlschemaannotation.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlSchemaAnnotation.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Schema {

    using System.Collections;
    using System.ComponentModel;
    using System.Xml.Serialization;

    /// <include file='doc\XmlSchemaAnnotation.uex' path='docs/doc[@for="XmlSchemaAnnotation"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public class XmlSchemaAnnotation : XmlSchemaObject {
        string id;
        XmlSchemaObjectCollection items = new XmlSchemaObjectCollection();
        XmlAttribute[] moreAttributes;

        /// <include file='doc\XmlSchemaAnnotation.uex' path='docs/doc[@for="XmlSchemaAnnotation.Id"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlAttribute("id", DataType = "ID")]
        public string Id {
            get { return id; }
            set { id = value; }
        }

        /// <include file='doc\XmlSchemaAnnotation.uex' path='docs/doc[@for="XmlSchemaAnnotation.Items"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlElement("documentation", typeof(XmlSchemaDocumentation)),
         XmlElement("appinfo", typeof(XmlSchemaAppInfo))]
        public XmlSchemaObjectCollection Items {
            get { return items; }
        }

        /// <include file='doc\XmlSchemaAnnotation.uex' path='docs/doc[@for="XmlSchemaAnnotation.UnhandledAttributes"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlAnyAttribute]
        public XmlAttribute[] UnhandledAttributes {
            get { return moreAttributes; }
            set { moreAttributes = value; }
        }

        [XmlIgnore]
        internal override string IdAttribute {
            get { return Id; }
            set { Id = value; }
        }

        internal override void SetUnhandledAttributes(XmlAttribute[] moreAttributes) {
            this.moreAttributes = moreAttributes;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\schema\xmlschemaany.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlSchemaAny.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Schema {

    using System.Collections;
    using System.ComponentModel;
    using System.Xml.Serialization;

    /// <include file='doc\XmlSchemaAny.uex' path='docs/doc[@for="XmlSchemaAny"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public class XmlSchemaAny : XmlSchemaParticle {
        string ns;
        XmlSchemaContentProcessing processContents = XmlSchemaContentProcessing.None;
        NamespaceList namespaceList;
        
        /// <include file='doc\XmlSchemaAny.uex' path='docs/doc[@for="XmlSchemaAny.Namespaces"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlAttribute("namespace")]
        public string Namespace {
            get { return ns; }
            set { ns = value; }
        }

        /// <include file='doc\XmlSchemaAny.uex' path='docs/doc[@for="XmlSchemaAny.ProcessContents"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlAttribute("processContents"), DefaultValue(XmlSchemaContentProcessing.None)]
        public XmlSchemaContentProcessing ProcessContents {
            get { return processContents; }
            set { processContents = value; }
        }

        [XmlIgnore]
        internal NamespaceList NamespaceList {
            get { return namespaceList; }
        }

        [XmlIgnore]
        internal XmlSchemaContentProcessing ProcessContentsCorrect {
            get { return processContents == XmlSchemaContentProcessing.None ? XmlSchemaContentProcessing.Strict : processContents; }
        }

        internal void BuildNamespaceList(string targetNamespace) {
            if (ns != null) {
                namespaceList = new NamespaceList(ns, targetNamespace);
            }
            else {
                namespaceList = new NamespaceList();
            }
        }

        internal bool Allows(XmlQualifiedName qname) {
            return namespaceList.Allows(qname.Namespace);
        }

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\schema\xmlschemaattribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlSchemaAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Schema {

    using System.Collections;
    using System.ComponentModel;
    using System.Xml.Serialization;

    /// <include file='doc\XmlSchemaAttribute.uex' path='docs/doc[@for="XmlSchemaAttribute"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public class XmlSchemaAttribute : XmlSchemaAnnotated {
        string defaultValue;
        string fixedValue;
        XmlSchemaForm form = XmlSchemaForm.None;
        string name;        
        XmlQualifiedName refName = XmlQualifiedName.Empty; 
        XmlQualifiedName typeName = XmlQualifiedName.Empty; 
        XmlSchemaSimpleType type;
        XmlSchemaUse use = XmlSchemaUse.None;
        XmlQualifiedName qualifiedName = XmlQualifiedName.Empty;
        object attributeType;
        string prefix;
        SchemaAttDef attDef;
        bool validating;
        
        /// <include file='doc\XmlSchemaAttribute.uex' path='docs/doc[@for="XmlSchemaAttribute.DefaultValue"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlAttribute("default")]
        [DefaultValue(null)]
        public string DefaultValue { 
            get { return defaultValue; }
            set { defaultValue = value; }
        }

        /// <include file='doc\XmlSchemaAttribute.uex' path='docs/doc[@for="XmlSchemaAttribute.FixedValue"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlAttribute("fixed")]
        [DefaultValue(null)]
        public string FixedValue { 
            get { return fixedValue; }
            set { fixedValue = value; }
        }

        /// <include file='doc\XmlSchemaAttribute.uex' path='docs/doc[@for="XmlSchemaAttribute.Form"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlAttribute("form"), DefaultValue(XmlSchemaForm.None)]
        public XmlSchemaForm Form { 
            get { return form; }
            set { form = value; }
        }

        /// <include file='doc\XmlSchemaAttribute.uex' path='docs/doc[@for="XmlSchemaAttribute.Name"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlAttribute("name")]
        public string Name { 
            get { return name; }
            set { name = value; }
        }
        
        /// <include file='doc\XmlSchemaAttribute.uex' path='docs/doc[@for="XmlSchemaAttribute.RefName"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlAttribute("ref")]
        public XmlQualifiedName RefName { 
            get { return refName; }
            set { refName = (value == null ? XmlQualifiedName.Empty : value); }
        }
        
        /// <include file='doc\XmlSchemaAttribute.uex' path='docs/doc[@for="XmlSchemaAttribute.SchemaTypeName"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlAttribute("type")]
        public XmlQualifiedName SchemaTypeName { 
            get { return typeName; }
            set { typeName = (value == null ? XmlQualifiedName.Empty : value); }
        }
        
        /// <include file='doc\XmlSchemaAttribute.uex' path='docs/doc[@for="XmlSchemaAttribute.SchemaType"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlElement("simpleType")]
        public XmlSchemaSimpleType SchemaType {
            get { return type; }
            set { type = value; }
        }

        /// <include file='doc\XmlSchemaAttribute.uex' path='docs/doc[@for="XmlSchemaAttribute.Use"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlAttribute("use"), DefaultValue(XmlSchemaUse.None)]
        public XmlSchemaUse Use {
            get { return use; }
            set { use = value; }
        }

        /// <include file='doc\XmlSchemaAttribute.uex' path='docs/doc[@for="XmlSchemaAttribute.QualifiedName"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlIgnore]
        public XmlQualifiedName QualifiedName { 
            get { return qualifiedName; }
        }

        /// <include file='doc\XmlSchemaAttribute.uex' path='docs/doc[@for="XmlSchemaAttribute.AttributeType"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlIgnore]
        public object AttributeType {
            get { return attributeType; }
        }

        [XmlIgnore]
        internal XmlSchemaDatatype Datatype {
            get { return attributeType is XmlSchemaSimpleType ? ((XmlSchemaSimpleType)attributeType).Datatype : (XmlSchemaDatatype)attributeType; }
        }

        internal void  SetQualifiedName(XmlQualifiedName value) { 
            qualifiedName = value;
        }

        internal void SetAttributeType(object value) { 
            attributeType = value;
        }

        internal string Prefix {
            get { return prefix; }
            set { prefix = value; }
        }

        internal SchemaAttDef AttDef {
            get { return attDef; }
            set { attDef = value; }
        }

        internal bool Validating {
            get { return validating; }
            set { validating = value; }
        }

        internal bool HasDefault {
            get { return defaultValue != null; }
        }

        [XmlIgnore]
        internal override string NameAttribute {
            get { return Name; }
            set { Name = value; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\schema\xmlschemaattributegroup.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlSchemaAttributeGroup.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Schema {

    using System.Collections;
    using System.ComponentModel;
    using System.Xml.Serialization;

    /// <include file='doc\XmlSchemaAttributeGroup.uex' path='docs/doc[@for="XmlSchemaAttributeGroup"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public class XmlSchemaAttributeGroup : XmlSchemaAnnotated {
        string name;        
        XmlSchemaObjectCollection attributes = new XmlSchemaObjectCollection();
        XmlSchemaAnyAttribute anyAttribute;
        XmlQualifiedName qname = XmlQualifiedName.Empty; 
        XmlSchemaAttributeGroup redefined;
        XmlSchemaObjectTable attributeUses = new XmlSchemaObjectTable();
        XmlSchemaAnyAttribute attributeWildcard;

        bool validating;

        /// <include file='doc\XmlSchemaAttributeGroup.uex' path='docs/doc[@for="XmlSchemaAttributeGroup.Name"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlAttribute("name")]
        public string Name { 
            get { return name; }
            set { name = value; }
        }

        /// <include file='doc\XmlSchemaAttributeGroup.uex' path='docs/doc[@for="XmlSchemaAttributeGroup.Attributes"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlElement("attribute", typeof(XmlSchemaAttribute)),
         XmlElement("attributeGroup", typeof(XmlSchemaAttributeGroupRef))]
        public XmlSchemaObjectCollection Attributes {
            get { return attributes; }
        }

        /// <include file='doc\XmlSchemaAttributeGroup.uex' path='docs/doc[@for="XmlSchemaAttributeGroup.AnyAttribute"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlElement("anyAttribute")]
        public XmlSchemaAnyAttribute AnyAttribute {
            get { return anyAttribute; }
            set { anyAttribute = value; }
        }

        [XmlIgnore]
        internal XmlQualifiedName QualifiedName {
            get { return qname; }
            set { qname = value; }
        }

        [XmlIgnore]
        internal XmlSchemaObjectTable AttributeUses {
            get { return attributeUses; }
        }

        [XmlIgnore]
        internal XmlSchemaAnyAttribute AttributeWildcard {
            get { return attributeWildcard; }
            set { attributeWildcard = value; }
        }

        /// <include file='doc\XmlSchemaAttributeGroup.uex' path='docs/doc[@for="XmlSchemaAttributeGroup.RedefinedAttributeGroup"]/*' />
        [XmlIgnore]
        public XmlSchemaAttributeGroup RedefinedAttributeGroup {
            get { return redefined; }
        }

        [XmlIgnore]
        internal XmlSchemaAttributeGroup Redefined {
            get { return redefined; }
            set { redefined = value; }
        }

        [XmlIgnore]
        internal bool Validating {
            get { return validating; }
            set { validating = value; }
        }
        
        [XmlIgnore]
        internal override string NameAttribute {
            get { return Name; }
            set { Name = value; }
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\schema\xmlschemaappinfo.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlSchemaAppInfo.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Schema {

    using System.Collections;
    using System.ComponentModel;
    using System.Xml.Serialization;

    /// <include file='doc\XmlSchemaAppInfo.uex' path='docs/doc[@for="XmlSchemaAppInfo"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public class XmlSchemaAppInfo : XmlSchemaObject {    
        string source;
        XmlNode[] markup;
        
        /// <include file='doc\XmlSchemaAppInfo.uex' path='docs/doc[@for="XmlSchemaAppInfo.Source"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlAttribute("source", DataType="anyURI")]
        public string Source {
            get { return source; }
            set { source = value; }
        }

        /// <include file='doc\XmlSchemaAppInfo.uex' path='docs/doc[@for="XmlSchemaAppInfo.Markup"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlText(), XmlAnyElement]
        public XmlNode[] Markup {
            get { return markup; }
            set { markup = value; }
        }
    }
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\schema\xmlschemaattributegroupref.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlSchemaAttributeGroupRef.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Schema {

    using System.Collections;
    using System.ComponentModel;
    using System.Xml.Serialization;

    /// <include file='doc\XmlSchemaAttributeGroupRef.uex' path='docs/doc[@for="XmlSchemaAttributeGroupRef"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public class XmlSchemaAttributeGroupRef : XmlSchemaAnnotated {
        XmlQualifiedName refName = XmlQualifiedName.Empty; 

        /// <include file='doc\XmlSchemaAttributeGroupRef.uex' path='docs/doc[@for="XmlSchemaAttributeGroupRef.RefName"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlAttribute("ref")]
        public XmlQualifiedName RefName { 
            get { return refName; }
            set { refName = (value == null ? XmlQualifiedName.Empty : value); }
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\schema\xmlschemaanyattribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlSchemaAnyAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Schema {

    using System.Collections;
    using System.ComponentModel;
    using System.Xml.Serialization;

    /// <include file='doc\XmlSchemaAnyAttribute.uex' path='docs/doc[@for="XmlSchemaAnyAttribute"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public class XmlSchemaAnyAttribute : XmlSchemaAnnotated {
        string ns;
        XmlSchemaContentProcessing processContents = XmlSchemaContentProcessing.None;
        NamespaceList namespaceList;
        
        /// <include file='doc\XmlSchemaAnyAttribute.uex' path='docs/doc[@for="XmlSchemaAnyAttribute.Namespaces"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlAttribute("namespace")]
        public string Namespace {
            get { return ns; }
            set { ns = value; }
        }
        
        /// <include file='doc\XmlSchemaAnyAttribute.uex' path='docs/doc[@for="XmlSchemaAnyAttribute.ProcessContents"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlAttribute("processContents"), DefaultValue(XmlSchemaContentProcessing.None)]
        public XmlSchemaContentProcessing ProcessContents {
            get { return processContents; }
            set { processContents = value; }
        }


        [XmlIgnore]
        internal NamespaceList NamespaceList {
            get { return namespaceList; }
        }

        [XmlIgnore]
        internal XmlSchemaContentProcessing ProcessContentsCorrect {
            get { return processContents == XmlSchemaContentProcessing.None ? XmlSchemaContentProcessing.Strict : processContents; }
        }

        internal void BuildNamespaceList(string targetNamespace) {
            if (ns != null) {
                namespaceList = new NamespaceList(ns, targetNamespace);
            }
            else {
                namespaceList = new NamespaceList();
            }
        }

        internal bool Allows(XmlQualifiedName qname) {
            return namespaceList.Allows(qname.Namespace);
        }

        internal static bool IsSubset(XmlSchemaAnyAttribute sub, XmlSchemaAnyAttribute super) {
            return NamespaceList.IsSubset(sub.NamespaceList, super.NamespaceList);
        }

        internal static XmlSchemaAnyAttribute Intersection(XmlSchemaAnyAttribute o1, XmlSchemaAnyAttribute o2) {
            NamespaceList nsl = NamespaceList.Intersection(o1.NamespaceList, o2.NamespaceList);
            if (nsl != null) {
                XmlSchemaAnyAttribute anyAttribute = new XmlSchemaAnyAttribute();
                anyAttribute.namespaceList = nsl;
                if (o1.processContents == XmlSchemaContentProcessing.Strict || 
                    o1.processContents == XmlSchemaContentProcessing.None ||
                    o2.processContents == XmlSchemaContentProcessing.Strict ||
                    o2.processContents == XmlSchemaContentProcessing.None) {
                    anyAttribute.processContents = XmlSchemaContentProcessing.Strict;
                }
                else if (o1.processContents == XmlSchemaContentProcessing.Lax ||
                         o2.processContents == XmlSchemaContentProcessing.Lax) {
                    anyAttribute.processContents = XmlSchemaContentProcessing.Lax;
                }
                else {
                    anyAttribute.processContents = XmlSchemaContentProcessing.Skip;
                }
                anyAttribute.Annotation = o1.Annotation;
                return anyAttribute;
            }
            else {
                // not expressible
                return null;
            }
        }

        internal static XmlSchemaAnyAttribute Union(XmlSchemaAnyAttribute o1, XmlSchemaAnyAttribute o2) {
            NamespaceList nsl = NamespaceList.Union(o1.NamespaceList, o2.NamespaceList);
            if (nsl != null) {
                XmlSchemaAnyAttribute anyAttribute = new XmlSchemaAnyAttribute();
                anyAttribute.namespaceList = nsl;
                anyAttribute.processContents = o1.processContents;
                anyAttribute.Annotation = o1.Annotation;
                return anyAttribute;
            }
            else {
                // not expressible
                return null;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\schema\validator.cs ===
//------------------------------------------------------------------------------
// <copyright file="Validator.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

/*
 * @(#) schemavalidator.cs 1.0 01/31/2000
 *
 *
 * Copyright (c) 1999, 2000 Microsoft, Corp. All Rights Reserved.
 *
 */


namespace System.Xml.Schema {
    using System;
    using System.Collections;
    using System.Text;
    using System.IO;
    using System.Net;
    using System.Diagnostics;
    using System.ComponentModel;
    using System.Xml.Schema;
    using System.Xml.XPath;
    using System.Globalization;
    

    internal sealed class Validator {
        private const int        STACK_INCREMENT = 10;
        private const string     x_schema = "x-schema:";
        private SchemaInfo       schemaInfo;
        private HWStack          validationStack;  // validaton contexts
        private ValidationState  context;          // current context
        private SchemaAttDef     attnDef;           // current attribute def
        private SchemaElementDecl nextElement;
        private StringBuilder    textValue;
        private string           textString;
        private bool             hasSibling;
        private Hashtable        attPresence;
        private XmlQualifiedName name = XmlQualifiedName.Empty;
        private XmlNameTable      nameTable;
        private XmlNamespaceManager  nsManager;
        private bool isProcessContents = false;
        private SchemaNames      schemaNames;
        private XmlValidatingReader reader;
        private PositionInfo        positionInfo;
        private XmlResolver      xmlResolver;
        private Hashtable        IDs;
        private ForwardRef       forwardRefs;
        private bool             checkDatatype = false;
        private Uri              baseUri;
        private int              startIDConstraint = -1;        // filter out no identityconstraint stack check
        private ValidationType validationFlag = ValidationType.Auto;
        private ValidationEventHandler  validationEventHandler;
        private XmlSchemaCollection schemaCollection;
        private Parser  inlineSchemaParser = null;
        private SchemaInfo inlineSchemaInfo;
        private String  inlineNs;
        private XmlSchemaContentProcessing processContents = XmlSchemaContentProcessing.Strict;

        static private readonly XmlSchemaDatatype dtCDATA = XmlSchemaDatatype.FromXmlTokenizedType(XmlTokenizedType.CDATA);
        static private readonly XmlSchemaDatatype dtQName = XmlSchemaDatatype.FromXmlTokenizedTypeXsd(XmlTokenizedType.QName);
        static private readonly XmlSchemaDatatype dtStringArray = dtCDATA.DeriveByList();

        internal Validator(XmlNameTable nameTable, SchemaNames schemaNames, XmlValidatingReader reader) {
            this.nameTable = nameTable;
            this.schemaNames = schemaNames;
            this.reader = reader;
            positionInfo = PositionInfo.GetPositionInfo(reader);
            nsManager = reader.NamespaceManager;
            if (nsManager == null) {
                nsManager = new XmlNamespaceManager(nameTable);
                isProcessContents = true;
            }
            SchemaInfo = new SchemaInfo(schemaNames);

            validationStack = new HWStack(STACK_INCREMENT);
            textValue = new StringBuilder();
            this.name = XmlQualifiedName.Empty;
            attPresence = new Hashtable();
            context = null;
            attnDef = null;
        }


        internal bool HasSchema { get { return SchemaInfo.SchemaType != SchemaType.None;}}

        internal SchemaInfo SchemaInfo {
            get { return schemaInfo; }
            set { schemaInfo = value; }
        }

        internal XmlSchemaCollection SchemaCollection {
            set { schemaCollection = value; }
        }

        internal XmlResolver XmlResolver {
            set { this.xmlResolver = value; }
        }

        internal Uri BaseUri {
            get { return baseUri; }
            set { baseUri = value; }
        }

        internal ValidationEventHandler  ValidationEventHandler {
           get { return validationEventHandler; }
           set { validationEventHandler = value; }
        }

        internal ValidationType  ValidationFlag {
           get { return validationFlag; }
           set { validationFlag = value; }
        }

        internal void CompleteValidation() {
#if DEBUG
            Debug.WriteLineIf(CompModSwitches.XmlSchema.TraceInfo, "Validator.CompleteValidation()");
#endif
            if (HasSchema) {
                if (context != null) {
                    while (context != null) {
                        EndChildren();
                    }
                }

                if (validationEventHandler != null) {
                    CheckForwardRefs();
                }
            }
            else if (ValidationFlag == ValidationType.XDR) {
                SendValidationEvent(new XmlSchemaException(Res.Xml_NoValidation), XmlSeverityType.Warning);
            }
        }


        internal void ValidateWhitespace() {
            if (validationEventHandler != null && context != null &&
                context.NeedValidateChildren &&
                processContents == XmlSchemaContentProcessing.Strict &&
                context.ElementDecl != null) {
                // make sure content is allowed to contain whitespace !
                if (context.ElementDecl.Content.ContentType == CompiledContentModel.Type.Empty) {
                    try {
                        context.ElementDecl.Content.CheckContent(context, XmlQualifiedName.Empty, ref processContents);
                    }
                    catch (XmlSchemaException) {
                        SendValidationEvent(Res.Sch_InvalidTextWhiteSpace);
                    }
                }
                else if (reader.StandAlone && context.ElementDecl.IsDeclaredInExternal && context.ElementDecl.Content.ContentType == CompiledContentModel.Type.ElementOnly) {
                    SendValidationEvent(Res.Sch_StandAlone);
                }
                else if (XmlNodeType.SignificantWhitespace != reader.NodeType) {
                    // No need to do any validation since the whitespace is insignificant and the context is not of type Empty
                    return;
                }
                if (checkDatatype) {
                    SaveTextValue(reader.Value);
                }
            }
        }

        internal void Validate(ValidationType valType) {
            if (ValidationType.None != valType) {
                Validate();
                return;
            }

            if (XmlNodeType.Element == reader.NodeType) {
                this.name = QualifiedName(reader.Prefix, reader.LocalName, reader.NamespaceURI);
                nextElement = SchemaInfo.GetElementDecl(this.name, (context != null) ? context.ElementDecl : null);

                if (null == nextElement) {
                    //this could be an undeclared element
                    nextElement = (SchemaElementDecl)(SchemaInfo.UndeclaredElementDecls[this.name]);
                    if (nextElement != null) {
                        //add default attributes
                        foreach (SchemaAttDef attdef in nextElement.AttDefs.Values) {
                                if (attdef.Presence == SchemaDeclBase.Use.Default ||
                                     attdef.Presence == SchemaDeclBase.Use.Fixed) {
                                        reader.AddDefaultAttribute(attdef);
                                }
                        }
                        return;
                    }
                    return;
                }
                int count = reader.AttributeCount;

                for (int i = 0; i < count ; i++) {
                    reader.MoveToAttribute(i);

                    this.name = QualifiedName(reader.Prefix, reader.LocalName, reader.NamespaceURI);
                    attnDef =  nextElement.GetAttDef(this.name);
                    if (attnDef != null) {
                        reader.SchemaTypeObject = (attnDef.SchemaType != null) ? (object)attnDef.SchemaType : (object)attnDef.Datatype;
                    }
                    else  {
                        reader.SchemaTypeObject = dtCDATA;
                    }
                }

                reader.MoveToElement();
                // Add default attributes
                foreach (SchemaAttDef attdef in nextElement.AttDefs.Values) {
                    if (attdef.Presence == SchemaDeclBase.Use.Default ||
                        attdef.Presence == SchemaDeclBase.Use.Fixed) {
                        reader.AddDefaultAttribute(attdef);
                    }
                }
            }

        }

        internal void Validate() {
            if (inlineSchemaParser != null) {
                if (!inlineSchemaParser.ParseReaderNode()) { // Done
                    XmlSchema schema = inlineSchemaParser.FinishParsing();
                    bool add = true;
                    if (schema != null) {
                        inlineNs = schema.TargetNamespace == null ? string.Empty : schema.TargetNamespace;
                        if (!SchemaInfo.HasSchema(inlineNs) && schema.ErrorCount == 0) {
                            schema.Compile(schemaCollection, nameTable, schemaNames, validationEventHandler, null, inlineSchemaInfo, true, this.xmlResolver);
                            add = schema.ErrorCount == 0;
                        }
                        else {
                            add = false;
                        }
                    }
                    else {
                        inlineNs = inlineSchemaInfo.CurrentSchemaNamespace;
                        add = !SchemaInfo.HasSchema(inlineNs);
                    }

                    if (add) {
                        SchemaInfo.Add(inlineNs, inlineSchemaInfo, validationEventHandler);
                        schemaCollection.Add(inlineNs, inlineSchemaInfo, schema, false);
                    }
                    inlineSchemaParser = null;
                    inlineSchemaInfo = null;
                    inlineNs = null;
                }
            }
            else {
                this.name = QualifiedName(reader.Prefix, reader.LocalName, reader.NamespaceURI);
                if (HasSchema) {
                    if (context != null) {
                        while (context != null && reader.Depth <= context.Depth) {
                            EndChildren();
                        }
                        ValidateElementContent(reader.NodeType);
                    }
                    if (reader.Depth == 0 && reader.NodeType == XmlNodeType.Element && SchemaInfo.SchemaType == SchemaType.DTD) {
                        if (!SchemaInfo.DocTypeName.Equals(this.name)) {
                            SendValidationEvent(Res.Sch_RootMatchDocType);
                        }
                    }
                }
                if (reader.NodeType == XmlNodeType.Element) {
                    if (schemaNames.IsSchemaRoot(this.name) &&
                        reader.Depth > 0 && 
                        !SkipProcess(this.name == schemaNames.QnXsdSchema ? SchemaType.XSD : SchemaType.XDR) &&
                        IsCorrectSchemaType(this.name == schemaNames.QnXsdSchema ? SchemaType.XSD : SchemaType.XDR)) {
                        inlineSchemaInfo = new SchemaInfo(schemaNames);
                        inlineSchemaParser = new Parser(schemaCollection, nameTable, schemaNames, validationEventHandler);
                        inlineSchemaParser.StartParsing(reader, null, inlineSchemaInfo);
                        inlineSchemaParser.ParseReaderNode();
                    }
                    else {
                        ProcessElement();
                    }
                }
            }
        }


        private bool IsXdrSchema(string uri) {
            return uri.Length >= x_schema.Length &&
                   0 == string.Compare(uri, 0, x_schema, 0, x_schema.Length, false, CultureInfo.InvariantCulture) &&
                   !uri.StartsWith("x-schema:#");
        }

        private bool IsCorrectSchemaType(SchemaType st) {
            switch(validationFlag) {
                case ValidationType.Auto:
                    return  SchemaInfo.SchemaType == SchemaType.None || SchemaInfo.SchemaType == st;
                case ValidationType.None:
                    return true;
                default:
                    if (SchemaInfo.SchemaType == SchemaType.None) {
                        return IsCorrectSchemaType(st, validationFlag);
                    }
                    else return SchemaInfo.SchemaType == st;
            }
        }

        private bool IsCorrectSchemaType(SchemaType st, ValidationType vt) {
            switch(vt) {
                case ValidationType.DTD:
                    return st == SchemaType.DTD;
                case ValidationType.XDR:
                    return st == SchemaType.XDR;
                case ValidationType.Schema:
                    return st == SchemaType.XSD;
            }
            return false;
        }

        private bool SkipProcess(SchemaType st) {
            return  (HasSchema && validationFlag == ValidationType.Auto && SchemaInfo.SchemaType != st);
        }

        private bool LoadSchema(string uri, string url) {
            bool expectXdr = false;

            uri = nameTable.Add(uri);
            if (SchemaInfo.HasSchema(uri)) {
                return false;
            }

            SchemaInfo schemaInfo = null;
            if (schemaCollection != null)
                schemaInfo = schemaCollection.GetSchemaInfo(uri);
            if (schemaInfo != null) {
                /*
                if (SkipProcess(schemaInfo.SchemaType))
                    return false;
                */
                if (!IsCorrectSchemaType(schemaInfo.SchemaType)) {
                    throw new XmlException(Res.Xml_MultipleValidaitonTypes, string.Empty, this.positionInfo.LineNumber, this.positionInfo.LinePosition);
                }
                SchemaInfo.Add(uri, schemaInfo, validationEventHandler);
                return true;
            }

            if (this.xmlResolver == null)
                return false;

            if (url == null && IsXdrSchema(uri)) {
                /* bug 67398
                if( ValidationFlag == ValidationType.DTD && 0 == this.reader.Depth) {
                    SendValidationEvent(Res.Xml_NoDTDPresent, this.name.ToString(), XmlSeverityType.Warning);
                }
                else  if (SkipProcess(SchemaType.XDR))
                    return false;
                else if (ValidationFlag != ValidationType.XDR && ValidationFlag != ValidationType.Auto) {
                    throw new XmlException(Res.Sch_XSCHEMA, string.Empty, this.positionInfo.LineNumber, this.positionInfo.LinePosition);
                }
                */
                if (ValidationFlag != ValidationType.XDR && ValidationFlag != ValidationType.Auto) {
                    return false;
                }
                url = uri.Substring(x_schema.Length);
                expectXdr = true;
            }
            if (url == null) {
                return false;
            }

            XmlSchema schema = null;
            XmlReader reader = null;
            try {
				Uri ruri = this.xmlResolver.ResolveUri(baseUri, url);
                Stream stm = (Stream)this.xmlResolver.GetEntity(ruri,null,null);
                reader = new XmlTextReader(ruri.ToString(), stm, nameTable);
                schemaInfo = new SchemaInfo(schemaNames);

                Parser sparser = new Parser(schemaCollection, nameTable, schemaNames, validationEventHandler);
		sparser.XmlResolver = this.xmlResolver;
                schema = sparser.Parse(reader, uri, schemaInfo);

                while(reader.Read());// wellformness check
            }
            catch(XmlSchemaException e) {
                SendValidationEvent(Res.Sch_CannotLoadSchema, new string[] {uri, e.Message}, XmlSeverityType.Error);
                schemaInfo = null;
            }
            catch(Exception e) {
                SendValidationEvent(Res.Sch_CannotLoadSchema, new string[] {uri, e.Message}, XmlSeverityType.Warning);
                schemaInfo = null;
            }
            finally {
                if (reader != null) {
                    reader.Close();
                }
            }
            if (schemaInfo != null) {
                int errorCount = 0;
                if (schema != null) {
                    if (expectXdr) {
                        throw new XmlException(Res.Sch_XSCHEMA, string.Empty, this.positionInfo.LineNumber, this.positionInfo.LinePosition);
                    }

                    if (schema.ErrorCount == 0) {
                        schema.Compile(schemaCollection, nameTable, schemaNames, validationEventHandler, uri, schemaInfo, true, this.xmlResolver);
                    }
                    errorCount += schema.ErrorCount;
                }
                else {
                    errorCount += schemaInfo.ErrorCount;
                }
                if (errorCount == 0) {
                    if (SkipProcess(schemaInfo.SchemaType))
                       return false;

                    if (!IsCorrectSchemaType(schemaInfo.SchemaType)) {
                        throw new XmlException(Res.Xml_MultipleValidaitonTypes, string.Empty, this.positionInfo.LineNumber, this.positionInfo.LinePosition);
                    }
                    SchemaInfo.Add(uri, schemaInfo, validationEventHandler);
                    schemaCollection.Add(uri, schemaInfo, schema, false);
                    return true;
                }
            }
            return false;
        }

        private void ProcessElement() {
            int count = reader.AttributeCount;
            XmlQualifiedName xsiType = XmlQualifiedName.Empty;
            if (reader.Depth == 0 && SchemaInfo.SchemaType != SchemaType.DTD && validationFlag != ValidationType.DTD && validationFlag != ValidationType.None) {
                LoadSchema(string.Empty, null);
            }

            string[] xsiSchemaLocation = null;
            string xsiNoNamespaceSchemaLocation = null;
            string xsiNil = null;
            if (SchemaInfo.SchemaType != SchemaType.DTD && validationFlag != ValidationType.DTD && validationFlag != ValidationType.None) {
                for (int i = 0; i < count ; i++) {
                    reader.MoveToAttribute(i);
                    string objectNs = reader.NamespaceURI;
                    string objectName = reader.LocalName;
                    if (Ref.Equal(objectNs, schemaNames.NsXmlNs)) {
                        LoadSchema(reader.Value, null);
                        if (isProcessContents) {
                            nsManager.AddNamespace(reader.Prefix == string.Empty ? string.Empty : reader.LocalName, reader.Value);
                        }
                    }
                    else if ((validationFlag != ValidationType.XDR) && Ref.Equal(objectNs, schemaNames.NsXsi)) {
                        if (Ref.Equal(objectName, schemaNames.XsiSchemaLocation)) {
                            xsiSchemaLocation = (string[])dtStringArray.ParseValue(reader.Value, nameTable, nsManager);
                        }
                        else if (Ref.Equal(objectName, schemaNames.XsiNoNamespaceSchemaLocation)) {
                            xsiNoNamespaceSchemaLocation = reader.Value;
                        }
                        else if (Ref.Equal(objectName, schemaNames.XsiType)) {
                            xsiType = (XmlQualifiedName)dtQName.ParseValue(reader.Value, nameTable, nsManager);
                        }
                        else if (Ref.Equal(objectName, schemaNames.XsiNil)) {
                            xsiNil = reader.Value;
                        }
                        SchemaInfo.SchemaType = SchemaType.XSD;
                    }
                    else if (
                        SchemaInfo.SchemaType != SchemaType.XSD &&
                        Ref.Equal(objectNs, schemaNames.QnDtDt.Namespace) &&
                        Ref.Equal(objectName, schemaNames.QnDtDt.Name)
                    ) {
                        reader.SchemaTypeObject = XmlSchemaDatatype.FromXdrName(reader.Value);
                        SchemaInfo.SchemaType = SchemaType.XDR;
                    }
                }
            }
            if (count > 0) {
                reader.MoveToElement();
            }
            if (xsiNoNamespaceSchemaLocation != null) {

                LoadSchema(string.Empty, xsiNoNamespaceSchemaLocation);
            }
            if (xsiSchemaLocation != null) {
                for (int i = 0; i < xsiSchemaLocation.Length - 1; i += 2) {
                    LoadSchema((string)xsiSchemaLocation[i], (string)xsiSchemaLocation[i + 1]);
                }
            }

            if (HasSchema) {
                if (processContents == XmlSchemaContentProcessing.Skip) {
                    nextElement = null;
                }
                else {
                    nextElement = SchemaInfo.GetElementDecl(this.name, (context != null) ? context.ElementDecl : null);
                    if (nextElement != null) {
                        if (xsiType.IsEmpty) {
                            if (nextElement.IsAbstract) {
                                SendValidationEvent(Res.Sch_AbstractElement, this.name.ToString());
                                nextElement = null;
                            }
                        }
                        else if(xsiNil != null && xsiNil.Equals("true")) {
                            SendValidationEvent(Res.Sch_XsiNilAndType);
                        }
                        else {
                            SchemaElementDecl nextElementXsi = (SchemaElementDecl)SchemaInfo.ElementDeclsByType[xsiType];
                            if (nextElementXsi == null && xsiType.Namespace == schemaNames.NsXsd) {
                                XmlSchemaDatatype datatype = XmlSchemaDatatype.FromTypeName(xsiType.Name);
                                if (datatype != null) {
                                    nextElementXsi = new SchemaElementDecl(datatype, this.schemaNames);
                                }
                            }
                            if (nextElementXsi == null) {
                                SendValidationEvent(Res.Sch_XsiTypeNotFound, xsiType.ToString());
                                nextElement = null;
                            }
                            else if (!XmlSchemaType.IsDerivedFrom(
                                (nextElementXsi.SchemaType == null ? (object)nextElementXsi.Datatype : (object)nextElementXsi.SchemaType),
                                (nextElement.SchemaType == null ? (object)nextElement.Datatype : (object)nextElement.SchemaType),
                                nextElement.Block
                            )) {
                                SendValidationEvent(Res.Sch_XsiTypeBlocked, this.name.ToString());
                                nextElement = null;
                            }
                            else {
                                nextElement = nextElementXsi;
                            }

                        }
                    }
                }

                PushElementDecl(this.name.Namespace, reader.Prefix, reader.Depth);
                if (context.ElementDecl != null || SchemaInfo.SchemaType == SchemaType.XSD) {
                    if (context.ElementDecl != null && context.ElementDecl.IsNillable) {
                        if (xsiNil != null) {
                            context.IsNill = XmlConvert.ToBoolean(xsiNil);
                            if (context.IsNill && context.ElementDecl.DefaultValueTyped != null) {
                                SendValidationEvent(Res.Sch_XsiNilAndFixed);
                            }
                        }
                    }
                    else if (xsiNil != null) {
                        SendValidationEvent(Res.Sch_InvalidXsiNill);
                    }

                    if (context.ElementDecl != null) {
                        if (context.ElementDecl.SchemaType != null) {
                            reader.SchemaTypeObject =  context.ElementDecl.SchemaType;
                        }
                        else {
                            reader.SchemaTypeObject =  context.ElementDecl.Datatype;
                        }
                        if (reader.IsEmptyElement && !context.IsNill && context.ElementDecl.DefaultValueTyped != null) {
                           reader.TypedValueObject = context.ElementDecl.DefaultValueTyped;
                           context.IsNill = true; // reusing IsNill
                        }
                        if (this.context.ElementDecl.HasRequiredAttribute || this.startIDConstraint != -1) {
                            attPresence.Clear();
                        }
                    }

                    if (nextElement != null) {
                        //foreach constraint in stack (including the current one)
                        if (this.startIDConstraint != -1) {
                            for (int i = this.startIDConstraint; i < this.validationStack.Length; i ++) {
                                // no constraint for this level
                                if (((ValidationState)(this.validationStack[i])).Constr == null) {
                                    continue;
                                }

                                // else
                                foreach (ConstraintStruct conuct in ((ValidationState)(this.validationStack[i])).Constr) {
                                    // check selector from here
                                    if (conuct.axisSelector.MoveToStartElement(reader.LocalName, reader.NamespaceURI)) {
                                        // selector selects new node, activate a new set of fields
                                        Debug.WriteLine("Selector Match!");
                                        Debug.WriteLine("Name: " + reader.LocalName + "\t|\tURI: " + reader.NamespaceURI + "\n");
                                        // in which axisFields got updated
                                        conuct.axisSelector.PushKS(positionInfo.LineNumber, positionInfo.LinePosition);
                                    }

                                    // axisFields is not null, but may be empty
                                    foreach (LocatedActiveAxis laxis in conuct.axisFields) {
                                        // check field from here
                                        if (laxis.MoveToStartElement(reader.LocalName, reader.NamespaceURI)) {
                                            Debug.WriteLine("Element Field Match!");
                                            // checking simpleType / simpleContent
                                            if (nextElement != null) {      // nextElement can be null when xml/xsd are not valid
                                                if (nextElement.Datatype == null) {
                                                    SendValidationEvent (Res.Sch_FieldSimpleTypeExpected, reader.LocalName);
                                                }
                                                else {
                                                    // can't fill value here, wait till later....
                                                    // fill type : xsdType
                                                    laxis.isMatched = true;
                                                    // since it's simpletyped element, the endchildren will come consequently... don't worry
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }

                    for (int i = 0; i < count ; i++) {
                        reader.MoveToAttribute(i);
                        if ((SchemaInfo.SchemaType == SchemaType.XSD || SchemaInfo.SchemaType == SchemaType.XDR) && (object)reader.NamespaceURI == (object)schemaNames.NsXmlNs) {
                            continue;
                        }
                        if (SchemaInfo.SchemaType == SchemaType.XSD && (object)reader.NamespaceURI == (object)schemaNames.NsXsi) {
                            continue;
                        }
                        this.name = QualifiedName(reader.Prefix, reader.LocalName, reader.NamespaceURI);
                        try {
                            bool skip = ((XmlSchemaContentProcessing.Skip == processContents || XmlSchemaContentProcessing.Lax == processContents)? true : false);
                            attnDef = SchemaInfo.GetAttribute(context.ElementDecl, this.name, ref skip);
                            if (attnDef != null) {
                                if (context.ElementDecl != null && (context.ElementDecl.HasRequiredAttribute || this.startIDConstraint != -1)) {
                                    attPresence.Add(attnDef.Name, attnDef);
                                }
                                reader.SchemaTypeObject = (attnDef.SchemaType != null) ? (object)attnDef.SchemaType : (object)attnDef.Datatype;
                                if (attnDef.Datatype != null) {

                                    // VC constraint:
                                    // The standalone document declaration must have the value "no" if any external markup declarations
                                    // contain declarations of attributes with values subject to normalization, where the attribute appears in
                                    // the document with a value which will change as a result of normalization,

                                    string attributeValue = reader.Value;
                                    if (reader.StandAlone && attnDef.IsDeclaredInExternal && attributeValue != reader.RawValue) {
                                        SendValidationEvent(Res.Sch_StandAloneNormalization, reader.Name);
                                    }

                                    // need to check the contents of this attribute to make sure
                                    // it is valid according to the specified attribute type.
                                    CheckValue(attributeValue, attnDef);
                                }
                            }
                            else if (ValidationFlag == ValidationType.Schema && !skip) {
                                SendValidationEvent(Res.Sch_NoAttributeSchemaFound, this.name.ToString(), XmlSeverityType.Warning);
                            }
                        }
                        catch (XmlSchemaException e) {
                            e.SetSource(reader.BaseURI, positionInfo.LineNumber, positionInfo.LinePosition);
                            SendValidationEvent(e);
                        }

                        // for all constraint in the stack, i have to check this thing
                        if (nextElement != null) {
                            IDCCheckAttr(reader.LocalName, reader.NamespaceURI, reader.TypedValueObject, reader.Value, attnDef);
                        }
                    }

                    if (count > 0) {
                        reader.MoveToElement();
                    }

                    // Add default attributes
                    if ( nextElement != null) {
                        foreach (SchemaAttDef attdef in nextElement.AttDefs.Values) {
                            if (attdef.Presence == SchemaDeclBase.Use.Default ||
                                attdef.Presence == SchemaDeclBase.Use.Fixed) {
                                // VC constraint:
                                // Standalone must be = "no" when any external markup declarations contain declarations of attributes
                                // with default values, if elements to which these attributes apply appear in the document without
                                // specifications of values for these attributes

                                // for default attribute i have to check too...
                                if (reader.AddDefaultAttribute(attdef) && reader.StandAlone && attdef.IsDeclaredInExternal) {
                                    SendValidationEvent(Res.Sch_UnSpecifiedDefaultAttributeInExternalStandalone, attdef.Name.Name);
                                }

                                // even default attribute i have to move to... but can't exist
                                if (! attPresence.Contains(attdef.Name)) {
                                    IDCCheckAttr(attdef.Name.Name, attdef.Name.Namespace, attdef.DefaultValueTyped, attdef.DefaultValueRaw, attdef);
                                }
                            }
                        }
                    }
                }
                BeginChildren();
                if (reader.IsEmptyElement) {
                    EndChildren();
                }
            }
            else {
                //couldnt find any schema for this element
                if( ValidationFlag == ValidationType.DTD && 0 == reader.Depth) {
                    // this warning only needs to be on the documentElement
                    SendValidationEvent(Res.Xml_NoDTDPresent, this.name.ToString(), XmlSeverityType.Warning);
                }
                else if(ValidationFlag == ValidationType.Schema) {
                    SendValidationEvent(Res.Sch_NoElementSchemaFound, this.name.ToString(),XmlSeverityType.Warning);

                    for (int i = 0; i < count ; i++) {
                        reader.MoveToAttribute(i);
                        if ((object)reader.NamespaceURI == (object)schemaNames.NsXmlNs
                            ||(ValidationType.Schema == ValidationFlag && (object)reader.NamespaceURI == (object)schemaNames.NsXsi)) {
                            continue;
                        }
                        this.name = QualifiedName(reader.Prefix, reader.LocalName, reader.NamespaceURI);
                        SendValidationEvent(Res.Sch_NoAttributeSchemaFound, this.name.ToString(), XmlSeverityType.Warning);
                    }
                    reader.MoveToElement();
                }
            }

        }

        private void CheckForEmptyElementInDTD() {
            if (SchemaType.DTD == SchemaInfo.SchemaType) {
                // When validating with a dtd, empty elements should be lexically empty.
                if (CompiledContentModel.Type.Empty == context.ElementDecl.Content.ContentType) {
                    throw new XmlSchemaException(Res.Sch_InvalidElementContent, new string[] { context.Name.ToString(), reader.NodeType.ToString() });
                }
            }

        }

        private void ValidateElementContent(XmlNodeType nodeType) {
            if (context != null &&
                context.NeedValidateChildren &&
                (processContents == XmlSchemaContentProcessing.Strict || processContents == XmlSchemaContentProcessing.Lax) &&
                context.ElementDecl != null) {
                try {
                    CheckForEmptyElementInDTD();
                    switch (nodeType) {
                        case XmlNodeType.Element:       // <foo ... >
                            context.ElementDecl.Content.CheckContent(context, this.name, ref processContents);
                            break;

                        case XmlNodeType.Whitespace:
                        case XmlNodeType.SignificantWhitespace:
                            ValidateWhitespace();
                            break;
                        case XmlNodeType.Text:          // text inside a node
                        case XmlNodeType.CDATA:         // <![CDATA[...]]>
                            context.ElementDecl.Content.CheckContent(context, XmlQualifiedName.Empty, ref processContents);
                            if (checkDatatype) {
                                SaveTextValue(reader.Value);
                            }
                            break;

                        case XmlNodeType.EntityReference:
                            this.name = QualifiedName(reader.Prefix, reader.LocalName, reader.NamespaceURI);
                            if (!IsGenEntity(this.name)) {
                                context.ElementDecl.Content.CheckContent(context, XmlQualifiedName.Empty, ref processContents);
                            }
                            break;

                        default:
                            break;
                    }
                }
                catch (XmlSchemaException e) {
                    e.SetSource(reader.BaseURI, positionInfo.LineNumber, positionInfo.LinePosition);
                    SendValidationEvent(e);
                }
            }
            else if (nodeType == XmlNodeType.EntityReference) {
                if (IsGenEntity(this.name)) {
                    //do nothing here.
                }
            }
        }

        private void PushElementDecl(string ns, string prefix, int depth) {
            //
            // push context
            //
            Push();
            context.ElementDecl = nextElement;
            context.Depth = depth;
            context.Name = this.name;
            context.Prefix = prefix;
            context.ProcessContents = processContents;
            context.IsNill = false;
            if (nextElement != null) {
                nextElement.Content.InitContent(context);

                // added on June 15, set the context here, so the stack can have them
                if (nextElement.Constraints != null) {
                    context.Constr = new ConstraintStruct[nextElement.Constraints.Length];
                    int id = 0;
                    foreach (CompiledIdentityConstraint constraint in nextElement.Constraints) {
                        context.Constr[id++] = new ConstraintStruct (constraint);
                    } // foreach constraint /constraintstruct

                    // added on June 19, make connections between new keyref tables with key/unique tables in stack
                    // i can't put it in the above loop, coz there will be key on the same level
                    foreach (ConstraintStruct keyrefconstr in context.Constr) {
                        if ( keyrefconstr.constraint.Role == CompiledIdentityConstraint.ConstraintRole.Keyref ) {
                            bool find = false;
                            ConstraintStruct findcs = null;
                            // go upwards checking or only in this level
                            for (int level = this.validationStack.Length - 1; level >= ((this.startIDConstraint >= 0) ? this.startIDConstraint : this.validationStack.Length - 1); level --) {
                                // no constraint for this level
                                if (((ValidationState)(this.validationStack[level])).Constr == null) {
                                    continue;
                                }
                                // else
                                foreach (ConstraintStruct constr in ((ValidationState)(this.validationStack[level])).Constr) {
                                    if (constr.constraint.name == keyrefconstr.constraint.refer) {
                                        find = true;
                                        findcs = constr;
                                        break;
                                    }
                                }

                                if (find) {
                                    break;
                                }
                            }
                            if (find) {
                                if (findcs.keyrefTables == null) {
                                    findcs.keyrefTables = new ArrayList();          // arraylist of keyref tables
                                }
                                findcs.keyrefTables.Add (keyrefconstr.qualifiedTable);
                            }
                            else {
                                // didn't find connections, throw exceptions
                                SendValidationEvent(Res.Sch_RefNotInScope, this.name.ToString());
                            }
                        } // finished dealing with keyref

                    }  // end foreach

                    // initial set
                    if (this.startIDConstraint == -1) {
                        this.startIDConstraint = this.validationStack.Length - 1;
                    }
                }
            }
            else {
                switch (SchemaInfo.SchemaType) {
                case SchemaType.XSD:
                    if (processContents == XmlSchemaContentProcessing.Strict) {
                        SendValidationEvent(Res.Sch_UndeclaredElement, this.name.ToString());
                    }
                    else {
                        if (processContents == XmlSchemaContentProcessing.Lax) {
                            SendValidationEvent(Res.Sch_NoElementSchemaFound, this.name.ToString(), XmlSeverityType.Warning);
                        }
                    }
                    break;
                case SchemaType.DTD:
                    SendValidationEvent(Res.Sch_UndeclaredElement, this.name.ToString());
                    break;
                case SchemaType.XDR:
                    if (SchemaInfo.HasSchema(ns)) {
                        SendValidationEvent(Res.Sch_UndeclaredElement, this.name.ToString());
                    }
                    break;
                default:
                    Debug.Assert(ValidationFlag == ValidationType.Auto);
                    break;
                }
            }
        }


        private void BeginChildren() {
            if (validationEventHandler != null &&
                context.ElementDecl != null) {
                if (context.ElementDecl.HasRequiredAttribute) {
                    try {
                        context.ElementDecl.CheckAttributes(attPresence, reader.StandAlone);
                    }
                    catch (XmlSchemaException e) {
                        e.SetSource(reader.BaseURI, positionInfo.LineNumber, positionInfo.LinePosition);
                        SendValidationEvent(e);
                    }

                }
                if (context.ElementDecl.Datatype != null) {
                    checkDatatype = true;
                    hasSibling = false;
                    textString = string.Empty;
                    textValue.Length = 0;
                }
            }
            attnDef = null;
            if (isProcessContents) {
                nsManager.PushScope();
            }
        }


        private void EndChildren() {
            if (isProcessContents) {
                nsManager.PopScope();
            }
            if (validationEventHandler != null &&
                context.ElementDecl != null) {
                if (context.NeedValidateChildren &&
                    !context.HasMatched &&
		    !context.IsNill &&
                    !context.ElementDecl.Content.HasMatched(context)) {
                    ArrayList v = context.ElementDecl.Content.ExpectedElements(context.State, context.AllElementsSet);
                    if (v == null || v.Count == 0){
                        SendValidationEvent(Res.Sch_IncompleteContent, context.Name.ToString());
                    }
                    else {
                        StringBuilder builder = new StringBuilder();
                        for (int i = 0; i < v.Count; ++i) {
                            builder.Append(v[i].ToString());
                            if (i+1 < v.Count)
                                builder.Append(" ");
                        }
                        SendValidationEvent(Res.Sch_IncompleteContentExpecting,  new string[] { context.Name.ToString(), builder.ToString() });
                    }
                }

          string stringValue = !hasSibling ? textString : textValue.ToString();  // only for identity-constraint exception reporting
                if (checkDatatype && !context.IsNill) {
                    if(!(stringValue == string.Empty && context.ElementDecl.DefaultValueTyped != null)) {
                        CheckValue(stringValue, null);
                        checkDatatype = false;
                        textValue.Length = 0; // cleanup
                        textString = string.Empty;
                    }
                }

                // for each level in the stack, endchildren and fill value from element
                if (this.startIDConstraint != -1) {
                    for (int ci = this.validationStack.Length - 1; ci >= this.startIDConstraint; ci --) {
                        // no constraint for this level
                        if (((ValidationState)(this.validationStack[ci])).Constr == null) {
                            continue;
                        }

                        // else
                        foreach (ConstraintStruct conuct in ((ValidationState)(this.validationStack[ci])).Constr) {
                            // axisFields is not null, but may be empty
                            foreach (LocatedActiveAxis laxis in conuct.axisFields) {
                                // check field from here
                                // isMatched is false when nextElement is null. so needn't change this part.
                                if (laxis.isMatched) {
                                    Debug.WriteLine("Element Field Filling Value!");
                                    Debug.WriteLine("Name: " + reader.LocalName + "\t|\tURI: " + reader.NamespaceURI + "\t|\tValue: " + reader.TypedValueObject + "\n");
                                    // fill value
                                    laxis.isMatched = false;
                                    if (laxis.Ks[laxis.Column] != null) {
                                        // [field...] should be evaluated to either an empty node-set or a node-set with exactly one member
                                        // two matches... already existing field value in the table.
                                        SendValidationEvent (Res.Sch_FieldSingleValueExpected, reader.LocalName);
                                    }
                                    else {
                                        // for element, reader.Value = "";
                                       laxis.Ks[laxis.Column] = new TypedObject (reader.TypedValueObject, stringValue, context.ElementDecl.Datatype);
                                    }
                                }
                                // EndChildren
                                laxis.EndElement(reader.LocalName, reader.NamespaceURI);
                            }

                            if (conuct.axisSelector.EndElement(reader.LocalName, reader.NamespaceURI)) {
                    	    // insert key sequence into hash (+ located active axis tuple leave for later)
                    	    KeySequence ks = conuct.axisSelector.PopKS();
	                    // unqualified keysequence are not allowed
	                    switch (conuct.constraint.Role) {
	                    case CompiledIdentityConstraint.ConstraintRole.Key:
                                if (! ks.IsQualified()) {
                                    //Key's fields can't be null...  if we can return context node's line info maybe it will be better
                                    //only keymissing & keyduplicate reporting cases are necessary to be dealt with... 3 places...
                                    SendValidationEvent(new XmlSchemaException(Res.Sch_MissingKey, conuct.constraint.name.ToString(), reader.BaseURI, ks.PosLine, ks.PosCol));
                                }
                                else if (conuct.qualifiedTable.Contains (ks)) {
                                    // unique or key checking value confliction
                                    // for redundant key, reporting both occurings
                                    // doesn't work... how can i retrieve value out??
                                    SendValidationEvent(new XmlSchemaException(Res.Sch_DuplicateKey,
                                        new string[2] {ks.ToString(), conuct.constraint.name.ToString()},
                                        reader.BaseURI, ks.PosLine, ks.PosCol));
                                }
                                else {
                                    conuct.qualifiedTable.Add (ks, ks);
                                }
	                        break;
	                    case CompiledIdentityConstraint.ConstraintRole.Unique:
                                if (! ks.IsQualified()) {
                                    continue;
                                }
                                if (conuct.qualifiedTable.Contains (ks)) {
                                // unique or key checking confliction
                                SendValidationEvent(new XmlSchemaException(Res.Sch_DuplicateKey,
                                    new string[2] {ks.ToString(), conuct.constraint.name.ToString()},
                                    reader.BaseURI, ks.PosLine, ks.PosCol));
                                }
                                else {
                                    conuct.qualifiedTable.Add (ks, ks);
                                }
	                        break;
	                    case CompiledIdentityConstraint.ConstraintRole.Keyref:
                                // is there any possibility:
                                // 2 keyrefs: value is equal, type is not
                                // both put in the hashtable, 1 reference, 1 not
                                if (! ks.IsQualified() || conuct.qualifiedTable.Contains (ks)) {
                                    continue;
                                }
                                conuct.qualifiedTable.Add (ks, ks);
	                            break;
	                        }
                    	
                            }

                        }
                    }

                    // current level's constraint struct
                    ConstraintStruct[] vcs = ((ValidationState)(this.validationStack[this.validationStack.Length - 1])).Constr;
                    if ( vcs != null) {
                        //validating all referencing tables...
                        foreach (ConstraintStruct conuct in vcs) {
                            if (( conuct.constraint.Role == CompiledIdentityConstraint.ConstraintRole.Keyref)
                                || (conuct.keyrefTables == null)) {
                                continue;
                            }
                            foreach (Hashtable keyrefTable in conuct.keyrefTables) {
                                foreach (KeySequence ks in keyrefTable.Keys) {
                                    if (! conuct.qualifiedTable.Contains (ks)) {
                                        SendValidationEvent(new XmlSchemaException(Res.Sch_UnresolvedKeyref, ks.ToString(),
                                            reader.BaseURI, ks.PosLine, ks.PosCol));
                                    }
                                }
                            }
                        }
                    }
                }
            }

            Pop();
        }


        private void SaveTextValue(string value) {
            if (textString == string.Empty) {
                textString = value;
            }
            else {
                if (!hasSibling) {
                    textValue.Append(textString);
                    hasSibling = true;
                }
                textValue.Append(value);
            }
        }

        internal bool AllowText() {
            return (context != null && context.ElementDecl != null) ? context.ElementDecl.AllowText() : false;
        }


        internal XmlScanner ResolveEntity(string name,
                                          bool fInAttribute,
                                          ref object o,
                                          out bool isExternal,
                                          out string resolvedUrl,
                                          bool disableUndeclaredEntityCheck) {
            isExternal = false;
            string code = null;
            string msg = null;
            this.name = new XmlQualifiedName(name, string.Empty);
            SchemaEntity en = (SchemaEntity)SchemaInfo.GeneralEntities[this.name];
            if (en != null) {
                if (reader.StandAlone && en.DeclaredInExternal) {
                   if (en.IsParEntity) {
                        throw new XmlException(Res.Xml_UndeclaredParEntity, name, positionInfo.LineNumber, positionInfo.LinePosition);
                   }else {
                throw new XmlException(Res.Xml_UndeclaredEntity, name, positionInfo.LineNumber, positionInfo.LinePosition);
           }
                }

                isExternal = en.IsExternal;
                if (!en.IsProcessed) {
                    o = en;
                    if (en.IsExternal) {
                        if (this.xmlResolver == null) {
                            resolvedUrl = null;
                            return null;
                        }
                        if (!fInAttribute) {
                            String baseuri = en.DeclaredURI;
                            Uri baseUriOb = ( baseuri == string.Empty || baseuri == null ) ? null : this.xmlResolver.ResolveUri( null, baseuri );
                            Uri uri = this.xmlResolver.ResolveUri( baseUriOb, en.Url);
                            Stream stm = (Stream)this.xmlResolver.GetEntity( uri, null, null);
                            resolvedUrl = uri.ToString();
                            en.IsProcessed = true;
                            return new XmlScanner(new XmlStreamReader(stm), nameTable);
                        }
                        else {
                            // fatal error, see xml spec 4.4.4
                            throw new XmlException(Res.Xml_ExternalEntityInAttValue, name, positionInfo.LineNumber, positionInfo.LinePosition);
                        }
                    }
                    else {
                        resolvedUrl = (en.DeclaredURI != null) ? en.DeclaredURI : string.Empty;
                        if (en.Text.Length > 0) {
                            en.IsProcessed = true;
                            return new XmlScanner(en.Text.ToCharArray(), nameTable, en.Line, en.Pos + 1);
                        }
                        else {
                            return null;
                        }
                    }
                }
                else {
                    // well-formness constraint - see xml spec [68]
                    code = Res.Xml_RecursiveGenEntity;
                    msg = name;
                    goto error;
                }
            }
            else {
                if (disableUndeclaredEntityCheck) {
                    resolvedUrl = string.Empty;
                    return null;
                }
                // well-formness constraint - see xml spec [68]
                code = Res.Xml_UndeclaredEntity;
                msg = name;
                goto error;
            }

            error:
            if (code != null)
                throw new XmlException(code, msg, positionInfo.LineNumber, positionInfo.LinePosition);

            // should not reach here at all
            resolvedUrl = string.Empty;
            return null;
        }

        static void ProcessEntity(SchemaInfo sinfo, string name, object sender, ValidationEventHandler  eventhandler) {
            SchemaEntity en = (SchemaEntity)sinfo.GeneralEntities[new XmlQualifiedName(name)];
            if (en == null) {
                // validation error, see xml spec [68]
                eventhandler(sender, new ValidationEventArgs(new XmlSchemaException(Res.Sch_UndeclaredEntity, name)));
            }
            else if (en.NData.IsEmpty) {
                // validation error, see xml spec [68]
                eventhandler(sender, new ValidationEventArgs(new XmlSchemaException(Res.Sch_UnparsedEntityRef, name)));
            }
        }

        void ProcessTokenizedType(
            XmlTokenizedType    ttype,
            string              name
        ) {
            switch(ttype) {
            case XmlTokenizedType.ID:
                if (FindID(name) != null) {
                    SendValidationEvent(Res.Sch_DupId, name);
                }
                else {
                    AddID(name, context.Name.Name);
                }
                break;
            case XmlTokenizedType.IDREF:
                object p = FindID(name);
                if (p == null) { // add it to linked list to check it later
                    AddForwardRef(context.Name.Name, context.Prefix, name, (reader as IXmlLineInfo).LineNumber, (reader as IXmlLineInfo).LinePosition, false, ForwardRef.Type.ID);
                }
                break;
            case XmlTokenizedType.ENTITY:
                ProcessEntity(SchemaInfo, name, this, validationEventHandler);
                break;
            default:
                break;
            }
        }

        private void CheckValue(
            string              value,
            SchemaAttDef        attdef
        ) {
#if DEBUG
            Debug.WriteLineIf(CompModSwitches.XmlSchema.TraceVerbose, string.Format("Validator.CheckValue(\"{0}\")", value));
#endif
            try {
                reader.TypedValueObject = null;
                bool isAttn = attdef != null;
                XmlSchemaDatatype dtype = isAttn ? attdef.Datatype : context.ElementDecl.Datatype;
                if (dtype == null) {
                    return; // no reason to check
                }
                if (SchemaInfo.SchemaType != SchemaType.XSD) {
                    if (dtype.TokenizedType != XmlTokenizedType.CDATA) {
                        value = value.Trim();
                    }
                    if (SchemaInfo.SchemaType == SchemaType.XDR && value == string.Empty) {
                        return; // don't need to check
                    }
                }

                object typedValue = dtype.ParseValue(value, nameTable, nsManager);
                reader.TypedValueObject = typedValue;
                // Check special types
                XmlTokenizedType ttype = dtype.TokenizedType;
                if (ttype == XmlTokenizedType.ENTITY || ttype == XmlTokenizedType.ID || ttype == XmlTokenizedType.IDREF) {
                    if (dtype.Variety == XmlSchemaDatatypeVariety.List) {
                        string[] ss = (string[])typedValue;
                        foreach(string s in ss) {
                            ProcessTokenizedType(dtype.TokenizedType, s);
                        }
                    }
                    else {
                        ProcessTokenizedType(dtype.TokenizedType, (string)typedValue);
                    }
                }

                SchemaDeclBase decl = isAttn ? (SchemaDeclBase)attdef : (SchemaDeclBase)context.ElementDecl;

                if (SchemaInfo.SchemaType == SchemaType.XDR && decl.MaxLength != uint.MaxValue) {
                    if(value.Length > decl.MaxLength) {
                        SendValidationEvent(Res.Sch_MaxLengthConstraintFailed, value);
                    }
                }
                if (SchemaInfo.SchemaType == SchemaType.XDR && decl.MinLength != uint.MaxValue) {
                    if(value.Length < decl.MinLength) {
                        SendValidationEvent(Res.Sch_MinLengthConstraintFailed, value);
                    }
                }
                if (decl.Values != null && !decl.CheckEnumeration(typedValue)) {
                    if (dtype.TokenizedType == XmlTokenizedType.NOTATION) {
                        SendValidationEvent(Res.Sch_NotationValue, typedValue.ToString());
                    }
                    else {
                        SendValidationEvent(Res.Sch_EnumerationValue, typedValue.ToString());
                    }

                }
                if (!decl.CheckValue(typedValue)) {
                    if (isAttn) {
                        SendValidationEvent(Res.Sch_FixedAttributeValue, attdef.Name.ToString());
                    }
                    else {
                        SendValidationEvent(Res.Sch_FixedElementValue, context.Name.ToString());
                    }
                }
            }
            catch (XmlSchemaException) {
                if (attdef != null) {
                    SendValidationEvent(Res.Sch_AttributeValueDataType, attdef.Name.ToString());
                }
                else {
                    SendValidationEvent(Res.Sch_ElementValueDataType, context.Name.ToString());
                }
            }
        }

        internal static void CheckDefaultValue(
            string              value,
            SchemaAttDef        attdef,
            SchemaInfo          sinfo,
            XmlNamespaceManager     nsManager,
            XmlNameTable        nameTable,
            object              sender,
            ValidationEventHandler  eventhandler
        ) {
#if DEBUG
            Debug.WriteLineIf(CompModSwitches.XmlSchema.TraceVerbose, string.Format("Validator.CheckDefaultValue(\"{0}\")", value));
#endif
            try {

                XmlSchemaDatatype dtype = attdef.Datatype;
                if (dtype == null) {
                    return; // no reason to check
                }
                if (sinfo.SchemaType != SchemaType.XSD) {
                    if (dtype.TokenizedType != XmlTokenizedType.CDATA) {
                        value = value.Trim();
                    }
                    if (sinfo.SchemaType == SchemaType.XDR && value == string.Empty) {
                        return; // don't need to check
                    }
                }

                object typedValue = dtype.ParseValue(value, nameTable, nsManager);

                // Check special types
                XmlTokenizedType ttype = dtype.TokenizedType;
                if (ttype == XmlTokenizedType.ENTITY) {
                    if (dtype.Variety == XmlSchemaDatatypeVariety.List) {
                        string[] ss = (string[])typedValue;
                        foreach(string s in ss) {
                            ProcessEntity(sinfo, s, sender, eventhandler);
                        }
                    }
                    else {
                        ProcessEntity(sinfo, (string)typedValue, sender, eventhandler);
                    }
                }
                else if (ttype == XmlTokenizedType.ENUMERATION) {
                    if (!attdef.CheckEnumeration(typedValue)) {
                        XmlSchemaException e = new XmlSchemaException(Res.Sch_EnumerationValue, typedValue.ToString());
                        if (eventhandler != null) {
                            eventhandler(sender, new ValidationEventArgs(e));
                        }
                        else {
                            throw e;
                        }
                    }
                }
                attdef.DefaultValueTyped = typedValue;
            }
#if DEBUG
            catch (XmlSchemaException ex) {
                Debug.WriteLineIf(CompModSwitches.XmlSchema.TraceError, ex.Message);
#else
            catch  {
#endif
                XmlSchemaException e = new XmlSchemaException(Res.Sch_AttributeDefaultDataType, attdef.Name.ToString());
                if (eventhandler != null) {
                    eventhandler(sender, new ValidationEventArgs(e));
                }
                else {
                    throw e;
                }
            }
        }

        internal void AddID(string name, object node) {
            // Note: It used to be true that we only called this if _fValidate was true,
            // but due to the fact that you can now dynamically type somethign as an ID
            // that is no longer true.
            if (IDs == null) {
                IDs = new Hashtable();
            }

            IDs.Add(name, node);
        }

        internal object  FindID(string name) {
            return IDs == null ? null : IDs[name];
        }

        private void SendValidationEvent(string code) {
            SendValidationEvent(code, string.Empty);
        }

        private void SendValidationEvent(string code, string[] args) {
            SendValidationEvent(new XmlSchemaException(code, args, reader.BaseURI, positionInfo.LineNumber, positionInfo.LinePosition));
        }

        private void SendValidationEvent(string code, string arg) {
            SendValidationEvent(new XmlSchemaException(code, arg, reader.BaseURI, positionInfo.LineNumber, positionInfo.LinePosition));
        }

        private void SendValidationEvent(XmlSchemaException e) {
            SendValidationEvent(e, XmlSeverityType.Error);
        }

        private void SendValidationEvent(string code, string msg, XmlSeverityType severity) {
            SendValidationEvent(new XmlSchemaException(code, msg, reader.BaseURI, positionInfo.LineNumber, positionInfo.LinePosition), severity);
        }

        private void SendValidationEvent(string code, string[] args, XmlSeverityType severity) {
            SendValidationEvent(new XmlSchemaException(code, args, reader.BaseURI, positionInfo.LineNumber, positionInfo.LinePosition), severity);
        }

        private void SendValidationEvent(XmlSchemaException e, XmlSeverityType severity) {
            if (validationEventHandler != null) {
                validationEventHandler(null, new ValidationEventArgs(e, severity));
            }
            else if (severity == XmlSeverityType.Error) {
                throw e;
            }
        }


        private bool IsGenEntity(XmlQualifiedName qname) {
            string n = qname.Name;
            if (n[0] == '#') { // char entity reference
                return false;
            }
            else if (SchemaEntity.IsPredefinedEntity(n)) {
                return false;
            }
            else {
                SchemaEntity en = GetEntity(qname, false);
                if (en == null) {
                    // well-formness error, see xml spec [68]
                    throw new XmlException(Res.Xml_UndeclaredEntity, n);
                }
                if (!en.NData.IsEmpty) {
                    // well-formness error, see xml spec [68]
                    throw new XmlException(Res.Xml_UnparsedEntityRef, n);
                }

                if (reader.StandAlone && en.DeclaredInExternal && validationEventHandler != null) {
                    SendValidationEvent(Res.Sch_StandAlone);
                }
                return true;
            }
        }


        private SchemaEntity GetEntity(XmlQualifiedName qname, bool fParameterEntity) {
            if (fParameterEntity) {
                return (SchemaEntity)SchemaInfo.ParameterEntities[qname];
            }
            else {
                return (SchemaEntity)SchemaInfo.GeneralEntities[qname];
            }
        }


        private    void Push() {
            context = (ValidationState)validationStack.Push();
            if (context == null) {
                context = new ValidationState();
                validationStack[validationStack.Length-1] = context;
            }
            context.NeedValidateChildren = true;
            context.HasMatched = false;
            context.Constr = null; //resetting the constraints to be null incase context != null 
                                   // when pushing onto stack;
        }


        private    void Pop() {
            validationStack.Pop();
            if (this.startIDConstraint == this.validationStack.Length) {
                this.startIDConstraint = -1;
            }
            if (validationStack.Length > 0) {
                context = (ValidationState)validationStack[validationStack.Length - 1];
                processContents = context.ProcessContents;
            }
            else {
                context = null;
            }
        }


        private void AddForwardRef(string name, string prefix, string id, int line, int col, bool implied, ForwardRef.Type type) {
            forwardRefs = new ForwardRef(forwardRefs, name, prefix, id, line, col, implied, type);
        }


        private void CheckForwardRefs() {
            ForwardRef next = forwardRefs;

            while (next != null) {
                next.Check(null, this, validationEventHandler);
                ForwardRef ptr = next.Next;
                next.Next = null; // unhook each object so it is cleaned up by Garbage Collector
                next = ptr;
            }

            // not needed any more.
            forwardRefs = null;
        }

        private XmlQualifiedName QualifiedName(string prefix, string name, string ns) {
            if (SchemaInfo.SchemaType == SchemaType.DTD) {
                return new XmlQualifiedName(name, prefix);
            }
            if (SchemaInfo.SchemaType != SchemaType.XSD) {
                ns = XmlSchemaDatatype.XdrCanonizeUri(ns, nameTable, schemaNames);
            }
            return new XmlQualifiedName(name, ns);
        }

        // facilitate modifying
        private void IDCCheckAttr(string name, string ns, object obj, string sobj, SchemaAttDef attdef) {
            if (this.startIDConstraint != -1) {
                for (int ci = this.startIDConstraint; ci < this.validationStack.Length; ci ++) {
                    // no constraint for this level
                    if (((ValidationState)(this.validationStack[ci])).Constr == null) {
                        continue;
                    }

                    // else
                    foreach (ConstraintStruct conuct in ((ValidationState)(this.validationStack[ci])).Constr) {
                        // axisFields is not null, but may be empty
                        foreach (LocatedActiveAxis laxis in conuct.axisFields) {
                            // check field from here
                            if (laxis.MoveToAttribute(name, ns)) {
                                Debug.WriteLine("Attribute Field Match!");
                                //attribute is only simpletype, so needn't checking...
                                // can fill value here, yeah!!
                                Debug.WriteLine("Attribute Field Filling Value!");
                                Debug.WriteLine("Name: " + name + "\t|\tURI: " + ns + "\t|\tValue: " + obj + "\n");
                                if (laxis.Ks[laxis.Column] != null) {
                                    // should be evaluated to either an empty node-set or a node-set with exactly one member
                                    // two matches...
                                    SendValidationEvent (Res.Sch_FieldSingleValueExpected, name);
                                }
                                else if ((attdef != null) && (attdef.Datatype != null)){
                                    laxis.Ks[laxis.Column] = new TypedObject (obj, sobj, attdef.Datatype);
                                }
                            }
                        }
                    }
                }
            }
            return;
        }

    };

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\schema\xmlschemachoice.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlSchemaChoice.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Schema {

    using System.Collections;
    using System.ComponentModel;
    using System.Xml.Serialization;

    /// <include file='doc\XmlSchemaChoice.uex' path='docs/doc[@for="XmlSchemaChoice"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public class XmlSchemaChoice : XmlSchemaGroupBase {
        XmlSchemaObjectCollection items = new XmlSchemaObjectCollection();

        /// <include file='doc\XmlSchemaChoice.uex' path='docs/doc[@for="XmlSchemaChoice.Items"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlElement("element", typeof(XmlSchemaElement)),
         XmlElement("group", typeof(XmlSchemaGroupRef)),
         XmlElement("choice", typeof(XmlSchemaChoice)),
         XmlElement("sequence", typeof(XmlSchemaSequence)),
         XmlElement("any", typeof(XmlSchemaAny))]
        public override XmlSchemaObjectCollection Items {
            get { return items; }
        }

        internal override bool IsEmpty {
            get { return  base.IsEmpty /*|| items.Count == 0*/; }
        } 

        internal XmlSchemaChoice Clone() {
            return (XmlSchemaChoice)MemberwiseClone();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\schema\xmlschemacomplexcontentextension.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlSchemaComplexContentExtension.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Schema {

    using System.Collections;
    using System.ComponentModel;
    using System.Xml.Serialization;

    /// <include file='doc\XmlSchemaComplexContentExtension.uex' path='docs/doc[@for="XmlSchemaComplexContentExtension"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public class XmlSchemaComplexContentExtension : XmlSchemaContent {
        XmlSchemaParticle particle;
        XmlSchemaObjectCollection attributes = new XmlSchemaObjectCollection();
        XmlSchemaAnyAttribute anyAttribute;
        XmlQualifiedName baseTypeName = XmlQualifiedName.Empty; 

        /// <include file='doc\XmlSchemaComplexContentExtension.uex' path='docs/doc[@for="XmlSchemaComplexContentExtension.BaseTypeName"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlAttribute("base")]
        public XmlQualifiedName BaseTypeName { 
            get { return baseTypeName; }
            set { baseTypeName = (value == null ? XmlQualifiedName.Empty : value); }
        }

        /// <include file='doc\XmlSchemaComplexContentExtension.uex' path='docs/doc[@for="XmlSchemaComplexContentExtension.Particle"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlElement("group", typeof(XmlSchemaGroupRef)),
         XmlElement("choice", typeof(XmlSchemaChoice)),
         XmlElement("all", typeof(XmlSchemaAll)),
         XmlElement("sequence", typeof(XmlSchemaSequence))]
        public XmlSchemaParticle Particle {
            get { return particle; }
            set { particle = value; }
        }

        /// <include file='doc\XmlSchemaComplexContentExtension.uex' path='docs/doc[@for="XmlSchemaComplexContentExtension.Attributes"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlElement("attribute", typeof(XmlSchemaAttribute)),
         XmlElement("attributeGroup", typeof(XmlSchemaAttributeGroupRef))]
        public XmlSchemaObjectCollection Attributes {
            get { return attributes; }
        }


        /// <include file='doc\XmlSchemaComplexContentExtension.uex' path='docs/doc[@for="XmlSchemaComplexContentExtension.AnyAttribute"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlElement("anyAttribute")]
        public XmlSchemaAnyAttribute AnyAttribute {
            get { return anyAttribute; }
            set { anyAttribute = value; }
        }

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\schema\xmlschemacomplexcontent.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlSchemaComplexContent.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Schema {

    using System.ComponentModel;
    using System.Xml.Serialization;

    /// <include file='doc\XmlSchemaComplexContent.uex' path='docs/doc[@for="XmlSchemaComplexContent"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public class XmlSchemaComplexContent : XmlSchemaContentModel {
        XmlSchemaContent content;
        bool isMixed;
        bool hasMixedAttribute;

        /// <include file='doc\XmlSchemaComplexContent.uex' path='docs/doc[@for="XmlSchemaComplexContent.IsMixed"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlAttribute("mixed")]
        public bool IsMixed {
            get { return isMixed; }
            set { isMixed = value; hasMixedAttribute = true; }
        }

        /// <include file='doc\XmlSchemaComplexContent.uex' path='docs/doc[@for="XmlSchemaComplexContent.Content"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlElement("restriction", typeof(XmlSchemaComplexContentRestriction)),
         XmlElement("extension", typeof(XmlSchemaComplexContentExtension))]
        public override XmlSchemaContent Content { 
            get { return content; }
            set { content = value; }
        }

        [XmlIgnore]
        internal bool HasMixedAttribute {
            get { return hasMixedAttribute; }
        }

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\schema\xmlschemacomplexcontentrestriction.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlSchemaComplexContentRestriction.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Schema {

    using System.Collections;
    using System.ComponentModel;
    using System.Xml.Serialization;

    /// <include file='doc\XmlSchemaComplexContentRestriction.uex' path='docs/doc[@for="XmlSchemaComplexContentRestriction"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public class XmlSchemaComplexContentRestriction : XmlSchemaContent {
        XmlSchemaParticle particle;
        XmlSchemaObjectCollection attributes = new XmlSchemaObjectCollection();
        XmlSchemaAnyAttribute anyAttribute;
        XmlQualifiedName baseTypeName = XmlQualifiedName.Empty; 

        /// <include file='doc\XmlSchemaComplexContentRestriction.uex' path='docs/doc[@for="XmlSchemaComplexContentRestriction.BaseTypeName"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlAttribute("base")]
        public XmlQualifiedName BaseTypeName { 
            get { return baseTypeName; }
            set { baseTypeName = (value == null ? XmlQualifiedName.Empty : value); }
        }

        /// <include file='doc\XmlSchemaComplexContentRestriction.uex' path='docs/doc[@for="XmlSchemaComplexContentRestriction.Particle"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlElement("group", typeof(XmlSchemaGroupRef)),
         XmlElement("choice", typeof(XmlSchemaChoice)),
         XmlElement("all", typeof(XmlSchemaAll)),
         XmlElement("sequence", typeof(XmlSchemaSequence))]
        public XmlSchemaParticle Particle {
            get { return particle; }
            set { particle = value; }
        }

        /// <include file='doc\XmlSchemaComplexContentRestriction.uex' path='docs/doc[@for="XmlSchemaComplexContentRestriction.Attributes"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlElement("attribute", typeof(XmlSchemaAttribute)),
         XmlElement("attributeGroup", typeof(XmlSchemaAttributeGroupRef))]
        public XmlSchemaObjectCollection Attributes {
            get { return attributes; }
        }

        /// <include file='doc\XmlSchemaComplexContentRestriction.uex' path='docs/doc[@for="XmlSchemaComplexContentRestriction.AnyAttribute"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlElement("anyAttribute")]
        public XmlSchemaAnyAttribute AnyAttribute {
            get { return anyAttribute; }
            set { anyAttribute = value; }
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\schema\xmlschemacontent.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlSchemaContent.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Schema {

    using System.Collections;
    using System.ComponentModel;
    using System.Xml.Serialization;

    /// <include file='doc\XmlSchemaContent.uex' path='docs/doc[@for="XmlSchemaContent"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public abstract class XmlSchemaContent : XmlSchemaAnnotated {
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\schema\xmlschemacontentmodel.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlSchemaContentModel.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Schema {

    using System.ComponentModel;
    using System.Xml.Serialization;

    /// <include file='doc\XmlSchemaContentModel.uex' path='docs/doc[@for="XmlSchemaContentModel"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public abstract class XmlSchemaContentModel : XmlSchemaAnnotated {
        /// <include file='doc\XmlSchemaContentModel.uex' path='docs/doc[@for="XmlSchemaContentModel.Content"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlIgnore]
        public abstract XmlSchemaContent Content { get; set; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\schema\xmlschemacomplextype.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlSchemaComplexType.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Schema {

    using System.Collections;
    using System.ComponentModel;
    using System.Xml.Serialization;

    /// <include file='doc\XmlSchemaComplexType.uex' path='docs/doc[@for="XmlSchemaComplexType"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public class XmlSchemaComplexType : XmlSchemaType {
        bool isAbstract;
        XmlSchemaDerivationMethod block = XmlSchemaDerivationMethod.None;
        bool isMixed;
        XmlSchemaContentModel contentModel;
        XmlSchemaParticle particle;
        XmlSchemaObjectCollection attributes = new XmlSchemaObjectCollection();
        XmlSchemaAnyAttribute anyAttribute;

        //compiled information
        XmlSchemaContentType contentType;
        XmlSchemaParticle contentTypeParticle = XmlSchemaParticle.Empty;
        XmlSchemaDerivationMethod blockResolved;
        XmlSchemaObjectTable localElements = new XmlSchemaObjectTable();
        XmlSchemaObjectTable attributeUses = new XmlSchemaObjectTable();
        XmlSchemaAnyAttribute attributeWildcard;

        Hashtable localElementDecls = new Hashtable();

        static XmlSchemaComplexType anyType;

        static XmlSchemaComplexType() {
            anyType = new XmlSchemaComplexType();
            anyType.SetContentType(XmlSchemaContentType.Mixed);
            anyType.ElementDecl = SchemaElementDecl.CreateAnyTypeElementDecl();
            XmlSchemaAnyAttribute anyAttribute = new XmlSchemaAnyAttribute();
            anyAttribute.BuildNamespaceList(null);
            anyType.SetAttributeWildcard(anyAttribute);
            anyType.ElementDecl.AnyAttribute = anyAttribute;
        }

        /// <include file='doc\XmlSchemaComplexType.uex' path='docs/doc[@for="XmlSchemaComplexType.XmlSchemaComplexType"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public XmlSchemaComplexType() {
        }


        [XmlIgnore]
        internal static XmlSchemaComplexType AnyType {
             get { return anyType; }
        }

        /// <include file='doc\XmlSchemaComplexType.uex' path='docs/doc[@for="XmlSchemaComplexType.IsAbstract"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlAttribute("abstract"), DefaultValue(false)]
        public bool IsAbstract {
            get { return isAbstract; }
            set { isAbstract = value; }
        }

        /// <include file='doc\XmlSchemaComplexType.uex' path='docs/doc[@for="XmlSchemaComplexType.Block"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlAttribute("block"), DefaultValue(XmlSchemaDerivationMethod.None)]
        public XmlSchemaDerivationMethod Block {
            get { return block; }
            set { block = value; }
        }

        /// <include file='doc\XmlSchemaComplexType.uex' path='docs/doc[@for="XmlSchemaComplexType.IsMixed"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlAttribute("mixed"), DefaultValue(false)]
        public override bool IsMixed {
            get { return isMixed; }
            set { isMixed = value; }
        }


        /// <include file='doc\XmlSchemaComplexType.uex' path='docs/doc[@for="XmlSchemaComplexType.ContentModel"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlElement("simpleContent", typeof(XmlSchemaSimpleContent)),
         XmlElement("complexContent", typeof(XmlSchemaComplexContent))]
        public XmlSchemaContentModel ContentModel {
            get { return contentModel; }
            set { contentModel = value; }
        }

        /// <include file='doc\XmlSchemaComplexType.uex' path='docs/doc[@for="XmlSchemaComplexType.Particle"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlElement("group", typeof(XmlSchemaGroupRef)),
         XmlElement("choice", typeof(XmlSchemaChoice)),
         XmlElement("all", typeof(XmlSchemaAll)),
         XmlElement("sequence", typeof(XmlSchemaSequence))]
        public XmlSchemaParticle Particle {
            get { return particle; }
            set { particle = value; }
        }

        /// <include file='doc\XmlSchemaComplexType.uex' path='docs/doc[@for="XmlSchemaComplexType.Attributes"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlElement("attribute", typeof(XmlSchemaAttribute)),
         XmlElement("attributeGroup", typeof(XmlSchemaAttributeGroupRef))]
        public XmlSchemaObjectCollection Attributes {
            get { return attributes; }
        }

        /// <include file='doc\XmlSchemaComplexType.uex' path='docs/doc[@for="XmlSchemaComplexType.AnyAttribute"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlElement("anyAttribute")]
        public XmlSchemaAnyAttribute AnyAttribute {
            get { return anyAttribute; }
            set { anyAttribute = value; }
        }


        /// <include file='doc\XmlSchemaComplexType.uex' path='docs/doc[@for="XmlSchemaComplexType.ContentType"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlIgnore]
        public XmlSchemaContentType ContentType {
            get { return contentType; }
        }

        /// <include file='doc\XmlSchemaComplexType.uex' path='docs/doc[@for="XmlSchemaComplexType.ContentTypeParticle"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlIgnore]
        public XmlSchemaParticle ContentTypeParticle {
            get { return contentTypeParticle; }
        }

        /// <include file='doc\XmlSchemaComplexType.uex' path='docs/doc[@for="XmlSchemaComplexType.BlockResolved"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlIgnore]
        public XmlSchemaDerivationMethod BlockResolved {
             get { return blockResolved; }
        }

        /// <include file='doc\XmlSchemaComplexType.uex' path='docs/doc[@for="XmlSchemaComplexType.AttributeUses"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlIgnore]
        public XmlSchemaObjectTable AttributeUses {
            get { return attributeUses; }
        }

        /// <include file='doc\XmlSchemaComplexType.uex' path='docs/doc[@for="XmlSchemaComplexType.AttributeWildcard"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlIgnore]
        public XmlSchemaAnyAttribute AttributeWildcard {
            get { return attributeWildcard; }
        }

        internal void SetContentType(XmlSchemaContentType value) { 
            contentType = value; 
        }

        internal void SetContentTypeParticle(XmlSchemaParticle value) { 
            contentTypeParticle = value; 
        }

        internal void SetBlockResolved(XmlSchemaDerivationMethod value) {
             blockResolved = value; 
        }

        internal void SetAttributeWildcard(XmlSchemaAnyAttribute value) {
             attributeWildcard = value; 
        }

        [XmlIgnore]
        internal XmlSchemaObjectTable LocalElements {
            get { return localElements; }
        }

        [XmlIgnore]
        internal Hashtable LocalElementDecls {
            get { return localElementDecls; }
        }

        internal override XmlQualifiedName DerivedFrom {
            get {
                if (contentModel == null) {
                    // type derived from anyType
                    return XmlQualifiedName.Empty;
                }
                if (contentModel.Content is XmlSchemaComplexContentRestriction)
                    return ((XmlSchemaComplexContentRestriction)contentModel.Content).BaseTypeName;
                else if (contentModel.Content is XmlSchemaComplexContentExtension)
                    return ((XmlSchemaComplexContentExtension)contentModel.Content).BaseTypeName;
                else if (contentModel.Content is XmlSchemaSimpleContentRestriction)
                    return ((XmlSchemaSimpleContentRestriction)contentModel.Content).BaseTypeName;
                else if (contentModel.Content is XmlSchemaSimpleContentExtension)
                    return ((XmlSchemaSimpleContentExtension)contentModel.Content).BaseTypeName;
                else
                    return XmlQualifiedName.Empty;
            }
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\schema\xmlschemacollection.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlSchemaCollection.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * @(#)XmlSchemaCollection.cs 1.0 6/27/2000
 * 
 * Defines the XmlSchemaCollection class
 *
 * Copyright (c) 2000 Microsoft, Corp. All Rights Reserved.
 * 
 */


namespace System.Xml.Schema {

    using System;
    using System.Threading;
    using System.Collections;
    using System.Xml.Schema;


    /// <include file='doc\XmlSchemaCollection.uex' path='docs/doc[@for="XmlSchemaCollection"]/*' />
    /// <devdoc>
    ///    <para>The XmlSchemaCollection contains a set of namespace URI's.
    ///       Each namespace also have an associated private data cache
    ///       corresponding to the XML-Data Schema or W3C XML Schema.
    ///       The XmlSchemaCollection will able to load XSD and XDR schemas,
    ///       and compile them into an internal "cooked schema representation".
    ///       The Validate method then uses this internal representation for
    ///       efficient runtime validation of any given subtree.</para>
    /// </devdoc>
    public sealed class XmlSchemaCollection: ICollection {
        private Hashtable               collection;
        private XmlNameTable            nameTable;
        private SchemaNames             schemaNames;
        private ReaderWriterLock        wLock;
        private int                     timeout = Timeout.Infinite;
        private bool                    isThreadSafe = true;
        private ValidationEventHandler  validationEventHandler = null;
        private XmlResolver             xmlResolver = null;


        /// <include file='doc\XmlSchemaCollection.uex' path='docs/doc[@for="XmlSchemaCollection.XmlSchemaCollection"]/*' />
        /// <devdoc>
        ///    <para>Construct a new empty schema collection.</para>
        /// </devdoc>
        public XmlSchemaCollection() : this(new NameTable()) {
        }
 
        /// <include file='doc\XmlSchemaCollection.uex' path='docs/doc[@for="XmlSchemaCollection.XmlSchemaCollection1"]/*' />
        /// <devdoc>
        ///    <para>Construct a new empty schema collection with associated XmlNameTable.
        ///       The XmlNameTable is used when loading schemas</para>
        /// </devdoc>
        public XmlSchemaCollection(XmlNameTable nametable) {
            if (nametable == null) {
                throw new ArgumentNullException("nametable");
            }
            nameTable = nametable;
            collection = Hashtable.Synchronized(new Hashtable());
            schemaNames = new SchemaNames(nametable);
            xmlResolver = new XmlUrlResolver();
            isThreadSafe = true;
            if (isThreadSafe) {
                wLock = new ReaderWriterLock();
            }
        }

        /// <include file='doc\XmlSchemaCollection.uex' path='docs/doc[@for="XmlSchemaCollection.Count"]/*' />
        /// <devdoc>
        ///    <para>Returns the number of namespaces defined in this collection
        ///       (whether or not there is an actual schema associated with those namespaces or not).</para>
        /// </devdoc>
        public int Count {
            get { return collection.Count;}
        }
 
        /// <include file='doc\XmlSchemaCollection.uex' path='docs/doc[@for="XmlSchemaCollection.NameTable"]/*' />
        /// <devdoc>
        ///    <para>The default XmlNameTable used by the XmlSchemaCollection when loading new schemas.</para>
        /// </devdoc>
        public XmlNameTable NameTable {
            get { return nameTable;}
        }

        /// <include file='doc\XmlSchemaCollection.uex' path='docs/doc[@for="XmlSchemaCollection.ValidationEventHandler"]/*' />
        public  event ValidationEventHandler ValidationEventHandler {
            add { validationEventHandler += value; }
            remove { validationEventHandler -= value; }
        }

        internal XmlResolver XmlResolver
        {
            set {
                xmlResolver = value;
            }
        }


        /// <include file='doc\XmlSchemaCollection.uex' path='docs/doc[@for="XmlSchemaCollection.Add"]/*' />
        /// <devdoc>
        ///    <para>Add the schema located by the given URL into the schema collection.
        ///       If the given schema references other namespaces, the schemas for those other
        ///       namespaces are NOT automatically loaded.</para>
        /// </devdoc>
        public XmlSchema Add(string ns, string uri) {
            if (uri == null || uri == String.Empty)
                throw new ArgumentNullException("uri");
            XmlTextReader reader = new XmlTextReader(uri, nameTable);
            reader.XmlResolver = xmlResolver;

            XmlSchema schema = null;
            try {
                schema = Add(ns, reader, xmlResolver);
                while(reader.Read());// wellformness check
            }
            finally {
                reader.Close();
            }
            return schema;
        }

	/// <include file='doc\XmlSchemaCollection.uex' path='docs/doc[@for="XmlSchemaCollection.Add4"]/*' />
        public XmlSchema Add(String ns, XmlReader reader) {
	    return Add(ns, reader, xmlResolver);	
	}

        /// <include file='doc\XmlSchemaCollection.uex' path='docs/doc[@for="XmlSchemaCollection.Add1"]/*' />
        /// <devdoc>
        ///    <para>Add the given schema into the schema collection.
        ///       If the given schema references other namespaces, the schemas for those
        ///       other namespaces are NOT automatically loaded.</para>
        /// </devdoc>
        public XmlSchema Add(String ns, XmlReader reader, XmlResolver resolver) {
            if (reader == null)
                throw new ArgumentNullException("reader");
            XmlNameTable tmpNameTable = reader.NameTable;
            SchemaNames tmpSchemaNames = nameTable == tmpNameTable ? schemaNames : new SchemaNames(tmpNameTable);
            SchemaInfo schemaInfo = new SchemaInfo(tmpSchemaNames); 
	    Parser parser = new Parser(this, reader.NameTable, tmpSchemaNames, validationEventHandler);
	    parser.XmlResolver = resolver;
            return Add(ns, schemaInfo, parser.Parse(reader, ns, schemaInfo), true, resolver);
        }

        /// <include file='doc\XmlSchemaCollection.uex' path='docs/doc[@for="XmlSchemaCollection.Add2"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public XmlSchema Add(XmlSchema schema) {
	    return Add(schema, xmlResolver);
        }

        /// <include file='doc\XmlSchemaCollection.uex' path='docs/doc[@for="XmlSchemaCollection.Add5"]/*' />
	    public XmlSchema Add(XmlSchema schema, XmlResolver resolver) {
            if (schema == null)
                throw new ArgumentNullException("schema");

            SchemaInfo schemaInfo = new SchemaInfo(schemaNames); 
            schemaInfo.SchemaType = SchemaType.XSD;
            return Add(schema.TargetNamespace, schemaInfo, schema, true, resolver);
        }

        /// <include file='doc\XmlSchemaCollection.uex' path='docs/doc[@for="XmlSchemaCollection.Add3"]/*' />
        /// <devdoc>
        ///    <para>Adds all the namespaces defined in the given collection
        ///       (including their associated schemas) to this collection.</para>
        /// </devdoc>
        public void Add(XmlSchemaCollection schema) {
            if (schema == null)
                throw new ArgumentNullException("schema");
            if (this == schema)
                return;
            IDictionaryEnumerator iterator = schema.collection.GetEnumerator();
            while (iterator.MoveNext()) {
                XmlSchemaCollectionNode node = (XmlSchemaCollectionNode) iterator.Value;
                Add(node.NamespaceURI, node);
            }
        }


        /// <include file='doc\XmlSchemaCollection.uex' path='docs/doc[@for="XmlSchemaCollection.this"]/*' />
        /// <devdoc>
        ///    <para>Looks up the schema by it's associated namespace URI</para>
        /// </devdoc>
        public XmlSchema this[string ns] {
            get {
                XmlSchemaCollectionNode node = (XmlSchemaCollectionNode)collection[(ns != null) ? ns: string.Empty];
                return (node != null) ? node.Schema : null;
            }
        }

        /// <include file='doc\XmlSchemaCollection.uex' path='docs/doc[@for="XmlSchemaCollection.Contains"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public bool Contains(XmlSchema schema) {
            if (schema == null) {
                throw new ArgumentNullException("schema");
            }
            return this[schema.TargetNamespace] != null;
        }

        /// <include file='doc\XmlSchemaCollection.uex' path='docs/doc[@for="XmlSchemaCollection.Contains1"]/*' />
        public bool Contains(string ns) {
            return collection[(ns != null) ? ns : string.Empty] != null;
        }

/*
        [Obsolete("This Method is going away")]
        public void Remove(XmlSchema schema) {
            if (schema == null) {
                throw new ArgumentNullException("schema");
            }
            Remove(schema.TargetNamespace);
        }

        [Obsolete("This Method is going away")]
        public void Remove(string ns) {
            if (ns == null) ns = string.Empty;
            if (collection[ns] != null)
                collection.Remove(ns);
            else 
                throw new XmlSchemaException(Res.Sch_NotInSchemaCollection, ns);
        }
*/

        /// <include file='doc\XmlSchemaCollection.uex' path='docs/doc[@for="XmlSchemaCollection.IEnumerable.GetEnumerator"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// Get a IEnumerator of the XmlSchemaCollection.
        /// </devdoc>
        IEnumerator IEnumerable.GetEnumerator() {
            return new XmlSchemaCollectionEnumerator(collection);
        }

        /// <include file='doc\XmlSchemaCollection.uex' path='docs/doc[@for="XmlSchemaCollection.GetEnumerator"]/*' />
        public XmlSchemaCollectionEnumerator GetEnumerator() {
            return new XmlSchemaCollectionEnumerator(collection);
        }

        /// <include file='doc\XmlSchemaCollection.uex' path='docs/doc[@for="XmlSchemaCollection.ICollection.CopyTo"]/*' />
        /// <internalonly/>
        void ICollection.CopyTo(Array array, int index) {
            if (array == null)
                throw new ArgumentNullException("array");
            if (index < 0)
                throw new ArgumentOutOfRangeException("index");
            for (XmlSchemaCollectionEnumerator e = this.GetEnumerator(); e.MoveNext();) {
                if (index == array.Length && array.IsFixedSize) {
                    throw new ArgumentOutOfRangeException("index");
                }
                array.SetValue(e.Current, index++);
            }
        }

        /// <include file='doc\XmlSchemaCollection.uex' path='docs/doc[@for="XmlSchemaCollection.CopyTo"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void CopyTo(XmlSchema[] array, int index) {
            if (array == null)
                throw new ArgumentNullException("array");
            if (index < 0)
                throw new ArgumentOutOfRangeException("index");
            for (XmlSchemaCollectionEnumerator e = this.GetEnumerator(); e.MoveNext();) {
                XmlSchema schema = e.Current;
                if (schema != null) {
                    if (index == array.Length) {
                        throw new ArgumentOutOfRangeException("index");
                    }
                    array[index++] = e.Current;
                }
            }
        }

        /// <include file='doc\XmlSchemaCollection.uex' path='docs/doc[@for="XmlSchemaCollection.ICollection.IsSynchronized"]/*' />
        /// <internalonly/>
        bool ICollection.IsSynchronized {
            get { return true; }
        }

        /// <include file='doc\XmlSchemaCollection.uex' path='docs/doc[@for="XmlSchemaCollection.ICollection.SyncRoot"]/*' />
        /// <internalonly/>
        object ICollection.SyncRoot {
            get { return this; }
        }

        /// <include file='doc\XmlSchemaCollection.uex' path='docs/doc[@for="XmlSchemaCollection.ICollection.Count"]/*' />
        /// <internalonly/>
        int ICollection.Count {
            get { return collection.Count; }
        }

        internal SchemaInfo GetSchemaInfo(string ns) {
            XmlSchemaCollectionNode node = (XmlSchemaCollectionNode)collection[(ns != null) ? ns : string.Empty];
            return (node != null) ? node.SchemaInfo : null;
        }


        internal XmlSchema Add(string ns, SchemaInfo schemaInfo, XmlSchema schema, bool compile) {
		return Add(ns, schemaInfo, schema, compile, xmlResolver);
	}

        private XmlSchema Add(string ns, SchemaInfo schemaInfo, XmlSchema schema, bool compile, XmlResolver resolver) {
            int errorCount = 0;
            if (schema != null) {
                if (schema.ErrorCount == 0 && compile) {
                    schema.Compile(this, nameTable, schemaNames, validationEventHandler, ns, schemaInfo, true, resolver);
                    ns = schema.TargetNamespace == null ? string.Empty : schema.TargetNamespace;
                }
                errorCount += schema.ErrorCount;
            } 
            else {
                errorCount += schemaInfo.ErrorCount;
                ns = NameTable.Add(ns);
            }
            if (errorCount == 0) {
                XmlSchemaCollectionNode node = new XmlSchemaCollectionNode();
                node.NamespaceURI = ns;
                node.SchemaInfo = schemaInfo; 
                node.Schema = schema; 
                Add(ns, node);
                return schema;
            }
            return null;
        }

        private void Add(string ns, XmlSchemaCollectionNode node) {
            if (isThreadSafe)
                wLock.AcquireWriterLock(timeout);           
            try {
                if (collection[ns] != null)
                    collection.Remove(ns);
                collection.Add(ns, node);    
            }
            finally {
                if (isThreadSafe)
                    wLock.ReleaseWriterLock();                      
            }
        }
    };


    internal sealed class XmlSchemaCollectionNode {
        private String      namespaceUri;
        private SchemaInfo  schemaInfo;
        private XmlSchema   schema;

        internal String NamespaceURI {
            get { return namespaceUri;}
            set { namespaceUri = value;}
        }

        internal SchemaInfo SchemaInfo {       
            get { return schemaInfo;}
            set { schemaInfo = value;}
        }

        internal XmlSchema Schema {
            get { return schema;}
            set { schema = value;}
        }   
}


    /// <include file='doc\XmlSchemaCollection.uex' path='docs/doc[@for="XmlSchemaCollectionEnumerator"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public sealed class XmlSchemaCollectionEnumerator: IEnumerator {
        private IDictionaryEnumerator     enumerator;

        internal XmlSchemaCollectionEnumerator( Hashtable collection ) {
            enumerator = collection.GetEnumerator();            
        }

        /// <include file='doc\XmlSchemaCollection.uex' path='docs/doc[@for="XmlSchemaCollectionEnumerator.IEnumerator.Reset"]/*' />
        /// <internalonly/>
        void IEnumerator.Reset() {
            enumerator.Reset();
        }

        /// <include file='doc\XmlSchemaCollection.uex' path='docs/doc[@for="XmlSchemaCollectionEnumerator.IEnumerator.MoveNext"]/*' />
        /// <internalonly/>
        bool IEnumerator.MoveNext() {
            return enumerator.MoveNext();
        }

        /// <include file='doc\XmlSchemaCollection.uex' path='docs/doc[@for="XmlSchemaCollectionEnumerator.MoveNext"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public bool MoveNext() {
            return enumerator.MoveNext();
        }

        /// <include file='doc\XmlSchemaCollection.uex' path='docs/doc[@for="XmlSchemaCollectionEnumerator.IEnumerator.Current"]/*' />
        /// <internalonly/>
        object IEnumerator.Current {
            get { return this.Current; }
        }

        /// <include file='doc\XmlSchemaCollection.uex' path='docs/doc[@for="XmlSchemaCollectionEnumerator.Current"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public XmlSchema Current {
            get {
                XmlSchemaCollectionNode n = (XmlSchemaCollectionNode)enumerator.Value;
                if (n != null)
                    return n.Schema;
                else
                    return null;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\schema\xmlschemacontentprocessing.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlSchemaContentProcessing.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Schema {

    using System.Collections;
    using System.ComponentModel;
    using System.Xml.Serialization;

    /// <include file='doc\XmlSchemaContentProcessing.uex' path='docs/doc[@for="XmlSchemaContentProcessing"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public enum XmlSchemaContentProcessing {
        /// <include file='doc\XmlSchemaContentProcessing.uex' path='docs/doc[@for="XmlSchemaContentProcessing.None"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlIgnore]
        None,
        /// <include file='doc\XmlSchemaContentProcessing.uex' path='docs/doc[@for="XmlSchemaContentProcessing.XmlEnum"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlEnum("skip")]
        Skip,
        /// <include file='doc\XmlSchemaContentProcessing.uex' path='docs/doc[@for="XmlSchemaContentProcessing.XmlEnum1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlEnum("lax")]
        Lax,
        /// <include file='doc\XmlSchemaContentProcessing.uex' path='docs/doc[@for="XmlSchemaContentProcessing.XmlEnum2"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlEnum("strict")]
        Strict
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\schema\xmlschemadatatype.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlSchemaDatatype.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

 
namespace System.Xml.Schema {

    using System;
    using System.Collections;
    using System.Diagnostics;
    using System.ComponentModel;
    using System.Xml;
    using System.Globalization;

    /// <include file='doc\XmlSchemaDatatype.uex' path='docs/doc[@for="XmlSchemaDatatype"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public abstract class XmlSchemaDatatype {
        /// <include file='doc\XmlSchemaDatatype.uex' path='docs/doc[@for="XmlSchemaDatatype.ValueType"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public abstract Type ValueType { get; }
        /// <include file='doc\XmlSchemaDatatype.uex' path='docs/doc[@for="XmlSchemaDatatype.TokenizedType"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public abstract  XmlTokenizedType TokenizedType { get; }
        /// <include file='doc\XmlSchemaDatatype.uex' path='docs/doc[@for="XmlSchemaDatatype.ParseValue"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public abstract object ParseValue(string s, XmlNameTable nameTable, XmlNamespaceManager nsmgr);

        internal static XmlSchemaDatatype AnyType { get { return DatatypeImplementation.AnyType; } }

        internal static XmlSchemaDatatype AnySimpleType { get { return DatatypeImplementation.AnySimpleType; } }

        internal static XmlSchemaDatatype FromXmlTokenizedType(XmlTokenizedType token) {
            return DatatypeImplementation.FromXmlTokenizedType(token);
        }

        internal static XmlSchemaDatatype FromXmlTokenizedTypeXsd(XmlTokenizedType token) {
            return DatatypeImplementation.FromXmlTokenizedTypeXsd(token);
        }

        internal static XmlSchemaDatatype FromTypeName(string name) {
            return DatatypeImplementation.FromTypeName(name);
        }

        internal static XmlSchemaDatatype FromXdrName(string name) {
            return DatatypeImplementation.FromXdrName(name);
        }

        internal XmlSchemaDatatype DeriveByRestriction(XmlSchemaObjectCollection facets, XmlNameTable nameTable) {
            return ((DatatypeImplementation)this).DeriveByRestriction(facets, nameTable);
        }

        internal static XmlSchemaDatatype DeriveByUnion(XmlSchemaDatatype[] types) {
            return DatatypeImplementation.DeriveByUnion(types);
        }

        internal XmlSchemaDatatype DeriveByList() { 
            return ((DatatypeImplementation)this).DeriveByList();
        }
        
        internal void VerifySchemaValid(XmlSchema schema, XmlSchemaObject caller) { 
            ((DatatypeImplementation)this).VerifySchemaValid(schema, caller);
        }

        internal bool IsDerivedFrom(XmlSchemaDatatype dtype) {
            return ((DatatypeImplementation)this).IsDerivedFrom(dtype);
        }

        internal bool IsEqual(object o1, object o2) {
            return ((DatatypeImplementation)this).IsEqual(o1, o2);
        }


        internal XmlSchemaDatatypeVariety Variety { get { return ((DatatypeImplementation)this).Variety;}}

        internal static string XdrCanonizeUri(string uri, XmlNameTable nameTable, SchemaNames schemaNames) {
            string canonicalUri;
            int offset = 5;
            bool convert = false;

            if (uri.Length > 5 && uri.StartsWith("uuid:")) {
                convert = true;
            }
            else if (uri.Length > 9 && uri.StartsWith("urn:uuid:")) {
                convert = true;
                offset = 9;
            }

            if (convert) {
                canonicalUri = nameTable.Add(uri.Substring(0, offset) + uri.Substring(offset, uri.Length - offset).ToUpper(CultureInfo.InvariantCulture));
            }
            else {
                canonicalUri = uri;
            }

            if (
                Ref.Equal(schemaNames.NsDataTypeAlias, canonicalUri) ||
                Ref.Equal(schemaNames.NsDataTypeOld  , canonicalUri)
            ) {
                canonicalUri = schemaNames.NsDataType;
            }
            else if (Ref.Equal(schemaNames.NsXdrAlias, canonicalUri)) {
                canonicalUri = schemaNames.NsXdr;
            }

            return canonicalUri;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\schema\xmlschemadocumentation.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlSchemaDocumentation.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Schema {

    using System.Collections;
    using System.ComponentModel;
    using System.Xml.Serialization;

    /// <include file='doc\XmlSchemaDocumentation.uex' path='docs/doc[@for="XmlSchemaDocumentation"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public class XmlSchemaDocumentation : XmlSchemaObject {    
        string source;
        string language;
        XmlNode[] markup;
        static XmlSchemaDatatype languageDatatype = XmlSchemaDatatype.FromTypeName("language");

        /// <include file='doc\XmlSchemaDocumentation.uex' path='docs/doc[@for="XmlSchemaDocumentation.Source"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlAttribute("source", DataType="anyURI")]
        public string Source {
            get { return source; }
            set { source = value; }
        }

        /// <include file='doc\XmlSchemaDocumentation.uex' path='docs/doc[@for="XmlSchemaDocumentation.Language"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlAttribute("xml:lang")]
        public string Language {
            get { return language; }
            set { language = (string)languageDatatype.ParseValue(value, null, null); }
        }

        /// <include file='doc\XmlSchemaDocumentation.uex' path='docs/doc[@for="XmlSchemaDocumentation.Markup"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlText(), XmlAnyElement]
        public XmlNode[] Markup {
            get { return markup; }
            set { markup = value; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\schema\xmlschemaderivationmethod.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlSchemaDerivationMethod.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Schema {

    using System.Collections;
    using System.ComponentModel;
    using System.Xml.Serialization;

    /// <include file='doc\XmlSchemaDerivationMethod.uex' path='docs/doc[@for="XmlSchemaDerivationMethod"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [Flags]
    public enum XmlSchemaDerivationMethod {
        /// <include file='doc\XmlSchemaDerivationMethod.uex' path='docs/doc[@for="XmlSchemaDerivationMethod.Empty"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlEnum("")]
        Empty = 0,
        /// <include file='doc\XmlSchemaDerivationMethod.uex' path='docs/doc[@for="XmlSchemaDerivationMethod.Substitution"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlEnum("substitution")]
        Substitution = 0x0001,
        /// <include file='doc\XmlSchemaDerivationMethod.uex' path='docs/doc[@for="XmlSchemaDerivationMethod.Extension"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlEnum("extension")]
        Extension = 0x0002,
        /// <include file='doc\XmlSchemaDerivationMethod.uex' path='docs/doc[@for="XmlSchemaDerivationMethod.Restriction"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlEnum("restriction")]
        Restriction = 0x0004,
        /// <include file='doc\XmlSchemaDerivationMethod.uex' path='docs/doc[@for="XmlSchemaDerivationMethod.List"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlEnum("list")]
        List = 0x0008,
        /// <include file='doc\XmlSchemaDerivationMethod.uex' path='docs/doc[@for="XmlSchemaDerivationMethod.Union"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlEnum("union")]
        Union = 0x0010,
        /// <include file='doc\XmlSchemaDerivationMethod.uex' path='docs/doc[@for="XmlSchemaDerivationMethod.All"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlEnum("#all")]
        All = 0x00FF,
        /// <include file='doc\XmlSchemaDerivationMethod.uex' path='docs/doc[@for="XmlSchemaDerivationMethod.None"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlIgnore]
        None = 0x0100
    }
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\schema\xmlschemacontenttype.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlSchemaContentType.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------


namespace System.Xml.Schema
{
    /// <include file='doc\XmlSchemaContentType.uex' path='docs/doc[@for="XmlSchemaContentType"]/*' />
    public enum XmlSchemaContentType {
        /// <include file='doc\XmlSchemaContentType.uex' path='docs/doc[@for="XmlSchemaContentType.TextOnly"]/*' />
        TextOnly,
        /// <include file='doc\XmlSchemaContentType.uex' path='docs/doc[@for="XmlSchemaContentType.Empty"]/*' />
        Empty,
        /// <include file='doc\XmlSchemaContentType.uex' path='docs/doc[@for="XmlSchemaContentType.ElementOnly"]/*' />
        ElementOnly,
        /// <include file='doc\XmlSchemaContentType.uex' path='docs/doc[@for="XmlSchemaContentType.Mixed"]/*' />
        Mixed
    };

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\schema\xmlschemaexception.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlSchemaException.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * @(#)xmlexception.h 1.0 4/14/99
 * 
 * An Exception subclass for specific Xml exceptions.
 *
 * Copyright (c) 1999 Microsoft, Corp. All Rights Reserved.
 * 
 */


namespace System.Xml.Schema {
    using System;
    using System.IO;
    using System.Text;  
    using System.Resources;
    using System.Runtime.Serialization;
    using System.Diagnostics;
    using System.Security.Permissions;

    /// <include file='doc\XmlSchemaException.uex' path='docs/doc[@for="XmlSchemaException"]/*' />
    [Serializable]
    public class XmlSchemaException : SystemException {
        string res;
        string[] args;
        string sourceUri;
        int lineNumber;
        int linePosition; 
        XmlSchemaObject sourceSchemaObject;
        string message;

        /// <include file='doc\XmlSchemaException.uex' path='docs/doc[@for="XmlSchemaException.XmlSchemaException5"]/*' />
        protected XmlSchemaException(SerializationInfo info, StreamingContext context) : base(info, context) {
            res                = (string)         info.GetValue("res"  , typeof(string));
            args               = (string[])       info.GetValue("args", typeof(string[]));
            sourceUri          = (string)         info.GetValue("sourceUri", typeof(string));
            lineNumber         = (int)            info.GetValue("lineNumber", typeof(int));
            linePosition       = (int)            info.GetValue("linePosition", typeof(int));
            sourceSchemaObject = (XmlSchemaObject)info.GetValue("sourceSchemaObject", typeof(XmlSchemaObject));
        }


        /// <include file='doc\XmlSchemaException.uex' path='docs/doc[@for="XmlSchemaException.GetObjectData"]/*' />
        [SecurityPermissionAttribute(SecurityAction.Demand,SerializationFormatter=true)]
		public override void GetObjectData(SerializationInfo info, StreamingContext context) {
            base.GetObjectData(info, context);
            info.AddValue("res",                res);
            info.AddValue("args",               args);
            info.AddValue("sourceUri",          sourceUri);
            info.AddValue("lineNumber",         lineNumber);
            info.AddValue("linePosition",       linePosition);
            info.AddValue("sourceSchemaObject", sourceSchemaObject);
        }

		/// <include file='doc\XmlSchemaException.uex' path='docs/doc[@for="XmlSchemaException.XmlSchemaException0"]/*' />
		public XmlSchemaException(String message, Exception innerException) : base(message, innerException) {
            HResult = HResults.XmlSchema;
			this.res = Res.Xml_UserException;
			this.args = new string[] { message };
		}

        internal XmlSchemaException(string res) :
            this(res, (string[])null, null, 0, 0, null) {}

        
        internal XmlSchemaException(string res, string[] args) :
            this(res, args, null, 0, 0, null) {}
        
        internal XmlSchemaException(string res, string arg) :
            this(res, new string[] { arg }, null, 0, 0, null) {}

        internal XmlSchemaException(string res, string arg, string sourceUri, int lineNumber, int linePosition) :
            this(res, new string[] { arg }, sourceUri, lineNumber, linePosition, null) {}

        internal XmlSchemaException(string res, string sourceUri, int lineNumber, int linePosition) :
            this(res, (string[])null, sourceUri, lineNumber, linePosition, null) {}

        internal XmlSchemaException(string res, string[] args, string sourceUri, int lineNumber, int linePosition) :
            this(res, args, sourceUri, lineNumber, linePosition, null) {}

        internal XmlSchemaException(string res, XmlSchemaObject source) :
            this(res, (string[])null, source) {}

        internal XmlSchemaException(string res, string arg, XmlSchemaObject source) :
            this(res, new string[] { arg }, source) {}

        internal XmlSchemaException(string res, string[] args, XmlSchemaObject source) :
            this(res, args, source.SourceUri,  source.LineNumber, source.LinePosition, source) {}

        internal XmlSchemaException(string res, string[] args, string sourceUri, int lineNumber, int linePosition, XmlSchemaObject source) {
            HResult = HResults.XmlSchema;
            this.res = res;
            this.args = args;
            this.sourceUri = sourceUri;
            this.lineNumber = lineNumber;
            this.linePosition = linePosition;
            this.sourceSchemaObject = source;
        }

        /*
         * Returns the XML exception description.
         */
        /// <include file='doc\XmlSchemaException.uex' path='docs/doc[@for="XmlSchemaException.Message"]/*' />
        public override string Message { 
            get {
                string message = this.message;
                if (message == null) {
                    try {
                        message = Res.GetString(this.res, this.args);
                    }
                    catch {
                        message = "UNKNOWN("+res+")";
                    }

                    if (this.sourceUri != null) {
                        string[] msg = new string[] {this.sourceUri , this.lineNumber.ToString(), this.linePosition.ToString() };
                        message += " " + Res.GetString(Res.Sch_ErrorPosition, msg);
                    }

                    this.message = message;
                }
                return message;
            }
        }

        /// <include file='doc\XmlSchemaException.uex' path='docs/doc[@for="XmlSchemaException.SourceUri"]/*' />
        public string SourceUri {
            get { return this.sourceUri; }
        }

        /// <include file='doc\XmlSchemaException.uex' path='docs/doc[@for="XmlSchemaException.LineNumber"]/*' />
        public int LineNumber {
            get { return this.lineNumber; }
        }

        /// <include file='doc\XmlSchemaException.uex' path='docs/doc[@for="XmlSchemaException.LinePosition"]/*' />
        public int LinePosition {
            get { return this.linePosition; }
        }
      
        /// <include file='doc\XmlSchemaException.uex' path='docs/doc[@for="XmlSchemaException.SourceObject"]/*' />
        public XmlSchemaObject SourceSchemaObject {
            get { return this.sourceSchemaObject; }
        }

        internal void SetSource(string sourceUri, int lineNumber, int linePosition) {
            this.sourceUri = sourceUri;
            this.lineNumber = lineNumber;
            this.linePosition = linePosition;
        }

        internal void SetSource(XmlSchemaObject source) {
            this.sourceSchemaObject = source;
            this.sourceUri = source.SourceUri;
            this.lineNumber = source.LineNumber;
            this.linePosition = source.LinePosition;
        }
    };
} // namespace System.Xml.Schema
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\schema\xmlschemaelement.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlSchemaElement.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Schema {

    using System.Collections;
    using System.ComponentModel;
    using System.Xml.Serialization;
    using System.Diagnostics;

    /// <include file='doc\XmlSchemaElement.uex' path='docs/doc[@for="XmlSchemaElement"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public class XmlSchemaElement : XmlSchemaParticle {
        bool isAbstract;
        XmlSchemaDerivationMethod block = XmlSchemaDerivationMethod.None;
        XmlSchemaDerivationMethod final = XmlSchemaDerivationMethod.None;
        XmlSchemaForm form = XmlSchemaForm.None;
        string defaultValue;
        string fixedValue;
        string name;        
        bool isNillable;
        bool hasNillableAttribute;
        XmlQualifiedName refName = XmlQualifiedName.Empty;
        XmlQualifiedName substitutionGroup = XmlQualifiedName.Empty;
        XmlQualifiedName typeName = XmlQualifiedName.Empty;
        XmlSchemaType type = null;

        XmlQualifiedName qualifiedName = XmlQualifiedName.Empty;
        object elementType;
        XmlSchemaDerivationMethod blockResolved;
        XmlSchemaDerivationMethod finalResolved;
        XmlSchemaObjectCollection constraints = new XmlSchemaObjectCollection();
        SchemaElementDecl elementDecl;
        bool validating;

        /// <include file='doc\XmlSchemaElement.uex' path='docs/doc[@for="XmlSchemaElement.IsAbstract"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlAttribute("abstract"), DefaultValue(false)]
        public bool IsAbstract {
            get { return isAbstract; }
            set { isAbstract = value; }
        }

        /// <include file='doc\XmlSchemaElement.uex' path='docs/doc[@for="XmlSchemaElement.Block"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlAttribute("block"), DefaultValue(XmlSchemaDerivationMethod.None)]
        public XmlSchemaDerivationMethod Block {
             get { return block; }
             set { block = value; }
        }

        /// <include file='doc\XmlSchemaElement.uex' path='docs/doc[@for="XmlSchemaElement.DefaultValue"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlAttribute("default")]
        [DefaultValue(null)]
        public string DefaultValue { 
            get { return defaultValue; }
            set { defaultValue = value; }
        }

        /// <include file='doc\XmlSchemaElement.uex' path='docs/doc[@for="XmlSchemaElement.Final"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlAttribute("final"), DefaultValue(XmlSchemaDerivationMethod.None)]
        public XmlSchemaDerivationMethod Final {
             get { return final; }
             set { final = value; }
        }

        /// <include file='doc\XmlSchemaElement.uex' path='docs/doc[@for="XmlSchemaElement.FixedValue"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlAttribute("fixed")]
        [DefaultValue(null)]
        public string FixedValue { 
            get { return fixedValue; }
            set { fixedValue = value; }
        }

        /// <include file='doc\XmlSchemaElement.uex' path='docs/doc[@for="XmlSchemaElement.Form"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlAttribute("form"), DefaultValue(XmlSchemaForm.None)]
        public XmlSchemaForm Form {
             get { return form; }
             set { form = value; }
        }

        /// <include file='doc\XmlSchemaElement.uex' path='docs/doc[@for="XmlSchemaElement.Name"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlAttribute("name"), DefaultValue("")]
        public string Name { 
            get { return name; }
            set { name = value; }
        }
        
        /// <include file='doc\XmlSchemaElement.uex' path='docs/doc[@for="XmlSchemaElement.IsNillable"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlAttribute("nillable"), DefaultValue(false)]
        public bool IsNillable {
            get { return isNillable; }
            set { isNillable = value; hasNillableAttribute = true; }
        }

        [XmlIgnore]
        internal bool HasNillableAttribute {
            get { return hasNillableAttribute; } 
        } 
    
        /// <include file='doc\XmlSchemaElement.uex' path='docs/doc[@for="XmlSchemaElement.RefName"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlAttribute("ref")]
        public XmlQualifiedName RefName { 
            get { return refName; }
            set { refName = (value == null ? XmlQualifiedName.Empty : value); }
        }
        
        /// <include file='doc\XmlSchemaElement.uex' path='docs/doc[@for="XmlSchemaElement.SubstitutionGroup"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlAttribute("substitutionGroup")]
        public XmlQualifiedName SubstitutionGroup {
            get { return substitutionGroup; }
            set { substitutionGroup = (value == null ? XmlQualifiedName.Empty : value); }
        }
    
        /// <include file='doc\XmlSchemaElement.uex' path='docs/doc[@for="XmlSchemaElement.SchemaTypeName"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlAttribute("type")]
        public XmlQualifiedName SchemaTypeName { 
            get { return typeName; }
            set { typeName = (value == null ? XmlQualifiedName.Empty : value); }
        }
        
        /// <include file='doc\XmlSchemaElement.uex' path='docs/doc[@for="XmlSchemaElement.SchemaType"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlElement("complexType", typeof(XmlSchemaComplexType)),
         XmlElement("simpleType", typeof(XmlSchemaSimpleType))]
        public XmlSchemaType SchemaType {
            get { return type; }
            set { type = value; }
        }
        
        /// <include file='doc\XmlSchemaElement.uex' path='docs/doc[@for="XmlSchemaElement.Constraints"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlElement("key", typeof(XmlSchemaKey)),
         XmlElement("keyref", typeof(XmlSchemaKeyref)),
         XmlElement("unique", typeof(XmlSchemaUnique))]
        public XmlSchemaObjectCollection Constraints {
            get { return constraints; }
        }

        /// <include file='doc\XmlSchemaElement.uex' path='docs/doc[@for="XmlSchemaElement.QualifiedName"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlIgnore]
        public XmlQualifiedName QualifiedName { 
            get { return qualifiedName; }
        }

        /// <include file='doc\XmlSchemaElement.uex' path='docs/doc[@for="XmlSchemaElement.ElementType"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlIgnore]
        public object ElementType {
            get { return elementType; }
        }

        /// <include file='doc\XmlSchemaElement.uex' path='docs/doc[@for="XmlSchemaElement.BlockResolved"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlIgnore]
        public XmlSchemaDerivationMethod BlockResolved {
             get { return blockResolved; }
        }

        /// <include file='doc\XmlSchemaElement.uex' path='docs/doc[@for="XmlSchemaElement.FinalResolved"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlIgnore]
        public XmlSchemaDerivationMethod FinalResolved {
             get { return finalResolved; }
        }

        internal void SetQualifiedName(XmlQualifiedName value) { 
            qualifiedName = value;
        }

        internal void SetElementType(object value) { 
            elementType = value;
        }

        internal void SetBlockResolved(XmlSchemaDerivationMethod value) {
             blockResolved = value; 
        }

        internal void SetFinalResolved(XmlSchemaDerivationMethod value) {
             finalResolved = value; 
        }

        [XmlIgnore]
        internal bool HasDefault {
            get { return defaultValue != null && defaultValue.Length > 0; }
        }

        internal bool HasConstraints {
            get { return constraints.Count > 0; }
        }

        internal SchemaElementDecl ElementDecl {
            get { return elementDecl; }
            set { elementDecl = value; }
        }

        internal bool Validating {
            get { return validating; }
            set { validating = value; }
        }

        [XmlIgnore]
        internal override string NameAttribute {
            get { return Name; }
            set { Name = value; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\schema\xmlschemaexternal.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlSchemaExternal.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Schema {

    using System.Collections;
    using System.ComponentModel;
    using System.Xml.Serialization;

    /// <include file='doc\XmlSchemaExternal.uex' path='docs/doc[@for="XmlSchemaExternal"]/*' />
    public abstract class XmlSchemaExternal : XmlSchemaObject {
        string location;
        string fullPath;
        XmlSchema schema; 
        string id;
        XmlAttribute[] moreAttributes;

        /// <include file='doc\XmlSchemaExternal.uex' path='docs/doc[@for="XmlSchemaExternal.SchemaLocation"]/*' />
        [XmlAttribute("schemaLocation", DataType="anyURI")]
        public string SchemaLocation {
            get { return location; }
            set { location = value; }
        }

        /// <include file='doc\XmlSchemaExternal.uex' path='docs/doc[@for="XmlSchemaExternal.Schema"]/*' />
        [XmlIgnore]
        public XmlSchema Schema {
            get { return schema; }
            set { schema = value; }
        }

        /// <include file='doc\XmlSchemaExternal.uex' path='docs/doc[@for="XmlSchemaExternal.Id"]/*' />
        [XmlAttribute("id", DataType="ID")]
        public string Id {
            get { return id; }
            set { id = value; }
        }

        /// <include file='doc\XmlSchemaExternal.uex' path='docs/doc[@for="XmlSchemaExternal.UnhandledAttributes"]/*' />
        [XmlAnyAttribute]
        public XmlAttribute[] UnhandledAttributes {
            get { return moreAttributes; }
            set { moreAttributes = value; }
        }

        [XmlIgnore]
        internal string FullPath {
            get { return fullPath; }
            set { fullPath = value; }
        }

        [XmlIgnore]
        internal override string IdAttribute {
            get { return Id; }
            set { Id = value; }
        }

        internal override void SetUnhandledAttributes(XmlAttribute[] moreAttributes) {
            this.moreAttributes = moreAttributes;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\schema\xmlschemafacet.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlSchemaFacet.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Schema {

    using System.Collections;
    using System.ComponentModel;
    using System.Xml.Serialization;

    /// <include file='doc\XmlSchemaFacet.uex' path='docs/doc[@for="XmlSchemaFacet"]/*' />
    public abstract class XmlSchemaFacet : XmlSchemaAnnotated {
        string value;
        bool isFixed;

        /// <include file='doc\XmlSchemaFacet.uex' path='docs/doc[@for="XmlSchemaFacet.Value"]/*' />
        [XmlAttribute("value")]
        public string Value { 
            get { return this.value; }
            set { this.value = value; }
        }

        /// <include file='doc\XmlSchemaFacet.uex' path='docs/doc[@for="XmlSchemaFacet.IsFixed"]/*' />
        [XmlAttribute("fixed"), DefaultValue(false)]
        public virtual bool IsFixed {
            get { return isFixed; }
            set { 
                if (!(this is XmlSchemaEnumerationFacet) && !(this is XmlSchemaPatternFacet)) {
                    isFixed = value; 
                }
            }
        }
    }

    /// <include file='doc\XmlSchemaFacet.uex' path='docs/doc[@for="XmlSchemaNumericFacet"]/*' />
    public abstract class XmlSchemaNumericFacet : XmlSchemaFacet { }

    /// <include file='doc\XmlSchemaFacet.uex' path='docs/doc[@for="XmlSchemaLengthFacet"]/*' />
    public class XmlSchemaLengthFacet : XmlSchemaNumericFacet { }

    /// <include file='doc\XmlSchemaFacet.uex' path='docs/doc[@for="XmlSchemaMinLengthFacet"]/*' />
    public class XmlSchemaMinLengthFacet : XmlSchemaNumericFacet { }

    /// <include file='doc\XmlSchemaFacet.uex' path='docs/doc[@for="XmlSchemaMaxLengthFacet"]/*' />
    public class XmlSchemaMaxLengthFacet : XmlSchemaNumericFacet { }

    /// <include file='doc\XmlSchemaFacet.uex' path='docs/doc[@for="XmlSchemaPatternFacet"]/*' />
    public class XmlSchemaPatternFacet : XmlSchemaFacet { }

    /// <include file='doc\XmlSchemaFacet.uex' path='docs/doc[@for="XmlSchemaEnumerationFacet"]/*' />
    public class XmlSchemaEnumerationFacet : XmlSchemaFacet { }

    /// <include file='doc\XmlSchemaFacet.uex' path='docs/doc[@for="XmlSchemaMinExclusiveFacet"]/*' />
    public class XmlSchemaMinExclusiveFacet : XmlSchemaFacet { }

    /// <include file='doc\XmlSchemaFacet.uex' path='docs/doc[@for="XmlSchemaMinInclusiveFacet"]/*' />
    public class XmlSchemaMinInclusiveFacet : XmlSchemaFacet { }

    /// <include file='doc\XmlSchemaFacet.uex' path='docs/doc[@for="XmlSchemaMaxExclusiveFacet"]/*' />
    public class XmlSchemaMaxExclusiveFacet : XmlSchemaFacet { }

    /// <include file='doc\XmlSchemaFacet.uex' path='docs/doc[@for="XmlSchemaMaxInclusiveFacet"]/*' />
    public class XmlSchemaMaxInclusiveFacet : XmlSchemaFacet { }

    /// <include file='doc\XmlSchemaFacet.uex' path='docs/doc[@for="XmlSchemaTotalDigitsFacet"]/*' />
    public class XmlSchemaTotalDigitsFacet : XmlSchemaNumericFacet { }

    /// <include file='doc\XmlSchemaFacet.uex' path='docs/doc[@for="XmlSchemaFractionDigitsFacet"]/*' />
    public class XmlSchemaFractionDigitsFacet : XmlSchemaNumericFacet { }

    /// <include file='doc\XmlSchemaFacet.uex' path='docs/doc[@for="XmlSchemaWhiteSpaceFacet"]/*' />
    public class XmlSchemaWhiteSpaceFacet : XmlSchemaFacet { }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\schema\xmlschemaform.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlSchemaForm.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Schema {

    using System.Collections;
    using System.ComponentModel;
    using System.Xml.Serialization;

    //nzeng: if change the enum, have to change xsdbuilder as well.
    /// <include file='doc\XmlSchemaForm.uex' path='docs/doc[@for="XmlSchemaForm"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public enum XmlSchemaForm {
        /// <include file='doc\XmlSchemaForm.uex' path='docs/doc[@for="XmlSchemaForm.XmlEnum"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlIgnore]
        None,
        /// <include file='doc\XmlSchemaForm.uex' path='docs/doc[@for="XmlSchemaForm.XmlEnum1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlEnum("qualified")]
        Qualified,
        /// <include file='doc\XmlSchemaForm.uex' path='docs/doc[@for="XmlSchemaForm.XmlEnum2"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlEnum("unqualified")]
        Unqualified,
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\schema\xmlschemagroupbase.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlSchemaGroupbase.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Schema {

    using System.Xml.Serialization;

    /// <include file='doc\XmlSchemaGroupbase.uex' path='docs/doc[@for="XmlSchemaGroupBase"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public abstract class XmlSchemaGroupBase : XmlSchemaParticle {
        /// <include file='doc\XmlSchemaGroupbase.uex' path='docs/doc[@for="XmlSchemaGroupBase.Items"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlIgnore]
        public abstract XmlSchemaObjectCollection Items { get; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\schema\xmlschemagroupref.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlSchemaGroupRef.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Schema {

    using System.Collections;
    using System.ComponentModel;
    using System.Xml.Serialization;

    /// <include file='doc\XmlSchemaGroupRef.uex' path='docs/doc[@for="XmlSchemaGroupRef"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public class XmlSchemaGroupRef : XmlSchemaParticle {
        XmlQualifiedName refName = XmlQualifiedName.Empty; 
        XmlSchemaGroupBase particle;
        XmlSchemaGroup refined;
        
        /// <include file='doc\XmlSchemaGroupRef.uex' path='docs/doc[@for="XmlSchemaGroupRef.RefName"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlAttribute("ref")]
        public XmlQualifiedName RefName { 
            get { return refName; }
            set { refName = (value == null ? XmlQualifiedName.Empty : value); }
        }

        /// <include file='doc\XmlSchemaGroupRef.uex' path='docs/doc[@for="XmlSchemaGroupRef.Particle"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlIgnore]
        public XmlSchemaGroupBase Particle {
            get { return particle; }
        }

        internal void SetParticle(XmlSchemaGroupBase value) {
             particle = value; 
        }

        [XmlIgnore]
        internal XmlSchemaGroup Redefined {
            get { return refined; }
            set { refined = value; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\schema\xmlschemagroup.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlSchemaGroup.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Schema {

    using System.Collections;
    using System.ComponentModel;
    using System.Xml.Serialization;

    /// <include file='doc\XmlSchemaGroup.uex' path='docs/doc[@for="XmlSchemaGroup"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public class XmlSchemaGroup : XmlSchemaAnnotated {
        string name;        
        XmlSchemaGroupBase particle;
        XmlSchemaParticle canonicalParticle;
        XmlQualifiedName qname = XmlQualifiedName.Empty; 
        XmlSchemaGroup redefined;
        bool validating;

        /// <include file='doc\XmlSchemaGroup.uex' path='docs/doc[@for="XmlSchemaGroup.Name"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlAttribute("name")]
        public string Name { 
            get { return name; }
            set { name = value; }
        }

        /// <include file='doc\XmlSchemaGroup.uex' path='docs/doc[@for="XmlSchemaGroup.Particle"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlElement("choice", typeof(XmlSchemaChoice)),
         XmlElement("all", typeof(XmlSchemaAll)),
         XmlElement("sequence", typeof(XmlSchemaSequence))]
        public XmlSchemaGroupBase Particle {
            get { return particle; }
            set { particle = value; }
        }

        [XmlIgnore]
        internal XmlQualifiedName QualifiedName {
            get { return qname; }
            set { qname = value; }
        }

        [XmlIgnore]
        internal XmlSchemaParticle CanonicalParticle {
            get { return canonicalParticle; }
            set { canonicalParticle = value; }
        }

        [XmlIgnore]
        internal XmlSchemaGroup Redefined {
            get { return redefined; }
            set { redefined = value; }
        }

        [XmlIgnore]
        internal bool Validating {
            get { return validating; }
            set { validating = value; }
        }

        [XmlIgnore]
        internal override string NameAttribute {
            get { return Name; }
            set { Name = value; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\schema\xmlschemaidentityconstraint.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlSchemaIdentityConstraint.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Schema {

    using System.Collections;
    using System.ComponentModel;
    using System.Xml.Serialization;

    /// <include file='doc\XmlSchemaIdentityConstraint.uex' path='docs/doc[@for="XmlSchemaIdentityConstraint"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public class XmlSchemaIdentityConstraint : XmlSchemaAnnotated {
        bool validating;
        string name;        
        XmlSchemaXPath selector;
        XmlSchemaObjectCollection fields = new XmlSchemaObjectCollection();
		XmlQualifiedName qualifiedName = XmlQualifiedName.Empty;
		CompiledIdentityConstraint compiledConstraint = null;

        internal bool Validating {
            get { return validating; }
            set { validating = value; }
        }

        /// <include file='doc\XmlSchemaIdentityConstraint.uex' path='docs/doc[@for="XmlSchemaIdentityConstraint.Name"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlAttribute("name")]
        public string Name { 
            get { return name; }
            set { name = value; }
        }

        /// <include file='doc\XmlSchemaIdentityConstraint.uex' path='docs/doc[@for="XmlSchemaIdentityConstraint.Selector"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlElement("selector", typeof(XmlSchemaXPath))]
        public XmlSchemaXPath Selector {
            get { return selector; }
            set { selector = value; }
        }

        /// <include file='doc\XmlSchemaIdentityConstraint.uex' path='docs/doc[@for="XmlSchemaIdentityConstraint.Fields"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlElement("field", typeof(XmlSchemaXPath))]
        public XmlSchemaObjectCollection Fields {
            get { return fields; }
        }
		
        /// <include file='doc\XmlSchemaIdentityConstraint.uex' path='docs/doc[@for="XmlSchemaIdentityConstraint.QualifiedName"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
		[XmlIgnore]
		public XmlQualifiedName QualifiedName { 
			get { return qualifiedName; }
		}

		internal void  SetQualifiedName(XmlQualifiedName value) { 
			qualifiedName = value;
		}

		[XmlIgnore]
		internal CompiledIdentityConstraint CompiledConstraint {
			get { return compiledConstraint; }
			set { compiledConstraint = value; }
		}

        [XmlIgnore]
        internal override string NameAttribute {
            get { return Name; }
            set { Name = value; }
        }
    }

    /// <include file='doc\XmlSchemaIdentityConstraint.uex' path='docs/doc[@for="XmlSchemaXPath"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public class XmlSchemaXPath : XmlSchemaAnnotated {
        string xpath;
        /// <include file='doc\XmlSchemaIdentityConstraint.uex' path='docs/doc[@for="XmlSchemaXPath.XPath"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlAttribute("xpath"), DefaultValue("")]
        public string XPath {
            get { return xpath; }
            set { xpath = value; }
        }
    }

    /// <include file='doc\XmlSchemaIdentityConstraint.uex' path='docs/doc[@for="XmlSchemaUnique"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public class XmlSchemaUnique : XmlSchemaIdentityConstraint {
    }

    /// <include file='doc\XmlSchemaIdentityConstraint.uex' path='docs/doc[@for="XmlSchemaKey"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public class XmlSchemaKey : XmlSchemaIdentityConstraint {
    }

    /// <include file='doc\XmlSchemaIdentityConstraint.uex' path='docs/doc[@for="XmlSchemaKeyref"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public class XmlSchemaKeyref : XmlSchemaIdentityConstraint {
        XmlQualifiedName refer = XmlQualifiedName.Empty; 

        /// <include file='doc\XmlSchemaIdentityConstraint.uex' path='docs/doc[@for="XmlSchemaKeyref.Refer"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlAttribute("refer")]
        public XmlQualifiedName Refer { 
            get { return refer; }
            set { refer = (value == null ? XmlQualifiedName.Empty : value); }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\schema\xmlschemaimport.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlSchemaImport.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Schema {

    using System.Collections;
    using System.ComponentModel;
    using System.Xml.Serialization;

    /// <include file='doc\XmlSchemaImport.uex' path='docs/doc[@for="XmlSchemaImport"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public class XmlSchemaImport : XmlSchemaExternal {
        string ns;
        XmlSchemaAnnotation annotation;

        /// <include file='doc\XmlSchemaImport.uex' path='docs/doc[@for="XmlSchemaImport.Namespace"]/*' />
        [XmlAttribute("namespace", DataType="anyURI")]
        public string Namespace {
            get { return ns; }
            set { ns = value; }
        }

        /// <include file='doc\XmlSchemaImport.uex' path='docs/doc[@for="XmlSchemaImport.Annotation"]/*' />
        [XmlElement("annotation", typeof(XmlSchemaAnnotation))]
        public XmlSchemaAnnotation Annotation {
            get { return annotation; }
            set { annotation = value; }
        }

        internal override void AddAnnotation(XmlSchemaAnnotation annotation) {
            this.annotation = annotation;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\schema\xmlschemainclude.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlSchemaInclude.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Schema {

    using System.Collections;
    using System.ComponentModel;
    using System.Xml.Serialization;

    /// <include file='doc\XmlSchemaInclude.uex' path='docs/doc[@for="XmlSchemaInclude"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public class XmlSchemaInclude : XmlSchemaExternal {
        XmlSchemaAnnotation annotation;

        /// <include file='doc\XmlSchemaInclude.uex' path='docs/doc[@for="XmlSchemaInclude.Annotation"]/*' />
        [XmlElement("annotation", typeof(XmlSchemaAnnotation))]
        public XmlSchemaAnnotation Annotation {
            get { return annotation; }
            set { annotation = value; }
        }

        internal override void AddAnnotation(XmlSchemaAnnotation annotation) {
            this.annotation = annotation;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\schema\xmlschemaobject.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlSchemaObject.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Schema {

    using System.Collections;
    using System.Diagnostics;
    using System.ComponentModel;
    using System.Xml.Serialization;
    
    /// <include file='doc\XmlSchemaObject.uex' path='docs/doc[@for="XmlSchemaObject"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public abstract class XmlSchemaObject {
        int lineNum = 0;
        int linePos = 0;
        string sourceUri;
        XmlSerializerNamespaces namespaces;
        XmlSchemaObject parent;

        /// <include file='doc\XmlSchemaObject.uex' path='docs/doc[@for="XmlSchemaObject.LineNum"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlIgnore]
        public int LineNumber {
            get { return lineNum;}
            set { lineNum = value;}
        }

        /// <include file='doc\XmlSchemaObject.uex' path='docs/doc[@for="XmlSchemaObject.LinePos"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlIgnore]
        public int LinePosition {
            get { return linePos;}
            set { linePos = value;}
        }

        /// <include file='doc\XmlSchemaObject.uex' path='docs/doc[@for="XmlSchemaObject.SourceUri"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlIgnore]
        public string SourceUri {
            get { return sourceUri;}
            set { sourceUri = value;}
        }

        [XmlIgnore]
        internal XmlSchemaObject Parent {
            get { return parent;}
            set { parent = value;}
        }

        /// <include file='doc\XmlSchemaObject.uex' path='docs/doc[@for="XmlSchemaObject.Namespaces"]/*' />
        [XmlNamespaceDeclarations]
        public XmlSerializerNamespaces Namespaces {
            get {
                if (namespaces == null)
                    namespaces = new XmlSerializerNamespaces();
                return namespaces;
            }
            set { namespaces = value; }
        }

        internal virtual void OnAdd(XmlSchemaObjectCollection container, object item) {}
        internal virtual void OnRemove(XmlSchemaObjectCollection container, object item) {}
        internal virtual void OnClear(XmlSchemaObjectCollection container) {}

        [XmlIgnore]
        internal virtual string IdAttribute {
            get { Debug.Assert(false); return null; }
            set { Debug.Assert(false); }
        }
        
        internal virtual void SetUnhandledAttributes(XmlAttribute[] moreAttributes) {}
        internal virtual void AddAnnotation(XmlSchemaAnnotation annotation) {}

        [XmlIgnore]
        internal virtual string NameAttribute {
            get { Debug.Assert(false); return null; }
            set { Debug.Assert(false); }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\schema\xmlschemanotation.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlSchemaNotation.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Schema {

    using System.Collections;
    using System.ComponentModel;
    using System.Xml.Serialization;

    /// <include file='doc\XmlSchemaNotation.uex' path='docs/doc[@for="XmlSchemaNotation"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public class XmlSchemaNotation : XmlSchemaAnnotated {
        string name;        
        string publicId;
        string systemId;
        XmlQualifiedName qname = XmlQualifiedName.Empty; 
        
        /// <include file='doc\XmlSchemaNotation.uex' path='docs/doc[@for="XmlSchemaNotation.Name"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlAttribute("name")]
        public string Name { 
            get { return name; }
            set { name = value; }
        }

        /// <include file='doc\XmlSchemaNotation.uex' path='docs/doc[@for="XmlSchemaNotation.Public"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlAttribute("public")]
        public string Public {
            get { return publicId; }
            set { publicId = value; }
        }

        /// <include file='doc\XmlSchemaNotation.uex' path='docs/doc[@for="XmlSchemaNotation.System"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlAttribute("system")]
        public string System {
            get { return systemId; }
            set { systemId = value; }
        }

        [XmlIgnore]
        internal XmlQualifiedName QualifiedName {
            get { return qname; }
            set { qname = value; }
        }

        [XmlIgnore]
        internal override string NameAttribute {
            get { return Name; }
            set { Name = value; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\schema\xmlschemaobjectcollection.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlSchemaObjectCollection.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Schema {

    using System.Collections;
    using System.ComponentModel;
    using System.Xml.Serialization;

    /// <include file='doc\XmlSchemaObjectCollection.uex' path='docs/doc[@for="XmlSchemaObjectCollection"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public class XmlSchemaObjectCollection : CollectionBase {
        XmlSchemaObject parent;

        /// <include file='doc\XmlSchemaObjectCollection.uex' path='docs/doc[@for="XmlSchemaObjectCollection.XmlSchemaObjectCollection"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public XmlSchemaObjectCollection() {
        }

        /// <include file='doc\XmlSchemaObjectCollection.uex' path='docs/doc[@for="XmlSchemaObjectCollection.XmlSchemaObjectCollection1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public XmlSchemaObjectCollection(XmlSchemaObject parent) {
            parent = parent;
        }
        
        /// <include file='doc\XmlSchemaObjectCollection.uex' path='docs/doc[@for="XmlSchemaObjectCollection.this"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public virtual XmlSchemaObject this[int index] {
            get { return (XmlSchemaObject)List[index]; }
            set { List[index] = value; }
        }

        /// <include file='doc\XmlSchemaObjectCollection.uex' path='docs/doc[@for="XmlSchemaObjectCollection.GetEnumerator"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public new XmlSchemaObjectEnumerator GetEnumerator() {
            return new XmlSchemaObjectEnumerator(InnerList.GetEnumerator());
        }
        
        /// <include file='doc\XmlSchemaObjectCollection.uex' path='docs/doc[@for="XmlSchemaObjectCollection.Add"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public int Add(XmlSchemaObject item) {
            return List.Add(item);
        }
        
        /// <include file='doc\XmlSchemaObjectCollection.uex' path='docs/doc[@for="XmlSchemaObjectCollection.Insert"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void Insert(int index, XmlSchemaObject item) {
            List.Insert(index, item);
        }
        
        /// <include file='doc\XmlSchemaObjectCollection.uex' path='docs/doc[@for="XmlSchemaObjectCollection.IndexOf"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public int IndexOf(XmlSchemaObject item) {
            return List.IndexOf(item);
        }
        
        /// <include file='doc\XmlSchemaObjectCollection.uex' path='docs/doc[@for="XmlSchemaObjectCollection.Contains"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public bool Contains(XmlSchemaObject item) {
            return List.Contains(item);
        }
        
        /// <include file='doc\XmlSchemaObjectCollection.uex' path='docs/doc[@for="XmlSchemaObjectCollection.Remove"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void Remove(XmlSchemaObject item) {
            List.Remove(item);
        }
        
        /// <include file='doc\XmlSchemaObjectCollection.uex' path='docs/doc[@for="XmlSchemaObjectCollection.CopyTo"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void CopyTo(XmlSchemaObject[] array, int index) {
            List.CopyTo(array, index);
        }

        /// <include file='doc\XmlSchemaObjectCollection.uex' path='docs/doc[@for="XmlSchemaObjectCollection.OnInsert"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected override void OnInsert(int index, object item) {
            if (parent != null) {
                parent.OnAdd(this, item);
            }
        }

        /// <include file='doc\XmlSchemaObjectCollection.uex' path='docs/doc[@for="XmlSchemaObjectCollection.OnSet"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected override void OnSet(int index, object oldValue, object newValue) {
            if (parent != null) {
                parent.OnRemove(this, oldValue);
                parent.OnAdd(this, newValue);
            }
        }

        /// <include file='doc\XmlSchemaObjectCollection.uex' path='docs/doc[@for="XmlSchemaObjectCollection.OnClear"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected override void OnClear() {
            if (parent != null) {
                parent.OnClear(this);
            }
        }
        
        /// <include file='doc\XmlSchemaObjectCollection.uex' path='docs/doc[@for="XmlSchemaObjectCollection.OnRemove"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected override void OnRemove(int index, object item) {
            if (parent != null) {
                parent.OnRemove(this, item);
            }
        }
    }

    /// <include file='doc\XmlSchemaObjectCollection.uex' path='docs/doc[@for="XmlSchemaObjectEnumerator"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public sealed class XmlSchemaObjectEnumerator: IEnumerator {
        IEnumerator enumerator;

        internal XmlSchemaObjectEnumerator( IEnumerator enumerator ) {
            this.enumerator = enumerator;            
        }

        /// <include file='doc\XmlSchemaObjectCollection.uex' path='docs/doc[@for="XmlSchemaObjectEnumerator.Reset"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void Reset() {
            enumerator.Reset();
        }

        /// <include file='doc\XmlSchemaObjectCollection.uex' path='docs/doc[@for="XmlSchemaObjectEnumerator.MoveNext"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public bool MoveNext() {
            return enumerator.MoveNext();
        }

        /// <include file='doc\XmlSchemaObjectCollection.uex' path='docs/doc[@for="XmlSchemaObjectEnumerator.Current"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public XmlSchemaObject Current {
            get { return (XmlSchemaObject)enumerator.Current; }
        }

        /// <include file='doc\XmlSchemaObjectCollection.uex' path='docs/doc[@for="XmlSchemaObjectEnumerator.IEnumerator.Reset"]/*' />
        /// <internalonly/>
        void IEnumerator.Reset() {
            enumerator.Reset();
        }

        /// <include file='doc\XmlSchemaObjectCollection.uex' path='docs/doc[@for="XmlSchemaObjectEnumerator.IEnumerator.MoveNext"]/*' />
        /// <internalonly/>
        bool IEnumerator.MoveNext() {
            return enumerator.MoveNext();
        }

        /// <include file='doc\XmlSchemaObjectCollection.uex' path='docs/doc[@for="XmlSchemaObjectEnumerator.IEnumerator.Current"]/*' />
        /// <internalonly/>
        object IEnumerator.Current {
            get { return enumerator.Current; }
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\schema\xmlschemaobjecttable.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlSchemaObjectTable.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Schema {

    using System.Collections;
    using System.ComponentModel;
    using System.Xml.Serialization;

    /// <include file='doc\XmlSchemaObjectTable.uex' path='docs/doc[@for="XmlSchemaObjectTable"]/*' />
    public class XmlSchemaObjectTable {
        Hashtable table = new Hashtable();

        internal XmlSchemaObjectTable() {
        }

        internal void Add(XmlQualifiedName name,  XmlSchemaObject value) {
            table.Add(name, value);
        }

        internal void Insert(XmlQualifiedName name,  XmlSchemaObject value) {
            table[name] = value;
        }

        internal void Remove(XmlQualifiedName name) {
            table.Remove(name);
        }

        internal void Clear() {
            table.Clear();
        }

        /// <include file='doc\XmlSchemaObjectTable.uex' path='docs/doc[@for="XmlSchemaObjectTable.Count"]/*' />
        public int Count {
    		get { return table.Count; }
        }

        /// <include file='doc\XmlSchemaObjectTable.uex' path='docs/doc[@for="XmlSchemaObjectTable.Contains"]/*' />
        public bool Contains(XmlQualifiedName name) {
            return table.Contains(name);
        }

    	/// <include file='doc\XmlSchemaObjectTable.uex' path='docs/doc[@for="XmlSchemaObjectTable.this"]/*' />
    	public XmlSchemaObject this[XmlQualifiedName name] {
            get { return (XmlSchemaObject)table[name]; }
        }
        
        /// <include file='doc\XmlSchemaObjectTable.uex' path='docs/doc[@for="XmlSchemaObjectTable.Names"]/*' />
        public ICollection Names {
            get { return table.Keys; }
        }

        /// <include file='doc\XmlSchemaObjectTable.uex' path='docs/doc[@for="XmlSchemaObjectTable.Values"]/*' />
        public ICollection Values {
            get { return table.Values; }
        }
        /// <include file='doc\XmlSchemaObjectTable.uex' path='docs/doc[@for="XmlSchemaObjectTable.GetEnumerator"]/*' />
        public IDictionaryEnumerator GetEnumerator() {
            return table.GetEnumerator();
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\schema\xmlschemaredefine.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlSchemaRedefine.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Schema {

    using System.Collections;
    using System.ComponentModel;
    using System.Xml.Serialization;

    /// <include file='doc\XmlSchemaRedefine.uex' path='docs/doc[@for="XmlSchemaRedefine"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public class XmlSchemaRedefine : XmlSchemaExternal {
        XmlSchemaObjectCollection items = new XmlSchemaObjectCollection();
        XmlSchemaObjectTable attributeGroups = new XmlSchemaObjectTable();
        XmlSchemaObjectTable types = new XmlSchemaObjectTable();
        XmlSchemaObjectTable groups = new XmlSchemaObjectTable();


        /// <include file='doc\XmlSchemaRedefine.uex' path='docs/doc[@for="XmlSchemaRedefine.Items"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlElement("annotation", typeof(XmlSchemaAnnotation)),
         XmlElement("attributeGroup", typeof(XmlSchemaAttributeGroup)),
         XmlElement("complexType", typeof(XmlSchemaComplexType)),
         XmlElement("group", typeof(XmlSchemaGroup)),
         XmlElement("simpleType", typeof(XmlSchemaSimpleType))]
        public XmlSchemaObjectCollection Items {
            get { return items; }
        }

        /// <include file='doc\XmlSchemaRedefine.uex' path='docs/doc[@for="XmlSchemaRedefine.AttributeGroups"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlIgnore]
        public XmlSchemaObjectTable AttributeGroups {
            get { return attributeGroups; }
        }

        /// <include file='doc\XmlSchemaRedefine.uex' path='docs/doc[@for="XmlSchemaRedefine.SchemaTypes"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlIgnore]
        public XmlSchemaObjectTable SchemaTypes {
            get { return types; }
        }

        /// <include file='doc\XmlSchemaRedefine.uex' path='docs/doc[@for="XmlSchemaRedefine.Groups"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlIgnore]
        public XmlSchemaObjectTable Groups {
            get { return groups; }
        }

        internal override void AddAnnotation(XmlSchemaAnnotation annotation) {
            items.Add(annotation);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\schema\xmlschemasimplecontent.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlSchemaSimpleContent.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Schema {

    using System.Collections;
    using System.ComponentModel;
    using System.Xml.Serialization;

    /// <include file='doc\XmlSchemaSimpleContent.uex' path='docs/doc[@for="XmlSchemaSimpleContent"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public class XmlSchemaSimpleContent : XmlSchemaContentModel {
        XmlSchemaContent content;

        /// <include file='doc\XmlSchemaSimpleContent.uex' path='docs/doc[@for="XmlSchemaSimpleContent.Content"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlElement("restriction", typeof(XmlSchemaSimpleContentRestriction)),
         XmlElement("extension", typeof(XmlSchemaSimpleContentExtension))]
        public override XmlSchemaContent Content { 
            get { return content; }
            set { content = value; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\schema\xmlschemaparticle.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlSchemaParticle.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Schema {

    using System.Collections;
    using System.ComponentModel;
    using System.Xml.Serialization;

    /// <include file='doc\XmlSchemaParticle.uex' path='docs/doc[@for="XmlSchemaParticle"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public abstract class XmlSchemaParticle : XmlSchemaAnnotated {
        [Flags]
        enum Occurs {
            None,
            Min,
            Max
        };
        decimal minOccurs = decimal.One;
        decimal maxOccurs = decimal.One;
        Occurs flags = Occurs.None;
        
        /// <include file='doc\XmlSchemaParticle.uex' path='docs/doc[@for="XmlSchemaParticle.MinOccursString"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlAttribute("minOccurs")]
        public string MinOccursString {
            get { 
                return (flags & Occurs.Min) == 0 ? null : XmlConvert.ToString(minOccurs); 
            }
            set {
                if (value == null) {
                    minOccurs = decimal.One;
                    flags &= ~Occurs.Min;
                }
                else {
                    minOccurs = XmlConvert.ToInteger(value);
                    if (minOccurs < decimal.Zero) {
                        throw new XmlSchemaException(Res.Sch_MinOccursInvalidXsd);
                    }
                    flags |= Occurs.Min;
                }
            }
        }
        
        /// <include file='doc\XmlSchemaParticle.uex' path='docs/doc[@for="XmlSchemaParticle.MaxOccursString"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlAttribute("maxOccurs")]
        public string MaxOccursString {
            get { 
                return  (flags & Occurs.Max) == 0 ? null : (maxOccurs == decimal.MaxValue) ? "unbounded" : XmlConvert.ToString(maxOccurs); 
            }
            set {
                if (value == null) {
                    maxOccurs = decimal.One;
                    flags &= ~Occurs.Max;
                }
                else {
                    if (value == "unbounded") {
                        maxOccurs = decimal.MaxValue;
                    }
                    else {
                        maxOccurs = XmlConvert.ToInteger(value); 
                        if (maxOccurs < decimal.Zero) {
                            throw new XmlSchemaException(Res.Sch_MaxOccursInvalidXsd);
                        }
                        else if (maxOccurs == decimal.Zero && (flags & Occurs.Min) == 0) {
                            minOccurs = decimal.Zero;
                        }
                    }
                    flags |= Occurs.Max;
                }
            }
        }
        
        /// <include file='doc\XmlSchemaParticle.uex' path='docs/doc[@for="XmlSchemaParticle.MinOccurs"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlIgnore]
        public decimal MinOccurs {
            get { return minOccurs; }
            set {
                if (value < decimal.Zero || value != decimal.Truncate(value)) {
                    throw new XmlSchemaException(Res.Sch_MinOccursInvalidXsd);
                }
                minOccurs = value; 
                flags |= Occurs.Min;
            }
        }
        
        /// <include file='doc\XmlSchemaParticle.uex' path='docs/doc[@for="XmlSchemaParticle.MaxOccurs"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlIgnore]
        public decimal MaxOccurs {
            get { return maxOccurs; }
            set { 
                if (value < decimal.Zero || value != decimal.Truncate(value)) {
                    throw new XmlSchemaException(Res.Sch_MaxOccursInvalidXsd);
                }
                maxOccurs = value; 
                if (maxOccurs == decimal.Zero && (flags & Occurs.Min) == 0) {
                    minOccurs = decimal.Zero;
                }
                flags |= Occurs.Max;
            }
        }

        internal virtual bool IsEmpty {
            get { return maxOccurs == decimal.Zero; }
        } 

        internal bool IsMultipleOccurrence {
            get { return maxOccurs > decimal.One; }
        }
        
        class EmptyParticle : XmlSchemaParticle {
            internal override bool IsEmpty {
                get { return true; }
            } 
        }

        internal static readonly XmlSchemaParticle Empty = new EmptyParticle();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\schema\xmlschemasequence.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlSchemaSequence.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Schema {

    using System.Collections;
    using System.ComponentModel;
    using System.Xml.Serialization;

    /// <include file='doc\XmlSchemaSequence.uex' path='docs/doc[@for="XmlSchemaSequence"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public class XmlSchemaSequence : XmlSchemaGroupBase {
        XmlSchemaObjectCollection items = new XmlSchemaObjectCollection();

        /// <include file='doc\XmlSchemaSequence.uex' path='docs/doc[@for="XmlSchemaSequence.Items"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlElement("element", typeof(XmlSchemaElement)),
         XmlElement("group", typeof(XmlSchemaGroupRef)),
         XmlElement("choice", typeof(XmlSchemaChoice)),
         XmlElement("sequence", typeof(XmlSchemaSequence)),
         XmlElement("any", typeof(XmlSchemaAny))]
        public override  XmlSchemaObjectCollection Items {
            get { return items; }
        }

        internal override bool IsEmpty {
            get { return base.IsEmpty || items.Count == 0; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\schema\xmlschemasimplecontentrestriction.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlSchemaSimpleContentRestriction.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Schema {

    using System.Collections;
    using System.ComponentModel;
    using System.Xml.Serialization;

    /// <include file='doc\XmlSchemaSimpleContentRestriction.uex' path='docs/doc[@for="XmlSchemaSimpleContentRestriction"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public class XmlSchemaSimpleContentRestriction : XmlSchemaContent {
        XmlQualifiedName baseTypeName = XmlQualifiedName.Empty; 
		XmlSchemaSimpleType baseType;
        XmlSchemaObjectCollection facets = new XmlSchemaObjectCollection();
        XmlSchemaObjectCollection attributes = new XmlSchemaObjectCollection();
        XmlSchemaAnyAttribute anyAttribute;

        /// <include file='doc\XmlSchemaSimpleContentRestriction.uex' path='docs/doc[@for="XmlSchemaSimpleContentRestriction.BaseTypeName"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlAttribute("base")]
        public XmlQualifiedName BaseTypeName { 
            get { return baseTypeName; }
            set { baseTypeName = (value == null ? XmlQualifiedName.Empty : value); }
        }
        
        /// <include file='doc\XmlSchemaSimpleContentRestriction.uex' path='docs/doc[@for="XmlSchemaSimpleContentRestriction.BaseType"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlElement("simpleType", typeof(XmlSchemaSimpleType))]
        public XmlSchemaSimpleType BaseType { 
            get { return baseType; }
            set { baseType = value; }
        }
        
        /// <include file='doc\XmlSchemaSimpleContentRestriction.uex' path='docs/doc[@for="XmlSchemaSimpleContentRestriction.Facets"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlElement("length", typeof(XmlSchemaLengthFacet)),
         XmlElement("minLength", typeof(XmlSchemaMinLengthFacet)),
         XmlElement("maxLength", typeof(XmlSchemaMaxLengthFacet)),
         XmlElement("pattern", typeof(XmlSchemaPatternFacet)),
         XmlElement("enumeration", typeof(XmlSchemaEnumerationFacet)),
         XmlElement("maxInclusive", typeof(XmlSchemaMaxInclusiveFacet)),
         XmlElement("maxExclusive", typeof(XmlSchemaMaxExclusiveFacet)),
         XmlElement("minInclusive", typeof(XmlSchemaMinInclusiveFacet)),
         XmlElement("minExclusive", typeof(XmlSchemaMinExclusiveFacet)),
         XmlElement("totalDigits", typeof(XmlSchemaTotalDigitsFacet)),
         XmlElement("fractionDigits", typeof(XmlSchemaFractionDigitsFacet)),
         XmlElement("whiteSpace", typeof(XmlSchemaWhiteSpaceFacet))]
        public XmlSchemaObjectCollection Facets {
            get { return facets; }
        }

        /// <include file='doc\XmlSchemaSimpleContentRestriction.uex' path='docs/doc[@for="XmlSchemaSimpleContentRestriction.Attributes"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlElement("attribute", typeof(XmlSchemaAttribute)),
         XmlElement("attributeGroup", typeof(XmlSchemaAttributeGroupRef))]
        public XmlSchemaObjectCollection Attributes {
            get { return attributes; }
        }

        /// <include file='doc\XmlSchemaSimpleContentRestriction.uex' path='docs/doc[@for="XmlSchemaSimpleContentRestriction.AnyAttribute"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlElement("anyAttribute")]
        public XmlSchemaAnyAttribute AnyAttribute {
            get { return anyAttribute; }
            set { anyAttribute = value; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\schema\xmlschemasimpletype.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlSchemaSimpleType.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Schema {
    
    using System.Collections;
    using System.ComponentModel;
    using System.Xml.Serialization;
    using System.Xml;

    /// <include file='doc\XmlSchemaSimpleType.uex' path='docs/doc[@for="XmlSchemaSimpleType"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public class XmlSchemaSimpleType : XmlSchemaType {
        XmlSchemaSimpleTypeContent content;
        
        /// <include file='doc\XmlSchemaSimpleType.uex' path='docs/doc[@for="XmlSchemaSimpleType.Content"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlElement("restriction", typeof(XmlSchemaSimpleTypeRestriction)), 
         XmlElement("list", typeof(XmlSchemaSimpleTypeList)),
         XmlElement("union", typeof(XmlSchemaSimpleTypeUnion))]
        public XmlSchemaSimpleTypeContent Content { 
            get { return content; }
            set { content = value; }
        }

        internal override XmlQualifiedName DerivedFrom {
            get {
                if (content == null) {
                    // type derived from anyType
                    return XmlQualifiedName.Empty;
                }
                if (content is XmlSchemaSimpleTypeRestriction) {
                    return ((XmlSchemaSimpleTypeRestriction)content).BaseTypeName;
                }
                return XmlQualifiedName.Empty;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\schema\xmlschemasimplecontentextension.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlSchemaSimpleContentExtension.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Schema {

    using System.Collections;
    using System.ComponentModel;
    using System.Xml.Serialization;

    /// <include file='doc\XmlSchemaSimpleContentExtension.uex' path='docs/doc[@for="XmlSchemaSimpleContentExtension"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public class XmlSchemaSimpleContentExtension : XmlSchemaContent {
        XmlSchemaObjectCollection attributes = new XmlSchemaObjectCollection();
        XmlSchemaAnyAttribute anyAttribute;
        XmlQualifiedName baseTypeName = XmlQualifiedName.Empty; 

        /// <include file='doc\XmlSchemaSimpleContentExtension.uex' path='docs/doc[@for="XmlSchemaSimpleContentExtension.BaseTypeName"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlAttribute("base")]
        public XmlQualifiedName BaseTypeName { 
            get { return baseTypeName; }
            set { baseTypeName = (value == null ? XmlQualifiedName.Empty : value); }
        }

        /// <include file='doc\XmlSchemaSimpleContentExtension.uex' path='docs/doc[@for="XmlSchemaSimpleContentExtension.Attributes"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlElement("attribute", typeof(XmlSchemaAttribute)),
         XmlElement("attributeGroup", typeof(XmlSchemaAttributeGroupRef))]
        public XmlSchemaObjectCollection Attributes {
            get { return attributes; }
        }

        /// <include file='doc\XmlSchemaSimpleContentExtension.uex' path='docs/doc[@for="XmlSchemaSimpleContentExtension.AnyAttribute"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlElement("anyAttribute")]
        public XmlSchemaAnyAttribute AnyAttribute {
            get { return anyAttribute; }
            set { anyAttribute = value; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\schema\xmlschemasimpletypecontent.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlSchemaSimpleTypeContent.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Schema {
    using System.ComponentModel;
    using System.Xml.Serialization;

    /// <include file='doc\XmlSchemaSimpleTypeContent.uex' path='docs/doc[@for="XmlSchemaSimpleTypeContent"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public abstract class XmlSchemaSimpleTypeContent : XmlSchemaAnnotated {
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\schema\xmlschemasimpletyperestriction.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlSchemaSimpleTypeRestriction.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

namespace System.Xml.Schema {

    using System.Collections;
    using System.Xml.Serialization;

    /// <include file='doc\XmlSchemaSimpleTypeRestriction.uex' path='docs/doc[@for="XmlSchemaSimpleTypeRestriction"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public class XmlSchemaSimpleTypeRestriction : XmlSchemaSimpleTypeContent {
        XmlQualifiedName baseTypeName = XmlQualifiedName.Empty;
        XmlSchemaSimpleType baseType;
        XmlSchemaObjectCollection facets = new XmlSchemaObjectCollection();

        /// <include file='doc\XmlSchemaSimpleTypeRestriction.uex' path='docs/doc[@for="XmlSchemaSimpleTypeRestriction.BaseTypeName"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlAttribute("base")]
        public XmlQualifiedName BaseTypeName {
            get { return baseTypeName; }
            set { baseTypeName = (value == null ? XmlQualifiedName.Empty : value); }
        }

        /// <include file='doc\XmlSchemaSimpleTypeRestriction.uex' path='docs/doc[@for="XmlSchemaSimpleTypeRestriction.BaseType"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlElement("simpleType", typeof(XmlSchemaSimpleType))]
        public XmlSchemaSimpleType BaseType {
            get { return baseType; }
            set { baseType = value; }
        }

        /// <include file='doc\XmlSchemaSimpleTypeRestriction.uex' path='docs/doc[@for="XmlSchemaSimpleTypeRestriction.Facets"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlElement("length", typeof(XmlSchemaLengthFacet)),
         XmlElement("minLength", typeof(XmlSchemaMinLengthFacet)),
         XmlElement("maxLength", typeof(XmlSchemaMaxLengthFacet)),
         XmlElement("pattern", typeof(XmlSchemaPatternFacet)),
         XmlElement("enumeration", typeof(XmlSchemaEnumerationFacet)),
         XmlElement("maxInclusive", typeof(XmlSchemaMaxInclusiveFacet)),
         XmlElement("maxExclusive", typeof(XmlSchemaMaxExclusiveFacet)),
         XmlElement("minInclusive", typeof(XmlSchemaMinInclusiveFacet)),
         XmlElement("minExclusive", typeof(XmlSchemaMinExclusiveFacet)),
         XmlElement("totalDigits", typeof(XmlSchemaTotalDigitsFacet)),
         XmlElement("fractionDigits", typeof(XmlSchemaFractionDigitsFacet)),
         XmlElement("whiteSpace", typeof(XmlSchemaWhiteSpaceFacet))]
        public XmlSchemaObjectCollection Facets {
            get { return facets; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\schema\xmlschemauri.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlSchemaNotation.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Schema {

    using System.Collections;
    using System.ComponentModel;
    using System.Xml.Serialization;

    /// <include file='doc\XmlSchemaNotation.uex' path='docs/doc[@for="XmlSchemaUri"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    internal class XmlSchemaUri : Uri {
        string rawValue;
		bool isAbsolute = false;

        public XmlSchemaUri(string s, bool isAbsolute) : base((isAbsolute ? s : "anyuri:" + s), true) {
			this.rawValue = s;
			this.isAbsolute = isAbsolute;
		}
		
		public bool Equals(XmlSchemaUri uri) {
			return ((this.isAbsolute == uri.isAbsolute) && base.Equals(uri));
        }
		 
        public override string ToString() {
            return rawValue;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\schema\xmlschematype.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlSchemaType.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Schema {

    using System.Collections;
    using System.ComponentModel;
    using System.Xml.Serialization;

    /// <include file='doc\XmlSchemaType.uex' path='docs/doc[@for="XmlSchemaType"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public class XmlSchemaType : XmlSchemaAnnotated {
        string name;
        XmlSchemaDerivationMethod final = XmlSchemaDerivationMethod.None;
        XmlSchemaDerivationMethod derivedBy;
        object baseSchemaType;
        XmlSchemaDatatype datatype;
        XmlSchemaDerivationMethod finalResolved;
        SchemaElementDecl elementDecl;
        XmlQualifiedName qname = XmlQualifiedName.Empty; 
        XmlSchemaType redefined;
        bool validating;

        /// <include file='doc\XmlSchemaType.uex' path='docs/doc[@for="XmlSchemaType.Name"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlAttribute("name")]
        public string Name { 
            get { return name; }
            set { name = value; }
        }

        /// <include file='doc\XmlSchemaType.uex' path='docs/doc[@for="XmlSchemaType.Final"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlAttribute("final"), DefaultValue(XmlSchemaDerivationMethod.None)]
        public XmlSchemaDerivationMethod Final {
             get { return final; }
             set { final = value; }
        }

        /// <include file='doc\XmlSchemaType.uex' path='docs/doc[@for="XmlSchemaType.QualifiedName"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlIgnore]
        public XmlQualifiedName QualifiedName {
            get { return qname; }
        }

        /// <include file='doc\XmlSchemaType.uex' path='docs/doc[@for="XmlSchemaType.FinalResolved"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlIgnore]
        public XmlSchemaDerivationMethod FinalResolved {
             get { return finalResolved; }
        }

        /// <include file='doc\XmlSchemaType.uex' path='docs/doc[@for="XmlSchemaType.BaseSchemaType"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlIgnore]
        public object BaseSchemaType {
            get { return baseSchemaType;}
        }

        /// <include file='doc\XmlSchemaType.uex' path='docs/doc[@for="XmlSchemaType.DerivedBy"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlIgnore]
        public XmlSchemaDerivationMethod DerivedBy {
            get { return derivedBy; }
        }

        /// <include file='doc\XmlSchemaType.uex' path='docs/doc[@for="XmlSchemaType.Datatype"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlIgnore]
        public XmlSchemaDatatype Datatype {
            get { return datatype;}
        }

        /// <include file='doc\XmlSchemaType.uex' path='docs/doc[@for="XmlSchemaType.IsMixed"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlIgnore]
        public virtual bool IsMixed {
            get { return false; }
            set {;}
        }

        internal void SetQualifiedName(XmlQualifiedName value) {
            qname = value;
        }

        internal void SetFinalResolved(XmlSchemaDerivationMethod value) {
             finalResolved = value; 
        }

        internal void SetBaseSchemaType(object value) { 
            baseSchemaType = value;
        }

        internal void SetDerivedBy(XmlSchemaDerivationMethod value) { 
            derivedBy = value;
        }

        internal void SetDatatype(XmlSchemaDatatype value) { 
            datatype = value;
        }

        internal SchemaElementDecl ElementDecl {
            get { return elementDecl; }
            set { elementDecl = value; }
        }

        [XmlIgnore]
        internal XmlSchemaType Redefined {
            get { return redefined; }
            set { redefined = value; }
        }

        [XmlIgnore]
        internal bool Validating {
            get { return validating; }
            set { validating = value; }
        }

        internal virtual XmlQualifiedName DerivedFrom {
            get { return XmlQualifiedName.Empty; }
        }

        internal static bool IsDerivedFrom(object derivedType, object baseType, XmlSchemaDerivationMethod except) {
            if (derivedType == baseType) {
                return true;
            }
            if (baseType == XmlSchemaComplexType.AnyType) {
                return true;
            }
            if (derivedType is XmlSchemaDatatype) {
                if ((except & XmlSchemaDerivationMethod.Restriction) != 0) {
                    return false;
                }
                return IsDerivedFromDatatype(derivedType, baseType, except);
            }
            else if (derivedType is XmlSchemaType) {
                XmlSchemaType derivedSchemaType = (XmlSchemaType)derivedType;
                XmlSchemaType baseSchemaType = baseType as XmlSchemaType;
                if (baseSchemaType != null) {
                    return IsDerivedFromBaseType(derivedSchemaType, baseSchemaType, except);
                }
                else {
                    if ((except & derivedSchemaType.DerivedBy) != 0) {
                        return false;
                    }
                    return IsDerivedFromDatatype(derivedSchemaType.Datatype, baseType, except);
                }
            }
            return false;
        }

        private static bool IsDerivedFromBaseType(XmlSchemaType derivedType, XmlSchemaType baseType, XmlSchemaDerivationMethod except) {
            do {
                if ((except & derivedType.DerivedBy) != 0) {
                    return false;
                }
                object[] types = derivedType.BaseSchemaType as object[];
                if (types != null) { // union
                    foreach (object type in types) {
                        if (IsDerivedFrom(type, baseType, except)) {
                            return true;
                        }
                    }
                    return false;
                }
                derivedType = derivedType.BaseSchemaType as XmlSchemaType;
                if (derivedType == baseType) {
                    return true;
                }
            } while(derivedType != null);
            return false;
        }

        private static bool IsDerivedFromDatatype(object derivedType, object baseType, XmlSchemaDerivationMethod except) {
            if (XmlSchemaDatatype.AnyType == baseType) {
                return true;
            }
            XmlSchemaDatatype dtDerived = derivedType as XmlSchemaDatatype;
            if (dtDerived == null) {
                return false;
            }
            XmlSchemaDatatype dtBase = baseType as XmlSchemaDatatype;
            if (dtBase == null) {
                return false;
            }
            return dtDerived.IsDerivedFrom(dtBase);
        }

        [XmlIgnore]
        internal override string NameAttribute {
            get { return Name; }
            set { Name = value; }
        }
	}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\schema\xmlschemasimpletypelist.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlSchemaSimpleTypeList.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Schema {

    using System.Collections;
    using System.ComponentModel;
    using System.Xml.Serialization;

    /// <include file='doc\XmlSchemaSimpleTypeList.uex' path='docs/doc[@for="XmlSchemaSimpleTypeList"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public class XmlSchemaSimpleTypeList : XmlSchemaSimpleTypeContent {
        XmlQualifiedName itemTypeName = XmlQualifiedName.Empty; 
        XmlSchemaSimpleType itemType;
        
        /// <include file='doc\XmlSchemaSimpleTypeList.uex' path='docs/doc[@for="XmlSchemaSimpleTypeList.ItemTypeName"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlAttribute("itemType")]
        public XmlQualifiedName ItemTypeName { 
            get { return itemTypeName; }
            set { itemTypeName = (value == null ? XmlQualifiedName.Empty : value); }
        }

        /// <include file='doc\XmlSchemaSimpleTypeList.uex' path='docs/doc[@for="XmlSchemaSimpleTypeList.BaseType"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlElement("simpleType", typeof(XmlSchemaSimpleType))]
        public XmlSchemaSimpleType ItemType {
            get { return itemType; }
            set { itemType = value; }
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\schema\xmlschemause.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlSchemaUse.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Schema {

    using System.Collections;
    using System.ComponentModel;
    using System.Xml.Serialization;

    //nzeng: if change the enum, have to change xsdbuilder as well.
    /// <include file='doc\XmlSchemaUse.uex' path='docs/doc[@for="XmlSchemaUse"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public enum XmlSchemaUse {
        /// <include file='doc\XmlSchemaUse.uex' path='docs/doc[@for="XmlSchemaUse.None"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlIgnore]
        None,
        /// <include file='doc\XmlSchemaUse.uex' path='docs/doc[@for="XmlSchemaUse.Optional"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlEnum("optional")]
        Optional,
        /// <include file='doc\XmlSchemaUse.uex' path='docs/doc[@for="XmlSchemaUse.Prohibited"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlEnum("prohibited")]
        Prohibited,
        /// <include file='doc\XmlSchemaUse.uex' path='docs/doc[@for="XmlSchemaUse.Required"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlEnum("required")]
        Required,
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\schema\xmlschemasimpletypeunion.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlSchemaSimpleTypeUnion.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Schema {

    using System.Collections;
    using System.ComponentModel;
    using System.Xml.Serialization;

    /// <include file='doc\XmlSchemaSimpleTypeUnion.uex' path='docs/doc[@for="XmlSchemaSimpleTypeUnion"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public class XmlSchemaSimpleTypeUnion : XmlSchemaSimpleTypeContent {
        XmlSchemaObjectCollection baseTypes = new XmlSchemaObjectCollection();
        XmlQualifiedName[] memberTypes;

        /// <include file='doc\XmlSchemaSimpleTypeUnion.uex' path='docs/doc[@for="XmlSchemaSimpleTypeUnion.BaseTypes"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [XmlElement("simpleType", typeof(XmlSchemaSimpleType))]
        public XmlSchemaObjectCollection BaseTypes {
            get { return baseTypes; }
        }

        /// <include file='doc\XmlSchemaSimpleTypeUnion.uex' path='docs/doc[@for="XmlSchemaSimpleTypeUnion.MemberTypes"]/*' />
        [XmlAttribute("memberTypes")]
        public XmlQualifiedName[] MemberTypes {
            get { return memberTypes; }
            set { memberTypes = value; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\schema\xmlschemasubstitutiongroup.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlSchemaSubstitutionGroup.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Schema {

    using System.Collections;
    using System.ComponentModel;
    using System.Xml.Serialization;

    internal class XmlSchemaSubstitutionGroup : XmlSchemaObject {
        Hashtable members = new Hashtable();
        XmlQualifiedName examplar = XmlQualifiedName.Empty;
        XmlSchemaChoice choice = new XmlSchemaChoice();
        bool validating = false;

        [XmlIgnore]
        internal Hashtable Members {
            get { return members; }
        } 

        [XmlIgnore]
        internal XmlQualifiedName Examplar {
            get { return examplar; }
            set { examplar = value; }
        }
        
        [XmlIgnore]
        internal XmlSchemaChoice Choice {
            get { return choice; }
            set { choice = value; }
        }          

        [XmlIgnore]
        internal bool Validating {
            get { return validating; }
            set { validating = value; }
        } 
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\schema\xmlseveritytype.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlSeverityType.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Schema {
    //UE Atention
    /// <include file='doc\XmlSeverityType.uex' path='docs/doc[@for="XmlSeverityType"]/*' />
    public enum XmlSeverityType {
        /// Errors that can be recovered from. 
        /// <include file='doc\XmlSeverityType.uex' path='docs/doc[@for="XmlSeverityType.Error"]/*' />
        Error,
        /// Errors that can be ignored
        /// <include file='doc\XmlSeverityType.uex' path='docs/doc[@for="XmlSeverityType.Warning"]/*' />
        Warning
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\schema\xsdbuilder.cs ===
//------------------------------------------------------------------------------
// <copyright file="XsdBuilder.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Schema {

    using System;
    using System.IO;
    using System.Collections;
    using System.Diagnostics;
    using System.ComponentModel;
    using System.Xml;
    using System.Xml.Serialization;

    internal sealed class XsdBuilder : SchemaBuilder {
        private enum State {
            Root,
            Schema,
            Annotation,
            Include,
            Import,
            Element,
            Attribute,
            AttributeGroup,
            AttributeGroupRef,
            AnyAttribute,
            Group,
            GroupRef,
            All,
            Choice,
            Sequence,
            Any,
            Notation,
            SimpleType,
            ComplexType,
            ComplexContent,
            ComplexContentRestriction,
            ComplexContentExtension,
            SimpleContent,
            SimpleContentExtension,
            SimpleContentRestriction,
            SimpleTypeUnion,
            SimpleTypeList,
            SimpleTypeRestriction,
            Unique,
            Key,
            KeyRef,
            Selector,
            Field,
            MinExclusive,
            MinInclusive,
            MaxExclusive,
            MaxInclusive,
            TotalDigits,
            FractionDigits,
            Length,
            MinLength,
            MaxLength,
            Enumeration,
            Pattern,
            WhiteSpace,
            AppInfo,
            Documentation,
            Redefine,
        }
        private const int STACK_INCREMENT         = 10;

        private delegate void XsdBuildFunction(XsdBuilder builder, string value);
        private delegate void XsdInitFunction(XsdBuilder builder, string value);
        private delegate void XsdBeginChildFunction(XsdBuilder builder);
        private delegate void XsdEndChildFunction(XsdBuilder builder);

        private sealed class XsdAttributeEntry {
            public SchemaNames.ID Attribute;               // possible attribute names
            public XsdBuildFunction BuildFunc;  // Corresponding build functions for attribute value

            public XsdAttributeEntry(SchemaNames.ID a, XsdBuildFunction build) {
                Attribute = a;
                BuildFunc = build;
            }
        };

        //
        // XsdEntry controls the states of parsing a schema document
        // and calls the corresponding "init", "end" and "build" functions when necessary
        //
        private sealed class XsdEntry {
            public SchemaNames.ID Name;                  // the name of the object it is comparing to
            public State CurrentState;                     
            public State[] NextStates;                   // possible next states
            public XsdAttributeEntry[] Attributes;       // allowed attributes
            public XsdInitFunction InitFunc;             // "init" functions in XsdBuilder
            public XsdBeginChildFunction BeginChildFunc; // "begin" functions in XsdBuilder for BeginChildren
            public XsdEndChildFunction EndChildFunc;     // "end" functions in XsdBuilder for EndChildren
            public bool ParseContent;                       // whether text content is allowed  

            public XsdEntry(SchemaNames.ID n, 
                            State   state, 
                            State[] nextStates, 
                            XsdAttributeEntry[] attributes, 
                            XsdInitFunction init, 
                            XsdBeginChildFunction begin, 
                            XsdEndChildFunction end, 
                            bool parseContent) {
                Name = n;
                CurrentState = state;
                NextStates = nextStates;
                Attributes = attributes;
                InitFunc = init;
                BeginChildFunc = begin;
                EndChildFunc = end;
                ParseContent = parseContent; 
            }
        };


        //////////////////////////////////////////////////////////////////////////////////////////////
        // Data structures for XSD Schema, Sept 2000 version
        //

        //
        //Elements
        //
        private static readonly State[] SchemaElement = {   
            State.Schema};
        private static readonly State[] SchemaSubelements = {   
            State.Annotation, State.Include, State.Import, State.Redefine,
            State.ComplexType, State.SimpleType, State.Element, State.Attribute,
            State.AttributeGroup, State.Group, State.Notation}; 
        private static readonly State[] AttributeSubelements = { 
            State.Annotation, State.SimpleType};
        private static readonly State[] ElementSubelements   = { 
            State.Annotation, State.SimpleType, State.ComplexType,
            State.Unique, State.Key, State.KeyRef};
        private static readonly State[] ComplexTypeSubelements = {
            State.Annotation, State.SimpleContent, State.ComplexContent,
            State.GroupRef, State.All, State.Choice, State.Sequence, 
            State.Attribute, State.AttributeGroupRef, State.AnyAttribute};
        private static readonly State[] SimpleContentSubelements = { 
            State.Annotation, State.SimpleContentRestriction, State.SimpleContentExtension };
        private static readonly State[] SimpleContentExtensionSubelements = { 
            State.Annotation, State.Attribute, State.AttributeGroupRef, State.AnyAttribute};
        private static readonly State[] SimpleContentRestrictionSubelements = { 
            State.Annotation, State.SimpleType,  
            State.Enumeration, State.Length, State.MaxExclusive, State.MaxInclusive, State.MaxLength, State.MinExclusive, 
            State.MinInclusive, State.MinLength, State.Pattern, State.TotalDigits, State.FractionDigits, State.WhiteSpace, 
            State.Attribute, State.AttributeGroupRef, State.AnyAttribute};
        private static readonly State[] ComplexContentSubelements = { 
            State.Annotation, State.ComplexContentRestriction, State.ComplexContentExtension };
        private static readonly State[] ComplexContentExtensionSubelements = { 
            State.Annotation, State.GroupRef, State.All, State.Choice, State.Sequence, 
            State.Attribute, State.AttributeGroupRef, State.AnyAttribute};
        private static readonly State[] ComplexContentRestrictionSubelements = { 
            State.Annotation, State.GroupRef, State.All, State.Choice, State.Sequence, 
            State.Attribute, State.AttributeGroupRef, State.AnyAttribute};
        private static readonly State[] SimpleTypeSubelements   = { 
            State.Annotation, State.SimpleTypeList, State.SimpleTypeRestriction, State.SimpleTypeUnion};
        private static readonly State[] SimpleTypeRestrictionSubelements   = { 
            State.Annotation, State.SimpleType, 
            State.Enumeration, State.Length, State.MaxExclusive, State.MaxInclusive, State.MaxLength, State.MinExclusive, 
            State.MinInclusive, State.MinLength, State.Pattern, State.TotalDigits, State.FractionDigits, State.WhiteSpace};
        private static readonly State[] SimpleTypeListSubelements   = { 
            State.Annotation, State.SimpleType};
        private static readonly State[] SimpleTypeUnionSubelements   = { 
            State.Annotation, State.SimpleType};
        private static readonly State[] RedefineSubelements   = { 
            State.Annotation, State.AttributeGroup, State.ComplexType, State.Group, State.SimpleType };
        private static readonly State[] AttributeGroupSubelements = { 
            State.Annotation, State.Attribute, State.AttributeGroupRef, State.AnyAttribute};
        private static readonly State[] GroupSubelements = { 
            State.Annotation, State.All, State.Choice, State.Sequence};
        private static readonly State[] AllSubelements = { 
            State.Annotation, State.Element};
        private static readonly State[] ChoiceSequenceSubelements = { 
            State.Annotation, State.Element, State.GroupRef, State.Choice, State.Sequence, State.Any};
        private static readonly State[] IdentityConstraintSubelements = { 
            State.Annotation, State.Selector, State.Field};
        private static readonly State[] AnnotationSubelements = { 
            State.AppInfo, State.Documentation};
        private static readonly State[] AnnotatedSubelements = {
            State.Annotation}; 


        //
        //Attributes
        //
        private static readonly XsdAttributeEntry[] SchemaAttributes = {
            new XsdAttributeEntry(SchemaNames.ID.SCHEMA_ATTRIBUTEFORMDEFAULT,   new XsdBuildFunction(BuildSchema_AttributeFormDefault) ),
            new XsdAttributeEntry(SchemaNames.ID.SCHEMA_ELEMENTFORMDEFAULT,     new XsdBuildFunction(BuildSchema_ElementFormDefault) ),
            new XsdAttributeEntry(SchemaNames.ID.SCHEMA_TARGETNAMESPACE,        new XsdBuildFunction(BuildSchema_TargetNamespace) ),
            new XsdAttributeEntry(SchemaNames.ID.SCHEMA_ID,                     new XsdBuildFunction(BuildAnnotated_Id) ),
            new XsdAttributeEntry(SchemaNames.ID.SCHEMA_VERSION,                new XsdBuildFunction(BuildSchema_Version) ),
            new XsdAttributeEntry(SchemaNames.ID.SCHEMA_FINALDEFAULT,           new XsdBuildFunction(BuildSchema_FinalDefault) ),
            new XsdAttributeEntry(SchemaNames.ID.SCHEMA_BLOCKDEFAULT,           new XsdBuildFunction(BuildSchema_BlockDefault) )
        };

        private static readonly XsdAttributeEntry[] AttributeAttributes = {
            new XsdAttributeEntry(SchemaNames.ID.SCHEMA_DEFAULT,                new XsdBuildFunction(BuildAttribute_Default) ),
            new XsdAttributeEntry(SchemaNames.ID.SCHEMA_FIXED,                  new XsdBuildFunction(BuildAttribute_Fixed) ),
            new XsdAttributeEntry(SchemaNames.ID.SCHEMA_FORM,                   new XsdBuildFunction(BuildAttribute_Form) ),
            new XsdAttributeEntry(SchemaNames.ID.SCHEMA_ID,                     new XsdBuildFunction(BuildAnnotated_Id) ),
            new XsdAttributeEntry(SchemaNames.ID.SCHEMA_NAME,                   new XsdBuildFunction(BuildAttribute_Name) ),       
            new XsdAttributeEntry(SchemaNames.ID.SCHEMA_REF,                    new XsdBuildFunction(BuildAttribute_Ref) ),
            new XsdAttributeEntry(SchemaNames.ID.SCHEMA_TYPE,                   new XsdBuildFunction(BuildAttribute_Type) ),
            new XsdAttributeEntry(SchemaNames.ID.SCHEMA_USE,                    new XsdBuildFunction(BuildAttribute_Use) )
        };

        private static readonly XsdAttributeEntry[] ElementAttributes = {
            new XsdAttributeEntry(SchemaNames.ID.SCHEMA_ABSTRACT,               new XsdBuildFunction(BuildElement_Abstract) ),
            new XsdAttributeEntry(SchemaNames.ID.SCHEMA_BLOCK,                  new XsdBuildFunction(BuildElement_Block) ),
            new XsdAttributeEntry(SchemaNames.ID.SCHEMA_DEFAULT,                new XsdBuildFunction(BuildElement_Default) ),
            new XsdAttributeEntry(SchemaNames.ID.SCHEMA_FINAL,                  new XsdBuildFunction(BuildElement_Final) ),
            new XsdAttributeEntry(SchemaNames.ID.SCHEMA_FIXED,                  new XsdBuildFunction(BuildElement_Fixed) ),
            new XsdAttributeEntry(SchemaNames.ID.SCHEMA_FORM,                   new XsdBuildFunction(BuildElement_Form) ),
            new XsdAttributeEntry(SchemaNames.ID.SCHEMA_ID,                     new XsdBuildFunction(BuildAnnotated_Id) ),
            new XsdAttributeEntry(SchemaNames.ID.SCHEMA_MAXOCCURS,              new XsdBuildFunction(BuildElement_MaxOccurs) ),
            new XsdAttributeEntry(SchemaNames.ID.SCHEMA_MINOCCURS,              new XsdBuildFunction(BuildElement_MinOccurs) ),
            new XsdAttributeEntry(SchemaNames.ID.SCHEMA_NAME,                   new XsdBuildFunction(BuildElement_Name) ),
            new XsdAttributeEntry(SchemaNames.ID.SCHEMA_NILLABLE,               new XsdBuildFunction(BuildElement_Nillable) ),
            new XsdAttributeEntry(SchemaNames.ID.SCHEMA_REF,                    new XsdBuildFunction(BuildElement_Ref) ),
            new XsdAttributeEntry(SchemaNames.ID.SCHEMA_SUBSTITUTIONGROUP,      new XsdBuildFunction(BuildElement_SubstitutionGroup) ),
            new XsdAttributeEntry(SchemaNames.ID.SCHEMA_TYPE,                   new XsdBuildFunction(BuildElement_Type) )
        };

        private static readonly XsdAttributeEntry[] ComplexTypeAttributes = {
            new XsdAttributeEntry(SchemaNames.ID.SCHEMA_ABSTRACT,               new XsdBuildFunction(BuildComplexType_Abstract) ),
            new XsdAttributeEntry(SchemaNames.ID.SCHEMA_BLOCK,                  new XsdBuildFunction(BuildComplexType_Block) ),
            new XsdAttributeEntry(SchemaNames.ID.SCHEMA_FINAL,                  new XsdBuildFunction(BuildComplexType_Final) ),
            new XsdAttributeEntry(SchemaNames.ID.SCHEMA_ID,                     new XsdBuildFunction(BuildAnnotated_Id) ),
            new XsdAttributeEntry(SchemaNames.ID.SCHEMA_MIXED,                  new XsdBuildFunction(BuildComplexType_Mixed) ),
            new XsdAttributeEntry(SchemaNames.ID.SCHEMA_NAME,                   new XsdBuildFunction(BuildComplexType_Name) )
        };

        private static readonly XsdAttributeEntry[] SimpleContentAttributes = {
            new XsdAttributeEntry(SchemaNames.ID.SCHEMA_ID,                     new XsdBuildFunction(BuildAnnotated_Id) ),
        };

        private static readonly XsdAttributeEntry[] SimpleContentExtensionAttributes = {
            new XsdAttributeEntry(SchemaNames.ID.SCHEMA_BASE,                   new XsdBuildFunction(BuildSimpleContentExtension_Base) ),
            new XsdAttributeEntry(SchemaNames.ID.SCHEMA_ID,                     new XsdBuildFunction(BuildAnnotated_Id) )
        };

        private static readonly XsdAttributeEntry[] SimpleContentRestrictionAttributes = {
            new XsdAttributeEntry(SchemaNames.ID.SCHEMA_BASE,                   new XsdBuildFunction(BuildSimpleContentRestriction_Base) ),
            new XsdAttributeEntry(SchemaNames.ID.SCHEMA_ID,                     new XsdBuildFunction(BuildAnnotated_Id) ),
        };

        private static readonly XsdAttributeEntry[] ComplexContentAttributes = {
            new XsdAttributeEntry(SchemaNames.ID.SCHEMA_ID,                     new XsdBuildFunction(BuildAnnotated_Id) ),
            new XsdAttributeEntry(SchemaNames.ID.SCHEMA_MIXED,                  new XsdBuildFunction(BuildComplexContent_Mixed) ),
        };

        private static readonly XsdAttributeEntry[] ComplexContentExtensionAttributes = {
            new XsdAttributeEntry(SchemaNames.ID.SCHEMA_BASE,                   new XsdBuildFunction(BuildComplexContentExtension_Base) ),
            new XsdAttributeEntry(SchemaNames.ID.SCHEMA_ID,                     new XsdBuildFunction(BuildAnnotated_Id) ),
        };

        private static readonly XsdAttributeEntry[] ComplexContentRestrictionAttributes = {
            new XsdAttributeEntry(SchemaNames.ID.SCHEMA_BASE,                   new XsdBuildFunction(BuildComplexContentRestriction_Base) ),
            new XsdAttributeEntry(SchemaNames.ID.SCHEMA_ID,                     new XsdBuildFunction(BuildAnnotated_Id) ),
        };

        private static readonly XsdAttributeEntry[] SimpleTypeAttributes = {
            new XsdAttributeEntry(SchemaNames.ID.SCHEMA_ID,                     new XsdBuildFunction(BuildAnnotated_Id) ),
            new XsdAttributeEntry(SchemaNames.ID.SCHEMA_FINAL,                  new XsdBuildFunction(BuildSimpleType_Final) ),
            new XsdAttributeEntry(SchemaNames.ID.SCHEMA_NAME,                   new XsdBuildFunction(BuildSimpleType_Name) )
        };

        private static readonly XsdAttributeEntry[] SimpleTypeRestrictionAttributes = {
            new XsdAttributeEntry(SchemaNames.ID.SCHEMA_BASE,                   new XsdBuildFunction(BuildSimpleTypeRestriction_Base) ),
            new XsdAttributeEntry(SchemaNames.ID.SCHEMA_ID,                     new XsdBuildFunction(BuildAnnotated_Id) ),
        };

        private static readonly XsdAttributeEntry[] SimpleTypeUnionAttributes = {
            new XsdAttributeEntry(SchemaNames.ID.SCHEMA_ID,                     new XsdBuildFunction(BuildAnnotated_Id) ),
            new XsdAttributeEntry(SchemaNames.ID.SCHEMA_MEMBERTYPES,            new XsdBuildFunction(BuildSimpleTypeUnion_MemberTypes) ),
        };

        private static readonly XsdAttributeEntry[] SimpleTypeListAttributes = {
            new XsdAttributeEntry(SchemaNames.ID.SCHEMA_ID,                     new XsdBuildFunction(BuildAnnotated_Id) ),
            new XsdAttributeEntry(SchemaNames.ID.SCHEMA_ITEMTYPE,               new XsdBuildFunction(BuildSimpleTypeList_ItemType) ),
        };

        private static readonly XsdAttributeEntry[] AttributeGroupAttributes = {
            new XsdAttributeEntry(SchemaNames.ID.SCHEMA_ID,                     new XsdBuildFunction(BuildAnnotated_Id) ),
            new XsdAttributeEntry(SchemaNames.ID.SCHEMA_NAME,                   new XsdBuildFunction(BuildAttributeGroup_Name) ),
        };

        private static readonly XsdAttributeEntry[] AttributeGroupRefAttributes = {
            new XsdAttributeEntry(SchemaNames.ID.SCHEMA_ID,                     new XsdBuildFunction(BuildAnnotated_Id) ),
            new XsdAttributeEntry(SchemaNames.ID.SCHEMA_REF,                    new XsdBuildFunction(BuildAttributeGroupRef_Ref) )
        };

        private static readonly XsdAttributeEntry[] GroupAttributes = {
            new XsdAttributeEntry(SchemaNames.ID.SCHEMA_ID,                     new XsdBuildFunction(BuildAnnotated_Id) ),
            new XsdAttributeEntry(SchemaNames.ID.SCHEMA_NAME,                   new XsdBuildFunction(BuildGroup_Name) ),
        };

        private static readonly XsdAttributeEntry[] GroupRefAttributes = {
            new XsdAttributeEntry(SchemaNames.ID.SCHEMA_ID,                     new XsdBuildFunction(BuildAnnotated_Id) ),
            new XsdAttributeEntry(SchemaNames.ID.SCHEMA_MAXOCCURS,              new XsdBuildFunction(BuildParticle_MaxOccurs) ),
            new XsdAttributeEntry(SchemaNames.ID.SCHEMA_MINOCCURS,              new XsdBuildFunction(BuildParticle_MinOccurs) ),
            new XsdAttributeEntry(SchemaNames.ID.SCHEMA_REF,                    new XsdBuildFunction(BuildGroupRef_Ref) )
        };

        private static readonly XsdAttributeEntry[] ParticleAttributes = {
            new XsdAttributeEntry(SchemaNames.ID.SCHEMA_ID,                     new XsdBuildFunction(BuildAnnotated_Id) ),
            new XsdAttributeEntry(SchemaNames.ID.SCHEMA_MAXOCCURS,              new XsdBuildFunction(BuildParticle_MaxOccurs) ),
            new XsdAttributeEntry(SchemaNames.ID.SCHEMA_MINOCCURS,              new XsdBuildFunction(BuildParticle_MinOccurs) ),
        };


        private static readonly XsdAttributeEntry[] AnyAttributes = {
            new XsdAttributeEntry(SchemaNames.ID.SCHEMA_ID,                     new XsdBuildFunction(BuildAnnotated_Id) ),
            new XsdAttributeEntry(SchemaNames.ID.SCHEMA_MAXOCCURS,              new XsdBuildFunction(BuildParticle_MaxOccurs) ),
            new XsdAttributeEntry(SchemaNames.ID.SCHEMA_MINOCCURS,              new XsdBuildFunction(BuildParticle_MinOccurs) ),
            new XsdAttributeEntry(SchemaNames.ID.SCHEMA_NAMESPACE,              new XsdBuildFunction(BuildAny_Namespace) ),
            new XsdAttributeEntry(SchemaNames.ID.SCHEMA_PROCESSCONTENTS,        new XsdBuildFunction(BuildAny_ProcessContents) )
        };

        private static readonly XsdAttributeEntry[] IdentityConstraintAttributes = {
            new XsdAttributeEntry(SchemaNames.ID.SCHEMA_ID,                     new XsdBuildFunction(BuildAnnotated_Id) ),
            new XsdAttributeEntry(SchemaNames.ID.SCHEMA_NAME,                   new XsdBuildFunction(BuildIdentityConstraint_Name) ), 
            new XsdAttributeEntry(SchemaNames.ID.SCHEMA_REFER,                  new XsdBuildFunction(BuildIdentityConstraint_Refer) ) 
        };

        private static readonly XsdAttributeEntry[] SelectorAttributes = {
            new XsdAttributeEntry(SchemaNames.ID.SCHEMA_ID,                     new XsdBuildFunction(BuildAnnotated_Id) ),
            new XsdAttributeEntry(SchemaNames.ID.SCHEMA_XPATH,                  new XsdBuildFunction(BuildSelector_XPath) ) 
        };

        private static readonly XsdAttributeEntry[] FieldAttributes = {
            new XsdAttributeEntry(SchemaNames.ID.SCHEMA_ID,                     new XsdBuildFunction(BuildAnnotated_Id) ),
            new XsdAttributeEntry(SchemaNames.ID.SCHEMA_XPATH,                  new XsdBuildFunction(BuildField_XPath) ) 
        };

        private static readonly XsdAttributeEntry[] NotationAttributes = {
            new XsdAttributeEntry(SchemaNames.ID.SCHEMA_ID,                     new XsdBuildFunction(BuildAnnotated_Id) ),
            new XsdAttributeEntry(SchemaNames.ID.SCHEMA_NAME,                   new XsdBuildFunction(BuildNotation_Name) ), 
            new XsdAttributeEntry(SchemaNames.ID.SCHEMA_PUBLIC,                 new XsdBuildFunction(BuildNotation_Public) ),
            new XsdAttributeEntry(SchemaNames.ID.SCHEMA_SYSTEM,                 new XsdBuildFunction(BuildNotation_System) ) 
        };

        private static readonly XsdAttributeEntry[] IncludeAttributes = {
            new XsdAttributeEntry(SchemaNames.ID.SCHEMA_ID,                     new XsdBuildFunction(BuildAnnotated_Id) ),
            new XsdAttributeEntry(SchemaNames.ID.SCHEMA_SCHEMALOCATION,         new XsdBuildFunction(BuildInclude_SchemaLocation) )
        };

        private static readonly XsdAttributeEntry[] ImportAttributes = {
            new XsdAttributeEntry(SchemaNames.ID.SCHEMA_ID,                     new XsdBuildFunction(BuildAnnotated_Id) ),
            new XsdAttributeEntry(SchemaNames.ID.SCHEMA_NAMESPACE,              new XsdBuildFunction(BuildImport_Namespace) ),
            new XsdAttributeEntry(SchemaNames.ID.SCHEMA_SCHEMALOCATION,         new XsdBuildFunction(BuildImport_SchemaLocation) )
        };

        private static readonly XsdAttributeEntry[] FacetAttributes = {
            new XsdAttributeEntry(SchemaNames.ID.SCHEMA_ID,                     new XsdBuildFunction(BuildAnnotated_Id) ),
            new XsdAttributeEntry(SchemaNames.ID.SCHEMA_FIXED,                  new XsdBuildFunction(BuildFacet_Fixed) ),
            new XsdAttributeEntry(SchemaNames.ID.SCHEMA_VALUE,                  new XsdBuildFunction(BuildFacet_Value) )
        };

        private static readonly XsdAttributeEntry[] AnyAttributeAttributes = {
            new XsdAttributeEntry(SchemaNames.ID.SCHEMA_ID,                     new XsdBuildFunction(BuildAnnotated_Id) ),
            new XsdAttributeEntry(SchemaNames.ID.SCHEMA_NAMESPACE,              new XsdBuildFunction(BuildAnyAttribute_Namespace) ),
            new XsdAttributeEntry(SchemaNames.ID.SCHEMA_PROCESSCONTENTS,        new XsdBuildFunction(BuildAnyAttribute_ProcessContents) )
        };

        private static readonly XsdAttributeEntry[] DocumentationAttributes = {
            new XsdAttributeEntry(SchemaNames.ID.SCHEMA_SOURCE,                 new XsdBuildFunction(BuildDocumentation_Source) ),
            new XsdAttributeEntry(SchemaNames.ID.XMLLANG,                       new XsdBuildFunction(BuildDocumentation_XmlLang) )
        };

        private static readonly XsdAttributeEntry[] AppinfoAttributes = {
            new XsdAttributeEntry(SchemaNames.ID.SCHEMA_SOURCE,                 new XsdBuildFunction(BuildAppinfo_Source) )
        };

        private static readonly XsdAttributeEntry[] RedefineAttributes = {
            new XsdAttributeEntry(SchemaNames.ID.SCHEMA_ID,                     new XsdBuildFunction(BuildAnnotated_Id) ),
            new XsdAttributeEntry(SchemaNames.ID.SCHEMA_SCHEMALOCATION,         new XsdBuildFunction(BuildRedefine_SchemaLocation) )
        };

        private static readonly XsdAttributeEntry[] AnnotationAttributes = {
            new XsdAttributeEntry(SchemaNames.ID.SCHEMA_ID,                     new XsdBuildFunction(BuildAnnotated_Id) ),
        };
        //
        // XSD Schema entries
        //                        

       private static readonly XsdEntry[] SchemaEntries = {
       /* Root */                       new XsdEntry( SchemaNames.ID.EMPTY, State.Root, SchemaElement, null, 
                                                      null, 
                                                      null, 
                                                      null, 
                                                      true),
       /* Schema */                     new XsdEntry( SchemaNames.ID.XSD_SCHEMA, State.Schema,     SchemaSubelements, SchemaAttributes, 
                                                      new XsdInitFunction(InitSchema), 
                                                      null,
                                                      null,
                                                      true),
       /* Annotation */                 new XsdEntry( SchemaNames.ID.XSD_ANNOTATION, State.Annotation,     AnnotationSubelements, AnnotationAttributes,
                                                      new XsdInitFunction(InitAnnotation), 
                                                      null, 
                                                      null,
                                                      true),
       /* Include */                    new XsdEntry( SchemaNames.ID.XSD_INCLUDE, State.Include,    AnnotatedSubelements, IncludeAttributes,
                                                      new XsdInitFunction(InitInclude),       
                                                      null,   
                                                      null,
                                                      true),
       /* Import */                     new XsdEntry( SchemaNames.ID.XSD_IMPORT, State.Import,     AnnotatedSubelements, ImportAttributes,
                                                      new XsdInitFunction(InitImport),   
                                                      null,   
                                                      null,
                                                      true),
       /* Element */                    new XsdEntry( SchemaNames.ID.XSD_ELEMENT, State.Element,     ElementSubelements, ElementAttributes,
                                                      new XsdInitFunction(InitElement),    
                                                      null,   
                                                      null,
                                                      true),
       /* Attribute */                  new XsdEntry( SchemaNames.ID.XSD_ATTRIBUTE, State.Attribute,     AttributeSubelements, AttributeAttributes,
                                                      new XsdInitFunction(InitAttribute),    
                                                      null,   
                                                      null,
                                                      true),
       /* AttributeGroup */             new XsdEntry( SchemaNames.ID.XSD_ATTRIBUTEGROUP, State.AttributeGroup,     AttributeGroupSubelements, AttributeGroupAttributes,
                                                      new XsdInitFunction(InitAttributeGroup),    
                                                      null,   
                                                      null,
                                                      true),
       /* AttributeGroupRef */          new XsdEntry( SchemaNames.ID.XSD_ATTRIBUTEGROUP, State.AttributeGroupRef,  AnnotatedSubelements, AttributeGroupRefAttributes,
                                                      new XsdInitFunction(InitAttributeGroupRef),    
                                                      null,   
                                                      null,
                                                      true),
       /* AnyAttribute */               new XsdEntry( SchemaNames.ID.XSD_ANYATTRIBUTE, State.AnyAttribute,     AnnotatedSubelements, AnyAttributeAttributes,
                                                      new XsdInitFunction(InitAnyAttribute),    
                                                      null,       
                                                      null,
                                                      true),
       /* Group */                      new XsdEntry( SchemaNames.ID.XSD_GROUP, State.Group,     GroupSubelements, GroupAttributes,
                                                      new XsdInitFunction(InitGroup),    
                                                      null,   
                                                      null,
                                                      true),
       /* GroupRef */                   new XsdEntry( SchemaNames.ID.XSD_GROUP, State.GroupRef,     AnnotatedSubelements, GroupRefAttributes,
                                                      new XsdInitFunction(InitGroupRef),    
                                                      null,   
                                                      null,
                                                      true),
       /* All */                        new XsdEntry( SchemaNames.ID.XSD_ALL, State.All,     AllSubelements, ParticleAttributes,
                                                      new XsdInitFunction(InitAll),    
                                                      null, 
                                                      null,
                                                      true),
       /* Choice */                     new XsdEntry( SchemaNames.ID.XSD_CHOICE, State.Choice,     ChoiceSequenceSubelements, ParticleAttributes,
                                                      new XsdInitFunction(InitChoice),    
                                                      null,  
                                                      null,
                                                      true),
       /* Sequence */                   new XsdEntry( SchemaNames.ID.XSD_SEQUENCE, State.Sequence,     ChoiceSequenceSubelements, ParticleAttributes,
                                                      new XsdInitFunction(InitSequence),    
                                                      null,  
                                                      null,
                                                      true),
       /* Any */                        new XsdEntry( SchemaNames.ID.XSD_ANY, State.Any,     AnnotatedSubelements, AnyAttributes,
                                                      new XsdInitFunction(InitAny),    
                                                      null, 
                                                      null,
                                                      true),
       /* Notation */                   new XsdEntry( SchemaNames.ID.XSD_NOTATION, State.Notation,     AnnotatedSubelements, NotationAttributes,
                                                      new XsdInitFunction(InitNotation),    
                                                      null,
                                                      null,
                                                      true),
       /* SimpleType */                 new XsdEntry( SchemaNames.ID.XSD_SIMPLETYPE, State.SimpleType,     SimpleTypeSubelements, SimpleTypeAttributes,
                                                      new XsdInitFunction(InitSimpleType),    
                                                      null,   
                                                      null,
                                                      true),
       /* ComplexType */                new XsdEntry( SchemaNames.ID.XSD_COMPLEXTYPE, State.ComplexType,     ComplexTypeSubelements, ComplexTypeAttributes,
                                                      new XsdInitFunction(InitComplexType),    
                                                      null,   
                                                      null,
                                                      true),
       /* ComplexContent */             new XsdEntry( SchemaNames.ID.XSD_COMPLEXCONTENT, State.ComplexContent,  ComplexContentSubelements, ComplexContentAttributes,
                                                      new XsdInitFunction(InitComplexContent),    
                                                      null,   
                                                      null,
                                                      true),
       /* ComplexContentRestriction */    new XsdEntry( SchemaNames.ID.XSD_COMPLEXCONTENTRESTRICTION, State.ComplexContentRestriction,  ComplexContentRestrictionSubelements, ComplexContentRestrictionAttributes,
                                                      new XsdInitFunction(InitComplexContentRestriction),    
                                                      null,   
                                                      null,
                                                      true),
       /* ComplexContentExtension */  new XsdEntry( SchemaNames.ID.XSD_COMPLEXCONTENTEXTENSION, State.ComplexContentExtension,  ComplexContentExtensionSubelements, ComplexContentExtensionAttributes,
                                                      new XsdInitFunction(InitComplexContentExtension),    
                                                      null,   
                                                      null,
                                                      true),
       /* SimpleContent */              new XsdEntry( SchemaNames.ID.XSD_SIMPLECONTENT, State.SimpleContent,  SimpleContentSubelements, SimpleContentAttributes,
                                                      new XsdInitFunction(InitSimpleContent),    
                                                      null,   
                                                      null,
                                                      true),
       /* SimpleContentExtension */     new XsdEntry( SchemaNames.ID.XSD_SIMPLECONTENTEXTENSION, State.SimpleContentExtension,  SimpleContentExtensionSubelements, SimpleContentExtensionAttributes,
                                                      new XsdInitFunction(InitSimpleContentExtension),    
                                                      null,   
                                                      null,
                                                      true),
       /* SimpleContentRestriction */   new XsdEntry( SchemaNames.ID.XSD_SIMPLECONTENTRESTRICTION, State.SimpleContentRestriction,  SimpleContentRestrictionSubelements, SimpleContentRestrictionAttributes,
                                                      new XsdInitFunction(InitSimpleContentRestriction),    
                                                      null,   
                                                      null,
                                                      true),
       /* SimpleTypeUnion */            new XsdEntry( SchemaNames.ID.XSD_SIMPLETYPEUNION, State.SimpleTypeUnion,    SimpleTypeUnionSubelements, SimpleTypeUnionAttributes,
                                                      new XsdInitFunction(InitSimpleTypeUnion),    
                                                      null,   
                                                      null,
                                                      true),
       /* SimpleTypeList */             new XsdEntry( SchemaNames.ID.XSD_SIMPLETYPELIST, State.SimpleTypeList,     SimpleTypeListSubelements, SimpleTypeListAttributes,
                                                      new XsdInitFunction(InitSimpleTypeList),    
                                                      null,   
                                                      null,
                                                      true),
       /* SimpleTypeRestriction */      new XsdEntry( SchemaNames.ID.XSD_SIMPLETYPERESTRICTION, State.SimpleTypeRestriction,  SimpleTypeRestrictionSubelements, SimpleTypeRestrictionAttributes,
                                                      new XsdInitFunction(InitSimpleTypeRestriction),    
                                                      null,   
                                                      null,
                                                      true),
       /* Unique */                     new XsdEntry( SchemaNames.ID.XSD_UNIQUE,  State.Unique,    IdentityConstraintSubelements, IdentityConstraintAttributes,
                                                      new XsdInitFunction(InitIdentityConstraint),    
                                                      null,
                                                      null,
                                                      true),
       /* Key */                        new XsdEntry( SchemaNames.ID.XSD_KEY, State.Key,        IdentityConstraintSubelements, IdentityConstraintAttributes,
                                                      new XsdInitFunction(InitIdentityConstraint),    
                                                      null,
                                                      null,
                                                      true),
       /* KeyRef */                     new XsdEntry( SchemaNames.ID.XSD_KEYREF, State.KeyRef,     IdentityConstraintSubelements, IdentityConstraintAttributes,
                                                      new XsdInitFunction(InitIdentityConstraint),    
                                                      null,
                                                      null,
                                                      true),
       /* Selector */                   new XsdEntry( SchemaNames.ID.XSD_SELECTOR, State.Selector,     AnnotatedSubelements, SelectorAttributes,
                                                      new XsdInitFunction(InitSelector),
                                                      null,
                                                      null,
                                                      true),
       /* Field */                      new XsdEntry( SchemaNames.ID.XSD_FIELD, State.Field,     AnnotatedSubelements, FieldAttributes,
                                                      new XsdInitFunction(InitField),    
                                                      null,
                                                      null,
                                                      true),
       /* MinExclusive */               new XsdEntry( SchemaNames.ID.XSD_MINEXCLUSIVE, State.MinExclusive,     AnnotatedSubelements, FacetAttributes,
                                                      new XsdInitFunction(InitFacet),    
                                                      null,   
                                                      null,
                                                      true),
       /* MinInclusive */               new XsdEntry( SchemaNames.ID.XSD_MININCLUSIVE, State.MinInclusive,     AnnotatedSubelements, FacetAttributes,
                                                      new XsdInitFunction(InitFacet),    
                                                      null,   
                                                      null,
                                                      true),
       /* MaxExclusive */               new XsdEntry( SchemaNames.ID.XSD_MAXEXCLUSIVE, State.MaxExclusive,     AnnotatedSubelements, FacetAttributes,
                                                      new XsdInitFunction(InitFacet),    
                                                      null,   
                                                      null,
                                                      true),
       /* MaxInclusive */               new XsdEntry( SchemaNames.ID.XSD_MAXINCLUSIVE, State.MaxInclusive,     AnnotatedSubelements, FacetAttributes,
                                                      new XsdInitFunction(InitFacet),    
                                                      null,   
                                                      null,
                                                      true),
       /* TotalDigits */                new XsdEntry( SchemaNames.ID.XSD_TOTALDIGITS, State.TotalDigits,     AnnotatedSubelements, FacetAttributes,
                                                      new XsdInitFunction(InitFacet),    
                                                      null,   
                                                      null,
                                                      true),
       /* FractionDigits */             new XsdEntry( SchemaNames.ID.XSD_FRACTIONDIGITS, State.FractionDigits,     AnnotatedSubelements, FacetAttributes,
                                                      new XsdInitFunction(InitFacet),    
                                                      null,   
                                                      null,
                                                      true),
       /* Length */                     new XsdEntry( SchemaNames.ID.XSD_LENGTH, State.Length,     AnnotatedSubelements, FacetAttributes,
                                                      new XsdInitFunction(InitFacet),    
                                                      null,   
                                                      null,
                                                      true),
       /* MinLength */                  new XsdEntry( SchemaNames.ID.XSD_MINLENGTH, State.MinLength,     AnnotatedSubelements, FacetAttributes,
                                                      new XsdInitFunction(InitFacet),    
                                                      null,   
                                                      null,
                                                      true),
       /* MaxLength */                  new XsdEntry( SchemaNames.ID.XSD_MAXLENGTH, State.MaxLength,     AnnotatedSubelements, FacetAttributes,
                                                      new XsdInitFunction(InitFacet),    
                                                      null,   
                                                      null,
                                                      true),
       /* Enumeration */                new XsdEntry( SchemaNames.ID.XSD_ENUMERATION, State.Enumeration,    AnnotatedSubelements, FacetAttributes,
                                                      new XsdInitFunction(InitFacet),    
                                                      null,   
                                                      null,
                                                      true),
       /* Pattern */                    new XsdEntry( SchemaNames.ID.XSD_PATTERN, State.Pattern,    AnnotatedSubelements, FacetAttributes,
                                                      new XsdInitFunction(InitFacet),    
                                                      null,   
                                                      null,
                                                      true),
       /* WhiteSpace */                 new XsdEntry( SchemaNames.ID.XSD_WHITESPACE, State.WhiteSpace, AnnotatedSubelements, FacetAttributes,
                                                      new XsdInitFunction(InitFacet),    
                                                      null,   
                                                      null,
                                                      true),
       /* AppInfo */                    new XsdEntry( SchemaNames.ID.XSD_APPINFO, State.AppInfo,    null, AppinfoAttributes,
                                                      new XsdInitFunction(InitAppinfo), 
                                                      null,   
                                                      new XsdEndChildFunction(EndAppinfo),
                                                      false),
       /* Documentation */              new XsdEntry( SchemaNames.ID.XSD_DOCUMENTATION, State.Documentation,    null, DocumentationAttributes,
                                                      new XsdInitFunction(InitDocumentation),    
                                                      null,   
                                                      new XsdEndChildFunction(EndDocumentation),
                                                      false),
       /* Redefine */                   new XsdEntry( SchemaNames.ID.XSD_REDEFINE, State.Redefine,    RedefineSubelements, RedefineAttributes,
                                                      new XsdInitFunction(InitRedefine),    
                                                      null,   
                                                      new XsdEndChildFunction(EndRedefine),
                                                      true)
        };

        //
        // for 'block' and 'final' attribute values
        //
        private static readonly int[]    DerivationMethodValues = { 
            (int)XmlSchemaDerivationMethod.Substitution,
            (int)XmlSchemaDerivationMethod.Extension, 
            (int)XmlSchemaDerivationMethod.Restriction, 
            (int)XmlSchemaDerivationMethod.List, 
            (int)XmlSchemaDerivationMethod.Union, 
            (int)XmlSchemaDerivationMethod.All, 
        };        
        private static readonly string[] DerivationMethodStrings = { 
            "substitution",
            "extension", 
            "restriction", 
            "list", 
            "union", 
            "#all", 
        };
                 
        private static readonly string[] FormStringValues = { "qualified", "unqualified"};
        private static readonly string[] UseStringValues = { "optional", "prohibited", "required" };
        private static readonly string[] ProcessContentsStringValues = {"skip", "lax", "strict"};

        private XmlReader reader;
        private PositionInfo positionInfo;
        private XsdEntry currentEntry;
        private XsdEntry nextEntry;
        private bool hasChild;
        private HWStack stateHistory = new HWStack(STACK_INCREMENT);
        private Stack containerStack = new Stack();
        private XmlNameTable nameTable;
        private SchemaNames schemaNames;
        private XmlNamespaceManager namespaceManager;
        private bool canIncludeImport;

        private XmlSchema schema;
        private XmlSchemaObject xso;
        private XmlSchemaElement element;
        private XmlSchemaAny anyElement;
        private XmlSchemaAttribute attribute;
        private XmlSchemaAnyAttribute anyAttribute;
        private XmlSchemaComplexType complexType;
        private XmlSchemaSimpleType simpleType;
        private XmlSchemaComplexContent complexContent;
        private XmlSchemaComplexContentExtension complexContentExtension;
        private XmlSchemaComplexContentRestriction complexContentRestriction;
        private XmlSchemaSimpleContent simpleContent;
        private XmlSchemaSimpleContentExtension simpleContentExtension;
        private XmlSchemaSimpleContentRestriction simpleContentRestriction;
        private XmlSchemaSimpleTypeUnion simpleTypeUnion;
        private XmlSchemaSimpleTypeList simpleTypeList;
        private XmlSchemaSimpleTypeRestriction simpleTypeRestriction;
        private XmlSchemaGroup group;  
        private XmlSchemaGroupRef groupRef; 
        private XmlSchemaAll all;  
        private XmlSchemaChoice choice;  
        private XmlSchemaSequence sequence;
        private XmlSchemaParticle particle;
        private XmlSchemaAttributeGroup attributeGroup;
        private XmlSchemaAttributeGroupRef attributeGroupRef;
        private XmlSchemaNotation notation; 
        private XmlSchemaIdentityConstraint identityConstraint; 
        private XmlSchemaXPath xpath;
        private XmlSchemaInclude include;
        private XmlSchemaImport import;
        private XmlSchemaAnnotation annotation;
        private XmlSchemaAppInfo appInfo;  
        private XmlSchemaDocumentation documentation;
        private XmlSchemaFacet facet;
        private XmlNode[] markup;
        private XmlSchemaRedefine redefine;

        private ValidationEventHandler validationEventHandler;
        private ArrayList unhandledAttributes = new ArrayList();
        private Hashtable namespaces;

        internal XsdBuilder( 
                           XmlReader reader,
                           XmlNamespaceManager curmgr, 
                           XmlSchema schema, 
                           XmlNameTable nameTable,
                           SchemaNames schemaNames,
                           ValidationEventHandler eventhandler
                           ) {
            this.reader = reader;
            this.xso = this.schema = schema;
            this.namespaceManager = curmgr;
            this.validationEventHandler = eventhandler;
            this.nameTable = nameTable;
            this.schemaNames = schemaNames;
            this.stateHistory = new HWStack(STACK_INCREMENT);
            this.currentEntry = SchemaEntries[0];
            positionInfo = PositionInfo.GetPositionInfo(reader);
        }

        internal override bool ProcessElement(string prefix, string name, string ns) {
            XmlQualifiedName qname = new XmlQualifiedName(name, ns);
            if (GetNextState(qname)) {
                Push();
                Debug.Assert(this.currentEntry.InitFunc != null);
                xso = null;
                this.currentEntry.InitFunc(this, null);
                Debug.Assert(xso != null);
                RecordPosition();
            }
            else {
                if (!IsSkipableElement(qname)) {
                    SendValidationEvent(Res.Sch_UnsupportedElement, qname.ToString());
                }
                return false;
            }
            return true;
        }

        internal override void ProcessAttribute(string prefix, string name, string ns, string value) {
            XmlQualifiedName qname = new XmlQualifiedName(name, ns);
            if (this.currentEntry.Attributes != null) {
                for (int i = 0; i < this.currentEntry.Attributes.Length; i++) {
                    XsdAttributeEntry a = this.currentEntry.Attributes[i];
                    if (this.schemaNames.GetName(a.Attribute).Equals(qname)) {
                        try {
                            a.BuildFunc(this, value);
                        } 
                        catch (XmlSchemaException e) {
                            e.SetSource(this.reader.BaseURI, this.positionInfo.LineNumber, this.positionInfo.LinePosition);
                            SendValidationEvent(Res.Sch_InvalidXsdAttributeDatatypeValue, new string[] {name, e.Message},XmlSeverityType.Error);
                        }
                        return;
                    }
                }
            }

            // Check non-supported attribute
            if ((ns != this.schemaNames.NsXsd) && (ns != string.Empty)) {
                if (ns == this.schemaNames.NsXmlNs) {
                    if (this.namespaces == null) {
                        this.namespaces = new Hashtable();
                    }
                    this.namespaces.Add((name == this.schemaNames.QnXmlNs.Name) ? string.Empty : name, value);
                }
                else {
                    XmlAttribute attribute = new XmlAttribute(prefix, name, ns, this.schema.Document);
                    attribute.Value = value;
                    this.unhandledAttributes.Add(attribute);
                }
            } 
            else {
                SendValidationEvent(Res.Sch_UnsupportedAttribute, qname.ToString());
            }
        }

        internal override bool IsContentParsed() {
            return this.currentEntry.ParseContent;
        }

        internal override void ProcessMarkup(XmlNode[] markup) {
            this.markup = markup;
        }

        internal override void ProcessCData(string value) {
            SendValidationEvent(Res.Sch_TextNotAllowed, value);
        }

        internal override void StartChildren() {
            if (this.xso != null ) {
                if (this.namespaces != null && this.namespaces.Count > 0) {
                    this.xso.Namespaces.Namespaces = this.namespaces;
                    this.namespaces = null;
                }
                if (this.unhandledAttributes.Count != 0) {
                    this.xso.SetUnhandledAttributes((XmlAttribute[])this.unhandledAttributes.ToArray(typeof(System.Xml.XmlAttribute)));
                    this.unhandledAttributes.Clear();
                }
            }
            if (this.currentEntry.BeginChildFunc != null) {
                (this.currentEntry.BeginChildFunc)(this);
            }
        }

        internal override void EndChildren() {
            if (this.currentEntry.EndChildFunc != null) {
                (this.currentEntry.EndChildFunc)(this);
            }
            Pop();
        }


        // State stack push & pop
        private void Push() {
            this.stateHistory.Push();
            this.stateHistory[this.stateHistory.Length - 1] = this.currentEntry;
            containerStack.Push(GetContainer(this.currentEntry.CurrentState));
            this.currentEntry = this.nextEntry;
            if (this.currentEntry.Name != SchemaNames.ID.XSD_ANNOTATION) {
                this.hasChild = false;
            }
        }

        private void Pop() {
            this.currentEntry = (XsdEntry)this.stateHistory.Pop();
            SetContainer(this.currentEntry.CurrentState, containerStack.Pop());
            this.hasChild = true;
        }

        private SchemaNames.ID CurrentElement {
            get { return this.currentEntry.Name;}
        }

        private SchemaNames.ID ParentElement {
            get { return((XsdEntry)this.stateHistory[this.stateHistory.Length - 1]).Name;}
        }

        private XmlSchemaObject ParentContainer {
            get { return (XmlSchemaObject)containerStack.Peek(); }
        }

        private XmlSchemaObject GetContainer(State state) {
            XmlSchemaObject container = null;
            switch (state) {
                case State.Root:
                    break;
                case State.Schema:
                    container = this.schema;
                    break;
                case State.Annotation:
                    container = this.annotation;
                    break;
                case State.Include:
                    container = this.include;
                    break;
                case State.Import:
                    container = this.import;
                    break;
                case State.Element:
                    container = this.element;
                    break;
                case State.Attribute:
                    container = this.attribute;
                    break;
                case State.AttributeGroup:
                    container = this.attributeGroup;
                    break;
                case State.AttributeGroupRef:
                    container = this.attributeGroupRef;
                    break;
                case State.AnyAttribute:
                    container = this.anyAttribute;
                    break;
                case State.Group:
                    container = this.group;
                    break;
                case State.GroupRef:
                    container = this.groupRef;
                    break;
                case State.All:
                    container = this.all;
                    break;
                case State.Choice:
                    container = this.choice;
                    break;
                case State.Sequence:
                    container = this.sequence;
                    break;
                case State.Any:
                    container = this.anyElement;
                    break;
                case State.Notation:
                    container = this.notation;
                    break;
                case State.SimpleType:
                    container = this.simpleType;
                    break;
                case State.ComplexType:
                    container = this.complexType;
                    break;
                case State.ComplexContent:
                    container = this.complexContent;
                    break;
                case State.ComplexContentExtension:
                    container = this.complexContentExtension;
                    break;
                case State.ComplexContentRestriction:
                    container = this.complexContentRestriction;
                    break;
                case State.SimpleContent:
                    container = this.simpleContent;
                    break;
                case State.SimpleContentExtension:
                    container = this.simpleContentExtension;
                    break;
                case State.SimpleContentRestriction:
                    container = this.simpleContentRestriction;
                    break;
                case State.SimpleTypeUnion:
                    container = this.simpleTypeUnion;
                    break;
                case State.SimpleTypeList:
                    container = this.simpleTypeList;
                    break;
                case State.SimpleTypeRestriction:
                    container = this.simpleTypeRestriction;
                    break;
                case State.Unique:
                case State.Key:
                case State.KeyRef:
                    container = this.identityConstraint;
                    break;
                case State.Selector:
                case State.Field:
                    container = this.xpath;
                    break;
                case State.MinExclusive:
                case State.MinInclusive:
                case State.MaxExclusive:
                case State.MaxInclusive:
                case State.TotalDigits:
                case State.FractionDigits:
                case State.Length:
                case State.MinLength:
                case State.MaxLength:
                case State.Enumeration:
                case State.Pattern:
                case State.WhiteSpace:
                    container = this.facet;
                    break;
                case State.AppInfo:
                    container = this.appInfo;
                    break;
                case State.Documentation:
                    container = this.documentation;
                    break;
                case State.Redefine:
                    container = this.redefine;
                    break;
                default:
                    Debug.Assert(false, "State is " + state);
                    break;
            }
            return container;
        }

        private void SetContainer(State state, object container) {
            switch (state) {
                case State.Root:
                    break;
                case State.Schema:
                    break;
                case State.Annotation:
                    this.annotation = (XmlSchemaAnnotation)container;
                    break;
                case State.Include:
                    this.include = (XmlSchemaInclude)container;
                    break;
                case State.Import:
                    this.import = (XmlSchemaImport)container;
                    break;
                case State.Element:
                    this.element = (XmlSchemaElement)container;
                    break;
                case State.Attribute:
                    this.attribute = (XmlSchemaAttribute)container;
                    break;
                case State.AttributeGroup:
                    this.attributeGroup = (XmlSchemaAttributeGroup)container;
                    break;
                case State.AttributeGroupRef:
                    this.attributeGroupRef = (XmlSchemaAttributeGroupRef)container;
                    break;
                case State.AnyAttribute:
                    this.anyAttribute = (XmlSchemaAnyAttribute)container;
                    break;
                case State.Group:
                    this.group = (XmlSchemaGroup)container;
                    break;
                case State.GroupRef:
                    this.groupRef = (XmlSchemaGroupRef)container;
                    break;
                case State.All:
                    this.all = (XmlSchemaAll)container;
                    break;
                case State.Choice:
                    this.choice = (XmlSchemaChoice)container;
                    break;
                case State.Sequence:
                    this.sequence = (XmlSchemaSequence)container;
                    break;
                case State.Any:
                    this.anyElement = (XmlSchemaAny)container;
                    break;
                case State.Notation:
                    this.notation = (XmlSchemaNotation)container;
                    break;
                case State.SimpleType:
                    this.simpleType = (XmlSchemaSimpleType)container;
                    break;
                case State.ComplexType:
                    this.complexType = (XmlSchemaComplexType)container;
                    break;
                case State.ComplexContent:
                    this.complexContent = (XmlSchemaComplexContent)container;
                    break;
                case State.ComplexContentExtension:
                    this.complexContentExtension = (XmlSchemaComplexContentExtension)container;
                    break;
                case State.ComplexContentRestriction:
                    this.complexContentRestriction = (XmlSchemaComplexContentRestriction)container;
                    break;
                case State.SimpleContent:
                    this.simpleContent = (XmlSchemaSimpleContent)container;
                    break;
                case State.SimpleContentExtension:
                    this.simpleContentExtension = (XmlSchemaSimpleContentExtension)container;
                    break;
                case State.SimpleContentRestriction:
                    this.simpleContentRestriction = (XmlSchemaSimpleContentRestriction)container;
                    break;
                case State.SimpleTypeUnion:
                    this.simpleTypeUnion = (XmlSchemaSimpleTypeUnion)container;
                    break;
                case State.SimpleTypeList:
                    this.simpleTypeList = (XmlSchemaSimpleTypeList)container;
                    break;
                case State.SimpleTypeRestriction:
                    this.simpleTypeRestriction = (XmlSchemaSimpleTypeRestriction)container;
                    break;
                case State.Unique:
                case State.Key:
                case State.KeyRef:
                    this.identityConstraint = (XmlSchemaIdentityConstraint)container;
                    break;
                case State.Selector:
                case State.Field:
                    this.xpath = (XmlSchemaXPath)container;
                    break;
                case State.MinExclusive:
                case State.MinInclusive:
                case State.MaxExclusive:
                case State.MaxInclusive:
                case State.TotalDigits:
                case State.FractionDigits:
                case State.Length:
                case State.MinLength:
                case State.MaxLength:
                case State.Enumeration:
                case State.Pattern:
                case State.WhiteSpace:
                    this.facet = (XmlSchemaFacet)container;
                    break;
                case State.AppInfo:
                    this.appInfo = (XmlSchemaAppInfo)container;
                    break;
                case State.Documentation:
                    this.documentation = (XmlSchemaDocumentation)container;
                    break;
                case State.Redefine:
                    this.redefine = (XmlSchemaRedefine)container;
                    break;
                default:
                    Debug.Assert(false, "State is " + state);
                    break;
            }
        }

        /////////////////////////////////////////////////////////////////////////////////////////////////////////
        // XSD Schema
        //

        private static void BuildAnnotated_Id(XsdBuilder builder, string value) {
            builder.xso.IdAttribute = value;
        }

        /*
            <schema 
              attributeFormDefault = qualified | unqualified : unqualified
              blockDefault = #all or (possibly empty) subset of {substitution, extension, restriction} 
              elementFormDefault = qualified | unqualified : unqualified
              finalDefault = #all or (possibly empty) subset of {extension, restriction} 
              id = ID 
              targetNamespace = uriReference 
              version = string 
              {any attributes with non-schema namespace . . .}>
              Content: ((include | import | redefine | annotation)* , ((attribute | attributeGroup | complexType | element | group | notation | simpleType) , annotation*)*)
            </schema>
        */
        
        private static void BuildSchema_AttributeFormDefault(XsdBuilder builder, string value) {
            builder.schema.AttributeFormDefault = (XmlSchemaForm)builder.ParseEnum(value, "attributeFormDefault", FormStringValues);
        }

        private static void BuildSchema_ElementFormDefault(XsdBuilder builder, string value) {
            builder.schema.ElementFormDefault = (XmlSchemaForm)builder.ParseEnum(value, "elementFormDefault", FormStringValues);
        }
 
        private static void BuildSchema_TargetNamespace(XsdBuilder builder, string value) {
            builder.schema.TargetNamespace = value;    
        }

        private static void BuildSchema_Version(XsdBuilder builder, string value) {
            builder.schema.Version = value;
        }

        private static void BuildSchema_FinalDefault(XsdBuilder builder, string value) {
            builder.schema.FinalDefault = (XmlSchemaDerivationMethod)builder.ParseEnumFlags(value, "finalDefault", DerivationMethodStrings, DerivationMethodValues);
        }

        private static void BuildSchema_BlockDefault(XsdBuilder builder, string value) {
            builder.schema.BlockDefault = (XmlSchemaDerivationMethod)builder.ParseEnumFlags(value, "blockDefault", DerivationMethodStrings, DerivationMethodValues);
        }

        private static void InitSchema(XsdBuilder builder, string value) {
            builder.canIncludeImport = true;
            builder.xso = builder.schema;
        }

        /*
            <include 
              id = ID 
              schemaLocation = uriReference 
              {any attributes with non-schema namespace . . .}>
              Content: (annotation?)
            </include>
        */
        private static void InitInclude(XsdBuilder builder, string value) {
            if (!builder.canIncludeImport) {
                builder.SendValidationEvent(Res.Sch_IncludeLocation, null);        
            }
            builder.xso = builder.include = new XmlSchemaInclude();
            builder.schema.Includes.Add(builder.include);
        }

        private static void BuildInclude_SchemaLocation(XsdBuilder builder, string value) {
            builder.include.SchemaLocation = value;
        }

        /*
            <import 
              id = ID 
              namespace = uriReference 
              schemaLocation = uriReference 
              {any attributes with non-schema namespace . . .}>
              Content: (annotation?)
            </import>
        */
        private static void InitImport(XsdBuilder builder, string value) {
            if (!builder.canIncludeImport) {
                builder.SendValidationEvent(Res.Sch_ImportLocation, null);            
            }
            builder.xso = builder.import = new XmlSchemaImport();
            builder.schema.Includes.Add(builder.import);
        }

        private static void BuildImport_Namespace(XsdBuilder builder, string value) {
            builder.import.Namespace = value;
        }

        private static void BuildImport_SchemaLocation(XsdBuilder builder, string value) {
            builder.import.SchemaLocation = value;
        }

        /*
            <redefine 
              schemaLocation = uriReference 
              {any attributes with non-schema namespace . . .}>
              Content: (annotation | (attributeGroup | complexType | group | simpleType))*
            </redefine>
        */
        private static void InitRedefine(XsdBuilder builder, string value) {
            if (!builder.canIncludeImport) {
                builder.SendValidationEvent(Res.Sch_RedefineLocation, null);            
            }
            builder.xso = builder.redefine = new XmlSchemaRedefine();
            builder.schema.Includes.Add(builder.redefine);
        }

        private static void BuildRedefine_SchemaLocation(XsdBuilder builder, string value) {
            builder.redefine.SchemaLocation = value;
        }

        private static void EndRedefine(XsdBuilder builder) {    
            builder.canIncludeImport = true;
        }

        /*
            <attribute 
              form = qualified | unqualified 
              id = ID 
              name = NCName 
              ref = QName 
              type = QName 
              use = prohibited | optional | required | default | fixed : optional
              value = string 
              {any attributes with non-schema namespace . . .}>
              Content: (annotation? , (simpleType?))
            </attribute>
        */
        private static void InitAttribute(XsdBuilder builder, string value) {
            builder.xso = builder.attribute = new XmlSchemaAttribute();
            if (builder.ParentElement == SchemaNames.ID.XSD_SCHEMA)
                builder.schema.Items.Add(builder.attribute);
            else 
                builder.AddAttribute(builder.attribute);
            builder.canIncludeImport = false;  // disable import and include elements in schema
        }

        private static void BuildAttribute_Default(XsdBuilder builder, string value) {
            builder.attribute.DefaultValue = value;
        }

        private static void BuildAttribute_Fixed(XsdBuilder builder, string value) {
            builder.attribute.FixedValue = value;
        }

        private static void BuildAttribute_Form(XsdBuilder builder, string value) {
            builder.attribute.Form = (XmlSchemaForm)builder.ParseEnum(value, "form", FormStringValues);
        }

        private static void BuildAttribute_Use(XsdBuilder builder, string value) {
            builder.attribute.Use = (XmlSchemaUse)builder.ParseEnum(value, "use", UseStringValues);
        }

        private static void BuildAttribute_Ref(XsdBuilder builder, string value) {
            builder.attribute.RefName = builder.ParseQName(value, "ref");
        }

        private static void BuildAttribute_Name(XsdBuilder builder, string value) {
            builder.attribute.Name = value;
        }

        private static void BuildAttribute_Type(XsdBuilder builder, string value) {
            builder.attribute.SchemaTypeName = builder.ParseQName(value, "type");
        }

        /*
            <element 
              abstract = boolean : false
              block = #all or (possibly empty) subset of {substitution, extension, restriction} 
              default = string 
              final = #all or (possibly empty) subset of {extension, restriction} 
              fixed = string 
              form = qualified | unqualified 
              id = ID 
              maxOccurs = for maxOccurs : 1
              minOccurs = nonNegativeInteger : 1
              name = NCName 
              nillable = boolean : false
              ref = QName 
              substitutionGroup = QName 
              type = QName 
              {any attributes with non-schema namespace . . .}>
              Content: (annotation? , ((simpleType | complexType)? , (key | keyref | unique)*))
            </element>
        */    
        private static void InitElement(XsdBuilder builder, string value) {
            builder.xso = builder.element = new XmlSchemaElement();
            builder.canIncludeImport = false;
            switch (builder.ParentElement) {
                case SchemaNames.ID.XSD_SCHEMA:
                    builder.schema.Items.Add(builder.element);
                    break;
                case SchemaNames.ID.XSD_ALL:
                    builder.all.Items.Add(builder.element);
                    break;
                case SchemaNames.ID.XSD_CHOICE:
                    builder.choice.Items.Add(builder.element);
                    break;
                case SchemaNames.ID.XSD_SEQUENCE:
                    builder.sequence.Items.Add(builder.element);
                    break;
                default:
                    Debug.Assert(false);
                    break;
            }
        }

        private static void BuildElement_Abstract(XsdBuilder builder, string value) {
            builder.element.IsAbstract = builder.ParseBoolean(value, "abstract");
        }

        private static void BuildElement_Block(XsdBuilder builder, string value) {
            builder.element.Block = (XmlSchemaDerivationMethod)builder.ParseEnumFlags(value, "block", DerivationMethodStrings, DerivationMethodValues);
        }

        private static void BuildElement_Default(XsdBuilder builder, string value) {
            builder.element.DefaultValue = value;
        }

        private static void BuildElement_Form(XsdBuilder builder, string value) {
            builder.element.Form = (XmlSchemaForm)builder.ParseEnum(value, "form", FormStringValues);
        }

        private static void BuildElement_SubstitutionGroup(XsdBuilder builder, string value) {
            builder.element.SubstitutionGroup = builder.ParseQName(value, "substitutionGroup");
        }

        private static void BuildElement_Final(XsdBuilder builder, string value) {
            builder.element.Final = (XmlSchemaDerivationMethod)builder.ParseEnumFlags(value, "final", DerivationMethodStrings, DerivationMethodValues);
        }

        private static void BuildElement_Fixed(XsdBuilder builder, string value) {
            builder.element.FixedValue = value;
        }

        private static void BuildElement_MaxOccurs(XsdBuilder builder, string value) {
            builder.SetMaxOccurs(builder.element, value);
        }

        private static void BuildElement_MinOccurs(XsdBuilder builder, string value) {
            builder.SetMinOccurs(builder.element, value);
        }

        private static void BuildElement_Name(XsdBuilder builder, string value) {
            builder.element.Name = value;
        }

        private static void BuildElement_Nillable(XsdBuilder builder, string value) {
            builder.element.IsNillable = builder.ParseBoolean(value, "nillable");
        }

        private static void BuildElement_Ref(XsdBuilder builder, string value) {
            builder.element.RefName = builder.ParseQName(value, "ref");
        }

        private static void BuildElement_Type(XsdBuilder builder, string value) {
            builder.element.SchemaTypeName = builder.ParseQName(value, "type");
        }

        /*
            <simpleType 
              id = ID 
              name = NCName 
              {any attributes with non-schema namespace . . .}>
              Content: (annotation? , ((list | restriction | union)))
            </simpleType>
        */
        private static void InitSimpleType(XsdBuilder builder, string value) {
            builder.xso = builder.simpleType = new XmlSchemaSimpleType();
            switch (builder.ParentElement) {
                case SchemaNames.ID.XSD_SCHEMA:
                    builder.canIncludeImport = false;  // disable import and include elements in schema
                    builder.schema.Items.Add(builder.simpleType);                    
                    break;
                case SchemaNames.ID.XSD_REDEFINE:
                    builder.redefine.Items.Add(builder.simpleType);                    
                    break;
                case SchemaNames.ID.XSD_ATTRIBUTE:
                    if (builder.attribute.SchemaType != null) {
                        builder.SendValidationEvent(Res.Sch_DupXsdElement, "simpleType");
                    }
                    builder.attribute.SchemaType = builder.simpleType;
                    break;
                case SchemaNames.ID.XSD_ELEMENT:
                    if (builder.element.SchemaType != null) {
                        builder.SendValidationEvent(Res.Sch_DupXsdElement, "simpleType");
                    }
                    if (builder.element.Constraints.Count != 0) {
                        builder.SendValidationEvent(Res.Sch_TypeAfterConstraints, null);
                    }
                    builder.element.SchemaType = builder.simpleType;
                    break;
                case SchemaNames.ID.XSD_SIMPLETYPELIST:
                    if (builder.simpleTypeList.ItemType != null) {
                        builder.SendValidationEvent(Res.Sch_DupXsdElement, "simpleType");
                    }
                    builder.simpleTypeList.ItemType = builder.simpleType;
                    break;
                case SchemaNames.ID.XSD_SIMPLETYPERESTRICTION:
                    if (builder.simpleTypeRestriction.BaseType != null) {
                        builder.SendValidationEvent(Res.Sch_DupXsdElement, "simpleType");
                    }
                    builder.simpleTypeRestriction.BaseType = builder.simpleType;
                    break;
                case SchemaNames.ID.XSD_SIMPLECONTENTRESTRICTION:
                    if (builder.simpleContentRestriction.BaseType != null) {
                        builder.SendValidationEvent(Res.Sch_DupXsdElement, "simpleType");
                    }
                    if (
                        builder.simpleContentRestriction.Attributes.Count != 0 || 
                        builder.simpleContentRestriction.AnyAttribute != null || 
                        builder.simpleContentRestriction.Facets.Count != 0
                    ) {
                        builder.SendValidationEvent(Res.Sch_SimpleTypeRestriction, null);
                    }
                    builder.simpleContentRestriction.BaseType = builder.simpleType;
                    break;

                case SchemaNames.ID.XSD_SIMPLETYPEUNION:
                    builder.simpleTypeUnion.BaseTypes.Add(builder.simpleType);  
                    break;
            }
        }

        private static void BuildSimpleType_Name(XsdBuilder builder, string value) {
            builder.simpleType.Name =value;
        }

        private static void BuildSimpleType_Final(XsdBuilder builder, string value) {
            builder.simpleType.Final = (XmlSchemaDerivationMethod)builder.ParseEnumFlags(value, "final", DerivationMethodStrings, DerivationMethodValues);
        }


        /*
            <union 
              id = ID 
              memberTypes = List of [anon]
              {any attributes with non-schema namespace . . .}>
              Content: (annotation? , (simpleType*))
            </union>
        */
        private static void InitSimpleTypeUnion(XsdBuilder builder, string value) {
            if (builder.simpleType.Content != null) {
                builder.SendValidationEvent(Res.Sch_DupSimpleTypeChild, null);
            }    
            builder.xso = builder.simpleTypeUnion = new XmlSchemaSimpleTypeUnion();
            builder.simpleType.Content = builder.simpleTypeUnion;
        }

        private static void BuildSimpleTypeUnion_MemberTypes(XsdBuilder builder, string value) {
            XmlSchemaDatatype dt = XmlSchemaDatatype.FromXmlTokenizedTypeXsd(XmlTokenizedType.QName).DeriveByList();
            try {
                builder.simpleTypeUnion.MemberTypes = (XmlQualifiedName[])dt.ParseValue(value, builder.nameTable, builder.namespaceManager);
            } 
            catch (XmlSchemaException e) {
                e.SetSource(builder.reader.BaseURI, builder.positionInfo.LineNumber, builder.positionInfo.LinePosition);
                builder.SendValidationEvent(e);
            }
        }


        /*
            <list 
              id = ID 
              itemType = QName 
              {any attributes with non-schema namespace . . .}>
              Content: (annotation? , (simpleType?))
            </list>
        */
        private static void InitSimpleTypeList(XsdBuilder builder, string value) {   
            if (builder.simpleType.Content != null) {
                builder.SendValidationEvent(Res.Sch_DupSimpleTypeChild, null);
            }
            builder.xso = builder.simpleTypeList = new XmlSchemaSimpleTypeList();
            builder.simpleType.Content = builder.simpleTypeList;
        }

        private static void BuildSimpleTypeList_ItemType(XsdBuilder builder, string value) {
            builder.simpleTypeList.ItemTypeName = builder.ParseQName(value, "itemType");
        }

        /*
            <restriction 
              base = QName 
              id = ID 
              {any attributes with non-schema namespace . . .}>
              Content: (annotation? , (simpleType? , ((duration | encoding | enumeration | length | maxExclusive | maxInclusive | maxLength | minExclusive | minInclusive | minLength | pattern | period | TotalDigits | FractionDigits)*)))
            </restriction>
        */
        private static void InitSimpleTypeRestriction(XsdBuilder builder, string value) {
            if (builder.simpleType.Content != null) {
                builder.SendValidationEvent(Res.Sch_DupSimpleTypeChild, null);
            }
            builder.xso = builder.simpleTypeRestriction = new XmlSchemaSimpleTypeRestriction();
            builder.simpleType.Content = builder.simpleTypeRestriction;
        }

        private static void BuildSimpleTypeRestriction_Base(XsdBuilder builder, string value) {
            builder.simpleTypeRestriction.BaseTypeName = builder.ParseQName(value, "base");
        }

        /*
            <complexType 
              abstract = boolean : false
              block = #all or (possibly empty) subset of {extension, restriction} 
              final = #all or (possibly empty) subset of {extension, restriction} 
              id = ID 
              mixed = boolean : false
              name = NCName 
              {any attributes with non-schema namespace . . .}>
              Content: (annotation? , (simpleContent | complexContent | ((group | all | choice | sequence)? , ((attribute | attributeGroup)* , anyAttribute?))))
            </complexType>
        */
        private static void InitComplexType(XsdBuilder builder, string value) {
            builder.xso = builder.complexType = new XmlSchemaComplexType();
            switch (builder.ParentElement) {
                case SchemaNames.ID.XSD_SCHEMA:
                    builder.canIncludeImport = false;  // disable import and include elements in schema
                    builder.schema.Items.Add(builder.complexType);                    
                    break;
                case SchemaNames.ID.XSD_REDEFINE:
                    builder.redefine.Items.Add(builder.complexType);                    
                    break;
                case SchemaNames.ID.XSD_ELEMENT:
                    if (builder.element.SchemaType != null) {
                        builder.SendValidationEvent(Res.Sch_DupElement, "complexType");
                    }
                    if (builder.element.Constraints.Count != 0) {
                        builder.SendValidationEvent(Res.Sch_TypeAfterConstraints, null);
                    }
                    builder.element.SchemaType = builder.complexType;
                    break;
            }
        }

        private static void BuildComplexType_Abstract(XsdBuilder builder, string value) {
            builder.complexType.IsAbstract = builder.ParseBoolean(value, "abstract");
        }

        private static void BuildComplexType_Block(XsdBuilder builder, string value) {
            builder.complexType.Block = (XmlSchemaDerivationMethod)builder.ParseEnumFlags(value, "block", DerivationMethodStrings, DerivationMethodValues);
        }

        private static void BuildComplexType_Final(XsdBuilder builder, string value) {
            builder.complexType.Final = (XmlSchemaDerivationMethod)builder.ParseEnumFlags(value, "final", DerivationMethodStrings, DerivationMethodValues);
        }

        private static void BuildComplexType_Mixed(XsdBuilder builder, string value) {
            builder.complexType.IsMixed = builder.ParseBoolean(value, "mixed");
        }

        private static void BuildComplexType_Name(XsdBuilder builder, string value) {
            builder.complexType.Name = value;
        }

        /*
            <complexContent 
              id = ID 
              mixed = boolean 
              {any attributes with non-schema namespace . . .}>
              Content: (annotation? , (restriction | extension))
            </complexContent>
        */
        private static void InitComplexContent(XsdBuilder builder, string value) {
            if ( (builder.complexType.ContentModel != null) ||
                 (builder.complexType.Particle != null || builder.complexType.Attributes.Count != 0 || builder.complexType.AnyAttribute != null)
               ) {
                 builder.SendValidationEvent(Res.Sch_ComplexTypeContentModel, "complexContent");
            }
            builder.xso = builder.complexContent = new XmlSchemaComplexContent();
            builder.complexType.ContentModel = builder.complexContent;
        }

        private static void BuildComplexContent_Mixed(XsdBuilder builder, string value) {
            builder.complexContent.IsMixed = builder.ParseBoolean(value, "mixed");
        }

        /*
            <extension 
              base = QName 
              id = ID 
              {any attributes with non-schema namespace . . .}>
              Content: (annotation? , ((group | all | choice | sequence)? , ((attribute | attributeGroup)* , anyAttribute?)))
            </extension>
        */
        private static void InitComplexContentExtension(XsdBuilder builder, string value) {
            if (builder.complexContent.Content != null) {
                builder.SendValidationEvent(Res.Sch_ComplexContentContentModel, "extension");
            }
            builder.xso = builder.complexContentExtension = new XmlSchemaComplexContentExtension();
            builder.complexContent.Content = builder.complexContentExtension;
        }

        private static void BuildComplexContentExtension_Base(XsdBuilder builder, string value) {
            builder.complexContentExtension.BaseTypeName = builder.ParseQName(value, "base");
        }

        /*
            <restriction 
              base = QName 
              id = ID 
              {any attributes with non-schema namespace . . .}>
              Content: (annotation? , (group | all | choice | sequence)? , ((attribute | attributeGroup)* , anyAttribute?))
            </restriction>
        */
        private static void InitComplexContentRestriction(XsdBuilder builder, string value) {
            builder.xso = builder.complexContentRestriction = new XmlSchemaComplexContentRestriction();
            builder.complexContent.Content = builder.complexContentRestriction;
        }

        private static void BuildComplexContentRestriction_Base(XsdBuilder builder, string value) {
            builder.complexContentRestriction.BaseTypeName = builder.ParseQName(value, "base");
        }

        /*
            <simpleContent 
              id = ID 
              {any attributes with non-schema namespace . . .}>
              Content: (annotation? , (restriction | extension))
            </simpleContent>
        */
        private static void InitSimpleContent(XsdBuilder builder, string value) {
            if ( (builder.complexType.ContentModel != null) || 
                 (builder.complexType.Particle != null || builder.complexType.Attributes.Count != 0 || builder.complexType.AnyAttribute != null)
                 ) {
                   builder.SendValidationEvent(Res.Sch_ComplexTypeContentModel, "simpleContent");
            }
            builder.xso = builder.simpleContent = new XmlSchemaSimpleContent();
            builder.complexType.ContentModel = builder.simpleContent;
        }

        /*
            <extension 
              base = QName 
              id = ID 
              {any attributes with non-schema namespace . . .}>
              Content: (annotation? , ((attribute | attributeGroup)* , anyAttribute?))
            </extension>
        */

        private static void InitSimpleContentExtension(XsdBuilder builder, string value) {
            if (builder.simpleContent.Content != null) {
                builder.SendValidationEvent(Res.Sch_DupElement, "extension");
            }
            builder.xso = builder.simpleContentExtension = new XmlSchemaSimpleContentExtension();
            builder.simpleContent.Content = builder.simpleContentExtension;
        }

        private static void BuildSimpleContentExtension_Base(XsdBuilder builder, string value) {
            builder.simpleContentExtension.BaseTypeName = builder.ParseQName(value, "base");
        }


        /*
            <restriction 
              base = QName 
              id = ID 
              {any attributes with non-schema namespace . . .}>
              Content: (annotation? , ((duration | encoding | enumeration | length | maxExclusive | maxInclusive | maxLength | minExclusive | minInclusive | minLength | pattern | period | totalDigits | fractionDigits)*)? , ((attribute | attributeGroup)* , anyAttribute?))
            </restriction>
        */
        private static void InitSimpleContentRestriction(XsdBuilder builder, string value) {
            if (builder.simpleContent.Content != null) {
                builder.SendValidationEvent(Res.Sch_DupElement, "restriction");
            }
            builder.xso = builder.simpleContentRestriction = new XmlSchemaSimpleContentRestriction();
            builder.simpleContent.Content = builder.simpleContentRestriction;
        }

        private static void BuildSimpleContentRestriction_Base(XsdBuilder builder, string value) {
            builder.simpleContentRestriction.BaseTypeName = builder.ParseQName(value, "base");
        }

        /*
            <attributeGroup 
              id = ID 
              name = NCName 
              ref = QName 
              {any attributes with non-schema namespace . . .}>
              Content: (annotation? , ((attribute | attributeGroup)* , anyAttribute?))
            </attributeGroup>
        */
        private static void InitAttributeGroup(XsdBuilder builder, string value) {
            builder.canIncludeImport = false;
            builder.xso = builder.attributeGroup = new XmlSchemaAttributeGroup();
            switch (builder.ParentElement) {
                case SchemaNames.ID.XSD_SCHEMA:
                    builder.schema.Items.Add(builder.attributeGroup);
                    break;
                case SchemaNames.ID.XSD_REDEFINE:
                    builder.redefine.Items.Add(builder.attributeGroup);                    
                    break;
            }
        }

        private static void BuildAttributeGroup_Name(XsdBuilder builder, string value) {
            builder.attributeGroup.Name = value;
        }

        /*
            <attributeGroup 
              id = ID 
              ref = QName 
              {any attributes with non-schema namespace . . .}>
              Content: (annotation?)
            </attributeGroup>
        */
        private static void InitAttributeGroupRef(XsdBuilder builder, string value) {
            builder.xso = builder.attributeGroupRef = new XmlSchemaAttributeGroupRef();
            builder.AddAttribute(builder.attributeGroupRef);
        }

        private static void BuildAttributeGroupRef_Ref(XsdBuilder builder, string value) {
            builder.attributeGroupRef.RefName = builder.ParseQName(value, "ref");
        }

        /*
            <anyAttribute 
              id = ID 
              namespace = ##any | ##other | list of {uri, ##targetNamespace, ##local} : ##any
              processContents = skip | lax | strict : strict
              {any attributes with non-schema namespace . . .}>
              Content: (annotation?)
            </anyAttribute>
        */
        private static void InitAnyAttribute(XsdBuilder builder, string value) {
            builder.xso = builder.anyAttribute = new XmlSchemaAnyAttribute();
            switch (builder.ParentElement) {
                case SchemaNames.ID.XSD_COMPLEXTYPE:
                    if (builder.complexType.ContentModel != null) {
                        builder.SendValidationEvent(Res.Sch_AttributeMutuallyExclusive, "anyAttribute");
                    }
                    if (builder.complexType.AnyAttribute != null) {
                        builder.SendValidationEvent(Res.Sch_DupElement, "anyAttribute");
                    }
                    builder.complexType.AnyAttribute = builder.anyAttribute;
                    break;
                case SchemaNames.ID.XSD_SIMPLECONTENTRESTRICTION:
                    if (builder.simpleContentRestriction.AnyAttribute != null) {
                        builder.SendValidationEvent(Res.Sch_DupElement, "anyAttribute");
                    }
                    builder.simpleContentRestriction.AnyAttribute = builder.anyAttribute;
                    break;
                case SchemaNames.ID.XSD_SIMPLECONTENTEXTENSION:
                    if (builder.simpleContentExtension.AnyAttribute != null) {
                        builder.SendValidationEvent(Res.Sch_DupElement, "anyAttribute");
                    }
                    builder.simpleContentExtension.AnyAttribute = builder.anyAttribute;
                    break;
                case SchemaNames.ID.XSD_COMPLEXCONTENTEXTENSION:
                    if (builder.complexContentExtension.AnyAttribute != null) {
                        builder.SendValidationEvent(Res.Sch_DupElement, "anyAttribute");
                    }
                    builder.complexContentExtension.AnyAttribute = builder.anyAttribute;
                    break;
                case SchemaNames.ID.XSD_COMPLEXCONTENTRESTRICTION:
                    if (builder.complexContentRestriction.AnyAttribute != null) {
                        builder.SendValidationEvent(Res.Sch_DupElement, "anyAttribute");
                    }
                    builder.complexContentRestriction.AnyAttribute = builder.anyAttribute;
                    break;
                case SchemaNames.ID.XSD_ATTRIBUTEGROUP:
                    if (builder.attributeGroup.AnyAttribute != null) {
                        builder.SendValidationEvent(Res.Sch_DupElement, "anyAttribute");
                    }
                    builder.attributeGroup.AnyAttribute = builder.anyAttribute;
                    break;
            }
        }

        private static void BuildAnyAttribute_Namespace(XsdBuilder builder, string value) {
            builder.anyAttribute.Namespace = value;
        }

        private static void BuildAnyAttribute_ProcessContents(XsdBuilder builder, string value) {
            builder.anyAttribute.ProcessContents = (XmlSchemaContentProcessing)builder.ParseEnum(value, "processContents", ProcessContentsStringValues);
        }

        /*
            <group 
              id = ID 
              name = NCName 
              {any attributes with non-schema namespace . . .}>
              Content: (annotation? , (all | choice | sequence)?)
            </group>
        */
        private static void InitGroup(XsdBuilder builder, string value) {
            builder.xso = builder.group = new XmlSchemaGroup();
            builder.canIncludeImport = false;  // disable import and include elements in schema
            switch (builder.ParentElement) {
                case SchemaNames.ID.XSD_SCHEMA:
                    builder.schema.Items.Add(builder.group);
                    break;
                case SchemaNames.ID.XSD_REDEFINE:
                    builder.redefine.Items.Add(builder.group);                    
                    break;
            }
        }

        private static void BuildGroup_Name(XsdBuilder builder, string value) {
            builder.group.Name = value;
        }

        /*
            <group 
              id = ID 
              maxOccurs = for maxOccurs : 1
              minOccurs = nonNegativeInteger : 1
              ref = QName 
              {any attributes with non-schema namespace . . .}>
              Content: (annotation?)
            </group>
        */
        private static void InitGroupRef(XsdBuilder builder, string value) {
            builder.xso = builder.particle = builder.groupRef = new XmlSchemaGroupRef();
            builder.AddParticle(builder.groupRef);
        }

        private static void BuildParticle_MaxOccurs(XsdBuilder builder, string value) {
            builder.SetMaxOccurs(builder.particle, value);
        }

        private static void BuildParticle_MinOccurs(XsdBuilder builder, string value) {
            builder.SetMinOccurs(builder.particle, value);
        }

        private static void BuildGroupRef_Ref(XsdBuilder builder, string value) {
            builder.groupRef.RefName = builder.ParseQName(value, "ref");
        }

        /*
            <all 
              id = ID 
              maxOccurs = for maxOccurs : 1
              minOccurs = nonNegativeInteger : 1
              {any attributes with non-schema namespace . . .}>
              Content: (annotation? , element*)
            </all>
        */
        private static void InitAll(XsdBuilder builder, string value) {
            builder.xso = builder.particle = builder.all = new XmlSchemaAll();
            builder.AddParticle(builder.all);
        }

        /*
            <choice 
              id = ID 
              maxOccurs = for maxOccurs : 1
              minOccurs = nonNegativeInteger : 1
              {any attributes with non-schema namespace . . .}>
              Content: (annotation? , (element | group | choice | sequence | any)*)
            </choice>
        */
        private static void InitChoice(XsdBuilder builder, string value) {
            builder.xso = builder.particle = builder.choice = new XmlSchemaChoice();
            builder.AddParticle(builder.choice);
        }

        /*
             <sequence 
              id = ID 
              maxOccurs = for maxOccurs : 1
              minOccurs = nonNegativeInteger : 1
              {any attributes with non-schema namespace . . .}>
              Content: (annotation? , (element | group | choice | sequence | any)*)
            </sequence>
        */
        private static void InitSequence(XsdBuilder builder, string value) {
            builder.xso = builder.particle = builder.sequence = new XmlSchemaSequence();
            builder.AddParticle(builder.sequence);
        }

        /*
            <any 
              id = ID 
              maxOccurs = for maxOccurs : 1
              minOccurs = nonNegativeInteger : 1
              namespace = ##any | ##other | list of {uri, ##targetNamespace, ##local} : ##any
              processContents = skip | lax | strict : strict
              {any attributes with non-schema namespace . . .}>
              Content: (annotation?)
            </any>
        */
        private static void InitAny(XsdBuilder builder, string value) {
            builder.xso = builder.particle = builder.anyElement = new XmlSchemaAny();
            builder.AddParticle(builder.anyElement);
        } 

        private static void BuildAny_Namespace(XsdBuilder builder, string value) {
            builder.anyElement.Namespace = value;
        } 

        private static void BuildAny_ProcessContents(XsdBuilder builder, string value) {
            builder.anyElement.ProcessContents = (XmlSchemaContentProcessing)builder.ParseEnum(value, "processContents", ProcessContentsStringValues);
        }

        /*
            <notation 
              id = ID 
              name = NCName 
              public = A public identifier, per ISO 8879 
              system = uriReference 
              {any attributes with non-schema namespace . . .}>
              Content: (annotation?)
            </notation>
        */
        private static void InitNotation(XsdBuilder builder, string value) {
            builder.xso = builder.notation = new XmlSchemaNotation();
            builder.canIncludeImport = false;
            builder.schema.Items.Add(builder.notation);
        }

        private static void BuildNotation_Name(XsdBuilder builder, string value) {
            builder.notation.Name = value;
        }

        private static void BuildNotation_Public(XsdBuilder builder, string value) {
            builder.notation.Public = value;
        }

        private static void BuildNotation_System(XsdBuilder builder, string value) {
            builder.notation.System = value;
        }

        //
        // Facets
        //
        /*
            <duration 
              id = ID 
              value = timeDuration 
              fixed = boolean : false>
              Content: (annotation?)
            </duration>
        */
        private static void InitFacet(XsdBuilder builder, string value) {
            switch (builder.CurrentElement) {
                case SchemaNames.ID.XSD_ENUMERATION:
                    builder.facet = new XmlSchemaEnumerationFacet();
                    break;
                case SchemaNames.ID.XSD_LENGTH:
                    builder.facet = new XmlSchemaLengthFacet();
                    break;
                case SchemaNames.ID.XSD_MAXEXCLUSIVE:
                    builder.facet = new XmlSchemaMaxExclusiveFacet();
                    break;
                case SchemaNames.ID.XSD_MAXINCLUSIVE:
                    builder.facet = new XmlSchemaMaxInclusiveFacet();
                    break;
                case SchemaNames.ID.XSD_MAXLENGTH:
                    builder.facet = new XmlSchemaMaxLengthFacet();
                    break;
                case SchemaNames.ID.XSD_MINEXCLUSIVE:
                    builder.facet = new XmlSchemaMinExclusiveFacet();
                    break;
                case SchemaNames.ID.XSD_MININCLUSIVE:
                    builder.facet = new XmlSchemaMinInclusiveFacet();
                    break;
                case SchemaNames.ID.XSD_MINLENGTH:
                    builder.facet = new XmlSchemaMinLengthFacet();
                    break;
                case SchemaNames.ID.XSD_PATTERN:
                    builder.facet = new XmlSchemaPatternFacet();
                    break;
                case SchemaNames.ID.XSD_TOTALDIGITS:
                    builder.facet = new XmlSchemaTotalDigitsFacet();
                    break;
                case SchemaNames.ID.XSD_FRACTIONDIGITS:
                    builder.facet = new XmlSchemaFractionDigitsFacet();
                    break;
                case SchemaNames.ID.XSD_WHITESPACE:
                    builder.facet = new XmlSchemaWhiteSpaceFacet();
                    break;
            }
            builder.xso = builder.facet;
            if (SchemaNames.ID.XSD_SIMPLETYPERESTRICTION == builder.ParentElement) {
                builder.simpleTypeRestriction.Facets.Add(builder.facet);
            }
            else {
                if (builder.simpleContentRestriction.Attributes.Count != 0 || (builder.simpleContentRestriction.AnyAttribute != null)) {
                    builder.SendValidationEvent(Res.Sch_InvalidFacetPosition, null);
                }
                builder.simpleContentRestriction.Facets.Add(builder.facet);
            }
        }

        private static void BuildFacet_Fixed(XsdBuilder builder, string value) {
            builder.facet.IsFixed = builder.ParseBoolean(value, "fixed");
        }

        private static void BuildFacet_Value(XsdBuilder builder, string value) {
            builder.facet.Value = value;
        }

        /*
            <unique 
              id = ID 
              name = NCName 
              {any attributes with non-schema namespace . . .}>
              Content: (annotation? , (selector , field+))
            </unique>
 
            <key 
              id = ID 
              name = NCName 
              {any attributes with non-schema namespace . . .}>
              Content: (annotation? , (selector , field+))
            </key>
 
            <keyref 
              id = ID 
              name = NCName 
              refer = QName 
              {any attributes with non-schema namespace . . .}>
              Content: (annotation? , (selector , field+))
            </keyref>
        */
        private static void InitIdentityConstraint(XsdBuilder builder, string value) {
            if (!builder.element.RefName.IsEmpty) {
                builder.SendValidationEvent(Res.Sch_ElementRef, null);
            }

            switch (builder.CurrentElement) {
                case SchemaNames.ID.XSD_UNIQUE:
                    builder.xso = builder.identityConstraint = new XmlSchemaUnique();
                    break;
                case SchemaNames.ID.XSD_KEY:
                    builder.xso = builder.identityConstraint = new XmlSchemaKey();
                    break;
                case SchemaNames.ID.XSD_KEYREF:
                    builder.xso = builder.identityConstraint = new XmlSchemaKeyref();
                    break;
            }
            builder.element.Constraints.Add(builder.identityConstraint);
        }

        private static void BuildIdentityConstraint_Name(XsdBuilder builder, string value) {
            builder.identityConstraint.Name = value;
        } 

        private static void BuildIdentityConstraint_Refer(XsdBuilder builder, string value) {
            if (builder.identityConstraint is XmlSchemaKeyref) {
                ((XmlSchemaKeyref)builder.identityConstraint).Refer = builder.ParseQName(value, "refer");
            }
            else {
                builder.SendValidationEvent(Res.Sch_UnsupportedAttribute, "refer");
            }
        } 

        /*
            <selector 
              id = ID 
              xpath = An XPath expression 
              {any attributes with non-schema namespace . . .}>
              Content: (annotation?)
            </selector>
        */
        private static void InitSelector(XsdBuilder builder, string value) {
            builder.xso = builder.xpath = new XmlSchemaXPath();
            if ( builder.identityConstraint.Selector == null ) {
                builder.identityConstraint.Selector = builder.xpath;
            }
            else {
                builder.SendValidationEvent(Res.Sch_DupSelector, builder.identityConstraint.Name);
            }
        }

        private static void BuildSelector_XPath(XsdBuilder builder, string value) {
            builder.xpath.XPath = value;
        } 

        /*
            <field 
              id = ID 
              xpath = An XPath expression 
              {any attributes with non-schema namespace . . .}>
              Content: (annotation?)
            </field>
        */
        private static void InitField(XsdBuilder builder, string value) {
            builder.xso = builder.xpath = new XmlSchemaXPath();
            // no selector before fields?
            if ( builder.identityConstraint.Selector == null ) {
                builder.SendValidationEvent(Res.Sch_SelectorBeforeFields, builder.identityConstraint.Name);
            }
            builder.identityConstraint.Fields.Add(builder.xpath);
        }

        private static void BuildField_XPath(XsdBuilder builder, string value) {
            builder.xpath.XPath = value;
        } 

        /*
            <annotation>
              Content: (appinfo | documentation)*
            </annotation>
        */
        private static void InitAnnotation(XsdBuilder builder, string value) {
            if (builder.hasChild && builder.ParentElement != SchemaNames.ID.XSD_SCHEMA) {
                builder.SendValidationEvent(Res.Sch_AnnotationLocation, null);
            }
            builder.xso = builder.annotation = new XmlSchemaAnnotation();
            builder.ParentContainer.AddAnnotation(builder.annotation);
        }

        /*
            <appinfo 
              source = uriReference>
              Content: ({any})*
            </appinfo>
        */
        private static void InitAppinfo(XsdBuilder builder, string value) {
            builder.xso = builder.appInfo = new XmlSchemaAppInfo();
            builder.annotation.Items.Add(builder.appInfo);
            builder.markup = new XmlNode[] {};
        }

        private static void BuildAppinfo_Source(XsdBuilder builder, string value) {
            builder.appInfo.Source = ParseUriReference(value);
        }

        private static void EndAppinfo(XsdBuilder builder) {
            builder.appInfo.Markup = builder.markup;
        }


        /*
            <documentation 
              source = uriReference>
              Content: ({any})*
            </documentation>
        */
        private static void InitDocumentation(XsdBuilder builder, string value) {
            builder.xso = builder.documentation = new XmlSchemaDocumentation();
            builder.annotation.Items.Add(builder.documentation);
            builder.markup = new XmlNode[] {};
        }

        private static void BuildDocumentation_Source(XsdBuilder builder, string value) {
            builder.documentation.Source = ParseUriReference(value);
        }

        private static void BuildDocumentation_XmlLang(XsdBuilder builder, string value) {
            try {
                builder.documentation.Language = value;
            } 
            catch (XmlSchemaException e) {
                e.SetSource(builder.reader.BaseURI, builder.positionInfo.LineNumber, builder.positionInfo.LinePosition);
                builder.SendValidationEvent(e);
            }
        }

        private static void EndDocumentation(XsdBuilder builder) {
            builder.documentation.Markup = builder.markup;

        }


        ///////////////////////////////////////////////////////////////////////////////////////////////
        //
        // helper functions

        private void AddAttribute(XmlSchemaObject value) {
            switch (this.ParentElement) {
                case SchemaNames.ID.XSD_COMPLEXTYPE:
                    if (complexType.ContentModel != null) {
                        SendValidationEvent(Res.Sch_AttributeMutuallyExclusive, "attribute");
                    }
                    if (complexType.AnyAttribute != null) {
                        SendValidationEvent(Res.Sch_AnyAttributeLastChild, null);
                    }
                    this.complexType.Attributes.Add(value);
                    break;
                case SchemaNames.ID.XSD_SIMPLECONTENTRESTRICTION:
                    if (simpleContentRestriction.AnyAttribute != null) {
                        SendValidationEvent(Res.Sch_AnyAttributeLastChild, null);
                    }
                    this.simpleContentRestriction.Attributes.Add(value);
                    break;
                case SchemaNames.ID.XSD_SIMPLECONTENTEXTENSION:
                    if (simpleContentExtension.AnyAttribute != null) {
                        SendValidationEvent(Res.Sch_AnyAttributeLastChild, null);
                    }
                    this.simpleContentExtension.Attributes.Add(value);
                    break;
                case SchemaNames.ID.XSD_COMPLEXCONTENTEXTENSION:
                    if (complexContentExtension.AnyAttribute != null) {
                        SendValidationEvent(Res.Sch_AnyAttributeLastChild, null);
                    }
                    this.complexContentExtension.Attributes.Add(value);
                    break;
                case SchemaNames.ID.XSD_COMPLEXCONTENTRESTRICTION:
                    if (complexContentRestriction.AnyAttribute != null) {
                        SendValidationEvent(Res.Sch_AnyAttributeLastChild, null);
                    }
                    this.complexContentRestriction.Attributes.Add(value);
                    break;
                case SchemaNames.ID.XSD_ATTRIBUTEGROUP:
                    if (attributeGroup.AnyAttribute != null) {
                        SendValidationEvent(Res.Sch_AnyAttributeLastChild, null);
                    }
                    this.attributeGroup.Attributes.Add(value);
                    break;
                default:
                    Debug.Assert(false);
                    break;
            }
        }

        private void AddParticle(XmlSchemaParticle particle) {
            switch (this.ParentElement) {
                case SchemaNames.ID.XSD_COMPLEXTYPE:
                    if ( (complexType.ContentModel != null) || 
                         (complexType.Attributes.Count != 0 || complexType.AnyAttribute != null) ||
                         (complexType.Particle != null)
                         ) {
                        SendValidationEvent(Res.Sch_ComplexTypeContentModel, "complexType");
                    }
                    complexType.Particle = particle;
                    break;
                case SchemaNames.ID.XSD_COMPLEXCONTENTEXTENSION:
                    if ( (complexContentExtension.Particle != null) ||
                         (complexContentExtension.Attributes.Count != 0 || complexContentExtension.AnyAttribute != null)
                       ) {
                         SendValidationEvent(Res.Sch_ComplexContentContentModel, "ComplexContentExtension");
                    }
                    complexContentExtension.Particle = particle;
                    break;
                case SchemaNames.ID.XSD_COMPLEXCONTENTRESTRICTION:
                    if ( (complexContentRestriction.Particle != null) ||
                         (complexContentRestriction.Attributes.Count != 0 || complexContentRestriction.AnyAttribute != null)
                       ) {
                         SendValidationEvent(Res.Sch_ComplexContentContentModel, "ComplexContentExtension");
                    }
                    complexContentRestriction.Particle = particle;
                    break;
                case SchemaNames.ID.XSD_GROUP:
                    if (group.Particle != null) {
                        SendValidationEvent(Res.Sch_DupGroupParticle, "particle");
                    }
                    group.Particle = (XmlSchemaGroupBase)particle;
                    break;
                case SchemaNames.ID.XSD_CHOICE:
                case SchemaNames.ID.XSD_SEQUENCE:
                    ((XmlSchemaGroupBase)this.ParentContainer).Items.Add(particle);
                    break;
                default:
                    Debug.Assert(false);
                    break;
            }
        }

        private bool GetNextState(XmlQualifiedName qname) {
            if (this.currentEntry.NextStates != null) {
                foreach(State state in this.currentEntry.NextStates) {
                    if (this.schemaNames.GetName(SchemaEntries[(int)state].Name).Equals(qname)) {
                        this.nextEntry = SchemaEntries[(int)state];
                        return true;
                    }
                }
            }

            return false;
        }

        private bool IsSkipableElement(XmlQualifiedName qname) {
            return ((CurrentElement == SchemaNames.ID.XSD_DOCUMENTATION) ||
                    (CurrentElement == SchemaNames.ID.XSD_APPINFO));
        }

        private void SetMinOccurs(XmlSchemaParticle particle, string value) {
            try {
                particle.MinOccursString = value;
            }
            catch(Exception) {
                SendValidationEvent(Res.Sch_MinOccursInvalidXsd, null);
            }
        }

        private void SetMaxOccurs(XmlSchemaParticle particle, string value) {
            try {
                particle.MaxOccursString = value;
            }
            catch(Exception) {
                SendValidationEvent(Res.Sch_MaxOccursInvalidXsd, null);
            }
        }

        private bool ParseBoolean(string value, string attributeName) {
            try {
                return XmlConvert.ToBoolean(value);
            }
            catch(Exception) {
                SendValidationEvent(Res.Sch_InvalidXsdAttributeValue, attributeName, value, null);
                return false;
            }
        }

        private int ParseEnum(string value, string attributeName, string[] values) {
            string s = value.Trim();
            for (int i = 0; i < values.Length; i++) {
                if (values[i] == s)
                    return i + 1;
            }
            SendValidationEvent(Res.Sch_InvalidXsdAttributeValue, attributeName, s, null);
            return 0;
        }

        private XmlQualifiedName ParseQName(string value, string attributeName) {
            try {
                string prefix;
                return XmlQualifiedName.Parse(value, this.nameTable, this.namespaceManager, out prefix);
            } 
            catch(Exception) {
                SendValidationEvent(Res.Sch_InvalidXsdAttributeValue, attributeName, value, null);
                return XmlQualifiedName.Empty;
            }
        }

        private static readonly char[] Delimiters = {' ', '\t', '\n', '\r'};

        private int ParseEnumFlags(string value, string attributeName, string[] values, int[] intvalues) {
            Debug.Assert(values.Length == intvalues.Length);
            int r = 0;
            string[] ss = value.Split(Delimiters);
            for (int i = 0; i < ss.Length; i++) {
                if (ss[i] == string.Empty) {
                    continue;
                }
                bool matched = false;
                for (int j = 0; j < values.Length; j++) {
                    if (ss[i] == values[j]) {
                        if ((r & intvalues[j]) != 0) {
                            SendValidationEvent(Res.Sch_InvalidXsdAttributeValue, attributeName, value, null);
                            return 0;
                        }
                        r |= intvalues[j];
                        matched = true;
                        break;
                    }
                }
                if (!matched) {
                    SendValidationEvent(Res.Sch_InvalidXsdAttributeValue, attributeName, value, null);
                    return 0;
                }
            }
            return r;
        }

        private static string ParseUriReference(string s) {
            return s;
        }

        private void SendValidationEvent(string code, string arg0, string arg1, string arg2) {
            SendValidationEvent(new XmlSchemaException(code, new string[] { arg0, arg1, arg2 }, this.reader.BaseURI, this.positionInfo.LineNumber, this.positionInfo.LinePosition));
        }

        private void SendValidationEvent(string code, string msg) {
            SendValidationEvent(new XmlSchemaException(code, msg, this.reader.BaseURI, this.positionInfo.LineNumber, this.positionInfo.LinePosition));
        }

        private void SendValidationEvent(string code, string[] args, XmlSeverityType severity) {
            SendValidationEvent(new XmlSchemaException(code, args, this.reader.BaseURI, this.positionInfo.LineNumber, this.positionInfo.LinePosition), severity);
        }

        private void SendValidationEvent(XmlSchemaException e, XmlSeverityType severity) {
            if (validationEventHandler != null) {
                validationEventHandler(null, new ValidationEventArgs(e, severity));
            }
            else if (severity == XmlSeverityType.Error) {
                throw e;
            }
        }

        private void SendValidationEvent(XmlSchemaException e) {
            this.schema.ErrorCount ++;
            if (this.validationEventHandler != null) {
                this.validationEventHandler(this, new ValidationEventArgs(e));
            } 
            else {
                throw e;
            }
        }

        private void RecordPosition() {
            this.xso.SourceUri = this.reader.BaseURI;
            this.xso.LineNumber = this.positionInfo.LineNumber;
            this.xso.LinePosition = this.positionInfo.LinePosition;
            if (this.xso != this.schema) {
                this.xso.Parent = this.ParentContainer;
            }
        }

    }; // class XsdBuilder

} // namespace System.Xml.Schema
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\serialization\codeidentifier.cs ===
//------------------------------------------------------------------------------
// <copyright file="CodeIdentifier.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Serialization {
    
    using System;
    using System.Text;
    using System.Collections;
    using System.IO;
    using System.Globalization;
    using System.Diagnostics;
    using System.CodeDom.Compiler;

    /// <include file='doc\CodeIdentifier.uex' path='docs/doc[@for="CodeIdentifier"]/*' />
    ///<internalonly/>
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public class CodeIdentifier {

        private static readonly string[][] csharpkeywords = new string[][] {
            null,           // 1 character
            new string[] {  // 2 characters
                "as",
                "do",
                "if",
                "in",
                "is",
            },
            new string[] {  // 3 characters
                "for",
                "int",
                "new",
                "out",
                "ref",
                "try",
            },
            new string[] {  // 4 characters
                "base",
                "bool",
                "byte",
                "case",
                "char",
                "else",
                "enum",
                "goto",
                "lock",
                "long",
                "null",
                "this",
                "true",
                "uint",
                "void",
            },
            new string[] {  // 5 characters
                "break",
                "catch",
                "class",
                "const",
                "event",
                "false",
                "fixed",
                "float",
                "sbyte",
                "short",
                "throw",
                "ulong",
                "using",
                "while",
            },
            new string[] {  // 6 characters
                "double",
                "extern",
                "object",
                "params",
                "public",
                "return",
                "sealed",
                "sizeof",
                "static",
                "string",
                "struct",
                "switch",
                "typeof",
                "unsafe",
                "ushort",
            },
            new string[] {  // 7 characters
                "checked",
                "decimal",
                "default",
                "finally",
                "foreach",
                "private",
                "virtual",
            },
            new string[] {  // 8 characters
                "abstract",
                "continue",
                "delegate",
                "explicit",
                "implicit",
                "internal",
                "operator",
                "override",
                "readonly",
                "volatile",
            },
            new string[] {  // 9 characters
                "__arglist",
                "__makeref",
                "__reftype",
                "interface",
                "namespace",
                "protected",
                "unchecked",
            },
            new string[] {  // 10 characters
                "__refvalue",
                "stackalloc",
            },
        };


        /// <include file='doc\CodeIdentifier.uex' path='docs/doc[@for="CodeIdentifier.MakePascal"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static string MakePascal(string identifier) {
            identifier = MakeValid(identifier);
            if (identifier.Length <= 2)
                return identifier.ToUpper(CultureInfo.InvariantCulture);
            else if (char.IsLower(identifier[0]))
                return char.ToUpper(identifier[0], CultureInfo.InvariantCulture).ToString() + identifier.Substring(1);
            else
                return identifier;
        }
        
        /// <include file='doc\CodeIdentifier.uex' path='docs/doc[@for="CodeIdentifier.MakeCamel"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static string MakeCamel(string identifier) {
            identifier = MakeValid(identifier);
            if (identifier.Length <= 2)
                return identifier.ToLower(CultureInfo.InvariantCulture);
            else if (char.IsUpper(identifier[0]))
                return char.ToLower(identifier[0], CultureInfo.InvariantCulture).ToString() + identifier.Substring(1);
            else
                return identifier;
        }
        
        /// <include file='doc\CodeIdentifier.uex' path='docs/doc[@for="CodeIdentifier.MakeValid"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static string MakeValid(string identifier) {
            StringBuilder builder = new StringBuilder();
            for (int i = 0; i < identifier.Length; i++) {
                char c = identifier[i];
                if (IsValid(c)) builder.Append(c);
            }
            if (builder.Length == 0) return "Item";
            if (IsValidStart(builder[0]))
                return builder.ToString();
            else
                return "Item" + builder.ToString();
        }

        static bool IsValidStart(char c) {

            // the given char is already a valid name character
            #if DEBUG
                // use exception in the place of Debug.Assert to avoid throwing asserts from a server process such as aspnet_ewp.exe
                if (!IsValid(c)) throw new ArgumentException(Res.GetString(Res.XmlInternalErrorDetails, "Invalid identifier character " + ((Int16)c).ToString()), "c");
            #endif

            // First char cannot be a number
            if (Char.GetUnicodeCategory(c) == UnicodeCategory.DecimalDigitNumber)
                return false;
            return true;
        }

        static bool IsValid(char c) {
            UnicodeCategory uc = Char.GetUnicodeCategory(c);
            // each char must be Lu, Ll, Lt, Lm, Lo, Nd, Mn, Mc, Pc
            // 
            switch (uc) {
                case UnicodeCategory.UppercaseLetter:        // Lu
                case UnicodeCategory.LowercaseLetter:        // Ll
                case UnicodeCategory.TitlecaseLetter:        // Lt
                case UnicodeCategory.ModifierLetter:         // Lm
                case UnicodeCategory.OtherLetter:            // Lo
                case UnicodeCategory.DecimalDigitNumber:     // Nd
                case UnicodeCategory.NonSpacingMark:         // Mn
                case UnicodeCategory.SpacingCombiningMark:   // Mc
                case UnicodeCategory.ConnectorPunctuation:   // Pc
                    break;
                case UnicodeCategory.LetterNumber:
                case UnicodeCategory.OtherNumber:
                case UnicodeCategory.EnclosingMark:
                case UnicodeCategory.SpaceSeparator:
                case UnicodeCategory.LineSeparator:
                case UnicodeCategory.ParagraphSeparator:
                case UnicodeCategory.Control:
                case UnicodeCategory.Format:
                case UnicodeCategory.Surrogate:
                case UnicodeCategory.PrivateUse:
                case UnicodeCategory.DashPunctuation:
                case UnicodeCategory.OpenPunctuation:
                case UnicodeCategory.ClosePunctuation:
                case UnicodeCategory.InitialQuotePunctuation:
                case UnicodeCategory.FinalQuotePunctuation:
                case UnicodeCategory.OtherPunctuation:
                case UnicodeCategory.MathSymbol:
                case UnicodeCategory.CurrencySymbol:
                case UnicodeCategory.ModifierSymbol:
                case UnicodeCategory.OtherSymbol:
                case UnicodeCategory.OtherNotAssigned:
                    return false;
                default:
                    #if DEBUG
                        // use exception in the place of Debug.Assert to avoid throwing asserts from a server process such as aspnet_ewp.exe
                        throw new ArgumentException(Res.GetString(Res.XmlInternalErrorDetails, "Unhandled category " + uc), "c");
                    #else
                        return false;
                    #endif
            }
            return true;
        }

        internal static void CheckValidTypeIdentifier(string identifier) {
            if (identifier != null && identifier.Length > 0) {
                while (identifier.EndsWith("[]")) {
                    identifier = identifier.Substring(0, identifier.Length - 2);
                }
                string[] names = identifier.Split(new char[] {'.'});

                for (int i = 0; i < names.Length; i++) {
                    CheckValidIdentifier(names[i]);
                }
            }
        }

        internal static void CheckValidIdentifier(string ident) {
            if (!CodeGenerator.IsValidLanguageIndependentIdentifier(ident))
                throw new ArgumentException(Res.GetString(Res.XmlInvalidIdentifier, ident), "ident");
        }


        // CONSIDER: we should switch to using CodeCom for this.  Keep this for the performance reasons
        static bool IsKeyword(string value) {
            return FixedStringLookup.Contains(csharpkeywords, value, false);
        }

        internal static string EscapeKeywords(string identifier) {
            if (identifier == null || identifier.Length == 0) return identifier;
            string originalIdentifier = identifier;
            int arrayCount = 0;
            while (identifier.EndsWith("[]")) {
                arrayCount++;
                identifier = identifier.Substring(0, identifier.Length - 2);
            }
            string[] names = identifier.Split(new char[] {'.'});
            bool newIdent = false;
            StringBuilder sb = new StringBuilder();
            for (int i = 0; i < names.Length; i++) {
                if (i > 0) sb.Append(".");
                if (IsKeyword(names[i])) {
                    sb.Append("@");
                    newIdent = true;
                }
                CheckValidIdentifier(names[i]);
                sb.Append(names[i]);
            }

            if (newIdent) {
                for (int i = 0; i < arrayCount; i++)
                    sb.Append("[]");
                return sb.ToString();
            }
            return originalIdentifier;
        }
    }

    // This class provides a very efficient way to lookup an entry in a list of strings,
    // providing that they are declared in a particular way.
    
    // It requires the set of strings to be orderded into an array of arrays of strings.
    // The first indexer must the length of the string, so that each sub-array is of the
    // same length. The contained array must be in alphabetical order. Furthermore, if the 
    // table is to be searched case-insensitively, the strings must all be lower case.
    // CONSIDER: we should switch to using CodeCom for this.  Keep this for the performance reasons.
    internal class FixedStringLookup {
        
        // Returns whether the match is found in the lookup table
        internal static bool Contains(string[][] lookupTable, string value, bool ignoreCase) {
            int length = value.Length;
            if (length <= 0 || length - 1 >= lookupTable.Length) {
                return false;
            }

            string[] subArray = lookupTable[length - 1];
            if (subArray == null) {
                return false;
            }
            return Contains(subArray, value, ignoreCase);            
        }

        // This routine finds a hit within a single sorted array, with the assumption that the
        // value and all the strings are of the same length.
        private static bool Contains(string[] array, string value, bool ignoreCase) {
            int min = 0;
            int max = array.Length;
            int pos = 0;
            char searchChar;
            while (pos < value.Length) {            
                if (ignoreCase) {
                    searchChar = char.ToLower(value[pos]);
                } else {
                    searchChar = value[pos];
                }
                if ((max - min) <= 1) {
                    // we are down to a single item, so we can stay on this row until the end.
                    if (searchChar != array[min][pos]) {
                        return false;
                    }
                    pos++;
                    continue;
                }

                // There are multiple items to search, use binary search to find one of the hits
                if (!FindCharacter(array, searchChar, pos, ref min, ref max)) {
                    return false;
                }
                // and move to next char
                pos++;
            }
            return true;
        }

        // Do a binary search on the character array at the specific position and constrict the ranges appropriately.
        private static bool FindCharacter(string[] array, char value, int pos, ref int min, ref int max) {
            int index = min;
            while (min < max) {
                index = (min + max) / 2;
                char comp = array[index][pos];
                if (value == comp) {
                    // We have a match. Now adjust to any adjacent matches
                    int newMin = index;
                    while (newMin > min && array[newMin - 1][pos] == value) {
                        newMin--;
                    }
                    min = newMin;

                    int newMax = index + 1;
                    while (newMax < max && array[newMax][pos] == value) {
                        newMax++;
                    }
                    max = newMax;
                    return true;
                }
                if (value < comp) {
                    max = index;
                }
                else {
                    min = index + 1;
                }
            }
            return false;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\serialization\ixmlserializable.cs ===
//------------------------------------------------------------------------------
// <copyright file="IXmlSerializable.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Serialization {

    using System.Xml.Schema;

    /// <include file='doc\IXmlSerializable.uex' path='docs/doc[@for="IXmlSerializable"]/*' />
    ///<internalonly/>
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public interface IXmlSerializable {
        /// <include file='doc\IXmlSerializable.uex' path='docs/doc[@for="IXmlSerializable.GetSchema"]/*' />
        XmlSchema GetSchema();
        /// <include file='doc\IXmlSerializable.uex' path='docs/doc[@for="IXmlSerializable.ReadXml"]/*' />
        void ReadXml(XmlReader reader);
        /// <include file='doc\IXmlSerializable.uex' path='docs/doc[@for="IXmlSerializable.WriteXml"]/*' />
        void WriteXml(XmlWriter writer);
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\serialization\indentedwriter.cs ===
//------------------------------------------------------------------------------
// <copyright file="IndentedWriter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Serialization {

    using System.IO;
    
    /// <include file='doc\IndentedWriter.uex' path='docs/doc[@for="IndentedWriter"]/*' />
    /// <devdoc>
    ///     This class will write to a stream and manage indentation.
    /// </devdoc>
    internal class IndentedWriter {
        TextWriter writer;
        bool needIndent;
        int indentLevel;
        bool compact;
        
        internal IndentedWriter(TextWriter writer, bool compact) {
            this.writer = writer;
            this.compact = compact;
        }

        internal int Indent {
            get {
                return indentLevel;
            }
            set {
                indentLevel = value;
            }
        }
        
        internal void Write(string s) {
            if (needIndent) WriteIndent();
            writer.Write(s);
        }
        
        internal void Write(char c) {
            if (needIndent) WriteIndent();
            writer.Write(c);
        }
        
        internal void WriteLine(string s) {
            if (needIndent) WriteIndent();
            writer.WriteLine(s);
            needIndent = true;
        }
        
        internal void WriteLine() {
            writer.WriteLine();
            needIndent = true;
        }

        internal void WriteIndent() {
            needIndent = false;
            if (!compact) {
                for (int i = 0; i < indentLevel; i++) {
                    writer.Write("    ");
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\serialization\compiler.cs ===
//------------------------------------------------------------------------------
// <copyright file="Compiler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Serialization {
    using System.Reflection;
    using System.Reflection.Emit;
    using System.Collections;
    using System.IO;
    using System;
    using System.Text;
    using System.ComponentModel;
    using System.CodeDom.Compiler;
    using System.Security;
    using System.Security.Permissions;

    internal class Compiler {
        private FileIOPermission fileIOPermission;

        Hashtable imports = new Hashtable();
        StringWriter writer = new StringWriter();

        protected string[] Imports {
            get { 
                string[] array = new string[imports.Values.Count];
                imports.Values.CopyTo(array, 0);
                return array;
            }
        }
        
        internal void AddImport(Type type) {
            Type baseType = type.BaseType;
            if (baseType != null)
                AddImport(baseType);
            foreach (Type intf in type.GetInterfaces())
                AddImport(intf);
            FileIOPermission.Assert();
            Module module = type.Module;
            Assembly assembly = module.Assembly;
            if (module is ModuleBuilder || assembly.Location.Length == 0) {
                // current problems with dynamic modules:
                // 1. transient modules can't be supported since they aren't backed by disk.
                // 2. non-transient modules may not be saved to disk.
                // 3. saved, non-transient modules end up with InvalidCastException
                // CONSIDER, alexdej: allow non-transient, saved modules (ie fix #3)
                throw new InvalidOperationException(Res.GetString(Res.XmlCompilerDynModule, type.FullName, module.Name));
            }
            
            if (imports[assembly] == null) 
                imports.Add(assembly, assembly.Location);
        }

        private FileIOPermission FileIOPermission {
            get {
                if (fileIOPermission == null)
                    fileIOPermission = new FileIOPermission(PermissionState.Unrestricted);
                return fileIOPermission;
            }
        }

        internal TextWriter Source {
            get { return writer; }
        }

        internal void Close() { }

        internal Assembly Compile() {
            CodeDomProvider codeProvider = new Microsoft.CSharp.CSharpCodeProvider();
            ICodeCompiler compiler = codeProvider.CreateCompiler();
            CompilerParameters options = new CompilerParameters(Imports);

            // allows us to catch the "'X' is defined in multiple places" warning (1595)
            options.WarningLevel = 1;
            
            if (CompModSwitches.KeepTempFiles.Enabled) {
                options.GenerateInMemory = false;
                options.IncludeDebugInformation = true;
                options.TempFiles = new TempFileCollection();
                options.TempFiles.KeepFiles = true;
            }
            else {
                options.GenerateInMemory = true;
            }

            // CONSIDER, stefanph: we should probably have a specific CodeDomPermission.
            PermissionSet perms = new PermissionSet(PermissionState.None);
            perms.AddPermission(FileIOPermission);
            perms.AddPermission(new EnvironmentPermission(PermissionState.Unrestricted));
            perms.AddPermission(new SecurityPermission(SecurityPermissionFlag.UnmanagedCode));
            perms.Assert();

            CompilerResults results = null;
            Assembly assembly = null;
            try {
                results = compiler.CompileAssemblyFromSource(options, writer.ToString());
                assembly = results.CompiledAssembly;
            }
            finally {
                CodeAccessPermission.RevertAssert();
            }

            // check the output for errors or a certain level-1 warning (1595)
            if (results.Errors.Count > 0) {
                StringWriter stringWriter = new StringWriter();
                stringWriter.WriteLine(Res.GetString(Res.XmlCompilerError, results.NativeCompilerReturnValue.ToString()));
                bool foundOne = false;
                foreach (CompilerError e in results.Errors) {
                    // clear filename. This makes ToString() print just error number and message.
                    e.FileName = "";
                    if (!e.IsWarning || e.ErrorNumber == "CS1595") {
                        foundOne = true;
                        stringWriter.WriteLine(e.ToString());
                    }
                }
                if (foundOne) {
                    throw new InvalidOperationException(stringWriter.ToString());
                }
            }
            // somehow we got here without generating an assembly
            if (assembly == null) throw new InvalidOperationException(Res.GetString(Res.XmlInternalError));
            
            return assembly;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\serialization\codeidentifiers.cs ===
//------------------------------------------------------------------------------
// <copyright file="CodeIdentifiers.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Serialization {
    
    using System;
    using System.Collections;
    using System.IO;
    
    /// <include file='doc\CodeIdentifiers.uex' path='docs/doc[@for="CodeIdentifiers"]/*' />
    ///<internalonly/>
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public class CodeIdentifiers {
        Hashtable identifiers = new Hashtable();
        Hashtable reservedIdentifiers = new Hashtable();
        ArrayList list = new ArrayList();
        bool camelCase;

        /// <include file='doc\CodeIdentifiers.uex' path='docs/doc[@for="CodeIdentifiers.Clear"]/*' />
        public void Clear(){
            identifiers.Clear();
            list.Clear();
        }

        /// <include file='doc\CodeIdentifiers.uex' path='docs/doc[@for="CodeIdentifiers.UseCamelCasing"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public bool UseCamelCasing {
            get { return camelCase; }
            set { camelCase = value; }
        }

        /// <include file='doc\CodeIdentifiers.uex' path='docs/doc[@for="CodeIdentifiers.MakeRightCase"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public string MakeRightCase(string identifier) {
            if (camelCase)
                return CodeIdentifier.MakeCamel(identifier);
            else
                return CodeIdentifier.MakePascal(identifier);
        }
        
        /// <include file='doc\CodeIdentifiers.uex' path='docs/doc[@for="CodeIdentifiers.MakeUnique"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public string MakeUnique(string identifier) {
            if (IsInUse(identifier)) {
                for (int i = 1; ; i++) {
                    string newIdentifier = identifier + i.ToString();
                    if (!IsInUse(newIdentifier)) {
                        identifier = newIdentifier;
                        break;
                    }
                }
            }
            return identifier;
        }

        /// <include file='doc\CodeIdentifiers.uex' path='docs/doc[@for="CodeIdentifiers.AddReserved"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void AddReserved(string identifier) {
            reservedIdentifiers.Add(identifier, identifier);
        }
        
        /// <include file='doc\CodeIdentifiers.uex' path='docs/doc[@for="CodeIdentifiers.RemoveReserved"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void RemoveReserved(string identifier) {
            reservedIdentifiers.Remove(identifier);
        }
        
        /// <include file='doc\CodeIdentifiers.uex' path='docs/doc[@for="CodeIdentifiers.AddUnique"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public string AddUnique(string identifier, object value) {
            identifier = MakeUnique(identifier);
            Add(identifier, value);
            return identifier;
        }
        
        /// <include file='doc\CodeIdentifiers.uex' path='docs/doc[@for="CodeIdentifiers.IsInUse"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public bool IsInUse(string identifier) {
            return identifiers.Contains(identifier) || reservedIdentifiers.Contains(identifier);
        }
        
        /// <include file='doc\CodeIdentifiers.uex' path='docs/doc[@for="CodeIdentifiers.Add"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void Add(string identifier, object value) {
            identifiers.Add(identifier, value);
            list.Add(value);
        }
        
        /// <include file='doc\CodeIdentifiers.uex' path='docs/doc[@for="CodeIdentifiers.Remove"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void Remove(string identifier) {
            list.Remove(identifiers[identifier]);
            identifiers.Remove(identifier);
        }
        
        /// <include file='doc\CodeIdentifiers.uex' path='docs/doc[@for="CodeIdentifiers.ToArray"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public object ToArray(Type type) {
            //Array array = Array.CreateInstance(type, identifiers.Values.Count);
            //identifiers.Values.CopyTo(array, 0);
            Array array = Array.CreateInstance(type, list.Count);
            list.CopyTo(array, 0);
            return array;
        }

        internal CodeIdentifiers Clone() {
            CodeIdentifiers newIdentifiers = new CodeIdentifiers();
            newIdentifiers.identifiers = (Hashtable)this.identifiers.Clone();
            newIdentifiers.reservedIdentifiers = (Hashtable)this.reservedIdentifiers.Clone();
            newIdentifiers.list = (ArrayList)this.list.Clone();
            newIdentifiers.camelCase = this.camelCase;

            return newIdentifiers;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\serialization\mappings.cs ===
//------------------------------------------------------------------------------
// <copyright file="Mappings.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Serialization {

    using System.Reflection;
    using System.Collections;
    using System.Xml.Schema;
    using System;
    using System.ComponentModel;
    using System.Xml;
    
    // These classes represent a mapping between classes and a particular XML format.
    // There are two class of mapping information: accessors (such as elements and
    // attributes), and mappings (which specify the type of an accessor).

    internal abstract class Accessor {
        string name;
        object defaultValue = DBNull.Value;
        string ns;
        TypeMapping mapping;
        bool any;

        internal Accessor() { }

        internal TypeMapping Mapping {
            get { return mapping; }
            set { mapping = value; }
        }
        
        internal object Default {
            get { return defaultValue; }
            set { defaultValue = value; }
        }
        
        internal bool HasDefault {
            get { return defaultValue != null && defaultValue != DBNull.Value; }
        }
        
        internal virtual string Name {
            get { return name == null ? string.Empty : name; }
            set { name = value; }
        }

        internal bool Any {
            get { return any; }
            set { any = value; }
        }

        internal string Namespace {
            get { return ns; }
            set { ns = value; }
        }

        internal static string EscapeName(string name, bool canBeQName) {
            if (name == null || name.Length == 0) return name;

            if (canBeQName) {
                int colon = name.LastIndexOf(':');
                if (colon < 0)
                    return XmlConvert.EncodeLocalName(name);
                else {
                    if (colon == 0 || colon == name.Length - 1)
                        throw new ArgumentException(Res.GetString(Res.Xml_InvalidNameChars, name), "name");
                    return new XmlQualifiedName(XmlConvert.EncodeLocalName(name.Substring(colon + 1)), XmlConvert.EncodeLocalName(name.Substring(0, colon))).ToString();
                }
            }
            else
                return XmlConvert.EncodeLocalName(name);
        }

        internal static string UnescapeName(string name) {
            return XmlConvert.DecodeName(name);
        }
    }
    
    internal class ElementAccessor : Accessor {
        bool nullable;
        bool topLevelInSchema;
        XmlSchemaForm form = XmlSchemaForm.None;
        bool isSoap;

        internal bool IsSoap {
            get { return isSoap; }
            set { isSoap = value; }
        }
        
        internal bool IsNullable {
            get { return nullable; }
            set { nullable = value; }
        }

        internal bool IsTopLevelInSchema {
            get { return topLevelInSchema; }
            set { topLevelInSchema = value; }
        }

        internal XmlSchemaForm Form {
            get { return form; }
            set { form = value; }
        }
    }

    internal class ChoiceIdentifierAccessor : Accessor {
        string memberName;
        string[] memberIds;

        internal string MemberName {
            get { return memberName; }
            set { memberName = value; }
        }

        internal string[] MemberIds {
            get { return memberIds; }
            set { memberIds = value; }
        }

    }

    internal class TextAccessor : Accessor {
    }

    internal class XmlnsAccessor : Accessor {
    }
   
    internal class AttributeAccessor : Accessor {
        bool isSpecial;
        XmlSchemaForm form = XmlSchemaForm.None;
        bool isList;

        internal bool IsSpecialXmlNamespace {
            get { return isSpecial; }
        }

        internal XmlSchemaForm Form {
            get { return form; }
            set { form = value; }
        }

        internal bool IsList {
            get { return isList; }
            set { isList = value; }
        }

        internal void CheckSpecial() {
            int colon = Name.LastIndexOf(':');

            if (colon >= 0) {
                if (!Name.StartsWith("xml:")) {
                    throw new InvalidOperationException(Res.GetString(Res.Xml_InvalidNameChars, Name));
                }
                Name = Name.Substring("xml:".Length);
                Namespace = XmlReservedNs.NsXml;
                isSpecial = true;
            }
            else {
                if (Namespace == XmlReservedNs.NsXml) {
                    isSpecial = true;
                }
                else {
                    isSpecial = false;
                }
            }
            if (isSpecial) {
                form = XmlSchemaForm.Qualified;
            }
        }
    }

    internal abstract class Mapping {
        bool isSoap;

        internal Mapping() { }

        internal bool IsSoap {
            get { return isSoap; }
            set { isSoap = value; }
        }
    }

    internal abstract class TypeMapping : Mapping {
        TypeDesc typeDesc;
        string typeNs;
        string typeName;
        bool referencedByElement;
        bool referencedByTopLevelElement;
        bool includeInSchema = true;

        internal bool ReferencedByTopLevelElement {
            get { return referencedByTopLevelElement; }
            set { referencedByTopLevelElement = value; }
        }
        
        internal bool ReferencedByElement {
            get { return referencedByElement || referencedByTopLevelElement; }
            set { referencedByElement = value; }
        }
        internal string Namespace {
            get { return typeNs; }
            set { typeNs = value; }
        }

        internal string TypeName {
            get { return typeName; }
            set { typeName = value; }
        }
        
        internal TypeDesc TypeDesc {
            get { return typeDesc; }
            set { typeDesc = value; }
        }

        internal bool IncludeInSchema {
            get { return includeInSchema; }
            set { includeInSchema = value; }
        }

        internal virtual bool IsList {
            get { return false; }
            set { }
        }
    }
    
    internal class PrimitiveMapping : TypeMapping {
        bool isList;

        internal override bool IsList {
            get { return isList; }
            set { isList = value; }
        }
    }

    internal class ArrayMapping : TypeMapping {
        ElementAccessor[] elements;
        ElementAccessor[] sortedElements;
        ArrayMapping next;
        StructMapping topLevelMapping;

        internal ElementAccessor[] Elements {
            get { return elements; }
            set { elements = value; sortedElements = null; }
        }

        internal ElementAccessor[] ElementsSortedByDerivation {
            get {
                if (sortedElements != null)
                    return sortedElements;
                if (elements == null)
                    return null;
                sortedElements = new ElementAccessor[elements.Length];
                Array.Copy(elements, 0, sortedElements, 0, elements.Length);
                AccessorMapping.SortMostToLeastDerived(sortedElements);
                return sortedElements;
            }
        }


        internal ArrayMapping Next {
            get { return next; }
            set { next = value; }
        }

        internal StructMapping TopLevelMapping {
            get { return topLevelMapping; }
            set { topLevelMapping = value; }
        }
    }
    
    internal class EnumMapping : PrimitiveMapping {
        ConstantMapping[] constants;
        bool isFlags;

        internal bool IsFlags {
            get { return isFlags; }
            set { isFlags = value; }
        }

        internal ConstantMapping[] Constants {
            get { return constants; }
            set { constants = value; }
        }
    }
    
    internal class ConstantMapping : Mapping {
        string xmlName;
        string name;
        long value;
        
        internal string XmlName {
            get { return xmlName== null ? string.Empty : xmlName; }
            set { xmlName = value; }
        }
        
        internal string Name {
            get { return name == null ? string.Empty : name; }
            set { this.name = value; }
        }

        internal long Value {
            get { return value; }
            set { this.value = value; }
        }
    }
    
    internal class StructMapping : TypeMapping {
        MemberMapping[] members;
        StructMapping baseMapping;
        StructMapping derivedMappings;
        StructMapping nextDerivedMapping;
        MemberMapping xmlnsMember = null;
        bool hasSimpleContent;
        NameTable elements;
        NameTable attributes;
        CodeIdentifiers scope;

        internal StructMapping BaseMapping {
            get { return baseMapping; }
            set { 
                baseMapping = value; 
                if (baseMapping != null) {
                    nextDerivedMapping = baseMapping.derivedMappings;
                    baseMapping.derivedMappings = this;
                }
            }
        }

        internal StructMapping DerivedMappings {
            get { return derivedMappings; }
        }

        internal NameTable LocalElements {
            get {
                if (elements == null)
                    elements = new NameTable();
                return elements; 
            }
        }
        internal NameTable LocalAttributes {
            get {
                if (attributes == null)
                    attributes = new NameTable();
                return attributes; 
            }
        }
        
        internal StructMapping NextDerivedMapping {
            get { return nextDerivedMapping; }
        }

        internal bool HasSimpleContent {
            get { return hasSimpleContent; }
        }

        internal bool HasXmlnsMember {
            get {
                StructMapping mapping = this;
                while (mapping != null) {
                    if (mapping.XmlnsMember != null)
                        return true;
                    mapping = mapping.BaseMapping;
                }
                return false;
            }
        }
        
        internal MemberMapping[] Members {
            get { return members; }
            set { members = value; }
        }

        internal MemberMapping XmlnsMember {
            get { return xmlnsMember; }
            set { xmlnsMember = value; }
        }

        internal CodeIdentifiers Scope {
            get {
                if (scope == null)
                    scope = new CodeIdentifiers();
                return scope; 
            }
            set { scope = value; }
        }

        internal MemberMapping FindDeclaringMapping(MemberMapping member, out StructMapping declaringMapping, string parent) {
            declaringMapping = null;
            if (BaseMapping != null) {
                MemberMapping baseMember =  BaseMapping.FindDeclaringMapping(member, out declaringMapping, parent);
                if (baseMember != null) return baseMember;
            }
            if (members == null) return null;

            for (int i = 0; i < members.Length; i++) {
                if (members[i].Name == member.Name) {
                    if (members[i].TypeDesc != member.TypeDesc) 
                        throw new InvalidOperationException(Res.GetString(Res.XmlHiddenMember, parent, member.Name, member.TypeDesc.FullName, this.TypeName, members[i].Name, members[i].TypeDesc.FullName));
                    else if (!members[i].Match(member)) {
                        throw new InvalidOperationException(Res.GetString(Res.XmlInvalidXmlOverride, parent, member.Name, this.TypeName, members[i].Name));
                    }
                    declaringMapping = this;
                    return members[i];
                }
            }
            return null;
        }
        internal bool Declares(MemberMapping member, string parent) {
            StructMapping m;
            return (FindDeclaringMapping(member, out m, parent) != null);
        }

        internal void SetContentModel(TextAccessor text, bool hasElements) {
            if (BaseMapping == null || BaseMapping.TypeDesc.IsRoot) {
                hasSimpleContent = !hasElements && text != null && !text.Mapping.IsList;
            }
            else if (BaseMapping.HasSimpleContent) {
                if (text != null || hasElements) {
                    // we can only extent a simleContent type with attributes
                    throw new InvalidOperationException(Res.GetString(Res.XmlIllegalSimpleContentExtension, TypeDesc.FullName, BaseMapping.TypeDesc.FullName));
                }
                else {
                    hasSimpleContent = true;
                }
            }
            else {
                hasSimpleContent = false;
            }
            if (!hasSimpleContent && text != null && !text.Mapping.TypeDesc.CanBeTextValue) {
                throw new InvalidOperationException(Res.GetString(Res.XmlIllegalTypedTextAttribute, TypeDesc.FullName, text.Name, text.Mapping.TypeDesc.FullName));
            }
        }
    }
    
    internal abstract class AccessorMapping : Mapping {
        TypeDesc typeDesc;
        AttributeAccessor attribute;
        ElementAccessor[] elements;
        ElementAccessor[] sortedElements;
        TextAccessor text;
        ChoiceIdentifierAccessor choiceIdentifier;
        XmlnsAccessor xmlns;
        bool ignore;
        
        internal TypeDesc TypeDesc {
            get { return typeDesc; }
            set { typeDesc = value; }
        }
        
        internal AttributeAccessor Attribute {
            get { return attribute; }
            set { attribute = value; }
        }
        
        internal ElementAccessor[] Elements {
            get { return elements; }
            set { elements = value; sortedElements = null; }
        }

        internal static void SortMostToLeastDerived(ElementAccessor[] elements) {
            for (int i = 0; i < elements.Length; i++) {
                for (int j = i+1; j < elements.Length; j++) {
                    if (elements[j].Mapping.TypeDesc.IsDerivedFrom(elements[i].Mapping.TypeDesc)) {
                        ElementAccessor temp = elements[i];
                        elements[i] = elements[j];
                        elements[j] = temp;
                    }
                }
            }
        }

        internal ElementAccessor[] ElementsSortedByDerivation {
            get {
                if (sortedElements != null)
                    return sortedElements;
                if (elements == null)
                    return null;
                sortedElements = new ElementAccessor[elements.Length];
                Array.Copy(elements, 0, sortedElements, 0, elements.Length);
                SortMostToLeastDerived(sortedElements);
                return sortedElements;
            }
        }

        internal TextAccessor Text {
            get { return text; }
            set { text = value; }
        }

        internal ChoiceIdentifierAccessor ChoiceIdentifier {
            get { return choiceIdentifier; }
            set { choiceIdentifier = value; }
        }

        internal XmlnsAccessor Xmlns {
            get { return xmlns; }
            set { xmlns = value; }
        }

        internal bool Ignore {
            get { return ignore; }
            set { ignore = value; }
        }

        internal Accessor Accessor {
            get {
                if (xmlns != null) return xmlns;
                if (attribute != null) return attribute;
                if (elements != null && elements.Length > 0) return elements[0];
                return text;
            }
        }
        internal static bool ElementsMatch(ElementAccessor[] a, ElementAccessor[] b) {
            if (a == null) {
                if (b == null)
                    return true;
                return false;
            }
            if (b == null)
                return false;
            if (a.Length != b.Length)
                return false;
            for (int i = 0; i < a.Length; i++) {
                if (a[i].Name != b[i].Name || a[i].Namespace != b[i].Namespace || a[i].Form != b[i].Form || a[i].IsNullable != b[i].IsNullable)
                    return false;
            }
            return true;
        }

        internal bool Match(AccessorMapping mapping) {
            if (Elements != null && Elements.Length > 0) {
                if (!ElementsMatch(Elements, mapping.Elements)) {
                    return false;
                }
                if (Text == null) {
                    return (mapping.Text == null);
                }
            }
            if (Attribute != null) {
                if (mapping.Attribute == null)
                    return false;
                return (Attribute.Name == mapping.Attribute.Name && Attribute.Namespace == mapping.Attribute.Namespace && Attribute.Form == mapping.Attribute.Form);
            }
            if (Text != null) {
                return (mapping.Text != null);
            }
            return (mapping.Accessor == null);
        }
    }

    internal class MemberMapping : AccessorMapping {
        string name;
        bool checkShouldPersist;
        bool checkSpecified;
        bool isReturnValue;
        bool readOnly = false;

        internal bool CheckShouldPersist {
            get { return checkShouldPersist; }
            set { checkShouldPersist = value; }
        }
        
        internal bool CheckSpecified {
            get { return checkSpecified; }
            set { checkSpecified = value; }
        }

        internal string Name {
            get { return name == null ? string.Empty : name; }
            set { name = value; }
        }

        internal bool IsReturnValue {
            get { return isReturnValue; }
            set { isReturnValue = value; }
        }

        internal bool ReadOnly {
            get { return readOnly; }
            set { readOnly = value; }
        }
    }
   
    internal class MembersMapping : TypeMapping {
        MemberMapping[] members;
        bool hasWrapperElement = true;
        bool validateRpcWrapperElement;
        bool writeAccessors = true;
        MemberMapping xmlnsMember = null;
        
        internal MemberMapping[] Members {
            get { return members; }
            set { members = value; }
        }

        internal MemberMapping XmlnsMember {
            get { return xmlnsMember; }
            set { xmlnsMember = value; }
        }

        internal bool HasWrapperElement {
            get { return hasWrapperElement; }
            set { hasWrapperElement = value; }
        }

        internal bool ValidateRpcWrapperElement {
            get { return validateRpcWrapperElement; }
            set { validateRpcWrapperElement = value; }
        }

        internal bool WriteAccessors {
            get { return writeAccessors; }
            set { writeAccessors = value; }
        }
    }

    internal class SpecialMapping : TypeMapping {
        bool namedAny;

        internal bool NamedAny {
            get { return namedAny; }
            set { namedAny = value; }
        }
    }

    internal class SerializableMapping : SpecialMapping {
        XmlSchema schema;
        Type type;

        internal Type Type {
            get { return type; }
            set { 
                type = value;
                IXmlSerializable serializable = (IXmlSerializable)Activator.CreateInstance(type);
                schema = serializable.GetSchema();
                if (schema != null) {
                    if (schema.Id == null || schema.Id.Length == 0) throw new InvalidOperationException(Res.GetString(Res.XmlSerializableNameMissing1, type.FullName));
                }
            }
        }

        internal XmlSchema Schema {
            get { return schema; }
            set {
                schema = value; 
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\serialization\soapattributeoverrides.cs ===
//------------------------------------------------------------------------------
// <copyright file="SoapAttributeOverrides.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Serialization {
    using System.Reflection;
    using System.Collections;
    using System.IO;
    using System.Xml.Schema;
    using System;
    using System.ComponentModel;

    /// <include file='doc\SoapAttributeOverrides.uex' path='docs/doc[@for="SoapAttributeOverrides"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public class SoapAttributeOverrides {
        Hashtable types = new Hashtable();

        /// <include file='doc\SoapAttributeOverrides.uex' path='docs/doc[@for="SoapAttributeOverrides.Add"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void Add(Type type, SoapAttributes attributes) {
            Add(type, string.Empty, attributes);
        }

        /// <include file='doc\SoapAttributeOverrides.uex' path='docs/doc[@for="SoapAttributeOverrides.Add1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void Add(Type type, string member, SoapAttributes attributes) {
            Hashtable members = (Hashtable)types[type];
            if (members == null) {
                members = new Hashtable();
                types.Add(type, members);
            }
            else if (members[member] != null) {
                throw new InvalidOperationException(Res.GetString(Res.XmlMultipleAttributeOverrides, type.FullName, member));
            }
            members.Add(member, attributes);
        }

        /// <include file='doc\SoapAttributeOverrides.uex' path='docs/doc[@for="SoapAttributeOverrides.this"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public SoapAttributes this[Type type] {
            get {
                return this[type, string.Empty];
            }
        }

        /// <include file='doc\SoapAttributeOverrides.uex' path='docs/doc[@for="SoapAttributeOverrides.this1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public SoapAttributes this[Type type, string member] {
            get {
                Hashtable members = (Hashtable)types[type];
                if (members == null) return null;
                return (SoapAttributes)members[member];
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\serialization\soapattributeattribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="SoapAttributeAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Serialization {
    using System;

    /// <include file='doc\SoapAttributeAttribute.uex' path='docs/doc[@for="SoapAttributeAttribute"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [AttributeUsage(AttributeTargets.Field | AttributeTargets.Property | AttributeTargets.Parameter | AttributeTargets.ReturnValue)]
    public class SoapAttributeAttribute : System.Attribute {
        string attrName;
        string ns;
        string dataType;
        
        /// <include file='doc\SoapAttributeAttribute.uex' path='docs/doc[@for="SoapAttributeAttribute.SoapAttributeAttribute"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public SoapAttributeAttribute() {
        }
        
        /// <include file='doc\SoapAttributeAttribute.uex' path='docs/doc[@for="SoapAttributeAttribute.SoapAttributeAttribute1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public SoapAttributeAttribute(string attrName) {
            this.attrName = attrName;
        }

        /// <include file='doc\SoapAttributeAttribute.uex' path='docs/doc[@for="SoapAttributeAttribute.ElementName"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public string AttributeName {
            get { return attrName == null ? string.Empty : attrName; }
            set { attrName = value; }
        }

        /// <include file='doc\SoapAttributeAttribute.uex' path='docs/doc[@for="SoapAttributeAttribute.Namespace"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public string Namespace {
            get { return ns; }
            set { ns = value; }
        }

        /// <include file='doc\SoapAttributeAttribute.uex' path='docs/doc[@for="SoapAttributeAttribute.DataType"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public string DataType {
            get { return dataType == null ? string.Empty : dataType; }
            set { dataType = value; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\serialization\nametable.cs ===
//------------------------------------------------------------------------------
// <copyright file="NameTable.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Serialization {

    using System.Collections;

    internal class NameKey {
        string ns;
        string name;

        internal NameKey(string name, string ns) {
            this.name = name;
            this.ns = ns;
        }

        public override bool Equals(object other) {
            if (!(other is NameKey)) return false;
            NameKey key = (NameKey)other;
            return name == key.name && ns == key.ns;
        }

        public override int GetHashCode() {
            return (ns == null ? 0 : ns.GetHashCode()) ^ (name == null ? 0 : name.GetHashCode());
        }
    }

    internal class NameTable {
        Hashtable table = new Hashtable();

        internal void Add(string name, string ns, object value) {
            NameKey key = new NameKey(name, ns);
            table.Add(key, value);
        }

        internal object this[string name, string ns] {
            get {
                return table[new NameKey(name, ns)];
            }
            set {
                table[new NameKey(name, ns)] = value;
            }
        }

        internal ICollection Values {
            get { return table.Values; }
        }

        internal Array ToArray(Type type) {
            Array a = Array.CreateInstance(type, table.Count);
            table.Values.CopyTo(a, 0);
            return a;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\serialization\compilation.cs ===
//------------------------------------------------------------------------------
// <copyright file="Compilation.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Serialization {

    using System.Reflection;
    using System.Collections;
    using System.IO;
    using System;
    using System.Xml;
    using System.Threading;
    using System.Security;
    using System.Security.Permissions;

    internal class TempAssembly {
        const string GeneratedAssemblyNamespace = "Microsoft.Xml.Serialization.GeneratedAssembly";
        const string LinkDemandAttribute = "[System.Security.Permissions.PermissionSet(System.Security.Permissions.SecurityAction.LinkDemand, Name=\"FullTrust\")]";
        Assembly assembly;
        Type writerType;
        Type readerType;
        TempMethod[] methods;
        static object[] emptyObjectArray = new object[0];
        Hashtable assemblies;
        bool allAssembliesAllowPartialTrust;

        internal class TempMethod {
            internal MethodInfo writeMethod;
            internal MethodInfo readMethod;
            internal string name;
            internal string ns;
            internal bool isSoap;
        }

        internal TempAssembly(XmlMapping[] xmlMappings) {
            Compiler compiler = new Compiler();
            allAssembliesAllowPartialTrust = false;
            try {
                Hashtable scopeTable = new Hashtable();
                foreach (XmlMapping mapping in xmlMappings)
                    scopeTable[mapping.Scope] = mapping;
                TypeScope[] scopes = new TypeScope[scopeTable.Keys.Count];
                scopeTable.Keys.CopyTo(scopes, 0);
                
                allAssembliesAllowPartialTrust = true;
                assemblies = new Hashtable();
                foreach (TypeScope scope in scopes) {
                    foreach (Type t in scope.Types) {
                        compiler.AddImport(t);
                        Assembly a = t.Assembly;
                        if (allAssembliesAllowPartialTrust && !AssemblyAllowsPartialTrust(a))
                            allAssembliesAllowPartialTrust = false;
                        if (!a.GlobalAssemblyCache)
                            assemblies[a.FullName] = a;
                    }
                }
                compiler.AddImport(typeof(XmlWriter));
                compiler.AddImport(typeof(XmlSerializationWriter));
                compiler.AddImport(typeof(XmlReader));
                compiler.AddImport(typeof(XmlSerializationReader));

                IndentedWriter writer = new IndentedWriter(compiler.Source, false);
                
                // CONSIDER, alexdej: remove this (not necessary since generated assembly isn't signed)
                writer.WriteLine("[assembly:System.Security.AllowPartiallyTrustedCallers()]");

                writer.WriteLine("namespace " + GeneratedAssemblyNamespace + " {");
                writer.Indent++;
                writer.WriteLine();

                XmlSerializationWriterCodeGen writerCodeGen = new XmlSerializationWriterCodeGen(writer, scopes);

                writerCodeGen.GenerateBegin();
                string[] writeMethodNames = new string[xmlMappings.Length];
                for (int i = 0; i < xmlMappings.Length; i++) {
                    if (!allAssembliesAllowPartialTrust) {
                        writer.WriteLine(LinkDemandAttribute);
                    }
                    writeMethodNames[i] = writerCodeGen.GenerateElement(xmlMappings[i]);
                }
                writerCodeGen.GenerateEnd();
                    
                writer.WriteLine();
                
                XmlSerializationReaderCodeGen readerCodeGen = new XmlSerializationReaderCodeGen(writer, scopes);

                readerCodeGen.GenerateBegin();
                string[] readMethodNames = new string[xmlMappings.Length];
                for (int i = 0; i < xmlMappings.Length; i++) {
                    if (!allAssembliesAllowPartialTrust) {
                        writer.WriteLine(LinkDemandAttribute);
                    }
                    readMethodNames[i] = readerCodeGen.GenerateElement(xmlMappings[i]);
                }
                readerCodeGen.GenerateEnd();
                    
                writer.Indent--;
                writer.WriteLine("}");

                assembly = compiler.Compile();

                methods = new TempMethod[xmlMappings.Length];
                
                readerType = GetTypeFromAssembly("XmlSerializationReader1");
                writerType = GetTypeFromAssembly("XmlSerializationWriter1");

                for (int i = 0; i < methods.Length; i++) {
                    TempMethod method = new TempMethod();
                    method.isSoap = xmlMappings[i].IsSoap;
                    XmlTypeMapping xmlTypeMapping = xmlMappings[i] as XmlTypeMapping;
                    if (xmlTypeMapping != null) {
                        method.name = xmlTypeMapping.ElementName;
                        method.ns = xmlTypeMapping.Namespace;
                    }
                    method.readMethod = GetMethodFromType(readerType, readMethodNames[i]);
                    method.writeMethod = GetMethodFromType(writerType, writeMethodNames[i]);
                    methods[i] = method;
                }
            }
            finally {
                compiler.Close();
            }
        }

        // assert FileIOPermission so we can look at the AssemblyName
        [FileIOPermission(SecurityAction.Assert, Unrestricted=true)]
        bool AssemblyAllowsPartialTrust(Assembly a) {
            // assembly allows partial trust if it has APTC attr or is not strong-named signed
            if (a.GetCustomAttributes(typeof(AllowPartiallyTrustedCallersAttribute), false).Length > 0) {
                // has APTC attr
                return true;
            }
            else {
                // no attr: check for strong-name signing
                return a.GetName().GetPublicKey().Length == 0;
            }
        }

        MethodInfo GetMethodFromType(Type type, string methodName) {
            MethodInfo method = type.GetMethod(methodName);
            if (method != null) return method;
            throw new InvalidOperationException(Res.GetString(Res.XmlMissingMethod, methodName, type.FullName));
        }
        
        Type GetTypeFromAssembly(string typeName) {
            typeName = GeneratedAssemblyNamespace + "." + typeName;
            Type type = assembly.GetType(typeName);
            if (type == null) throw new InvalidOperationException(Res.GetString(Res.XmlMissingType, typeName));
            return type;
        }

        internal bool CanRead(int methodIndex, XmlReader xmlReader) {
            TempMethod method = methods[methodIndex];
            return xmlReader.IsStartElement(method.name, method.ns);
        }
        
        string ValidateEncodingStyle(string encodingStyle, int methodIndex) {
            if (encodingStyle != null && encodingStyle.Length > 0) {
                if (methods[methodIndex].isSoap) {
                    if (encodingStyle != Soap.Encoding && encodingStyle != Soap12.Encoding) {
                        throw new InvalidOperationException(Res.GetString(Res.XmlInvalidEncoding3, encodingStyle, Soap.Encoding, Soap12.Encoding));
                    }
                }
                else {
                    throw new InvalidOperationException(Res.GetString(Res.XmlInvalidEncodingNotEncoded1, encodingStyle));
                }
            }
            else {
                if (methods[methodIndex].isSoap) {
                    encodingStyle = Soap.Encoding;
                }
            }
            return encodingStyle;
        }

        internal object InvokeReader(int methodIndex, XmlReader xmlReader, XmlDeserializationEvents events, string encodingStyle) {
            XmlSerializationReader reader = null;
            try {
                encodingStyle = ValidateEncodingStyle(encodingStyle, methodIndex);
                reader = (XmlSerializationReader)Activator.CreateInstance(readerType);
                reader.Init(xmlReader, events, encodingStyle, this);
                
                return methods[methodIndex].readMethod.Invoke(reader, emptyObjectArray);
            }
            catch (SecurityException e) {
                throw new InvalidOperationException(Res.GetString(Res.XmlNoPartialTrust), e);
            }
            finally {
                if (reader != null)
                    reader.Dispose();
            }
        }

        internal void InvokeWriter(int methodIndex, XmlWriter xmlWriter, object o, ArrayList namespaces, string encodingStyle) {
            XmlSerializationWriter writer = null;
            try {
                encodingStyle = ValidateEncodingStyle(encodingStyle, methodIndex);
                writer = (XmlSerializationWriter)Activator.CreateInstance(writerType);
                writer.Init(xmlWriter, namespaces, encodingStyle, this);

                methods[methodIndex].writeMethod.Invoke(writer, new object[] { o });
            }
            catch (SecurityException e) {
                throw new InvalidOperationException(Res.GetString(Res.XmlNoPartialTrust), e);
            }
            finally {
                if (writer != null)
                    writer.Dispose();
            }
        }

        internal Assembly GetReferencedAssembly(string name) {
            return assemblies != null && name != null ? (Assembly)assemblies[name] : null;
        }
    }

    class TempAssemblyCacheKey {
        string ns;
        object type;
        
        internal TempAssemblyCacheKey(string ns, object type) {
            this.type = type;
            this.ns = ns;
        }

        public override bool Equals(object o) {
            TempAssemblyCacheKey key = o as TempAssemblyCacheKey;
            if (key == null) return false;

            return (key.type == this.type && key.ns == this.ns);
        }

        public override int GetHashCode() {
            return ((ns != null ? ns.GetHashCode() : 0) ^ (type != null ? type.GetHashCode() : 0));
        }
    }

    internal class TempAssemblyCache {
        Hashtable cache = new Hashtable();

        internal TempAssembly this[string ns, object o] {
            get { return (TempAssembly)cache[new TempAssemblyCacheKey(ns, o)]; }
        }

        internal void Add(string ns, object o, TempAssembly assembly) {
            TempAssemblyCacheKey key = new TempAssemblyCacheKey(ns, o);
            lock(this) {
                if (cache[key] == assembly) return;
                Hashtable clone = new Hashtable();
                foreach (object k in cache.Keys) {
                    clone.Add(k, cache[k]);
                }
                cache = clone;
                cache[key] = assembly;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\serialization\soapattributes.cs ===
//------------------------------------------------------------------------------
// <copyright file="SoapAttributes.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Serialization {
    using System;
    using System.Reflection;
    using System.Collections;
    using System.ComponentModel;

    internal enum SoapAttributeFlags {
        Enum = 0x1,
        Type = 0x2,
        Element = 0x4,
        Attribute = 0x8,
    }

    /// <include file='doc\SoapAttributes.uex' path='docs/doc[@for="SoapAttributes"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public class SoapAttributes {
        bool soapIgnore;
        SoapTypeAttribute soapType;
        SoapElementAttribute soapElement;
        SoapAttributeAttribute soapAttribute;
        SoapEnumAttribute soapEnum;
        object soapDefaultValue = DBNull.Value;
        
        /// <include file='doc\SoapAttributes.uex' path='docs/doc[@for="SoapAttributes.SoapAttributes"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public SoapAttributes() {
        }

        /// <include file='doc\SoapAttributes.uex' path='docs/doc[@for="SoapAttributes.SoapAttributes1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public SoapAttributes(ICustomAttributeProvider provider) {
            soapIgnore = GetAttr(provider, typeof(SoapIgnoreAttribute)) != null;
            if (!soapIgnore) {
                soapElement = (SoapElementAttribute)GetAttr(provider, typeof(SoapElementAttribute));
                soapAttribute = (SoapAttributeAttribute)GetAttr(provider, typeof(SoapAttributeAttribute));
                soapType = (SoapTypeAttribute)GetAttr(provider, typeof(SoapTypeAttribute));
                soapEnum = (SoapEnumAttribute)GetAttr(provider, typeof(SoapEnumAttribute));

                DefaultValueAttribute defaultValueAttribute = (DefaultValueAttribute)GetAttr(provider, typeof(DefaultValueAttribute));
                if (defaultValueAttribute != null) soapDefaultValue = defaultValueAttribute.Value;
            }
        }

        object GetAttr(ICustomAttributeProvider provider, Type attrType) {
            object[] attrs = provider.GetCustomAttributes(attrType, false);
            if (attrs.Length == 0) return null;
            return attrs[0];
        }
        
        internal SoapAttributeFlags SoapFlags {
            get { 
                SoapAttributeFlags flags = 0;
                if (soapElement != null) flags |= SoapAttributeFlags.Element;
                if (soapAttribute != null) flags |= SoapAttributeFlags.Attribute;
                if (soapEnum != null) flags |= SoapAttributeFlags.Enum;
                if (soapType != null) flags |= SoapAttributeFlags.Type;
                return flags;
            }
        }

        /// <include file='doc\SoapAttributes.uex' path='docs/doc[@for="SoapAttributes.SoapType"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public SoapTypeAttribute SoapType {
            get { return soapType; }
            set { soapType = value; }
        }
        
        /// <include file='doc\SoapAttributes.uex' path='docs/doc[@for="SoapAttributes.SoapEnum"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public SoapEnumAttribute SoapEnum {
            get { return soapEnum; }
            set { soapEnum = value; }
        }
        
        /// <include file='doc\SoapAttributes.uex' path='docs/doc[@for="SoapAttributes.SoapIgnore"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public bool SoapIgnore {
            get { return soapIgnore; }
            set { soapIgnore = value; }
        }
        
        /// <include file='doc\SoapAttributes.uex' path='docs/doc[@for="SoapAttributes.SoapElement"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public SoapElementAttribute SoapElement {
            get { return soapElement; }
            set { soapElement = value; }
        }
        
        /// <include file='doc\SoapAttributes.uex' path='docs/doc[@for="SoapAttributes.SoapAttribute"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public SoapAttributeAttribute SoapAttribute {
            get { return soapAttribute; }
            set { soapAttribute = value; }
        }

        /// <include file='doc\SoapAttributes.uex' path='docs/doc[@for="SoapAttributes.SoapDefaultValue"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public object SoapDefaultValue {
            get { return soapDefaultValue; }
            set { soapDefaultValue = value; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\serialization\soapcodeexporter.cs ===
//------------------------------------------------------------------------------
// <copyright file="SoapCodeExporter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Serialization {
    
    using System;
    using System.Collections;
    using System.IO;
    using System.ComponentModel;
    using System.Xml.Schema;
    using System.CodeDom;
    using System.CodeDom.Compiler;
    using System.Reflection;
    using System.Diagnostics;
    using System.Xml;

    /// <include file='doc\SoapCodeExporter.uex' path='docs/doc[@for="SoapCodeExporter"]/*' />
    /// <internalonly/>
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public class SoapCodeExporter {
        Hashtable exportedMappings = new Hashtable();
        CodeNamespace codeNamespace;
        bool rootExported;
        TypeScope scope;
        CodeAttributeDeclarationCollection includeMetadata = new CodeAttributeDeclarationCollection();

        /// <include file='doc\SoapCodeExporter.uex' path='docs/doc[@for="SoapCodeExporter.SoapCodeExporter"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public SoapCodeExporter(CodeNamespace codeNamespace) {
            if (codeNamespace != null)
                CodeGenerator.ValidateIdentifiers(codeNamespace);
            this.codeNamespace = codeNamespace;
        }

        /// <include file='doc\SoapCodeExporter.uex' path='docs/doc[@for="SoapCodeExporter.SoapCodeExporter1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public SoapCodeExporter(CodeNamespace codeNamespace, CodeCompileUnit codeCompileUnit) : this(codeNamespace) {
            if (codeCompileUnit != null) {
                codeCompileUnit.ReferencedAssemblies.Add("System.dll");
                codeCompileUnit.ReferencedAssemblies.Add("System.Xml.dll");
            }
        }


        /// <include file='doc\SoapCodeExporter.uex' path='docs/doc[@for="SoapCodeExporter.ExportTypeMapping"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void ExportTypeMapping(XmlTypeMapping xmlTypeMapping) {
            CheckScope(xmlTypeMapping.Scope);
            CheckNamespace();

            ExportElement(xmlTypeMapping.Accessor);
        }

        /// <include file='doc\SoapCodeExporter.uex' path='docs/doc[@for="SoapCodeExporter.ExportMembersMapping"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void ExportMembersMapping(XmlMembersMapping xmlMembersMapping) {
            CheckScope(xmlMembersMapping.Scope);
            CheckNamespace();
            for (int i = 0; i < xmlMembersMapping.Count; i++) {
                ExportElement((ElementAccessor)xmlMembersMapping[i].Accessor);
            }
        }

        void CheckScope(TypeScope scope) {
            if (this.scope == null) {
                this.scope = scope;
            }
            else if (this.scope != scope) {
                throw new InvalidOperationException(Res.GetString(Res.XmlMappingsScopeMismatch));
            }
        }

        void ExportElement(ElementAccessor element) {
            ExportType((TypeMapping)element.Mapping);
        }

        void ExportType(TypeMapping mapping) {

            if (exportedMappings[mapping] == null) {
                exportedMappings.Add(mapping, mapping);
                if (mapping is EnumMapping) {
                    ExportEnum((EnumMapping)mapping);
                }
                else if (mapping is StructMapping) {
                    ExportStruct((StructMapping)mapping);
                }
                else if (mapping is ArrayMapping) {
                    EnsureTypesExported(((ArrayMapping)mapping).Elements);
                }
            }
        }

        void AddIncludeMetadata(CodeAttributeDeclarationCollection metadata, StructMapping mapping) {
            for (StructMapping derived = mapping.DerivedMappings; derived != null; derived = derived.NextDerivedMapping) {
                CodeIdentifier.CheckValidTypeIdentifier(derived.TypeDesc.FullName);
                CodeAttributeArgument[] arguments  = new CodeAttributeArgument[] { new CodeAttributeArgument(new CodeTypeOfExpression(derived.TypeDesc.FullName)) };
                AddCustomAttribute(metadata, typeof(SoapIncludeAttribute), arguments);
                AddIncludeMetadata(metadata, derived);
            }
        }

        void AddTypeMetadata(CodeAttributeDeclarationCollection metadata, string name, string ns, bool includeInSchema) {
            CodeAttributeArgument[] arguments = new CodeAttributeArgument[2 + (includeInSchema ? 0 : 1)];
            arguments[0] = new CodeAttributeArgument(new CodePrimitiveExpression(name));
            arguments[1] = new CodeAttributeArgument(new CodePrimitiveExpression(ns));
            if (!includeInSchema) {
                arguments[2] = new CodeAttributeArgument("IncludeInSchema", new CodePrimitiveExpression(false));
            }
            AddCustomAttribute(metadata, typeof(SoapTypeAttribute), arguments);
        }

        void ExportEnum(EnumMapping mapping) {
            CodeTypeDeclaration codeClass = new CodeTypeDeclaration(mapping.TypeDesc.Name);
            codeClass.IsEnum = true;
            codeClass.TypeAttributes |= TypeAttributes.Public;
            codeClass.Comments.Add(new CodeCommentStatement("<remarks/>", true));
            codeNamespace.Types.Add(codeClass);
            codeClass.CustomAttributes = new CodeAttributeDeclarationCollection();
            AddTypeMetadata(codeClass.CustomAttributes, mapping.TypeName, mapping.Namespace, mapping.IncludeInSchema);

            for (int i = 0; i < mapping.Constants.Length; i++) {
                ExportConstant(codeClass, mapping.Constants[i]);
            }
            if (mapping.IsFlags) {
                AddCustomAttribute(codeClass.CustomAttributes, typeof(FlagsAttribute), new CodeAttributeArgument[0]);
            }
            CodeGenerator.ValidateIdentifiers(codeClass);
        }


        void ExportConstant(CodeTypeDeclaration codeClass, ConstantMapping constant) {
            CodeMemberField field = new CodeMemberField(typeof(int).FullName, constant.Name);
            codeClass.Members.Add(field);
            field.CustomAttributes = new CodeAttributeDeclarationCollection();
            field.Comments.Add(new CodeCommentStatement("<remarks/>", true));
            if (constant.XmlName != constant.Name) {
                CodeAttributeDeclaration attribute = new CodeAttributeDeclaration(typeof(SoapEnumAttribute).FullName);
                attribute.Arguments.Add(new CodeAttributeArgument(new CodePrimitiveExpression(constant.XmlName)));
                field.CustomAttributes.Add(attribute);
            }
        }

        void ExportRoot(StructMapping mapping) {
            if (!rootExported) {
                rootExported = true;
                ExportDerivedStructs(mapping);

                for (StructMapping derived = mapping.DerivedMappings; derived != null; derived = derived.NextDerivedMapping) {
                    if (!derived.ReferencedByElement) {
                        CodeIdentifier.CheckValidTypeIdentifier(derived.TypeDesc.FullName);
                        CodeAttributeArgument[] arguments  = new CodeAttributeArgument[] { new CodeAttributeArgument(new CodeTypeOfExpression(derived.TypeDesc.FullName)) };
                        AddCustomAttribute(includeMetadata, typeof(SoapIncludeAttribute), arguments);
                    }
                }
            }
        }

        void ExportStruct(StructMapping mapping) {
            if (mapping.TypeDesc.IsRoot) {
                ExportRoot(mapping);
                return;
            }

            string className = mapping.TypeDesc.Name;
            string baseName = mapping.TypeDesc.BaseTypeDesc == null ? string.Empty : mapping.TypeDesc.BaseTypeDesc.Name;

            CodeTypeDeclaration codeClass = new CodeTypeDeclaration(className);
            codeClass.CustomAttributes = new CodeAttributeDeclarationCollection();
            codeClass.Comments.Add(new CodeCommentStatement("<remarks/>", true));
            codeNamespace.Types.Add(codeClass);

            if (baseName != null && baseName.Length > 0) {
                codeClass.BaseTypes.Add(baseName);
            }

            codeClass.TypeAttributes |= TypeAttributes.Public;
            if (mapping.TypeDesc.IsAbstract)
                codeClass.TypeAttributes |= TypeAttributes.Abstract;

            AddTypeMetadata(codeClass.CustomAttributes, mapping.TypeName, mapping.Namespace, mapping.IncludeInSchema);
            AddIncludeMetadata(codeClass.CustomAttributes, mapping);

            for (int i = 0; i < mapping.Members.Length; i++) {
                ExportMember(codeClass, mapping.Members[i]);
            }

            for (int i = 0; i < mapping.Members.Length; i++) {
                EnsureTypesExported(mapping.Members[i].Elements);
            }

            if (mapping.BaseMapping != null)
                ExportType(mapping.BaseMapping);

            ExportDerivedStructs(mapping);

            CodeGenerator.ValidateIdentifiers(codeClass);
        }

        void ExportDerivedStructs(StructMapping mapping) {
            for (StructMapping derived = mapping.DerivedMappings; derived != null; derived = derived.NextDerivedMapping)
                ExportType(derived);
        }

        /// <include file='doc\SoapCodeExporter.uex' path='docs/doc[@for="SoapCodeExporter.AddMappingMetadata"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void AddMappingMetadata(CodeAttributeDeclarationCollection metadata, XmlMemberMapping member, bool forceUseMemberName) {
            AddMemberMetadata(metadata, member.Mapping, forceUseMemberName);
        }         
         
        /// <include file='doc\SoapCodeExporter.uex' path='docs/doc[@for="SoapCodeExporter.AddMappingMetadata1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void AddMappingMetadata(CodeAttributeDeclarationCollection metadata, XmlMemberMapping member) {
            AddMemberMetadata(metadata, member.Mapping, false);
        }

        void AddElementMetadata(CodeAttributeDeclarationCollection metadata, string elementName, TypeDesc typeDesc, bool isNullable) {
            CodeAttributeDeclaration attribute = new CodeAttributeDeclaration(typeof(SoapElementAttribute).FullName);
            if (elementName != null) {
                attribute.Arguments.Add(new CodeAttributeArgument(new CodePrimitiveExpression(elementName)));
            }
            if (typeDesc != null && typeDesc.IsAmbiguousDataType) {
                attribute.Arguments.Add(new CodeAttributeArgument("DataType", new CodePrimitiveExpression(typeDesc.DataType.Name)));
            }
            if (isNullable) {
                attribute.Arguments.Add(new CodeAttributeArgument("IsNullable", new CodePrimitiveExpression(true)));
            }
            metadata.Add(attribute);
        }

        void AddMemberMetadata(CodeAttributeDeclarationCollection metadata, MemberMapping member, bool forceUseMemberName) {
            if (member.Elements.Length == 0) return;
            ElementAccessor element = member.Elements[0];
            TypeMapping mapping = (TypeMapping)element.Mapping;
            string elemName = Accessor.UnescapeName(element.Name);
            bool sameName = ((elemName == member.Name) && !forceUseMemberName);

            if (!sameName || mapping.TypeDesc.IsAmbiguousDataType || element.IsNullable) {
                AddElementMetadata(metadata, sameName ? null : elemName, mapping.TypeDesc.IsAmbiguousDataType ? mapping.TypeDesc : null, element.IsNullable);
            }
        }

        void ExportMember(CodeTypeDeclaration codeClass, MemberMapping member) {
            CodeAttributeDeclarationCollection metadata = new CodeAttributeDeclarationCollection();
            CodeMemberField field = new CodeMemberField(member.TypeDesc.FullName, member.Name);
            field.Attributes = (field.Attributes & ~MemberAttributes.AccessMask) | MemberAttributes.Public;
            field.Comments.Add(new CodeCommentStatement("<remarks/>", true));
            codeClass.Members.Add(field);
            AddMemberMetadata(metadata, member, false);
            field.CustomAttributes = metadata;
        }

        void EnsureTypesExported(ElementAccessor[] elements) {
            if (elements == null) return;
            for (int i = 0; i < elements.Length; i++)
                ExportType((TypeMapping)elements[i].Mapping);
        }

        void AddCustomAttribute(CodeAttributeDeclarationCollection metadata, Type type, CodeAttributeArgument[] arguments) {
            CodeAttributeDeclaration attribute = new CodeAttributeDeclaration(type.FullName, arguments);
            metadata.Add(attribute);
        }

        /// <include file='doc\SoapCodeExporter.uex' path='docs/doc[@for="SoapCodeExporter.IncludeMetadata"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public CodeAttributeDeclarationCollection IncludeMetadata {
            get { return includeMetadata; }
        }

        void CheckNamespace() {
            if (codeNamespace == null) codeNamespace = new CodeNamespace();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\serialization\soapelementattribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="SoapElementAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Serialization {
    using System;

    /// <include file='doc\SoapElementAttribute.uex' path='docs/doc[@for="SoapElementAttribute"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [AttributeUsage(AttributeTargets.Field | AttributeTargets.Property | AttributeTargets.Parameter | AttributeTargets.ReturnValue)]
    public class SoapElementAttribute : System.Attribute {
        string elementName;
        string dataType;
        bool nullable;
        
        /// <include file='doc\SoapElementAttribute.uex' path='docs/doc[@for="SoapElementAttribute.SoapElementAttribute"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public SoapElementAttribute() {
        }
        
        /// <include file='doc\SoapElementAttribute.uex' path='docs/doc[@for="SoapElementAttribute.SoapElementAttribute1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public SoapElementAttribute(string elementName) {
            this.elementName = elementName;
        }

        /// <include file='doc\SoapElementAttribute.uex' path='docs/doc[@for="SoapElementAttribute.ElementName"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public string ElementName {
            get { return elementName == null ? string.Empty : elementName; }
            set { elementName = value; }
        }

        /// <include file='doc\SoapElementAttribute.uex' path='docs/doc[@for="SoapElementAttribute.DataType"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public string DataType {
            get { return dataType == null ? string.Empty : dataType; }
            set { dataType = value; }
        }

        /// <include file='doc\SoapElementAttribute.uex' path='docs/doc[@for="SoapElementAttribute.IsNullable"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public bool IsNullable {
            get { return nullable; }
            set { nullable = value; }
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\serialization\models.cs ===
//------------------------------------------------------------------------------
// <copyright file="Models.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Serialization {

    using System;
    using System.Reflection;
    using System.Collections;
    using System.Diagnostics;

    // These classes define the abstract serialization model, e.g. the rules for WHAT is serialized.  
    // The answer of HOW the values are serialized is answered by a particular reflection importer 
    // by looking for a particular set of custom attributes specific to the serialization format
    // and building an appropriate set of accessors/mappings.

    internal class ModelScope {
        TypeScope typeScope;
        Hashtable models = new Hashtable();
        Hashtable arrayModels = new Hashtable();

        internal ModelScope(TypeScope typeScope) {
            this.typeScope = typeScope;
        }

        internal TypeScope TypeScope {
            get { return typeScope; }
        }

        internal TypeModel GetTypeModel(Type type) {
            return GetTypeModel(type, true);
        }   

        internal TypeModel GetTypeModel(Type type, bool directReference) {
            TypeModel model = (TypeModel)models[type];
            if (model != null) return model;
            TypeDesc typeDesc = typeScope.GetTypeDesc(type, null, directReference);

            switch (typeDesc.Kind) {
                case TypeKind.Enum: 
                    model = new EnumModel(type, typeDesc, this);
                    break;
                case TypeKind.Primitive:
                    model = new PrimitiveModel(type, typeDesc, this);
                    break;
                case TypeKind.Array:
                case TypeKind.Collection:
                case TypeKind.Enumerable:
                    model = new ArrayModel(type, typeDesc, this);
                    break;
                case TypeKind.Root:
                case TypeKind.Class:
                case TypeKind.Struct:
                    model = new StructModel(type, typeDesc, this);
                    break;
                default:
                    if (!typeDesc.IsSpecial) throw new NotSupportedException(Res.GetString(Res.XmlUnsupportedTypeKind, type.FullName));
                    model = new SpecialModel(type, typeDesc, this);
                    break;
            }

            models.Add(type, model);
            return model;
        }

        internal ArrayModel GetArrayModel(Type type) {
            TypeModel model = (TypeModel) arrayModels[type];
            if (model == null) {
                model = GetTypeModel(type);
                if (!(model is ArrayModel)) {
                    TypeDesc typeDesc = typeScope.GetArrayTypeDesc(type);
                    model = new ArrayModel(type, typeDesc, this);
                }
                arrayModels.Add(type, model);
            }
            return (ArrayModel) model;
        }
    }

    internal abstract class TypeModel {
        TypeDesc typeDesc;
        Type type;
        ModelScope scope;

        protected TypeModel(Type type, TypeDesc typeDesc, ModelScope scope) {
            this.scope = scope;
            this.type = type;
            this.typeDesc = typeDesc;
        }

        internal Type Type {
            get { return type; }
        }

        internal ModelScope ModelScope {
            get { return scope; }
        }

        internal TypeDesc TypeDesc {
            get { return typeDesc; }
        }
    }

    internal class ArrayModel : TypeModel {
        internal ArrayModel(Type type, TypeDesc typeDesc, ModelScope scope) : base(type, typeDesc, scope) { }

        internal TypeModel Element {
            get { return ModelScope.GetTypeModel(TypeScope.GetArrayElementType(Type)); }
        }
    }

    internal class PrimitiveModel : TypeModel {
        internal PrimitiveModel(Type type, TypeDesc typeDesc, ModelScope scope) : base(type, typeDesc, scope) { }
    }

    internal class SpecialModel : TypeModel {
        internal SpecialModel(Type type, TypeDesc typeDesc, ModelScope scope) : base(type, typeDesc, scope) { }
    }

    internal class StructModel : TypeModel {

        internal StructModel(Type type, TypeDesc typeDesc, ModelScope scope) : base(type, typeDesc, scope) { }

        internal MemberInfo[] GetMemberInfos() {
            return Type.GetMembers(BindingFlags.DeclaredOnly | BindingFlags.Public | BindingFlags.Instance | BindingFlags.Static);
        }

        internal FieldModel GetFieldModel(MemberInfo memberInfo) {
            FieldModel model = null;
            if (memberInfo is FieldInfo)
                model = GetFieldModel((FieldInfo)memberInfo);
            else if (memberInfo is PropertyInfo)
                model = GetPropertyModel((PropertyInfo)memberInfo);
            if (model != null) {
                if (model.ReadOnly && model.FieldTypeDesc.Kind != TypeKind.Collection && model.FieldTypeDesc.Kind != TypeKind.Enumerable)
                    return null;
            }
            return model;
        }

        FieldModel GetFieldModel(FieldInfo fieldInfo) {
            if (fieldInfo.IsStatic) return null;
            if (fieldInfo.DeclaringType != Type) return null;
            TypeDesc typeDesc = ModelScope.TypeScope.GetTypeDesc(fieldInfo.FieldType, fieldInfo);
            return new FieldModel(fieldInfo, fieldInfo.FieldType, typeDesc);
        }

        FieldModel GetPropertyModel(PropertyInfo propertyInfo) {
            if (propertyInfo.DeclaringType != Type) return null;
            TypeDesc typeDesc = ModelScope.TypeScope.GetTypeDesc(propertyInfo.PropertyType, propertyInfo);

            if (!propertyInfo.CanRead) return null;

            foreach (MethodInfo accessor in propertyInfo.GetAccessors())
                if ((accessor.Attributes & MethodAttributes.HasSecurity) != 0)
                    throw new InvalidOperationException(Res.GetString(Res.XmlPropertyHasSecurityAttributes, propertyInfo.Name, Type.FullName));
            if ((propertyInfo.DeclaringType.Attributes & TypeAttributes.HasSecurity) != 0)
                throw new InvalidOperationException(Res.GetString(Res.XmlPropertyHasSecurityAttributes, propertyInfo.Name, Type.FullName));
                
            MethodInfo getMethod = propertyInfo.GetGetMethod();
            if (getMethod.IsStatic) return null;
            ParameterInfo[] parameters = getMethod.GetParameters();
            if (parameters.Length > 0) return null;

            return new FieldModel(propertyInfo, propertyInfo.PropertyType, typeDesc);
        }
    }


    internal class FieldModel {
        bool checkSpecified;
        bool checkShouldPersist;
        bool readOnly = false;
        bool isProperty = false;
        Type fieldType;
        string name;
        TypeDesc fieldTypeDesc;

        internal FieldModel(string name, Type fieldType, TypeDesc fieldTypeDesc, bool checkSpecified, bool checkShouldPersist) : 
            this(name, fieldType, fieldTypeDesc, checkSpecified, checkShouldPersist, false) {
        }
        internal FieldModel(string name, Type fieldType, TypeDesc fieldTypeDesc, bool checkSpecified, bool checkShouldPersist, bool readOnly) {
            this.fieldTypeDesc = fieldTypeDesc;
            this.name = name;
            this.fieldType = fieldType;
            this.checkSpecified = checkSpecified;
            this.checkShouldPersist = checkShouldPersist;
            this.readOnly = readOnly;
        }

        internal FieldModel(MemberInfo memberInfo, Type fieldType, TypeDesc fieldTypeDesc) {
            this.name = memberInfo.Name;
            this.fieldType = fieldType;
            this.fieldTypeDesc = fieldTypeDesc;
            this.checkShouldPersist = memberInfo.DeclaringType.GetMethod("ShouldSerialize" + memberInfo.Name, new Type[0]) != null;
            this.checkSpecified = memberInfo.DeclaringType.GetField(memberInfo.Name + "Specified") != null;
            if (!this.checkSpecified) {
                this.checkSpecified = memberInfo.DeclaringType.GetProperty(memberInfo.Name + "Specified") != null;
            }
            if (memberInfo is PropertyInfo) {
                readOnly = !((PropertyInfo)memberInfo).CanWrite;
                isProperty = true;
            }
            else if (memberInfo is FieldInfo) {
                readOnly = ((FieldInfo)memberInfo).IsInitOnly;
            }
        }

        internal string Name {
            get { return name; }
        }

        internal Type FieldType {
            get { return fieldType; }
        }

        internal TypeDesc FieldTypeDesc {
            get { return fieldTypeDesc; }
        }

        internal bool CheckShouldPersist {
            get { return checkShouldPersist; }
        }

        internal bool CheckSpecified {
            get { return checkSpecified; }
        }

        internal bool ReadOnly {
            get { return readOnly; }
        }
        
        internal bool IsProperty {
            get { return isProperty; }
        }
        
        internal bool IsField {
            get { return !isProperty; }
        }
    }

    internal class ConstantModel {
        FieldInfo fieldInfo;
        long value;

        internal ConstantModel(FieldInfo fieldInfo, long value) {
            this.fieldInfo = fieldInfo;
            this.value = value;
        }

        internal string Name {
            get { return fieldInfo.Name; }
        }

        internal long Value {
            get { return value; }
        }

        internal FieldInfo FieldInfo {
            get { return fieldInfo; }
        }
    }

    internal class EnumModel : TypeModel {
        ConstantModel[] constants;

        internal EnumModel(Type type, TypeDesc typeDesc, ModelScope scope) : base(type, typeDesc, scope) { }

        internal ConstantModel[] Constants {
            get {
                if (constants == null) {
                    ArrayList list = new ArrayList();
                    FieldInfo[] fields = Type.GetFields();
                    for (int i = 0; i < fields.Length; i++) {
                        FieldInfo field = fields[i];
                        ConstantModel constant = GetConstantModel(field);
                        if (constant != null) list.Add(constant);
                    }
                    constants = (ConstantModel[])list.ToArray(typeof(ConstantModel));
                }
                return constants;
            }

        }

        ConstantModel GetConstantModel(FieldInfo fieldInfo) {
            if (fieldInfo.IsSpecialName) return null;
            return new ConstantModel(fieldInfo, ((IConvertible)fieldInfo.GetValue(null)).ToInt64(null));
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\serialization\soapincludeattribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="SoapIncludeAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Serialization {

    using System;

    /// <include file='doc\SoapIncludeAttribute.uex' path='docs/doc[@for="SoapIncludeAttribute"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct | AttributeTargets.Method, AllowMultiple=true)]
    public class SoapIncludeAttribute : System.Attribute {
        Type type;

        /// <include file='doc\SoapIncludeAttribute.uex' path='docs/doc[@for="SoapIncludeAttribute.SoapIncludeAttribute"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public SoapIncludeAttribute(Type type) {
            this.type = type;
        }

        /// <include file='doc\SoapIncludeAttribute.uex' path='docs/doc[@for="SoapIncludeAttribute.Type"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public Type Type {
            get { return type; }
            set { type = value; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\serialization\soapignoreattribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="SoapIgnoreAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Serialization {

    using System;

    /// <include file='doc\SoapIgnoreAttribute.uex' path='docs/doc[@for="SoapIgnoreAttribute"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [AttributeUsage(AttributeTargets.Field | AttributeTargets.Property | AttributeTargets.Parameter | AttributeTargets.ReturnValue)]
    public class SoapIgnoreAttribute : System.Attribute {
        /// <include file='doc\SoapIgnoreAttribute.uex' path='docs/doc[@for="SoapIgnoreAttribute.SoapIgnoreAttribute"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public SoapIgnoreAttribute() {
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\serialization\soapenumattribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="SoapEnumAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Serialization {

    using System;
    
    /// <include file='doc\SoapEnumAttribute.uex' path='docs/doc[@for="SoapEnumAttribute"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [AttributeUsage(AttributeTargets.Field)]
    public class SoapEnumAttribute : System.Attribute {
        string name; 

        /// <include file='doc\SoapEnumAttribute.uex' path='docs/doc[@for="SoapEnumAttribute.SoapEnumAttribute"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public SoapEnumAttribute() {
        }

        /// <include file='doc\SoapEnumAttribute.uex' path='docs/doc[@for="SoapEnumAttribute.SoapEnumAttribute1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public SoapEnumAttribute(string name) {
            this.name = name;
        }

        /// <include file='doc\SoapEnumAttribute.uex' path='docs/doc[@for="SoapEnumAttribute.Name"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public string Name {
            get { return name == null ? string.Empty : name; }
            set { name = value; }
        }
    }
 }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\serialization\soapschemaexporter.cs ===
//------------------------------------------------------------------------------
// <copyright file="SoapSchemaExporter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Serialization {
    
    using System;
    using System.Collections;
    using System.Xml.Schema;
    using System.Xml;
    using System.ComponentModel;
    using System.Diagnostics;

    /// <include file='doc\SoapSchemaExporter.uex' path='docs/doc[@for="SoapSchemaExporter"]/*' />
    /// <internalonly/>
    public class SoapSchemaExporter {
        XmlSchemas schemas;
        Hashtable types = new Hashtable();      // StructMapping/EnumMapping -> XmlSchemaComplexType/XmlSchemaSimpleType
        bool exportedRoot;
        TypeScope scope;
        XmlDocument document;

        static XmlQualifiedName ArrayQName = new XmlQualifiedName(Soap.Array, Soap.Encoding);
        static XmlQualifiedName ArrayTypeQName = new XmlQualifiedName(Soap.ArrayType, Soap.Encoding);
        
        /// <include file='doc\SoapSchemaExporter.uex' path='docs/doc[@for="SoapSchemaExporter.SoapSchemaExporter"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public SoapSchemaExporter(XmlSchemas schemas) {
            this.schemas = schemas;
        }

        /// <include file='doc\SoapSchemaExporter.uex' path='docs/doc[@for="SoapSchemaExporter.ExportTypeMapping"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void ExportTypeMapping(XmlTypeMapping xmlTypeMapping) {
            CheckScope(xmlTypeMapping.Scope);
            ExportTypeMapping(xmlTypeMapping.Mapping, null);
        }

        /// <include file='doc\SoapSchemaExporter.uex' path='docs/doc[@for="SoapSchemaExporter.ExportMembersMapping"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void ExportMembersMapping(XmlMembersMapping xmlMembersMapping) {
            ExportMembersMapping(xmlMembersMapping, false);
        }

        /// <include file='doc\SoapSchemaExporter.uex' path='docs/doc[@for="SoapSchemaExporter.ExportMembersMapping1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void ExportMembersMapping(XmlMembersMapping xmlMembersMapping, bool exportEnclosingType) {
            CheckScope(xmlMembersMapping.Scope);
            MembersMapping membersMapping = (MembersMapping)xmlMembersMapping.Accessor.Mapping;
            if (exportEnclosingType) {
                ExportTypeMapping(membersMapping, null);
            }
            else {
                foreach (MemberMapping memberMapping in membersMapping.Members) {
                    if (memberMapping.Elements.Length > 0) 
                        ExportTypeMapping(memberMapping.Elements[0].Mapping, null);
                }
            }
        }

        void CheckScope(TypeScope scope) {
            if (this.scope == null) {
                this.scope = scope;
            }
            else if (this.scope != scope) {
                throw new InvalidOperationException(Res.GetString(Res.XmlMappingsScopeMismatch));
            }
        }

        internal XmlDocument Document {
            get { 
                if (document == null) document = new XmlDocument();
                return document; 
            }
        }

        void CheckForDuplicateType(string newTypeName, string newNamespace){
            XmlSchema schema = schemas[newNamespace];
            if (schema != null){
                foreach (XmlSchemaObject o in schema.Items) {
                    XmlSchemaType type = o as XmlSchemaType;
                    if ( type != null && type.Name == newTypeName)
                        throw new InvalidOperationException(Res.GetString(Res.XmlDuplicateTypeName, newTypeName, newNamespace));

                }
            }
        }

        void AddSchemaItem(XmlSchemaObject item, string ns, string referencingNs) {
            if (!SchemaContainsItem(item, ns)) {
                XmlSchema schema = schemas[ns];
                if (schema == null) {
                    schema = new XmlSchema();
                    schema.TargetNamespace = ns == null || ns.Length == 0 ? null : ns;
                    schemas.Add(schema);
                }
                schema.Items.Add(item);
            }
            if (referencingNs != null)
                AddSchemaImport(ns, referencingNs);
        }

        void AddSchemaImport(string ns, string referencingNs) {
            if (referencingNs == null || ns == null) return;
            if (ns == referencingNs) return;
            XmlSchema schema = schemas[referencingNs];
            if (schema == null) throw new InvalidOperationException(Res.GetString(Res.XmlMissingSchema, referencingNs));
            if (ns != null && ns.Length > 0 && FindImport(schema, ns) == null) {
                XmlSchemaImport import = new XmlSchemaImport();
                import.Namespace = ns;
                schema.Includes.Add(import);
            }
        }

        bool SchemaContainsItem(XmlSchemaObject item, string ns) {
            XmlSchema schema = schemas[ns];
            if (schema != null) {
                return schema.Items.Contains(item);
            }
            return false;
        }

        XmlSchemaImport FindImport(XmlSchema schema, string ns) {
            foreach (object item in schema.Includes) {
                if (item is XmlSchemaImport) {
                    XmlSchemaImport import = (XmlSchemaImport)item;
                    if (import.Namespace == ns) {
                        return import;
                    }
                }
            }
            return null;
        }

        XmlQualifiedName ExportTypeMapping(TypeMapping mapping, string ns) {
            if (mapping is ArrayMapping)
                 return ExportArrayMapping((ArrayMapping)mapping, ns);
            else if (mapping is EnumMapping)
                return ExportEnumMapping((EnumMapping)mapping, ns);
            else if (mapping is PrimitiveMapping) {
                PrimitiveMapping pm = (PrimitiveMapping)mapping;
                if (pm.TypeDesc.IsXsdType) {
                    return ExportPrimitiveMapping(pm);
                }
                else {
                    return ExportNonXsdPrimitiveMapping(pm, ns);
                }
            }
            else if (mapping is StructMapping)
                return ExportStructMapping((StructMapping)mapping, ns);
            else if (mapping is MembersMapping)
                return ExportMembersMapping((MembersMapping)mapping, ns);
            else
                throw new ArgumentException(Res.GetString(Res.XmlInternalError), "mapping");
        }

        XmlQualifiedName ExportNonXsdPrimitiveMapping(PrimitiveMapping mapping, string ns) {
            XmlSchemaSimpleType type = mapping.TypeDesc.DataType;
            if (!SchemaContainsItem(type, UrtTypes.Namespace)) {
                AddSchemaItem(type, UrtTypes.Namespace, ns);
            }
            return new XmlQualifiedName(mapping.TypeDesc.DataType.Name, UrtTypes.Namespace);
        }

        XmlQualifiedName ExportPrimitiveMapping(PrimitiveMapping mapping) {
            return new XmlQualifiedName(mapping.TypeDesc.DataType.Name, XmlSchema.Namespace);
        }

        XmlQualifiedName ExportArrayMapping(ArrayMapping mapping, string ns) {
            // for the Rpc ArrayMapping  different mappings could have the same schema type
            // we link all mappings corresponding to the same type together
            // loop through all mapping that will map to the same complexType, and export only one, 
            // the obvious choice is the last one.
            while (mapping.Next != null) {
                mapping = mapping.Next;
            }

            XmlSchemaComplexType type = (XmlSchemaComplexType)types[mapping];
            if (type == null) {
                CheckForDuplicateType(mapping.TypeName, mapping.Namespace);
                type = new XmlSchemaComplexType();
                type.Name = mapping.TypeName;
                types.Add(mapping, type);

                // we need to add the type first, to make sure that the schema get created
                AddSchemaItem(type, mapping.Namespace, ns);
                AddSchemaImport(Soap.Encoding, mapping.Namespace);
                AddSchemaImport(Wsdl.Namespace, mapping.Namespace);

                XmlSchemaComplexContentRestriction restriction = new XmlSchemaComplexContentRestriction();
                XmlQualifiedName qname = ExportTypeMapping(mapping.Elements[0].Mapping, mapping.Namespace);

                if (qname.IsEmpty) {
                    // this is a root mapping
                    qname = new XmlQualifiedName(Soap.UrType, XmlSchema.Namespace);
                }
                //<attribute ref="soapenc:arrayType" wsdl:arrayType="xsd:float[]"/> 
                XmlSchemaAttribute attr = new XmlSchemaAttribute();
                attr.RefName = ArrayTypeQName;
                XmlAttribute attribute = new XmlAttribute("wsdl", Wsdl.ArrayType, Wsdl.Namespace, Document);
                attribute.Value = qname.Namespace + ":" + qname.Name + "[]";

                attr.UnhandledAttributes = new XmlAttribute[] {attribute};
                restriction.Attributes.Add(attr);
                restriction.BaseTypeName = ArrayQName;
                XmlSchemaComplexContent model = new XmlSchemaComplexContent();
                model.Content = restriction;
                type.ContentModel = model;
            }
            else {
                AddSchemaImport(mapping.Namespace, ns);
            }
            return new XmlQualifiedName(mapping.TypeName, mapping.Namespace);
        }

        void ExportElementAccessors(XmlSchemaGroupBase group, ElementAccessor[] accessors, bool repeats, string ns) {
            if (accessors.Length == 0) return;
            if (accessors.Length == 1) {
                ExportElementAccessor(group, accessors[0], repeats, ns);
            }
            else {
                XmlSchemaChoice choice = new XmlSchemaChoice();
                choice.MaxOccurs = repeats ? decimal.MaxValue : 1;
                choice.MinOccurs = repeats ? 0 : 1;
                for (int i = 0; i < accessors.Length; i++)
                    ExportElementAccessor(choice, accessors[i], false, ns);

                if (choice.Items.Count > 0) group.Items.Add(choice);
            }
        }


        void ExportElementAccessor(XmlSchemaGroupBase group, ElementAccessor accessor, bool repeats, string ns) {
            XmlSchemaElement element = new XmlSchemaElement();
            element.MinOccurs = repeats ? 0 : 1;
            element.MaxOccurs = repeats ? decimal.MaxValue : 1;
            element.Name = accessor.Name;
            element.SchemaTypeName = ExportTypeMapping((TypeMapping)accessor.Mapping, accessor.Namespace);

            group.Items.Add(element);
        }

        XmlQualifiedName ExportRootMapping(StructMapping mapping) {
            if (!exportedRoot) {
                exportedRoot = true;
                ExportDerivedMappings(mapping);
            }
            return new XmlQualifiedName(Soap.UrType, XmlSchema.Namespace);
        }

        XmlQualifiedName ExportStructMapping(StructMapping mapping, string ns) {
            if (mapping.TypeDesc.IsRoot) return ExportRootMapping(mapping);
            XmlSchemaComplexType type = (XmlSchemaComplexType)types[mapping];
            if (type == null) {
                if (!mapping.IncludeInSchema) throw new InvalidOperationException(Res.GetString(Res.XmlSoapCannotIncludeInSchema, mapping.TypeDesc.Name));
                CheckForDuplicateType(mapping.TypeName, mapping.Namespace);
                type = new XmlSchemaComplexType();
                type.Name = mapping.TypeName;
                types.Add(mapping, type);
                AddSchemaItem(type, mapping.Namespace, ns);
                type.IsAbstract = mapping.TypeDesc.IsAbstract;

                if (mapping.BaseMapping != null && mapping.BaseMapping.IncludeInSchema) {
                    XmlSchemaComplexContentExtension extension = new XmlSchemaComplexContentExtension();
                    extension.BaseTypeName = ExportStructMapping(mapping.BaseMapping, mapping.Namespace);
                    XmlSchemaComplexContent model = new XmlSchemaComplexContent();
                    model.Content = extension;
                    type.ContentModel = model;
                }
                ExportTypeMembers(type, mapping.Members, mapping.Namespace);
                ExportDerivedMappings(mapping);
            }
            else {
                AddSchemaImport(mapping.Namespace, ns);
            }
            return new XmlQualifiedName(type.Name, mapping.Namespace);
        }

        XmlQualifiedName ExportMembersMapping(MembersMapping mapping, string ns) {
            XmlSchemaComplexType type = (XmlSchemaComplexType)types[mapping];
            if(type == null) {
                CheckForDuplicateType(mapping.TypeName, mapping.Namespace);
                type = new XmlSchemaComplexType();
                type.Name = mapping.TypeName;
                types.Add(mapping, type);
                AddSchemaItem(type, mapping.Namespace, ns);
                ExportTypeMembers(type, mapping.Members, mapping.Namespace);
            }
            else {
                AddSchemaImport(mapping.Namespace, ns);
            }
            return new XmlQualifiedName(type.Name, mapping.Namespace);
        }

        void ExportTypeMembers(XmlSchemaComplexType type, MemberMapping[] members, string ns) {
            XmlSchemaGroupBase seq = new XmlSchemaSequence();
            for (int i = 0; i < members.Length; i++) {
                MemberMapping member = members[i];
                if (member.Elements.Length > 0) {
                    ExportElementAccessors(seq, member.Elements, false, ns);
                }
            }
            if (seq.Items.Count > 0) {
                if (type.ContentModel != null) {
                    if (type.ContentModel.Content is XmlSchemaComplexContentExtension)
                        ((XmlSchemaComplexContentExtension)type.ContentModel.Content).Particle = seq;
                    else if (type.ContentModel.Content is XmlSchemaComplexContentRestriction)
                        ((XmlSchemaComplexContentRestriction)type.ContentModel.Content).Particle = seq;
                    else
                        throw new InvalidOperationException(Res.GetString(Res.XmlInvalidContent, type.ContentModel.Content.GetType().Name));
                }
                else {
                    type.Particle = seq;
                }
            }
        }

        void ExportDerivedMappings(StructMapping mapping) {
            for (StructMapping derived = mapping.DerivedMappings; derived != null; derived = derived.NextDerivedMapping) {
                if (derived.IncludeInSchema) ExportStructMapping(derived, mapping.TypeDesc.IsRoot ? null : mapping.Namespace);
            }
        }

        XmlQualifiedName ExportEnumMapping(EnumMapping mapping, string ns) {
            XmlSchemaSimpleType dataType = (XmlSchemaSimpleType)types[mapping];
            if (dataType == null) {
                CheckForDuplicateType(mapping.TypeName, mapping.Namespace);
                dataType = new XmlSchemaSimpleType();
                dataType.Name = mapping.TypeName;
                types.Add(mapping, dataType);
                AddSchemaItem(dataType, mapping.Namespace, ns);

                XmlSchemaSimpleTypeRestriction restriction = new XmlSchemaSimpleTypeRestriction();
                restriction.BaseTypeName = new XmlQualifiedName("string", XmlSchema.Namespace);

                for (int i = 0; i < mapping.Constants.Length; i++) {
                    ConstantMapping constant = mapping.Constants[i];
                    XmlSchemaEnumerationFacet enumeration = new XmlSchemaEnumerationFacet();
                    enumeration.Value = constant.XmlName;
                    restriction.Facets.Add(enumeration);
                }
                if (!mapping.IsFlags) {
                    dataType.Content = restriction;
                }
                else {
                    XmlSchemaSimpleTypeList list = new XmlSchemaSimpleTypeList();
                    XmlSchemaSimpleType enumType = new XmlSchemaSimpleType();
                    enumType.Content =  restriction;
                    list.ItemType = enumType;
                    dataType.Content =  list;
                }
            }
            else {
                AddSchemaImport(mapping.Namespace, ns);
            }
            return new XmlQualifiedName(mapping.TypeName, mapping.Namespace);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\serialization\soapschemaimporter.cs ===
//------------------------------------------------------------------------------
// <copyright file="SoapSchemaImporter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Serialization  {

    using System;
    using System.Xml.Schema;
    using System.Xml;
    using System.Collections;
    using System.ComponentModel;
    using System.Reflection;
    using System.Diagnostics;
    
    /// <include file='doc\SoapSchemaImporter.uex' path='docs/doc[@for="SoapSchemaImporter"]/*' />
    ///<internalonly/>
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public class SoapSchemaImporter {
        XmlSchemas schemas;
        Hashtable mappings = new Hashtable(); // XmlSchema -> PersistentMapping, XmlSchemaSimpleType -> EnumMapping, XmlSchemaComplexType -> StructMapping
        StructMapping root;
        CodeIdentifiers typeIdentifiers;
        TypeScope scope = new TypeScope();
        bool rootImported;

        /// <include file='doc\SoapSchemaImporter.uex' path='docs/doc[@for="SoapSchemaImporter.SoapSchemaImporter"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public SoapSchemaImporter(XmlSchemas schemas) {
            this.schemas = schemas;
            this.typeIdentifiers = new CodeIdentifiers();
        }

        /// <include file='doc\SoapSchemaImporter.uex' path='docs/doc[@for="SoapSchemaImporter.SoapSchemaImporter1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public SoapSchemaImporter(XmlSchemas schemas, CodeIdentifiers typeIdentifiers) {
            this.schemas = schemas;
            this.typeIdentifiers = typeIdentifiers;
        }

        /// <include file='doc\SoapSchemaImporter.uex' path='docs/doc[@for="SoapSchemaImporter.ImportDerivedTypeMapping"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public XmlTypeMapping ImportDerivedTypeMapping(XmlQualifiedName name, Type baseType, bool baseTypeCanBeIndirect) {
            TypeMapping mapping = ImportType(name, false);
            if (mapping is StructMapping) {
                MakeDerived((StructMapping)mapping, baseType, baseTypeCanBeIndirect);
            }
            else if (baseType != null)
                throw new InvalidOperationException(Res.GetString(Res.XmlPrimitiveBaseType, name.Name, name.Namespace, baseType.FullName));
            ElementAccessor accessor = new ElementAccessor();
            accessor.IsSoap = true;
            accessor.Name = Accessor.EscapeName(name.Name, false);
            accessor.Namespace = name.Namespace;
            accessor.Mapping = mapping;
            accessor.IsNullable = true;
            accessor.Form = XmlSchemaForm.Qualified;

            return new XmlTypeMapping(scope, accessor);
        }


        /// <include file='doc\SoapSchemaImporter.uex' path='docs/doc[@for="SoapSchemaImporter.ImportMembersMapping"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public XmlMembersMapping ImportMembersMapping(string name, string ns, SoapSchemaMember member) {
            TypeMapping typeMapping = ImportType(member.MemberType, true);
            if (!(typeMapping is StructMapping)) return ImportMembersMapping(name, ns, new SoapSchemaMember[] { member });

            MembersMapping mapping = new MembersMapping();
            mapping.TypeDesc = scope.GetTypeDesc(typeof(object[]));
            mapping.Members = ((StructMapping)typeMapping).Members;
            mapping.HasWrapperElement = true;
            
            ElementAccessor accessor = new ElementAccessor();
            accessor.IsSoap = true;
            accessor.Name = Accessor.EscapeName(name, false);
            accessor.Namespace = typeMapping.Namespace != null ? typeMapping.Namespace : ns;
            accessor.Mapping = mapping;
            accessor.IsNullable = false;
            accessor.Form = XmlSchemaForm.Qualified;

            return new XmlMembersMapping(scope, accessor);
        }
        
        /// <include file='doc\SoapSchemaImporter.uex' path='docs/doc[@for="SoapSchemaImporter.ImportMembersMapping1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public XmlMembersMapping ImportMembersMapping(string name, string ns, SoapSchemaMember[] members) {
            return ImportMembersMapping(name, ns, members, true);
        }

        /// <include file='doc\SoapSchemaImporter.uex' path='docs/doc[@for="SoapSchemaImporter.ImportMembersMapping2"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public XmlMembersMapping ImportMembersMapping(string name, string ns, SoapSchemaMember[] members, bool hasWrapperElement) {
            return ImportMembersMapping(name, ns, members, hasWrapperElement, null, false);
        }

        /// <include file='doc\SoapSchemaImporter.uex' path='docs/doc[@for="SoapSchemaImporter.ImportMembersMapping3"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public XmlMembersMapping ImportMembersMapping(string name, string ns, SoapSchemaMember[] members, bool hasWrapperElement, Type baseType, bool baseTypeCanBeIndirect) {
            XmlSchemaComplexType type = new XmlSchemaComplexType();
            XmlSchemaSequence seq = new XmlSchemaSequence();
            type.Particle = seq;
            foreach (SoapSchemaMember member in members) {
                XmlSchemaElement element = new XmlSchemaElement();
                element.Name = Accessor.EscapeName(member.MemberName, false);
                element.SchemaTypeName = member.MemberType;
                seq.Items.Add(element);
            }

            CodeIdentifiers identifiers = new CodeIdentifiers();
            identifiers.UseCamelCasing = true;
            MembersMapping mapping = new MembersMapping();
            mapping.TypeDesc = scope.GetTypeDesc(typeof(object[]));
            mapping.Members = ImportTypeMembers(type, ns, identifiers);
            mapping.HasWrapperElement = hasWrapperElement;
            
            if (baseType != null) {
                for (int i = 0; i < mapping.Members.Length; i++) {
                    MemberMapping member = mapping.Members[i];
                    if (member.Accessor.Mapping is StructMapping)
                        MakeDerived((StructMapping)member.Accessor.Mapping, baseType, baseTypeCanBeIndirect);
                }
            }
            ElementAccessor accessor = new ElementAccessor();
            accessor.IsSoap = true;
            accessor.Name = Accessor.EscapeName(name, false);
            accessor.Namespace = ns;
            accessor.Mapping = mapping;
            accessor.IsNullable = false;
            accessor.Form = XmlSchemaForm.Qualified;

            return new XmlMembersMapping(scope, accessor);
        }

        void MakeDerived(StructMapping structMapping, Type baseType, bool baseTypeCanBeIndirect) {
            structMapping.ReferencedByTopLevelElement = true;
            TypeDesc baseTypeDesc;
            if (baseType != null) {
                baseTypeDesc = scope.GetTypeDesc(baseType);
                if (baseTypeDesc != null) {
                    TypeDesc typeDescToChange = structMapping.TypeDesc;
                    if (baseTypeCanBeIndirect) {
                        // if baseTypeCanBeIndirect is true, we apply the supplied baseType to the top of the
                        // inheritance chain, not necessarily directly to the imported type.
                        while (typeDescToChange.BaseTypeDesc != null && typeDescToChange.BaseTypeDesc != baseTypeDesc)
                            typeDescToChange = typeDescToChange.BaseTypeDesc;
                    }
                    if (typeDescToChange.BaseTypeDesc != null && typeDescToChange.BaseTypeDesc != baseTypeDesc)
                        throw new InvalidOperationException(Res.GetString(Res.XmlInvalidBaseType, structMapping.TypeDesc.FullName, baseType.FullName, typeDescToChange.BaseTypeDesc.FullName));
                    typeDescToChange.BaseTypeDesc = baseTypeDesc;
                }
            }
        }

        ElementAccessor ImportElement(XmlSchemaElement element, string ns) {
            if (!element.RefName.IsEmpty)
                throw new InvalidOperationException(Res.GetString(Res.RefSyntaxNotSupportedForElements0));

            if (element.Name.Length == 0) throw new InvalidOperationException(Res.GetString(Res.XmlElementHasNoName));
            TypeMapping mapping = ImportElementType(element, ns);
            ElementAccessor accessor = new ElementAccessor();
            accessor.IsSoap = true;
            accessor.Name = element.Name;
            accessor.Namespace = ns;
            accessor.Mapping = mapping;
            accessor.IsNullable = false;
            accessor.Form = XmlSchemaForm.None;

            return accessor;
        }

        TypeMapping ImportElementType(XmlSchemaElement element, string ns) {
            TypeMapping mapping;
            if (!element.SchemaTypeName.IsEmpty)
                mapping = ImportType(element.SchemaTypeName, false);
            else if (element.SchemaType != null) {
                if (element.SchemaType is XmlSchemaComplexType) {
                    mapping = ImportType((XmlSchemaComplexType)element.SchemaType, ns, false);
                    if (!(mapping is ArrayMapping)) {
                        throw new InvalidOperationException(Res.GetString(Res.XmlInvalidSchemaType));
                    }
                }
                else {
                    throw new InvalidOperationException(Res.GetString(Res.XmlInvalidSchemaType));
                }
            }
            else if (!element.SubstitutionGroup.IsEmpty)
                throw new InvalidOperationException(Res.GetString(Res.XmlInvalidSubstitutionGroupUse));
            else 
                throw new InvalidOperationException(Res.GetString(Res.XmlElementMissingType, element.Name));

            mapping.ReferencedByElement = true;

            return mapping;
        }

        string GenerateUniqueTypeName(string typeName) {
            typeName = CodeIdentifier.MakeValid(typeName);
            return typeIdentifiers.AddUnique(typeName, typeName);
        }

        StructMapping CreateRootMapping() {
            TypeDesc typeDesc = scope.GetTypeDesc(typeof(object));
            StructMapping mapping = new StructMapping();
            mapping.TypeDesc = typeDesc;
            mapping.Members = new MemberMapping[0];
            mapping.IncludeInSchema = false;
            mapping.TypeName = Soap.UrType;
            mapping.Namespace = XmlSchema.Namespace;
            return mapping;
        }

        StructMapping GetRootMapping() {
            if (root == null)
                root = CreateRootMapping();
            return root;
        }

        StructMapping ImportRootMapping() {
            if (!rootImported) {
                rootImported = true;
                ImportDerivedTypes(XmlQualifiedName.Empty);
            }
            return GetRootMapping();
        }

        void ImportDerivedTypes(XmlQualifiedName baseName) {
            foreach (XmlSchema schema in schemas) {
                if (XmlSchemas.IsDataSet(schema)) continue;
                foreach (object item in schema.Items) {
                    if (item is XmlSchemaType) {
                        XmlSchemaType type = (XmlSchemaType)item;
                        if (type.DerivedFrom == baseName) {
                            ImportType(new XmlQualifiedName(type.Name, schema.TargetNamespace), false);
                        }
                    }
                }
            }
        }

        TypeMapping ImportType(XmlQualifiedName name, bool excludeFromImport) {
            if (name.Name == Soap.UrType && name.Namespace == XmlSchema.Namespace)
                return ImportRootMapping();
            object type = FindType(name);
            TypeMapping mapping = (TypeMapping)mappings[type];
            if (mapping == null) {
                if (type is XmlSchemaComplexType)
                    mapping = ImportType((XmlSchemaComplexType)type, name.Namespace, excludeFromImport);
                else if (type is XmlSchemaSimpleType)
                    mapping = ImportDataType((XmlSchemaSimpleType)type, name.Namespace, name.Name);
                else
                    throw new InvalidOperationException(Res.GetString(Res.XmlInternalError));
            }
            return mapping;
        }
        
        TypeMapping ImportType(XmlSchemaComplexType type, string typeNs, bool excludeFromImport) {
            if (type.Redefined != null) {
                // we do not support redefine in the current version
                throw new NotSupportedException(Res.GetString(Res.XmlUnsupportedRedefine, type.Name, typeNs));
            }
            TypeMapping mapping = ImportAnyType(type, typeNs);
            if (mapping == null)                     
               mapping = ImportArrayMapping(type, typeNs);
            if (mapping == null)
                mapping = ImportStructType(type, typeNs, excludeFromImport);
            return mapping;
        }
        TypeMapping ImportAnyType(XmlSchemaComplexType type, string typeNs){
            if (type.Particle == null)
                return null;
            if(!(type.Particle is XmlSchemaAll ||type.Particle is XmlSchemaSequence))
                return null;
            XmlSchemaGroupBase group = (XmlSchemaGroupBase) type.Particle;

            if (group.Items.Count != 1 || !(group.Items[0] is XmlSchemaAny))
                return null;
            return ImportRootMapping();
        }

        StructMapping ImportStructType(XmlSchemaComplexType type, string typeNs, bool excludeFromImport) {

            if (type.Name == null) {
                throw new InvalidOperationException(Res.GetString(Res.XmlInvalidSchemaType));
            }

            TypeDesc baseTypeDesc = null;

            Mapping baseMapping = null;
            if (!type.DerivedFrom.IsEmpty) {
                baseMapping = ImportType(type.DerivedFrom, excludeFromImport);

                if (baseMapping is StructMapping) 
                    baseTypeDesc = ((StructMapping)baseMapping).TypeDesc;
                else
                    baseMapping = null;
            }
            if (baseMapping == null) baseMapping = GetRootMapping();
            Mapping previousMapping = (Mapping)mappings[type];
            if (previousMapping != null) {
                return (StructMapping)previousMapping;
            }
            string typeName = GenerateUniqueTypeName(type.Name);
            StructMapping structMapping = new StructMapping();
            TypeFlags flags = TypeFlags.Reference;
            if (type.IsAbstract) flags |= TypeFlags.Abstract;
            structMapping.TypeDesc = new TypeDesc(typeName, typeName, TypeKind.Struct, baseTypeDesc, flags);
            structMapping.Namespace = typeNs;
            structMapping.TypeName = type.Name;
            if (!excludeFromImport) {
                structMapping.BaseMapping = (StructMapping)baseMapping;
                mappings.Add(type, structMapping);
            }
            CodeIdentifiers members = new CodeIdentifiers();
            members.AddReserved(typeName);
            structMapping.Members = ImportTypeMembers(type, typeNs, members);
            if (!excludeFromImport)
                scope.AddTypeMapping(structMapping);
            ImportDerivedTypes(new XmlQualifiedName(type.Name, typeNs));
            return structMapping;
        }

        MemberMapping[] ImportTypeMembers(XmlSchemaComplexType type, string typeNs, CodeIdentifiers members) {
            if (type.AnyAttribute != null) {
                throw new InvalidOperationException(Res.GetString(Res.XmlInvalidAnyUse));
            }

            XmlSchemaObjectCollection items = type.Attributes;
            for (int i = 0; i < items.Count; i++) {
                object item = items[i];
                if (item is XmlSchemaAttributeGroup) {
                    throw new InvalidOperationException(Res.GetString(Res.XmlSoapInvalidAttributeUse));
                }
                if (item is XmlSchemaAttribute) {
                    XmlSchemaAttribute attr = (XmlSchemaAttribute)item;
                    if (attr.Use != XmlSchemaUse.Prohibited) throw new InvalidOperationException(Res.GetString(Res.XmlSoapInvalidAttributeUse));
                }
            }
            if (type.Particle != null) {
                ImportGroup(type.Particle, members, typeNs);
            }
            else if (type.ContentModel != null && type.ContentModel is XmlSchemaComplexContent) {
                XmlSchemaComplexContent model = (XmlSchemaComplexContent)type.ContentModel;

                if (model.Content is XmlSchemaComplexContentExtension) {
                    if (((XmlSchemaComplexContentExtension)model.Content).Particle != null) {
                        ImportGroup(((XmlSchemaComplexContentExtension)model.Content).Particle, members, typeNs);
                    }
                }
                else if (model.Content is XmlSchemaComplexContentRestriction) {
                    if (((XmlSchemaComplexContentRestriction)model.Content).Particle != null) {
                        ImportGroup(((XmlSchemaComplexContentRestriction)model.Content).Particle, members, typeNs);
                    }
                }
            }
            return (MemberMapping[])members.ToArray(typeof(MemberMapping));
        }

        void ImportGroup(XmlSchemaParticle group, CodeIdentifiers members, string ns) {
            if (group is XmlSchemaChoice)
                throw new InvalidOperationException(Res.GetString(Res.XmlSoapInvalidChoice));
            else
                ImportGroupMembers(group, members, ns);
        }

        void ImportGroupMembers(XmlSchemaParticle particle, CodeIdentifiers members, string ns) {
            if (particle is XmlSchemaGroupRef) {
                throw new InvalidOperationException(Res.GetString(Res.XmlSoapUnsupportedGroupRef));
            }
            else if (particle is XmlSchemaGroupBase) {
                XmlSchemaGroupBase group = (XmlSchemaGroupBase)particle;
                if (group.IsMultipleOccurrence)
                    throw new InvalidOperationException(Res.GetString(Res.XmlSoapUnsupportedGroupRepeat));
                for (int i = 0; i < group.Items.Count; i++) {
                    object item = group.Items[i];
                    if (item is XmlSchemaGroupBase)
                        throw new InvalidOperationException(Res.GetString(Res.XmlSoapUnsupportedGroupNested));
                    else if (item is XmlSchemaElement)
                        ImportElementMember((XmlSchemaElement)item, members, ns);
                    else if (item is XmlSchemaAny) 
                        throw new InvalidOperationException(Res.GetString(Res.XmlSoapUnsupportedGroupAny));
                }
            }
        }

        
        ElementAccessor ImportArray(XmlSchemaElement element, string ns) {
            if (element.SchemaType == null) return null;
            if (!element.IsMultipleOccurrence) return null;
            XmlSchemaType type = element.SchemaType;
            ArrayMapping arrayMapping = ImportArrayMapping(type, ns);
            if (arrayMapping == null) return null;
            ElementAccessor arrayAccessor = new ElementAccessor();
            arrayAccessor.IsSoap = true;
            arrayAccessor.Name = element.Name;
            arrayAccessor.Namespace = ns;
            arrayAccessor.Mapping = arrayMapping;
            arrayAccessor.IsNullable = false;
            arrayAccessor.Form = XmlSchemaForm.None;

            return arrayAccessor;
        }

        ArrayMapping ImportArrayMapping(XmlSchemaType type, string ns) {
            if (!(type.DerivedFrom.Name == Soap.Array && type.DerivedFrom.Namespace == Soap.Encoding)) return null;

            // the type should be a XmlSchemaComplexType
            XmlSchemaContentModel model = ((XmlSchemaComplexType)type).ContentModel;

            // the Content  should be an restriction
            if (!(model.Content is XmlSchemaComplexContentRestriction)) return null;

            ArrayMapping arrayMapping = new ArrayMapping();

            XmlSchemaComplexContentRestriction restriction = (XmlSchemaComplexContentRestriction)model.Content;

            for (int i = 0; i < restriction.Attributes.Count; i++) {
                XmlSchemaAttribute attribute = restriction.Attributes[i] as XmlSchemaAttribute;
                if (attribute != null && attribute.RefName.Name == Soap.ArrayType && attribute.RefName.Namespace == Soap.Encoding) {
                    // read the value of the wsdl:arrayType attribute
                    string arrayType = null;

                    if (attribute.UnhandledAttributes != null) {
                        foreach (XmlAttribute a in attribute.UnhandledAttributes) {
                            if (a.LocalName == Wsdl.ArrayType && a.NamespaceURI == Wsdl.Namespace) {
                                arrayType = a.Value;
                                break;
                            }
                        }
                    }
                    if (arrayType != null) {
                        string dims;
                        XmlQualifiedName typeName = TypeScope.ParseWsdlArrayType(arrayType, out dims, attribute);

                        TypeMapping mapping;
                        TypeDesc td = scope.GetTypeDesc(typeName);
                        if (td != null && td.IsPrimitive) {
                            mapping = new PrimitiveMapping();
                            mapping.TypeDesc = td;
                            mapping.TypeName = td.DataType.Name;
                        }
                        else {
                            mapping = ImportType(typeName, false);
                        }
                        ElementAccessor itemAccessor = new ElementAccessor();
                        itemAccessor.IsSoap = true;
                        itemAccessor.Name = typeName.Name;
                        itemAccessor.Namespace = ns;
                        itemAccessor.Mapping = mapping;
                        itemAccessor.IsNullable = true;
                        itemAccessor.Form = XmlSchemaForm.None;

                        arrayMapping.Elements = new ElementAccessor[] { itemAccessor };
                        arrayMapping.TypeDesc = itemAccessor.Mapping.TypeDesc.CreateArrayTypeDesc();
                        arrayMapping.TypeName = "ArrayOf" + CodeIdentifier.MakePascal(itemAccessor.Mapping.TypeName);

                        return arrayMapping;
                    }
                }
            }

            XmlSchemaParticle particle = restriction.Particle;
            if (particle is XmlSchemaAll || particle is XmlSchemaSequence) {
                XmlSchemaGroupBase group = (XmlSchemaGroupBase)particle;
                if (group.Items.Count != 1 || !(group.Items[0] is XmlSchemaElement))
                    return null;
                XmlSchemaElement itemElement = (XmlSchemaElement)group.Items[0];
                if (!itemElement.IsMultipleOccurrence) return null;
                ElementAccessor itemAccessor = ImportElement(itemElement, ns);
                arrayMapping.Elements = new ElementAccessor[] { itemAccessor };
                arrayMapping.TypeDesc = ((TypeMapping)itemAccessor.Mapping).TypeDesc.CreateArrayTypeDesc();
            }
            else {
                return null;
            }
            return arrayMapping;
        }

        void ImportElementMember(XmlSchemaElement element, CodeIdentifiers members, string ns) {
            ElementAccessor accessor;
            if ((accessor = ImportArray(element, ns)) == null) {
                accessor = ImportElement(element, ns);
            }

            MemberMapping member = new MemberMapping();
            member.Name = CodeIdentifier.MakeValid(Accessor.UnescapeName(accessor.Name));
            member.Name = members.AddUnique(member.Name, member);
            if (member.Name.EndsWith("Specified")) {
                string name = member.Name;
                member.Name = members.AddUnique(member.Name, member);
                members.Remove(name);
            }
            member.TypeDesc = ((TypeMapping)accessor.Mapping).TypeDesc;
            member.Elements = new ElementAccessor[] { accessor };
            if (element.IsMultipleOccurrence)
                member.TypeDesc = member.TypeDesc.CreateArrayTypeDesc();
        }
        
        TypeMapping ImportDataType(XmlSchemaSimpleType dataType, string typeNs, string identifier) {
            TypeMapping mapping = ImportNonXsdPrimitiveDataType(dataType);
            if (mapping != null)
                return mapping;

            if (dataType.Content is XmlSchemaSimpleTypeRestriction) {
                XmlSchemaSimpleTypeRestriction restriction = (XmlSchemaSimpleTypeRestriction)dataType.Content;
                foreach (object o in restriction.Facets) {
                    if (o is XmlSchemaEnumerationFacet) {
                        return ImportEnumeratedDataType(dataType, typeNs, identifier);
                    }
                }
            }
            else if (dataType.Content is XmlSchemaSimpleTypeList || dataType.Content is XmlSchemaSimpleTypeUnion) {
                if (dataType.Content is XmlSchemaSimpleTypeList) {
                    // check if we have enumeration list
                    XmlSchemaSimpleTypeList list = (XmlSchemaSimpleTypeList)dataType.Content;
                    if (list.ItemType != null) {
                        mapping = ImportDataType(list.ItemType, typeNs, identifier);
                        if (mapping != null && mapping is EnumMapping) {
                            ((EnumMapping)mapping).IsFlags = true;
                            return mapping;
                        }
                    }
                }
                mapping = new PrimitiveMapping();
                mapping.TypeDesc = scope.GetTypeDesc(typeof(string));
                mapping.TypeName = mapping.TypeDesc.DataType.Name;
                return mapping;
            }
            return ImportPrimitiveDataType(dataType);
        }

        TypeMapping ImportEnumeratedDataType(XmlSchemaSimpleType dataType, string typeNs, string identifier) {
            EnumMapping enumMapping = (EnumMapping)mappings[dataType];
            if (enumMapping != null) return enumMapping;
            XmlSchemaSimpleType sourceDataType = FindDataType(dataType.DerivedFrom);
            TypeDesc sourceTypeDesc = scope.GetTypeDesc(sourceDataType);
            if (sourceTypeDesc != null && sourceTypeDesc != scope.GetTypeDesc(typeof(string)))
                return ImportPrimitiveDataType(dataType);
            string typeName = GenerateUniqueTypeName(identifier);
            enumMapping = new EnumMapping();
            enumMapping.TypeDesc = new TypeDesc(typeName, typeName, TypeKind.Enum, null, 0);
            enumMapping.TypeName = identifier;
            enumMapping.Namespace = typeNs;
            enumMapping.IsFlags = false;
            mappings.Add(dataType, enumMapping);
            CodeIdentifiers constants = new CodeIdentifiers();

            if (!(dataType.Content is XmlSchemaSimpleTypeRestriction))
                throw new InvalidOperationException(Res.GetString(Res.XmlInvalidEnumContent, dataType.Content.GetType().Name, identifier));

            XmlSchemaSimpleTypeRestriction restriction = (XmlSchemaSimpleTypeRestriction)dataType.Content;

            for (int i = 0; i < restriction.Facets.Count; i++) {
                object facet = restriction.Facets[i];
                if (!(facet is XmlSchemaEnumerationFacet)) continue;
                XmlSchemaEnumerationFacet enumeration = (XmlSchemaEnumerationFacet)facet;
                ConstantMapping constant = new ConstantMapping();
                string constantName = CodeIdentifier.MakeValid(enumeration.Value);
                constant.Name = constants.AddUnique(constantName, constant);
                constant.XmlName = enumeration.Value;
                constant.Value = i;
            }
            enumMapping.Constants = (ConstantMapping[])constants.ToArray(typeof(ConstantMapping));
            scope.AddTypeMapping(enumMapping);
            return enumMapping;
        }
        
        PrimitiveMapping ImportPrimitiveDataType(XmlSchemaSimpleType dataType) {
            TypeDesc sourceTypeDesc = GetDataTypeSource(dataType);
            PrimitiveMapping mapping = new PrimitiveMapping();
            mapping.TypeDesc = sourceTypeDesc;
            mapping.TypeName = sourceTypeDesc.DataType.Name;
            return mapping;
        }

        PrimitiveMapping ImportNonXsdPrimitiveDataType(XmlSchemaSimpleType dataType) {
            PrimitiveMapping mapping = null;
            TypeDesc typeDesc = null;
            if (dataType.Name != null && dataType.Name.Length != 0) {
                typeDesc = scope.GetTypeDesc(new XmlQualifiedName(dataType.Name, UrtTypes.Namespace));
                if (typeDesc != null) {
                    mapping = new PrimitiveMapping();
                    mapping.TypeDesc = typeDesc;
                    mapping.TypeName = typeDesc.DataType.Name;
                }
            }
            return mapping;
        }
        
        TypeDesc GetDataTypeSource(XmlSchemaSimpleType dataType) {
            if (dataType.Name != null && dataType.Name.Length != 0) {
                TypeDesc typeDesc = scope.GetTypeDesc(dataType);
                if (typeDesc != null) return typeDesc;
            }
            return GetDataTypeSource(FindDataType(dataType.DerivedFrom));
        }
        
        XmlSchemaSimpleType FindDataType(XmlQualifiedName name) {
            TypeDesc typeDesc = scope.GetTypeDesc(name);
            if (typeDesc != null)
                return typeDesc.DataType;
            XmlSchemaSimpleType dataType = (XmlSchemaSimpleType)schemas.Find(name, typeof(XmlSchemaSimpleType));
            if (dataType != null)
                return dataType;
            if (name.Namespace == XmlSchema.Namespace)
                return scope.GetTypeDesc(typeof(string)).DataType;
            else 
                throw new InvalidOperationException(Res.GetString(Res.XmlMissingDataType, name.Name));
        }
        
        object FindType(XmlQualifiedName name) {
            object type = schemas.Find(name, typeof(XmlSchemaComplexType));
            if (type != null) return type;
            return FindDataType(name);
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\serialization\soapschemamember.cs ===
//------------------------------------------------------------------------------
// <copyright file="SoapSchemaMember.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Serialization {

    using System;

    /// <include file='doc\SoapSchemaMember.uex' path='docs/doc[@for="SoapSchemaMember"]/*' />
    /// <internalonly/>
    public class SoapSchemaMember {
        string memberName;
        XmlQualifiedName type = XmlQualifiedName.Empty;

        /// <include file='doc\SoapSchemaMember.uex' path='docs/doc[@for="SoapSchemaMember.MemberType"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public XmlQualifiedName MemberType {
            get { return type; }
            set { type = value; }
        }

        /// <include file='doc\SoapSchemaMember.uex' path='docs/doc[@for="SoapSchemaMember.MemberName"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public string MemberName {
            get { return memberName == null ? string.Empty : memberName; }
            set { memberName = value; }
        }
    }


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\serialization\soaptypeattribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="SoapTypeAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Serialization {
    using System;

    /// <include file='doc\SoapTypeAttribute.uex' path='docs/doc[@for="SoapTypeAttribute"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [AttributeUsage(AttributeTargets.Class | AttributeTargets.Enum | AttributeTargets.Interface | AttributeTargets.Struct)]
    public class SoapTypeAttribute : System.Attribute {
        string ns;
        string typeName;
        bool includeInSchema = true;

        /// <include file='doc\SoapTypeAttribute.uex' path='docs/doc[@for="SoapTypeAttribute.SoapTypeAttribute"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public SoapTypeAttribute() {
        }

        /// <include file='doc\SoapTypeAttribute.uex' path='docs/doc[@for="SoapTypeAttribute.SoapTypeAttribute1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public SoapTypeAttribute(string typeName) {
            this.typeName = typeName;
        }

        /// <include file='doc\SoapTypeAttribute.uex' path='docs/doc[@for="SoapTypeAttribute.SoapTypeAttribute2"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public SoapTypeAttribute(string typeName, string ns) {
            this.typeName = typeName;
            this.ns = ns;
        }

        /// <include file='doc\SoapTypeAttribute.uex' path='docs/doc[@for="SoapTypeAttribute.IncludeInSchema"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public bool IncludeInSchema {
            get { return includeInSchema; }
            set { includeInSchema = value; }
        }

        /// <include file='doc\SoapTypeAttribute.uex' path='docs/doc[@for="SoapTypeAttribute.TypeName"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public string TypeName {
            get { return typeName == null ? string.Empty : typeName; }
            set { typeName = value; }
        }

        /// <include file='doc\SoapTypeAttribute.uex' path='docs/doc[@for="SoapTypeAttribute.Namespace"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public string Namespace {
            get { return ns; }
            set { ns = value; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\serialization\soapreflectionimporter.cs ===
//------------------------------------------------------------------------------
// <copyright file="SoapReflectionImporter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Serialization {

    using System.Reflection;
    using System;
    using System.Xml.Schema;
    using System.Collections;
    using System.ComponentModel;

    /// <include file='doc\SoapReflectionImporter.uex' path='docs/doc[@for="SoapReflectionImporter"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public class SoapReflectionImporter {
        TypeScope typeScope;
        SoapAttributeOverrides attributeOverrides;
        NameTable types = new NameTable();      // xmltypename + xmlns -> Mapping
        StructMapping root;
        string defaultNs;
        ModelScope modelScope;

       
        /// <include file='doc\SoapReflectionImporter.uex' path='docs/doc[@for="SoapReflectionImporter.SoapReflectionImporter"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public SoapReflectionImporter() : this(null, null) {
        }

        /// <include file='doc\SoapReflectionImporter.uex' path='docs/doc[@for="SoapReflectionImporter.SoapReflectionImporter1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public SoapReflectionImporter(string defaultNamespace) : this(null, defaultNamespace) {
        }

        /// <include file='doc\SoapReflectionImporter.uex' path='docs/doc[@for="SoapReflectionImporter.SoapReflectionImporter2"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public SoapReflectionImporter(SoapAttributeOverrides attributeOverrides) : this(attributeOverrides, null) {
        }

        /// <include file='doc\SoapReflectionImporter.uex' path='docs/doc[@for="SoapReflectionImporter.SoapReflectionImporter3"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public SoapReflectionImporter(SoapAttributeOverrides attributeOverrides, string defaultNamespace) {
            if (defaultNamespace == null)
                defaultNamespace = String.Empty;
            if (attributeOverrides == null)
                attributeOverrides = new SoapAttributeOverrides();
            this.attributeOverrides = attributeOverrides;
            this.defaultNs = defaultNamespace;
            this.typeScope = new TypeScope();
            this.modelScope = new ModelScope(this.typeScope);
        }

        /// <include file='doc\SoapReflectionImporter.uex' path='docs/doc[@for="SoapReflectionImporter.IncludeTypes"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void IncludeTypes(ICustomAttributeProvider provider) {
            object[] attrs = provider.GetCustomAttributes(typeof(SoapIncludeAttribute), false);
            for (int i = 0; i < attrs.Length; i++) {
                IncludeType(((SoapIncludeAttribute)attrs[i]).Type);
            }
        }

        /// <include file='doc\SoapReflectionImporter.uex' path='docs/doc[@for="SoapReflectionImporter.IncludeType"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void IncludeType(Type type) {
            ImportTypeMapping(modelScope.GetTypeModel(type));
        }

        /// <include file='doc\SoapReflectionImporter.uex' path='docs/doc[@for="XmlReflectionImporter.ImportTypeMapping"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public XmlTypeMapping ImportTypeMapping(Type type) {
            return ImportTypeMapping(type, null);
        }

        /// <include file='doc\SoapReflectionImporter.uex' path='docs/doc[@for="XmlReflectionImporter.ImportTypeMapping1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public XmlTypeMapping ImportTypeMapping(Type type, string defaultNamespace) {
            ElementAccessor element = new ElementAccessor();
            element.IsSoap = true;
            element.Mapping = ImportTypeMapping(modelScope.GetTypeModel(type));
            element.Name = Accessor.EscapeName(element.Mapping.TypeName, false);
            element.Namespace = element.Mapping.Namespace == null ? defaultNamespace : element.Mapping.Namespace;
            element.Form = XmlSchemaForm.Qualified;
            XmlTypeMapping xmlMapping = new XmlTypeMapping(typeScope, element);
            xmlMapping.IsSoap = true;
            xmlMapping.GenerateSerializer = true;
            return xmlMapping;
        }

        /// <include file='doc\SoapReflectionImporter.uex' path='docs/doc[@for="SoapReflectionImporter.ImportMembersMapping"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public XmlMembersMapping ImportMembersMapping(string elementName, string ns, XmlReflectionMember[] members) {
            return ImportMembersMapping(elementName, ns, members, true, true, false);
        }

        /// <include file='doc\SoapReflectionImporter.uex' path='docs/doc[@for="SoapReflectionImporter.ImportMembersMapping1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public XmlMembersMapping ImportMembersMapping(string elementName, string ns, XmlReflectionMember[] members, bool hasWrapperElement, bool writeAccessors) {
            return ImportMembersMapping(elementName, ns, members, hasWrapperElement, writeAccessors, false);
        }

        /// <include file='doc\SoapReflectionImporter.uex' path='docs/doc[@for="SoapReflectionImporter.ImportMembersMapping2"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public XmlMembersMapping ImportMembersMapping(string elementName, string ns, XmlReflectionMember[] members, bool hasWrapperElement, bool writeAccessors, bool validate) {
            ElementAccessor element = new ElementAccessor();
            element.IsSoap = true;
            element.Name = Accessor.EscapeName(elementName, false);

            element.Mapping = ImportMembersMapping(members, ns, hasWrapperElement, writeAccessors, validate);
            element.Mapping.TypeName = elementName;
            element.Namespace = element.Mapping.Namespace == null ? ns : element.Mapping.Namespace;
            element.Form = XmlSchemaForm.Qualified;
            XmlMembersMapping xmlMapping = new XmlMembersMapping(typeScope, element);
            xmlMapping.IsSoap = true;
            xmlMapping.GenerateSerializer = true;
            return xmlMapping;
        }

        string GetMappingName(Mapping mapping) {
            if (mapping is MembersMapping)
                return "(method)";
            else if (mapping is TypeMapping)
                return ((TypeMapping)mapping).TypeDesc.FullName;
            else
                throw new ArgumentException(Res.GetString(Res.XmlInternalError), "mapping");
        }

        Exception ReflectionException(string context, Exception e) {
            return new InvalidOperationException(Res.GetString(Res.XmlReflectionError, context), e);
        }

        internal TypeScope TypeScope {
            get { return typeScope; }
        }

        SoapAttributes GetAttributes(Type type) {
            SoapAttributes attrs = attributeOverrides[type];
            if (attrs != null) return attrs;
            return new SoapAttributes(type);
        }

        SoapAttributes GetAttributes(MemberInfo memberInfo) {
            SoapAttributes attrs = attributeOverrides[memberInfo.DeclaringType, memberInfo.Name];
            if (attrs != null) return attrs;
            return new SoapAttributes(memberInfo);
        }

        TypeMapping ImportTypeMapping(TypeModel model) {
            return ImportTypeMapping(model, String.Empty);
        }

        TypeMapping ImportTypeMapping(TypeModel model, string dataType) {
            if (dataType.Length > 0) {
                if (!model.TypeDesc.IsPrimitive) {
                    throw new InvalidOperationException(Res.GetString(Res.XmlInvalidDataTypeUsage, dataType, "SoapElementAttribute.DataType"));
                }
                TypeDesc td = typeScope.GetTypeDesc(new XmlQualifiedName(dataType, XmlSchema.Namespace));
                if (td == null) {
                    throw new InvalidOperationException(Res.GetString(Res.XmlInvalidXsdDataType, dataType, "SoapElementAttribute.DataType", new XmlQualifiedName(dataType, XmlSchema.Namespace).ToString()));
                }
                if (model.TypeDesc.FullName != td.FullName) {
                    throw new InvalidOperationException(Res.GetString(Res.XmlDataTypeMismatch, dataType, "SoapElementAttribute.DataType", model.TypeDesc.FullName));
                }
            }

            SoapAttributes a = GetAttributes(model.Type);
            
            if ((a.SoapFlags & ~SoapAttributeFlags.Type) != 0)
                throw new InvalidOperationException(Res.GetString(Res.XmlInvalidTypeAttributes, model.Type.FullName));

            switch (model.TypeDesc.Kind) {
                case TypeKind.Enum: 
                    return ImportEnumMapping((EnumModel)model);
                case TypeKind.Primitive:
                    return ImportPrimitiveMapping((PrimitiveModel)model, dataType);
                case TypeKind.Array:
                case TypeKind.Collection:
                case TypeKind.Enumerable:
                    return ImportArrayLikeMapping((ArrayModel)model);
                case TypeKind.Root:
                case TypeKind.Class:
                case TypeKind.Struct:
                case TypeKind.Interface:
                    return ImportStructLikeMapping((StructModel)model);
                default:
                    throw new NotSupportedException(Res.GetString(Res.XmlUnsupportedSoapTypeKind, model.TypeDesc.FullName));
            }
        }

        StructMapping CreateRootMapping() {
            TypeDesc typeDesc = typeScope.GetTypeDesc(typeof(object));
            StructMapping mapping = new StructMapping();
            mapping.IsSoap = true;
            mapping.TypeDesc = typeDesc;
            mapping.Members = new MemberMapping[0];
            mapping.IncludeInSchema = false;
            mapping.TypeName = Soap.UrType;
            mapping.Namespace = XmlSchema.Namespace;
            return mapping;
        }
        
        StructMapping GetRootMapping() {
            if (root == null) {
                root = CreateRootMapping();
                typeScope.AddTypeMapping(root);
            }
            return root;
        }

        TypeMapping GetTypeMapping(string typeName, string ns, TypeDesc typeDesc) {
            TypeMapping mapping = (TypeMapping)types[typeName, ns];
            if (mapping == null) return null;
            if (mapping.TypeDesc != typeDesc) 
                throw new InvalidOperationException(Res.GetString(Res.XmlTypesDuplicate, typeDesc.FullName, mapping.TypeDesc.FullName, typeName, ns));
            return mapping;
        }

        StructMapping ImportStructLikeMapping(StructModel model) {
            if (model.TypeDesc.Kind == TypeKind.Root) return GetRootMapping();

            SoapAttributes a = GetAttributes(model.Type);

            string typeNs = defaultNs;
            if (a.SoapType != null && a.SoapType.Namespace != null)
                typeNs = a.SoapType.Namespace;

            string typeName = string.Empty;
            if (a.SoapType != null)
                typeName = a.SoapType.TypeName;
            if (typeName.Length == 0) 
                typeName = model.TypeDesc.Name;


            StructMapping mapping = (StructMapping)GetTypeMapping(typeName, typeNs, model.TypeDesc);
            if (mapping == null) {
                mapping = new StructMapping();
                mapping.IsSoap = true;
                mapping.TypeDesc = model.TypeDesc;
                mapping.Namespace = typeNs;
                mapping.TypeName = typeName;
                if (a.SoapType != null) mapping.IncludeInSchema = a.SoapType.IncludeInSchema;
                typeScope.AddTypeMapping(mapping);
                types.Add(typeName, typeNs, mapping);
                if (model.TypeDesc.BaseTypeDesc != null) {
                    mapping.BaseMapping = ImportStructLikeMapping((StructModel)modelScope.GetTypeModel(model.Type.BaseType, false));
                }
                ArrayList members = new ArrayList();
                foreach (MemberInfo memberInfo in model.GetMemberInfos()) {
                    SoapAttributes memberAttrs = GetAttributes(memberInfo);
                    if (memberAttrs.SoapIgnore) continue;
                    FieldModel fieldModel = model.GetFieldModel(memberInfo);
                    if (fieldModel == null) continue;
                    MemberMapping member = ImportFieldMapping(fieldModel, memberAttrs, mapping.Namespace);
                    if (member == null) continue;

                    if (!member.TypeDesc.IsPrimitive && !member.TypeDesc.IsEnum) {
                        if (model.TypeDesc.IsValueType)
                            throw new NotSupportedException(Res.GetString(Res.XmlRpcRefsInValueType, model.TypeDesc.FullName));
                        if (member.TypeDesc.IsValueType)
                            throw new NotSupportedException(Res.GetString(Res.XmlRpcNestedValueType, member.TypeDesc.FullName));
                    }
                    if (mapping.BaseMapping != null) {
                        if (mapping.BaseMapping.Declares(member, mapping.TypeName)) continue;
                    }
                    members.Add(member);
                }
                mapping.Members = (MemberMapping[])members.ToArray(typeof(MemberMapping));
                if (mapping.BaseMapping == null) mapping.BaseMapping = GetRootMapping();
                IncludeTypes(model.Type);
            }
            return mapping;
        }

        ArrayMapping ImportArrayLikeMapping(ArrayModel model) {

            ArrayMapping mapping = new ArrayMapping();
            mapping.IsSoap = true;
            TypeMapping itemTypeMapping = ImportTypeMapping(model.Element);

            if (itemTypeMapping.TypeDesc.IsValueType && !itemTypeMapping.TypeDesc.IsPrimitive && !itemTypeMapping.TypeDesc.IsEnum)
                throw new NotSupportedException(Res.GetString(Res.XmlRpcArrayOfValueTypes, model.TypeDesc.FullName));
            
            mapping.TypeDesc = model.TypeDesc;
            mapping.Elements = new ElementAccessor[] { 
                CreateElementAccessor(itemTypeMapping, null, mapping.Namespace) };
            SetArrayMappingType(mapping);

            // in the case of an ArrayMapping we can have more that one mapping correspond to a type
            // examples of that are ArrayList and object[] both will map tp ArrayOfur-type
            // so we create a link list for all mappings of the same XSD type
            ArrayMapping existingMapping = (ArrayMapping)types[mapping.TypeName, mapping.Namespace];
            if (existingMapping != null) {
                ArrayMapping first = existingMapping;
                while (existingMapping != null) {
                    if (existingMapping.TypeDesc == model.TypeDesc)
                        return existingMapping;
                    existingMapping = existingMapping.Next;
                }
                mapping.Next = first;
                types[mapping.TypeName, mapping.Namespace] = mapping;
                return mapping;
            }
            typeScope.AddTypeMapping(mapping);
            types.Add(mapping.TypeName, mapping.Namespace, mapping);
            IncludeTypes(model.Type);
            return mapping;
        }

        void SetArrayMappingType(ArrayMapping mapping) {
            bool useDefaultNs = false;

            string itemTypeName;
            string itemTypeNamespace;

            TypeMapping itemTypeMapping;
            if (mapping.Elements.Length == 1)
                itemTypeMapping = mapping.Elements[0].Mapping;
            else
                itemTypeMapping = null;

            if (itemTypeMapping is EnumMapping) {
                itemTypeNamespace = itemTypeMapping.Namespace;
                itemTypeName = itemTypeMapping.TypeName;
            }
            else if (itemTypeMapping is PrimitiveMapping) {
                itemTypeNamespace = itemTypeMapping.TypeDesc.IsXsdType ? XmlSchema.Namespace : UrtTypes.Namespace;
                itemTypeName = itemTypeMapping.TypeDesc.DataType.Name;
                useDefaultNs = true;
            }
            else if (itemTypeMapping is StructMapping) {
                if (itemTypeMapping.TypeDesc.IsRoot) {
                    itemTypeNamespace = XmlSchema.Namespace;
                    itemTypeName = Soap.UrType;
                    useDefaultNs = true;
                }
                else {
                    itemTypeNamespace = itemTypeMapping.Namespace;
                    itemTypeName = itemTypeMapping.TypeName;
                }
            }
            else if (itemTypeMapping is ArrayMapping) {
                itemTypeNamespace = itemTypeMapping.Namespace;
                itemTypeName = itemTypeMapping.TypeName;
            }
            else {
                throw new InvalidOperationException(Res.GetString(Res.XmlInvalidSoapArray, mapping.TypeDesc.FullName));
            }

            mapping.Namespace = useDefaultNs ? defaultNs : itemTypeNamespace;
            mapping.TypeName = "ArrayOf" + CodeIdentifier.MakePascal(itemTypeName);
        }

        PrimitiveMapping ImportPrimitiveMapping(PrimitiveModel model, string dataType) {
            PrimitiveMapping mapping = new PrimitiveMapping();
            mapping.IsSoap = true;
            if (dataType.Length > 0) {
                mapping.TypeDesc = typeScope.GetTypeDesc(new XmlQualifiedName(dataType, XmlSchema.Namespace));
                if (mapping.TypeDesc == null) {
                    // try it as a non-Xsd type
                    mapping.TypeDesc = typeScope.GetTypeDesc(new XmlQualifiedName(dataType, UrtTypes.Namespace));
                    if (mapping.TypeDesc == null) {
                        throw new InvalidOperationException(Res.GetString(Res.XmlUdeclaredXsdType, dataType));
                    }
                }
            }
            else {
                mapping.TypeDesc = model.TypeDesc;
            }
            mapping.TypeName = mapping.TypeDesc.DataType.Name;
            mapping.Namespace = mapping.TypeDesc.IsXsdType ? XmlSchema.Namespace : UrtTypes.Namespace;
            return mapping;
        }
       
        EnumMapping ImportEnumMapping(EnumModel model) {
            SoapAttributes a = GetAttributes(model.Type);
            string typeNs = defaultNs;
            if (a.SoapType != null && a.SoapType.Namespace != null)
                typeNs = a.SoapType.Namespace;

            string typeName = string.Empty;
            if (a.SoapType != null)
                typeName = a.SoapType.TypeName;
            if (typeName.Length == 0) 
                typeName = model.TypeDesc.Name;

            EnumMapping mapping = (EnumMapping)GetTypeMapping(typeName, typeNs, model.TypeDesc);
            if (mapping == null) {
                mapping = new EnumMapping();
                mapping.IsSoap = true;
                mapping.TypeDesc = model.TypeDesc;
                mapping.TypeName = typeName;
                mapping.Namespace = typeNs;
                mapping.IsFlags =  model.Type.IsDefined(typeof(FlagsAttribute), false);
                typeScope.AddTypeMapping(mapping);
                types.Add(typeName, typeNs, mapping);
                ArrayList constants = new ArrayList();
                for (int i = 0; i < model.Constants.Length; i++) {
                    ConstantMapping constant = ImportConstantMapping(model.Constants[i]);
                    if (constant != null) constants.Add(constant);
                }
                if (constants.Count == 0) {
                    throw new InvalidOperationException(Res.GetString(Res.XmlNoSerializableMembers, model.TypeDesc.FullName));
                }
                mapping.Constants = (ConstantMapping[])constants.ToArray(typeof(ConstantMapping));
            }
            return mapping;
        }
        
        ConstantMapping ImportConstantMapping(ConstantModel model) {
            SoapAttributes a = GetAttributes(model.FieldInfo);
            if (a.SoapIgnore) return null;
            if ((a.SoapFlags & ~SoapAttributeFlags.Enum) != 0)
                throw new InvalidOperationException(Res.GetString(Res.XmlInvalidEnumAttribute));
            if (a.SoapEnum == null)
                a.SoapEnum = new SoapEnumAttribute();

            ConstantMapping constant = new ConstantMapping();
            constant.XmlName = a.SoapEnum.Name.Length == 0 ? model.Name : a.SoapEnum.Name;
            constant.Name = model.Name;
            constant.Value = model.Value;
            return constant;
        }
        
        MembersMapping ImportMembersMapping(XmlReflectionMember[] xmlReflectionMembers, string ns, bool hasWrapperElement, bool writeAccessors, bool validateWrapperElement) {
            MembersMapping members = new MembersMapping();
            members.TypeDesc = typeScope.GetTypeDesc(typeof(object[]));
            MemberMapping[] mappings = new MemberMapping[xmlReflectionMembers.Length];
            for (int i = 0; i < mappings.Length; i++) {
                try {
                    XmlReflectionMember member = xmlReflectionMembers[i];
                    MemberMapping mapping = ImportMemberMapping(member, ns, hasWrapperElement ? XmlSchemaForm.Unqualified : XmlSchemaForm.Qualified);
                    if (member.IsReturnValue && writeAccessors) { // no special treatment for return values with doc/enc
                        if (i > 0) throw new InvalidOperationException(Res.GetString(Res.XmlInvalidReturnPosition));
                        mapping.IsReturnValue = true;
                    }
                    mappings[i] = mapping;
                }
                catch (Exception e) {
                    throw ReflectionException(xmlReflectionMembers[i].MemberName, e);
                }
            }
            members.Members = mappings;
            members.HasWrapperElement = hasWrapperElement;
            if (hasWrapperElement) {
                members.ValidateRpcWrapperElement = validateWrapperElement;
            }
            members.WriteAccessors = writeAccessors;
            members.IsSoap = true;
            if (hasWrapperElement && !writeAccessors)
                members.Namespace = ns;
            return members;
        }
        
        MemberMapping ImportMemberMapping(XmlReflectionMember xmlReflectionMember, string ns, XmlSchemaForm form) {
            SoapAttributes a = xmlReflectionMember.SoapAttributes;
            if (a.SoapIgnore) return null;
            MemberMapping member = new MemberMapping();
            member.IsSoap = true;
            member.Name = xmlReflectionMember.MemberName;
            FieldModel model = new FieldModel(xmlReflectionMember.MemberName, xmlReflectionMember.MemberType, typeScope.GetTypeDesc(xmlReflectionMember.MemberType), false, false);
            member.ReadOnly = model.ReadOnly || !model.FieldTypeDesc.HasDefaultConstructor;
            ImportAccessorMapping(member, model, a, ns, form);
            if (xmlReflectionMember.OverrideIsNullable)
                member.Elements[0].IsNullable = false;
            return member;
        }

        MemberMapping ImportFieldMapping(FieldModel model, SoapAttributes a, string ns) {
            if (a.SoapIgnore) return null;
            MemberMapping member = new MemberMapping();
            member.IsSoap = true;
            member.Name = model.Name;
            member.CheckShouldPersist = model.CheckShouldPersist;
            member.CheckSpecified = model.CheckSpecified;
            member.ReadOnly = model.ReadOnly || !model.FieldTypeDesc.HasDefaultConstructor;
            ImportAccessorMapping(member, model, a, ns, XmlSchemaForm.Unqualified);
            return member;
        }

        void ImportAccessorMapping(MemberMapping accessor, FieldModel model, SoapAttributes a, string ns, XmlSchemaForm form) {
            Type accessorType = model.FieldType;
            string accessorName = model.Name;
            accessor.TypeDesc = typeScope.GetTypeDesc(accessorType);
            if (accessor.TypeDesc.IsVoid) {
                throw new InvalidOperationException(Res.GetString(Res.XmlInvalidVoid));
            }

            SoapAttributeFlags flags = a.SoapFlags;
            if ((flags & SoapAttributeFlags.Attribute) == SoapAttributeFlags.Attribute) {
                if (!accessor.TypeDesc.IsPrimitive && !accessor.TypeDesc.IsEnum)
                    throw new InvalidOperationException(Res.GetString(Res.XmlIllegalAttrOrText));

                if ((flags & SoapAttributeFlags.Attribute) != flags)
                    throw new InvalidOperationException(Res.GetString(Res.XmlInvalidElementAttribute));
                
                AttributeAccessor attribute = new AttributeAccessor();
                attribute.Name = Accessor.EscapeName(a.SoapAttribute == null || a.SoapAttribute.AttributeName.Length == 0 ? accessorName : a.SoapAttribute.AttributeName, true);
                attribute.Namespace = a.SoapAttribute == null || a.SoapAttribute.Namespace == null ? ns : a.SoapAttribute.Namespace;
                attribute.Form = XmlSchemaForm.Qualified; // attributes are always qualified since they're only used for encoded soap headers
                attribute.Mapping = ImportTypeMapping(modelScope.GetTypeModel(accessorType), (a.SoapAttribute == null ? String.Empty : a.SoapAttribute.DataType));
                attribute.Default = GetDefaultValue(model.FieldTypeDesc, a);
                accessor.Attribute = attribute;
                accessor.Elements = new ElementAccessor[0];
            }
            else {
                if ((flags & SoapAttributeFlags.Element) != flags)
                    throw new InvalidOperationException(Res.GetString(Res.XmlInvalidElementAttribute));

                ElementAccessor element = new ElementAccessor();
                element.IsSoap = true;
                element.Name = Accessor.EscapeName(a.SoapElement == null || a.SoapElement.ElementName.Length == 0 ? accessorName : a.SoapElement.ElementName, false);
                element.Namespace = ns;
                element.Form = form;
                element.Mapping = ImportTypeMapping(modelScope.GetTypeModel(accessorType), (a.SoapElement == null ? String.Empty : a.SoapElement.DataType));
                if (a.SoapElement != null)
                    element.IsNullable = a.SoapElement.IsNullable;
                accessor.Elements = new ElementAccessor[] { element };
            }
        }

        static ElementAccessor CreateElementAccessor(TypeMapping mapping, string name, string ns) {
            ElementAccessor element = new ElementAccessor();
            element.IsSoap = true;
            element.Name = Accessor.EscapeName(name == null ? mapping.TypeName : name, false);
            element.Namespace = ns;
            element.Mapping = mapping;
            return element;
        }

        object GetDefaultValue(TypeDesc fieldTypeDesc, SoapAttributes a) {
            if (a.SoapDefaultValue == DBNull.Value) return a.SoapDefaultValue;
            if (!(fieldTypeDesc.Kind == TypeKind.Primitive || fieldTypeDesc.Kind == TypeKind.Enum))  {
                a.SoapDefaultValue = DBNull.Value;
                return a.SoapDefaultValue;
            }
            // for enums validate and return a string representation
            if (fieldTypeDesc.Kind == TypeKind.Enum) {
                if (fieldTypeDesc != typeScope.GetTypeDesc(a.SoapDefaultValue.GetType()))
                    throw new InvalidOperationException(Res.GetString(Res.XmlInvalidDefaultEnumValue, a.SoapDefaultValue.GetType().FullName, fieldTypeDesc.FullName));
                string strValue = Enum.Format(a.SoapDefaultValue.GetType(), a.SoapDefaultValue, "G").Replace(",", " ");
                string numValue = Enum.Format(a.SoapDefaultValue.GetType(), a.SoapDefaultValue, "D");
                if (strValue == numValue) // means enum value wasn't recognized
                    throw new InvalidOperationException(Res.GetString(Res.XmlInvalidDefaultValue, strValue, a.SoapDefaultValue.GetType().FullName));
                return strValue;
            }
            return a.SoapDefaultValue;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\serialization\xmlanyattributeattribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlAnyAttributeAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Serialization {
    using System;
    using System.Xml.Schema;

    /// <include file='doc\XmlAnyAttributeAttribute.uex' path='docs/doc[@for="XmlAnyAttributeAttribute"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [AttributeUsage(AttributeTargets.Field | AttributeTargets.Property | AttributeTargets.Parameter | AttributeTargets.ReturnValue, AllowMultiple=false)]
    public class XmlAnyAttributeAttribute : System.Attribute {

        /// <include file='doc\XmlAnyAttributeAttribute.uex' path='docs/doc[@for="XmlAnyAttributeAttribute.XmlAnyAttributeAttribute"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public XmlAnyAttributeAttribute() {
        }
       
    }
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\serialization\xmlanyelementattributes.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlAnyElementAttributes.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Serialization {
    using System;
    using System.Reflection;
    using System.Collections;
    using System.ComponentModel;

    /// <include file='doc\XmlAnyElementAttributes.uex' path='docs/doc[@for="XmlAnyElementAttributes"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public class XmlAnyElementAttributes : CollectionBase {
        
        /// <include file='doc\XmlAnyElementAttributes.uex' path='docs/doc[@for="XmlAnyElementAttributes.this"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public XmlAnyElementAttribute this[int index] {
            get { return (XmlAnyElementAttribute)List[index]; }
            set { List[index] = value; }
        }
        
        /// <include file='doc\XmlAnyElementAttributes.uex' path='docs/doc[@for="XmlAnyElementAttributes.Add"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public int Add(XmlAnyElementAttribute attribute) {
            return List.Add(attribute);
        }
        
        /// <include file='doc\XmlAnyElementAttributes.uex' path='docs/doc[@for="XmlAnyElementAttributes.Insert"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void Insert(int index, XmlAnyElementAttribute attribute) {
            List.Insert(index, attribute);
        }
        
        /// <include file='doc\XmlAnyElementAttributes.uex' path='docs/doc[@for="XmlAnyElementAttributes.IndexOf"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public int IndexOf(XmlAnyElementAttribute attribute) {
            return List.IndexOf(attribute);
        }
        
        /// <include file='doc\XmlAnyElementAttributes.uex' path='docs/doc[@for="XmlAnyElementAttributes.Contains"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public bool Contains(XmlAnyElementAttribute attribute) {
            return List.Contains(attribute);
        }
        
        /// <include file='doc\XmlAnyElementAttributes.uex' path='docs/doc[@for="XmlAnyElementAttributes.Remove"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void Remove(XmlAnyElementAttribute attribute) {
            List.Remove(attribute);
        }
        
        /// <include file='doc\XmlAnyElementAttributes.uex' path='docs/doc[@for="XmlAnyElementAttributes.CopyTo"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void CopyTo(XmlAnyElementAttribute[] array, int index) {
            List.CopyTo(array, index);
        }
        
    }



}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\serialization\xmlarrayitemattribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlArrayItemAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Serialization {

    using System;
    using System.Xml.Schema;

    /// <include file='doc\XmlArrayItemAttribute.uex' path='docs/doc[@for="XmlArrayItemAttribute"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [AttributeUsage(AttributeTargets.Field | AttributeTargets.Property | AttributeTargets.Parameter | AttributeTargets.ReturnValue, AllowMultiple=true)]
    public class XmlArrayItemAttribute : System.Attribute {
        string elementName;
        Type type;
        string ns;
        string dataType;
        bool nullable;
        bool nullableSpecified = false;
        XmlSchemaForm form = XmlSchemaForm.None;
        int nestingLevel;
        
        /// <include file='doc\XmlArrayItemAttribute.uex' path='docs/doc[@for="XmlArrayItemAttribute.XmlArrayItemAttribute"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public XmlArrayItemAttribute() {
        }
        
        /// <include file='doc\XmlArrayItemAttribute.uex' path='docs/doc[@for="XmlArrayItemAttribute.XmlArrayItemAttribute1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public XmlArrayItemAttribute(string elementName) {
            this.elementName = elementName;
        }
        
        /// <include file='doc\XmlArrayItemAttribute.uex' path='docs/doc[@for="XmlArrayItemAttribute.XmlArrayItemAttribute2"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public XmlArrayItemAttribute(Type type) {
            this.type = type;
        }
        
        /// <include file='doc\XmlArrayItemAttribute.uex' path='docs/doc[@for="XmlArrayItemAttribute.XmlArrayItemAttribute3"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public XmlArrayItemAttribute(string elementName, Type type) {
            this.elementName = elementName;
            this.type = type;
        }
        
        /// <include file='doc\XmlArrayItemAttribute.uex' path='docs/doc[@for="XmlArrayItemAttribute.Type"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public Type Type {
            get { return type; }
            set { type = value; }
        }
        
        /// <include file='doc\XmlArrayItemAttribute.uex' path='docs/doc[@for="XmlArrayItemAttribute.ElementName"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public string ElementName {
            get { return elementName == null ? string.Empty : elementName; }
            set { elementName = value; }
        }

        /// <include file='doc\XmlArrayItemAttribute.uex' path='docs/doc[@for="XmlArrayItemAttribute.Namespace"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public string Namespace {
            get { return ns; }
            set { ns = value; }
        }

        /// <include file='doc\XmlArrayItemAttribute.uex' path='docs/doc[@for="XmlArrayItemAttribute.NestingLevel"]/*' />
        public int NestingLevel {
            get { return nestingLevel; }
            set { nestingLevel = value; }
        }

        /// <include file='doc\XmlArrayItemAttribute.uex' path='docs/doc[@for="XmlArrayItemAttribute.DataType"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public string DataType {
            get { return dataType == null ? string.Empty : dataType; }
            set { dataType = value; }
        }

        /// <include file='doc\XmlArrayItemAttribute.uex' path='docs/doc[@for="XmlArrayItemAttribute.IsNullable"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public bool IsNullable {
            get { return nullable; }
            set { nullable = value; nullableSpecified = true; }
        }

        internal bool IsNullableSpecified {
            get { return nullableSpecified; }
        }

        /// <include file='doc\XmlArrayItemAttribute.uex' path='docs/doc[@for="XmlArrayItemAttribute.Form"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public XmlSchemaForm Form {
            get { return form; }
            set { form = value; }
        }
    }
 }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\serialization\xmlanyelementattribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlAnyElementAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Serialization {
    using System;
    using System.Xml.Schema;

    /// <include file='doc\XmlAnyElementAttribute.uex' path='docs/doc[@for="XmlAnyElementAttribute"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [AttributeUsage(AttributeTargets.Field | AttributeTargets.Property | AttributeTargets.Parameter | AttributeTargets.ReturnValue, AllowMultiple=true)]
    public class XmlAnyElementAttribute : System.Attribute {
        string name;
        string ns;

        /// <include file='doc\XmlAnyElementAttribute.uex' path='docs/doc[@for="XmlAnyElementAttribute.XmlAnyElementAttribute"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public XmlAnyElementAttribute() {
        }
        
        /// <include file='doc\XmlAnyElementAttribute.uex' path='docs/doc[@for="XmlAnyElementAttribute.XmlAnyElementAttribute1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public XmlAnyElementAttribute(string name) {
            this.name = name;
        }

        /// <include file='doc\XmlAnyElementAttribute.uex' path='docs/doc[@for="XmlAnyElementAttribute.XmlAnyElementAttribute2"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public XmlAnyElementAttribute(string name, string ns) {
            this.name = name;
            this.ns = ns;
        }
        
        /// <include file='doc\XmlAnyElementAttribute.uex' path='docs/doc[@for="XmlAnyElementAttribute.Name"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public string Name {
            get { return name == null ? string.Empty : name; }
            set { name = value; }
        }
        
        /// <include file='doc\XmlAnyElementAttribute.uex' path='docs/doc[@for="XmlAnyElementAttribute.Namespace"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public string Namespace {
            get { return ns; }
            set { ns = value; }
        }
    }
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\serialization\xmlarrayattribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlArrayAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Serialization {

    using System;
    using System.Xml.Schema;
    
    /// <include file='doc\XmlArrayAttribute.uex' path='docs/doc[@for="XmlArrayAttribute"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [AttributeUsage(AttributeTargets.Field | AttributeTargets.Property | AttributeTargets.Parameter | AttributeTargets.ReturnValue, AllowMultiple=false)]
    public class XmlArrayAttribute : System.Attribute {
        string elementName;
        string ns;
        bool nullable;
        XmlSchemaForm form = XmlSchemaForm.None;
        
        /// <include file='doc\XmlArrayAttribute.uex' path='docs/doc[@for="XmlArrayAttribute.XmlArrayAttribute"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public XmlArrayAttribute() {
        }
        
        /// <include file='doc\XmlArrayAttribute.uex' path='docs/doc[@for="XmlArrayAttribute.XmlArrayAttribute1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public XmlArrayAttribute(string elementName) {
            this.elementName = elementName;
        }
        
        /// <include file='doc\XmlArrayAttribute.uex' path='docs/doc[@for="XmlArrayAttribute.ElementName"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public string ElementName {
            get { return elementName == null ? string.Empty : elementName; }
            set { elementName = value; }
        }
    
        /// <include file='doc\XmlArrayAttribute.uex' path='docs/doc[@for="XmlArrayAttribute.Namespace"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public string Namespace {
            get { return ns; }
            set { ns = value; }
        }

        /// <include file='doc\XmlArrayAttribute.uex' path='docs/doc[@for="XmlArrayAttribute.IsNullable"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public bool IsNullable {
            get { return nullable; }
            set { nullable = value; }
        }

        /// <include file='doc\XmlArrayAttribute.uex' path='docs/doc[@for="XmlArrayAttribute.Form"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public XmlSchemaForm Form {
            get { return form; }
            set { form = value; }
        }
    }
 }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\serialization\xmlarrayitemattributes.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlArrayItemAttributes.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Serialization {
    using System;
    using System.Reflection;
    using System.Collections;
    using System.ComponentModel;

   /// <include file='doc\XmlArrayItemAttributes.uex' path='docs/doc[@for="XmlArrayItemAttributes"]/*' />
   /// <devdoc>
   ///    <para>[To be supplied.]</para>
   /// </devdoc>
   public class XmlArrayItemAttributes : CollectionBase {
        
        /// <include file='doc\XmlArrayItemAttributes.uex' path='docs/doc[@for="XmlArrayItemAttributes.this"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public XmlArrayItemAttribute this[int index] {
            get { return (XmlArrayItemAttribute)List[index]; }
            set { List[index] = value; }
        }
        
        /// <include file='doc\XmlArrayItemAttributes.uex' path='docs/doc[@for="XmlArrayItemAttributes.Add"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public int Add(XmlArrayItemAttribute attribute) {
            return List.Add(attribute);
        }
        
        /// <include file='doc\XmlArrayItemAttributes.uex' path='docs/doc[@for="XmlArrayItemAttributes.Insert"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void Insert(int index, XmlArrayItemAttribute attribute) {
            List.Insert(index, attribute);
        }
        
        /// <include file='doc\XmlArrayItemAttributes.uex' path='docs/doc[@for="XmlArrayItemAttributes.IndexOf"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public int IndexOf(XmlArrayItemAttribute attribute) {
            return List.IndexOf(attribute);
        }
        
        /// <include file='doc\XmlArrayItemAttributes.uex' path='docs/doc[@for="XmlArrayItemAttributes.Contains"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public bool Contains(XmlArrayItemAttribute attribute) {
            return List.Contains(attribute);
        }
        
        /// <include file='doc\XmlArrayItemAttributes.uex' path='docs/doc[@for="XmlArrayItemAttributes.Remove"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void Remove(XmlArrayItemAttribute attribute) {
            List.Remove(attribute);
        }
        
        /// <include file='doc\XmlArrayItemAttributes.uex' path='docs/doc[@for="XmlArrayItemAttributes.CopyTo"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void CopyTo(XmlArrayItemAttribute[] array, int index) {
            List.CopyTo(array, index);
        }
        
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\serialization\xmlattributeattribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlAttributeAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Serialization {

    using System;
    using System.Xml.Schema;

    /// <include file='doc\XmlAttributeAttribute.uex' path='docs/doc[@for="XmlAttributeAttribute"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [AttributeUsage(AttributeTargets.Field | AttributeTargets.Property | AttributeTargets.Parameter | AttributeTargets.ReturnValue)]
    public class XmlAttributeAttribute : System.Attribute {
        string attributeName;
        Type type;
        string ns;
        string dataType;
        XmlSchemaForm form = XmlSchemaForm.None;
        
        /// <include file='doc\XmlAttributeAttribute.uex' path='docs/doc[@for="XmlAttributeAttribute.XmlAttributeAttribute"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public XmlAttributeAttribute() {
        }
        
        /// <include file='doc\XmlAttributeAttribute.uex' path='docs/doc[@for="XmlAttributeAttribute.XmlAttributeAttribute1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public XmlAttributeAttribute(string attributeName) {
            this.attributeName = attributeName;
        }
        
        /// <include file='doc\XmlAttributeAttribute.uex' path='docs/doc[@for="XmlAttributeAttribute.XmlAttributeAttribute2"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public XmlAttributeAttribute(Type type) {
            this.type = type;
        }
        
        /// <include file='doc\XmlAttributeAttribute.uex' path='docs/doc[@for="XmlAttributeAttribute.XmlAttributeAttribute3"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public XmlAttributeAttribute(string attributeName, Type type) {
            this.attributeName = attributeName;
            this.type = type;
        }

        /// <include file='doc\XmlAttributeAttribute.uex' path='docs/doc[@for="XmlAttributeAttribute.Type"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public Type Type {
            get { return type; }
            set { type = value; }
        }
       
        /// <include file='doc\XmlAttributeAttribute.uex' path='docs/doc[@for="XmlAttributeAttribute.AttributeName"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public string AttributeName {
            get { return attributeName == null ? string.Empty : attributeName; }
            set { attributeName = value; }
        }
        
        /// <include file='doc\XmlAttributeAttribute.uex' path='docs/doc[@for="XmlAttributeAttribute.Namespace"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public string Namespace {
            get { return ns; }
            set { ns = value; }
        }

        /// <include file='doc\XmlAttributeAttribute.uex' path='docs/doc[@for="XmlAttributeAttribute.DataType"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public string DataType {
            get { return dataType == null ? string.Empty : dataType; }
            set { dataType = value; }
        }

        /// <include file='doc\XmlAttributeAttribute.uex' path='docs/doc[@for="XmlAttributeAttribute.Form"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public XmlSchemaForm Form {
            get { return form; }
            set { form = value; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\serialization\xmlcustomformatter.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlCustomFormatter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   XmlCustomFormatter.cs
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/
namespace System.Xml.Serialization {

    using System;
    using System.Xml;
    using System.Globalization;
    using System.ComponentModel;
    using System.Diagnostics;
    using System.Text;
    using System.Collections;

    /// <summary>
    ///   The <see cref="XmlCustomFormatter"/> class provides a set of static methods for converting
    ///   primitive type values to and from their XML string representations.</summary>
    internal class XmlCustomFormatter
    {
        internal static string FromDefaultValue(object value, string formatter) {
            if (value == null) return null;
            Type type = value.GetType();
            if (type == typeof(DateTime)) {
                if (formatter == "DateTime") {
                    return FromDateTime((DateTime)value);
                }
                if (formatter == "Date") {
                    return FromDate((DateTime)value);
                }
                if (formatter == "Time") {
                    return FromTime((DateTime)value);
                }
            }
            else if (type == typeof(string)) {
                if (formatter == "XmlName") {
                    return FromXmlName((string)value);
                }
                if (formatter == "XmlNCName") {
                    return FromXmlNCName((string)value);
                }
                if (formatter == "XmlNmToken") {
                    return FromXmlNmToken((string)value);
                }
                if (formatter == "XmlNmTokens") {
                    return FromXmlNmTokens((string)value);
                }
            }
            throw new Exception(Res.GetString(Res.XmlUnsupportedDefaultType, type.FullName));
        }

        internal static string FromDate(DateTime value) {
            return XmlConvert.ToString(value, "yyyy-MM-dd");
        }

        internal static string FromTime(DateTime value) {
            return XmlConvert.ToString(DateTime.MinValue + value.TimeOfDay, "HH:mm:ss.fffffffzzzzzz");
        }
        internal static string FromDateTime(DateTime value) {
            return XmlConvert.ToString(value, "yyyy-MM-ddTHH:mm:ss.fffffffzzzzzz");
        }

        internal static string FromChar(char value) {
            return XmlConvert.ToString((UInt16)value);
        }

        internal static string FromXmlName(string name) {
            return XmlConvert.EncodeName(name);
        }

        internal static string FromXmlNCName(string ncName) {
            return XmlConvert.EncodeLocalName(ncName);
        }

        internal static string FromXmlNmToken(string nmToken) {
            return XmlConvert.EncodeNmToken(nmToken);
        }

        internal static string FromXmlNmTokens(string nmTokens) {
            if (nmTokens == null)
                return null;
            if (nmTokens.IndexOf(' ') < 0) 
                return FromXmlNmToken(nmTokens);
            else {
                string[] toks = nmTokens.Split(new char[] { ' ' });
                StringBuilder sb = new StringBuilder();
                for (int i = 0; i < toks.Length; i++) {
                    if (i > 0) sb.Append(' ');
                    sb.Append(FromXmlNmToken(toks[i]));
                }
                return sb.ToString();
            }
        }

        private const int Base64LineSize = 76;  
        private const int InDataLineSize = Base64LineSize/4*3;    
        private static readonly char[] CRLF = new char[2] {(char)0x0D, (char)0x0A};

        internal static void WriteArrayBase64(XmlWriter writer, byte[] inData, int start, int count) {
            if (inData == null || count == 0) {
                return;
            }
            char[] line = new char[Base64LineSize];
            
            int chunkSize = InDataLineSize;
            int end = start + count;
            while(start < end) {
                if (start + chunkSize > end) {
                    chunkSize = end - start;
                }
                writer.WriteRaw(line, 0, Convert.ToBase64CharArray(inData, start, chunkSize, line, 0));
                start+=chunkSize;
                if ( start < end) {
                    writer.WriteRaw(CRLF, 0, 2);
                }
            }
        }

        internal static string FromByteArrayHex(byte[] value) {
            if (value == null)
                return null;
            if (value.Length == 0)
                return "";
            return XmlConvert.ToBinHexString(value);
        }

        internal static string FromEnum(long val, string[] vals, long[] ids) {
            #if DEBUG
                // use exception in the place of Debug.Assert to avoid throwing asserts from a server process such as aspnet_ewp.exe
                if (ids.Length != vals.Length) throw new InvalidOperationException(Res.GetString(Res.XmlInternalErrorDetails, "Invalid enum"));
            #endif

            long originalValue = val;
            StringBuilder sb = new StringBuilder();
            int iZero = -1;

            for (int i = 0; i < ids.Length; i++) {
                if (ids[i] == 0) {
                    iZero = i;
                    continue;
                }
                if (val == 0) {
                    break;
                }
                if ((ids[i] & originalValue) == ids[i]) {
                    if (sb.Length != 0)
                        sb.Append(" ");
                    sb.Append(vals[i]);
                    val &= ~ids[i];
                }
            }
            if (val != 0) {
                return originalValue.ToString();
            }
            if (sb.Length == 0 && iZero >= 0) {
                sb.Append(vals[iZero]);
            }
            return sb.ToString();
        }

        internal static object ToDefaultValue(string value, string formatter) {
            if (formatter == "DateTime") {
                return ToDateTime(value);
            }
            if (formatter == "Date") {
                return ToDate(value);
            }
            if (formatter == "Time") {
                return ToTime(value);
            }
            if (formatter == "XmlName") {
                return ToXmlName(value);
            }
            if (formatter == "XmlNCName") {
                return ToXmlNCName(value);
            }
            if (formatter == "XmlNmToken") {
                return ToXmlNmToken(value);
            }
            if (formatter == "XmlNmTokens") {
                return ToXmlNmTokens(value);
            }
            throw new Exception(Res.GetString(Res.XmlUnsupportedDefaultValue, formatter));
//            Debug.WriteLineIf(CompModSwitches.XmlSerialization.TraceVerbose, "XmlSerialization::Unhandled default value " + value + " formatter " + formatter);
//            return DBNull.Value;
        }

        static string[] allDateTimeFormats = new string[] {
            "yyyy-MM-ddTHH:mm:ss.fffffffzzzzzz",
            "yyyy",
            "---dd",
            "---ddZ",
            "---ddzzzzzz",
            "--MM-dd",
            "--MM-ddZ",
            "--MM-ddzzzzzz",
            "--MM--",
            "--MM--Z",
            "--MM--zzzzzz",
            "yyyy-MM",
            "yyyy-MMZ",
            "yyyy-MMzzzzzz",
            "yyyyzzzzzz",
            "yyyy-MM-dd",
            "yyyy-MM-ddZ",
            "yyyy-MM-ddzzzzzz",

            "HH:mm:ss",
            "HH:mm:ss.f",
            "HH:mm:ss.ff",
            "HH:mm:ss.fff",
            "HH:mm:ss.ffff",
            "HH:mm:ss.fffff",
            "HH:mm:ss.ffffff",
            "HH:mm:ss.fffffff",
            "HH:mm:ssZ",
            "HH:mm:ss.fZ",
            "HH:mm:ss.ffZ",
            "HH:mm:ss.fffZ",
            "HH:mm:ss.ffffZ",
            "HH:mm:ss.fffffZ",
            "HH:mm:ss.ffffffZ",
            "HH:mm:ss.fffffffZ",
            "HH:mm:sszzzzzz",
            "HH:mm:ss.fzzzzzz",
            "HH:mm:ss.ffzzzzzz",
            "HH:mm:ss.fffzzzzzz",
            "HH:mm:ss.ffffzzzzzz",
            "HH:mm:ss.fffffzzzzzz",
            "HH:mm:ss.ffffffzzzzzz",
            "HH:mm:ss.fffffffzzzzzz",
            "yyyy-MM-ddTHH:mm:ss",
            "yyyy-MM-ddTHH:mm:ss.f",
            "yyyy-MM-ddTHH:mm:ss.ff",
            "yyyy-MM-ddTHH:mm:ss.fff",
            "yyyy-MM-ddTHH:mm:ss.ffff",
            "yyyy-MM-ddTHH:mm:ss.fffff",
            "yyyy-MM-ddTHH:mm:ss.ffffff",
            "yyyy-MM-ddTHH:mm:ss.fffffff",
            "yyyy-MM-ddTHH:mm:ssZ",
            "yyyy-MM-ddTHH:mm:ss.fZ",
            "yyyy-MM-ddTHH:mm:ss.ffZ",
            "yyyy-MM-ddTHH:mm:ss.fffZ",
            "yyyy-MM-ddTHH:mm:ss.ffffZ",
            "yyyy-MM-ddTHH:mm:ss.fffffZ",
            "yyyy-MM-ddTHH:mm:ss.ffffffZ",
            "yyyy-MM-ddTHH:mm:ss.fffffffZ",
            "yyyy-MM-ddTHH:mm:sszzzzzz",
            "yyyy-MM-ddTHH:mm:ss.fzzzzzz",
            "yyyy-MM-ddTHH:mm:ss.ffzzzzzz",
            "yyyy-MM-ddTHH:mm:ss.fffzzzzzz",
            "yyyy-MM-ddTHH:mm:ss.ffffzzzzzz",
            "yyyy-MM-ddTHH:mm:ss.fffffzzzzzz",
            "yyyy-MM-ddTHH:mm:ss.ffffffzzzzzz",
        };

        static string[] allDateFormats = new string[] {
            "yyyy-MM-ddzzzzzz",
            "yyyy-MM-dd",
            "yyyy-MM-ddZ",
            "yyyy",
            "---dd",
            "---ddZ",
            "---ddzzzzzz",
            "--MM-dd",
            "--MM-ddZ",
            "--MM-ddzzzzzz",
            "--MM--",
            "--MM--Z",
            "--MM--zzzzzz",
            "yyyy-MM",
            "yyyy-MMZ",
            "yyyy-MMzzzzzz",
            "yyyyzzzzzz",
        };

        static string[] allTimeFormats = new string[] {
            "HH:mm:ss.fffffffzzzzzz",
            "HH:mm:ss",
            "HH:mm:ss.f",
            "HH:mm:ss.ff",
            "HH:mm:ss.fff",
            "HH:mm:ss.ffff",
            "HH:mm:ss.fffff",
            "HH:mm:ss.ffffff",
            "HH:mm:ss.fffffff",
            "HH:mm:ssZ",
            "HH:mm:ss.fZ",
            "HH:mm:ss.ffZ",
            "HH:mm:ss.fffZ",
            "HH:mm:ss.ffffZ",
            "HH:mm:ss.fffffZ",
            "HH:mm:ss.ffffffZ",
            "HH:mm:ss.fffffffZ",
            "HH:mm:sszzzzzz",
            "HH:mm:ss.fzzzzzz",
            "HH:mm:ss.ffzzzzzz",
            "HH:mm:ss.fffzzzzzz",
            "HH:mm:ss.ffffzzzzzz",
            "HH:mm:ss.fffffzzzzzz",
            "HH:mm:ss.ffffffzzzzzz",
        };

        internal static DateTime ToDateTime(string value) {
            return ToDateTime(value, allDateTimeFormats);
        }

        internal static DateTime ToDateTime(string value, string[] formats) {
            return XmlConvert.ToDateTime(value, formats);
        }

        internal static DateTime ToDate(string value) {
            return ToDateTime(value, allDateFormats);
        }

        internal static DateTime ToTime(string value) {
            return DateTime.ParseExact(value, allTimeFormats, DateTimeFormatInfo.InvariantInfo, DateTimeStyles.AllowLeadingWhite|DateTimeStyles.AllowTrailingWhite|DateTimeStyles.NoCurrentDateDefault);
        }

        internal static char ToChar(string value) {
            return (char)XmlConvert.ToUInt16(value);
        }

        internal static string ToXmlName(string value) {
            return XmlConvert.DecodeName(value);
        }

        internal static string ToXmlNCName(string value) {
            return XmlConvert.DecodeName(value);
        }
        
        internal static string ToXmlNmToken(string value) {
            return XmlConvert.DecodeName(value);
        }
        
        internal static string ToXmlNmTokens(string value) {
            return XmlConvert.DecodeName(value);
        }
        
        internal static byte[] ToByteArrayBase64(string value) {
            if (value == null) return null;
            value = value.Trim();
            if (value.Length == 0)
                return new byte[0];           
            return Convert.FromBase64String(value);
        }
        internal static byte[] ToByteArrayHex(string value) {
            if (value == null) return null;
            value = value.Trim();
            return XmlConvert.FromBinHexString(value);
        }

        internal static long ToEnum(string val, Hashtable vals, string typeName, bool validate)     {
            long value = 0;
            string[] parts = val.Split(null);
            for (int i = 0; i < parts.Length; i++) {
                object id = vals[parts[i]];
                if (id != null)
                    value |= (long)id;
                else if (validate && parts[i].Length > 0)
                    throw new InvalidOperationException(Res.GetString(Res.XmlUnknownConstant, parts[i], typeName));
            }
            return value;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\serialization\xmlcodeexporter.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlCodeExporter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Serialization {
    
    using System;
    using System.Collections;
    using System.IO;
    using System.ComponentModel;
    using System.Xml.Schema;
    using System.CodeDom;
    using System.CodeDom.Compiler;
    using System.Reflection;
    using System.Globalization;
    using System.Diagnostics;

    /// <include file='doc\XmlCodeExporter.uex' path='docs/doc[@for="XmlCodeExporter"]/*' />
    ///<internalonly/>
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public class XmlCodeExporter {
        Hashtable exportedMappings = new Hashtable();
        Hashtable exportedClasses = new Hashtable(); // TypeMapping -> CodeTypeDeclaration
        CodeNamespace codeNamespace;
        bool rootExported;
        TypeScope scope;
        CodeAttributeDeclarationCollection includeMetadata = new CodeAttributeDeclarationCollection();

        /// <include file='doc\XmlCodeExporter.uex' path='docs/doc[@for="XmlCodeExporter.XmlCodeExporter"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public XmlCodeExporter(CodeNamespace codeNamespace) {
            if (codeNamespace != null)
                CodeGenerator.ValidateIdentifiers(codeNamespace);
            this.codeNamespace = codeNamespace;
        }

        /// <include file='doc\XmlCodeExporter.uex' path='docs/doc[@for="XmlCodeExporter.XmlCodeExporter1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public XmlCodeExporter(CodeNamespace codeNamespace, CodeCompileUnit codeCompileUnit) : this(codeNamespace) {
            if (codeCompileUnit != null) {
                codeCompileUnit.ReferencedAssemblies.Add("System.dll");
                codeCompileUnit.ReferencedAssemblies.Add("System.Xml.dll");
            }
        }

        /// <include file='doc\XmlCodeExporter.uex' path='docs/doc[@for="XmlCodeExporter.ExportTypeMapping"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void ExportTypeMapping(XmlTypeMapping xmlTypeMapping) {
            CheckScope(xmlTypeMapping.Scope);
            CheckNamespace();
            if (xmlTypeMapping.Accessor.Any) throw new InvalidOperationException(Res.GetString(Res.XmlIllegalWildcard));

            ExportElement(xmlTypeMapping.Accessor);
        }

        /// <include file='doc\XmlCodeExporter.uex' path='docs/doc[@for="XmlCodeExporter.ExportMembersMapping"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void ExportMembersMapping(XmlMembersMapping xmlMembersMapping) {
            CheckScope(xmlMembersMapping.Scope);
            CheckNamespace();

            for (int i = 0; i < xmlMembersMapping.Count; i++) {
                Accessor accessor = xmlMembersMapping[i].Accessor;
                if (!(accessor is XmlnsAccessor)) {
                    ExportType(accessor.Mapping, Accessor.UnescapeName(accessor.Name), accessor.Namespace, null);
                }
            }
        }

        void CheckScope(TypeScope scope) {
            if (this.scope == null) {
                this.scope = scope;
            }
            else if (this.scope != scope) {
                throw new InvalidOperationException(Res.GetString(Res.XmlMappingsScopeMismatch));
            }
        }

        void ExportElement(ElementAccessor element) {
            ExportType(element.Mapping, Accessor.UnescapeName(element.Name), element.Namespace, element);
        }

        void ExportType(TypeMapping mapping, string ns) {
            ExportType(mapping, null, ns, null);
        }

        void ExportType(TypeMapping mapping, string name, string ns, ElementAccessor rootElement) {
            if (mapping is StructMapping && ((StructMapping)mapping).ReferencedByTopLevelElement &&
                rootElement == null)
                return;

            if (mapping is ArrayMapping && rootElement != null && rootElement.IsTopLevelInSchema && ((ArrayMapping)mapping).TopLevelMapping != null) {
                mapping = ((ArrayMapping)mapping).TopLevelMapping;
            }

            CodeTypeDeclaration codeClass = null;
            if (exportedMappings[mapping] == null) {
                exportedMappings.Add(mapping, mapping);
                if (mapping is EnumMapping) {
                    codeClass = ExportEnum((EnumMapping)mapping, name, ns);
                }
                else if (mapping is StructMapping) {
                    codeClass = ExportStruct((StructMapping)mapping, name, ns);
                }
                else if (mapping is ArrayMapping) {
                    EnsureTypesExported(((ArrayMapping)mapping).Elements, ns);
                }
                if (codeClass != null) {
                    CodeGenerator.ValidateIdentifiers(codeClass);
                    exportedClasses.Add(mapping, codeClass);
                }
            }
            else
                codeClass = (CodeTypeDeclaration)exportedClasses[mapping];
            
            if (codeClass != null && rootElement != null) 
                AddRootMetadata(codeClass.CustomAttributes, mapping, name, ns, rootElement);
        }

        void AddRootMetadata(CodeAttributeDeclarationCollection metadata, TypeMapping typeMapping, string name, string ns, ElementAccessor rootElement) {
            string rootAttrName = typeof(XmlRootAttribute).FullName;
            
            // check that we haven't already added a root attribute since we can only add one
            foreach (CodeAttributeDeclaration attr in metadata) {
                if (attr.Name == rootAttrName) return;
            }

            CodeAttributeDeclaration attribute = new CodeAttributeDeclaration(rootAttrName);
            if (typeMapping.TypeDesc.Name != name) {
                attribute.Arguments.Add(new CodeAttributeArgument(new CodePrimitiveExpression(name)));
            }
            if (ns != null) {
                attribute.Arguments.Add(new CodeAttributeArgument("Namespace", new CodePrimitiveExpression(ns)));
            }
            if (typeMapping.TypeDesc != null && typeMapping.TypeDesc.IsAmbiguousDataType) {
                attribute.Arguments.Add(new CodeAttributeArgument("DataType", new CodePrimitiveExpression(typeMapping.TypeDesc.DataType.Name)));
            }
            if ((object)(rootElement.IsNullable) != null) {
                attribute.Arguments.Add(new CodeAttributeArgument("IsNullable", new CodePrimitiveExpression((bool)rootElement.IsNullable)));
            }
            metadata.Add(attribute);
        }

        void AddIncludeMetadata(CodeAttributeDeclarationCollection metadata, StructMapping mapping) {
            for (StructMapping derived = mapping.DerivedMappings; derived != null; derived = derived.NextDerivedMapping) {
                CodeIdentifier.CheckValidTypeIdentifier(derived.TypeDesc.FullName);
                CodeAttributeArgument[] arguments  = new CodeAttributeArgument[] { new CodeAttributeArgument(new CodeTypeOfExpression(derived.TypeDesc.FullName)) };
                AddCustomAttribute(metadata, typeof(XmlIncludeAttribute), arguments);
                AddIncludeMetadata(metadata, derived);
            }
        }

        void AddTypeMetadata(CodeAttributeDeclarationCollection metadata, string defaultName, string name, string ns, bool includeInSchema) {
            CodeAttributeArgument[] arguments = new CodeAttributeArgument[(defaultName == name ? 0 : 1) + (ns == null || ns.Length == 0 ? 0 : 1) + (includeInSchema ? 0 : 1)];
            if (arguments.Length == 0) return;
            int i = 0;
            if (defaultName != name) {
                arguments[i] = new CodeAttributeArgument("TypeName", new CodePrimitiveExpression(name));
                i++;
            }
            if (ns != null && ns.Length != 0) {
                arguments[i] = new CodeAttributeArgument("Namespace", new CodePrimitiveExpression(ns));
                i++;
            }
            if (!includeInSchema) {
                arguments[i] = new CodeAttributeArgument("IncludeInSchema", new CodePrimitiveExpression(false));
                i++;
            }
            AddCustomAttribute(metadata, typeof(XmlTypeAttribute), arguments);
        }

        object PromoteType(Type type, object value) {
            if (type == typeof(sbyte)) {
                return ((IConvertible)value).ToInt16(null);
            }
            else if (type == typeof(UInt16)) {
                return ((IConvertible)value).ToInt32(null);
            }
            else if (type == typeof(UInt32)) {
                return ((IConvertible)value).ToInt64(null);
            }
            else if (type == typeof(UInt64)) {
                return ((IConvertible)value).ToDecimal(null);
            }
            else {
                return value;
            }
        }

        void AddDefaultValueAttribute(CodeMemberField field, CodeAttributeDeclarationCollection metadata, object value, TypeMapping mapping) {
            #if DEBUG
                // use exception in the place of Debug.Assert to avoid throwing asserts from a server process such as aspnet_ewp.exe
                if (!(mapping is PrimitiveMapping)) {
                    throw new InvalidOperationException(Res.GetString(Res.XmlInternalErrorDetails, "Default value is invalid for " + mapping.GetType().Name));
                }
                else if (mapping.IsList) {
                    throw new InvalidOperationException(Res.GetString(Res.XmlInternalErrorDetails, "Default value is invalid for " + mapping.GetType().Name));
                }
            #endif

            if (value == null) return;

            CodeExpression valueExpression = null;
            CodeExpression initExpression = null;
            CodeExpression typeofValue = null;
            string typeName = mapping.TypeDesc.FullName;
            Type type = value.GetType();

            CodeAttributeArgument[] arguments = null;

            if (mapping is EnumMapping) {
                #if DEBUG
                    // use exception in the place of Debug.Assert to avoid throwing asserts from a server process such as aspnet_ewp.exe
                    if (value.GetType() != typeof(string)) throw new InvalidOperationException(Res.GetString(Res.XmlInternalErrorDetails, "Invalid enumeration type " + value.GetType().Name));
                #endif

                if (((EnumMapping)mapping).IsFlags) {
                    string[] values = ((string)value).Split(null);
                    for (int i = 0; i < values.Length; i++) {
                        if (values[i].Length == 0) continue;
                        CodeExpression enumRef = new CodeFieldReferenceExpression(new CodeTypeReferenceExpression(typeName), values[i]);
                        if (valueExpression != null)
                            valueExpression = new CodeBinaryOperatorExpression(valueExpression, CodeBinaryOperatorType.BitwiseOr, enumRef);
                        else
                            valueExpression = enumRef;
                    }
                }
                else {
                    valueExpression = new CodeFieldReferenceExpression(new CodeTypeReferenceExpression(typeName), (string)value);
                }
                initExpression = valueExpression;
                arguments  = new CodeAttributeArgument[] {new CodeAttributeArgument(valueExpression)};
            }
            else if (type == typeof(bool) ||
                type == typeof(Int32)     ||
                type == typeof(string)    ||
                type == typeof(double)) {

                initExpression = valueExpression = new CodePrimitiveExpression(value);
                arguments  = new CodeAttributeArgument[] {new CodeAttributeArgument(valueExpression)};
            }
            else if (type == typeof(Int16) ||
                type == typeof(Int64)      ||
                type == typeof(float)      ||
                type == typeof(byte)       ||
                type == typeof(decimal)) {
                valueExpression = new CodePrimitiveExpression(Convert.ToString(value, NumberFormatInfo.InvariantInfo));
                typeofValue = new CodeTypeOfExpression(type.FullName);
                arguments  = new CodeAttributeArgument[] {new CodeAttributeArgument(typeofValue), new CodeAttributeArgument(valueExpression)};
                initExpression = new CodeCastExpression(type.FullName, new CodePrimitiveExpression(value));
            }
            else if (type == typeof(sbyte) ||
                type == typeof(UInt16)     ||
                type == typeof(UInt32)     ||
                type == typeof(UInt64)) {
                // need to promote the non-CLS complient types

                value = PromoteType(type, value);

                valueExpression = new CodePrimitiveExpression(value.ToString());
                typeofValue = new CodeTypeOfExpression(type.FullName);
                arguments  = new CodeAttributeArgument[] {new CodeAttributeArgument(typeofValue), new CodeAttributeArgument(valueExpression)};
                initExpression = new CodeCastExpression(type.FullName, new CodePrimitiveExpression(value));
            }
            else if (type == typeof(DateTime)) {
                DateTime dt = (DateTime)value;
                string dtString;
                long ticks;
                if (mapping.TypeDesc.FormatterName == "Date") {
                    dtString = XmlCustomFormatter.FromDate(dt);
                    ticks = (new DateTime(dt.Year, dt.Month, dt.Day)).Ticks;
                }
                else if (mapping.TypeDesc.FormatterName == "Time") {
                    dtString = XmlCustomFormatter.FromDateTime(dt);
                    ticks = dt.Ticks;
                }
                else {
                    dtString = XmlCustomFormatter.FromDateTime(dt);
                    ticks = dt.Ticks;
                }
                valueExpression = new CodePrimitiveExpression(dtString);
                typeofValue = new CodeTypeOfExpression(type.FullName);
                arguments  = new CodeAttributeArgument[] {new CodeAttributeArgument(typeofValue), new CodeAttributeArgument(valueExpression)};
                initExpression = new CodeObjectCreateExpression(new CodeTypeReference(typeof(DateTime)), new CodeExpression[] {new CodePrimitiveExpression(ticks)});
            }
            if (arguments != null) {
                if (field != null) field.InitExpression = initExpression;
                AddCustomAttribute(metadata, typeof(DefaultValueAttribute), arguments);
            }
        }

        CodeTypeDeclaration ExportEnum(EnumMapping mapping, string name, string ns) {
            CodeTypeDeclaration codeClass = new CodeTypeDeclaration(mapping.TypeDesc.Name);
            codeClass.IsEnum = true;
            codeClass.TypeAttributes |= TypeAttributes.Public;
            codeClass.Comments.Add(new CodeCommentStatement("<remarks/>", true));
            codeNamespace.Types.Add(codeClass);
            codeClass.CustomAttributes = new CodeAttributeDeclarationCollection();
            AddTypeMetadata(codeClass.CustomAttributes, mapping.TypeDesc.Name, mapping.TypeName, mapping.Namespace, mapping.IncludeInSchema);

            for (int i = 0; i < mapping.Constants.Length; i++) {
                ExportConstant(codeClass, mapping.Constants[i], mapping.IsFlags, 1L << i);
            }
            if (mapping.IsFlags) {
                AddCustomAttribute(codeClass.CustomAttributes, typeof(FlagsAttribute), new CodeAttributeArgument[0]);
            }
            return codeClass;
        }

        void ExportConstant(CodeTypeDeclaration codeClass, ConstantMapping constant, bool init, long enumValue) {
            CodeMemberField field = new CodeMemberField(typeof(int).FullName, constant.Name);
            field.Comments.Add(new CodeCommentStatement("<remarks/>", true));
            if (init)
                field.InitExpression = new CodePrimitiveExpression(enumValue);
            codeClass.Members.Add(field);
            field.CustomAttributes = new CodeAttributeDeclarationCollection();
            if (constant.XmlName != constant.Name) {
                CodeAttributeDeclaration attribute = new CodeAttributeDeclaration(typeof(XmlEnumAttribute).FullName);
                attribute.Arguments.Add(new CodeAttributeArgument(new CodePrimitiveExpression(constant.XmlName)));
                field.CustomAttributes.Add(attribute);
            }
        }

        void ExportRoot(StructMapping mapping) {
            if (!rootExported) {
                rootExported = true;
                ExportDerivedStructs(mapping);

                for (StructMapping derived = mapping.DerivedMappings; derived != null; derived = derived.NextDerivedMapping) {
                    if (!derived.ReferencedByElement) {
                        CodeIdentifier.CheckValidTypeIdentifier(derived.TypeDesc.FullName);
                        CodeAttributeArgument[] arguments  = new CodeAttributeArgument[] { new CodeAttributeArgument(new CodeTypeOfExpression(derived.TypeDesc.FullName)) };
                        AddCustomAttribute(includeMetadata, typeof(XmlIncludeAttribute), arguments);
                    }
                }
                Hashtable typesIncluded = new Hashtable();
                foreach (TypeMapping m in scope.TypeMappings) {
                    if (m is ArrayMapping) {
                        ArrayMapping arrayMapping = (ArrayMapping) m;
                        if (ShouldInclude(arrayMapping) && !typesIncluded.Contains(arrayMapping.TypeDesc.FullName)) {
                            CodeIdentifier.CheckValidTypeIdentifier(arrayMapping.TypeDesc.FullName);
                            CodeAttributeArgument[] arguments = new CodeAttributeArgument[] { new CodeAttributeArgument(new CodeTypeOfExpression(arrayMapping.TypeDesc.FullName)) };
                            AddCustomAttribute(includeMetadata, typeof(XmlIncludeAttribute), arguments);
                            typesIncluded.Add(arrayMapping.TypeDesc.FullName, "");
                        }
                    }
                }
            }
        }

        private static bool ShouldInclude(ArrayMapping arrayMapping) {
            if (arrayMapping.ReferencedByElement)
                return false;
            if (arrayMapping.Next != null)
                return false;
            if (arrayMapping.Elements.Length == 1) {
                TypeKind kind = arrayMapping.Elements[0].Mapping.TypeDesc.Kind;
                if (kind == TypeKind.Node)
                    return false;
            }
            return true;
        }

        CodeTypeDeclaration ExportStruct(StructMapping mapping, string name, string ns) {
            if (mapping.TypeDesc.IsRoot) {
                ExportRoot(mapping);
                return null;
            }

            string className = mapping.TypeDesc.Name;
            string baseName = mapping.TypeDesc.BaseTypeDesc == null || mapping.TypeDesc.BaseTypeDesc.IsRoot ? string.Empty : mapping.TypeDesc.BaseTypeDesc.FullName;

            CodeTypeDeclaration codeClass = new CodeTypeDeclaration(className);
            codeClass.CustomAttributes = new CodeAttributeDeclarationCollection();
            codeClass.Comments.Add(new CodeCommentStatement("<remarks/>", true));
            codeNamespace.Types.Add(codeClass);

            if (baseName != null && baseName.Length > 0) {
                codeClass.BaseTypes.Add(baseName);
            }

            codeClass.TypeAttributes |= TypeAttributes.Public;
            if (mapping.TypeDesc.IsAbstract)
                codeClass.TypeAttributes |= TypeAttributes.Abstract;

            AddTypeMetadata(codeClass.CustomAttributes, mapping.TypeDesc.Name, mapping.TypeName, mapping.Namespace, mapping.IncludeInSchema);
            AddIncludeMetadata(codeClass.CustomAttributes, mapping);

            for (int i = 0; i < mapping.Members.Length; i++) {
                ExportMember(codeClass, mapping.Members[i], mapping.Namespace);
            }

            for (int i = 0; i < mapping.Members.Length; i++) {
                EnsureTypesExported(mapping.Members[i].Elements, mapping.Namespace);
                EnsureTypesExported(mapping.Members[i].Attribute, mapping.Namespace);
                EnsureTypesExported(mapping.Members[i].Text, mapping.Namespace);
            }

            if (mapping.BaseMapping != null)
                ExportType(mapping.BaseMapping, mapping.Namespace);

            ExportDerivedStructs(mapping);

            return codeClass;
        }

        void ExportDerivedStructs(StructMapping mapping) {
            for (StructMapping derived = mapping.DerivedMappings; derived != null; derived = derived.NextDerivedMapping)
                ExportType(derived, mapping.Namespace);
        }

        /// <include file='doc\XmlCodeExporter.uex' path='docs/doc[@for="XmlCodeExporter.AddMappingMetadata"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void AddMappingMetadata(CodeAttributeDeclarationCollection metadata, XmlTypeMapping mapping, string ns) {
            // For struct or enum mappings, we generate the XmlRoot on the struct/class/enum.  For primitives 
            // or arrays, there is nowhere to generate the XmlRoot, so we generate it elsewhere (on the 
            // method for web services get/post). 
            if (mapping.Mapping is StructMapping || mapping.Mapping is EnumMapping) return;
            AddRootMetadata(metadata, mapping.Mapping, Accessor.UnescapeName(mapping.Accessor.Name), mapping.Accessor.Namespace, mapping.Accessor);
            // CONSIDER, add XmlType for arrays
        }

        /// <include file='doc\XmlCodeExporter.uex' path='docs/doc[@for="XmlCodeExporter.AddMappingMetadata1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void AddMappingMetadata(CodeAttributeDeclarationCollection metadata, XmlMemberMapping member, string ns, bool forceUseMemberName) {
            AddMemberMetadata(null, metadata, member.Mapping, ns, forceUseMemberName);
        }         
         
        /// <include file='doc\XmlCodeExporter.uex' path='docs/doc[@for="XmlCodeExporter.AddMappingMetadata2"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void AddMappingMetadata(CodeAttributeDeclarationCollection metadata, XmlMemberMapping member, string ns) {
            AddMemberMetadata(null, metadata, member.Mapping, ns, false);
        }

        void ExportArrayElements(CodeAttributeDeclarationCollection metadata, ArrayMapping array, string ns, TypeDesc elementTypeDesc, int nestingLevel) {
            for (int i = 0; i < array.Elements.Length; i++) {
                ElementAccessor arrayElement = array.Elements[i];
                TypeMapping elementMapping = arrayElement.Mapping;
                string elementName = Accessor.UnescapeName(arrayElement.Name);
                bool sameName = elementName == arrayElement.Mapping.TypeName;
                bool sameElementType = elementMapping.TypeDesc == elementTypeDesc;
                bool sameElementNs = arrayElement.Namespace == ns;
                bool sameNullable = arrayElement.IsNullable == elementMapping.TypeDesc.IsNullable;
                bool defaultForm = arrayElement.Form != XmlSchemaForm.Unqualified;
                if (!sameName || !sameElementType || !sameElementNs || !sameNullable || !defaultForm || nestingLevel > 0)
                    ExportArrayItem(metadata, sameName ? null : elementName, sameElementNs ? null : arrayElement.Namespace, sameElementType ? null : elementMapping.TypeDesc, elementMapping.TypeDesc, arrayElement.IsNullable, defaultForm ? XmlSchemaForm.None : arrayElement.Form, nestingLevel);
                if (elementMapping is ArrayMapping)
                    ExportArrayElements(metadata, (ArrayMapping) elementMapping, ns, elementTypeDesc.ArrayElementTypeDesc, nestingLevel+1);
            }
        }

        void AddMemberMetadata(CodeMemberField field, CodeAttributeDeclarationCollection metadata, MemberMapping member, string ns, bool forceUseMemberName) {
            if (member.Xmlns != null) {
                CodeAttributeDeclaration attribute = new CodeAttributeDeclaration(typeof(XmlNamespaceDeclarationsAttribute).FullName);
                metadata.Add(attribute);
            }
            else if (member.Attribute != null) {
                AttributeAccessor attribute = member.Attribute;
                if (attribute.Any)
                    ExportAnyAttribute(metadata);
                else {
                    TypeMapping mapping = (TypeMapping)attribute.Mapping;
                    string attrName = Accessor.UnescapeName(attribute.Name);
                    bool sameType = mapping.TypeDesc == member.TypeDesc ||
                        (member.TypeDesc.IsArrayLike && mapping.TypeDesc == member.TypeDesc.ArrayElementTypeDesc);
                    bool sameName = attrName == member.Name && !forceUseMemberName;
                    bool sameNs = attribute.Namespace == ns;
                    bool defaultForm = attribute.Form != XmlSchemaForm.Qualified;
                    ExportAttribute(metadata, 
                        sameName ? null : attrName, 
                        sameNs ? null : attribute.Namespace, 
                        sameType ? null : mapping.TypeDesc,
                        mapping.TypeDesc, 
                        defaultForm ? XmlSchemaForm.None : attribute.Form);
                
                    if (attribute.HasDefault) {
                        AddDefaultValueAttribute(field, metadata, attribute.Default, mapping);
                    }
                }
            }
            else {
                if (member.Text != null) {
                    TypeMapping mapping = (TypeMapping)member.Text.Mapping;
                    bool sameType = mapping.TypeDesc == member.TypeDesc ||
                        (member.TypeDesc.IsArrayLike && mapping.TypeDesc == member.TypeDesc.ArrayElementTypeDesc);
                    ExportText(metadata, sameType ? null : mapping.TypeDesc, mapping.TypeDesc.IsAmbiguousDataType ? mapping.TypeDesc.DataType.Name : null);
                }
                if (member.Elements.Length == 1) {
                    ElementAccessor element = member.Elements[0];
                    TypeMapping mapping = (TypeMapping)element.Mapping;
                    string elemName = Accessor.UnescapeName(element.Name);
                    bool sameName = ((elemName == member.Name) && !forceUseMemberName);                    
                    bool isArray = mapping is ArrayMapping;
                    bool sameNs = element.Namespace == ns;
                    bool defaultForm = element.Form != XmlSchemaForm.Unqualified;

                    if (element.Any)
                        ExportAnyElement(metadata, elemName, sameNs ? null : element.Namespace);
                    else if (isArray) {
                        bool sameType = mapping.TypeDesc == member.TypeDesc;
                        ArrayMapping array = (ArrayMapping)mapping;
                        if (!sameName || !sameNs || element.IsNullable || !defaultForm)
                            ExportArray(metadata, sameName ? null : elemName, sameNs ? null : element.Namespace, element.IsNullable, defaultForm ? XmlSchemaForm.None : element.Form);
                        ExportArrayElements(metadata, array, ns, member.TypeDesc.ArrayElementTypeDesc, 0);
                    }
                    else {
                        bool sameType = mapping.TypeDesc == member.TypeDesc ||
                            (member.TypeDesc.IsArrayLike && mapping.TypeDesc == member.TypeDesc.ArrayElementTypeDesc);
                        if (member.TypeDesc.IsArrayLike)
                            sameName = false;
                        if (member.TypeDesc.IsAmbiguousDataType || member.TypeDesc.IsArrayLike || !sameName || !sameType || !sameNs || element.IsNullable || !defaultForm) {
                            ExportElement(metadata, sameName ? null : elemName, sameNs ? null : element.Namespace, sameType ? null : mapping.TypeDesc, mapping.TypeDesc, element.IsNullable, defaultForm ? XmlSchemaForm.None : element.Form);
                        }
                    }
                    if (element.HasDefault) {
                        AddDefaultValueAttribute(field, metadata, element.Default, mapping);
                    }
                }
                else {
                    for (int i = 0; i < member.Elements.Length; i++) {
                        ElementAccessor element = member.Elements[i];
                        string elemName = Accessor.UnescapeName(element.Name);
                        bool sameNs = element.Namespace == ns;
                        if (element.Any)
                            ExportAnyElement(metadata, elemName, sameNs ? null : element.Namespace);
                        else {
                            bool defaultForm = element.Form != XmlSchemaForm.Unqualified;
                            ExportElement(metadata, elemName, sameNs ? null : element.Namespace, ((TypeMapping)element.Mapping).TypeDesc, ((TypeMapping)element.Mapping).TypeDesc, element.IsNullable, defaultForm ? XmlSchemaForm.None : element.Form);
                        }
                    }
                }
                if (member.ChoiceIdentifier != null) {
                    CodeAttributeDeclaration attribute = new CodeAttributeDeclaration(typeof(XmlChoiceIdentifierAttribute).FullName);
                    attribute.Arguments.Add(new CodeAttributeArgument(new CodePrimitiveExpression(member.ChoiceIdentifier.MemberName)));
                    metadata.Add(attribute);
                }
                if (member.Ignore) {
                    CodeAttributeDeclaration attribute = new CodeAttributeDeclaration(typeof(XmlIgnoreAttribute).FullName);
                    metadata.Add(attribute);
                }
            }
        }

        void ExportMember(CodeTypeDeclaration codeClass, MemberMapping member, string ns) {
            CodeAttributeDeclarationCollection metadata = new CodeAttributeDeclarationCollection();
            CodeMemberField field = new CodeMemberField(member.TypeDesc.FullName, member.Name);
            field.Attributes = (field.Attributes & ~MemberAttributes.AccessMask) | MemberAttributes.Public;
            field.Comments.Add(new CodeCommentStatement("<remarks/>", true));
            codeClass.Members.Add(field);
            AddMemberMetadata(field, metadata, member, ns, false);
            field.CustomAttributes = metadata;

            if (member.CheckSpecified) {
                field = new CodeMemberField(typeof(bool).FullName, member.Name + "Specified");
                field.Attributes = (field.Attributes & ~MemberAttributes.AccessMask) | MemberAttributes.Public;
                field.CustomAttributes = new CodeAttributeDeclarationCollection();
                field.Comments.Add(new CodeCommentStatement("<remarks/>", true));
                CodeAttributeDeclaration attribute = new CodeAttributeDeclaration(typeof(XmlIgnoreAttribute).FullName);
                field.CustomAttributes.Add(attribute);
                codeClass.Members.Add(field);
            }
        }

        void ExportText(CodeAttributeDeclarationCollection metadata, TypeDesc typeDesc, string dataType) {
            CodeAttributeDeclaration attribute = new CodeAttributeDeclaration(typeof(XmlTextAttribute).FullName);
            if (typeDesc != null) {
                CodeIdentifier.CheckValidTypeIdentifier(typeDesc.FullName);
                attribute.Arguments.Add(new CodeAttributeArgument(new CodeTypeOfExpression(typeDesc.FullName)));
            }
            if (dataType != null) {
                attribute.Arguments.Add(new CodeAttributeArgument("DataType", new CodePrimitiveExpression(dataType)));
            }
            metadata.Add(attribute);
        }
        
        void ExportAttribute(CodeAttributeDeclarationCollection metadata, string name, string ns, TypeDesc typeDesc, TypeDesc dataTypeDesc, XmlSchemaForm form) {
            ExportMetadata(metadata, typeof(XmlAttributeAttribute), name, ns, typeDesc, dataTypeDesc, null, form, 0);
        }
        
        void ExportArrayItem(CodeAttributeDeclarationCollection metadata, string name, string ns, TypeDesc typeDesc, TypeDesc dataTypeDesc, bool isNullable, XmlSchemaForm form, int nestingLevel) {
            ExportMetadata(metadata, typeof(XmlArrayItemAttribute), name, ns, typeDesc, dataTypeDesc, isNullable ? null : (object)false, form, nestingLevel);
        }
        
        void ExportElement(CodeAttributeDeclarationCollection metadata, string name, string ns, TypeDesc typeDesc, TypeDesc dataTypeDesc, bool isNullable, XmlSchemaForm form) {
            ExportMetadata(metadata, typeof(XmlElementAttribute), name, ns, typeDesc, dataTypeDesc, isNullable ? (object)true : null, form, 0);
        }

        void ExportArray(CodeAttributeDeclarationCollection metadata, string name, string ns, bool isNullable, XmlSchemaForm form) {
            ExportMetadata(metadata, typeof(XmlArrayAttribute), name, ns, null, null, isNullable ? (object)true : null, form, 0);
        }
        
        void ExportMetadata(CodeAttributeDeclarationCollection metadata, Type attributeType, string name, string ns, TypeDesc typeDesc, TypeDesc dataTypeDesc, object isNullable, XmlSchemaForm form, int nestingLevel) {
            CodeAttributeDeclaration attribute = new CodeAttributeDeclaration(attributeType.FullName);
            if (name != null) {
                attribute.Arguments.Add(new CodeAttributeArgument(new CodePrimitiveExpression(name)));
            }
            if (typeDesc != null) {
                CodeIdentifier.CheckValidTypeIdentifier(typeDesc.FullName);
                attribute.Arguments.Add(new CodeAttributeArgument(new CodeTypeOfExpression(typeDesc.FullName)));
            }
            if (form != XmlSchemaForm.None) {
                attribute.Arguments.Add(new CodeAttributeArgument("Form", new CodeFieldReferenceExpression(new CodeTypeReferenceExpression(typeof(XmlSchemaForm).FullName), Enum.Format(typeof(XmlSchemaForm), form, "G"))));
            }
            if (ns != null) {
                attribute.Arguments.Add(new CodeAttributeArgument("Namespace", new CodePrimitiveExpression(ns)));
            }
            if (dataTypeDesc != null && dataTypeDesc.IsAmbiguousDataType) {
                attribute.Arguments.Add(new CodeAttributeArgument("DataType", new CodePrimitiveExpression(dataTypeDesc.DataType.Name)));
            }
            if (isNullable != null) {
                attribute.Arguments.Add(new CodeAttributeArgument("IsNullable", new CodePrimitiveExpression((bool)isNullable)));
            }
            if (nestingLevel > 0) {
                attribute.Arguments.Add(new CodeAttributeArgument("NestingLevel", new CodePrimitiveExpression(nestingLevel)));
            }

            if (attribute.Arguments.Count == 0 && attributeType == typeof(XmlElementAttribute)) return;
            metadata.Add(attribute);
        }

        void ExportAnyElement(CodeAttributeDeclarationCollection metadata, string name, string ns) {
            CodeAttributeDeclaration attribute = new CodeAttributeDeclaration(typeof(XmlAnyElementAttribute).FullName);
            if (name != null && name.Length > 0) {
                attribute.Arguments.Add(new CodeAttributeArgument("Name", new CodePrimitiveExpression(name)));
            }
            if (ns != null && ns.Length > 0) {
                attribute.Arguments.Add(new CodeAttributeArgument("Namespace", new CodePrimitiveExpression(ns)));
            }
            metadata.Add(attribute);
        }

        void ExportAnyAttribute(CodeAttributeDeclarationCollection metadata) {
            metadata.Add(new CodeAttributeDeclaration(typeof(XmlAnyAttributeAttribute).FullName));
        }

        void EnsureTypesExported(Accessor[] accessors, string ns) {
            if (accessors == null) return;
            for (int i = 0; i < accessors.Length; i++)
                EnsureTypesExported(accessors[i], ns);
        }

        void EnsureTypesExported(Accessor accessor, string ns) {
            if (accessor == null) return;
            ExportType(accessor.Mapping, ns);
        }

        void AddCustomAttribute(CodeAttributeDeclarationCollection metadata, Type type, CodeAttributeArgument[] arguments) {
            CodeAttributeDeclaration attribute = new CodeAttributeDeclaration(type.FullName, arguments);
            metadata.Add(attribute);
        }

        /// <include file='doc\XmlCodeExporter.uex' path='docs/doc[@for="XmlCodeExporter.IncludeMetadata"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public CodeAttributeDeclarationCollection IncludeMetadata {
            get { return includeMetadata; }
        }

        void CheckNamespace() {
            if (codeNamespace == null) codeNamespace = new CodeNamespace();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\serialization\xmlelementattribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlElementAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Serialization {
    using System;
    using System.Xml.Schema;

    /// <include file='doc\XmlElementAttribute.uex' path='docs/doc[@for="XmlElementAttribute"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [AttributeUsage(AttributeTargets.Field | AttributeTargets.Property | AttributeTargets.Parameter | AttributeTargets.ReturnValue, AllowMultiple=true)]
    public class XmlElementAttribute : System.Attribute {
        string elementName;
        Type type;
        string ns;
        string dataType;
        bool nullable;
        XmlSchemaForm form = XmlSchemaForm.None;
        
        /// <include file='doc\XmlElementAttribute.uex' path='docs/doc[@for="XmlElementAttribute.XmlElementAttribute"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public XmlElementAttribute() {
        }
        
        /// <include file='doc\XmlElementAttribute.uex' path='docs/doc[@for="XmlElementAttribute.XmlElementAttribute1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public XmlElementAttribute(string elementName) {
            this.elementName = elementName;
        }

        /// <include file='doc\XmlElementAttribute.uex' path='docs/doc[@for="XmlElementAttribute.XmlElementAttribute2"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public XmlElementAttribute(Type type) {
            this.type = type;
        }
        
        /// <include file='doc\XmlElementAttribute.uex' path='docs/doc[@for="XmlElementAttribute.XmlElementAttribute3"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public XmlElementAttribute(string elementName, Type type) {
            this.elementName = elementName;
            this.type = type;
        }

        /// <include file='doc\XmlElementAttribute.uex' path='docs/doc[@for="XmlElementAttribute.Type"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public Type Type {
            get { return type; }
            set { type = value; }
        }

        /// <include file='doc\XmlElementAttribute.uex' path='docs/doc[@for="XmlElementAttribute.ElementName"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public string ElementName {
            get { return elementName == null ? string.Empty : elementName; }
            set { elementName = value; }
        }
        
        /// <include file='doc\XmlElementAttribute.uex' path='docs/doc[@for="XmlElementAttribute.Namespace"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public string Namespace {
            get { return ns; }
            set { ns = value; }
        }

        /// <include file='doc\XmlElementAttribute.uex' path='docs/doc[@for="XmlElementAttribute.DataType"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public string DataType {
            get { return dataType == null ? string.Empty : dataType; }
            set { dataType = value; }
        }

        /// <include file='doc\XmlElementAttribute.uex' path='docs/doc[@for="XmlElementAttribute.IsNullable"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public bool IsNullable {
            get { return nullable; }
            set { nullable = value; }
        }

        /// <include file='doc\XmlElementAttribute.uex' path='docs/doc[@for="XmlElementAttribute.Form"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public XmlSchemaForm Form {
            get { return form; }
            set { form = value; }
        }
    }
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\serialization\xmlattributeoverrides.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlAttributeOverrides.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Serialization {
    using System.Reflection;
    using System.Collections;
    using System.IO;
    using System.Xml.Schema;
    using System;
    using System.ComponentModel;

    /// <include file='doc\XmlAttributeOverrides.uex' path='docs/doc[@for="XmlAttributeOverrides"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public class XmlAttributeOverrides {
        Hashtable types = new Hashtable();

        /// <include file='doc\XmlAttributeOverrides.uex' path='docs/doc[@for="XmlAttributeOverrides.Add"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void Add(Type type, XmlAttributes attributes) {
            Add(type, string.Empty, attributes);
        }

        /// <include file='doc\XmlAttributeOverrides.uex' path='docs/doc[@for="XmlAttributeOverrides.Add1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void Add(Type type, string member, XmlAttributes attributes) {
            Hashtable members = (Hashtable)types[type];
            if (members == null) {
                members = new Hashtable();
                types.Add(type, members);
            }
            else if (members[member] != null) {
                throw new InvalidOperationException(Res.GetString(Res.XmlAttributeSetAgain, type.FullName, member));
            }
            members.Add(member, attributes);
        }

        /// <include file='doc\XmlAttributeOverrides.uex' path='docs/doc[@for="XmlAttributeOverrides.this"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public XmlAttributes this[Type type] {
            get {
                return this[type, string.Empty];
            }
        }

        /// <include file='doc\XmlAttributeOverrides.uex' path='docs/doc[@for="XmlAttributeOverrides.this1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public XmlAttributes this[Type type, string member] {
            get {
                Hashtable members = (Hashtable)types[type];
                if (members == null) return null;
                return (XmlAttributes)members[member];
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\serialization\xmlchoiceidentifierattribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlChoiceIdentifierAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Serialization {
    using System;
    using System.Xml.Schema;

    /// <include file='doc\XmlChoiceIdentifierAttribute.uex' path='docs/doc[@for="XmlChoiceIdentifierAttribute"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [AttributeUsage(AttributeTargets.Field | AttributeTargets.Property | AttributeTargets.Parameter | AttributeTargets.ReturnValue, AllowMultiple=false)]
    public class XmlChoiceIdentifierAttribute : System.Attribute {
        string name;

        /// <include file='doc\XmlChoiceIdentifierAttribute.uex' path='docs/doc[@for="XmlChoiceIdentifierAttribute.XmlChoiceIdentifierAttribute"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public XmlChoiceIdentifierAttribute() {
        }
        
        /// <include file='doc\XmlChoiceIdentifierAttribute.uex' path='docs/doc[@for="XmlChoiceIdentifierAttribute.XmlChoiceIdentifierAttribute1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public XmlChoiceIdentifierAttribute(string name) {
            this.name = name;
        }

        /// <include file='doc\XmlChoiceIdentifierAttribute.uex' path='docs/doc[@for="XmlChoiceIdentifierAttribute.Name"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public string MemberName {
            get { return name == null ? string.Empty : name; }
            set { name = value; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\serialization\xmlelementattributes.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlElementAttributes.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Serialization {
    using System;
    using System.Reflection;
    using System.Collections;
    using System.ComponentModel;

    /// <include file='doc\XmlElementAttributes.uex' path='docs/doc[@for="XmlElementAttributes"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public class XmlElementAttributes : CollectionBase {
        
        /// <include file='doc\XmlElementAttributes.uex' path='docs/doc[@for="XmlElementAttributes.this"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public XmlElementAttribute this[int index] {
            get { return (XmlElementAttribute)List[index]; }
            set { List[index] = value; }
        }
        
        /// <include file='doc\XmlElementAttributes.uex' path='docs/doc[@for="XmlElementAttributes.Add"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public int Add(XmlElementAttribute attribute) {
            return List.Add(attribute);
        }
        
        /// <include file='doc\XmlElementAttributes.uex' path='docs/doc[@for="XmlElementAttributes.Insert"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void Insert(int index, XmlElementAttribute attribute) {
            List.Insert(index, attribute);
        }
        
        /// <include file='doc\XmlElementAttributes.uex' path='docs/doc[@for="XmlElementAttributes.IndexOf"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public int IndexOf(XmlElementAttribute attribute) {
            return List.IndexOf(attribute);
        }
        
        /// <include file='doc\XmlElementAttributes.uex' path='docs/doc[@for="XmlElementAttributes.Contains"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public bool Contains(XmlElementAttribute attribute) {
            return List.Contains(attribute);
        }
        
        /// <include file='doc\XmlElementAttributes.uex' path='docs/doc[@for="XmlElementAttributes.Remove"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void Remove(XmlElementAttribute attribute) {
            List.Remove(attribute);
        }
        
        /// <include file='doc\XmlElementAttributes.uex' path='docs/doc[@for="XmlElementAttributes.CopyTo"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void CopyTo(XmlElementAttribute[] array, int index) {
            List.CopyTo(array, index);
        }
        
    }



}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\serialization\xmlattributes.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlAttributes.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Serialization {
    using System;
    using System.Reflection;
    using System.Collections;
    using System.ComponentModel;

    internal enum XmlAttributeFlags {
        Enum = 0x1,
        Array = 0x2,
        Text = 0x4,
        ArrayItems = 0x8,
        Elements = 0x10,
        Attribute = 0x20,
        Root = 0x40,
        Type = 0x80,
        AnyElements = 0x100,
        AnyAttribute = 0x200,
        ChoiceIdentifier = 0x400,
        XmlnsDeclarations = 0x800,
    }

    /// <include file='doc\XmlAttributes.uex' path='docs/doc[@for="XmlAttributes"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public class XmlAttributes {
        XmlElementAttributes xmlElements = new XmlElementAttributes();
        XmlArrayItemAttributes xmlArrayItems = new XmlArrayItemAttributes();
        XmlAnyElementAttributes xmlAnyElements = new XmlAnyElementAttributes();
        XmlArrayAttribute xmlArray;
        XmlAttributeAttribute xmlAttribute;
        XmlTextAttribute xmlText;
        XmlEnumAttribute xmlEnum;
        bool xmlIgnore;
        bool xmlns;
        object xmlDefaultValue = DBNull.Value;
        XmlRootAttribute xmlRoot;
        XmlTypeAttribute xmlType;
        XmlAnyAttributeAttribute xmlAnyAttribute;
        XmlChoiceIdentifierAttribute xmlChoiceIdentifier;
        
        
        /// <include file='doc\XmlAttributes.uex' path='docs/doc[@for="XmlAttributes.XmlAttributes"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public XmlAttributes() {
        }

        internal XmlAttributeFlags XmlFlags {
            get { 
                XmlAttributeFlags flags = 0;
                if (xmlElements.Count > 0) flags |= XmlAttributeFlags.Elements;
                if (xmlArrayItems.Count > 0) flags |= XmlAttributeFlags.ArrayItems;
                if (xmlAnyElements.Count > 0) flags |= XmlAttributeFlags.AnyElements;
                if (xmlArray != null) flags |= XmlAttributeFlags.Array;
                if (xmlAttribute != null) flags |= XmlAttributeFlags.Attribute;
                if (xmlText != null) flags |= XmlAttributeFlags.Text;
                if (xmlEnum != null) flags |= XmlAttributeFlags.Enum;
                if (xmlRoot != null) flags |= XmlAttributeFlags.Root;
                if (xmlType != null) flags |= XmlAttributeFlags.Type;
                if (xmlAnyAttribute != null) flags |= XmlAttributeFlags.AnyAttribute;
                if (xmlChoiceIdentifier != null) flags |= XmlAttributeFlags.ChoiceIdentifier;
                if (xmlns) flags |= XmlAttributeFlags.XmlnsDeclarations;
                return flags;
            }
        }

        /// <include file='doc\XmlAttributes.uex' path='docs/doc[@for="XmlAttributes.XmlAttributes1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public XmlAttributes(ICustomAttributeProvider provider) {
            xmlIgnore = GetAttr(provider, typeof(XmlIgnoreAttribute)) != null;
            if (!xmlIgnore) {

                object[] attrs = provider.GetCustomAttributes(typeof(XmlElementAttribute), false);
                for (int i = 0; i < attrs.Length; i++)
                    this.xmlElements.Add((XmlElementAttribute)attrs[i]);

                attrs = provider.GetCustomAttributes(typeof(XmlArrayItemAttribute), false);
                for (int i = 0; i < attrs.Length; i++)
                    this.xmlArrayItems.Add((XmlArrayItemAttribute)attrs[i]);

                attrs = provider.GetCustomAttributes(typeof(XmlAnyElementAttribute), false);
                for (int i = 0; i < attrs.Length; i++)
                    this.xmlAnyElements.Add((XmlAnyElementAttribute)attrs[i]);

                DefaultValueAttribute defaultValueAttribute = (DefaultValueAttribute)GetAttr(provider, typeof(DefaultValueAttribute));
                if (defaultValueAttribute != null) xmlDefaultValue = defaultValueAttribute.Value;

                xmlAttribute = (XmlAttributeAttribute)GetAttr(provider, typeof(XmlAttributeAttribute));
                xmlArray = (XmlArrayAttribute)GetAttr(provider, typeof(XmlArrayAttribute));
                xmlText = (XmlTextAttribute)GetAttr(provider, typeof(XmlTextAttribute));
                xmlEnum = (XmlEnumAttribute)GetAttr(provider, typeof(XmlEnumAttribute));
                xmlRoot = (XmlRootAttribute)GetAttr(provider, typeof(XmlRootAttribute));
                xmlType = (XmlTypeAttribute)GetAttr(provider, typeof(XmlTypeAttribute));
                xmlAnyAttribute = (XmlAnyAttributeAttribute)GetAttr(provider, typeof(XmlAnyAttributeAttribute));
                xmlChoiceIdentifier = (XmlChoiceIdentifierAttribute)GetAttr(provider, typeof(XmlChoiceIdentifierAttribute));
                xmlns = GetAttr(provider, typeof(XmlNamespaceDeclarationsAttribute)) != null;
            }
        }

        object GetAttr(ICustomAttributeProvider provider, Type attrType) {
            object[] attrs = provider.GetCustomAttributes(attrType, false);
            if (attrs.Length == 0) return null;
            return attrs[0];
        }
        
        /// <include file='doc\XmlAttributes.uex' path='docs/doc[@for="XmlAttributes.XmlElements"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public XmlElementAttributes XmlElements {
            get { return xmlElements; }
        }
        
        /// <include file='doc\XmlAttributes.uex' path='docs/doc[@for="XmlAttributes.XmlAttribute"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public XmlAttributeAttribute XmlAttribute {
            get { return xmlAttribute; }
            set { xmlAttribute = value; }
        }
        
        /// <include file='doc\XmlAttributes.uex' path='docs/doc[@for="XmlAttributes.XmlEnum"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public XmlEnumAttribute XmlEnum {
            get { return xmlEnum; }
            set { xmlEnum = value; }
        }
        
        /// <include file='doc\XmlAttributes.uex' path='docs/doc[@for="XmlAttributes.XmlText"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public XmlTextAttribute XmlText {
            get { return xmlText; }
            set { xmlText = value; }
        }
        
        /// <include file='doc\XmlAttributes.uex' path='docs/doc[@for="XmlAttributes.XmlArray"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public XmlArrayAttribute XmlArray {
            get { return xmlArray; }
            set { xmlArray = value; }
        }
        
        /// <include file='doc\XmlAttributes.uex' path='docs/doc[@for="XmlAttributes.XmlArrayItems"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public XmlArrayItemAttributes XmlArrayItems {
            get { return xmlArrayItems; }
        }

        /// <include file='doc\XmlAttributes.uex' path='docs/doc[@for="XmlAttributes.XmlDefaultValue"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public object XmlDefaultValue {
            get { return xmlDefaultValue; }
            set { xmlDefaultValue = value; }
        }

        /// <include file='doc\XmlAttributes.uex' path='docs/doc[@for="XmlAttributes.XmlIgnore"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public bool XmlIgnore {
            get { return xmlIgnore; }
            set { xmlIgnore = value; }
        }

        /// <include file='doc\XmlAttributes.uex' path='docs/doc[@for="XmlAttributes.XmlType"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public XmlTypeAttribute XmlType {
            get { return xmlType; }
            set { xmlType = value; }
        }
        
        /// <include file='doc\XmlAttributes.uex' path='docs/doc[@for="XmlAttributes.XmlRoot"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public XmlRootAttribute XmlRoot {
            get { return xmlRoot; }
            set { xmlRoot = value; }
        }

        /// <include file='doc\XmlAttributes.uex' path='docs/doc[@for="XmlAttributes.XmlAnyElement"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public XmlAnyElementAttributes XmlAnyElements {
            get { return xmlAnyElements; }
        }

        /// <include file='doc\XmlAttributes.uex' path='docs/doc[@for="XmlAttributes.XmlAnyAttribute"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public XmlAnyAttributeAttribute XmlAnyAttribute {
            get { return xmlAnyAttribute; }
            set { xmlAnyAttribute = value; }
        }

        /// <include file='doc\XmlAttributes.uex' path='docs/doc[@for="XmlAttributes.XmlChoiceIdentifier"]/*' />
        public XmlChoiceIdentifierAttribute XmlChoiceIdentifier {
            get { return xmlChoiceIdentifier; }
        }

        /// <include file='doc\XmlAttributes.uex' path='docs/doc[@for="XmlAttributes.Xmlns"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public bool Xmlns {
            get { return xmlns; }
            set { xmlns = value; }
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\serialization\xmlenumattribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlEnumAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Serialization {

    using System;
    
    /// <include file='doc\XmlEnumAttribute.uex' path='docs/doc[@for="XmlEnumAttribute"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [AttributeUsage(AttributeTargets.Field)]
    public class XmlEnumAttribute : System.Attribute {
        string name; 

        /// <include file='doc\XmlEnumAttribute.uex' path='docs/doc[@for="XmlEnumAttribute.XmlEnumAttribute"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public XmlEnumAttribute() {
        }

        /// <include file='doc\XmlEnumAttribute.uex' path='docs/doc[@for="XmlEnumAttribute.XmlEnumAttribute1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public XmlEnumAttribute(string name) {
            this.name = name;
        }

        /// <include file='doc\XmlEnumAttribute.uex' path='docs/doc[@for="XmlEnumAttribute.Name"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public string Name {
            get { return name; }
            set { name = value; }
        }
    }
 }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\serialization\xmlincludeattribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlIncludeAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Serialization {

    using System;

    /// <include file='doc\XmlIncludeAttribute.uex' path='docs/doc[@for="XmlIncludeAttribute"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct | AttributeTargets.Method, AllowMultiple=true)]
    public class XmlIncludeAttribute : System.Attribute {
        Type type;

        /// <include file='doc\XmlIncludeAttribute.uex' path='docs/doc[@for="XmlIncludeAttribute.XmlIncludeAttribute"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public XmlIncludeAttribute(Type type) {
            this.type = type;
        }

        /// <include file='doc\XmlIncludeAttribute.uex' path='docs/doc[@for="XmlIncludeAttribute.Type"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public Type Type {
            get { return type; }
            set { type = value; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\serialization\xmlmapping.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlMapping.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Serialization {

    using System;

    /// <include file='doc\XmlMapping.uex' path='docs/doc[@for="XmlMapping"]/*' />
    ///<internalonly/>
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public abstract class XmlMapping {
        TypeScope scope;
        bool generateSerializer = false;
        bool isSoap;

        internal XmlMapping(TypeScope scope) {
            this.scope = scope;
        }

        internal TypeScope Scope {
            get { return scope; }
        }

        internal bool GenerateSerializer {
            get { return generateSerializer; }
            set { generateSerializer = value; }
        }

        internal bool IsSoap {
            get { return isSoap; }
            set { isSoap = value; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\serialization\types.cs ===
//------------------------------------------------------------------------------
// <copyright file="Types.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Serialization {

    using System;
    using System.Reflection;
    using System.Collections;
    using System.Xml.Schema;
    using System.Xml;
    using System.IO;
    using System.ComponentModel;

    // These classes provide a higher level view on reflection specific to 
    // Xml serialization, for example:
    // - allowing one to talk about types w/o having them compiled yet
    // - abstracting collections & arrays
    // - abstracting classes, structs, interfaces
    // - knowing about XSD primitives
    // - dealing with Serializable and xmlelement
    // and lots of other little details

    internal enum TypeKind {
        Root,
        Primitive,
        Enum,
        Struct,
        Class,
        Interface,
        Array,
        Collection,
        Enumerable,
        Void,
        Node,
        Attribute,
        Serializable
    }

    internal enum TypeFlags {
        Abstract = 0x1,
        Reference = 0x2,
        Special = 0x4,
        CanBeAttributeValue = 0x8,
        CanBeTextValue = 0x10,
        CanBeElementValue = 0x20,
        HasCustomFormatter = 0x40,
        AmbiguousDataType = 0x80,
        IgnoreDefault = 0x200,
        HasIsEmpty = 0x400,
        HasDefaultConstructor = 0x800,
        XmlEncodingNotRequired = 0x1000,
        CtorHasSecurity = 0x2000,
    }

    internal class TypeDesc {
        string name;
        string fullName;
        TypeDesc arrayElementTypeDesc;
        TypeDesc arrayTypeDesc;
        TypeKind kind;
        XmlSchemaSimpleType dataType;
        Type type;
        TypeDesc baseTypeDesc;
        TypeFlags flags;
        string formatterName;
        bool isXsdType;
        bool isMixed;
        
        internal TypeDesc(string name, string fullName, TypeKind kind, TypeDesc baseTypeDesc, TypeFlags flags) {
            this.name = name.Replace('+', '.');
            this.fullName = fullName.Replace('+', '.');
            this.kind = kind;
            if (baseTypeDesc != null) {
                this.baseTypeDesc = baseTypeDesc;
            }
            this.flags = flags;
            this.isXsdType = kind == TypeKind.Primitive;
        }
        
        internal TypeDesc(Type type, bool isXsdType, XmlSchemaSimpleType dataType, string formatterName, TypeFlags flags) : this(type.Name, type.FullName, TypeKind.Primitive, (TypeDesc)null, flags) {
            this.dataType = dataType;
            this.formatterName = formatterName;
            this.isXsdType = isXsdType;
            this.type = type;
        }
        
        internal TypeDesc(string name, string fullName, TypeKind kind, TypeDesc baseTypeDesc, TypeFlags flags, TypeDesc arrayElementTypeDesc) : this(name, fullName, kind, baseTypeDesc, flags) {
            this.arrayElementTypeDesc = arrayElementTypeDesc;
        }

        public override string ToString() {
            return fullName;
        }
        
        internal bool IsXsdType {
            get { return isXsdType; }
        }

        internal string Name { 
            get { return name; }
        }
        
        internal string FullName {
            get { return fullName; }
        }
        
        internal XmlSchemaSimpleType DataType {
            get { return dataType; }
        }

        internal Type Type {
            get { return type; }
        }

        internal string FormatterName {    
            get { return formatterName; }
        }
        
        internal TypeKind Kind {
            get { return kind; }
        }

        internal bool IsValueType {
            get { return (flags & TypeFlags.Reference) == 0; }
        }

        internal bool CanBeAttributeValue {
            get { return (flags & TypeFlags.CanBeAttributeValue) != 0; }
        }

        internal bool XmlEncodingNotRequired {
            get { return (flags & TypeFlags.XmlEncodingNotRequired) != 0; }
        }
        
        internal bool CanBeElementValue {
            get { return (flags & TypeFlags.CanBeElementValue) != 0; }
        }

        internal bool CanBeTextValue {
            get { return (flags & TypeFlags.CanBeTextValue) != 0; }
        }

        internal bool IsMixed {
            get { return isMixed || CanBeTextValue; }
            set { isMixed = value; }
        }

        internal bool IsSpecial {
            get { return (flags & TypeFlags.Special) != 0; }
        }

        internal bool IsAmbiguousDataType {
            get { return (flags & TypeFlags.AmbiguousDataType) != 0; }
        }

        internal bool HasCustomFormatter {
            get { return (flags & TypeFlags.HasCustomFormatter) != 0; }
        }

        internal bool HasDefaultSupport {
            get { return (flags & TypeFlags.IgnoreDefault) == 0; }
        }

        internal bool HasIsEmpty {
            get { return (flags & TypeFlags.HasIsEmpty) != 0; }
        }

        internal bool HasDefaultConstructor {
            get { return (flags & TypeFlags.HasDefaultConstructor) != 0; }
        }

        internal bool ConstructorHasSecurity {
            get { return (flags & TypeFlags.CtorHasSecurity) != 0; }
        }

        internal bool IsAbstract {
            get { return (flags & TypeFlags.Abstract) != 0; }
        }

        internal bool IsVoid {
            get { return kind == TypeKind.Void; }
        }
        
        internal bool IsStruct {
            get { return kind == TypeKind.Struct; }
        }
        
        internal bool IsClass {
            get { return kind == TypeKind.Class; }
        }

        internal bool IsStructLike {
            get { return kind == TypeKind.Struct || kind == TypeKind.Class; }
        }
        
        internal bool IsArrayLike {
            get { return kind == TypeKind.Array || kind == TypeKind.Collection || kind == TypeKind.Enumerable; }
        }
        
        internal bool IsCollection {
            get { return kind == TypeKind.Collection; }
        }
        
        internal bool IsEnumerable {
            get { return kind == TypeKind.Enumerable; }
        }

        internal bool IsArray {
            get { return kind == TypeKind.Array; }
        }
        
        internal bool IsPrimitive {
            get { return kind == TypeKind.Primitive; }
        }
        
        internal bool IsEnum {
            get { return kind == TypeKind.Enum; }
        }

        internal bool IsNullable {
            get { return !IsValueType; }
        }

        internal bool IsRoot {
            get { return kind == TypeKind.Root; }
        }
        
        internal string ArrayLengthName {
            get { return kind == TypeKind.Array ? "Length" : "Count"; }
        }
        
        internal TypeDesc ArrayElementTypeDesc {
            get { return arrayElementTypeDesc; }
        }

        internal TypeDesc CreateArrayTypeDesc() {
            if (arrayTypeDesc == null)
                arrayTypeDesc = new TypeDesc(name + "[]", fullName + "[]", TypeKind.Array, null, TypeFlags.Reference, this);
            return arrayTypeDesc;
        }

        internal TypeDesc BaseTypeDesc {
            get { return baseTypeDesc; }
            set { baseTypeDesc = value; }
        }

        internal int GetDerivationLevels() {
            int count = 0;
            TypeDesc typeDesc = this;
            while (typeDesc != null) {
                count++;
                typeDesc = typeDesc.BaseTypeDesc;
            }
            return count;
        }

        internal bool IsDerivedFrom(TypeDesc baseTypeDesc) {
            TypeDesc typeDesc = this;
            while (typeDesc != null) {
                if (typeDesc == baseTypeDesc) return true;
                typeDesc = typeDesc.BaseTypeDesc;
            }
            return baseTypeDesc.IsRoot;
        }

        internal static TypeDesc FindCommonBaseTypeDesc(TypeDesc[] typeDescs) {
            if (typeDescs.Length == 0) return null;
            TypeDesc leastDerivedTypeDesc = null;
            int leastDerivedLevel = int.MaxValue;
            for (int i = 0; i < typeDescs.Length; i++) {
                int derivationLevel = typeDescs[i].GetDerivationLevels();
                if (derivationLevel < leastDerivedLevel) {
                    leastDerivedLevel = derivationLevel;
                    leastDerivedTypeDesc = typeDescs[i];
                }
            }
            while (leastDerivedTypeDesc != null) {
                int i;
                for (i = 0; i < typeDescs.Length; i++) {
                    if (!typeDescs[i].IsDerivedFrom(leastDerivedTypeDesc)) break;
                }
                if (i == typeDescs.Length) break;
                leastDerivedTypeDesc = leastDerivedTypeDesc.BaseTypeDesc;
            }
            return leastDerivedTypeDesc;
        }
    }
   
    internal class TypeScope {
        Hashtable typeDescs = new Hashtable();
        Hashtable arrayTypeDescs = new Hashtable();
        ArrayList typeMappings = new ArrayList();

        static Hashtable primitiveTypes = new Hashtable();
        static Hashtable primitiveDataTypes = new Hashtable();
        static Hashtable primitiveNames = new Hashtable();
        static string[] unsupportedTypes = new string[] {
            "anyURI",
            "duration",
            "ENTITY",
            "ENTITIES",
            "gDay",
            "gMonth",
            "gMonthDay",
            "gYear",
            "gYearMonth",
            "ID",
            "IDREF",
            "IDREFS",
            "integer",
            "language",
            "negativeInteger",
            "nonNegativeInteger",
            "nonPositiveInteger",
            "normalizedString",
            "NOTATION",
            "positiveInteger",
            "token"
        };

        static TypeScope() {
            AddPrimitive(typeof(string), "string", "String", TypeFlags.CanBeAttributeValue | TypeFlags.CanBeElementValue | TypeFlags.CanBeTextValue | TypeFlags.Reference);
            AddPrimitive(typeof(int), "int", "Int32", TypeFlags.CanBeAttributeValue | TypeFlags.CanBeElementValue | TypeFlags.XmlEncodingNotRequired);
            AddPrimitive(typeof(bool), "boolean", "Boolean", TypeFlags.CanBeAttributeValue | TypeFlags.CanBeElementValue | TypeFlags.XmlEncodingNotRequired);
            AddPrimitive(typeof(short), "short", "Int16", TypeFlags.CanBeAttributeValue | TypeFlags.CanBeElementValue | TypeFlags.XmlEncodingNotRequired);
            AddPrimitive(typeof(long), "long", "Int64", TypeFlags.CanBeAttributeValue | TypeFlags.CanBeElementValue | TypeFlags.XmlEncodingNotRequired);
            AddPrimitive(typeof(float), "float", "Single", TypeFlags.CanBeAttributeValue | TypeFlags.CanBeElementValue | TypeFlags.XmlEncodingNotRequired);
            AddPrimitive(typeof(double), "double", "Double", TypeFlags.CanBeAttributeValue | TypeFlags.CanBeElementValue | TypeFlags.XmlEncodingNotRequired);
            AddPrimitive(typeof(decimal), "decimal", "Decimal", TypeFlags.CanBeAttributeValue | TypeFlags.CanBeElementValue | TypeFlags.XmlEncodingNotRequired);
            AddPrimitive(typeof(DateTime), "dateTime", "DateTime", TypeFlags.CanBeAttributeValue | TypeFlags.CanBeElementValue | TypeFlags.HasCustomFormatter | TypeFlags.XmlEncodingNotRequired);
            AddPrimitive(typeof(XmlQualifiedName), "QName", "XmlQualifiedName", TypeFlags.CanBeAttributeValue | TypeFlags.HasCustomFormatter | TypeFlags.HasIsEmpty | TypeFlags.CanBeElementValue | TypeFlags.XmlEncodingNotRequired);
            AddPrimitive(typeof(byte), "unsignedByte", "Byte", TypeFlags.CanBeAttributeValue | TypeFlags.CanBeElementValue | TypeFlags.XmlEncodingNotRequired);
            AddPrimitive(typeof(SByte), "byte", "SByte", TypeFlags.CanBeAttributeValue | TypeFlags.CanBeElementValue | TypeFlags.XmlEncodingNotRequired);
            AddPrimitive(typeof(UInt16), "unsignedShort", "UInt16", TypeFlags.CanBeAttributeValue | TypeFlags.CanBeElementValue | TypeFlags.XmlEncodingNotRequired);
            AddPrimitive(typeof(UInt32), "unsignedInt", "UInt32", TypeFlags.CanBeAttributeValue | TypeFlags.CanBeElementValue | TypeFlags.XmlEncodingNotRequired);
            AddPrimitive(typeof(UInt64), "unsignedLong", "UInt64", TypeFlags.CanBeAttributeValue | TypeFlags.CanBeElementValue | TypeFlags.XmlEncodingNotRequired);

            // Types without direct mapping (ambigous)
            AddPrimitive(typeof(DateTime), "date", "Date", TypeFlags.AmbiguousDataType | TypeFlags.CanBeAttributeValue | TypeFlags.CanBeElementValue | TypeFlags.HasCustomFormatter | TypeFlags.XmlEncodingNotRequired);
            AddPrimitive(typeof(DateTime), "time", "Time", TypeFlags.AmbiguousDataType | TypeFlags.CanBeAttributeValue | TypeFlags.CanBeElementValue | TypeFlags.HasCustomFormatter | TypeFlags.XmlEncodingNotRequired);

            AddPrimitive(typeof(string), "Name", "XmlName", TypeFlags.AmbiguousDataType | TypeFlags.CanBeAttributeValue | TypeFlags.CanBeElementValue | TypeFlags.HasCustomFormatter | TypeFlags.Reference);
            AddPrimitive(typeof(string), "NCName", "XmlNCName", TypeFlags.AmbiguousDataType | TypeFlags.CanBeAttributeValue | TypeFlags.CanBeElementValue | TypeFlags.HasCustomFormatter | TypeFlags.Reference);
            AddPrimitive(typeof(string), "NMTOKEN", "XmlNmToken", TypeFlags.AmbiguousDataType | TypeFlags.CanBeAttributeValue | TypeFlags.CanBeElementValue | TypeFlags.HasCustomFormatter | TypeFlags.Reference);
            AddPrimitive(typeof(string), "NMTOKENS", "XmlNmTokens", TypeFlags.AmbiguousDataType | TypeFlags.CanBeAttributeValue | TypeFlags.CanBeElementValue | TypeFlags.HasCustomFormatter | TypeFlags.Reference);

            AddPrimitive(typeof(byte[]), "base64Binary", "ByteArrayBase64", TypeFlags.AmbiguousDataType | TypeFlags.CanBeAttributeValue | TypeFlags.CanBeElementValue | TypeFlags.HasCustomFormatter | TypeFlags.Reference | TypeFlags.IgnoreDefault | TypeFlags.XmlEncodingNotRequired);
            AddPrimitive(typeof(byte[]), "hexBinary", "ByteArrayHex", TypeFlags.AmbiguousDataType | TypeFlags.CanBeAttributeValue | TypeFlags.CanBeElementValue | TypeFlags.HasCustomFormatter | TypeFlags.Reference  | TypeFlags.IgnoreDefault | TypeFlags.XmlEncodingNotRequired);
            // NOTE, stefanph: byte[] can also be used to mean array of bytes. That datatype is not a primitive, so we
            // can't use the AmbiguousDataType mechanism. To get an array of bytes in literal XML, apply [XmlArray] or
            // [XmlArrayItem].

            XmlSchemaPatternFacet guidPattern = new XmlSchemaPatternFacet();
            guidPattern.Value = "[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}";

            AddNonXsdPrimitive(typeof(Guid), "guid", UrtTypes.Namespace, "Guid", new XmlQualifiedName("string", XmlSchema.Namespace), new XmlSchemaFacet[] { guidPattern }, TypeFlags.CanBeAttributeValue | TypeFlags.CanBeElementValue | TypeFlags.XmlEncodingNotRequired);
            AddNonXsdPrimitive(typeof(char), "char", UrtTypes.Namespace, "Char", new XmlQualifiedName("unsignedShort", XmlSchema.Namespace), new XmlSchemaFacet[0], TypeFlags.CanBeAttributeValue | TypeFlags.CanBeElementValue | TypeFlags.HasCustomFormatter);

            AddSoapEncodedTypes(Soap.Encoding);

            // Unsuppoted types that we map to string, if in the future we decide 
            // to add support for them we would need to create custom formatters for them
            for (int i = 0; i < unsupportedTypes.Length; i++) {
                AddPrimitive(typeof(string), unsupportedTypes[i], "String", TypeFlags.AmbiguousDataType | TypeFlags.CanBeAttributeValue | TypeFlags.CanBeElementValue | TypeFlags.CanBeTextValue | TypeFlags.Reference);
            }
        }

        static void AddSoapEncodedTypes(string ns) {
            for (int i = 0; i < unsupportedTypes.Length; i++) {
                AddSoapEncodedPrimitive(typeof(string), unsupportedTypes[i], ns, "String", new XmlQualifiedName(unsupportedTypes[i], XmlSchema.Namespace), TypeFlags.AmbiguousDataType | TypeFlags.CanBeAttributeValue | TypeFlags.CanBeElementValue | TypeFlags.Reference);
            }

            AddSoapEncodedPrimitive(typeof(string), "string", ns, "String", new XmlQualifiedName("string", XmlSchema.Namespace), TypeFlags.CanBeAttributeValue | TypeFlags.CanBeElementValue | TypeFlags.CanBeTextValue | TypeFlags.Reference);
            AddSoapEncodedPrimitive(typeof(int), "int", ns, "Int32", new XmlQualifiedName("string", XmlSchema.Namespace), TypeFlags.CanBeAttributeValue | TypeFlags.CanBeElementValue | TypeFlags.XmlEncodingNotRequired);
            AddSoapEncodedPrimitive(typeof(bool), "boolean", ns, "Boolean", new XmlQualifiedName("string", XmlSchema.Namespace), TypeFlags.CanBeAttributeValue | TypeFlags.CanBeElementValue | TypeFlags.XmlEncodingNotRequired);
            AddSoapEncodedPrimitive(typeof(short), "short", ns, "Int16", new XmlQualifiedName("string", XmlSchema.Namespace), TypeFlags.CanBeAttributeValue | TypeFlags.CanBeElementValue | TypeFlags.XmlEncodingNotRequired);
            AddSoapEncodedPrimitive(typeof(long), "long", ns, "Int64", new XmlQualifiedName("string", XmlSchema.Namespace), TypeFlags.CanBeAttributeValue | TypeFlags.CanBeElementValue | TypeFlags.XmlEncodingNotRequired);
            AddSoapEncodedPrimitive(typeof(float), "float", ns, "Single", new XmlQualifiedName("string", XmlSchema.Namespace), TypeFlags.CanBeAttributeValue | TypeFlags.CanBeElementValue | TypeFlags.XmlEncodingNotRequired);
            AddSoapEncodedPrimitive(typeof(double), "double", ns, "Double", new XmlQualifiedName("string", XmlSchema.Namespace), TypeFlags.CanBeAttributeValue | TypeFlags.CanBeElementValue | TypeFlags.XmlEncodingNotRequired);
            AddSoapEncodedPrimitive(typeof(decimal), "decimal", ns, "Decimal", new XmlQualifiedName("string", XmlSchema.Namespace), TypeFlags.CanBeAttributeValue | TypeFlags.CanBeElementValue | TypeFlags.XmlEncodingNotRequired);
            AddSoapEncodedPrimitive(typeof(DateTime), "dateTime", ns, "DateTime", new XmlQualifiedName("string", XmlSchema.Namespace), TypeFlags.CanBeAttributeValue | TypeFlags.CanBeElementValue | TypeFlags.HasCustomFormatter | TypeFlags.XmlEncodingNotRequired);
            AddSoapEncodedPrimitive(typeof(XmlQualifiedName), "QName", ns, "XmlQualifiedName", new XmlQualifiedName("string", XmlSchema.Namespace), TypeFlags.CanBeAttributeValue | TypeFlags.HasCustomFormatter | TypeFlags.HasIsEmpty | TypeFlags.CanBeElementValue | TypeFlags.XmlEncodingNotRequired);
            AddSoapEncodedPrimitive(typeof(byte), "unsignedByte", ns, "Byte", new XmlQualifiedName("string", XmlSchema.Namespace), TypeFlags.CanBeAttributeValue | TypeFlags.CanBeElementValue | TypeFlags.XmlEncodingNotRequired);
            AddSoapEncodedPrimitive(typeof(SByte), "byte", ns, "SByte", new XmlQualifiedName("string", XmlSchema.Namespace), TypeFlags.CanBeAttributeValue | TypeFlags.CanBeElementValue | TypeFlags.XmlEncodingNotRequired);
            AddSoapEncodedPrimitive(typeof(UInt16), "unsignedShort", ns, "UInt16", new XmlQualifiedName("string", XmlSchema.Namespace), TypeFlags.CanBeAttributeValue | TypeFlags.CanBeElementValue | TypeFlags.XmlEncodingNotRequired);
            AddSoapEncodedPrimitive(typeof(UInt32), "unsignedInt", ns, "UInt32", new XmlQualifiedName("string", XmlSchema.Namespace), TypeFlags.CanBeAttributeValue | TypeFlags.CanBeElementValue | TypeFlags.XmlEncodingNotRequired);
            AddSoapEncodedPrimitive(typeof(UInt64), "unsignedLong", ns, "UInt64", new XmlQualifiedName("string", XmlSchema.Namespace), TypeFlags.CanBeAttributeValue | TypeFlags.CanBeElementValue | TypeFlags.XmlEncodingNotRequired);

            // Types without direct mapping (ambigous)
            AddSoapEncodedPrimitive(typeof(DateTime), "date", ns, "Date", new XmlQualifiedName("string", XmlSchema.Namespace), TypeFlags.AmbiguousDataType | TypeFlags.CanBeAttributeValue | TypeFlags.CanBeElementValue | TypeFlags.HasCustomFormatter | TypeFlags.XmlEncodingNotRequired);
            AddSoapEncodedPrimitive(typeof(DateTime), "time", ns, "Time", new XmlQualifiedName("string", XmlSchema.Namespace), TypeFlags.AmbiguousDataType | TypeFlags.CanBeAttributeValue | TypeFlags.CanBeElementValue | TypeFlags.HasCustomFormatter | TypeFlags.XmlEncodingNotRequired);

            AddSoapEncodedPrimitive(typeof(string), "Name", ns, "XmlName", new XmlQualifiedName("string", XmlSchema.Namespace), TypeFlags.AmbiguousDataType | TypeFlags.CanBeAttributeValue | TypeFlags.CanBeElementValue | TypeFlags.HasCustomFormatter | TypeFlags.Reference);
            AddSoapEncodedPrimitive(typeof(string), "NCName", ns, "XmlNCName", new XmlQualifiedName("string", XmlSchema.Namespace), TypeFlags.AmbiguousDataType | TypeFlags.CanBeAttributeValue | TypeFlags.CanBeElementValue | TypeFlags.HasCustomFormatter | TypeFlags.Reference);
            AddSoapEncodedPrimitive(typeof(string), "NMTOKEN", ns, "XmlNmToken", new XmlQualifiedName("string", XmlSchema.Namespace), TypeFlags.AmbiguousDataType | TypeFlags.CanBeAttributeValue | TypeFlags.CanBeElementValue | TypeFlags.HasCustomFormatter | TypeFlags.Reference);
            AddSoapEncodedPrimitive(typeof(string), "NMTOKENS", ns, "XmlNmTokens", new XmlQualifiedName("string", XmlSchema.Namespace), TypeFlags.AmbiguousDataType | TypeFlags.CanBeAttributeValue | TypeFlags.CanBeElementValue | TypeFlags.HasCustomFormatter | TypeFlags.Reference);

            AddSoapEncodedPrimitive(typeof(byte[]), "base64Binary", ns, "ByteArrayBase64", new XmlQualifiedName("string", XmlSchema.Namespace), TypeFlags.AmbiguousDataType | TypeFlags.CanBeAttributeValue | TypeFlags.CanBeElementValue | TypeFlags.HasCustomFormatter | TypeFlags.Reference | TypeFlags.IgnoreDefault | TypeFlags.XmlEncodingNotRequired);
            AddSoapEncodedPrimitive(typeof(byte[]), "hexBinary", ns, "ByteArrayHex", new XmlQualifiedName("string", XmlSchema.Namespace), TypeFlags.AmbiguousDataType | TypeFlags.CanBeAttributeValue | TypeFlags.CanBeElementValue | TypeFlags.HasCustomFormatter | TypeFlags.Reference  | TypeFlags.IgnoreDefault | TypeFlags.XmlEncodingNotRequired);

            AddSoapEncodedPrimitive(typeof(string), "arrayCoordinate", ns, "String", new XmlQualifiedName("string", XmlSchema.Namespace), TypeFlags.CanBeAttributeValue | TypeFlags.CanBeElementValue);
            AddSoapEncodedPrimitive(typeof(byte[]), "base64", ns, "ByteArrayBase64", new XmlQualifiedName("base64Binary", XmlSchema.Namespace), TypeFlags.CanBeAttributeValue | TypeFlags.CanBeElementValue);
        }

        static void AddPrimitive(Type type, string dataTypeName, string formatterName, TypeFlags flags) {
            XmlSchemaSimpleType dataType = new XmlSchemaSimpleType();
            dataType.Name = dataTypeName;
            TypeDesc typeDesc = new TypeDesc(type, true, dataType, formatterName, flags);
            if (primitiveTypes[type] == null)
                primitiveTypes.Add(type, typeDesc);
            primitiveDataTypes.Add(dataType, typeDesc);
            primitiveNames.Add((new XmlQualifiedName(dataTypeName, XmlSchema.Namespace)).ToString(), typeDesc);
        }

        static void AddNonXsdPrimitive(Type type, string dataTypeName, string ns, string formatterName, XmlQualifiedName baseTypeName, XmlSchemaFacet[] facets, TypeFlags flags) {
            XmlSchemaSimpleType dataType = new XmlSchemaSimpleType();
            dataType.Name = dataTypeName;
            XmlSchemaSimpleTypeRestriction restriction = new XmlSchemaSimpleTypeRestriction();
            restriction.BaseTypeName = baseTypeName;
            foreach (XmlSchemaFacet facet in facets) {
                restriction.Facets.Add(facet);
            }
            dataType.Content = restriction;
            TypeDesc typeDesc = new TypeDesc(type, false, dataType, formatterName, flags);
            if (primitiveTypes[type] == null)
                primitiveTypes.Add(type, typeDesc);
            primitiveDataTypes.Add(dataType, typeDesc);
            primitiveNames.Add((new XmlQualifiedName(dataTypeName, ns)).ToString(), typeDesc);
        }

        static void AddSoapEncodedPrimitive(Type type, string dataTypeName, string ns, string formatterName, XmlQualifiedName baseTypeName, TypeFlags flags) {
            AddNonXsdPrimitive(type, dataTypeName, ns, formatterName, baseTypeName, new XmlSchemaFacet[0], flags);
        }

        internal TypeDesc GetTypeDesc(XmlQualifiedName name) {
            return (TypeDesc)primitiveNames[name.ToString()];
        }
        
        internal TypeDesc GetTypeDesc(XmlSchemaSimpleType dataType) {
            return (TypeDesc)primitiveDataTypes[dataType];
        }
        
        internal TypeDesc GetTypeDesc(Type type) {
            return GetTypeDesc(type, null, true);
        }

        internal TypeDesc GetTypeDesc(Type type, MemberInfo source) {
            return GetTypeDesc(type, source, true);
        }

        internal TypeDesc GetTypeDesc(Type type, MemberInfo source, bool directReference) {
            TypeDesc typeDesc = (TypeDesc)typeDescs[type];
            if (typeDesc == null) {
                typeDesc = ImportTypeDesc(type, true, source);
                typeDescs.Add(type, typeDesc);
            }
            if (directReference && typeDesc.IsClass && !typeDesc.IsAbstract && !typeDesc.HasDefaultConstructor) {
                throw new InvalidOperationException(Res.GetString(Res.XmlConstructorInaccessible, typeDesc.FullName));
            }
            return typeDesc;
        }

        internal TypeDesc GetArrayTypeDesc(Type type) {
            TypeDesc typeDesc = (TypeDesc) arrayTypeDescs[type];
            if (typeDesc == null) {
                typeDesc = GetTypeDesc(type);
                if (!typeDesc.IsArrayLike)
                    typeDesc = ImportTypeDesc(type, false, null);
                arrayTypeDescs.Add(type, typeDesc);
            }
            return typeDesc;
        }

        TypeDesc ImportTypeDesc(Type type, bool canBePrimitive, MemberInfo memberInfo) {
            TypeDesc typeDesc = null;
            if (canBePrimitive) {
                typeDesc = (TypeDesc)primitiveTypes[type];
                if (typeDesc != null) return typeDesc;
            }
            TypeKind kind;
            Type arrayElementType = null;
            Type baseType = null;
            TypeFlags flags = 0;
            if (!type.IsValueType)
                flags |= TypeFlags.Reference;
            if (type.IsNotPublic) {
                throw new InvalidOperationException(Res.GetString(Res.XmlTypeInaccessible, type.FullName));
            }
            else if (type == typeof(object)) {
                kind = TypeKind.Root;
                flags |= TypeFlags.HasDefaultConstructor;
            }
            else if (type == typeof(ValueType)) {
                throw new NotSupportedException(Res.GetString(Res.XmlUnsupportedType, type.FullName));
            }
            else if (type == typeof(void)) {
                kind = TypeKind.Void;
            }
            else if (typeof(IXmlSerializable).IsAssignableFrom(type)) {
                // CONSIDER, just because it's typed, doesn't mean it has schema?
                kind = TypeKind.Serializable;
                flags |= TypeFlags.Special | TypeFlags.CanBeElementValue;
                flags |= GetConstructorFlags(type, true);
                CheckMethodSecurity(type, "GetSchema", new Type[] {}, "");
                CheckMethodSecurity(type, "ReadXml", new Type[] {typeof(XmlReader)}, typeof(XmlReader).Name);
                CheckMethodSecurity(type, "WriteXml", new Type[] {typeof(XmlWriter)}, typeof(XmlWriter).Name);
            }
            else if (type.IsArray) {
                if (type.GetArrayRank() > 1) {
                    throw new NotSupportedException(Res.GetString(Res.XmlUnsupportedRank, type.FullName));
                }
                kind = TypeKind.Array;
                arrayElementType = type.GetElementType();
                flags |= TypeFlags.HasDefaultConstructor;
            }
            else if (typeof(ICollection).IsAssignableFrom(type)) {
                arrayElementType = GetCollectionElementType(type);
                kind = TypeKind.Collection;
                flags |= GetConstructorFlags(type, true);

                if (HasSecurityAttributes(type.GetProperty("Count"))) {
                    throw new InvalidOperationException(Res.GetString(Res.XmlPropertyHasSecurityAttributes, "Count", type.FullName));
                }
            }
            else if (type == typeof(XmlQualifiedName)) {
                kind = TypeKind.Primitive;
            }
            else if (type.IsPrimitive) {
                //CONSIDER: return (TypeDesc)primitiveTypes[typeof(string)];
                throw new NotSupportedException(Res.GetString(Res.XmlUnsupportedType, type.FullName));
            }
            else if (type.IsEnum) {
                kind = TypeKind.Enum;
            }
            else if (type.IsValueType) {
                kind = TypeKind.Struct;
                baseType = type.BaseType;
                if (type.IsAbstract) flags |= TypeFlags.Abstract;
            }
            else if (type.IsClass) {
                if (type == typeof(XmlAttribute)) {
                    kind = TypeKind.Attribute;
                    flags |= TypeFlags.Special | TypeFlags.CanBeAttributeValue;
                }
                else if (typeof(XmlNode).IsAssignableFrom(type)) {
                    kind = TypeKind.Node;
                    flags |= TypeFlags.Special | TypeFlags.CanBeElementValue | TypeFlags.CanBeTextValue;
                    if (typeof(XmlText).IsAssignableFrom(type))
                        flags &= ~TypeFlags.CanBeElementValue;
                    else if (typeof(XmlElement).IsAssignableFrom(type))
                        flags &= ~TypeFlags.CanBeTextValue;
                    else if (type.IsAssignableFrom(typeof(XmlAttribute)))
                        flags |= TypeFlags.CanBeAttributeValue;
                }
                else {
                    kind = TypeKind.Class;
                    baseType = type.BaseType;
                    if (type.IsAbstract)
                        flags |= TypeFlags.Abstract;
                }
            }
            else if (type.IsInterface) {
                if (memberInfo == null) {
                    throw new NotSupportedException(Res.GetString(Res.XmlUnsupportedInterface, type.FullName));
                }
                else {
                    throw new NotSupportedException(Res.GetString(Res.XmlUnsupportedInterfaceDetails, memberInfo.DeclaringType.FullName + "." + memberInfo.Name, type.FullName));
                }
            }
            else {
                throw new NotSupportedException(Res.GetString(Res.XmlUnsupportedType, type.FullName));
            }

            // check to see if the type has public default constructor for classes
            if (kind == TypeKind.Class && !type.IsAbstract) {
                flags |= GetConstructorFlags(type, false);
            }

            // check if a struct-like type is enumerable

            if (kind == TypeKind.Struct || kind == TypeKind.Class){
                if (typeof(IEnumerable).IsAssignableFrom(type)) {
                    arrayElementType = GetEnumeratorElementType(type);
                    kind = TypeKind.Enumerable;

                    // GetEnumeratorElementType checks for the security attributes on the GetEnumerator(), Add() methods and Current property, 
                    // we need to check the MoveNext() and ctor methods for the security attribues
                    flags |= GetConstructorFlags(type, true);
                    CheckMethodSecurity(type, "MoveNext", new Type[0], "");
                }
            }
            TypeDesc arrayElementTypeDesc;
            if (arrayElementType != null) {
                arrayElementTypeDesc = GetTypeDesc(arrayElementType);
            }
            else
                arrayElementTypeDesc = null;
            TypeDesc baseTypeDesc;
            if (baseType != null && baseType != typeof(object) && baseType != typeof(ValueType))
                baseTypeDesc = GetTypeDesc(baseType, null, false);
            else
                baseTypeDesc = null;

            string name = type.Name;
            string fullName = type.FullName;
            if (type.IsNestedPublic) {
                for (Type t = type.DeclaringType; t != null; t = t.DeclaringType)
                    GetTypeDesc(t, null, false);
                int plus = name.LastIndexOf('+');
                if (plus >= 0) {
                    name = name.Substring(plus + 1);
                    fullName = fullName.Replace('+', '.');
                }
            }
            return new TypeDesc(name, fullName, kind, baseTypeDesc, flags, arrayElementTypeDesc);
        }
        
        internal static Type GetArrayElementType(Type type) {
            if (type.IsArray)
                return type.GetElementType();
            else if (typeof(ICollection).IsAssignableFrom(type))
                return GetCollectionElementType(type);
            else if (typeof(IEnumerable).IsAssignableFrom(type))
                return GetEnumeratorElementType(type);
            else
                return null;
        }

        internal static MemberMapping[] GetAllMembers(StructMapping mapping) {
            if (mapping.BaseMapping == null)
                return mapping.Members;
            ArrayList list = new ArrayList();
            GetAllMembers(mapping, list);
            return (MemberMapping[])list.ToArray(typeof(MemberMapping));
        }
       
        internal static void GetAllMembers(StructMapping mapping, ArrayList list) {
            if (mapping.BaseMapping != null) {
                GetAllMembers(mapping.BaseMapping, list);
            }
            for (int i = 0; i < mapping.Members.Length; i++) {
                list.Add(mapping.Members[i]);
            }
        }

        internal static bool HasSecurityAttributes(PropertyInfo propertyInfo) {
            if (propertyInfo != null) {
                foreach (MethodInfo accessor in propertyInfo.GetAccessors()) {
                    if ((accessor.Attributes & MethodAttributes.HasSecurity) != 0) {
                        return true;
                    }
                }
                if ((propertyInfo.DeclaringType.Attributes & TypeAttributes.HasSecurity) != 0) {
                    return true;
                }
            }
            return false;
        }

        internal static bool HasSecurityAttributes(MethodInfo methodInfo) {
            return (methodInfo != null && ((methodInfo.Attributes & MethodAttributes.HasSecurity) != 0 || (methodInfo.DeclaringType.Attributes & TypeAttributes.HasSecurity) != 0));
        }

        internal static TypeFlags GetConstructorFlags(Type type, bool throwOnHasSecurity) {
            ConstructorInfo ctor = type.GetConstructor(new Type[0]);
            if (ctor != null) {
                if ((ctor.Attributes & MethodAttributes.HasSecurity) != 0 || (type.Attributes & TypeAttributes.HasSecurity) != 0) {
                    if (throwOnHasSecurity )
                        throw new InvalidOperationException(Res.GetString(Res.XmlConstructorHasSecurityAttributes, type.FullName));
                    return TypeFlags.CtorHasSecurity | TypeFlags.HasDefaultConstructor;
                }
                return TypeFlags.HasDefaultConstructor;
            }
            return 0;
        }

        internal static void CheckMethodSecurity(Type type, string name, Type[] parameters, string parameterName) {
            MethodInfo method = type.GetMethod(name, parameters);
            if (HasSecurityAttributes(method)) {
                throw new InvalidOperationException(Res.GetString(Res.XmlMethodHasSecurityAttributes, type.FullName, name, parameterName));
            }
        }
      
        static Type GetEnumeratorElementType(Type type) {
            if (typeof(IEnumerable).IsAssignableFrom(type)) {
                MethodInfo e = type.GetMethod("GetEnumerator", new Type[0]);

                XmlAttributes methodAttrs = new XmlAttributes(e);
                if (methodAttrs.XmlIgnore) return null;

                if (HasSecurityAttributes(e))
                    throw new InvalidOperationException(Res.GetString(Res.XmlMethodHasSecurityAttributes, type.FullName, e.Name, ""));

                PropertyInfo p = e.ReturnType.GetProperty("Current");
                if (HasSecurityAttributes(p)) {
                    throw new InvalidOperationException(Res.GetString(Res.XmlPropertyHasSecurityAttributes, p.Name, type.FullName));
                }

                Type currentType = (p == null ? typeof(object) : p.PropertyType);

                MethodInfo addMethod = type.GetMethod("Add", new Type[] { currentType });

                if (addMethod == null && currentType != typeof(object)) {
                    currentType = typeof(object);
                    addMethod = type.GetMethod("Add", new Type[] { currentType });
                }
                if (addMethod == null) {
                    throw new InvalidOperationException(Res.GetString(Res.XmlNoAddMethod, type.FullName, currentType, "IEnumerable"));
                }
                else {
                    if (HasSecurityAttributes(addMethod))
                        throw new InvalidOperationException(Res.GetString(Res.XmlMethodHasSecurityAttributes, type.FullName, addMethod.Name, currentType.Name));
                }
                return currentType;
            }
            else {
                return null;
            }
        }

        static Type GetCollectionElementType(Type type) {
            if (typeof(IDictionary).IsAssignableFrom(type)) {
                throw new NotSupportedException(Res.GetString(Res.XmlUnsupportedIDictionary, type.FullName));
            }

            PropertyInfo indexer = null;
            for (Type t = type; t != null; t = t.BaseType) {
                MemberInfo[] defaultMembers = type.GetDefaultMembers();
                if (defaultMembers != null) {
                    for (int i = 0; i < defaultMembers.Length; i++) {
                        if (defaultMembers[i] is PropertyInfo) {
                            PropertyInfo defaultProp = (PropertyInfo)defaultMembers[i];
                            if (!defaultProp.CanRead) continue;
                            MethodInfo getMethod = defaultProp.GetGetMethod();
                            ParameterInfo[] parameters = getMethod.GetParameters();
                            if (parameters.Length == 1 && parameters[0].ParameterType == typeof(int)) {
                                indexer = defaultProp;
                                break;
                            }
                        }
                    }
                }
                if (indexer != null) break;
            }

            if (indexer == null) {
                throw new InvalidOperationException(Res.GetString(Res.XmlNoDefaultAccessors, type.FullName));
            }
            else {
                if (HasSecurityAttributes(indexer))
                    throw new InvalidOperationException(Res.GetString(Res.XmlDefaultAccessorHasSecurityAttributes, type.FullName));
            }
            
            MethodInfo addMethod = type.GetMethod("Add", new Type[] { indexer.PropertyType });
            if (addMethod == null) {
                throw new InvalidOperationException(Res.GetString(Res.XmlNoAddMethod, type.FullName, indexer.PropertyType, "ICollection"));
            }
            else if (HasSecurityAttributes(addMethod)) {
                throw new InvalidOperationException(Res.GetString(Res.XmlMethodHasSecurityAttributes, type.FullName, addMethod.Name, indexer.PropertyType.Name));
            }
        
            return indexer.PropertyType;
        }
        
        static internal XmlQualifiedName ParseWsdlArrayType(string type, out string dims) {
            return ParseWsdlArrayType(type, out dims, null);
        }

        static internal XmlQualifiedName ParseWsdlArrayType(string type, out string dims, XmlSchemaObject parent) {
            string ns;
            string name;

            int nsLen = type.LastIndexOf(':');

            if (nsLen <= 0) {
                ns = "";
            }
            else {
                ns = type.Substring(0, nsLen);
            }
            int nameLen = type.IndexOf('[', nsLen + 1);

            if (nameLen <= nsLen) {
                throw new InvalidOperationException(Res.GetString(Res.XmlInvalidArrayTypeSyntax, type));
            }
            name = type.Substring(nsLen + 1, nameLen - nsLen - 1);
            dims = type.Substring(nameLen);

            // parent is not null only in the case when we used XmlSchema.Read(), 
            // in which case we need to fixup the wsdl:arayType attribute value
            while (parent != null) {
                if (parent.Namespaces != null) {
                    string wsdlNs = (string)parent.Namespaces.Namespaces[ns];
                    if (wsdlNs != null) {
                        ns = wsdlNs;
                        break;
                    }
                }
                parent = parent.Parent;
            }
            return new XmlQualifiedName(name, ns);
        }

        internal ICollection Types {
            get { return this.typeDescs.Keys; }
        }

        internal void AddTypeMapping(TypeMapping typeMapping) {
            typeMappings.Add(typeMapping);
        }

        internal ICollection TypeMappings {
            get { return typeMappings; }
        }

        internal bool IsValidXsdDataType(string dataType) {
            return (null != GetTypeDesc(new XmlQualifiedName(dataType, XmlSchema.Namespace)));
        }
    }

    internal class Soap {
        internal const string Encoding = "http://schemas.xmlsoap.org/soap/encoding/";
        internal const string UrType = "anyType";
        internal const string Array = "Array";
        internal const string ArrayType = "arrayType";
    }

    internal class Soap12 {
        internal const string Encoding = "http://www.w3.org/2002/06/soap-encoding";
        internal const string RpcNamespace = "http://www.w3.org/2002/06/soap-rpc";
        internal const string RpcResult = "result";
    }

    internal class Wsdl {
        internal const string Namespace = "http://schemas.xmlsoap.org/wsdl/";
        internal const string ArrayType = "arrayType";
    }

    internal class UrtTypes {
        internal const string Namespace = "http://microsoft.com/wsdl/types/";
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\serialization\xmlmembersmapping.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlMembersMapping.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Serialization {

    using System.Reflection;
    using System;

    /// <include file='doc\XmlMembersMapping.uex' path='docs/doc[@for="XmlMembersMapping"]/*' />
    ///<internalonly/>
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public class XmlMembersMapping : XmlMapping {
        XmlMemberMapping[] mappings;
        ElementAccessor accessor;

        internal XmlMembersMapping(TypeScope scope, ElementAccessor accessor) : base(scope) {
            this.accessor = accessor;
            MembersMapping mapping = (MembersMapping)accessor.Mapping;
            mappings = new XmlMemberMapping[mapping.Members.Length];
            for (int i = 0; i < mappings.Length; i++)
                mappings[i] = new XmlMemberMapping(scope, mapping.Members[i]);
        }

        internal ElementAccessor Accessor {
            get { return accessor; }
        }

        /// <include file='doc\XmlMembersMapping.uex' path='docs/doc[@for="XmlMembersMapping.ElementName"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public string ElementName { 
            get { return System.Xml.Serialization.Accessor.UnescapeName(Accessor.Name); }
        }

        /// <include file='doc\XmlMembersMapping.uex' path='docs/doc[@for="XmlMembersMapping.Namespace"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public string Namespace {
            get { return accessor.Namespace; }
        }

        /// <include file='doc\XmlMembersMapping.uex' path='docs/doc[@for="XmlMembersMapping.TypeName"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public string TypeName {
            get { return accessor.Mapping.TypeName; }
        }

        /// <include file='doc\XmlMembersMapping.uex' path='docs/doc[@for="XmlMembersMapping.TypeNamespace"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public string TypeNamespace {
            get { return accessor.Mapping.Namespace; }
        }

        /// <include file='doc\XmlMembersMapping.uex' path='docs/doc[@for="XmlMembersMapping.this"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public XmlMemberMapping this[int index] {
            get { return mappings[index]; }
        }

        /// <include file='doc\XmlMembersMapping.uex' path='docs/doc[@for="XmlMembersMapping.Count"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public int Count {
            get { return mappings.Length; }
        }
    }
 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\serialization\xmlmembermapping.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlMemberMapping.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Serialization {

    using System.Reflection;
    using System;
    using System.CodeDom;

    /// <include file='doc\XmlMemberMapping.uex' path='docs/doc[@for="XmlMemberMapping"]/*' />
    /// <internalonly/>
    public class XmlMemberMapping {
        MemberMapping mapping;
        TypeScope scope;

        internal XmlMemberMapping(TypeScope scope, MemberMapping mapping) {
            this.scope = scope;
            this.mapping = mapping;
        }

        internal TypeScope Scope {
            get { return scope; }
        }

        internal MemberMapping Mapping {
            get { return mapping; }
        }

        internal Accessor Accessor {
            get { return mapping.Accessor; }
        }

        /// <include file='doc\XmlMemberMapping.uex' path='docs/doc[@for="XmlMemberMapping.Any"]/*' />
        public bool Any {
            get { return Accessor.Any; }
        }

        /// <include file='doc\XmlMemberMapping.uex' path='docs/doc[@for="XmlMemberMapping.ElementName"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public string ElementName { 
            get { return Accessor.UnescapeName(Accessor.Name); }
        }

        /// <include file='doc\XmlMemberMapping.uex' path='docs/doc[@for="XmlMemberMapping.Namespace"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public string Namespace {
            get { return Accessor.Namespace; }
        }

        /// <include file='doc\XmlMemberMapping.uex' path='docs/doc[@for="XmlMemberMapping.MemberName"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public string MemberName {
            get { return mapping.Name; }
        }

        /// <include file='doc\XmlMemberMapping.uex' path='docs/doc[@for="XmlMemberMapping.TypeName"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public string TypeName {
            get { return mapping.Accessor.Mapping.TypeName; }
        }

        /// <include file='doc\XmlMemberMapping.uex' path='docs/doc[@for="XmlMemberMapping.TypeNamespace"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public string TypeNamespace {
            get { return mapping.Accessor.Mapping.Namespace; }
        }

        /// <include file='doc\XmlMemberMapping.uex' path='docs/doc[@for="XmlMemberMapping.TypeFullName"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public string TypeFullName {
            get { return mapping.TypeDesc.FullName; }
        }

        /// <include file='doc\XmlMemberMapping.uex' path='docs/doc[@for="XmlMemberMapping.CheckSpecified"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public bool CheckSpecified {
            get { return mapping.CheckSpecified; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\serialization\xmlnamespacedeclarationsattribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlNamespaceDeclarationsAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Serialization {
    using System;
    using System.Xml.Schema;

    /// <include file='doc\XmlNamespaceDeclarationsAttribute.uex' path='docs/doc[@for="XmlNamespaceDeclarationsAttribute"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [AttributeUsage(AttributeTargets.Field | AttributeTargets.Property | AttributeTargets.Parameter | AttributeTargets.ReturnValue, AllowMultiple=false)]
    public class XmlNamespaceDeclarationsAttribute : System.Attribute {

        /// <include file='doc\XmlNamespaceDeclarationsAttribute.uex' path='docs/doc[@for="XmlNamespaceDeclarationsAttribute.XmlNamespaceDeclarationsAttribute"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public XmlNamespaceDeclarationsAttribute() {
        }
       
    }
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\serialization\xmlignoreattribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlIgnoreAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Serialization {

    using System;

    /// <include file='doc\XmlIgnoreAttribute.uex' path='docs/doc[@for="XmlIgnoreAttribute"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [AttributeUsage(AttributeTargets.Field | AttributeTargets.Property | AttributeTargets.Parameter | AttributeTargets.ReturnValue)]
    public class XmlIgnoreAttribute : System.Attribute {
        /// <include file='doc\XmlIgnoreAttribute.uex' path='docs/doc[@for="XmlIgnoreAttribute.XmlIgnoreAttribute"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public XmlIgnoreAttribute() {
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\serialization\xmlschemas.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlSchemas.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Serialization {

    using System.Collections;
    using System.IO;
    using System;
    using System.ComponentModel;
    using System.Xml.Serialization;
    using System.Xml.Schema;
    using System.Diagnostics;

    /// <include file='doc\XmlSchemas.uex' path='docs/doc[@for="XmlSchemas"]/*' />
    /// <internalonly/>
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public class XmlSchemas : CollectionBase {
        Hashtable namespaces = new Hashtable();
        
        /// <include file='doc\XmlSchemas.uex' path='docs/doc[@for="XmlSchemas.this"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public XmlSchema this[int index] {
            get { return (XmlSchema)List[index]; }
            set { List[index] = value; }
        }

        /// <include file='doc\XmlSchemas.uex' path='docs/doc[@for="XmlSchemas.this1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public XmlSchema this[string ns] {
            get { 
                if (ns == null) 
                    return (XmlSchema)namespaces[String.Empty]; 
                return (XmlSchema)namespaces[ns]; 
            }
        }
        
        /// <include file='doc\XmlSchemas.uex' path='docs/doc[@for="XmlSchemas.Add"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public int Add(XmlSchema schema) {
            return List.Add(schema);
        }

        /// <include file='doc\XmlSchemas.uex' path='docs/doc[@for="XmlSchemas.Add1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void Add(XmlSchemas schemas) {
            foreach (XmlSchema schema in schemas) {
                Add(schema);
            }
        }
        
        /// <include file='doc\XmlSchemas.uex' path='docs/doc[@for="XmlSchemas.Insert"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void Insert(int index, XmlSchema schema) {
            List.Insert(index, schema);
        }
        
        /// <include file='doc\XmlSchemas.uex' path='docs/doc[@for="XmlSchemas.IndexOf"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public int IndexOf(XmlSchema schema) {
            return List.IndexOf(schema);
        }
        
        /// <include file='doc\XmlSchemas.uex' path='docs/doc[@for="XmlSchemas.Contains"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public bool Contains(XmlSchema schema) {
            return List.Contains(schema);
        }
        
        /// <include file='doc\XmlSchemas.uex' path='docs/doc[@for="XmlSchemas.Remove"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void Remove(XmlSchema schema) {
            List.Remove(schema);
        }
        
        /// <include file='doc\XmlSchemas.uex' path='docs/doc[@for="XmlSchemas.CopyTo"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void CopyTo(XmlSchema[] array, int index) {
            List.CopyTo(array, index);
        }

        /// <include file='doc\XmlSchemas.uex' path='docs/doc[@for="XmlSchemas.OnInsert"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected override void OnInsert(int index, object value) {
            AddName((XmlSchema)value);
        }

        /// <include file='doc\XmlSchemas.uex' path='docs/doc[@for="XmlSchemas.OnRemove"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected override void OnRemove(int index, object value) {
            RemoveName((XmlSchema)value);
        }

        /// <include file='doc\XmlSchemas.uex' path='docs/doc[@for="XmlSchemas.OnClear"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected override void OnClear() {
            namespaces.Clear();
        }

        /// <include file='doc\XmlSchemas.uex' path='docs/doc[@for="XmlSchemas.OnSet"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected override void OnSet(int index, object oldValue, object newValue) {
            RemoveName((XmlSchema)oldValue);
            AddName((XmlSchema)newValue);
        }

        void AddName(XmlSchema schema) {
            string targetNamespace = schema.TargetNamespace == null ? string.Empty : schema.TargetNamespace;

            if (namespaces[targetNamespace] != null)
                throw new InvalidOperationException(Res.GetString(Res.XmlSchemaDuplicateNamespace, targetNamespace));
            namespaces.Add(targetNamespace, schema);
        }

        void RemoveName(XmlSchema schema) {
            string targetNamespace = schema.TargetNamespace == null ? string.Empty : schema.TargetNamespace;
            namespaces.Remove(targetNamespace);
        }

        /// <include file='doc\XmlSchemas.uex' path='docs/doc[@for="XmlSchemas.Find"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public object Find(XmlQualifiedName name, Type type) {
            XmlSchema schema = (XmlSchema)namespaces[name.Namespace];
            if (schema == null) return null;

            if (!schema.IsPreprocessed) {
                try {
                    schema.Preprocess(null);
                }
                catch(Exception e) {
                    throw new InvalidOperationException(Res.GetString(Res.XmlSchemaSyntaxError, name.Namespace), e);
                }
            }
            if (type == typeof(XmlSchemaSimpleType) || type == typeof(XmlSchemaComplexType)) {
                object ret = schema.SchemaTypes[name];
                if (ret != null && type.IsAssignableFrom(ret.GetType()))
                    return ret;
                else
                    return null;
            }
            else if (type == typeof(XmlSchemaGroup)) {
                return schema.Groups[name];
            }
            else if (type == typeof(XmlSchemaAttributeGroup)) {
                return schema.AttributeGroups[name];
            }
            else if (type == typeof(XmlSchemaElement)) {
                return schema.Elements[name];
            }
            else if (type == typeof(XmlSchemaAttribute)) {
                return schema.Attributes[name];
            }
            else if (type == typeof(XmlSchemaNotation)) {
                return schema.Notations[name];
            }
            #if DEBUG
                // use exception in the place of Debug.Assert to avoid throwing asserts from a server process such as aspnet_ewp.exe
                throw new InvalidOperationException(Res.GetString(Res.XmlInternalErrorDetails, "XmlSchemas.Find: Invalid object type " + type.FullName));
            #else
                return null;
            #endif
        }

        /// <include file='doc\XmlSchemas.uex' path='docs/doc[@for="XmlSchemas.IsDataSet"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static bool IsDataSet(XmlSchema schema) {
            foreach (XmlSchemaObject o in schema.Items) {
                if (o is XmlSchemaElement) {
                    XmlSchemaElement e = (XmlSchemaElement)o;
                    if (e.UnhandledAttributes != null) {
                        foreach (XmlAttribute a in e.UnhandledAttributes) {
                            if (a.LocalName == "IsDataSet" && a.NamespaceURI == "urn:schemas-microsoft-com:xml-msdata") {
                                // currently the msdata:IsDataSet uses its own format for the boolean values
                                if (a.Value == "True" || a.Value == "true" || a.Value == "1") return true;
                            }
                        }
                    }
                }
            }
            return false;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\serialization\xmlrootattribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlRootAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Serialization {
    using System;
    using System.Xml.Schema;

    /// <include file='doc\XmlRootAttribute.uex' path='docs/doc[@for="XmlRootAttribute"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [AttributeUsage(AttributeTargets.ReturnValue | AttributeTargets.Class | AttributeTargets.Enum | AttributeTargets.Interface | AttributeTargets.Struct)]
    public class XmlRootAttribute : System.Attribute {
        string elementName;
        string ns;
        string dataType;
        bool nullable = true;
        bool nullableSpecified;
        
        /// <include file='doc\XmlRootAttribute.uex' path='docs/doc[@for="XmlRootAttribute.XmlRootAttribute"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public XmlRootAttribute() {
        }
        
        /// <include file='doc\XmlRootAttribute.uex' path='docs/doc[@for="XmlRootAttribute.XmlRootAttribute1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public XmlRootAttribute(string elementName) {
            this.elementName = elementName;
        }
        
        /// <include file='doc\XmlRootAttribute.uex' path='docs/doc[@for="XmlRootAttribute.ElementName"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public string ElementName {
            get { return elementName == null ? string.Empty : elementName; }
            set { elementName = value; }
        }
        
        /// <include file='doc\XmlRootAttribute.uex' path='docs/doc[@for="XmlRootAttribute.Namespace"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public string Namespace {
            get { return ns; }
            set { ns = value; }
        }

        /// <include file='doc\XmlRootAttribute.uex' path='docs/doc[@for="XmlRootAttribute.DataType"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public string DataType {
            get { return dataType == null ? string.Empty : dataType; }
            set { dataType = value; }
        }

        /// <include file='doc\XmlRootAttribute.uex' path='docs/doc[@for="XmlRootAttribute.IsNullable"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public bool IsNullable {
            get { return nullable; }
            set { 
                nullable = value; 
                nullableSpecified = true;
            }
        }

        internal bool IsNullableSpecified {
            get { return nullableSpecified; }
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\serialization\xmlschemaexporter.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlSchemaExporter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Serialization {
    
    using System;
    using System.Collections;
    using System.Xml.Schema;
    using System.ComponentModel;
    using System.Diagnostics;
    
    /// <include file='doc\XmlSchemaExporter.uex' path='docs/doc[@for="XmlSchemaExporter"]/*' />
    ///<internalonly/>
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public class XmlSchemaExporter {
        internal const XmlSchemaForm elementFormDefault = XmlSchemaForm.Qualified;
        internal const XmlSchemaForm attributeFormDefault = XmlSchemaForm.Unqualified;

        XmlSchemas schemas;
        Hashtable elements = new Hashtable();   // ElementAccessor -> XmlSchemaElement
        Hashtable types = new Hashtable();      // StructMapping/EnumMapping -> XmlSchemaComplexType/XmlSchemaSimpleType
        bool needToExportRoot;
        TypeScope scope;
       
        /// <include file='doc\XmlSchemaExporter.uex' path='docs/doc[@for="XmlSchemaExporter.XmlSchemaExporter"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public XmlSchemaExporter(XmlSchemas schemas) {
            this.schemas = schemas;
        }

        /// <include file='doc\XmlSchemaExporter.uex' path='docs/doc[@for="XmlSchemaExporter.ExportTypeMapping"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void ExportTypeMapping(XmlTypeMapping xmlTypeMapping) {
            CheckScope(xmlTypeMapping.Scope);
            ExportElement(xmlTypeMapping.Accessor);
            ExportRootIfNecessary(xmlTypeMapping.Scope);
        }

        /// <include file='doc\XmlSchemaExporter.uex' path='docs/doc[@for="XmlSchemaExporter.ExportTypeMapping1"]/*' />
        public XmlQualifiedName ExportTypeMapping(XmlMembersMapping xmlMembersMapping) {
            CheckScope(xmlMembersMapping.Scope);
            MembersMapping mapping = (MembersMapping)xmlMembersMapping.Accessor.Mapping;
            if (mapping.Members.Length == 1 && mapping.Members[0].Elements[0].Mapping is SpecialMapping) {
                SpecialMapping special = (SpecialMapping)mapping.Members[0].Elements[0].Mapping;
                XmlSchemaType type = ExportSpecialMapping(special, xmlMembersMapping.Accessor.Namespace, false);
                type.Name = xmlMembersMapping.Accessor.Name;
                AddSchemaItem(type, xmlMembersMapping.Accessor.Namespace, null);
                ExportRootIfNecessary(xmlMembersMapping.Scope);
                return (new XmlQualifiedName(xmlMembersMapping.Accessor.Name, xmlMembersMapping.Accessor.Namespace));
            }
            return null;
        }


        /// <include file='doc\XmlSchemaExporter.uex' path='docs/doc[@for="XmlSchemaExporter.ExportMembersMapping"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void ExportMembersMapping(XmlMembersMapping xmlMembersMapping) {
            MembersMapping mapping = (MembersMapping)xmlMembersMapping.Accessor.Mapping;
            CheckScope(xmlMembersMapping.Scope);
            if (mapping.HasWrapperElement) {
                ExportElement(xmlMembersMapping.Accessor);
            }
            else {
                foreach (MemberMapping member in mapping.Members) {
                    if (member.Attribute != null) 
                        throw new InvalidOperationException(Res.GetString(Res.XmlBareAttributeMember, member.Attribute.Name));
                    else if (member.Text != null) 
                        throw new InvalidOperationException(Res.GetString(Res.XmlBareTextMember, member.Text.Name));
                    else if (member.Elements == null || member.Elements.Length == 0)
                        continue;
                    
                    if (member.TypeDesc.IsArray && !(member.Elements[0].Mapping is ArrayMapping)) 
                        throw new InvalidOperationException(Res.GetString(Res.XmlIllegalArrayElement, member.Elements[0].Name));
                    
                    ExportElement(member.Elements[0]);
                }
            }
            ExportRootIfNecessary(xmlMembersMapping.Scope);
        }

        private static XmlSchemaType FindSchemaType(string name, XmlSchemaObjectCollection items) {
            // Have to loop through the items because schema.SchemaTypes has not been populated yet.
            foreach (object o in items) {
                XmlSchemaType type = o as XmlSchemaType;
                if (type == null)
                    continue;
                if (type.Name == name)
                    return type;
            }
            return null;
        }

        private static bool IsAnyType(XmlSchemaType schemaType) {
            XmlSchemaComplexType complexType = schemaType as XmlSchemaComplexType;
            if (complexType != null) {
                if (complexType.IsMixed && complexType.Particle is XmlSchemaSequence) {
                    XmlSchemaSequence sequence = (XmlSchemaSequence) complexType.Particle;
                    if (sequence.Items.Count == 1 && sequence.Items[0] is XmlSchemaAny)
                        return true;
                }
            }
            return false;
        }

        /// <include file='doc\XmlSchemaExporter.uex' path='docs/doc[@for="XmlSchemaExporter.ExportAnyType"]/*' />
        public string ExportAnyType(string ns) {
            string name = "any";
            int i = 1;
            XmlSchema schema = schemas[ns];
            if (schema != null) {
                while (true) {
                    XmlSchemaType schemaType = FindSchemaType(name, schema.Items);
                    if (schemaType == null)
                        break;
                    if (IsAnyType(schemaType))
                        return name;
                    i++;
                    name = "any" + i.ToString();
                }
            }

            XmlSchemaComplexType type = new XmlSchemaComplexType();
            type.Name = name;
            type.IsMixed = true;
            XmlSchemaSequence seq = new XmlSchemaSequence();
            XmlSchemaAny any = new XmlSchemaAny();
            any.MinOccurs = 0;
            any.MaxOccurs = decimal.MaxValue;
            seq.Items.Add(any);
            type.Particle = seq;
            AddSchemaItem(type, ns, null);
            return name;
        }

        void CheckScope(TypeScope scope) {
            if (this.scope == null) {
                this.scope = scope;
            }
            else if (this.scope != scope) {
                throw new InvalidOperationException(Res.GetString(Res.XmlMappingsScopeMismatch));
            }
        }

        XmlSchemaElement ExportElement(ElementAccessor accessor) {
            if (!accessor.Mapping.IncludeInSchema && !accessor.Mapping.TypeDesc.IsRoot) {
                return null;
            }
            if (accessor.Any && accessor.Name == String.Empty) throw new InvalidOperationException(Res.GetString(Res.XmlIllegalWildcard));
            XmlSchemaElement element = (XmlSchemaElement)elements[accessor];
            if (element != null) return element;
            element = new XmlSchemaElement();
            element.Name = accessor.Name;
            element.IsNillable = accessor.IsNullable;
            elements.Add(accessor, element);
            element.Form = accessor.Form;
            AddSchemaItem(element, accessor.Namespace, null);
            ExportElementMapping(element, accessor.Mapping, accessor.Namespace, accessor.Any);
            return element;
        }
        
        void CheckForDuplicateType(string newTypeName, string newNamespace) {
            XmlSchema schema = schemas[newNamespace];
            if (schema != null){
                foreach (XmlSchemaObject o in schema.Items) {
                    XmlSchemaType type = o as XmlSchemaType;
                    if ( type != null && type.Name == newTypeName)
                        throw new InvalidOperationException(Res.GetString(Res.XmlDuplicateTypeName, newTypeName, newNamespace));

                }
            }
        }

        void AddSchemaItem(XmlSchemaObject item, string ns, string referencingNs) {
            XmlSchema schema = schemas[ns];
            if (schema == null) {
                schema = new XmlSchema();
                schema.TargetNamespace = ns == null || ns.Length == 0 ? null : ns;
                schema.ElementFormDefault = elementFormDefault == XmlSchemaForm.Unqualified ? XmlSchemaForm.None : elementFormDefault;
                schema.AttributeFormDefault = attributeFormDefault == XmlSchemaForm.Unqualified ? XmlSchemaForm.None : attributeFormDefault;
                schemas.Add(schema);
            }
            if (item is XmlSchemaElement) {
                XmlSchemaElement e = (XmlSchemaElement)item;
                if (e.Form == XmlSchemaForm.Unqualified)
                    throw new InvalidOperationException(Res.GetString(Res.XmlIllegalForm, e.Name));
                e.Form = XmlSchemaForm.None;
            }
            else if (item is XmlSchemaAttribute) {
                XmlSchemaAttribute a = (XmlSchemaAttribute)item;
                if (a.Form == XmlSchemaForm.Unqualified)
                    throw new InvalidOperationException(Res.GetString(Res.XmlIllegalForm, a.Name));
                a.Form = XmlSchemaForm.None;
            }
            schema.Items.Add(item);

            if (referencingNs != null)
                AddSchemaImport(ns, referencingNs);
        }

        void AddSchemaImport(string ns, string referencingNs) {
            if (referencingNs == null || ns == null) return;
            if (ns == referencingNs) return;
            XmlSchema schema = schemas[referencingNs];
            if (schema == null) throw new InvalidOperationException(Res.GetString(Res.XmlMissingSchema, referencingNs));
            if (ns != null && ns.Length > 0 && FindImport(schema, ns) == null) {
                XmlSchemaImport import = new XmlSchemaImport();
                import.Namespace = ns;
                schema.Includes.Add(import);
            }
        }

        bool SchemaContainsItem(XmlSchemaObject item, string ns) {
            XmlSchema schema = schemas[ns];
            if (schema != null) {
                return schema.Items.Contains(item);
            }
            return false;
        }

        XmlSchemaImport FindImport(XmlSchema schema, string ns) {
            foreach (object item in schema.Includes) {
                if (item is XmlSchemaImport) {
                    XmlSchemaImport import = (XmlSchemaImport)item;
                    if (import.Namespace == ns) {
                        return import;
                    }
                }
            }
            return null;
        }

        void ExportElementMapping(XmlSchemaElement element, Mapping mapping, string ns, bool isAny) {
            if (mapping is ArrayMapping)
                element.SchemaTypeName = ExportArrayMapping((ArrayMapping)mapping, ns);
            else if (mapping is PrimitiveMapping) {
                element.SchemaTypeName = ExportPrimitiveMapping((PrimitiveMapping)mapping, ns);
            }
            else if (mapping is StructMapping)
                element.SchemaTypeName = ExportStructMapping((StructMapping)mapping, ns);
            else if (mapping is MembersMapping)
                element.SchemaType = ExportMembersMapping((MembersMapping)mapping, ns);
            else if (mapping is SpecialMapping)
                element.SchemaType = ExportSpecialMapping((SpecialMapping)mapping, ns, isAny);
            else
                throw new ArgumentException(Res.GetString(Res.XmlInternalError), "mapping");
        }

        XmlQualifiedName ExportNonXsdPrimitiveMapping(PrimitiveMapping mapping, string ns) {
            XmlSchemaSimpleType type = mapping.TypeDesc.DataType;
            if (!SchemaContainsItem(type, UrtTypes.Namespace)) {
                AddSchemaItem(type, UrtTypes.Namespace, ns);
            }
            return new XmlQualifiedName(mapping.TypeDesc.DataType.Name, UrtTypes.Namespace);
        }

        XmlSchemaType ExportSpecialMapping(SpecialMapping mapping, string ns, bool isAny) {
            switch (mapping.TypeDesc.Kind) {
                case TypeKind.Node: {
                    XmlSchemaComplexType type = new XmlSchemaComplexType();
                    type.IsMixed = mapping.TypeDesc.IsMixed;
                    XmlSchemaSequence seq = new XmlSchemaSequence();
                    XmlSchemaAny any = new XmlSchemaAny();
                    if (isAny) {
                        type.AnyAttribute = new XmlSchemaAnyAttribute();
                        type.IsMixed = true;
                        any.MaxOccurs = decimal.MaxValue;
                    }
                    seq.Items.Add(any);
                    type.Particle = seq;
                    return type;

                }
                case TypeKind.Serializable: {
                    SerializableMapping serializableMapping = (SerializableMapping)mapping;
                    XmlSchemaComplexType type = new XmlSchemaComplexType();

                    if (serializableMapping.Schema == null) {
                        XmlSchemaElement schemaElement = new XmlSchemaElement();
                        schemaElement.RefName = new XmlQualifiedName("schema", XmlSchema.Namespace);
                        XmlSchemaSequence seq = new XmlSchemaSequence();
                        seq.Items.Add(schemaElement);
                        seq.Items.Add(new XmlSchemaAny());
                        type.Particle = seq;
                        AddSchemaImport(XmlSchema.Namespace, ns);
                    } 
                    else {
                        XmlSchemaAny any = new XmlSchemaAny();
                        XmlSchemaSequence seq = new XmlSchemaSequence();
                        seq.Items.Add(any);
                        type.Particle = seq;
                        string anyNs = serializableMapping.Schema.TargetNamespace;
                        any.Namespace = anyNs == null ? "" : anyNs;
                        XmlSchema existingSchema = schemas[anyNs];
                        if (existingSchema == null) {
                            schemas.Add(serializableMapping.Schema);
                            AddSchemaImport(anyNs, ns);
                        }
                        else if (existingSchema != serializableMapping.Schema) {
                            throw new InvalidOperationException(Res.GetString(Res.XmlDuplicateNamespace, anyNs));
                        }
                    }
                    return type;
                }
                default:
                    throw new ArgumentException(Res.GetString(Res.XmlInternalError), "mapping");
            }
        }

        XmlSchemaType ExportMembersMapping(MembersMapping mapping, string ns) {
            XmlSchemaComplexType type = new XmlSchemaComplexType();
            ExportTypeMembers(type, mapping.Members, mapping.TypeName, ns, false);

            if (mapping.XmlnsMember != null) {
                AddXmlnsAnnotation(type, mapping.XmlnsMember.Name);
            }

            return type;
        }

        XmlQualifiedName ExportPrimitiveMapping(PrimitiveMapping mapping, string ns) {
            XmlQualifiedName qname;
            if (mapping is EnumMapping) {
                qname = ExportEnumMapping((EnumMapping)mapping, ns);
            }
            else {
                if (mapping.TypeDesc.IsXsdType) {
                    qname = new XmlQualifiedName(mapping.TypeDesc.DataType.Name, XmlSchema.Namespace);
                }
                else {
                    qname = ExportNonXsdPrimitiveMapping(mapping, ns);
                }
            }
            return qname;
        }

        XmlQualifiedName ExportArrayMapping(ArrayMapping mapping, string ns) {
            // some of the items in the linked list differ only by CLR type. We don't need to
            // export different schema types for these. Look further down the list for another
            // entry with the same elements. If there is one, it will be exported later so
            // just return its name now.

            ArrayMapping currentMapping = mapping;
            while (currentMapping.Next != null) {
                currentMapping = currentMapping.Next;
            }
            XmlSchemaComplexType type = (XmlSchemaComplexType) types[currentMapping];
            if (type == null) {
                CheckForDuplicateType(currentMapping.TypeName, currentMapping.Namespace);
                type = new XmlSchemaComplexType();
                type.Name = mapping.TypeName;
                types.Add(currentMapping, type);
                AddSchemaItem(type, mapping.Namespace, ns);
                XmlSchemaSequence seq = new XmlSchemaSequence();
                ExportElementAccessors(seq, mapping.Elements, true, false, mapping.Namespace);
                if (seq.Items.Count > 0) {
                    #if DEBUG
                        // we can have only one item for the array mapping
                        if (seq.Items.Count != 1) 
                            throw new InvalidOperationException(Res.GetString(Res.XmlInternalErrorDetails, "Type " + mapping.TypeName + " from namespace '" + ns + "' is an invalid array mapping"));
                    #endif
                    if (seq.Items[0] is XmlSchemaChoice) {
                        type.Particle = (XmlSchemaChoice)seq.Items[0];
                    }
                    else {
                        type.Particle = seq;
                    }
                }
            }
            else {
                AddSchemaImport(mapping.Namespace, ns);
            }
            return new XmlQualifiedName(type.Name, mapping.Namespace);
        }

        void ExportElementAccessors(XmlSchemaGroupBase group, ElementAccessor[] accessors, bool repeats, bool valueTypeOptional, string ns) {
            if (accessors.Length == 0) return;
            if (accessors.Length == 1) {
                ExportElementAccessor(group, accessors[0], repeats, valueTypeOptional, ns);
            }
            else {
                XmlSchemaChoice choice = new XmlSchemaChoice();
                choice.MaxOccurs = repeats ? decimal.MaxValue : 1;
                choice.MinOccurs = repeats ? 0 : 1;
                for (int i = 0; i < accessors.Length; i++)
                    ExportElementAccessor(choice, accessors[i], false, valueTypeOptional, ns);

                if (choice.Items.Count > 0) group.Items.Add(choice);
            }
        }

        void ExportAttributeAccessor(XmlSchemaComplexType type, AttributeAccessor accessor, bool valueTypeOptional, string ns) {
            if (accessor == null) return;
            XmlSchemaObjectCollection attributes;

            if (type.ContentModel != null) {
                if (type.ContentModel.Content is XmlSchemaComplexContentRestriction)
                    attributes = ((XmlSchemaComplexContentRestriction)type.ContentModel.Content).Attributes;
                else if (type.ContentModel.Content is XmlSchemaComplexContentExtension)
                    attributes = ((XmlSchemaComplexContentExtension)type.ContentModel.Content).Attributes;
                else if (type.ContentModel.Content is XmlSchemaSimpleContentExtension)
                    attributes = ((XmlSchemaSimpleContentExtension)type.ContentModel.Content).Attributes;
                else
                    throw new InvalidOperationException(Res.GetString(Res.XmlInvalidContent, type.ContentModel.Content.GetType().Name));
            }
            else {
                attributes = type.Attributes;
            }

            if (accessor.IsSpecialXmlNamespace) {

                // add <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
                AddSchemaImport(XmlReservedNs.NsXml, ns);

                // generate <xsd:attribute ref="xml:lang" use="optional" />
                XmlSchemaAttribute attribute = new XmlSchemaAttribute();
                attribute.Use = XmlSchemaUse.Optional;
                attribute.RefName = new XmlQualifiedName(accessor.Name, XmlReservedNs.NsXml);
                attributes.Add(attribute);
            }
            else if (accessor.Any) {
                if (type.ContentModel == null) {
                    type.AnyAttribute = new XmlSchemaAnyAttribute();
                }
                else {
                    XmlSchemaContent content = type.ContentModel.Content;
                    if (content is XmlSchemaComplexContentExtension) {
                        XmlSchemaComplexContentExtension extension = (XmlSchemaComplexContentExtension)content;
                        extension.AnyAttribute = new XmlSchemaAnyAttribute();
                    }
                    else if (content is XmlSchemaComplexContentRestriction) {
                        XmlSchemaComplexContentRestriction restriction = (XmlSchemaComplexContentRestriction)content;
                        restriction.AnyAttribute = new XmlSchemaAnyAttribute();
                    }
                }
            }
            else {
                XmlSchemaAttribute attribute = new XmlSchemaAttribute();
                attribute.Use = XmlSchemaUse.None;
                if (!accessor.HasDefault && !valueTypeOptional && accessor.Mapping.TypeDesc.IsValueType) {
                    attribute.Use = XmlSchemaUse.Required;
                }
                attribute.Name = accessor.Name;
                if (accessor.Namespace == null || accessor.Namespace == ns) {
                    // determine the form attribute value
                    XmlSchema schema = schemas[ns];
                    if (schema == null)
                        attribute.Form = accessor.Form == attributeFormDefault ? XmlSchemaForm.None : accessor.Form;
                    else {
                        attribute.Form = accessor.Form == schema.AttributeFormDefault ? XmlSchemaForm.None : accessor.Form;
                    }
                    attributes.Add(attribute);
                }
                else {
                    // we are going to add the attribute to the top-level items. "use" attribute should not be set
                    attribute.Use = XmlSchemaUse.None;
                    attribute.Form = accessor.Form;
                    AddSchemaItem(attribute, accessor.Namespace, ns);
                    XmlSchemaAttribute refAttribute = new XmlSchemaAttribute();
                    refAttribute.Use = XmlSchemaUse.None;
                    refAttribute.RefName = new XmlQualifiedName(accessor.Name, accessor.Namespace);
                    attributes.Add(refAttribute);
                }
                if (accessor.Mapping is PrimitiveMapping) {
                    PrimitiveMapping pm = (PrimitiveMapping)accessor.Mapping;
                    if (pm.IsList) {
                        // create local simple type for the list-like attributes
                        XmlSchemaSimpleType dataType = new XmlSchemaSimpleType();
                        XmlSchemaSimpleTypeList list = new XmlSchemaSimpleTypeList();
                        list.ItemTypeName = ExportPrimitiveMapping(pm, accessor.Namespace == null ? ns : accessor.Namespace);
                        dataType.Content = list;
                        attribute.SchemaType = dataType;
                    }
                    else {
                        attribute.SchemaTypeName = ExportPrimitiveMapping(pm, accessor.Namespace == null ? ns : accessor.Namespace);
                    }
                }
                else if (!(accessor.Mapping is SpecialMapping))
                    throw new InvalidOperationException(Res.GetString(Res.XmlInternalError));

                if (accessor.HasDefault && accessor.Mapping.TypeDesc.HasDefaultSupport) {
                    attribute.DefaultValue = ExportDefaultValue(accessor.Mapping, accessor.Default);
                }
            }
        }

        void ExportElementAccessor(XmlSchemaGroupBase group, ElementAccessor accessor, bool repeats, bool valueTypeOptional, string ns) {
            if (accessor.Any  && accessor.Name == String.Empty) {
                XmlSchemaAny any = new XmlSchemaAny();
                any.MinOccurs = 0;
                any.MaxOccurs = repeats ? decimal.MaxValue : 1;
                group.Items.Add(any);
            }
            else {
                XmlSchemaElement element = (XmlSchemaElement)elements[accessor];
                int minOccurs = repeats || accessor.HasDefault || (!accessor.IsNullable && !accessor.Mapping.TypeDesc.IsValueType) || valueTypeOptional ? 0 : 1;
                decimal maxOccurs = repeats ? decimal.MaxValue : 1;

                if (element == null) {
                    element = new XmlSchemaElement();
                    element.IsNillable = accessor.IsNullable;
                    element.Name = accessor.Name;
                    if (accessor.HasDefault && accessor.Mapping.TypeDesc.HasDefaultSupport)
                        element.DefaultValue = ExportDefaultValue(accessor.Mapping, accessor.Default);

                    if (accessor.IsTopLevelInSchema) {
                        elements.Add(accessor, element);
                        element.Form = accessor.Form;
                        AddSchemaItem(element, accessor.Namespace, ns);
                    }
                    else {
                        element.MinOccurs = minOccurs;
                        element.MaxOccurs = maxOccurs;
                        // determine the form attribute value
                        XmlSchema schema = schemas[ns];
                        if (schema == null)
                            element.Form = accessor.Form == elementFormDefault ? XmlSchemaForm.None : accessor.Form;
                        else {
                            element.Form = accessor.Form == schema.ElementFormDefault ? XmlSchemaForm.None : accessor.Form;
                        }
                    }
                    ExportElementMapping(element, (TypeMapping)accessor.Mapping, accessor.Namespace, accessor.Any);
                }
                if (accessor.IsTopLevelInSchema) {
                    AddSchemaImport(accessor.Namespace, ns);
                    XmlSchemaElement refElement = new XmlSchemaElement();
                    refElement.RefName = new XmlQualifiedName(accessor.Name, accessor.Namespace);
                    refElement.MinOccurs = minOccurs;
                    refElement.MaxOccurs = maxOccurs;
                    group.Items.Add(refElement);
                }
                else {
                    group.Items.Add(element);
                }
            }
        }

        static internal string ExportDefaultValue(TypeMapping mapping, object value) {
            #if DEBUG
                // use exception in the place of Debug.Assert to avoid throwing asserts from a server process such as aspnet_ewp.exe
                if (!(mapping is PrimitiveMapping)) {
                    throw new InvalidOperationException(Res.GetString(Res.XmlInternalErrorDetails, "Mapping " + mapping.GetType() + ", should not have Default"));
                }
                else if (mapping.IsList) {
                    throw new InvalidOperationException(Res.GetString(Res.XmlInternalErrorDetails, "Mapping " + mapping.GetType() + ", should not have Default"));
                }
            #endif


            if (mapping is EnumMapping) {
                EnumMapping em = (EnumMapping)mapping;

                #if DEBUG
                    // use exception in the place of Debug.Assert to avoid throwing asserts from a server process such as aspnet_ewp.exe
                    if (value.GetType() != typeof(string)) throw new InvalidOperationException(Res.GetString(Res.XmlInternalErrorDetails, Res.GetString(Res.XmlInvalidDefaultValue, value.ToString(), value.GetType().FullName)));
                #endif

                // check the validity of the value
                ConstantMapping[] c = em.Constants;
                if (em.IsFlags) {
                    string[] names = new string[c.Length];
                    long[] ids = new long[c.Length];
                    Hashtable values = new Hashtable();
                    for (int i = 0; i < c.Length; i++) {
                        names[i] = c[i].XmlName;
                        ids[i] = 1 << i;
                        values.Add(c[i].Name, ids[i]);
                    }
                    long val = XmlCustomFormatter.ToEnum((string)value, values, em.TypeName, false);
                    return val != 0 ? XmlCustomFormatter.FromEnum(val, names, ids) : null;
                }
                else {
                    for (int i = 0; i < c.Length; i++) {
                        if (c[i].Name == (string)value) {
                            return c[i].XmlName;
                        }
                    }
                    return null; // unknown value
                }
            }
            
            PrimitiveMapping pm = (PrimitiveMapping)mapping;

            if (!pm.TypeDesc.HasCustomFormatter) {

                #if DEBUG
                    // use exception in the place of Debug.Assert to avoid throwing asserts from a server process such as aspnet_ewp.exe
                    if (pm.TypeDesc.Type == null) {
                        throw new InvalidOperationException(Res.GetString(Res.XmlInternalErrorDetails, "Mapping for " + pm.TypeDesc.Name + " missing type property"));
                    }
                #endif

                if (pm.TypeDesc.FormatterName == "String")
                    return (string)value;

                Type formatter = typeof(XmlConvert);
                System.Reflection.MethodInfo format = formatter.GetMethod("ToString", new Type[] { pm.TypeDesc.Type });
                if (format != null)
                    return (string)format.Invoke(formatter, new Object[] {value});
            }
            else {
                string defaultValue = XmlCustomFormatter.FromDefaultValue(value, pm.TypeDesc.FormatterName);
                if (defaultValue == null)
                    throw new InvalidOperationException(Res.GetString(Res.XmlInvalidDefaultValue, value.ToString(), pm.TypeDesc.Name));
                return defaultValue;
            }
            throw new InvalidOperationException(Res.GetString(Res.XmlInvalidDefaultValue, value.ToString(), pm.TypeDesc.Name));
        }

        void ExportRootIfNecessary(TypeScope typeScope) {
            if (!needToExportRoot)
                return;
            foreach (TypeMapping mapping in typeScope.TypeMappings) {
                if (mapping is StructMapping && mapping.TypeDesc.IsRoot)
                    ExportDerivedMappings((StructMapping) mapping);
                else if (mapping is ArrayMapping) {
                    ExportArrayMapping((ArrayMapping) mapping, mapping.Namespace);
                }
            }
        }

        XmlQualifiedName ExportStructMapping(StructMapping mapping, string ns) {
            if (mapping.TypeDesc.IsRoot) {
                needToExportRoot = true;
                return XmlQualifiedName.Empty;
            }
            XmlSchemaComplexType type = (XmlSchemaComplexType)types[mapping];
            if (type == null) {
                if (!mapping.IncludeInSchema) throw new InvalidOperationException(Res.GetString(Res.XmlCannotIncludeInSchema, mapping.TypeDesc.Name));
                CheckForDuplicateType(mapping.TypeName, mapping.Namespace);
                type = new XmlSchemaComplexType();
                type.Name = mapping.TypeName;
                types.Add(mapping, type);
                AddSchemaItem(type, mapping.Namespace, ns);
                type.IsAbstract = mapping.TypeDesc.IsAbstract;

                if (mapping.BaseMapping != null && mapping.BaseMapping.IncludeInSchema) {
                    if (mapping.HasSimpleContent) {
                        XmlSchemaSimpleContent model = new XmlSchemaSimpleContent();
                        XmlSchemaSimpleContentExtension extension = new XmlSchemaSimpleContentExtension();
                        extension.BaseTypeName = ExportStructMapping(mapping.BaseMapping, mapping.Namespace);
                        model.Content = extension;
                        type.ContentModel = model;
                    }
                    else {
                        XmlSchemaComplexContentExtension extension = new XmlSchemaComplexContentExtension();
                        extension.BaseTypeName = ExportStructMapping(mapping.BaseMapping, mapping.Namespace);
                        XmlSchemaComplexContent model = new XmlSchemaComplexContent();
                        model.Content = extension;
                        model.IsMixed = XmlSchemaImporter.IsMixed((XmlSchemaComplexType)types[mapping.BaseMapping]);
                        type.ContentModel = model;
                    }
                }
                ExportTypeMembers(type, mapping.Members, mapping.TypeName, mapping.Namespace, mapping.HasSimpleContent);
                ExportDerivedMappings(mapping);
                if (mapping.XmlnsMember != null) {
                    AddXmlnsAnnotation(type, mapping.XmlnsMember.Name);
                }
            }
            else {
                AddSchemaImport(mapping.Namespace, ns);
            }
            return new XmlQualifiedName(type.Name, mapping.Namespace);
        }

        void ExportTypeMembers(XmlSchemaComplexType type, MemberMapping[] members, string name, string ns, bool hasSimpleContent) {
            XmlSchemaGroupBase seq = new XmlSchemaSequence();
            TypeMapping textMapping = null;
            
            for (int i = 0; i < members.Length; i++) {
                MemberMapping member = members[i];
                if (member.Ignore)
                    continue;
                if (member.Text != null) {
                    if (textMapping != null) {
                        throw new InvalidOperationException(Res.GetString(Res.XmlIllegalMultipleText, name));
                    }
                    textMapping = member.Text.Mapping;
                }
                if (member.Elements.Length > 0) {
                    bool repeats = member.TypeDesc.IsArrayLike && 
                        !(member.Elements.Length == 1 && member.Elements[0].Mapping is ArrayMapping);
                    bool valueTypeOptional = member.CheckSpecified || member.CheckShouldPersist;
                    ExportElementAccessors(seq, member.Elements, repeats, valueTypeOptional, ns);
                }
            }

            if (seq.Items.Count > 0) {
                if (type.ContentModel != null) {
                    if (type.ContentModel.Content is XmlSchemaComplexContentRestriction)
                        ((XmlSchemaComplexContentRestriction)type.ContentModel.Content).Particle = seq;
                    else if (type.ContentModel.Content is XmlSchemaComplexContentExtension)
                        ((XmlSchemaComplexContentExtension)type.ContentModel.Content).Particle = seq;
                    else
                        throw new InvalidOperationException(Res.GetString(Res.XmlInvalidContent, type.ContentModel.Content.GetType().Name));
                }
                else {
                    type.Particle = seq;
                }
            }
            if (textMapping != null) {
                if (hasSimpleContent) {
                    if (textMapping is PrimitiveMapping && seq.Items.Count == 0) {
                        PrimitiveMapping pm = (PrimitiveMapping)textMapping;
                        if (pm.IsList) {
                            type.IsMixed = true;
                        }
                        else {
                            // Create simpleContent
                            XmlSchemaSimpleContent model = new XmlSchemaSimpleContent();
                            XmlSchemaSimpleContentExtension ex = new XmlSchemaSimpleContentExtension();
                            model.Content = ex;
                            type.ContentModel = model;
                            ex.BaseTypeName = ExportPrimitiveMapping(pm, ns);
                        }
                    }
                }
                else {
                    type.IsMixed = true;
                }
            }
            for (int i = 0; i < members.Length; i++) {
                ExportAttributeAccessor(type, members[i].Attribute, members[i].CheckSpecified || members[i].CheckShouldPersist, ns);
            }
        }

        void ExportDerivedMappings(StructMapping mapping) {
            for (StructMapping derived = mapping.DerivedMappings; derived != null; derived = derived.NextDerivedMapping) {
                if (derived.IncludeInSchema) ExportStructMapping(derived, mapping.TypeDesc.IsRoot ? null : mapping.Namespace);
            }
        }

        XmlQualifiedName ExportEnumMapping(EnumMapping mapping, string ns) {
            if (!mapping.IncludeInSchema) throw new InvalidOperationException(Res.GetString(Res.XmlCannotIncludeInSchema, mapping.TypeDesc.Name));
            XmlSchemaSimpleType dataType = (XmlSchemaSimpleType)types[mapping];
            if (dataType == null) {
                CheckForDuplicateType(mapping.TypeName, mapping.Namespace);
                dataType = new XmlSchemaSimpleType();
                dataType.Name = mapping.TypeName;
                types.Add(mapping, dataType);
                AddSchemaItem(dataType, mapping.Namespace, ns);

                XmlSchemaSimpleTypeRestriction restriction = new XmlSchemaSimpleTypeRestriction();
                restriction.BaseTypeName = new XmlQualifiedName("string", XmlSchema.Namespace);

                for (int i = 0; i < mapping.Constants.Length; i++) {
                    ConstantMapping constant = mapping.Constants[i];
                    XmlSchemaEnumerationFacet enumeration = new XmlSchemaEnumerationFacet();
                    enumeration.Value = constant.XmlName;
                    restriction.Facets.Add(enumeration);
                }
                if (!mapping.IsFlags) {
                    dataType.Content = restriction;
                }
                else {
                    XmlSchemaSimpleTypeList list = new XmlSchemaSimpleTypeList();
                    XmlSchemaSimpleType enumType = new XmlSchemaSimpleType();
                    enumType.Content =  restriction;
                    list.ItemType = enumType;
                    dataType.Content =  list;
                }
            }
            else {
                AddSchemaImport(mapping.Namespace, ns);
            }
            return new XmlQualifiedName(dataType.Name, mapping.Namespace);
        }

        void AddXmlnsAnnotation(XmlSchemaComplexType type, string xmlnsMemberName) {
            XmlSchemaAnnotation annotation = new XmlSchemaAnnotation();
            XmlSchemaAppInfo appinfo = new XmlSchemaAppInfo();

            XmlDocument d = new XmlDocument();
            XmlElement e = d.CreateElement("keepNamespaceDeclarations");
            if (xmlnsMemberName != null)
                e.InsertBefore(d.CreateTextNode(xmlnsMemberName), null);
            appinfo.Markup = new XmlNode[] {e};
            annotation.Items.Add(appinfo);
            type.Annotation = annotation;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\serialization\xmlreflectionmember.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlReflectionMember.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Serialization {

    using System;

    /// <include file='doc\XmlReflectionMember.uex' path='docs/doc[@for="XmlReflectionMember"]/*' />
    ///<internalonly/>
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public class XmlReflectionMember {
        string memberName;
        Type type;
        XmlAttributes xmlAttributes = new XmlAttributes();
        SoapAttributes soapAttributes = new SoapAttributes();
        bool isReturnValue;
        bool overrideIsNullable;

        /// <include file='doc\XmlReflectionMember.uex' path='docs/doc[@for="XmlReflectionMember.MemberType"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public Type MemberType {
            get { return type; }
            set { type = value; }
        }

        /// <include file='doc\XmlReflectionMember.uex' path='docs/doc[@for="XmlReflectionMember.XmlAttributes"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public XmlAttributes XmlAttributes {
            get { return xmlAttributes; }
            set { xmlAttributes = value; }
        }

        /// <include file='doc\XmlReflectionMember.uex' path='docs/doc[@for="XmlReflectionMember.SoapAttributes"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public SoapAttributes SoapAttributes {
            get { return soapAttributes; }
            set { soapAttributes = value; }
        }

        /// <include file='doc\XmlReflectionMember.uex' path='docs/doc[@for="XmlReflectionMember.MemberName"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public string MemberName {
            get { return memberName == null ? string.Empty : memberName; }
            set { memberName = value; }
        }

        /// <include file='doc\XmlReflectionMember.uex' path='docs/doc[@for="XmlReflectionMember.IsReturnValue"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public bool IsReturnValue {
            get { return isReturnValue; }
            set { isReturnValue = value; }
        }

        /// <include file='doc\XmlReflectionMember.uex' path='docs/doc[@for="XmlReflectionMember.OverrideIsNullable"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public bool OverrideIsNullable {
            get { return overrideIsNullable; }
            set { overrideIsNullable = value; }
        }
    }


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\serialization\xmlreflectionimporter.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlReflectionImporter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Serialization {

    using System.Reflection;
    using System;
    using System.Xml.Schema;
    using System.Collections;
    using System.ComponentModel;
    using System.Globalization;

    /// <include file='doc\XmlReflectionImporter.uex' path='docs/doc[@for="XmlReflectionImporter"]/*' />
    ///<internalonly/>
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public class XmlReflectionImporter {
        TypeScope typeScope;
        XmlAttributeOverrides attributeOverrides;
        NameTable types = new NameTable();      // xmltypename + xmlns -> Mapping
        NameTable elements = new NameTable();   // xmlelementname + xmlns -> ElementAccessor
        Hashtable specials = new Hashtable();   // type -> SpecialMapping
        StructMapping root;
        string defaultNs;
        ModelScope modelScope;
        int arrayNestingLevel;
        XmlArrayItemAttributes savedArrayItemAttributes;
        string savedArrayNamespace;
        int choiceNum = 1;

        enum ImportContext {
            Text,
            Attribute,
            Element
        }
        
        /// <include file='doc\XmlReflectionImporter.uex' path='docs/doc[@for="XmlReflectionImporter.XmlReflectionImporter"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public XmlReflectionImporter() : this(null, null) {
        }

        /// <include file='doc\XmlReflectionImporter.uex' path='docs/doc[@for="XmlReflectionImporter.XmlReflectionImporter1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public XmlReflectionImporter(string defaultNamespace) : this(null, defaultNamespace) {
        }

        /// <include file='doc\XmlReflectionImporter.uex' path='docs/doc[@for="XmlReflectionImporter.XmlReflectionImporter2"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public XmlReflectionImporter(XmlAttributeOverrides attributeOverrides) : this(attributeOverrides, null) {
        }

        /// <include file='doc\XmlReflectionImporter.uex' path='docs/doc[@for="XmlReflectionImporter.XmlReflectionImporter3"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public XmlReflectionImporter(XmlAttributeOverrides attributeOverrides, string defaultNamespace) {
            if (defaultNamespace == null)
                defaultNamespace = String.Empty;
            if (attributeOverrides == null)
                attributeOverrides = new XmlAttributeOverrides();
            this.attributeOverrides = attributeOverrides;
            this.defaultNs = defaultNamespace;
            this.typeScope = new TypeScope();
            this.modelScope = new ModelScope(this.typeScope);
        }

        /// <include file='doc\XmlReflectionImporter.uex' path='docs/doc[@for="XmlReflectionImporter.IncludeTypes"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void IncludeTypes(ICustomAttributeProvider provider) {
            object[] attrs = provider.GetCustomAttributes(typeof(XmlIncludeAttribute), false);
            for (int i = 0; i < attrs.Length; i++) {
                Type type = ((XmlIncludeAttribute)attrs[i]).Type;
                if (typeof(IXmlSerializable).IsAssignableFrom(type)){
                    throw new InvalidOperationException(Res.GetString(Res.XmlIncludeSerializableError, type.FullName, typeof(IXmlSerializable).FullName));
                }
                else
                    IncludeType(type);
            }
        }

        /// <include file='doc\XmlReflectionImporter.uex' path='docs/doc[@for="XmlReflectionImporter.IncludeType"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void IncludeType(Type type) {
            int previousNestingLevel = arrayNestingLevel;
            XmlArrayItemAttributes previousArrayItemAttributes = savedArrayItemAttributes;
            string previousArrayNamespace = savedArrayNamespace;
            arrayNestingLevel = 0;
            savedArrayItemAttributes = null;
            savedArrayNamespace = null;

            ImportTypeMapping(modelScope.GetTypeModel(type), defaultNs, ImportContext.Element, string.Empty);

            arrayNestingLevel = previousNestingLevel;
            savedArrayItemAttributes = previousArrayItemAttributes;
            savedArrayNamespace = previousArrayNamespace;
        }

        /// <include file='doc\XmlReflectionImporter.uex' path='docs/doc[@for="XmlReflectionImporter.ImportTypeMapping"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public XmlTypeMapping ImportTypeMapping(Type type) {
            return ImportTypeMapping(type, null, null);
        }

        /// <include file='doc\XmlReflectionImporter.uex' path='docs/doc[@for="XmlReflectionImporter.ImportTypeMapping1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public XmlTypeMapping ImportTypeMapping(Type type, string defaultNamespace) {
            return ImportTypeMapping(type, null, defaultNamespace);
        }

        /// <include file='doc\XmlReflectionImporter.uex' path='docs/doc[@for="XmlReflectionImporter.ImportTypeMapping2"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public XmlTypeMapping ImportTypeMapping(Type type, XmlRootAttribute root) {
            return ImportTypeMapping(type, root, null);
        }

        /// <include file='doc\XmlReflectionImporter.uex' path='docs/doc[@for="XmlReflectionImporter.ImportTypeMapping3"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public XmlTypeMapping ImportTypeMapping(Type type, XmlRootAttribute root, string defaultNamespace) {
            XmlTypeMapping xmlMapping = new XmlTypeMapping(typeScope, ImportElement(modelScope.GetTypeModel(type), root, defaultNamespace));
            xmlMapping.GenerateSerializer = true;
            return xmlMapping;
        }

        /// <include file='doc\XmlReflectionImporter.uex' path='docs/doc[@for="XmlReflectionImporter.ImportMembersMapping"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public XmlMembersMapping ImportMembersMapping(string elementName, string ns, XmlReflectionMember[] members, bool hasWrapperElement) {
            ElementAccessor element = new ElementAccessor();
            element.Name = Accessor.EscapeName(elementName, false);
            element.Namespace = ns;
            MembersMapping membersMapping = ImportMembersMapping(members, ns, hasWrapperElement);
            element.Mapping = membersMapping;
            element.Form = XmlSchemaForm.Qualified;   // elements within soap:body are always qualified
            if (hasWrapperElement)
                element = ReconcileAccessor(element);
            else {
                foreach (MemberMapping mapping in membersMapping.Members) {
                    if (mapping.Elements != null && mapping.Elements.Length > 0) {
                        mapping.Elements[0] = ReconcileAccessor(mapping.Elements[0]);
                    }
                }
            }
            XmlMembersMapping xmlMapping = new XmlMembersMapping(typeScope, element);
            xmlMapping.GenerateSerializer = true;
            return xmlMapping;
        }

        XmlAttributes GetAttributes(Type type) {
            XmlAttributes attrs = attributeOverrides[type];
            if (attrs != null) return attrs;
            return new XmlAttributes(type);
        }

        XmlAttributes GetAttributes(MemberInfo memberInfo) {
            XmlAttributes attrs = attributeOverrides[memberInfo.DeclaringType, memberInfo.Name];
            if (attrs != null) return attrs;
            return new XmlAttributes(memberInfo);
        }

        ElementAccessor ImportElement(TypeModel model, XmlRootAttribute root, string defaultNamespace) {
            XmlAttributes a = GetAttributes(model.Type);

            if (root == null)
                root = a.XmlRoot;
            string ns = root == null ? null : root.Namespace;
            if (ns == null) ns = defaultNamespace;
            if (ns == null) ns = this.defaultNs;

            arrayNestingLevel = -1;
            savedArrayItemAttributes = null;
            savedArrayNamespace = null;
            ElementAccessor element = CreateElementAccessor(ImportTypeMapping(model, ns, ImportContext.Element, string.Empty, false), ns);

            if (root != null) {
                if (root.ElementName.Length > 0)
                    element.Name = Accessor.EscapeName(root.ElementName, false);
                element.IsNullable = root.IsNullableSpecified ? root.IsNullable : model.TypeDesc.IsNullable;
                CheckNullable(element.IsNullable, model.TypeDesc);
            }
            else
                element.IsNullable = model.TypeDesc.IsNullable;
            element.Form = XmlSchemaForm.Qualified;
            return ReconcileAccessor(element);
        }

        static string GetMappingName(Mapping mapping) {
            if (mapping is MembersMapping)
                return "(method)";
            else if (mapping is TypeMapping)
                return ((TypeMapping)mapping).TypeDesc.FullName;
            else
                throw new ArgumentException(Res.GetString(Res.XmlInternalError), "mapping");
        }

        ElementAccessor ReconcileLocalAccessor(ElementAccessor accessor, string ns) {
            if (accessor.Namespace == ns) return accessor;
            return ReconcileAccessor(accessor);
        }

        ElementAccessor ReconcileAccessor(ElementAccessor accessor) {
            if (accessor.Any && accessor.Name == String.Empty) return accessor;

            ElementAccessor existing = (ElementAccessor)elements[accessor.Name, accessor.Namespace];
            if (existing == null) {
                accessor.IsTopLevelInSchema = true;
                elements.Add(accessor.Name, accessor.Namespace, accessor);
                return accessor;
            }

            if (existing.Mapping == accessor.Mapping) 
                return existing;

            if (!(accessor.Mapping is MembersMapping) && !(existing.Mapping is MembersMapping)) {
                if (accessor.Mapping.TypeDesc == existing.Mapping.TypeDesc)
                    return existing;
            }

            if (accessor.Mapping is MembersMapping || existing.Mapping is MembersMapping)
                throw new InvalidOperationException(Res.GetString(Res.XmlMethodTypeNameConflict, accessor.Name, accessor.Namespace));

            if (accessor.Mapping is ArrayMapping) {
                if (!(existing.Mapping is ArrayMapping)) {
                    throw new InvalidOperationException(Res.GetString(Res.XmlCannotReconcileAccessor, accessor.Name, accessor.Namespace, GetMappingName(existing.Mapping), GetMappingName(accessor.Mapping)));        
                }
                ArrayMapping mapping = (ArrayMapping)accessor.Mapping;
                ArrayMapping existingMapping = (ArrayMapping)types[existing.Mapping.TypeName, existing.Mapping.Namespace];
                ArrayMapping first = existingMapping;
                while (existingMapping != null) {
                    if (existingMapping == accessor.Mapping)
                        return existing;
                    existingMapping = existingMapping.Next;
                }
                mapping.Next = first;
                types[existing.Mapping.TypeName, existing.Mapping.Namespace] = mapping;
                return existing;
            }
            throw new InvalidOperationException(Res.GetString(Res.XmlCannotReconcileAccessor, accessor.Name, accessor.Namespace, GetMappingName(existing.Mapping), GetMappingName(accessor.Mapping)));
        }

        Exception CreateReflectionException(string context, Exception e) {
            return new InvalidOperationException(Res.GetString(Res.XmlReflectionError, context), e);
        }

        Exception CreateTypeReflectionException(string context, Exception e) {
            return new InvalidOperationException(Res.GetString(Res.XmlTypeReflectionError, context), e);
        }

        Exception CreateMemberReflectionException(FieldModel model, Exception e) {
            return new InvalidOperationException(Res.GetString(model.IsProperty ? Res.XmlPropertyReflectionError : Res.XmlFieldReflectionError, model.Name), e);
        }

        internal TypeScope TypeScope {
            get { return typeScope; }
        }

        TypeMapping ImportTypeMapping(TypeModel model, string ns, ImportContext context, string dataType) {
            return ImportTypeMapping(model, ns, context, dataType, false);
        }

        TypeMapping ImportTypeMapping(TypeModel model, string ns, ImportContext context, string dataType, bool repeats) {
            try {
                if (dataType.Length > 0) {
                    if (!model.TypeDesc.IsPrimitive) {
                        throw new InvalidOperationException(Res.GetString(Res.XmlInvalidDataTypeUsage, dataType, "XmlElementAttribute.DataType"));
                    }
                    TypeDesc td = typeScope.GetTypeDesc(new XmlQualifiedName(dataType, XmlSchema.Namespace));
                    if (td == null) {
                        throw new InvalidOperationException(Res.GetString(Res.XmlInvalidXsdDataType, dataType, "XmlElementAttribute.DataType", new XmlQualifiedName(dataType, XmlSchema.Namespace).ToString()));
                    }
                    if (model.TypeDesc.FullName != td.FullName) {
                        throw new InvalidOperationException(Res.GetString(Res.XmlDataTypeMismatch, dataType, "XmlElementAttribute.DataType", model.TypeDesc.FullName));
                    }
                }

                XmlAttributes a = GetAttributes(model.Type);
                
                if ((a.XmlFlags & ~(XmlAttributeFlags.Type | XmlAttributeFlags.Root)) != 0)
                    throw new InvalidOperationException(Res.GetString(Res.XmlInvalidTypeAttributes, model.Type.FullName));

                switch (model.TypeDesc.Kind) {
                    case TypeKind.Enum: 
                        return ImportEnumMapping((EnumModel)model, ns, repeats);
                    case TypeKind.Primitive:
                        if (a.XmlFlags != 0) throw InvalidAttributeUseException(model.Type);
                        return ImportPrimitiveMapping((PrimitiveModel)model, context, dataType, repeats);
                    case TypeKind.Array:
                    case TypeKind.Collection:
                    case TypeKind.Enumerable:
                        if (a.XmlFlags != 0) throw InvalidAttributeUseException(model.Type);
                        if (context != ImportContext.Element) throw UnsupportedException(model.TypeDesc, context);
                        arrayNestingLevel++;
                        ArrayMapping arrayMapping = ImportArrayLikeMapping((ArrayModel)model, ns);
                        arrayNestingLevel--;
                        return arrayMapping;
                    case TypeKind.Root:
                    case TypeKind.Class:
                    case TypeKind.Struct:
                    case TypeKind.Interface:
                        if (context != ImportContext.Element) throw UnsupportedException(model.TypeDesc, context);
                        return ImportStructLikeMapping((StructModel)model, ns);
                    default:
                        if (a.XmlFlags != 0) throw InvalidAttributeUseException(model.Type);
                        if (model.TypeDesc.IsSpecial)
                            return ImportSpecialMapping(model.Type, model.TypeDesc, ns, context);
                        throw UnsupportedException(model.TypeDesc, context);
                }
            }
            catch (Exception e) {
                throw CreateTypeReflectionException(model.TypeDesc.FullName, e);
            }
        }
        
        SpecialMapping ImportSpecialMapping(Type type, TypeDesc typeDesc, string ns, ImportContext context) {
            SpecialMapping mapping = (SpecialMapping)specials[type];
            if (mapping != null) {
                CheckContext(mapping.TypeDesc, context);
                return mapping;
            }
            if (typeDesc.Kind == TypeKind.Serializable) {
                SerializableMapping serializableMapping = new SerializableMapping();
                serializableMapping.Type = type;
                mapping = serializableMapping;
            }
            else {
                mapping = new SpecialMapping();
            }
            mapping.TypeDesc = typeDesc;
            mapping.TypeName = typeDesc.Name;
            CheckContext(typeDesc, context);
            specials.Add(type, mapping);
            return mapping;
        }

        static string GetContextName(ImportContext context) {
            switch (context) {
                case ImportContext.Element: return "element";
                case ImportContext.Attribute: return "attribute";
                case ImportContext.Text: return "text";
                default:
                    throw new ArgumentException(Res.GetString(Res.XmlInternalError), "context");
            }
        }

        static Exception InvalidAttributeUseException(Type type) {
            return new InvalidOperationException(Res.GetString(Res.XmlInvalidAttributeUse, type.FullName));
        }

        static Exception UnsupportedException(TypeDesc typeDesc, ImportContext context) {
            return new InvalidOperationException(Res.GetString(Res.XmlIllegalTypeContext, typeDesc.FullName, GetContextName(context)));
        }

        StructMapping CreateRootMapping() {
            TypeDesc typeDesc = typeScope.GetTypeDesc(typeof(object));
            StructMapping mapping = new StructMapping();
            mapping.TypeDesc = typeDesc;
            mapping.TypeName = Soap.UrType;
            mapping.Namespace = XmlSchema.Namespace;
            mapping.Members = new MemberMapping[0];
            mapping.IncludeInSchema = false;
            return mapping;
        }

        StructMapping GetRootMapping() {
            if (root == null) {
                root = CreateRootMapping();
                typeScope.AddTypeMapping(root);
            }
            return root;
        }

        TypeMapping GetTypeMapping(string typeName, string ns, TypeDesc typeDesc) {
            TypeMapping mapping = (TypeMapping)types[typeName, ns];
            if (mapping == null) return null;
            if (mapping.TypeDesc != typeDesc) 
                throw new InvalidOperationException(Res.GetString(Res.XmlTypesDuplicate, typeDesc.FullName, mapping.TypeDesc.FullName, typeName, ns));
            return mapping;
        }

        StructMapping ImportStructLikeMapping(StructModel model, string ns) {
            if (model.TypeDesc.Kind == TypeKind.Root) return GetRootMapping();
            XmlAttributes a = GetAttributes(model.Type);

            string typeNs = ns;
            if (a.XmlType != null && a.XmlType.Namespace != null)
                typeNs = a.XmlType.Namespace;
            else if (a.XmlRoot != null && a.XmlRoot.Namespace != null)
                typeNs = a.XmlRoot.Namespace;

            string typeName = string.Empty;
            if (a.XmlType != null)
                typeName = a.XmlType.TypeName;
            if (typeName.Length == 0) 
                typeName = model.TypeDesc.Name;

            StructMapping mapping = (StructMapping)GetTypeMapping(typeName, typeNs, model.TypeDesc);
            if (mapping == null) {
                mapping = new StructMapping();
                mapping.TypeDesc = model.TypeDesc;
                mapping.Namespace = typeNs;
                mapping.TypeName = typeName;
                typeScope.AddTypeMapping(mapping);
                types.Add(typeName, typeNs, mapping);
                if (a.XmlType != null) {
                    mapping.IncludeInSchema = a.XmlType.IncludeInSchema;
                }
                if (model.TypeDesc.BaseTypeDesc != null) {
                    mapping.BaseMapping = ImportStructLikeMapping((StructModel)modelScope.GetTypeModel(model.Type.BaseType, false), mapping.Namespace);
                    ICollection values = mapping.BaseMapping.LocalElements.Values;
                    foreach (ElementAccessor e in values) {
                        AddUniqueAccessor(mapping.LocalElements, e);
                    }
                    values = mapping.BaseMapping.LocalAttributes.Values;
                    foreach (AttributeAccessor attribute in values) {
                        AddUniqueAccessor(mapping.LocalAttributes, attribute);
                    }
                }
                ArrayList members = new ArrayList();
                TextAccessor textAccesor = null;
                bool hasElements = false;

                foreach (MemberInfo memberInfo in model.GetMemberInfos()) {
                    XmlAttributes memberAttrs = GetAttributes(memberInfo);
                    if (memberAttrs.XmlIgnore) continue;
                    FieldModel fieldModel = model.GetFieldModel(memberInfo);
                    if (fieldModel == null) continue;
                    try {
                        MemberMapping member = ImportFieldMapping(model, fieldModel, memberAttrs, mapping.Namespace);
                        if (member == null) continue;
                        if (mapping.BaseMapping != null) {
                            if (mapping.BaseMapping.Declares(member, mapping.TypeName)) continue;
                        }
                        // add All memeber accessors to the scope accessors
                        AddUniqueAccessor(member, mapping.LocalElements, mapping.LocalAttributes);

                        if (member.Text != null) {
                            if (!member.Text.Mapping.TypeDesc.CanBeTextValue && member.Text.Mapping.IsList)
                                throw new InvalidOperationException(Res.GetString(Res.XmlIllegalTypedTextAttribute, typeName, member.Text.Name, member.Text.Mapping.TypeDesc.FullName));
                            if (textAccesor != null) {
                                throw new InvalidOperationException(Res.GetString(Res.XmlIllegalMultipleText, model.Type.FullName));
                            }
                            textAccesor = member.Text;
                        }
                        if (member.Xmlns != null) {
                            if (mapping.XmlnsMember != null)
                                throw new InvalidOperationException(Res.GetString(Res.XmlMultipleXmlns, model.Type.FullName));
                            mapping.XmlnsMember = member;
                        }
                        if (member.Elements != null && member.Elements.Length != 0) {
                            hasElements = true;
                        }
                        members.Add(member);
                    }
                    catch (Exception e) {
                        throw CreateMemberReflectionException(fieldModel, e);
                    }
                }
                mapping.SetContentModel(textAccesor, hasElements);
                mapping.Members = (MemberMapping[])members.ToArray(typeof(MemberMapping));

                if (mapping.BaseMapping == null) mapping.BaseMapping = GetRootMapping();

                if (mapping.XmlnsMember != null && mapping.BaseMapping.HasXmlnsMember)
                    throw new InvalidOperationException(Res.GetString(Res.XmlMultipleXmlns, model.Type.FullName));

                IncludeTypes(model.Type);
            }
            return mapping;
        }

        private static int CountAtLevel(XmlArrayItemAttributes attributes, int level) {
            int sum = 0;
            for (int i = 0; i < attributes.Count; i++)
                if (attributes[i].NestingLevel == level) sum++;
            return sum;
        }

        void SetArrayMappingType(ArrayMapping mapping, string defaultNs) {
            string name;
            string ns;

            TypeMapping itemTypeMapping;
            if (mapping.Elements.Length == 1)
                itemTypeMapping = mapping.Elements[0].Mapping;
            else
                itemTypeMapping = null;

            if (itemTypeMapping is EnumMapping) {
                ns = itemTypeMapping.Namespace;
                name = itemTypeMapping.TypeName;
            }
            else if (itemTypeMapping is PrimitiveMapping) {
                ns = defaultNs;
                name = itemTypeMapping.TypeDesc.DataType.Name;
            }
            else if (itemTypeMapping is StructMapping && itemTypeMapping.TypeDesc.IsRoot) {
                ns = defaultNs;
                name = Soap.UrType;
            }
            else if (itemTypeMapping != null) {
                ns = itemTypeMapping.Namespace;
                name = itemTypeMapping.TypeName;
            }
            else {
                ns = defaultNs;
                name = "Choice" + (choiceNum++);
            }

            if (name == null)
                name = "Any";
            if (ns == null)
                ns = defaultNs;
            
            string uniqueName = name = "ArrayOf" + CodeIdentifier.MakePascal(name);
            int i = 1;
            ArrayMapping existingMapping = (ArrayMapping)types[uniqueName, ns];
            while (existingMapping != null && (!AccessorMapping.ElementsMatch(existingMapping.Elements, mapping.Elements))) {
                // need to re-name the mapping
                uniqueName = name + i.ToString();
                existingMapping = (ArrayMapping)types[uniqueName, ns];
                i++;
            }
            mapping.TypeName = uniqueName;
            mapping.Namespace = ns;
        }

        ArrayMapping ImportArrayLikeMapping(ArrayModel model, string ns) {
            ArrayMapping mapping = new ArrayMapping();
            mapping.TypeDesc = model.TypeDesc;
            if (savedArrayItemAttributes == null)
                savedArrayItemAttributes = new XmlArrayItemAttributes();
            if (CountAtLevel(savedArrayItemAttributes, arrayNestingLevel) == 0)
                savedArrayItemAttributes.Add(CreateArrayItemAttribute(typeScope.GetTypeDesc(model.Element.Type), arrayNestingLevel));
            CreateArrayElementsFromAttributes(mapping, savedArrayItemAttributes, model.Element.Type, savedArrayNamespace == null ? ns : savedArrayNamespace);
            SetArrayMappingType(mapping, ns);

            // reconcile accessors now that we have the ArrayMapping namespace
            for (int i = 0; i < mapping.Elements.Length; i++) {
                mapping.Elements[i] = ReconcileLocalAccessor(mapping.Elements[i], mapping.Namespace);
            }

            IncludeTypes(model.Type);

            // in the case of an ArrayMapping we can have more that one mapping correspond to a type
            // examples of that are ArrayList and object[] both will map tp ArrayOfur-type
            // so we create a link list for all mappings of the same XSD type
            ArrayMapping existingMapping = (ArrayMapping)types[mapping.TypeName, mapping.Namespace];
            if (existingMapping != null) {
                ArrayMapping first = existingMapping;
                while (existingMapping != null) {
                    if (existingMapping.TypeDesc == model.TypeDesc)
                        return existingMapping;
                    existingMapping = existingMapping.Next;
                }
                mapping.Next = first;
                types[mapping.TypeName, mapping.Namespace] = mapping;
                return mapping;
            }
            typeScope.AddTypeMapping(mapping);
            types.Add(mapping.TypeName, mapping.Namespace, mapping);
            return mapping;
        }

        void CheckContext(TypeDesc typeDesc, ImportContext context) {
            switch (context) {
                case ImportContext.Element:
                    if (typeDesc.CanBeElementValue) return;
                    break;
                case ImportContext.Attribute:
                    if (typeDesc.CanBeAttributeValue) return;
                    break;
                case ImportContext.Text:
                    if (typeDesc.CanBeTextValue || typeDesc.IsEnum || typeDesc.IsPrimitive)
                        return;
                    break;
                default:
                    throw new ArgumentException(Res.GetString(Res.XmlInternalError), "context");
            }
            throw UnsupportedException(typeDesc, context);
        }
        
        PrimitiveMapping ImportPrimitiveMapping(PrimitiveModel model, ImportContext context, string dataType, bool repeats) {
            PrimitiveMapping mapping = new PrimitiveMapping();
            if (dataType.Length > 0) {
                mapping.TypeDesc = typeScope.GetTypeDesc(new XmlQualifiedName(dataType, XmlSchema.Namespace));
                if (mapping.TypeDesc == null) {
                    // try it as a non-Xsd type
                    mapping.TypeDesc = typeScope.GetTypeDesc(new XmlQualifiedName(dataType, UrtTypes.Namespace));
                    if (mapping.TypeDesc == null) {
                        throw new InvalidOperationException(Res.GetString(Res.XmlUdeclaredXsdType, dataType));
                    }
                }
            }
            else {
                mapping.TypeDesc = model.TypeDesc;
            }
            mapping.TypeName = mapping.TypeDesc.DataType.Name;
            mapping.IsList = repeats;
            CheckContext(mapping.TypeDesc, context);
            return mapping;
        }
        
        EnumMapping ImportEnumMapping(EnumModel model, string ns, bool repeats) {
            XmlAttributes a = GetAttributes(model.Type);
            string typeNs = ns;
            if (a.XmlType != null && a.XmlType.Namespace != null)
                typeNs = a.XmlType.Namespace;

            string typeName = string.Empty;
            if (a.XmlType != null)
                typeName = a.XmlType.TypeName;
            if (typeName.Length == 0) 
                typeName = model.TypeDesc.Name;

            EnumMapping mapping = (EnumMapping)GetTypeMapping(typeName, typeNs, model.TypeDesc);
            if (mapping == null) {
                mapping = new EnumMapping();
                mapping.TypeDesc = model.TypeDesc;
                mapping.TypeName = typeName;
                mapping.Namespace = typeNs;
                mapping.IsFlags =  model.Type.IsDefined(typeof(FlagsAttribute), false);
                if (mapping.IsFlags && repeats)
                    throw new InvalidOperationException(Res.GetString(Res.XmlIllegalAttributeFlagsArray, model.TypeDesc.FullName));
                mapping.IsList = repeats;
                mapping.IncludeInSchema = a.XmlType == null ? true : a.XmlType.IncludeInSchema;
                typeScope.AddTypeMapping(mapping);
                types.Add(typeName, typeNs, mapping);
                ArrayList constants = new ArrayList();                
                for (int i = 0; i < model.Constants.Length; i++) {
                    ConstantMapping constant = ImportConstantMapping(model.Constants[i]);
                    if (constant != null) constants.Add(constant);
                }
                if (constants.Count == 0) {
                    throw new InvalidOperationException(Res.GetString(Res.XmlNoSerializableMembers, model.TypeDesc.FullName));
                }
                mapping.Constants = (ConstantMapping[])constants.ToArray(typeof(ConstantMapping));
            }
            return mapping;
        }
        
        ConstantMapping ImportConstantMapping(ConstantModel model) {
            XmlAttributes a = GetAttributes(model.FieldInfo);
            if (a.XmlIgnore) return null;
            if ((a.XmlFlags & ~XmlAttributeFlags.Enum) != 0)
                throw new InvalidOperationException(Res.GetString(Res.XmlInvalidConstantAttribute));
            if (a.XmlEnum == null)
                a.XmlEnum = new XmlEnumAttribute();

            ConstantMapping constant = new ConstantMapping();
            constant.XmlName = a.XmlEnum.Name == null ? model.Name : a.XmlEnum.Name;
            constant.Name = model.Name;
            constant.Value = model.Value;
            return constant;
        }
        
        MembersMapping ImportMembersMapping(XmlReflectionMember[] xmlReflectionMembers, string ns, bool hasWrapperElement) {
            MembersMapping members = new MembersMapping();
            members.TypeDesc = typeScope.GetTypeDesc(typeof(object[]));
            MemberMapping[] mappings = new MemberMapping[xmlReflectionMembers.Length];
            NameTable elements = new NameTable();
            NameTable attributes = new NameTable();
            TextAccessor textAccessor = null;

            for (int i = 0; i < mappings.Length; i++) {
                try {
                    MemberMapping mapping = ImportMemberMapping(xmlReflectionMembers[i], ns, xmlReflectionMembers);
                    if (!hasWrapperElement) {
                        if (mapping.Attribute != null) throw new InvalidOperationException(Res.GetString(Res.XmlInvalidAttributeType, "XmlAttribute"));
                    }
                    // add All memeber accessors to the scope accessors
                    AddUniqueAccessor(mapping, elements, attributes);

                    mappings[i] = mapping;
                    if (mapping.Text != null) {
                        if (textAccessor != null) {
                            throw new InvalidOperationException(Res.GetString(Res.XmlIllegalMultipleTextMembers));
                        }
                        textAccessor = mapping.Text;
                    }

                    if (mapping.Xmlns != null) {
                        if (members.XmlnsMember != null)
                            throw new InvalidOperationException(Res.GetString(Res.XmlMultipleXmlnsMembers));
                        members.XmlnsMember = mapping;
                    }
                }
                catch (Exception e) {
                    throw CreateReflectionException(xmlReflectionMembers[i].MemberName, e);
                }
            }
            members.Members = mappings;
            members.HasWrapperElement = hasWrapperElement;
            return members;
        }
        
        MemberMapping ImportMemberMapping(XmlReflectionMember xmlReflectionMember, string ns, XmlReflectionMember[] xmlReflectionMembers) {
            XmlSchemaForm form = XmlSchemaForm.Qualified;
            XmlAttributes a = xmlReflectionMember.XmlAttributes;
            TypeDesc typeDesc = typeScope.GetTypeDesc(xmlReflectionMember.MemberType);

            if (a.XmlFlags == 0) {
                if (typeDesc.IsArrayLike) {
                    XmlArrayAttribute xmlArray = CreateArrayAttribute(typeDesc);
                    xmlArray.ElementName = Accessor.EscapeName(xmlReflectionMember.MemberName, false);
                    xmlArray.Namespace = ns;
                    xmlArray.Form = form;
                    a.XmlArray = xmlArray;
                }
                else {
                    XmlElementAttribute xmlElement = CreateElementAttribute(typeDesc);

                    // If there is no metadata specified on a parameter, then see if someone used
                    // an XmlRoot attribute on the struct or class.
                    if (typeDesc.IsStructLike) {
                        XmlAttributes structAttrs = new XmlAttributes(xmlReflectionMember.MemberType);
                        if (structAttrs.XmlRoot != null) {
                            xmlElement.ElementName = Accessor.EscapeName(structAttrs.XmlRoot.ElementName, false);
                            xmlElement.Namespace = structAttrs.XmlRoot.Namespace;
                            xmlElement.IsNullable = structAttrs.XmlRoot.IsNullable;
                        }
                    }
                    if (xmlElement.ElementName.Length == 0)
                        xmlElement.ElementName = xmlReflectionMember.MemberName;

                    if (xmlElement.Namespace == null)
                        xmlElement.Namespace = ns;
                    xmlElement.Form = form;
                    a.XmlElements.Add(xmlElement);
                }
            }
            else if (a.XmlRoot != null) {
                CheckNullable(a.XmlRoot.IsNullable, typeDesc);
            }
            MemberMapping member = new MemberMapping();
            member.Name = xmlReflectionMember.MemberName;
            bool checkSpecified = FindSpecifiedMember(xmlReflectionMember.MemberName, xmlReflectionMembers) != null;
            FieldModel model = new FieldModel(xmlReflectionMember.MemberName, xmlReflectionMember.MemberType, typeScope.GetTypeDesc(xmlReflectionMember.MemberType), checkSpecified, false);
            member.CheckShouldPersist = model.CheckShouldPersist;
            member.CheckSpecified = model.CheckSpecified;
            member.ReadOnly = model.ReadOnly || !model.FieldTypeDesc.HasDefaultConstructor;

            Type choiceIdentifierType = null;
            if (a.XmlChoiceIdentifier != null) {
                choiceIdentifierType = GetChoiceIdentifierType(a.XmlChoiceIdentifier, xmlReflectionMembers, typeDesc.IsArrayLike, model.Name);
            }
            ImportAccessorMapping(member, model, a, ns, choiceIdentifierType);
            if (xmlReflectionMember.OverrideIsNullable && member.Elements.Length > 0)
                member.Elements[0].IsNullable = false;
            return member;
        }
        
        XmlReflectionMember FindSpecifiedMember(string memberName, XmlReflectionMember[] reflectionMembers) {
            for (int i = 0; i < reflectionMembers.Length; i++)
                if (string.Compare(reflectionMembers[i].MemberName, memberName + "Specified", false, CultureInfo.InvariantCulture) == 0)
                    return reflectionMembers[i];
            return null;
        }

        MemberMapping ImportFieldMapping(StructModel parent, FieldModel model, XmlAttributes a, string ns) {
            MemberMapping member = new MemberMapping();
            member.Name = model.Name;
            member.CheckShouldPersist = model.CheckShouldPersist;
            member.CheckSpecified = model.CheckSpecified;
            member.ReadOnly = model.ReadOnly || !model.FieldTypeDesc.HasDefaultConstructor;
            Type choiceIdentifierType = null;
            if (a.XmlChoiceIdentifier != null) {
                choiceIdentifierType = GetChoiceIdentifierType(a.XmlChoiceIdentifier, parent, model.FieldTypeDesc.IsArrayLike, model.Name);
            }
            ImportAccessorMapping(member, model, a, ns, choiceIdentifierType);
            return member;
        }

        Type CheckChoiceIdentifierType(Type type, bool isArrayLike, string identifierName, string memberName) {
            if (type.IsArray) {
                if (!isArrayLike) {
                    // Inconsistent type of the choice identifier '{0}'.  Please use {1}.
                    throw new InvalidOperationException(Res.GetString(Res.XmlChoiceIdentifierType, identifierName, memberName, type.GetElementType().FullName));
                }
                type = type.GetElementType();
            }
            else if (isArrayLike) {
                // Inconsistent type of the choice identifier '{0}'.  Please use {1}.
                throw new InvalidOperationException(Res.GetString(Res.XmlChoiceIdentifierArrayType, identifierName, memberName, type.FullName));
            }

            if (!type.IsEnum) {
                // Choice identifier '{0}' must be an enum.
                throw new InvalidOperationException(Res.GetString(Res.XmlChoiceIdentifierTypeEnum, identifierName));
            }
            return type;
        }

        Type GetChoiceIdentifierType(XmlChoiceIdentifierAttribute choice, XmlReflectionMember[] xmlReflectionMembers, bool isArrayLike, string accessorName) {
            for (int i = 0; i < xmlReflectionMembers.Length; i++) {
                if (choice.MemberName == xmlReflectionMembers[i].MemberName) {
                    return CheckChoiceIdentifierType(xmlReflectionMembers[i].MemberType, isArrayLike, choice.MemberName, accessorName);
                }
            }
            // Missing '{0}' needed for serialization of choice '{1}'.
            throw new InvalidOperationException(Res.GetString(Res.XmlChoiceIdentiferMemberMissing, choice.MemberName, accessorName));
        }

        Type GetChoiceIdentifierType(XmlChoiceIdentifierAttribute choice, StructModel structModel, bool isArrayLike, string accessorName) {
            // check that the choice field exists

            MemberInfo[] infos = structModel.Type.GetMember(choice.MemberName, BindingFlags.DeclaredOnly | BindingFlags.Public | BindingFlags.Instance | BindingFlags.Static);
            if (infos == null || infos.Length == 0) {
                // if we can not find the choice identifier between fields, check proerties
                PropertyInfo info = structModel.Type.GetProperty(choice.MemberName, BindingFlags.DeclaredOnly | BindingFlags.Public | BindingFlags.Instance | BindingFlags.Static);
                
                if (info == null) {
                    // Missing '{0}' needed for serialization of choice '{1}'.
                    throw new InvalidOperationException(Res.GetString(Res.XmlChoiceIdentiferMemberMissing, choice.MemberName, accessorName));
                }
                infos = new MemberInfo[] { info };
            }
            else if (infos.Length > 1) {
                // Ambiguous choice identifer: there are several members named '{0}'.
                throw new InvalidOperationException(Res.GetString(Res.XmlChoiceIdentiferAmbiguous, choice.MemberName));
            }

            FieldModel member = structModel.GetFieldModel(infos[0]);
            if (member == null) {
                // Missing '{0}' needed for serialization of choice '{1}'.
                throw new InvalidOperationException(Res.GetString(Res.XmlChoiceIdentiferMemberMissing, choice.MemberName, accessorName));
            }
            Type enumType = member.FieldType;
            enumType = CheckChoiceIdentifierType(enumType, isArrayLike, choice.MemberName, accessorName);
            return enumType;
        }
       
        void CreateArrayElementsFromAttributes(ArrayMapping arrayMapping, XmlArrayItemAttributes attributes, Type arrayElementType, string arrayElementNs) {
            NameTable arrayItemElements = new NameTable();   // xmlelementname + xmlns -> ElementAccessor

            for (int i = 0; attributes != null && i < attributes.Count; i++) {
                XmlArrayItemAttribute xmlArrayItem = attributes[i];
                if (xmlArrayItem.NestingLevel != arrayNestingLevel)
                    continue;
                Type targetType = xmlArrayItem.Type != null ? xmlArrayItem.Type : arrayElementType;
                TypeDesc targetTypeDesc = typeScope.GetTypeDesc(targetType);
                ElementAccessor arrayItemElement = new ElementAccessor();
                arrayItemElement.Namespace = xmlArrayItem.Namespace == null ? arrayElementNs : xmlArrayItem.Namespace;
                arrayItemElement.Mapping = ImportTypeMapping(modelScope.GetTypeModel(targetType), arrayItemElement.Namespace, ImportContext.Element, xmlArrayItem.DataType);
                arrayItemElement.Name = Accessor.EscapeName(xmlArrayItem.ElementName.Length == 0 ? arrayItemElement.Mapping.TypeName : xmlArrayItem.ElementName, false);
                arrayItemElement.IsNullable = xmlArrayItem.IsNullableSpecified ? xmlArrayItem.IsNullable : targetTypeDesc.IsNullable;
                arrayItemElement.Form = xmlArrayItem.Form == XmlSchemaForm.None ? XmlSchemaForm.Qualified : xmlArrayItem.Form;
                CheckForm(arrayItemElement.Form, arrayElementNs != arrayItemElement.Namespace);
                CheckNullable(arrayItemElement.IsNullable, targetTypeDesc);
                AddUniqueAccessor(arrayItemElements, arrayItemElement);
            }
            arrayMapping.Elements = (ElementAccessor[])arrayItemElements.ToArray(typeof(ElementAccessor));
        }

        void ImportAccessorMapping(MemberMapping accessor, FieldModel model, XmlAttributes a, string ns, Type choiceIdentifierType) {
            XmlSchemaForm elementFormDefault = XmlSchemaForm.Qualified;
            int previousNestingLevel = arrayNestingLevel;
            XmlArrayItemAttributes previousArrayItemAttributes = savedArrayItemAttributes;
            string previousArrayNamespace = savedArrayNamespace;
            arrayNestingLevel = 0;
            savedArrayItemAttributes = null;
            savedArrayNamespace = null;
            Type accessorType = model.FieldType;
            string accessorName = model.Name;
            NameTable elements = new NameTable();
            accessor.TypeDesc = typeScope.GetTypeDesc(accessorType);
            XmlAttributeFlags flags = a.XmlFlags;
            accessor.Ignore = a.XmlIgnore;
            CheckAmbiguousChoice(a, accessorType, accessorName);

            XmlAttributeFlags elemFlags = XmlAttributeFlags.Elements | XmlAttributeFlags.Text | XmlAttributeFlags.AnyElements | XmlAttributeFlags.ChoiceIdentifier;
            XmlAttributeFlags attrFlags = XmlAttributeFlags.Attribute | XmlAttributeFlags.AnyAttribute;
            XmlAttributeFlags arrayFlags = XmlAttributeFlags.Array | XmlAttributeFlags.ArrayItems;

            // special case for byte[]. It can be a primitive (base64Binary or hexBinary), or it can
            // be an array of bytes. Our default is primitive; specify [XmlArray] to get array behavior.
            if ((flags & arrayFlags) != 0 && accessorType == typeof(byte[]))
                accessor.TypeDesc = typeScope.GetArrayTypeDesc(accessorType);


            if (a.XmlChoiceIdentifier != null) {
                accessor.ChoiceIdentifier = new ChoiceIdentifierAccessor();
                accessor.ChoiceIdentifier.MemberName = a.XmlChoiceIdentifier.MemberName;
                accessor.ChoiceIdentifier.Mapping = ImportTypeMapping(modelScope.GetTypeModel(choiceIdentifierType), ns, ImportContext.Element, String.Empty);
                CheckChoiceIdentifierMapping((EnumMapping)accessor.ChoiceIdentifier.Mapping);
            }

            if (accessor.TypeDesc.IsArrayLike) {
                Type arrayElementType = TypeScope.GetArrayElementType(accessorType);

                if ((flags & attrFlags) != 0) {
                    if ((flags & attrFlags) != flags) 
                        throw new InvalidOperationException(Res.GetString(Res.XmlIllegalAttributesArrayAttribute));

                    if (a.XmlAttribute != null && !accessor.TypeDesc.ArrayElementTypeDesc.IsPrimitive && !accessor.TypeDesc.ArrayElementTypeDesc.IsEnum)
                        throw new InvalidOperationException(Res.GetString(Res.XmlIllegalAttrOrText, accessorName));

                    bool isList = a.XmlAttribute != null && (accessor.TypeDesc.ArrayElementTypeDesc.IsPrimitive || accessor.TypeDesc.ArrayElementTypeDesc.IsEnum);

                    if (a.XmlAnyAttribute != null) {
                        a.XmlAttribute = new XmlAttributeAttribute();
                    }

                    AttributeAccessor attribute = new AttributeAccessor();
                    Type targetType = a.XmlAttribute.Type == null ? arrayElementType : a.XmlAttribute.Type;
                    TypeDesc targetTypeDesc = typeScope.GetTypeDesc(targetType);
                    attribute.Name = Accessor.EscapeName(a.XmlAttribute.AttributeName.Length == 0 ? accessorName : a.XmlAttribute.AttributeName, true);
                    attribute.Namespace = a.XmlAttribute.Namespace == null ? ns : a.XmlAttribute.Namespace;
                    attribute.Form = a.XmlAttribute.Form;
                    if (attribute.Form == XmlSchemaForm.None && ns != attribute.Namespace) {
                        attribute.Form = XmlSchemaForm.Qualified;
                    }
                    attribute.CheckSpecial();
                    CheckForm(attribute.Form, ns != attribute.Namespace);
                    attribute.Mapping = ImportTypeMapping(modelScope.GetTypeModel(targetType), ns, ImportContext.Attribute, a.XmlAttribute.DataType, isList);
                    attribute.IsList = isList;
                    attribute.Default = GetDefaultValue(model.FieldTypeDesc, model.FieldType, a);
                    attribute.Any = (a.XmlAnyAttribute != null);
                    accessor.Attribute = attribute;

                }
                else if ((flags & elemFlags) != 0) {
                    if ((flags & elemFlags) != flags)
                        throw new InvalidOperationException(Res.GetString(Res.XmlIllegalElementsArrayAttribute));
                    
                    if (a.XmlText != null) {
                        TextAccessor text = new TextAccessor();
                        Type targetType = a.XmlText.Type == null ? arrayElementType : a.XmlText.Type;
                        TypeDesc targetTypeDesc = typeScope.GetTypeDesc(targetType);
                        text.Name = accessorName; // unused except to make more helpful error messages
                        text.Mapping = ImportTypeMapping(modelScope.GetTypeModel(targetType), ns, ImportContext.Text, a.XmlText.DataType, true);
                        if (!(text.Mapping is SpecialMapping) && targetTypeDesc != typeScope.GetTypeDesc(typeof(string)))
                            throw new InvalidOperationException(Res.GetString(Res.XmlIllegalArrayTextAttribute, accessorName));

                        accessor.Text = text;
                    }
                    if (a.XmlText == null && a.XmlElements.Count == 0 && a.XmlAnyElements.Count == 0)
                        a.XmlElements.Add(CreateElementAttribute(accessor.TypeDesc));
                    
                    for (int i = 0; i < a.XmlElements.Count; i++) {
                        XmlElementAttribute xmlElement = a.XmlElements[i];
                        Type targetType = xmlElement.Type == null ? arrayElementType : xmlElement.Type;
                        TypeDesc targetTypeDesc = typeScope.GetTypeDesc(targetType);
                        TypeModel typeModel = modelScope.GetTypeModel(targetType);
                        ElementAccessor element = new ElementAccessor();
                        element.Namespace = xmlElement.Namespace == null ? ns : xmlElement.Namespace;
                        element.Mapping = ImportTypeMapping(typeModel, element.Namespace, ImportContext.Element, xmlElement.DataType);
                        if (a.XmlElements.Count == 1) {
                            element.Name = Accessor.EscapeName(xmlElement.ElementName.Length == 0 ? accessorName : xmlElement.ElementName, false);
                        }
                        else {
                            element.Name = Accessor.EscapeName(xmlElement.ElementName.Length == 0 ? element.Mapping.TypeName : xmlElement.ElementName, false);
                        }
                        element.Default = GetDefaultValue(model.FieldTypeDesc, model.FieldType, a);
                        element.IsNullable = xmlElement.IsNullable;
                        element.Form = xmlElement.Form == XmlSchemaForm.None ? elementFormDefault : xmlElement.Form;
                        CheckForm(element.Form, ns != element.Namespace);
                        CheckNullable(element.IsNullable, targetTypeDesc);
                        element = ReconcileLocalAccessor(element, ns);
                        AddUniqueAccessor(elements, element);
                    }
                    for (int i = 0; i < a.XmlAnyElements.Count; i++) {
                        XmlAnyElementAttribute xmlAnyElement = a.XmlAnyElements[i];
                        Type targetType = typeof(XmlNode).IsAssignableFrom(arrayElementType) ? arrayElementType : typeof(XmlElement);
                        ElementAccessor element = new ElementAccessor();
                        element.Name = Accessor.EscapeName(xmlAnyElement.Name, false);
                        element.Namespace = xmlAnyElement.Namespace == null ? ns : xmlAnyElement.Namespace;
                        if (elements[element.Name, element.Namespace] != null) {
                            throw new InvalidOperationException(Res.GetString(Res.XmlAnyElementDuplicate, accessorName, xmlAnyElement.Name, xmlAnyElement.Namespace == null ? "null" : xmlAnyElement.Namespace));
                        }
                        element.Any = true;
                        TypeDesc targetTypeDesc = typeScope.GetTypeDesc(targetType);
                        TypeModel typeModel = modelScope.GetTypeModel(targetType);
                        if (element.Name.Length > 0)
                            typeModel.TypeDesc.IsMixed = true;
                        else if (xmlAnyElement.Namespace != null)
                            throw new InvalidOperationException(Res.GetString(Res.XmlAnyElementNamespace, accessorName, xmlAnyElement.Namespace));
                        element.Mapping = ImportTypeMapping(typeModel, element.Namespace, ImportContext.Element, String.Empty);
                        element.Default = GetDefaultValue(model.FieldTypeDesc, model.FieldType, a);
                        element.IsNullable = false;
                        element.Form = elementFormDefault;
                        CheckForm(element.Form, ns != element.Namespace);
                        CheckNullable(element.IsNullable, targetTypeDesc);
                        element = ReconcileLocalAccessor(element, ns);
                        elements.Add(element.Name, element.Namespace, element);
                    }

                }
                else {
                    if ((flags & arrayFlags) != 0) {
                        if ((flags & arrayFlags) != flags)
                            throw new InvalidOperationException(Res.GetString(Res.XmlIllegalArrayArrayAttribute));
                    }
                    
                    TypeDesc arrayElementTypeDesc = typeScope.GetTypeDesc(arrayElementType);
                    if (a.XmlArray == null)
                        a.XmlArray = CreateArrayAttribute(accessor.TypeDesc);
                    if (CountAtLevel(a.XmlArrayItems, arrayNestingLevel) == 0)
                        a.XmlArrayItems.Add(CreateArrayItemAttribute(arrayElementTypeDesc, arrayNestingLevel));
                    ElementAccessor arrayElement = new ElementAccessor();
                    arrayElement.Name = Accessor.EscapeName(a.XmlArray.ElementName.Length == 0 ? accessorName : a.XmlArray.ElementName, false);
                    arrayElement.Namespace = a.XmlArray.Namespace == null ? ns : a.XmlArray.Namespace;
                    savedArrayItemAttributes = a.XmlArrayItems;
                    savedArrayNamespace = arrayElement.Namespace;
                    ArrayMapping arrayMapping = ImportArrayLikeMapping(modelScope.GetArrayModel(accessorType), ns);
                    arrayElement.Mapping = arrayMapping;
                    arrayElement.IsNullable = a.XmlArray.IsNullable;
                    arrayElement.Form = a.XmlArray.Form == XmlSchemaForm.None ? elementFormDefault : a.XmlArray.Form;
                    CheckForm(arrayElement.Form, ns != arrayElement.Namespace);
                    CheckNullable(arrayElement.IsNullable, accessor.TypeDesc);
                    savedArrayItemAttributes = null;
                    savedArrayNamespace = null;
                    arrayElement = ReconcileLocalAccessor(arrayElement, ns);
                    AddUniqueAccessor(elements, arrayElement);
                }
            }
            else if (!accessor.TypeDesc.IsVoid) {
                XmlAttributeFlags allFlags = XmlAttributeFlags.Elements | XmlAttributeFlags.Text | XmlAttributeFlags.Attribute | XmlAttributeFlags.AnyElements | XmlAttributeFlags.ChoiceIdentifier | XmlAttributeFlags.XmlnsDeclarations;
                if ((flags & allFlags) != flags)
                    throw new InvalidOperationException(Res.GetString(Res.XmlIllegalAttribute));

                if (accessor.TypeDesc.IsPrimitive || accessor.TypeDesc.IsEnum) {
                    if (a.XmlAnyElements.Count > 0) throw new InvalidOperationException(Res.GetString(Res.XmlIllegalAnyElement));

                    if (a.XmlAttribute != null) {
                        if (a.XmlElements.Count > 0) throw new InvalidOperationException(Res.GetString(Res.XmlIllegalAttribute));
                        if (a.XmlAttribute.Type != null) throw new InvalidOperationException(Res.GetString(Res.XmlIllegalType, "XmlAttribute"));
                        AttributeAccessor attribute = new AttributeAccessor();
                        attribute.Name = Accessor.EscapeName(a.XmlAttribute.AttributeName.Length == 0 ? accessorName : a.XmlAttribute.AttributeName, true);
                        attribute.Namespace = a.XmlAttribute.Namespace == null ? ns : a.XmlAttribute.Namespace;
                        attribute.Form = a.XmlAttribute.Form;
                        if (attribute.Form == XmlSchemaForm.None && ns != attribute.Namespace) {
                            attribute.Form = XmlSchemaForm.Qualified;
                        }
                        attribute.CheckSpecial();
                        CheckForm(attribute.Form, ns != attribute.Namespace);
                        attribute.Mapping = ImportTypeMapping(modelScope.GetTypeModel(accessorType), ns, ImportContext.Attribute, a.XmlAttribute.DataType);
                        attribute.Default = GetDefaultValue(model.FieldTypeDesc, model.FieldType, a);
                        attribute.Any = a.XmlAnyAttribute != null;
                        accessor.Attribute = attribute;
                    }
                    else {
                        if (a.XmlText != null) {
                            if (a.XmlText.Type != null && a.XmlText.Type != accessorType) 
                                throw new InvalidOperationException(Res.GetString(Res.XmlIllegalType, "XmlText"));
                            TextAccessor text = new TextAccessor();
                            text.Name = accessorName; // unused except to make more helpful error messages
                            text.Mapping = ImportTypeMapping(modelScope.GetTypeModel(accessorType), ns, ImportContext.Text, a.XmlText.DataType);
                            accessor.Text = text;
                        }
                        else if (a.XmlElements.Count == 0) {
                            a.XmlElements.Add(CreateElementAttribute(accessor.TypeDesc));
                        }

                        for (int i = 0; i < a.XmlElements.Count; i++) {
                            XmlElementAttribute xmlElement = a.XmlElements[i];
                            if (xmlElement.Type != null) {
                                if (typeScope.GetTypeDesc(xmlElement.Type) != accessor.TypeDesc)
                                    throw new InvalidOperationException(Res.GetString(Res.XmlIllegalType, "XmlElement"));
                            }
                            ElementAccessor element = new ElementAccessor();
                            element.Name = Accessor.EscapeName(xmlElement.ElementName.Length == 0 ? accessorName : xmlElement.ElementName, false);
                            element.Namespace = xmlElement.Namespace == null ? ns : xmlElement.Namespace;
                            element.Mapping = ImportTypeMapping(modelScope.GetTypeModel(accessorType), element.Namespace, ImportContext.Element, xmlElement.DataType);
                            element.Default = GetDefaultValue(model.FieldTypeDesc, model.FieldType, a);
                            element.IsNullable = xmlElement.IsNullable;
                            element.Form = xmlElement.Form == XmlSchemaForm.None ? elementFormDefault : xmlElement.Form;
                            CheckForm(element.Form, ns != element.Namespace);
                            CheckNullable(element.IsNullable, accessor.TypeDesc);
                            element = ReconcileLocalAccessor(element, ns);
                            AddUniqueAccessor(elements, element);
                        }
                    }
                }
                else if (a.Xmlns) {
                    if (flags != XmlAttributeFlags.XmlnsDeclarations)
                        throw new InvalidOperationException(Res.GetString(Res.XmlSoleXmlnsAttribute));
                    
                    if (accessorType != typeof(XmlSerializerNamespaces)) {
                        throw new InvalidOperationException(Res.GetString(Res.XmlXmlnsInvalidType, accessorName, accessorType.FullName, typeof(XmlSerializerNamespaces).FullName));
                    }
                    accessor.Xmlns = new XmlnsAccessor();
                    accessor.Ignore = true;
                }
                else  {
                    if (a.XmlAttribute != null || a.XmlText != null) throw new InvalidOperationException(Res.GetString(Res.XmlIllegalAttrOrText, accessorName));
                    if (a.XmlElements.Count == 0 && a.XmlAnyElements.Count == 0)
                        a.XmlElements.Add(CreateElementAttribute(accessor.TypeDesc));
                    for (int i = 0; i < a.XmlElements.Count; i++) {
                        XmlElementAttribute xmlElement = a.XmlElements[i];
                        Type targetType = xmlElement.Type == null ? accessorType : xmlElement.Type;
                        TypeDesc targetTypeDesc = typeScope.GetTypeDesc(targetType);
                        ElementAccessor element = new ElementAccessor();
                        TypeModel typeModel = modelScope.GetTypeModel(targetType);
                        element.Namespace = xmlElement.Namespace == null ? ns : xmlElement.Namespace;
                        element.Mapping = ImportTypeMapping(typeModel, element.Namespace, ImportContext.Element, xmlElement.DataType);
                        if (a.XmlElements.Count == 1) {
                            element.Name = Accessor.EscapeName(xmlElement.ElementName.Length == 0 ? accessorName : xmlElement.ElementName, false);
                        }
                        else {
                            element.Name = Accessor.EscapeName(xmlElement.ElementName.Length == 0 ? element.Mapping.TypeName : xmlElement.ElementName, false);
                        }
                        element.Default = GetDefaultValue(model.FieldTypeDesc, model.FieldType, a);
                        element.IsNullable = xmlElement.IsNullable;
                        element.Form = xmlElement.Form == XmlSchemaForm.None ? elementFormDefault : xmlElement.Form;
                        CheckForm(element.Form, ns != element.Namespace);
                        CheckNullable(element.IsNullable, targetTypeDesc);
                        element = ReconcileLocalAccessor(element, ns);
                        AddUniqueAccessor(elements, element);
                    }
                    
                    for (int i = 0; i < a.XmlAnyElements.Count; i++) {
                        XmlAnyElementAttribute xmlAnyElement = a.XmlAnyElements[i];
                        Type targetType = typeof(XmlNode).IsAssignableFrom(accessorType) ? accessorType : typeof(XmlElement);
                        ElementAccessor element = new ElementAccessor();
                        element.Name = Accessor.EscapeName(xmlAnyElement.Name, false);
                        element.Namespace = xmlAnyElement.Namespace == null ? ns : xmlAnyElement.Namespace;
                        if (elements[element.Name, element.Namespace] != null) {
                            throw new InvalidOperationException(Res.GetString(Res.XmlAnyElementDuplicate, accessorName, xmlAnyElement.Name, xmlAnyElement.Namespace == null ? "null" : xmlAnyElement.Namespace));
                        }
                        element.Any = true;
                        TypeDesc targetTypeDesc = typeScope.GetTypeDesc(targetType);
                        TypeModel typeModel = modelScope.GetTypeModel(targetType);

                        if (element.Name.Length > 0)
                            typeModel.TypeDesc.IsMixed = true;
                        else if (xmlAnyElement.Namespace != null)
                            throw new InvalidOperationException(Res.GetString(Res.XmlAnyElementNamespace, accessorName, xmlAnyElement.Namespace));
                        element.Mapping = ImportTypeMapping(typeModel, element.Namespace, ImportContext.Element, String.Empty);
                        element.Default = GetDefaultValue(model.FieldTypeDesc, model.FieldType, a);
                        element.IsNullable = false;
                        element.Form = elementFormDefault;
                        CheckForm(element.Form, ns != element.Namespace);
                        CheckNullable(element.IsNullable, targetTypeDesc);
                        element = ReconcileLocalAccessor(element, ns);
                        elements.Add(element.Name, element.Namespace, element);
                    }
                }
            }

            accessor.Elements = (ElementAccessor[])elements.ToArray(typeof(ElementAccessor));

            if (accessor.ChoiceIdentifier != null) {
                // find the enum value corresponding to each element
                accessor.ChoiceIdentifier.MemberIds = new string[accessor.Elements.Length];
                for (int i = 0; i < accessor.Elements.Length; i++) {
                    bool found = false;
                    ElementAccessor element = accessor.Elements[i];
                    EnumMapping choiceMapping = (EnumMapping)accessor.ChoiceIdentifier.Mapping;
                    for (int j = 0; j < choiceMapping.Constants.Length; j++) {
                        string xmlName = choiceMapping.Constants[j].XmlName;

                        if (element.Any && element.Name.Length == 0) {
                            if (xmlName == "##any:") {
                                accessor.ChoiceIdentifier.MemberIds[i] = choiceMapping.Constants[j].Name;
                                found = true;
                                break;
                            }
                            continue;
                        }
                        int colon = xmlName.LastIndexOf(':');
                        string choiceNs = colon < 0 ? choiceMapping.Namespace : xmlName.Substring(0, colon);
                        string choiceName = colon < 0 ? xmlName : xmlName.Substring(colon+1);

                        if (element.Name == choiceName && element.Namespace == choiceNs) {
                            accessor.ChoiceIdentifier.MemberIds[i] = choiceMapping.Constants[j].Name;
                            found = true;
                            break;
                        }
                    }
                    if (!found) {
                        if (element.Any && element.Name.Length == 0) {
                            // Type {0} is missing enumeration value '##any' for XmlAnyElementAttribute.
                            throw new InvalidOperationException(Res.GetString(Res.XmlChoiceMissingAnyValue, accessor.ChoiceIdentifier.Mapping.TypeDesc.FullName));
                        }
                        else {
                            string id = element.Namespace != null && element.Namespace.Length > 0 ? element.Namespace + ":" + element.Name : element.Name;
                            // Type {0} is missing value for '{1}'.
                            throw new InvalidOperationException(Res.GetString(Res.XmlChoiceMissingValue, accessor.ChoiceIdentifier.Mapping.TypeDesc.FullName, id, element.Name, element.Namespace));
                        }
                    }
                }
            }
            arrayNestingLevel = previousNestingLevel;
            savedArrayItemAttributes = previousArrayItemAttributes;
            savedArrayNamespace = previousArrayNamespace;
        }

        void CheckAmbiguousChoice(XmlAttributes a, Type accessorType, string accessorName) {
            Hashtable choiceTypes = new Hashtable();

            XmlElementAttributes elements = a.XmlElements;
            if (elements != null && elements.Count >= 2 && a.XmlChoiceIdentifier == null) {
                for (int i = 0; i < elements.Count; i++) {
                    Type type = elements[i].Type == null ? accessorType : elements[i].Type;
                    if (choiceTypes.Contains(type)) {
                        // You need to add {0} to the '{1}'.
                        throw new InvalidOperationException(Res.GetString(Res.XmlChoiceIdentiferMissing, typeof(XmlChoiceIdentifierAttribute).Name, accessorName));
                    }
                    else {
                        choiceTypes.Add(type, false);
                    }
                }
            }
            if (choiceTypes.Contains(typeof(XmlElement)) && a.XmlAnyElements.Count > 0) {
                // You need to add {0} to the '{1}'.
                throw new InvalidOperationException(Res.GetString(Res.XmlChoiceIdentiferMissing, typeof(XmlChoiceIdentifierAttribute).Name, accessorName));
            }

            XmlArrayItemAttributes items = a.XmlArrayItems;
            if (items != null && items.Count >= 2) {
                NameTable arrayTypes = new NameTable();

                for (int i = 0; i < items.Count; i++) {
                    Type type = items[i].Type == null ? accessorType : items[i].Type;
                    string ns = items[i].NestingLevel.ToString();
                    XmlArrayItemAttribute item = (XmlArrayItemAttribute)arrayTypes[type.FullName, ns];
                    if (item != null) {
                        throw new InvalidOperationException(Res.GetString(Res.XmlArrayItemAmbiguousTypes, accessorName, item.ElementName, items[i].ElementName, typeof(XmlElementAttribute).Name, typeof(XmlChoiceIdentifierAttribute).Name, accessorName));
                    }
                    else {
                        arrayTypes[type.FullName, ns] =  items[i];
                    }
                }
            }
        }

        void CheckChoiceIdentifierMapping(EnumMapping choiceMapping) {
            NameTable ids = new NameTable();
            for (int i = 0; i < choiceMapping.Constants.Length; i++) {
                string choiceId = choiceMapping.Constants[i].XmlName;
                int colon = choiceId.LastIndexOf(':');
                string choiceName = colon < 0 ? choiceId : choiceId.Substring(colon+1);
                string choiceNs = colon < 0 ? "" : choiceId.Substring(0, colon);

                if (ids[choiceName, choiceNs] != null) {
                    // Enum values in the XmlChoiceIdentifier '{0}' have to be unique.  Value '{1}' already present.
                    throw new InvalidOperationException(Res.GetString(Res.XmlChoiceIdDuplicate, choiceMapping.TypeName, choiceId));
                }
                ids.Add(choiceName, choiceNs, choiceMapping.Constants[i]);
            }
        }

        object GetDefaultValue(TypeDesc fieldTypeDesc, Type t, XmlAttributes a) {
            if (a.XmlDefaultValue == DBNull.Value) return a.XmlDefaultValue;
            if (!(fieldTypeDesc.Kind == TypeKind.Primitive || fieldTypeDesc.Kind == TypeKind.Enum))  {
                //throw new InvalidOperationException(Res.GetString(Res.XmlIllegalDefault));
                a.XmlDefaultValue = DBNull.Value;
                return a.XmlDefaultValue;
            }
            // for enums validate and return a string representation
            if (fieldTypeDesc.Kind == TypeKind.Enum) {
                string strValue = Enum.Format(t, a.XmlDefaultValue, "G").Replace(",", " ");
                string numValue = Enum.Format(t, a.XmlDefaultValue, "D");
                if (strValue == numValue) // means enum value wasn't recognized
                    throw new InvalidOperationException(Res.GetString(Res.XmlInvalidDefaultValue, strValue, a.XmlDefaultValue.GetType().FullName));
                return strValue;
            }
            return a.XmlDefaultValue;
        }

        static XmlArrayItemAttribute CreateArrayItemAttribute(TypeDesc typeDesc, int nestingLevel) {
            XmlArrayItemAttribute xmlArrayItem = new XmlArrayItemAttribute();
            xmlArrayItem.NestingLevel = nestingLevel;
            return xmlArrayItem;
        }

        static XmlArrayAttribute CreateArrayAttribute(TypeDesc typeDesc) {
            XmlArrayAttribute xmlArrayItem = new XmlArrayAttribute();
            return xmlArrayItem;
        }

        static XmlElementAttribute CreateElementAttribute(TypeDesc typeDesc) {
            XmlElementAttribute xmlElement = new XmlElementAttribute();
            return xmlElement;
        }

        static void AddUniqueAccessor(NameTable scope, Accessor accessor) {
            Accessor existing = (Accessor)scope[accessor.Name, accessor.Namespace];
            if (existing != null) {
                if (accessor is ElementAccessor) {
                    throw new InvalidOperationException(Res.GetString(Res.XmlDuplicateElementName, existing.Name, existing.Namespace));
                }
                else {
                    #if DEBUG
                    if (!(accessor is AttributeAccessor))
                        throw new InvalidOperationException(Res.GetString(Res.XmlInternalErrorDetails, "Bad accessor type " + accessor.GetType().FullName));
                    #endif
                    throw new InvalidOperationException(Res.GetString(Res.XmlDuplicateAttributeName, existing.Name, existing.Namespace));
                }
            }
            else {
                scope.Add(accessor.Name, accessor.Namespace, accessor);
            }
        }

        static void AddUniqueAccessor(MemberMapping member, NameTable elements, NameTable attributes) {
            if (member.Attribute != null) {
                AddUniqueAccessor(attributes, member.Attribute);
            }
            else if (member.Elements != null && member.Elements.Length > 0) {
                for (int i = 0; i < member.Elements.Length; i++) {
                    AddUniqueAccessor(elements, member.Elements[i]);
                }
            }
        }

        static void CheckForm(XmlSchemaForm form, bool isQualified) {
            if (isQualified && form == XmlSchemaForm.Unqualified) throw new InvalidOperationException(Res.GetString(Res.XmlInvalidFormUnqualified));
        }

        static void CheckNullable(bool isNullable, TypeDesc typeDesc) {
            if (isNullable && !typeDesc.IsNullable) throw new InvalidOperationException(Res.GetString(Res.XmlInvalidIsNullable, typeDesc.FullName));
        }

        static ElementAccessor CreateElementAccessor(TypeMapping mapping, string ns) {
            ElementAccessor element = new ElementAccessor();
            if (mapping.TypeDesc.Kind == TypeKind.Node) {
                element.Any = true;
            }
            else {
                element.Name = Accessor.EscapeName(mapping.TypeName, false);
                element.Namespace = ns;
            }
            element.Mapping = mapping;
            return element;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\serialization\xmlserializer.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlSerializer.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Serialization {

    using System.Reflection;
    using System.Collections;
    using System.IO;
    using System.Xml.Schema;
    using System;

    internal struct XmlDeserializationEvents {
        public XmlNodeEventHandler onUnknownNode;
        public XmlAttributeEventHandler onUnknownAttribute;
        public XmlElementEventHandler onUnknownElement;
        public UnreferencedObjectEventHandler onUnreferencedObject;
        public object sender;
    }

    /// <include file='doc\XmlSerializer.uex' path='docs/doc[@for="XmlSerializer"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public class XmlSerializer {
        TempAssembly tempAssembly;
        int methodIndex;
        XmlDeserializationEvents events = new XmlDeserializationEvents();

        static TempAssemblyCache cache = new TempAssemblyCache();
        static XmlSerializerNamespaces defaultNamespaces;

        static XmlSerializer() {
            defaultNamespaces = new XmlSerializerNamespaces();
            defaultNamespaces.Add("xsi", XmlSchema.InstanceNamespace);
            defaultNamespaces.Add("xsd", XmlSchema.Namespace);
        }
        /// <include file='doc\XmlSerializer.uex' path='docs/doc[@for="XmlSerializer.XmlSerializer7"]/*' />
        ///<internalonly/>
        protected XmlSerializer() {
            this.events.sender = this;
        }

        XmlSerializer(TempAssembly tempAssembly, int methodIndex) {
            this.tempAssembly = tempAssembly;
            this.methodIndex = methodIndex;
            this.events.sender = this;
        }

        
        /// <include file='doc\XmlSerializer.uex' path='docs/doc[@for="XmlSerializer.XmlSerializer"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public XmlSerializer(Type type, XmlAttributeOverrides overrides, Type[] extraTypes, XmlRootAttribute root, string defaultNamespace) {
            XmlReflectionImporter importer = new XmlReflectionImporter(overrides, defaultNamespace);
            for (int i = 0; i < extraTypes.Length; i++)
                importer.IncludeType(extraTypes[i]);
            tempAssembly = GenerateTempAssembly(importer.ImportTypeMapping(type, root));
            this.events.sender = this;
        }

        /// <include file='doc\XmlSerializer.uex' path='docs/doc[@for="XmlSerializer.XmlSerializer2"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public XmlSerializer(Type type, XmlRootAttribute root) : this(type, null, new Type[0], root, null) {
        }

        /// <include file='doc\XmlSerializer.uex' path='docs/doc[@for="XmlSerializer.XmlSerializer3"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public XmlSerializer(Type type, Type[] extraTypes) : this(type, null, extraTypes, null, null) {
        }

        /// <include file='doc\XmlSerializer.uex' path='docs/doc[@for="XmlSerializer.XmlSerializer4"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public XmlSerializer(Type type, XmlAttributeOverrides overrides) : this(type, overrides, new Type[0], null, null) {
        }

        /// <include file='doc\XmlSerializer.uex' path='docs/doc[@for="XmlSerializer.XmlSerializer5"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public XmlSerializer(XmlTypeMapping xmlTypeMapping) {
            tempAssembly = GenerateTempAssembly(xmlTypeMapping);
            this.events.sender = this;
        }

        /// <include file='doc\XmlSerializer.uex' path='docs/doc[@for="XmlSerializer.XmlSerializer6"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public XmlSerializer(Type type) : this(type, (string)null) {
        }

        /// <include file='doc\XmlSerializer.uex' path='docs/doc[@for="XmlSerializer.XmlSerializer1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public XmlSerializer(Type type, string defaultNamespace)  {
            this.events.sender = this;
            tempAssembly = cache[defaultNamespace, type];
            if (tempAssembly == null) {
                lock (cache) {
                    tempAssembly = cache[defaultNamespace, type];
                    if (tempAssembly == null) {
                        XmlReflectionImporter importer = new XmlReflectionImporter(defaultNamespace);
                        tempAssembly = GenerateTempAssembly(importer.ImportTypeMapping(type));
                        cache.Add(defaultNamespace, type, tempAssembly);
                    }
                }
            }
        }

        static TempAssembly GenerateTempAssembly(XmlTypeMapping xmlTypeMapping) {
            return new TempAssembly(new XmlMapping[] { xmlTypeMapping });
        }
        
        /// <include file='doc\XmlSerializer.uex' path='docs/doc[@for="XmlSerializer.Serialize"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void Serialize(TextWriter textWriter, object o) {
            Serialize(textWriter, o, null);
        }

        /// <include file='doc\XmlSerializer.uex' path='docs/doc[@for="XmlSerializer.Serialize1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void Serialize(TextWriter textWriter, object o, XmlSerializerNamespaces namespaces) {
            XmlTextWriter xmlWriter = new XmlTextWriter(textWriter);
            xmlWriter.Formatting = Formatting.Indented;
            xmlWriter.Indentation = 2;
            Serialize(xmlWriter, o, namespaces);
        }

        /// <include file='doc\XmlSerializer.uex' path='docs/doc[@for="XmlSerializer.Serialize2"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void Serialize(Stream stream, object o) {
            Serialize(stream, o, null);
        }
        
        /// <include file='doc\XmlSerializer.uex' path='docs/doc[@for="XmlSerializer.Serialize3"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void Serialize(Stream stream, object o, XmlSerializerNamespaces namespaces) {
            XmlTextWriter xmlWriter = new XmlTextWriter(stream, null);
            xmlWriter.Formatting = Formatting.Indented;
            xmlWriter.Indentation = 2;
            Serialize(xmlWriter, o, namespaces);
        }

        /// <include file='doc\XmlSerializer.uex' path='docs/doc[@for="XmlSerializer.Serialize4"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void Serialize(XmlWriter xmlWriter, object o) {
            Serialize(xmlWriter, o, null);
        }

        /// <include file='doc\XmlSerializer.uex' path='docs/doc[@for="XmlSerializer.Serialize5"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void Serialize(XmlWriter xmlWriter, object o, XmlSerializerNamespaces namespaces) {
            Serialize(xmlWriter, o, namespaces, null);
        }

        /// <include file='doc\XmlSerializer.uex' path='docs/doc[@for="XmlSerializer.Serialize6"]/*' />
        // SOAP12: made this internal
        internal void Serialize(XmlWriter xmlWriter, object o, XmlSerializerNamespaces namespaces, string encodingStyle) {
            try {
                if(tempAssembly == null){
                    XmlSerializationWriter writer = CreateWriter();
                    writer.Init(xmlWriter, (namespaces == null || namespaces.Count == 0 ? defaultNamespaces : namespaces).NamespaceList, encodingStyle, null);
                    try {
                        Serialize(o, writer);
                    }
                    finally {
                        writer.Dispose();
                    }
                }
                else
                    tempAssembly.InvokeWriter(methodIndex, xmlWriter, o, (namespaces == null || namespaces.Count == 0 ? defaultNamespaces : namespaces).NamespaceList, encodingStyle);
            }
            catch (Exception e) {
                if (e is TargetInvocationException)
                    e = e.InnerException;
                throw new InvalidOperationException(Res.GetString(Res.XmlGenError), e);
            }
            xmlWriter.Flush();
        }
        
        /// <include file='doc\XmlSerializer.uex' path='docs/doc[@for="XmlSerializer.Deserialize"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public object Deserialize(Stream stream) {
            XmlTextReader xmlReader = new XmlTextReader(stream);
            xmlReader.WhitespaceHandling = WhitespaceHandling.Significant;
            xmlReader.Normalization = true;
            xmlReader.XmlResolver = null;
            return Deserialize(xmlReader, null);
        }
        
        /// <include file='doc\XmlSerializer.uex' path='docs/doc[@for="XmlSerializer.Deserialize1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public object Deserialize(TextReader textReader) {
            XmlTextReader xmlReader = new XmlTextReader(textReader);
            xmlReader.WhitespaceHandling = WhitespaceHandling.Significant;
            xmlReader.Normalization = true;
            xmlReader.XmlResolver = null;
            return Deserialize(xmlReader, null);
        }
        
        /// <include file='doc\XmlSerializer.uex' path='docs/doc[@for="XmlSerializer.Deserialize2"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public object Deserialize(XmlReader xmlReader) {
            return Deserialize(xmlReader, null);
        }

        /// <include file='doc\XmlSerializer.uex' path='docs/doc[@for="XmlSerializer.Deserialize3"]/*' />
        // SOAP12: made this internal
        internal object Deserialize(XmlReader xmlReader, string encodingStyle) {
            try {
                if(tempAssembly == null){
                    XmlSerializationReader reader = CreateReader();
                    reader.Init(xmlReader, events, encodingStyle, null);
                    try {
                        return Deserialize(reader);
                    }
                    finally {
                        reader.Dispose();
                    }
                }
                return tempAssembly.InvokeReader(methodIndex, xmlReader, events, encodingStyle);
            }
            catch (Exception e) {
                if (e is TargetInvocationException)
                    e = e.InnerException;

                if (xmlReader is XmlTextReader) {
                    XmlTextReader xmlTextReader = (XmlTextReader)xmlReader;
                    throw new InvalidOperationException(Res.GetString(Res.XmlSerializeErrorDetails, xmlTextReader.LineNumber.ToString(), xmlTextReader.LinePosition.ToString()), e);
                }
                else {
                    throw new InvalidOperationException(Res.GetString(Res.XmlSerializeError), e);
                }
            }
        }
                                 
        /// <include file='doc\XmlSerializer.uex' path='docs/doc[@for="XmlSerializer.CanDeserialize"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public virtual bool CanDeserialize(XmlReader xmlReader) {
            return tempAssembly.CanRead(methodIndex, xmlReader);
        }

        /// <include file='doc\XmlSerializer.uex' path='docs/doc[@for="XmlSerializer.FromMappings"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static XmlSerializer[] FromMappings(XmlMapping[] mappings) {
            if (mappings.Length == 0) return new XmlSerializer[0];
            TempAssembly tempAssembly = new TempAssembly(mappings);
            XmlSerializer[] serializers = new XmlSerializer[mappings.Length];
            for (int i = 0; i < serializers.Length; i++)
                serializers[i] = new XmlSerializer(tempAssembly, i);
            return serializers;
        }

        /// <include file='doc\XmlSerializer.uex' path='docs/doc[@for="XmlSerializer.FromTypes"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static XmlSerializer[] FromTypes(Type[] types) {
            XmlReflectionImporter importer = new XmlReflectionImporter();
            XmlTypeMapping[] mappings = new XmlTypeMapping[types.Length];
            for (int i = 0; i < types.Length; i++) {
                mappings[i] = importer.ImportTypeMapping(types[i]);
            }
            return FromMappings(mappings);
        }

        /// <include file='doc\XmlSerializer.uex' path='docs/doc[@for="XmlSerializer.UnknownNode"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public event XmlNodeEventHandler UnknownNode {
            add {
                events.onUnknownNode += value;
            }
            remove {
                events.onUnknownNode -= value;
            }
        }

        /// <include file='doc\XmlSerializer.uex' path='docs/doc[@for="XmlSerializer.UnknownAttribute"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public event XmlAttributeEventHandler UnknownAttribute {
            add {
                events.onUnknownAttribute += value;
            }
            remove {
                events.onUnknownAttribute -= value;
            }
        }
        
        /// <include file='doc\XmlSerializer.uex' path='docs/doc[@for="XmlSerializer.UnknownElement"]/*' />
        public event XmlElementEventHandler UnknownElement {
            add {
                events.onUnknownElement += value;
            }
            remove {
                events.onUnknownElement -= value;
            }
        }

        /// <include file='doc\XmlSerializer.uex' path='docs/doc[@for="XmlSerializer.UnreferencedObject"]/*' />
        public event UnreferencedObjectEventHandler UnreferencedObject {
            add {
                events.onUnreferencedObject += value;
            }
            remove {
                events.onUnreferencedObject -= value;
            }
        }

        /// <include file='doc\XmlSerializer.uex' path='docs/doc[@for="XmlSerializer.CreateReader"]/*' />
        ///<internalonly/>
        protected virtual XmlSerializationReader CreateReader() {throw new NotImplementedException();}
        /// <include file='doc\XmlSerializer.uex' path='docs/doc[@for="XmlSerializer.Deserialize4"]/*' />
        ///<internalonly/>
        protected virtual object Deserialize(XmlSerializationReader reader){throw new NotImplementedException();}
        /// <include file='doc\XmlSerializer.uex' path='docs/doc[@for="XmlSerializer.CreateWriter"]/*' />
        ///<internalonly/>
        protected virtual XmlSerializationWriter CreateWriter(){throw new NotImplementedException();}
        /// <include file='doc\XmlSerializer.uex' path='docs/doc[@for="XmlSerializer.Serialize7"]/*' />
        ///<internalonly/>
        protected virtual void Serialize(object o, XmlSerializationWriter writer){throw new NotImplementedException();}
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\serialization\xmlserializernamespaces.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlSerializerNamespaces.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Serialization {

    using System.Reflection;
    using System.Collections;
    using System.IO;
    using System.Xml.Schema;
    using System;

    /// <include file='doc\XmlSerializerNamespaces.uex' path='docs/doc[@for="XmlSerializerNamespaces"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public class XmlSerializerNamespaces {
        Hashtable namespaces = null;

        /// <include file='doc\XmlSerializerNamespaces.uex' path='docs/doc[@for="XmlSerializerNamespaces.XmlSerializerNamespaces"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public XmlSerializerNamespaces() {
        }


        /// <include file='doc\XmlSerializerNamespaces.uex' path='docs/doc[@for="XmlSerializerNamespaces.XmlSerializerNamespaces1"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public XmlSerializerNamespaces(XmlSerializerNamespaces namespaces) {
            this.namespaces = (Hashtable)namespaces.Namespaces.Clone();
        }

        /// <include file='doc\XmlSerializerNamespaces.uex' path='docs/doc[@for="XmlSerializerNamespaces.XmlSerializerNamespaces2"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public XmlSerializerNamespaces(XmlQualifiedName[] namespaces) {
            for (int i = 0; i < namespaces.Length; i++) {
                XmlQualifiedName qname = namespaces[i];
                Add(qname.Name, qname.Namespace);
            }
        }
        
        /// <include file='doc\XmlSerializerNamespaces.uex' path='docs/doc[@for="XmlSerializerNamespaces.Add"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void Add(string prefix, string ns) {
            // parameter value check
            if (prefix != null && prefix.Length > 0)
                XmlConvert.VerifyNCName(prefix);
            if (ns != null && ns.Length > 0)
                XmlConvert.ToUri(ns);

            Namespaces[prefix] = ns;
        }

        /// <include file='doc\XmlSerializerNamespaces.uex' path='docs/doc[@for="XmlSerializerNamespaces.ToArray"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public XmlQualifiedName[] ToArray() {
            return (XmlQualifiedName[])NamespaceList.ToArray(typeof(XmlQualifiedName));
        }

        /// <include file='doc\XmlSerializerNamespaces.uex' path='docs/doc[@for="XmlSerializerNamespaces.Count"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public int Count {
            get { return Namespaces.Count; }
        }

        internal ArrayList NamespaceList {
            get {
                ArrayList namespaceList = new ArrayList();
                foreach(string key in Namespaces.Keys) {
                    namespaceList.Add(new XmlQualifiedName(key, (string)namespaces[key]));
                }
                return namespaceList;
            }
        }

        internal Hashtable Namespaces {
            get {
                if (namespaces == null)
                    namespaces = new Hashtable();
                return namespaces;
            }
            set { namespaces = value; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\serialization\xmltextattribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlTextAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Serialization {

    using System;
    
    /// <include file='doc\XmlTextAttribute.uex' path='docs/doc[@for="XmlTextAttribute"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [AttributeUsage(AttributeTargets.Field | AttributeTargets.Property | AttributeTargets.Parameter | AttributeTargets.ReturnValue)]
    public class XmlTextAttribute : System.Attribute {
        Type type;
        string dataType;

        /// <include file='doc\XmlTextAttribute.uex' path='docs/doc[@for="XmlTextAttribute.XmlTextAttribute"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public XmlTextAttribute() {
        }
        
        /// <include file='doc\XmlTextAttribute.uex' path='docs/doc[@for="XmlTextAttribute.XmlTextAttribute1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public XmlTextAttribute(Type type) {
            this.type = type;
        }
        
        /// <include file='doc\XmlTextAttribute.uex' path='docs/doc[@for="XmlTextAttribute.Type"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public Type Type {
            get { return type; }
            set { type = value; }
        }

        /// <include file='doc\XmlTextAttribute.uex' path='docs/doc[@for="XmlTextAttribute.DataType"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public string DataType {
            get { return dataType == null ? string.Empty : dataType; }
            set { dataType = value; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\serialization\xmlschemaimporter.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlSchemaImporter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

namespace System.Xml.Serialization  {

    using System;
    using System.Xml.Schema;
    using System.Collections;
    using System.ComponentModel;
    using System.Reflection;
#if DEBUG
    using System.Diagnostics;
#endif

    /// <include file='doc\XmlSchemaImporter.uex' path='docs/doc[@for="XmlSchemaImporter"]/*' />
    ///<internalonly/>
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public class XmlSchemaImporter {
        XmlSchemas schemas;
        Hashtable elements = new Hashtable(); // XmlSchemaElement -> ElementAccessor
        Hashtable mappings = new Hashtable(); // XmlSchema -> SerializableMapping, XmlSchemaSimpleType -> EnumMapping, XmlSchemaComplexType -> StructMapping
        StructMapping root;
        CodeIdentifiers typeIdentifiers;
        TypeScope scope = new TypeScope();
        bool rootImported;

        /// <include file='doc\XmlSchemaImporter.uex' path='docs/doc[@for="XmlSchemaImporter.XmlSchemaImporter"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public XmlSchemaImporter(XmlSchemas schemas) {
            this.schemas = schemas;
            this.typeIdentifiers = new CodeIdentifiers();
        }

        /// <include file='doc\XmlSchemaImporter.uex' path='docs/doc[@for="XmlSchemaImporter.XmlSchemaImporter1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public XmlSchemaImporter(XmlSchemas schemas, CodeIdentifiers typeIdentifiers) {
            this.schemas = schemas;
            this.typeIdentifiers = typeIdentifiers;
        }

        /// <include file='doc\XmlSchemaImporter.uex' path='docs/doc[@for="XmlSchemaImporter.ImportDerivedTypeMapping"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public XmlTypeMapping ImportDerivedTypeMapping(XmlQualifiedName name, Type baseType) {
            return ImportDerivedTypeMapping(name, baseType, false);
        }

        XmlQualifiedName EncodeQName(XmlQualifiedName qname) {
            return new XmlQualifiedName(Accessor.EscapeName(qname.Name, false), qname.Namespace);
        }

        /// <include file='doc\XmlSchemaImporter.uex' path='docs/doc[@for="XmlSchemaImporter.ImportDerivedTypeMapping1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public XmlTypeMapping ImportDerivedTypeMapping(XmlQualifiedName name, Type baseType, bool baseTypeCanBeIndirect) {
            ElementAccessor element = ImportElement(EncodeQName(name), typeof(TypeMapping), baseType);

            if (element.Mapping is StructMapping) {
                MakeDerived((StructMapping)element.Mapping, baseType, baseTypeCanBeIndirect);
            }
            else if (baseType != null) {
                if (element.Mapping is ArrayMapping && ((ArrayMapping)element.Mapping).TopLevelMapping != null) {
                    // in the case of the ArrayMapping we can use the top-level StructMapping, because it does not have base base type
                    element.Mapping = ((ArrayMapping)element.Mapping).TopLevelMapping;
                    MakeDerived((StructMapping)element.Mapping, baseType, baseTypeCanBeIndirect);
                }
                else {
                    // Element '{0}' from namespace '{1}' is not a complex type and cannot be used as a {2}.
                    throw new InvalidOperationException(Res.GetString(Res.XmlBadBaseType, name.Name, name.Namespace, baseType.FullName));
                }
            }
            return new XmlTypeMapping(scope, element);
        }

        /// <include file='doc\XmlSchemaImporter.uex' path='docs/doc[@for="XmlSchemaImporter.ImportTypeMapping"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public XmlTypeMapping ImportTypeMapping(XmlQualifiedName name) {
            return ImportDerivedTypeMapping(name, null);
        }

        /// <include file='doc\XmlSchemaImporter.uex' path='docs/doc[@for="XmlSchemaImporter.ImportMembersMapping"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public XmlMembersMapping ImportMembersMapping(XmlQualifiedName name) {
            return new XmlMembersMapping(scope, ImportElement(EncodeQName(name), typeof(MembersMapping), null));
        }

        /// <include file='doc\XmlSchemaImporter.uex' path='docs/doc[@for="XmlSchemaImporter.ImportAnyType"]/*' />
        public XmlMembersMapping ImportAnyType(XmlQualifiedName typeName, string elementName) {
            MembersMapping mapping = (MembersMapping) ImportType(EncodeQName(typeName), typeof(MembersMapping), null);
            if (mapping.Members.Length != 1 || !mapping.Members[0].Accessor.Any)
                return null;
            mapping.Members[0].Name = elementName;
            ElementAccessor accessor = new ElementAccessor();
            accessor.Name = elementName;
            accessor.Namespace = typeName.Namespace;
            accessor.Mapping = mapping;
            accessor.Any = true;
            XmlSchema schema = schemas[typeName.Namespace];
            if (schema != null) accessor.Form = ElementFormDefault(schema);
            XmlMembersMapping members = new XmlMembersMapping(scope, accessor);
            return members;
        }

        /// <include file='doc\XmlSchemaImporter.uex' path='docs/doc[@for="XmlSchemaImporter.ImportMembersMapping1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public XmlMembersMapping ImportMembersMapping(XmlQualifiedName[] names) {
            return ImportMembersMapping(names, null, false);
        }

        /// <include file='doc\XmlSchemaImporter.uex' path='docs/doc[@for="XmlSchemaImporter.ImportMembersMapping2"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public XmlMembersMapping ImportMembersMapping(XmlQualifiedName[] names, Type baseType, bool baseTypeCanBeIndirect) {
            CodeIdentifiers memberScope = new CodeIdentifiers();
            memberScope.UseCamelCasing = true;
            MemberMapping[] members = new MemberMapping[names.Length];
            for (int i = 0; i < names.Length; i++) {
                XmlQualifiedName name = EncodeQName(names[i]);
                ElementAccessor accessor = ImportElement(name, typeof(TypeMapping), baseType);
                if (baseType != null && accessor.Mapping is StructMapping)
                    MakeDerived((StructMapping)accessor.Mapping, baseType, baseTypeCanBeIndirect);

                MemberMapping member = new MemberMapping();
                member.Name = CodeIdentifier.MakeValid(Accessor.UnescapeName(accessor.Name));
                member.Name = memberScope.AddUnique(member.Name, member);
                member.TypeDesc = accessor.Mapping.TypeDesc;
                member.Elements = new ElementAccessor[] { accessor };
                members[i] = member;
            }

            MembersMapping mapping = new MembersMapping();
            mapping.HasWrapperElement = false;
            mapping.TypeDesc = scope.GetTypeDesc(typeof(object[]));
            mapping.Members = members;
            ElementAccessor element = new ElementAccessor();
            element.Mapping = mapping;
            return new XmlMembersMapping(scope, element);
        }

        void MakeDerived(StructMapping structMapping, Type baseType, bool baseTypeCanBeIndirect) {
            structMapping.ReferencedByTopLevelElement = true;
            TypeDesc baseTypeDesc;
            if (baseType != null) {
                baseTypeDesc = scope.GetTypeDesc(baseType);
                if (baseTypeDesc != null) {
                    TypeDesc typeDescToChange = structMapping.TypeDesc;
                    if (baseTypeCanBeIndirect) {
                        // if baseTypeCanBeIndirect is true, we apply the supplied baseType to the top of the
                        // inheritance chain, not necessarily directly to the imported type.
                        while (typeDescToChange.BaseTypeDesc != null && typeDescToChange.BaseTypeDesc != baseTypeDesc)
                            typeDescToChange = typeDescToChange.BaseTypeDesc;
                    }
                    if (typeDescToChange.BaseTypeDesc != null && typeDescToChange.BaseTypeDesc != baseTypeDesc)
                        throw new InvalidOperationException(Res.GetString(Res.XmlInvalidBaseType, structMapping.TypeDesc.FullName, baseType.FullName, typeDescToChange.BaseTypeDesc.FullName));
                    typeDescToChange.BaseTypeDesc = baseTypeDesc;
                }
            }
        }

        ElementAccessor ImportElement(XmlQualifiedName name, Type desiredMappingType, Type baseType) {
            XmlSchemaElement element = FindElement(name);
            ElementAccessor accessor = (ElementAccessor)elements[element];
            if (accessor != null) return accessor;
            accessor = ImportElement(element, string.Empty, desiredMappingType, baseType, name.Namespace, true);
            ElementAccessor existing = (ElementAccessor)elements[element];
            if (existing != null) {
                #if DEBUG
                if (existing.Mapping != accessor.Mapping)
                    throw new InvalidOperationException(Res.GetString(Res.XmlInternalErrorDetails, "element redefinition: " + name));
                #endif
                return existing;
            }
            elements.Add(element, accessor);
            return accessor;
        }

        ElementAccessor ImportElement(XmlSchemaElement element, string identifier, Type desiredMappingType, Type baseType, string ns, bool topLevelElement) {
            if (!element.RefName.IsEmpty) {
                return ImportElement(element.RefName, desiredMappingType, baseType);
            }
            if (element.Name.Length == 0) throw new InvalidOperationException(Res.GetString(Res.XmlElementHasNoName));
            string unescapedName = Accessor.UnescapeName(element.Name);
            if (identifier.Length == 0)
                identifier = CodeIdentifier.MakeValid(unescapedName);
            else
                identifier += CodeIdentifier.MakePascal(unescapedName);
            TypeMapping mapping = ImportElementType(element, identifier, desiredMappingType, baseType, ns);
            ElementAccessor accessor = new ElementAccessor();
            accessor.IsTopLevelInSchema = (schemas.Find(new XmlQualifiedName(element.Name, ns), typeof(XmlSchemaElement)) != null);
            accessor.Name = element.Name;
            accessor.Namespace = ns;
            accessor.Mapping = mapping;
            accessor.Default = ImportDefaultValue(mapping, element.DefaultValue);
            if (mapping is SpecialMapping && ((SpecialMapping)mapping).NamedAny)
                accessor.Any = true;
            if (mapping.TypeDesc.IsNullable)
                accessor.IsNullable = element.IsNillable;
            if (topLevelElement) {
                accessor.Form = XmlSchemaForm.Qualified;
            }
            else if (element.Form == XmlSchemaForm.None) {
                XmlSchema schema = schemas[ns];
                if (schema != null) accessor.Form = ElementFormDefault(schema);
            }
            else
                accessor.Form = element.Form;

            return accessor;
        }

        TypeMapping ImportElementType(XmlSchemaElement element, string identifier, Type desiredMappingType, Type baseType, string ns) {
            TypeMapping mapping;
            if (!element.SchemaTypeName.IsEmpty)
                mapping = ImportType(element.SchemaTypeName, desiredMappingType, baseType);
            else if (element.SchemaType != null) {
                if (element.SchemaType is XmlSchemaComplexType)
                    mapping = ImportType((XmlSchemaComplexType)element.SchemaType, ns, identifier, desiredMappingType, baseType);
                else
                    mapping = ImportDataType((XmlSchemaSimpleType)element.SchemaType, ns, identifier, baseType);
            }
            else if (!element.SubstitutionGroup.IsEmpty)
                mapping = ImportElementType(FindElement(element.SubstitutionGroup), identifier, desiredMappingType, baseType, ns);
            else {
                if (desiredMappingType == typeof(MembersMapping)) {
                    mapping = ImportMembersType(new XmlSchemaType(), ns, identifier);
                }
                else {
                    mapping = ImportRootMapping();
                }
            }
            if (!(desiredMappingType.IsAssignableFrom(mapping.GetType())))
                throw new InvalidOperationException(Res.GetString(Res.XmlElementImportedTwice, element.Name, ns, mapping.GetType().Name, desiredMappingType.Name));

            mapping.ReferencedByElement = true;

            return mapping;
        }

        string GenerateUniqueTypeName(string typeName) {
            typeName = CodeIdentifier.MakeValid(typeName);
            return typeIdentifiers.AddUnique(typeName, typeName);
        }

        string GenerateUniqueTypeName(string desiredName, string ns) {
            int i = 1;

            string typeName = desiredName;
            while (true) {
                XmlQualifiedName qname = new XmlQualifiedName(typeName, ns);

                object type = schemas.Find(qname, typeof(XmlSchemaComplexType));
                if (type == null) {
                    type = schemas.Find(qname, typeof(XmlSchemaSimpleType));
                }
                if (type == null) {
                    break;
                }
                typeName = desiredName + i.ToString();
                i++;
            }
            return typeIdentifiers.AddUnique(typeName, typeName);
        }

        StructMapping CreateRootMapping() {
            TypeDesc typeDesc = scope.GetTypeDesc(typeof(object));
            StructMapping mapping = new StructMapping();
            mapping.TypeDesc = typeDesc;
            mapping.Members = new MemberMapping[0];
            mapping.IncludeInSchema = false;
            mapping.TypeName = Soap.UrType;
            mapping.Namespace = XmlSchema.Namespace;

            return mapping;
        }

        StructMapping GetRootMapping() {
            if (root == null)
                root = CreateRootMapping();
            return root;
        }

        StructMapping ImportRootMapping() {
            if (!rootImported) {
                rootImported = true;
                ImportDerivedTypes(XmlQualifiedName.Empty);
            }
            return GetRootMapping();
        }

        void ImportDerivedTypes(XmlQualifiedName baseName) {
            foreach (XmlSchema schema in schemas) {
                if (XmlSchemas.IsDataSet(schema)) continue;
                foreach (object item in schema.Items) {
                    if (item is XmlSchemaComplexType) {
                        XmlSchemaComplexType type = (XmlSchemaComplexType)item;
                        if (type.DerivedFrom == baseName) {
                            ImportType(new XmlQualifiedName(type.Name, schema.TargetNamespace), typeof(TypeMapping), null);
                        }
                    }
                }
            }
        }

        TypeMapping ImportType(XmlQualifiedName name, Type desiredMappingType, Type baseType) {
            if (name.Name == Soap.UrType && name.Namespace == XmlSchema.Namespace)
                return ImportRootMapping();
            object type = FindType(name);
            TypeMapping mapping = (TypeMapping)mappings[type];
            if (mapping != null && desiredMappingType.IsAssignableFrom(mapping.GetType()))
                return mapping;

            if (type is XmlSchemaComplexType)
                mapping = ImportType((XmlSchemaType)type, name.Namespace, name.Name, desiredMappingType, baseType);
            else if (type is XmlSchemaSimpleType)
                mapping = ImportDataType((XmlSchemaSimpleType)type, name.Namespace, name.Name, baseType);
            else
                throw new InvalidOperationException(Res.GetString(Res.XmlInternalError));
            return mapping;
        }

        TypeMapping ImportType(XmlSchemaType type, string typeNs, string identifier, Type desiredMappingType, Type baseType) {
            if (type.Redefined != null) {
                // we do not support redefine in the current version
                throw new NotSupportedException(Res.GetString(Res.XmlUnsupportedRedefine, type.Name, typeNs));
            }
            if (desiredMappingType == typeof(TypeMapping)) {
                TypeMapping mapping = null;
                if (baseType == null) {
                    if ((mapping = ImportArrayMapping(type, identifier, typeNs, false)) == null) {
                        if ((mapping = ImportSerializable(type, identifier, typeNs)) == null) {
                            mapping = ImportAnyMapping(type, identifier, typeNs, false);
                        }
                    }
                }
                if (mapping == null) {
                    mapping = ImportStructType(type, typeNs, identifier, baseType, false);

                    if (mapping != null && type.Name != null && type.Name.Length != 0)
                        ImportDerivedTypes(new XmlQualifiedName(identifier, typeNs));

                }
                return mapping;
            }
            else if (desiredMappingType == typeof(MembersMapping))
                return ImportMembersType(type, typeNs, identifier);
            else
                throw new ArgumentException(Res.GetString(Res.XmlInternalError), "desiredMappingType");
        }

        MembersMapping ImportMembersType(XmlSchemaType type, string typeNs, string identifier) {
            if (!type.DerivedFrom.IsEmpty) throw new InvalidOperationException(Res.GetString(Res.XmlMembersDeriveError));
            CodeIdentifiers memberScope = new CodeIdentifiers();
            memberScope.UseCamelCasing = true;
            MemberMapping[] members = ImportTypeMembers(type, typeNs, identifier, memberScope, new CodeIdentifiers());
            MembersMapping mappings = new MembersMapping();
            mappings.HasWrapperElement = true;
            mappings.TypeDesc = scope.GetTypeDesc(typeof(object[]));
            mappings.Members = members;
            return mappings;
        }

        StructMapping ImportStructType(XmlSchemaType type, string typeNs, string identifier, Type baseType, bool arrayLike) {
            TypeDesc baseTypeDesc = null;
            Mapping baseMapping = null;

            if (!type.DerivedFrom.IsEmpty) {
                baseMapping = ImportType(type.DerivedFrom, typeof(TypeMapping), null);

                if (baseMapping is StructMapping)
                    baseTypeDesc = ((StructMapping)baseMapping).TypeDesc;
                else if (baseMapping is ArrayMapping) {
                    baseMapping = ((ArrayMapping)baseMapping).TopLevelMapping;
                    if (baseMapping != null) {
                        ((StructMapping)baseMapping).ReferencedByTopLevelElement = false;
                        baseTypeDesc = ((StructMapping)baseMapping).TypeDesc;
                    }
                }
                else
                    baseMapping = null;
            }
            if (baseTypeDesc == null && baseType != null)
                baseTypeDesc = scope.GetTypeDesc(baseType);
            if (baseMapping == null) baseMapping = GetRootMapping();
            Mapping previousMapping = (Mapping)mappings[type];
            if (previousMapping != null) {
                if (previousMapping is StructMapping) {
                    return (StructMapping)previousMapping;
                }
                else {
                    if (!arrayLike) {
                        throw new InvalidOperationException(Res.GetString(Res.XmlTypeUsedTwice, type.QualifiedName.Name, type.QualifiedName.Namespace));
                    }
                }
            }
            string typeName = GenerateUniqueTypeName(identifier);
            StructMapping structMapping = new StructMapping();
            TypeFlags flags = TypeFlags.Reference;
            if (type is XmlSchemaComplexType) {
                if (((XmlSchemaComplexType)type).IsAbstract) flags |= TypeFlags.Abstract;
            }
            structMapping.TypeDesc = new TypeDesc(typeName, typeName, TypeKind.Struct, baseTypeDesc, flags);
            structMapping.Namespace = typeNs;
            structMapping.TypeName = identifier;
            structMapping.BaseMapping = (StructMapping)baseMapping;
            if (!arrayLike)
                mappings.Add(type, structMapping);
            CodeIdentifiers members = new CodeIdentifiers();
            CodeIdentifiers membersScope = structMapping.BaseMapping.Scope.Clone();
            members.AddReserved(typeName);
            membersScope.AddReserved(typeName);
            structMapping.Members = ImportTypeMembers(type, typeNs, identifier, members, membersScope);

            // CONSIDER, elenak: this is invalid xsd. Maybe we should validate schemas up-front.
            for (int i = 0; i < structMapping.Members.Length; i++) {
                StructMapping declaringMapping;
                MemberMapping baseMember = ((StructMapping)baseMapping).FindDeclaringMapping(structMapping.Members[i], out declaringMapping, structMapping.TypeName);
                if (baseMember != null && baseMember.TypeDesc != structMapping.Members[i].TypeDesc)
                    throw new InvalidOperationException(Res.GetString(Res.XmlIllegalOverride, type.Name, baseMember.Name, baseMember.TypeDesc.FullName, structMapping.Members[i].TypeDesc.FullName, declaringMapping.TypeDesc.FullName));
            }
            structMapping.Scope = membersScope;
            scope.AddTypeMapping(structMapping);
            return structMapping;
        }

        StructMapping ImportStructDataType(XmlSchemaSimpleType dataType, string typeNs, string identifier, Type baseType) {
            string typeName = GenerateUniqueTypeName(identifier);
            StructMapping structMapping = new StructMapping();
            TypeFlags flags = TypeFlags.Reference;
            TypeDesc baseTypeDesc = scope.GetTypeDesc(baseType);
            structMapping.TypeDesc = new TypeDesc(typeName, typeName, TypeKind.Struct, baseTypeDesc, flags);
            structMapping.Namespace = typeNs;
            structMapping.TypeName = identifier;
            CodeIdentifiers members = new CodeIdentifiers();
            members.AddReserved(typeName);
            ImportTextMember(members, new CodeIdentifiers(), null);
            structMapping.Members = (MemberMapping[])members.ToArray(typeof(MemberMapping));
            structMapping.Scope = members;
            scope.AddTypeMapping(structMapping);
            return structMapping;
        }

        internal class TypeItems {
            internal XmlSchemaObjectCollection Attributes = new XmlSchemaObjectCollection();
            internal XmlSchemaAnyAttribute AnyAttribute;
            internal XmlSchemaGroupBase Particle;
            internal XmlQualifiedName baseSimpleType;
        }

        MemberMapping[] ImportTypeMembers(XmlSchemaType type, string typeNs, string identifier, CodeIdentifiers members, CodeIdentifiers membersScope) {
            TypeItems items = GetTypeItems(type);
            bool mixed = IsMixed(type);

            if (mixed) {
                // check if we can transfer the attribute to the base class
                XmlSchemaType t = type;
                while (!t.DerivedFrom.IsEmpty) {
                    t = FindType(t.DerivedFrom);
                    if (IsMixed(t)) {
                        // keep the mixed attribute on the base class
                        mixed = false;
                        break;
                    }
                }
            }

            if (items.Particle != null) {
                ImportGroup(items.Particle, identifier, members, membersScope, typeNs, mixed);
            }
            for (int i = 0; i < items.Attributes.Count; i++) {
                object item = items.Attributes[i];
                if (item is XmlSchemaAttribute) {
                    ImportAttributeMember((XmlSchemaAttribute)item, identifier, members, membersScope, typeNs);
                }
                else if (item is XmlSchemaAttributeGroupRef) {
                    ImportAttributeGroupMembers(FindAttributeGroup(((XmlSchemaAttributeGroupRef)item).RefName), identifier, members, membersScope, typeNs);
                }
            }
            if (items.AnyAttribute != null) {
                ImportAnyAttributeMember(items.AnyAttribute, members, membersScope);
            }
            
            if (items.baseSimpleType != null || (items.Particle == null && mixed)) {
                ImportTextMember(members, membersScope, mixed ? null : items.baseSimpleType);
            }

            ImportXmlnsDeclarationsMember(type, members, membersScope);
            return (MemberMapping[])members.ToArray(typeof(MemberMapping));
        }

        internal static bool IsMixed(XmlSchemaType type) {
            if (!(type is XmlSchemaComplexType))
                return false;

            XmlSchemaComplexType ct = (XmlSchemaComplexType)type;
            bool mixed = ct.IsMixed;

            // check the mixed attribute on the complexContent
            if (!mixed) {
                if (ct.ContentModel != null && ct.ContentModel is XmlSchemaComplexContent) {
                    mixed = ((XmlSchemaComplexContent)ct.ContentModel).IsMixed;
                }
            }
            return mixed;
        }

        TypeItems GetTypeItems(XmlSchemaType type) {
            TypeItems items = new TypeItems();
            if (type is XmlSchemaComplexType) {
                XmlSchemaParticle particle = null;
                XmlSchemaComplexType ct = (XmlSchemaComplexType)type;
                if (ct.ContentModel != null) {
                    XmlSchemaContent content = ct.ContentModel.Content;
                    if (content is XmlSchemaComplexContentExtension) {
                        XmlSchemaComplexContentExtension extension = (XmlSchemaComplexContentExtension)content;
                        items.Attributes = extension.Attributes;
                        items.AnyAttribute = extension.AnyAttribute;
                        particle = extension.Particle;
                    }
                    else if (content is XmlSchemaSimpleContentExtension) {
                        XmlSchemaSimpleContentExtension extension = (XmlSchemaSimpleContentExtension)content;
                        items.Attributes = extension.Attributes;
                        items.AnyAttribute = extension.AnyAttribute;
                        items.baseSimpleType = extension.BaseTypeName;
                    }
                }
                else {
                    items.Attributes = ct.Attributes;
                    items.AnyAttribute = ct.AnyAttribute;
                    particle = ct.Particle;
                }
                if (particle is XmlSchemaGroupRef) {
                    XmlSchemaGroupRef refGroup = (XmlSchemaGroupRef)particle;
                    items.Particle = FindGroup(refGroup.RefName).Particle;
                }
                else if (particle is XmlSchemaGroupBase) {
                    items.Particle = (XmlSchemaGroupBase)particle;
                }
            }
            return items;
        }

        void ImportGroup(XmlSchemaParticle group, string identifier, CodeIdentifiers members, CodeIdentifiers membersScope, string ns, bool mixed) {
            if (group is XmlSchemaChoice)
                ImportChoiceGroup((XmlSchemaChoice)group, identifier, members, membersScope, ns, false);
            else
                ImportGroupMembers(group, identifier, members, membersScope, ns, false, ref mixed);

            if (mixed) {
                ImportTextMember(members, membersScope, null);
            }
        }

        MemberMapping ImportChoiceGroup(XmlSchemaChoice group, string identifier, CodeIdentifiers members, CodeIdentifiers membersScope, string ns, bool groupRepeats) {
            NameTable choiceElements = new NameTable();
            if (GatherGroupChoices(group, choiceElements, identifier, ns))
                groupRepeats = true;
            MemberMapping member = new MemberMapping();
            member.Elements = (ElementAccessor[])choiceElements.ToArray(typeof(ElementAccessor));

            bool duplicateTypes = false;
            Hashtable uniqueTypeDescs = new Hashtable(member.Elements.Length);

            for (int i = 0; i < member.Elements.Length; i++) {
                TypeDesc td = member.Elements[i].Mapping.TypeDesc;
                if (uniqueTypeDescs.Contains(td.FullName)) {
                    duplicateTypes = true;
                }
                else {
                    uniqueTypeDescs.Add(td.FullName, td);
                }
            }
            TypeDesc[] typeDescs = new TypeDesc[uniqueTypeDescs.Count];
            uniqueTypeDescs.Values.CopyTo(typeDescs, 0);
            member.TypeDesc = TypeDesc.FindCommonBaseTypeDesc(typeDescs);
            if (member.TypeDesc == null) member.TypeDesc = scope.GetTypeDesc(typeof(object));

            if (groupRepeats)
                member.TypeDesc = member.TypeDesc.CreateArrayTypeDesc();

            if (membersScope != null) {
                member.Name = membersScope.AddUnique(groupRepeats ? "Items" : "Item", member);
                if (members != null) {
                    members.Add(member.Name, member);
                }
            }

            if (duplicateTypes) {
                member.ChoiceIdentifier = new ChoiceIdentifierAccessor();
                member.ChoiceIdentifier.MemberName = member.Name + "ElementName";
                // we need to create the EnumMapping to store all of the element names
                member.ChoiceIdentifier.Mapping = ImportEnumeratedChoice(member.Elements, ns, member.Name + "ChoiceType");
                member.ChoiceIdentifier.MemberIds = new string[member.Elements.Length];
                ConstantMapping[] constants = ((EnumMapping)member.ChoiceIdentifier.Mapping).Constants;
                for (int i = 0; i < member.Elements.Length; i++) {
                    member.ChoiceIdentifier.MemberIds[i] = constants[i].Name;
                }
                MemberMapping choiceIdentifier = new MemberMapping();
                choiceIdentifier.Ignore = true;
                choiceIdentifier.Name = member.ChoiceIdentifier.MemberName;
                if (groupRepeats) {
                    choiceIdentifier.TypeDesc = member.ChoiceIdentifier.Mapping.TypeDesc.CreateArrayTypeDesc();
                }
                else {
                    choiceIdentifier.TypeDesc = member.ChoiceIdentifier.Mapping.TypeDesc;
                }

                // create element accessor for the choiceIdentifier

                ElementAccessor choiceAccessor = new ElementAccessor();
                choiceAccessor.Name = choiceIdentifier.Name;
                choiceAccessor.Namespace = ns;
                choiceAccessor.Mapping =  member.ChoiceIdentifier.Mapping;
                choiceIdentifier.Elements  = new ElementAccessor[] {choiceAccessor};

                if (membersScope != null) {
                    choiceAccessor.Name = choiceIdentifier.Name = member.ChoiceIdentifier.MemberName = membersScope.AddUnique(member.ChoiceIdentifier.MemberName, choiceIdentifier);
                    if (members != null) {
                        members.Add(choiceAccessor.Name, choiceIdentifier);
                    }
                }
            }
            return member;
        }

        bool GatherGroupChoices(XmlSchemaGroup group, NameTable choiceElements, string identifier, string ns) {
            return GatherGroupChoices(group.Particle, choiceElements, identifier, ns);
        }

        bool GatherGroupChoices(XmlSchemaParticle particle, NameTable choiceElements, string identifier, string ns) {
            if (particle is XmlSchemaGroupRef) {
                XmlSchemaGroupRef refGroup = (XmlSchemaGroupRef)particle;
                if (!refGroup.RefName.IsEmpty)
                    return GatherGroupChoices(FindGroup(refGroup.RefName), choiceElements, identifier, refGroup.RefName.Namespace);
            }
            else if (particle is XmlSchemaGroupBase) {
                XmlSchemaGroupBase group = (XmlSchemaGroupBase)particle;
                bool groupRepeats = group.IsMultipleOccurrence;
                XmlSchemaAny any = null;
                for (int i = 0; i < group.Items.Count; i++) {
                    object item = group.Items[i];
                    if (item is XmlSchemaGroupBase) {
                        if (GatherGroupChoices((XmlSchemaParticle)item, choiceElements, identifier, ns))
                            groupRepeats = true;
                    }
                    else if (item is XmlSchemaAny) {
                        any = (XmlSchemaAny)item;
                    }
                    else if (item is XmlSchemaElement) {
                        XmlSchemaElement element = (XmlSchemaElement)item;
                        XmlSchemaElement abstractElement = GetAbstractElement(element);
                        if (abstractElement != null) {
                            XmlSchemaElement[] elements = GetEquivalentElements(abstractElement);
                            for (int j = 0; j < elements.Length; j++) {
                                if (elements[j].IsMultipleOccurrence) groupRepeats = true;
                                AddChoiceElement(choiceElements, ImportElement(elements[j], identifier, typeof(TypeMapping), null, ns, true));
                            }
                        }
                        else {
                            if (element.IsMultipleOccurrence) groupRepeats = true;
                            AddChoiceElement(choiceElements, ImportElement(element, identifier, typeof(TypeMapping), null, ns, false));
                        }
                    }
                }
                if (any != null) {
                    AddChoiceElement(choiceElements, ImportAny(any, true));
                }

                return groupRepeats;
            }
            return false;
        }

        void AddChoiceElement(NameTable choiceElements, ElementAccessor element) {
            ElementAccessor scopeElement = (ElementAccessor)choiceElements[element.Name, element.Namespace];
            if (scopeElement != null) {
                if (scopeElement.Mapping.TypeDesc != element.Mapping.TypeDesc) {
                    throw new InvalidOperationException(Res.GetString(Res.XmlDuplicateChoiceElement, element.Name, element.Namespace));
                }
            }
            else {
                choiceElements[element.Name, element.Namespace] = element;
            }
        }

        void ImportGroupMembers(XmlSchemaParticle particle, string identifier, CodeIdentifiers members, CodeIdentifiers membersScope, string ns, bool groupRepeats, ref bool mixed) {

            if (particle is XmlSchemaGroupRef) {
                XmlSchemaGroupRef refGroup = (XmlSchemaGroupRef)particle;
                if (!refGroup.RefName.IsEmpty) {
                    ImportGroupMembers(FindGroup(refGroup.RefName).Particle, identifier, members, membersScope, refGroup.RefName.Namespace, groupRepeats, ref mixed);
                }
            }
            else if (particle is XmlSchemaGroupBase) {
                XmlSchemaGroupBase group = (XmlSchemaGroupBase)particle;

                if (group.IsMultipleOccurrence)
                    groupRepeats = true;

                for (int i = 0; i < group.Items.Count; i++) {
                    object item = group.Items[i];
                    if (item is XmlSchemaChoice)
                        ImportChoiceGroup((XmlSchemaChoice)item, identifier, members, membersScope, ns, groupRepeats);
                    else if (item is XmlSchemaElement)
                        ImportElementMember((XmlSchemaElement)item, identifier, members, membersScope, ns, groupRepeats);
                    else if (item is XmlSchemaAny) {
                        ImportAnyMember((XmlSchemaAny)item, identifier, members, membersScope, ns, ref mixed);
                    }
                    else if (item is XmlSchemaParticle) {
                        ImportGroupMembers((XmlSchemaParticle)item, identifier, members, membersScope, ns, groupRepeats, ref mixed);
                    }
                }
            }
        }

        XmlSchemaElement GetAbstractElement(XmlSchemaElement element) {
            while (!element.RefName.IsEmpty)
                element = FindElement(element.RefName);
            if (element.IsAbstract) return element;
            return null;
        }

        XmlSchemaElement[] GetEquivalentElements(XmlSchemaElement element) {
            ArrayList equivalentElements = new ArrayList();
            for (int i = 0; i < schemas.Count; i++) {
                XmlSchema schema = schemas[i];
                for (int j = 0; j < schema.Items.Count; j++) {
                    object item = schema.Items[j];
                    if (item is XmlSchemaElement) {
                        XmlSchemaElement equivalentElement = (XmlSchemaElement)item;
                        if (!equivalentElement.IsAbstract &&
                            equivalentElement.SubstitutionGroup.Namespace == schema.TargetNamespace &&
                            equivalentElement.SubstitutionGroup.Name == element.Name) {
                            equivalentElements.Add(equivalentElement);
                        }
                    }
                }
            }

            return (XmlSchemaElement[])equivalentElements.ToArray(typeof(XmlSchemaElement));
        }

        void ImportAbstractMember(XmlSchemaElement element, string identifier, CodeIdentifiers members, CodeIdentifiers membersScope, string ns, bool repeats) {
            XmlSchemaElement[] elements = GetEquivalentElements(element);
            XmlSchemaChoice choice = new XmlSchemaChoice();
            for (int i = 0; i < elements.Length; i++)
                choice.Items.Add(elements[i]);
            if (identifier.Length == 0)
                identifier = CodeIdentifier.MakeValid(Accessor.UnescapeName(element.Name));
            else
                identifier += CodeIdentifier.MakePascal(Accessor.UnescapeName(element.Name));
            ImportChoiceGroup(choice, identifier, members, membersScope, ns, repeats);
        }

        void ImportTextMember(CodeIdentifiers members, CodeIdentifiers membersScope, XmlQualifiedName simpleContentType) {
            TypeMapping mapping;
            bool isMixed = false;

            if (simpleContentType != null) {
                mapping = ImportType(simpleContentType, typeof(TypeMapping), null);
                if (!(mapping is PrimitiveMapping || mapping.TypeDesc.CanBeTextValue)) {
                    return;
                }
            }
            else {
                // this is a case of the mixed content type, just generate string typeDesc
                isMixed = true;
                mapping = new PrimitiveMapping();
                mapping.TypeDesc = scope.GetTypeDesc(typeof(string));
                mapping.TypeName = mapping.TypeDesc.DataType.Name;
            }

            TextAccessor accessor = new TextAccessor();
            accessor.Mapping = mapping;

            MemberMapping member = new MemberMapping();
            member.Elements = new ElementAccessor[0];
            member.Text = accessor;
            if (isMixed) {
                // just generate code for the standard mixed case (string[] text)
                member.TypeDesc = accessor.Mapping.TypeDesc.CreateArrayTypeDesc();
                member.Name = members.MakeRightCase("Text");
            }
            else {
                // import mapping for the simpleContent
                PrimitiveMapping pm = (PrimitiveMapping)accessor.Mapping;
                if (pm.IsList) {
                    member.TypeDesc = accessor.Mapping.TypeDesc.CreateArrayTypeDesc();
                    member.Name = members.MakeRightCase("Text");
                }
                else {
                    member.TypeDesc = accessor.Mapping.TypeDesc;
                    member.Name = members.MakeRightCase("Value");
                }
            }
            member.Name = membersScope.AddUnique(member.Name, member);
            members.Add(member.Name, member);
        }

        void ImportAnyMember(XmlSchemaAny any, string identifier, CodeIdentifiers members, CodeIdentifiers membersScope, string ns, ref bool mixed) {
            ElementAccessor accessor = ImportAny(any, !mixed);

            MemberMapping member = new MemberMapping();
            member.Elements = new ElementAccessor[] { accessor };
            member.Name = membersScope.MakeRightCase("Any");
            member.Name = membersScope.AddUnique(member.Name, member);
            members.Add(member.Name, member);
            member.TypeDesc = ((TypeMapping)accessor.Mapping).TypeDesc;

            bool repeats = any.IsMultipleOccurrence;

            if (mixed) {
                SpecialMapping textMapping = new SpecialMapping();
                textMapping.TypeDesc = scope.GetTypeDesc(typeof(XmlNode));
                textMapping.TypeName = textMapping.TypeDesc.Name;
                member.TypeDesc = textMapping.TypeDesc;
                TextAccessor text = new TextAccessor();
                text.Mapping = textMapping;
                member.Text = text;
                repeats = true;
                mixed = false;
            }

            if (repeats) {
                member.TypeDesc = member.TypeDesc.CreateArrayTypeDesc();
            }
        }

        ElementAccessor ImportAny(XmlSchemaAny any, bool makeElement) {
            SpecialMapping mapping = new SpecialMapping();
            mapping.TypeDesc = scope.GetTypeDesc(makeElement ? typeof(XmlElement) : typeof(XmlNode));
            mapping.TypeName = mapping.TypeDesc.Name;

            ElementAccessor accessor = new ElementAccessor();
            accessor.Mapping = mapping;
            accessor.Any = true;
            return accessor;
        }

        ElementAccessor ImportSerializable(XmlSchemaElement element, string identifier, string ns, bool repeats) {
            if (repeats) return null;
            if (element.SchemaType == null) return null;
            SerializableMapping mapping = ImportSerializable(element.SchemaType, identifier, ns);
            if (mapping == null) return null;
            ElementAccessor accessor = new ElementAccessor();
            accessor.Name = element.Name;
            accessor.Namespace = ns;
            accessor.Mapping = mapping;
            if (mapping.TypeDesc.IsNullable)
                accessor.IsNullable = element.IsNillable;
            if (element.Form == XmlSchemaForm.None) {
                XmlSchema schema = schemas[ns];
                if (schema != null) accessor.Form = ElementFormDefault(schema);
            }
            else
                accessor.Form = element.Form;
            return accessor;
        }

        SerializableMapping ImportSerializable(XmlSchemaType type, string identifier, string ns) {
            // we expecting type with one base group (all) for the dataset
            TypeItems items = GetTypeItems(type);
            if (items.Particle == null) return null;
            if (!(items.Particle is XmlSchemaAll || items.Particle is XmlSchemaSequence)) return null;
            XmlSchemaGroupBase group = (XmlSchemaGroupBase)items.Particle;
            if (group.Items.Count == 2) {
                if (!(group.Items[0] is XmlSchemaElement && group.Items[1] is XmlSchemaAny)) return null;
                XmlSchemaElement schema = (XmlSchemaElement)group.Items[0];
                if (!(schema.RefName.Name == "schema" && schema.RefName.Namespace == XmlSchema.Namespace)) return null;
                SerializableMapping specialMapping = new SerializableMapping();
                specialMapping.TypeDesc = new TypeDesc("System.Data.DataSet", "System.Data.DataSet", TypeKind.Serializable, null,
                        TypeFlags.Special | TypeFlags.CanBeElementValue | TypeFlags.Reference);
                specialMapping.TypeName = specialMapping.TypeDesc.Name;
                return specialMapping;
            }
            else if (group.Items.Count == 1) {
                if (!(group.Items[0] is XmlSchemaAny)) return null;
                XmlSchemaAny any = (XmlSchemaAny)group.Items[0];
                if (any.Namespace == null) return null;
                if (any.Namespace.IndexOf('#') >= 0) return null; // special syntax (##any, ##other, ...)
                if (any.Namespace.IndexOf(' ') >= 0) return null; // more than one Uri present
                XmlSchema schema = schemas[any.Namespace];
                if (schema == null) return null;

                SerializableMapping mapping = (SerializableMapping)mappings[schema];
                if (mapping == null) {
                    string typeName = CodeIdentifier.MakeValid(schema.Id);
                    TypeDesc typeDesc = new TypeDesc(typeName, typeName, TypeKind.Serializable, null,
                        TypeFlags.Special | TypeFlags.CanBeElementValue | TypeFlags.Reference);
                    mapping = new SerializableMapping();
                    mapping.Schema = schema;
                    mapping.TypeDesc = typeDesc;
                    mapping.TypeName = typeDesc.Name;
                    mappings.Add(schema, mapping);
                }
                return mapping;
            }
            else {
                return null;
            }
        }

        ElementAccessor ImportArray(XmlSchemaElement element, string identifier, string ns, bool repeats) {
            if (repeats) return null;
            if (element.SchemaType == null) return null;
            if (element.IsMultipleOccurrence) return null;
            XmlSchemaType type = element.SchemaType;
            ArrayMapping arrayMapping = ImportArrayMapping(type, identifier, ns, repeats);
            if (arrayMapping == null) return null;
            ElementAccessor arrayAccessor = new ElementAccessor();
            arrayAccessor.Name = element.Name;
            arrayAccessor.Namespace = ns;
            arrayAccessor.Mapping = arrayMapping;
            if (arrayMapping.TypeDesc.IsNullable)
                arrayAccessor.IsNullable = element.IsNillable;
            if (element.Form == XmlSchemaForm.None) {
                XmlSchema schema = schemas[ns];
                if (schema != null) arrayAccessor.Form = ElementFormDefault(schema);
            }
            else
                arrayAccessor.Form = element.Form;

            return arrayAccessor;
        }

        ArrayMapping ImportArrayMapping(XmlSchemaType type, string identifier, string ns, bool repeats) {
            if (!(type is XmlSchemaComplexType)) return null;
            if (!type.DerivedFrom.IsEmpty) return null;
            if (IsMixed(type)) return null;

            Mapping previousMapping = (Mapping)mappings[type];
            if (previousMapping != null) {
                if (previousMapping is ArrayMapping)
                    return (ArrayMapping)previousMapping;
                else
                    return null;
            }

            TypeItems items = GetTypeItems(type);

            if (items.Attributes != null && items.Attributes.Count > 0) return null;
            if (items.AnyAttribute != null) return null;
            if (items.Particle == null) return null;

            XmlSchemaGroupBase item = items.Particle;
            ArrayMapping arrayMapping = new ArrayMapping();

            arrayMapping.TypeName = identifier;
            arrayMapping.Namespace = ns;

            if (item is XmlSchemaChoice) {
                XmlSchemaChoice choice = (XmlSchemaChoice)item;
                if (!choice.IsMultipleOccurrence)
                    return null;
                MemberMapping choiceMember = ImportChoiceGroup(choice, identifier, null, null, ns, true);
                if (choiceMember.ChoiceIdentifier != null) return null;
                arrayMapping.TypeDesc = choiceMember.TypeDesc;
                arrayMapping.Elements = choiceMember.Elements;
                arrayMapping.TypeName = "ArrayOf" + CodeIdentifier.MakePascal(arrayMapping.TypeDesc.Name);
            }
            else if (item is XmlSchemaAll || item is XmlSchemaSequence) {
                if (item.Items.Count != 1 || !(item.Items[0] is XmlSchemaElement)) return null;
                XmlSchemaElement itemElement = (XmlSchemaElement)item.Items[0];
                if (!itemElement.IsMultipleOccurrence) return null;
                ElementAccessor itemAccessor;
                if ((itemAccessor = ImportSerializable(itemElement, identifier, ns, repeats)) == null) {
                    itemAccessor = ImportElement(itemElement, identifier, typeof(TypeMapping), null, ns, false);
                    // the Any set only for the namedAny element
                    if (itemAccessor.Any)
                        return null;
                }
                arrayMapping.Elements = new ElementAccessor[] { itemAccessor };
                arrayMapping.TypeDesc = ((TypeMapping)itemAccessor.Mapping).TypeDesc.CreateArrayTypeDesc();
                arrayMapping.TypeName = "ArrayOf" + CodeIdentifier.MakePascal(itemAccessor.Mapping.TypeName);
            }
            else {
                return null;
            }
            if (type.Name != null && type.Name.Length != 0)
                mappings[type] = arrayMapping;

            scope.AddTypeMapping(arrayMapping);
            // for the array-like mappings we need to create a struct mapping for the case when it referenced by the top-level element
            arrayMapping.TopLevelMapping = ImportStructType(type, ns, identifier, null, true);
            if (arrayMapping.TopLevelMapping != null && type.Name != null && type.Name.Length != 0)
                ImportDerivedTypes(new XmlQualifiedName(identifier, ns));

            arrayMapping.TopLevelMapping.ReferencedByTopLevelElement = true;
            return arrayMapping;
        }

        SpecialMapping ImportAnyMapping(XmlSchemaType type, string identifier, string ns, bool repeats) {
            if (type == null) return null;
            if (!type.DerivedFrom.IsEmpty) return null;

            bool mixed = IsMixed(type);
            TypeItems items = GetTypeItems(type);
            if (items.Particle == null) return null;
            if (!(items.Particle is XmlSchemaAll || items.Particle is XmlSchemaSequence)) return null;
            if (items.Attributes != null && items.Attributes.Count > 0) return null;
            XmlSchemaGroupBase group = (XmlSchemaGroupBase) items.Particle;

            if (group.Items.Count != 1 || !(group.Items[0] is XmlSchemaAny)) return null;
            XmlSchemaAny any = (XmlSchemaAny)group.Items[0];

            SpecialMapping mapping = new SpecialMapping();
            // check for special named any case
            if (items.AnyAttribute != null && any.IsMultipleOccurrence && mixed) {
                mapping.NamedAny = true;
                mapping.TypeDesc = scope.GetTypeDesc(typeof(XmlElement));
            }
            else if (items.AnyAttribute != null || any.IsMultipleOccurrence) {
                // these only work for named any case -- otherwise import as struct
                return null;
            }
            else {
                mapping.TypeDesc = scope.GetTypeDesc(mixed ? typeof(XmlNode) : typeof(XmlElement));
            }
            mapping.TypeName = mapping.TypeDesc.Name;
            if (repeats)
                mapping.TypeDesc = mapping.TypeDesc.CreateArrayTypeDesc();

            return mapping;
        }

        void ImportElementMember(XmlSchemaElement element, string identifier, CodeIdentifiers members, CodeIdentifiers membersScope, string ns, bool repeats) {
            XmlSchemaElement abstractElement = GetAbstractElement(element);
            if (abstractElement != null) {
                ImportAbstractMember(abstractElement, identifier, members, membersScope, ns, repeats);
                return;
            }
            ElementAccessor accessor;
            if ((accessor = ImportArray(element, identifier, ns, repeats)) == null) {
                if ((accessor = ImportSerializable(element, identifier, ns, repeats)) == null) {
                    accessor = ImportElement(element, identifier, typeof(TypeMapping), null, ns, false);
                }
            }

            MemberMapping member = new MemberMapping();
            member.Name = CodeIdentifier.MakeValid(Accessor.UnescapeName(accessor.Name));
            member.Name = membersScope.AddUnique(member.Name, member);

            if (member.Name.EndsWith("Specified")) {
                string name = member.Name;
                member.Name = membersScope.AddUnique(member.Name, member);
                membersScope.Remove(name);
            }
            members.Add(member.Name, member);
            member.TypeDesc = ((TypeMapping)accessor.Mapping).TypeDesc;
            member.Elements = new ElementAccessor[] { accessor };
            if (element.IsMultipleOccurrence || repeats)
                member.TypeDesc = member.TypeDesc.CreateArrayTypeDesc();

            if (element.MinOccurs == 0 && member.TypeDesc.IsValueType && !element.HasDefault && !member.TypeDesc.HasIsEmpty) {
                member.CheckSpecified = true;
            }
        }

        void ImportAttributeMember(XmlSchemaAttribute attribute, string identifier, CodeIdentifiers members, CodeIdentifiers membersScope, string ns) {
            AttributeAccessor accessor = ImportAttribute(attribute, identifier, ns);
            if (accessor == null) return;
            MemberMapping member = new MemberMapping();
            member.Elements = new ElementAccessor[0];
            member.Attribute = accessor;
            member.Name = CodeIdentifier.MakeValid(Accessor.UnescapeName(accessor.Name));
            member.Name = membersScope.AddUnique(member.Name, member);
            if (member.Name.EndsWith("Specified")) {
                string name = member.Name;
                member.Name = membersScope.AddUnique(member.Name, member);
                membersScope.Remove(name);
            }
            members.Add(member.Name, member);
            member.TypeDesc = accessor.IsList ? accessor.Mapping.TypeDesc.CreateArrayTypeDesc() : accessor.Mapping.TypeDesc;

            if ((attribute.Use == XmlSchemaUse.Optional || attribute.Use == XmlSchemaUse.None) && member.TypeDesc.IsValueType && !attribute.HasDefault && !member.TypeDesc.HasIsEmpty) {
                member.CheckSpecified = true;
            }
        }

        void ImportAnyAttributeMember(XmlSchemaAnyAttribute any, CodeIdentifiers members, CodeIdentifiers membersScope) {
            SpecialMapping mapping = new SpecialMapping();
            mapping.TypeDesc = scope.GetTypeDesc(typeof(XmlAttribute));
            mapping.TypeName = mapping.TypeDesc.Name;

            AttributeAccessor accessor = new AttributeAccessor();
            accessor.Any = true;
            accessor.Mapping = mapping;

            MemberMapping member = new MemberMapping();
            member.Elements = new ElementAccessor[0];
            member.Attribute = accessor;
            member.Name = membersScope.MakeRightCase("AnyAttr");
            member.Name = membersScope.AddUnique(member.Name, member);
            members.Add(member.Name, member);
            member.TypeDesc = ((TypeMapping)accessor.Mapping).TypeDesc;
            member.TypeDesc = member.TypeDesc.CreateArrayTypeDesc();
        }

        bool KeepXmlnsDeclarations(XmlSchemaType type, out string xmlnsMemberName) {
            xmlnsMemberName = null;
            if (type.Annotation == null)
                return false;
            if (type.Annotation.Items == null || type.Annotation.Items.Count == 0)
                return false;

            foreach(XmlSchemaObject o in type.Annotation.Items) {
                if (o is XmlSchemaAppInfo) {
                    XmlNode[] nodes = ((XmlSchemaAppInfo)o).Markup;
                    if (nodes != null && nodes.Length > 0) {
                        foreach(XmlNode node in nodes) {
                            if (node is XmlElement) {
                                XmlElement e = (XmlElement)node;
                                if (e.Name == "keepNamespaceDeclarations") {
                                    if (e.LastNode is XmlText) {
                                        xmlnsMemberName = (((XmlText)e.LastNode).Value).Trim(null);
                                    }
                                    return true;
                                }
                            }
                        }
                    }
                }
            }
            return false; 
        }

        void ImportXmlnsDeclarationsMember(XmlSchemaType type, CodeIdentifiers members, CodeIdentifiers membersScope) {
            string xmlnsMemberName;
            if (!KeepXmlnsDeclarations(type, out xmlnsMemberName))
                return;
            TypeDesc xmlnsTypeDesc = scope.GetTypeDesc(typeof(XmlSerializerNamespaces));
            StructMapping xmlnsMapping = new StructMapping();

            xmlnsMapping.TypeDesc = xmlnsTypeDesc;
            xmlnsMapping.TypeName = xmlnsMapping.TypeDesc.Name;
            xmlnsMapping.Members = new MemberMapping[0];
            xmlnsMapping.IncludeInSchema = false;
            xmlnsMapping.ReferencedByTopLevelElement = true;
         
            ElementAccessor xmlns = new ElementAccessor();
            xmlns.Mapping = xmlnsMapping;
            
            MemberMapping member = new MemberMapping();
            member.Elements = new ElementAccessor[] {xmlns};
            member.Name = CodeIdentifier.MakeValid(xmlnsMemberName == null ? "Namespaces" : xmlnsMemberName);
            member.Name = membersScope.AddUnique(member.Name, member);
            members.Add(member.Name, member);
            member.TypeDesc = xmlnsTypeDesc;
            member.Xmlns = new XmlnsAccessor();
            member.Ignore = true;
        }

        void ImportAttributeGroupMembers(XmlSchemaAttributeGroupRef group, string identifier, CodeIdentifiers members, CodeIdentifiers membersScope, string ns) {
            if (!group.RefName.IsEmpty) {
                ImportAttributeGroupMembers(FindAttributeGroup(group.RefName), identifier, members, membersScope, group.RefName.Namespace);
                return;
            }
        }

        void ImportAttributeGroupMembers(XmlSchemaAttributeGroup group, string identifier, CodeIdentifiers members, CodeIdentifiers membersScope, string ns) {
            for (int i = 0; i < group.Attributes.Count; i++) {
                object item = group.Attributes[i];
                if (item is XmlSchemaAttributeGroup)
                    ImportAttributeGroupMembers((XmlSchemaAttributeGroup)item, identifier, members, membersScope, ns);
                else if (item is XmlSchemaAttribute)
                    ImportAttributeMember((XmlSchemaAttribute)item, identifier, members, membersScope, ns);
            }
            if (group.AnyAttribute != null)
                ImportAnyAttributeMember(group.AnyAttribute, members, membersScope);
        }

        AttributeAccessor ImportSpecialAttribute(XmlQualifiedName name, string identifier) {
            PrimitiveMapping mapping = new PrimitiveMapping();
            mapping.TypeDesc = scope.GetTypeDesc(typeof(string));
            mapping.TypeName = mapping.TypeDesc.DataType.Name;
            AttributeAccessor accessor = new AttributeAccessor();
            accessor.Name = name.Name;
            accessor.Namespace = XmlReservedNs.NsXml;
            accessor.CheckSpecial();
            accessor.Mapping = mapping;
            return accessor;
        }

        AttributeAccessor ImportAttribute(XmlSchemaAttribute attribute, string identifier, string ns) {
            if (attribute.Use == XmlSchemaUse.Prohibited) return null;
            if (!attribute.RefName.IsEmpty) {
                if (attribute.RefName.Namespace == XmlReservedNs.NsXml)
                    return ImportSpecialAttribute(attribute.RefName, identifier);
                else
                    return ImportAttribute(FindAttribute(attribute.RefName), identifier, attribute.RefName.Namespace);
            }
            TypeMapping mapping;
            if (attribute.Name.Length == 0) throw new InvalidOperationException(Res.GetString(Res.XmlAttributeHasNoName));
            if (identifier.Length == 0)
                identifier = CodeIdentifier.MakeValid(attribute.Name);
            else
                identifier += CodeIdentifier.MakePascal(attribute.Name);
            if (!attribute.SchemaTypeName.IsEmpty)
                mapping = (TypeMapping)ImportType(attribute.SchemaTypeName, typeof(TypeMapping), null);
            else if (attribute.SchemaType != null)
                mapping = ImportDataType((XmlSchemaSimpleType)attribute.SchemaType, ns, identifier, null);
            else {
                mapping = new PrimitiveMapping();
                mapping.TypeDesc = scope.GetTypeDesc(typeof(string));
                mapping.TypeName = mapping.TypeDesc.DataType.Name;
            }
            AttributeAccessor accessor = new AttributeAccessor();
            accessor.Name = attribute.Name;
            accessor.Namespace = ns;
            if (attribute.Form == XmlSchemaForm.None) {
                XmlSchema schema = schemas[ns];
                if (schema != null) accessor.Form = AttributeFormDefault(schema);
            }
            else {
                accessor.Form = attribute.Form;
            }
            accessor.CheckSpecial();
            accessor.Mapping = mapping;
            accessor.IsList = mapping.IsList;

            if (attribute.DefaultValue != null) {
                accessor.Default = ImportDefaultValue(mapping, attribute.DefaultValue);
            }
            else if (attribute.FixedValue != null) {
                accessor.Default = ImportDefaultValue(mapping, attribute.FixedValue);
            }
            return accessor;
        }

        TypeMapping ImportDataType(XmlSchemaSimpleType dataType, string typeNs, string identifier, Type baseType) {
            if (baseType != null)
                return ImportStructDataType(dataType, typeNs, identifier, baseType);

            TypeMapping mapping = ImportNonXsdPrimitiveDataType(dataType);
            if (mapping != null)
                return mapping;

            if (dataType.Content is XmlSchemaSimpleTypeRestriction) {
                XmlSchemaSimpleTypeRestriction restriction = (XmlSchemaSimpleTypeRestriction)dataType.Content;
                foreach (object o in restriction.Facets) {
                    if (o is XmlSchemaEnumerationFacet) {
                        return ImportEnumeratedDataType(dataType, typeNs, identifier);
                    }
                }
            }
            else if (dataType.Content is XmlSchemaSimpleTypeList || dataType.Content is XmlSchemaSimpleTypeUnion) {
                if (dataType.Content is XmlSchemaSimpleTypeList) {
                    // check if we have enumeration list
                    XmlSchemaSimpleTypeList list = (XmlSchemaSimpleTypeList)dataType.Content;
                    if (list.ItemType != null) {
                        mapping = ImportDataType(list.ItemType, typeNs, identifier, null);
                        if (mapping != null && mapping is EnumMapping) {
                            ((EnumMapping)mapping).IsFlags = true;
                            return mapping;
                        }
                    }
                    else if (list.ItemTypeName != null && !list.ItemTypeName.IsEmpty) {
                        mapping = ImportType(list.ItemTypeName, typeof(TypeMapping), null);
                        if (mapping != null && mapping is PrimitiveMapping) {
                            ((PrimitiveMapping)mapping).IsList = true;
                            return mapping;
                        }
                    }
                }
                mapping = new PrimitiveMapping();
                mapping.TypeDesc = scope.GetTypeDesc(typeof(string));
                mapping.TypeName = mapping.TypeDesc.DataType.Name;
                return mapping;
            }
            return ImportPrimitiveDataType(dataType);
        }

        TypeMapping ImportEnumeratedDataType(XmlSchemaSimpleType dataType, string typeNs, string identifier) {
            EnumMapping enumMapping = (EnumMapping)mappings[dataType];
            if (enumMapping != null) return enumMapping;
            XmlSchemaType sourceType = FindType(dataType.DerivedFrom);
            if (sourceType is XmlSchemaComplexType) return null;
            TypeDesc sourceTypeDesc = scope.GetTypeDesc((XmlSchemaSimpleType)sourceType);
            if (sourceTypeDesc != null && sourceTypeDesc.FullName != typeof(string).FullName)
                return ImportPrimitiveDataType(dataType);
            string typeName = GenerateUniqueTypeName(identifier);
            enumMapping = new EnumMapping();
            enumMapping.TypeDesc = new TypeDesc(typeName, typeName, TypeKind.Enum, null, 0);
            enumMapping.TypeName = identifier;
            enumMapping.Namespace = typeNs;
            enumMapping.IsFlags = false;

            mappings.Add(dataType, enumMapping);
            CodeIdentifiers constants = new CodeIdentifiers();
            XmlSchemaSimpleTypeContent content = dataType.Content;

            if (content is XmlSchemaSimpleTypeRestriction) {
                XmlSchemaSimpleTypeRestriction restriction = (XmlSchemaSimpleTypeRestriction)content;
                for (int i = 0; i < restriction.Facets.Count; i++) {
                    object facet = restriction.Facets[i];
                    if (!(facet is XmlSchemaEnumerationFacet)) continue;
                    XmlSchemaEnumerationFacet enumeration = (XmlSchemaEnumerationFacet)facet;
                    // validate the enumeration value
                    if (sourceTypeDesc != null && sourceTypeDesc.HasCustomFormatter) {
                        XmlCustomFormatter.ToDefaultValue(enumeration.Value, sourceTypeDesc.FormatterName);
                    }
                    ConstantMapping constant = new ConstantMapping();
                    string constantName = CodeIdentifier.MakeValid(enumeration.Value);
                    constant.Name = constants.AddUnique(constantName, constant);
                    constant.XmlName = enumeration.Value;
                    constant.Value = i;
                }
            }
            enumMapping.Constants = (ConstantMapping[])constants.ToArray(typeof(ConstantMapping));
            scope.AddTypeMapping(enumMapping);
            return enumMapping;
        }

        EnumMapping ImportEnumeratedChoice(ElementAccessor[] choice, string typeNs, string typeName) {
            typeName = GenerateUniqueTypeName(typeName, typeNs);
            EnumMapping enumMapping = new EnumMapping();
            enumMapping.TypeDesc = new TypeDesc(typeName, typeName, TypeKind.Enum, null, 0);
            enumMapping.TypeName = typeName;
            enumMapping.Namespace = typeNs;
            enumMapping.IsFlags = false;
            enumMapping.IncludeInSchema = false;

            CodeIdentifiers constants = new CodeIdentifiers();

            for (int i = 0; i < choice.Length; i++) {
                ElementAccessor element = choice[i];
                ConstantMapping constant = new ConstantMapping();
                string constantName = CodeIdentifier.MakeValid(element.Name);
                constant.Name = constants.AddUnique(constantName, constant);
                constant.XmlName = element.Any && element.Name.Length == 0 ? "##any:" : (element.Namespace == typeNs ? element.Name : element.Namespace + ":" + element.Name);
                constant.Value = i;
            }
            enumMapping.Constants = (ConstantMapping[])constants.ToArray(typeof(ConstantMapping));
            scope.AddTypeMapping(enumMapping);
            return enumMapping;
        }


        PrimitiveMapping ImportPrimitiveDataType(XmlSchemaSimpleType dataType) {
            TypeDesc sourceTypeDesc = GetDataTypeSource(dataType);
            PrimitiveMapping mapping = new PrimitiveMapping();
            mapping.TypeDesc = sourceTypeDesc;
            mapping.TypeName = sourceTypeDesc.DataType.Name;
            return mapping;
        }

        PrimitiveMapping ImportNonXsdPrimitiveDataType(XmlSchemaSimpleType dataType) {
            PrimitiveMapping mapping = null;
            TypeDesc typeDesc = null;
            if (dataType.Name != null && dataType.Name.Length != 0) {
                typeDesc = scope.GetTypeDesc(new XmlQualifiedName(dataType.Name, UrtTypes.Namespace));
                if (typeDesc != null) {
                    mapping = new PrimitiveMapping();
                    mapping.TypeDesc = typeDesc;
                    mapping.TypeName = typeDesc.DataType.Name;
                }
            }
            return mapping;
        }

        XmlSchemaGroup FindGroup(XmlQualifiedName name) {
            XmlSchemaGroup group = (XmlSchemaGroup)schemas.Find(name, typeof(XmlSchemaGroup));
            if (group == null)
                throw new InvalidOperationException(Res.GetString(Res.XmlMissingGroup, name.Name));
            return group;
        }

        XmlSchemaAttributeGroup FindAttributeGroup(XmlQualifiedName name) {
            XmlSchemaAttributeGroup group = (XmlSchemaAttributeGroup)schemas.Find(name, typeof(XmlSchemaAttributeGroup));
            if (group == null)
                throw new InvalidOperationException(Res.GetString(Res.XmlMissingAttributeGroup, name.Name));
            return group;
        }

        TypeDesc GetDataTypeSource(XmlSchemaSimpleType dataType) {
            if (dataType.Name != null && dataType.Name.Length != 0) {
                TypeDesc typeDesc = scope.GetTypeDesc(dataType);
                if (typeDesc != null) return typeDesc;
            }
            return GetDataTypeSource(FindDataType(dataType.DerivedFrom));
        }

        XmlSchemaSimpleType FindDataType(XmlQualifiedName name) {
            TypeDesc typeDesc = scope.GetTypeDesc(name);
            if (typeDesc != null)
                return typeDesc.DataType;
            XmlSchemaSimpleType dataType = (XmlSchemaSimpleType)schemas.Find(name, typeof(XmlSchemaSimpleType));
            if (dataType != null)
                return dataType;
            if (name.Namespace == XmlSchema.Namespace)
                return scope.GetTypeDesc(typeof(string)).DataType;
            else {
                if (name.Name == Soap.Array && name.Namespace == Soap.Encoding) {
                    throw new InvalidOperationException(Res.GetString(Res.XmlInvalidEncoding, name.ToString()));
                }
                else {
                    throw new InvalidOperationException(Res.GetString(Res.XmlMissingDataType, name.ToString()));
                }
            }
        }

        XmlSchemaType FindType(XmlQualifiedName name) {
            object type = schemas.Find(name, typeof(XmlSchemaComplexType));
            if (type != null)
                return (XmlSchemaComplexType)type;
            return FindDataType(name);
        }

        XmlSchemaElement FindElement(XmlQualifiedName name) {
            XmlSchemaElement element = (XmlSchemaElement)schemas.Find(name, typeof(XmlSchemaElement));
            if (element == null) throw new InvalidOperationException(Res.GetString(Res.XmlMissingElement, name.ToString()));
            return element;
        }

        XmlSchemaAttribute FindAttribute(XmlQualifiedName name) {
            XmlSchemaAttribute element = (XmlSchemaAttribute)schemas.Find(name, typeof(XmlSchemaAttribute));
            if (element == null) throw new InvalidOperationException(Res.GetString(Res.XmlMissingAttribute, name.Name));
            return element;
        }

        object ImportDefaultValue(TypeMapping mapping, string defaultValue) {
            if (defaultValue == null)
                return DBNull.Value;

            #if DEBUG
                // use exception in the place of Debug.Assert to avoid throwing asserts from a server process such as aspnet_ewp.exe
                if (!(mapping is PrimitiveMapping)) {
                    throw new InvalidOperationException(Res.GetString(Res.XmlInternalErrorDetails, "Mapping " + mapping.GetType() + ", should not have Default"));
                }
                else if (mapping.IsList) {
                    throw new InvalidOperationException(Res.GetString(Res.XmlInternalErrorDetails, "Mapping " + mapping.GetType() + ", should not have Default"));
                }
            #endif

            if (mapping is EnumMapping) {
                EnumMapping em = (EnumMapping)mapping;
                ConstantMapping[] c = em.Constants;

                if (em.IsFlags) {
                    Hashtable values = new Hashtable();
                    string[] names = new string[c.Length];
                    long[] ids = new long[c.Length];

                    // CONSIDER, check number of enum values vs. size of long?
                    for (int i = 0; i < c.Length; i++) {
                        ids[i] = em.IsFlags ? 1L << i : (long)i;
                        names[i] = c[i].Name;
                        values.Add(c[i].XmlName, ids[i]);
                    }
                    // this validates the values
                    long val = XmlCustomFormatter.ToEnum(defaultValue, values, em.TypeName, true);
                    return XmlCustomFormatter.FromEnum(val, names, ids);
                }
                else {
                    for (int i = 0; i < c.Length; i++) {
                        if (c[i].XmlName == defaultValue)
                            return c[i].Name;
                    }
                }
                throw new InvalidOperationException(Res.GetString(Res.XmlInvalidDefaultValue, defaultValue, em.TypeDesc.FullName));
            }

            // Primitive mapping
            PrimitiveMapping pm = (PrimitiveMapping)mapping;

            if (!pm.TypeDesc.HasDefaultSupport) {
#if DEBUG
                Debug.WriteLineIf(CompModSwitches.XmlSerialization.TraceVerbose, "XmlSerialization::Dropping default value for " + pm.TypeDesc.Name);
#endif
                return DBNull.Value;
            }

            if (!pm.TypeDesc.HasCustomFormatter) {
                if (pm.TypeDesc.FormatterName == "String")
                    return defaultValue;
                Type formatter = typeof(XmlConvert);

                MethodInfo format = formatter.GetMethod("To" + pm.TypeDesc.FormatterName, new Type[] {typeof(string)});
                if (format != null) {
                    return format.Invoke(formatter, new Object[] {defaultValue});
                }
#if DEBUG
                Debug.WriteLineIf(CompModSwitches.XmlSerialization.TraceVerbose, "XmlSerialization::Failed to GetMethod " + formatter.Name + ".To" + pm.TypeDesc.FormatterName);
#endif
            }
            else {
                return XmlCustomFormatter.ToDefaultValue(defaultValue, pm.TypeDesc.FormatterName);
            }
            return DBNull.Value;
        }
        
        XmlSchemaForm ElementFormDefault(XmlSchema schema) {
            return schema.ElementFormDefault == XmlSchemaForm.None ? XmlSchemaForm.Unqualified : schema.ElementFormDefault;
        }
        
        XmlSchemaForm AttributeFormDefault(XmlSchema schema) {
            return schema.AttributeFormDefault == XmlSchemaForm.None ? XmlSchemaForm.Unqualified : schema.AttributeFormDefault;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\serialization\xmltypeattribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlTypeAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Serialization {

    using System;

    /// <include file='doc\XmlTypeAttribute.uex' path='docs/doc[@for="XmlTypeAttribute"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [AttributeUsage(AttributeTargets.Class | AttributeTargets.Enum | AttributeTargets.Interface | AttributeTargets.Struct)]
    public class XmlTypeAttribute : System.Attribute {
        bool includeInSchema = true;
        string ns;
        string typeName;

        /// <include file='doc\XmlTypeAttribute.uex' path='docs/doc[@for="XmlTypeAttribute.XmlTypeAttribute"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public XmlTypeAttribute() {
        }

        /// <include file='doc\XmlTypeAttribute.uex' path='docs/doc[@for="XmlTypeAttribute.XmlTypeAttribute1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public XmlTypeAttribute(string typeName) {
            this.typeName = typeName;
        }

        /// <include file='doc\XmlTypeAttribute.uex' path='docs/doc[@for="XmlTypeAttribute.IncludeInSchema"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public bool IncludeInSchema {
            get { return includeInSchema; }
            set { includeInSchema = value; }
        }

        /// <include file='doc\XmlTypeAttribute.uex' path='docs/doc[@for="XmlTypeAttribute.TypeName"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public string TypeName {
            get { return typeName == null ? string.Empty : typeName; }
            set { typeName = value; }
        }

        /// <include file='doc\XmlTypeAttribute.uex' path='docs/doc[@for="XmlTypeAttribute.Namespace"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public string Namespace {
            get { return ns; }
            set { ns = value; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\serialization\xmltypemapping.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlTypeMapping.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Serialization {

    using System.Reflection;
    using System;

    /// <include file='doc\XmlTypeMapping.uex' path='docs/doc[@for="XmlTypeMapping"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public class XmlTypeMapping : XmlMapping {
        ElementAccessor accessor;

        internal XmlTypeMapping(TypeScope scope, ElementAccessor accessor) : base(scope) { 
            this.accessor = accessor;
        }

        internal ElementAccessor Accessor {
            get { return accessor; }
        }

        /// <include file='doc\XmlTypeMapping.uex' path='docs/doc[@for="XmlTypeMapping.ElementName"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public string ElementName { 
            get { return System.Xml.Serialization.Accessor.UnescapeName(Accessor.Name); }
        }

        /// <include file='doc\XmlTypeMapping.uex' path='docs/doc[@for="XmlTypeMapping.Namespace"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public string Namespace {
            get { return accessor.Namespace; }
        }

        internal TypeMapping Mapping {
            get { return (TypeMapping)Accessor.Mapping; }
        }

        /// <include file='doc\XmlTypeMapping.uex' path='docs/doc[@for="XmlTypeMapping.TypeName"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public string TypeName {
            get { return Mapping.TypeDesc.Name; }
        }

        /// <include file='doc\XmlTypeMapping.uex' path='docs/doc[@for="XmlTypeMapping.TypeFullName"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public string TypeFullName {
            get { return Mapping.TypeDesc.FullName; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\serialization\xmlserializationreader.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlSerializationReader.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Serialization {

    using System.IO;
    using System;
    using System.Security;
    using System.Collections;
    using System.Xml;
    using System.Xml.Schema;
    using System.ComponentModel;
    using System.Globalization;
    using System.CodeDom.Compiler;
    using System.Diagnostics;
    using System.Threading;
    using System.Reflection;

    /// <include file='doc\XmlSerializationReader.uex' path='docs/doc[@for="XmlSerializationReader"]/*' />
    ///<internalonly/>
    public abstract class XmlSerializationReader {
        XmlReader r;
        XmlDocument d;
        Hashtable callbacks;
        Hashtable types;
        Hashtable typesReverse;
        XmlDeserializationEvents events;
        Hashtable targets;
        Hashtable referencedTargets;
        Hashtable unknownTargetTypes;
        ArrayList targetsWithoutIds;
        ArrayList fixups;
        ArrayList collectionFixups;
        string encodingStyle;
        bool soap12;
        bool isReturnValue;
        TempAssembly tempAssembly;
        int threadCode;
        ResolveEventHandler assemblyResolver;

        string schemaNsID;
        string schemaNs1999ID;
        string schemaNs2000ID;
        string schemaNonXsdTypesNsID;
        string instanceNsID;
        string instanceNs2000ID;
        string instanceNs1999ID;
        string soapNsID;
        string soap12NsID;
        string schemaID;
        string wsdlNsID;
        string wsdlArrayTypeID;
        string nullID;
        string nilID;
        string typeID;
        string arrayTypeID;
        string itemTypeID;
        string arraySizeID;
        string arrayID;
        string urTypeID;
        string stringID;
        string intID;
        string booleanID;
        string shortID;
        string longID;
        string floatID;
        string doubleID;
        string decimalID;
        string dateTimeID;
        string qnameID;
        string dateID;
        string timeID;
        string hexBinaryID;
        string base64BinaryID;
        string base64ID;
        string unsignedByteID;
        string byteID;
        string unsignedShortID;
        string unsignedIntID;
        string unsignedLongID;
        string oldDecimalID;
        string oldTimeInstantID;

        string anyURIID;
        string durationID;
        string ENTITYID;
        string ENTITIESID;
        string gDayID;
        string gMonthID;
        string gMonthDayID;
        string gYearID;
        string gYearMonthID;
        string IDID;
        string IDREFID;
        string IDREFSID;
        string integerID;
        string languageID;
        string negativeIntegerID;
        string nonPositiveIntegerID;
        string nonNegativeIntegerID;
        string normalizedStringID;
        string NOTATIONID;
        string positiveIntegerID;
        string tokenID;

        string charID;
        string guidID;

        /// <include file='doc\XmlSerializationReader.uex' path='docs/doc[@for="XmlSerializationReader.InitIDs"]/*' />
        protected abstract void InitIDs();

        // this method must be called before any generated deserialization methods are called
        internal void Init(XmlReader r, XmlDeserializationEvents events, string encodingStyle, TempAssembly tempAssembly) {
            this.events = events;
            this.r = r;
            this.d = null;
            this.encodingStyle = encodingStyle;
            this.soap12 = (encodingStyle == Soap12.Encoding);
            this.tempAssembly = tempAssembly;
            // only hook the assembly resolver if we have something to help us do the resolution
            if (tempAssembly != null) {
                // we save the threadcode to make sure we don't handle any resolve events for any other threads
                threadCode = Thread.CurrentThread.GetHashCode();
                assemblyResolver = new ResolveEventHandler(OnAssemblyResolve);
                AppDomain.CurrentDomain.AssemblyResolve += assemblyResolver;
            }

            schemaNsID = r.NameTable.Add(XmlSchema.Namespace);
            schemaNs2000ID = r.NameTable.Add("http://www.w3.org/2000/10/XMLSchema");
            schemaNs1999ID = r.NameTable.Add("http://www.w3.org/1999/XMLSchema");
            schemaNonXsdTypesNsID = r.NameTable.Add(UrtTypes.Namespace);
            instanceNsID = r.NameTable.Add(XmlSchema.InstanceNamespace);
            instanceNs2000ID = r.NameTable.Add("http://www.w3.org/2000/10/XMLSchema-instance");
            instanceNs1999ID = r.NameTable.Add("http://www.w3.org/1999/XMLSchema-instance");
            soapNsID = r.NameTable.Add(Soap.Encoding);
            soap12NsID = r.NameTable.Add(Soap12.Encoding);
            schemaID = r.NameTable.Add("schema");
            wsdlNsID = r.NameTable.Add(Wsdl.Namespace);
            wsdlArrayTypeID = r.NameTable.Add(Wsdl.ArrayType);
            nullID = r.NameTable.Add("null");
            nilID = r.NameTable.Add("nil");
            typeID = r.NameTable.Add("type");
            arrayTypeID = r.NameTable.Add("arrayType");
            itemTypeID = r.NameTable.Add("itemType");
            arraySizeID = r.NameTable.Add("arraySize");
            arrayID = r.NameTable.Add("Array");
            urTypeID = r.NameTable.Add(Soap.UrType);
            InitIDs();
        }

        // this method must be called at the end of deserialization
        internal void Dispose() {
            if (assemblyResolver != null)
                AppDomain.CurrentDomain.AssemblyResolve -= assemblyResolver;
            assemblyResolver = null;
        }

        internal Assembly OnAssemblyResolve(object sender, ResolveEventArgs args) {
            if (tempAssembly != null && Thread.CurrentThread.GetHashCode() == threadCode)
                return tempAssembly.GetReferencedAssembly(args.Name);
            return null;
        }

        /// <include file='doc\XmlSerializationReader.uex' path='docs/doc[@for="XmlSerializationReader.Reader"]/*' />
        protected XmlReader Reader {
            get {
                return r;
            }
        }

        /// <include file='doc\XmlSerializationReader.uex' path='docs/doc[@for="XmlSerializationReader.Document"]/*' />
        protected XmlDocument Document {
            get {
                if (d == null)
                    d = new XmlDocument(r.NameTable);
                return d;
            }
        }

        void InitPrimitiveIDs() {
            if (stringID != null) return;
            object ns = r.NameTable.Add(XmlSchema.Namespace);
            object ns2 = r.NameTable.Add(UrtTypes.Namespace);
            
            stringID = r.NameTable.Add("string");
            intID = r.NameTable.Add("int");
            booleanID = r.NameTable.Add("boolean");
            shortID = r.NameTable.Add("short");
            longID = r.NameTable.Add("long");
            floatID = r.NameTable.Add("float");
            doubleID = r.NameTable.Add("double");
            decimalID = r.NameTable.Add("decimal");
            dateTimeID = r.NameTable.Add("dateTime");
            qnameID = r.NameTable.Add("QName");
            dateID = r.NameTable.Add("date");
            timeID = r.NameTable.Add("time");
            hexBinaryID = r.NameTable.Add("hexBinary");
            base64BinaryID = r.NameTable.Add("base64Binary");
            unsignedByteID = r.NameTable.Add("unsignedByte");
            byteID = r.NameTable.Add("byte");
            unsignedShortID = r.NameTable.Add("unsignedShort");
            unsignedIntID = r.NameTable.Add("unsignedInt");
            unsignedLongID = r.NameTable.Add("unsignedLong");
            oldDecimalID = r.NameTable.Add("decimal");
            oldTimeInstantID = r.NameTable.Add("timeInstant");
            charID = r.NameTable.Add("char");
            guidID = r.NameTable.Add("guid");
            base64ID = r.NameTable.Add("base64");

            anyURIID = r.NameTable.Add("anyURI");
            durationID = r.NameTable.Add("duration");
            ENTITYID = r.NameTable.Add("ENTITY");
            ENTITIESID = r.NameTable.Add("ENTITIES");
            gDayID = r.NameTable.Add("gDay");
            gMonthID = r.NameTable.Add("gMonth");
            gMonthDayID = r.NameTable.Add("gMonthDay");
            gYearID = r.NameTable.Add("gYear");
            gYearMonthID = r.NameTable.Add("gYearMonth");
            IDID = r.NameTable.Add("ID");
            IDREFID = r.NameTable.Add("IDREF");
            IDREFSID = r.NameTable.Add("IDREFS");
            integerID = r.NameTable.Add("integer");
            languageID = r.NameTable.Add("language");
            negativeIntegerID = r.NameTable.Add("negativeInteger");
            nonNegativeIntegerID = r.NameTable.Add("nonNegativeInteger");
            nonPositiveIntegerID = r.NameTable.Add("nonPositiveInteger");
            normalizedStringID = r.NameTable.Add("normalizedString");
            NOTATIONID = r.NameTable.Add("NOTATION");
            positiveIntegerID = r.NameTable.Add("positiveInteger");
            tokenID = r.NameTable.Add("token");
        }

        /// <include file='doc\XmlSerializationReader.uex' path='docs/doc[@for="XmlSerializationReader.GetXsiType"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected XmlQualifiedName GetXsiType() {
            string type = r.GetAttribute(typeID, instanceNsID);
            if (type == null) {
                type = r.GetAttribute(typeID, instanceNs2000ID);
                if (type == null) {
                    type = r.GetAttribute(typeID, instanceNs1999ID);
                    if (type == null)
                        return null;
                }
            }
            return ToXmlQualifiedName(type);
        }

        // throwOnUnknown flag controls whether this method throws an exception or just returns 
        // null if typeName.Namespace is unknown. the method still throws if typeName.Namespace
        // is recognized but typeName.Name isn't.
        Type GetPrimitiveType(XmlQualifiedName typeName, bool throwOnUnknown) {
            InitPrimitiveIDs();

            if ((object) typeName.Namespace == (object) schemaNsID) {
                if ((object) typeName.Name == (object) stringID ||
                    (object) typeName.Name == (object) anyURIID ||
                    (object) typeName.Name == (object) durationID ||
                    (object) typeName.Name == (object) ENTITYID ||
                    (object) typeName.Name == (object) ENTITIESID ||
                    (object) typeName.Name == (object) gDayID ||
                    (object) typeName.Name == (object) gMonthID ||
                    (object) typeName.Name == (object) gMonthDayID ||
                    (object) typeName.Name == (object) gYearID ||
                    (object) typeName.Name == (object) gYearMonthID ||
                    (object) typeName.Name == (object) IDID ||
                    (object) typeName.Name == (object) IDREFID ||
                    (object) typeName.Name == (object) IDREFSID ||
                    (object) typeName.Name == (object) integerID ||
                    (object) typeName.Name == (object) languageID ||
                    (object) typeName.Name == (object) negativeIntegerID ||
                    (object) typeName.Name == (object) nonPositiveIntegerID ||
                    (object) typeName.Name == (object) nonNegativeIntegerID ||
                    (object) typeName.Name == (object) normalizedStringID ||
                    (object) typeName.Name == (object) NOTATIONID ||
                    (object) typeName.Name == (object) positiveIntegerID ||
                    (object) typeName.Name == (object) tokenID)
                    return typeof(string);
                else if ((object) typeName.Name == (object) intID)
                    return typeof(int);
                else if ((object) typeName.Name == (object) booleanID)
                    return typeof(bool);
                else if ((object) typeName.Name == (object) shortID)
                    return typeof(short);
                else if ((object) typeName.Name == (object) longID)
                    return typeof(long);
                else if ((object) typeName.Name == (object) floatID)
                    return typeof(float);
                else if ((object) typeName.Name == (object) doubleID)
                    return typeof(double);
                else if ((object) typeName.Name == (object) decimalID)
                    return typeof(decimal);
                else if ((object) typeName.Name == (object) dateTimeID)
                    return typeof(DateTime);
                else if ((object) typeName.Name == (object) qnameID)
                    return typeof(XmlQualifiedName);
                else if ((object) typeName.Name == (object) dateID)
                    return typeof(DateTime);
                else if ((object) typeName.Name == (object) timeID)
                    return typeof(DateTime);
                else if ((object) typeName.Name == (object) hexBinaryID)
                    return typeof(byte[]);
                else if ((object)typeName.Name == (object)base64BinaryID)
                    return typeof(byte[]);
                else if ((object)typeName.Name == (object)unsignedByteID)
                    return typeof(byte);
                else if ((object) typeName.Name == (object) byteID)
                    return typeof(SByte);
                else if ((object) typeName.Name == (object) unsignedShortID)
                    return typeof(UInt16);
                else if ((object) typeName.Name == (object) unsignedIntID)
                    return typeof(UInt32);
                else if ((object) typeName.Name == (object) unsignedLongID)
                    return typeof(UInt64);
                else
                    throw CreateUnknownTypeException(typeName);
            } 
            else if ((object) typeName.Namespace == (object) schemaNs2000ID || (object) typeName.Namespace == (object) schemaNs1999ID) {
                if ((object) typeName.Name == (object) stringID ||
                    (object) typeName.Name == (object) anyURIID ||
                    (object) typeName.Name == (object) durationID ||
                    (object) typeName.Name == (object) ENTITYID ||
                    (object) typeName.Name == (object) ENTITIESID ||
                    (object) typeName.Name == (object) gDayID ||
                    (object) typeName.Name == (object) gMonthID ||
                    (object) typeName.Name == (object) gMonthDayID ||
                    (object) typeName.Name == (object) gYearID ||
                    (object) typeName.Name == (object) gYearMonthID ||
                    (object) typeName.Name == (object) IDID ||
                    (object) typeName.Name == (object) IDREFID ||
                    (object) typeName.Name == (object) IDREFSID ||
                    (object) typeName.Name == (object) integerID ||
                    (object) typeName.Name == (object) languageID ||
                    (object) typeName.Name == (object) negativeIntegerID ||
                    (object) typeName.Name == (object) nonPositiveIntegerID ||
                    (object) typeName.Name == (object) nonNegativeIntegerID ||
                    (object) typeName.Name == (object) normalizedStringID ||
                    (object) typeName.Name == (object) NOTATIONID ||
                    (object) typeName.Name == (object) positiveIntegerID ||
                    (object) typeName.Name == (object) tokenID)
                    return typeof(string);
                else if ((object) typeName.Name == (object) intID)
                    return typeof(int);
                else if ((object) typeName.Name == (object) booleanID)
                    return typeof(bool);
                else if ((object) typeName.Name == (object) shortID)
                    return typeof(short);
                else if ((object) typeName.Name == (object) longID)
                    return typeof(long);
                else if ((object) typeName.Name == (object) floatID)
                    return typeof(float);
                else if ((object) typeName.Name == (object) doubleID)
                    return typeof(double);
                else if ((object) typeName.Name == (object) oldDecimalID)
                    return typeof(decimal);
                else if ((object) typeName.Name == (object) oldTimeInstantID)
                    return typeof(DateTime);
                else if ((object) typeName.Name == (object) qnameID)
                    return typeof(XmlQualifiedName);
                else if ((object) typeName.Name == (object) dateID)
                    return typeof(DateTime);
                else if ((object) typeName.Name == (object) timeID)
                    return typeof(DateTime);
                else if ((object) typeName.Name == (object) hexBinaryID)
                    return typeof(byte[]);
                else if ((object) typeName.Name == (object) byteID)
                    return typeof(SByte);
                else if ((object) typeName.Name == (object) unsignedShortID)
                    return typeof(UInt16);
                else if ((object) typeName.Name == (object) unsignedIntID)
                    return typeof(UInt32);
                else if ((object) typeName.Name == (object) unsignedLongID)
                    return typeof(UInt64);
                else
                    throw CreateUnknownTypeException(typeName);
            }
            else if ((object) typeName.Namespace == (object) schemaNonXsdTypesNsID) {
                if ((object) typeName.Name == (object) charID)
                    return typeof(char);
                else if ((object) typeName.Name == (object) guidID)
                    return typeof(Guid);
                else
                    throw CreateUnknownTypeException(typeName);
            }
            else if (throwOnUnknown)
                throw CreateUnknownTypeException(typeName);
            else
                return null;
        }

        bool IsPrimitiveNamespace(string ns) {
            return (object) ns == (object) schemaNsID ||
                   (object) ns == (object) schemaNonXsdTypesNsID ||
                   (object) ns == (object) soapNsID ||
                   (object) ns == (object) schemaNs2000ID ||
                   (object) ns == (object) schemaNs1999ID;
        }

        private string ReadStringValue(){
            if (r.IsEmptyElement){
                r.Skip();
                return string.Empty;
            }
            r.ReadStartElement();
            string retVal = r.ReadString();
            ReadEndElement();
            return retVal;
        }

        private XmlQualifiedName ReadXmlQualifiedName(){
            string s;
            bool isEmpty = false;
            if (r.IsEmptyElement) {
                s = string.Empty;
                isEmpty = true;
            }
            else{
                r.ReadStartElement();
                s = r.ReadString();
            }
            XmlQualifiedName retVal = ToXmlQualifiedName(s);
            if (isEmpty)
                r.Skip();
            else
                ReadEndElement();
            return retVal;
        }

        private byte[] ReadByteArray(bool isBase64) {
            ArrayList list = new ArrayList();
            const   int MAX_ALLOC_SIZE = 64*1024;
            int     currentSize = 1024;
            byte[]  buffer;
            int     bytes = -1;
            int     offset = 0;
            int     total = 0;
            XmlTextReader reader = r as XmlTextReader;

                if (reader == null) {
                    //We dont have an API to read decoded byte[] from XmlReader
                    string value = ReadStringValue();
                    if (isBase64) {                            
                        return ToByteArrayBase64(value);
                    }
                    else {
                        return ToByteArrayHex(value);
                    }
                }

                buffer = new byte[currentSize];
                list.Add(buffer);
                while (bytes != 0) {
                    if (offset == buffer.Length) {
                        currentSize = Math.Min(currentSize*2, MAX_ALLOC_SIZE);
                        buffer = new byte[currentSize];
                        offset = 0;              
                        list.Add(buffer);
                    }

                    if (isBase64) {
                        bytes = reader.ReadBase64(buffer, offset, buffer.Length-offset);
                    }
                    else {
                        bytes = reader.ReadBinHex(buffer, offset, buffer.Length-offset);
                    }
                    offset += bytes;
                    total += bytes;

                    //This IF is to compensate an XmlTextReader bug (not conformant to their spec)
                    if (bytes != buffer.Length) {
                        break;
                    }
                }

                byte[] result = new byte[total];
                offset = 0;
                foreach (byte[] block in list) {
                    currentSize = Math.Min(block.Length, total);
                    if (currentSize > 0) {
                        Buffer.BlockCopy(block, 0, result, offset, currentSize);
                        offset += currentSize;
                        total -= currentSize;
                    }
                }
                list.Clear();
                return result;
        }

        /// <include file='doc\XmlSerializationReader.uex' path='docs/doc[@for="XmlSerializationReader.ReadTypedPrimitive"]/*' />
        protected object ReadTypedPrimitive(XmlQualifiedName type) {
            return ReadTypedPrimitive(type, false);
        }

        private object ReadTypedPrimitive(XmlQualifiedName type, bool elementCanBeType) {
            InitPrimitiveIDs();
            object value = null;
            if (!IsPrimitiveNamespace(type.Namespace) || (object)type.Name == (object)urTypeID) 
                return ReadXmlNodes(elementCanBeType);

            if ((object) type.Namespace == (object) schemaNsID || (object) type.Namespace == (object) soapNsID) {
                if ((object) type.Name == (object) stringID ||
                    (object) type.Name == (object) anyURIID ||
                    (object) type.Name == (object) durationID ||
                    (object) type.Name == (object) ENTITYID ||
                    (object) type.Name == (object) ENTITIESID ||
                    (object) type.Name == (object) gDayID ||
                    (object) type.Name == (object) gMonthID ||
                    (object) type.Name == (object) gMonthDayID ||
                    (object) type.Name == (object) gYearID ||
                    (object) type.Name == (object) gYearMonthID ||
                    (object) type.Name == (object) IDID ||
                    (object) type.Name == (object) IDREFID ||
                    (object) type.Name == (object) IDREFSID ||
                    (object) type.Name == (object) integerID ||
                    (object) type.Name == (object) languageID ||
                    (object) type.Name == (object) negativeIntegerID ||
                    (object) type.Name == (object) nonPositiveIntegerID ||
                    (object) type.Name == (object) nonNegativeIntegerID ||
                    (object) type.Name == (object) normalizedStringID ||
                    (object) type.Name == (object) NOTATIONID ||
                    (object) type.Name == (object) positiveIntegerID ||
                    (object) type.Name == (object) tokenID)
                    value = ReadStringValue();
                else if ((object) type.Name == (object) intID)
                    value = XmlConvert.ToInt32(ReadStringValue());
                else if ((object) type.Name == (object) booleanID)
                    value = XmlConvert.ToBoolean(ReadStringValue());
                else if ((object) type.Name == (object) shortID)
                    value = XmlConvert.ToInt16(ReadStringValue());
                else if ((object) type.Name == (object) longID)
                    value = XmlConvert.ToInt64(ReadStringValue());
                else if ((object)type.Name == (object)floatID)
                    value = XmlConvert.ToSingle(ReadStringValue());
                else if ((object)type.Name == (object)doubleID)
                    value = XmlConvert.ToDouble(ReadStringValue());
                else if ((object)type.Name == (object)decimalID)
                    value = XmlConvert.ToDecimal(ReadStringValue());
                else if ((object)type.Name == (object)dateTimeID)
                    value = ToDateTime(ReadStringValue());
                else if ((object) type.Name == (object) qnameID)
                    value = ReadXmlQualifiedName();
                else if ((object) type.Name == (object) dateID)
                    value = ToDate(ReadStringValue());
                else if ((object) type.Name == (object) timeID)
                    value = ToTime(ReadStringValue());
                else if ((object) type.Name == (object) unsignedByteID)
                    value = XmlConvert.ToByte(ReadStringValue());
                else if ((object) type.Name == (object) byteID)
                    value = XmlConvert.ToSByte(ReadStringValue());
                else if ((object) type.Name == (object) unsignedShortID)
                    value = XmlConvert.ToUInt16(ReadStringValue());
                else if ((object) type.Name == (object) unsignedIntID)
                    value = XmlConvert.ToUInt32(ReadStringValue());
                else if ((object) type.Name == (object) unsignedLongID)
                    value = XmlConvert.ToUInt64(ReadStringValue());
                else if ((object) type.Name == (object) hexBinaryID)
                    value = ToByteArrayHex(false);
                else if ((object) type.Name == (object) base64BinaryID)
                    value = ToByteArrayBase64(false);
                else if ((object) type.Name == (object) base64ID && (object) type.Namespace == (object) soapNsID)
                    value = ToByteArrayBase64(ReadStringValue());
                else
                    value = ReadXmlNodes(elementCanBeType);
            }
            else if ((object) type.Namespace == (object) schemaNs2000ID || (object) type.Namespace == (object) schemaNs1999ID) {
                if ((object) type.Name == (object) stringID ||
                    (object) type.Name == (object) anyURIID ||
                    (object) type.Name == (object) durationID ||
                    (object) type.Name == (object) ENTITYID ||
                    (object) type.Name == (object) ENTITIESID ||
                    (object) type.Name == (object) gDayID ||
                    (object) type.Name == (object) gMonthID ||
                    (object) type.Name == (object) gMonthDayID ||
                    (object) type.Name == (object) gYearID ||
                    (object) type.Name == (object) gYearMonthID ||
                    (object) type.Name == (object) IDID ||
                    (object) type.Name == (object) IDREFID ||
                    (object) type.Name == (object) IDREFSID ||
                    (object) type.Name == (object) integerID ||
                    (object) type.Name == (object) languageID ||
                    (object) type.Name == (object) negativeIntegerID ||
                    (object) type.Name == (object) nonPositiveIntegerID ||
                    (object) type.Name == (object) nonNegativeIntegerID ||
                    (object) type.Name == (object) normalizedStringID ||
                    (object) type.Name == (object) NOTATIONID ||
                    (object) type.Name == (object) positiveIntegerID ||
                    (object) type.Name == (object) tokenID)
                    value = ReadStringValue();
                else if ((object) type.Name == (object) intID)
                    value = XmlConvert.ToInt32(ReadStringValue());
                else if ((object) type.Name == (object) booleanID)
                    value = XmlConvert.ToBoolean(ReadStringValue());
                else if ((object) type.Name == (object) shortID)
                    value = XmlConvert.ToInt16(ReadStringValue());
                else if ((object) type.Name == (object) longID)
                    value = XmlConvert.ToInt64(ReadStringValue());
                else if ((object)type.Name == (object)floatID)
                    value = XmlConvert.ToSingle(ReadStringValue());
                else if ((object)type.Name == (object)doubleID)
                    value = XmlConvert.ToDouble(ReadStringValue());
                else if ((object)type.Name == (object) oldDecimalID)
                    value = XmlConvert.ToDecimal(ReadStringValue());
                else if ((object)type.Name == (object) oldTimeInstantID)
                    value = ToDateTime(ReadStringValue());
                else if ((object) type.Name == (object) qnameID)
                    value = ReadXmlQualifiedName();
                else if ((object) type.Name == (object) dateID)
                    value = ToDate(ReadStringValue());
                else if ((object) type.Name == (object) timeID)
                    value = ToTime(ReadStringValue());
                else if ((object) type.Name == (object) unsignedByteID)
                    value = XmlConvert.ToByte(ReadStringValue());
                else if ((object) type.Name == (object) byteID)
                    value = XmlConvert.ToSByte(ReadStringValue());
                else if ((object) type.Name == (object) unsignedShortID)
                    value = XmlConvert.ToUInt16(ReadStringValue());
                else if ((object) type.Name == (object) unsignedIntID)
                    value = XmlConvert.ToUInt32(ReadStringValue());
                else if ((object) type.Name == (object) unsignedLongID)
                    value = XmlConvert.ToUInt64(ReadStringValue());
                else
                    value = ReadXmlNodes(elementCanBeType);
            }
            else if ((object) type.Namespace == (object) schemaNonXsdTypesNsID) {
                if ((object) type.Name == (object) charID)
                    value = ToChar(ReadStringValue());
                else if ((object) type.Name == (object) guidID)
                    value = new Guid(ReadStringValue());
                else
                    value = ReadXmlNodes(elementCanBeType);
            }
            else
                value = ReadXmlNodes(elementCanBeType);
            return value;
        }

        /// <include file='doc\XmlSerializationReader.uex' path='docs/doc[@for="XmlSerializationReader.IsXmlnsAttribute"]/*' />
        protected bool IsXmlnsAttribute(string name) {
            if (!name.StartsWith("xmlns")) return false;
            if (name.Length == 5) return true;
            return name[5] == ':';
        }

        /// <include file='doc\XmlSerializationReader.uex' path='docs/doc[@for="XmlSerializationReader.IsArrayTypeAttribute"]/*' />
        protected void ParseWsdlArrayType(XmlAttribute attr) {
            if ((object)attr.LocalName == (object)wsdlArrayTypeID && (object)attr.NamespaceURI == (object)wsdlNsID ) {

                int colon = attr.Value.LastIndexOf(':');
                if (colon < 0) {
                    attr.Value = r.LookupNamespace("") + ":" + attr.Value;
                }
                else {
                    attr.Value = r.LookupNamespace(attr.Value.Substring(0, colon)) + ":" + attr.Value.Substring(colon + 1);
                }
            }
            return;
        }

        /// <include file='doc\XmlSerializationReader.uex' path='docs/doc[@for="XmlSerializationReader.IsReturnValue"]/*' />
        protected bool IsReturnValue {
            // value only valid for soap 1.1
            get { return isReturnValue && !soap12; }
            set { isReturnValue = value; }
        }

        /// <include file='doc\XmlSerializationReader.uex' path='docs/doc[@for="XmlSerializationReader.ReadNull"]/*' />
        protected bool ReadNull() {
            if (!GetNullAttr()) return false;
            if (r.IsEmptyElement) {
                r.Skip();
                return true;
            }
            r.ReadStartElement();
            while (r.NodeType != XmlNodeType.EndElement)
                UnknownNode(null);
            ReadEndElement();
            return true;
        }

        /// <include file='doc\XmlSerializationReader.uex' path='docs/doc[@for="XmlSerializationReader.GetNullAttr"]/*' />
        protected bool GetNullAttr() {
            string isNull = r.GetAttribute(nilID, instanceNsID);
            if(isNull == null)
                isNull = r.GetAttribute(nullID, instanceNsID);
            if (isNull == null) {
                isNull = r.GetAttribute(nullID, instanceNs2000ID);
                if (isNull == null)
                    isNull = r.GetAttribute(nullID, instanceNs1999ID);
            }
            if (isNull == null || !XmlConvert.ToBoolean(isNull)) return false;
            return true;
        }

        /// <include file='doc\XmlSerializationReader.uex' path='docs/doc[@for="XmlSerializationReader.ReadNullableString"]/*' />
        protected string ReadNullableString() {
            if (ReadNull()) return null;
            return r.ReadElementString();
        }

        /// <include file='doc\XmlSerializationReader.uex' path='docs/doc[@for="XmlSerializationReader.ReadNullableQualifiedName"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected XmlQualifiedName ReadNullableQualifiedName() {
            if (ReadNull()) return null;
            return ReadElementQualifiedName();
        }

        /// <include file='doc\XmlSerializationReader.uex' path='docs/doc[@for="XmlSerializationReader.ReadElementQualifiedName"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected XmlQualifiedName ReadElementQualifiedName() {
            if (r.IsEmptyElement) {
                r.Skip();
                return ToXmlQualifiedName(String.Empty);
            }
            XmlQualifiedName qname = ToXmlQualifiedName(r.ReadString());
            r.ReadEndElement();
            return qname;
        }

        /// <include file='doc\XmlSerializationReader.uex' path='docs/doc[@for="XmlSerializationReader.ReadXmlDocument"]/*' />
        protected XmlDocument ReadXmlDocument(bool wrapped) {
            XmlNode n = ReadXmlNode(wrapped);
            XmlDocument doc = new XmlDocument();
            doc.AppendChild(doc.ImportNode(n, true));
            return doc;
        }

        /// <include file='doc\XmlSerializationReader.uex' path='docs/doc[@for="XmlSerializationReader.ReadXmlNode"]/*' />
        protected XmlNode ReadXmlNode(bool wrapped) {
            XmlNode node = null;
            if (wrapped) {
                if (ReadNull()) return null;
                r.ReadStartElement();
                r.MoveToContent();
                if (r.NodeType != XmlNodeType.EndElement)
                    node = Document.ReadNode(r);
                while (r.NodeType != XmlNodeType.EndElement)
                    UnknownNode(null);
                r.ReadEndElement();
            }
            else
                node = Document.ReadNode(r);
            return node;
        }
            
        /// <include file='doc\XmlSerializationReader.uex' path='docs/doc[@for="XmlSerializationReader.ToByteArrayBase64"]/*' />
        protected static byte[] ToByteArrayBase64(string value) {
            return XmlCustomFormatter.ToByteArrayBase64(value);
        }

        /// <include file='doc\XmlSerializationReader.uex' path='docs/doc[@for="XmlSerializationReader.ToByteArrayBase641"]/*' />
        protected byte[] ToByteArrayBase64(bool isNull) {
            if (isNull) {
                return null;
            }
            return ReadByteArray(true); //means use Base64
        }

        /// <include file='doc\XmlSerializationReader.uex' path='docs/doc[@for="XmlSerializationReader.ToByteArrayHex"]/*' />
        protected static byte[] ToByteArrayHex(string value) {
            return XmlCustomFormatter.ToByteArrayHex(value);
        }

        /// <include file='doc\XmlSerializationReader.uex' path='docs/doc[@for="XmlSerializationReader.ToByteArrayHex1"]/*' />
        protected byte[] ToByteArrayHex(bool isNull) {
            if (isNull) {
                return null;
            }
            return ReadByteArray(false); //means use BinHex
        }

        /// <include file='doc\XmlSerializationReader.uex' path='docs/doc[@for="XmlSerializationReader.GetArrayLength"]/*' />
        protected int GetArrayLength(string name, string ns) {
            if (GetNullAttr()) return 0;
            string arrayType = r.GetAttribute(arrayTypeID, soapNsID);
            SoapArrayInfo arrayInfo = ParseArrayType(arrayType);
            if (arrayInfo.dimensions != 1) throw new InvalidOperationException(Res.GetString(Res.XmlInvalidArrayDimentions, CurrentTag()));
            XmlQualifiedName qname = ToXmlQualifiedName(arrayInfo.qname);
            if (qname.Name != name) throw new InvalidOperationException(Res.GetString(Res.XmlInvalidArrayTypeName, qname.Name, name, CurrentTag()));
            if (qname.Namespace != ns) throw new InvalidOperationException(Res.GetString(Res.XmlInvalidArrayTypeNamespace, qname.Namespace, ns, CurrentTag()));
            return arrayInfo.length;
        }

        struct SoapArrayInfo {
            /// <include file='doc\XmlSerializationReader.uex' path='docs/doc[@for="XmlSerializationReader.qname;"]/*' />
            public string qname;
            /// <include file='doc\XmlSerializationReader.uex' path='docs/doc[@for="XmlSerializationReader.dimensions;"]/*' />
            public int dimensions;
            /// <include file='doc\XmlSerializationReader.uex' path='docs/doc[@for="XmlSerializationReader.length;"]/*' />
            public int length;
            public int jaggedDimensions;
        }
 
        private SoapArrayInfo ParseArrayType(string value) {
            if (value == null) {
                throw new ArgumentNullException(Res.GetString(Res.XmlMissingArrayType, CurrentTag()));
            }

            if (value.Length == 0) {
                throw new ArgumentException(Res.GetString(Res.XmlEmptyArrayType, CurrentTag()), "value");
            }
 
            char[] chars = value.ToCharArray();
            int charsLength = chars.Length;
        
            SoapArrayInfo soapArrayInfo = new SoapArrayInfo(); 
 
            // Parse backwards to get length first, then optional dimensions, then qname.
            int pos = charsLength - 1;
 
            // Must end with ]
            if (chars[pos] != ']') {
                throw new ArgumentException(Res.GetString(Res.XmlInvalidArraySyntax), "value");
            }
            pos--;   
 
            // Find [
            while (pos != -1 && chars[pos] != '[') {
                if (chars[pos] == ',')
                    throw new ArgumentException(Res.GetString(Res.XmlInvalidArrayDimentions, CurrentTag()), "value");
                pos--;
            }
            if (pos == -1) {
                throw new ArgumentException(Res.GetString(Res.XmlMismatchedArrayBrackets), "value");
            }
 
            int len = charsLength - pos - 2;
            if (len > 0) {
                string lengthString = new String(chars, pos + 1, len);
                try {
                    soapArrayInfo.length = Int32.Parse(lengthString);
                }
                catch (Exception) {
                    throw new ArgumentException(Res.GetString(Res.XmlInvalidArrayLength, lengthString), "value");
                }
            }
            else {
                soapArrayInfo.length = -1;
            }

            pos--;         

            soapArrayInfo.jaggedDimensions = 0;
            while (pos != -1 && chars[pos] == ']') {
                pos--;
                if (pos < 0)
                    throw new ArgumentException(Res.GetString(Res.XmlMismatchedArrayBrackets), "value");
                if (chars[pos] == ',')
                    throw new ArgumentException(Res.GetString(Res.XmlInvalidArrayDimentions, CurrentTag()), "value");
                else if (chars[pos] != '[')
                    throw new ArgumentException(Res.GetString(Res.XmlInvalidArraySyntax), "value");
                pos--;
                soapArrayInfo.jaggedDimensions++;
            }

            soapArrayInfo.dimensions = 1;
 
            // everything else is qname - validation of qnames?
            soapArrayInfo.qname = new String(chars, 0, pos + 1);
            return soapArrayInfo;
        }

        private SoapArrayInfo ParseSoap12ArrayType(string itemType, string arraySize) {
            SoapArrayInfo soapArrayInfo = new SoapArrayInfo(); 

            if (itemType != null && itemType.Length > 0)
                soapArrayInfo.qname = itemType;
            else
                soapArrayInfo.qname = "";

            string[] dimensions;
            if (arraySize != null && arraySize.Length > 0)
                dimensions = arraySize.Split(null);
            else
                dimensions = new string[0];

            soapArrayInfo.dimensions = 0;
            soapArrayInfo.length = -1;
            for (int i = 0; i < dimensions.Length; i++) {
                if (dimensions[i].Length > 0) {
                    if (dimensions[i] == "*") {
                        soapArrayInfo.dimensions++;
                    }
                    else {
                        try {
                            soapArrayInfo.length = Int32.Parse(dimensions[i]);
                            soapArrayInfo.dimensions++;
                        }
                        catch (Exception) {
                            throw new ArgumentException(Res.GetString(Res.XmlInvalidArrayLength, dimensions[i]), "value");
                        }
                    }
                }
            }
            if (soapArrayInfo.dimensions == 0)
                soapArrayInfo.dimensions = 1; // default is 1D even if no arraySize is specified

            return soapArrayInfo;
        }

        /// <include file='doc\XmlSerializationReader.uex' path='docs/doc[@for="XmlSerializationReader.ToDateTime"]/*' />
        protected static DateTime ToDateTime(string value) {
            return XmlCustomFormatter.ToDateTime(value);
        }

        /// <include file='doc\XmlSerializationReader.uex' path='docs/doc[@for="XmlSerializationReader.ToDate"]/*' />
        protected static DateTime ToDate(string value) {
            return XmlCustomFormatter.ToDate(value);
        }

        /// <include file='doc\XmlSerializationReader.uex' path='docs/doc[@for="XmlSerializationReader.ToTime"]/*' />
        protected static DateTime ToTime(string value) {
            return XmlCustomFormatter.ToTime(value);
        }

        /// <include file='doc\XmlSerializationReader.uex' path='docs/doc[@for="XmlSerializationReader.ToChar"]/*' />
        protected static char ToChar(string value) {
            return XmlCustomFormatter.ToChar(value);
        }

        /// <include file='doc\XmlSerializationReader.uex' path='docs/doc[@for="XmlSerializationReader.ToEnum"]/*' />
        protected static long ToEnum(string value, Hashtable h, string typeName) {
            return XmlCustomFormatter.ToEnum(value, h, typeName, true);
        }

        /// <include file='doc\XmlSerializationReader.uex' path='docs/doc[@for="XmlSerializationReader.ToXmlName"]/*' />
        protected static string ToXmlName(string value) {
            return XmlCustomFormatter.ToXmlName(value);
        }

        /// <include file='doc\XmlSerializationReader.uex' path='docs/doc[@for="XmlSerializationReader.ToXmlNCName"]/*' />
        protected static string ToXmlNCName(string value) {
            return XmlCustomFormatter.ToXmlNCName(value);
        }
        
        /// <include file='doc\XmlSerializationReader.uex' path='docs/doc[@for="XmlSerializationReader.ToXmlNmToken"]/*' />
        protected static string ToXmlNmToken(string value) {
            return XmlCustomFormatter.ToXmlNmToken(value);
        }
        
        /// <include file='doc\XmlSerializationReader.uex' path='docs/doc[@for="XmlSerializationReader.ToXmlNmTokens"]/*' />
        protected static string ToXmlNmTokens(string value) {
            return XmlCustomFormatter.ToXmlNmTokens(value);
        }
        
        /// <include file='doc\XmlSerializationReader.uex' path='docs/doc[@for="XmlSerializationReader.ToXmlQualifiedName"]/*' />
        protected XmlQualifiedName ToXmlQualifiedName(string value) {
            int colon = value.LastIndexOf(':');
            value = XmlConvert.DecodeName(value);
            if (colon < 0) {
                return new XmlQualifiedName(r.NameTable.Add(value), r.LookupNamespace(""));
            }
            else {
                string ns = r.LookupNamespace(value.Substring(0, colon));
                if (ns == null) {
                    // Namespace prefix '{0}' is not defined.
                    throw new InvalidOperationException(Res.GetString(Res.XmlUndefinedAlias, value.Substring(0, colon)));
                }
                return new XmlQualifiedName(r.NameTable.Add(value.Substring(colon + 1)), ns);
            }
        }

        /// <include file='doc\XmlSerializationReader.uex' path='docs/doc[@for="XmlSerializationReader.UnknownAttribute"]/*' />
        protected void UnknownAttribute(object o, XmlAttribute attr) {
            if (events.onUnknownAttribute != null) {
                int lineNumber, linePosition;
                GetCurrentPosition(out lineNumber, out linePosition);
                XmlAttributeEventArgs e = new XmlAttributeEventArgs(attr, lineNumber, linePosition, o);
                events.onUnknownAttribute(events.sender, e);
            }
        }

        /// <include file='doc\XmlSerializationReader.uex' path='docs/doc[@for="XmlSerializationReader.UnknownElement"]/*' />
        protected void UnknownElement(object o, XmlElement elem) {
            if (events.onUnknownElement != null) {
                int lineNumber, linePosition;
                GetCurrentPosition(out lineNumber, out linePosition);
                XmlElementEventArgs e = new XmlElementEventArgs(elem, lineNumber, linePosition, o);
                events.onUnknownElement(events.sender, e);
            }
        }

        /// <include file='doc\XmlSerializationReader.uex' path='docs/doc[@for="XmlSerializationReader.UnknownNode"]/*' />
        protected void UnknownNode(object o) {
            XmlNode unknownNode = Document.ReadNode(r);
            UnknownNode(unknownNode, o);
        }

        void UnknownNode(XmlNode unknownNode, object o){
            if (unknownNode.NodeType != XmlNodeType.None && r.NodeType != XmlNodeType.Whitespace && events.onUnknownNode != null) {
                int lineNumber, linePosition;
                GetCurrentPosition(out lineNumber, out linePosition);
                XmlNodeEventArgs e = new XmlNodeEventArgs(unknownNode, lineNumber, linePosition, o);
                events.onUnknownNode(events.sender, e);
            }
            if (unknownNode.NodeType == XmlNodeType.Attribute) {
                UnknownAttribute(o, (XmlAttribute)unknownNode);
            }
            else if (unknownNode.NodeType == XmlNodeType.Element) {
                UnknownElement(o, (XmlElement)unknownNode);
            }
        }


        void GetCurrentPosition(out int lineNumber, out int linePosition){
            if (Reader is XmlTextReader){
                XmlTextReader textReader = (XmlTextReader)Reader;
                lineNumber = textReader.LineNumber;
                linePosition = textReader.LinePosition;
            }
            else
                lineNumber = linePosition = -1;
        }

        /// <include file='doc\XmlSerializationReader.uex' path='docs/doc[@for="XmlSerializationReader.UnreferencedObject"]/*' />
        protected void UnreferencedObject(string id, object o) {
            if (events.onUnreferencedObject != null) {
                UnreferencedObjectEventArgs e = new UnreferencedObjectEventArgs(o, id);
                events.onUnreferencedObject(events.sender, e);
            }
        }

        string CurrentTag() {
            switch (r.NodeType) {
                case XmlNodeType.Element:
                    return "<" + r.LocalName + " xmlns='" + r.NamespaceURI + "'>";
                case XmlNodeType.EndElement:
                    return ">";
                case XmlNodeType.Text:
                    return r.Value;
                case XmlNodeType.CDATA:
                    return "CDATA";
                case XmlNodeType.Comment:
                    return "<--";
                case XmlNodeType.ProcessingInstruction:
                    return "<?";
                default:
                    return "(unknown)";
            }
        }

        /// <include file='doc\XmlSerializationReader.uex' path='docs/doc[@for="XmlSerializationReader.CreateUnknownTypeException"]/*' />
        protected Exception CreateUnknownTypeException(XmlQualifiedName type) {
            return new InvalidOperationException(Res.GetString(Res.XmlUnknownType, type.Name, type.Namespace, CurrentTag()));
        }

        /// <include file='doc\XmlSerializationReader.uex' path='docs/doc[@for="XmlSerializationReader.CreateReadOnlyCollectionException"]/*' />
        protected Exception CreateReadOnlyCollectionException(string name) {
            return new InvalidOperationException(Res.GetString(Res.XmlReadOnlyCollection, name));
        }

        /// <include file='doc\XmlSerializationReader.uex' path='docs/doc[@for="XmlSerializationReader.CreateAbstractTypeException"]/*' />
        protected Exception CreateAbstractTypeException(string name, string ns) {
            return new InvalidOperationException(Res.GetString(Res.XmlAbstractType, name, ns, CurrentTag()));
        }

        /// <include file='doc\XmlSerializationReader.uex' path='docs/doc[@for="XmlSerializationReader.CreateInaccessibleConstructorException"]/*' />
        protected Exception CreateInaccessibleConstructorException(string typeName) {
            return new InvalidOperationException(Res.GetString(Res.XmlConstructorInaccessible, typeName));
        }

        /// <include file='doc\XmlSerializationReader.uex' path='docs/doc[@for="XmlSerializationReader.CreateCtorHasSecurityException"]/*' />
        protected Exception CreateCtorHasSecurityException(string typeName) {
            return new InvalidOperationException(Res.GetString(Res.XmlConstructorHasSecurityAttributes, typeName));
        }

        /// <include file='doc\XmlSerializationReader.uex' path='docs/doc[@for="XmlSerializationReader.CreateUnknownNodeException"]/*' />
        protected Exception CreateUnknownNodeException() {
            return new InvalidOperationException(Res.GetString(Res.XmlUnknownNode, CurrentTag()));
        }

        /// <include file='doc\XmlSerializationReader.uex' path='docs/doc[@for="XmlSerializationReader.CreateUnknownConstantException"]/*' />
        protected Exception CreateUnknownConstantException(string value, Type enumType) {
            return new InvalidOperationException(Res.GetString(Res.XmlUnknownConstant, value, enumType.Name));
        }

        /// <include file='doc\XmlSerializationReader.uex' path='docs/doc[@for="XmlSerializationReader.CreateInvalidCastException"]/*' />
        protected Exception CreateInvalidCastException(Type type, object value) {
            if (value == null)
                return new InvalidCastException(Res.GetString(Res.XmlInvalidNullCast, type.FullName));
            else
                return new InvalidCastException(Res.GetString(Res.XmlInvalidCast, value.GetType().FullName, type.FullName));
        }

        /// <include file='doc\XmlSerializationReader.uex' path='docs/doc[@for="XmlSerializationReader.EnsureArrayIndex"]/*' />
        protected Array EnsureArrayIndex(Array a, int index, Type elementType) {
            if (a == null) return Array.CreateInstance(elementType, 32);
            if (index < a.Length) return a;
            Array b = Array.CreateInstance(elementType, a.Length * 2);
            Array.Copy(a, b, index);
            return b;
        }

        /// <include file='doc\XmlSerializationReader.uex' path='docs/doc[@for="XmlSerializationReader.ShrinkArray"]/*' />
        protected Array ShrinkArray(Array a, int length, Type elementType, bool isNullable) {
            if (a == null) {
                if (isNullable) return null;
                return Array.CreateInstance(elementType, 0);
            }
            if (a.Length == length) return a;
            Array b = Array.CreateInstance(elementType, length);
            Array.Copy(a, b, length);
            return b;
        } 

        /// <include file='doc\XmlSerializationReader.uex' path='docs/doc[@for="XmlSerializationReader.ReadString"]/*' />
        protected string ReadString(string value) {
            if (value == null || value.Length == 0)
                return r.ReadString();
            return value + r.ReadString();
        }

        /// <include file='doc\XmlSerializationReader.uex' path='docs/doc[@for="XmlSerializationReader.ReadSerializable"]/*' />
        protected IXmlSerializable ReadSerializable(IXmlSerializable serializable) {
            serializable.ReadXml(r);
            return serializable;
        }

        /// <include file='doc\XmlSerializationReader.uex' path='docs/doc[@for="XmlSerializationReader.ReadReference"]/*' />
        protected bool ReadReference(out string fixupReference) {
            string href = r.GetAttribute(soap12 ? "ref" : "href");
            if (href == null) {
                fixupReference = null;
                return false;
            }
            if (!soap12) {
                // soap 1.1 href starts with '#'; soap 1.2 ref does not
                if (!href.StartsWith("#")) throw new InvalidOperationException(Res.GetString(Res.XmlMissingHref, href));
                fixupReference = href.Substring(1);
            }
            else
                fixupReference = href;

            if (r.IsEmptyElement) {
                r.Skip();
            }
            else {
                r.ReadStartElement();
                ReadEndElement();
            }
            return true;
        }

        void AddUnknownTargetType(string id, XmlQualifiedName typeName) {
            if (unknownTargetTypes == null) unknownTargetTypes = new Hashtable();
            unknownTargetTypes.Add(id, typeName);
        }

        /// <include file='doc\XmlSerializationReader.uex' path='docs/doc[@for="XmlSerializationReader.AddTarget"]/*' />
        protected void AddTarget(string id, object o) {
            if (id == null) {
                if (targetsWithoutIds == null) 
                    targetsWithoutIds = new ArrayList();
                if (o != null) 
                    targetsWithoutIds.Add(o);
            }
            else {
                if (targets == null) targets = new Hashtable();
                if (!targets.Contains(id))
                    targets.Add(id, o);
            }
        }



        /// <include file='doc\XmlSerializationReader.uex' path='docs/doc[@for="XmlSerializationReader.AddFixup"]/*' />
        protected void AddFixup(Fixup fixup) {
            if (fixups == null) fixups = new ArrayList();
            fixups.Add(fixup);
        }

        /// <include file='doc\XmlSerializationReader.uex' path='docs/doc[@for="XmlSerializationReader.AddFixup2"]/*' />
        protected void AddFixup(CollectionFixup fixup) {
            if (collectionFixups == null) collectionFixups = new ArrayList();
            collectionFixups.Add(fixup);
        }

        /// <include file='doc\XmlSerializationReader.uex' path='docs/doc[@for="XmlSerializationReader.GetTarget"]/*' />
        protected object GetTarget(string id) {
            object target = targets != null ? targets[id] : null;
            if (target == null) {
                if (unknownTargetTypes != null) {
                    XmlQualifiedName unknownTypeName = (XmlQualifiedName)unknownTargetTypes[id];
                    if (unknownTypeName != null) {
                        CreateUnknownTypeException(unknownTypeName);
                    }
                }
                throw new InvalidOperationException(Res.GetString(Res.XmlInvalidHref, id));
            }
            Referenced(target);
            return target;
        }

        /// <include file='doc\XmlSerializationReader.uex' path='docs/doc[@for="XmlSerializationReader.Referenced"]/*' />
        protected void Referenced(object o) {
            if (o == null) return;
            if (referencedTargets == null) referencedTargets = new Hashtable();
            referencedTargets[o] = o;
        }

        void HandleUnreferencedObjects() {
            if (targets != null) {
                foreach (DictionaryEntry target in targets) {
                    if (referencedTargets == null || !referencedTargets.Contains(target.Value)) {
                        UnreferencedObject((string)target.Key, target.Value);
                    }
                }
            }
            if (targetsWithoutIds != null) {
                foreach (object o in targetsWithoutIds) {
                    if (referencedTargets == null || !referencedTargets.Contains(o)) {
                        UnreferencedObject(null, o);
                    }
                }
            }
        }

        void DoFixups() {
            if (fixups == null) return;
            for (int i = 0; i < fixups.Count; i++) {
                Fixup fixup = (Fixup)fixups[i];
                fixup.Callback(fixup);
            }

            if (collectionFixups == null) return;
            for (int i = 0; i < collectionFixups.Count; i++) {
                CollectionFixup collectionFixup = (CollectionFixup)collectionFixups[i];
                collectionFixup.Callback(collectionFixup.Collection, collectionFixup.CollectionItems);
            }
        }

        /// <include file='doc\XmlSerializationReader.uex' path='docs/doc[@for="XmlSerializationReader.FixupArrayRefs"]/*' />
        protected void FixupArrayRefs(object fixup) {
            Fixup f = (Fixup)fixup;
            Array array = (Array)f.Source;
            for (int i = 0; i < array.Length; i++) {
                string id = f.Ids[i];
                if (id == null) continue;
                object o = GetTarget(id);
                array.SetValue(o, i);
            }
        }

        object ReadArray(string typeName, string typeNs) {
            SoapArrayInfo arrayInfo;
            Type fallbackElementType = null;
            if (soap12) {
                string itemType = r.GetAttribute(itemTypeID, soap12NsID);
                string arraySize = r.GetAttribute(arraySizeID, soap12NsID);
                Type arrayType = (Type)types[new XmlQualifiedName(typeName, typeNs)];
                // no indication that this is an array?
                if (itemType == null && arraySize == null && (arrayType == null || !arrayType.IsArray))
                    return null;

                arrayInfo = ParseSoap12ArrayType(itemType, arraySize);
                if (arrayType != null)
                    fallbackElementType = TypeScope.GetArrayElementType(arrayType);
            }
            else {
                string arrayType = r.GetAttribute(arrayTypeID, soapNsID);
                if (arrayType == null) 
                    return null;

                arrayInfo = ParseArrayType(arrayType);
            }

            if (arrayInfo.dimensions != 1) throw new InvalidOperationException(Res.GetString(Res.XmlInvalidArrayDimentions, CurrentTag()));

            // NOTE: don't use the array size that is specified since an evil client might pass
            // a number larger than the actual number of items in an attempt to harm the server.

            XmlQualifiedName qname;
            bool isPrimitive;
            Type elementType = null;
            XmlQualifiedName urTypeName = new XmlQualifiedName(urTypeID, schemaNsID);
            if (arrayInfo.qname.Length > 0) {
                qname = ToXmlQualifiedName(arrayInfo.qname);
                elementType = (Type)types[qname];
            }
            else
                qname = urTypeName;
            
            // try again if the best we could come up with was object
            if (soap12 && elementType == typeof(object))
                elementType = null;
            
            if (elementType == null) {
                if (!soap12) {
                    elementType = GetPrimitiveType(qname, true);
                    isPrimitive = true;
                }
                else {
                    // try it as a primitive
                    if (qname != urTypeName)
                        elementType = GetPrimitiveType(qname, false);
                    if (elementType != null) {
                        isPrimitive = true;
                    }
                    else {
                        // still nothing: go with fallback type or object
                        if (fallbackElementType == null) {
                            elementType = typeof(object);
                            isPrimitive = false;
                        }
                        else {
                            elementType = fallbackElementType;
                            XmlQualifiedName newQname = (XmlQualifiedName)typesReverse[elementType];
                            if (newQname == null) {
                                newQname = XmlSerializationWriter.GetPrimitiveTypeNameInternal(elementType);
                                isPrimitive = true;
                            }
                            else
                                isPrimitive = elementType.IsPrimitive;
                            if (newQname != null) qname = newQname;
                        }
                    }
                }
            }
            else
                isPrimitive = elementType.IsPrimitive;

            if (!soap12 && arrayInfo.jaggedDimensions > 0) {
                // Unfortunately there's no way to create an array type given its
                // element type without actually creating the array.
                int[] dummyLengths = new int[arrayInfo.jaggedDimensions];
                Array dummyArray = Array.CreateInstance(elementType, dummyLengths);
                elementType = dummyArray.GetType();
            }

            if (r.IsEmptyElement) {
                r.Skip();
                return Array.CreateInstance(elementType, 0);
            }

            r.ReadStartElement();
            r.MoveToContent();

            int arrayLength = 0;
            Array array = null;

            if (elementType.IsValueType) {
                if (!isPrimitive && !elementType.IsEnum) {
                    throw new NotSupportedException(Res.GetString(Res.XmlRpcArrayOfValueTypes, elementType.FullName));
                }
                // CONSIDER, erikc, we could have specialized read functions here
                // for primitives, which would avoid boxing.
                while (r.NodeType != XmlNodeType.EndElement) {
                    array = EnsureArrayIndex(array, arrayLength, elementType);
                    array.SetValue(ReadReferencedElement(qname.Name, qname.Namespace), arrayLength);
                    arrayLength++;
                    r.MoveToContent();
                }
                array = ShrinkArray(array, arrayLength, elementType, false);
    
            }
            else {
                string type;
                string typens;
                string[] ids = null;
                int idsLength = 0;

                while (r.NodeType != XmlNodeType.EndElement) {
                    array = EnsureArrayIndex(array, arrayLength, elementType);
                    ids = (string[])EnsureArrayIndex(ids, idsLength, typeof(string));
                    // CONSIDER: i'm not sure it's correct to let item name take precedence over arrayType
                    if (r.NamespaceURI.Length != 0){
                        type = r.LocalName;
                        if ((object)r.NamespaceURI == (object)soapNsID)
                            typens = XmlSchema.Namespace;
                        else
                            typens = r.NamespaceURI;
                    }
                    else {
                        type = qname.Name;
                        typens = qname.Namespace;                        
                    }
                    array.SetValue(ReadReferencingElement(type, typens, out ids[idsLength]), arrayLength);
                    arrayLength++;
                    idsLength++;
                    // CONSIDER, erikc, sparse arrays, perhaps?
                    r.MoveToContent();
                }
                // special case for soap 1.2: try to get a better fit than object[] when no metadata is known
                // this applies in the doc/enc/bare case
                if (soap12 && elementType == typeof(object)) {
                    Type itemType = null;
                    for (int i = 0; i < arrayLength; i++) {
                        object currItem = array.GetValue(i);
                        if (currItem != null) {
                            Type currItemType = currItem.GetType();
                            if (itemType == null || currItemType.IsAssignableFrom(itemType)) {
                                itemType = currItemType;
                            }
                            else if (!itemType.IsAssignableFrom(currItemType)) {
                                itemType = null;
                                break;
                            }
                        }
                    }
                    if (itemType != null)
                        elementType = itemType;
                }
                ids = (string[])ShrinkArray(ids, idsLength, typeof(string), false);
                array = ShrinkArray(array, arrayLength, elementType, false);
                Fixup fixupArray = new Fixup(array, new XmlSerializationFixupCallback(this.FixupArrayRefs), ids);
                AddFixup(fixupArray);
            }

            // CONSIDER, erikc, check to see if the specified array length was right, perhaps?

            ReadEndElement();
            return array;
        }

        /// <include file='doc\XmlSerializationReader.uex' path='docs/doc[@for="XmlSerializationReader.InitCallbacks"]/*' />
        protected abstract void InitCallbacks();

        /// <include file='doc\XmlSerializationReader.uex' path='docs/doc[@for="XmlSerializationReader.ReadReferencedElements"]/*' />
        protected void ReadReferencedElements() {
            r.MoveToContent();
            string dummy;
            while (r.NodeType != XmlNodeType.EndElement && r.NodeType != XmlNodeType.None) {
                ReadReferencingElement(null, null, true, out dummy);
                r.MoveToContent();
            }
            DoFixups();

            HandleUnreferencedObjects();
        }

        /// <include file='doc\XmlSerializationReader.uex' path='docs/doc[@for="XmlSerializationReader.ReadReferencedElement"]/*' />
        protected object ReadReferencedElement() {
            return ReadReferencedElement(null, null);
        }

        /// <include file='doc\XmlSerializationReader.uex' path='docs/doc[@for="XmlSerializationReader.ReadReferencedElement1"]/*' />
        protected object ReadReferencedElement(string name, string ns) {
            string dummy;
            return ReadReferencingElement(name, ns, out dummy);
        }

        /// <include file='doc\XmlSerializationReader.uex' path='docs/doc[@for="XmlSerializationReader.ReadReferencingElement"]/*' />
        protected object ReadReferencingElement(out string fixupReference) {
            return ReadReferencingElement(null, null, out fixupReference);
        }

        /// <include file='doc\XmlSerializationReader.uex' path='docs/doc[@for="XmlSerializationReader.ReadReferencingElement1"]/*' />
        protected object ReadReferencingElement(string name, string ns, out string fixupReference) {
            return ReadReferencingElement(name, ns, false, out fixupReference);
        }

        /// <include file='doc\XmlSerializationReader.uex' path='docs/doc[@for="XmlSerializationReader.ReadReferencingElement2"]/*' />
        protected object ReadReferencingElement(string name, string ns, bool elementCanBeType, out string fixupReference) {
            object o = null;

            if (callbacks == null) {
                callbacks = new Hashtable();
                types = new Hashtable();
                XmlQualifiedName urType = new XmlQualifiedName(urTypeID, r.NameTable.Add(XmlSchema.Namespace));
                types.Add(urType, typeof(object));
                typesReverse = new Hashtable();
                typesReverse.Add(typeof(object), urType);
                InitCallbacks();
            }

            r.MoveToContent();

            if (ReadReference(out fixupReference)) return null;

            if (ReadNull()) return null;

            string id = r.GetAttribute("id", null);

            if ((o = ReadArray(name, ns)) == null) {

                XmlQualifiedName typeId = GetXsiType();
                if (typeId == null) {
                    if (name == null)
                        typeId = new XmlQualifiedName(r.NameTable.Add(r.LocalName), r.NameTable.Add(r.NamespaceURI));
                    else
                        typeId = new XmlQualifiedName(r.NameTable.Add(name), r.NameTable.Add(ns));
                }
                XmlSerializationReadCallback callback = (XmlSerializationReadCallback)callbacks[typeId];
                if (callback != null) {
                    o = callback();
                }
                else 
                    o = ReadTypedPrimitive(typeId, elementCanBeType);
            }

            AddTarget(id, o);

            return o;
        }

        /// <include file='doc\XmlSerializationReader.uex' path='docs/doc[@for="XmlSerializationReader.AddReadCallback"]/*' />
        protected void AddReadCallback(string name, string ns, Type type, XmlSerializationReadCallback read) {
            XmlQualifiedName typeName = new XmlQualifiedName(r.NameTable.Add(name), r.NameTable.Add(ns));
            callbacks.Add(typeName, read);
            types.Add(typeName, type);
            typesReverse[type] = typeName;
        }

        /// <include file='doc\XmlSerializationReader.uex' path='docs/doc[@for="XmlSerializationReader.ReadEndElement"]/*' />
        protected void ReadEndElement() {
            while (r.NodeType == XmlNodeType.Whitespace) r.Skip();
            if (r.NodeType == XmlNodeType.None) r.Skip();
            else r.ReadEndElement();
        }

        object ReadXmlNodes( bool elementCanBeType) {

            ArrayList xmlNodeList = new ArrayList();
            string elemLocalName = Reader.LocalName;
            string elemNs = Reader.NamespaceURI;
            string elemName = Reader.Name;
            string xsiTypeName = null;
            string xsiTypeNs = null;
            int skippableNodeCount = 0;
            int lineNumber = -1, linePosition=-1;
            XmlNode unknownNode = null;
            if(Reader.NodeType == XmlNodeType.Attribute){
                XmlAttribute attr = Document.CreateAttribute(elemName, elemNs);
                attr.Value = Reader.Value;
                unknownNode = attr;
            }
            else
                unknownNode = Document.CreateElement(elemName, elemNs);
            GetCurrentPosition(out lineNumber, out linePosition);
            XmlElement unknownElement = unknownNode as XmlElement;

            while (Reader.MoveToNextAttribute()) {
                if (IsXmlnsAttribute(Reader.Name) || Reader.Name == "id")
                    skippableNodeCount++;
                if ( (object)Reader.LocalName == (object)typeID &&
                     ( (object)Reader.NamespaceURI == (object)instanceNsID ||
                       (object)Reader.NamespaceURI == (object)instanceNs2000ID ||
                       (object)Reader.NamespaceURI == (object)instanceNs1999ID
                     )
                   ){
                    string value = Reader.Value;
                    int colon = value.LastIndexOf(':');
                    xsiTypeName = (colon >= 0) ? value.Substring(colon+1) : value;
                    xsiTypeNs = Reader.LookupNamespace((colon >= 0) ? value.Substring(0, colon) : "");
                }
                XmlAttribute xmlAttribute = (XmlAttribute)Document.ReadNode(r);
                xmlNodeList.Add(xmlAttribute);
                if (unknownElement != null) unknownElement.SetAttributeNode(xmlAttribute);
            }

            // If the node is referenced (or in case of paramStyle = bare) and if xsi:type is not
            // specified then the element name is used as the type name. Reveal this to the user
            // by adding an extra attribute node "xsi:type" with value as the element name.
            if(elementCanBeType && xsiTypeName == null){
                xsiTypeName = elemLocalName;
                xsiTypeNs = elemNs;
                XmlAttribute xsiTypeAttribute = Document.CreateAttribute(typeID, instanceNsID);
                xsiTypeAttribute.Value = elemName;
                xmlNodeList.Add(xsiTypeAttribute);
            }
            if( xsiTypeName == Soap.UrType &&
                ( (object)xsiTypeNs == (object)schemaNsID ||
                  (object)xsiTypeNs == (object)schemaNs1999ID ||
                  (object)xsiTypeNs == (object)schemaNs2000ID
                )
               )
                skippableNodeCount++;
            
            
            Reader.MoveToElement();
            if (Reader.IsEmptyElement) {
                Reader.Skip();
            }
            else {
                Reader.ReadStartElement();
                Reader.MoveToContent();
                while (Reader.NodeType != System.Xml.XmlNodeType.EndElement) {
                    XmlNode xmlNode = Document.ReadNode(r);
                    xmlNodeList.Add(xmlNode);
                    if (unknownElement != null) unknownElement.AppendChild(xmlNode);
                    Reader.MoveToContent();
                }
                ReadEndElement();

            }


            if(xmlNodeList.Count <= skippableNodeCount)
                return new object();

            XmlNode[] childNodes =  (XmlNode[])xmlNodeList.ToArray(typeof(XmlNode));

            UnknownNode(unknownNode, null);
            return childNodes;
        }

        /// <include file='doc\XmlSerializationReader.uex' path='docs/doc[@for="Fixup"]/*' />
        ///<internalonly/>
        protected class Fixup {
            XmlSerializationFixupCallback callback;
            object source;
            string[] ids;

            /// <include file='doc\XmlSerializationReader.uex' path='docs/doc[@for="Fixup.Fixup1"]/*' />
            public Fixup(object o, XmlSerializationFixupCallback callback, int count) 
                : this (o, callback, new string[count]) {
            }

            /// <include file='doc\XmlSerializationReader.uex' path='docs/doc[@for="Fixup.Fixup2"]/*' />
            public Fixup(object o, XmlSerializationFixupCallback callback, string[] ids) {
                this.callback = callback;
                this.Source = o;
                this.ids = ids;
            }

            /// <include file='doc\XmlSerializationReader.uex' path='docs/doc[@for="Fixup.Callback"]/*' />
            public XmlSerializationFixupCallback Callback {
                get { return callback; }
            }

            /// <include file='doc\XmlSerializationReader.uex' path='docs/doc[@for="Fixup.Source"]/*' />
            public object Source {
                get { return source; }
                set { source = value; }
            }

            /// <include file='doc\XmlSerializationReader.uex' path='docs/doc[@for="Fixup.Ids"]/*' />
            public string[] Ids {
                get { return ids; }
            }
        }

        /// <include file='doc\XmlSerializationReader.uex' path='docs/doc[@for="CollectionFixup"]/*' />
        protected class CollectionFixup {
            XmlSerializationCollectionFixupCallback callback;
            object collection;
            object collectionItems;

            /// <include file='doc\XmlSerializationReader.uex' path='docs/doc[@for="CollectionFixup.CollectionFixup"]/*' />
            public CollectionFixup(object collection, XmlSerializationCollectionFixupCallback callback, object collectionItems) {
                this.callback = callback;
                this.collection = collection;
                this.collectionItems = collectionItems;
            }

            /// <include file='doc\XmlSerializationReader.uex' path='docs/doc[@for="CollectionFixup.Callback"]/*' />
            public XmlSerializationCollectionFixupCallback Callback {
                get { return callback; }
            }

            /// <include file='doc\XmlSerializationReader.uex' path='docs/doc[@for="CollectionFixup.Collection"]/*' />
            public object Collection {
                get { return collection; }
            }

            /// <include file='doc\XmlSerializationReader.uex' path='docs/doc[@for="CollectionFixup.CollectionItems"]/*' />
            public object CollectionItems {
                get { return collectionItems; }
            }
        }
    }

    /// <include file='doc\XmlSerializationReader.uex' path='docs/doc[@for="XmlSerializationFixupCallback"]/*' />
    ///<internalonly/>
    public delegate void XmlSerializationFixupCallback(object fixup);


    /// <include file='doc\XmlSerializationReader.uex' path='docs/doc[@for="XmlSerializationCollectionFixupCallback"]/*' />
    ///<internalonly/>
    public delegate void XmlSerializationCollectionFixupCallback(object collection, object collectionItems);

    /// <include file='doc\XmlSerializationReader.uex' path='docs/doc[@for="XmlSerializationReadCallback"]/*' />
    ///<internalonly/>
    public delegate object XmlSerializationReadCallback();

    internal class XmlSerializationReaderCodeGen {
        IndentedWriter writer;
        Hashtable methodNames = new Hashtable();
        Hashtable idNames = new Hashtable();
        Hashtable enums;
        Hashtable createMethods = new Hashtable();
        int nextMethodNumber = 0;
        int nextCreateMethodNumber = 0;
        int nextIdNumber = 0;
        TypeScope[] scopes;
        TypeDesc stringTypeDesc;
        TypeDesc qnameTypeDesc;
        string access = "public";
        string className = "XmlSerializationReader1";

        internal Hashtable Enums {
            get {
                if (enums == null) {
                    enums = new Hashtable();
                }
                return enums;
            }
        }

        class CreateCollectionInfo {
            string name;
            TypeDesc td;

            internal CreateCollectionInfo(string name, TypeDesc td) {
                this.name = name;
                this.td = td;
            }
            internal string Name {
                get { return name; }
            }

            internal TypeDesc TypeDesc {
                get { return td; }
            }
        }
        class Member {
            string source;
            string arrayName;
            string arraySource;
            string choiceArrayName;
            string choiceSource;
            string choiceArraySource;
            MemberMapping mapping;
            bool isArray;
            bool isList;
            bool isNullable;
            bool multiRef;
            bool hasAccessor = true;
            int fixupIndex = -1;
            string paramsReadSource;
            string checkSpecifiedSource;

            internal Member(string source, string arrayName, int i, MemberMapping mapping) 
                : this(source, null, arrayName, i, mapping, false, null) {
            }
            internal Member(string source, string arrayName, int i, MemberMapping mapping, string choiceSource)
                : this(source, null, arrayName, i, mapping, false, choiceSource) {
            }
            internal Member(string source, string arraySource, string arrayName, int i, MemberMapping mapping) 
                : this (source, arraySource, arrayName, i, mapping, false, null) { 
            }
            internal Member(string source, string arraySource, string arrayName, int i, MemberMapping mapping, string choiceSource) 
                : this (source, arraySource, arrayName, i, mapping, false, choiceSource) { 
            }
            internal Member(string source, string arrayName, int i, MemberMapping mapping, bool multiRef)
                : this(source, null, arrayName, i, mapping, multiRef, null) {
            }
            internal Member(string source, string arraySource, string arrayName, int i, MemberMapping mapping, bool multiRef, string choiceSource) {
                this.source = source;
                this.arrayName = arrayName + "_" + i.ToString();
                this.choiceArrayName = "choice_" + this.arrayName;
                this.choiceSource = choiceSource;
                ElementAccessor[] elements = mapping.Elements;

                if (mapping.TypeDesc.IsArrayLike) {
                    if (arraySource != null)
                        this.arraySource = arraySource;
                    else
                        this.arraySource = GetArraySource(mapping.TypeDesc, this.arrayName, multiRef);
                    isArray = mapping.TypeDesc.IsArray;
                    isList = !isArray;
                    if (mapping.ChoiceIdentifier != null) {
                        this.choiceArraySource = GetArraySource(mapping.TypeDesc, this.choiceArrayName, multiRef);

                        string a = choiceArrayName;
                        string c = "c" + a;
                        string choiceTypeFullName = CodeIdentifier.EscapeKeywords(mapping.ChoiceIdentifier.Mapping.TypeDesc.FullName);
                        string init = a + " = (" + choiceTypeFullName + 
                            "[])EnsureArrayIndex(" + a + ", " + c + ", typeof(" + choiceTypeFullName + "));";
                        this.choiceArraySource = init + a + "[" + c + "++]";
                    }
                    else {
                        this.choiceArraySource = this.choiceSource;
                    }
                }
                else {
                    this.arraySource = arraySource == null ? source : arraySource;
                    this.choiceArraySource = this.choiceSource;
                }
                this.mapping = mapping;
            }

            internal MemberMapping Mapping {
                get { return mapping; }
            }

            internal string Source {
                get { return source; }
            }

            internal string ArrayName {
                get { return arrayName; }
            }

            internal string ArraySource {
                get { return arraySource; }
            }

            internal bool IsList {
                get { return isList; }
            }

            internal bool IsArrayLike {
                get { return (isArray || isList); }
            }

            internal bool IsNullable {
                get { return isNullable; }
                set { isNullable = value; }
            }

            internal bool MultiRef {
                get { return multiRef; }
                set { multiRef = value; }
            }

            internal int FixupIndex {
                get { return fixupIndex; }
                set { fixupIndex = value; }
            }

            internal bool HasAccessor {
                get { return hasAccessor; }
                set { hasAccessor = value; }
            }

            internal string ParamsReadSource {
                get { return paramsReadSource; }
                set { paramsReadSource = value; }
            }
            
            internal string CheckSpecifiedSource {
                get { return checkSpecifiedSource; }
                set { checkSpecifiedSource = value; }
            }

            internal string ChoiceSource {
                get { return choiceSource; }
            }
            internal string ChoiceArrayName {
                get { return choiceArrayName; }
            }
            internal string ChoiceArraySource {
                get { return choiceArraySource; }
            }
        }

        internal XmlSerializationReaderCodeGen(IndentedWriter writer, TypeScope[] scopes, string access, string className) : this(writer, scopes){
            this.className = className;
            this.access = access;
        }
        internal XmlSerializationReaderCodeGen(IndentedWriter writer, TypeScope[] scopes) {
            this.writer = writer;
            this.scopes = scopes;
            stringTypeDesc = scopes[0].GetTypeDesc(typeof(string));
            qnameTypeDesc = scopes[0].GetTypeDesc(typeof(XmlQualifiedName));
        }

        internal void GenerateBegin() {
            writer.Write(access);
            writer.Write(" class ");
            writer.Write(className);
            writer.Write(" : ");
            writer.Write(typeof(XmlSerializationReader).FullName);
            writer.WriteLine(" {");
            writer.Indent++;
            foreach (TypeScope scope in scopes) {
                foreach (TypeMapping mapping in scope.TypeMappings) {
                    if (mapping is StructMapping || mapping is EnumMapping) 
                        methodNames.Add(mapping, NextMethodName(((TypeMapping)mapping).TypeDesc.Name));
                }
            }

            foreach (TypeScope scope in scopes) {
                foreach (TypeMapping mapping in scope.TypeMappings) {
                    if (mapping is StructMapping)
                        WriteStructMethod((StructMapping)mapping);
                    else if (mapping is EnumMapping)
                        WriteEnumMethod((EnumMapping)mapping);
                }
            }

            GenerateInitCallbacksMethod();
        }

        internal void GenerateEnd() {
            foreach (CreateCollectionInfo c in createMethods.Values) {
                WriteCreateCollectionMethod(c);
            }

            writer.WriteLine();
            foreach (string idName in idNames.Values) {
                writer.Write(typeof(string).FullName);
                writer.Write(" ");
                writer.Write(idName);
                writer.WriteLine(";");
            }                

            writer.WriteLine();
            writer.WriteLine("protected override void InitIDs() {");
            writer.Indent++;
            foreach (string id in idNames.Keys) {
                // CONSIDER, erikc, switch to enumerating via DictionaryEntry when issue recolved in BCL
                string idName = (string)idNames[id];
                writer.Write(idName);
                writer.Write(" = Reader.NameTable.Add(");
                WriteQuotedCSharpString(id);
                writer.WriteLine(");");
            }
            writer.Indent--;
            writer.WriteLine("}");

            writer.Indent--;
            writer.WriteLine("}");
        }

        internal string GenerateElement(XmlMapping xmlMapping) {
            if (!xmlMapping.GenerateSerializer) 
                throw new ArgumentException(Res.GetString(Res.XmlInternalError), "xmlMapping");

            if (xmlMapping is XmlTypeMapping)
                return GenerateTypeElement((XmlTypeMapping)xmlMapping);
            else if (xmlMapping is XmlMembersMapping)
                return GenerateMembersElement((XmlMembersMapping)xmlMapping);
            else
                throw new ArgumentException(Res.GetString(Res.XmlInternalError), "xmlMapping");
        }

        void WriteQuotedCSharpString(string value) {
            if (value == null) {
                // REVIEW, stefanph: this should read
                //    writer.Write("null");
                // instead.
                writer.Write("\"\"");
                return;
            }
            writer.Write("@\"");

            for (int i=0; i<value.Length; i++) {
                if (value[i] == '\"')
                    writer.Write("\"\"");
                else
                    writer.Write(value[i]);
            }

            writer.Write("\"");
        }

        void WriteIsStartTag(string name, string ns) {
            writer.Write("if (Reader.IsStartElement(");
            WriteID(name);
            writer.Write(", ");
            WriteID(ns);
            writer.WriteLine(")) {");
            writer.Indent++;
        }

        void WriteElse(string source, bool anyIfs) {
            if (anyIfs) {
                writer.WriteLine("else {");
                writer.Indent++;
            }
            writer.WriteLine(source);
            if (anyIfs) {
                writer.Indent--;
                writer.WriteLine("}");
            }
        }

        void GenerateInitCallbacksMethod() {
            writer.WriteLine();
            writer.WriteLine("protected override void InitCallbacks() {");
            writer.Indent++;

            string dummyArrayMethodName = NextMethodName("Array");
            bool needDummyArrayMethod = false;
            foreach (TypeScope scope in scopes) {
                foreach (TypeMapping mapping in scope.TypeMappings) {
                    if (mapping.IsSoap && 
                        (mapping is StructMapping || mapping is EnumMapping || mapping is ArrayMapping) &&
                        !mapping.TypeDesc.IsRoot) {

                        string methodName;
                        if (mapping is ArrayMapping) {
                            methodName = dummyArrayMethodName;
                            needDummyArrayMethod = true;
                        }
                        else
                            methodName = (string)methodNames[mapping];

                        writer.Write("AddReadCallback(");
                        WriteID(mapping.TypeName);
                        writer.Write(", ");
                        WriteID(mapping.Namespace);
                        writer.Write(", typeof(");
                        writer.Write(CodeIdentifier.EscapeKeywords(mapping.TypeDesc.FullName));
                        writer.Write("), new ");
                        writer.Write(typeof(XmlSerializationReadCallback).FullName);
                        writer.Write("(this.");
                        writer.Write(methodName);
                        writer.WriteLine("));");
                    }
                }
            }

            writer.Indent--;
            writer.WriteLine("}");

            if (needDummyArrayMethod) {
                writer.WriteLine();
                writer.Write("object ");
                writer.Write(dummyArrayMethodName);
                writer.WriteLine("() {");
                writer.Indent++;
                writer.WriteLine("// dummy array method");
                writer.WriteLine("return null;");
                writer.Indent--;
                writer.WriteLine("}");
            }
        }

       
        string GenerateMembersElement(XmlMembersMapping xmlMembersMapping) {
            if (xmlMembersMapping.Accessor.IsSoap)
                return GenerateEncodedMembersElement(xmlMembersMapping);
            else
                return GenerateLiteralMembersElement(xmlMembersMapping);
        }

        string GetChoiceIdentifierSource(MemberMapping[] mappings, MemberMapping member) {
            string choiceSource = null;
            if (member.ChoiceIdentifier != null) {
                for (int j = 0; j < mappings.Length; j++) {
                    if (mappings[j].Name == member.ChoiceIdentifier.MemberName) {
                        choiceSource = "p[" + j.ToString() + "]";
                        break;
                    }
                }
                #if DEBUG
                    // use exception in the place of Debug.Assert to avoid throwing asserts from a server process such as aspnet_ewp.exe
                    if (choiceSource == null) throw new InvalidOperationException(Res.GetString(Res.XmlInternalErrorDetails, "Can not find " + member.ChoiceIdentifier.MemberName + " in the members mapping."));
                #endif

            }
            return choiceSource;
        }

        string GetChoiceIdentifierSource(MemberMapping mapping, string parent) {
            if (mapping.ChoiceIdentifier == null) return "";
            CodeIdentifier.CheckValidIdentifier(mapping.ChoiceIdentifier.MemberName);
            return parent + ".@" + mapping.ChoiceIdentifier.MemberName;
        }

        string GenerateLiteralMembersElement(XmlMembersMapping xmlMembersMapping) {
            ElementAccessor element = xmlMembersMapping.Accessor;
            MemberMapping[] mappings = ((MembersMapping)element.Mapping).Members;
            bool hasWrapperElement = ((MembersMapping)element.Mapping).HasWrapperElement;
            string methodName = NextMethodName(element.Name);
            writer.WriteLine();
            writer.Write("public object[] ");
            writer.Write(methodName);
            writer.WriteLine("() {");
            writer.Indent++;
            writer.WriteLine("Reader.MoveToContent();");

            writer.Write("object[] p = new object[");
            writer.Write(mappings.Length.ToString());
            writer.WriteLine("];");
            InitializeValueTypes("p", mappings);

            if (hasWrapperElement) {
                WriteWhileNotEndTag();
                writer.Indent++;
                WriteIsStartTag(element.Name, element.Form == XmlSchemaForm.Qualified ? element.Namespace : "");
            }

            Member anyText = null;
            Member anyElement = null;
            Member anyAttribute = null; 

            ArrayList membersList = new ArrayList();
            ArrayList textOrArrayMembersList = new ArrayList();
            ArrayList attributeMembersList = new ArrayList();
            
            for (int i = 0; i < mappings.Length; i++) {
                MemberMapping mapping = mappings[i];
                string source = "p[" + i.ToString() + "]";
                string arraySource = source;
                if (mapping.Xmlns != null) {
                    arraySource = "((" + CodeIdentifier.EscapeKeywords(mapping.TypeDesc.FullName) + ")" + source + ")";
                }
                Member member = new Member(source, arraySource, "a", i, mapping, GetChoiceIdentifierSource(mappings, mapping));
                Member anyMember = new Member(source, "a", i, mapping);
                member.ParamsReadSource = "paramsRead[" + i.ToString() + "]";
                if (mapping.CheckSpecified) {
                    string nameSpecified = mapping.Name + "Specified";
                    for (int j = 0; j < mappings.Length; j++) {
                        if (mappings[j].Name == nameSpecified) {
                            member.CheckSpecifiedSource = "p[" + j.ToString() + "]";
                            break;
                        }
                    }
                }
                bool foundAnyElement = false;
                if (mapping.Text != null) anyText = anyMember;
                if (mapping.Attribute != null && mapping.Attribute.Any)
                    anyAttribute = anyMember;
                if (mapping.Attribute != null || mapping.Xmlns != null)
                    attributeMembersList.Add(member);
                else if (mapping.Text != null)
                    textOrArrayMembersList.Add(member);
                for (int j = 0; j < mapping.Elements.Length; j++) {
                    if (mapping.Elements[j].Any && mapping.Elements[j].Name.Length == 0) {
                        anyElement = anyMember;
                        if (mapping.Attribute == null && mapping.Text == null)
                            textOrArrayMembersList.Add(anyMember);
                        foundAnyElement = true;
                        break;
                    }
                }

                if (mapping.Attribute != null || mapping.Text != null || foundAnyElement)
                    membersList.Add(anyMember);
                else if (mapping.TypeDesc.IsArray && !(mapping.Elements.Length == 1 && mapping.Elements[0].Mapping is ArrayMapping)) {
                    membersList.Add(anyMember);
                    textOrArrayMembersList.Add(anyMember);
                }
                else {
                    if (mapping.TypeDesc.IsArrayLike && !mapping.TypeDesc.IsArray)
                        member.ParamsReadSource = null; // collection
                    membersList.Add(member);
                }
            }
            Member[] members = (Member[]) membersList.ToArray(typeof(Member));
            Member[] textOrArrayMembers = (Member[]) textOrArrayMembersList.ToArray(typeof(Member));
            Member[] attributeMembers = (Member[]) attributeMembersList.ToArray(typeof(Member));
            
            WriteParamsRead(mappings.Length);

            WriteMemberBegin(attributeMembers);

            writer.WriteLine("while (Reader.MoveToNextAttribute()) {");
            writer.Indent++;
            WriteAttributes(attributeMembers, anyAttribute, "UnknownNode((object)p);");
            writer.Indent--;
            writer.WriteLine("}");
            WriteMemberEnd(attributeMembers);
            writer.WriteLine("Reader.MoveToElement();");

            WriteMemberBegin(textOrArrayMembers);

            if (hasWrapperElement) {
                writer.WriteLine("if (Reader.IsEmptyElement) { Reader.Skip(); Reader.MoveToContent(); continue; }");
                writer.WriteLine("Reader.ReadStartElement();");
            }

            WriteWhileNotEndTag();
            writer.Indent++;

            WriteMemberElements(members, "UnknownNode((object)p);", "UnknownNode((object)p);", anyElement, anyText, null);

            writer.WriteLine("Reader.MoveToContent();");
            writer.Indent--;
            writer.WriteLine("}");

            WriteMemberEnd(textOrArrayMembers);

            if (hasWrapperElement) {
                writer.WriteLine("ReadEndElement();");

                writer.Indent--;
                writer.WriteLine("}");

                WriteElse("UnknownNode(null);", true);

                writer.WriteLine("Reader.MoveToContent();");
                writer.Indent--;
                writer.WriteLine("}");
            }
            
            writer.WriteLine("return p;");
            writer.Indent--;
            writer.WriteLine("}");
            
            return methodName;
        }
        
        void InitializeValueTypes(string arrayName, MemberMapping[] mappings) {
            for (int i = 0; i < mappings.Length; i++) {
                if (!mappings[i].TypeDesc.IsValueType)
                    continue;
                writer.Write(arrayName);
                writer.Write("[");
                writer.Write(i.ToString());
                writer.Write("] = new ");
                writer.Write(mappings[i].TypeDesc.FullName);
                writer.WriteLine("();");
            }
        }
        
        string GenerateEncodedMembersElement(XmlMembersMapping xmlMembersMapping) {
            ElementAccessor element = xmlMembersMapping.Accessor;
            MembersMapping membersMapping = (MembersMapping)element.Mapping;
            MemberMapping[] mappings = membersMapping.Members;
            bool hasWrapperElement = membersMapping.HasWrapperElement;
            bool writeAccessors = membersMapping.WriteAccessors;
            string methodName = NextMethodName(element.Name);
            writer.WriteLine();
            writer.Write("public object[] ");
            writer.Write(methodName);
            writer.WriteLine("() {");
            writer.Indent++;

            writer.WriteLine("Reader.MoveToContent();");

            writer.Write("object[] p = new object[");
            writer.Write(mappings.Length.ToString());
            writer.WriteLine("];");
            InitializeValueTypes("p", mappings);

            if (hasWrapperElement) {
                WriteReadNonRoots();

                if (membersMapping.ValidateRpcWrapperElement) {
                    writer.Write("if (!");
                    WriteXmlNodeEqual("Reader", element.Name, element.Form == XmlSchemaForm.Qualified ? element.Namespace : "");
                    writer.WriteLine(") throw CreateUnknownNodeException();");
                }
                writer.WriteLine("Reader.ReadStartElement();");
            }

            Member[] members = new Member[mappings.Length];
            for (int i = 0; i < mappings.Length; i++) {
                MemberMapping mapping = mappings[i];
                string source = "p[" + i.ToString() + "]";
                string arraySource = source;
                if (mapping.Xmlns != null) {
                    arraySource = "((" + CodeIdentifier.EscapeKeywords(mapping.TypeDesc.FullName) + ")" + source + ")";
                }
                Member member = new Member(source, arraySource, "a", i, mapping);
                member.HasAccessor = writeAccessors || hasWrapperElement;
                member.ParamsReadSource = "paramsRead[" + i.ToString() + "]";
                members[i] = member;
            }

            string fixupMethodName = "fixup_" + methodName;
            bool anyFixups = WriteMemberFixupBegin(members, fixupMethodName, "p");

            if (members.Length > 0 && members[0].Mapping.IsReturnValue) writer.WriteLine("IsReturnValue = true;");

            string checkTypeHrefSource = (!hasWrapperElement && !writeAccessors) ? "hrefList" : null;
            if (checkTypeHrefSource != null)
                WriteInitCheckTypeHrefList(checkTypeHrefSource);
                     
            WriteParamsRead(mappings.Length);
            WriteWhileNotEndTag();
            writer.Indent++;

            string unrecognizedElementSource = checkTypeHrefSource == null ? "UnknownNode((object)p);" : "if (Reader.GetAttribute(\"id\", null) != null) { ReadReferencedElement(); } else { UnknownNode((object)p); }";
            WriteMemberElements(members, unrecognizedElementSource, "UnknownNode((object)p);", null, null, checkTypeHrefSource);
            writer.WriteLine("Reader.MoveToContent();");

            writer.Indent--;
            writer.WriteLine("}");

            if (hasWrapperElement)
                writer.WriteLine("ReadEndElement();");

            if (checkTypeHrefSource != null)
                WriteHandleHrefList(members, checkTypeHrefSource);

            writer.WriteLine("ReadReferencedElements();");
            writer.WriteLine("return p;");

            writer.Indent--;
            writer.WriteLine("}");

            if (anyFixups) WriteFixupMethod(fixupMethodName, members, typeof(object[]).FullName, false, "p");
          
            return methodName;
        }

        void WriteCreateCollection(TypeDesc td, string source) {
            string item = (td.ArrayElementTypeDesc == null ? typeof(object).FullName : CodeIdentifier.EscapeKeywords(td.ArrayElementTypeDesc.FullName)) + "[]";
            writer.Write(item);
            writer.Write(" ci = (");
            writer.Write(item);
            writer.Write(")");
            writer.Write(source);
            writer.WriteLine(";");
            writer.WriteLine("for (int i = 0; i < ci.Length; i++) {");
            writer.Indent++;
            writer.WriteLine("c.Add(ci[i]);");
            writer.Indent--;
            writer.WriteLine("}");
        }

        string GenerateTypeElement(XmlTypeMapping xmlTypeMapping) {
            ElementAccessor element = xmlTypeMapping.Accessor;
            TypeMapping mapping = (TypeMapping)element.Mapping;
            string methodName = NextMethodName(element.Name);
            writer.WriteLine();
            writer.Write("public object ");
            writer.Write(methodName);
            writer.WriteLine("() {");
            writer.Indent++;
            writer.WriteLine("object o = null;");
            MemberMapping member = new MemberMapping();
            member.TypeDesc = mapping.TypeDesc;
            member.Elements = new ElementAccessor[] { element };
            Member[] members = new Member[] { new Member("o", "o", "a", 0, member) };
            writer.WriteLine("Reader.MoveToContent();");
            WriteMemberElements(members, "throw CreateUnknownNodeException();", "UnknownNode(null);", element.Any ? members[0] : null,  null, null);
            if (element.IsSoap) {
                writer.WriteLine("Referenced(o);");
                writer.WriteLine("ReadReferencedElements();");
            }
            writer.WriteLine("return (object)o;");
            writer.Indent--;
            writer.WriteLine("}");
            return methodName;
        }
        
        string NextMethodName(string name) {
            return "Read" + (++nextMethodNumber).ToString() + "_" + CodeIdentifier.MakeValid(name);
        }
        
        string NextIdName(string name) {
            return "id" + (++nextIdNumber).ToString() + "_" + CodeIdentifier.MakeValid(name);
        }

        void WritePrimitive(TypeMapping mapping, string source) {
            if (mapping is EnumMapping) {
                string enumMethodName = (string)methodNames[mapping];
                if (enumMethodName == null) throw new InvalidOperationException(Res.GetString(Res.XmlMissingMethodEnum, mapping.TypeDesc.Name));
                if (mapping.IsSoap) {
                    // SOAP methods are not strongly-typed (the return object), so we need to add a cast
                    writer.Write("(");
                    writer.Write(CodeIdentifier.EscapeKeywords(mapping.TypeDesc.FullName));
                    writer.Write(")");
                }
                writer.Write(enumMethodName);
                writer.Write("(");
                if (!mapping.IsSoap) writer.Write(source);
                writer.Write(")");
            }
            else if (mapping.TypeDesc == stringTypeDesc || mapping.TypeDesc.FormatterName == "String") {
                writer.Write(source);
            }
            else {
                if (!mapping.TypeDesc.HasCustomFormatter) {
                    writer.Write(typeof(XmlConvert).FullName);
                    writer.Write(".");
                }
                writer.Write("To");
                writer.Write(mapping.TypeDesc.FormatterName);
                writer.Write("(");
                writer.Write(source);
                writer.Write(")");
            }
        }

        string MakeUnique(EnumMapping mapping, string name) {
            string uniqueName = name;
            object m = Enums[uniqueName];
            if (m != null) {
                if (m == mapping) {
                    // we already have created the hashtable
                    return null;
                }
                int i = 0;
                while (m != null) {
                    i++;
                    uniqueName = name + i.ToString();
                    m = Enums[uniqueName];
                }
            }
            Enums.Add(uniqueName, mapping);
            return uniqueName;
        }

        string WriteHashtable(EnumMapping mapping, string typeName) {

            CodeIdentifier.CheckValidIdentifier(typeName);
            string propName = MakeUnique(mapping, typeName + "Values");
            if (propName == null) return CodeIdentifier.EscapeKeywords(typeName);
            string memberName = MakeUnique(mapping, "_" + propName);
            propName = CodeIdentifier.EscapeKeywords(propName);

            writer.WriteLine();
            writer.Write(typeof(Hashtable).FullName);
            writer.Write(" ");
            writer.Write(memberName);
            writer.WriteLine(";");
            writer.WriteLine();

            writer.Write("internal ");
            writer.Write(typeof(Hashtable).FullName);
            writer.Write(" ");
            writer.Write(propName);
            writer.WriteLine(" {");
            writer.Indent++;

            writer.WriteLine("get {");
            writer.Indent++;

            writer.Write("if ((object)");
            writer.Write(memberName);
            writer.WriteLine(" == null) {");
            writer.Indent++;

            writer.Write(typeof(Hashtable).FullName);
            writer.Write(" h = new ");
            writer.Write(typeof(Hashtable).FullName);
            writer.WriteLine("();");

            ConstantMapping[] constants = mapping.Constants;

            for (int i = 0; i < constants.Length; i++) {
                writer.Write("h.Add(");
                WriteQuotedCSharpString(constants[i].XmlName);
                writer.Write(", (");
                writer.Write(typeof(long).FullName);
                writer.Write(")");

                writer.Write(CodeIdentifier.EscapeKeywords(mapping.TypeDesc.FullName));
                writer.Write(".@");
                CodeIdentifier.CheckValidIdentifier(constants[i].Name);
                writer.Write(constants[i].Name);

                writer.WriteLine(");");
            }

            writer.Write(memberName);
            writer.WriteLine(" = h;");

            writer.Indent--;
            writer.WriteLine("}");

            writer.Write("return ");
            writer.Write(memberName);
            writer.WriteLine(";");

            writer.Indent--;
            writer.WriteLine("}");

            writer.Indent--;
            writer.WriteLine("}");

            return propName;
        }

        void WriteEnumMethod(EnumMapping mapping) {
            string tableName = null;
            if (mapping.IsFlags)
                tableName = WriteHashtable(mapping, mapping.TypeDesc.Name);

            string methodName = (string)methodNames[mapping];
            writer.WriteLine();
            string fullTypeName = CodeIdentifier.EscapeKeywords(mapping.TypeDesc.FullName);
            if (mapping.IsSoap) {
                writer.Write("object");
                writer.Write(" ");
                writer.Write(methodName);
                writer.WriteLine("() {");
                writer.Indent++;
                writer.WriteLine("string s = Reader.ReadElementString();");
            }
            else {
                writer.Write(fullTypeName);
                writer.Write(" ");
                writer.Write(methodName);
                writer.WriteLine("(string s) {");
                writer.Indent++;
            }

            ConstantMapping[] constants = mapping.Constants;

            if (mapping.IsFlags) {
                writer.Write("return (");
                writer.Write(fullTypeName);
                writer.Write(")ToEnum(s, ");
                writer.Write(tableName);
                writer.Write(", ");
                WriteQuotedCSharpString(fullTypeName);
                writer.WriteLine(");");
            }
            else {
                writer.WriteLine("switch (s) {");
                writer.Indent++;
                for (int i = 0; i < constants.Length; i++) {
                    ConstantMapping c = constants[i];

                    CodeIdentifier.CheckValidIdentifier(c.Name);
                    writer.Write("case ");
                    WriteQuotedCSharpString(c.XmlName);
                    writer.Write(": return ");

                    writer.Write(fullTypeName);
                    writer.Write(".@");
                    writer.Write(c.Name);
                    writer.WriteLine(";");
                }
                
                writer.Write("default: throw CreateUnknownConstantException(s, typeof(");
                writer.Write(fullTypeName);
                writer.WriteLine("));");
                writer.Indent--;
                writer.WriteLine("}");
            }

            writer.Indent--;
            writer.WriteLine("}");
        }

        void WriteDerivedTypes(StructMapping mapping) {
            for (StructMapping derived = mapping.DerivedMappings; derived != null; derived = derived.NextDerivedMapping) {
                writer.Write("else if (");
                WriteQNameEqual("t", derived.TypeName, derived.Namespace);
                writer.WriteLine(")");
                writer.Indent++;

                string methodName = (string)methodNames[derived];
                #if DEBUG
                    // use exception in the place of Debug.Assert to avoid throwing asserts from a server process such as aspnet_ewp.exe
                    if (methodName == null) throw new InvalidOperationException(Res.GetString(Res.XmlInternalErrorMethod, derived.TypeDesc.Name));
                #endif
                writer.Write("return ");
                writer.Write(methodName);
                writer.Write("(");
                if (derived.TypeDesc.IsNullable)
                    writer.Write("isNullable, ");
                writer.WriteLine("false);");

                writer.Indent--;

                WriteDerivedTypes(derived);
            }
        }

        void WriteEnumAndArrayTypes() {
            foreach (TypeScope scope in scopes) {
                foreach (Mapping m in scope.TypeMappings) {
                    if (m.IsSoap)
                        continue;
                    if (m is EnumMapping) {
                        EnumMapping mapping = (EnumMapping)m;
                        writer.Write("else if (");
                        WriteQNameEqual("t", mapping.TypeName, mapping.Namespace);
                        writer.WriteLine(") {");
                        writer.Indent++;
                        writer.WriteLine("Reader.ReadStartElement();");
                        string methodName = (string)methodNames[mapping];
                        #if DEBUG
                            // use exception in the place of Debug.Assert to avoid throwing asserts from a server process such as aspnet_ewp.exe
                            if (methodName == null) throw new InvalidOperationException(Res.GetString(Res.XmlInternalErrorMethod, mapping.TypeDesc.Name));
                        #endif
                        writer.Write("object e = ");
                        writer.Write(methodName);
                        writer.WriteLine("(Reader.ReadString());");
                        writer.WriteLine("ReadEndElement();");
                        writer.WriteLine("return e;");
                        writer.Indent--;
                        writer.WriteLine("}");
                    }
                    else if (m is ArrayMapping) {
                        ArrayMapping mapping = (ArrayMapping) m;
                        if (mapping.TypeDesc.HasDefaultConstructor) {
                            writer.Write("else if (");
                            WriteQNameEqual("t", mapping.TypeName, mapping.Namespace);
                            writer.WriteLine(") {");
                            writer.Indent++;
                            MemberMapping memberMapping = new MemberMapping();
                            memberMapping.TypeDesc = mapping.TypeDesc;
                            memberMapping.Elements = mapping.Elements;
                            Member member = new Member("a", "z", 0, memberMapping);

                            string fullTypeName = CodeIdentifier.EscapeKeywords(mapping.TypeDesc.FullName);
                            writer.Write(fullTypeName);
                            writer.Write(" a = ");
                            if (mapping.TypeDesc.IsValueType) {
                                writer.Write("new ");
                                writer.Write(fullTypeName);
                                writer.WriteLine("();");
                            }
                            else
                                writer.WriteLine("null;");

                            WriteArray(member.Source, member.ArrayName, mapping, false, false, -1);
                            writer.WriteLine("return a;");
                            writer.Indent--;
                            writer.WriteLine("}");
                        }
                    }
                }
            }
        }

        void WriteStructMethod(StructMapping structMapping) {
            if (structMapping.IsSoap)
                WriteEncodedStructMethod(structMapping);
            else
                WriteLiteralStructMethod(structMapping);
        }

        void WriteLiteralStructMethod(StructMapping structMapping) {
            string methodName = (string)methodNames[structMapping];
            writer.WriteLine();
            writer.Write(CodeIdentifier.EscapeKeywords(structMapping.TypeDesc.FullName));
            writer.Write(" ");
            writer.Write(methodName);
            writer.Write("(");
            if (structMapping.TypeDesc.IsNullable)
                writer.Write("bool isNullable, ");
            writer.WriteLine("bool checkType) {");
            writer.Indent++;

            if (structMapping.TypeDesc.IsNullable)
                writer.WriteLine("if (isNullable && ReadNull()) return null;");

            writer.WriteLine("if (checkType) {");
            writer.Indent++;
            writer.Write(typeof(XmlQualifiedName).FullName);
            writer.WriteLine(" t = GetXsiType();");
            writer.Write("if (t == null");
            if (!structMapping.TypeDesc.IsRoot) {
                writer.Write(" || ");
                WriteQNameEqual("t", structMapping.TypeName, structMapping.Namespace);
            }
            writer.WriteLine(")");
            writer.Indent++;
            if (structMapping.TypeDesc.IsRoot)
                writer.Write("return ReadTypedPrimitive(new System.Xml.XmlQualifiedName(\"" + Soap.UrType + "\", \"" + XmlSchema.Namespace + "\"))");
            writer.WriteLine(";");
            writer.Indent--;
            WriteDerivedTypes(structMapping);
            if (structMapping.TypeDesc.IsRoot) WriteEnumAndArrayTypes();
            writer.WriteLine("else");
            writer.Indent++;
            if (structMapping.TypeDesc.IsRoot)
                writer.Write("return ReadTypedPrimitive((");
            else
                writer.Write("throw CreateUnknownTypeException((");
            writer.Write(typeof(XmlQualifiedName).FullName);
            writer.WriteLine(")t);");
            writer.Indent--;
            writer.Indent--;
            writer.WriteLine("}");

            if (structMapping.TypeDesc.IsAbstract) {
                writer.Write("throw CreateAbstractTypeException(");
                WriteQuotedCSharpString(structMapping.TypeName);
                writer.Write(", ");
                WriteQuotedCSharpString(structMapping.Namespace);
                writer.WriteLine(");");
            }
            else {
                WriteCreateStruct(structMapping);

                MemberMapping[] mappings = TypeScope.GetAllMembers(structMapping);
                
                Member anyText = null;
                Member anyElement = null;
                Member anyAttribute = null; 

                ArrayList arraysToDeclareList = new ArrayList(mappings.Length);
                ArrayList arraysToSetList = new ArrayList(mappings.Length);
                ArrayList allMembersList = new ArrayList(mappings.Length);

                for (int i = 0; i < mappings.Length; i++) {
                    MemberMapping mapping = mappings[i];
                    CodeIdentifier.CheckValidIdentifier(mapping.Name);
                    Member member = new Member("o.@" + mapping.Name, "a", i, mapping, GetChoiceIdentifierSource(mapping, "o"));
                    member.ParamsReadSource = "paramsRead[" + i.ToString() + "]";
                    member.IsNullable = mapping.TypeDesc.IsNullable;
                    if (mapping.CheckSpecified)
                        member.CheckSpecifiedSource = "o.@" + mapping.Name + "Specified";
                    if (mapping.Text != null)
                        anyText = member;
                    if (mapping.Attribute != null && mapping.Attribute.Any)
                        anyAttribute = member;
                    for (int j = 0; j < mapping.Elements.Length; j++) {
                        if (mapping.Elements[j].Any && (mapping.Elements[j].Name == null || mapping.Elements[j].Name.Length == 0)) {
                            anyElement = member;
                            break;
                        }
                    }

                    if (mapping.Attribute == null && mapping.Elements.Length == 1 && mapping.Elements[0].Mapping is ArrayMapping)
                        allMembersList.Add(new Member("o.@" + mapping.Name, "o.@" + mapping.Name, "a", i, mapping, GetChoiceIdentifierSource(mapping, "o")));
                    else
                        allMembersList.Add(member);

                    if (mapping.TypeDesc.IsArrayLike) {
                        arraysToDeclareList.Add(member);
                        if (mapping.TypeDesc.IsArray && !(mapping.Elements.Length == 1 && mapping.Elements[0].Mapping is ArrayMapping)) {
                            member.ParamsReadSource = null; // flat arrays -- don't want to count params read.
                            arraysToSetList.Add(member);
                        }
                        else if (!mapping.TypeDesc.IsArray) {
                            member.ParamsReadSource = null; // collection
                        }
                    }
                }
                if (anyText != null) arraysToSetList.Add(anyText);
                if (anyElement != null) arraysToSetList.Add(anyElement);

                Member[] arraysToDeclare = (Member[]) arraysToDeclareList.ToArray(typeof(Member));
                Member[] arraysToSet = (Member[]) arraysToSetList.ToArray(typeof(Member));
                Member[] allMembers = (Member[]) allMembersList.ToArray(typeof(Member));

                WriteMemberBegin(arraysToDeclare);
                
                WriteParamsRead(mappings.Length);

                writer.WriteLine("while (Reader.MoveToNextAttribute()) {");
                writer.Indent++;

                WriteAttributes(allMembers, anyAttribute, "UnknownNode((object)o);");
                writer.Indent--;
                writer.WriteLine("}");

                if (anyAttribute != null)
                    WriteMemberEnd(arraysToDeclare);

                writer.WriteLine("Reader.MoveToElement();");
                writer.WriteLine("if (Reader.IsEmptyElement) {");
                writer.Indent++;
                writer.WriteLine("Reader.Skip();");
                WriteMemberEnd(arraysToSet);
                writer.WriteLine("return o;");
                writer.Indent--;
                writer.WriteLine("}");

                writer.WriteLine("Reader.ReadStartElement();");

                WriteWhileNotEndTag();
                writer.Indent++;

                WriteMemberElements(allMembers, "UnknownNode((object)o);", "UnknownNode((object)o);", anyElement, anyText, null);
                writer.WriteLine("Reader.MoveToContent();");

                writer.Indent--;
                writer.WriteLine("}");

                WriteMemberEnd(arraysToSet);

                writer.WriteLine("ReadEndElement();");
                writer.WriteLine("return o;");
            }
            writer.Indent--;
            writer.WriteLine("}");
        }

        void WriteEncodedStructMethod(StructMapping structMapping) {
            if(structMapping.TypeDesc.IsRoot)
                return;
            string methodName = (string)methodNames[structMapping];
            writer.WriteLine();
            writer.Write("object");
            writer.Write(" ");
            writer.Write(methodName);
            writer.Write("(");
            writer.WriteLine(") {");
            writer.Indent++;

            Member[] members;
            bool anyFixups;
            string fixupMethodName;

            if (structMapping.TypeDesc.IsAbstract) {
                writer.Write("throw CreateAbstractTypeException(");
                WriteQuotedCSharpString(structMapping.TypeName);
                writer.Write(", ");
                WriteQuotedCSharpString(structMapping.Namespace);
                writer.WriteLine(");");
                members = new Member[0];
                anyFixups = false;
                fixupMethodName = null;
            }
            else {
                WriteCreateStruct(structMapping);
                MemberMapping[] mappings = TypeScope.GetAllMembers(structMapping);
                members = new Member[mappings.Length];
                for (int i = 0; i < mappings.Length; i++) {
                    MemberMapping mapping = mappings[i];
                    CodeIdentifier.CheckValidIdentifier(mapping.Name);
                    Member member = new Member("o.@" + mapping.Name, "o.@" + mapping.Name, "a", i, mapping, GetChoiceIdentifierSource(mapping, "o"));
                    member.ParamsReadSource = "paramsRead[" + i.ToString() + "]";
                    members[i] = member;
                }

                fixupMethodName = "fixup_" + methodName;
                anyFixups = WriteMemberFixupBegin(members, fixupMethodName, "o");
                
                // we're able to not do WriteMemberBegin here because we don't allow arrays as attributes
                
                WriteParamsRead(mappings.Length);

                writer.WriteLine("while (Reader.MoveToNextAttribute()) {");
                writer.Indent++;

                WriteAttributes(members, null, "UnknownNode((object)o);");
                writer.Indent--;
                writer.WriteLine("}");

                writer.WriteLine("Reader.MoveToElement();");

                writer.WriteLine("if (Reader.IsEmptyElement) { Reader.Skip(); return o; }");
                writer.WriteLine("Reader.ReadStartElement();");

                WriteWhileNotEndTag();
                writer.Indent++;

                WriteMemberElements(members, "UnknownNode((object)o);", "UnknownNode((object)o);", null, null, null);
                writer.WriteLine("Reader.MoveToContent();");

                writer.Indent--;
                writer.WriteLine("}");

                writer.WriteLine("ReadEndElement();");
                writer.WriteLine("return o;");
            }
            writer.Indent--;
            writer.WriteLine("}");

            if (anyFixups) WriteFixupMethod(fixupMethodName, members, CodeIdentifier.EscapeKeywords(structMapping.TypeDesc.FullName), true, "o");
        }

        void WriteFixupMethod(string fixupMethodName, Member[] members, string typeName, bool typed, string source) {
            writer.WriteLine();
            writer.Write("void ");
            writer.Write(fixupMethodName);
            writer.WriteLine("(object objFixup) {");
            writer.Indent++;
            writer.WriteLine("Fixup fixup = (Fixup)objFixup;");
            writer.Write(typeName);
            writer.Write(" ");
            writer.Write(source);
            writer.Write(" = (");
            writer.Write(typeName);
            writer.WriteLine(")fixup.Source;");
            writer.WriteLine("string[] ids = fixup.Ids;");

            for (int i = 0; i < members.Length; i++) {
                Member member = members[i];
                if (member.MultiRef) {
                    string fixupIndex = member.FixupIndex.ToString();
                    writer.Write("if (ids[");
                    writer.Write(fixupIndex);
                    writer.WriteLine("] != null) {");
                    writer.Indent++;

                    string memberSource = /*member.IsList ? source + ".Add(" :*/ member.ArraySource;

                    string targetSource = "GetTarget(ids[" + fixupIndex + "])";
                    TypeDesc td = member.Mapping.TypeDesc;
                    if (td.IsCollection || td.IsEnumerable) {
                        WriteAddCollectionFixup(td, member.Mapping.ReadOnly, memberSource, targetSource);
                    }
                    else {
                        if (typed) {
                            writer.WriteLine("try {");
                            writer.Indent++;
                            WriteSourceBeginTyped(memberSource, member.Mapping.TypeDesc);
                        }
                        else
                            WriteSourceBegin(memberSource);
                        writer.Write(targetSource);
                        WriteSourceEnd(memberSource);
                        writer.WriteLine(";");
                        if (typed) {
                            WriteCatchCastException(member.Mapping.TypeDesc, targetSource);
                        }
                    }
                    writer.Indent--;
                    writer.WriteLine("}");
                }
            }
            writer.Indent--;
            writer.WriteLine("}");
        }

        void WriteAddCollectionFixup(TypeDesc typeDesc, bool readOnly, string memberSource, string targetSource) {
            writer.WriteLine("// get array of the collection items");
            CreateCollectionInfo create = (CreateCollectionInfo)createMethods[typeDesc];
            if (create == null) {
                string createName = "create" + (++nextCreateMethodNumber).ToString() + "_" + typeDesc.Name;
                create = new CreateCollectionInfo(createName, typeDesc);
                createMethods.Add(typeDesc, create);
            }

            writer.Write("if ((object)(");
            writer.Write(memberSource);
            writer.WriteLine(") == null) {");
            writer.Indent++;

            if (readOnly) {
                writer.Write("throw CreateReadOnlyCollectionException(");
                WriteQuotedCSharpString(typeDesc.FullName);
                writer.WriteLine(");");
            }
            else {
                writer.Write(memberSource);
                writer.Write(" = new ");
                writer.Write(CodeIdentifier.EscapeKeywords(typeDesc.FullName));
                writer.WriteLine("();");
            }

            writer.Indent--;
            writer.WriteLine("}");
        
            writer.Write("CollectionFixup collectionFixup = new CollectionFixup(");
            writer.Write(memberSource);
            writer.Write(", ");
            writer.Write("new ");
            writer.Write(typeof(XmlSerializationCollectionFixupCallback).FullName);
            writer.Write("(this.");
            writer.Write(create.Name);
            writer.Write("), ");
            writer.Write(targetSource);
            writer.WriteLine(");");
            writer.WriteLine("AddFixup(collectionFixup);");
        }

        void WriteCreateCollectionMethod(CreateCollectionInfo c) {
            writer.Write("void ");
            writer.Write(c.Name);
            writer.WriteLine("(object collection, object collectionItems) {");
            writer.Indent++;

            writer.WriteLine("if (collectionItems == null) return;");
            writer.WriteLine("if (collection == null) return;");

            TypeDesc td = c.TypeDesc;
            string fullTypeName = CodeIdentifier.EscapeKeywords(td.FullName);

            writer.Write(fullTypeName);
            writer.Write(" c = (");
            writer.Write(fullTypeName);
            writer.WriteLine(")collection;");

            WriteCreateCollection(td, "collectionItems");

            writer.Indent--;
            writer.WriteLine("}");
        }

        void WriteQNameEqual(string source, string name, string ns) {
            writer.Write("((object) ((");
            writer.Write(typeof(XmlQualifiedName).FullName);
            writer.Write(")");
            writer.Write(source);
            writer.Write(").Name == (object)");
            WriteID(name);
            writer.Write(" && (object) ((");
            writer.Write(typeof(XmlQualifiedName).FullName);
            writer.Write(")");
            writer.Write(source);
            writer.Write(").Namespace == (object)");
            WriteID(ns);
            writer.Write(")");
        }

        void WriteXmlNodeEqual(string source, string name, string ns) {
            writer.Write("((object) ");
            writer.Write(source);
            writer.Write(".LocalName == (object)");
            WriteID(name);
            writer.Write(" && (object) ");
            writer.Write(source);
            writer.Write(".NamespaceURI == (object)");
            WriteID(ns);
            writer.Write(")");
        }

        void WriteID(string name) {
            if (name == null) {
                //writer.Write("null");
                //return;
                name = "";
            }
            string idName = (string)idNames[name];
            if (idName == null) {
                idName = NextIdName(name);
                idNames.Add(name, idName);
            }
            writer.Write(idName);
        }

        void WriteAttributes(Member[] members, Member anyAttribute, string attrElse) {
            int count = 0;
            Member xmlnsMember = null;
            
            for (int i = 0; i < members.Length; i++) {
                Member member = (Member)members[i];
                if (member.Mapping.Xmlns != null) {
                    xmlnsMember = member;
                    continue;
                }
                if (member.Mapping.Ignore)
                    continue;
                AttributeAccessor attribute = member.Mapping.Attribute;

                if (attribute == null) continue;
                if (attribute.Any) continue;

                if (count++ > 0)
                    writer.Write("else ");

                writer.Write("if (");
                if (member.ParamsReadSource != null) {
                    writer.Write("!");
                    writer.Write(member.ParamsReadSource);
                    writer.Write(" && ");
                }

                if (attribute.IsSpecialXmlNamespace) {
                    WriteXmlNodeEqual("Reader", attribute.Name, XmlReservedNs.NsXml);
                }
                else
                    WriteXmlNodeEqual("Reader", attribute.Name, attribute.Form == XmlSchemaForm.Qualified ? attribute.Namespace : "");
                writer.WriteLine(") {");
                writer.Indent++;

                WriteAttribute(member);

                if (member.Mapping.CheckSpecified) { 
                    writer.Write(member.CheckSpecifiedSource);
                    writer.WriteLine(" = true;");
                }
                writer.Indent--;
                writer.WriteLine("}");
            }

            if (count > 0)
                writer.Write("else ");

            if (xmlnsMember != null) {
                writer.WriteLine("if (IsXmlnsAttribute(Reader.Name)) {");
                writer.Indent++;

                writer.Write("if (");
                writer.Write(xmlnsMember.Source);
                writer.Write(" == null) ");
                writer.Write(xmlnsMember.Source);
                writer.Write(" = new ");
                writer.Write(CodeIdentifier.EscapeKeywords(xmlnsMember.Mapping.TypeDesc.FullName));
                writer.WriteLine("();");

                writer.Write(xmlnsMember.ArraySource);
                writer.WriteLine(".Add(Reader.Name.Length == 5 ? \"\" : Reader.LocalName, Reader.Value);");

                writer.Indent--;
                writer.WriteLine("}");

                writer.WriteLine("else {");
                writer.Indent++;
            }
            else {
                writer.WriteLine("if (!IsXmlnsAttribute(Reader.Name)) {");
                writer.Indent++;
            }
            if (anyAttribute != null) {
                writer.Write(typeof(XmlAttribute).FullName);
                writer.Write(" attr = ");
                writer.Write("(");
                writer.Write(typeof(XmlAttribute).FullName);
                writer.WriteLine(") Document.ReadNode(Reader);");
                writer.WriteLine("ParseWsdlArrayType(attr);");
                WriteAttribute(anyAttribute);
            }
            else {
                writer.WriteLine(attrElse);
            }
            writer.Indent--;
            writer.WriteLine("}");
        }

        void WriteAttribute(Member member) {

            AttributeAccessor attribute = member.Mapping.Attribute;

            if (attribute.Mapping is SpecialMapping) {
                SpecialMapping special = (SpecialMapping)attribute.Mapping;
                    
                if (special.TypeDesc.Kind == TypeKind.Attribute) {
                    WriteSourceBegin(member.ArraySource);
                    writer.Write("attr");
                    WriteSourceEnd(member.ArraySource);
                    writer.WriteLine(";");
                }
                else if (special.TypeDesc.CanBeAttributeValue) {
                    writer.Write("if (attr is ");
                    writer.Write(typeof(XmlAttribute).FullName);
                    writer.WriteLine(") {");
                    writer.Indent++;
                    WriteSourceBegin(member.ArraySource);
                    writer.Write("(");
                    writer.Write(typeof(XmlAttribute).FullName);
                    writer.Write(")attr");
                    WriteSourceEnd(member.ArraySource);
                    writer.WriteLine(";");
                    writer.Indent--;
                    writer.WriteLine("}");
                }
                else
                    throw new InvalidOperationException(Res.GetString(Res.XmlInternalError));
            }
            else {
                if (attribute.IsList) {
                    writer.WriteLine("string listValues = Reader.Value;");
                    writer.WriteLine("string[] vals = listValues.Split(null);");
                    writer.WriteLine("for (int i = 0; i < vals.Length; i++) {");
                    writer.Indent++;

                    string attributeSource = GetArraySource(member.Mapping.TypeDesc, member.ArrayName);

                    WriteSourceBegin(attributeSource);
                    WritePrimitive(attribute.Mapping, "vals[i]");
                    WriteSourceEnd(attributeSource);
                    writer.WriteLine(";");
                    writer.Indent--;
                    writer.WriteLine("}");
                }
                else {
                    WriteSourceBegin(member.ArraySource);
                    WritePrimitive(attribute.Mapping, attribute.IsList ? "vals[i]" : "Reader.Value");
                    WriteSourceEnd(member.ArraySource);
                    writer.WriteLine(";");

                }
            }
            if (member.ParamsReadSource != null) {
                writer.Write(member.ParamsReadSource);
                writer.WriteLine(" = true;");
            }
        }

        bool WriteMemberFixupBegin(Member[] members, string fixupMethodName, string source) {
            int fixupCount = 0;
            for (int i = 0; i < members.Length; i++) {
                Member member = (Member)members[i];
                if (member.Mapping.Elements.Length == 0)
                    continue;

                TypeMapping mapping = member.Mapping.Elements[0].Mapping;
                if (mapping is StructMapping || mapping is ArrayMapping || mapping is PrimitiveMapping) {
                    member.MultiRef = true;
                    member.FixupIndex = fixupCount++;
                }
            }

            if (fixupCount > 0) {
                writer.Write("Fixup fixup = new Fixup(");
                writer.Write(source);
                writer.Write(", ");
                writer.Write("new ");
                writer.Write(typeof(XmlSerializationFixupCallback).FullName);
                writer.Write("(this.");
                writer.Write(fixupMethodName);
                writer.Write("), ");
                writer.Write(fixupCount.ToString());
                writer.WriteLine(");");
                writer.WriteLine("AddFixup(fixup);");
                return true;
            }
            return false;
        }

        void WriteMemberBegin(Member[] members) {

            for (int i = 0; i < members.Length; i++) {
                Member member = (Member)members[i];

                if (member.IsArrayLike) {
                    string a = member.ArrayName;
                    string c = "c" + a;

                    TypeDesc typeDesc = member.Mapping.TypeDesc;
                    string typeDescFullName = CodeIdentifier.EscapeKeywords(typeDesc.FullName);
                
                    if (member.Mapping.TypeDesc.IsArray) {

                        writer.Write(CodeIdentifier.EscapeKeywords(typeDesc.ArrayElementTypeDesc.FullName));
                        writer.Write("[] ");
                        writer.Write(a);
                        writer.WriteLine(" = null;");
                        writer.Write("int ");
                        writer.Write(c);
                        writer.WriteLine(" = 0;");

                        if (member.Mapping.ChoiceIdentifier != null) {
                            writer.Write(CodeIdentifier.EscapeKeywords(member.Mapping.ChoiceIdentifier.Mapping.TypeDesc.FullName));
                            writer.Write("[] ");
                            writer.Write(member.ChoiceArrayName);
                            writer.WriteLine(" = null;");
                            writer.Write("int ");
                            writer.Write("c" + member.ChoiceArrayName);
                            writer.WriteLine(" = 0;");

                        }
                    }
                    else {
                        if (member.Source[member.Source.Length - 1] == '(') {
                            writer.Write(typeDescFullName);
                            writer.Write(" ");
                            writer.Write(a);

                            writer.Write(" = new ");
                            writer.Write(typeDescFullName);
                            writer.WriteLine("();");

                            writer.Write(member.Source);
                            writer.Write(a);
                            writer.WriteLine(");");
                        }
                        else {
                            if (member.IsList && !member.Mapping.ReadOnly && member.Mapping.TypeDesc.IsNullable) {
                                // we need to new the Collections and ArrayLists
                                writer.Write("if ((object)(");
                                writer.Write(member.Source);
                                writer.Write(") == null) ");
                                writer.Write(member.Source);
                                writer.Write(" = new ");
                                writer.Write(typeDescFullName);
                                writer.WriteLine("();");
                            }

                            writer.Write(typeDescFullName);
                            writer.Write(" ");
                            writer.Write(a);
                            writer.Write(" = (");
                            writer.Write(typeDescFullName);
                            writer.Write(")");
                            writer.Write(member.Source);
                            writer.WriteLine(";");
                        }
                    }
                }
            }
        }

        void WriteMemberElements(Member[] members, string elementElseString, string elseString, Member anyElement, Member anyText, string checkTypeHrefsSource) {
            bool checkType = (checkTypeHrefsSource != null && checkTypeHrefsSource.Length > 0);

            if (anyText != null) {
                writer.WriteLine("string t = null;");
            }

            writer.Write("if (Reader.NodeType == ");
            writer.Write(typeof(XmlNodeType).FullName);
            writer.WriteLine(".Element) {");
            writer.Indent++;

            if (checkType) {
                WriteIfNotSoapRoot(elementElseString + " continue;");

                WriteMemberElementsCheckType(checkTypeHrefsSource);
            }
            else {
                WriteMemberElementsIf(members, anyElement, elementElseString, null);
            }

            writer.Indent--;
            writer.WriteLine("}");

            if (anyText != null)
                WriteMemberText(anyText, elseString);

            writer.WriteLine("else {");
            writer.Indent++;
            writer.WriteLine(elseString);
            writer.Indent--;
            writer.WriteLine("}");
        }

        void WriteMemberText(Member anyText, string elseString) {
            writer.Write("else if (Reader.NodeType == ");
            writer.Write(typeof(XmlNodeType).FullName);
            writer.WriteLine(".Text || ");
            writer.Write("Reader.NodeType == ");
            writer.Write(typeof(XmlNodeType).FullName);
            writer.WriteLine(".CDATA || ");
            writer.Write("Reader.NodeType == ");
            writer.Write(typeof(XmlNodeType).FullName);
            writer.WriteLine(".Whitespace || ");
            writer.Write("Reader.NodeType == ");
            writer.Write(typeof(XmlNodeType).FullName);
            writer.WriteLine(".SignificantWhitespace) {");
            writer.Indent++;

            if (anyText != null) {
                WriteText(anyText);
            }
            else {
                writer.Write(elseString);
                writer.WriteLine(";");
            }
            writer.Indent--;
            writer.WriteLine("}");
        }

        void WriteText(Member member) {

            TextAccessor text = member.Mapping.Text;

            if (text.Mapping is SpecialMapping) {
                SpecialMapping special = (SpecialMapping)text.Mapping;
                WriteSourceBeginTyped(member.ArraySource, special.TypeDesc);
                switch (special.TypeDesc.Kind) {
                    case TypeKind.Node:
                        writer.Write("Document.CreateTextNode(Reader.ReadString())");
                        break;
                    default:
                        throw new InvalidOperationException(Res.GetString(Res.XmlInternalError));
                }
                WriteSourceEnd(member.ArraySource);
            }
            else {
                if (member.IsArrayLike) {
                    WriteSourceBegin(member.ArraySource);
                    writer.Write("Reader.ReadString()");
                }
                else {
                    if (text.Mapping.TypeDesc == stringTypeDesc || text.Mapping.TypeDesc.FormatterName == "String") {
                        writer.WriteLine("t = ReadString(t);");
                        WriteSourceBegin(member.ArraySource);
                        writer.Write("t");
                    }
                    else {
                        WriteSourceBegin(member.ArraySource);
                        WritePrimitive(text.Mapping, "Reader.ReadString()");
                    }
                }
                WriteSourceEnd(member.ArraySource);
            }

            writer.WriteLine(";");
        }

        void WriteMemberElementsCheckType(string checkTypeHrefsSource) {
            writer.WriteLine("string refElemId = null;");
            writer.WriteLine("object refElem = ReadReferencingElement(null, null, true, out refElemId);");
            
            writer.WriteLine("if (refElemId != null) {");
            writer.Indent++;
            writer.Write(checkTypeHrefsSource);
            writer.WriteLine(".Add(refElemId);");
            writer.Write(checkTypeHrefsSource);
            writer.WriteLine("IsObject.Add(false);");
            writer.Indent--;
            writer.WriteLine("}");
            writer.WriteLine("else if (refElem != null) {");
            writer.Indent++;
            writer.Write(checkTypeHrefsSource);
            writer.WriteLine(".Add(refElem);");
            writer.Write(checkTypeHrefsSource);
            writer.WriteLine("IsObject.Add(true);");
            writer.Indent--;
            writer.WriteLine("}");
        }

        void WriteMemberElementsElse(Member anyElement, string elementElseString) {
            if (anyElement != null) {
                ElementAccessor[] elements = anyElement.Mapping.Elements;
                for (int i = 0; i < elements.Length; i++) {
                    ElementAccessor element = elements[i];
                    if (element.Any && element.Name.Length == 0) {
                        WriteElement(anyElement.ArraySource, anyElement.ArrayName, anyElement.ChoiceArraySource, element, anyElement.Mapping.ChoiceIdentifier, null, false, false, -1, i);
                        break;
                    }
                }
            }
            else {
                writer.WriteLine(elementElseString);
            }
        }

        void WriteMemberElementsIf(Member[] members, Member anyElement, string elementElseString, string checkTypeSource) {
            bool checkType = checkTypeSource != null && checkTypeSource.Length > 0;
            //int count = checkType ? 1 : 0;
            int count = 0;

            for (int i = 0; i < members.Length; i++) {
                Member member = (Member)members[i];
                if (member.Mapping.Xmlns != null)
                    continue;
                if (member.Mapping.Ignore)
                    continue;
                ChoiceIdentifierAccessor choice = member.Mapping.ChoiceIdentifier;
                ElementAccessor[] elements = member.Mapping.Elements;
                for (int j = 0; j < elements.Length; j++) {
                    ElementAccessor e = elements[j];
                    string ns = e.Form == XmlSchemaForm.Qualified ? e.Namespace : "";
                    if (e.Any && (e.Name == null || e.Name.Length == 0)) continue;
                    if (count++ > 0)
                        writer.Write("else ");
                    writer.Write("if (");
                    if (member.ParamsReadSource != null) {
                        writer.Write("!");
                        writer.Write(member.ParamsReadSource);
                        writer.Write(" && ");
                    }
                    if (checkType) {
                        writer.Write("typeof(");
                        writer.Write(CodeIdentifier.EscapeKeywords(e.Mapping.TypeDesc.FullName));
                        writer.Write(").IsAssignableFrom(");
                        writer.Write(checkTypeSource);
                        writer.Write("Type)");
                    }
                    else {
                        if (e.IsSoap && member.Mapping.IsReturnValue)
                            writer.Write("(IsReturnValue || ");
                        WriteXmlNodeEqual("Reader", e.Name, ns);
                        if (e.IsSoap && member.Mapping.IsReturnValue)
                            writer.Write(")");
                    }
                    writer.WriteLine(") {");
                    writer.Indent++;
                    if (checkType) {
                        if (e.Mapping.TypeDesc.IsValueType) {
                            writer.Write("if (");
                            writer.Write(checkTypeSource);
                            writer.WriteLine(" != null) {");
                            writer.Indent++;
                        }
                        WriteSourceBeginTyped(member.ArraySource, e.Mapping.TypeDesc);
                        writer.Write(checkTypeSource);
                        WriteSourceEnd(member.ArraySource);
                        writer.WriteLine(";");
                        if (e.Mapping.TypeDesc.IsValueType) {
                            writer.Indent--;
                            writer.WriteLine("}");
                        }
                        if (member.FixupIndex >= 0) {
                            writer.Write("fixup.Ids[");
                            writer.Write(member.FixupIndex.ToString());
                            writer.Write("] = ");
                            writer.Write(checkTypeSource);
                            writer.WriteLine("Id;");
                        }
                    }
                    else {
                        WriteElement(member.ArraySource, member.ArrayName, member.ChoiceArraySource, e, choice, member.Mapping.CheckSpecified ? member.CheckSpecifiedSource : null, member.IsList && member.Mapping.TypeDesc.IsNullable, member.Mapping.ReadOnly, member.FixupIndex, j);
                    }
                    if (e.IsSoap && member.Mapping.IsReturnValue)
                        writer.WriteLine("IsReturnValue = false;");
                    if (member.Mapping.CheckSpecified) { 
                        writer.Write(member.CheckSpecifiedSource);
                        writer.WriteLine(" = true;");
                    }
                    if (member.ParamsReadSource != null) {
                        writer.Write(member.ParamsReadSource);
                        writer.WriteLine(" = true;");
                    }
                    writer.Indent--;
                    writer.WriteLine("}");
                }
            }

            if (count > 0) {
                writer.WriteLine("else {");
                writer.Indent++;
            }

            WriteMemberElementsElse(anyElement, elementElseString);

            if (count > 0) {
                writer.Indent--;
                writer.WriteLine("}");
            }
        }

        static string GetArraySource(TypeDesc typeDesc, string arrayName) {
            return GetArraySource(typeDesc, arrayName, false);
        }
        static string GetArraySource(TypeDesc typeDesc, string arrayName, bool multiRef) {
            string a = arrayName;
            string c = "c" + a;
            string init = "";

            if (multiRef) {
                init = "soap = (System.Object[])EnsureArrayIndex(soap, " + c + "+2, typeof(System.Object)); ";
            }
            if (typeDesc.IsArray) {
                string arrayTypeFullName = CodeIdentifier.EscapeKeywords(typeDesc.ArrayElementTypeDesc.FullName);
                init = init + a + " = (" + arrayTypeFullName + 
                    "[])EnsureArrayIndex(" + a + ", " + c + ", typeof(" + arrayTypeFullName + "));";
                if (multiRef) {
                    init = init + " soap[1] = " + a + ";";
                    init = init + " if (ReadReference(out soap[" + c + "+2])) " + a + "[" + c + "++] = null; else ";
                }
                return init + a + "[" + c + "++]";
            }
            else {
                return arrayName + ".Add(";
            }
        }

        void WriteMemberEnd(Member[] members) {
            WriteMemberEnd(members, false);
        }

        void WriteMemberEnd(Member[] members, bool soapRefs) {
            for (int i = 0; i < members.Length; i++) {
                Member member = (Member)members[i];

                if (member.IsArrayLike) {

                    TypeDesc typeDesc = member.Mapping.TypeDesc;

                    if (typeDesc.IsArray) {

                        WriteSourceBegin(member.Source);

                        if (soapRefs)
                            writer.Write(" soap[1] = ");

                        string a = member.ArrayName;
                        string c = "c" + a;
                        
                        writer.Write("(");
                        string arrayTypeFullName = CodeIdentifier.EscapeKeywords(typeDesc.ArrayElementTypeDesc.FullName);
                        writer.Write(arrayTypeFullName);
                        writer.Write("[])ShrinkArray(");
                        writer.Write(a);
                        writer.Write(", ");
                        writer.Write(c);
                        writer.Write(", typeof(");
                        writer.Write(arrayTypeFullName);
                        writer.Write("), ");
                        WriteBooleanValue(member.IsNullable);
                        writer.Write(")");
                        WriteSourceEnd(member.Source);
                        writer.WriteLine(";");

                        if (member.Mapping.ChoiceIdentifier != null) {
                            WriteSourceBegin(member.ChoiceSource);
                            a = member.ChoiceArrayName;
                            c = "c" + a;
                        
                            writer.Write("(");
                            string choiceTypeName = CodeIdentifier.EscapeKeywords(member.Mapping.ChoiceIdentifier.Mapping.TypeDesc.FullName);
                            writer.Write(choiceTypeName);
                            writer.Write("[])ShrinkArray(");
                            writer.Write(a);
                            writer.Write(", ");
                            writer.Write(c);
                            writer.Write(", typeof(");
                            writer.Write(choiceTypeName);
                            writer.Write("), ");
                            WriteBooleanValue(member.IsNullable);
                            writer.Write(")");
                            WriteSourceEnd(member.ChoiceSource);
                            writer.WriteLine(";");
                        }

                    }
                    else if (typeDesc.IsValueType) {
                        writer.Write(member.Source);
                        writer.Write(" = ");
                        writer.Write(member.ArrayName);
                        writer.WriteLine(";");
                    }
                }
            }
        }

        void WriteSourceBeginTyped(string source, TypeDesc typeDesc) {
            WriteSourceBegin(source);
            if (typeDesc != null) {
                writer.Write("(");
                writer.Write(CodeIdentifier.EscapeKeywords(typeDesc.FullName));
                writer.Write(")");
            }
        }

        void WriteSourceBegin(string source) {
            writer.Write(source);
            if (source[source.Length - 1] != '(')
                writer.Write(" = ");
        }
        
        void WriteSourceEnd(string source) {
            if (source[source.Length - 1] == '(')
                writer.Write(")");
        }

        void WriteArray(string source, string arrayName, ArrayMapping arrayMapping, bool readOnly, bool isNullable, int fixupIndex) {
            if (arrayMapping.IsSoap) {
                writer.Write("object rre = ");
                writer.Write(fixupIndex >= 0 ? "ReadReferencingElement" : "ReadReferencedElement");
                writer.Write("(");
                WriteID(arrayMapping.TypeName);
                writer.Write(", ");
                WriteID(arrayMapping.Namespace);
                if (fixupIndex >= 0) {
                    writer.Write(", ");
                    writer.Write("out fixup.Ids[");
                    writer.Write((fixupIndex).ToString());
                    writer.Write("]");
                }
                writer.WriteLine(");");

                TypeDesc td = arrayMapping.TypeDesc;
                if (td.IsEnumerable || td.IsCollection) {
                    writer.WriteLine("if (rre != null) {");
                    writer.Indent++;
                    WriteAddCollectionFixup(td, readOnly, source, "rre");
                    writer.Indent--;
                    writer.WriteLine("}");
                }
                else {
                    writer.WriteLine("try {");
                    writer.Indent++;
                    WriteSourceBeginTyped(source, arrayMapping.TypeDesc);
                    writer.Write("rre");
                    WriteSourceEnd(source);
                    writer.WriteLine(";");
                    WriteCatchCastException(arrayMapping.TypeDesc, "rre");
                }
            }
            else {
                writer.WriteLine("if (!ReadNull()) {");
                writer.Indent++;
                MemberMapping memberMapping = new MemberMapping();
                memberMapping.Elements = arrayMapping.Elements;
                memberMapping.TypeDesc = arrayMapping.TypeDesc;
                memberMapping.ReadOnly = readOnly;
                Member member = new Member(source, arrayName, 0, memberMapping, false);
                member.IsNullable = false;//Note, sowmys: IsNullable is set to false since null condition (xsi:nil) is already handled by 'ReadNull()'

                Member[] members = new Member[] { member };
                
                WriteMemberBegin(members);
                writer.WriteLine("if (Reader.IsEmptyElement) {");
                writer.Indent++;
                writer.WriteLine("Reader.Skip();");
                writer.Indent--;
                writer.WriteLine("}");
                writer.WriteLine("else {");
                writer.Indent++;

                writer.WriteLine("Reader.ReadStartElement();");
                WriteWhileNotEndTag();
                writer.Indent++;

                WriteMemberElements(members, "UnknownNode(null);", "UnknownNode(null);", null, null, null);
                writer.WriteLine("Reader.MoveToContent();");

                writer.Indent--;
                writer.WriteLine("}");
                writer.Indent--;
                writer.WriteLine("ReadEndElement();");
                writer.WriteLine("}");

                WriteMemberEnd(members, false);
                writer.Indent--;
                writer.WriteLine("}");
                if (isNullable) {
                    writer.WriteLine("else {");
                    writer.Indent++;
                    member.IsNullable = true;
                    WriteMemberBegin(members);
                    WriteMemberEnd(members);
                    writer.Indent--;
                    writer.WriteLine("}");
                }
            }
        }
        
        void WriteElement(string source, string arrayName, string choiceSource, ElementAccessor element, ChoiceIdentifierAccessor choice, string checkSpecified, bool checkForNull, bool readOnly, int fixupIndex, int elementIndex) {
            if (element.Mapping is ArrayMapping)
                WriteArray(source, arrayName, (ArrayMapping)element.Mapping, readOnly, element.IsNullable, fixupIndex);
            else if (!element.Mapping.IsSoap && (element.Mapping is PrimitiveMapping)) {
                WriteSourceBegin(source);
                if (element.Mapping.TypeDesc == qnameTypeDesc)
                    writer.Write(element.IsNullable || element.Mapping.IsSoap ? "ReadNullableQualifiedName()" : "ReadElementQualifiedName()");
                else {
                    string readFunc; 
                    switch(((TypeMapping)element.Mapping).TypeDesc.FormatterName) {
                    case "ByteArrayBase64":
                    case "ByteArrayHex":    readFunc = element.IsNullable || element.Mapping.IsSoap? "ReadNull()":"false";
                                            break;
                    default:                readFunc = element.IsNullable || element.Mapping.IsSoap ? "ReadNullableString()" : "Reader.ReadElementString()";
                                            break;
                    }
                    WritePrimitive((TypeMapping)element.Mapping, readFunc);
                }

                WriteSourceEnd(source);
                writer.WriteLine(";");
                if (checkSpecified != null && checkSpecified.Length > 0) {
                    writer.Write(checkSpecified);
                    writer.WriteLine(" = true;");
                }
            }
            else if (element.Mapping is StructMapping || (element.Mapping.IsSoap && element.Mapping is PrimitiveMapping)) {
                TypeMapping mapping = element.Mapping;
                if (mapping.IsSoap) {
                    writer.Write("object rre = ");
                    writer.Write(fixupIndex >= 0 ? "ReadReferencingElement" : "ReadReferencedElement");
                    writer.Write("(");
                    WriteID(mapping.TypeName);
                    writer.Write(", ");
                    WriteID(mapping.Namespace);

                    if (fixupIndex >= 0) {
                        writer.Write(", out fixup.Ids[");
                        writer.Write((fixupIndex).ToString());
                        writer.Write("]");
                    }
                    writer.Write(")");
                    WriteSourceEnd(source);
                    writer.WriteLine(";");

                    if (mapping.TypeDesc.IsValueType) {
                        writer.WriteLine("if (rre != null) {");
                        writer.Indent++;
                    }

                    writer.WriteLine("try {");
                    writer.Indent++;
                    WriteSourceBeginTyped(source, mapping.TypeDesc);
                    writer.WriteLine("rre;");
                    WriteCatchCastException(mapping.TypeDesc, "rre");
                    writer.Write("Referenced(");
                    writer.Write(source);
                    writer.WriteLine(");");

                    if (mapping.TypeDesc.IsValueType) {
                        writer.Indent--;
                        writer.WriteLine("}");
                    }
                }
                else {

                    string methodName = (string)methodNames[mapping];
                    #if DEBUG
                        // use exception in the place of Debug.Assert to avoid throwing asserts from a server process such as aspnet_ewp.exe
                        if (methodName == null) throw new InvalidOperationException(Res.GetString(Res.XmlInternalErrorMethod, mapping.TypeDesc.Name));
                    #endif

                    if (checkForNull) {
                        writer.Write("if ((object)(");
                        writer.Write(arrayName);
                        writer.Write(") == null) Reader.Skip(); else ");
                    }
                    WriteSourceBegin(source);
                    writer.Write(methodName);
                    writer.Write("(");
                    if (mapping.TypeDesc.IsNullable) {
                        WriteBooleanValue(element.IsNullable);
                        writer.Write(", ");
                    }
                    writer.Write("true");
                    writer.Write(")");
                    WriteSourceEnd(source);
                    writer.WriteLine(";");
                }
            }
            else if (element.Mapping is SpecialMapping) {
                SpecialMapping special = (SpecialMapping)element.Mapping;
                bool isDoc = special.TypeDesc.FullName == typeof(XmlDocument).FullName;
                WriteSourceBeginTyped(source, special.TypeDesc);
                switch (special.TypeDesc.Kind) {
                    case TypeKind.Node:
                        writer.Write(isDoc ? "ReadXmlDocument(" : "ReadXmlNode(");
                        writer.Write(element.Any ? "false" : "true");
                        writer.Write(")");
                        break;
                    case TypeKind.Serializable:
                        writer.Write("ReadSerializable(new ");
                        writer.Write(CodeIdentifier.EscapeKeywords(special.TypeDesc.FullName));
                        writer.Write("())");
                        break;
                    default:
                        throw new InvalidOperationException(Res.GetString(Res.XmlInternalError));
                }
                WriteSourceEnd(source);
                writer.WriteLine(";");
            }
            else {
                throw new InvalidOperationException(Res.GetString(Res.XmlInternalError));
            }
            if (choice != null) {
                #if DEBUG
                    // use exception in the place of Debug.Assert to avoid throwing asserts from a server process such as aspnet_ewp.exe
                    if (choiceSource == null) throw new InvalidOperationException(Res.GetString(Res.XmlInternalErrorDetails, "need parent for the " + source));
                #endif

                string enumTypeName = CodeIdentifier.EscapeKeywords(choice.Mapping.TypeDesc.FullName);
                writer.Write(choiceSource);
                writer.Write(" = ");
                writer.Write(enumTypeName);
                writer.Write(".@");
                CodeIdentifier.CheckValidIdentifier(choice.MemberIds[elementIndex]);
                writer.Write(choice.MemberIds[elementIndex]);
                writer.WriteLine(";");
            }
        }

        void WriteWhileNotEndTag() {
            writer.WriteLine("Reader.MoveToContent();");
            writer.Write("while (Reader.NodeType != ");
            writer.Write(typeof(XmlNodeType).FullName);
            writer.WriteLine(".EndElement) {");
        }
        
        void WriteParamsRead(int length) {
            writer.Write("bool[] paramsRead = new bool[");
            writer.Write(length.ToString());
            writer.WriteLine("];");
        }
        
        void WriteWhileNotEnd() {
            writer.WriteLine("Reader.MoveToContent();");
            writer.Write("while (Reader.NodeType != ");
            writer.Write(typeof(XmlNodeType).FullName);
            writer.WriteLine(".EndElement) {");
        }

        void WriteReadNonRoots() {
            writer.WriteLine("Reader.MoveToContent();");
            writer.Write("while (Reader.NodeType == ");
            writer.Write(typeof(XmlNodeType).FullName);
            writer.WriteLine(".Element) {");
            writer.Indent++;
            writer.Write(typeof(string).FullName);
            writer.Write(" root = Reader.GetAttribute(\"root\", \"");
            writer.Write(Soap.Encoding);
            writer.WriteLine("\");");
            writer.Write("if (root == null || ");
            writer.Write(typeof(XmlConvert).FullName);
            writer.WriteLine(".ToBoolean(root)) break;");
            writer.WriteLine("ReadReferencedElement();");
            writer.WriteLine("Reader.MoveToContent();");
            writer.Indent--;
            writer.WriteLine("}");
        }

        void WriteBooleanValue(bool value) {
            writer.Write(value ? "true" : "false");
        }

        void WriteInitCheckTypeHrefList(string source) {
            writer.Write(typeof(ArrayList).FullName);
            writer.Write(" ");
            writer.Write(source);
            writer.Write(" = new ");
            writer.Write(typeof(ArrayList).FullName);
            writer.WriteLine("();");

            writer.Write(typeof(ArrayList).FullName);
            writer.Write(" ");
            writer.Write(source);
            writer.Write("IsObject = new ");
            writer.Write(typeof(ArrayList).FullName);
            writer.WriteLine("();");
        }
        
        void WriteHandleHrefList(Member[] members, string listSource) {
            writer.WriteLine("int isObjectIndex = 0;");
            writer.Write("foreach (object obj in ");
            writer.Write(listSource);
            writer.WriteLine(") {");
            writer.Indent++;
            writer.WriteLine("bool isReferenced = true;");
            writer.Write("bool isObject = (bool)");
            writer.Write(listSource);
            writer.WriteLine("IsObject[isObjectIndex++];");
            writer.WriteLine("object refObj = isObject ? obj : GetTarget((string)obj);");
            writer.WriteLine("if (refObj == null) continue;");
            writer.Write(typeof(Type).FullName);
            writer.WriteLine(" refObjType = refObj.GetType();");
            writer.WriteLine("string refObjId = null;");

            WriteMemberElementsIf(members, null, "isReferenced = false;", "refObj");

            writer.WriteLine("if (isObject && isReferenced) Referenced(refObj); // need to mark this obj as ref'd since we didn't do GetTarget");
            writer.Indent--;
            writer.WriteLine("}");
        }

        void WriteIfNotSoapRoot(string source) {
            writer.Write("if (Reader.GetAttribute(\"root\", \"");
            writer.Write(Soap.Encoding);
            writer.WriteLine("\") == \"0\") {");
            writer.Indent++;
            writer.WriteLine(source);
            writer.Indent--;
            writer.WriteLine("}");
        }

        void WriteCreateStruct(StructMapping structMapping) {
            string fullTypeName = CodeIdentifier.EscapeKeywords(structMapping.TypeDesc.FullName);

            if (structMapping.TypeDesc.HasDefaultConstructor && !structMapping.TypeDesc.ConstructorHasSecurity) {
                writer.Write(fullTypeName);
                writer.Write(" o = new ");
                writer.Write(fullTypeName);
                writer.WriteLine("();");
            }
            else {
                writer.Write(fullTypeName);
                writer.WriteLine(" o;");
                writer.WriteLine("try {");
                writer.Indent++;

                writer.Write("o = (");
                writer.Write(fullTypeName);
                writer.Write(")");
                writer.Write(typeof(Activator).FullName);
                writer.Write(".CreateInstance(typeof(");
                writer.Write(fullTypeName);
                writer.WriteLine("));");

                WriteCatchException(typeof(MissingMethodException));
                writer.Indent++;

                writer.Write("throw CreateInaccessibleConstructorException(");
                WriteQuotedCSharpString(structMapping.TypeName);
                writer.WriteLine(");");

                WriteCatchException(typeof(SecurityException));
                writer.Indent++;

                writer.Write("throw CreateCtorHasSecurityException(");
                WriteQuotedCSharpString(structMapping.TypeName);
                writer.WriteLine(");");

                writer.Indent--;
                writer.WriteLine("}");
            }
        }

        void WriteCatchException(Type exceptionType) {
            writer.Indent--;
            writer.WriteLine("}");
            writer.Write("catch (");
            writer.Write(exceptionType.FullName);
            writer.WriteLine(") {");
        }

        void WriteCatchCastException(TypeDesc typeDesc, string source) {
            WriteCatchException(typeof(InvalidCastException));
            writer.Indent++;
            writer.Write("throw CreateInvalidCastException(typeof(");
            writer.Write(typeDesc.FullName);
            writer.Write("), ");
            writer.Write(source);
            writer.WriteLine(");");
            writer.Indent--;
            writer.WriteLine("}");
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\serialization\_events.cs ===
//------------------------------------------------------------------------------
// <copyright file="_Events.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Serialization {

    using System.IO;
    using System;
    using System.Collections;
    using System.ComponentModel;

    /// <include file='doc\_Events.uex' path='docs/doc[@for="XmlAttributeEventHandler"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public delegate void XmlAttributeEventHandler(object sender, XmlAttributeEventArgs e);

    /// <include file='doc\_Events.uex' path='docs/doc[@for="XmlAttributeEventArgs"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public class XmlAttributeEventArgs : EventArgs {
        object o;
        XmlAttribute attr;

        int lineNumber;
        int linePosition;
        

        internal XmlAttributeEventArgs(XmlAttribute attr, int lineNumber, int linePosition, object o) {
            this.attr = attr;
            this.o = o;
            this.lineNumber = lineNumber;
            this.linePosition = linePosition;
        }
        

        /// <include file='doc\_Events.uex' path='docs/doc[@for="XmlAttributeEventArgs.ObjectBeingDeserialized"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public object ObjectBeingDeserialized {
            get { return o; }
        }

        /// <include file='doc\_Events.uex' path='docs/doc[@for="XmlAttributeEventArgs.Attr"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public XmlAttribute Attr {
            get { return attr; }
        }

        /// <include file='doc\_Events.uex' path='docs/doc[@for="XmlAttributeEventArgs.LineNumber"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the current line number.
        ///    </para>
        /// </devdoc>
        public int LineNumber {
            get { return lineNumber; }
        }

        /// <include file='doc\_Events.uex' path='docs/doc[@for="XmlAttributeEventArgs.LinePosition"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the current line position.
        ///    </para>
        /// </devdoc>
        public int LinePosition {
            get { return linePosition; }
        }
    }

    /// <include file='doc\_Events.uex' path='docs/doc[@for="XmlElementEventHandler"]/*' />
    public delegate void XmlElementEventHandler(object sender, XmlElementEventArgs e);

    /// <include file='doc\_Events.uex' path='docs/doc[@for="XmlElementEventArgs"]/*' />
    public class XmlElementEventArgs : EventArgs {
        object o;
        XmlElement elem;
        int lineNumber;
        int linePosition;

        internal XmlElementEventArgs(XmlElement elem, int lineNumber, int linePosition, object o) {
            this.elem = elem;
            this.o = o;
            this.lineNumber = lineNumber;
            this.linePosition = linePosition;
        }
        
        /// <include file='doc\_Events.uex' path='docs/doc[@for="XmlElementEventArgs.ObjectBeingDeserialized"]/*' />
        public object ObjectBeingDeserialized {
            get { return o; }
        }

        /// <include file='doc\_Events.uex' path='docs/doc[@for="XmlElementEventArgs.Attr"]/*' />
        public XmlElement Element {
            get { return elem; }
        }

        /// <include file='doc\_Events.uex' path='docs/doc[@for="XmlElementEventArgs.LineNumber"]/*' />
        public int LineNumber {
            get { return lineNumber; }
        }

        /// <include file='doc\_Events.uex' path='docs/doc[@for="XmlElementEventArgs.LinePosition"]/*' />
        public int LinePosition {
            get { return linePosition; }
        }
    }

    /// <include file='doc\_Events.uex' path='docs/doc[@for="XmlNodeEventHandler"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public delegate void XmlNodeEventHandler(object sender, XmlNodeEventArgs e);

    /// <include file='doc\_Events.uex' path='docs/doc[@for="XmlNodeEventArgs"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public class XmlNodeEventArgs : EventArgs {
        object o;
        XmlNode xmlNode;
        int lineNumber;
        int linePosition;
        

        internal XmlNodeEventArgs(XmlNode xmlNode, int lineNumber, int linePosition, object o) {
            this.o = o;
            this.xmlNode = xmlNode;
            this.lineNumber = lineNumber;
            this.linePosition = linePosition;
        }

        internal XmlNode XmlNode {
            get { return xmlNode;}
        }

        /// <include file='doc\_Events.uex' path='docs/doc[@for="XmlNodeEventArgs.ObjectBeingDeserialized"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public object ObjectBeingDeserialized {
            get { return o; }
        }


        /// <include file='doc\_Events.uex' path='docs/doc[@for="XmlNodeEventArgs.NodeType"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public XmlNodeType NodeType {
            get { return xmlNode.NodeType; }
        }

        /// <include file='doc\_Events.uex' path='docs/doc[@for="XmlNodeEventArgs.Name"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public string Name {
            get { return xmlNode.Name; }
        }

        /// <include file='doc\_Events.uex' path='docs/doc[@for="XmlNodeEventArgs.LocalName"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public string LocalName {
            get { return xmlNode.LocalName; }
        }

        /// <include file='doc\_Events.uex' path='docs/doc[@for="XmlNodeEventArgs.NamespaceURI"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public string NamespaceURI {
            get { return xmlNode.NamespaceURI; }
        }

        /// <include file='doc\_Events.uex' path='docs/doc[@for="XmlNodeEventArgs.Text"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public string Text {
            get { return xmlNode.Value; }
        }

        /// <include file='doc\_Events.uex' path='docs/doc[@for="XmlNodeEventArgs.LineNumber"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the current line number.
        ///    </para>
        /// </devdoc>
        public int LineNumber {
            get { return lineNumber; }
        }

        /// <include file='doc\_Events.uex' path='docs/doc[@for="XmlNodeEventArgs.LinePosition"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the current line position.
        ///    </para>
        /// </devdoc>
        public int LinePosition {
            get { return linePosition; }
        }
    }

    /// <include file='doc\_Events.uex' path='docs/doc[@for="UnreferencedObjectEventHandler"]/*' />
    public delegate void UnreferencedObjectEventHandler(object sender, UnreferencedObjectEventArgs e);

    /// <include file='doc\_Events.uex' path='docs/doc[@for="UnreferencedObjectEventArgs"]/*' />
    public class UnreferencedObjectEventArgs : EventArgs {
        object o;
        string id;

        /// <include file='doc\_Events.uex' path='docs/doc[@for="UnreferencedObjectEventArgs.UnreferencedObjectEventArgs"]/*' />
        public UnreferencedObjectEventArgs(object o, string id) {
            this.o = o;
            this.id = id;
        }

        /// <include file='doc\_Events.uex' path='docs/doc[@for="UnreferencedObjectEventArgs.UnreferencedObject"]/*' />
        public object UnreferencedObject {
            get { return o; }
        }

        /// <include file='doc\_Events.uex' path='docs/doc[@for="UnreferencedObjectEventArgs.UnreferencedId"]/*' />
        public string UnreferencedId {
            get { return id; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\serialization\xmlserializationwriter.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlSerializationWriter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Serialization {

    using System;
    using System.IO;
    using System.Collections;
    using System.Reflection;
    using System.Xml.Schema;
    using System.ComponentModel;
    using System.Diagnostics;
    using System.CodeDom.Compiler;
    using System.Globalization;
    using System.Text;
    using System.Threading;
   
    /// <include file='doc\XmlSerializationWriter.uex' path='docs/doc[@for="XmlSerializationWriter"]/*' />
    ///<internalonly/>
    public abstract class XmlSerializationWriter {
        XmlWriter w;
        ArrayList namespaces;
        int tempNamespacePrefix;
        Hashtable usedPrefixes;
        Hashtable references;
        int nextId;
        Hashtable typeEntries;
        ArrayList referencesToWrite;
        Hashtable objectsInUse;
        string aliasBase = "q";
        string encodingStyle;
        bool soap12;
        TempAssembly tempAssembly;
        int threadCode;
        ResolveEventHandler assemblyResolver;

        // this method must be called before any generated serialization methods are called
        internal void Init(XmlWriter w, ArrayList namespaces, string encodingStyle, TempAssembly tempAssembly) {
            this.w = w;
            this.namespaces = namespaces;
            this.encodingStyle = encodingStyle;
            this.soap12 = (encodingStyle == Soap12.Encoding);
            this.tempAssembly = tempAssembly;
            // only hook the assembly resolver if we have something to help us do the resolution
            if (tempAssembly != null) {
                // we save the threadcode to make sure we don't handle any resolve events for any other threads
                threadCode = Thread.CurrentThread.GetHashCode();
                assemblyResolver = new ResolveEventHandler(OnAssemblyResolve);
                AppDomain.CurrentDomain.AssemblyResolve += assemblyResolver;
            }
        }

        // this method must be called at the end of serialization
        internal void Dispose() {
            if (assemblyResolver != null)
                AppDomain.CurrentDomain.AssemblyResolve -= assemblyResolver;
            assemblyResolver = null;
        }

        internal Assembly OnAssemblyResolve(object sender, ResolveEventArgs args) {
            if (tempAssembly != null && Thread.CurrentThread.GetHashCode() == threadCode)
                return tempAssembly.GetReferencedAssembly(args.Name);
            return null;
        }

        /// <include file='doc\XmlSerializationWriter.uex' path='docs/doc[@for="XmlSerializationWriter.Writer"]/*' />
        protected XmlWriter Writer {
            get {
                return w;
            }
            set {
                w = value;
            }
        }

        /// <include file='doc\XmlSerializationWriter.uex' path='docs/doc[@for="XmlSerializationWriter.Namespaces"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected ArrayList Namespaces {
            get {
                return namespaces;
            }
            set {
                namespaces = value;
            }
        }

        /// <include file='doc\XmlSerializationWriter.uex' path='docs/doc[@for="XmlSerializationWriter.FromByteArrayBase64"]/*' />
        protected static byte[] FromByteArrayBase64(byte[] value) {
        // Unlike other "From" functions that one is just a place holder for automatic code generation.
        // The reason is performance and memory consumption for (potentially) big 64base-encoded chunks
        // And it is assumed that the caller generates the code that will distinguish between byte[] and string return types
        //
             return value;
        }

        /// <include file='doc\XmlSerializationWriter.uex' path='docs/doc[@for="XmlSerializationWriter.FromByteArrayHex"]/*' />
        protected static string FromByteArrayHex(byte[] value) {
            return XmlCustomFormatter.FromByteArrayHex(value);
        }

        /// <include file='doc\XmlSerializationWriter.uex' path='docs/doc[@for="XmlSerializationWriter.FromDateTime"]/*' />
        protected static string FromDateTime(DateTime value) {
            return XmlCustomFormatter.FromDateTime(value);
        }

        /// <include file='doc\XmlSerializationWriter.uex' path='docs/doc[@for="XmlSerializationWriter.FromDate"]/*' />
        protected static string FromDate(DateTime value) {
            return XmlCustomFormatter.FromDate(value);
        }

        /// <include file='doc\XmlSerializationWriter.uex' path='docs/doc[@for="XmlSerializationWriter.FromTime"]/*' />
        protected static string FromTime(DateTime value) {
            return XmlCustomFormatter.FromTime(value);
        }

        /// <include file='doc\XmlSerializationWriter.uex' path='docs/doc[@for="XmlSerializationWriter.FromChar"]/*' />
        protected static string FromChar(char value) {
            return XmlCustomFormatter.FromChar(value);
        }

        /// <include file='doc\XmlSerializationWriter.uex' path='docs/doc[@for="XmlSerializationWriter.FromEnum"]/*' />
        protected static string FromEnum(long value, string[] values, long[] ids) {
            return XmlCustomFormatter.FromEnum(value, values, ids);
        }

        /// <include file='doc\XmlSerializationWriter.uex' path='docs/doc[@for="XmlSerializationWriter.FromXmlName"]/*' />
        protected static string FromXmlName(string name) {
            return XmlCustomFormatter.FromXmlName(name);
        }

        /// <include file='doc\XmlSerializationWriter.uex' path='docs/doc[@for="XmlSerializationWriter.FromXmlNCName"]/*' />
        protected static string FromXmlNCName(string ncName) {
            return XmlCustomFormatter.FromXmlNCName(ncName);
        }

        /// <include file='doc\XmlSerializationWriter.uex' path='docs/doc[@for="XmlSerializationWriter.FromXmlNmToken"]/*' />
        protected static string FromXmlNmToken(string nmToken) {
            return XmlCustomFormatter.FromXmlNmToken(nmToken);
        }

        /// <include file='doc\XmlSerializationWriter.uex' path='docs/doc[@for="XmlSerializationWriter.FromXmlNmTokens"]/*' />
        protected static string FromXmlNmTokens(string nmTokens) {
            return XmlCustomFormatter.FromXmlNmTokens(nmTokens);
        }

        /// <include file='doc\XmlSerializationWriter.uex' path='docs/doc[@for="XmlSerializationWriter.WriteXsiType"]/*' />
        protected void WriteXsiType(string name, string ns) {
            WriteAttribute("type", XmlSchema.InstanceNamespace, GetQualifiedName(name, ns));
        }

        XmlQualifiedName GetPrimitiveTypeName(Type type) {
            return GetPrimitiveTypeName(type, true);
        }

        XmlQualifiedName GetPrimitiveTypeName(Type type, bool throwIfUnknown) {
            XmlQualifiedName qname = GetPrimitiveTypeNameInternal(type);
            if (throwIfUnknown && qname == null)
                throw CreateUnknownTypeException(type);
            return qname;
        }

        internal static XmlQualifiedName GetPrimitiveTypeNameInternal(Type type) {
            string typeName;
            string typeNs = XmlSchema.Namespace;
            
            switch (Type.GetTypeCode(type)) {
            case TypeCode.String: typeName = "string"; break;
            case TypeCode.Int32: typeName = "int"; break;
            case TypeCode.Boolean: typeName = "boolean"; break;
            case TypeCode.Int16: typeName = "short"; break;
            case TypeCode.Int64: typeName = "long"; break;
            case TypeCode.Single: typeName = "float"; break;
            case TypeCode.Double: typeName = "double"; break;
            case TypeCode.Decimal: typeName = "decimal"; break;
            case TypeCode.DateTime: typeName = "dateTime"; break;
            case TypeCode.Byte: typeName = "unsignedByte"; break;
            case TypeCode.SByte: typeName = "byte"; break;
            case TypeCode.UInt16: typeName = "unsignedShort"; break;
            case TypeCode.UInt32: typeName = "unsignedInt"; break;
            case TypeCode.UInt64: typeName = "unsignedLong"; break;
            case TypeCode.Char: 
                typeName = "char"; 
                typeNs = UrtTypes.Namespace;
                break;
            default:
                if (type == typeof(XmlQualifiedName)) typeName = "QName";
                else if (type == typeof(byte[])) typeName = "base64Binary";
                else if (type == typeof(Guid)) {
                    typeName = "guid";
                    typeNs = UrtTypes.Namespace;
                }
                else if (type == typeof(XmlNode[])){
                    typeName = Soap.UrType;
                }
                else
                    return null;
                break;
            }
            return new XmlQualifiedName(typeName, typeNs);
        }

        /// <include file='doc\XmlSerializationWriter.uex' path='docs/doc[@for="XmlSerializationWriter.WriteTypedPrimitive"]/*' />
        protected void WriteTypedPrimitive(string name, string ns, object o, bool xsiType) {
            string value;
            string type;
            string typeNs = XmlSchema.Namespace;
            bool writeRaw = true;
            bool writeDirect = false;
            Type t = o.GetType();
            bool wroteStartElement = false;

            switch (Type.GetTypeCode(t)) {
            case TypeCode.String:
                value = (string)o;
                type = "string";
                writeRaw = false;
                break;
            case TypeCode.Int32:
                value = XmlConvert.ToString((int)o);
                type = "int";
                break;
            case TypeCode.Boolean:
                value = XmlConvert.ToString((bool)o);
                type = "boolean";
                break;
            case TypeCode.Int16:
                value = XmlConvert.ToString((short)o);
                type = "short";
                break;
            case TypeCode.Int64:
                value = XmlConvert.ToString((long)o);
                type = "long";
                break;
            case TypeCode.Single:
                value = XmlConvert.ToString((float)o);
                type = "float";
                break;
            case TypeCode.Double:
                value = XmlConvert.ToString((double)o);
                type = "double";

                break;
            case TypeCode.Decimal:
                value = XmlConvert.ToString((decimal)o);
                type = "decimal";
                break;
            case TypeCode.DateTime:
                value = FromDateTime((DateTime)o);
                type = "dateTime";
                break;
            case TypeCode.Char:
                value = FromChar((char)o);
                type = "char";
                typeNs = UrtTypes.Namespace;
                break;
            case TypeCode.Byte:
                value = XmlConvert.ToString((byte)o);
                type = "unsignedByte";
                break;
            case TypeCode.SByte:
                value = XmlConvert.ToString((sbyte)o);
                type = "byte";
                break;
            case TypeCode.UInt16:
                value = XmlConvert.ToString((UInt16)o);
                type = "unsignedShort";
                break;
            case TypeCode.UInt32:
                value = XmlConvert.ToString((UInt32)o);
                type = "unsignedInt";
                break;
            case TypeCode.UInt64:
                value = XmlConvert.ToString((UInt64)o);
                type = "unsignedLong";
                break;

            default:
                if (t == typeof(XmlQualifiedName)) {
                    type = "QName";
                    // need to write start element ahead of time to establish context
                    // for ns definitions by FromXmlQualifiedName
                    wroteStartElement = true;
                    if (name == null)
                        w.WriteStartElement(type, typeNs);
                    else
                        w.WriteStartElement(name, ns);
                    value = FromXmlQualifiedName((XmlQualifiedName)o);
                }
                else if (t == typeof(byte[])) {
                    writeDirect = true;
                    value = null;
                    type = "base64Binary";
                }
                else if (t == typeof(Guid)) {
                    value = XmlConvert.ToString((Guid)o);
                    type = "guid";
                    typeNs = UrtTypes.Namespace;
                }
                else if (typeof(XmlNode[]).IsAssignableFrom(t)){
                    if (name == null)
                        w.WriteStartElement(Soap.UrType, XmlSchema.Namespace);
                    else
                        w.WriteStartElement(name, ns);
                    XmlNode[] xmlNodes = (XmlNode[])o;
                    for (int i=0;i<xmlNodes.Length;i++){
                        xmlNodes[i].WriteTo(w);
                    }
                    w.WriteEndElement();
                    return;
                }
                else
                    throw CreateUnknownTypeException(t);

        
                break;
            }
            if (!wroteStartElement) {
                if (name == null)
                    w.WriteStartElement(type, typeNs);
                else
                    w.WriteStartElement(name, ns);
            }

            if (xsiType) WriteXsiType(type, typeNs);
            if (writeDirect) {
                // only one type currently writes directly to XML stream
                XmlCustomFormatter.WriteArrayBase64(w, (byte[])o, 0,((byte[])o).Length);
            }
            else if(writeRaw) {
                w.WriteRaw(value);
            }
            else
                w.WriteString(value);
            w.WriteEndElement();
        }

        string GetQualifiedName(string name, string ns) {
            if (ns == null || ns.Length == 0) return name;
            string prefix = w.LookupPrefix(ns);
            if (prefix == null) {
                if (ns == XmlReservedNs.NsXml) {
                    prefix = "xml";
                }
                else {
                    prefix = NextPrefix();
                    WriteAttribute("xmlns", prefix, null, ns);
                }
            }
            else if (prefix.Length == 0) {
                return name;
            }
            return prefix + ":" + name;
        }

        /// <include file='doc\XmlSerializationWriter.uex' path='docs/doc[@for="XmlSerializationWriter.FromXmlQualifiedName"]/*' />
        protected string FromXmlQualifiedName(XmlQualifiedName xmlQualifiedName) {
            if (xmlQualifiedName == null || xmlQualifiedName.IsEmpty) return null;
            return GetQualifiedName(XmlConvert.EncodeLocalName(xmlQualifiedName.Name), xmlQualifiedName.Namespace);
        }

        /// <include file='doc\XmlSerializationWriter.uex' path='docs/doc[@for="XmlSerializationWriter.WriteStartElement"]/*' />
        protected void WriteStartElement(string name) {
            WriteStartElement(name, null);
        }

        /// <include file='doc\XmlSerializationWriter.uex' path='docs/doc[@for="XmlSerializationWriter.WriteStartElement1"]/*' />
        protected void WriteStartElement(string name, string ns) {
            WriteStartElement(name, ns, null);
        }

        /// <include file='doc\XmlSerializationWriter.uex' path='docs/doc[@for="XmlSerializationWriter.WriteStartElement4"]/*' />
        protected void WriteStartElement(string name, string ns, bool writePrefixed) {
            WriteStartElement(name, ns, null, writePrefixed);
        }

        /// <include file='doc\XmlSerializationWriter.uex' path='docs/doc[@for="XmlSerializationWriter.WriteStartElement2"]/*' />
        protected void WriteStartElement(string name, string ns, object o) {
            WriteStartElement(name, ns, o, false);
        }

        /// <include file='doc\XmlSerializationWriter.uex' path='docs/doc[@for="XmlSerializationWriter.WriteStartElement3"]/*' />
        protected void WriteStartElement(string name, string ns, object o, bool writePrefixed) {
            if (o != null && objectsInUse != null) {
                if (objectsInUse.ContainsKey(o)) throw new InvalidOperationException(Res.GetString(Res.XmlCircularReference, o.GetType().FullName));
                objectsInUse.Add(o, o);
            }

            string prefix = null;
            bool needEmptyDefaultNamespace = false;
            if (namespaces != null) {
                for (int i = 0; i < namespaces.Count; i++) {
                    XmlQualifiedName qname = (XmlQualifiedName)namespaces[i];
                    if (qname.Name.Length > 0 && qname.Namespace == ns)
                        prefix = qname.Name;
                    if (qname.Name.Length == 0) {
                        if (qname.Namespace == null || qname.Namespace.Length == 0)
                            needEmptyDefaultNamespace = true;
                        if (ns != qname.Namespace)
                            writePrefixed = true;
                    }
                }
                usedPrefixes = ListUsedPrefixes(namespaces, aliasBase);
            }
            if (writePrefixed && prefix == null && ns != null && ns.Length > 0) {
                prefix = w.LookupPrefix(ns);
                if (prefix == null || prefix.Length == 0) {
                    prefix = NextPrefix();
                }
            }
            if (needEmptyDefaultNamespace && prefix == null && ns != null && ns.Length != 0)
                prefix = NextPrefix();
            w.WriteStartElement(prefix, name, ns);
            if (namespaces != null) {
                for (int i = 0; i < namespaces.Count; i++) {
                    XmlQualifiedName qname = (XmlQualifiedName)namespaces[i];
                    if (qname.Name.Length == 0 && (qname.Namespace == null || qname.Namespace.Length == 0))
                        continue;
                    if (qname.Namespace == null || qname.Namespace.Length == 0) {
                        if (qname.Name.Length > 0)
                            throw new InvalidOperationException(Res.GetString(Res.XmlInvalidXmlns, qname.ToString()));
                        WriteAttribute("xmlns", qname.Name, null, qname.Namespace);
                    }
                    else {
                        if (w.LookupPrefix(qname.Namespace) == null) {
                            WriteAttribute("xmlns", qname.Name, null, qname.Namespace);
                        }
                    }
                }
                namespaces = null;
            }
        }

        Hashtable ListUsedPrefixes(ArrayList nsList, string prefix) {
            Hashtable qnIndexes = new Hashtable();
            int prefixLength = prefix.Length;
            const string MaxInt32 = "2147483647";
            for (int i = 0; i < nsList.Count; i++) {
                string name;
                XmlQualifiedName qname = (XmlQualifiedName)nsList[i];
                if (qname.Name.Length > prefixLength) {
                    name = qname.Name;
                    int nameLength = name.Length;
                    if (name.Length > prefixLength && name.Length <= prefixLength + MaxInt32.Length && name.StartsWith(prefix)) {
                        bool numeric = true;
                        for (int j = prefixLength; j < name.Length; j++) {
                            if (!Char.IsDigit(name, j)) {
                                numeric = false;
                                break;
                            }
                        }
                        if (numeric) {
                            Int64 index = Int64.Parse(name.Substring(prefixLength));
                            if (index <= Int32.MaxValue) {
                                Int32 newIndex = (Int32)index;
                                if (!qnIndexes.ContainsKey(newIndex)) {
                                    qnIndexes.Add(newIndex, newIndex);
                                }
                            }
                        }
                    }
                }
            }
            if (qnIndexes.Count > 0) {
                return qnIndexes;
            }
            return null;
        }

        /// <include file='doc\XmlSerializationWriter.uex' path='docs/doc[@for="XmlSerializationWriter.WriteNullTagEncoded"]/*' />
        protected void WriteNullTagEncoded(string name) {
            WriteNullTagEncoded(name, null);
        }

        /// <include file='doc\XmlSerializationWriter.uex' path='docs/doc[@for="XmlSerializationWriter.WriteNullTagEncoded1"]/*' />
        protected void WriteNullTagEncoded(string name, string ns) {
            WriteStartElement(name, ns, true);
            w.WriteAttributeString("nil", XmlSchema.InstanceNamespace, "true");
            w.WriteEndElement();
        }

        /// <include file='doc\XmlSerializationWriter.uex' path='docs/doc[@for="XmlSerializationWriter.WriteNullTagLiteral"]/*' />
        protected void WriteNullTagLiteral(string name) {
            WriteNullTagLiteral(name, null);
        }

        /// <include file='doc\XmlSerializationWriter.uex' path='docs/doc[@for="XmlSerializationWriter.WriteNullTag1"]/*' />
        protected void WriteNullTagLiteral(string name, string ns) {
            WriteStartElement(name, ns);
            w.WriteAttributeString("nil", XmlSchema.InstanceNamespace, "true");
            w.WriteEndElement();
        }

        /// <include file='doc\XmlSerializationWriter.uex' path='docs/doc[@for="XmlSerializationWriter.WriteEmptyTag"]/*' />
        protected void WriteEmptyTag(string name) {
            WriteStartElement(name, null);
            w.WriteEndElement();
        }

        /// <include file='doc\XmlSerializationWriter.uex' path='docs/doc[@for="XmlSerializationWriter.WriteEmptyTag1"]/*' />
        protected void WriteEmptyTag(string name, string ns) {
            WriteStartElement(name, ns);
            w.WriteEndElement();
        }

        /// <include file='doc\XmlSerializationWriter.uex' path='docs/doc[@for="XmlSerializationWriter.WriteEndElement"]/*' />
        protected void WriteEndElement() {
            WriteEndElement(null);
        }

        /// <include file='doc\XmlSerializationWriter.uex' path='docs/doc[@for="XmlSerializationWriter.WriteEndElement1"]/*' />
        protected void WriteEndElement(object o) {
            w.WriteEndElement();

            if (o != null && objectsInUse != null) {
                #if DEBUG
                    // use exception in the place of Debug.Assert to avoid throwing asserts from a server process such as aspnet_ewp.exe
                    if (!objectsInUse.ContainsKey(o)) throw new InvalidOperationException(Res.GetString(Res.XmlInternalErrorDetails, "missing stack object of type " + o.GetType().FullName));
                #endif

                objectsInUse.Remove(o);
            }
        }

        /// <include file='doc\XmlSerializationWriter.uex' path='docs/doc[@for="XmlSerializationWriter.WriteSerializable"]/*' />
        protected void WriteSerializable(IXmlSerializable serializable, string name, string ns, bool isNullable) {
            if (serializable == null) {
                if (isNullable) WriteNullTagLiteral(name, ns);
                return;
            }
            w.WriteStartElement(name, ns);
            serializable.WriteXml(w);
            w.WriteEndElement();
        }

        /// <include file='doc\XmlSerializationWriter.uex' path='docs/doc[@for="XmlSerializationWriter.WriteNullableStringEncoded"]/*' />
        protected void WriteNullableStringEncoded(string name, string ns, string value, XmlQualifiedName xsiType) {
            if (value == null)
                WriteNullTagEncoded(name, ns);
            else
                WriteElementString(name, ns, value, xsiType);
        }

        /// <include file='doc\XmlSerializationWriter.uex' path='docs/doc[@for="XmlSerializationWriter.WriteNullableStringLiteral"]/*' />
        protected void WriteNullableStringLiteral(string name, string ns, string value) {
            if (value == null)
                WriteNullTagLiteral(name, ns);
            else
                WriteElementString(name, ns, value);
        }
        

        /// <include file='doc\XmlSerializationWriter.uex' path='docs/doc[@for="XmlSerializationWriter.WriteNullableStringEncodedRaw"]/*' />
        protected void WriteNullableStringEncodedRaw(string name, string ns, string value, XmlQualifiedName xsiType) {
            if (value == null)
                WriteNullTagEncoded(name, ns);
            else
                WriteElementStringRaw(name, ns, value, xsiType);
        }

        /// <include file='doc\XmlSerializationWriter.uex' path='docs/doc[@for="XmlSerializationWriter.WriteNullableStringEncodedRaw1"]/*' />
        protected void WriteNullableStringEncodedRaw(string name, string ns, byte[] value, XmlQualifiedName xsiType) {
            if (value == null)
                WriteNullTagEncoded(name, ns);
            else
                WriteElementStringRaw(name, ns, value, xsiType);
        }

        /// <include file='doc\XmlSerializationWriter.uex' path='docs/doc[@for="XmlSerializationWriter.WriteNullableStringLiteralRaw"]/*' />
        protected void WriteNullableStringLiteralRaw(string name, string ns, string value) {
            if (value == null)
                WriteNullTagLiteral(name, ns);
            else
                WriteElementStringRaw(name, ns, value, null);
        }

        /// <include file='doc\XmlSerializationWriter.uex' path='docs/doc[@for="XmlSerializationWriter.WriteNullableStringLiteralRaw1"]/*' />
        protected void WriteNullableStringLiteralRaw(string name, string ns, byte[] value) {
            if (value == null)
                WriteNullTagLiteral(name, ns);
            else
                WriteElementStringRaw(name, ns, value, null);
        }

        /// <include file='doc\XmlSerializationWriter.uex' path='docs/doc[@for="XmlSerializationWriter.WriteNullableQualifiedNameEncoded"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected void WriteNullableQualifiedNameEncoded(string name, string ns, XmlQualifiedName value, XmlQualifiedName xsiType) {
            if (value == null)
                WriteNullTagEncoded(name, ns);
            else
                WriteElementQualifiedName(name, ns, value, xsiType);
        }

        /// <include file='doc\XmlSerializationWriter.uex' path='docs/doc[@for="XmlSerializationWriter.WriteNullableQualifiedNameLiteral"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected void WriteNullableQualifiedNameLiteral(string name, string ns, XmlQualifiedName value) {
            if (value == null)
                WriteNullTagLiteral(name, ns);
            else
                WriteElementQualifiedName(name, ns, value);
        }

        
        /// <include file='doc\XmlSerializationWriter.uex' path='docs/doc[@for="XmlSerializationWriter.WriteElementEncoded"]/*' />
        protected void WriteElementEncoded(XmlNode node, string name, string ns, bool isNullable, bool any) {
            if (node == null) {
                if (isNullable) WriteNullTagEncoded(name, ns);
                return;
            }
            WriteElement(node, name, ns, any);
        }
        
        /// <include file='doc\XmlSerializationWriter.uex' path='docs/doc[@for="XmlSerializationWriter.WriteElementLiteral"]/*' />
        protected void WriteElementLiteral(XmlNode node, string name, string ns, bool isNullable, bool any) {
            if (node == null) {
                if (isNullable) WriteNullTagLiteral(name, ns);
                return;
            }
            WriteElement(node, name, ns, any);
        }
        
        private void WriteElement(XmlNode node, string name, string ns, bool any) {
            if (typeof(XmlAttribute).IsAssignableFrom(node.GetType()))
                throw new InvalidOperationException(Res.GetString(Res.XmlNoAttributeHere));
            if (node is XmlDocument)
                node = ((XmlDocument)node).DocumentElement;
            if (any) {
                if (node is XmlElement && name != null && name.Length > 0) {
                    // need to check against schema
                    if (node.LocalName != name || node.NamespaceURI != ns)
                        throw new InvalidOperationException(Res.GetString(Res.XmlElementNameMismatch, node.LocalName, node.NamespaceURI, name, ns));
                }
            }
            else
                w.WriteStartElement(name, ns);

            node.WriteTo(w);

            if (!any)
                w.WriteEndElement();
        }

        /// <include file='doc\XmlSerializationWriter.uex' path='docs/doc[@for="XmlSerializationWriter.CreateUnknownTypeException"]/*' />
        protected Exception CreateUnknownTypeException(object o) {
            return CreateUnknownTypeException(o.GetType());
        }

        /// <include file='doc\XmlSerializationWriter.uex' path='docs/doc[@for="XmlSerializationWriter.CreateUnknownTypeException1"]/*' />
        protected Exception CreateUnknownTypeException(Type type) {
            if (typeof(IXmlSerializable).IsAssignableFrom(type)) return new InvalidOperationException(Res.GetString(Res.XmlInvalidSerializable, type.FullName));
            TypeDesc typeDesc = new TypeScope().GetTypeDesc(type);
            if (!typeDesc.IsStructLike) return new InvalidOperationException(Res.GetString(Res.XmlInvalidUseOfType, type.FullName));
            return new InvalidOperationException(Res.GetString(Res.XmlUnxpectedType, type.FullName));
        }

        /// <include file='doc\XmlSerializationWriter.uex' path='docs/doc[@for="XmlSerializationWriter.CreateMismatchChoiceException"]/*' />
        protected Exception CreateMismatchChoiceException(string value, string elementName, string enumValue) {
            // Value of {0} mismatches the type of {1}, you need to set it to {2}.
            return new InvalidOperationException(Res.GetString(Res.XmlChoiceMismatchChoiceException, elementName, value, enumValue));
        }

        /// <include file='doc\XmlSerializationWriter.uex' path='docs/doc[@for="XmlSerializationWriter.CreateUnknownAnyElementException"]/*' />
        protected Exception CreateUnknownAnyElementException(string name, string ns) {
            return new InvalidOperationException(Res.GetString(Res.XmlUnknownAnyElement, name, ns));
        }

        /// <include file='doc\XmlSerializationWriter.uex' path='docs/doc[@for="XmlSerializationWriter.CreateInvalidChoiceIdentifierValueException"]/*' />
        protected Exception CreateInvalidChoiceIdentifierValueException(string type, string identifier) {
            return new InvalidOperationException(Res.GetString(Res.XmlInvalidChoiceIdentifierValue, type, identifier));
        }

        /// <include file='doc\XmlSerializationWriter.uex' path='docs/doc[@for="XmlSerializationWriter.CreateChoiceIdentifierValueException"]/*' />
        protected Exception CreateChoiceIdentifierValueException(string value, string identifier, string name, string ns) {
            // XmlChoiceIdentifierMismatch=Value '{0}' of the choice identifier '{1}' does not match element '{2}' from namespace '{3}'.
            return new InvalidOperationException(Res.GetString(Res.XmlChoiceIdentifierMismatch, value, identifier, name, ns));
        }

        /// <include file='doc\XmlSerializationWriter.uex' path='docs/doc[@for="XmlSerializationWriter.WriteReferencingElement"]/*' />
        protected void WriteReferencingElement(string n, string ns, object o) {
            WriteReferencingElement(n, ns, o, false);
        }

        /// <include file='doc\XmlSerializationWriter.uex' path='docs/doc[@for="XmlSerializationWriter.WriteReferencingElement1"]/*' />
        protected void WriteReferencingElement(string n, string ns, object o, bool isNullable) {
            if (o == null) {
                if (isNullable) WriteNullTagEncoded(n, ns);
                return;
            }
            WriteStartElement(n, ns, true);
            if (soap12)
                w.WriteAttributeString("ref", GetId(o, true));
            else
                w.WriteAttributeString("href", "#" + GetId(o, true));
            w.WriteEndElement();
        }

        bool IsIdDefined(object o) {
            if (references != null) return references.Contains(o);
            else return false;
        }

        string GetId(object o, bool addToReferencesList) {
            if (references == null) {
                references = new Hashtable();
                referencesToWrite = new ArrayList();
            }
            string id = (string)references[o];
            if (id == null) {
                id = "id" + (++nextId).ToString();
                references.Add(o, id);
                if (addToReferencesList) referencesToWrite.Add(o);
            }
            return id;
        }

        /// <include file='doc\XmlSerializationWriter.uex' path='docs/doc[@for="XmlSerializationWriter.WriteId"]/*' />
        protected void WriteId(object o) {
            w.WriteAttributeString("id", GetId(o, true));
        }

        /// <include file='doc\XmlSerializationWriter.uex' path='docs/doc[@for="XmlSerializationWriter.WriteXmlAttribute1"]/*' />
        protected void WriteXmlAttribute(XmlNode node) {
            WriteXmlAttribute(node, null);
        }

        /// <include file='doc\XmlSerializationWriter.uex' path='docs/doc[@for="XmlSerializationWriter.WriteXmlAttribute2"]/*' />
        protected void WriteXmlAttribute(XmlNode node, object container) {
            XmlAttribute attr = node as XmlAttribute;
            if (attr == null) throw new InvalidOperationException(Res.GetString(Res.XmlNeedAttributeHere));
            if (attr.Value != null) {
                if (attr.NamespaceURI == Wsdl.Namespace && attr.LocalName == Wsdl.ArrayType) {
                    string dims;
                    XmlQualifiedName qname = TypeScope.ParseWsdlArrayType(attr.Value, out dims, (container is XmlSchemaObject) ? (XmlSchemaObject)container : null);

                    string value = FromXmlQualifiedName(qname) + dims;

                    //<xsd:attribute xmlns:q3="s0" wsdl:arrayType="q3:FoosBase[]" xmlns:q4="http://schemas.xmlsoap.org/soap/encoding/" ref="q4:arrayType" />
                    WriteAttribute(Wsdl.ArrayType, Wsdl.Namespace, value);
                }
                else {
                    WriteAttribute(attr.Name, attr.NamespaceURI, attr.Value);
                }
            }
        }

        /// <include file='doc\XmlSerializationWriter.uex' path='docs/doc[@for="XmlSerializationWriter.WriteAttribute"]/*' />
        protected void WriteAttribute(string localName, string ns, string value) {
            if (value == null) return;
            if (localName == "xmlns" || localName.StartsWith("xmlns:")) {
                ;
            }
            else {
                int colon = localName.IndexOf(":");
                if (colon < 0) {
                    if (ns == XmlReservedNs.NsXml) {
                        string prefix = w.LookupPrefix(ns);
                        if (prefix == null || prefix.Length == 0)
                            prefix = "xml";
                        w.WriteAttributeString(prefix, localName, ns, value);
                    }
                    else {
                        w.WriteAttributeString(localName, ns, value);
                    }
                }
                else {
                    string prefix = localName.Substring(0, colon);
                    w.WriteAttributeString(prefix, localName.Substring(colon+1), ns, value);
                }
            }
        }

        /// <include file='doc\XmlSerializationWriter.uex' path='docs/doc[@for="XmlSerializationWriter.WriteAttribute0"]/*' />
        protected void WriteAttribute(string localName, string ns, byte[] value) {
            if (value == null) return;
            if (localName == "xmlns" || localName.StartsWith("xmlns:")) {
                ;
            }
            else {
                int colon = localName.IndexOf(":");
                if (colon < 0) {
                    if (ns == XmlReservedNs.NsXml) {
                        string prefix = w.LookupPrefix(ns);
                        if (prefix == null || prefix.Length == 0)
                            prefix = "xml";
                        w.WriteStartAttribute("xml", localName, ns);
                    }
                    else {
                        w.WriteStartAttribute(null, localName, ns);
                    }
                }
                else {
                    string prefix = localName.Substring(0, colon);
                    prefix = w.LookupPrefix(ns);
                    w.WriteStartAttribute(prefix, localName.Substring(colon+1), ns);
                }
                XmlCustomFormatter.WriteArrayBase64(w, value, 0, value.Length);
                w.WriteEndAttribute();
            }
        }

        /// <include file='doc\XmlSerializationWriter.uex' path='docs/doc[@for="XmlSerializationWriter.WriteAttribute1"]/*' />
        protected void WriteAttribute(string localName, string value) {
            if (value == null) return;
            w.WriteAttributeString(localName, null, value);
        }

        /// <include file='doc\XmlSerializationWriter.uex' path='docs/doc[@for="XmlSerializationWriter.WriteAttribute01"]/*' />
        protected void WriteAttribute(string localName, byte[] value) {
            if (value == null) return;

            w.WriteStartAttribute(null, localName, null);
            XmlCustomFormatter.WriteArrayBase64(w, value, 0, value.Length);
            w.WriteEndAttribute();
        }

        /// <include file='doc\XmlSerializationWriter.uex' path='docs/doc[@for="XmlSerializationWriter.WriteAttribute2"]/*' />
        protected void WriteAttribute(string prefix, string localName, string ns, string value) {
            if (value == null) return;
            w.WriteAttributeString(prefix, localName, null, value);
        }

        /// <include file='doc\XmlSerializationWriter.uex' path='docs/doc[@for="XmlSerializationWriter.WriteValue"]/*' />
        protected void WriteValue(string value) {
            if (value == null) return;
            w.WriteString(value);
        }

        /// <include file='doc\XmlSerializationWriter.uex' path='docs/doc[@for="XmlSerializationWriter.WriteValue01"]/*' />
        protected void WriteValue(byte[] value) {
            if (value == null) return;
            XmlCustomFormatter.WriteArrayBase64(w, value, 0, value.Length);
        }
        
        /// <include file='doc\XmlSerializationWriter.uex' path='docs/doc[@for="XmlSerializationWriter.WriteStartDocument"]/*' />
        protected void WriteStartDocument() {
            if (w.WriteState == WriteState.Start) {
                w.WriteStartDocument();
            }
        }

        /// <include file='doc\XmlSerializationWriter.uex' path='docs/doc[@for="XmlSerializationWriter.WriteElementString"]/*' />
        protected void WriteElementString(String localName, String value) {
            WriteElementString(localName,null,value, null);
        }

        /// <include file='doc\XmlSerializationWriter.uex' path='docs/doc[@for="XmlSerializationWriter.WriteElementString1"]/*' />
        protected void WriteElementString(String localName, String ns, String value) {
            WriteElementString(localName, ns, value, null);
        }

        /// <include file='doc\XmlSerializationWriter.uex' path='docs/doc[@for="XmlSerializationWriter.WriteElementString2"]/*' />
        protected void WriteElementString(String localName, String value, XmlQualifiedName xsiType) {
            WriteElementString(localName,null,value, xsiType);
        }

        /// <include file='doc\XmlSerializationWriter.uex' path='docs/doc[@for="XmlSerializationWriter.WriteElementString3"]/*' />
        protected void WriteElementString(String localName, String ns, String value, XmlQualifiedName xsiType) {
            if (value == null) return;
            if (xsiType == null)
                w.WriteElementString(localName, ns, value);
            else {
                w.WriteStartElement(localName, ns);
                WriteXsiType(xsiType.Name, xsiType.Namespace);
                w.WriteString(value);
                w.WriteEndElement();
            }
        }

        /// <include file='doc\XmlSerializationWriter.uex' path='docs/doc[@for="XmlSerializationWriter.WriteElementStringRaw"]/*' />
        protected void WriteElementStringRaw(String localName, String value) {
            WriteElementStringRaw(localName,null,value, null);
        }

        /// <include file='doc\XmlSerializationWriter.uex' path='docs/doc[@for="XmlSerializationWriter.WriteElementStringRaw0"]/*' />
        protected void WriteElementStringRaw(String localName, byte[] value) {
            WriteElementStringRaw(localName,null,value, null);
        }

        /// <include file='doc\XmlSerializationWriter.uex' path='docs/doc[@for="XmlSerializationWriter.WriteElementStringRaw1"]/*' />
        protected void WriteElementStringRaw(String localName, String ns, String value) {
            WriteElementStringRaw(localName, ns, value, null);
        }

        /// <include file='doc\XmlSerializationWriter.uex' path='docs/doc[@for="XmlSerializationWriter.WriteElementStringRaw01"]/*' />
        protected void WriteElementStringRaw(String localName, String ns, byte[] value) {
            WriteElementStringRaw(localName, ns, value, null);
        }

        /// <include file='doc\XmlSerializationWriter.uex' path='docs/doc[@for="XmlSerializationWriter.WriteElementStringRaw2"]/*' />
        protected void WriteElementStringRaw(String localName, String value, XmlQualifiedName xsiType) {
            WriteElementStringRaw(localName,null,value, xsiType);
        }

        /// <include file='doc\XmlSerializationWriter.uex' path='docs/doc[@for="XmlSerializationWriter.WriteElementStringRaw02"]/*' />
        protected void WriteElementStringRaw(String localName, byte[] value, XmlQualifiedName xsiType) {
            WriteElementStringRaw(localName, null, value, xsiType);
        }

        /// <include file='doc\XmlSerializationWriter.uex' path='docs/doc[@for="XmlSerializationWriter.WriteElementStringRaw3"]/*' />
        protected void WriteElementStringRaw(String localName, String ns, String value, XmlQualifiedName xsiType) {
            if (value == null) return;
            w.WriteStartElement(localName, ns);
            if (xsiType != null)
                WriteXsiType(xsiType.Name, xsiType.Namespace);
            w.WriteRaw(value);
            w.WriteEndElement();
        }

        /// <include file='doc\XmlSerializationWriter.uex' path='docs/doc[@for="XmlSerializationWriter.WriteElementStringRaw03"]/*' />
        protected void WriteElementStringRaw(String localName, String ns, byte[] value, XmlQualifiedName xsiType) {
            if (value == null) return;
            w.WriteStartElement(localName, ns);
            if (xsiType != null)
                WriteXsiType(xsiType.Name, xsiType.Namespace);
            XmlCustomFormatter.WriteArrayBase64(w, value, 0, value.Length);
            w.WriteEndElement();
        }

        /// <include file='doc\XmlSerializationWriter.uex' path='docs/doc[@for="XmlSerializationWriter.WriteRpcResult"]/*' />
        protected void WriteRpcResult(string name, string ns) {
            if (!soap12) return;
            WriteElementQualifiedName(Soap12.RpcResult, Soap12.RpcNamespace, new XmlQualifiedName(name, ns));
        }

        /// <include file='doc\XmlSerializationWriter.uex' path='docs/doc[@for="XmlSerializationWriter.WriteElementQualifiedName"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected void WriteElementQualifiedName(String localName, XmlQualifiedName value) {
            WriteElementQualifiedName(localName,null,value, null);
        }

        /// <include file='doc\XmlSerializationWriter.uex' path='docs/doc[@for="XmlSerializationWriter.WriteElementQualifiedName1"]/*' />
        protected void WriteElementQualifiedName(string localName, XmlQualifiedName value, XmlQualifiedName xsiType) {
            WriteElementQualifiedName(localName, null, value, xsiType);
        }

        /// <include file='doc\XmlSerializationWriter.uex' path='docs/doc[@for="XmlSerializationWriter.WriteElementQualifiedName2"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected void WriteElementQualifiedName(String localName, String ns, XmlQualifiedName value) {
            WriteElementQualifiedName(localName, ns, value, null);
        }

        /// <include file='doc\XmlSerializationWriter.uex' path='docs/doc[@for="XmlSerializationWriter.WriteElementQualifiedName3"]/*' />
        protected void WriteElementQualifiedName(string localName, string ns, XmlQualifiedName value, XmlQualifiedName xsiType) {
            if (value == null) return;
            if (value.Namespace == null || value.Namespace.Length == 0) {
                WriteStartElement(localName, ns, true);
                WriteAttribute("xmlns", "");
            }
            else
                w.WriteStartElement(localName, ns);
            if (xsiType != null)
                WriteXsiType(xsiType.Name, xsiType.Namespace);
            w.WriteString(FromXmlQualifiedName(value));
            w.WriteEndElement();
        }

        /// <include file='doc\XmlSerializationWriter.uex' path='docs/doc[@for="XmlSerializationWriter.AddWriteCallback"]/*' />
        protected void AddWriteCallback(Type type, string typeName, string typeNs, XmlSerializationWriteCallback callback) {
            TypeEntry entry = new TypeEntry();
            entry.typeName = typeName;
            entry.typeNs = typeNs;
            entry.type = type;
            entry.callback = callback;
            typeEntries.Add(type, entry);
        }

        void WriteArray(string name, string ns, object o, Type type) {
            Type elementType = TypeScope.GetArrayElementType(type);
            string typeName;
            string typeNs;
            
            StringBuilder arrayDims = new StringBuilder();
            if (!soap12) {
                while ((elementType.IsArray || typeof(IEnumerable).IsAssignableFrom(elementType)) && GetPrimitiveTypeName(elementType, false) == null) {
                    elementType = TypeScope.GetArrayElementType(elementType);
                    arrayDims.Append("[]");
                }
            }
            
            if (elementType == typeof(object)) {
                typeName = Soap.UrType;
                typeNs = XmlSchema.Namespace;
            }
            else {
                TypeEntry entry = GetTypeEntry(elementType);
                if (entry != null) {
                    typeName = entry.typeName;
                    typeNs = entry.typeNs;
                }
                else if (soap12) {
                    XmlQualifiedName qualName = GetPrimitiveTypeName(elementType, false);
                    if (qualName != null) {
                        typeName = qualName.Name;
                        typeNs = qualName.Namespace;
                    }
                    else {
                        Type elementBaseType = elementType.BaseType;
                        while (elementBaseType != null) {
                            entry = GetTypeEntry(elementBaseType);
                            if (entry != null) break;
                            elementBaseType = elementBaseType.BaseType;
                        }
                        if (entry != null) {
                            typeName = entry.typeName;
                            typeNs = entry.typeNs;
                        }
                        else {
                            typeName = Soap.UrType;
                            typeNs = XmlSchema.Namespace;
                        }
                    }
                }
                else {
                    XmlQualifiedName qualName = GetPrimitiveTypeName(elementType);
                    typeName = qualName.Name;
                    typeNs = qualName.Namespace;
                }
            }
            
            if (arrayDims.Length > 0)
                typeName = typeName + arrayDims.ToString();
            
            if (soap12 && name != null && name.Length > 0)
                WriteStartElement(name, ns);
            else
                WriteStartElement(Soap.Array, Soap.Encoding, true);
            
            w.WriteAttributeString("id", GetId(o, false));
            if (type.IsArray) {
                Array a = (Array)o;
                int arrayLength = a.Length;
                if (soap12) {
                    w.WriteAttributeString("itemType", Soap12.Encoding, GetQualifiedName(typeName, typeNs));
                    w.WriteAttributeString("arraySize", Soap12.Encoding, arrayLength.ToString());
                }
                else {
                    w.WriteAttributeString("arrayType", Soap.Encoding, GetQualifiedName(typeName, typeNs) + "[" + arrayLength.ToString() + "]");
                }
                for (int i = 0; i < arrayLength; i++) {
                    WritePotentiallyReferencingElement("Item", "", a.GetValue(i), elementType, false, true);
                }
            }
            else {
                #if DEBUG
                    // use exception in the place of Debug.Assert to avoid throwing asserts from a server process such as aspnet_ewp.exe
                    if (!typeof(IEnumerable).IsAssignableFrom(type)) throw new InvalidOperationException(Res.GetString(Res.XmlInternalErrorDetails, "not array like type " + type.FullName));
                #endif

                int arrayLength = typeof(ICollection).IsAssignableFrom(type) ? ((ICollection)o).Count : -1;
                if (soap12) {
                    w.WriteAttributeString("itemType", Soap12.Encoding, GetQualifiedName(typeName, typeNs));
                    if (arrayLength >= 0)
                        w.WriteAttributeString("arraySize", Soap12.Encoding, arrayLength.ToString());
                }
                else {
                    string brackets = arrayLength >= 0 ? "[" + arrayLength + "]" : "[]";
                    w.WriteAttributeString("arrayType", Soap.Encoding, GetQualifiedName(typeName, typeNs) + brackets);
                }
                IEnumerator e = ((IEnumerable)o).GetEnumerator();
                if (e != null) {
                    while (e.MoveNext()) {
                        WritePotentiallyReferencingElement("Item", "", e.Current, elementType, false, true);
                    }
                }
            }
            w.WriteEndElement();
        }
        /// <include file='doc\XmlSerializationWriter.uex' path='docs/doc[@for="XmlSerializationWriter.WritePotentiallyReferencingElement"]/*' />
        protected void WritePotentiallyReferencingElement(string n, string ns, object o) {
            WritePotentiallyReferencingElement(n, ns, o, null, false);
        }

        /// <include file='doc\XmlSerializationWriter.uex' path='docs/doc[@for="XmlSerializationWriter.WritePotentiallyReferencingElement1"]/*' />
        protected void WritePotentiallyReferencingElement(string n, string ns, object o, Type ambientType) {
            WritePotentiallyReferencingElement(n, ns, o, ambientType, false);
        }

        /// <include file='doc\XmlSerializationWriter.uex' path='docs/doc[@for="XmlSerializationWriter.WritePotentiallyReferencingElement2"]/*' />
        protected void WritePotentiallyReferencingElement(string n, string ns, object o, Type ambientType, bool suppressReference) {
            WritePotentiallyReferencingElement(n, ns, o, ambientType, suppressReference, false);
        }
        
        /// <include file='doc\XmlSerializationWriter.uex' path='docs/doc[@for="XmlSerializationWriter.WritePotentiallyReferencingElement3"]/*' />
        protected void WritePotentiallyReferencingElement(string n, string ns, object o, Type ambientType, bool suppressReference, bool isNullable) {
            if (o == null) {
                if (isNullable) WriteNullTagEncoded(n, ns);
                return;
            }
            Type t = o.GetType();
            if (Convert.GetTypeCode(o) == TypeCode.Object && !(o is Guid) && !(o is XmlQualifiedName) && !(o is XmlNode[]) && !(o is Byte[])) {
                if ((suppressReference || soap12) && !IsIdDefined(o)) {
                    WriteReferencedElement(n, ns, o, ambientType);
                }
                else {
                    if (n == null) {
                        TypeEntry entry = GetTypeEntry(t);
                        WriteReferencingElement(entry.typeName, entry.typeNs, o, isNullable);
                    }
                    else
                        WriteReferencingElement(n, ns, o, isNullable);
                }
            }
            else {
                // Enums always write xsi:type, so don't write it again here.
                bool needXsiType = t != ambientType && !t.IsEnum;
                TypeEntry entry = GetTypeEntry(t);
                if (entry != null) {
                    if (n == null)
                        WriteStartElement(entry.typeName, entry.typeNs, true);
                    else
                        WriteStartElement(n, ns, true);
                    
                    if (needXsiType) WriteXsiType(entry.typeName, entry.typeNs);
                    entry.callback(o);
                    w.WriteEndElement();
                }
                else {
                    WriteTypedPrimitive(n, ns, o, needXsiType);
                }
            }
        }

        
        void WriteReferencedElement(object o, Type ambientType) {
            WriteReferencedElement(null, null, o, ambientType);
        }

        void WriteReferencedElement(string name, string ns, object o, Type ambientType) {
            if (name == null) name = String.Empty;
            Type t = o.GetType();
            if (t.IsArray || typeof(IEnumerable).IsAssignableFrom(t)) {
                WriteArray(name, ns, o, t);
            }
            else {
                TypeEntry entry = GetTypeEntry(t);
                if (entry == null) throw CreateUnknownTypeException(t);
                WriteStartElement(name.Length == 0 ? entry.typeName : name, ns == null ? entry.typeNs : ns, true);
                w.WriteAttributeString("id", GetId(o, false));
                if (ambientType != t) WriteXsiType(entry.typeName, entry.typeNs);
                entry.callback(o);
                w.WriteEndElement();
            }
        }

        TypeEntry GetTypeEntry(Type t) {
            if (typeEntries == null) {
                typeEntries = new Hashtable();
                InitCallbacks();
            }
            return (TypeEntry)typeEntries[t];
        }

        /// <include file='doc\XmlSerializationWriter.uex' path='docs/doc[@for="XmlSerializationWriter.InitCallbacks"]/*' />
        protected abstract void InitCallbacks();

        /// <include file='doc\XmlSerializationWriter.uex' path='docs/doc[@for="XmlSerializationWriter.WriteReferencedElements"]/*' />
        protected void WriteReferencedElements() {
            if (referencesToWrite == null) return;

            for (int i = 0; i < referencesToWrite.Count; i++) {
                WriteReferencedElement(referencesToWrite[i], null);
            }
        }

        /// <include file='doc\XmlSerializationWriter.uex' path='docs/doc[@for="XmlSerializationWriter.TopLevelElement"]/*' />
        protected void TopLevelElement() {
            objectsInUse = new Hashtable();
        }

        /// <include file='doc\XmlSerializationWriter.uex' path='docs/doc[@for="XmlSerializationWriter.WriteNamespaceDeclarations"]/*' />
        ///<internalonly/>
        protected void WriteNamespaceDeclarations(XmlSerializerNamespaces xmlns) {
            if (xmlns != null) {
                foreach (DictionaryEntry entry in xmlns.Namespaces) {
                    string prefix = (string)entry.Key;
                    string ns = (string)entry.Value;
                    string oldPrefix = (ns == null || ns.Length == 0) ? "" : Writer.LookupPrefix(ns);

                    if (oldPrefix == null || oldPrefix != prefix) {
                        WriteAttribute("xmlns", prefix, null, ns);
                    }
                }
            }
        }

        string NextPrefix() {
            if (usedPrefixes == null) {
                return aliasBase + (++tempNamespacePrefix);
            }
            while (usedPrefixes.ContainsKey(++tempNamespacePrefix)) {;}
            return aliasBase + tempNamespacePrefix;
        }

        internal class TypeEntry {
            internal XmlSerializationWriteCallback callback;
            internal string typeNs;
            internal string typeName;
            internal Type type;
        }
    }

    /// <include file='doc\XmlSerializationWriter.uex' path='docs/doc[@for="XmlSerializationWriteCallback"]/*' />
    ///<internalonly/>
    public delegate void XmlSerializationWriteCallback(object o);

    internal class XmlSerializationWriterCodeGen {
        IndentedWriter writer;
        int nextMethodNumber = 0;
        Hashtable methodNames = new Hashtable();
        TypeScope[] scopes;
        TypeDesc stringTypeDesc;
        TypeDesc qnameTypeDesc;
        string access = "public";
        string className = "XmlSerializationWriter1";
        
        internal XmlSerializationWriterCodeGen(IndentedWriter writer, TypeScope[] scopes, string access, string className) : this(writer, scopes){
            this.className = className;
            this.access = access;
        }
        internal XmlSerializationWriterCodeGen(IndentedWriter writer, TypeScope[] scopes) {
            this.writer = writer;
            this.scopes = scopes;
            this.stringTypeDesc = scopes[0].GetTypeDesc(typeof(string));
            this.qnameTypeDesc = scopes[0].GetTypeDesc(typeof(XmlQualifiedName));
        }

        internal void GenerateBegin() {
            writer.Write(access);
            writer.Write(" class ");
            writer.Write(className);
            writer.Write(" : ");
            writer.Write(typeof(XmlSerializationWriter).FullName);
            writer.WriteLine(" {");
            writer.Indent++;

            foreach (TypeScope scope in scopes) {
                foreach (TypeMapping mapping in scope.TypeMappings) {
                    if (mapping is StructMapping || mapping is EnumMapping)
                        methodNames.Add(mapping, NextMethodName(((TypeMapping)mapping).TypeDesc.Name));
                }                    
            }

            foreach (TypeScope scope in scopes) {
                foreach (TypeMapping mapping in scope.TypeMappings) {
                    if (mapping is StructMapping)
                        WriteStructMethod((StructMapping)mapping);
                    else if (mapping is EnumMapping)
                        WriteEnumMethod((EnumMapping)mapping);
                }
            }
            GenerateInitCallbacksMethod();
        }
        
        internal void GenerateEnd() {
            writer.Indent--;
            writer.WriteLine("}");
        }

        internal string GenerateElement(XmlMapping xmlMapping) {
            if (!xmlMapping.GenerateSerializer) 
                throw new ArgumentException(Res.GetString(Res.XmlInternalError), "xmlMapping");

            if (xmlMapping is XmlTypeMapping)
                return GenerateTypeElement((XmlTypeMapping)xmlMapping);
            else if (xmlMapping is XmlMembersMapping)
                return GenerateMembersElement((XmlMembersMapping)xmlMapping);
            else
                throw new ArgumentException(Res.GetString(Res.XmlInternalError), "xmlMapping");
        }

        void WriteQuotedCSharpString(string value) {
            if (value == null) {
                // REVIEW, stefanph: this should read
                //    writer.Write("null");
                // instead.
                writer.Write("\"\"");
                return;
            }

            writer.Write("@\"");

            for (int i=0; i<value.Length; i++) {
                if (value[i] == '\"')
                    writer.Write("\"\"");
                else
                    writer.Write(value[i]);
            }

            writer.Write("\"");
        }

        void GenerateInitCallbacksMethod() {
            writer.WriteLine();
            writer.WriteLine("protected override void InitCallbacks() {");
            writer.Indent++;

            // CONSIDER, alexdej: add array callbacks as well
            foreach (TypeScope scope in scopes) {
                foreach (TypeMapping typeMapping in scope.TypeMappings) {
                    if (typeMapping.IsSoap && 
                        (typeMapping is StructMapping || typeMapping is EnumMapping) && 
                        !typeMapping.TypeDesc.IsRoot) {
                        
                        string methodName = (string)methodNames[typeMapping];
                        writer.Write("AddWriteCallback(typeof(");
                        string typeName = CodeIdentifier.EscapeKeywords(typeMapping.TypeDesc.FullName);
                        writer.Write(typeName);
                        writer.Write("), ");
                        WriteQuotedCSharpString(typeMapping.TypeName);
                        writer.Write(", ");
                        WriteQuotedCSharpString(typeMapping.Namespace);
                        writer.Write(", new ");
                        writer.Write(typeof(XmlSerializationWriteCallback).FullName);
                        writer.Write("(this.");
                        writer.Write(methodName);
                        writer.WriteLine("));");
                    }
                }
            }
            writer.Indent--;
            writer.WriteLine("}");
        }

        void WriteQualifiedNameElement(string name, string ns, object defaultValue, string source, bool nullable, bool IsSoap, TypeMapping mapping) {
            bool hasDefault = defaultValue != DBNull.Value;
            if (hasDefault) {
                writer.Write("if (");
                writer.Write(source);
                writer.Write(" != ");
                WriteValue(defaultValue);
                writer.WriteLine(") {");
                writer.Indent++;
            }
            string suffix = IsSoap ? "Encoded" : "Literal";
            writer.Write(nullable ? ("WriteNullableQualifiedName" + suffix): "WriteElementQualifiedName");
            writer.Write("(");
            WriteQuotedCSharpString(name);
            if (ns != null) {
                writer.Write(", ");
                WriteQuotedCSharpString(ns);
            }
            writer.Write(", ");
            writer.Write(source);

            if (IsSoap) {
                writer.Write(", new System.Xml.XmlQualifiedName(");
                WriteQuotedCSharpString(mapping.TypeName);
                writer.Write(", ");
                WriteQuotedCSharpString(mapping.Namespace);
                writer.Write(")");
            }

            writer.WriteLine(");");

            if (hasDefault) {
                writer.Indent--;
                writer.WriteLine("}");
            }
        }

        void WriteEnumValue(EnumMapping mapping, string source) {
            string methodName = (string)methodNames[mapping];
            #if DEBUG
                // use exception in the place of Debug.Assert to avoid throwing asserts from a server process such as aspnet_ewp.exe
                if (methodName == null) throw new InvalidOperationException(Res.GetString(Res.XmlInternalErrorMethod, mapping.TypeDesc.Name));
            #endif

            writer.Write(methodName);
            writer.Write("(");
            writer.Write(source);
            writer.Write(")");
        }

        void WritePrimitiveValue(TypeDesc typeDesc, string source) {
            if (typeDesc == stringTypeDesc || typeDesc.FormatterName == "String") {
                writer.Write(source);
            }
            else {
                if (!typeDesc.HasCustomFormatter) {
                    writer.Write(typeof(XmlConvert).FullName);
                    writer.Write(".ToString((");
                    writer.Write(CodeIdentifier.EscapeKeywords(typeDesc.FullName));
                    writer.Write(")");
                    writer.Write(source);
                    writer.Write(")");
                } 
                else {
                    writer.Write("From");
                    writer.Write(typeDesc.FormatterName);
                    writer.Write("(");
                    writer.Write(source);
                    writer.Write(")");
                }
            }
        }

        void WritePrimitive(string method, string name, string ns, object defaultValue, string source, TypeMapping mapping, bool writeXsiType) {
            TypeDesc typeDesc = mapping.TypeDesc;
            bool hasDefault = defaultValue != DBNull.Value && mapping.TypeDesc.HasDefaultSupport;
            if (hasDefault) {
                writer.Write("if (");
                writer.Write(source);
                writer.Write(" != ");
                if (mapping is EnumMapping) {
                    #if DEBUG
                        // use exception in the place of Debug.Assert to avoid throwing asserts from a server process such as aspnet_ewp.exe
                        if (defaultValue.GetType() != typeof(string)) throw new InvalidOperationException(Res.GetString(Res.XmlInternalErrorDetails, name + " has invalid default type " + defaultValue.GetType().Name));
                    #endif

                    string enumName = CodeIdentifier.EscapeKeywords(mapping.TypeDesc.FullName);
                    if (((EnumMapping)mapping).IsFlags) {
                        writer.Write("(");
                        string[] values = ((string)defaultValue).Split(null);
                        for (int i = 0; i < values.Length; i++) {
                            if (values[i] == String.Empty) continue;
                            if (i > 0) writer.WriteLine(" | ");
                            writer.Write(enumName);
                            writer.Write(".@");
                            CodeIdentifier.CheckValidIdentifier(values[i]);
                            writer.Write(values[i]);
                        }
                        writer.Write(")");
                    }
                    else {
                        writer.Write(enumName);
                        writer.Write(".@");
                        CodeIdentifier.CheckValidIdentifier((string)defaultValue);
                        writer.Write((string)defaultValue);
                    }
                }
                else {
                    WriteValue(defaultValue);
                }
                writer.WriteLine(") {");
                writer.Indent++;
            }
            writer.Write(method);
            writer.Write("(");
            WriteQuotedCSharpString(name);
            if (ns != null) {
                writer.Write(", ");
                WriteQuotedCSharpString(ns);
            }
            writer.Write(", ");

            if (mapping is EnumMapping) {
                WriteEnumValue((EnumMapping)mapping, source);
            }
            else {
                WritePrimitiveValue(typeDesc, source);
            }

            if (writeXsiType) {
                writer.Write(", new System.Xml.XmlQualifiedName(");
                WriteQuotedCSharpString(mapping.TypeName);
                writer.Write(", ");
                WriteQuotedCSharpString(mapping.Namespace);
                writer.Write(")");
            }

            writer.WriteLine(");");

            if (hasDefault) {
                writer.Indent--;
                writer.WriteLine("}");
            }
        }

        void WriteTag(string methodName, string name, string ns) {
            WriteTag(methodName, name, ns, false);
        }

        void WriteTag(string methodName, string name, string ns, bool writePrefixed) {
            writer.Write(methodName);
            writer.Write("(");
            WriteQuotedCSharpString(name);
            if (ns != null) {
                writer.Write(", ");
                WriteQuotedCSharpString(ns);
            }
            if (writePrefixed)
                writer.Write(", true");
            writer.WriteLine(");");
        }

        void WriteStartElement(string name, string ns) {
            WriteTag("WriteStartElement", name, ns);
        }

        void WriteStartElement(string name, string ns, bool writePrefixed) {
            WriteTag("WriteStartElement", name, ns, writePrefixed);
        }

        void WriteEndElement() {
            WriteEndElement("");
        }
        void WriteEndElement(string source) {
            writer.Write("WriteEndElement(");
            writer.Write(source);
            writer.WriteLine(");");
        }

        void WriteEncodedNullTag(string name, string ns) {
            WriteTag("WriteNullTagEncoded", name, ns);
        }

        void WriteLiteralNullTag(string name, string ns) {
            WriteTag("WriteNullTagLiteral", name, ns);
        }

        void WriteEmptyTag(string name, string ns) {
            WriteTag("WriteEmptyTag", name, ns);
        }

        string GenerateMembersElement(XmlMembersMapping xmlMembersMapping) {
            ElementAccessor element = xmlMembersMapping.Accessor;
            MembersMapping mapping = (MembersMapping)element.Mapping;
            bool hasWrapperElement = mapping.HasWrapperElement;
            bool writeAccessors = mapping.WriteAccessors;
            bool isRpc = xmlMembersMapping.IsSoap && writeAccessors;
            string methodName = NextMethodName(element.Name);
            writer.WriteLine();
            writer.Write("public void ");
            writer.Write(methodName);
            writer.WriteLine("(object[] p) {");
            writer.Indent++;

            writer.WriteLine("WriteStartDocument();");

            if (!mapping.IsSoap) {
                writer.WriteLine("TopLevelElement();");
            }

            // in the top-level method add check for the parameters length, 
            // because visual basic does not have a concept of an <out> parameter it uses <ByRef> instead
            // so sometime we think that we have more parameters then supplied
            writer.WriteLine("int pLength = p.Length;");

            if (hasWrapperElement) {
                WriteStartElement(element.Name, (element.Form == XmlSchemaForm.Qualified ? element.Namespace : ""), mapping.IsSoap);

                int xmlnsMember = FindXmlnsIndex(mapping.Members);
                if (xmlnsMember >= 0) {
                    MemberMapping member = mapping.Members[xmlnsMember];
                    string source = "((" + typeof(XmlSerializerNamespaces).FullName + ")p[" + xmlnsMember.ToString() + "])";

                    writer.Write("if (pLength > ");
                    writer.Write(xmlnsMember.ToString());
                    writer.WriteLine(") {");
                    writer.Indent++;
                    WriteNamespaces(source);
                    writer.Indent--;
                    writer.WriteLine("}");
                }

                for (int i = 0; i < mapping.Members.Length; i++) {
                    MemberMapping member = mapping.Members[i];
                    
                    if (member.Attribute != null && !member.Ignore) {
                        string source = "p[" + i.ToString() + "]";

                        string specifiedSource = null;
                        int specifiedPosition = 0;
                        if (member.CheckSpecified) {
                            string memberNameSpecified = member.Name + "Specified";
                            for (int j = 0; j < mapping.Members.Length; j++) {
                                if (mapping.Members[j].Name == memberNameSpecified) {
                                    specifiedSource = "((bool) p[" + j.ToString() + "])";
                                    specifiedPosition = j;
                                    break;
                                }
                            }
                        }

                        writer.Write("if (pLength > ");
                        writer.Write(i.ToString());
                        writer.WriteLine(") {");
                        writer.Indent++;

                        if (specifiedSource != null) {
                            writer.Write("if (pLength <= ");
                            writer.Write(specifiedPosition.ToString());
                            writer.Write(" || ");
                            writer.Write(specifiedSource);
                            writer.WriteLine(") {");
                            writer.Indent++;
                        }

                        WriteMember(source, member.Attribute, member.TypeDesc, "p");

                        if (specifiedSource != null) {
                            writer.Indent--;
                            writer.WriteLine("}");
                        }
                        
                        writer.Indent--;
                        writer.WriteLine("}");
                    }
                }
            }
               
            for (int i = 0; i < mapping.Members.Length; i++) {
                MemberMapping member = mapping.Members[i];
                if (member.Xmlns != null)
                    continue;
                if (member.Ignore)
                    continue;
                    
                string specifiedSource = null;
                int specifiedPosition = 0;
                if (member.CheckSpecified) {
                    string memberNameSpecified = member.Name + "Specified";

                    for (int j = 0; j < mapping.Members.Length; j++) {
                        if (mapping.Members[j].Name == memberNameSpecified) {
                            specifiedSource = "((bool) p[" + j.ToString() + "])";
                            specifiedPosition = j;
                            break;
                        }
                    }
                }

                writer.Write("if (pLength > ");
                writer.Write(i.ToString());
                writer.WriteLine(") {");
                writer.Indent++;
               
                if (specifiedSource != null) {
                    writer.Write("if (pLength <= ");
                    writer.Write(specifiedPosition.ToString());
                    writer.Write(" || ");
                    writer.Write(specifiedSource);
                    writer.WriteLine(") {");
                    writer.Indent++;
                }

                string source = "p[" + i.ToString() + "]";
                string enumSource = null;
                if (member.ChoiceIdentifier != null) {
                    for (int j = 0; j < mapping.Members.Length; j++) {
                        if (mapping.Members[j].Name == member.ChoiceIdentifier.MemberName) {
                            enumSource = "((" + CodeIdentifier.EscapeKeywords(member.ChoiceIdentifier.Mapping.TypeDesc.FullName) + ")p[" + j.ToString() + "]" + ")";
                            break;
                        }
                    }

                    #if DEBUG
                        // use exception in the place of Debug.Assert to avoid throwing asserts from a server process such as aspnet_ewp.exe
                        if (enumSource == null) throw new InvalidOperationException(Res.GetString(Res.XmlInternalErrorDetails, "Can not find " + member.ChoiceIdentifier.MemberName + " in the members mapping."));
                    #endif

                }
                
                if (isRpc && member.IsReturnValue && member.Elements.Length > 0) {
                    writer.Write("WriteRpcResult(");
                    WriteQuotedCSharpString(member.Elements[0].Name);
                    writer.Write(", ");
                    WriteQuotedCSharpString("");
                    writer.WriteLine(");");
                }

                // override writeAccessors choice when we've written a wrapper element
                WriteMember(source, enumSource, member.ElementsSortedByDerivation, member.Text, member.ChoiceIdentifier, member.TypeDesc, writeAccessors || hasWrapperElement);

                if (specifiedSource != null) {
                    writer.Indent--;
                    writer.WriteLine("}");
                }
                
                writer.Indent--;
                writer.WriteLine("}");
            }

            if (hasWrapperElement) {
                WriteEndElement();
            }
            if (element.IsSoap) {
                if (!hasWrapperElement && !writeAccessors) {
                    // doc/bare case -- allow extra members
                    writer.Write("if (pLength > ");
                    writer.Write(mapping.Members.Length.ToString());
                    writer.WriteLine(") {");
                    writer.Indent++;
                    
                    WriteExtraMembers(mapping.Members.Length.ToString(), "pLength");
                
                    writer.Indent--;
                    writer.WriteLine("}");
                }
                writer.WriteLine("WriteReferencedElements();");
            }
            writer.Indent--;
            writer.WriteLine("}");
            return methodName;
        }
        
        string GenerateTypeElement(XmlTypeMapping xmlTypeMapping) {
            ElementAccessor element = xmlTypeMapping.Accessor;
            TypeMapping mapping = (TypeMapping)element.Mapping;
            string methodName = NextMethodName(element.Name);
            writer.WriteLine();
            writer.Write("public void ");
            writer.Write(methodName);
            writer.WriteLine("(object o) {");
            writer.Indent++;

            writer.WriteLine("WriteStartDocument();");

            writer.WriteLine("if (o == null) {");
            writer.Indent++;
            if (element.IsNullable){
                if(mapping.IsSoap)
                    WriteEncodedNullTag(element.Name, (element.Form == XmlSchemaForm.Qualified ? element.Namespace : ""));
                else
                    WriteLiteralNullTag(element.Name, (element.Form == XmlSchemaForm.Qualified ? element.Namespace : ""));
            }
            else
                WriteEmptyTag(element.Name, (element.Form == XmlSchemaForm.Qualified ? element.Namespace : ""));
            writer.WriteLine("return;");
            writer.Indent--;
            writer.WriteLine("}");

            if (!mapping.IsSoap) {
                writer.WriteLine("TopLevelElement();");
            }

            WriteMember("o", null, new ElementAccessor[] { element }, null, null, mapping.TypeDesc, !element.IsSoap);

            if (mapping.IsSoap) {
                writer.WriteLine("WriteReferencedElements();");
            }
            writer.Indent--;
            writer.WriteLine("}");
            return methodName;
        }

        string NextMethodName(string name) {
            return "Write" + (++nextMethodNumber).ToString(null, NumberFormatInfo.InvariantInfo) + "_" + CodeIdentifier.MakeValid(name);
        }
        
        void WriteEnumMethod(EnumMapping mapping) {
            string methodName = (string)methodNames[mapping];
            writer.WriteLine();
            string fullTypeName = CodeIdentifier.EscapeKeywords(mapping.TypeDesc.FullName);
            if (mapping.IsSoap) {
                writer.Write("void ");
                writer.Write(methodName);
                writer.WriteLine("(object e) {");
                writer.Write(fullTypeName);
                writer.Write(" v = (");
                writer.Write(fullTypeName);
                writer.Write(")e;");
            }
            else {
                writer.Write("string ");
                writer.Write(methodName);
                writer.Write("(");
                writer.Write(fullTypeName);
                writer.WriteLine(" v) {");
            }
            writer.Indent++;
            writer.WriteLine("string s = null;");
            ConstantMapping[] constants = mapping.Constants;

            if (constants.Length > 0) {
                Hashtable values = new Hashtable();
                writer.WriteLine("switch (v) {");
                writer.Indent++;
                for (int i = 0; i < constants.Length; i++) {
                    ConstantMapping c = constants[i];
                    if (values[c.Value] == null) {
                        CodeIdentifier.CheckValidIdentifier(c.Name);
                        writer.Write("case ");
                        writer.Write(fullTypeName);
                        writer.Write(".@");
                        writer.Write(c.Name);
                        writer.Write(": s = ");
                        WriteQuotedCSharpString(c.XmlName);
                        writer.WriteLine("; break;");
                        values.Add(c.Value, c.Value);
                    }
                }
                

                if (mapping.IsFlags) {
                    writer.Write("default: s = FromEnum((");
                    writer.Write(typeof(long).FullName);
                    writer.Write(")v, new ");
                    writer.Write(typeof(string).FullName);
                    writer.Write("[] {");

                    writer.Indent++;
                    for (int i = 0; i < constants.Length; i++) {
                        ConstantMapping c = constants[i];
                        if (i > 0)
                            writer.WriteLine(", ");
                        WriteQuotedCSharpString(c.XmlName);
                    }
                    writer.Write("}, new ");
                    writer.Write(typeof(long).FullName);
                    writer.Write("[] {");

                    for (int i = 0; i < constants.Length; i++) {
                        ConstantMapping c = constants[i];
                        if (i > 0)
                            writer.WriteLine(", ");
                        writer.Write("(");
                        writer.Write(typeof(long).FullName);
                        writer.Write(")");
                        writer.Write(fullTypeName);
                        writer.Write(".@");
                        CodeIdentifier.CheckValidIdentifier(c.Name);
                        writer.Write(c.Name);
                    }
                    writer.Indent--;
                    writer.WriteLine("}); break;");
                }
                else {
                    writer.Write("default: s = ((");
                    writer.Write(typeof(long).FullName);
                    writer.WriteLine(")v).ToString(); break;");
                }

                writer.Indent--;
                writer.WriteLine("}");
            }
            if (mapping.IsSoap) {
                writer.Write("WriteXsiType(");
                WriteQuotedCSharpString(mapping.TypeName);
                writer.Write(", ");
                WriteQuotedCSharpString(mapping.Namespace);
                writer.WriteLine(");");
                writer.WriteLine("Writer.WriteString(s);");
            }
            else {
                writer.WriteLine("return s;");
            }
            writer.Indent--;
            writer.WriteLine("}");
        }

        void WriteDerivedTypes(StructMapping mapping) {
            for (StructMapping derived = mapping.DerivedMappings; derived != null; derived = derived.NextDerivedMapping) {
                string fullTypeName = CodeIdentifier.EscapeKeywords(derived.TypeDesc.FullName);
                writer.Write("else if (t == typeof(");
                writer.Write(fullTypeName);
                writer.WriteLine(")) {");
                writer.Indent++;

                string methodName = (string)methodNames[derived];

                #if DEBUG
                    // use exception in the place of Debug.Assert to avoid throwing asserts from a server process such as aspnet_ewp.exe
                    if (methodName == null) throw new InvalidOperationException(Res.GetString(Res.XmlInternalErrorMethod, derived.TypeDesc.Name));
                #endif

                writer.Write(methodName);
                writer.Write("(n, ns, (");
                writer.Write(fullTypeName);
                writer.Write(")o");
                if (derived.TypeDesc.IsNullable)
                    writer.Write(", isNullable");
                writer.Write(", true");
                writer.WriteLine(");");
                writer.WriteLine("return;");
                writer.Indent--;
                writer.WriteLine("}");

                WriteDerivedTypes(derived);
            }
        }

        void WriteEnumAndArrayTypes() {
            foreach (TypeScope scope in scopes) {
                foreach (Mapping m in scope.TypeMappings) {
                    if (m is EnumMapping && !m.IsSoap) {
                        EnumMapping mapping = (EnumMapping)m;
                        string fullTypeName = CodeIdentifier.EscapeKeywords(mapping.TypeDesc.FullName);
                        writer.Write("else if (t == typeof(");
                        writer.Write(fullTypeName);
                        writer.WriteLine(")) {");
                        writer.Indent++;

                        string methodName = (string)methodNames[mapping];
                        #if DEBUG
                            // use exception in the place of Debug.Assert to avoid throwing asserts from a server process such as aspnet_ewp.exe
                            if (methodName == null) throw new InvalidOperationException(Res.GetString(Res.XmlInternalErrorMethod, mapping.TypeDesc.Name));
                        #endif
                        writer.WriteLine("Writer.WriteStartElement(n, ns);");
                        writer.Write("WriteXsiType(");
                        WriteQuotedCSharpString(mapping.TypeName);
                        writer.Write(", ");
                        WriteQuotedCSharpString(mapping.Namespace);
                        writer.WriteLine(");");
                        writer.Write("Writer.WriteString(");
                        writer.Write(methodName);
                        writer.Write("((");
                        writer.Write(fullTypeName);
                        writer.WriteLine(")o));");
                        writer.WriteLine("Writer.WriteEndElement();");
                        writer.WriteLine("return;");
                        writer.Indent--;
                        writer.WriteLine("}");
                    }
                    else if (m is ArrayMapping && !m.IsSoap) {
                        ArrayMapping mapping = m as ArrayMapping;
                        if (mapping == null || m.IsSoap) continue;

                        string fullTypeName = CodeIdentifier.EscapeKeywords(mapping.TypeDesc.FullName);
                        writer.Write("else if (t == typeof(");
                        writer.Write(fullTypeName);
                        writer.WriteLine(")) {");
                        writer.Indent++;

                        writer.WriteLine("Writer.WriteStartElement(n, ns);");
                        writer.Write("WriteXsiType(");
                        WriteQuotedCSharpString(mapping.TypeName);
                        writer.Write(", ");
                        WriteQuotedCSharpString(mapping.Namespace);
                        writer.WriteLine(");");

                        WriteMember("o", null, mapping.ElementsSortedByDerivation, null, null, mapping.TypeDesc, true);

                        writer.WriteLine("Writer.WriteEndElement();");
                        writer.WriteLine("return;");
                        writer.Indent--;
                        writer.WriteLine("}");
                    }
                    else if (m is StructMapping) {

                    }
                }
            }
        }
        
        void WriteStructMethod(StructMapping mapping) {
            if (mapping.IsSoap && mapping.TypeDesc.IsRoot) return;

            string methodName = (string)methodNames[mapping];
            writer.WriteLine();
            writer.Write("void ");
            writer.Write(methodName);

            string fullTypeName = CodeIdentifier.EscapeKeywords(mapping.TypeDesc.FullName);

            if (mapping.IsSoap) {
                writer.WriteLine("(object s) {");
                writer.Indent++;
                writer.Write(fullTypeName);
                writer.Write(" o = (");
                writer.Write(fullTypeName);
                writer.WriteLine(")s;");
            }
            else {
                writer.Write("(string n, string ns, ");
                writer.Write(fullTypeName);
                writer.Write(" o");
                if (mapping.TypeDesc.IsNullable)
                    writer.Write(", bool isNullable");
                writer.WriteLine(", bool needType) {");
                writer.Indent++;
                if (mapping.TypeDesc.IsNullable) {
                    writer.WriteLine("if ((object)o == null) {");
                    writer.Indent++;
                    writer.WriteLine("if (isNullable) WriteNullTagLiteral(n, ns);");
                    writer.WriteLine("return;");
                    writer.Indent--;
                    writer.WriteLine("}");
                }
                writer.WriteLine("if (!needType) {");
                writer.Indent++;

                writer.Write(typeof(Type).FullName);
                writer.WriteLine(" t = o.GetType();");
                writer.Write("if (t == typeof(");
                writer.Write(fullTypeName);
                writer.WriteLine("))");
                writer.Indent++;
                writer.WriteLine(";");
                writer.Indent--;
                WriteDerivedTypes(mapping);
                if (mapping.TypeDesc.IsRoot)
                    WriteEnumAndArrayTypes();
                writer.WriteLine("else {");

                writer.Indent++;
                if (mapping.TypeDesc.IsRoot) {
                    writer.WriteLine("WriteTypedPrimitive(n, ns, o, true);");
                    writer.WriteLine("return;");
                }
                else {
                    writer.WriteLine("throw CreateUnknownTypeException(o);");
                }
                writer.Indent--;
                writer.WriteLine("}");
                writer.Indent--;
                writer.WriteLine("}");
            }

            if (!mapping.TypeDesc.IsAbstract) {
                if (!mapping.IsSoap) {
                    writer.WriteLine("WriteStartElement(n, ns, o);");
                    if (!mapping.TypeDesc.IsRoot) {
                        writer.Write("if (needType) WriteXsiType(");
                        WriteQuotedCSharpString(mapping.TypeName);
                        writer.Write(", ");
                        WriteQuotedCSharpString(mapping.Namespace);
                        writer.WriteLine(");");
                    }
                }

                MemberMapping[] members = TypeScope.GetAllMembers(mapping);
                int xmlnsMember = FindXmlnsIndex(members);
                if (xmlnsMember >= 0) {
                    MemberMapping member = members[xmlnsMember];
                    CodeIdentifier.CheckValidIdentifier(member.Name);
                    WriteNamespaces("o.@" + member.Name);
                }
                for (int i = 0; i < members.Length; i++) {
                    MemberMapping m = members[i];
                    if (m.Attribute != null) {
                        CodeIdentifier.CheckValidIdentifier(m.Name);
                        if (m.CheckShouldPersist) {
                            writer.Write("if (o.ShouldSerialize");
                            writer.Write(m.Name);
                            writer.WriteLine("()) {");
                            writer.Indent++;
                        }
                        if (m.CheckSpecified) {
                            writer.Write("if (o.");
                            writer.Write(m.Name);
                            writer.WriteLine("Specified) {");
                            writer.Indent++;
                        }
                        WriteMember("o.@" + m.Name, m.Attribute, m.TypeDesc, "o");

                        if (m.CheckSpecified) {
                            writer.Indent--;
                            writer.WriteLine("}");
                        }
                        if (m.CheckShouldPersist) {
                            writer.Indent--;
                            writer.WriteLine("}");
                        }
                    }
                }
                
                for (int i = 0; i < members.Length; i++) {
                    MemberMapping m = members[i];
                    if (m.Xmlns != null)
                        continue;
                    CodeIdentifier.CheckValidIdentifier(m.Name);
                    bool checkShouldPersist = m.CheckShouldPersist && (m.Elements.Length > 0 || m.Text != null);

                    if (checkShouldPersist) {
                        writer.Write("if (o.ShouldSerialize");
                        writer.Write(m.Name);
                        writer.WriteLine("()) {");
                        writer.Indent++;
                    }
                    if (m.CheckSpecified) {
                        writer.Write("if (o.");
                        writer.Write(m.Name);
                        writer.WriteLine("Specified) {");
                        writer.Indent++;
                    }

                    if (m.ChoiceIdentifier != null)
                        CodeIdentifier.CheckValidIdentifier(m.ChoiceIdentifier.MemberName);
                    string choiceSource = m.ChoiceIdentifier == null ? null : "o.@" + m.ChoiceIdentifier.MemberName;
                    WriteMember("o.@" + m.Name, choiceSource, m.ElementsSortedByDerivation, m.Text, m.ChoiceIdentifier, m.TypeDesc, true);

                    if (m.CheckSpecified) {
                        writer.Indent--;
                        writer.WriteLine("}");
                    }
                    if (checkShouldPersist) {
                        writer.Indent--;
                        writer.WriteLine("}");
                    }
                }
                if (!mapping.IsSoap) {
                    WriteEndElement("o");
                }
            }

            writer.Indent--;
            writer.WriteLine("}");
        }

        bool CanOptimizeWriteListSequence(TypeDesc listElementTypeDesc) {

            // check to see if we can write values of the attribute sequentially
            // currently we have only one data type (XmlQualifiedName) that we can not write "inline", 
            // because we need to output xmlns:qx="..." for each of the qnames

            return (listElementTypeDesc != null && listElementTypeDesc != qnameTypeDesc);
        }

        void WriteMember(string source, AttributeAccessor attribute, TypeDesc memberTypeDesc, string parent) {
            if (memberTypeDesc.IsAbstract) return;
            if (memberTypeDesc.IsArrayLike) {
                writer.WriteLine("{");
                writer.Indent++;
                string fullTypeName = CodeIdentifier.EscapeKeywords(memberTypeDesc.FullName);
                writer.Write(fullTypeName);
                writer.Write(" a = (");
                writer.Write(fullTypeName);
                writer.Write(")");
                writer.Write(source);
                writer.WriteLine(";");

                if (memberTypeDesc.IsNullable) {
                    writer.WriteLine("if (a != null) {");
                    writer.Indent++;
                }
                if (attribute.IsList) {
                    if (CanOptimizeWriteListSequence(memberTypeDesc.ArrayElementTypeDesc)) {
                        writer.Write("Writer.WriteStartAttribute(null, ");
                        WriteQuotedCSharpString(attribute.Name);
                        writer.Write(", ");
                        string ns = attribute.Form == XmlSchemaForm.Qualified ? attribute.Namespace : String.Empty;
                        if (ns != null) {
                            WriteQuotedCSharpString(ns);
                        }
                        else {
                            writer.Write("null");
                        }
                        writer.WriteLine(");");
                    }
                    else {
                        writer.Write(typeof(StringBuilder).FullName);
                        writer.Write(" sb = new ");
                        writer.Write(typeof(StringBuilder).FullName);
                        writer.WriteLine("();");
                    }
                }
                TypeDesc arrayElementTypeDesc = memberTypeDesc.ArrayElementTypeDesc;

                if (memberTypeDesc.IsEnumerable) {
                    writer.Write(typeof(IEnumerator).FullName);
                    writer.WriteLine(" e = a.GetEnumerator();");

                    writer.WriteLine("if (e != null)");
                    writer.WriteLine("while (e.MoveNext()) {");
                    writer.Indent++;

                    string arrayTypeFullName = CodeIdentifier.EscapeKeywords(arrayElementTypeDesc.FullName);
                    writer.Write(arrayTypeFullName);
                    writer.Write(" ai = (");
                    writer.Write(arrayTypeFullName);
                    writer.WriteLine(")e.Current;");
                }
                else {
                    writer.Write("for (int i = 0; i < a.");
                    writer.Write(memberTypeDesc.ArrayLengthName);
                    writer.WriteLine("; i++) {");
                    writer.Indent++;
                    string arrayTypeFullName = CodeIdentifier.EscapeKeywords(arrayElementTypeDesc.FullName);
                    writer.Write(arrayTypeFullName);
                    writer.Write(" ai = (");
                    writer.Write(arrayTypeFullName);
                    writer.WriteLine(")a[i];");
                }
                if (attribute.IsList) {
                    // check to see if we can write values of the attribute sequentially
                    if (CanOptimizeWriteListSequence(memberTypeDesc.ArrayElementTypeDesc)) {
                        writer.WriteLine("if (i != 0) Writer.WriteString(\" \");");
                        writer.Write("WriteValue(");
                    }
                    else {
                        writer.WriteLine("if (i != 0) sb.Append(\" \");");
                        writer.Write("sb.Append(");
                    }
                    if (attribute.Mapping is EnumMapping)
                        WriteEnumValue((EnumMapping)attribute.Mapping, "ai");
                    else
                        WritePrimitiveValue(arrayElementTypeDesc, "ai");
                    writer.WriteLine(");");
                }
                else {
                    WriteAttribute("ai", attribute, parent);
                }
                writer.Indent--;
                writer.WriteLine("}");
                if (attribute.IsList) {
                    // check to see if we can write values of the attribute sequentially
                    if (CanOptimizeWriteListSequence(memberTypeDesc.ArrayElementTypeDesc)) {
                        writer.WriteLine("Writer.WriteEndAttribute();");
                    }
                    else {
                        writer.WriteLine("if (sb.Length != 0) {");
                        writer.Indent++;
                    
                        writer.Write("WriteAttribute(");
                        WriteQuotedCSharpString(attribute.Name);
                        writer.Write(", ");
                        string ns = attribute.Form == XmlSchemaForm.Qualified ? attribute.Namespace : String.Empty;
                        if (ns != null) {
                            WriteQuotedCSharpString(ns);
                            writer.Write(", ");
                        }
                        writer.WriteLine("sb.ToString());");
                        writer.Indent--;
                        writer.WriteLine("}");
                    }
                }

                if (memberTypeDesc.IsNullable) {
                    writer.Indent--;
                    writer.WriteLine("}");
                }
                writer.Indent--;
                writer.WriteLine("}");
            }
            else {
                WriteAttribute(source, attribute, parent);
            }
        }

        void WriteAttribute(string source, AttributeAccessor attribute, string parent) {
            if (attribute.Mapping is SpecialMapping) {
                SpecialMapping special = (SpecialMapping)attribute.Mapping;
                if (special.TypeDesc.Kind == TypeKind.Attribute || special.TypeDesc.CanBeAttributeValue) {
                    writer.Write("WriteXmlAttribute(");
                    writer.Write(source);
                    writer.Write(", ");
                    writer.Write(parent);
                    writer.WriteLine(");");
                }
                else
                    throw new InvalidOperationException(Res.GetString(Res.XmlInternalError));
            }
            else {
                TypeDesc typeDesc = attribute.Mapping.TypeDesc;
                WritePrimitive("WriteAttribute", attribute.Name, attribute.Form == XmlSchemaForm.Qualified ? attribute.Namespace : "", attribute.Default, "(" + CodeIdentifier.EscapeKeywords(typeDesc.FullName) + ")" + source, attribute.Mapping, false);
            }
        }
        
        void WriteMember(string source, string choiceSource, ElementAccessor[] elements, TextAccessor text, ChoiceIdentifierAccessor choice, TypeDesc memberTypeDesc, bool writeAccessors) {
            if (memberTypeDesc.IsArrayLike && 
                !(elements.Length == 1 && elements[0].Mapping is ArrayMapping))
                WriteArray(source, choiceSource, elements, text, choice, memberTypeDesc);
            else
                WriteElements(source, choiceSource, elements, text, choice, "a", writeAccessors, memberTypeDesc.IsNullable);
        }
        
        void WriteArray(string source, string choiceSource, ElementAccessor[] elements, TextAccessor text, ChoiceIdentifierAccessor choice, TypeDesc arrayTypeDesc) {
            if (elements.Length == 0 && text == null) return;
            writer.WriteLine("{");
            writer.Indent++;
            string arrayTypeName = CodeIdentifier.EscapeKeywords(arrayTypeDesc.FullName);
            writer.Write(arrayTypeName);
            writer.Write(" a = (");
            writer.Write(arrayTypeName);
            writer.Write(")");
            writer.Write(source);
            writer.WriteLine(";");
            if (arrayTypeDesc.IsNullable) {
                writer.WriteLine("if (a != null) {");
                writer.Indent++;
            }

            if (choice != null) {
                writer.Write(CodeIdentifier.EscapeKeywords(choice.Mapping.TypeDesc.FullName));
                writer.Write("[] c = ");
                writer.Write(choiceSource);
                writer.WriteLine(";");

                // write check for the choice identifier array
                
                writer.WriteLine("if (c == null || c.Length < a.Length) {");
                writer.Indent--;
                writer.Write("throw CreateInvalidChoiceIdentifierValueException(");
                WriteQuotedCSharpString(choice.Mapping.TypeDesc.FullName);
                writer.Write(", ");
                WriteQuotedCSharpString(choice.MemberName);
                writer.Write(");");
                writer.Indent--;
                writer.WriteLine("}");
            }

            WriteArrayItems(elements, text, choice, arrayTypeDesc, "a", "c");
            if (arrayTypeDesc.IsNullable) {
                writer.Indent--;
                writer.WriteLine("}");
            }
            writer.Indent--;
            writer.WriteLine("}");
        }

        void WriteArrayItems(ElementAccessor[] elements, TextAccessor text, ChoiceIdentifierAccessor choice, TypeDesc arrayTypeDesc, string arrayName, string choiceName) {
            TypeDesc arrayElementTypeDesc = arrayTypeDesc.ArrayElementTypeDesc;

            if (arrayTypeDesc.IsEnumerable) {
                writer.Write(typeof(IEnumerator).FullName);
                writer.Write(" e = ");
                writer.Write(arrayName);
                writer.WriteLine(".GetEnumerator();");
                writer.WriteLine("if (e != null)");
                writer.WriteLine("while (e.MoveNext()) {");
                writer.Indent++;
                string arrayElementTypeName = CodeIdentifier.EscapeKeywords(arrayElementTypeDesc.FullName);
                writer.Write(arrayElementTypeName);
                writer.Write(" ");
                writer.Write(arrayName);
                writer.Write("i = (");
                writer.Write(arrayElementTypeName);
                writer.WriteLine(")e.Current;");
                WriteElements(arrayName + "i", choiceName + "i", elements, text, choice, arrayName + "a", true, true);
            }
            else {
                writer.Write("for (int i");
                writer.Write(arrayName);
                writer.Write(" = 0; i");
                writer.Write(arrayName);
                writer.Write(" < ");
                writer.Write(arrayName);
                writer.Write(".");
                writer.Write(arrayTypeDesc.ArrayLengthName);
                writer.Write("; i");
                writer.Write(arrayName);
                writer.WriteLine("++) {");
                writer.Indent++;
                int count = elements.Length + (text == null ? 0 : 1);
                if (count > 1) {
                    writer.Write(CodeIdentifier.EscapeKeywords(arrayElementTypeDesc.FullName));
                    writer.Write(" ");
                    writer.Write(arrayName);
                    writer.Write("i = ");
                    writer.Write(arrayName);
                    writer.Write("[i");
                    writer.Write(arrayName);
                    writer.WriteLine("];");
                    if (choice != null) {
                        writer.Write(CodeIdentifier.EscapeKeywords(choice.Mapping.TypeDesc.FullName));
                        writer.Write(" ");
                        writer.Write(choiceName);
                        writer.Write("i = ");
                        writer.Write(choiceName);
                        writer.Write("[i");
                        writer.Write(arrayName);
                        writer.WriteLine("];");
                    }
                    WriteElements(arrayName + "i", choiceName + "i", elements, text, choice, arrayName + "a", true, arrayElementTypeDesc.IsNullable);
                }
                else {
                    WriteElements(arrayName + "[i" + arrayName + "]", elements, text, choice, arrayName + "a", true, arrayElementTypeDesc.IsNullable);
                }
            }
            writer.Indent--;
            writer.WriteLine("}");
        }
        
        void WriteElements(string source, ElementAccessor[] elements, TextAccessor text, ChoiceIdentifierAccessor choice, string arrayName, bool writeAccessors, bool isNullable) {
            WriteElements(source, null, elements, text, choice, arrayName, writeAccessors, isNullable);
        }

        void WriteElements(string source, string enumSource, ElementAccessor[] elements, TextAccessor text, ChoiceIdentifierAccessor choice, string arrayName, bool writeAccessors, bool isNullable) {
            if (elements.Length == 0 && text == null) return;
            if (elements.Length == 1 && text == null) {
                WriteElement("((" + CodeIdentifier.EscapeKeywords(((TypeMapping)elements[0].Mapping).TypeDesc.FullName) + ")" + source + ")", elements[0], arrayName, writeAccessors);
            }
            else {

                writer.WriteLine("{");
                writer.Indent++;
                int anyCount = 0;
                ArrayList namedAnys = new ArrayList();
                ElementAccessor unnamedAny = null; // can only have one
                bool wroteFirstIf = false;
                string enumTypeName = choice == null ? null : CodeIdentifier.EscapeKeywords(choice.Mapping.TypeDesc.FullName);

                for (int i = 0; i < elements.Length; i++) {
                    ElementAccessor element = elements[i];

                    if (element.Any) {
                        anyCount++;
                        if (element.Name != null && element.Name.Length > 0)
                            namedAnys.Add(element);
                        else if (unnamedAny == null)
                            unnamedAny = element;
                    }
                    else if (choice != null) {
                        string fullTypeName = CodeIdentifier.EscapeKeywords(((TypeMapping)element.Mapping).TypeDesc.FullName);
                        string enumFullName = enumTypeName + ".@" + FindChoiceEnumValue(element, (EnumMapping)choice.Mapping);

                        if (wroteFirstIf) writer.Write("else ");
                        else wroteFirstIf = true;
                        writer.Write("if (");
                        writer.Write(enumSource);
                        writer.Write(" == ");
                        writer.Write(enumFullName);
                        writer.WriteLine(") {");
                        writer.Indent++;

                        WriteChoiceTypeCheck(source, fullTypeName, choice, enumFullName);

                        WriteElement("((" + fullTypeName + ")" + source + ")", element, arrayName, writeAccessors);
                        writer.Indent--;
                        writer.WriteLine("}");
                    }
                    else {
                        string fullTypeName = CodeIdentifier.EscapeKeywords(((TypeMapping)element.Mapping).TypeDesc.FullName);
                        if (wroteFirstIf) writer.Write("else ");
                        else wroteFirstIf = true;
                        writer.Write("if (");
                        writer.Write(source);
                        writer.Write(" is ");
                        writer.Write(fullTypeName);
                        writer.WriteLine(") {");
                        writer.Indent++;
                        WriteElement("((" + fullTypeName + ")" + source + ")", element, arrayName, writeAccessors);
                        writer.Indent--;
                        writer.WriteLine("}");
                    }
                }
                if (anyCount > 0) {
                    if (elements.Length - anyCount > 0) writer.Write("else ");
                    
                    string fullTypeName = typeof(XmlElement).FullName;

                    writer.Write("if (");
                    writer.Write(source);
                    writer.Write(" is ");
                    writer.Write(fullTypeName);
                    writer.WriteLine(") {");
                    writer.Indent++;

                    writer.Write(fullTypeName);
                    writer.Write(" elem = (");
                    writer.Write(fullTypeName);
                    writer.Write(")");
                    writer.Write(source);
                    writer.WriteLine(";");
                    
                    int c = 0;

                    foreach (ElementAccessor element in namedAnys) {
                        if (c++ > 0) writer.Write("else ");

                        string enumFullName = null;

                        if (choice != null) {
                            enumFullName = enumTypeName + ".@" + FindChoiceEnumValue(element, (EnumMapping)choice.Mapping);
                            writer.Write("if (");
                            writer.Write(enumSource);
                            writer.Write(" == ");
                            writer.Write(enumFullName);
                            writer.WriteLine(") {");
                            writer.Indent++;
                        }
                        writer.Write("if (elem.Name == ");
                        WriteQuotedCSharpString(element.Name);
                        writer.Write(" && elem.NamespaceURI == ");
                        WriteQuotedCSharpString(element.Namespace);
                        writer.WriteLine(") {");
                        writer.Indent++;
                        WriteElement("elem", element, arrayName, writeAccessors);

                        if (choice != null) {
                            writer.Indent--;
                            writer.WriteLine("}");
                            writer.WriteLine("else {");
                            writer.Indent++;

                            writer.WriteLine("// throw Value '{0}' of the choice identifier '{1}' does not match element '{2}' from namespace '{3}'.");
                            
                            writer.Write("throw CreateChoiceIdentifierValueException(");
                            WriteQuotedCSharpString(enumFullName);
                            writer.Write(", ");
                            WriteQuotedCSharpString(choice.MemberName);
                            writer.WriteLine(", elem.Name, elem.NamespaceURI);");
                            writer.Indent--;
                            writer.WriteLine("}");
                        }
                        writer.Indent--;
                        writer.WriteLine("}");
                    }
                    if (c > 0) {
                        writer.WriteLine("else {");
                        writer.Indent++;
                    }
                    if (unnamedAny != null) {
                        WriteElement("elem", unnamedAny, arrayName, writeAccessors);
                    }
                    else {
                        writer.WriteLine("throw CreateUnknownAnyElementException(elem.Name, elem.NamespaceURI);");
                    }
                    if (c > 0) {
                        writer.Indent--;
                        writer.WriteLine("}");
                    }
                    writer.Indent--;
                    writer.WriteLine("}");
                }
                if (text != null) {
                    string fullTypeName = CodeIdentifier.EscapeKeywords(text.Mapping.TypeDesc.FullName);
                    if (elements.Length > 0) {
                        writer.Write("else ");
                        writer.Write("if (");
                        writer.Write(source);
                        writer.Write(" is ");
                        writer.Write(fullTypeName);
                        writer.WriteLine(") {");
                        writer.Indent++;
                        WriteText("((" + fullTypeName + ")" + source + ")", text);
                        writer.Indent--;
                        writer.WriteLine("}");
                    }
                    else {
                        WriteText("((" + fullTypeName + ")" + source + ")", text);
                    }
                }
                if (elements.Length > 0) {
                    writer.WriteLine("else {");

                    writer.Indent++;
                    if (isNullable) {
                        writer.Write("if (");
                        writer.Write(source);
                        writer.WriteLine(" != null) {");
                        writer.Indent++;
                    }
                    writer.Write("throw CreateUnknownTypeException(");
                    writer.Write(source);
                    writer.WriteLine(");");
                    if (isNullable) {
                        writer.Indent--;
                        writer.WriteLine("}");
                    }
                    writer.Indent--;
                    writer.WriteLine("}");
                }
                writer.Indent--;
                writer.WriteLine("}");
            }
        }

        void WriteText(string source, TextAccessor text) {
            if (text.Mapping is PrimitiveMapping) {
                PrimitiveMapping mapping = (PrimitiveMapping)text.Mapping;
                writer.Write("WriteValue(");
                if (text.Mapping is EnumMapping) {
                    WriteEnumValue((EnumMapping)text.Mapping, source);
                }
                else {
                    WritePrimitiveValue(mapping.TypeDesc, source);
                }
                writer.WriteLine(");");
            }
            else if (text.Mapping is SpecialMapping) {
                SpecialMapping mapping = (SpecialMapping)text.Mapping;
                switch (mapping.TypeDesc.Kind) {
                    case TypeKind.Node:
                        writer.Write(source);
                        writer.WriteLine(".WriteTo(Writer);");
                        break;
                    default:
                        throw new InvalidOperationException(Res.GetString(Res.XmlInternalError));
                }
            }
        }
        
        void WriteElement(string source, ElementAccessor element, string arrayName, bool writeAccessor) {
            string name = writeAccessor ? element.Name : element.Mapping.TypeName;
            string ns = element.Any && element.Name.Length == 0 ? null : (element.Form == XmlSchemaForm.Qualified ? (writeAccessor ? element.Namespace : element.Mapping.Namespace) : "");
            if (element.Mapping is ArrayMapping) {
                ArrayMapping mapping = (ArrayMapping)element.Mapping;
                if (mapping.IsSoap) {
                    writer.Write("WritePotentiallyReferencingElement(");
                    WriteQuotedCSharpString(name);
                    writer.Write(", ");
                    WriteQuotedCSharpString(ns);
                    writer.Write(", ");
                    writer.Write(source);
                    if (!writeAccessor) {
                        writer.Write(", typeof(");
                        writer.Write(CodeIdentifier.EscapeKeywords(element.Mapping.TypeDesc.FullName));
                        writer.Write("), true, ");
                    }
                    else {
                        writer.Write(", null, false, ");
                    }
                    WriteValue(element.IsNullable);
                    writer.WriteLine(");");
                }
                else {
                    string fullTypeName = CodeIdentifier.EscapeKeywords(mapping.TypeDesc.FullName);
                    writer.WriteLine("{");
                    writer.Indent++;
                    writer.Write(fullTypeName);
                    writer.Write(" ");
                    writer.Write(arrayName);
                    writer.Write(" = (");
                    writer.Write(fullTypeName);
                    writer.Write(")");
                    writer.Write(source);
                    writer.WriteLine(";");
                    if (element.IsNullable) {
                        WriteNullCheckBegin(arrayName, element);
                    }
                    else {
                        if (mapping.TypeDesc.IsNullable) {
                            writer.Write("if (");
                            writer.Write(arrayName);
                            writer.Write(" != null)");
                        }
                        writer.WriteLine("{");
                        writer.Indent++;
                    }
                    WriteStartElement(name, ns);
                    WriteArrayItems(mapping.ElementsSortedByDerivation, null, null, mapping.TypeDesc, arrayName, null);
                    WriteEndElement();
                    writer.Indent--;
                    writer.WriteLine("}");
                    writer.Indent--;
                    writer.WriteLine("}");
                }
            }
            else if (element.Mapping is EnumMapping) {
                if (element.Mapping.IsSoap) {
                    string methodName = (string)methodNames[element.Mapping];
                    writer.Write("Writer.WriteStartElement(");
                    WriteQuotedCSharpString(name);
                    writer.Write(", ");
                    WriteQuotedCSharpString(ns);
                    writer.WriteLine(");");
                    writer.Write(methodName);
                    writer.Write("(");
                    writer.Write(source);
                    writer.WriteLine(");");
                    WriteEndElement();
                }
                else {
                    WritePrimitive("WriteElementString", name, ns, element.Default, source, (TypeMapping)element.Mapping, false);
                }
            }
            else if (element.Mapping is PrimitiveMapping) {
                PrimitiveMapping mapping = (PrimitiveMapping)element.Mapping;
                if (mapping.TypeDesc == qnameTypeDesc)
                    WriteQualifiedNameElement(name, ns, element.Default, source, element.IsNullable, mapping.IsSoap, mapping);
                else {
                    string suffixNullable = mapping.IsSoap ? "Encoded" : "Literal";
                    string suffixRaw = mapping.TypeDesc.XmlEncodingNotRequired?"Raw":"";
                    WritePrimitive(element.IsNullable ? ("WriteNullableString" + suffixNullable + suffixRaw) : ("WriteElementString" + suffixRaw),
                                   name, ns, element.Default, source, mapping, mapping.IsSoap);
                }
            }
            else if (element.Mapping is StructMapping) {
                StructMapping mapping = (StructMapping)element.Mapping;

                if (mapping.IsSoap) {
                    writer.Write("WritePotentiallyReferencingElement(");
                    WriteQuotedCSharpString(name);
                    writer.Write(", ");
                    WriteQuotedCSharpString(ns);
                    writer.Write(", ");
                    writer.Write(source);
                    if (!writeAccessor) {
                        writer.Write(", typeof(");
                        writer.Write(CodeIdentifier.EscapeKeywords(element.Mapping.TypeDesc.FullName));
                        writer.Write("), true, ");
                    }
                    else {
                        writer.Write(", null, false, ");
                    }
                    WriteValue(element.IsNullable);
                }
                else {
                    string methodName = (string)methodNames[mapping];
                    #if DEBUG
                        // use exception in the place of Debug.Assert to avoid throwing asserts from a server process such as aspnet_ewp.exe
                        if (methodName == null) throw new InvalidOperationException(Res.GetString(Res.XmlInternalErrorMethod, ((TypeMapping)element.Mapping).TypeDesc.Name));
                    #endif
                    writer.Write(methodName);
                    writer.Write("(");
                    WriteQuotedCSharpString(name);
                    writer.Write(", ");
                    if (ns == null)
                        writer.Write("null");
                    else {
                        WriteQuotedCSharpString(ns);
                    }
                    writer.Write(", ");
                    writer.Write(source);
                    if (mapping.TypeDesc.IsNullable) {
                        writer.Write(", ");
                        WriteValue(element.IsNullable);
                    }
                    writer.Write(", false");
                }
                writer.WriteLine(");");
            }
            else if (element.Mapping is SpecialMapping) {
                SpecialMapping mapping = (SpecialMapping)element.Mapping;
                switch (mapping.TypeDesc.Kind) {
                    case TypeKind.Node:
                        writer.Write("WriteElementLiteral(");
                        writer.Write(source);
                        writer.Write(", ");
                        WriteQuotedCSharpString(name);
                        writer.Write(", ");
                        WriteQuotedCSharpString(ns);
                        writer.Write(", ");
                        WriteValue(element.IsNullable);
                        writer.Write(", ");
                        WriteValue(element.Any);
                        writer.WriteLine(");");
                        break;
                    case TypeKind.Serializable:
                        writer.Write("WriteSerializable(");
                        writer.Write(source);
                        writer.Write(", ");
                        WriteQuotedCSharpString(name);
                        writer.Write(", ");
                        WriteQuotedCSharpString(ns);
                        writer.Write(", ");
                        WriteValue(element.IsNullable);
                        writer.WriteLine(");");
                        break;
                    default:
                        throw new InvalidOperationException(Res.GetString(Res.XmlInternalError));
                }
            }
            else {
                throw new InvalidOperationException(Res.GetString(Res.XmlInternalError));
            }
        }
        void WriteChoiceTypeCheck(string source, string fullTypeName, ChoiceIdentifierAccessor choice, string enumName) {
            // CONSIDER: elenak it would be nice to have the Declaring type here, for error reporting

            writer.Write("if (((object)");
            writer.Write(source);
            writer.Write(") != null && !(");
            writer.Write(source);
            writer.Write(" is ");
            writer.Write(fullTypeName);
            writer.Write(")) throw CreateMismatchChoiceException(");
            WriteQuotedCSharpString(fullTypeName);
            writer.Write(", ");
            WriteQuotedCSharpString(choice.MemberName);
            writer.Write(", ");
            WriteQuotedCSharpString(enumName);
            writer.WriteLine(");");
        }

        void WriteNullCheckBegin(string source, ElementAccessor element) {
            writer.Write("if ((object)(");
            writer.Write(source);
            writer.WriteLine(") == null) {");
            writer.Indent++;
            WriteLiteralNullTag(element.Name, element.Form == XmlSchemaForm.Qualified ? element.Namespace : "");
            writer.Indent--;
            writer.WriteLine("}");
            writer.WriteLine("else {");
            writer.Indent++;
        }

        void WriteValue(object value) {
            if (value == null) {
                writer.Write("null");
            }
            else {
                Type type = value.GetType();

                switch (Type.GetTypeCode(type)) {
                case TypeCode.String:
                    {
                        string s = (string)value;
                        WriteQuotedCSharpString(s);
                    }
                    break;
                case TypeCode.Char:
                    {
                        writer.Write('\'');
                        char ch = (char)value;
                        if (ch == '\'') 
                            writer.Write("\'");
                        else
                            writer.Write(ch);
                        writer.Write('\'');
                    }
                    break;
                case TypeCode.Int32:
                    writer.Write(((Int32)value).ToString(null, NumberFormatInfo.InvariantInfo));
                    break;
                case TypeCode.Double:
                    writer.Write(((Double)value).ToString("R", NumberFormatInfo.InvariantInfo));
                    break;
                case TypeCode.Boolean:
                    writer.Write((bool)value ? "true" : "false");
                    break;
                case TypeCode.Int16:
                case TypeCode.Int64:
                case TypeCode.UInt16:
                case TypeCode.UInt32:
                case TypeCode.UInt64:
                case TypeCode.Byte:
                case TypeCode.SByte:
                    writer.Write("(");
                    writer.Write(type.FullName);
                    writer.Write(")");
                    writer.Write("(");
                    writer.Write(Convert.ToString(value, NumberFormatInfo.InvariantInfo));
                    writer.Write(")");
                    break;
                case TypeCode.Single:
                    writer.Write(((Single)value).ToString("R", NumberFormatInfo.InvariantInfo));
                    writer.Write("f");
                    break;
                case TypeCode.Decimal:
                    writer.Write(((Decimal)value).ToString(null, NumberFormatInfo.InvariantInfo));
                    writer.Write("m");
                    break;
                case TypeCode.DateTime:
                    writer.Write(" new ");
                    writer.Write(type.FullName);
                    writer.Write("(");
                    writer.Write(((DateTime)value).Ticks.ToString());
                    writer.Write(")");
                    break;
                default:
                    if (type.IsEnum) {
                        writer.Write(((int)value).ToString(null, NumberFormatInfo.InvariantInfo));
                    }
                    else {
                        throw new InvalidOperationException(Res.GetString(Res.XmlUnsupportedDefaultType, type.FullName));
                    }
                    break;
                }
            }
        }

        void WriteNamespaces(string source) {
            writer.Write("WriteNamespaceDeclarations(");
            writer.Write(source);
            writer.WriteLine(");");
        }

        int FindXmlnsIndex(MemberMapping[] members) {
            for (int i = 0; i < members.Length; i++) {
                if (members[i].Xmlns == null)
                    continue;
                return i;
            }
            return -1;
        }

        void WriteExtraMembers(string loopStartSource, string loopEndSource) {
            writer.Write("for (int i = ");
            writer.Write(loopStartSource);
            writer.Write("; i < ");
            writer.Write(loopEndSource);
            writer.WriteLine("; i++) {");
            writer.Indent++;
            writer.WriteLine("if (p[i] != null) {");
            writer.Indent++;
            writer.WriteLine("WritePotentiallyReferencingElement(null, null, p[i], p[i].GetType(), true, false);");
            writer.Indent--;
            writer.WriteLine("}");
            writer.Indent--;
            writer.WriteLine("}");
        }

        string FindChoiceEnumValue(ElementAccessor element, EnumMapping choiceMapping) {
            string enumValue = null;

            for (int i = 0; i < choiceMapping.Constants.Length; i++) {
                string xmlName = choiceMapping.Constants[i].XmlName;

                if (element.Any && element.Name.Length == 0) {
                    if (xmlName == "##any:") {
                        enumValue = choiceMapping.Constants[i].Name;
                        break;
                    }
                    continue;
                }
                int colon = xmlName.LastIndexOf(':');
                string choiceNs = colon < 0 ? choiceMapping.Namespace : xmlName.Substring(0, colon);
                string choiceName = colon < 0 ? xmlName : xmlName.Substring(colon+1);

                if (element.Name == choiceName && element.Namespace == choiceNs) {
                    enumValue = choiceMapping.Constants[i].Name;
                    break;
                }
            }
            if (enumValue == null || enumValue.Length == 0) {
                if (element.Any && element.Name.Length == 0) {
                    // Type {0} is missing enumeration value '##any' for XmlAnyElementAttribute.
                    throw new InvalidOperationException(Res.GetString(Res.XmlChoiceMissingAnyValue, choiceMapping.TypeDesc.FullName));
                }
                // Type {0} is missing value for '{1}'.
                throw new InvalidOperationException(Res.GetString(Res.XmlChoiceMissingValue, choiceMapping.TypeDesc.FullName, element.Namespace + ":" + element.Name, element.Name, element.Namespace));
            }
            CodeIdentifier.CheckValidIdentifier(enumValue);
            return enumValue;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xpath\absolutequery.cs ===
//------------------------------------------------------------------------------
// <copyright file="AbsoluteQuery.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.XPath {
    using System.Xml;
    using System.Diagnostics;

    internal sealed class AbsoluteQuery : XPathSelfQuery {
        internal AbsoluteQuery() : base() {
        }

        internal override void setContext( XPathNavigator e) {
            Debug.Assert(e != null);
            e = e.Clone();
            e.MoveToRoot();
            base.setContext( e);
        }
        
        internal override XPathNavigator advance() {
            if (_e != null) {
                if (first) {
                    first = false;
                    return _e;
                }
                else
                    return null;
            }
            return null;
        }
        
        private AbsoluteQuery(IQuery qyInput) {
            m_qyInput = qyInput;
        }

        internal override XPathNavigator MatchNode(XPathNavigator context) {
            if (context != null && context.NodeType == XPathNodeType.Root)
                return context;
            return null;
        }

        internal override IQuery Clone() {
            IQuery query = new AbsoluteQuery(CloneInput());
            if ( _e != null ) {
                query.setContext(_e);
            }
            return query;
        }
        internal override Querytype getName() {
            return Querytype.Root;
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xpath\andexpr.cs ===
//------------------------------------------------------------------------------
// <copyright file="AndExpr.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.XPath {
    using System.Xml; 
    using System.Xml.Xsl;

    internal sealed class AndExpr : IQuery {
        private BooleanFunctions _opnd1;
        private BooleanFunctions _opnd2;

        AndExpr() {
        }

        internal AndExpr( IQuery  opnd1, IQuery  opnd2) {
            _opnd1 = new BooleanFunctions(opnd1);
            _opnd2 = new BooleanFunctions(opnd2);
        }

        private AndExpr(BooleanFunctions opnd1, BooleanFunctions opnd2) {
            _opnd1 = opnd1;
            _opnd2 = opnd2;
        }

        internal override object getValue(XPathNavigator  qyContext, XPathNodeIterator iterator) {
            Boolean n1= Convert.ToBoolean(_opnd1.getValue(qyContext, iterator));
            if (!n1)
                return n1;
            return _opnd2.getValue(qyContext, iterator);
        }

        internal override object getValue(IQuery  qyContext) {
            Boolean n1= Convert.ToBoolean(_opnd1.getValue(qyContext));
            if (!n1)
                return n1;
            return _opnd2.getValue(qyContext);
        }

        internal override XPathResultType ReturnType() {
            return XPathResultType.Boolean;
        }

        internal override void reset() {
            _opnd1.reset();
            _opnd2.reset();
        }

        internal override IQuery Clone() {
            return new AndExpr(_opnd1.Clone(), _opnd2.Clone());
        }
        
        internal override void SetXsltContext(XsltContext context){
            _opnd1.SetXsltContext(context);
            _opnd2.SetXsltContext(context);            
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xpath\attributequery.cs ===
//------------------------------------------------------------------------------
// <copyright file="AttributeQuery.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.XPath {
    using System.Xml; 


    internal sealed class AttributeQuery : BaseAxisQuery {
        private int _count = 0;

        internal AttributeQuery(
                               IQuery qyParent,
                               String Name, 
                               String Prefix,
                               String URN,
                               XPathNodeType Type) : base(qyParent, Name, Prefix, URN, Type) {
        }


        internal override void reset() {
            _count = 0;
            base.reset();
        }

        internal override XPathNavigator advance() {
            while (true) {
                if (_count == 0) {
                    m_eNext = m_qyInput.advance();
                    if (m_eNext == null)
                        return null;
                    m_eNext = m_eNext.Clone();
                    if (m_eNext.MoveToFirstAttribute())
                        _count = 1;
                    _position = 0;

                }
                else
                    if (! m_eNext.MoveToNextAttribute())
                    _count = 0;
                else
                    _count++;

                if (_count != 0) {
                    System.Diagnostics.Debug.Assert(! m_eNext.NamespaceURI.Equals("http://www.w3.org/2000/xmlns/"));
                    if (matches(m_eNext)) {
                        _position++;
                        return m_eNext;
                    }
                }

            } // while

        } // Advance

        override internal XPathNavigator MatchNode(XPathNavigator context) {
            if (context != null) {
                if (m_Type != XPathNodeType.All && matches(context)) {
                    XPathNavigator temp = context.Clone();
                    if (temp.MoveToParent()) {
                        if (m_qyInput != null)
                            return m_qyInput.MatchNode(temp);
                        return temp;
                    }
                    else
                        return null;
                }
            }
            return null;
        } 
        internal override Querytype getName() {
            return Querytype.Attribute;
        }  

        internal override IQuery Clone() {
            return new AttributeQuery(CloneInput(),m_Name,m_Prefix,m_URN,m_Type);
        }


    } // Attribute Query

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xpath\axis.cs ===
//------------------------------------------------------------------------------
// <copyright file="Axis.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.XPath {
    internal class Axis : AstNode {
        internal static readonly String[] str = {
            "Ancestor",
            "AncestorOrSelf",
            "Attribute",
            "Child",
            "Descendant",
            "DescendantOrSelf",
            "Following",
            "FollowingSibling",
            "Namespace",
            "Parent",
            "Preceding",
            "PrecedingSibling",
            "Self"
        };

        internal AxisType _axistype;
        internal AstNode _input;
        internal String _urn = string.Empty;
        internal String _prefix;
        internal String _name;
        internal XPathNodeType _nodetype;
        internal bool abbrAxis;

        internal enum AxisType {
            Ancestor=0,
            AncestorOrSelf,
            Attribute,
            Child,
            Descendant,
            DescendantOrSelf,
            Following,
            FollowingSibling,
            Namespace,
            Parent,
            Preceding,
            PrecedingSibling,
            Self,
            None
        };

        // constructor
        internal Axis(
                     AxisType axistype,
                     AstNode input,
                     String prefix,
                     String name,
                     XPathNodeType nodetype) {
            _axistype = axistype;
            _input = input;
            _prefix = prefix;
            _name = name;
            _nodetype = nodetype;
        }

        // constructor
        internal Axis(AxisType axistype, AstNode input) {
            _axistype = axistype;
            _input = input;
            _prefix = String.Empty;
            _name = String.Empty;
            _nodetype =  XPathNodeType.All;
            this.abbrAxis = true;
        }
        internal Axis () {
        }

        internal override QueryType TypeOfAst {
            get {return  QueryType.Axis;}
        }

        internal override XPathResultType ReturnType {
            get {return XPathResultType.NodeSet;}
        }

        internal AstNode Input {
            get {return _input;}
            set {_input = value;}
        }

        internal string URN {
            get {return _urn;}
        }

        internal string Prefix {
            get {return _prefix;}
        }

        internal string Name {
            get {return _name;}
        }

        internal XPathNodeType Type {
            get {return _nodetype;}
        }

        internal AxisType TypeOfAxis {
            get {return _axistype;}
        }

        internal string AxisName {
            get {return str[(int)_axistype];}
        }

        internal override double DefaultPriority {
            get {
                if (_input != null)
                    return 0.5;
                if (_axistype == AxisType.Child|| _axistype == AxisType.Attribute) {

                    if (_name != null && _name.Length != 0)
                        return 0;
                    if (_prefix != null && _prefix.Length != 0)
                        return -0.25;
                    return -0.5;
                }
                return 0.5;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xpath\astnode.cs ===
//------------------------------------------------------------------------------
// <copyright file="AstNode.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.XPath
{
    using System;
    using System.Diagnostics;

    internal  class   AstNode 
    {
        internal enum QueryType
        {
            Axis            ,
            Operator        ,
            Filter          ,
            ConstantOperand ,
            Function        ,
            Group           ,
            Root            ,
            Variable        ,        
            Error           
        };


        static internal AstNode NewAstNode(String parsestring)
        {
            try {
                return (XPathParser.ParseXPathExpresion(parsestring));
            }
            catch (XPathException e)
            {
                Debug.WriteLine(e.Message);
            }
            return null;
        }
        
        internal virtual  QueryType TypeOfAst {  
            get {return QueryType.Error;}
        }
        
        internal virtual  XPathResultType ReturnType {
            get {return XPathResultType.Error;}
        }

        internal virtual double DefaultPriority {
            get {return 0.5;}
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xpath\asttree.cs ===
//------------------------------------------------------------------------------
// <copyright file="asttree.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.XPath {
    using System;
    using System.IO;
    using System.Collections;
    using System.Xml;
    using System.Xml.Schema;

    /*--------------------------------------------------------------------------------------------- *
     * Dynamic Part Below...                                                                        *
     * -------------------------------------------------------------------------------------------- */

    // stack element class
    // this one needn't change, even the parameter in methods
    internal class AxisElement {
        internal DoubleLinkAxis curNode;                // current under-checking node during navigating
        internal int rootDepth;                         // root depth -- contextDepth + 1 if ! isDss; context + {1...} if isDss
        internal int curDepth;                          // current depth
        internal bool isMatch;                          // current is already matching or waiting for matching

        internal DoubleLinkAxis CurNode {
            get { return this.curNode; }
        }
            
        internal int RootDepth {
            get { return this.rootDepth; }
        }
        internal int CurDepth {
            get { return this.curDepth; }
        }

        internal string CurName {
            get { return this.curNode.Name; }
        }

        internal string CurPrefix {
            get { return this.curNode.Prefix; }
        }

        internal string CurURN {
            get { return this.curNode.URN; }
        }

        // constructor
        internal AxisElement (DoubleLinkAxis node, int depth) {
            this.curNode = node;
            this.rootDepth = this.curDepth = depth;
            this.isMatch = false;
        }

        internal void SetDepth (int depth) {
            this.rootDepth = this.curDepth = depth;
            return;
        }

        // "a/b/c"     pointer from b move to a
        // needn't change even tree structure changes
        internal void MoveToParent(int depth, ForwardAxis parent) {
            // "a/b/c", trying to match b (current node), but meet the end of a, so move pointer to a
            if ( depth == this.curDepth - 1 ) {
                // really need to move the current node pointer to parent
                // what i did here is for seperating the case of IsDss or only IsChild
                // bcoz in the first case i need to expect "a" from random depth
                // -1 means it doesn't expect some specific depth (referecing the dealing to -1 in movetochild method
                // while in the second case i can't change the root depth which is 1.
                if ((this.curNode.Input == parent.RootNode ) && (parent.IsDss)) {
                    this.curNode = parent.RootNode;
                    this.rootDepth = this.curDepth = -1;
                    return;
                }
                else if (this.curNode.Input != null) {      // else cur-depth --, cur-node change
                    this.curNode = (DoubleLinkAxis) (this.curNode.Input);
                    this.curDepth --;
                    return;
                }
                else return;
            }
            // "a/b/c", trying to match b (current node), but meet the end of x (another child of a)
            // or maybe i matched, now move out the current node
            // or move out after failing to match attribute
            // the node i m next expecting is still the current node
            else if (depth == this.curDepth) {              // after matched or [2] failed in matching attribute
                if (this.isMatch) {
                    this.isMatch = false;   
                }
            }
            return;                                         // this node is still what i am expecting
            // ignore
        }

        // equal & ! attribute then move
        // "a/b/c"     pointer from a move to b
        // return true if reach c and c is an element and c is the axis
        internal bool MoveToChild(string name, string URN, int depth, ForwardAxis parent) { 
            // an attribute can never be the same as an element
            if (Asttree.IsAttribute(this.curNode)) {
                return false; 
            }

            // either moveToParent or moveToChild status will have to be changed into unmatch...
            if (this.isMatch) {
                this.isMatch = false;    
            }
            if (! AxisStack.Equal (this.curNode.Name, this.curNode.URN, name, URN)) {
                return false; 
            }
            if (this.curDepth == -1) {
                SetDepth (depth); 
            }
            else if (depth > this.curDepth) {
                return false; 
            }
            // matched ...  
            if (this.curNode == parent.TopNode) {
                this.isMatch = true;
                return true;                
            }
            // move down this.curNode
            DoubleLinkAxis nowNode = (DoubleLinkAxis) (this.curNode.Next);
            if (Asttree.IsAttribute (nowNode)) {
                this.isMatch = true;                    // for attribute 
                return false;
            }
            this.curNode = nowNode;
            this.curDepth ++;
            return false;
        }

    }

    internal class AxisStack {
        // property
        private ArrayList stack;                            // of AxisElement
        private ForwardAxis subtree;                        // reference to the corresponding subtree
        private ActiveAxis parent;

        internal ForwardAxis Subtree {
            get { return this.subtree; }
        }

        internal int Length {                               // stack length
            get {return this.stack.Count; }
        }
    
        // instructor
        public AxisStack (ForwardAxis faxis, ActiveAxis parent) {
            this.subtree = faxis;
            this.stack = new ArrayList();
            this.parent = parent;       // need to use its contextdepth each time....

            // improvement:
            // if ! isDss, there has nothing to do with Push/Pop, only one copy each time will be kept
            // if isDss, push and pop each time....
            if (! faxis.IsDss) {                // keep an instance
                this.Push (1);              // context depth + 1
            }
            // else just keep stack empty
        }

        // method
        internal void Push (int depth) {
            AxisElement eaxis = new AxisElement (this.subtree.RootNode, depth);
            this.stack.Add (eaxis);
        }

        internal void Pop () {
            this.stack.RemoveAt (Length - 1);
        }

        // used in the beginning of .//  and MoveToChild
        // didn't consider Self, only consider name
        internal static bool Equal (string thisname, string thisURN, string name, string URN) {
            // which means "b" in xpath, no namespace should be specified
            if (thisURN == null) {
                if ( !((URN == null) || (URN == string.Empty))) {
                    return false;
                }
            }
            // != "*"
            else if ((thisURN != string.Empty) && (thisURN != URN)) {
                return false; 
            }
            // != "a:*" || "*"
            if ((thisname != string.Empty) && (thisname != name)) {
                return false; 
            }
            return true;
        }

        // "a/b/c"     pointer from b move to a
        // needn't change even tree structure changes
        internal void MoveToParent(string name, string URN, int depth) {
            if (this.subtree.IsSelfAxis) {
                return; 
            }

            foreach (AxisElement eaxis in this.stack) {
                eaxis.MoveToParent (depth, this.subtree);
            }

            // in ".//"'s case, since each time you push one new element while match, why not pop one too while match?
            if ( this.subtree.IsDss && Equal (this.subtree.RootNode.Name, this.subtree.RootNode.URN, name, URN)) {
                Pop();  
            }   // only the last one
        }

        // "a/b/c"     pointer from a move to b
        // return true if reach c
        internal bool MoveToChild(string name, string URN, int depth) {
            bool result = false;
            // push first
            if ( this.subtree.IsDss && Equal (this.subtree.RootNode.Name, this.subtree.RootNode.URN, name, URN)) {      
                Push(-1); 
            }   
            foreach (AxisElement eaxis in this.stack) {
                if (eaxis.MoveToChild (name, URN, depth, this.subtree)) {
                    result = true;
                }
            }
            return result;
        }

        // attribute can only at the topaxis part
        // dealing with attribute only here, didn't go into stack element at all
        // stack element only deal with moving the pointer around elements
        internal bool MoveToAttribute(string name, string URN, int depth) {
            if (! this.subtree.IsAttribute) {
                return false;
            }
            if (! Equal (this.subtree.TopNode.Name, this.subtree.TopNode.URN, name, URN) ) {
                return false;
            }

            bool result = false;

            // no stack element for single attribute, so dealing with it seperately
            if (this.subtree.TopNode.Input == null) {
                return (this.subtree.IsDss || (depth == 1));
            }

            foreach (AxisElement eaxis in this.stack) {
                if ((eaxis.isMatch) && ( eaxis.CurNode == this.subtree.TopNode.Input )) {
                    result = true;
                }
            }
            return result;
        }

    }

    // whenever an element is under identity-constraint, an instance of this class will be called
    // only care about property at this time
    internal class ActiveAxis : ForwardOnlyXpathExpr {
        // consider about reactivating....  the stack should be clear right??
        // just reset contextDepth & isActive....
        private int currentDepth;                       // current depth, trace the depth by myself... movetochild, movetoparent, movetoattribute
        private bool isActive;                          // not active any more after moving out context node
        private Asttree axisTree;                       // reference to the whole tree
        // for each subtree i need to keep a stack...
        private ArrayList axisStack;                    // of AxisStack

        internal bool IsActive {
            get { return this.isActive; }
        }

        public int CurrentDepth {
            get { return this.currentDepth; }
        }

        // if an instance is !IsActive, then it can be reactive and reuse
        // still need thinking.....
        internal void Reactivate () {
            this.isActive = true; 
            this.currentDepth = -1;
        }

        internal ActiveAxis (Asttree axisTree) {
            this.axisTree = axisTree;                                               // only a pointer.  do i need it?
            this.currentDepth = -1;                                                 // context depth is 0 -- enforce moveToChild for the context node
                                                                                    // otherwise can't deal with "." node
            this.axisStack = new ArrayList(axisTree.SubtreeArray.Count);            // defined length
            // new one stack element for each one
            foreach (ForwardAxis faxis in axisTree.SubtreeArray) {
                AxisStack stack = new AxisStack (faxis, this);
                axisStack.Add (stack);
            }
            this.isActive = true;
        }

        public bool MoveToStartElement (string localname, string URN) {
            if (!isActive) {
                return false;
            }

            // for each:
            this.currentDepth ++;
            bool result = false;
            foreach (AxisStack stack in this.axisStack) {
                // special case for self tree   "." | ".//."
                if (stack.Subtree.IsSelfAxis) {
                    if ( stack.Subtree.IsDss || (this.CurrentDepth == 0))
                        result = true;
                    continue;
                }

                // otherwise if it's context node then return false
                if (this.CurrentDepth == 0) continue;

                if (stack.MoveToChild (localname, URN, this.currentDepth)) {
                    result = true;
                    // even already know the last result is true, still need to continue...
                    // run everyone once
                }
            }
            return result;
        }
            
        // return result doesn't have any meaning until in SelectorActiveAxis
        public virtual bool EndElement (string localname, string URN) {
            // need to think if the early quitting will affect reactivating....
            if (this.currentDepth ==  0) {          // leave context node
                this.isActive = false;
            }
            if (! this.isActive) {
                return false;
            }
            foreach (AxisStack stack in this.axisStack) {
                stack.MoveToParent (localname, URN, this.currentDepth);
            }
            this.currentDepth -- ;
            return false;
        }

        // Secondly field interface 
        public bool MoveToAttribute (string localname, string URN) {
            if (! this.isActive) {
                return false;
            }
            bool result = false;
            foreach (AxisStack stack in this.axisStack) {
                if (stack.MoveToAttribute (localname, URN, this.currentDepth + 1)) {  // don't change depth for attribute, but depth is add 1 
                    result = true;
                }
            }
            return result;
        }
    }

    /* ---------------------------------------------------------------------------------------------- *
     * Static Part Below...                                                                           *
     * ---------------------------------------------------------------------------------------------- */

    // each node in the xpath tree
    internal class DoubleLinkAxis : Axis {
        internal Axis next;

        internal Axis Next {
            get { return this.next; }
            set { this.next = value; }
        }

        //constructor
        // I can't recrusively call constructor -- "No overload for method 'Axis' takes '0' arguments"
        // or assign value to 'this' -- "Cannot assign to '<this>' because it is read-only"

        //constructor
        internal DoubleLinkAxis ( Axis input, 
            Axis next, 
            String urn, 
            String prefix, 
            String name, 
            XPathNodeType nodetype, 
            AxisType axistype,
            bool abbrAxis ) {
            this._input = input;
            this.next = next;
            this._urn = urn;
            this._prefix = prefix;
            this._name = name;
            this._nodetype = nodetype;
            this._axistype = axistype;
            this.abbrAxis = abbrAxis;
        }

        //constructor
        internal DoubleLinkAxis (Axis axis, DoubleLinkAxis inputaxis) {
            this.next = null;
            this._input = inputaxis;
            this._urn = axis.URN;
            this._prefix = axis.Prefix;
            this._name = axis.Name;
            this._nodetype = axis.Type;
            this._axistype = axis.TypeOfAxis;
            this.abbrAxis = axis.abbrAxis;
            if (inputaxis != null) {
                inputaxis.Next = this;
            }
        }

        // recursive here
        internal static DoubleLinkAxis ConvertTree (Axis axis) {
            if (axis == null) {
                return null;
            }
            return ( new DoubleLinkAxis (axis, ConvertTree ((Axis) (axis.Input))));
        }
    }



    // only keep axis, rootNode, isAttribute, isDss inside
    // act as an element tree for the Asttree
    internal class ForwardAxis {
        // Axis tree
        private DoubleLinkAxis topNode;
        private DoubleLinkAxis rootNode;                // the root for reverse Axis

        // Axis tree property
        private bool isAttribute;                       // element or attribute?      "@"?
        private bool isDss;                             // has ".//" in front of it?
        private bool isSelfAxis;                        // only one node in the tree, and it's "." (self) node

        internal DoubleLinkAxis RootNode { 
            get { return this.rootNode; }
        }

        internal DoubleLinkAxis TopNode {
            get { return this.topNode; }
        }

        internal bool IsAttribute {
            get { return this.isAttribute; }
        }

        // has ".//" in front of it?
        internal bool IsDss {
            get { return this.isDss; }
        }

        internal bool IsSelfAxis {
            get { return this.isSelfAxis; }
        }

        public ForwardAxis (DoubleLinkAxis axis, bool isdesorself) {
            this.isDss = isdesorself;
            this.isAttribute = Asttree.IsAttribute (axis);
            this.topNode = axis;
            this.rootNode = axis;
            while ( this.rootNode.Input != null ) {
                this.rootNode = (DoubleLinkAxis)(this.rootNode.Input);
            }
            // better to calculate it out, since it's used so often, and if the top is self then the whole tree is self
            this.isSelfAxis = Asttree.IsSelf (this.topNode);
        }
    }

    // static, including an array of ForwardAxis  (this is the whole picture)
    internal class Asttree {
        // set private then give out only get access, to keep it intact all along
        private ArrayList fAxisArray;           
        private string xpathexpr;
        private bool isField;                                   // field or selector
        private XmlNamespaceManager nsmgr;

        internal ArrayList SubtreeArray {
            get { return fAxisArray; }
        }

        // when making a new instance for Asttree, we do the compiling, and create the static tree instance
        public Asttree (string xPath, bool isField, XmlNamespaceManager nsmgr) {
            this.xpathexpr = xPath;
            this.isField = isField;
            this.nsmgr = nsmgr;
            // checking grammar... and build fAxisArray
            this.CompileXPath (xPath, isField, nsmgr);          // might throw exception in the middle
        }

        // only for debug
#if DEBUG
        public void PrintTree (StreamWriter msw) {
            foreach (ForwardAxis axis in fAxisArray) {
                msw.WriteLine ("<Tree IsDss=\"{0}\" IsAttribute=\"{1}\">" , axis.IsDss, axis.IsAttribute);
                DoubleLinkAxis printaxis = axis.TopNode;
                while ( printaxis != null ) {
                    msw.WriteLine (" <node>");
                    msw.WriteLine ("  <URN> {0} </URN>", printaxis.URN);
                    msw.WriteLine ("  <Prefix> {0} </Prefix>", printaxis.Prefix);
                    msw.WriteLine ("  <Name> {0} </Name>", printaxis.Name);
                    msw.WriteLine ("  <NodeType> {0} </NodeType>", printaxis.Type);
                    msw.WriteLine ("  <AxisType> {0} </AxisType>", printaxis.TypeOfAxis);
                    msw.WriteLine (" </node>");
                    printaxis = (DoubleLinkAxis) (printaxis.Input);
                }
                msw.WriteLine ("</Tree>");
            }
        }
#endif

        // this part is for parsing restricted xpath from grammar
        private static bool IsNameTest(Axis ast) {
            // Type = Element, abbrAxis = false
            // all are the same, has child:: or not
            return ((ast.TypeOfAxis == Axis.AxisType.Child) && (ast.Type == XPathNodeType.Element));
        }

        internal static bool IsAttribute(Axis ast) {
            return ((ast.TypeOfAxis == Axis.AxisType.Attribute) && (ast.Type == XPathNodeType.Attribute));
        }

        private static bool IsDescendantOrSelf(Axis ast) {
            return ((ast.TypeOfAxis == Axis.AxisType.DescendantOrSelf) && (ast.Type == XPathNodeType.All) && (ast.abbrAxis));
        }

        internal static bool IsSelf(Axis ast) {
            return ((ast.TypeOfAxis == Axis.AxisType.Self) && (ast.Type == XPathNodeType.All) && (ast.abbrAxis));
        }

        // don't return true or false, if it's invalid path, just throw exception during the process
        // for whitespace thing, i will directly trim the tree built here...
        public void CompileXPath (string xPath, bool isField, XmlNamespaceManager nsmgr) {
            if ((xPath == null) || (xPath == string.Empty)) {
                throw new XmlSchemaException(Res.Sch_EmptyXPath);
            }

            // firstly i still need to have an ArrayList to store tree only...
            // can't new ForwardAxis right away
            string[] xpath = xPath.Split('|');
            ArrayList AstArray = new ArrayList(xpath.Length);
            this.fAxisArray = new ArrayList(xpath.Length);

            // throw compile exceptions
            // can i only new one builder here then run compile several times??
            try {
                foreach (string value in xpath) {
                    // default ! isdesorself (no .//)
                    Axis ast = (Axis) (XPathParser.ParseXPathExpresion(value));
                    AstArray.Add (ast);
                }
            }   
            catch {
                throw  new XmlSchemaException(Res.Sch_ICXpathError, xPath);
            }

            Axis stepAst;
            foreach (Axis ast in AstArray) {
                // Restricted form
                // field can have an attribute:

                // throw exceptions during casting
                if ((stepAst = ast) == null) {
                    throw new XmlSchemaException(Res.Sch_ICXpathError, xPath);
                }

                Axis top = stepAst;

                // attribute will have namespace too
                // field can have top attribute
                if (IsAttribute (stepAst)) {
                    if (! isField) {
                        throw new XmlSchemaException(Res.Sch_SelectorAttr, xPath);
                    }
                    else {
                        SetURN (stepAst, nsmgr);
                        try {
                            stepAst = (Axis) (stepAst.Input);
                        }
                        catch {
                            throw new XmlSchemaException(Res.Sch_ICXpathError, xPath);
                        }
                    }
                }

                // field or selector
                while ((stepAst != null) && (IsNameTest (stepAst) || IsSelf (stepAst))) {
                    // trim tree "." node, if it's not the top one
                    if (IsSelf (stepAst) && (ast != stepAst)) {
                        top.Input = stepAst.Input;
                    }
                    else {
                        top = stepAst;
                        // set the URN
                        if (IsNameTest(stepAst)) {
                            SetURN (stepAst, nsmgr);
                        }
                    }
                    try {
                        stepAst = (Axis) (stepAst.Input);
                    }
                    catch {
                        throw new XmlSchemaException(Res.Sch_ICXpathError, xPath);
                    }
                }

                // the rest part can only be .// or null
                // trim the rest part, but need compile the rest part first
                top.Input = null;
                if (stepAst == null) {      // top "." and has other element beneath, trim this "." node too
                    if (IsSelf(ast) && (ast.Input != null)) {
                        this.fAxisArray.Add ( new ForwardAxis ( DoubleLinkAxis.ConvertTree ((Axis) (ast.Input)), false));
                    }
                    else {
                        this.fAxisArray.Add ( new ForwardAxis ( DoubleLinkAxis.ConvertTree (ast), false));
                    }
                    continue;
                }
                if (! IsDescendantOrSelf (stepAst)) {
                    throw new XmlSchemaException(Res.Sch_ICXpathError, xPath);
                }
                try {
                    stepAst = (Axis) (stepAst.Input);
                }
                catch {
                    throw new XmlSchemaException(Res.Sch_ICXpathError, xPath);
                }
                if ((stepAst == null) || (! IsSelf (stepAst)) || (stepAst.Input != null)) {
                    throw new XmlSchemaException(Res.Sch_ICXpathError, xPath);
                }

                // trim top "." if it's not the only node
                if (IsSelf(ast) && (ast.Input != null)) {
                    this.fAxisArray.Add ( new ForwardAxis ( DoubleLinkAxis.ConvertTree ((Axis) (ast.Input)), true));
                }
                else {
                    this.fAxisArray.Add ( new ForwardAxis ( DoubleLinkAxis.ConvertTree (ast), true));
                }
            }
        }

        // depending on axis.Name & axis.Prefix, i will set the axis._urn;
        // also, record urn from prefix during this
        // 4 different types of element or attribute (with @ before it) combinations: 
        // (1) a:b (2) b (3) * (4) a:*
        // i will check xpath to be strictly conformed from these forms
        // for (1) & (4) i will have URN set properly
        // for (2) the URN is null
        // for (3) the URN is empty
        private void SetURN (Axis axis, XmlNamespaceManager nsmgr) {
            if (axis.Prefix != String.Empty) {      // (1) (4)
                XmlNameTable nameTable = nsmgr.NameTable;
                if (nameTable != null) {
                    axis._urn = nsmgr.LookupNamespace(nsmgr.NameTable.Get(axis.Prefix));        
                }
                else {
                    axis._urn = nsmgr.LookupNamespace(axis.Prefix);     
                }
                // axis._urn = prefix == null ? null : nsmgr.LookupNamespace(prefix);       
                // wrong prefix, throw exceptions
                if (axis._urn == null) {
                    throw new XmlSchemaException(Res.Sch_UnresolvedPrefix, axis.Prefix);
                }
            }
            else if (axis.Name != String.Empty) {   // (2)
                axis._urn = null;
            }
            else {                                  // (3)
                axis._urn = "";
            }
        }

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xpath\baseaxisquery.cs ===
//------------------------------------------------------------------------------
// <copyright file="baseaxisquery.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.XPath {
    using System.Xml; 
    using System.Xml.Xsl;
    using System.Diagnostics;
    using System.Collections;


    internal class BaseAxisQuery :   IQuery {
        protected bool _fMatchName ;
        internal IQuery m_qyInput;
        internal String m_Name = String.Empty;
        internal String m_Prefix = String.Empty;
        protected String m_URN = String.Empty;
        internal XPathNodeType m_Type;

        // these two things are the state of this class
        // that need to be reset whenever the context changes.
        protected XPathNavigator m_eNext;
        internal int _position;

        protected BaseAxisQuery() {
        }

        protected BaseAxisQuery(IQuery qyInput) {
            m_qyInput = qyInput;
        }

        internal BaseAxisQuery(
                              IQuery qyInput,
                              String Name,
                              String Prefix,
                              String urn,
                              XPathNodeType Type) {
            m_Prefix = Prefix;
            m_URN = urn;
            m_qyInput = qyInput;
            m_Name = Name;
            m_Type = Type;
            _fMatchName = !m_Prefix.Equals(String.Empty) || !m_Name.Equals(String.Empty);

        }

        internal override int Position {
            get {
                return _position;
            }
        }
        
        internal override void SetXsltContext(XsltContext context){
            System.Diagnostics.Debug.Assert(context != null);
            m_URN = context.LookupNamespace(m_Prefix);
            if (m_qyInput != null)
                m_qyInput.SetXsltContext(context);

        }
        
        override internal XPathResultType ReturnType() {
            return XPathResultType.NodeSet;
        }
        override internal object getValue(IQuery qy) {
            return null;
        }
        override internal object getValue(XPathNavigator qy, XPathNodeIterator iterator) {
            return null;
        }
        override internal XPathNavigator MatchNode(XPathNavigator current) {
            throw new XPathException(Res.Xp_InvalidPattern);
        }
        
         virtual internal bool matches(XPathNavigator e) {
            if (e.NodeType == m_Type || m_Type == XPathNodeType.All ||
                (m_Type == XPathNodeType.Text && (e.NodeType == XPathNodeType.Whitespace
                 || e.NodeType == XPathNodeType.SignificantWhitespace))){
                if (_fMatchName) {
                    if (m_Name.Equals(e.LocalName) || m_Name.Length == 0){
                        if (m_URN.Equals(e.NamespaceURI)){
                            return true;
                        }
                    }
                }
                else {
                    return true;
                }
            }
            return false;       
        }        
        
        internal override XPathNavigator peekElement() {
            if (m_eNext == null)
                m_eNext = advance();
            return m_eNext;
        }
        internal override void reset() {
            // reset the state
            _position = 0;
            m_eNext = null;
            if (m_qyInput != null)
                m_qyInput.reset();
        }
        internal override void setContext(XPathNavigator e) {
            reset();
            if (m_qyInput == null) {
                if (e == null)
                    return;
                m_qyInput = new XPathSelfQuery(e);
            }
            else
                m_qyInput.setContext( e);
        }
        
        override internal XPathNavigator advance() {
            System.Diagnostics.Debug.Assert(false,"Should not come here in basequery advance");
            return null;
        }
        
        internal override Querytype getName() {
            return Querytype.None;
        }

        override internal IQuery Clone() {
            System.Diagnostics.Debug.Assert(false,"Should not be here");
            return null;
        }

        internal IQuery CloneInput() {
            if (m_qyInput != null) {
                return m_qyInput.Clone();
            }
            return null;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xpath\cachechildrenquery.cs ===
//------------------------------------------------------------------------------
// <copyright file="CacheChildrenQuery.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.XPath {
    using System.Xml; 

    using System.Collections;

    internal sealed class CacheChildrenQuery : ChildrenQuery {
        Stack _ElementStk = new Stack();
        XPathNavigator _NextInput = null;
        Stack _PositionStk = new Stack();
        
        internal CacheChildrenQuery(
                                   IQuery qyInput,
                                   String name,
                                   String prefix,
                                   String urn,
                                   XPathNodeType type) : base (qyInput, name, prefix, urn, type) {
        }

        internal override void reset() {
            _ElementStk.Clear();
            _NextInput = null;
            base.reset();
        }


        internal override XPathNavigator advance() {
            while (true) {
                if (_count == 0) {
                    if (DecideInput())
                        return null;
                }
                else {
                    if (! m_eNext.MoveToNext())
                        _count = 0;
                    else {
                        _count++;
                    }
                }
                if (_count > 1)
                    CompareNextInput();
                if (_count != 0) {
                    if (matches(m_eNext)) {
                        _position++;
                        return m_eNext;
                    }
                }

            } // while

        } // Advance

        private bool DecideInput() {
            if (_ElementStk.Count == 0) {
                if (_NextInput == null) {
                    m_eNext = m_qyInput.advance();
                    if (m_eNext == null)
                        return true;
                    m_eNext = m_eNext.Clone();
                }
                else {
                    m_eNext = _NextInput;
                    _NextInput = null;

                }
                if (m_eNext.MoveToFirstChild()) {

                    _count = 1;
                }
                _position = 0;
            }
            else {
                m_eNext = _ElementStk.Pop() as XPathNavigator;
                _position = (int) _PositionStk.Pop();
                _count = 2;
            }
            return false;
        }

        private void CompareNextInput() {
            XmlNodeOrder order;
            if (_NextInput == null) {
                _NextInput = m_qyInput.advance();
                if (_NextInput != null) {
                    _NextInput = _NextInput.Clone();

                }
                else
                    return;
            }
            
            order = m_eNext.ComparePosition(_NextInput);
            if (order == XmlNodeOrder.After) {
                _ElementStk.Push(m_eNext);
                _PositionStk.Push(_position);
                m_eNext = _NextInput;
                _NextInput = null;
                if (!m_eNext.MoveToFirstChild())
                    _count = 0;
                else {
                    _count = 1;
                }
                _position = 0;
            }

        }

        internal override IQuery Clone() {
            return new CacheChildrenQuery(CloneInput(),m_Name,m_Prefix,m_URN,m_Type);
        }        

    } // Children Query}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xpath\booleanfunctions.cs ===
//------------------------------------------------------------------------------
// <copyright file="BooleanFunctions.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.XPath {
    using System.Xml; 
    using System.Xml.Xsl;
    using FT = System.Xml.XPath.Function.FunctionType;
    using System.Globalization;
        
    internal sealed class BooleanFunctions : IQuery {
        IQuery _qy;
        FT _FuncType;

        internal BooleanFunctions(IQuery qy, FT ftype) {
            _qy = qy;
            _FuncType = ftype;
        }

        internal BooleanFunctions(IQuery qy) {
            _qy = qy;
            _FuncType = FT.FuncBoolean;
        }

        internal override void SetXsltContext(XsltContext context){
            if (_qy != null)
                _qy.SetXsltContext(context);
        }

        internal override object getValue(IQuery qy) {
            switch (_FuncType) {
                case FT.FuncBoolean :
                    return toBoolean(qy);
                case FT.FuncNot :
                    return Not(qy);
                case FT.FuncTrue :
                    return true;
                case FT.FuncFalse :
                    return false;
                case FT.FuncLang :
                    return Lang(qy);
            }
            return null;
        }

        internal override object getValue(XPathNavigator qy, XPathNodeIterator iterator) {
            switch (_FuncType) {
                case FT.FuncBoolean :
                    return toBoolean(qy, iterator);
                case FT.FuncNot :
                    return Not(qy, iterator);
                case FT.FuncTrue :
                    return true;
                case FT.FuncFalse :
                    return false;
                case FT.FuncLang :
                    return Lang(qy, iterator);
            }
            return null;
        }

        internal static Boolean toBoolean(double number) {
            if (number == 0 || double.IsNaN(number))
                return false;
            else
                return true;
        }
        internal static Boolean toBoolean(String str) {
            if (str.Length > 0)
                return true;
            return false;
        }

        internal override void reset() {
            if (_qy != null)
                _qy.reset();
        }

        internal Boolean toBoolean(XPathNavigator qyContext, XPathNodeIterator iterator) {
            if (_qy.ReturnType() == XPathResultType.NodeSet) {
                _qy.setContext(qyContext.Clone());
                XPathNavigator value = _qy.advance();
                if (value  != null)
                    return true;
                else
                    return false;
            }
            else if (_qy.ReturnType() == XPathResultType.String) {
                object result = _qy.getValue(qyContext, iterator);
                if (result.ToString().Length > 0) {
                    return true;
                }
                else {
                    if (result is string) {
                        return false;
                    } 
                    else {
                        Debug.Assert(result is XPathNavigator);
                        return true;              // RTF can't be empty ?
                    }
                }
            }
            else if (_qy.ReturnType() == XPathResultType.Boolean)
                return Convert.ToBoolean(_qy.getValue(qyContext, iterator));
            else if (_qy.ReturnType() == XPathResultType.Number) {
                return(toBoolean(XmlConvert.ToXPathDouble(_qy.getValue(qyContext, iterator))));
            }
            return false;

        } // toBoolean

        internal Boolean toBoolean(IQuery qyContext) {
            if (_qy.ReturnType() == XPathResultType.NodeSet) {
                _qy.setContext(qyContext.peekElement().Clone());
                XPathNavigator value = _qy.advance();
                if (value  != null)
                    return true;
                else
                    return false;
            }
            else if (_qy.ReturnType() == XPathResultType.String) {
                if (_qy.getValue(qyContext).ToString().Length > 0)
                    return true;
                else
                    return false;
            }
            else if (_qy.ReturnType() == XPathResultType.Boolean)
                return Convert.ToBoolean(_qy.getValue(qyContext));
            else if (_qy.ReturnType() == XPathResultType.Number) {
                return(toBoolean(XmlConvert.ToXPathDouble(_qy.getValue(qyContext))));
            }
            return false;

        } // toBoolean

        internal override XPathResultType  ReturnType() {
            return XPathResultType.Boolean;
        }

        private Boolean Not(IQuery qy) {
            return !Convert.ToBoolean(_qy.getValue(qy));
        }

        private Boolean Not(XPathNavigator qy, XPathNodeIterator iterator) {
            return !Convert.ToBoolean(_qy.getValue(qy, iterator));
        }  

        private Boolean Lang(IQuery qy) {
            String str = _qy.getValue(qy).ToString();
            XPathNavigator context = qy.peekElement().Clone();
            return Lang(str, context);
        }

        private Boolean Lang(XPathNavigator context, XPathNodeIterator iterator) {
            String str = _qy.getValue(context, iterator).ToString().ToLower(CultureInfo.InvariantCulture); 
            return Lang(str, context);          
        }

        private Boolean Lang(String str, XPathNavigator context){
           if (context == null)
                return false;
            String lang = context.XmlLang.ToLower(CultureInfo.InvariantCulture);
            return (lang.Equals(str) || str.Equals(lang.Split('-')[0]));
        }

        internal override IQuery Clone() {
            if (_qy != null )
                return new BooleanFunctions(_qy.Clone(), _FuncType);
            else
                 return new BooleanFunctions(null, _FuncType);         
        }

    } // class Functions

} // namespace
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xpath\cachequery.cs ===
//------------------------------------------------------------------------------
// <copyright file="CacheQuery.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.XPath {
    using System.Xml; 
    using System.Collections;
    using System.Xml.Xsl;

    internal class CacheQuery : PositionQuery {
        
        internal CacheQuery() {
        }

        internal CacheQuery(IQuery qyParent) : base(qyParent){
        }
        
        
        internal override XPathNavigator advance() {
            if (_fillStk){
                _position = 0;
                FillStk();
            }
            if (_count < _Stk.Count ){
                _position++;
                m_eNext = (XPathNavigator)_Stk[_count++];
                return m_eNext;
            }
            return null;
        }

        internal override void FillStk() {
            while ( (m_eNext = m_qyInput.advance()) != null) {
                bool add = true;
                for (int i=0; i< _Stk.Count ; i++) {
                    XPathNavigator nav = _Stk[i] as XPathNavigator;
                    XmlNodeOrder compare = nav.ComparePosition(m_eNext) ;      
                    if (compare == XmlNodeOrder.Same ) {
                        add = false;
                        break;
                    }
                }
                if (add) {
                    _Stk.Add(m_eNext.Clone());
                }
                
            }
            _fillStk = false; 
        }
        
        internal override IQuery Clone() {
            return new CacheQuery(CloneInput());
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xpath\elementstack.cs ===
//------------------------------------------------------------------------------
// <copyright file="ElementStack.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.XPath {
    using System.Diagnostics;
    using System.Collections;

    internal sealed class IteratorFrame {
        internal XPathNavigator _eParent;
        internal bool _fNext;
        internal bool _fIsAttribute;
        internal int _index;

        internal IteratorFrame() {
        }
        internal void init(XPathNavigator  eParent ) {
            _eParent = eParent;
            _fNext = false;
            _fIsAttribute = false;
            _index = 1;
        }
        internal void init(XPathNavigator  eParent, bool fIsAttribute ) {
            _eParent = eParent;
            _fNext = false;
            _fIsAttribute = fIsAttribute;
            _index = 1;
        }
        XPathNavigator getParent() {
            return _eParent;
        }

    } // class IteratorFrame

    internal class IteratorStack {
        internal ArrayList _astkframe = new ArrayList();
        internal int _sp = 0;

        internal IteratorStack() {
        }
        internal bool empty() {
            return(_sp == 0);
        }
        internal void reset() {
            _sp = 0;
            _astkframe.Clear();
        }
        internal int sp() {
            return _sp;
        }
        internal void anc_reset() {
            _sp = 1;
        }
        internal IteratorFrame item(int i) {
            return(IteratorFrame)_astkframe[i];
        }
        internal IteratorFrame push(XPathNavigator eParent, bool fIsAttribute) {
            IteratorFrame frame = new IteratorFrame();


            frame.init(eParent, fIsAttribute);
            _astkframe.Add((Object)frame);
            _sp++;
            return frame;
        }
        internal void pop() {
            Debug.Assert(_sp > 0, "Ooops. stack is empty");
            _astkframe.RemoveAt(_sp - 1);
            _sp--;
        }
        internal void stackdump() {
            int i= _sp;
            while (i > 0)
                Debug.WriteLine(((IteratorFrame)_astkframe[--i])._eParent.LocalName);
        }
        internal IteratorFrame tos() {
            Debug.Assert(_sp > 0, "Oops. stack is empty");
            return(IteratorFrame)_astkframe[_sp - 1];
        }

    } // class IteratorStack

} // namespace
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xpath\documentorderquery.cs ===
//------------------------------------------------------------------------------
// <copyright file="DocumentOrderQuery.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.XPath {
    using System.Xml; 
    using System.Collections;
    using System.Xml.Xsl;

    internal sealed class DocumentOrderQuery : CacheQuery {
        
        internal DocumentOrderQuery() {
        }

        internal DocumentOrderQuery(IQuery qyParent) : base(qyParent){
        }
        
        
        internal override XPathNavigator advance() {
            if (_fillStk){
                _position = 0;
                FillStk();
            }
            if (_count > 0  ){
                _position++;
                m_eNext = (XPathNavigator)_Stk[--_count];
                return m_eNext;
            }
            return null;
        }

        internal override void FillStk() {
            while ( (m_eNext = m_qyInput.advance()) != null) {
                bool add = true;
                for (int i=0; i< _Stk.Count ; i++) {
                    XPathNavigator nav = _Stk[i] as XPathNavigator;
                    XmlNodeOrder compare = nav.ComparePosition(m_eNext) ;      
                    if (compare == XmlNodeOrder.Same ) {
                        add = false;
                        break;
                    }
                    if (compare == XmlNodeOrder.Before)
                    {
                        _Stk.Insert(i,m_eNext.Clone());
                        add = false; 
                        break;
                    }
                }
                if (add) {
                    _Stk.Add(m_eNext.Clone());
                }
                
            }
            _fillStk = false; 
            _count = _Stk.Count;
        }
        
        internal override IQuery Clone() {
            return new DocumentOrderQuery(CloneInput());
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xpath\childrenquery.cs ===
//------------------------------------------------------------------------------
// <copyright file="ChildrenQuery.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.XPath {
    using System.Xml; 
    using System.Xml.Xsl;
    using System.Collections;

    internal  class ChildrenQuery : BaseAxisQuery {
        protected int _count = 0;
        XPathNodeIterator _iterator;
        
        internal ChildrenQuery(
                              IQuery qyInput,
                              String name,
                              String prefix,
                              String urn,
                              XPathNodeType type) : base (qyInput, name, prefix, urn, type) {
        }

        internal override void reset() {
            _count = 0;
            base.reset();
        }
        
        internal override XPathNavigator advance() {
            while (true) {
                if (_count == 0) {
                    m_eNext = m_qyInput.advance();
                    if (m_eNext == null ){
                        return null;
                    }
                    if( _fMatchName ) {
                        if( m_Type == XPathNodeType.ProcessingInstruction ) {
                            _iterator = new IteratorFilter( m_eNext.SelectChildren( m_Type ), m_Name );
                        }
                        else {
                            _iterator = m_eNext.SelectChildren( m_Name, m_URN );
                        }

                    }
                    else {
                        _iterator = m_eNext.SelectChildren( m_Type );
                    }
                    _count = 1;
                    _position = 0;
                }
                if( _iterator.MoveNext() ) {
                    _position++;
                    m_eNext = _iterator.Current;
                    return m_eNext;
                }
                else {
                    _count = 0;
                }

            }
        } // Advance



        override internal XPathNavigator MatchNode(XPathNavigator context) {
            if (context != null) {
                if (matches(context)) {
                    XPathNavigator temp = context.Clone();
                    if (temp.NodeType != XPathNodeType.Attribute && temp.MoveToParent()) {
                        if (m_qyInput != null){
                            return m_qyInput.MatchNode(temp);
                        }
                        return temp;
                    }
                    return null;
                }
            }
            return null;
        } 
  
        internal override Querytype getName() {
            return Querytype.Child;
        }

        internal override IQuery Clone() {
            return new ChildrenQuery(CloneInput(),m_Name,m_Prefix,m_URN,m_Type);
        }

    } // Children Query}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xpath\compiledxpathexpr.cs ===
//------------------------------------------------------------------------------
// <copyright file="CompiledXpathExpr.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------



namespace System.Xml.XPath {

    using System;
    using System.Globalization;
    using System.Collections;
    using System.Xml.Xsl;

    internal class CompiledXpathExpr : XPathExpression {
        IQuery _compiledQuery;
        string _expr;
        SortQuery _sortQuery;
        QueryBuilder _builder;
        bool _allowSort;
        bool _hasUnresolvedPrefix;
        
        internal CompiledXpathExpr(IQuery query, string expression, bool hasPrefix) {
            _compiledQuery = query;
            _expr = expression;
            _builder = new QueryBuilder();
            _hasUnresolvedPrefix = hasPrefix;
        }

        internal IQuery QueryTree {
            get { 
                if (_hasUnresolvedPrefix)
                    throw new XPathException(Res.Xp_NoContext);
                return _compiledQuery; 
            }
        }
        
        public override string Expression {
            get { return _expr; }
        }

        public override void AddSort(object expr, IComparer comparer) {
            // sort makes sense only when we are dealing with a query that
            // returns a nodeset.
	    IQuery evalExpr;
             _allowSort = true;
            if (expr is String) {
                evalExpr = _builder.Build((String)expr, out _hasUnresolvedPrefix); // this will throw if expr is invalid
            }
            else if (expr is CompiledXpathExpr) {
		evalExpr = ((CompiledXpathExpr)expr).QueryTree;
	    }
            else {
                throw new XPathException(Res.Xp_BadQueryObject);
            }
            if (_sortQuery == null) {
                _sortQuery = new SortQuery(_compiledQuery);
                _compiledQuery = _sortQuery;
            }
            _sortQuery.AddSort(evalExpr, comparer);
        }
        
        public override void AddSort(object expr, XmlSortOrder order, XmlCaseOrder caseOrder, string lang, XmlDataType dataType) {
            AddSort(expr, new XPathComparerHelper(order, caseOrder, lang, dataType));
        }
        
        public override XPathExpression Clone() {
            return new CompiledXpathExpr(_compiledQuery.Clone(), _expr, _hasUnresolvedPrefix);
        }
        
        public override void SetContext(XmlNamespaceManager nsManager) {
            XsltContext xsltContext = nsManager as XsltContext;
            if(xsltContext == null) {
                if(nsManager == null) {
                    nsManager = new XmlNamespaceManager(new NameTable());
                }
                xsltContext = new UndefinedXsltContext(nsManager);
            }
            _compiledQuery.SetXsltContext(xsltContext);
//            _compiledQuery.SetNamespaceContext((XmlNamespaceManager)context);

            if (_allowSort && (_compiledQuery.ReturnType() != XPathResultType.NodeSet)) {
               throw new XPathException(Res.Xp_NodeSetExpected);
            }
           _hasUnresolvedPrefix = false;
        }

 	    public override XPathResultType ReturnType {
            get { return _compiledQuery.ReturnType(); }
        }

        private class UndefinedXsltContext : XsltContext {
            private XmlNamespaceManager nsManager;

            public UndefinedXsltContext(XmlNamespaceManager nsManager) {
                this.nsManager = nsManager;
            }
            //----- Namespace support -----
            public override string DefaultNamespace {
                get { return string.Empty; }
            }
            public override string LookupNamespace(string prefix) {
                Debug.Assert(prefix != null);
                if(prefix == string.Empty) {
                    return string.Empty;
                }
                string ns = this.nsManager.LookupNamespace(this.nsManager.NameTable.Get(prefix));
                if(ns == null) {
                    throw new XsltException(Res.Xslt_InvalidPrefix, prefix);
                }
                Debug.Assert(ns != string.Empty, "No XPath prefix can be mapped to 'null namespace'");
                return ns;
            }
            //----- XsltContext support -----
            public override IXsltContextVariable ResolveVariable(string prefix, string name) {
                throw new XPathException(Res.Xp_UndefinedXsltContext);
            }
            public override IXsltContextFunction ResolveFunction(string prefix, string name, XPathResultType[] ArgTypes) {
                throw new XPathException(Res.Xp_UndefinedXsltContext);
            }
            public override bool Whitespace { get{ return false; } }
            public override bool PreserveWhitespace(XPathNavigator node) { return false; }
            public override int CompareDocument (string baseUri, string nextbaseUri) {
                throw new XPathException(Res.Xp_UndefinedXsltContext);
            }
        }
    }

    internal sealed class XPathComparerHelper : IComparer {
        private XmlSortOrder order;
        private XmlCaseOrder caseOrder;
        private CultureInfo  cinfo;
        private XmlDataType  dataType;
        
        public XPathComparerHelper(XmlSortOrder order, XmlCaseOrder caseOrder, string lang, XmlDataType dataType) {
            if (lang == null || lang == String.Empty)
                this.cinfo = System.Threading.Thread.CurrentThread.CurrentCulture;
            else
                this.cinfo = new CultureInfo(lang);

            if (order == XmlSortOrder.Descending) {
                if (caseOrder == XmlCaseOrder.LowerFirst) {
                    caseOrder = XmlCaseOrder.UpperFirst;
                }
                else if (caseOrder == XmlCaseOrder.UpperFirst) {
                    caseOrder = XmlCaseOrder.LowerFirst;
                }
            }

            this.order     = order;
            this.caseOrder = caseOrder;
            this.dataType  = dataType;
        }

        public Int32 Compare(object x, object y) {
            Int32 sortOrder = (this.order == XmlSortOrder.Ascending) ? 1 : -1;
            switch(this.dataType) {
            case XmlDataType.Text:
                String s1 = Convert.ToString(x);
                String s2 = Convert.ToString(y);
                Int32 result = String.Compare(s1, s2, (this.caseOrder == XmlCaseOrder.None) ? false : true, this.cinfo);
                if (result != 0 || this.caseOrder == XmlCaseOrder.None)
                    return (sortOrder * result);

                // If we came this far, it means that strings s1 and s2 are
                // equal to each other when case is ignored. Now it's time to check
                // and see if they differ in case only and take into account the user
                // requested case order for sorting purposes.
                Int32 caseOrder = (this.caseOrder == XmlCaseOrder.LowerFirst) ? 1 : -1;
                result = String.Compare(s1, s2, false, this.cinfo);
                return (caseOrder * result);

            case XmlDataType.Number:
                double r1 = XmlConvert.ToXPathDouble(x);
                double r2 = XmlConvert.ToXPathDouble(y);

                // trying to return the result of (r1 - r2) casted down
                // to an Int32 can be dangerous. E.g 100.01 - 100.00 would result
                // erroneously in zero when casted down to Int32.
                if (r1 > r2) {
                    return (1*sortOrder);
                }
                else if (r1 < r2) {
                    return (-1*sortOrder);
                }
                else {
                    if (r1 == r2) {
                        return 0;
                    }
                    if (Double.IsNaN(r1)) {
                        if (Double.IsNaN(r2)) {
                            return 0;
                        }
                        //r2 is not NaN .NaN comes before any other number
                        return (-1*sortOrder);
                    }
                    //r2 is NaN. So it should come after r1
                    return (1*sortOrder);
                }
            default:
                throw new ArgumentException("x");
            } // switch
        } // Compare ()
    } // class XPathComparerHelper
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xpath\fandexpr.cs ===
//------------------------------------------------------------------------------
// <copyright file="FAndExpr.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

#if StreamFilter

namespace System.Xml.XPath {
    internal sealed class FAndExpr : IFQuery {
        private IFQuery _opnd1;
        private IFQuery _opnd2;

        FAndExpr() {
        }

        internal FAndExpr( IFQuery  opnd1, IFQuery  opnd2) {
            _opnd1 = opnd1;
            _opnd2 = opnd2;
        }

        internal override  bool MatchNode(XmlReader  qyContext) {
            if (!_opnd1.MatchNode(qyContext))
                return false;
            return _opnd2.MatchNode(qyContext);
        }

        internal override XPathResultType ReturnType() {
            return XPathResultType.Boolean;
        }
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xpath\flogicalexpr.cs ===
//------------------------------------------------------------------------------
// <copyright file="FLogicalExpr.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

#if StreamFilter
namespace System.Xml.XPath {
    internal sealed class FLogicalExpr : IFQuery {
        private IFQuery _opnd1;
        private IFQuery _opnd2;
        private Operator.Op _op;

        internal FLogicalExpr(Operator.Op op, IFQuery  opnd1, IFQuery  opnd2) {
            _opnd1= opnd1;
            _opnd2= opnd2;
            _op= op;
        }

        static bool CompareAsNumber(
                                   IFQuery opnd1,
                                   IFQuery opnd2,
                                   XmlReader qyContext,
                                   Operator.Op op) {
            double n1 = 0, n2=0 ;
            try {
                if (!opnd2.getValue(qyContext, ref n2))
                    return false;
                if (!opnd1.getValue(qyContext,ref n1))
                    return false;

                switch (op) {
                    case Operator.Op.LT :
                        if (n1 < n2)
                            return true;
                        break;
                    case Operator.Op.GT : 
                        if (n1 > n2)
                            return true;
                        break;
                    case Operator.Op.LE :
                        if (n1 <= n2)
                            return true;
                        break;
                    case Operator.Op.GE  :
                        if (n1 >= n2)
                            return true;
                        break;
                    case Operator.Op.EQ :
                        if (n1 == n2)
                            return true;
                        break;
                    case Operator.Op.NE :
                        if (n1 != n2)
                            return true;
                        break;
                }
            }
            catch (System.Exception) {
                //The DataRecord strongly typed getters throw exception for invalid casting
                return false; 
            }
            return false;

        }


        static bool CompareAsString(
                                   IFQuery opnd1,
                                   IFQuery opnd2, 
                                   XmlReader qyContext, 
                                   Operator.Op op) {
            try {
                if (op <= Operator.Op.GE) {
                    double n1 = 0, n2 = 0;
                    if (!opnd2.getValue(qyContext, ref n2))
                        return false;
                    if (!opnd1.getValue(qyContext,ref n1))
                        return false;
                    switch (op) {
                        case Operator.Op.LT : if (n1 < n2) return true;
                            break;
                        case Operator.Op.GT : if (n1 > n2) return true;
                            break;
                        case Operator.Op.LE : if (n1 <= n2) return true;
                            break;
                        case Operator.Op.GE  :if (n1 >= n2) return true;
                            break;
                    }
                }
                else {
                    String n1 = null, n2 = null;
                    if (!opnd2.getValue(qyContext,ref n2))
                        return false;
                    if (!opnd1.getValue(qyContext,ref n1))
                        return false;
                    switch (op) {
                        case Operator.Op.EQ : if (n1.Equals(n2)) return true;
                            break;
                        case Operator.Op.NE : if (!n1.Equals(n2)) return true;
                            break;
                    }
                }
            }
            catch (System.Exception) {
                //The DataRecord strongly typed getters throw exception for invalid casting
                return false;
            }
            return false;
        }

        static bool CompareAsBoolean(
                                    IFQuery opnd1,
                                    IFQuery opnd2,
                                    XmlReader qyContext,
                                    Operator.Op op) {
            try {
                if (op <= Operator.Op.GE) {
                    double n1 = 0, n2 = 0;
                    if (!opnd2.getValue(qyContext, ref n2))
                        return false;
                    if (!opnd1.getValue(qyContext,ref n1))
                        return false;
                    switch (op) {
                        case Operator.Op.LT : if (n1 < n2) return true;
                            break;
                        case Operator.Op.GT : if (n1 > n2) return true;
                            break;
                        case Operator.Op.LE : if (n1 <= n2) return true;
                            break;
                        case Operator.Op.GE  :if (n1 >= n2) return true;
                            break;
                    }
                }
                else {
                    Boolean n1 = false, n2 = false;
                    opnd2.getValue(qyContext, ref n2);
                    if (!opnd1.getValue(qyContext,ref n1))
                        return false;
                    switch (op) {
                        
                        case Operator.Op.EQ : if (n1 == n2) return true;
                            break;
                        case Operator.Op.NE : if (n1 != n2) return true;
                            break;
                    }
                }
            }
            catch (System.Exception) {
                //The DataRecord strongly typed getters throw exception for invalid casting
                return false;
            }
            return false;

        }

        internal override bool MatchNode( XmlReader  qyContext) {
            if (_opnd1.ReturnType() == XPathResultType.Boolean || 
                _opnd2.ReturnType() == XPathResultType.Boolean)
                return CompareAsBoolean(_opnd1,_opnd2,qyContext,_op);
            else
                if (_opnd1.ReturnType() == XPathResultType.Number ||
                    _opnd2.ReturnType() == XPathResultType.Number)
                return CompareAsNumber(_opnd1,_opnd2,qyContext,_op);
            else
                return CompareAsString(_opnd1,_opnd2,qyContext,_op);
        }

        internal override XPathResultType ReturnType() {
            return XPathResultType.Boolean;
        }
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xpath\filter.cs ===
//------------------------------------------------------------------------------
// <copyright file="Filter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.XPath {
    internal class Filter : AstNode {
        private AstNode _input;
        private AstNode _condition;

        internal Filter( AstNode input, AstNode condition) {
            _input = input;
            _condition = condition;
        }

        internal override QueryType TypeOfAst {
            get {return  QueryType.Filter;}
        }

        internal override XPathResultType ReturnType {
            get {return XPathResultType.NodeSet;}
        }

        internal AstNode Input {
            get { return _input;}
        }

        internal AstNode Condition {
            get {return _condition;}
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xpath\filterquery.cs ===
//------------------------------------------------------------------------------
// <copyright file="FilterQuery.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.XPath {
    using System.Xml; 
    using System.Xml.Xsl;

    internal class FilterQuery : BaseAxisQuery {
        protected IQuery _opnd;
        private bool noPosition;
        
        internal FilterQuery() {
        }

        internal FilterQuery(IQuery qyParent, IQuery opnd) {
            m_qyInput = qyParent;
            _opnd = opnd;
        }

        internal FilterQuery(IQuery qyParent, IQuery opnd, bool noPosition) : this(qyParent, opnd){
            this.noPosition = noPosition;
        }
        
        internal override void reset() {
            _opnd.reset();
            base.reset();
        }

        internal override void setContext(XPathNavigator input) {
            reset();
            m_qyInput.setContext(input);
        }

        internal override void SetXsltContext(XsltContext input) {
            m_qyInput.SetXsltContext(input);
            _opnd.SetXsltContext(input);
            if (_opnd.ReturnType() != XPathResultType.Number) {
                ReversePositionQuery query = m_qyInput as ReversePositionQuery;
                if (query != null) {
                    m_qyInput = query.m_qyInput;
                }
            }
        }

        internal override XPathNavigator advance() {
            while ((m_eNext = m_qyInput.advance()) != null) {
                bool fMatches = matches( m_qyInput,m_eNext);        
                if (fMatches) {
                    //This is done this way for handling multiple predicates 
                    //where the second predicate is applied on the results of first
                    //predicate like child::*[position() >=2][position() <=4]
                    //revert to earlier version if it applies to child::*
                    _position++;
                    return m_eNext;
                }
            }
            return null;
        }

        internal bool matches(IQuery e, XPathNavigator context) {
            if (_opnd == null)
                return false;
            XPathResultType resultType = _opnd.ReturnType();
            if (resultType == XPathResultType.Number){
                double i = XmlConvert.ToXPathDouble(_opnd.getValue(e));
                return( i == e.Position);
            }
            if (resultType == XPathResultType.NodeSet) {
                _opnd.setContext(context); 
                if (_opnd.advance() != null)
                    return true;
                else
                    return false;
            }
            if (resultType == XPathResultType.Boolean)
                return Convert.ToBoolean(_opnd.getValue(e));
            if (resultType == XPathResultType.String) {
                if (_opnd.getValue(context, null).ToString().Length >0)
                    return true;
                else
                    return false;
            }
            return false;      
        }

        internal override XPathResultType  ReturnType() {
            return m_qyInput.ReturnType();
        }

        internal override IQuery Clone() {
            return new FilterQuery(CloneInput(), _opnd.Clone(), this.noPosition);
        }

        override internal XPathNavigator MatchNode(XPathNavigator current) {
            return MatchNode( current, m_qyInput );
        }
        
        protected XPathNavigator MatchNode(XPathNavigator current, IQuery query) {
            XPathNavigator context;
            if (current != null) {
                context = query.MatchNode(current);
                if (context != null) {
                    if (_opnd.ReturnType() == XPathResultType.Number) {
                        if (_opnd.getName() == Querytype.Constant) {
                            XPathNavigator result = current.Clone();

                            int i=0;
                            if (query.getName() == Querytype.Child) {
                                result.MoveToParent();
                                result.MoveToFirstChild();
                                while (true) {
                                    if (((ChildrenQuery)query).matches(result)){
                                        i++;
                                    if (current.IsSamePosition(result))
                                        if (XmlConvert.ToXPathDouble(_opnd.getValue(current, null)) ==  i)
                                            return context;
                                        else
                                            return null;
                                    }        
                                    if (!result.MoveToNext())
                                        return null;

                                }
                            }
                            if (query.getName() == Querytype.Attribute) {
                                result.MoveToParent();
                                result.MoveToFirstAttribute();
                                while (true) {
                                    if (((AttributeQuery)query).matches(result))
                                        i++;
                                    if (current.IsSamePosition(result))
                                        if (XmlConvert.ToXPathDouble(_opnd.getValue(current, null)) == i)
                                            return context;
                                        else
                                            return null;
                                    if (!result.MoveToNextAttribute())
                                        return null;
                         
                                }
                            }
                        }
                        else {
                            setContext(context.Clone());
                            XPathNavigator result = advance();
                            while (result != null) {
                                if (result.IsSamePosition(current))
                                    return context;
                                result = advance();
                            }
                        }

                    }
                    if (_opnd.ReturnType() == XPathResultType.NodeSet) {
                        _opnd.setContext(current); 
                        if (_opnd.advance() != null)
                            return context;
                        else
                            return null;
                    }
                    if (_opnd.ReturnType() == XPathResultType.Boolean) {
                        if (noPosition) {
                            if ((bool)_opnd.getValue(current, null)) {
                                return context;
                            }
                            return null;
                        }
                        setContext(context.Clone());
                        XPathNavigator result = advance();
                        while (result != null) {
                            if (result.IsSamePosition(current))
                                return context;
                            result = advance();
                        }
                        return null;
                    }
                    if (_opnd.ReturnType() == XPathResultType.String)
                        if (_opnd.getValue(context, null).ToString().Length >0)
                            return context;
                        else
                            return null;

                }
                else
                    return null;
            }
            return null;
        } 

        internal override bool Merge {
            get {
                return m_qyInput.Merge;
            }
        }


    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xpath\fnumericexpr.cs ===
//------------------------------------------------------------------------------
// <copyright file="FNumericExpr.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

#if StreamFilter
namespace System.Xml.XPath {
    using System.Diagnostics;

    internal sealed class FNumericExpr : IFQuery {
        private IFQuery _opnd1;
        private IFQuery _opnd2;
        private Operator.Op _op;

        internal FNumericExpr(Operator.Op op, IFQuery  opnd1, IFQuery  opnd2) {
            _opnd1= opnd1;
            _opnd2= opnd2;
            _op= op;
        }

        internal override  bool getValue( XmlReader  qyContext, ref double val) {
            double n1=0,n2=0;
            try {
                if (! _opnd1.getValue(qyContext, ref n1))
                    return false;
                if (_op != Operator.Op.NEGATE)
                    if (!_opnd2.getValue(qyContext,ref n2))
                        return false;
                switch (_op) {
                    case Operator.Op.PLUS : val = n1 + n2;
                        break;
                    case Operator.Op.MINUS : val = n1 - n2;
                        break;
                    case Operator.Op.MOD : val =n1 % n2;
                        break;
                    case Operator.Op.DIV  : val = n1 / n2;
                        break;
                    case Operator.Op.MUL  : val = n1 * n2;
                        break;
                    case Operator.Op.NEGATE : val = -n1;
                        break;

                }
                return true;
            }
            catch (System.Exception) {
                return false;
            }
        }

        internal override  bool getValue( XmlReader  qyContext, ref String val) {
            double n1 = 0;
            if (!getValue(qyContext, ref n1))
                return false;
            val = Convert.ToString(n1);
            return true;
        }

        internal override  bool getValue( XmlReader  qyContext, ref Boolean val) {
            double n1 = 0;
            if (! getValue(qyContext, ref n1))
                return false;
            if (n1 != 0)
                val = true;
            else
                val = false;
            return true;
        }

        internal override  XPathResultType ReturnType() {
            return XPathResultType.Number;
        }

        internal override bool MatchNode(XmlReader current) {
            Debug.Assert(false,"No position matching");
            return false;
        }

    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xpath\ffilterquery.cs ===
//------------------------------------------------------------------------------
// <copyright file="FFilterQuery.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

#if StreamFilter

namespace System.Xml.XPath {
    using System.Diagnostics;

    internal sealed class FFilterQuery : IFQuery {
        private IFQuery _opnd;
        private IFQuery m_qyInput;

        internal FFilterQuery(IFQuery qyParent, IFQuery opnd) {
            m_qyInput = qyParent;
            _opnd = opnd;
        }

        internal override  XPathResultType ReturnType() {
            return XPathResultType.NodeSet;
        }

        internal override bool MatchNode(XmlReader qyContext) {
            if (m_qyInput.MatchNode(qyContext))
                return _opnd.MatchNode(qyContext);
            return false;
        }

        internal override bool getValue(XmlReader context,ref String val) {
            Debug.Assert(false,"Elements dont have value");
            return false;
        }

        internal override bool getValue(XmlReader context,ref double val) {
            Debug.Assert(false,"Elements dont have value");
            return false;
        }

        internal override bool getValue(XmlReader context,ref Boolean val) {
            Debug.Assert(false,"Elements dont have value");
            return false;
        }

    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xpath\fattributequery.cs ===
//------------------------------------------------------------------------------
// <copyright file="FAttributeQuery.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

#if StreamFilter

namespace System.Xml.XPath {
    internal sealed class FAttributeQuery :IFQuery {
        private bool _fMatchName = true;
        private bool _fPrefixIsURN = true;

        private String m_Name;
        private String m_Prefix;
        private String m_URN;
        private XPathNodeType m_Type;

        internal FAttributeQuery(
                                String Name,
                                String Prefix,
                                String URN,
                                XPathNodeType Type) {
            if (!URN.Equals(String.Empty) &&
                !Prefix.Equals(String.Empty)) {
                _fPrefixIsURN = true;
                Prefix = URN;
            }
            else {
                _fPrefixIsURN = false;
            }
            m_Prefix = Prefix;
            m_URN = URN;
            m_Name = Name;
            m_Type = Type;
            _fMatchName = !m_Prefix.Equals(String.Empty) || !m_Name.Equals(String.Empty);
        }

        internal override bool MatchNode(XmlReader context) {
            if (context != null)
                if (matches(context)) {
                    return true;
                }
            return false;
        } 

        internal override bool getValue(XmlReader context,ref double val) {
            if (context != null)
                if (matches(context)) {
                    try {
                        val = Convert.ToDouble(context.Value);
                        return true;
                    }
                    catch (System.Exception) {
                        return false;
                    }
                }
            return false;
        }

        internal override bool getValue(XmlReader context,ref String val) {
            if (context != null)
                if (matches(context)) {
                    val = context.Value;
                    return true;
                }
            return false;
        }

        internal override bool getValue(XmlReader context,ref Boolean val) {
            if (context != null) {
                if (matches(context)) {
                    val = true;
                    return true;
                }
            }
            val = false;
            return false;
        } 

        private bool matches(XmlReader e) {
            if (!e.MoveToFirstAttribute())
                return false;
            while (true) {
                if (_fMatchName) {
                    if (m_Name.Equals(e.LocalName))
                        if (_fPrefixIsURN) {
                            if (m_Prefix.Equals(e.NamespaceURI))
                                return true;
                        }
                        else
                            if (m_Prefix.Equals(e.Prefix))
                            return true;
                }
                else
                    return true;
                if (!e.MoveToNextAttribute())
                    return false;
            } 
        }

        internal override XPathResultType ReturnType() {
            return XPathResultType.NodeSet;
        }
    } 
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xpath\fchildrenquery.cs ===
//------------------------------------------------------------------------------
// <copyright file="FChildrenQuery.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

#if StreamFilter

namespace System.Xml.XPath {
    using System.Diagnostics;

    internal sealed class FChildrenQuery : IFQuery {
        private bool _fMatchName = true;
        private bool _fPrefixIsURN = true;

        private String m_Name;
        private String m_Prefix;
        private String m_URN;
        private XPathNodeType m_Type;

        internal FChildrenQuery(
                               String Name,
                               String Prefix,
                               String URN,
                               XPathNodeType Type) {
            if (!(String.Empty).Equals(URN) &&
                (!(String.Empty).Equals(Prefix) ||
                 Type != XPathNodeType.Attribute)) {
                _fPrefixIsURN = true;
                Prefix = URN;
            }
            else {
                _fPrefixIsURN = false;
            }
            m_Prefix = Prefix;
            m_URN = URN;
            m_Name = Name;
            m_Type = Type;
            _fMatchName = !m_Prefix.Equals(String.Empty) || !m_Name.Equals(String.Empty);
        }

        internal override bool MatchNode(XmlReader context) {
            if (context != null)
                if (matches(context))
                    return true;
            return false;
        } 

        private bool matches(XmlReader e) {
            if (m_Type != XPathNodeType.All) {
                if (m_Type == XPathNodeType.Text) {
                    if (e.NodeType != XPathNodeType.Text)
                        return false;
                }
                else if (e.NodeType != m_Type)
                    return false;
            }
            if (_fMatchName) {
                if (!m_Name.Equals(e.Name))
                    return false;

                if (_fPrefixIsURN) {
                    if (!m_Prefix.Equals(e.NamespaceURI))
                        return false;
                }
                else if (!m_Prefix.Equals(e.Prefix))
                    return false;
            }
            return true;       
        }

        internal override bool getValue(XmlReader context,ref String val) {
            Debug.Assert(false,"Elements dont have value");
            return false;
        }

        internal override bool getValue(XmlReader context,ref double val) {
            Debug.Assert(false,"Elements dont have value");
            return false;
        }

        internal override bool getValue(XmlReader context,ref Boolean val) {
            Debug.Assert(false,"Elements dont have value");
            return false;
        }

        internal override XPathResultType ReturnType() {
            return XPathResultType.NodeSet;
        }
    } // Children Query}
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xpath\forexpr.cs ===
//------------------------------------------------------------------------------
// <copyright file="FOrExpr.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

#if StreamFilter
namespace System.Xml.XPath {
    internal sealed class FOrExpr :IFQuery {
        private IFQuery _opnd1;
        private IFQuery _opnd2;

        FOrExpr() {
        }
        internal FOrExpr( IFQuery  opnd1, IFQuery  opnd2) {
            _opnd1 = opnd1;
            _opnd2 = opnd2;
        }
        internal override  bool MatchNode( XmlReader  qyContext) {
            if (_opnd1.MatchNode(qyContext))
                return true;
            return _opnd2.MatchNode(qyContext);
        }

        internal override  XPathResultType ReturnType() {
            return XPathResultType.Boolean;
        }
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xpath\foperandquery.cs ===
//------------------------------------------------------------------------------
// <copyright file="FOperandQuery.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

#if StreamFilter
namespace System.Xml.XPath {
    using System.Diagnostics;

    internal sealed class FOperandQuery : IFQuery {
        private object _Var;
        private XPathResultType _Type;

        internal FOperandQuery(object var,XPathResultType type) {
            _Var = var;
            _Type = type;
        }

        internal override bool getValue(XmlReader qy,ref double val) {
            val = Convert.ToDouble(_Var);
            return true;
        }

        internal override bool getValue(XmlReader qy,ref String val) {
            if (_Type == XPathResultType.Boolean)
                if (Convert.ToBoolean(_Var))
                    val = String.Copy("true");
                else
                    val = String.Copy("false");
            else
                val = _Var.ToString();
            return true;
        }

        internal override bool getValue(XmlReader qy,ref Boolean val) {
            if (_Type == XPathResultType.Number) {
                val = (0.0 != Convert.ToDouble(_Var));
            }
            else if (_Type == XPathResultType.String) {
                val = (_Var.ToString().Length > 0);
            }
            else {
                val = Convert.ToBoolean(_Var);
            }
            return true;
        }

        internal override XPathResultType ReturnType() {
            return _Type;
        }

        internal override bool MatchNode(XmlReader current) {
            Debug.Assert(false,"Cannot match constants");
            return false;
        }
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xpath\followingquery.cs ===
//------------------------------------------------------------------------------
// <copyright file="followingquery.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.XPath
{
    using System.Xml;
    using System.Collections;

    internal sealed class FollowingQuery : BaseAxisQuery
    {
        private XPathNavigator _eLast;
        private XPathNodeIterator _qy;
        private bool _first = true;

        internal FollowingQuery(
            IQuery          qyInput,
            String          Name,
            String          Prefix,
            String          URN,
            XPathNodeType Type) : base(qyInput, Name, Prefix, URN, Type)
        {
        }

        internal override void reset() 
        {
            _eLast = null;
            _qy = null;
            _first = true;
            base.reset();
        }

        internal override void setContext(XPathNavigator e) {
            reset();
            base.setContext(e);
        }

        internal override  IQuery Clone() {
            return new FollowingQuery(CloneInput(), this.m_Name, this.m_Prefix, this.m_URN, this.m_Type);
        }
            
        internal override XPathNavigator advance()
        {
            if (_eLast == null ){
                XPathNavigator temp = null;
                _eLast = m_qyInput.advance();
                if (_eLast == null)
                    return null;

                while (_eLast != null){
                    _eLast = _eLast.Clone();
                    temp = _eLast;
                    _eLast = m_qyInput.advance();
                    if (!temp.IsDescendant(_eLast))
                        break;
                }
                _eLast = temp;
            } 
            while (true)
            {
                if (_first)
                {
                    _first = false;
                    if (_eLast.NodeType == XPathNodeType.Attribute || _eLast.NodeType == XPathNodeType.Namespace){
                        _eLast.MoveToParent();
                        if( _fMatchName ) {
                            _qy = _eLast.SelectDescendants( m_Name, m_URN, false);
                        }
                        else {
                            _qy = _eLast.SelectDescendants( m_Type, false );
                        }                    
                    }
                    else {
                        while (true){
                            if (! _eLast.MoveToNext()){
                                if (!_eLast.MoveToParent()) {
                                    _first = true;
                                    return null;
                                }
                            }
                            else{
                                break;
                            }
                        }
                        if( _fMatchName ) {
                            _qy = _eLast.SelectDescendants( m_Name, m_URN, true);
                        }
                        else {
                            _qy = _eLast.SelectDescendants( m_Type, true );
                        }
                    }
                }
                if( _qy.MoveNext() ) {
                    _position++;
                    m_eNext = _qy.Current;
                    return m_eNext;
                }
                else {
                    _first = true;
                }
            }
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xpath\forquery.cs ===
//------------------------------------------------------------------------------
// <copyright file="FOrQuery.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

#if StreamFilter
namespace System.Xml.XPath {
    internal sealed class FOrQuery : IFQuery {
        private IFQuery _opnd1, _opnd2;

        internal FOrQuery(IFQuery query1, IFQuery query2) {
            _opnd1 = query1;
            _opnd2 = query2;
        }
        internal override bool MatchNode(XmlReader reader) {
            if (_opnd1.MatchNode(reader))
                return true;
            if (_opnd2.MatchNode(reader))
                return true;
            return false;
        }
        internal override XPathResultType ReturnType() {
            return XPathResultType.NodeSet;
        }
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xpath\forwardonlyxpathexpr.cs ===
//------------------------------------------------------------------------------
// <copyright file="ForwardOnlyXpathExpr.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.XPath {

    using System;
    using System.Xml;
    using System.Collections;

    internal interface ForwardOnlyXpathExpr {
        int CurrentDepth { get; }

        // this is for checking the restrictly xpath in grammer, and generate the basic tree
        // leave it commentted bcoz interface doesn't allow static function
        // static ForwardOnlyXpathExpr CompileXPath (string xPath, bool isField);
        
        // Firstly only think about selector interface
        bool MoveToStartElement (string NCName, string URN);
        bool EndElement (string NCName, string URN);

        // Secondly field interface 
        bool MoveToAttribute (string NCName, string URN);
        
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xpath\followingsibling.cs ===
//------------------------------------------------------------------------------
// <copyright file="followingsibling.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.XPath
{
    using System.Xml; 
    
    using System.Collections;
    
    internal  class FollSiblingQuery: BaseAxisQuery
    {
        protected int _count = 0;
        Stack _ElementStk = new Stack();
        ArrayList _ParentStk = new ArrayList();
        XPathNavigator _NextInput = null;
		
        internal FollSiblingQuery(
            IQuery qyInput,
            String name,
            String prefix,
            String urn,
            XPathNodeType type) : base (qyInput, name, prefix, urn, type)
        {
        }

        internal override void reset()
        {
            _count = 0;
            _ElementStk.Clear();
            _ParentStk.Clear();
            m_eNext = null;
            _NextInput = null;
            base.reset();
        }

        private bool NotVisited(XPathNavigator nav)
        {
            XPathNavigator nav1 = nav.Clone();
            nav1.MoveToParent();
            for(int i=0;i<_ParentStk.Count;i++)
                if (nav1.IsSamePosition((XPathNavigator)_ParentStk[i]))
                    return false;
            _ParentStk.Add(nav1);
            return true;
        }
        
        internal override XPathNavigator advance()
        {
        	while (true)
        	{       	
        		if (m_eNext == null )
	        		if (_ElementStk.Count == 0){
	        		    if (_NextInput == null){ 
    						while ((m_eNext = m_qyInput.advance())!= null )
    						    if (NotVisited(m_eNext))
    						        break;
    						if (m_eNext != null){
    						    m_eNext = m_eNext.Clone();
							}
						    else
						        return null;
					    }
					    else{
					        m_eNext = _NextInput;
					        _NextInput = null;
				        }
					        
					}
					else{
						m_eNext = _ElementStk.Pop() as XPathNavigator;
					}

				if (_NextInput == null ){
					while ((_NextInput = m_qyInput.advance())!= null)
					    if (NotVisited(_NextInput))
					        break;
					if (_NextInput != null){
					    _NextInput = _NextInput.Clone();
					}
				}

				if (_NextInput != null)
    				while (m_eNext.IsDescendant(_NextInput)){
    				    _ElementStk.Push(m_eNext);
    					m_eNext = _NextInput;
    					_NextInput = m_qyInput.advance(); 
    					if (_NextInput != null){
    					    _NextInput = _NextInput.Clone();
					    }
    				}

				while (m_eNext.MoveToNext() ){
				    if ( matches(m_eNext)){
				        _position++;
    				    return m_eNext;
			        }
			    }
		        m_eNext = null;
			}
			//return null;
                
        } // Advance
                
        internal override IQuery Clone() {
            return new FollSiblingQuery(CloneInput(),m_Name,m_Prefix,m_URN,m_Type);
        }
        
    } // Children Query}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xpath\forwardpositionquery.cs ===
//------------------------------------------------------------------------------
// <copyright file="ForwardPositionQuery.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.XPath {
    using System.Xml; 
    using System.Collections;
    using System.Xml.Xsl;

    internal sealed class ForwardPositionQuery : PositionQuery {
        
        internal ForwardPositionQuery() {
        }

        internal ForwardPositionQuery(IQuery qyParent) : base(qyParent){
        }
        
        
        internal override XPathNavigator advance() {
            if (_fillStk){
                _position = 0;
                FillStk();
            }
            if (_count < _Stk.Count ){
                _position++;
                m_eNext = (XPathNavigator)_Stk[_count++];
                return m_eNext;
            }
            return null;
        }

        internal override IQuery Clone() {
            return new ForwardPositionQuery(CloneInput());
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xpath\group.cs ===
//------------------------------------------------------------------------------
// <copyright file="Group.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.XPath {
    internal class Group : AstNode {
        private AstNode _groupNode;

        internal Group(AstNode groupNode) {
            _groupNode = groupNode;
        }
        internal override QueryType TypeOfAst {
            get {return QueryType.Group;}
        }
        internal override XPathResultType ReturnType {
            get {return XPathResultType.NodeSet;}
        }

        internal AstNode GroupNode {
            get {return _groupNode;}
        }

        internal override double DefaultPriority {
            get {
                //return _groupNode.DefaultPriority;
                return 0;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xpath\groupquery.cs ===
//------------------------------------------------------------------------------
// <copyright file="GroupQuery.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.XPath {
    using System.Xml; 


    internal sealed class GroupQuery : BaseAxisQuery {

        internal GroupQuery(IQuery qy): base() {
            m_qyInput = qy;
        }

        internal override XPathNavigator advance() {
            if (m_qyInput.ReturnType() == XPathResultType.NodeSet) {
                m_eNext = m_qyInput.advance();
                if (m_eNext != null)
                    _position++;
                return m_eNext;
            }
            return null;
        }

        override internal object getValue(IQuery qyContext) {
            return m_qyInput.getValue(qyContext);
        }

        override internal object getValue(XPathNavigator qyContext, XPathNodeIterator iterator) {
            return m_qyInput.getValue(qyContext, iterator);
        }

        override internal XPathResultType ReturnType() {
            return m_qyInput.ReturnType();
        }

        internal override IQuery Clone() {
            return new GroupQuery(CloneInput());
        }

        internal override bool Merge {
            get {
                return false;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xpath\function.cs ===
//------------------------------------------------------------------------------
// <copyright file="Function.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.XPath {
    using System.Collections;

    internal class Function : AstNode {
        internal enum FunctionType {
            FuncLast = 0,
            FuncPosition,
            FuncCount,
            FuncLocalName,
            FuncNameSpaceUri,
            FuncName,
            FuncString,
            FuncBoolean,
            FuncNumber,
            FuncTrue,
            FuncFalse,
            FuncNot,
            FuncID,            
            FuncConcat,        
            FuncStartsWith,    
            FuncContains,    
            FuncSubstringBefore,
            FuncSubstringAfter,
            FuncSubstring,
            FuncStringLength,
            FuncNormalize,
            FuncTranslate,
            FuncLang,
            FuncSum,
            FuncFloor,
            FuncCeiling,
            FuncRound,
            FuncUserDefined,
            Error
        };

        private FunctionType _functionType = FunctionType.Error;
        private ArrayList _argumentList;

        static private  String[] str = {
            "last()",
            "position()",
            "count()",
            "localname()",
            "namespaceuri()",
            "name()",
            "string()",
            "boolean()", 
            "number()",
            "true()",
            "false()",
            "not()",
            "id()",
            "concat()",
            "starts-with()",
            "contains()",
            "substring-before()",
            "substring-after()",
            "substring()",
            "string-length()",
            "normalize-space()",
            "translate()",
            "lang()",
            "sum()",
            "floor()", 
            "celing()",
            "round()",
        };

        private String _Name = null;
        private String _Prefix = null;

        internal Function(FunctionType ftype, ArrayList argumentList) {
            _functionType = ftype;
            _argumentList = new ArrayList(argumentList);
        }

        internal Function(String prefix, String name, ArrayList argumentList) {
            _functionType = FunctionType.FuncUserDefined;
            _Prefix = prefix;
            _Name = name;
            _argumentList = new ArrayList(argumentList);
        }

        internal Function(FunctionType ftype) {
            _functionType = ftype;
        }

        internal Function(FunctionType ftype, AstNode arg) {
            _functionType = ftype;
            _argumentList = new ArrayList();
            _argumentList.Add(arg);
        }

        internal override QueryType TypeOfAst {
            get {return  QueryType.Function;}
        }

        internal override XPathResultType ReturnType {
            get {
                switch (_functionType) {
                    case FunctionType.FuncLast  : return XPathResultType.Number;
                    case FunctionType.FuncPosition  : return XPathResultType.Number;
                    case FunctionType.FuncCount  : return XPathResultType.Number ;
                    case FunctionType.FuncID : return XPathResultType.NodeSet;
                    case FunctionType.FuncLocalName : return XPathResultType.String;
                    case FunctionType.FuncNameSpaceUri : return XPathResultType.String;
                    case FunctionType.FuncName  : return XPathResultType.String;
                    case FunctionType.FuncString  : return XPathResultType.String;
                    case FunctionType.FuncBoolean : return XPathResultType.Boolean; 
                    case FunctionType.FuncNumber : return XPathResultType.Number;
                    case FunctionType.FuncTrue: return XPathResultType.Boolean;
                    case FunctionType.FuncFalse : return XPathResultType.Boolean; 
                    case FunctionType.FuncNot : return XPathResultType.Boolean;
                    case FunctionType.FuncConcat : return XPathResultType.String;
                    case FunctionType.FuncStartsWith: return XPathResultType.Boolean;
                    case FunctionType.FuncContains : return XPathResultType.Boolean;
                    case FunctionType.FuncSubstringBefore: return XPathResultType.String; 
                    case FunctionType.FuncSubstringAfter  : return XPathResultType.String;
                    case FunctionType.FuncSubstring : return XPathResultType.String;
                    case FunctionType.FuncStringLength : return XPathResultType.Number;
                    case FunctionType.FuncNormalize : return XPathResultType.String;
                    case FunctionType.FuncTranslate : return XPathResultType.String;
                    case FunctionType.FuncLang : return XPathResultType.Boolean;
                    case FunctionType.FuncSum : return XPathResultType.Number;
                    case FunctionType.FuncFloor : return XPathResultType.Number; 
                    case FunctionType.FuncCeiling : return XPathResultType.Number;
                    case FunctionType.FuncRound : return XPathResultType.Number;
                    case FunctionType.FuncUserDefined : return XPathResultType.Error;
                }
                return XPathResultType.Error;
            }
        }

        internal FunctionType TypeOfFunction {
            get {return _functionType;}
        }

        internal ArrayList ArgumentList {
            get {return _argumentList;}
        }

        internal String Prefix {
            get {return _Prefix;}
        }

        internal String Name {
            get {return _functionType == FunctionType.FuncUserDefined ? _Name : str[(int)_functionType];}
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xpath\idquery.cs ===
//------------------------------------------------------------------------------
// <copyright file="IDQuery.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.XPath {
    using System.Diagnostics;
    using System.Xml; 
    using System.Collections;

    internal  class IDQuery : BaseAxisQuery {

        XPathNavigator _context;
        int strcount = 0;
        ArrayList ElementList;
        
        internal IDQuery(IQuery qyInput)
        {
            m_qyInput = qyInput;
        }

        internal override void reset() {
            strcount = 0;
            ElementList = null;
        }
        
        internal override void setContext(XPathNavigator context)
        {
            reset();
            base.setContext(context);
            _context = context.Clone();
        }

        void AddToStack(XPathNavigator current)
        {
            XmlNodeOrder compare;
            for (int i=0; i< ElementList.Count ; i++)
            {
                XPathNavigator nav = ElementList[i] as XPathNavigator;
                compare = nav.ComparePosition(current) ;      
                if (compare == XmlNodeOrder.Same ) return;
                if (compare == XmlNodeOrder.Before)
                {
                    ElementList.Insert(i,current.Clone());
                    return;
                }
            }
            ElementList.Add(current.Clone());
        }

        internal override XPathNavigator advance() {
            switch (m_qyInput.ReturnType())
            {
                case XPathResultType.NodeSet :
                        if ( ElementList  == null ) {
                            ElementList = new ArrayList();
                            XPathNavigator temp ;
                            while ((temp = m_qyInput.advance()) != null) {
                                if (_context.MoveToId(temp.Value)) {
                                    AddToStack(_context.Clone());
                                }
                            }
                            strcount = ElementList.Count;
                        }
                        Debug.Assert(strcount >= 0);
                        if ( strcount != 0 ) {
                            return ElementList[--strcount] as XPathNavigator;
                        }
                        return null;
                case XPathResultType.String :
                    if (ElementList == null ) {
                        String str = (String)m_qyInput.getValue(_context, null);                        char[] a ={' '};
                        String[] strarray = str.Split(null);                   
                        ElementList = new ArrayList();
                        while (strcount < strarray.Length) {
                            if (_context.MoveToId(strarray[strcount++])) {
                                AddToStack(_context.Clone());
                            }
                        }
                        strcount = ElementList.Count;                    }
                    Debug.Assert(strcount >= 0);
                    
                    if ( strcount != 0 ) {
                        return ElementList[--strcount] as XPathNavigator;
                    }
                    return null;
                case XPathResultType.Number :
                    if ( strcount == 0 && _context.MoveToId(StringFunctions.toString((double)m_qyInput.getValue(_context, null)))) {
                        strcount = 1;
                        return _context;
                    }
                    else {
                        return null;
                    }
                case XPathResultType.Boolean :
                    if ( strcount == 0 && _context.MoveToId(StringFunctions.toString((Boolean)m_qyInput.getValue(_context, null)))) {
                        strcount = 1;
                        return _context;
                    }
                    else {
                        return null;                        
                    }
            }
            return null;
 
        } // Advance

        internal override IQuery Clone() {
            return new IDQuery(CloneInput());
        }

        internal override XPathNavigator MatchNode(XPathNavigator context) {
            setContext(context) ;
            XPathNavigator result  = null;
            while ( (result = advance()) != null) {
                if (result.IsSamePosition(context)) {
                    return context;
                }
            }
            return null;
        }
            

    } // Children Query}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xpath\ifquery.cs ===
//------------------------------------------------------------------------------
// <copyright file="IFQuery.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

#if StreamFilter

namespace System.Xml.XPath {
    internal abstract class IFQuery {
        internal abstract XPathResultType ReturnType();

        internal abstract bool MatchNode(XmlReader current);

        internal virtual bool getValue(XmlReader context,ref String val) {
            if (MatchNode(context)) {
                val = "true";
                return true;
            }
            val = "false";
            return false;        
        }

        internal virtual bool getValue(XmlReader context,ref double val) {
            if (MatchNode(context)) {
                val = 1;
                return true;
            }
            val=0;
            return false; 
        }

        internal virtual bool getValue(XmlReader context,ref Boolean val) {
            if (MatchNode(context)) {
                val = true;
                return true;
            }
            val = false;
            return false;
        }
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xpath\ixpathnavigable.cs ===
//------------------------------------------------------------------------------
// <copyright file="IXPathNavigable.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   IXPathNavigable.cs
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/
namespace System.Xml.XPath {
    using System;

    /// <include file='doc\IXPathNavigable.uex' path='docs/doc[@for="IXPathNavigable"]/*' />
    public interface IXPathNavigable {
        /// <include file='doc\IXPathNavigable.uex' path='docs/doc[@for="IXPathNavigable.CreateNavigator"]/*' />
        XPathNavigator CreateNavigator();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xpath\iteratorfilter.cs ===
//------------------------------------------------------------------------------
// <copyright file="IteratorFilter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.XPath {
    using System;

    internal class IteratorFilter : XPathNodeIterator {
        private XPathNodeIterator innerIterator;
        private string            name;
        private int               position = 0;

        internal IteratorFilter(XPathNodeIterator innerIterator, string name) {
            this.innerIterator = innerIterator;
            this.name          = name;
        }

        public IteratorFilter(IteratorFilter it) {
            this.innerIterator = it.innerIterator.Clone();
            this.name          = name;
            this.position      = position;
        }

        public override XPathNodeIterator Clone()         { return new IteratorFilter(this); }
        public override XPathNavigator    Current         { get { return innerIterator.Current;} }        
        public override int               CurrentPosition { get { return this.position; } }

        public override bool MoveNext() {
            while(innerIterator.MoveNext()) {
                if(innerIterator.Current.LocalName == this.name) {
                    this.position ++;
                    return true;
                }
            }
            return false;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xpath\iquery.cs ===
//------------------------------------------------------------------------------
// <copyright file="IQuery.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.XPath {
    using System;
    using System.Xml; 
    using System.Xml.Xsl;
    
    using System.Collections;

    /// <include file='doc\IQuery.uex' path='docs/doc[@for="Querytype"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    internal enum Querytype {
        /// <include file='doc\IQuery.uex' path='docs/doc[@for="Querytype.Constant"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Constant = 1,
        /// <include file='doc\IQuery.uex' path='docs/doc[@for="Querytype.Child"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Child = 2,
        /// <include file='doc\IQuery.uex' path='docs/doc[@for="Querytype.Attribute"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Attribute = 3,
        Root = 4,
        Self = 5,
        /// <include file='doc\IQuery.uex' path='docs/doc[@for="Querytype.Descendant"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Descendant ,
        /// <include file='doc\IQuery.uex' path='docs/doc[@for="Querytype.Ancestor"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Ancestor ,
        /// <include file='doc\IQuery.uex' path='docs/doc[@for="Querytype.Sort"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Sort ,
        /// <include file='doc\IQuery.uex' path='docs/doc[@for="Querytype.None"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        None
    }; 

    internal abstract class IQuery {
        internal virtual  XPathResultType ReturnType() {
            return XPathResultType.Error;
        }

        internal virtual  void setContext( XPathNavigator e) {
            reset();
        }
        internal virtual  XPathNavigator peekElement() {
            return null;
        }
        internal virtual  Querytype getName() {
            return Querytype.None;
        }
        internal virtual  XPathNavigator advance() {
            return null;
        }

        internal virtual  XPathNavigator advancefordescendant(){
            return null;
        }
        internal virtual  object getValue(IQuery qy) {
            return null;
        }
        internal virtual  object getValue(XPathNavigator qy, XPathNodeIterator iterator) {
            return null;
        }
        internal virtual  void reset() {
        }
        internal virtual  XPathNavigator MatchNode(XPathNavigator current) {
            throw new XPathException(Res.Xp_InvalidPattern);
        }
        internal virtual  IQuery Clone() {
            return null;
        }

        internal virtual  void SetXsltContext(XsltContext context){
        }

        internal virtual  int Position { 
            get {
                Debug.Assert( false, " Should not be in IQuery Position");
                return 0;
            }
        }

        internal virtual bool Merge {
            get {
                return true;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xpath\mergefilterquery.cs ===
//------------------------------------------------------------------------------
// <copyright file="MergeFilterQuery.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.XPath {
    using System.Collections;
    using System.Xml; 
    using System.Xml.Xsl;

    internal sealed class MergeFilterQuery : BaseAxisQuery {
        private IQuery _child;
        private bool _getInput1 = true;
        private bool _fillList = true;
        private ArrayList _elementList;
        private int _top;
        
        internal MergeFilterQuery() {}

        internal MergeFilterQuery(IQuery qyParent, IQuery child) {
            m_qyInput = qyParent;
            _child = child;
        }
        
        internal override void reset() {
            _getInput1 = true;
            _fillList = true;
            _elementList = null;
            _child.reset();
            base.reset();
        }

        internal override void SetXsltContext(XsltContext input) {
            m_qyInput.SetXsltContext(input);
            _child.SetXsltContext(input);
        }
        
        internal override XPathNavigator advance() {

            if ( _fillList ) {
                _fillList = false;
                FillList();
            }
            if (_top > 0) {
                _position++;
                m_eNext = (XPathNavigator)_elementList[--_top];
                return m_eNext;
            }
            else
                return null;
        }
        
        void NotVisited(XPathNavigator current)
        {
            XmlNodeOrder compare;
            for (int i=0; i< _elementList.Count ; i++)
            {
                XPathNavigator nav = _elementList[i] as XPathNavigator;
                compare = nav.ComparePosition(current) ;      
                if (compare == XmlNodeOrder.Same ) return ;
                if (compare == XmlNodeOrder.Before)
                {
                    _elementList.Insert(i,current.Clone());
                    return ;
                }
            }
            _elementList.Add(current.Clone());
        }
        
        internal void FillList() {
           _elementList = new ArrayList();
           while (true) {
               if ( _getInput1 ) {
                   _getInput1 = false;
                   if ((m_eNext = m_qyInput.advance()) == null) {
                       _top = _elementList.Count;
                       return ;
                   }
                   _child.setContext(m_eNext);
               }
               while ( (m_eNext = _child.advance()) != null ) {
                     //if ( matches( _child, m_eNext) ) {
                        NotVisited( m_eNext );
                     //}
               }
               _getInput1 = true;
           }
        }

        internal override XPathResultType  ReturnType() {
            return XPathResultType.NodeSet;
        }

        internal override IQuery Clone() {
            return new MergeFilterQuery(CloneInput(), _child.Clone());
        }

        override internal XPathNavigator MatchNode(XPathNavigator current) {
            XPathNavigator context = _child.MatchNode(current);
            if (context == null) {
                return null;
            }
            context = m_qyInput.MatchNode(context);
            if (context == null) {
                return null;
            }
            setContext(context.Clone());
            XPathNavigator result = advance();
            while (result != null) {
                if (result.IsSamePosition(current)) {
                    return context;
                }
                result = advance();
            } 
            return null;
        } 
/*
        internal override bool Merge {
            get {
                return false;
            }
        }
*/

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xpath\methodoperand.cs ===
//------------------------------------------------------------------------------
// <copyright file="MethodOperand.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.XPath {
    using System.Xml; 
    using System.Xml.Xsl;
    using FT = System.Xml.XPath.Function.FunctionType;

    internal sealed class MethodOperand : IQuery {
        IQuery _Opnd = null;
        FT _FType;
        bool checkWhitespace;
        XsltContext context;
        double last = -1;
        
        internal MethodOperand(
                              IQuery opnd,
                              FT ftype) {
            _FType= ftype;
            _Opnd = opnd; 

        }

        internal override void SetXsltContext(XsltContext context){
            checkWhitespace = context.Whitespace;
            if (checkWhitespace) {
                this.context = context;
            }
            if (_Opnd != null)
                _Opnd.SetXsltContext(context);
        }
        
        internal override void setContext(XPathNavigator context) {
            if (_Opnd != null)
                _Opnd.setContext(context);
        }

        internal override void reset() {
            last = -1;
            if (_Opnd != null)
                _Opnd.reset();
        }

        internal override object getValue( IQuery  qyContext) {
            XPathNavigator eNext;
            switch (_FType) {
                
                case FT.FuncPosition:
                    if (qyContext != null) {
                        return (double)qyContext.Position;
                    }
                    break;
                case FT.FuncLast:
                    if (qyContext != null) {
                        if (checkWhitespace) {
                            return(double)((PositionQuery)qyContext).getNonWSCount(context);
                        }
                        try {
                            return(double)((PositionQuery)qyContext).getCount();
                        }
                        catch(Exception) {
                            if (last == -1) {
                                last = 0;
                                IQuery temp = qyContext.Clone();
                                while (temp.advance() != null) {
                                    last++;
                                }
                            }
                            return last;
                        }
                    }
                    break;
                case FT.FuncCount:
                    int i = 0;
                    _Opnd.setContext(qyContext.peekElement());
                    if (checkWhitespace) {
                        XPathNavigator nav;
                        while ((nav = _Opnd.advance())!= null) {
                            if (nav.NodeType != XPathNodeType.Whitespace || context.PreserveWhitespace(nav)) { 
                                i++;
                            }
                        }
                        return (double)i;
                    }
                    while (_Opnd.advance()!= null) {
                        i++;
                    }
                    return (double)i;
                case FT.FuncNameSpaceUri:
                    if (_Opnd != null) {
                        _Opnd.setContext(qyContext.peekElement());
                        if (( eNext = _Opnd.advance()) != null) {
                            return eNext.NamespaceURI;
                        }
                        else {
                            return String.Empty;
                        }
                    }
                    return qyContext.peekElement().NamespaceURI;

                case FT.FuncLocalName:
                    if (_Opnd != null) {
                        _Opnd.setContext(qyContext.peekElement().Clone());
                        if (( eNext = _Opnd.advance()) != null) {
                            return eNext.LocalName;
                        }
                        else {
                            return String.Empty;
                        }
                    }
                    return qyContext.peekElement().LocalName;

                case FT.FuncName :
                    if (_Opnd != null) {
                        _Opnd.setContext(qyContext.peekElement().Clone());
                        if (( eNext = _Opnd.advance()) != null) {
                            return eNext.Name;
                        }
                        else {
                            return String.Empty;
                        }
                    }
                    return qyContext.peekElement().Name;

            }
            return String.Empty;
        }

        internal override object getValue( XPathNavigator qyContext, XPathNodeIterator iterator ) {
            XPathNavigator eNext;

            switch (_FType) {
                case FT.FuncPosition:
                    if (iterator != null)
                        return (double)iterator.CurrentPosition;
                    return (double)0;
                case FT.FuncNameSpaceUri:
                    if (_Opnd != null) {
                        _Opnd.setContext(qyContext.Clone());
                        if (( eNext = _Opnd.advance()) != null)
                            return eNext.NamespaceURI;
                        else
                            return String.Empty;
                    }
                    if (qyContext != null)
                        return qyContext.NamespaceURI;

                    return String.Empty;
                case FT.FuncLocalName:
                    if (_Opnd != null) {
                        _Opnd.setContext(qyContext.Clone());
                        if (( eNext = _Opnd.advance()) != null)
                            return eNext.LocalName;
                        else
                            return String.Empty;
                    }
                    if (qyContext != null)
                        return qyContext.LocalName;

                    return String.Empty;
                case FT.FuncName :
                    if (_Opnd != null) {
                        _Opnd.setContext(qyContext.Clone());
                        if (( eNext = _Opnd.advance()) != null)
                            return eNext.Name;
                        else
                            return String.Empty;
                    }
                    if (qyContext != null)
                        return qyContext.Name;
                    return String.Empty;

                case FT.FuncCount:
                    int i = 0;
                    _Opnd.setContext(qyContext.Clone());
                    if (checkWhitespace) {
                        XPathNavigator nav;
                        while ((nav = _Opnd.advance())!= null) {
                            if (nav.NodeType != XPathNodeType.Whitespace || context.PreserveWhitespace(nav)) { 
                                i++;
                            }
                        }
                        return (double)i;
                    }
                    while (_Opnd.advance()!= null)
                        i++;
                    return (double)i;
                case FT.FuncLast:
                    if (iterator != null)
                        return (double)iterator.Count;
                    else
                        return (double)0;


            }
            return String.Empty;
        }
        internal override XPathResultType  ReturnType() {
            if (_FType <= FT.FuncCount)
                return XPathResultType.Number;
            return XPathResultType.String;
        }

        internal override IQuery Clone() {
            MethodOperand method = (_Opnd != null) ? 
                new MethodOperand(_Opnd.Clone(), _FType) : 
                new MethodOperand(null, _FType)
            ;
            method.checkWhitespace = this.checkWhitespace;
            method.context         = this.context;
            return method;
       }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xpath\logicalexpr.cs ===
//------------------------------------------------------------------------------
// <copyright file="LogicalExpr.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.XPath {
    using System.Xml; 
    using System.Xml.Xsl;

    internal sealed class LogicalExpr : IQuery {

        IQuery _opnd1;
        IQuery _opnd2;

        Operator.Op _op;
        
        internal override void SetXsltContext(XsltContext context){
            _opnd1.SetXsltContext(context);
            _opnd2.SetXsltContext(context);
        }

        delegate bool compare(IQuery opnd1, IQuery opnd2, IQuery qyContext, Operator.Op op);
        delegate bool compareforXslt(IQuery opnd1, IQuery opnd2, XPathNavigator qyContext, Operator.Op op, XPathNodeIterator iterator);

        private static readonly compare[,] Comp_fn1 = {{   
                new compare(LogicalExpr.compareNumberNumber), 
                new compare(LogicalExpr.compareNumberString),
                new compare(LogicalExpr.compareNumberBool1),
                new compare(LogicalExpr.compareNumberQuery)
            }, {
                new compare(LogicalExpr.compareStringNumber),
                new compare(LogicalExpr.compareStringString1),
                new compare(LogicalExpr.compareStringBool1),
                new compare(LogicalExpr.compareStringQuery1)
            }, {
                new compare(LogicalExpr.compareBoolNumber1),
                new compare(LogicalExpr.compareBoolString1),
                new compare(LogicalExpr.compareBoolBool1),
                new compare(LogicalExpr.compareBoolQuery1)
            }, {
                new compare(LogicalExpr.compareQueryNumber),
                new compare(LogicalExpr.compareQueryString1),
                new compare(LogicalExpr.compareQueryBool1),
                new compare(LogicalExpr.compareQueryQuery1)
        }};

        private static readonly compareforXslt[,] Comp_fn11 = {{   
                new compareforXslt(LogicalExpr.compareNumberNumber), 
                new compareforXslt(LogicalExpr.compareNumberString),
                new compareforXslt(LogicalExpr.compareNumberBool1),
                new compareforXslt(LogicalExpr.compareNumberQuery)
            }, {
                new compareforXslt(LogicalExpr.compareStringNumber),
                new compareforXslt(LogicalExpr.compareStringString1),
                new compareforXslt(LogicalExpr.compareStringBool1),
                new compareforXslt(LogicalExpr.compareStringQuery1)
            }, {
                new compareforXslt(LogicalExpr.compareBoolNumber1),
                new compareforXslt(LogicalExpr.compareBoolString1),
                new compareforXslt(LogicalExpr.compareBoolBool1),
                new compareforXslt(LogicalExpr.compareBoolQuery1)
            }, {
                new compareforXslt(LogicalExpr.compareQueryNumber),
                new compareforXslt(LogicalExpr.compareQueryString1),
                new compareforXslt(LogicalExpr.compareQueryBool1),
                new compareforXslt(LogicalExpr.compareQueryQuery1)
        }};


        private static readonly compare[,] Comp_fn2 = {{
                new compare(LogicalExpr.compareNumberNumber),
                new compare(LogicalExpr.compareNumberString),
                new compare(LogicalExpr.compareNumberBool2),
                new compare(LogicalExpr.compareNumberQuery)
            }, {
                new compare(LogicalExpr.compareStringNumber),
                new compare(LogicalExpr.compareStringString2),
                new compare(LogicalExpr.compareStringBool2),
                new compare(LogicalExpr.compareStringQuery2)
            }, {
                new compare(LogicalExpr.compareBoolNumber2),
                new compare(LogicalExpr.compareBoolString2),
                new compare(LogicalExpr.compareBoolBool2),
                new compare(LogicalExpr.compareBoolQuery2)
            }, {
                new compare(LogicalExpr.compareQueryNumber),
                new compare(LogicalExpr.compareQueryString2),
                new compare(LogicalExpr.compareQueryBool2),
                new compare(LogicalExpr.compareQueryQuery2)
        }};

       private static readonly compareforXslt[,] Comp_fn22 = {{
                new compareforXslt(LogicalExpr.compareNumberNumber),
                new compareforXslt(LogicalExpr.compareNumberString),
                new compareforXslt(LogicalExpr.compareNumberBool2),
                new compareforXslt(LogicalExpr.compareNumberQuery)
            }, {
                new compareforXslt(LogicalExpr.compareStringNumber),
                new compareforXslt(LogicalExpr.compareStringString2),
                new compareforXslt(LogicalExpr.compareStringBool2),
                new compareforXslt(LogicalExpr.compareStringQuery2)
            }, {
                new compareforXslt(LogicalExpr.compareBoolNumber2),
                new compareforXslt(LogicalExpr.compareBoolString2),
                new compareforXslt(LogicalExpr.compareBoolBool2),
                new compareforXslt(LogicalExpr.compareBoolQuery2)
            }, {
                new compareforXslt(LogicalExpr.compareQueryNumber),
                new compareforXslt(LogicalExpr.compareQueryString2),
                new compareforXslt(LogicalExpr.compareQueryBool2),
                new compareforXslt(LogicalExpr.compareQueryQuery2)
        }};

        
        LogicalExpr() {
        }

        internal LogicalExpr(Operator.Op op, IQuery  opnd1, IQuery  opnd2) {
            _opnd1= opnd1;
            _opnd2= opnd2;
            _op= op;
        }

        internal override void reset() {
            _opnd1.reset();
            _opnd2.reset();
        }

        static bool compareQueryQuery1(
                                      IQuery opnd1,
                                      IQuery opnd2,
                                      XPathNavigator qyContext,
                                      Operator.Op op,
                                      XPathNodeIterator iterator) {
            return compareQueryQuery1(opnd1, opnd2, new XPathSelfQuery(qyContext), op);
        }
        
        static bool compareQueryQuery1(
                                      IQuery opnd1,
                                      IQuery opnd2,
                                      IQuery qyContext,
                                      Operator.Op op) {
            XPathNavigator val1, val2; 
            String str1,str2;  
            opnd1.setContext(qyContext.peekElement().Clone()); 
            opnd2.setContext(qyContext.peekElement().Clone());
            while (true) {
                val1 = opnd1.advance();
                if (val1 != null)
                    str1 = val1.Value;
                else
                    return false;

                val2 = opnd2.advance();

                if (val2 != null)
                    str2 = val2.Value;
                else
                    return false;

                while (true) {
                    switch (op) {
                        case Operator.Op.EQ :
                            if (str1 == str2)
                                return true;
                            break;
                        case Operator.Op.NE :
                            if (str1 != str2)
                                return true;
			                break;
                    }
                    val2 = opnd2.advance();
                    if (val2 != null)
                        str2 = val2.Value;
                    else {
                        opnd2.reset();    
                        break;
                    }           
                }
            }
        }

        static bool compareQueryQuery2(
                                      IQuery opnd1,
                                      IQuery opnd2,
                                      XPathNavigator qyContext,
                                      Operator.Op op,
                                      XPathNodeIterator iterator) {
            return compareQueryQuery2(opnd1, opnd2, new XPathSelfQuery(qyContext), op);
        }
        
        static bool compareQueryQuery2(
                                      IQuery opnd1,
                                      IQuery opnd2,
                                      IQuery qyContext,
                                      Operator.Op op) {
            XPathNavigator val1, val2;
            double n1,n2;   
            opnd1.setContext(qyContext.peekElement().Clone()); 
            opnd2.setContext(qyContext.peekElement().Clone());
            while (true) {
                val1 = opnd1.advance();
                if (val1 != null)
                    n1 = NumberFunctions.Number(val1.Value);
                else
                    return false;
                val2 = opnd2.advance();

                if (val2 != null)
                    n2 = NumberFunctions.Number(val2.Value);
                else
                    return false;
                while (true) {

                    switch (op) {
                        case Operator.Op.LT : if (n1 < n2) return true;
                            break;
                        case Operator.Op.GT : if (n1 > n2) return true;
                            break;
                        case Operator.Op.LE : if (n1 <= n2) return true;
                            break;
                        case Operator.Op.GE : if (n1 >= n2) return true;
                            break;
                        case Operator.Op.EQ : if (n1 == n2) return true;
                            break;
		        case Operator.Op.NE : if (n1 != n2) return true;
			    break;
                    }
                    val2 = opnd2.advance();
                    if (val2 != null)
                        n2 = NumberFunctions.Number(val2.Value);
                    else {
                        opnd2.reset();    
                        break;
                    }

                }
            }

        }
        static bool compareQueryNumber(
                                      IQuery opnd1,
                                      IQuery opnd2,
                                      IQuery qyContext,
                                      Operator.Op op) {
            XPathNavigator val1;
            opnd1.setContext(qyContext.peekElement().Clone()); 
            double n1, n2 = XmlConvert.ToXPathDouble(opnd2.getValue(qyContext));

            while (true) {
                val1 = opnd1.advance();
                if (val1 != null)
                    n1 = NumberFunctions.Number(val1.Value);
                else
                    return false;

                switch (op) {
                    
                    case Operator.Op.LT : if (n1 <  n2) return true;
                        break;                                          
                    case Operator.Op.GT : if (n1 >  n2) return true;
                        break;
                    case Operator.Op.LE : if (n1 <= n2) return true;
                        break;
                    case Operator.Op.GE : if (n1 >= n2) return true;
                        break;
                    case Operator.Op.EQ : if (n1 == n2) return true;
                        break;
                    case Operator.Op.NE : if (n1 != n2) return true;
                        break;
                }
            }
        }

       static bool compareQueryNumber(
                                      IQuery opnd1,
                                      IQuery opnd2,
                                      XPathNavigator qyContext,
                                      Operator.Op op,
                                      XPathNodeIterator iterator) {
            XPathNavigator val1;
            opnd1.setContext(qyContext.Clone()); 
            double n1, n2 = XmlConvert.ToXPathDouble(opnd2.getValue(qyContext, iterator));

            while (true) {
                val1 = opnd1.advance();
                if (val1 != null)
                    n1 = NumberFunctions.Number(val1.Value);
                else
                    return false;

                switch (op) {
                    
                    case Operator.Op.LT : if (n1 <  n2) return true;
                        break;                                          
                    case Operator.Op.GT : if (n1 >  n2) return true;
                        break;
                    case Operator.Op.LE : if (n1 <= n2) return true;
                        break;
                    case Operator.Op.GE : if (n1 >= n2) return true;
                        break;
                    case Operator.Op.EQ : if (n1 == n2) return true;
                        break;
                    case Operator.Op.NE : if (n1 != n2) return true;
                        break;
                }
            }
        }
        
        static bool compareNumberQuery(
                                      IQuery opnd1,
                                      IQuery opnd2,
                                      IQuery qyContext,
                                      Operator.Op op
                                      ) {
            XPathNavigator val1;
            opnd2.setContext(qyContext.peekElement().Clone()); 
            double n2, n1 = XmlConvert.ToXPathDouble(opnd1.getValue(qyContext));

            while (true) {
                val1 = opnd2.advance();
                if (val1 != null)
                    n2 = NumberFunctions.Number(val1.Value);
                else
                    return false;

                switch (op) {
                    
                    case Operator.Op.LT : if (n1 <  n2) return true;
                        break;
                    case Operator.Op.GT : if (n1 >  n2) return true;
                        break;
                    case Operator.Op.LE : if (n1 <= n2) return true;
                        break;
                    case Operator.Op.GE : if (n1 >= n2) return true;
                        break;
                    case Operator.Op.EQ : if (n1 == n2) return true;
                        break;
                    case Operator.Op.NE : if (n1 != n2) return true;
                        break;
		        }
            }
        }
       static bool compareNumberQuery(
                                      IQuery opnd1,
                                      IQuery opnd2,
                                      XPathNavigator qyContext,
                                      Operator.Op op,
                                      XPathNodeIterator iterator) {
            XPathNavigator val1;
            opnd2.setContext(qyContext.Clone()); 
            double n2, n1 = XmlConvert.ToXPathDouble(opnd1.getValue(qyContext, iterator));

            while (true) {
                val1 = opnd2.advance();
                if (val1 != null)
                    n2 = NumberFunctions.Number(val1.Value);
                else
                    return false;

                switch (op) {
                    
                    case Operator.Op.LT : if (n1 <  n2) return true;
                        break;
                    case Operator.Op.GT : if (n1 >  n2) return true;
                        break;
                    case Operator.Op.LE : if (n1 <= n2) return true;
                        break;
                    case Operator.Op.GE : if (n1 >= n2) return true;
                        break;
                    case Operator.Op.EQ : if (n1 == n2) return true;
                        break;
                    case Operator.Op.NE : if (n1 != n2) return true;
                        break;
		        }
            }
        }
        
        static bool compareQueryString1(IQuery opnd1, IQuery opnd2, IQuery qyContext, Operator.Op op) {
            XPathNavigator val1;
            opnd1.setContext(qyContext.peekElement().Clone()); 
            String n2 = XmlConvert.ToXPathString(opnd2.getValue(qyContext));
            while ((val1 = opnd1.advance()) != null) {
                if (op == Operator.Op.EQ) {
                    if (val1.Value == n2) return true;
                }
                else if (val1.Value != n2) return true;
            }
            return false;
        }

        static bool compareQueryString1(IQuery opnd1, IQuery opnd2, XPathNavigator qyContext, Operator.Op op, XPathNodeIterator iterator) {
            XPathNavigator val1;
            opnd1.setContext(qyContext.Clone()); 
            String n2 = XmlConvert.ToXPathString(opnd2.getValue(qyContext, iterator));
            while ((val1 = opnd1.advance()) != null) {
                if (op == Operator.Op.EQ) {
                    if (val1.Value == n2) return true;
                }
                else if (val1.Value != n2) return true;
            }
            return false;
        }

       static bool compareQueryString2(IQuery opnd1, IQuery opnd2, IQuery qyContext, Operator.Op op) {

            XPathNavigator val1;
            opnd1.setContext(qyContext.peekElement().Clone()); 
            double n1, n2 = NumberFunctions.Number(XmlConvert.ToXPathString(opnd2.getValue(qyContext)));

            while (true) {
                val1 = opnd1.advance();
                if (val1 != null)
                    n1 = NumberFunctions.Number(val1.Value);
                else
                    return false;

                switch (op) {
                    
                    case Operator.Op.LT :if (n1 <  n2) return true;
                        break;
                    case Operator.Op.GT :if (n1 >  n2) return true;
                        break;
                    case Operator.Op.LE :if (n1 <= n2) return true;
                        break;
                    case Operator.Op.GE :if (n1 >= n2)  return true;
                        break;
                    case Operator.Op.EQ :if (n1 == n2) return true;
                        break;
                    case Operator.Op.NE :if (n1 != n2) return true;
                        break;
                }
            }
        }
        
        static bool compareQueryString2(IQuery opnd1, IQuery opnd2, XPathNavigator qyContext, Operator.Op op, XPathNodeIterator iterator) {

            XPathNavigator val1;
            opnd1.setContext(qyContext.Clone()); 
            double n1, n2 = NumberFunctions.Number(XmlConvert.ToXPathString(opnd2.getValue(qyContext, iterator)));

            while (true) {
                val1 = opnd1.advance();
                if (val1 != null)
                    n1 = NumberFunctions.Number(val1.Value);
                else
                    return false;

                switch (op) {
                    
                    case Operator.Op.LT :if (n1 <  n2) return true;
                        break;
                    case Operator.Op.GT :if (n1 >  n2) return true;
                        break;
                    case Operator.Op.LE :if (n1 <= n2) return true;
                        break;
                    case Operator.Op.GE :if (n1 >= n2)  return true;
                        break;
                    case Operator.Op.EQ :if (n1 == n2) return true;
                        break;
                    case Operator.Op.NE :if (n1 != n2) return true;
                        break;
                }
            }
        }

        static bool compareStringQuery1(IQuery opnd1, IQuery opnd2, IQuery qyContext, Operator.Op op) {
            XPathNavigator val1;
            opnd2.setContext(qyContext.peekElement().Clone()); 
            String n2, n1 = XmlConvert.ToXPathString(opnd1.getValue(qyContext));

            while (true) {
                val1 = opnd2.advance();
                if (val1 != null)
                    n2 = val1.Value;
                else
                    return false;

                switch (op) {
                    
                    case Operator.Op.EQ : if (n1 == n2) return true ;
                        break;
                    case Operator.Op.NE : if (n1 != n2) return true ;
                        break;
                }

            }
        }

        static bool compareStringQuery1(IQuery opnd1, IQuery opnd2, XPathNavigator qyContext, Operator.Op op , XPathNodeIterator iterator) {
            XPathNavigator val1;
            opnd2.setContext(qyContext.Clone()); 
            String n2, n1 = XmlConvert.ToXPathString(opnd1.getValue(qyContext, iterator));

            while (true) {
                val1 = opnd2.advance();
                if (val1 != null)
                    n2 = val1.Value;
                else
                    return false;

                switch (op) {
                    
                    case Operator.Op.EQ : if (n1 == n2) return true ;
                        break;
                    case Operator.Op.NE : if (n1 != n2) return true ;
                        break;
                }

            }
        }

        static bool compareStringQuery2(IQuery opnd1, IQuery opnd2, IQuery qyContext, Operator.Op op) {
            XPathNavigator val1;
            opnd1.setContext(qyContext.peekElement().Clone()); 
            double n2, n1 = NumberFunctions.Number(XmlConvert.ToXPathString(opnd1.getValue(qyContext)));

            while (true) {
                val1 = opnd2.advance();
                if (val1 != null)
                    n2 = NumberFunctions.Number(val1.Value);
                else
                    return false;

                switch (op) {
                    
                    case Operator.Op.LT :if (n1 <  n2) return true ;
                        break;
                    case Operator.Op.GT :if (n1 >  n2) return true ;
                        break;
                    case Operator.Op.LE :if (n1 <= n2) return true ;
                        break;
                    case Operator.Op.GE :if (n1 >= n2) return true ;
                        break;
                    case Operator.Op.EQ :if (n1 == n2) return true ;
                        break;
                    case Operator.Op.NE :if (n1 != n2) return true ;
                        break;

                }

            }
        }

      static bool compareStringQuery2(IQuery opnd1, IQuery opnd2, XPathNavigator qyContext, Operator.Op op, XPathNodeIterator iterator) {
            XPathNavigator val1;
            opnd2.setContext(qyContext.Clone()); 
            double n2, n1 = NumberFunctions.Number(XmlConvert.ToXPathString(opnd1.getValue(qyContext, iterator)));

            while (true) {
                val1 = opnd2.advance();
                if (val1 != null)
                    n2 = NumberFunctions.Number(val1.Value);
                else
                    return false;

                switch (op) {
                    
                    case Operator.Op.LT :if (n1 <  n2) return true ;
                        break;
                    case Operator.Op.GT :if (n1 >  n2) return true ;
                        break;
                    case Operator.Op.LE :if (n1 <= n2) return true ;
                        break;
                    case Operator.Op.GE :if (n1 >= n2) return true ;
                        break;
                    case Operator.Op.EQ :if (n1 == n2) return true ;
                        break;
                    case Operator.Op.NE :if (n1 != n2) return true ;
                        break;

                }

            }
        }


        static bool compareQueryBool1(IQuery opnd1, IQuery opnd2, IQuery qyContext, Operator.Op op) {
            XPathNavigator val1;
            opnd1.setContext(qyContext.peekElement().Clone()); 
            Boolean n1 = false, n2 = Convert.ToBoolean(opnd2.getValue(qyContext));

                val1 = opnd1.advance();
                if (val1 != null) {
                    n1 = true;
                }
                else {
                    if (op ==  Operator.Op.EQ ) {
                        return (n2 == n1);
                    }
                    return (n2 != n1);
                }

                switch (op) {
                    
                    case Operator.Op.EQ : return (n1 == n2)  ;
                    case Operator.Op.NE : return (n1 != n2) ;
                }
                return false;

        }

        static bool compareQueryBool1(IQuery opnd1, IQuery opnd2, XPathNavigator qyContext, Operator.Op op, XPathNodeIterator iterator) {
            XPathNavigator val1;
            opnd1.setContext(qyContext.Clone()); 
            Boolean n1 = false, n2 = Convert.ToBoolean(opnd2.getValue(qyContext, iterator));

                val1 = opnd1.advance();
                if (val1 != null) {
                    n1 = true;
                }
                else {
                    if (op ==  Operator.Op.EQ ) {
                        return (n2 == n1);
                    }
                    return (n2 != n1);
                }

                switch (op) {
                    
                    case Operator.Op.EQ : return (n1 == n2)  ;
                    case Operator.Op.NE : return (n1 != n2)  ;
                }
                return false;

        }
        static bool compareQueryBool2(IQuery opnd1, IQuery opnd2, IQuery qyContext, Operator.Op op) {
            XPathNavigator val1;
            opnd1.setContext(qyContext.peekElement().Clone()); 
            double n1, n2 = NumberFunctions.Number(Convert.ToBoolean(opnd2.getValue(qyContext)));

                val1 = opnd1.advance();
                if (val1 != null)
                    n1 = 1.0;
                else {
                    n1 = 0;
                    switch (op) {                    
                        case Operator.Op.LT : return (n1 <  n2) ;
                        case Operator.Op.GT : return (n1 >  n2) ;
                        case Operator.Op.LE : return (n1 <= n2) ;
                        case Operator.Op.GE : return (n1 >= n2) ;

                    }
                }

                switch (op) {
                    
                    case Operator.Op.LT : return (n1 <  n2) ;
                    case Operator.Op.GT : return (n1 >  n2) ;
                    case Operator.Op.LE : return (n1 <= n2) ;
                    case Operator.Op.GE : return (n1 >= n2) ;

                }
                return false;

        }

       static bool compareQueryBool2(IQuery opnd1, IQuery opnd2, XPathNavigator qyContext, Operator.Op op, XPathNodeIterator iterator) {
            XPathNavigator val1;
            opnd1.setContext(qyContext.Clone()); 
            double n1, n2 = NumberFunctions.Number(Convert.ToBoolean(opnd2.getValue(qyContext, iterator)));

                val1 = opnd1.advance();
                if (val1 != null)
                    n1 = 1.0;
                else {
                    n1 = 0;
                    switch (op) {                    
                        case Operator.Op.LT : return (n1 <  n2) ;
                        case Operator.Op.GT : return (n1 >  n2) ;
                        case Operator.Op.LE : return (n1 <= n2) ;
                        case Operator.Op.GE : return (n1 >= n2) ;

                    }
                }
                switch (op) {
                    
                    case Operator.Op.LT : return (n1 <  n2) ;
                    case Operator.Op.GT : return (n1 >  n2) ;
                    case Operator.Op.LE : return (n1 <= n2) ;
                    case Operator.Op.GE : return (n1 >= n2) ;

                }
                return false;

        }
        static bool compareBoolQuery1(IQuery opnd1, IQuery opnd2, IQuery qyContext, Operator.Op op) {
            XPathNavigator val1;
            opnd2.setContext(qyContext.peekElement().Clone()); 
            Boolean n2 = false, n1 = Convert.ToBoolean(opnd1.getValue(qyContext));

                val1 = opnd2.advance();
                if (val1 != null)
                    n2 = true;
                else {
                    if (op ==  Operator.Op.EQ ) {
                        return (n2 == n1);
                    }
                    return (n2 != n1);
                }
                    

                switch (op) {
                    
                    case Operator.Op.EQ : return (n1 == n2) ;
                    case Operator.Op.NE : return (n1 != n2) ;
                }
                return false;

        }

      static bool compareBoolQuery1(IQuery opnd1, IQuery opnd2, XPathNavigator qyContext, Operator.Op op, XPathNodeIterator iterator) {
            XPathNavigator val1;
            opnd2.setContext(qyContext.Clone()); 
            Boolean n2 = false, n1 = Convert.ToBoolean(opnd1.getValue(qyContext, iterator));

                val1 = opnd2.advance();
                if (val1 != null)
                    n2 = true;
                else {
                    if (op ==  Operator.Op.EQ ) {
                        return (n2 == n1);
                    }
                    return (n2 != n1);
                }

                switch (op) {
                    
                    case Operator.Op.EQ : return (n1 == n2) ;
                    case Operator.Op.NE : return (n1 != n2) ;
                }
                return false;

        }

        static bool compareBoolQuery2(IQuery opnd1, IQuery opnd2, IQuery qyContext, Operator.Op op) {
            XPathNavigator val1;
            opnd2.setContext(qyContext.peekElement().Clone()); 
            double n2, n1 = NumberFunctions.Number(Convert.ToBoolean(opnd1.getValue(qyContext)));

                val1 = opnd2.advance();
                if (val1 != null)
                    n2 = 1.0;
               else {
                    n2 = 0;
                    switch (op) {                    
                        case Operator.Op.LT : return (n1 <  n2) ;
                        case Operator.Op.GT : return (n1 >  n2) ;
                        case Operator.Op.LE : return (n1 <= n2) ;
                        case Operator.Op.GE : return (n1 >= n2) ;

                    }
                }
                switch (op) {
                    
                    case Operator.Op.LT : return (n1 <  n2)  ;
                    case Operator.Op.GT : return (n1 >  n2)   ;
                    case Operator.Op.LE : return (n1 <= n2)  ;
                    case Operator.Op.GE : return (n1 >= n2)  ;
                }
                return false;

        }

        static bool compareBoolQuery2(IQuery opnd1, IQuery opnd2, XPathNavigator qyContext, Operator.Op op, XPathNodeIterator iterator) {
            XPathNavigator val1;
            opnd2.setContext(qyContext.Clone()); 
            double n2, n1 = NumberFunctions.Number(Convert.ToBoolean(opnd1.getValue(qyContext, iterator)));

                val1 = opnd2.advance();
                if (val1 != null)
                    n2 = 1.0;
                else {
                    n2 = 0;
                    switch (op) {                    
                        case Operator.Op.LT : return (n1 <  n2) ;
                        case Operator.Op.GT : return (n1 >  n2) ;
                        case Operator.Op.LE : return (n1 <= n2) ;
                        case Operator.Op.GE : return (n1 >= n2) ;

                    }
                }

                switch (op) {
                    
                    case Operator.Op.LT : return (n1 <  n2)  ;
                    case Operator.Op.GT : return (n1 >  n2)  ;
                    case Operator.Op.LE : return (n1 <= n2) ;
                    case Operator.Op.GE : return (n1 >= n2)   ;
                }
                return false;

        }
        
        static bool compareBoolBool1(IQuery opnd1, IQuery opnd2, IQuery qyContext, Operator.Op op) {
            Boolean n1 = Convert.ToBoolean(opnd1.getValue(qyContext));
            Boolean n2 = Convert.ToBoolean(opnd2.getValue(qyContext));
            switch (op) {
                
                case Operator.Op.EQ : return( n1 == n2 ) ;
                case Operator.Op.NE : return( n1 != n2 ) ;
            } 
            return false;

        }

        static bool compareBoolBool1(IQuery opnd1, IQuery opnd2, XPathNavigator qyContext, Operator.Op op, XPathNodeIterator iterator) {
            Boolean n1 = Convert.ToBoolean(opnd1.getValue(qyContext, iterator));
            Boolean n2 = Convert.ToBoolean(opnd2.getValue(qyContext, iterator));
            switch (op) {
                
                case Operator.Op.EQ : return( n1 == n2 ) ;
                case Operator.Op.NE : return( n1 != n2 ) ;
            } 
            return false;

        }

        static bool compareBoolBool2(IQuery opnd1, IQuery opnd2, IQuery qyContext, Operator.Op op) {
            double n1 = NumberFunctions.Number(Convert.ToBoolean(opnd1.getValue(qyContext)));
            double n2 = NumberFunctions.Number(Convert.ToBoolean(opnd2.getValue(qyContext)));
            switch (op) {
                
                case Operator.Op.LT : return( n1 <  n2 ) ;
                case Operator.Op.GT : return( n1 >  n2 ) ;
                case Operator.Op.LE : return( n1 <= n2 ) ;
                case Operator.Op.GE : return( n1 >= n2 ) ;
            } 
            return false;

        }

       static bool compareBoolBool2(IQuery opnd1, IQuery opnd2, XPathNavigator qyContext, Operator.Op op, XPathNodeIterator iterator) {
            double n1 = NumberFunctions.Number(Convert.ToBoolean(opnd1.getValue(qyContext, iterator)));
            double n2 = NumberFunctions.Number(Convert.ToBoolean(opnd2.getValue(qyContext, iterator)));
            switch (op) {
                
                case Operator.Op.LT : return( n1 <  n2 ) ;
                case Operator.Op.GT : return( n1 >  n2 ) ;
                case Operator.Op.LE : return( n1 <= n2 ) ;
                case Operator.Op.GE : return( n1 >= n2 ) ;
            } 
            return false;

        }
        static bool compareBoolNumber1(IQuery opnd1, IQuery opnd2, IQuery qyContext, Operator.Op op) {
            Boolean n1 = Convert.ToBoolean(opnd1.getValue(qyContext));
            Boolean n2 = BooleanFunctions.toBoolean(XmlConvert.ToXPathDouble(opnd2.getValue(qyContext)));  
            switch (op) {
                

                case Operator.Op.EQ : return( n1 == n2 ) ;
                case Operator.Op.NE : return( n1 != n2 ) ;
            }
            return false;

        }

      static bool compareBoolNumber1(IQuery opnd1, IQuery opnd2, XPathNavigator qyContext, Operator.Op op, XPathNodeIterator iterator) {
            Boolean n1 = Convert.ToBoolean(opnd1.getValue(qyContext, iterator));
            Boolean n2 = BooleanFunctions.toBoolean(XmlConvert.ToXPathDouble(opnd2.getValue(qyContext, iterator)));  
            switch (op) {
                

                case Operator.Op.EQ : return( n1 == n2 ) ;
                case Operator.Op.NE : return( n1 != n2 ) ;
            }
            return false;

        }
        static bool compareBoolNumber2(IQuery opnd1, IQuery opnd2, IQuery qyContext, Operator.Op op) {
            double n1 = NumberFunctions.Number(Convert.ToBoolean(opnd1.getValue(qyContext)));
            double n2 = XmlConvert.ToXPathDouble(opnd2.getValue(qyContext));  
            switch (op) {
                
                case Operator.Op.LT : return( n1 <  n2 ) ;
                case Operator.Op.GT : return( n1 >  n2 ) ;
                case Operator.Op.LE : return( n1 <= n2 ) ;
                case Operator.Op.GE : return( n1 >= n2 ) ;
            }
            return false;
        }

       static bool compareBoolNumber2(IQuery opnd1, IQuery opnd2, XPathNavigator qyContext, Operator.Op op, XPathNodeIterator iterator) {
            double n1 = NumberFunctions.Number(Convert.ToBoolean(opnd1.getValue(qyContext, iterator)));
            double n2 = XmlConvert.ToXPathDouble(opnd2.getValue(qyContext, iterator));  
            switch (op) {
                
                case Operator.Op.LT : return( n1 <  n2 ) ;
                case Operator.Op.GT : return( n1 >  n2 ) ;
                case Operator.Op.LE : return( n1 <= n2 ) ;
                case Operator.Op.GE : return( n1 >= n2 ) ;
            }
            return false;
        }
        
        static bool compareBoolString1(IQuery opnd1, IQuery opnd2, IQuery qyContext, Operator.Op op) {
            Boolean n1 = Convert.ToBoolean(opnd1.getValue(qyContext));
            Boolean n2 = BooleanFunctions.toBoolean(XmlConvert.ToXPathString(opnd2.getValue(qyContext)));  
            switch (op) {
                
                case Operator.Op.EQ : return( n1 == n2 );
                case Operator.Op.NE : return( n1 != n2 );
            } 
            return false;

        }

       static bool compareBoolString1(IQuery opnd1, IQuery opnd2, XPathNavigator qyContext, Operator.Op op, XPathNodeIterator iterator) {
            Boolean n1 = Convert.ToBoolean(opnd1.getValue(qyContext, iterator));
            Boolean n2 = BooleanFunctions.toBoolean(XmlConvert.ToXPathString(opnd2.getValue(qyContext, iterator)));  
            switch (op) {
                
                case Operator.Op.EQ : return( n1 == n2 );
                case Operator.Op.NE : return( n1 != n2 );
            } 
            return false;

        }
        
        static bool compareBoolString2(IQuery opnd1, IQuery opnd2, IQuery qyContext, Operator.Op op) {
            double n1 = NumberFunctions.Number(Convert.ToBoolean(opnd1.getValue(qyContext)));
            double n2 = NumberFunctions.Number(XmlConvert.ToXPathString(opnd2.getValue(qyContext)));
            switch (op) {
                
                case Operator.Op.LT : return( n1 <  n2 ) ;
                case Operator.Op.GT : return( n1 >  n2 ) ;
                case Operator.Op.LE : return( n1 <= n2 ) ;
                case Operator.Op.GE : return( n1 >= n2 ) ;
            } 
            return false;
        }      

       static bool compareBoolString2(IQuery opnd1, IQuery opnd2, XPathNavigator qyContext, Operator.Op op, XPathNodeIterator iterator) {
            double n1 = NumberFunctions.Number(Convert.ToBoolean(opnd1.getValue(qyContext, iterator)));
            double n2 = NumberFunctions.Number(XmlConvert.ToXPathString(opnd2.getValue(qyContext, iterator)));
            switch (op) {
                
                case Operator.Op.LT : return( n1 <  n2 ) ;
                case Operator.Op.GT : return( n1 >  n2 ) ;
                case Operator.Op.LE : return( n1 <= n2 ) ;
                case Operator.Op.GE : return( n1 >= n2 ) ;
            } 
            return false;
        }      
        
        static bool compareNumberNumber(IQuery opnd1, IQuery opnd2, IQuery qyContext, Operator.Op op) {

            double n1 = XmlConvert.ToXPathDouble(opnd1.getValue(qyContext));
            double n2 = XmlConvert.ToXPathDouble(opnd2.getValue(qyContext));  
            switch (op) {
                
                case Operator.Op.LT : return( n1 <  n2 ) ;
                case Operator.Op.GT : return( n1 >  n2 ) ;
                case Operator.Op.LE : return( n1 <= n2 ) ;
                case Operator.Op.GE : return( n1 >= n2 ) ;
                case Operator.Op.EQ : return( n1 == n2 ) ;
                case Operator.Op.NE : return( n1 != n2 ) ;
            }
            return false;
        }

      static bool compareNumberNumber(IQuery opnd1, IQuery opnd2, XPathNavigator qyContext, Operator.Op op, XPathNodeIterator iterator) {

            double n1 = XmlConvert.ToXPathDouble(opnd1.getValue(qyContext, iterator));
            double n2 = XmlConvert.ToXPathDouble(opnd2.getValue(qyContext, iterator));  
            switch (op) {
                
                case Operator.Op.LT : return( n1 <  n2 ) ;
                case Operator.Op.GT : return( n1 >  n2 ) ;
                case Operator.Op.LE : return( n1 <= n2 ) ;
                case Operator.Op.GE : return( n1 >= n2 ) ;
                case Operator.Op.EQ : return( n1 == n2 ) ;
                case Operator.Op.NE : return( n1 != n2 ) ;
            }
            return false;
        }

        static bool compareNumberBool1(IQuery opnd1, IQuery opnd2, IQuery qyContext, Operator.Op op) {
            Boolean n1 = BooleanFunctions.toBoolean(XmlConvert.ToXPathDouble(opnd1.getValue(qyContext)));
            Boolean n2 = Convert.ToBoolean(opnd2.getValue(qyContext));  
            switch (op) {
                

                case Operator.Op.EQ : return( n1 == n2 ) ;
                case Operator.Op.NE : return( n1 != n2 ) ;
            } 
            return false;
        }

       static bool compareNumberBool1(IQuery opnd1, IQuery opnd2, XPathNavigator qyContext, Operator.Op op, XPathNodeIterator iterator) {
            Boolean n1 = BooleanFunctions.toBoolean(XmlConvert.ToXPathDouble(opnd1.getValue(qyContext, iterator)));
            Boolean n2 = Convert.ToBoolean(opnd2.getValue(qyContext, iterator));  
            switch (op) {
                

                case Operator.Op.EQ : return( n1 == n2 ) ;
                case Operator.Op.NE : return( n1 != n2 ) ;
            } 
            return false;
        }

        static bool compareNumberBool2(IQuery opnd1, IQuery opnd2, IQuery qyContext, Operator.Op op) {
            double n1 = XmlConvert.ToXPathDouble(opnd1.getValue(qyContext));
            double n2 = NumberFunctions.Number(Convert.ToBoolean(opnd2.getValue(qyContext)));
            switch (op) {
                
                case Operator.Op.LT : return( n1 < n2 ) ;
                case Operator.Op.GT : return( n1 > n2 ) ;
                case Operator.Op.LE : return( n1 <= n2) ;
                case Operator.Op.GE : return( n1 >= n2) ;
            }
            return false;
        }


       static bool compareNumberBool2(IQuery opnd1, IQuery opnd2, XPathNavigator qyContext, Operator.Op op, XPathNodeIterator iterator) {
            double n1 = XmlConvert.ToXPathDouble(opnd1.getValue(qyContext, iterator));
            double n2 = NumberFunctions.Number(Convert.ToBoolean(opnd2.getValue(qyContext, iterator)));
            switch (op) {
                
                case Operator.Op.LT : return( n1 < n2 ) ;
                case Operator.Op.GT : return( n1 > n2 ) ;
                case Operator.Op.LE : return( n1 <= n2) ;
                case Operator.Op.GE : return( n1 >= n2) ;
            }
            return false;
        }
        
        static bool compareNumberString(IQuery opnd1, IQuery opnd2, IQuery qyContext, Operator.Op op) {
            double n1 = XmlConvert.ToXPathDouble(opnd1.getValue(qyContext));
            double n2 = NumberFunctions.Number(XmlConvert.ToXPathString(opnd2.getValue(qyContext)));  
            switch (op) {
                
                case Operator.Op.LT : return( n1 <  n2 ) ;
                case Operator.Op.GT : return( n1 >  n2 ) ;
                case Operator.Op.LE : return( n1 <= n2 ) ;
                case Operator.Op.GE : return( n1 >= n2 ) ;
                case Operator.Op.EQ : return( n1 == n2 ) ;
                case Operator.Op.NE : return( n1 != n2 ) ;
            }
            return false;
        }

      static bool compareNumberString(IQuery opnd1, IQuery opnd2, XPathNavigator qyContext, Operator.Op op, XPathNodeIterator iterator) {
            double n1 = XmlConvert.ToXPathDouble(opnd1.getValue(qyContext, iterator));
            double n2 = NumberFunctions.Number(XmlConvert.ToXPathString(opnd2.getValue(qyContext, iterator)));  
            switch (op) {
                
                case Operator.Op.LT : return( n1 <  n2 ) ;
                case Operator.Op.GT : return( n1 >  n2 ) ;
                case Operator.Op.LE : return( n1 <= n2 ) ;
                case Operator.Op.GE : return( n1 >= n2 ) ;
                case Operator.Op.EQ : return( n1 == n2 ) ;
                case Operator.Op.NE : return( n1 != n2 ) ;
            }
            return false;
        }
        
        static bool compareStringNumber(IQuery opnd1, IQuery opnd2, IQuery qyContext, Operator.Op op) {
            double n2 = XmlConvert.ToXPathDouble(opnd2.getValue(qyContext));
            double n1 = NumberFunctions.Number(XmlConvert.ToXPathString(opnd1.getValue(qyContext)));  
            switch (op) {
                
                case Operator.Op.LT : return( n1 <  n2 ) ;
                case Operator.Op.GT : return( n1 >  n2 ) ;
                case Operator.Op.LE : return( n1 <= n2 ) ;
                case Operator.Op.GE : return( n1 >= n2 ) ;
                case Operator.Op.EQ : return( n1 == n2 ) ;
                case Operator.Op.NE : return( n1 != n2 ) ;
            }
            return false;
        }

        static bool compareStringNumber(IQuery opnd1, IQuery opnd2, XPathNavigator qyContext, Operator.Op op, XPathNodeIterator iterator) {
            double n2 = XmlConvert.ToXPathDouble(opnd2.getValue(qyContext, iterator));
            double n1 = NumberFunctions.Number(XmlConvert.ToXPathString(opnd1.getValue(qyContext, iterator)));  
            switch (op) {
                
                case Operator.Op.LT : return( n1 <  n2 ) ;
                case Operator.Op.GT : return( n1 >  n2 ) ;
                case Operator.Op.LE : return( n1 <= n2 ) ;
                case Operator.Op.GE : return( n1 >= n2 ) ;
                case Operator.Op.EQ : return( n1 == n2 ) ;
                case Operator.Op.NE : return( n1 != n2 ) ;
            }
            return false;
        }

        static bool compareStringBool1(IQuery opnd1, IQuery opnd2, IQuery qyContext, Operator.Op op) {
            Boolean n2 = Convert.ToBoolean(opnd2.getValue(qyContext));
            Boolean n1 = BooleanFunctions.toBoolean(XmlConvert.ToXPathString(opnd1.getValue(qyContext)));  
            switch (op) {
                

                case Operator.Op.EQ : return( n1 == n2 ) ;
                case Operator.Op.NE : return( n1 != n2 ) ;
            } 
            return false;
        }

       static bool compareStringBool1(IQuery opnd1, IQuery opnd2, XPathNavigator qyContext, Operator.Op op, XPathNodeIterator iterator) {
            Boolean n2 = Convert.ToBoolean(opnd2.getValue(qyContext, iterator));
            Boolean n1 = BooleanFunctions.toBoolean(XmlConvert.ToXPathString(opnd1.getValue(qyContext, iterator)));  
            switch (op) {
                

                case Operator.Op.EQ : return( n1 == n2 ) ;
                case Operator.Op.NE : return( n1 != n2 ) ;
            } 
            return false;
        }
        
        static bool compareStringBool2(IQuery opnd1, IQuery opnd2, IQuery qyContext, Operator.Op op) {
            double n2 = NumberFunctions.Number(Convert.ToBoolean(opnd2.getValue(qyContext)));
            double n1 = NumberFunctions.Number(XmlConvert.ToXPathString(opnd1.getValue(qyContext)));
            switch (op) {
                
                case Operator.Op.LT : return( n1 <  n2 ) ;
                case Operator.Op.GT : return( n1 >  n2 ) ;
                case Operator.Op.LE : return( n1 <= n2 ) ;
                case Operator.Op.GE : return( n1 >= n2 ) ;
            }
            return false;
        } 

       static bool compareStringBool2(IQuery opnd1, IQuery opnd2, XPathNavigator qyContext, Operator.Op op, XPathNodeIterator iterator) {
            double n2 = NumberFunctions.Number(Convert.ToBoolean(opnd2.getValue(qyContext, iterator)));
            double n1 = NumberFunctions.Number(XmlConvert.ToXPathString(opnd1.getValue(qyContext, iterator)));
            switch (op) {
                
                case Operator.Op.LT : return( n1 <  n2 ) ;
                case Operator.Op.GT : return( n1 >  n2 ) ;
                case Operator.Op.LE : return( n1 <= n2 ) ;
                case Operator.Op.GE : return( n1 >= n2 ) ;
            }
            return false;
        } 
        
        static bool compareStringString1(IQuery opnd1, IQuery opnd2, IQuery qyContext, Operator.Op op) {
            String n1 = XmlConvert.ToXPathString(opnd1.getValue(qyContext));
            String n2 = XmlConvert.ToXPathString(opnd2.getValue(qyContext));  
            switch (op) {
                
                case Operator.Op.EQ : return( n1 == n2 ) ;
                case Operator.Op.NE : return( n1 != n2 ) ;
            }
            return false;

        } 

       static bool compareStringString1(IQuery opnd1, IQuery opnd2, XPathNavigator qyContext, Operator.Op op, XPathNodeIterator iterator) {
            String n1 = XmlConvert.ToXPathString(opnd1.getValue(qyContext, iterator));
            String n2 = XmlConvert.ToXPathString(opnd2.getValue(qyContext, iterator));  
            switch (op) {
                
                case Operator.Op.EQ : return( n1 == n2 ) ;
                case Operator.Op.NE : return( n1 != n2 ) ;
            }
            return false;

        } 

        static bool compareStringString2(IQuery opnd1, IQuery opnd2, IQuery qyContext, Operator.Op op) {
            double n1 = NumberFunctions.Number(XmlConvert.ToXPathString(opnd1.getValue(qyContext)));
            double n2 = NumberFunctions.Number(XmlConvert.ToXPathString(opnd2.getValue(qyContext)));
            switch (op) {
                case Operator.Op.LT : return( n1 <  n2 ) ;
                case Operator.Op.GT : return( n1 >  n2 ) ;
                case Operator.Op.LE : return( n1 <= n2 ) ;
                case Operator.Op.GE : return( n1 >= n2 ) ;
            } 
            return false;
        }

       static bool compareStringString2(IQuery opnd1, IQuery opnd2, XPathNavigator qyContext, Operator.Op op, XPathNodeIterator iterator) {
            double n1 = NumberFunctions.Number(XmlConvert.ToXPathString(opnd1.getValue(qyContext, iterator)));
            double n2 = NumberFunctions.Number(XmlConvert.ToXPathString(opnd2.getValue(qyContext, iterator)));
            switch (op) {
                case Operator.Op.LT : return( n1 <  n2 ) ;
                case Operator.Op.GT : return( n1 >  n2 ) ;
                case Operator.Op.LE : return( n1 <= n2 ) ;
                case Operator.Op.GE : return( n1 >= n2 ) ;
            } 
            return false;
        }

        override internal object getValue( IQuery  qyContext) {
            if (_op == Operator.Op.EQ || _op == Operator.Op.NE)
                return Comp_fn1[(int)_opnd1.ReturnType(),(int)_opnd2.ReturnType()](_opnd1,_opnd2,qyContext,_op);
            else {
                return Comp_fn2[(int)_opnd1.ReturnType(),(int)_opnd2.ReturnType()](_opnd1,_opnd2,qyContext,_op);
            }
        }
        override internal object getValue( XPathNavigator  qyContext, XPathNodeIterator iterator) {
            if (_op == Operator.Op.EQ || _op == Operator.Op.NE)
                return Comp_fn11[(int)_opnd1.ReturnType(),(int)_opnd2.ReturnType()](_opnd1,_opnd2,qyContext,_op, iterator);
            else {
                return Comp_fn22[(int)_opnd1.ReturnType(),(int)_opnd2.ReturnType()](_opnd1,_opnd2,qyContext,_op, iterator);
            }
        }
        override internal XPathResultType ReturnType() {
            return XPathResultType.Boolean;
        }

        internal override IQuery Clone() {
            return new LogicalExpr(_op, _opnd1.Clone(),_opnd2.Clone());
        }



    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xpath\navigatorquery.cs ===
//------------------------------------------------------------------------------
// <copyright file="NavigatorQuery.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.XPath {
    using System.Xml; 

    using System.Collections;

    internal class NavigatorQuery : IQuery {
        private XPathNavigator _e = null;
        
        internal NavigatorQuery(XPathNavigator Input) {
            _e = Input;
        }
             
        internal override XPathNavigator advance() {
            throw new XPathException(Res.Xp_NodeSetExpected);
        }

        override internal XPathNavigator peekElement() {
            throw new XPathException(Res.Xp_NodeSetExpected);

        } 
        
        internal override IQuery Clone() {
            if (_e != null)
                return new NavigatorQuery(_e);
            return null;
        }
        
        internal override object getValue(IQuery qy) {
            return _e;
        }
        
        internal override object getValue(XPathNavigator qy, XPathNodeIterator iterator) {
            return _e;
        }        

        internal override XPathResultType  ReturnType() {
            return XPathResultType.Navigator;
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xpath\namespacequery.cs ===
//------------------------------------------------------------------------------
// <copyright file="NamespaceQuery.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.XPath {
    using System.Xml; 
    using System.Diagnostics;

    internal class NamespaceQuery : BaseAxisQuery {
        private int _count = 0;
        
        internal NamespaceQuery(IQuery qyParent, String Name,  String Prefix, String URN, XPathNodeType Type) : 
            base(qyParent, Name, Prefix, URN, Type) 
        {}

        internal override void reset() {
            _count = 0;
            base.reset();
        }

        internal override XPathNavigator advance() {
            while (true) {
                if (_count == 0) {
                    m_eNext = m_qyInput.advance();
                    if (m_eNext == null)
                        return null;
                    m_eNext = m_eNext.Clone();
                    if (m_eNext.MoveToFirstNamespace())
                        _count = 1;
                    _position = 0;

                }
                else
                    if (! m_eNext.MoveToNextNamespace())
                    _count = 0;
                else
                    _count++;

                if (_count != 0) {
                    if (matches(m_eNext)) {
                        _position++;
                        return m_eNext;
                    }
                }

            } // while
        } // Advance

        internal override bool matches(XPathNavigator e) {
            Debug.Assert(e.NodeType == XPathNodeType.Namespace);
            if (e.Value.Length == 0) {
                Debug.Assert(e.LocalName == "", "Only xmlns='' can have empty string as a value");
                // Namespace axes never returns xmlns='', 
                // because it's not a NS declaration but rather undeclaration.
                return false;               
            }
            if (_fMatchName) {
                return m_Name.Equals(e.LocalName);
            }
            else {
                return true;
            }
        }
                    
        internal override IQuery Clone() {
            return new NamespaceQuery(CloneInput(),m_Name,m_Prefix,m_URN,m_Type);
        }
    }

    internal class EmptyNamespaceQuery : NamespaceQuery  {
        internal EmptyNamespaceQuery() : 
            base(null, "", "", "", XPathNodeType.All) 
        {}
        internal override XPathNavigator advance() {
            return null;
        }
        internal override IQuery Clone() {
            return new EmptyNamespaceQuery();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xpath\numberfunctions.cs ===
//------------------------------------------------------------------------------
// <copyright file="NumberFunctions.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.XPath {
    using System.Xml; 
    using System.Xml.Xsl;
    using System.Text;
    using FT = System.Xml.XPath.Function.FunctionType;

    internal sealed class NumberFunctions : IQuery {
        private IQuery _qy = null;
        private FT _FuncType;

        internal NumberFunctions(IQuery qy,
                                 FT ftype) {
            _qy = qy;
            _FuncType = ftype;
        }

        internal NumberFunctions() {
        }

        internal override void SetXsltContext(XsltContext context){
            if (_qy != null)
                _qy.SetXsltContext(context);
        }

        internal NumberFunctions(IQuery qy) {
            _qy = qy;
            _FuncType = FT.FuncNumber;
        }

        internal override void reset() {
            if (_qy != null)
                _qy.reset();
        }

        internal static double Number(bool _qy) {
            return(double) Convert.ToInt32(_qy);
        }
        internal static double Number(String _qy) {
            try {
                return XmlConvert.ToXPathDouble(_qy);
            }
            catch (System.Exception) {
                return double.NaN;
            }
        }

        internal static double Number(double num) {
            return num;
        }   

        internal override object getValue(IQuery qy) {
            switch (_FuncType) {
                case FT.FuncNumber:
                    return Number(qy);
                case FT.FuncSum:
                    return Sum(qy);
                case FT.FuncFloor:
                    return Floor(qy);
                case FT.FuncCeiling:
                    return Ceiling(qy);
                case FT.FuncRound:
                    return Round(qy);
            }
            return null;
        }

        internal override object getValue(XPathNavigator qy, XPathNodeIterator iterator) {
            switch (_FuncType) {
                case FT.FuncNumber:
                    return Number(qy, iterator);
                case FT.FuncSum:
                    return Sum(qy, iterator);
                case FT.FuncFloor:
                    return Floor(qy, iterator);
                case FT.FuncCeiling:
                    return Ceiling(qy, iterator);
                case FT.FuncRound:
                    return Round(qy, iterator);
            }
            return null;
        }

        private double Number(XPathNavigator qyContext, XPathNodeIterator iterator) {
            if (_qy != null) {
                if (_qy.ReturnType() == XPathResultType.NodeSet) {
                    _qy.setContext(qyContext.Clone());
                    XPathNavigator value = _qy.advance();
                    if (value != null)
                        return Number(value.Value);
                    else return double.NaN;
                }
                else
                    if (_qy.ReturnType() == XPathResultType.String)
                    return  Number(_qy.getValue(qyContext, iterator).ToString());
                else
                    if (_qy.ReturnType() == XPathResultType.Boolean)
                    return Number(Convert.ToBoolean(_qy.getValue(qyContext, iterator)));
                else
                    return XmlConvert.ToXPathDouble(_qy.getValue(qyContext, iterator));
            }
            else
                if (qyContext != null)
                return XmlConvert.ToXPathDouble(qyContext.Value);
            else
                return double.NaN;

        }

        private double Number(IQuery qyContext) {
            XPathNavigator value = null;
            if (_qy != null) {
                if (_qy.ReturnType() == XPathResultType.NodeSet) {
                    _qy.setContext(qyContext.peekElement().Clone());
                    value = _qy.advance();
                    if (value != null)
                        return Number(value.Value);
                    else return double.NaN;
                }
                else
                    if (_qy.ReturnType() == XPathResultType.String)
                    return  Number(_qy.getValue(qyContext).ToString());
                else
                    if (_qy.ReturnType() == XPathResultType.Boolean)
                    return Number(Convert.ToBoolean(_qy.getValue(qyContext)));
                else
                    return XmlConvert.ToXPathDouble(_qy.getValue(qyContext));
            }
            else
                if ((value = qyContext.peekElement()) != null)
                return XmlConvert.ToXPathDouble(value.Value);
            else
                return double.NaN;

        }

        private double Sum(IQuery qyContext) {
            double sum = 0;
            _qy.setContext(qyContext.peekElement().Clone());
            XPathNavigator value = _qy.advance();
            while (value != null) {
                sum += Number(value.Value);        
                value = _qy.advance();
            }
            return sum;
        }

        private double Sum(XPathNavigator qyContext, XPathNodeIterator iterator) {
            double sum = 0;
            _qy.setContext(qyContext);
            XPathNavigator value = _qy.advance();
            while (value != null) {
                sum += Number(value.Value);
                value = _qy.advance();
            }
            return sum;
        }

        private double Floor(IQuery qy) {
            return Math.Floor(XmlConvert.ToXPathDouble(_qy.getValue(qy)));

        }

        private double Floor(XPathNavigator qy, XPathNodeIterator iterator) {
            return Math.Floor(XmlConvert.ToXPathDouble(_qy.getValue(qy, iterator)));    
        }

        private double Ceiling(IQuery qy) {
            return Math.Ceiling(XmlConvert.ToXPathDouble(_qy.getValue(qy)));
        }

        private double Ceiling(XPathNavigator qy, XPathNodeIterator iterator) {
            return Math.Ceiling(XmlConvert.ToXPathDouble(_qy.getValue(qy, iterator)));
        }

        private double Round(IQuery qy) {
            double n = XmlConvert.ToXPathDouble(_qy.getValue(qy));
            // Math.Round does bankers rounding and Round(1.5) == Round(2.5) == 2
            // This is incorrect in XPath and to fix this we are useing Math.Floor(n + 0.5) istead
            // To deal with -0.0 we have to use Math.Round in [0.5, 0.0]
            return (-0.5 <= n && n <= 0.0) ? Math.Round(n) : Math.Floor(n + 0.5);
        }

        private double Round(XPathNavigator qy, XPathNodeIterator iterator) {
            double n = XmlConvert.ToXPathDouble(_qy.getValue(qy, iterator));
            return (-0.5 <= n && n <= 0.0) ? Math.Round(n) : Math.Floor(n + 0.5);
        }

        internal override XPathResultType  ReturnType() {
            return XPathResultType.Number;
        }

        internal override IQuery Clone() {
            if (_qy != null) {
                return new NumberFunctions(_qy.Clone(), _FuncType);
            }
            else {
                return new NumberFunctions(null, _FuncType);
            }

        }
    } // class Functions
} // namespace
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xpath\nodequerybuilder.cs ===
//------------------------------------------------------------------------------
// <copyright file="nodequerybuilder.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

#if StreamFilter

namespace System.Xml.XPath
{
    using System;
    using System.Xml;

    internal sealed class QueryBuildRecord {
        internal static IFQuery ProcessAxis(Axis root) {
            switch (root.TypeOfAxis) {
                case Axis.AxisType.Child:
                    if (root.Input != null)
                        if (root.Input.TypeOfAst != AstNode.QueryType.Root)                            
                             throw new XPathException(Res.Xp_InvalidPattern);
                    return new FChildrenQuery(root.Name, root.Prefix, root.URN, root.Type);

                case Axis.AxisType.Attribute:
                    if (root.Input != null)                        
                       throw new XPathException(Res.Xp_InvalidPattern);
                    return new FAttributeQuery(root.Name, root.Prefix, root.URN, root.Type);

                default :                     
                    throw new XPathException(Res.Xp_InvalidPattern);
            }

        }

        private static IFQuery ProcessOperand(Operand root) {
            return new FOperandQuery(root.OperandValue, root.ReturnType);
        }

        private static IFQuery ProcessOperator(Operator root) {
            switch (root.OperatorType) {
                case Operator.Op.OR:
                    return new FOrExpr(
                                      ProcessNode(root.Operand1),
                                      ProcessNode(root.Operand2));
                case Operator.Op.AND :
                    return new FAndExpr(
                                       ProcessNode(root.Operand1),
                                       ProcessNode(root.Operand2));
            }
            switch (root.ReturnType) {
                case XPathResultType.Number:
                    return new FNumericExpr(
                                           root.OperatorType,
                                           ProcessNode(root.Operand1),
                                           ProcessNode(root.Operand2));
                case XPathResultType.Boolean:
                    return new FLogicalExpr(
                                           root.OperatorType,
                                           ProcessNode(root.Operand1),
                                           ProcessNode(root.Operand2));
            }

            return new FOrQuery(
                               ProcessNode(root.Operand1),
                               ProcessNode(root.Operand2));
        }

        private static IFQuery ProcessFilter(IFQuery qyInput,IFQuery opnd) {
            if (opnd.ReturnType() == XPathResultType.Number)
                 throw new XPathException(Res.Xp_InvalidPattern);
            return new FFilterQuery(qyInput, opnd);         
        }

        internal static IFQuery ProcessNode(AstNode root) {
            if (root == null)
                return null;
            switch (root.TypeOfAst) {
                case AstNode.QueryType.Axis:
                    return ProcessAxis((Axis)root);                                
                case AstNode.QueryType.Operator:
                    return ProcessOperator((Operator)root);
                case AstNode.QueryType.ConstantOperand:
                    return ProcessOperand((Operand)root);
                case AstNode.QueryType.Filter:
                    return ProcessFilter(ProcessNode(((Filter)root).Input), ProcessNode(((Filter)root).Condition));
                default:
                    throw new XPathException(Res.Xp_InvalidPattern);
            }
        }

    } // QueryBuilder
    internal sealed class QueryBuildToken {
        internal static IFQuery ProcessNode(AstNode root) {
            if (root == null)
                return null;
            if (root.TypeOfAst == AstNode.QueryType.Axis && ((Axis)root).TypeOfAxis == Axis.AxisType.Child)
                return QueryBuildRecord.ProcessAxis((Axis)root);            
            throw new XPathException(Res.Xp_InvalidPattern);

        }
    }


}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xpath\numericexpr.cs ===
//------------------------------------------------------------------------------
// <copyright file="NumericExpr.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.XPath {
    using System.Xml; 
    using System.Xml.Xsl;

    internal sealed class NumericExpr : IQuery {
        internal IQuery _opnd1;
        internal IQuery _opnd2;
        internal Operator.Op _op;

        NumericExpr() {
        }

        internal NumericExpr(Operator.Op op, IQuery  opnd1, IQuery  opnd2) {
            if ( opnd1 is VariableQuery || opnd1 is XsltFunction  || opnd1.ReturnType() != XPathResultType.Number)
                _opnd1= new NumberFunctions(opnd1);
            else
                _opnd1 = opnd1;
            if (opnd2 != null && (opnd2 is VariableQuery || opnd2 is XsltFunction ||   opnd2.ReturnType() != XPathResultType.Number))
                _opnd2= new NumberFunctions(opnd2);
            else
                _opnd2 = opnd2;
            _op= op;
        }

        internal override void SetXsltContext(XsltContext context){
            _opnd1.SetXsltContext(context);
            if (_opnd2 != null)
                _opnd2.SetXsltContext(context);
        }

        internal override void reset() {
            _opnd1.reset();
            if (_opnd2 != null)
                _opnd2.reset();
        }

        internal override object getValue( XPathNavigator  qyContext, XPathNodeIterator iterator) {
            double n1=0,n2=0;

            //Debug.Assert(_opnd1 != null);
            //Debug.Assert((_opnd2 != null) || (OperandValue::NEGATE == _op));

            n1 = XmlConvert.ToXPathDouble(_opnd1.getValue(qyContext, iterator));
            if (_op != Operator.Op.NEGATE)
                n2 = XmlConvert.ToXPathDouble(_opnd2.getValue(qyContext, iterator));
            switch (_op) {
                case Operator.Op.PLUS   : return  n1 + n2;
                case Operator.Op.MINUS  : return  n1 - n2;
                case Operator.Op.MOD    : return  n1 % n2;
                case Operator.Op.DIV    : return  n1 / n2;
                case Operator.Op.MUL    : return  n1 * n2;
                case Operator.Op.NEGATE : return -n1;
            }
            return null;
        }
        internal override object getValue( IQuery  qyContext) {
            double n1=0,n2=0;

            //Debug.Assert(_opnd1 != null);
            //Debug.Assert((_opnd2 != null) || (OperandValue::NEGATE == _op));

            n1 = XmlConvert.ToXPathDouble(_opnd1.getValue(qyContext));
            if (_op != Operator.Op.NEGATE)
                n2 = XmlConvert.ToXPathDouble(_opnd2.getValue(qyContext));
            switch (_op) {
                case Operator.Op.PLUS   : return  n1 + n2;
                case Operator.Op.MINUS  : return  n1 - n2;
                case Operator.Op.MOD    : return  n1 % n2;
                case Operator.Op.DIV    : return  n1 / n2;
                case Operator.Op.MUL    : return  n1 * n2;               
                case Operator.Op.NEGATE : return -n1;
            }
            return null;
        }
        internal override XPathResultType ReturnType() {
            return XPathResultType.Number;
        }

        internal override IQuery Clone() {
            if ( _op != Operator.Op.NEGATE )
                return new NumericExpr(_op, _opnd1.Clone(), _opnd2.Clone());
            else
                return new NumericExpr(_op, _opnd1.Clone(), null);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xpath\operator.cs ===
//------------------------------------------------------------------------------
// <copyright file="Operator.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.XPath {
    internal class Operator : AstNode {
        internal enum Op {
            PLUS = 1,
            MINUS = 2,
            MUL  = 3 ,
            MOD = 4,
            DIV = 5,
            NEGATE = 6,
            LT = 7,
            GT = 8,
            LE = 9,
            GE = 10,
            EQ = 11,
            NE = 12,
            OR = 13,
            AND = 14,
            UNION = 15,
            INVALID
        };

        private String[] str = {
            "+",
            "-",
            "multiply",
            "mod",
            "divde",
            "negate",
            "<",
            ">",
            "<=",
            ">=",
            "=",
            "!=", 
            "or",
            "and",
            "union"
        };

        private Op _operatorType;
        private AstNode _opnd1;
        private AstNode _opnd2;

        internal Operator(Op op, AstNode opnd1, AstNode opnd2) {
            _operatorType = op;    
            _opnd1 = opnd1;
            _opnd2 = opnd2;
        }

        internal override QueryType TypeOfAst {
            get {return  QueryType.Operator;}
        }

        internal override XPathResultType ReturnType {
            get {
                if (_operatorType < Op.LT)
                    return XPathResultType.Number;
                if (_operatorType < Op.UNION)
                    return XPathResultType.Boolean;
                return XPathResultType.NodeSet;
            }
        }

        internal Op OperatorType {
            get { return _operatorType;}
        }

        internal AstNode Operand1
        {
            get {return _opnd1;}
        }

        internal AstNode Operand2
        {
            get {return _opnd2;}
        }

        internal String OperatorTypeName {
            get {return str[(int)_operatorType-1];}
        }

        internal override double DefaultPriority {
            get {
                if (_operatorType == Op.UNION) {
                    double pri1 = _opnd1.DefaultPriority;
                    double pri2 = _opnd2.DefaultPriority;

                    if (pri1 > pri2)
                        return pri1;
                    return pri2;
                }
                else
                    return 0.5;
            }

        }


    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xpath\operand.cs ===
//------------------------------------------------------------------------------
// <copyright file="Operand.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.XPath {
    using System.Diagnostics;

    internal class Operand : AstNode {
        private object _var;
	    private String _prefix = String.Empty;
        private XPathResultType _type;

        internal Operand(String var) {
            _var = var;
            _type = XPathResultType.String;
        }

        internal Operand(double var) {
            _var = var;
            _type = XPathResultType.Number;
        }

        internal Operand(bool var) {
            _var = var;
            _type = XPathResultType.Boolean;
        }

        internal override QueryType TypeOfAst {
            get {return QueryType.ConstantOperand;}
        }

        internal override XPathResultType ReturnType {
            get {return _type;}
        }

        internal String OperandType {
            get {
                switch (_type) {
                    case XPathResultType.Number : return "number";
                    case XPathResultType.String : return "string";
                    case XPathResultType.Boolean : return "boolean";
                }
                return null;
            }
        }

        internal object OperandValue {
            get {return _var;}
        }

       	internal String Prefix {
            get {return _prefix;}
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xpath\orquery.cs ===
//------------------------------------------------------------------------------
// <copyright file="OrQuery.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.XPath {
    using System.Collections;
    using System.Xml.Xsl;
    
    internal sealed class OrQuery : BaseAxisQuery {
        private IQuery qy1, qy2;
        private bool advance1 = true, advance2 = true;
        private XPathNavigator _last;
        private XsltContext context;

        internal OrQuery(IQuery query1, IQuery query2,bool specialaxis) {
            qy1 = query1;
            qy2 = query2;
        }
        
        internal override void reset() {
            qy1.reset();
            qy2.reset();
            advance1 = true;
            advance2 = true;
            _last = null;
            base.reset();
        }

        internal override void setContext(XPathNavigator e) {
            reset();
            qy1.setContext(e.Clone());
            qy2.setContext(e.Clone());
        }

        internal override void SetXsltContext(XsltContext context) {
            reset();
            qy1.SetXsltContext(context);
            qy2.SetXsltContext(context);
            this.context = context;
        }

        internal override IQuery Clone() {
            OrQuery clone = new OrQuery(qy1.Clone(), qy2.Clone(), false);
            clone.context = this.context;
            return clone;
        }

        private XPathNavigator ProcessSamePosition(XPathNavigator result){
           m_eNext = result;
           advance1 = advance2 = true;
           return result;
        }

        private XPathNavigator ProcessBeforePosition(XPathNavigator res1, XPathNavigator res2){
            _last = res2;
            advance2 = false;
            advance1 = true;
            m_eNext = res1;
            return res1;
        }

        private XPathNavigator ProcessAfterPosition(XPathNavigator res1, XPathNavigator res2){
            _last = res1;
            advance1 = false;
            advance2 = true;
            m_eNext = res2;
            return res2;
        } 
        
        internal override XPathNavigator advance() {
            XPathNavigator res1,res2;
            XmlNodeOrder order = 0;
            if (advance1)
                res1 = qy1.advance();
            else
                res1 = _last;
            if (advance2)
                res2 = qy2.advance();
            else
                res2 = _last;

            if (res1 != null && res2 != null) 
                order = res1.ComparePosition(res2);

            else if (res2 == null) {
                advance1 = true;
                advance2 = false;
                m_eNext = res1;
                _last = null;
                return res1;
            }
            else {
                advance1 = false;
                advance2 = true;
                m_eNext = res2;
                _last = null;
                return res2;
            }

            if (order == XmlNodeOrder.Same) {
                return ProcessSamePosition(res1);
            }
            if (order == XmlNodeOrder.Before) {
                return ProcessBeforePosition(res1, res2);
            }
            if (order == XmlNodeOrder.After) {
                return ProcessAfterPosition(res1, res2);
            }
            //Now order is XmlNodeOrder.Unknown
            XPathNavigator dummyres1 = res1.Clone();
            dummyres1.MoveToRoot();
            
            XPathNavigator dummyres2 = res2.Clone();
            dummyres2.MoveToRoot();
            int uriOrder = context.CompareDocument( dummyres1.BaseURI, dummyres2.BaseURI );
            if (uriOrder == 0) {
                return ProcessSamePosition(res1);
            }
            if (uriOrder < 0 ) {
                return ProcessBeforePosition(res1, res2);
            }
            if (uriOrder > 0 ) {
                return ProcessAfterPosition(res1, res2);
            }
            Debug.Assert(false, "should not be herein OrQuery.advance()");
            return null;
            
        }


        override internal XPathNavigator MatchNode(XPathNavigator context) {
            if (context != null) {
                XPathNavigator result = qy1.MatchNode(context);
                if (result != null)
                    return result;
                return qy2.MatchNode(context);

            }
            return null;
        } 

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xpath\orexpr.cs ===
//------------------------------------------------------------------------------
// <copyright file="OrExpr.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.XPath {
    using System.Xml; 
    using System.Xml.Xsl;

    internal sealed class OrExpr :IQuery {
        private BooleanFunctions _opnd1;
        private BooleanFunctions _opnd2;

        OrExpr() {
        }

        internal OrExpr( IQuery  opnd1, IQuery  opnd2) {
            _opnd1 = new BooleanFunctions(opnd1);
            _opnd2 = new BooleanFunctions(opnd2);
        }

        private OrExpr(BooleanFunctions opnd1, BooleanFunctions opnd2) {
            _opnd1 = opnd1;
            _opnd2 = opnd2;
        }

        internal override void reset() {
            _opnd1.reset();
            _opnd2.reset();
        }

        internal override object getValue( IQuery  qyContext) {
            Boolean n1= Convert.ToBoolean(_opnd1.getValue(qyContext));
            if (n1)
                return n1;
            return _opnd2.getValue(qyContext);
        }
        internal override object getValue( XPathNavigator  qyContext, XPathNodeIterator iterator) {
            Boolean n1= Convert.ToBoolean(_opnd1.getValue(qyContext, iterator));
            if (n1)
                return n1;
            return _opnd2.getValue(qyContext, iterator);
        }
        internal override XPathResultType ReturnType() {
            return XPathResultType.Boolean;
        }

        internal override IQuery Clone() {
            return new OrExpr(_opnd1.Clone(), _opnd2.Clone());
        }

        internal override void SetXsltContext(XsltContext context){
            _opnd1.SetXsltContext(context);
            _opnd2.SetXsltContext(context);            
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xpath\operandquery.cs ===
//------------------------------------------------------------------------------
// <copyright file="OperandQuery.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.XPath {
    using System.Xml; 

    using System.Collections;

    internal sealed class OperandQuery : IQuery {
        private object _Var;
        private XPathResultType _Type;

        internal override Querytype getName() {
            return Querytype.Constant;
        }

        internal override object getValue(IQuery qy) {
            return _Var;
        }
        internal override object getValue(XPathNavigator qy, XPathNodeIterator iterator) {
            return _Var;
        }
        internal override XPathResultType ReturnType() {
            return _Type;
        }
        internal OperandQuery(object var,XPathResultType type) {
            _Var = var;
            _Type = type;
        }

        internal override IQuery Clone() {
            return this;
        }


    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xpath\precedingquery.cs ===
//------------------------------------------------------------------------------
// <copyright file="precedingquery.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.XPath
{
    using System.Xml; 
    using System.Collections;

    internal sealed class PrecedingQuery : BaseAxisQuery
    {
        private XPathNavigator temp;
        private bool proceed = true;
        private XPathNodeIterator _qy;
        ArrayList _AncestorStk = new ArrayList();

        internal PrecedingQuery(
            IQuery          qyInput,
            String          Name,
            String          Prefix,
            String          URN,
            XPathNodeType Type) : base(qyInput, Name, Prefix, URN, Type)
        {
        }

        internal override void reset() 
        {
            proceed = true;
            temp = null;
            _qy = null;
            _AncestorStk.Clear();
            base.reset();
        }
        
        private void NotVisited(XPathNavigator temp){
            while (temp.MoveToParent()){
                _AncestorStk.Add(temp.Clone());
            }
            return;
        }

        internal override IQuery Clone() {
            return new PrecedingQuery(CloneInput(),m_Name,m_Prefix,m_URN,m_Type);
        }
        
        private int InStk(XPathNavigator temp){
            int flag = 0;
            for(int i= 0;i< _AncestorStk.Count; i++){
                if (temp.IsSamePosition((XPathNavigator)_AncestorStk[i])){
                    if (i == _AncestorStk.Count - 1)
                        flag = 2;
                    _AncestorStk.RemoveAt(i);
                    return flag;
                }
            }
            return 1;
        }

       private void PrintStk(){
            for(int i= 0;i< _AncestorStk.Count; i++){
                XPathNavigator temp = (XPathNavigator)_AncestorStk[i];
                Console.WriteLine("{0} value {1}",temp.Name,temp.Value);
            }
        }
        
        internal override XPathNavigator advance()
        {
            if (proceed) {
                if (temp == null )
                {
                        XPathNavigator _eLast = m_qyInput.advance();    
                        while (_eLast != null){
                            temp = _eLast.Clone();
                            _eLast = m_qyInput.advance();
                        }
                        if (temp == null || temp.NodeType == XPathNodeType.Root) 
                            return null;
                        if (temp.NodeType == XPathNodeType.Attribute || temp.NodeType == XPathNodeType.Namespace){
                            temp.MoveToParent();
                        }
                        NotVisited(temp.Clone());
                        _AncestorStk.Add(temp.Clone());
                        temp.MoveToRoot();
                        _qy = temp.SelectDescendants(XPathNodeType.All, false);
                } 
                int flag;
                while ( _qy.MoveNext())
                {
                    m_eNext = _qy.Current;
                    if (matches(m_eNext)){
                        flag = InStk(m_eNext);
                        if (flag == 1){
                            _position++;
                            return m_eNext;
                        }
                        if (flag == 2) {
                            proceed = false;
                            m_eNext = null;
                            return null;
                        }
                    }
                    else{
                        if (m_eNext.IsSamePosition((XPathNavigator)_AncestorStk[_AncestorStk.Count -1])) {
                            proceed = false;
                            m_eNext = null;
                            return null;
                        }
                    }
                }
                return null;

            }
            return null;

        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xpath\positionquery.cs ===
//------------------------------------------------------------------------------
// <copyright file="PositionQuery.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.XPath {
    using System.Xml; 
    using System.Collections;
    using System.Xml.Xsl;

    internal class PositionQuery : BaseAxisQuery {

        protected ArrayList _Stk = new ArrayList();
        protected int _count = 0;
        protected bool _fillStk = true;
        private int NonWSCount = 0;
        
        internal PositionQuery() {
        }

        internal PositionQuery(IQuery qyParent) {
            m_qyInput = qyParent;
        }

        internal override void reset() {
            _Stk.Clear();
            _count = 0;
            _fillStk = true;
            base.reset();
        }
              
        
        internal virtual void FillStk(){
            while ( (m_eNext = m_qyInput.advance()) != null)
                _Stk.Add(m_eNext.Clone());
            _fillStk = false;
        }

        internal int getCount() {
            return _Stk.Count;
        }  

        internal int getNonWSCount(XsltContext context) {
            if (NonWSCount == 0) {
                for(int i=0; i < _Stk.Count; i++) {
                    XPathNavigator nav = _Stk[i] as XPathNavigator;
                    if (nav.NodeType != XPathNodeType.Whitespace || context.PreserveWhitespace(nav)) {
                        NonWSCount++;
                    }
                }
            }
            return NonWSCount;
        }  
        
        internal override XPathResultType  ReturnType() {
            return m_qyInput.ReturnType();
        }
        
        override internal XPathNavigator MatchNode(XPathNavigator context) {
            if (context != null)
                if (m_qyInput != null)
                    return m_qyInput.MatchNode(context);
            return null;
        }
        
        internal override IQuery Clone() {
            return new PositionQuery(CloneInput());
        }

        internal override bool Merge {
            get {
                return true;
            }
        }
    }
 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xpath\parentquery.cs ===
//------------------------------------------------------------------------------
// <copyright file="ParentQuery.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.XPath {
    using System.Xml; 
    using System.Collections;

    internal sealed class ParentQuery : BaseAxisQuery {
        internal ArrayList _stack = new ArrayList();
        internal int _top;
        internal bool _fillstack = true;

        internal ParentQuery(
                            IQuery  qyInput,
                            String Name,
                            String Prefix,
                            String URN,
                            XPathNodeType Type) : base(qyInput,Name, Prefix, URN, Type) {
        }

        internal override void reset()
        {
            _fillstack = true;
            _top = 0;
            _stack.Clear();
            base.reset();
        }
        
        internal override XPathNavigator advance()
        {
            if (_fillstack){
                _fillstack = false;                
                populatestack();
            }
         
            if (_top > 0) {
                _position = 1;
                m_eNext = (XPathNavigator)_stack[--_top];
                return m_eNext;
            }
            else
                return null;
        
        }
        private void populatestack()
        {
            XPathNavigator _eLast;
            _fillstack = false;
            do {
                if ((_eLast = m_qyInput.advance())!= null )
                    _eLast = _eLast.Clone();
                else 
                    break;
                if (_eLast.MoveToParent())
                    if ( matches(_eLast) ) 
                    {
                        Process(_eLast);
                    }

            } while (true);
            _top = _stack.Count;
        }

        private void Process(XPathNavigator current)
        {
            XmlNodeOrder compare;
            for (int i=0; i< _stack.Count ; i++)
            {
                XPathNavigator nav = _stack[i] as XPathNavigator;
                compare = nav.ComparePosition(current) ;      
                if (compare == XmlNodeOrder.Same ) return;
                if (compare == XmlNodeOrder.Before)
                {
                    _stack.Insert(i,current.Clone());
                    return;
                }
            }
            _stack.Add(current.Clone());
        }


        internal override IQuery Clone() {
            return new ParentQuery(CloneInput(),m_Name,m_Prefix,m_URN,m_Type);
        }        
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xpath\precedingsibling.cs ===
//------------------------------------------------------------------------------
// <copyright file="precedingsibling.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.XPath
{
    using System.Xml; 
    
    using System.Collections;
    
    internal  class PreSiblingQuery: BaseAxisQuery
    {
        protected int _count = 0;
        private bool _first  = true;
        //protected int _childindex;
        ArrayList _InputStk = new ArrayList();
        ArrayList _ParentStk = new ArrayList();
        ArrayList _ResultStk = new ArrayList();



        internal PreSiblingQuery(
            IQuery qyInput,
            String name,
            String prefix,
            String urn,
            XPathNodeType type) : base (qyInput, name, prefix, urn, type)
        {
        }

        internal override void reset()
        {
            _count = 0;
            _first = true;
            _InputStk.Clear();
            _ParentStk.Clear();
            _ResultStk.Clear();
        }

        internal override void setContext(XPathNavigator e) {
            reset();
            base.setContext(e);
        }

        internal override XPathNavigator advance()
        {
            if (_first){
                _first = false;
                cacheinput();
                GetPreviousSiblings();
                DocOrderSort();
            }
            if ( _count> 0 ){
                _position--;
                //Console.WriteLine("returning {0}",((XPathNavigator)_ResultStk[_count - 1]).Name); 
                m_eNext = (XPathNavigator)_ResultStk[--_count];
                return m_eNext;
            }
            return null;
        }

        private void DocOrderSort(){
        //QuickSort algorithm here.
        }

        private void AddResult(XPathNavigator current) {
            for(int i = 0; i < _ResultStk.Count;i++) {
                XPathNavigator nav = _ResultStk[i] as XPathNavigator;
                XmlNodeOrder compare = nav.ComparePosition(current) ;      
                if (compare == XmlNodeOrder.Same ) return;
                if (compare == XmlNodeOrder.Before)
                {
                    _ResultStk.Insert(i,current);
                    return;
                }
            }
            _ResultStk.Add(current); 
        }

        private void cacheinput()
        {
            while ((m_eNext = m_qyInput.advance()) != null ){
                _InputStk.Add(m_eNext.Clone());
            }
            
        }

        private bool NotVisited(XPathNavigator nav){
            XPathNavigator nav1 = nav.Clone();
            nav1.MoveToParent();
            for (int i = 0; i< _ParentStk.Count; i++)
                if (nav1.IsSamePosition((XPathNavigator)_ParentStk[i]))
                    return false;
            _ParentStk.Add(nav1);
            return true;
        }
            
        private void GetPreviousSiblings()
        {
            for(int i= _InputStk.Count - 1; i >= 0; i--){
                //_childindex = m_eNext.IndexInInput;
                m_eNext = (XPathNavigator)_InputStk[i];
                if (NotVisited(m_eNext)){
                    while (m_eNext.MoveToPrevious())
                        if (matches(m_eNext))
                        {
                            AddResult(m_eNext.Clone());
                            //_ResultStk.Add(m_eNext.Clone());
                           // _PositionStk.Add(++_position);
                        }
                }
            }
                _count = _ResultStk.Count;
                _position = _count + 1;
        }
    

                
        internal override IQuery Clone() {
            return new PreSiblingQuery(CloneInput(),m_Name,m_Prefix,m_URN,m_Type);
        }        
        
    } // Children Query}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xpath\reversepositionquery.cs ===
//------------------------------------------------------------------------------
// <copyright file="ReversePositionQuery.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.XPath {
    using System.Xml; 
    using System.Collections;
    using System.Xml.Xsl;

    internal sealed class ReversePositionQuery : PositionQuery {
        
        internal ReversePositionQuery() {
        }

        internal ReversePositionQuery(IQuery qyParent) :base(qyParent){
        }
        
        internal override XPathNavigator advance() {
            if (_fillStk){
                FillStk();
                _position = _Stk.Count + 1;
            }
            if (_position > 1){
                _position--;
                m_eNext = (XPathNavigator)_Stk[_count++];
                return m_eNext;
            }
            return null;
        }

        internal override IQuery Clone() {
            return new ReversePositionQuery(CloneInput());
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xpath\root.cs ===
//------------------------------------------------------------------------------
// <copyright file="Root.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.XPath {
    internal class Root : AstNode {
        internal Root() {
        }

        internal override QueryType TypeOfAst {
            get {return QueryType.Root;}
        }

        internal override XPathResultType ReturnType {
            get {return XPathResultType.NodeSet;}
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xpath\resetableiterator.cs ===
//------------------------------------------------------------------------------
// <copyright file="ResetableIterator.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.XPath {
    using System;
    
    internal abstract class ResetableIterator : XPathNodeIterator {
        public abstract void Reset();
        public virtual bool MoveToPosition(int pos) {
            Reset();
            for(int i = CurrentPosition; i < pos ; i ++) {
                if(!MoveNext()) {
                    return false;
                }
            }
            return true;
        }

        public abstract ResetableIterator MakeNewCopy();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xpath\smartxpathdescendantquery.cs ===
//------------------------------------------------------------------------------
// <copyright file="SmartXPathDescendantQuery.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.XPath {
    using System.Xml; 


    internal sealed class SmartXPathDescendantQuery  : XPathDescendantQuery {

        private int _level = 0;
        
        internal SmartXPathDescendantQuery(): base() {
        }

        internal SmartXPathDescendantQuery(
                                          IQuery  qyParent,
                                          bool matchSelf,
                                          String Name,
                                          String Prefix,
                                          String URN,
                                          XPathNodeType Type) : base(qyParent,matchSelf, Name, Prefix, URN, Type) {

        }

        internal SmartXPathDescendantQuery(
                                          IQuery  qyParent,
                                          bool matchSelf,
                                          String Name,
                                          String Prefix,
                                          String URN,
                                          XPathNodeType Type,
                                          bool abbrAxis) : base(qyParent,matchSelf, Name, Prefix, URN, Type, abbrAxis) {

        }

        internal override XPathNavigator advance(){
            bool flag = false;
            while (true){
                if (_first){
                    m_eNext= m_qyInput.advance();
                    _level = 0;
                    _position = 0;
                    if (m_eNext != null){
                        m_eNext = m_eNext.Clone();
                    }
                    else
                        return null;
                    _first = false;
                    if (_fMatchSelf && matches(m_eNext)){
                        _position++;
                        _first = true;
                        return m_eNext;
                    }
                    else
                        flag = m_eNext.MoveToFirstChild();                    
                }
                if (!flag){
                    flag = m_eNext.MoveToNext();
                }
                while (!flag){
                    if ( --_level == 0 || !m_eNext.MoveToParent()){
                        _first = true;
                        break;
                    }


                    flag = m_eNext.MoveToNext();
                }
                if (flag){
                    if (matches(m_eNext)){
                        _position++;
                        return m_eNext;
                    }
                }
                flag = m_eNext.MoveToFirstChild(); 
                if (flag)
                    _level++;
            }
        }

        internal override IQuery Clone() {
            return new SmartXPathDescendantQuery(CloneInput(),_fMatchSelf, m_Name, m_Prefix, m_URN, m_Type);
        }           
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xpath\querybuilder.cs ===
//------------------------------------------------------------------------------
// <copyright file="querybuilder.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.XPath {
    using System;
    using System.Xml;
    using System.Diagnostics;
    using System.Collections;
    using FT = System.Xml.XPath.Function.FunctionType;

    internal sealed class QueryBuilder {
        private String _query;
        private bool _specialAxis;
        private int _smart = 1;
        private bool _slashslash;
        private bool allowVar;
        private bool allowKey;
        private bool allowCurrent;
        private bool _hasPrefix;
        private const int Regular_D         = 0;
        private const int Smart_D           = 1;
        private bool hasPosition = false;
        private bool abbrAxis;
        private bool hasReverseAxis;
        private BaseAxisQuery firstInput;
        private int filterCount;
        
        private void reset() {
            _hasPrefix = false;
            _specialAxis = false;
            _smart = 1;
            _slashslash = false;
            hasPosition = false;
        }
        
        private IQuery ProcessAxis(Axis root , IQuery qyInput, int parent,  Axis.AxisType parentaxis) {
            IQuery result = null;
            String URN = String.Empty;
            if ( root.Prefix.Length > 0) {
                _hasPrefix = true;
            }
            hasReverseAxis = false;
            switch (root.TypeOfAxis) {
            case Axis.AxisType.Ancestor:
                result = new XPathAncestorQuery( qyInput , false, root.Name, root.Prefix, URN, root.Type );
                _specialAxis = hasReverseAxis = true;
                break;
            case Axis.AxisType.AncestorOrSelf:
                result = new XPathAncestorQuery( qyInput, true, root.Name, root.Prefix, URN, root.Type );
                _specialAxis = hasReverseAxis = true;
                break;
            case Axis.AxisType.Child:
                if (_slashslash){
                    result = new XPathDescendantQuery( qyInput, false, root.Name, root.Prefix, URN, root.Type, abbrAxis); 
                   if (_specialAxis || (qyInput != null && (int)qyInput.getName() > (int) Querytype.Self)) {
                        result =  new CacheQuery(result);
                    }
                    _slashslash = false;
                    _specialAxis = true;
                    break;
                }
                if (_specialAxis || (qyInput != null && (int)qyInput.getName() > (int) Querytype.Self))
                    result = new CacheChildrenQuery( qyInput, root.Name, root.Prefix, URN, root.Type );                                                                                                           
                else
                    result = new ChildrenQuery( qyInput, root.Name, root.Prefix, URN, root.Type );
                break;
            case Axis.AxisType.Parent:
                result = new ParentQuery( qyInput, root.Name, root.Prefix, URN, root.Type );                        
                break;
            case Axis.AxisType.Descendant:
                switch (parent) {
                case Smart_D : 
                    result = new SmartXPathDescendantQuery( qyInput, false, root.Name, root.Prefix, URN, root.Type);
                    break;  
                case Regular_D :
                    result = new XPathDescendantQuery(qyInput, false, root.Name, root.Prefix, URN, root.Type);
                    if (_specialAxis || (qyInput != null && (int)qyInput.getName() > (int) Querytype.Self))
                        result = new CacheQuery(result);
                    _specialAxis = true;
			        break;
                }
                break;
            case Axis.AxisType.DescendantOrSelf:
                switch (parent) {
                case Smart_D : 
                    result = new SmartXPathDescendantQuery(qyInput, true, root.Name, root.Prefix, URN, root.Type, root.abbrAxis);                                                            
                    break;  
                case Regular_D :
                       if ( _smart <= 1 || root.Type != XPathNodeType.All ||
                        parentaxis != Axis.AxisType.Child) {
                            result = new XPathDescendantQuery(
                                                           qyInput,
                                                     true,
                                                     root.Name,
                                                     root.Prefix,
                                                     URN,
                                                     root.Type,
                                                     root.abbrAxis);
                            if (_specialAxis || (qyInput != null && (int)qyInput.getName() > (int) Querytype.Self))
                                result =  new CacheQuery(result);
                        _specialAxis = true;

                        }
                        else
                        {
                            _slashslash = true;
                            abbrAxis = root.abbrAxis;
                            result = qyInput;
                        }
        			break;
                }
                break;
            case Axis.AxisType.Preceding:
                result = new PrecedingQuery(
                                           qyInput,
                                           root.Name,
                                           root.Prefix,
                                           URN,
                                           root.Type);
               _specialAxis = hasReverseAxis = true;
                break;

            case Axis.AxisType.Following :
                result = new FollowingQuery(
                                           qyInput,
                                           root.Name,
                                           root.Prefix,
                                           URN,
                                           root.Type);
                _specialAxis = true;
                break;
            case Axis.AxisType.FollowingSibling :
                result = new FollSiblingQuery(
                                           qyInput,
                                           root.Name,
                                           root.Prefix,
                                           URN,
                                           root.Type);
                if (_specialAxis || (qyInput != null && (int)qyInput.getName() > (int) Querytype.Self)) {
                    result =  new DocumentOrderQuery(result);
                }
                break;
            case Axis.AxisType.PrecedingSibling :
                result = new PreSiblingQuery(
                                           qyInput,
                                           root.Name,
                                           root.Prefix,
                                           URN,
                                           root.Type);
                hasReverseAxis = true;
                break;
            case Axis.AxisType.Attribute:
                result = new AttributeQuery(
                                           qyInput,
                                           root.Name,
                                           root.Prefix,
                                           URN,
                                           root.Type);
                break;
            case Axis.AxisType.Self:
                result = new XPathSelfQuery(
                                           qyInput,
                                           root.Name,
                                           root.Prefix,
                                           URN,
                                           root.Type);
                break;
            case Axis.AxisType.Namespace:
                if (
                    (root.Type == XPathNodeType.All || root.Type == XPathNodeType.Element || root.Type == XPathNodeType.Attribute) &&
                    root.Prefix == string.Empty
                ) {
                    result = new NamespaceQuery(qyInput, root.Name, root.Prefix, URN, root.Type);
                }
                else {
                    result = new EmptyNamespaceQuery();
                }
                break;
            default:
                throw new XPathException(Res.Xp_NotSupported, _query);
            }
            return result;
        }

        private IQuery ProcessOperator(Operator root, IQuery qyInput, ref bool cache, ref bool position) {
            _specialAxis = false;
            switch (root.OperatorType) {
                case Operator.Op.OR:
                    return new OrExpr(
                                     ProcessNode(root.Operand1, null, 
                                     Regular_D, Axis.AxisType.None, ref cache, ref position),
                                     ProcessNode(root.Operand2, null, 
                                     Regular_D, Axis.AxisType.None, ref cache, ref position));
                case Operator.Op.AND :
                    return new AndExpr(
                                      ProcessNode(root.Operand1, null, 
                                      Regular_D, Axis.AxisType.None, ref cache, ref position),
                                      ProcessNode(root.Operand2, null, 
                                      Regular_D, Axis.AxisType.None, ref cache, ref position));
            }
            switch (root.ReturnType) {
                case XPathResultType.Number:
                    return new NumericExpr(
                                          root.OperatorType,
                                          ProcessNode(root.Operand1, null, 
                                          Regular_D, Axis.AxisType.None, ref cache, ref position),
                                          ProcessNode(root.Operand2, null, 
                                          Regular_D, Axis.AxisType.None, ref cache, ref position));
                case XPathResultType.Boolean:
                    return new LogicalExpr(
                                          root.OperatorType,
                                          ProcessNode(root.Operand1, null, 
                                          Regular_D, Axis.AxisType.None, ref cache, ref position),
                                          ProcessNode(root.Operand2, null, 
                                          Regular_D, Axis.AxisType.None, ref cache, ref position));
            }

            return new OrQuery(
                              ProcessNode(root.Operand1,null, Regular_D, 
                              Axis.AxisType.None, ref cache, ref position),
                              ProcessNode(root.Operand2,null, 
                              Regular_D, Axis.AxisType.None, ref cache, ref position),_specialAxis);
        }

        /*
        private bool SplitQuery(BaseAxisQuery origQuery, BaseAxisQuery parent, BaseAxisQuery input) {
            parent = origQuery as BaseAxisQuery;
            if (parent == null || parent is GroupQuery || parent is PositionQuery || parent is OrQuery) {
                return false;
            }
            input = parent = (BaseAxisQuery)parent.Clone();
            parent = (BaseAxisQuery) parent.m_qyInput;
            while (parent != null && !parent.IsAxis) {
                parent = (BaseAxisQuery)parent.m_qyInput;
            }
            if (parent == null) {
                return false;
            }
            BaseAxisQuery temp = (BaseAxisQuery)parent.m_qyInput;
            if (temp == null) {
                return false;
            }
            parent.m_qyInput = null;
            parent = temp;
            return true;
        }
        */
        private IQuery ProcessFilter(Filter root, ref bool cache, ref bool position) {
            bool _cache = false;
            bool merge = false;
            bool _position = false;
            _specialAxis = false;
            bool filterflag = true;
            bool first = (filterCount == 0);

            IQuery opnd = ProcessNode(root.Condition, null, Regular_D, 
            Axis.AxisType.None, ref _cache, ref _position);

            filterCount++;
            if (root.Condition.ReturnType == XPathResultType.Error ) {
                _position = true;
            }
            if (root.Condition.ReturnType == XPathResultType.Number || 
                _cache || _position ) {
                hasPosition = true;
                filterflag = false;
                _smart = 0;
            }
            IQuery qyInput = ProcessNode(root.Input, null, Regular_D, 
            Axis.AxisType.None, ref cache, ref position );            

            if (hasPosition && qyInput is CacheQuery) {
                qyInput = ((CacheQuery)qyInput).m_qyInput;
            }
            if (firstInput == null) {
                firstInput =  qyInput as BaseAxisQuery;
            }
            _smart = 2;
            merge = qyInput.Merge;
            if (_cache || _position) {
                hasPosition = true;
                if (hasReverseAxis) {
                    if (merge) {
                        qyInput = new ReversePositionQuery(qyInput);                
                    }
                    else if (_cache) {
                        qyInput = new ForwardPositionQuery(qyInput); 
                    }
                }
                else {
                    if (_cache) {
                        qyInput = new ForwardPositionQuery(qyInput); 

                    }
                }
            }
            else if (root.Condition.ReturnType == XPathResultType.Number ) {
                hasPosition = true;
                if (hasReverseAxis && merge) {
                    qyInput = new ReversePositionQuery(qyInput);                

                }
            }
            if (first && firstInput != null) {
                if (merge && hasPosition) {
                    qyInput = new FilterQuery(qyInput, opnd);
                    IQuery parent = firstInput.m_qyInput;
                    if (parent == null || !firstInput.Merge) {
                        firstInput = null;
                        return qyInput;
                    }
                    IQuery input = qyInput;
                    qyInput = qyInput.Clone();
                    firstInput.m