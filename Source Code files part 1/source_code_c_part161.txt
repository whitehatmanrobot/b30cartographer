   a DLL.  You do not have to use <f MakeProcInstance> to get a
 *   procedure-instance address for the callback function.
 *
 * @cb void CALLBACK | MidiInFunc | <f MidiInFunc> is a placeholder for
 *   the application-supplied function name.  The actual name must be
 *   exported by including it in an EXPORTS statement in the DLL's module
 *   definition file.
 *
 * @parm HMIDIIN | hMidiIn | Specifies a handle to the MIDI input device.
 *
 * @parm UINT | wMsg | Specifies a MIDI input message.
 *
 * @parm DWORD | dwInstance | Specifies the instance data supplied
 *      with <f midiInOpen>.
 *
 * @parm DWORD | dwParam1 | Specifies a parameter for the message.
 *
 * @parm DWORD | dwParam2 | Specifies a parameter for the message.
 *
 * @comm Because the callback is accessed at interrupt time, it must reside
 *   in a DLL, and its code segment must be specified as FIXED in the
 *   module-definition file for the DLL.  Any data that the callback accesses
 *   must be in a FIXED data segment as well. The callback may not make any
 *   system calls except for <f PostMessage>, <f timeGetSystemTime>,
 *   <f timeGetTime>, <f timeSetEvent>, <f timeKillEvent>,
 *   <f midiOutShortMsg>, <f midiOutLongMsg>, and <f OutputDebugStr>.
 *
 * @xref midiInClose
 ****************************************************************************/
UINT WINAPI
midiInOpen(
    LPHMIDIIN lphMidiIn,
    UINT wDeviceID,
    DWORD dwCallback,
    DWORD dwInstance,
    DWORD dwFlags
    )
{
    MIDIOPENDESC mo;
    PMIDIDEV     pdev;
    UINT         wRet;

    V_WPOINTER(lphMidiIn, sizeof(HMIDIIN), MMSYSERR_INVALPARAM);
    V_DCALLBACK(dwCallback, HIWORD(dwFlags), MMSYSERR_INVALPARAM);
    V_FLAGS(LOWORD(dwFlags), 0, midiInOpen, MMSYSERR_INVALFLAG);

    /*
    ** Check for no devices
    */
//  if (wTotalMidiInDevs == 0 ) {
//      return MMSYSERR_BADDEVICEID;
//  }
//
//  /*
//  ** check for device ID being to large
//  */
//  if ( wDeviceID != MIDI_MAPPER ) {
//      if ( wDeviceID >= wTotalMidiInDevs ) {
//          return MMSYSERR_BADDEVICEID;
//      }
//  }

    *lphMidiIn = NULL;

    if (!midiLockData()) {
        return MMSYSERR_NOMEM;
    }

    pdev = (PMIDIDEV)NewHandle(TYPE_MIDIIN, sizeof(MIDIDEV));
    if( pdev == NULL) {
        return MMSYSERR_NOMEM;
    }

    pdev->wDevice = wDeviceID;
    pdev->wDeviceID = wDeviceID;

    mo.hMidi      = (HMIDI)pdev;
    mo.dwCallback = dwCallback;
    mo.dwInstance = dwInstance;

    wRet = midiIIDMessage( wDeviceID, MIDM_OPEN,
                          (DWORD)(LPDWORD)&pdev->dwDrvUser,
                          (DWORD)(LPMIDIOPENDESC)&mo, dwFlags );

    if (wRet) {
        FreeHandle((HMIDIIN)pdev);
        midiUnlockData();
    } else {
        *lphMidiIn = (HMIDIIN)pdev;
    }

    return wRet;
}

/*****************************************************************************
 * @doc EXTERNAL  MIDI
 *
 * @api UINT | midiInClose | This function closes the specified MIDI input
 *   device.
 *
 * @parm HMIDIIN | hMidiIn | Specifies a handle to the MIDI input device.
 *  If the function is successful, the handle is no longer
 *   valid after this call.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_INVALHANDLE | Specified device handle is invalid.
 *   @flag MIDIERR_STILLPLAYING | There are still buffers in the queue.
 *
 * @comm If there are input buffers that have been sent with
 *   <f midiInAddBuffer> and haven't been returned to the application,
 *   the close operation will fail.  Call <f midiInReset> to mark all
 *   pending buffers as being done.
 *
 * @xref midiInOpen midiInReset
 ****************************************************************************/
UINT WINAPI
midiInClose(
    HMIDIIN hMidiIn
    )
{
    UINT         wRet;

    V_HANDLE(hMidiIn, TYPE_MIDIIN, MMSYSERR_INVALHANDLE);

    wRet = (UINT)midiIMessage( (HMIDI)hMidiIn, MIDM_CLOSE, 0L, 0L);

    if (!wRet) {
        FreeHandle(hMidiIn);
        midiUnlockData();
    }
    return wRet;
}

/*****************************************************************************
 * @doc EXTERNAL  MIDI
 *
 * @api UINT | midiInPrepareHeader | This function prepares a buffer for
 *   MIDI input.
 *
 * @parm HMIDIIN | hMidiIn | Specifies a handle to the MIDI input
 *   device.
 *
 * @parm LPMIDIHDR | lpMidiInHdr | Specifies a pointer to a <t MIDIHDR>
 *   structure that identifies the buffer to be prepared.
 *
 * @parm UINT | wSize | Specifies the size of the <t MIDIHDR> structure.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_INVALHANDLE | Specified device handle is invalid.
 *   @flag MMSYSERR_NOMEM | Unable to allocate or lock memory.
 *
 * @comm The <t MIDIHDR> data structure and the data block pointed to by its
 *   <e MIDIHDR.lpData> field must be allocated with <f GlobalAlloc> using the
 *   GMEM_MOVEABLE and GMEM_SHARE flags, and locked with <f GlobalLock>.
 *   Preparing a header that has already been prepared has no effect,
 *   and the function returns zero.
 *
 * @xref midiInUnprepareHeader
 ****************************************************************************/
UINT WINAPI
midiInPrepareHeader(
    HMIDIIN hMidiIn,
    LPMIDIHDR lpMidiInHdr,
    UINT wSize
    )
{
    UINT         wRet;

    V_HANDLE(hMidiIn, TYPE_MIDIIN, MMSYSERR_INVALHANDLE);
    V_HEADER(lpMidiInHdr, wSize, TYPE_MIDIIN, MMSYSERR_INVALPARAM);

    if (lpMidiInHdr->dwFlags & MHDR_PREPARED) {
        return MMSYSERR_NOERROR;
    }

    lpMidiInHdr->dwFlags = 0;

    wRet = midiPrepareHeader(lpMidiInHdr, wSize);
    if (wRet == MMSYSERR_NOERROR) {
        wRet = (UINT)midiIMessage( (HMIDI)hMidiIn, MIDM_PREPARE,
                                  (DWORD)lpMidiInHdr, (DWORD)wSize);
    }

    return wRet;
}

/*****************************************************************************
 * @doc EXTERNAL  MIDI
 *
 * @api UINT | midiInUnprepareHeader | This function cleans up the
 * preparation performed by <f midiInPrepareHeader>. The
 * <f midiInUnprepareHeader> function must be called
 * after the device driver fills a data buffer and returns it to the
 * application. You must call this function before freeing the data
 * buffer.
 *
 * @parm HMIDIIN | hMidiIn | Specifies a handle to the MIDI input
 *   device.
 *
 * @parm LPMIDIHDR | lpMidiInHdr |  Specifies a pointer to a <t MIDIHDR>
 *   structure identifying the data buffer to be cleaned up.
 *
 * @parm UINT | wSize | Specifies the size of the <t MIDIHDR> structure.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_INVALHANDLE | Specified device handle is invalid.
 *   @flag MIDIERR_STILLPLAYING | <p lpMidiInHdr> is still in the queue.
 *
 * @comm This function is the complementary function to <f midiInPrepareHeader>.
 * You must call this function before freeing the data buffer with
 * <f GlobalFree>.
 * After passing a buffer to the device driver with <f midiInAddBuffer>, you
 * must wait until the driver is finished with the buffer before calling
 * <f midiInUnprepareHeader>.  Unpreparing a buffer that has not been
 *   prepared has no effect, and the function returns zero.
 *
 * @xref midiInPrepareHeader
 ****************************************************************************/
UINT WINAPI
midiInUnprepareHeader(
    HMIDIIN hMidiIn,
    LPMIDIHDR lpMidiInHdr,
    UINT wSize
    )
{
    UINT         wRet;

    V_HANDLE(hMidiIn, TYPE_MIDIIN, MMSYSERR_INVALHANDLE);
    V_HEADER(lpMidiInHdr, wSize, TYPE_MIDIIN, MMSYSERR_INVALPARAM);

    if (!(lpMidiInHdr->dwFlags & MHDR_PREPARED)) {
        return MMSYSERR_NOERROR;
    }

    if(lpMidiInHdr->dwFlags & MHDR_INQUEUE) {
        DebugErr( DBF_WARNING,
                  "midiInUnprepareHeader: header still in queue\r\n");
        return MIDIERR_STILLPLAYING;
    }


    wRet = midiUnprepareHeader(lpMidiInHdr, wSize);
    if (wRet == MMSYSERR_NOERROR) {
        wRet = (UINT)midiIMessage( (HMIDI)hMidiIn, MIDM_UNPREPARE,
                                   (DWORD)lpMidiInHdr, (DWORD)wSize);
    }
    return wRet;
}

/******************************************************************************
 * @doc EXTERNAL  MIDI
 *
 * @api UINT | midiInAddBuffer | This function sends an input buffer
 *   to a specified opened MIDI input device.  When the buffer is filled,
 *   it is sent back to the application.  Input buffers are
 *   used only for system-exclusive messages.
 *
 * @parm HMIDIIN | hMidiIn | Specifies a handle to the MIDI input device.
 *
 * @parm LPMIDIHDR | lpMidiInHdr | Specifies a far pointer to a <t MIDIHDR>
 *   structure that identifies the buffer.
 *
 * @parm UINT | wSize | Specifies the size of the <t MIDIHDR> structure.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_INVALHANDLE | Specified device handle is invalid.
 *   @flag MIDIERR_UNPREPARED | <p lpMidiInHdr> hasn't been prepared.
 *
 * @comm The data buffer must be prepared with <f midiInPrepareHeader> before
 *   it is passed to <f midiInAddBuffer>.  The <t MIDIHDR> data structure
 *   and the data buffer pointed to by its <e MIDIHDR.lpData> field must be allocated
 *   with <f GlobalAlloc> using the GMEM_MOVEABLE and GMEM_SHARE flags, and
 *   locked with <f GlobalLock>.
 *
 * @xref midiInPrepareHeader
 *****************************************************************************/
UINT WINAPI
midiInAddBuffer(
    HMIDIIN hMidiIn,
    LPMIDIHDR lpMidiInHdr,
    UINT wSize
    )
{
    V_HANDLE(hMidiIn, TYPE_MIDIIN, MMSYSERR_INVALHANDLE);
    V_HEADER(lpMidiInHdr, wSize, TYPE_MIDIIN, MMSYSERR_INVALPARAM);

    if (!(lpMidiInHdr->dwFlags & MHDR_PREPARED)) {
        DebugErr(DBF_WARNING, "midiInAddBuffer: buffer not prepared\r\n");
        return MIDIERR_UNPREPARED;
    }

    if (lpMidiInHdr->dwFlags & MHDR_INQUEUE) {
        DebugErr(DBF_WARNING, "midiInAddBuffer: buffer already in queue\r\n");
        return MIDIERR_STILLPLAYING;
    }

    return (UINT)midiIMessage( (HMIDI)hMidiIn, MIDM_ADDBUFFER,
                              (DWORD)lpMidiInHdr, (DWORD)wSize );
}

/*****************************************************************************
 * @doc EXTERNAL  MIDI
 *
 * @api UINT | midiInStart | This function starts MIDI input on the
 *   specified MIDI input device.
 *
 * @parm HMIDIIN | hMidiIn | Specifies a handle to the MIDI input device.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_INVALHANDLE | Specified device handle is invalid.
 *
 * @comm This function resets the timestamps to zero; timestamp values for
 *   subsequently received messages are relative to the time this
 *   function was called.
 *
 *   All messages other than system-exclusive messages are sent
 *   directly to the client when received. System-exclusive
 *   messages are placed in the buffers supplied by <f midiInAddBuffer>;
 *   if there are no buffers in the queue,
 *   the data is thrown away without notification to the client, and input
 *   continues.
 *
 *   Buffers are returned to the client when full, when a
 *   complete system-exclusive message has been received,
 *   or when <f midiInReset> is
 *   called. The <e MIDIHDR.dwBytesRecorded> field in the header will contain the
 *   actual length of data received.
 *
 *   Calling this function when input is already started has no effect, and
 *   the function returns zero.
 *
 * @xref midiInStop midiInReset
 ****************************************************************************/
UINT WINAPI
midiInStart(
    HMIDIIN hMidiIn
    )
{
    V_HANDLE(hMidiIn, TYPE_MIDIIN, MMSYSERR_INVALHANDLE);
    return (UINT)midiIMessage( (HMIDI)hMidiIn, MIDM_START, 0L, 0L);
}

/*****************************************************************************
 * @doc EXTERNAL  MIDI
 *
 * @api UINT | midiInStop | This function terminates MIDI input on the
 *   specified MIDI input device.
 *
 * @parm HMIDIIN | hMidiIn | Specifies a handle to the MIDI input device.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_INVALHANDLE | Specified device handle is invalid.
 *
 * @comm Current status (running status, parsing state, etc.) is maintained
 *   across calls to <f midiInStop> and <f midiInStart>.
 *   If there are any system-exclusive message buffers in the queue,
 *   the current buffer
 *   is marked as done (the <e MIDIHDR.dwBytesRecorded> field in the header will
 *   contain the actual length of data), but any empty buffers in the queue
 *   remain there.  Calling this function when input is not started has no
 *   no effect, and the function returns zero.
 *
 * @xref midiInStart midiInReset
 ****************************************************************************/
UINT WINAPI
midiInStop(
    HMIDIIN hMidiIn
    )
{
    V_HANDLE(hMidiIn, TYPE_MIDIIN, MMSYSERR_INVALHANDLE);

    return (UINT)midiIMessage( (HMIDI)hMidiIn, MIDM_STOP, 0L, 0L);
}

/*****************************************************************************
 * @doc EXTERNAL  MIDI
 *
 * @api UINT | midiInReset | This function stops input on a given MIDI
 *  input device and marks all pending input buffers as done.
 *
 * @parm HMIDIIN | hMidiIn | Specifies a handle to the MIDI input device.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_INVALHANDLE | Specified device handle is invalid.
 *
 * @xref midiInStart midiInStop midiInAddBuffer midiInClose
 ****************************************************************************/
UINT WINAPI
midiInReset(
    HMIDIIN hMidiIn
    )
{
    V_HANDLE(hMidiIn, TYPE_MIDIIN, MMSYSERR_INVALHANDLE);

    return (UINT)midiIMessage( (HMIDI)hMidiIn, MIDM_RESET, 0L, 0L );
}

/*****************************************************************************
 * @doc EXTERNAL MIDI
 *
 * @api UINT | midiInGetID | This function gets the device ID for a
 * MIDI input device.
 *
 * @parm HMIDIIN | hMidiIn     | Specifies the handle to the MIDI input
 * device.
 * @parm UINT FAR*  | lpwDeviceID | Specifies a pointer to the UINT-sized
 * memory location to be filled with the device ID.
 *
 * @rdesc Returns zero if successful. Otherwise, returns
 * an error number. Possible error returns are:
 *
 * @flag MMSYSERR_INVALHANDLE | The <p hMidiIn> parameter specifies an
 * invalid handle.
 *
 ****************************************************************************/
UINT WINAPI
midiInGetID(
    HMIDIIN hMidiIn,
    UINT FAR* lpwDeviceID
    )
{
    V_HANDLE(hMidiIn, TYPE_MIDIIN, MMSYSERR_INVALHANDLE);
    V_WPOINTER(lpwDeviceID, sizeof(UINT), MMSYSERR_INVALPARAM);

    *lpwDeviceID = ((PMIDIDEV)hMidiIn)->wDeviceID;
    return MMSYSERR_NOERROR;
}

/*****************************************************************************
 * @doc EXTERNAL MIDI
 *
 * @api UINT | midiOutGetID | This function gets the device ID for a
 * MIDI output device.
 *
 * @parm HMIDIOUT | hMidiOut    | Specifies the handle to the MIDI output
 * device.
 * @parm UINT FAR*  | lpwDeviceID | Specifies a pointer to the UINT-sized
 * memory location to be filled with the device ID.
 *
 * @rdesc Returns MMSYSERR_NOERROR if successful. Otherwise, returns
 * an error number. Possible error returns are:
 *
 * @flag MMSYSERR_INVALHANDLE | The <p hMidiOut> parameter specifies an
 * invalid handle.
 *
 ****************************************************************************/
UINT WINAPI
midiOutGetID(
    HMIDIOUT hMidiOut,
    UINT FAR* lpwDeviceID
    )
{
    V_HANDLE(hMidiOut, TYPE_MIDIOUT, MMSYSERR_INVALHANDLE);
    V_WPOINTER(lpwDeviceID, sizeof(UINT), MMSYSERR_INVALPARAM);

    *lpwDeviceID = ((PMIDIDEV)hMidiOut)->wDeviceID;
    return MMSYSERR_NOERROR;
}

#if 0
/*****************************Private*Routine******************************\
* midiIDMessage
*
*
*
* History:
* dd-mm-93 - StephenE - Created
*
\**************************************************************************/
UINT FAR PASCAL
midiIDMessage(
    LPSOUNDDEVMSGPROC lpProc,
    UINT wDeviceID,
    UINT wMessage,
    DWORD dwUser,
    DWORD dwParam1,
    DWORD dwParam2
    )
{
    return CallProc32W( (DWORD)wDeviceID, (DWORD)wMessage,
                        dwUser, dwParam1, dwParam2, lpProc, 0L, 5L );
}
#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\mmsystem\mciparse.c ===
/*******************************Module*Header*********************************\
* Module Name: mciparse.c
*
* Media Control Architecture Command Parser
*
* Created: 3/2/90
* Author:  DLL (DavidLe)
*
* History:
*
* Copyright (c) 1990 Microsoft Corporation
*
\******************************************************************************/

#include <windows.h>
#define MMNOMIDI
#define MMNOWAVE
#define MMNOSOUND
#define MMNOTIMER
#define MMNOJOY
#define MMNOSEQ
#include "mmsystem.h"
#define NOMIDIDEV
#define NOWAVEDEV
#define NOTIMERDEV
#define NOJOYDEV
#define NOSEQDEV
#define NOTASKDEV
#include "mmddk.h"
#include "mmsysi.h"

#ifndef STATICFN
#define STATICFN
#endif

#define	WCODE	UINT _based(_segname("_CODE"))

extern char far szOpen[];       // in MCI.C

#ifdef DEBUG_RETAIL
extern int DebugmciSendCommand;
#endif

// Number of command tables registered, including "holes"
static UINT number_of_command_tables;

// Command table list
command_table_type command_tables[MAX_COMMAND_TABLES];

static SZCODE szTypeTableExtension[] = ".mci";
static SZCODE szCoreTable[] = "core";

// Core table is loaded when the first MCI command table is requested
static BOOL bCoreTableLoaded;

// One element for each device type.  Value is the table type to use
// or 0 if there is no device type specific table.
static WCODE table_types[] =
{
    MCI_DEVTYPE_VCR,                // vcr
    MCI_DEVTYPE_VIDEODISC,          // videodisc
    MCI_DEVTYPE_OVERLAY,            // overlay
    MCI_DEVTYPE_CD_AUDIO,           // cdaudio
    MCI_DEVTYPE_DAT,                // dat
    MCI_DEVTYPE_SCANNER,            // scanner
    MCI_DEVTYPE_ANIMATION,          // animation
    MCI_DEVTYPE_DIGITAL_VIDEO,      // digitalvideo
    MCI_DEVTYPE_OTHER,              // other
    MCI_DEVTYPE_WAVEFORM_AUDIO,     // waveaudio
    MCI_DEVTYPE_SEQUENCER           // sequencer
};
/*!!
void PASCAL NEAR mciToLower (LPSTR lpstrString)
{
    while (*lpstrString != '\0')
    {
        if (*lpstrString >= 'A' && *lpstrString <= 'Z')
            *lpstrString += 0x20;

        ++lpstrString;
    }
}
*/
/*
 * @doc INTERNAL MCI
 * @func UINT | mciEatCommandEntry | Read a command resource entry and
 * return its length and its value and identifier
 *
 * @parm LPCSTR | lpEntry | The start of the command resource entry
 *
 * @parm LPDWORD | lpValue | The value of the entry, returned to caller
 * May be NULL
 *
 * @parm UINT FAR* | lpID | The identifier of the entry, returned to caller
 * May be NULL
 *
 * @rdesc The total number of bytes in the entry
 *
 */
UINT PASCAL NEAR mciEatCommandEntry (
LPCSTR lpEntry,
LPDWORD lpValue,
UINT FAR* lpID)
{
    LPCSTR lpScan = lpEntry;

    while (*lpScan++ != '\0')
        ;
    if (lpValue != NULL)
        *lpValue = *(LPDWORD)lpScan;
    lpScan += sizeof(DWORD);
    if (lpID != NULL)
        *lpID = *(LPWORD)lpScan;
    lpScan += sizeof(UINT);

    return lpScan - lpEntry;
}

// Return the size used by this token in the parameter list
UINT PASCAL NEAR mciGetParamSize (DWORD dwValue, UINT wID)
{
    switch (wID)
    {
        case MCI_CONSTANT:
        case MCI_INTEGER:
        case MCI_STRING:
            return sizeof(DWORD);
        case MCI_RECT:
            return sizeof(RECT);
        case MCI_RETURN:
            switch ((UINT)dwValue)
            {
                case MCI_INTEGER:
                    return sizeof(DWORD);
                case MCI_STRING:
                case MCI_RECT:
                    return sizeof(RECT);
                default:
                    DOUT ("mciGetParamSize:  Unknown return type\r\n");
                    return 0;
            }
            break;
    }
    return 0;
}


/*
 * @doc INTERNAL MCI
 * @func UINT | mciRegisterCommandTable | This function adds a new
 * table for the MCI parser.
 *
 * @parm HGLOBAL | hResource | Handle to the RCDATA resource
 *
 * @parm UINT FAR* | lpwIndex | Pointer to command table index
 *
 * @parm UINT   | wType | Specifies the device type for this command table.
 * Driver tables and the core table are type 0.
 *
 * @parm HINSTANCE | hModule | Module instance registering table.
 *
 * @rdesc Returns the command table index number that was assigned or -1
 * on error.
 *
 */
STATICFN UINT PASCAL NEAR
mciRegisterCommandTable(
    HGLOBAL hResource,
    UINT FAR* lpwIndex,
    UINT wType,
    HINSTANCE hModule
    )
{
    UINT wID;

/* First check for free slots */
    for (wID = 0; wID < number_of_command_tables; ++wID)
        if (command_tables[wID].hResource == NULL)
            break;

/* If no empty slots then allocate another one */
    if (wID >= number_of_command_tables)
    {
        if (number_of_command_tables == MAX_COMMAND_TABLES)
        {
            DOUT ("mciRegisterCommandTable: No more tables\r\n");
            return (UINT)-1;
        }
        else
           wID = number_of_command_tables++;
    }

/* Fill in the slot */
    command_tables[wID].wType = wType;
    command_tables[wID].hResource = hResource;
    command_tables[wID].lpwIndex = lpwIndex;
    command_tables[wID].hModule = hModule;
#ifdef DEBUG
    command_tables[wID].wLockCount = 0;
#endif
#ifdef DEBUG
    if (DebugmciSendCommand > 2)
    {
        DPRINTF(("mciRegisterCommandTable INFO: assigned slot %u\r\n", wID));
        DPRINTF(("mciRegisterCommandTable INFO: #tables is %u\r\n",
                 number_of_command_tables));
    }
#endif
    return wID;
}

/*
 * @doc DDK MCI
 * @api UINT | mciLoadCommandResource | Registers the indicated
 * resource as an MCI command table and builds a command table
 * index.  If a file with the resource name and the extension '.mci' is
 * found in the path then the resource is taken from that file.
 *
 * @parm HINSTANCE | hInstance | The instance of the module whose executable
 * file contains the resource.  This parameter is ignored if an external file
 * is found.
 *
 * @parm LPCSTR | lpResName | The name of the resource
 *
 * @parm UINT | wType | The table type.  Custom device specific tables MUST
 * give a table type of 0.
 *
 * @rdesc Returns the command table index number that was assigned or -1
 * on error.
 *
 */
UINT WINAPI mciLoadCommandResource (
HINSTANCE hInstance,
LPCSTR lpResName,
UINT wType)
{
    UINT FAR*           lpwIndex, FAR* lpwScan;
    HINSTANCE           hExternal;
    HRSRC               hResInfo;
    HGLOBAL             hResource;
    LPSTR               lpResource, lpScan;
    int                 nCommands = 0;
    UINT                wID;
    UINT                wLen;
                        // Name + '.' + Extension + '\0'
    char                strFile[8 + 1 + 3 + 1];
    LPSTR               lpstrFile = strFile;
    LPCSTR              lpstrType = lpResName;
    OFSTRUCT            ofs;

#ifdef DEBUG
    if (DebugmciSendCommand > 2)
        DPRINTF(("mciLoadCommandResource INFO:  %s loading\r\n", (LPSTR)lpResName));
#endif

// Initialize the device list
    if (!MCI_bDeviceListInitialized && !mciInitDeviceList())
        return MCIERR_OUT_OF_MEMORY;

// Load the core table if its not already there
    if (!bCoreTableLoaded)
    {
        bCoreTableLoaded = TRUE;
// If its not the core table being loaded
        if (lstrcmpi (szCoreTable, lpResName) != 0)
            if (mciLoadCommandResource (ghInst, szCoreTable, 0) == -1)
            {
                DOUT ("mciLoadCommandResource:  Cannot load core table\r\n");
            }
    }

// Check for a file with the extension ".mci"
// Copy up to the first eight characters of device type
    while (lpstrType < lpResName + 8 && *lpstrType != '\0')
        *lpstrFile++ = *lpstrType++;

// Tack extension onto end
    lstrcpy (lpstrFile, szTypeTableExtension);

// If the file exists and can be loaded then set flag
// otherwise load resource from MMSYSTEM.DLL
    if (OpenFile (strFile, &ofs, OF_EXIST) == HFILE_ERROR ||
        (hExternal = LoadLibrary(strFile)) < HINSTANCE_ERROR)

        hExternal = NULL;

// Load the given table from the file or from the module if not found
    if (hExternal != NULL &&
        (hResInfo = FindResource (hExternal, lpResName, RT_RCDATA)) != NULL)

        hInstance = hExternal;
    else
        hResInfo = FindResource (hInstance, lpResName, RT_RCDATA);

    if (hResInfo == NULL)
    {
        DOUT ("mciLoadCommandResource:  Cannot find command resource\r\n");
        return (UINT)-1;
    }
    if ((hResource = LoadResource (hInstance, hResInfo)) == NULL)
    {
        DOUT ("mciLoadCommandResource:  Cannot load command resource\r\n");
        return (UINT)-1;
    }
    if ((lpResource = LockResource (hResource)) == NULL)
    {
        DOUT ("mciLoadCommandResource:  Cannot lock resource\r\n");
        FreeResource (hResource);
        return (UINT)-1;
    }

/* Count the number of commands  */
    lpScan = lpResource;
    while (TRUE)
    {
        lpScan += mciEatCommandEntry(lpScan, NULL, &wID);

// End of command?
        if (wID == MCI_COMMAND_HEAD)
            ++nCommands;
// End of command list?
        else if (wID == MCI_END_COMMAND_LIST)
            break;
    }

// There must be at least on command in the table
    if (nCommands == 0)
    {
        DOUT ("mciLoadCommandResource:  No commands in the specified table\r\n");
        UnlockResource (hResource);
        FreeResource (hResource);
        return (UINT)-1;
    }

// Allocate storage for the command table index
// Leave room for a -1 entry to terminate it
    if ((lpwIndex = (UINT FAR*)
                        mciAlloc ((UINT)sizeof (UINT) * (nCommands + 1)))
                        == NULL)
    {
        DOUT ("mciLoadCommandResource:  cannot allocate command table index\r\n");
        UnlockResource (hResource);
        FreeResource (hResource);
        return (UINT)-1;
    }

/* Build Command Table */
    lpwScan = lpwIndex;
    lpScan = lpResource;

    while (TRUE)
    {
// Get next command entry
        wLen = mciEatCommandEntry (lpScan, NULL, &wID);

        if (wID == MCI_COMMAND_HEAD)
// Add an index to this command
            *lpwScan++ = lpScan - lpResource;

        else if (wID == MCI_END_COMMAND_LIST)
        {
// Mark the end of the table
            *lpwScan = (UINT)-1;
            break;
        }
        lpScan += wLen;
    }
    UnlockResource (hResource);
    return mciRegisterCommandTable (hResource, lpwIndex, wType, hExternal);
}

/*
 * @doc INTERNAL MCI
 * @func UINT | mciLoadTableType | If the table of the given type
 * has not been loaded, register it
 *
 * @parm UINT | wType | The table type to load
 *
 * @rdesc Returns the command table index number that was assigned or -1
 * on error.
 */
UINT PASCAL NEAR mciLoadTableType (
UINT wType)
{
    UINT wID;
    char buf[MCI_MAX_DEVICE_TYPE_LENGTH];
    int nTypeLen;

// Check to see if this table type is already loaded
    for (wID = 0; wID < number_of_command_tables; ++wID)
        if (command_tables[wID].wType == wType)
            return wID;

// Must load table
// First look up what device type specific table to load for this type
    if (wType < MCI_DEVTYPE_FIRST || wType > MCI_DEVTYPE_LAST)
        return (UINT)-1;

// Load string that corresponds to table type
    LoadString (ghInst, table_types[wType - MCI_DEVTYPE_FIRST],
                buf, sizeof(buf));

//Must be at least one character in type name
    if ((nTypeLen = lstrlen (buf)) < 1)
        return (UINT)-1;

// Register the table with MCI
    return mciLoadCommandResource (ghInst, buf, wType);
}

/*
 * @doc DDK MCI
 *
 * @api BOOL | mciFreeCommandResource | Frees the memory used
 * by the specified command table.
 *
 * @parm UINT | wTable | The table index returned from a previous call to
 * mciLoadCommandResource.
 *
 * @rdesc FALSE if the table index is not valid, TRUE otherwise.
 *
 */
BOOL WINAPI mciFreeCommandResource (
UINT wTable)
{
    UINT wID;
    HGLOBAL hResource;
    UINT FAR* lpwIndex;

#ifdef DEBUG
    if (DebugmciSendCommand > 2)
    {
        DPRINTF(("mciFreeCommandResource INFO:  Free table %d\r\n", wTable));
        DPRINTF(("mciFreeCommandResource INFO:  Lockcount is %d\r\n",
                  command_tables[wTable].wLockCount));
    }
#endif

/* Validate input -- do not let the core table be free'd */
    if (wTable <= 0 || wTable >= number_of_command_tables)
    {
#ifdef DEBUG
// wTable == -1 is OK
        if (wTable != -1)
            DOUT ("mciFreeCommandResource: Bad table number\r\n");
#endif
        return FALSE;
    }

// If this table is being used elsewhere then keep it around
    for (wID = 1; wID < MCI_wNextDeviceID; ++wID)
        if (MCI_lpDeviceList[wID] != NULL)
            if (MCI_lpDeviceList[wID]->wCustomCommandTable == wTable ||
                MCI_lpDeviceList[wID]->wCommandTable == wTable)
            {
#ifdef DEBUG
                if (DebugmciSendCommand > 2)
                    DOUT ("mciFreeCommandResource INFO:  table in use\r\n");
#endif
                return FALSE;
            }

#if 0
/* Search the list of tables */
    for (wID = 0; wID < number_of_command_tables; ++wID)

/* If this resource is still in use, keep it around */
        if (command_tables[wID].hResource == hResource)
        {
#ifdef DEBUG
            if (DebugmciSendCommand > 2)
                DOUT ("mciFreeCommandResource INFO:  resource in use\r\n");
#endif
            return FALSE;
        }
#endif

    hResource = command_tables[wTable].hResource;
    command_tables[wTable].hResource = NULL;

    lpwIndex = command_tables[wTable].lpwIndex;
    command_tables[wTable].lpwIndex = NULL;
    command_tables[wTable].wType = 0;


    FreeResource (hResource);
    mciFree (lpwIndex);

    if (command_tables[wTable].hModule != NULL)
        FreeLibrary (command_tables[wTable].hModule);

// Make space at top of list
    if (wTable == number_of_command_tables - 1)
        --number_of_command_tables;

#ifdef DEBUG
    if (DebugmciSendCommand > 2)
        DPRINTF(("mciFreeCommandResource INFO:  number_of_command_tables: %u\r\n",
                                             number_of_command_tables));
#endif

    return TRUE;
}

#ifdef DEBUG
void PASCAL NEAR mciCheckLocks (void)
{
    UINT wTable;

    if (DebugmciSendCommand <= 2)
        return;

    for (wTable = 0; wTable < number_of_command_tables; ++wTable)
    {
        if (command_tables[wTable].hResource == NULL)
            continue;
        DPRINTF(("mciCheckLocks INFO: table %u ", wTable));
        DPRINTF(("user: %x ",
                 GlobalFlags (command_tables[wTable].hResource) & GMEM_LOCKCOUNT));
        DPRINTF(("mci: %u ", command_tables[wTable].wLockCount));
        if (GlobalFlags (command_tables[wTable].hResource) & GMEM_DISCARDABLE)
            DPRINTF(("discardable\r\n"));
        else
            DPRINTF(("NOT discardable\r\n"));
    }
}
#endif

/*
 * @doc INTERNAL MCI
 * @func BOOL | mciUnlockCommandTable | Unlocks the command table given by
 * a table index
 *
 * @parm UINT | wCommandTable | Table to unlock
 *
 * @rdesc TRUE if success, FALSE otherwise
 *
 * @comm Used external to this module by mci.c
 *
 */
BOOL PASCAL NEAR mciUnlockCommandTable (
UINT wCommandTable)
{
    UnlockResource(command_tables[wCommandTable].hResource);
#ifdef DEBUG
    --command_tables[wCommandTable].wLockCount;
    if (DebugmciSendCommand > 2)
    {
        DPRINTF(("mciUnlockCommandTable INFO:  table %d\r\n", wCommandTable));
        DOUT ("mciUnlockCommandTable INFO:  check locks...\r\n");
        mciCheckLocks();
    }
#endif
    return TRUE;
}

/*
 * @doc INTERNAL MCI
 * @func LPSTR | FindCommandInTable | Look up the given
 * command string in the GIVEN parser command table
 *
 * @parm UINT  | wTable | Command table to use
 *
 * @parm LPCSTR | lpstrCommand | The command to look up.  It must
 * be in lower case with no leading or trailing blanks and with at
 * least one character.
 *
 * @parm UINT FAR * | lpwMessage | The message corresponding to the command
 * Returned to caller.
 *
 * @rdesc NULL if the command is unknown or on error, otherwise a pointer to
 * the command list for the input command string.
 *
 * @comm If the command is found, the command resource will be locked on exit.
 *
 */
LPSTR PASCAL NEAR FindCommandInTable (
UINT wTable,
LPCSTR lpstrCommand,
UINT FAR * lpwMessage)
{
    UINT FAR* lpwIndex;
    LPSTR lpResource, lpstrThisCommand;
    UINT  wMessage;

/* Validate table */

    if (wTable >= number_of_command_tables)
    {
// Check the core table but its not yet loaded
        if (wTable == 0)
        {
// Try to load it
            if (mciLoadCommandResource (ghInst, szCoreTable, 0) == -1)
            {
                DOUT ("FindCommandInTable:  cannot load core table\r\n");
                return NULL;
            }
        } else
        {
            DOUT ("MCI FindCommandInTable:  invalid table ID\r\n");
            return NULL;
        }

    }

    if ((lpResource = LockResource (command_tables[wTable].hResource)) == NULL)
    {
        DOUT ("MCI FindCommandInTable:  Cannot lock table resource\r\n");
        return NULL;
    }
#ifdef DEBUG
    ++command_tables[wTable].wLockCount;
#endif

// Look at each command in the table
    lpwIndex = command_tables[wTable].lpwIndex;
    if (lpwIndex == NULL)
    {
        DOUT ("MCI FindCommandInTable:  null command table index\r\n");
        return NULL;
    }

    while (*lpwIndex != -1)
    {
        DWORD dwMessage;

        lpstrThisCommand = *lpwIndex++ + lpResource;

// Get message number from the table
        mciEatCommandEntry (lpstrThisCommand, &dwMessage, NULL);
        wMessage = (UINT)dwMessage;

// Does this command match the input?

// String case
        if  (HIWORD  (lpstrCommand) != 0 &&
             lstrcmpi (lpstrThisCommand, lpstrCommand) == 0  ||

// Message case
             HIWORD (lpstrCommand) == 0 &&
             wMessage == LOWORD ((DWORD)lpstrCommand))
        {
// Retain the locked resource pointer
                command_tables[wTable].lpResource = lpResource;

// Address the message ID which comes after the command name
                if (lpwMessage != NULL)
                    *lpwMessage = wMessage;
// Leave table locked on exit
                return lpstrThisCommand;
        }

// Strings don't match, go to the next command in the table
    }

    UnlockResource (command_tables[wTable].hResource);
#ifdef DEBUG
    --command_tables[wTable].wLockCount;
#endif

    return NULL;
}

/*
 * @doc INTERNAL MCI
 * @func LPSTR | FindCommandItem | Look up the given
 * command string in the parser command tables
 *
 * @parm UINT | wDeviceID | The device ID used for this command.
 * If 0 then only the system core command table is searched.
 *
 * @parm LPCSTR | lpstrType | The type name of the device
 *
 * @parm LPCSTR | lpstrCommand | The command to look up.  It must
 * be in lower case with no leading or trailing blanks and with at
 * least one character.  If the HIWORD is 0 then the LOWORD contains
 * the command message ID instead of a command name and the function is
 * merely to find the command list pointer.
 *
 * If the high word is 0 then the low word is an command ID value instead
 * of a command name
 *
 * @parm UINT FAR* | lpwMessage | The message corresponding to the command
 * Returned to caller.
 *
 * @parm UINT FAR* | lpwTable | The table index in which the command was found
 * Returned to caller.
 *
 * @rdesc NULL if the command is unknown, otherwise a pointer to
 * the command list for the input command string.
 */
LPSTR PASCAL NEAR FindCommandItem (
UINT wDeviceID,
LPCSTR lpstrType,
LPCSTR lpstrCommand,
UINT FAR* lpwMessage,
UINT FAR* lpwTable)
{
    LPSTR lpCommand;
    UINT wTable;
    LPMCI_DEVICE_NODE nodeWorking;

// Only check hiword per comments above
    if (HIWORD (lpstrCommand) != NULL && *lpstrCommand == '\0')
    {
        DOUT ("MCI FindCommandItem:  lpstrCommand is NULL or empty string\r\n");
        return NULL;
    }

// If a specific device ID was specified then look in any custom table
// or type table
    if (wDeviceID != 0 && wDeviceID != MCI_ALL_DEVICE_ID)
    {
// If the device ID is valid
        if (!MCI_VALID_DEVICE_ID(wDeviceID))
        {
            DOUT ("MCI FindCommandItem:  Invalid device ID\r\n");
            return NULL;
        }
        nodeWorking = MCI_lpDeviceList[wDeviceID];

// If there is a custom command table then use it
        if ((wTable = nodeWorking->wCustomCommandTable) != -1)
        {
            lpCommand = FindCommandInTable (wTable, lpstrCommand, lpwMessage);
            if (lpCommand != NULL)
                goto exit;
        }
// Get the device type table from the existing device
// Relies on mciReparseCommand in mciLoadDevice to catch all device type
// tables when device is not yet open.
        if ((wTable = nodeWorking->wCommandTable) != -1)
        {
            lpCommand = FindCommandInTable (wTable, lpstrCommand, lpwMessage);
            if (lpCommand != NULL)
                goto exit;
        }
    }

// If no match was found in the device or type specific tables
// Look in the core table
    wTable = 0;
    lpCommand = FindCommandInTable (wTable, lpstrCommand, lpwMessage);
    if (lpCommand == NULL)
        wTable = (UINT)-1;

exit:
    if (lpwTable != NULL)
        *lpwTable = wTable;

#ifdef DEBUG
    if (DebugmciSendCommand > 2)
    {
        DOUT ("FindCommandItem INFO:  check locks...\r\n");
        mciCheckLocks();
    }
#endif

    return lpCommand;
}

/*
 * @doc INTERNAL MCI
 * @func LPSTR | mciCheckToken | Check to see if the command item matches
 * the given string, allowing multiple blanks in the input parameter to
 * match a corresponding single blank in the command token and ignoring
 * case.
 *
 * @parm LPCSTR | lpstrToken | The command token to check
 *
 * @parm LPCSTR | lpstrParam | The input parameter
 *
 * @rdesc NULL if no match, otherwise points to the first character
 * after the parameter
 *
 */
STATICFN LPSTR PASCAL NEAR
mciCheckToken(
    LPCSTR lpstrToken,
    LPCSTR lpstrParam
    )
{
/* Check for legal input */
    if (lpstrToken == NULL || lpstrParam == NULL)
        return NULL;

    while (*lpstrToken != '\0' && MCI_TOLOWER(*lpstrParam) == *lpstrToken)
    {
// If the token contains a blank, allow more than one blank in the
// parameter
        if (*lpstrToken == ' ')
            while (*lpstrParam == ' ')
                ++lpstrParam;
        else
            *lpstrParam++;
        *lpstrToken++;
    }
    if (*lpstrToken != '\0'|| (*lpstrParam != '\0' && *lpstrParam != ' '))
        return NULL;
    else
        return (LPSTR)lpstrParam;
}

/*
 * @doc INTERNAL MCI
 * @api BOOL | mciParseInteger | Parse the given integer
 *
 * @parm LPSTR FAR * | lplpstrInput | The string containing the argument.
 * It is updated and returned to the caller pointing to the first character
 * after the argument or to the first character that is in error.
 *
 * @parm LPDWORD | lpdwArgument | The place to put the output
 *
 * @rdesc Returns TRUE if not error
 *
 * @comm If there are colons in the input (':') the result is "colonized".
 * This means that each time a colon is read, the current result is written
 * and any subsequent digits are shifted left one byte.  No one "segment"
 * can be more than 0xFF.  For example, "0:1:2:3" is parsed to 0x03020100.
 *
 */

#pragma warning(4:4146)

STATICFN BOOL PASCAL NEAR
mciParseInteger(
    LPSTR FAR * lplpstrInput,
    LPDWORD lpdwArgument
    )
{
    LPSTR lpstrInput = *lplpstrInput;
    BOOL fDigitFound;
    DWORD dwResult;
    LPSTR lpstrResult = (LPSTR)lpdwArgument;
    int   nDigitPosition = 0;
    BOOL  bSigned = FALSE;

// Leading blanks have been removed by mciParseParams

    if (*lpstrInput == '-')
    {
        ++lpstrInput;
        bSigned = TRUE;
    }

// Read digits
    *lpdwArgument = 0;                      /* Initialize */
    dwResult = 0;
    fDigitFound = FALSE;                    /* Initialize */
    while (*lpstrInput >= '0' && *lpstrInput <= '9' || *lpstrInput == ':')
    {
// ':' indicates colonized data
        if (*lpstrInput == ':')
        {
// Cannot mix colonized and signed forms
            if (bSigned)
            {
                DOUT ("Bad integer: mixing signed and colonized forms\r\n");
                return FALSE;
            }
// Check for overflow in accumulated colonized byte
            if (dwResult > 0xFF)
                return FALSE;

// Copy and move to next byte converted in output
            *lpstrResult++ = (char)dwResult;
            ++lpstrInput;
// Initialize next colonized byte
            dwResult = 0;
            ++nDigitPosition;
// Only allow four colonized components
            if (nDigitPosition > 3)
            {
                DOUT ("Bad integer:  Too many colonized components\r\n");
                return FALSE;
            }
        } else
        {
            char cDigit = (char)(*lpstrInput++ - '0');
// Satisfies condition that at least one digit must be read
            fDigitFound = TRUE;

            if (dwResult > 0xFFFFFFFF / 10)
// Overflow if multiply was to occur
                return FALSE;
            else
// Multiply for next digit
                dwResult *= 10;

// Add new digit
            dwResult += cDigit;
        }
    }
    if (nDigitPosition == 0)
    {
// No colonized components
        if (bSigned)
        {
// Check for overflow from negation
            if (dwResult > 0x7FFFFFFF)
                return FALSE;
// Negate result because a '-' sign was parsed
            dwResult = -dwResult;
        }

        *lpdwArgument = dwResult;
    }
    else
// Store last colonized component
    {
// Check for overflow
        if (dwResult > 0xFF)
            return FALSE;
// Store component
        *lpstrResult = (char)dwResult;
    }

    *lplpstrInput = lpstrInput;

/*
If there were no digits or if the digits were followed by a character
other than a blank or a '\0', then return a syntax error.
*/
    return fDigitFound && (!*lpstrInput || *lpstrInput == ' ');
}

/*
 * @doc INTERNAL MCI
 * @func BOOL | mciParseConstant | Parse the given integer
 *
 * @parm LPSTR FAR * | lplpstrInput | The string containing the argument.
 * It is updated and returned to the caller pointing to the first character
 * after the argument or to the first character that is in error.
 *
 * @parm LPDWORD | lpdwArgument | The place to put the output
 *
 * @parm LPSTR | lpItem | Pointer into command table.
 *
 * @rdesc Returns TRUE if not error
 *
 */
STATICFN BOOL PASCAL NEAR
mciParseConstant(
    LPSTR FAR * lplpstrInput,
    LPDWORD lpdwArgument,
    LPSTR lpItem
    )
{
    LPSTR lpPrev;
    DWORD dwValue;
    UINT wID;

// Skip past constant header
    lpItem += mciEatCommandEntry (lpItem, &dwValue, &wID);

    while (TRUE)
    {
        LPSTR lpstrAfter;

        lpPrev = lpItem;

        lpItem += mciEatCommandEntry (lpItem, &dwValue, &wID);

        if (wID == MCI_END_CONSTANT)
            break;

        if ((lpstrAfter = mciCheckToken (lpPrev, *lplpstrInput)) != NULL)
        {
            *lpdwArgument = dwValue;
            *lplpstrInput = lpstrAfter;
            return TRUE;
        }

    }

    return mciParseInteger (lplpstrInput, lpdwArgument);
}

/*
 * @doc INTERNAL MCI
 * @func UINT | mciParseArgument | Parse the given argument
 *
 * @parm DWORD | dwValue | The argument value
 *
 * @parm UINT | wID | The argument ID
 *
 * @parm LPSTR FAR * | lplpstrOutput | The string containing the argument.
 * It is updated and returned to the caller pointing to the first character
 * after the argument or to the first character that is in error.
 *
 * @parm LPDWORD | lpdwFlags | The output flags
 *
 * @parm LPDWORD | lpArgument | The place to put the output
 *
 * @rdesc Returns 0 if no error or
 * @flag MCIERR_BAD_INTEGER | An integer argument could not be parsed
 * @flag MCIERR_MISSING_STRING_ARGUMENT | An expected string argument
 * @flag MCIERR_PARM_OVERFLOW | The output buffer was a NULL pointer
 * was missing
 *
 */
STATICFN UINT PASCAL NEAR
mciParseArgument(
    DWORD dwValue,
    UINT wID,
    LPSTR FAR * lplpstrOutput,
    LPDWORD lpdwFlags,
    LPSTR lpArgument,
    LPSTR lpCurrentCommandItem
    )
{
LPSTR lpstrInput =  *lplpstrOutput;
UINT wRetval = 0;

/* Switch on the argument type */
    switch (wID)
    {

// The parameter is a flag
        case MCI_FLAG:
            break; /* switch */

        case MCI_CONSTANT:
            if (*lpstrInput == '\0')
                wRetval = MCIERR_NO_INTEGER;
            else if (!mciParseConstant (&lpstrInput, (LPDWORD)lpArgument,
                                        lpCurrentCommandItem))
                wRetval = MCIERR_BAD_CONSTANT;
            break;

/* The parameter has an integer argument, try to parse it */
        case MCI_INTEGER:
            if (!mciParseInteger (&lpstrInput, (LPDWORD)lpArgument))
                wRetval = MCIERR_BAD_INTEGER;

            break; /* switch */
        case MCI_RECT:
        {
// Read in four RECT components.  Resulting structure is the
// same as a Windows RECT
            long lTemp;
            int n;
            for (n = 0; n < 4; ++n)
            {
                if (!mciParseInteger (&lpstrInput, &lTemp))
                {
                    wRetval = MCIERR_BAD_INTEGER;
                    break;
                }
// Each component is a signed 16 bit number
                if (lTemp > 32768 || lTemp < -32767)
                {
                    wRetval = MCIERR_BAD_INTEGER;
                    break;
                }
                ((int FAR *)lpArgument)[n] = (int)lTemp;
// Remove leading blanks before next digit
                while (*lpstrInput == ' ') ++lpstrInput;
            }
            break;
        }

        case MCI_STRING:
        {
            LPSTR lpstrOutput;

/* The parameter has an string argument, read it */

// Leading blanks have been removed by mciParseParams

/* Are there any non-blank characters left in the input? */
            if (*lpstrInput == '\0')
            {
/* Return an error */
                wRetval = MCIERR_MISSING_STRING_ARGUMENT;
                break; /* switch */
            }

            if ((wRetval = mciEatToken (&lpstrInput, ' ', &lpstrOutput, FALSE))
                != 0)
            {
                DOUT ("mciParseArgument:  error parsing string\r\n");
                return wRetval;
            }

            *(LPDWORD)lpArgument = (DWORD)lpstrOutput;

// NOTE:  mciSendString frees the output string after command execution
// by calling mciParserFree

            break; /* switch */
        } /* case */
    } /* switch */

/* Update the output flags if there was no error */
    if (wRetval == 0)
    {
        if (*lpdwFlags & dwValue)
        {
            if (wID == MCI_CONSTANT)
                wRetval = MCIERR_FLAGS_NOT_COMPATIBLE;
            else
                wRetval = MCIERR_DUPLICATE_FLAGS;
        } else
            *lpdwFlags |= dwValue;
    }
/*
   Return the input pointer pointing at the first character after
   the argument or to the first character that is in error
*/
    *lplpstrOutput = lpstrInput;
    return wRetval;
}

/*
 * @doc MCI INTERNAL
 * @func UINT | mciParseParams | Parse the command parameters
 *
 * @parm LPCSTR | lpstrParams | The parameter string
 *
 * @parm LPCSTR | lpCommandList | The command table description
 * of the command tokens
 *
 * @parm LPDWORD | lpdwFlags | Return the parsed flags here
 *
 * @parm LPDWORD | lpdwOutputParams | Return the list of parameters here
 *
 * @parm UINT | wParamsSize | The size allocated for the parameter list
 *
 * @parm LPSTR FAR * FAR * | lpPointerList | A NULL terminated list of
 * pointers allocated by this function that should be free'd when
 * no longer needed.   The list itself should be free'd also.  In both
 * cases, use mciFree().
 *
 * @parm UINT FAR* | lpwParsingError | If not NULL then if the command is
 * 'open', unrecognized keywords return an error here, and the
 * function return value is 0 (unless other errors occur).  This
 * is used to allow reparsing of the command by mciLoadDevice
 *
 * @rdesc Returns zero if successful or one of the following error codes:
 * @flag MCIERR_PARM_OVERFLOW | Not enough space for parameters
 * @flag MCIERR_UNRECOGNIZED_KEYWORD | Unrecognized keyword
 *
 * @comm Any syntax error, including missing arguments, will result in
 * a non-zero error return and invalid output data.
 *
 */
UINT PASCAL NEAR
mciParseParams(
    LPCSTR lpstrParams,
    LPCSTR lpCommandList,
    LPDWORD lpdwFlags,
    LPSTR lpOutputParams,
    UINT wParamsSize,
    LPSTR FAR * FAR *lpPointerList,
    UINT FAR* lpwOpenError
    )
{
    LPSTR lpFirstCommandItem, lpCurrentCommandItem;
    UINT wArgumentPosition, wErr, wLen, wID, wDefaultID;
    DWORD dwValue, dwDefaultValue;
    BOOL bOpenCommand;
    LPSTR FAR *lpstrPointerList;
    UINT wPointers = 0;
    UINT wHeaderSize = 0;
    LPSTR lpDefaultCommandItem = NULL;
    UINT wDefaultArgumentPosition;

    if (lpwOpenError != NULL)
        *lpwOpenError = 0;

// If the parameter pointer is NULL, return
    if (lpstrParams == NULL)
    {
        DOUT ("Warning:  lpstrParams is null in mciParseParams()\r\n");
        return 0;
    }

    if ((lpstrPointerList =
         mciAlloc ((MCI_MAX_PARAM_SLOTS + 1) * sizeof (LPSTR)))
        == NULL)
    {
        *lpPointerList = NULL;
        return MCIERR_OUT_OF_MEMORY;
    }

// If this is the "open" command then allow parameter errors
    bOpenCommand = lstrcmpi (lpCommandList, szOpen) == 0;

/* Clear all the flags */
    *lpdwFlags = 0;

/* Initialize the entry for the callback message window handle */
    wHeaderSize += sizeof (DWORD);
    if (wHeaderSize > wParamsSize)
    {
        wErr = MCIERR_PARAM_OVERFLOW;
        goto error_exit;
    }

/* Skip past the header */
    lpFirstCommandItem = (LPSTR)lpCommandList +
        mciEatCommandEntry (lpCommandList, NULL, NULL);

    wLen = mciEatCommandEntry (lpFirstCommandItem, &dwValue, &wID);
/* Make room in lpdwOutputParams for the return arguments if any */
    if (wID == MCI_RETURN)
    {
        lpFirstCommandItem += wLen;
        wHeaderSize += mciGetParamSize (dwValue, wID);
        if (wHeaderSize > wParamsSize)
        {
            wErr = MCIERR_PARAM_OVERFLOW;
            goto error_exit;
        }
    }

    lpOutputParams += wHeaderSize;

// Scan the parameter string looking up each parameter in the given command
// list

    while (TRUE)
    {
        LPCSTR lpstrArgument = NULL;

/* Remove leading blanks */
        while (*lpstrParams == ' ') ++lpstrParams;

/* Break at end of parameter string */
        if (*lpstrParams == '\0') break;

/* Scan for this parameter in the command list */
        lpCurrentCommandItem = lpFirstCommandItem;

        wLen = mciEatCommandEntry (lpCurrentCommandItem, &dwValue, &wID);

        wArgumentPosition = 0;

/* While there are more tokens in the Command List */
        while (wID != MCI_END_COMMAND)
        {
/* Check for a default argument if not already read */
            if (lpDefaultCommandItem == NULL &&
                *lpCurrentCommandItem == '\0')
            {
// Remember default argument
                lpDefaultCommandItem = lpCurrentCommandItem;
                dwDefaultValue = dwValue;
                wDefaultID = wID;
                wDefaultArgumentPosition = wArgumentPosition;
//              break;
            }
/* Check to see if this token matches */
            else if ((lpstrArgument =
                mciCheckToken (lpCurrentCommandItem, lpstrParams)) != NULL)
                break;

/* This token did not match the input but advance the argument position */
            wArgumentPosition += mciGetParamSize (dwValue, wID);

/* Go to next token */
            lpCurrentCommandItem += wLen;

// Is this command parameter a constant?
            if (wID == MCI_CONSTANT)
// Skip constant list
                do
                    lpCurrentCommandItem +=
                        mciEatCommandEntry (lpCurrentCommandItem, &dwValue, &wID);
                while (wID != MCI_END_CONSTANT);

            wLen = mciEatCommandEntry (lpCurrentCommandItem, &dwValue, &wID);
        } /* while */

/* If there were no matches */
        if (lpstrArgument == NULL)
        {
// If a default argument exists then try it
            if (lpDefaultCommandItem != NULL)
            {
                lpstrArgument = lpstrParams;
                dwValue = dwDefaultValue;
                wID = wDefaultID;
                lpCurrentCommandItem = lpDefaultCommandItem;
                wArgumentPosition = wDefaultArgumentPosition;
            } else
            {
// Allow missing paramters on OPEN command if indicated by a non-null
// lpwOpenError address
                if (!bOpenCommand || lpwOpenError == NULL)
                {
                    wErr = MCIERR_UNRECOGNIZED_KEYWORD;
                    goto error_exit;
                } else
                {
// Skip the parameter if OPEN command
                    while (*lpstrParams != ' ' && *lpstrParams != '\0')
                        ++lpstrParams;
                    if (lpwOpenError != NULL)
                        *lpwOpenError = MCIERR_UNRECOGNIZED_KEYWORD;
                    continue;
                }
            }
        }

/* Is there room in the output buffer for this argument? */
        if (wArgumentPosition + wHeaderSize + mciGetParamSize (dwValue, wID)
            > wParamsSize)
        {
            DOUT ("mciParseParams:  parameter space overflow\r\n");
            wErr = MCIERR_PARAM_OVERFLOW;
            goto error_exit;
        }

// Remove leading blanks
        while (*lpstrArgument == ' ') ++lpstrArgument;

/* Process this parameter, filling in any flags or arguments */
        if ((wErr = mciParseArgument (dwValue, wID,
                                      &lpstrArgument, lpdwFlags,
                                      &lpOutputParams[wArgumentPosition],
                                      lpCurrentCommandItem))
            != 0)
            goto error_exit;

        lpstrParams = lpstrArgument;

        if (wID == MCI_STRING)
        {
            if (wPointers >= MCI_MAX_PARAM_SLOTS)
            {
                DOUT ("Warning: Out of pointer list slots in mciParseParams\r\n");
                break;
            }

            (DWORD)lpstrPointerList[wPointers++] =
                *(LPDWORD)&lpOutputParams[wArgumentPosition];
        }

/* Continue reading the parameter string */
    } /* while */

// Terminate list
    lpstrPointerList[wPointers] = NULL;
// Copy reference for caller
    *lpPointerList = lpstrPointerList;
// Return Success
    return 0;

error_exit:
    *lpPointerList = NULL;
// Terminate list
    lpstrPointerList[wPointers] = NULL;
    mciParserFree (lpstrPointerList);
    return wErr;
}

/*
 * @doc INTERNAL  MCI
 * @func UINT | mciParseCommand | This function converts an MCI
 * control string to an MCI control message suitable for sending to
 * <f mciSendCommand>.  The input string usually comes from <f mciSendString>
 * and always has the device name stripped off the front.
 *
 * @parm UINT | wDeviceID | Identifies the device. First searches the parsing
 * table belonging to the driver.
 * Then searches the command tables matching the type
 * of the given device.  Then searches the core command table.
 *
 * @parm LPSTR | lpstrCommand | An MCI control command without
 * a device name prefix.  There must be no leading or trailing
 * blanks.
 *
 * @parm LPCSTR | lpstrDeviceName | The device name (second token on the
 * command line).  It is used to identify the device type.
 *
 * @parm LPSTR FAR * | lpCommandList | If not NULL then the address of
 * the command list for the parsed command (if successful) is copied here.
 * It is used later by mciSendString when parsing arguments
 *
 * @parm UINT FAR* | lpwTable | The table resource ID to be unlocked
 * after parsing.  Returned to caller.
 *
 * @rdesc Returns the command ID or 0 if not found.
 *
 */
UINT PASCAL NEAR
mciParseCommand(
    UINT wDeviceID,
    LPSTR lpstrCommand,
    LPCSTR lpstrDeviceName,
    LPSTR FAR * lpCommandList,
    UINT FAR* lpwTable)
{
    LPSTR lpCommandItem;
    UINT wMessage;

// Put the command in lower case
//!!    mciToLower (lpstrCommand);

// Look up lpstrCommand in the parser's command tables.
    if ((lpCommandItem = FindCommandItem (wDeviceID, lpstrDeviceName,
                                          lpstrCommand,
                                          &wMessage, lpwTable))
        == NULL)
        return 0;

/* Return the command list to the caller */
    if (lpCommandList != NULL)
        *lpCommandList = lpCommandItem;
    else
       DOUT ("Warning: NULL lpCommandList in mciParseCommanad\r\n");

    return wMessage;
}

/*
 * @doc INTERNAL MCI
 * @func void | mciParserFree | Free any buffers allocated to
 * receive string arguments.
 *
 * @parm LPSTR FAR * | lpstrPointerList | A NULL terminated list of far
 * pointers to strings to be free'd
 *
 */
void PASCAL NEAR
mciParserFree(
    LPSTR FAR *lpstrPointerList
    )
{
    LPSTR FAR *lpstrOriginal = lpstrPointerList;

    if (lpstrPointerList == NULL)
        return;

    while (*lpstrPointerList != NULL)
        mciFree (*lpstrPointerList++);

    mciFree (lpstrOriginal);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\mmsystem\mcisys.c ===
/*******************************Module*Header*********************************\
* Module Name: mcisys.c
*
* Media Control Architecture System Functions
*
* Created: 2/28/90
* Author:  DLL (DavidLe)
*
* History:
*
* Copyright (c) 1990 Microsoft Corporation
*
\******************************************************************************/

#include <windows.h>

#define MMNOMIDI
#define MMNOWAVE
#define MMNOSOUND
#define MMNOTIMER
#define MMNOJOY
#define MMNOSEQ
#include "mmsystem.h"
#define NOMIDIDEV
#define NOWAVEDEV
#define NOTIMERDEV
#define NOJOYDEV
#define NOSEQDEV
#define NOTASKDEV
#include "mmddk.h"
#include "mmsysi.h"
#include "thunks.h"

#ifndef STATICFN
#define STATICFN
#endif

extern char far szOpen[];          // in MCI.C

static SZCODE szNull[] = "";
static SZCODE szMciExtensions[] = "mci extensions";

#define MCI_EXTENSIONS szMciExtensions
#define MCI_PROFILE_STRING_LENGTH 255

//!!#define TOLOWER(c) ((c) >= 'A' && (c) <= 'Z' ? (c) + 'a' - 'A' : c)

// The device list is initialized on the first call to mciSendCommand or
// to mciSendString
BOOL MCI_bDeviceListInitialized;

// The next device ID to use for a new device
UINT MCI_wNextDeviceID = 1;

// The list of MCI devices. This list grows and shrinks as needed.
// The first offset MCI_lpDeviceList[0] is a placeholder and is unused
// because device 0 is defined as no device.
LPMCI_DEVICE_NODE FAR * MCI_lpDeviceList;

// The current size of the list of MCI devices
UINT MCI_wDeviceListSize;

// The internal mci heap used by mciAlloc and mciFree
HGLOBAL hMciHeap;

// File containing MCI device profile strings
extern char far szSystemIni[];			// in INIT.C

// Name of the section contining MCI device profile strings
static SZCODE szMCISectionName[] = "mci";

static SZCODE szAllDeviceName[] = "all";

static SZCODE szUnsignedFormat[] = "%u";

static void PASCAL NEAR mciFreeDevice(LPMCI_DEVICE_NODE nodeWorking);

BOOL NEAR PASCAL CouldBe16bitDrv(UINT wDeviceID)
{
    if (wDeviceID == MCI_ALL_DEVICE_ID) return TRUE;

    if (MCI_VALID_DEVICE_ID(wDeviceID)) {
        if (MCI_lpDeviceList[wDeviceID]->dwMCIFlags & MCINODE_16BIT_DRIVER) {
            return TRUE;
        }
    }
    return FALSE;
}

BOOL NEAR PASCAL Is16bitDrv(UINT wDeviceID)
{
    if (wDeviceID == MCI_ALL_DEVICE_ID) return FALSE;

    if (MCI_VALID_DEVICE_ID(wDeviceID)) {
        if (MCI_lpDeviceList[wDeviceID]->dwMCIFlags & MCINODE_16BIT_DRIVER) {
            return TRUE;
        }
    }
    return FALSE;
}

//
// Initialize device list
// Called once by mciSendString or mciSendCommand
// Returns TRUE on success
BOOL NEAR PASCAL mciInitDeviceList(void)
{

    if ((hMciHeap = HeapCreate(0)) == 0)
    {
        DOUT("Mci heap create failed!\r\n");
        return FALSE;
    }
    if ((MCI_lpDeviceList = mciAlloc (sizeof (LPMCI_DEVICE_NODE) *
                                  (MCI_INIT_DEVICE_LIST_SIZE + 1))) != NULL)
    {
        MCI_wDeviceListSize = MCI_INIT_DEVICE_LIST_SIZE;
        MCI_bDeviceListInitialized = TRUE;
        return TRUE;
    } else
    {
        DOUT ("MCIInit: could not allocate master MCI device list\r\n");
        return FALSE;
    }
}

/*
 * @doc EXTERNAL MCI
 * @api UINT | mciGetDeviceIDFromElementID | This function
 * retrieves the MCI device ID corresponding to and element ID
 *
 * @parm DWORD | dwElementID | The element ID
 *
 * @parm LPCSTR | lpstrType | The type name this element ID belongs to
 *
 * @rdesc Returns the device ID assigned when it was opened and used in the
 * <f mciSendCommand> function.  Returns zero if the device name was not known,
 * if the device was not open, or if there was not enough memory to complete
 * the operation or if lpstrType is NULL.
 *
 */
UINT WINAPI mciGetDeviceIDFromElementID (
DWORD dwElementID,
LPCSTR lpstrType)
{
    UINT wID;
    LPMCI_DEVICE_NODE nodeWorking, FAR *nodeCounter;
    char strTemp[MCI_MAX_DEVICE_TYPE_LENGTH];

    if (lpstrType == NULL)
        return 0;

    wID = (UINT)mciMessage( THUNK_MCI_GETDEVIDFROMELEMID, dwElementID,
                            (DWORD)lpstrType, 0L, 0L );
    if ( wID == 0 ) {

        nodeCounter = &MCI_lpDeviceList[1];

        for (wID = 1; wID < MCI_wNextDeviceID; ++wID)
        {
            nodeWorking = *nodeCounter++;

            if (nodeWorking == NULL)
                continue;

            if (nodeWorking->dwMCIOpenFlags & MCI_OPEN_ELEMENT_ID &&
                nodeWorking->dwElementID == dwElementID)

                if (LoadString (ghInst, nodeWorking->wDeviceType, strTemp,
                                sizeof(strTemp)) != 0
                    && lstrcmpi ((LPSTR)strTemp, lpstrType) == 0) {

                    return (wID);
                }
        }
        return 0;
    }
    return wID;
}

// Retrieves the device ID corresponding to the name of an opened device
// matching the given task
// This fn only looks for 16-bit devices
// See mciGetDeviceIDInternalEx that looks for all of them
UINT NEAR PASCAL mciGetDeviceIDInternal (
LPCSTR lpstrName,
HTASK hTask)
{
    UINT wID;
    LPMCI_DEVICE_NODE nodeWorking, FAR *nodeCounter;

    if (lstrcmpi (lpstrName, szAllDeviceName) == 0)
        return MCI_ALL_DEVICE_ID;

    if (MCI_lpDeviceList == NULL)
        return 0;

// Loop through the MCI device list
    nodeCounter = &MCI_lpDeviceList[1];
    for (wID = 1; wID < MCI_wNextDeviceID; ++wID)
    {
        nodeWorking = *nodeCounter++;

        if (nodeWorking == NULL)
            continue;

// If this device does not have a name then skip it
        if (nodeWorking->dwMCIOpenFlags & MCI_OPEN_ELEMENT_ID)
            continue;

// If the names match
        if (lstrcmpi(nodeWorking->lpstrName, lpstrName) == 0)

// If the device belongs to the indicated task
            if (nodeWorking->hOpeningTask == hTask)
// Return this device ID
                return wID;
    }

    return 0;
}

/*
 * @doc EXTERNAL MCI
 * @api UINT | mciGetDeviceID | This function retrieves the device
 * ID corresponding to the name of an open MCI device.
 *
 * @parm LPCSTR | lpstrName | Specifies the device name used to open the
 * MCI device.
 *
 * @rdesc Returns the device ID assigned when the device was opened.
 * Returns zero if the device name isn't known,
 * if the device isn't open, or if there was insufficient memory to complete
 * the operation.  Each compound device element has a unique device ID.
 * The ID of the "all" device is MCI_ALL_DEVICE_ID.
 *
 * @xref MCI_OPEN
 *
 */
UINT WINAPI mciGetDeviceID (
LPCSTR lpstrName)
{
    UINT    wDevID;

    /*
    ** Try the 32 bit side first
    */
    wDevID = (UINT)mciMessage( THUNK_MCI_GETDEVICEID, (DWORD)lpstrName,
                               0L, 0L, 0L );
    if ( wDevID == 0 ) {

        /*
        ** The 32 bit call failed so let the 16 bit side have a go.
        */
        wDevID = mciGetDeviceIDInternal (lpstrName, GetCurrentTask());

    }

    return wDevID;
}

//
//  This function is same as mciGetDeviceID but it won't call GetCurrentTask
//  Used when mci needs to verify the dev alias had not been allocated yet
//
//

UINT NEAR PASCAL mciGetDeviceIDInternalEx(
LPCSTR lpstrName,
HTASK hTask)
{
    UINT uiDevID;

    uiDevID = (UINT)mciMessage( THUNK_MCI_GETDEVICEID, (DWORD)lpstrName,
                                0L, 0L, 0L );
    if (0 == uiDevID) {

        uiDevID = mciGetDeviceIDInternal(lpstrName, hTask);
    }

    return uiDevID;
}


/*
 * @doc EXTERNAL MCI
 * @api HTASK | mciGetCreatorTask | This function retrieves the creator task
 * corresponding with the device ID passed.
 *
 * @parm UINT | wDeviceID | Specifies the device ID whose creator task is to
 * be returned.
 *
 * @rdesc Returns the creator task responsible for opening the device, else
 * NULL if the device ID passed is invalid.
 *
 */
HTASK WINAPI mciGetCreatorTask (
UINT wDeviceID)
{
    /*
    ** Is this a 16 bit device ID
    */
    if (Is16bitDrv(wDeviceID)) {

        return MCI_lpDeviceList[wDeviceID]->hCreatorTask;
    }

    /*
    ** No, so pass it on to the 32 bit code.
    */

    return (HTASK)mciMessage( THUNK_MCI_GETCREATORTASK, (DWORD)wDeviceID,
                              0L, 0L, 0L );
}

/*
 * @doc INTERNAL MCI
 * @func BOOL | mciDeviceMatch | Match the first string with the second.
 * Any single trailing digit on the first string is ignored.  Each string
 * must have at least one character
 *
 * @parm LPCSTR | lpstrDeviceName | The device name, possibly
 * with trailing digits but no blanks.
 *
 * @parm LPCSTR | lpstrDeviceType | The device type with no trailing digits
 * or blanks
 *
 * @rdesc TRUE if the strings match the above test, FALSE otherwise
 *
 */
STATICFN BOOL PASCAL NEAR
mciDeviceMatch(
    LPCSTR lpstrDeviceName,
    LPCSTR lpstrDeviceType
    )
{
    BOOL bAtLeastOne;

    for (bAtLeastOne = FALSE;;)
        if (!*lpstrDeviceType)
            break;
        else if (!*lpstrDeviceName || ((BYTE)(WORD)(DWORD)AnsiLower((LPSTR)(DWORD)(WORD)(*lpstrDeviceName++)) != (BYTE)(WORD)(DWORD)AnsiLower((LPSTR)(DWORD)(WORD)(*lpstrDeviceType++))))
            return FALSE;
        else
            bAtLeastOne = TRUE;
    if (!bAtLeastOne)
        return FALSE;
    for (; *lpstrDeviceName; lpstrDeviceName++)
        if ((*lpstrDeviceName < '0') || (*lpstrDeviceName > '9'))
            return FALSE;
    return TRUE;
}

/*
 * @doc INTERNAL MCI
 * @func UINT | mciLookUpType | Look up the type given a type name
 *
 * @parm LPCSTR | lpstrTypeName | The type name to look up.  Trailing
 * digits are ignored.
 *
 * @rdesc The MCI type number (MCI_DEVTYPE_<x>) or 0 if not found
 *
!! * @comm Converts the input string to lower case as a side effect
 *
 */
UINT PASCAL NEAR mciLookUpType (
LPCSTR lpstrTypeName)
{
    UINT wType;
    char strType[MCI_MAX_DEVICE_TYPE_LENGTH];

//!!    mciToLower (lpstrTypeName);

    for (wType = MCI_DEVTYPE_FIRST; wType <= MCI_DEVTYPE_LAST; ++wType)
    {
        if (LoadString (ghInst, wType, strType, sizeof(strType)) == 0)
        {
            DOUT ("mciLookUpType:  could not load string for type\r\n");
            continue;
        }

        if (mciDeviceMatch (lpstrTypeName, strType))
            return wType;
    }
    return 0;
}

/*
 * @doc INTERNAL MCI
 * @func DWORD | mciSysinfo | Get system information about a device
 *
 * @parm UINT | wDeviceID | Device ID, may be 0
 *
 * @parm DWORD | dwFlags | SYSINFO flags
 *
 * @parm LPMCI_SYSINFO_PARMS | lpSysinfo | SYSINFO parameters
 *
 * @rdesc 0 if successful, otherwise error code
 *
 */
DWORD PASCAL NEAR mciSysinfo (
UINT wDeviceID,
DWORD dwFlags,
LPMCI_SYSINFO_PARMS lpSysinfo)
{
    UINT wCounted;
    char              strBuffer[MCI_PROFILE_STRING_LENGTH];
    LPSTR             lpstrBuffer = (LPSTR)strBuffer, lpstrStart;

    if (dwFlags & MCI_SYSINFO_NAME && lpSysinfo->dwNumber == 0)
        return MCIERR_OUTOFRANGE;

    if (lpSysinfo->lpstrReturn == NULL || lpSysinfo->dwRetSize == 0)
        return MCIERR_PARAM_OVERFLOW;

    if (dwFlags & MCI_SYSINFO_NAME && dwFlags & MCI_SYSINFO_QUANTITY)
        return MCIERR_FLAGS_NOT_COMPATIBLE;

    if (dwFlags & MCI_SYSINFO_INSTALLNAME)
    {
        LPMCI_DEVICE_NODE nodeWorking;

        if (wDeviceID == MCI_ALL_DEVICE_ID)
            return MCIERR_CANNOT_USE_ALL;
        if (!MCI_VALID_DEVICE_ID(wDeviceID))
            return MCIERR_INVALID_DEVICE_NAME;

        nodeWorking = MCI_lpDeviceList[wDeviceID];
        if ((DWORD)lstrlen (nodeWorking->lpstrInstallName) >= lpSysinfo->dwRetSize)
            return MCIERR_PARAM_OVERFLOW;
        lstrcpy (lpSysinfo->lpstrReturn, nodeWorking->lpstrInstallName);
        return 0;
    } else if (!(dwFlags & MCI_SYSINFO_OPEN))
    {
        if (wDeviceID != MCI_ALL_DEVICE_ID && lpSysinfo->wDeviceType == 0)
            return MCIERR_DEVICE_TYPE_REQUIRED;

        if ((dwFlags & (MCI_SYSINFO_QUANTITY | MCI_SYSINFO_NAME)) == 0)
            return MCIERR_MISSING_PARAMETER;
        GetPrivateProfileString (szMCISectionName, NULL, szNull,
                                 lpstrBuffer, MCI_PROFILE_STRING_LENGTH,
                                 szSystemIni);
        wCounted = 0;
        while (TRUE)
        {
            if (dwFlags & MCI_SYSINFO_QUANTITY)
            {
                if (*lpstrBuffer == '\0')
                {
                    *(LPDWORD)lpSysinfo->lpstrReturn = (DWORD)wCounted;
                    return MCI_INTEGER_RETURNED;
                }
                if (wDeviceID == MCI_ALL_DEVICE_ID ||
                    mciLookUpType (lpstrBuffer) == lpSysinfo->wDeviceType)
                    ++wCounted;
// Skip past the terminating '\0'
                while (*lpstrBuffer != '\0')
                    *lpstrBuffer++;
                lpstrBuffer++;
            } else if (dwFlags & MCI_SYSINFO_NAME)
            {
                if (wCounted == (UINT)lpSysinfo->dwNumber)
                {
                    lstrcpy (lpSysinfo->lpstrReturn, lpstrStart);
                    return 0L;
                } else if (*lpstrBuffer == '\0')
                    return MCIERR_OUTOFRANGE;
                else
                {
                    lpstrStart = lpstrBuffer;
                    if (wDeviceID == MCI_ALL_DEVICE_ID ||
                        mciLookUpType (lpstrBuffer) == lpSysinfo->wDeviceType)
                        ++wCounted;
// Skip past the terminating '\0'
                    while (*lpstrBuffer != '\0')
                        *lpstrBuffer++;
                    lpstrBuffer++;
                }
            }
        }
    } else
// Process MCI_SYSINFO_OPEN cases
    {
        UINT wID;
        HTASK hCurrentTask = GetCurrentTask();
        LPMCI_DEVICE_NODE Node;

        if (wDeviceID != MCI_ALL_DEVICE_ID &&
            lpSysinfo->wDeviceType == 0)
            return MCIERR_DEVICE_TYPE_REQUIRED;

        if ((dwFlags & (MCI_SYSINFO_QUANTITY | MCI_SYSINFO_NAME)) == 0)
            return MCIERR_MISSING_PARAMETER;

        wCounted = 0;
        for (wID = 1; wID < MCI_wNextDeviceID; ++wID)
        {
            if ((Node = MCI_lpDeviceList[wID]) == 0)
                continue;

            if (wDeviceID == MCI_ALL_DEVICE_ID &&
                Node->hOpeningTask == hCurrentTask)
                ++wCounted;
            else
            {
                if (Node->wDeviceType == lpSysinfo->wDeviceType &&
                    Node->hOpeningTask == hCurrentTask)
                    ++wCounted;
            }
            if (dwFlags & MCI_SYSINFO_NAME &&
                wCounted == (UINT)lpSysinfo->dwNumber)
            {
                lstrcpy (lpSysinfo->lpstrReturn, Node->lpstrName);
                return 0L;
            }
        }
        if (dwFlags & MCI_SYSINFO_NAME)
        {
            if (lpSysinfo->lpstrReturn != NULL)
                lpSysinfo->lpstrReturn = '\0';
            return MCIERR_OUTOFRANGE;

        } else if (dwFlags & MCI_SYSINFO_QUANTITY &&
                   lpSysinfo->lpstrReturn != NULL &&
                   lpSysinfo->dwRetSize >= 4)

            *(LPDWORD)lpSysinfo->lpstrReturn = wCounted;
    }
    return MCI_INTEGER_RETURNED;
}

/*
 * @doc INTERNAL MCI
 * @func UINT | wAddDeviceNodeToList | Add the given global handle into the
 * MCI device table and return that entry's ID#
 *
 * @parm LPMCI_DEVICE_NODE | node | device description
 *
 * @rdesc The ID value for this device or 0 if there is no memory to expand
 * the device list
 *
 */
STATICFN UINT PASCAL NEAR
wAddDeviceNodeToList(
    LPMCI_DEVICE_NODE node
    )
{
    UINT wDeviceID = node->wDeviceID;
    LPMCI_DEVICE_NODE FAR *lpTempList;
    UINT iReallocSize;

    while (wDeviceID >= MCI_wDeviceListSize)
    {
        // The list is full so try to grow it
        iReallocSize = MCI_wDeviceListSize + 1 + MCI_DEVICE_LIST_GROW_SIZE;
        iReallocSize *= sizeof(LPMCI_DEVICE_NODE);
        if ((lpTempList = mciReAlloc(MCI_lpDeviceList, iReallocSize)) == NULL)
        {
            DOUT ("wReserveDeviceID:  cannot grow device list\r\n");
            return 0;
        }
        MCI_lpDeviceList = lpTempList;
        MCI_wDeviceListSize += MCI_DEVICE_LIST_GROW_SIZE;
    }

    if (wDeviceID >= MCI_wNextDeviceID) {
        MCI_wNextDeviceID = wDeviceID + 1;
    }

    MCI_lpDeviceList[wDeviceID] = node;

    return wDeviceID;
}

//
// Allocate space for the given string and assign the name to the given
// device.
// Return FALSE if could not allocate memory
//
STATICFN BOOL PASCAL NEAR
mciAddDeviceName(
    LPMCI_DEVICE_NODE nodeWorking,
    LPCSTR lpDeviceName
    )
{
    nodeWorking->lpstrName = mciAlloc(lstrlen(lpDeviceName)+1);

    if (nodeWorking->lpstrName == NULL)
    {
        DOUT ("mciAddDeviceName:  Out of memory allocating device name\r\n");
        return FALSE;
    }

    // copy device name to mci node and lowercase it

    lstrcpy(nodeWorking->lpstrName, lpDeviceName);
//!!    mciToLower(nodeWorking->lpstrName);

    return TRUE;
}

/*
 * @doc INTERNAL MCI
 * @func UINT | mciAllocateNode | Allocate a new driver entry
 *
 * @parm DWORD | dwFlags | As sent with MCI_OPEN message
 * @parm LPCSTR | lpDeviceName | The device name
 * @parm LPMCI_DEVICE_NODE FAR * | lpnodeNew | new node allocated
 *
 * @rdesc The device ID to the new node.  0 on error.
 *
 */
STATICFN UINT PASCAL NEAR mciAllocateNode(
    DWORD dwFlags,
    LPCSTR lpDeviceName,
    LPMCI_DEVICE_NODE FAR *lpnodeNew
    )
{
    LPMCI_DEVICE_NODE   nodeWorking;
    UINT wDeviceID;

    if ((nodeWorking = mciAlloc(sizeof(MCI_DEVICE_NODE))) == NULL)
    {
        DOUT("Out of memory in mciAllocateNode\r\n");
        return 0;
    }

    // The device ID is a global resource so we fetch it from 32-bit MCI.
    // A node is also allocated on the 32-bit side, and marked as 16-bit. The
    // node will be freed during mciFreeDevice, and acts as a place holder for
    // the device ID.

    wDeviceID = (UINT) mciMessage(THUNK_MCI_ALLOCATE_NODE,
                                  dwFlags,
                                  (DWORD)lpDeviceName,
                                  0L, 0L);

    // Copy the working node to the device list
    nodeWorking->wDeviceID = wDeviceID;
    if (wAddDeviceNodeToList(nodeWorking) == 0)
    {
        DOUT ("mciAllocateNode:  Cannot allocate new node\r\n");
        mciFree(nodeWorking);
        return 0;
    }

    // Initialize node
    nodeWorking->hCreatorTask = GetCurrentTask ();
    nodeWorking->dwMCIFlags |= MCINODE_16BIT_DRIVER;

    if (dwFlags & MCI_OPEN_ELEMENT_ID) {
        // No device name, just an element ID
        nodeWorking->dwElementID = (DWORD)lpDeviceName;
    }
    else {
        if (!mciAddDeviceName (nodeWorking, lpDeviceName))
        {
            mciFree (nodeWorking);
            return 0;
        }
    }
    *lpnodeNew = nodeWorking;

    return nodeWorking->wDeviceID;
}

//
// Reparse the original command parameters
// Returns MCIERR code.  If the reparse fails the original error code
// from the first parsing is returned.
//
STATICFN UINT PASCAL NEAR
mciReparseOpen(
    LPMCI_INTERNAL_OPEN_INFO lpOpenInfo,
    UINT wCustomTable,
    UINT wTypeTable,
    LPDWORD lpdwFlags,
    LPMCI_OPEN_PARMS FAR *lplpOpen,
    UINT wDeviceID
    )
{
    LPSTR               lpCommand;
    LPDWORD             lpdwParams;
    UINT                wErr;
    DWORD               dwOldFlags = *lpdwFlags;

// If the custom table contains no open command
    if (wCustomTable == -1 ||
        (lpCommand = FindCommandInTable (wCustomTable, szOpen, NULL)) == NULL)
    {
// Try the type specific table
        lpCommand = FindCommandInTable (wTypeTable, szOpen, NULL);
// If it still cannot be parsed
        if (lpCommand == NULL)
            return lpOpenInfo->wParsingError;
        wCustomTable = wTypeTable;
    }
// A new version of 'open' was found
// Free previous set of parameters
    mciParserFree (lpOpenInfo->lpstrPointerList);
    *lpdwFlags = 0;

    if ((lpdwParams =
            (LPDWORD)mciAlloc (sizeof(DWORD) * MCI_MAX_PARAM_SLOTS))
        == NULL)
            return MCIERR_OUT_OF_MEMORY;

    wErr = mciParseParams (lpOpenInfo->lpstrParams, lpCommand,
                            lpdwFlags,
                            (LPSTR)lpdwParams,
                            sizeof(DWORD) * MCI_MAX_PARAM_SLOTS,
                            &lpOpenInfo->lpstrPointerList, NULL);
// We don't need this around anymore
    mciUnlockCommandTable (wCustomTable);

// If there was a parsing error
    if (wErr != 0)
    {
// Make sure this does not get free'd by mciSendString
        lpOpenInfo->lpstrPointerList = NULL;

        mciFree (lpdwParams);
        return wErr;
    }
    if (dwOldFlags & MCI_OPEN_TYPE)
    {
// Device type was already extracted so add it manually
        ((LPMCI_OPEN_PARMS)lpdwParams)->lpstrDeviceType
            = (*lplpOpen)->lpstrDeviceType;
        *lpdwFlags |= MCI_OPEN_TYPE;
    }
    if (dwOldFlags & MCI_OPEN_ELEMENT)
    {
// Element name was already extracted so add it manually
        ((LPMCI_OPEN_PARMS)lpdwParams)->lpstrElementName
            = (*lplpOpen)->lpstrElementName;
        *lpdwFlags |= MCI_OPEN_ELEMENT;
    }
    if (dwOldFlags & MCI_OPEN_ALIAS)
    {
// Alias name was already extracted so add it manually
        ((LPMCI_OPEN_PARMS)lpdwParams)->lpstrAlias
            = (*lplpOpen)->lpstrAlias;
        *lpdwFlags |= MCI_OPEN_ALIAS;
    }
    if (dwOldFlags & MCI_NOTIFY)
// Notify was already extracted so add it manually
        ((LPMCI_OPEN_PARMS)lpdwParams)->dwCallback
            = (*lplpOpen)->dwCallback;

    // Replace old parameter list with new list
    *lplpOpen = (LPMCI_OPEN_PARMS)lpdwParams;

    return 0;
}

// See if lpstrDriverName exists in the profile strings of the [mci]
// section and return the keyname in lpstrDevice and the
// profile string in lpstrProfString
// Returns 0 on success or an error code
STATICFN UINT PASCAL NEAR
mciFindDriverName(
    LPCSTR lpstrDriverName,
    LPSTR lpstrDevice,
    LPSTR lpstrProfString,
    UINT wProfLength
    )
{
    LPSTR lpstrEnum, lpstrEnumStart;
    UINT wEnumLen = 100;
    UINT wErr;
    LPSTR lpstrDriverTemp, lpstrProfTemp;

// Enumerate values, trying until they fit into the buffer
    while (TRUE) {
        if ((lpstrEnum = mciAlloc (wEnumLen)) == NULL)
            return MCIERR_OUT_OF_MEMORY;

        wErr = GetPrivateProfileString ((LPSTR)szMCISectionName,
                                    NULL, szNull, lpstrEnum, wEnumLen,
                                    szSystemIni);

        if (*lpstrEnum == '\0')
        {
            mciFree (lpstrEnum);
            return MCIERR_DEVICE_NOT_INSTALLED;
        }

        if (wErr == wEnumLen - 2)
        {
            wEnumLen *= 2;
            mciFree (lpstrEnum);
        } else
            break;
    }

    lpstrEnumStart = lpstrEnum;
    if (lstrlen(lpstrDriverName) >= MCI_MAX_DEVICE_TYPE_LENGTH) {
        wErr = MCIERR_DEVICE_LENGTH;
        goto exit_fn;
    }
    lstrcpy(lpstrDevice, lpstrDriverName);
//!!    mciToLower (lpstrDevice);

// Walk through each string
    while (TRUE) {
        wErr = GetPrivateProfileString ((LPSTR)szMCISectionName,
                                    lpstrEnum, szNull, lpstrProfString,
                                    wProfLength,
                                    szSystemIni);
        if (*lpstrProfString == '\0')
        {
            DOUT ("mciFindDriverName: cannot load valid keyname\r\n");
            wErr = MCIERR_CANNOT_LOAD_DRIVER;
            goto exit_fn;
        }
// See if driver pathname matches input
//!!        mciToLower (lpstrProfString);
        lpstrDriverTemp = lpstrDevice;
        lpstrProfTemp = lpstrProfString;
// Find end of file name
        while (*lpstrProfTemp != '\0' && *lpstrProfTemp != ' ')
            ++lpstrProfTemp;
// Find begining of simple file name
        --lpstrProfTemp;
        while (*lpstrProfTemp != '\\' && *lpstrProfTemp != '/' &&
               *lpstrProfTemp != ':')
            if (--lpstrProfTemp < lpstrProfString)
                break;
        ++lpstrProfTemp;
// Compare to input
        while (*lpstrDriverTemp != '\0')
            if (*lpstrDriverTemp++ != *lpstrProfTemp++ ||
                (UINT)(lpstrProfTemp - lpstrProfString) >= wProfLength)
            {
                --lpstrProfTemp;
                break;
            }
// If the input was contained in the profile string and followed by
// a space or a '.' the we've got it!
        if (*lpstrDriverTemp == '\0' &&
            (*lpstrProfTemp == ' ' || *lpstrProfTemp == '.'))
        {
            if (lstrlen (lpstrEnum) >= MCI_MAX_DEVICE_TYPE_LENGTH)
            {
                DOUT ("mciFindDriverName: device name too long\r\n");
                wErr = MCIERR_DEVICE_LENGTH;
                goto exit_fn;
            }
            lstrcpy (lpstrDevice, lpstrEnum);
            wErr = 0;
            goto exit_fn;
        }
// Skip to next keyname
        while (*lpstrEnum++ != '\0') {}
// Error if no more left
        if (*lpstrEnum == 0)
        {
            wErr = MCIERR_INVALID_DEVICE_NAME;
            goto exit_fn;
        }
    }

exit_fn:
    mciFree (lpstrEnumStart);
    return wErr;
}

//
// Identifies the driver name to load
// Loads the driver
// Reparses open command if necessary
// Sets a default break key
//
// lpOpenInfo contains various info for reparsing
//
// bDefaultAlias indicates that the alias need not be verified because
// it was internally assigned
//
STATICFN UINT PASCAL NEAR
mciLoadDevice(
    DWORD dwFlags,
    LPMCI_OPEN_PARMS lpOpen,
    LPMCI_INTERNAL_OPEN_INFO lpOpenInfo,
    BOOL bDefaultAlias
    )
{
    LPMCI_DEVICE_NODE   nodeWorking;
    HINSTANCE           hDriver;
    UINT                wID, wErr;
    char                strProfileString[MCI_PROFILE_STRING_LENGTH];
    MCI_OPEN_DRIVER_PARMS DriverOpen;
    HDRVR               hDrvDriver;
    LPSTR               lpstrParams;
    LPCSTR              lpstrInstallName, lpstrDeviceName;
    LPSTR               lpstrCopy = NULL;
    LPMCI_OPEN_PARMS    lpOriginalOpenParms = lpOpen;

/* Check for the device name in SYSTEM.INI */
    lpstrInstallName = lpOpen->lpstrDeviceType;
    wErr = GetPrivateProfileString ((LPSTR)szMCISectionName,
                                lpstrInstallName,
                                szNull, (LPSTR)strProfileString,
                                MCI_PROFILE_STRING_LENGTH,
                                szSystemIni);

// If device name not found
    if (wErr == 0)
    {
        int nLen = lstrlen (lpstrInstallName);
        int index;

// Try for the device name with a '1' thru a '9' appended to it

        if ((lpstrCopy = (LPSTR)mciAlloc (nLen + 2)) // space for digit too
            == NULL)
        {
            DOUT ("mciLoadDevice:  cannot allocate device name copy\r\n");
            return MCIERR_OUT_OF_MEMORY;
        }
        lstrcpy (lpstrCopy, lpstrInstallName);

        lpstrCopy[nLen + 1] = '\0';

        for (index = 1; index <= 9; ++index)
        {
            lpstrCopy[nLen] = (char)('0' + index);
            wErr = GetPrivateProfileString ((LPSTR)szMCISectionName,
                                        lpstrCopy,
                                        szNull, (LPSTR)strProfileString,
                                        MCI_PROFILE_STRING_LENGTH,
                                        szSystemIni);
            if (wErr != 0)
                break;
        }
        if (wErr == 0)
        {
            mciFree (lpstrCopy);
            if ((lpstrCopy = (LPSTR)mciAlloc (MCI_MAX_DEVICE_TYPE_LENGTH))
                == NULL)
            {
                DOUT ("mciLoadDevice:  cannot allocate device name copy\r\n");
                return MCIERR_OUT_OF_MEMORY;
            }
            if ((wErr = mciFindDriverName (lpstrInstallName, lpstrCopy,
                                           (LPSTR)strProfileString,
                                           MCI_PROFILE_STRING_LENGTH)) != 0)
                goto exit_fn;
        }
        lpstrInstallName = lpstrCopy;
    }

// Break out the device driver pathname and the parameter list

    lpstrParams = strProfileString;

// Eat blanks
    while (*lpstrParams != ' ' && *lpstrParams != '\0')
        ++lpstrParams;

// Terminate driver file name
    if (*lpstrParams == ' ') *lpstrParams++ = '\0';

//Now "strProfileString" is the device driver and "lpstrParams" is
//the parameter string
    if (dwFlags & (MCI_OPEN_ELEMENT | MCI_OPEN_ELEMENT_ID))
        lpstrDeviceName = lpOpen->lpstrElementName;
    else
        lpstrDeviceName = lpOpen->lpstrDeviceType;

    if (dwFlags & MCI_OPEN_ALIAS)
    {
// If the alias is default then we've already checked its uniqueness
        if (!bDefaultAlias &&
            mciGetDeviceIDInternalEx (lpOpen->lpstrAlias,
                                      lpOpenInfo->hCallingTask) != 0)
        {
            wErr = MCIERR_DUPLICATE_ALIAS;
            goto exit_fn;
        }
        lpstrDeviceName = lpOpen->lpstrAlias;
    }

    wID = mciAllocateNode (dwFlags, lpstrDeviceName, &nodeWorking);

    if (wID == 0)
    {
        wErr = MCIERR_CANNOT_LOAD_DRIVER;
        goto exit_fn;
    }

// Identify the task which initiated the open command
    nodeWorking->hOpeningTask = lpOpenInfo->hCallingTask;

// Initialize the driver
    DriverOpen.lpstrParams = lpstrParams;
    DriverOpen.wCustomCommandTable = (UINT)-1;
    DriverOpen.wType = 0;
    DriverOpen.wDeviceID = wID;

// Load the driver
    hDrvDriver = OpenDriver ((LPSTR)strProfileString, szMCISectionName,
                          (LPARAM)(DWORD)(LPMCI_OPEN_DRIVER_PARMS)&DriverOpen);
    if (hDrvDriver == NULL)
    {
        DOUT ("mciLoadDevice:  OpenDriver failed\r\n");
// Assume driver has free'd any custom command table when it failed the open
        mciFreeDevice (nodeWorking);
        wErr = MCIERR_CANNOT_LOAD_DRIVER;
        goto exit_fn;
    }

    lpOpen->wDeviceID = wID;
    lpOpen->wReserved0 = 0;

    hDriver = GetDriverModuleHandle (hDrvDriver);

    nodeWorking->hDrvDriver = hDrvDriver;
    nodeWorking->hDriver = hDriver;

// Driver provides custom device table and type
    nodeWorking->wCustomCommandTable = DriverOpen.wCustomCommandTable;
    nodeWorking->wDeviceType = DriverOpen.wType;

// Load driver's type table
    if ((nodeWorking->wCommandTable = mciLoadTableType (DriverOpen.wType))
        == -1)
// Load from a file if necessary
        nodeWorking->wCommandTable =
            mciLoadCommandResource (ghInst, lpOpen->lpstrDeviceType,
                                    DriverOpen.wType);

// Record this for 'sysinfo installname'
    if ((nodeWorking->lpstrInstallName =
                    mciAlloc (lstrlen (lpstrInstallName) + 1))
        == NULL)
    {
        mciCloseDevice (wID, 0L, NULL, FALSE);
        wErr = MCIERR_OUT_OF_MEMORY;
        goto exit_fn;
    } else
        lstrcpy (nodeWorking->lpstrInstallName, lpstrInstallName);

// Reparse the input command if no type was known the first time or if
// there was a custom command table
// and there were any open command parameters
    if (lpOpenInfo->lpstrParams != NULL)
    {
        if ((wErr = mciReparseOpen (lpOpenInfo,
                                    nodeWorking->wCustomCommandTable,
                                    nodeWorking->wCommandTable,
                                    &dwFlags, &lpOpen, wID)) != 0)
        {
            mciCloseDevice (wID, 0L, NULL, FALSE);
            goto exit_fn;
        }
// If there is no custom command table but mciSendString had a parsing
// error then close the device and report the error now
    } else if (lpOpenInfo->wParsingError != 0)
    {
        mciCloseDevice (wID, 0L, NULL, FALSE);
        wErr = lpOpenInfo->wParsingError;
        goto exit_fn;
    }

/* Send MCI_OPEN_DRIVER command to device */
    wErr = LOWORD(mciSendCommand (wID, MCI_OPEN_DRIVER,
                                 dwFlags, (DWORD)lpOpen));

// If the OPEN failed then close the device (don't send a CLOSE though)
    if (wErr != 0)
        mciCloseDevice (wID, 0L, NULL, FALSE);
    else
// Set default break key
        mciSetBreakKey (nodeWorking->wDeviceID, VK_CANCEL, NULL);

// If we replaced the open parms here then free them
    if (lpOriginalOpenParms != lpOpen && lpOpen != NULL)
        mciFree (lpOpen);

exit_fn:
    if (lpstrCopy != NULL)
        mciFree (lpstrCopy);

    return wErr;
}

/*
 * @doc INTERNAL MCI
 * @func BOOL | mciExtractDeviceType | If the given device name ends with
 * a file extension (.???) then try to get a typename from the
 * [mci extensions] section of WIN.INI
 *
 * @parm LPCSTR | lpstrDeviceName | The name to get the type from
 *
 * @parm LPSTR | lpstrDeviceType | The device type, returned to caller.
 *
 * @parm UINT | wBufLen | The length of the output buffer
 *
 * @rdesc TRUE if the type was found, FALSE otherwise
 *
 */
BOOL PASCAL NEAR mciExtractDeviceType (
LPCSTR lpstrDeviceName,
LPSTR lpstrDeviceType,
UINT wBufLen)
{
    LPCSTR lpstrExt = lpstrDeviceName;
    int i;

// Goto end of string
    while (*lpstrExt != '\0')
    {
// '!' case is handled elsewhere
        if (*lpstrExt == '!')
            return FALSE;
        ++lpstrExt;
    }

// Must be at least 2 characters in string
    if (lpstrExt - lpstrDeviceName < 2)
        return FALSE;

    lpstrExt -= 1;

// Does not count if last character is '.'
    if (*lpstrExt == '.')
        return FALSE;

    lpstrExt -= 1;
// Now looking at second to the last character.  Check this and the two
// previous characters for a '.'

    for (i=1; i<=3; ++i)
    {
// Cannot have path separator here
        if (*lpstrExt == '/' || *lpstrExt == '\\')
            return FALSE;

        if (*lpstrExt == '.')
        {
            ++lpstrExt;
            if (GetProfileString (MCI_EXTENSIONS, lpstrExt, szNull,
                                            lpstrDeviceType, wBufLen) != 0)
                return TRUE;
        }
        if (lpstrExt == lpstrDeviceName)
            return FALSE;
        --lpstrExt;
    }
    return FALSE;
}

// Copy characters up to cSeparater into output which is allocated
// by this function using mciAlloc.  Return the input pointer pointing
// to the character after cSeparator
// unless the separator is '\0' in which case it points to the end.
//
// Return the allocated pointer
//
// If bMustFind then the output string is created only if the token
// is found and is otherwise NULL.  Else the output string is always created.
//
// cSeparator is ignored inside matching quotes ("abd"), the quotes
// are not coppied and doubled
// quotes inside are compressed to one.  There must be a terminating quote.
// Quotes are treated normally unless the first character is a quote
//
// Function return value is 0 or an MCIERR code.  A missing separator does
// not cause an error return.
UINT PASCAL NEAR mciEatToken (LPCSTR FAR *lplpstrInput, char cSeparater,
                  LPSTR FAR *lplpstrOutput, BOOL bMustFind)
{
    LPCSTR lpstrEnd = *lplpstrInput, lpstrCounter;
    LPSTR  lpstrOutput;
    UINT wLen;
    BOOL bInQuotes = FALSE, bParseQuotes = TRUE, bQuoted = FALSE;

// Clear output
   *lplpstrOutput = NULL;

// Scan for token or end of string
    while ((*lpstrEnd != cSeparater || bInQuotes) && *lpstrEnd != '\0')
    {
// If quote
        if (*lpstrEnd == '"' && bParseQuotes)
        {
// If inside quotes
            if (bInQuotes)
            {
// If next character is a quote also
                if (*(lpstrEnd + 1) == '"')
// Skip it
                    ++lpstrEnd;
                else
                    bInQuotes = FALSE;
            } else
            {
                bInQuotes = TRUE;
                bQuoted = TRUE;
            }
        } else if (!bInQuotes)
        {
            if (bQuoted)
                return MCIERR_EXTRA_CHARACTERS;
// A non-quote was read first so treat any quotes as normal characters
            bParseQuotes = FALSE;
        }
        ++lpstrEnd;
    }

    if (bInQuotes)
        return MCIERR_NO_CLOSING_QUOTE;

// Fail if the token was not found and bMustFind is TRUE
    if (*lpstrEnd != cSeparater && bMustFind)
        return 0;

// Length of new string (INCLUDES QUOTES NOT COPIED)
    wLen = lpstrEnd - *lplpstrInput + 1;

    if ((*lplpstrOutput = mciAlloc (wLen)) == NULL)
        return MCIERR_OUT_OF_MEMORY;

// Copy into allocated space
    lpstrCounter = *lplpstrInput;
    lpstrOutput = *lplpstrOutput;
    bInQuotes = FALSE;

    while (lpstrCounter != lpstrEnd)
    {
        if (*lpstrCounter == '"' && bParseQuotes)
        {
            if (bInQuotes)
            {
// If this is a doubled quote
                if (*(lpstrCounter + 1) == '"')
// Copy it
                    *lpstrOutput++ = *lpstrCounter++;
                else
                    bInQuotes = FALSE;
            } else
                bInQuotes = TRUE;
// Skip the quote
            ++lpstrCounter;
        } else
            *lpstrOutput++ = *lpstrCounter++;
    }

    *lpstrOutput = '\0';
    if (*lpstrEnd == '\0')
        *lplpstrInput = lpstrEnd;
    else
        *lplpstrInput = lpstrEnd + 1;

    return 0;
}

// Take the type number from the open parameters and return
// it as a string in lplpstrType which must be free'd with mciFree
// Returns 0 or an MCI error code
UINT PASCAL NEAR mciExtractTypeFromID (
LPMCI_OPEN_PARMS lpOpen)
{
    int nSize;
    LPSTR lpstrType;

    if ((lpstrType = mciAlloc (MCI_MAX_DEVICE_TYPE_LENGTH)) == NULL)
        return MCIERR_OUT_OF_MEMORY;

// Load the type string corresponding to the ID
    if ((nSize = LoadString (ghInst,
                                LOWORD ((DWORD)lpOpen->lpstrDeviceType),
                                lpstrType, MCI_MAX_DEVICE_TYPE_LENGTH)) == 0)
        return MCIERR_EXTENSION_NOT_FOUND;

// Add ordinal (if any) onto the end of the device type name
    if (HIWORD (lpOpen->lpstrDeviceType) != 0)
    {
        if (nSize > MCI_MAX_DEVICE_TYPE_LENGTH - 11)
        {
            DOUT ("mciExtractTypeFromID:  type + ordinal too long\r\n");
            return MCIERR_DEVICE_ORD_LENGTH;
        }

        wsprintf (lpstrType + nSize, szUnsignedFormat,
                    HIWORD ((DWORD)lpOpen->lpstrDeviceType));
    }
    lpOpen->lpstrDeviceType = lpstrType;
    return 0;
}

/*
 * @doc INTERNAL MCI
 * @func UINT | mciOpenDevice | Open an MCI device for access.
 * Used in processing the MCI_OPEN message.
 *
 * @parm DWORD | dwFlags | Open Flags
 * @parm LPMCI_OPEN_PARMS | lpOpen | Description of device
 *
 * @rdesc 0 if successful or an error code
 * @flag MCIERR_INVALID_DEVICE_NAME | Name not known
 * @flag MCIERR_DEVICE_OPEN | Device is already open and is not sharable
 *
 * @comm This function does the following:
 * 1) Check to see if device is already open.  If so, return an error
 *
 * 2) Locate the device name in the SYSTEM.INI file and load
 *    the corresponding device driver DLL
 *
 * 3) Allocate and initialize a new device description block
 *
 */
UINT NEAR PASCAL mciOpenDevice (
DWORD dwStartingFlags,
LPMCI_OPEN_PARMS lpOpen,
LPMCI_INTERNAL_OPEN_INFO lpOpenInfo)
{
    LPSTR               lpstrNewType = NULL;
    UINT                wID, wReturn;
    LPCSTR              lpstrDeviceName;
    LPSTR               lpstrNewElement = NULL;
    BOOL                bFromTypeID = FALSE;
    LPCSTR               lpstrOriginalType;
    LPCSTR               lpstrOriginalElement;
    LPCSTR               lpstrOriginalAlias;
    DWORD               dwFlags = dwStartingFlags;
    BOOL                bDefaultAlias = FALSE;

// Initialize
    if (lpOpen == NULL)
        return MCIERR_NULL_PARAMETER_BLOCK;
    lpstrOriginalType = lpOpen->lpstrDeviceType;
    lpstrOriginalElement = lpOpen->lpstrElementName;
    lpstrOriginalAlias = lpOpen->lpstrAlias;

// The type number is given explicitly, convert it to a type name
    if (dwFlags & MCI_OPEN_TYPE_ID)
        if ((wReturn = mciExtractTypeFromID (lpOpen)) != 0)
            return wReturn;
        else
            bFromTypeID = TRUE;

// The device name is the device type of a simple device or the device
// element of a compound device

    if (dwFlags & MCI_OPEN_ELEMENT)
        lpstrDeviceName = lpstrOriginalElement;
    else if (dwFlags & MCI_OPEN_TYPE)
        lpstrDeviceName = lpOpen->lpstrDeviceType;
    else
        return MCIERR_MISSING_PARAMETER;

    if (lpstrDeviceName == NULL)
    {
        DOUT ("mciOpenDevice:  Device name is NULL\r\n");
        return MCIERR_INVALID_DEVICE_NAME;
    }

// Is the device already open?
    if (dwFlags & MCI_OPEN_ELEMENT_ID)
        wID = mciGetDeviceIDFromElementID ((DWORD)lpstrDeviceName,
                                           lpOpen->lpstrDeviceType);
    else
        wID = mciGetDeviceIDInternalEx ((dwFlags & MCI_OPEN_ALIAS ?
                                       lpOpen->lpstrAlias : lpstrDeviceName),
                                       lpOpenInfo->hCallingTask);

// If the device is open already then return an error
    if (wID != 0)
        return dwFlags & MCI_OPEN_ALIAS ? MCIERR_DUPLICATE_ALIAS :
                                          MCIERR_DEVICE_OPEN;

// The device is not already open in that task by the name

// If the type was derived then skip all this crap
    if (bFromTypeID)
        goto load_device;

// If an element name is given but no type name (only via mciSendCommand)
    if (dwFlags & MCI_OPEN_ELEMENT && !(dwFlags & MCI_OPEN_TYPE))
    {
        lpstrNewType = mciAlloc (MCI_MAX_DEVICE_TYPE_LENGTH);
        if (lpstrNewType == NULL)
            return MCIERR_OUT_OF_MEMORY;

// Try to get the device type from the element name via a file extension
        if (mciExtractDeviceType (lpstrOriginalElement,
                                    lpstrNewType, MCI_MAX_DEVICE_TYPE_LENGTH))
        {
            lpOpen->lpstrDeviceType = lpstrNewType;
            dwFlags |= MCI_OPEN_TYPE;
        } else
        {
            mciFree (lpstrNewType);
            return MCIERR_EXTENSION_NOT_FOUND;
        }
    } else if (dwFlags & MCI_OPEN_TYPE && !(dwFlags & MCI_OPEN_ELEMENT))
// A type name is given but no element
    {
// Try to extract a device type from the given device name via a file extension
        lpstrNewType = mciAlloc (MCI_MAX_DEVICE_TYPE_LENGTH);
        if (lpstrNewType == NULL)
            return MCIERR_OUT_OF_MEMORY;
        if (mciExtractDeviceType (lpOpen->lpstrDeviceType, lpstrNewType,
                                    MCI_MAX_DEVICE_TYPE_LENGTH))
        {
// Fix up the type and element names
            dwFlags |= MCI_OPEN_ELEMENT;
            lpOpen->lpstrElementName = lpOpen->lpstrDeviceType;
            lpOpen->lpstrDeviceType = lpstrNewType;
        } else
// Failed to extract type so...
// Try to get a compound element name ('!' separator)
        {
            LPCSTR lpstrTemp = lpOpen->lpstrDeviceType;

            mciFree (lpstrNewType);
            lpstrNewType = NULL;

            if ((wReturn = mciEatToken (&lpstrTemp, '!', &lpstrNewType, TRUE))
                != 0)
                goto cleanup;
            else if (lpstrNewType != NULL)
            {
                if ((wReturn = mciEatToken (&lpstrTemp, '\0',
                                            &lpstrNewElement, TRUE))
                    != 0)
                    goto cleanup;
                else if (lpstrNewElement != NULL &&
                           *lpstrNewElement != '\0')
                {
// See if this element name is in use
                    if (!(dwFlags & MCI_OPEN_ALIAS))
                        if (mciGetDeviceIDInternalEx (lpstrNewElement,
                                                      lpOpenInfo->hCallingTask))
                        {
                            wReturn = MCIERR_DEVICE_OPEN;
                            goto cleanup;
                        }
// Swap type and element for new ones
                    lpOpen->lpstrElementName = lpstrNewElement;
                    lpOpen->lpstrDeviceType = lpstrNewType;
                    dwFlags |= MCI_OPEN_ELEMENT;
                }
            }
        }
    } else
        lpstrNewType = NULL;

// Tack on a default alias if none is given
    if (! (dwFlags & MCI_OPEN_ALIAS))
    {
        LPCSTR lpstrAlias;

// If an element name exists then the alias is the element name
        if (dwFlags & MCI_OPEN_ELEMENT)
        {
// If a device ID was specified then there is no alias
            if (dwFlags & MCI_OPEN_ELEMENT_ID)
                lpstrAlias = NULL;
            else
                lpstrAlias = lpOpen->lpstrElementName;
// Otherwise the alias is the device type
        } else
            lpstrAlias = lpOpen->lpstrDeviceType;

        if (lpstrAlias != NULL)
        {
            lpOpen->lpstrAlias = lpstrAlias;
            dwFlags |= MCI_OPEN_ALIAS;
            bDefaultAlias = TRUE;
        }
    }

load_device:;
    wReturn = mciLoadDevice (dwFlags, lpOpen, lpOpenInfo, bDefaultAlias);

cleanup:
    if (lpstrNewElement != NULL)
        mciFree (lpstrNewElement);
    if (lpstrNewType != NULL)
        mciFree (lpstrNewType);
    if (bFromTypeID)
        mciFree ((LPSTR)lpOpen->lpstrDeviceType);

// Replace original items
    lpOpen->lpstrDeviceType = lpstrOriginalType;
    lpOpen->lpstrElementName = lpstrOriginalElement;
    lpOpen->lpstrAlias = lpstrOriginalAlias;

    return wReturn;
}

STATICFN void PASCAL NEAR
mciFreeDevice(
    LPMCI_DEVICE_NODE nodeWorking
    )
{
    UINT wID = nodeWorking->wDeviceID;

    mciMessage(THUNK_MCI_FREE_NODE, (DWORD) nodeWorking->wDeviceID, 0L, 0L, 0L);

    if (nodeWorking->lpstrName != NULL)
        mciFree (nodeWorking->lpstrName);

    if (nodeWorking->lpstrInstallName != NULL)
        mciFree (nodeWorking->lpstrInstallName);

    mciFree(MCI_lpDeviceList[wID]);
    MCI_lpDeviceList[wID] = NULL;

/* If this was the last device in the list, decrement next ID value */
    if (wID + 1 == MCI_wNextDeviceID) {
        --MCI_wNextDeviceID;
    }
}

/*
 * @doc INTERNAL MCI
 * @func UINT | mciCloseDevice | Close an MCI device.  Used in
 * processing the MCI_CLOSE message.
 *
 * @parm UINT | wID | The ID of the device to close
 * @parm DWORD | dwFlags | Close Flags
 * @parm LPMCI_GENERIC_PARMS | lpClose | Generic parameters
 * @parm BOOL | bCloseDriver | TRUE if the CLOSE command should be sent
 * on to the driver.
 *
 * @rdesc 0 if successful or an error code
 *
 * @comm This function sends an MCI_CLOSE_DRIVER message to the corresponding
 * driver if the use count is zero and then unloads the driver DLL
 *
 */
UINT NEAR PASCAL mciCloseDevice (
UINT wID,
DWORD dwFlags,
LPMCI_GENERIC_PARMS lpGeneric,
BOOL bCloseDriver)
{
    LPMCI_DEVICE_NODE nodeWorking;
    UINT wErr, wTable;

    nodeWorking = MCI_lpDeviceList[wID];

    if (nodeWorking == NULL)
    {
        DOUT ("mciCloseDevice:  NULL node from device ID--error if not auto-close\r\n");
        return 0;
    }

// If a close is in progress (usually this message comes from a Yield
// after a mciDriverNotify actuated by the active close) then exit
    if (nodeWorking->dwMCIFlags & MCINODE_ISCLOSING)
        return 0;

    nodeWorking->dwMCIFlags |= MCINODE_ISCLOSING;
    if (bCloseDriver)
    {
        MCI_GENERIC_PARMS   GenericParms;
// Make fake generic params if close came internally
        if (lpGeneric == NULL)
            lpGeneric = &GenericParms;

        wErr = LOWORD(mciSendCommand (wID, MCI_CLOSE_DRIVER, dwFlags,
                                            (DWORD)lpGeneric));
    }
    else
        wErr = 0;

// Must zero this to allow the table to be freed by the driver
    nodeWorking->wCustomCommandTable = 0;

    wTable = nodeWorking->wCommandTable;
// Must zero this to allow the table to be freed
    nodeWorking->wCommandTable = 0;
    mciFreeCommandResource (wTable);

    CloseDriver (nodeWorking->hDrvDriver, 0L, 0L);

    mciFreeDevice (nodeWorking);

    return wErr;
}

/*
 * @doc INTERNAL MCI DDK
 * @api DWORD | mciGetDriverData | Returns a pointer to the instance
 * data associated with an MCI device
 *
 * @parm UINT | wDeviceID | The MCI device ID
 *
 * @rdesc The driver instance data.  On error, returns 0 but since
 * the driver data might be zero, this cannot be verified by the caller
 * unless the instance data is known to be non-zero (e.g. a pointer)
 *
 */
DWORD WINAPI mciGetDriverData (
UINT wDeviceID)
{
    if (!MCI_VALID_DEVICE_ID(wDeviceID))
    {
        DOUT ("mciGetDriverData:  invalid device ID\r\n");
        return 0;
    }
    return MCI_lpDeviceList[wDeviceID]->lpDriverData;
}

/*
 * @doc INTERNAL MCI DDK
 * @func BOOL | mciSetDriverData | Sets the instance
 * data associated with an MCI device
 *
 * @parm UINT | wDeviceID | The MCI device ID
 *
 * @parm DWORD | dwData | Driver data to set
 *
 * @rdesc FALSE if the device ID is not known or there is insufficient
 * memory to load the device description, else TRUE.
 *
 */
BOOL WINAPI mciSetDriverData (
UINT wDeviceID,
DWORD dwData)
{
    if (!MCI_VALID_DEVICE_ID(wDeviceID))
    {
        DOUT ("mciSetDriverData:  invalid device ID\r\n");
        return FALSE;
    }
    MCI_lpDeviceList[wDeviceID]->lpDriverData = dwData;
    return TRUE;
}

/*
 * @doc INTERNAL MCI DDK
 * @api UINT | mciDriverYield | Used in a driver's idle loop
 * to yield to Windows
 *
 * @parm UINT | wDeviceID | Device ID that is yielding.
 *
 * @rdesc Non-zero if the driver should abort the operation.
 *
 */
UINT WINAPI mciDriverYield (
UINT wDeviceID)
{
    if (MCI_VALID_DEVICE_ID(wDeviceID))
    {
        LPMCI_DEVICE_NODE node = MCI_lpDeviceList[wDeviceID];

        if (node->fpYieldProc != NULL)
            return (node->fpYieldProc)(wDeviceID, node->dwYieldData);
    }

    Yield();
    return 0;
}

/*
 * @doc EXTERNAL MCI
 * @api BOOL | mciSetYieldProc | This function sets the address
 * of a callback procedure to be called periodically when an MCI device
 * is completing a command specified with the WAIT flag.
 *
 * @parm UINT | wDeviceID | Specifies the device ID of the MCI device to
 * which the yield procedure is to be assigned.
 *
 * @parm YIELDPROC | fpYieldProc | Specifies the callback procedure
 * to be called when the given device is yielding. Specify a NULL value
 * to disable any existing yield procedure.
 *
 * @parm DWORD | dwYieldData | Specifies the data sent to the yield procedure
 * when it is called for the given device.
 *
 * @rdesc Returns TRUE if successful. Returns FALSE for an invalid device ID.
 *
 * @cb int CALLBACK | YieldProc | <f YieldProc> is a placeholder for
 * the application-supplied function name. Export the actual name
 * by including it in the EXPORTS statement in your module-definition
 * file.
 *
 * @parm UINT | wDeviceID | Specifies the device ID of the MCI device.
 *
 * @parm DWORD | dwData | Specifies the application-supplied yield data
 * originally supplied in the <p dwYieldData> parameter.
 *
 * @rdesc Return zero to continue the operation. To cancel the operation,
 * return a nonzero value.
 *
 * @comm This call overrides any previous yield procedure for this device.
 *
 */
BOOL WINAPI mciSetYieldProc (
UINT wDeviceID,
YIELDPROC fpYieldProc,
DWORD dwYieldData)
{
    V_CALLBACK((FARPROC)fpYieldProc, FALSE);

    if (Is16bitDrv(wDeviceID)) {

        LPMCI_DEVICE_NODE node = MCI_lpDeviceList[wDeviceID];

        node->fpYieldProc = fpYieldProc;
        node->dwYieldData = dwYieldData;
        return TRUE;
    }

    return (BOOL)mciMessage( THUNK_MCI_SETYIELDPROC, (DWORD)wDeviceID,
                             (DWORD)fpYieldProc, dwYieldData, 0L );

}

/*
 * @doc EXTERNAL MCI
 * @api YIELDPROC | mciGetYieldProc | This function gets the address
 * of the callback procedure to be called periodically when an MCI device
 * is completing a command specified with the WAIT flag.
 *
 * @parm UINT | wDeviceID | Specifies the device ID of the MCI device to
 * which the yield procedure is to be retrieved from.
 *
 * @parm LPDWORD | lpdwYieldData | Optionally specifies a buffer to place
 * the yield data passed to the function in.  If the parameter is NULL, it
 * is ignored.
 *
 * @rdesc Returns the current yield proc if any, else returns NULL for an
 * invalid device ID.
 *
 */
YIELDPROC WINAPI mciGetYieldProc (
UINT wDeviceID,
LPDWORD lpdwYieldData)
{
    /*
    ** Is this a 16 bit device ID ?
    */
    if (Is16bitDrv(wDeviceID)) {

        if (lpdwYieldData != NULL) {
            V_WPOINTER(lpdwYieldData, sizeof(DWORD), NULL);
            *lpdwYieldData = MCI_lpDeviceList[wDeviceID]->dwYieldData;
        }
        return MCI_lpDeviceList[wDeviceID]->fpYieldProc;
    }

    /*
    ** No, so pass it on to the 32 bit code.
    */
    return (YIELDPROC)mciMessage( THUNK_MCI_GETYIELDPROC, (DWORD)wDeviceID,
                                  (DWORD)lpdwYieldData, 0L, 0L );
}

/*
 * @doc INTERNAL MCI
 * @api int | mciBreakKeyYieldProc | Procedure called to check a
 * key state for the given device
 *
 * @parm UINT | wDeviceID | Device ID which is yielding
 *
 * @parm DWORD | dwYieldData | Data for this device's yield proc
 *
 * @rdesc Non-zero if the driver should abort the operation. Currently
 * always returns 0.
 *
 */
int CALLBACK mciBreakKeyYieldProc (
UINT wDeviceID,
DWORD dwYieldData)
{
    HWND hwndCheck;
    int nState;

    hwndCheck = (HWND)HIWORD (dwYieldData);
    if (hwndCheck == NULL || hwndCheck == GetActiveWindow())
    {
        nState = GetAsyncKeyState (LOWORD(dwYieldData));

// Break if key is down or has been down
        if (nState & 1)
        {
            MSG msg;

            while (PeekMessage (&msg, hwndCheck, WM_KEYFIRST, WM_KEYLAST,
                   PM_REMOVE));
            return -1;
        }
    }
    Yield();
    return 0;
}

/*
 * @doc INTERNAL MCI
 * @func UINT | mciSetBreakKey | Set a key which will break a wait loop
 * for a given driver
 *
 * @parm UINT | wDeviceID | The device ID to assign a break key to
 *
 * @parm int | nVirtKey | Virtual key code to trap
 *
 * @parm HWND | hwndTrap | The handle to a window that must be active
 * for the key to be trapped.  If NULL then all windows will be checked
 *
 * @rdesc TRUE if successful, FALSE if invalid device ID
 *
 */
UINT PASCAL NEAR mciSetBreakKey (
UINT wDeviceID,
int nVirtKey,
HWND hwndTrap)
{
    return mciSetYieldProc (wDeviceID, mciBreakKeyYieldProc,
                         MAKELONG (nVirtKey, hwndTrap));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\mmsystem\mmiocf.h ===
/* mmiocf.h
 *
 * Multimedia File I/O Library.
 *
 * This include file contains declarations required for compound file support.
 */

#define	PC(hmmcf)	((PMMCF)(hmmcf))
#define	CP(pmmcf)	((HMMCF)(pmmcf))

typedef HLOCAL HMMCF;		// a handle to an open RIFF compound file

typedef struct _MMCFINFO	// structure for representing CTOC header info.
{
	DWORD		dwHeaderSize;	// size of CTOC header (w/o entries)
	DWORD		dwEntriesTotal;	// no. of entries in table of contents
	DWORD		dwEntriesDeleted; // no. of entries ref. to. del. ent.
	DWORD		dwEntriesUnused; // no. of entries that are not used
	DWORD		dwBytesTotal;	// total bytes of CGRP contents
	DWORD		dwBytesDeleted;	// total bytes of deleted CGRP elements
	DWORD		dwHeaderFlags;	// flags
	WORD		wEntrySize;	// size of each <CTOC-table-entry>
	WORD		wNameSize;	// size of each <achName> field
	WORD		wExHdrFields;	// number of "extra header fields"
	WORD		wExEntFields;	// number of "extra entry fields"
} MMCFINFO, FAR *LPMMCFINFO;

typedef struct _MMCTOCENTRY	// structure for representing CTOC entry info.
{
	DWORD		dwOffset;	// offset of element inside CGRP chunk
	DWORD		dwSize;		// size of element inside CGRP chunk
	DWORD		dwMedType;	// media element type of CF element
	DWORD		dwMedUsage;	// media element usage information
	DWORD		dwCompressTech;	// media element compression technique
	DWORD		dwUncompressBytes; // size after decompression
	DWORD		adwExEntField[1]; // extra CTOC table entry fields
} MMCTOCENTRY, FAR *LPMMCTOCENTRY;

/* <dwFlags> field of MMIOINFO structure -- many same as OpenFile() flags */
#define MMIO_CTOCFIRST	0x00020000	// mmioCFOpen(): put CTOC before CGRP

/* flags for other functions */
#define MMIO_FINDFIRST		0x0010	// mmioCFFindEntry(): find first entry
#define MMIO_FINDNEXT		0x0020	// mmioCFFindEntry(): find next entry
#define MMIO_FINDUNUSED 	0x0040	// mmioCFFindEntry(): find unused entry
#define MMIO_FINDDELETED	0x0080	// mmioCFFindEntry(): find deleted entry

/* message numbers for MMIOPROC */
#define MMIOM_GETCF		10	// get HMMCF of CF element
#define MMIOM_GETCFENTRY	11	// get ptr. to CTOC table entry

/* four character codes used to identify standard built-in I/O procedures */
#define FOURCC_BND	mmioFOURCC('B', 'N', 'D', ' ')

/* <dwHeaderFlags> field of MMCFINFO structure */
#define CTOC_HF_SEQUENTIAL	0x00000001 // CF elements in same order as CTOC
#define CTOC_HF_MEDSUBTYPE	0x00000002 // <dwMedUsage> is a med. el. subtype

/* CTOC table entry flags */
#define CTOC_EF_DELETED		0x01	// CF element is deleted
#define CTOC_EF_UNUSED		0x02	// CTOC entry is unused

/* CF I/O prototypes */
HMMCF API mmioCFOpen(LPSTR szFileName, DWORD dwFlags);
HMMCF API mmioCFAccess(HMMIO hmmio, LPMMCFINFO lpmmcfinfo,
	DWORD dwFlags);
WORD API mmioCFClose(HMMCF hmmcf, WORD wFlags);
DWORD API mmioCFGetInfo(HMMCF hmmcf, LPMMCFINFO lpmmcfinfo, DWORD cb);
DWORD API mmioCFSetInfo(HMMCF hmmcf, LPMMCFINFO lpmmcfinfo, DWORD cb);
LPMMCTOCENTRY API mmioCFFindEntry(HMMCF hmmcf, LPSTR szName,
	WORD wFlags, LPARAM lParam);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\mmsystem\mmio.c ===
/* mmio.c
 *
 * Basic MMIO functions.
 *
 * Implementation notes:
 *
 * The "current disk offset" is the disk offset (i.e. the location
 * in the disk file) that the next MMIOM_READ or MMIOM_WRITE will
 * read from or write to.  The I/O procedure maintains the
 * <lDiskOffset> field of the file's MMIO structure so that
 * <lDiskOffset> is equal to the current disk offset.
 *
 * The "current buffered offset" is the disk offset that the next
 * mmioRead() or mmioWrite() call would read from or write to.
 * The current buffered offset is defined as
 *
 *	<lBufOffset> + (<pchNext> - <pchBuffer>)
 *
 * since <lBufOffset> is the disk offset of the start of the buffer
 * and <pchNext> corresponds to the current buffered offset.
 *
 * If the file is unbuffered, then <pchBuffer>, <pchNext>,
 * <pchEndRead> and <pchEndWrite> will always be NULL, and
 * <lBufOffset> will always be considered the "current buffered
 * offset", i.e. mmioRead() and mmioWrite() will read/write
 * at this offset.
 *
 *
 * Except right at the beginning of mmioOpen(), the MMIO_ALLOCBUF
 * flag is set if and only if the pchBuffer field points to a block
 * of global memory that MMIO has allocated.
 */

#include <windows.h>
#include "mmsystem.h"
#include "mmioi.h"
#include "mmsysi.h"

/* The I/O procedure map is a linked list of IOProcMPEntry structures.
 * The head of the list, <gIOProcMapHead> is a pointer node to the last
 * entry registered.  The first few elements of the list are the predefined
 * global IO procedures below -- these all have <hTask> equal to NULL so
 * that no task can unregister them.
 */
static LRESULT CALLBACK mmioDOSIOProc(LPSTR, UINT, LPARAM, LPARAM);
static LRESULT CALLBACK mmioMEMIOProc(LPSTR, UINT, LPARAM, LPARAM);

static IOProcMapEntry gIOProcMaps[] = {
	FOURCC_DOS, mmioDOSIOProc, NULL, STATICIOPROC, &gIOProcMaps[1],
	FOURCC_MEM, mmioMEMIOProc, NULL, STATICIOPROC, NULL,
};
IOProcMapEntry NEAR * gIOProcMapHead = gIOProcMaps;

/* private prototypes */
static LONG NEAR PASCAL mmioDiskIO(PMMIO pmmio, UINT wMsg, HPSTR pch, LONG cch);
static UINT NEAR PASCAL mmioExpandMemFile(PMMIO pmmio, LONG lExpand);

/* @doc INTERNAL

@func	LPMMIOPROC | FindIOProc | This function locates previously installed
	IO procedure.
*/
static LPMMIOPROC PASCAL NEAR
FindIOProc(FOURCC fccIOProc, HTASK htask)
{
	IOProcMapEntry *pEnt;		// an entry in linked list

	/* walk through the linked list, first looking for an entry with
	 * identifier <fccIOProc> that was added by the current task, then
	 * looking for global entries.
	 */

	for (pEnt = gIOProcMapHead; pEnt; pEnt = pEnt->pNext)
		if ((pEnt->fccIOProc == fccIOProc) && (pEnt->hTask == htask))
			return pEnt->pIOProc;

	for (pEnt = gIOProcMapHead; pEnt; pEnt = pEnt->pNext)
		if (!pEnt->hTask && (pEnt->fccIOProc == fccIOProc))
			return pEnt->pIOProc;

	return NULL;
}

/* @doc INTERNAL

@func	LPMMIOPROC | RemoveIOProc | This function removes previously installed
	IO procedure.
*/
static LPMMIOPROC PASCAL NEAR
RemoveIOProc(FOURCC fccIOProc, HTASK htask)
{
	IOProcMapEntry *pEnt;		// an entry in linked list
	IOProcMapEntry *pEntPrev;	// the entry before <pEnt>

	/* walk through the linked list, looking for an entry with
	 * identifier <fccIOProc> that was added by the current task
	 */
	for (pEntPrev = NULL, pEnt = gIOProcMapHead; pEnt; pEntPrev = pEnt, pEnt = pEnt->pNext)
		if ((pEnt->fccIOProc == fccIOProc) && (pEnt->hTask == htask)) {
			LPMMIOPROC	pIOProc;

			if (pEnt->wFlags & STATICIOPROC)
				return NULL;
			pIOProc = pEnt->pIOProc;
			if (pEntPrev)
				pEntPrev->pNext = pEnt->pNext;
			else
				gIOProcMapHead = pEnt->pNext;
			FreeHandle((HMMIO) pEnt);
			return pIOProc;
		}
	return NULL;
}

/* @doc INTERNAL

@func	void | SetIOProc | This function sets the physical IO procedure
	based on either the file name or the parameters within the
	<p lpmmioinfo> structure passed.

@parm	LPCSTR | szFilename | Specifies a far pointer to a string
containing the filename of the file to open. If no I/O procedure is

@parm	LPMMIOINFO | lpmmioinfo | Specifies a far pointer to an
	<t MMIOINFO> structure containing extra parameters used by
	<f SetIOProc> in determining the IO procedure to use.  The
	<e MMIOINFO.pIOProc> element is set to the procedure found.

@rdesc	Nothing.
*/

static void NEAR PASCAL
SetIOProc(LPCSTR szFileName, LPMMIOINFO lpmmio)
{
	/* If the IOProc is not given, see if the file name implies that
	 * <szFileName> is either a RIFF compound file or some kind of
	 * other registered storage system -- look for the last CFSEPCHAR in
	 * the name, e.g. '+' in "foo.bnd+bar.hlp+blorg.dib", and figure
	 * that the IOProc ID is the extension of the compound file name,
	 * e.g. the extension of "foo.bnd+bar.hlp", i.e. 'HLP '.
	 *
	 * Alternatively, if <szFileName> is NULL, then assume that
	 * <lpmmio->adwInfo[0]> is a DOS file handle.
	*/
	if (lpmmio->pIOProc == NULL)
	{
		if (lpmmio->fccIOProc == NULL)
		{
			if (szFileName != NULL)
			{
				LPSTR	pch;

				/* see if <szFileName> contains CFSEPCHAR */
				if ((pch = fstrrchr(szFileName, CFSEPCHAR)) != NULL)
				{
					/* find the extension that precedes CFSEPCHAR,
					 * e.g. "hlp" in "foo.bnd+bar.hlp+blorg.dib"
					*/
					while ((pch > szFileName) && (*pch != '.') && (*pch != ':') && (*pch != '\\'))
						pch--;
					if (*pch == '.')
					{
						char	aszFour[sizeof(FOURCC)+1];
						int	i;

						for (i = 0, pch++; i < sizeof(FOURCC); i++)
							if (*pch == CFSEPCHAR)
								aszFour[i] = (char)0;
							else
								aszFour[i] = *pch++;
						aszFour[sizeof(FOURCC)] = (char)0;
						lpmmio->fccIOProc = mmioStringToFOURCC(aszFour, MMIO_TOUPPER);
					}
				}
			}
			/* if the caller didn't specify an IOProc, and the code above
			 * didn't determine an IOProc ID, then the default is the DOS
			 * IOProc.
			*/
			if (lpmmio->fccIOProc == NULL)
				lpmmio->fccIOProc = FOURCC_DOS;
		}

		/* unless an IOProc address is specified explicitly, look up the
		 * IOProc in the global IOProc ID-to-address table -- the default
		 * is 'DOS' since we'll assume that custom storage system I/O
		 * procedures would have been installed
		*/
		lpmmio->pIOProc = FindIOProc(lpmmio->fccIOProc, lpmmio->htask ? lpmmio->htask : GetCurrentTask());

		if (lpmmio->pIOProc == NULL)
			lpmmio->pIOProc = mmioDOSIOProc;
	}
}

/* @doc EXTERNAL

@api	UINT | mmioRename | This function renames the specified file.

@parm	LPCSTR | szFilename | Specifies a far pointer to a string
containing the filename of the file to rename.

@parm	LPCSTR | szNewFileName | Specifies a far pointer to a string
containing the new filename.

@parm	LPMMIOINFO | lpmmioinfo | Specifies a far pointer to an
	<t MMIOINFO> structure containing extra parameters used by
	<f mmioRename>.

	If <p lpmmioinfo> is not NULL, all unused fields of the
	<t MMIOINFO> structure it references must be set to zero, including the
	reserved fields.

@parm	DWORD | dwRenameFlags | Specifies option flags for the rename
	operation.  This should be set to zero.

@rdesc	The return value is zero if the file was renamed.  Otherwise, the
return value is an error code returned from <f mmioRename> or from the I/O
procedure.
*/
UINT WINAPI
mmioRename(LPCSTR szFileName, LPCSTR szNewFileName, LPMMIOINFO lpmmioinfo, DWORD dwRenameFlags)
{
	PMMIO	pmmio;
	UINT	uReturn;

	V_FLAGS(dwRenameFlags, 0, mmioRename, MMSYSERR_INVALFLAG);
	V_RPOINTER0(lpmmioinfo, sizeof(MMIOINFO), MMSYSERR_INVALPARAM);

	if ((pmmio = PH(NewHandle(TYPE_MMIO, sizeof(MMIOINFO)))) == NULL)
		return MMIOERR_OUTOFMEMORY;

	if (lpmmioinfo) {
		V_CALLBACK0((FARPROC)lpmmioinfo->pIOProc, MMSYSERR_INVALPARAM);
		*pmmio = *lpmmioinfo;
	}
		
	SetIOProc(szFileName, pmmio);
	uReturn = (UINT)(DWORD) (pmmio->pIOProc((LPSTR) pmmio, MMIOM_RENAME, (LPARAM) szFileName, (LPARAM) szNewFileName));
	FreeHandle((HLOCAL)pmmio);
	return uReturn;
}

/* @doc EXTERNAL

@api	HMMIO | mmioOpen | This function opens a file for unbuffered
	or buffered I/O. The file can be a DOS file, a memory file, or an
	element of a custom storage system.

@parm	LPSTR | szFilename | Specifies a far pointer to a string
containing the filename of the file to open. If no I/O procedure is
specified to open the file, then the filename determines how the file
is opened, as follows:

	-- If the filename does not contain "+", then it is assumed
	to be the name of a DOS file.

	-- If the filename is of the form "foo.ext+bar", then the
	extension "EXT " is assumed to identify an installed I/O procedure
	which is called to perform I/O on the file (see <f mmioInstallIOProc>).

	-- If the filename is NULL and no I/O procedure is given, then
	<e MMIOINFO.adwInfo[0]> is assumed to be the DOS file handle
	of a currently open file.

	The filename should not be longer than 128 bytes, including the
	terminating NULL.

	When opening a memory file, set <p szFilename> to NULL.

@parm	LPMMIOINFO | lpmmioinfo | Specifies a far pointer to an
	<t MMIOINFO> structure containing extra parameters used by
	<f mmioOpen>. Unless you are opening a memory file, specifying the
	size of a buffer for buffered I/O, or specifying an uninstalled I/O
	procedure to open a file, this parameter should be NULL.

	If <p lpmmioinfo> is not NULL, all unused fields of the
	<t MMIOINFO> structure it references must be set to zero, including the
	reserved fields.

@parm	DWORD | dwOpenFlags | Specifies option flags for the open
	operation. The MMIO_READ, MMIO_WRITE, and MMIO_READWRITE flags are
	mutually exclusive--only one should be specified. The MMIO_COMPAT,
	MMIO_EXCLUSIVE, MMIO_DENYWRITE, MMIO_DENYREAD, and MMIO_DENYNONE flags
	are DOS file-sharing flags, and can only be used after the DOS
	command SHARE has been executed.

	@flag	MMIO_READ | Opens the file for reading only.  This is the
		default, if MMIO_WRITE and MMIO_READWRITE are not specified.

	@flag	MMIO_WRITE | Opens the file for writing.  You should not
		read from a file opened in this mode.

	@flag	MMIO_READWRITE | Opens the file for both reading and writing.

	@flag	MMIO_CREATE | Creates a new file.
		If the file already exists, it is truncated to zero length.
		For memory files, MMIO_CREATE indicates the end of the file
		is initially at the start of the buffer.

	@flag	MMIO_DELETE | Deletes a file. If this flag is specified,
		<p szFilename> should not be NULL. The return
		value will be TRUE (cast to HMMIO) if the file was deleted
		successfully, FALSE otherwise.  Do not call <f mmioClose>
		for a file that has been deleted.  If this flag is specified,
		all other file opening flags are ignored.

	@flag	MMIO_PARSE | Creates a fully qualified filename from the path
        specified in <p szFileName>. The fully qualified filename is
        placed back into <p szFileName>. The return value
		will be TRUE (cast to HMMIO) if the qualification was
        successful, FALSE otherwise. The file is not opened, and the function
        does not return a valid MMIO file handle, so do not attempt to
        close the file. If this flag is specified, all other file
        opening flags are ignored.

	@flag	MMIO_EXIST | Determines whether the specified file exists
        and creates a fully qualified filename from the path
        specified in <p szFileName>. The fully qualified filename is
        placed back into <p szFileName>. The return value
		will be TRUE (cast to HMMIO) if the qualification was
        successful and the file exists, FALSE otherwise. The file is
        not opened, and the function does not return a valid MMIO file
        handle, so do not attempt to close the file.

	@flag	MMIO_ALLOCBUF | Opens a file for buffered I/O.
		To allocate a buffer larger or smaller than the default
		buffer size (8K), set the <e MMIOINFO.cchBuffer> field of the
		<t MMIOINFO> structure to the desired buffer size. If
		<e MMIOINFO.cchBuffer> is zero, then the default buffer size
		is used. If you are providing your own I/O buffer, then the
		MMIO_ALLOCBUF flag should not be used.
	
	@flag	MMIO_COMPAT | Opens the file with compatibility mode,
		allowing any process on a given machine to open the file
		any number of times.  <f mmioOpen> fails if the file has
		been opened with any of the other sharing modes.

	@flag	MMIO_EXCLUSIVE | Opens the file with exclusive mode,
		denying other processes both read and write access to the file.
		<f mmioOpen> fails if the file has been opened in any other
		mode for read or write access, even by the current process.
		
	@flag	MMIO_DENYWRITE | Opens the file and denies other
		processes write access to the file.  <f mmioOpen> fails
		if the file has been opened in compatibility or for write
		access by any other process.

	@flag	MMIO_DENYREAD | Opens the file and denies other
		processes read access to the file.  <f mmioOpen> fails if the
		file has been opened in compatibility mode or for read access
		by any other process.

	@flag	MMIO_DENYNONE | Opens the file without denying other
		processes read or write access to the file.  <f mmioOpen>
		fails if the file has been opened in compatibility mode
		by any other process.

	@flag	MMIO_GETTEMP | Creates a temporary filename, optionally
        using the parameters passed in <p szFileName> to determine
        the temporary name. For example, you can specify "C:F" to
        create a temporary file residing on drive C, starting with
        letter "F". The resulting filename is placed in the buffer
        pointed to by <p szFileName>.  The return value will be TRUE
        (cast to HMMIO) if the temporary filename was created successfully,
        FALSE otherwise. The file is
        not opened, and the function does not return a valid MMIO file
        handle, so do not attempt to close the file.
		This flag overrides all other flags.

@rdesc	The return value is a handle to the opened file. This handle
	is not a DOS file handle--do not use it with any file I/O functions
	other than MMIO functions.

	If the file cannot be opened, the return value is NULL.  If
	<p lpmmioinfo> is not NULL, then its <e MMIOINFO.wErrorRet> field
	will contain extended error information returned by the I/O
	procedure.

@comm	If <p lpmmioinfo> references an <t MMIOINFO> structure, set
up the fields as described below. All unused fields must be set to
zero, including reserved fields.

-- To request that a file be opened with an installed I/O
procedure, set the <e MMIOINFO.fccIOProc> field
to the four-character code of the I/O procedure,
and set the <e MMIOINFO.pIOProc> field to NULL.

-- To request that a file be opened with an uninstalled I/O procedure,
set the <e MMIOINFO.pIOProc> field to
point to the I/O procedure, and set <e MMIOINFO.fccIOProc> to NULL.

-- To request that <f mmioOpen> determine which I/O procedure to use
to open the file based on the filename contained in <p szFilename>,
set both <e MMIOINFO.fccIOProc> and <e MMIOINFO.pIOProc> to NULL.
This is the default behavior if no <t MMIOINFO> structure is specified.

-- To open a memory file using an internally allocated and managed
buffer, set the <e MMIOINFO.pchBuffer> field to NULL,
<e MMIOINFO.fccIOProc> to FOURCC_MEM,
<e MMIOINFO.cchBuffer> to the initial size of the buffer, and
<e MMIOINFO.adwInfo[0]> to the incremental expansion size of the
buffer. This memory file will automatically be expanded in increments of
<e MMIOINFO.adwInfo[0]> bytes when necessary. Specify the MMIO_CREATE
flag for the <p dwOpenFlags> parameter to initially set the end of
the file to be the beginning of the buffer.

-- To open a memory file using a caller-supplied buffer, set
the <e MMIOINFO.pchBuffer> field to point to the memory buffer,
<e MMIOINFO.fccIOProc> to FOURCC_MEM,
<e MMIOINFO.cchBuffer> to the size of the buffer, and
<e MMIOINFO.adwInfo[0]> to the incremental expansion size of the
buffer. The expansion size in <e MMIOINFO.adwInfo[0]> should only
be non-zero if <e MMIOINFO.pchBuffer> is a pointer obtained by calling
<f GlobalAlloc> and <f GlobalLock>, since <f GlobalReAlloc> will be called to
expand the buffer.  In particular, if <e MMIOINFO.pchBuffer> points to a
local or global array, a block of memory in the local heap, or a block
of memory allocated by <f GlobalDosAlloc>, <e MMIOINFO.adwInfo[0]> must
be zero.
Specify the MMIO_CREATE flag for the <p dwOpenFlags> parameter to
initially set the end of the file to be the beginning of the buffer;
otherwise, the entire block of memory will be considered readable.

-- To use a currently open DOS file handle with MMIO, set the
<e MMIOINFO.fccIOProc> field to FOURCC_DOS,
<e MMIOINFO.pchBuffer> to NULL, and <e MMIOINFO.adwInfo[0]> to the
DOS file handle.  Note that offsets within the file will be relative to
the beginning of the file, and will not depend on the DOS file position
at the time <f mmioOpen> is called; the initial MMIO offset will be the same
as the DOS offset when <f mmioOpen> is called.
Later, to close the MMIO file handle without closing the DOS
file handle, pass the MMIO_FHOPEN flag to <f mmioClose>.

You must call <f mmioClose> to close a file opened with <f mmioOpen>.
Open files are not automatically closed when an application exits.

@xref	mmioClose
*/

/* these are the changes to mmioOpen() to support compound files... */

/* @doc CFDOC

@api	HMMIO | mmioOpen | ...The file can be a DOS file, a memory file,
	an element of a RIFF compound file...

@parm	LPSTR | szFilename | ...

	-- If <p szFilename> is of the form "foo+bar", then <f mmioOpen>
	opens the compound file element named "bar" that is stored inside
	the RIFF compound file named "foo".

	-- If <p szFilename> is of the form "foo.ext+bar", then the
	extension "ext" is assumed to identify the installed I/O procedure
	(see <f mmioInstallIOProc>).  The extension "bnd", and any extensions
	that have not been installed, are assumed to refer to a RIFF compound
	file.

@parm	LPMMIOINFO | lpmmioinfo | ...

@parm	DWORD | dwOpenFlags | ...

@rdesc	...

@comm	...

	The following I/O procedure identifiers (type FOURCC) are predefined:

	...

	FOURCC_BND: <p szFilename> is assumed to be the name of
	a RIFF compound file element, and <p adwInfo[0]> should
	contain the HMMCF of the compound file.  Alternatively,
	<p szFilename> can include the name of the compound file
	(e.g. "foo.bnd+bar.dib" as described above), and <p adwInfo[0]>
	should be NULL, to automatically open the compound file.

	...

	The easy way to open an element of a RIFF compound file: just
	include the name of the compound file in <p szFilename> preceded
	by a "+" as described above.  For example, opening
	"c:\data\bar.bnd+blorg.dib" opens the compound file element
	named "blorg.dib" in the compound file "c:\data\bar.bnd".
	<p lpmmioinfo> can be null in this case -- set <p dwOpenFlags>
	as described above.  You can use this same method to open an
	element of a custom storage system, if the file extension of the
	compound file ("bnd" in the above example) corresponds to an
	installed I/O procedure -- see <f mmioInstallIOProc> for details.

	To open an element of a RIFF compound file that was opened using
	<f mmioCFAccess> or <f mmioCFOpen>: set <p szFilename>
	to be the name of the compound file element; set <p fccIOProc>
	to FOURCC_BND; set <p adwInfo[0]> to the HMMCF of the open compound
	file; set <p dwOpenFlags> and <p cchBuffer> as described above;
	set all other fields of <p lpmmioinfo> to zero.

	...
*/
HMMIO WINAPI
mmioOpen(LPSTR szFileName, LPMMIOINFO lpmmioinfo, DWORD dwOpenFlags)
{
	PMMIO		pmmio;		// MMIO status block
	HPSTR		hpBuffer;
	UINT		w;

        V_FLAGS(dwOpenFlags, MMIO_OPEN_VALID, mmioOpen, NULL);
	V_WPOINTER0(lpmmioinfo, sizeof(MMIOINFO), NULL);

	if (lpmmioinfo) {
		lpmmioinfo->wErrorRet = 0;
		V_CALLBACK0((FARPROC)lpmmioinfo->pIOProc, NULL);
	}

	/* allocate MMIO status information block */
	if ((pmmio = PH(NewHandle(TYPE_MMIO, sizeof(MMIOINFO)))) == NULL)
	{
		if (lpmmioinfo)
			lpmmioinfo->wErrorRet = MMIOERR_OUTOFMEMORY;
		return NULL;
	}

	/* if user supplied <lpmmioinfo>, copy it to <pmmio> */
        if (lpmmioinfo != NULL)
		*pmmio = *lpmmioinfo;
	
	/* <dwOpenFlags> always takes precedence over contents of <pmmio> */
	pmmio->dwFlags = dwOpenFlags;
	pmmio->hmmio = HP(pmmio);

	/* MMIO_ALLOCBUF in the flags means that the user wants a buffer
	 * allocated for buffered I/O, but after this point it means that
	 * a buffer *was* allocated, so turn off the flag until the buffer
	 * is actually allocated (which is done by mmioSetBuffer() below)
	 */
	if (pmmio->dwFlags & MMIO_ALLOCBUF)
	{
		/* if a buffer size is not specified, use the default */
		if (pmmio->cchBuffer == 0)
			pmmio->cchBuffer = MMIO_DEFAULTBUFFER;
		pmmio->dwFlags &= ~MMIO_ALLOCBUF;
	}
	
	/* Set the pIOProc function as determined by the file name or the
	 * parameters in the pmmio structure.
	*/
	SetIOProc(szFileName, pmmio);

	/* The pmmio structure hasn't been set up for buffering, so we must
	 * explicitly make sure that pchBuffer is NULL.
	 */
	hpBuffer = pmmio->pchBuffer;
	pmmio->pchBuffer = NULL;
	
	/* set up buffered I/O however the user requested it */
	if (w = mmioSetBuffer(HP(pmmio), hpBuffer, pmmio->cchBuffer, 0))
	{
		if (lpmmioinfo)
			lpmmioinfo->wErrorRet = w;
		FreeHandle(HP(pmmio));
		return NULL;
	}

	/* let the I/O procedure open/delete/qualify the file */
	w = (UINT)(DWORD) (pmmio->pIOProc((LPSTR) pmmio, MMIOM_OPEN, (LPARAM) szFileName, (LPARAM) 0));

	/* If this is non-zero, return it to the user */
	if (w != 0)
	{
		if (lpmmioinfo != NULL)
			lpmmioinfo->wErrorRet = w;
		FreeHandle(HP(pmmio));
		return NULL;
        }
	
	if (pmmio->dwFlags & (MMIO_DELETE | MMIO_PARSE | MMIO_EXIST | MMIO_GETTEMP))
	{
		/* if the file is being deleted/parsed/name gotten, exit
		 * QUICKLY because the file handle (or whatever) in <pmmio>
		 * is not valid.
		 */
		mmioSetBuffer(HP(pmmio), NULL, 0L, 0);
                FreeHandle(HP(pmmio));
		return (HMMIO) TRUE;
	}
	
	/* the initial "current buffered offset" will be equal to the initial
	 * "current disk offset"
	 */
	pmmio->lBufOffset = pmmio->lDiskOffset;
	
	return HP(pmmio);
}


/* @doc EXTERNAL

@api	UINT | mmioClose | This function closes a file opened with
	<f mmioOpen>.

@parm	HMMIO | hmmio | Specifies the file handle of the file to
	close.

@parm	UINT | wFlags | Specifies options for the close operation.

	@flag	MMIO_FHOPEN | If the file was opened by passing the DOS
		file handle of an already-opened file to <f mmioOpen>, then
		using this flag tells <f mmioClose> to close the MMIO file
		handle, but not the DOS file handle.

@rdesc	The return value is zero if the function is successful.
	Otherwise, the return value is an error code, either from
	<f mmioFlush> or from the I/O procedure. The error code can be
	one of the following codes:

	@flag MMIOERR_CANNOTWRITE | The contents of the buffer could
	not be written to disk.
	
@xref	mmioOpen mmioFlush
*/
UINT WINAPI
mmioClose(HMMIO hmmio, UINT wFlags)
{
	UINT		w;

	V_HANDLE(hmmio, TYPE_MMIO, MMSYSERR_INVALHANDLE);
	
	if (mmioFlush(hmmio, 0) != 0) {
		DebugErr(DBF_WARNING, "MMIO File flush failed during close.\r\n");
		PH(hmmio)->dwFlags &= ~MMIO_DIRTY;
	}

	if ((w = (UINT)(DWORD) PH(hmmio)->pIOProc((LPSTR)PH(hmmio), MMIOM_CLOSE, (LPARAM)(DWORD) wFlags, (LPARAM) 0)) != 0)
		return w;

	/* free the buffer if necessary */
	mmioSetBuffer(hmmio, NULL, 0L, 0);
	
        FreeHandle(hmmio);
	
	return 0;
}


/* @doc EXTERNAL

@api	LONG | mmioRead | This function reads a specified number of
	bytes from a file opened with <f mmioOpen>.

@parm	HMMIO | hmmio | Specifies the file handle of the file to be
	read.

@parm	HPSTR | pch | Specifies a huge pointer to a buffer to contain
	the data read from the file.

@parm	LONG | cch | Specifies the number of bytes to read from the
	file.

@rdesc	The return value is the number of bytes actually read. If the
	end of the file has been reached and no more bytes can be read, the
	return value is zero. If there is an error reading from the file, the
	return value is -1.

@xref	mmioWrite
*/
LONG WINAPI
mmioRead(HMMIO hmmio, HPSTR pch, LONG cch)
{
	LONG		lTotalBytesRead = 0L;	// total no. bytes read
	LONG		lBytes;			// no. bytes that can be read

	V_HANDLE(hmmio, TYPE_MMIO, -1);
	V_WPOINTER(pch, cch, -1);
	
	while (TRUE)
	{
		/* calculate the number of bytes that can be read */
		lBytes = PH(hmmio)->pchEndRead - PH(hmmio)->pchNext;

		/* can only read at most <cch> bytes from buffer */
		if (lBytes > cch)
			lBytes = cch;

		if (lBytes > 0)
		{
			/* this is where some performance improvements can
			 * be made, especially for small reads... should
			 * special-case cases when segment boundaries are
                         * not crossed (or maybe MemCopy() should do that)
			 */
                        MemCopy(pch, PH(hmmio)->pchNext, lBytes);
			PH(hmmio)->pchNext += lBytes;
			pch += lBytes;
			cch -= lBytes;
			lTotalBytesRead += lBytes;
		}

		/* cannot do MMIOM_READ from memory files */
		if (PH(hmmio)->fccIOProc == FOURCC_MEM)
			return lTotalBytesRead;

		if (cch == 0)			// no more to read?
			return lTotalBytesRead;

		/* we need to read beyond this buffer; if we have at least
		 * another bufferful to read, just call the I/O procedure
		 */
		if (cch > PH(hmmio)->cchBuffer)
			break;

		/* read the next bufferful and loop around */
		if (mmioAdvance(hmmio, NULL, MMIO_READ) != 0)
			return -1;
		
		/* if mmioAdvance() couldn't read any more data, we must be
		 * at the end of the file
		 */
		if (PH(hmmio)->pchNext == PH(hmmio)->pchEndRead)
			return lTotalBytesRead;
	}
	
	/* flush and empty the I/O buffer and manipulate <lBufOffset>
	 * directly to change the current file position
	 */
	if (mmioFlush(hmmio, MMIO_EMPTYBUF) != 0)
		return -1;

	/* call the I/O procedure to do the rest of the reading */
	lBytes = mmioDiskIO(PH(hmmio), MMIOM_READ, pch, cch);
	PH(hmmio)->lBufOffset = PH(hmmio)->lDiskOffset;

	return (lBytes == -1L) ? -1L : lTotalBytesRead + lBytes;
}


/* @doc EXTERNAL

@api	LONG | mmioWrite | This function writes a specified number of
	bytes to a file opened with <f mmioOpen>.

@parm	HMMIO | hmmio | Specifies the file handle of the file.

@parm	char _huge* | pch | Specifies a huge pointer to the buffer to be
	written to the file.

@parm	LONG | cch | Specifies the number of bytes to write to the
	file.

@rdesc	The return value is the number of bytes actually written. If
	there is an error writing to the file, the return value is -1.

@comm	The current file position is incremented by the number of
	bytes written.

@xref	mmioRead
*/
LONG WINAPI
mmioWrite(HMMIO hmmio, const char _huge* pch, LONG cch)
{
	LONG		lTotalBytesWritten = 0L; // total no. bytes written
	LONG		lBytes;			// no. bytes that can be written

	V_HANDLE(hmmio, TYPE_MMIO, -1);
	V_RPOINTER(pch, cch, -1);
	
	while (TRUE)
	{
		/* calculate the number of bytes that can be written */
		lBytes = PH(hmmio)->pchEndWrite - PH(hmmio)->pchNext;

		if ((cch > lBytes) && (PH(hmmio)->fccIOProc == FOURCC_MEM))
		{
			/* this is a memory file -- expand it */
			if (mmioExpandMemFile(PH(hmmio), cch - lBytes) != 0)
				return -1;	// cannot expand
			lBytes = PH(hmmio)->pchEndWrite - PH(hmmio)->pchNext;
		}

		/* can only write at most <cch> bytes into the buffer */
		if (lBytes > cch)
			lBytes = cch;
		
		/* this is where some performance improvements can
		 * be made, especially for small writes... should
		 * special-case cases when segment boundaries are
                 * not crossed (or maybe MemCopy() should do that)
		 */
		if (lBytes > 0)
		{
                        MemCopy(PH(hmmio)->pchNext, pch, lBytes);
			PH(hmmio)->dwFlags |= MMIO_DIRTY;
			PH(hmmio)->pchNext += lBytes;
			pch += lBytes;
			cch -= lBytes;
			lTotalBytesWritten += lBytes;
		}

		/* validate <pchEndRead>, i.e. re-enforce the invariant that
		 * <pchEndRead> points past the last valid byte in the buffer
		 */
		if (PH(hmmio)->pchEndRead < PH(hmmio)->pchNext)
			PH(hmmio)->pchEndRead = PH(hmmio)->pchNext;

		if (cch == 0)			// no more to write?
			return lTotalBytesWritten;

		/* we need to read beyond this buffer; if we have at least
		 * another bufferful to read, just call the I/O procedure
		 */
		if (cch > PH(hmmio)->cchBuffer)
			break;

		/* write this buffer (if needed) and read the next
		 * bufferful (if needed)
		 */
		if (mmioAdvance(hmmio, NULL, MMIO_WRITE) != 0)
			return -1;
	}

	/* we should never need to do MMIOM_WRITE with memory files */

	/* flush and empty the I/O buffer and manipulate <lBufOffset>
	 * directly to change the current file position
	 */
	if (mmioFlush(hmmio, MMIO_EMPTYBUF) != 0)
		return -1;

	/* call the I/O procedure to do the rest of the writing */
	lBytes = mmioDiskIO(PH(hmmio), MMIOM_WRITE, (HPSTR)pch, cch);
	PH(hmmio)->lBufOffset = PH(hmmio)->lDiskOffset;

	return (lBytes == -1L) ? -1L : lTotalBytesWritten + lBytes;
}


/* @doc EXTERNAL

@api	LONG | mmioSeek | This function changes the current file
	position in a file opened with <f mmioOpen>. The current file
	position is the location in the file where data is read or written.

@parm	HMMIO | hmmio | Specifies the file handle of the file to seek
	in.

@parm	LONG | lOffset | Specifies an offset to change the file position.

@parm	int | iOrigin | Specifies how the offset specified by
	<p lOffset> is interpreted. Contains one of the following flags:

	@flag	SEEK_SET | Seeks to <p lOffset> bytes from the beginning
		of the file.

	@flag	SEEK_CUR | Seeks to <p lOffset> bytes from the current
		file position.

	@flag	SEEK_END | Seeks to <p lOffset> bytes from the end
		of the file.

@rdesc	The return value is the new file position in bytes, relative
	to the beginning of the file. If there is an error, the return value
	is -1.

@comm	Seeking to an invalid location in the file, such as past the
	end of the file, may not cause <f mmioSeek> to return an error,
	but may cause subsequent I/O operations on the file to fail.

	To locate the end of a file, call <f mmioSeek> with <p lOffset>
	set to zero and <p iOrigin> set to SEEK_END.
*/
LONG WINAPI
mmioSeek(HMMIO hmmio, LONG lOffset, int iOrigin)
{
	LONG		lCurOffset;	// disk offset of <pchNext>
	LONG		lEndBufOffset;	// disk offset of end of buffer
	LONG		lNewOffset;	// new disk offset

	V_HANDLE(hmmio, TYPE_MMIO, -1);
	
	/* careful! all this buffer pointer manipulation is fine, but keep
	 * in mind that buffering may be disabled (in which case <pchEndRead>
	 * and <pchBuffer> will both be NULL, so the buffer will appear to
	 * be zero bytes in size)
	 */

	/* <PH(hmmio)->lBufOffset> is the disk offset of the start of the start
	 * of the buffer; determine <lCurOffset>, the offset of <pchNext>,
	 * and <lEndBufOffset>, the offset of the end of the valid part
	 * of the buffer
	 */
	lCurOffset = PH(hmmio)->lBufOffset +
		(PH(hmmio)->pchNext - PH(hmmio)->pchBuffer);
	lEndBufOffset = PH(hmmio)->lBufOffset +
		(PH(hmmio)->pchEndRead - PH(hmmio)->pchBuffer);
	
	/* determine <lNewOffset>, the offset to seek to */
	switch (iOrigin)
	{
	case SEEK_SET:		// seek relative to start of file

		lNewOffset = lOffset;
		break;

	case SEEK_CUR:		// seek relative to current location

		lNewOffset = lCurOffset + lOffset;
		break;

	case SEEK_END:		// seek relative to end of file

		if (PH(hmmio)->fccIOProc == FOURCC_MEM)
			lNewOffset = lEndBufOffset - lOffset;
		else
		{
			LONG	lEndFileOffset;

			/* find out where the end of the file is */
			if ((lEndFileOffset = (LONG) PH(hmmio)->pIOProc((LPSTR) PH(hmmio),
					MMIOM_SEEK, (LPARAM) 0, (LPARAM) SEEK_END)) == -1)
				return -1;
			lNewOffset = lEndFileOffset - lOffset;
		}
		break;

	default:
		return -1;
	}

	if ((lNewOffset >= PH(hmmio)->lBufOffset) && (lNewOffset <= lEndBufOffset))
	{
		/* seeking within the valid part of the buffer
		 * (possibly including seeking to <lEndBufOffset>)
		 */
		PH(hmmio)->pchNext = PH(hmmio)->pchBuffer +
			(lNewOffset - PH(hmmio)->lBufOffset);
	}
	else
	{
		/* seeking outside the buffer */
		if (PH(hmmio)->fccIOProc == FOURCC_MEM)
			return -1;	// can't seek outside mem. file buffer
		if (mmioFlush(hmmio, 0) != 0)
			return -1;

		/* the current "buffered file position" (same as <lDiskOffset>
		 * for unbuffered files) equals <lBufOffset> +
		 * (<pchNext> - <pchBuffer>); we'll move the current buffered
		 * file position (and empty the buffer, since it becomes
		 * invalid when <lBufOffset> changes) as follows...
		 */
		PH(hmmio)->lBufOffset = lNewOffset;
		PH(hmmio)->pchNext = PH(hmmio)->pchEndRead = PH(hmmio)->pchBuffer;

		/* don't need to actually seek right now, since the next
		 * MMIOM_READ or MMIOM_WRITE will have to seek anyway
		 */
	}

	return lNewOffset;
}


/* @doc EXTERNAL

@api	UINT | mmioGetInfo | This function retrieves information
	about a file opened with <f mmioOpen>. This information allows the
	caller to directly access the I/O buffer, if the file is opened
	for buffered I/O.

@parm	HMMIO | hmmio | Specifies the file handle of the file.

@parm	LPMMIOINFO | lpmmioinfo | Specifies a far pointer to a
	caller-allocated <t MMIOINFO> structure that <f mmioGetInfo>
	fills with information about the file. See the <t MMIOINFO> structure
	and the <f mmioOpen> function for information about the fields in
	this structure.

@parm	UINT | wFlags | Is not used and should be set to zero.

@rdesc	The return value is zero if the function is successful.

@comm	To directly access the I/O buffer of a file opened for
	buffered I/O, use the following fields of the <t MMIOINFO> structure
	filled by <f mmioGetInfo>:

	-- The <e MMIOINFO.pchNext> field points to the next byte in the
	buffer that can be read or written. When you read or write, increment
	<e MMIOINFO.pchNext> by the number of bytes read or written.

	-- The <e MMIOINFO.pchEndRead> field points to one byte past the
	last valid byte in the buffer that can be read.

	-- The <e MMIOINFO.pchEndWrite> field points to one byte past the
	last location in the buffer that can be written.

	Once you read or write to the buffer and modify
	<e MMIOINFO.pchNext>, do not call any MMIO function except
	<f mmioAdvance> until you call <f mmioSetInfo>. Call <f mmioSetInfo>
	when you are finished directly accessing the buffer.

	When you reach the end of the buffer specified by
	<e MMIOINFO.pchEndRead> or <e MMIOINFO.pchEndWrite>, call
	<f mmioAdvance> to fill the buffer from the disk, or write
	the buffer to the disk. The <f mmioAdvance> function
	will update the <e MMIOINFO.pchNext>, <e MMIOINFO.pchEndRead>, and
	<e MMIOINFO.pchEndWrite> fields in the <t MMIOINFO> structure for the
	file.

	Before calling <f mmioAdvance> or <f mmioSetInfo> to flush a
	buffer to disk, set the MMIO_DIRTY flag in the <e MMIOINFO.dwFlags>
	field of the <t MMIOINFO> structure for the file. Otherwise, the
	buffer will not get written to disk.

	Do not decrement <e MMIOINFO.pchNext> or modify any fields in the
	<t MMIOINFO> structure other than <e MMIOINFO.pchNext> and
	<e MMIOINFO.dwFlags>. Do not set any flags in <e MMIOINFO.dwFlags>
	except MMIO_DIRTY.

@xref	mmioSetInfo MMIOINFO
*/
UINT WINAPI
mmioGetInfo(HMMIO hmmio, LPMMIOINFO lpmmioinfo, UINT wFlags)
{
	V_HANDLE(hmmio, TYPE_MMIO, MMSYSERR_INVALHANDLE);
	V_WPOINTER(lpmmioinfo, sizeof(MMIOINFO), MMSYSERR_INVALPARAM);
	V_FLAGS(wFlags, 0, mmioGetInfo, MMSYSERR_INVALFLAG);
	
	*lpmmioinfo = *PH(hmmio);

	return 0;
}


/* @doc EXTERNAL

@api	UINT | mmioSetInfo | This function updates the information
	retrieved by <f mmioGetInfo> about a file opened with <f mmioOpen>.
	Use this function to terminate direct buffer access of a file opened
	for buffered I/O.

@parm	HMMIO | hmmio | Specifies the file handle of the file.

@parm	LPMMIOINFO | lpmmioinfo | Specifies a far pointer to an
	<t MMIOINFO> structure filled with information with
	<f mmioGetInfo>.

@parm	UINT | wFlags | Is not used and should be set to zero.

@rdesc	The return value is zero if the function is successful.

@comm	If you have written to the file I/O buffer, set the
	MMIO_DIRTY flag in the <e MMIOINFO.dwFlags> field of the <t MMIOINFO>
	structure before calling <f mmioSetInfo> to terminate direct buffer
	access. Otherwise, the buffer will not get flushed to disk.
	
@xref	mmioGetInfo MMIOINFO
*/
UINT WINAPI
mmioSetInfo(HMMIO hmmio, const MMIOINFO FAR* lpmmioinfo, UINT wFlags)
{
	V_HANDLE(hmmio, TYPE_MMIO, MMSYSERR_INVALHANDLE);
	V_RPOINTER(lpmmioinfo, sizeof(MMIOINFO), MMSYSERR_INVALPARAM);
	V_WPOINTER0(lpmmioinfo->pchBuffer, lpmmioinfo->cchBuffer, MMSYSERR_INVALPARAM);
	V_CALLBACK((FARPROC)lpmmioinfo->pIOProc, MMSYSERR_INVALPARAM);
	V_FLAGS(wFlags, 0, mmioSetInfo, MMSYSERR_INVALFLAG);

	/* copy the relevant information from <lpmmioinfo> back into <hmmio> */
	*PH(hmmio) = *lpmmioinfo;

	/* validate <pchEndRead>, i.e. re-enforce the invariant that
	 * <pchEndRead> points past the last valid byte in the buffer
	 */
	if (PH(hmmio)->pchEndRead < PH(hmmio)->pchNext)
		PH(hmmio)->pchEndRead = PH(hmmio)->pchNext;

	return 0;
}


/* @doc EXTERNAL

@api	UINT | mmioSetBuffer | This function enables or disables
	buffered I/O, or changes the buffer or buffer size for a file opened
	with <f mmioOpen>.

@parm	HMMIO | hmmio | Specifies the file handle of the file.

@parm	LPSTR | pchBuffer | Specifies a far pointer to a
	caller-supplied buffer to use for buffered I/O. If NULL,
	<f mmioSetBuffer> allocates an internal buffer for buffered I/O.

@parm	LONG | cchBuffer | Specifies the size of the caller-supplied
	buffer, or the size of the buffer for <f mmioSetBuffer> to allocate.

@parm	UINT | wFlags | Is not used and should be set to zero.

@rdesc	The return value is zero if the function is successful.
	Otherwise, the return value specifies an error code. If an error
	occurs, the file handle remains valid. The error code can be one
	of the following codes:
	
	@flag MMIOERR_CANNOTWRITE | The contents of the old buffer could
	not be written to disk, so the operation was aborted.
	
	@flag MMIOERR_OUTOFMEMORY | The new buffer could not be allocated,
	probably due to a lack of available memory.

@comm	To enable buffering using an internal buffer, set
	<p pchBuffer> to NULL and <p cchBuffer> to the desired buffer size.

	To supply your own buffer, set <p pchBuffer> to point to the buffer,
	and set <p cchBuffer> to the size of the buffer.

	To disable buffered I/O, set <p pchBuffer> to NULL and
	<p cchBuffer> to zero.

	If buffered I/O is already enabled using an internal buffer, you
	can reallocate the buffer to a different size by setting
	<p pchBuffer> to NULL and <p cchBuffer> to the new buffer size. The
	contents of the buffer may be changed after resizing.
 */
UINT WINAPI
mmioSetBuffer(HMMIO hmmio, LPSTR pchBuffer, LONG cchBuffer, UINT wFlags)
{
	UINT		w;

	V_HANDLE(hmmio, TYPE_MMIO, MMSYSERR_INVALHANDLE);
	V_WPOINTER0(pchBuffer, cchBuffer, MMSYSERR_INVALPARAM);
	V_FLAGS(wFlags, 0, mmioSetBuffer, MMSYSERR_INVALFLAG);
	
	if ((PH(hmmio)->dwFlags & MMIO_ALLOCBUF) &&
	    (pchBuffer == NULL) && (cchBuffer > 0))
	{
		/* grow or shrink buffer in-place */
		HPSTR		pch;
		LONG		lDeltaNext;
		LONG		lDeltaEndRead;

		/* Since the ALLOCBUF flag is set, we must have a buffer */
		
		/* write the buffer to disk, but don't empty it */
		if ((w = mmioFlush(hmmio, 0)) != 0)
			return w;

		while (TRUE)
		{
			/* remember where <pchNext> and <pchEndRead> are
			 * in the buffer
			 */
			lDeltaNext = PH(hmmio)->pchNext - PH(hmmio)->pchBuffer;
			lDeltaEndRead = PH(hmmio)->pchEndRead - PH(hmmio)->pchBuffer;

			if (cchBuffer >= lDeltaNext)
				break;

			/* caller wants to truncate the part of the buffer
			 * that contains <pchNext> -- handle this by
			 * emptying the buffer, recalculating <lDeltaNext>
			 * and <lDeltaEndRead>, and continuing below
			 */
			if ((w = mmioFlush(hmmio, MMIO_EMPTYBUF)) != 0)
				return w;
		}

		/* reallocate buffer */
		pch = GlobalReAllocPtr(PH(hmmio)->pchBuffer, cchBuffer, GMEM_MOVEABLE);

		/* If we cannot allocate the new buffer, exit with no
		 *   harm done.
		 */
		if (pch == NULL)
			return MMIOERR_OUTOFMEMORY;	// out of memory
		
		/* transfer pointers to new buffer */
		PH(hmmio)->cchBuffer = cchBuffer;
		PH(hmmio)->pchBuffer = pch;
		PH(hmmio)->pchNext = pch + lDeltaNext;
		PH(hmmio)->pchEndRead = pch + lDeltaEndRead;

		/* <pchEndWrite> always points to the end of the buf. */
		PH(hmmio)->pchEndWrite = PH(hmmio)->pchBuffer + cchBuffer;

		/* check if the reallocation truncated valid data */
		if (lDeltaEndRead > cchBuffer)
			PH(hmmio)->pchEndRead = PH(hmmio)->pchEndWrite;
		
		return 0;
	}

	/* write the buffer to disk and stop using the buffer */
	if ((w = mmioFlush(hmmio, MMIO_EMPTYBUF)) != 0)
		return w;

	if (PH(hmmio)->dwFlags & MMIO_ALLOCBUF)
	{
		GlobalFreePtr(PH(hmmio)->pchBuffer);
		PH(hmmio)->dwFlags &= ~MMIO_ALLOCBUF;
	}
	
	/* Initially, no error. */
	w = 0;

	if ((pchBuffer == NULL) && (cchBuffer > 0))
	{
		pchBuffer = GlobalAllocPtr(GMEM_MOVEABLE, cchBuffer);
				
		/* If there is an error, change the file to be un-buffered
		 * and return an error code.  The file is still valid.
		 * (Just for a little extra security.)
		 */
		if (pchBuffer == NULL) {
		    w = MMIOERR_OUTOFMEMORY;
		    cchBuffer = 0L;
		} else
		    PH(hmmio)->dwFlags |= MMIO_ALLOCBUF;
	}

	/* invariant: <pchEndRead> points past the end of the "valid" portion
	 * of the buffer, and <pchEndWrite> points past the last byte that
	 * can be written into; <pchNext> points to the next byte to read
	 * or write; <lBufOffset> is the current disk offset of the start
	 * of the buffer, and it will not change
	 */
	PH(hmmio)->pchBuffer = pchBuffer;
	PH(hmmio)->cchBuffer = cchBuffer;
	PH(hmmio)->pchNext = PH(hmmio)->pchEndRead = PH(hmmio)->pchBuffer;
	PH(hmmio)->pchEndWrite = PH(hmmio)->pchBuffer + cchBuffer;

	return w;
}


/* @doc EXTERNAL

@api	UINT | mmioFlush | This function writes the I/O buffer of a
	file to disk, if the I/O buffer has been written to.

@parm	HMMIO | hmmio | Specifies the file handle of a file opened
	with <f mmioOpen>.

@parm	UINT | wFlags | Is not used and should be set to zero.

@rdesc	The return value is zero if the function is successful.
	Otherwise, the return value specifies an error code. The error
	code can be one of the following codes:
	
	@flag MMIOERR_CANNOTWRITE | The contents of the buffer could
	not be written to disk.
	
@comm	Closing a file with <f mmioClose> will automatically flush
	its buffer.

	If there is insufficient disk space to write the
	buffer, <f mmioFlush> will fail, even if the preceding <f mmioWrite>
	calls were successful.
*/
UINT WINAPI
mmioFlush(HMMIO hmmio, UINT wFlags)
{
	LONG		lBytesAsk;		// no. bytes to write
	LONG		lBytesWritten;		// no. bytes actually written

	V_HANDLE(hmmio, TYPE_MMIO, MMSYSERR_INVALHANDLE);
	V_FLAGS(wFlags, MMIO_FLUSH_VALID, mmioFlush, MMSYSERR_INVALFLAG);
	
	if ((PH(hmmio)->fccIOProc == FOURCC_MEM) || (PH(hmmio)->pchBuffer == NULL))
		return 0;		// cannot flush memory files
	
	/* if the file is unbuffered then the dirty flag should not be set */
	if (PH(hmmio)->dwFlags & MMIO_DIRTY)
	{
		/* figure out how many bytes need to be flushed */
		lBytesAsk = PH(hmmio)->pchEndRead - PH(hmmio)->pchBuffer;

		/* write the buffer to disk */
		lBytesWritten = mmioDiskIO(PH(hmmio), MMIOM_WRITEFLUSH,
			PH(hmmio)->pchBuffer, lBytesAsk);
		if (lBytesWritten != lBytesAsk)
			return MMIOERR_CANNOTWRITE;
		PH(hmmio)->dwFlags &= ~MMIO_DIRTY;	// buffer is clean now
	}

	if (wFlags & MMIO_EMPTYBUF)
	{
		/* empty the I/O buffer, and update <lBufOffset> to reflect
		 * what the current file position is
		 */
		PH(hmmio)->lBufOffset += (PH(hmmio)->pchNext - PH(hmmio)->pchBuffer);
		PH(hmmio)->pchNext = PH(hmmio)->pchEndRead = PH(hmmio)->pchBuffer;
	}

	return 0;
}


/* @doc EXTERNAL

@api	UINT | mmioAdvance | This function advances the I/O buffer of
	a file set up for direct I/O buffer access with <f mmioGetInfo>. If
	the file is opened for reading, the I/O buffer is filled from the
	disk.  If the file is opened for writing and the MMIO_DIRTY flag is
	set in the <e MMIOINFO.dwFlags> field of the <t MMIOINFO> structure,
	the buffer is written to disk.  The <e MMIOINFO.pchNext>,
	<e MMIOINFO.pchEndRead>, and <e MMIOINFO.pchEndWrite> fields of the
	<t MMIOINFO> structure are updated to reflect the new state of
	the I/O buffer.

@parm	HMMIO | hmmio | Specifies the file handle for a file opened
	with <f mmioOpen>.

@parm	LPMMIOINFO | lpmmioinfo | Optionally specifies a far pointer to the
	<t MMIOINFO> structure obtained with <f mmioGetInfo>, which is used to
	set the current file information, then updated after the buffer is
	advanced.

@parm	UINT | wFlags | Specifies options for the operation.
	Contains exactly one of the following two flags:

	@flag	MMIO_READ | The buffer is filled from the file.

	@flag	MMIO_WRITE | The buffer is written to the file.

@rdesc	The return value is zero if the operation is successful.
	Otherwise, the return value specifies an error code. The error
	code can be one of the following codes:
	
	@flag MMIOERR_CANNOTWRITE | The contents of the buffer could
	not be written to disk.
	
	@flag MMIOERR_CANNOTREAD | An error occurred while re-filling
	the buffer.
	
	@flag MMIOERR_UNBUFFERED | The specified file is not opened
	for buffered I/O.
	
	@flag MMIOERR_CANNOTEXPAND | The specified memory file cannot
	be expanded, probably because the <e MMIOINFO.adwInfo[0]> field
	was set to zero in the initial call to <f mmioOpen>.
	
	@flag MMIOERR_OUTOFMEMORY | There was not enough memory to expand
	a memory file for further writing.
	

@comm	If the specified file is opened for writing or for both
	reading and writing, the I/O buffer will be flushed to disk before
	the next buffer is read. If the I/O buffer cannot be written to disk
	because the disk is full, then <f mmioAdvance> will return
	MMIOERR_CANNOTWRITE.
	
	If the specified file is only open for writing, the MMIO_WRITE
	flag must be specified.

	If you have written to the I/O buffer, you must set the MMIO_DIRTY
	flag in the <e MMIOINFO.dwFlags> field of the <t MMIOINFO> structure
	before calling <f mmioAdvance>. Otherwise, the buffer will not be
	written to disk.
	
	If the end of file is reached, <f mmioAdvance> will still return
	success, even though no more data can be read.  Thus, to check for
	the end of the file, it is necessary to see if the
	<e MMIOINFO.pchNext> and <e MMIOINFO.pchEndRead> fields of the
	<t MMIOINFO> structure are equal after calling <f mmioAdvance>.

@xref	mmioGetInfo MMIOINFO
*/
UINT WINAPI
mmioAdvance(HMMIO hmmio, LPMMIOINFO lpmmioinfo, UINT wFlags)
{
	LONG		lBytesRead;		// bytes actually read
	UINT		w;

	V_HANDLE(hmmio, TYPE_MMIO, MMSYSERR_INVALHANDLE);
	V_FLAGS(wFlags, MMIO_ADVANCE_VALID, mmioAdvance, MMSYSERR_INVALFLAG);

	if (PH(hmmio)->pchBuffer == NULL)
		return MMIOERR_UNBUFFERED;
	if (lpmmioinfo != NULL) {
		V_WPOINTER(lpmmioinfo, sizeof(MMIOINFO), MMSYSERR_INVALPARAM);
		mmioSetInfo(hmmio, lpmmioinfo, 0);
	}

	if (PH(hmmio)->fccIOProc == FOURCC_MEM)
	{
		/* this is a memory file:
		 *   -- if the caller is reading, cannot advance
		 *   -- if the caller is writing, then advance by expanding
		 *      the buffer (if possible) if the there is less than
		 *	<adwInfo[0]> bytes left in the buffer
		 */
		if (!(wFlags & MMIO_WRITE))
			return 0;
		if ((DWORD)(PH(hmmio)->pchEndWrite - PH(hmmio)->pchNext) >= PH(hmmio)->adwInfo[0])
			return 0;
		if ((w = mmioExpandMemFile(PH(hmmio), 1L)) != 0)
			return w;	// out of memory, or whatever
		goto GETINFO_AND_EXIT;
	}

	/* empty the I/O buffer, which will effectively advance the
	 * buffer by (<pchNext> - <pchBuffer>) bytes
	 */
	if ((w = mmioFlush(hmmio, MMIO_EMPTYBUF)) != 0)
		return w;
	
	/* if MMIO_WRITE bit is not set in wFlags, fill the buffer  */
	if (!(wFlags & MMIO_WRITE))
	{
		/* read the next bufferful from the file */
		lBytesRead = mmioDiskIO(PH(hmmio), MMIOM_READ,
			PH(hmmio)->pchBuffer, PH(hmmio)->cchBuffer);
		if (lBytesRead == -1)
			return MMIOERR_CANNOTREAD;

		/* reading zero bytes should not be treated as an error
		 * condition -- e.g. open a new file R+W and call
		 * mmioAdvance(), and MMIOM_READ will return zero bytes
		 * because the file started off empty
		 */
		PH(hmmio)->pchEndRead += lBytesRead;
	}

GETINFO_AND_EXIT:

	/* copy <hmmio> back to <lpmmioinfo> if <lpmmioinfo> is provided */
	if (lpmmioinfo != NULL)
		mmioGetInfo(hmmio, lpmmioinfo, 0);
	
	return 0;
}


/* @doc EXTERNAL

@api	FOURCC | mmioStringToFOURCC | This function converts a
	null-terminated string to a four-character code.

@parm	LPCSTR | sz | Specifies a far pointer to a null-terminated
	string to a four-character code.

@parm	UINT | wFlags | Specifies options for the conversion:

	@flag	MMIO_TOUPPER | Converts all characters to uppercase.

@rdesc	The return value is the four character code created from the
	given string.

@comm	This function does not check to see if the string referenced
	by <p sz> follows any conventions regarding which characters to
	include in a four-character code.  The string is
	simply copied to a four-character code and padded with blanks or
    truncated to four characters if required.

@xref	mmioFOURCC
*/
FOURCC WINAPI
mmioStringToFOURCC(LPCSTR sz, UINT wFlags)
{
	FOURCC		fcc;
	LPSTR		pch = (LPSTR) &fcc;
	int		i;

    V_STRING(sz, (UINT)-1, NULL);
	V_FLAGS(wFlags, MMIO_FOURCC_VALID, mmioStringToFOURCC, (FOURCC)-1);

	for (i = sizeof(FOURCC) - 1; i >= 0; i--)
	{
		if (!*sz)
			*pch = ' ';
		else {
            *pch = *sz++;
			if (wFlags & MMIO_TOUPPER)
				*pch = (char)(WORD)(LONG)AnsiUpper((LPSTR)(LONG)*pch);
        }
		pch++;
	}
    return fcc;
}


/* @doc EXTERNAL

@api	LPMMIOPROC | mmioInstallIOProc | This function installs or
	removes a custom I/O procedure. It will also locate an installed I/O
	procedure, given its corresponding four-character code.

@parm	FOURCC | fccIOProc | Specifies a four-character code
	identifying the I/O procedure to install, remove, or locate. All
	characters in this four-character code should be uppercase characters.

@parm	LPMMIOPROC | pIOProc | Specifies the address of the I/O
	procedure to install. To remove or locate an I/O procedure, set this
	parameter to NULL.

@parm	DWORD | dwFlags | Specifies one of the following flags
	indicating whether the I/O procedure is being installed, removed, or
	located:

	@flag	MMIO_INSTALLPROC | Installs the specified I/O procedure.

	@flag	MMIO_GLOBALPROC | This flag is a modifier to the install flag,
		and indicates the I/O procedure should be installed for global
		use.  This flag is ignored on removal or find.

	@flag	MMIO_REMOVEPROC | Removes the specified I/O procedure.

	@flag	MMIO_FINDPROC | Searches for the specified I/O procedure.

@rdesc	The return value is the address of the I/O procedure
	installed, removed, or located. If there is an error, the return value
	is NULL.

@comm	If the I/O procedure resides in the application, use
	<f MakeProcInstance> to get a procedure-instance address and specify
	this address for <p pIOProc>. You don't need to get a procedure-instance
	address if the I/O procedure resides in a DLL.

@cb	LRESULT FAR PASCAL | IOProc | <f IOProc> is a placeholder for the
	application-supplied function name. The actual name must be exported
	by including it in a EXPORTS statement in the application's
	module-definitions file.

	@parm	LPSTR | lpmmioinfo | Specifies a far pointer to an
		<t MMIOINFO> structure containing information about the open
		file.  The I/O procedure must maintain the <e MMIOINFO.lDiskOffset>
		field in this structure to indicate the file offset to the
		next read or write location. The I/O procedure can use the
		<e MMIOINFO.adwInfo[]> field to store state information. The
		I/O procedure should not modify any other fields of the
		<t MMIOINFO> structure.


	@parm	UINT | wMsg | Specifies a message indicating the
		requested I/O operation. Messages that can be received include
		<m MMIOM_OPEN>, <m MMIOM_CLOSE>, <m MMIOM_READ>, <m MMIOM_WRITE>,
		and <m MMIOM_SEEK>.

	@parm	LPARAM | lParam1 | Specifies a parameter for the message.

	@parm	LPARAM | lParam2 | Specifies a parameter for the message.

@rdesc	The return value depends on the message specified by
	<p wMsg>. If the I/O procedure does not recognize a message, it should
	return zero.

@comm	The four-character code specified by the
	<e MMIOINFO.fccIOProc> field in the <t MMIOINFO> structure
	associated with a file identifies a filename extension for a custom
	storage system. When an application calls <f mmioOpen> with a
	filename such as "foo.xyz!bar", the I/O procedure associated with the
	four-character code "XYZ " is called to open the "bar" element of the
	file "foo.xyz".

	The <f mmioInstallIOProc> function maintains a separate list of
	installed I/O procedures for each Windows application. Therefore,
	different applications can use the same I/O procedure identifier for
	different I/O procedures without conflict.  Installing an I/O procedure
	globally however enables any process to use the procedure.

	If an application calls <f mmioInstallIOProc> more than once to
	register the same I/O procedure, then it must call
	<f mmioInstallIOProc> to remove the procedure once for each time it
	installed the procedure.

	<f mmioInstallIOProc> will not prevent an application from
	installing two different I/O procedures with the same identifier, or
	installing an I/O procedure with one of the predefined identifiers
	("DOS ", "MEM "). The most recently installed procedure
	takes precedence, and the most recently installed procedure is the
	first one to get removed.

	When searching for a specified I/O procedure, local procedures are
	searched first, then global procedures.

@xref	mmioOpen
 */
LPMMIOPROC WINAPI
mmioInstallIOProc(FOURCC fccIOProc, LPMMIOPROC pIOProc, DWORD dwFlags)
{
	IOProcMapEntry *pEnt;		// an entry in linked list
        HTASK           hTaskCurrent;   // current Windows task handl

        V_FLAGS(dwFlags, MMIO_VALIDPROC, mmioInstallIOProc, NULL);

        if (fccIOProc == 0L)
                return NULL;

	hTaskCurrent = GetCurrentTask();

	if (dwFlags & MMIO_INSTALLPROC)
	{
		/* install I/O procedure -- always add at the beginning of
		 * the list, so it overrides any other I/O procedures
		 * with the same identifier installed by the same task
		 */
		V_CALLBACK((FARPROC)pIOProc, NULL);
		if ((pEnt = (IOProcMapEntry NEAR *)
			NewHandle(TYPE_IOPROC, sizeof(IOProcMapEntry))) == NULL)
				return NULL;		// out of memory
		pEnt->fccIOProc = fccIOProc;
		pEnt->pIOProc = pIOProc;
		if (dwFlags & MMIO_GLOBALPROC) {

            char    libname[128];
            char    aszFour[sizeof(FOURCC)+1];

            pEnt->hTask = NULL;
            SetHandleOwner(pEnt, NULL);

            //
            // This is the hack to allow global IO Procs to be truly
            // global.  That is, if there is a matching 32 bit entry
            // in win.ini under [IOProcs] for this fccIOProc will we try
            // load the dll.   The dll should install its 32 bit
            // equivalent IOProc in the dll initialisation routine.
            //

            *(LPDWORD)&aszFour = (DWORD)fccIOProc;
            aszFour[ sizeof(FOURCC) ] = '\0';
            if ( GetProfileString( "IOProcs", aszFour, "", libname,
                                   sizeof(libname) ) ) {

                LoadLibraryEx32W( libname, 0L, 0L );
            }

        } else {
			pEnt->hTask = hTaskCurrent;
        }
		pEnt->wFlags = 0;
		pEnt->pNext = gIOProcMapHead;
		gIOProcMapHead = pEnt;
		return pIOProc;
	}
	if (!pIOProc)
		if (dwFlags & MMIO_REMOVEPROC) {
			LPMMIOPROC	lpmmioproc;

			lpmmioproc = RemoveIOProc(fccIOProc, hTaskCurrent);
			if (!lpmmioproc)
				lpmmioproc = RemoveIOProc(fccIOProc, NULL);
			return lpmmioproc;
		} else if (dwFlags & MMIO_FINDPROC)
			return FindIOProc(fccIOProc, hTaskCurrent);
	return NULL;		// couldn't find requested I/O procedure
}


/* @doc EXTERNAL

@api	LRESULT | mmioSendMessage | This function sends a message to the
	I/O procedure associated with the specified file.

@parm	HMMIO | hmmio | Specifies the file handle for a file opened
	with <f mmioOpen>.

@parm	UINT | wMsg | Specifies the message to send to the I/O procedure.

@parm	LPARAM | lParam1 | Specifies a parameter for the message.

@parm	LPARAM | lParam2 | Specifies a parameter for the message.

@rdesc	The return value depends on the message. If the I/O procedure
	does not recognize the message, the return value is zero.

@comm	Use this function to send custom user-defined messages. Do
	not use it to send the <m MMIOM_OPEN>, <m MMIOM_CLOSE>,
	<m MMIOM_READ>, <m MMIOM_WRITE>, <m MMIOM_WRITEFLUSH>, or
	<m MMIOM_SEEK> messages. Define
	custom messages to be greater than or equal to the MMIOM_USER constant.

@xref	mmioInstallIOProc
*/
LRESULT WINAPI
mmioSendMessage(HMMIO hmmio, UINT wMsg, LPARAM lParam1, LPARAM lParam2)
{
	V_HANDLE(hmmio, TYPE_MMIO, (LRESULT)0);
	return PH(hmmio)->pIOProc((LPSTR)PH(hmmio), wMsg, lParam1, lParam2);
}


/* @doc INTERNAL

@api	LONG | mmioDiskIO | Perform an unbuffered read or write.
	Do not assume where the current disk offset <p lDiskOffset> will be.

@parm	PMMIO | pmmio | The open file handle returned by <f mmioOpen>.

@parm	UINT | wMsg | MMIOM_READ if <f mmioDiskIO> should read from the disk,
	or MMIOM_WRITE if <f mmioDiskIO> should write to the disk.

@parm	HPSTR | pch | The buffer to read into or write from.

@parm	LONG | cch | The number of bytes to read or write.

	<f mmioDiskIO> changes the disk offset to be <p lBufOffset>
	and then performs an MMIOM_READ or MMIOM_WRITE operation as
	specified by <p wMsg>, <p pch>, and <p cch>.

	Note that if the I/O buffer is not empty at this point, this
	function may not do what you expect.

	Do not call this function for memory files.
*/
static LONG NEAR PASCAL
mmioDiskIO(PMMIO pmmio, UINT wMsg, HPSTR pch, LONG cch)
{
	if (pmmio->lDiskOffset != pmmio->lBufOffset)
	{
		if ((LONG) pmmio->pIOProc((LPSTR) pmmio, MMIOM_SEEK, (LPARAM) pmmio->lBufOffset,
		                   (LPARAM) SEEK_SET) == -1)
			return -1;
	}

	return (LONG) pmmio->pIOProc((LPSTR) pmmio, wMsg, (LPARAM) pch, (LPARAM) cch);
}


/* @doc INTERNAL

@api	UINT | mmioExpandMemFile | Assuming that <p pmmio> is a memory file,
	expand it by <p lExpand> bytes or <p adwInfo[0]> bytes, whichever
	is larger.  Do not disturb the contents of the buffer or change
	the current file position.

@parm	PMMIO | pmmio | The open file handle returned by <f mmioOpen>.

@parm	LONG | lExpand | The minimum number of bytes to expand the buffer by.

@rdesc	If the function succeeds, zero is returned.  If the function fails,
	an error code is returned.  In particular, MMIOERR_OUTOFMEMORY is
	returned if memory reallocation failed.

@comm	Only call this function for memory files.
*/
static UINT NEAR PASCAL
mmioExpandMemFile(PMMIO pmmio, LONG lExpand)
{
	MMIOMEMINFO *	pInfo = (MMIOMEMINFO *) pmmio->adwInfo;
	DWORD		dwFlagsTemp;
	UINT		w;

	/* make sure buffer can be expanded */
	/* Note: we used to check ALLOC_BUF here, we don't now. */
	if (pInfo->lExpand == 0)
		return MMIOERR_CANNOTEXPAND;	// cannot grow file

	/* how much should the buffer be expanded by? */
	if (lExpand < pInfo->lExpand)
		lExpand = pInfo->lExpand;
	
	dwFlagsTemp = pmmio->dwFlags;
	pmmio->dwFlags |= MMIO_ALLOCBUF;
	w = mmioSetBuffer(HP(pmmio), NULL,
		             pmmio->cchBuffer + lExpand, 0);
	pmmio->dwFlags = dwFlagsTemp;
	return w;
}


/************************************************************************/
/*
@doc	INTERNAL

@func	UINT | lrename |
	Renames the specified DOS file.

@parm	LPCSTR | lszOrigPath |
	Points to the DOS file to rename.

@parm	LPCSTR | lszNewPath |
	Points to the new name for the file.

@rdesc	Returns zero if the file was renamed, else the DOS error code.
*/

#pragma warning(4:4035)
#pragma warning(4:4704)

static	UINT PASCAL NEAR lrename(
	LPCSTR	lszOrigPath,
	LPCSTR	lszNewPath)
{
	_asm {
		push	ds
		lds	dx, lszOrigPath	; Original name.
		les	di, lszNewPath	; New name.
		mov	ah, 56H		; Rename file.
                int     21h             ; DOS.
                sbb     bx,bx           ; if error (C) BX=FFFF, (NC) BX=000
                and     ax,bx           ; set ax to zero if no error
		pop	ds
	}
}

/* @doc INTERNAL

@api	LRESULT | mmioDOSIOProc | The 'DOS' I/O procedure, which handles I/O
	on ordinary DOS files.

@parm	LPSTR | lpmmioinfo | A pointer to an MMIOINFO block that
	contains information about the open file.

@parm	UINT | wMsg | The message that the I/O procedure is being
	asked to execute.

@parm	LPARAM | lParam1 | Specifies additional message information.

@parm	LPARAM | lParam2 | Specifies additional message information.

@rdesc	Return value depends on <p wMsg>.
*/
static LRESULT CALLBACK
mmioDOSIOProc(LPSTR lpmmioStr, UINT wMsg, LPARAM lParam1, LPARAM lParam2)
{
	PMMIO		pmmio = (PMMIO) (UINT) (LONG) lpmmioStr; // only in DLL!
	MMIODOSINFO *	pInfo = (MMIODOSINFO *) pmmio->adwInfo;
	LONG		lResult;
	OFSTRUCT	of;

	switch (wMsg)
	{

	case MMIOM_OPEN:

		/* If a temporary file name is to be returned, use the file
		 * name parameter as a disk followed by a prefix for the name
		 * to create.  The extra info parameter optionally contains a
		 * sequence number to pass.
		*/
		if (pmmio->dwFlags & MMIO_GETTEMP) {
			V_RPOINTER((LPSTR)lParam1, 4, (LRESULT) MMSYSERR_INVALPARAM);
			return (LRESULT)(LONG) (GetTempFileName(*(LPSTR)lParam1,
				((LPSTR)lParam1) + 3, (UINT)pmmio->adwInfo[0],
				(LPSTR)lParam1) ? 0 : MMIOERR_FILENOTFOUND);
		}

		/* <lParam1> is either a file name or NULL; if it is
		 * NULL, then <adwInfo[0]>, which is actually <pInfo->fh>,
		 * should already contain an open DOS file handle.
		 * note that the low word of <dwFlags> is equivalent to
		 * the <wStyle> parameter of OpenFile()
		 */
		if (lParam1 != 0)
			pInfo->fh = OpenFile((LPSTR) lParam1, &of,
				    LOWORD(pmmio->dwFlags));
		if (pInfo->fh == HFILE_ERROR)
			return (LRESULT)(LONG) ((pmmio->dwFlags & MMIO_DELETE) ? MMIOERR_CANNOTWRITE : MMIOERR_FILENOTFOUND);

		/* if file is being deleted, there's nothing more to do */
		if (pmmio->dwFlags & MMIO_DELETE)
			return (LRESULT) 0;

		/* if file name is being parsed, translate to ansi */
		if (pmmio->dwFlags & (MMIO_PARSE | MMIO_EXIST))
		{
			OemToAnsi(of.szPathName, (LPSTR) lParam1);
			return (LRESULT) 0;
		}

		/* check the current file offset */
		pmmio->lDiskOffset = _llseek(pInfo->fh, 0L, SEEK_CUR);
		
		return (LRESULT) 0;

	case MMIOM_CLOSE:

		/* MMIO_FHOPEN flag means keep the DOS file handle open */
		if (!((DWORD)lParam1 & MMIO_FHOPEN) && (_lclose(pInfo->fh) == HFILE_ERROR))
			return (LRESULT) MMIOERR_CANNOTCLOSE;
		else
			return (LRESULT) 0;

        case MMIOM_READ:
                lResult = _hread(pInfo->fh, (LPVOID)lParam1, (LONG)lParam2);

                if (lResult != -1L)
                        pmmio->lDiskOffset += lResult;

                return (LRESULT) lResult;

	case MMIOM_WRITE:
	case MMIOM_WRITEFLUSH:
                lResult = _hwrite(pInfo->fh, (LPVOID)lParam1, (LONG)lParam2);

                if (lResult != -1L)
                        pmmio->lDiskOffset += lResult;

#ifdef DOSCANFLUSH
		if (wMsg == MMIOM_WRITEFLUSH)
		{
			/* Issue hardware flush command */
		}
#endif
                return (LRESULT) lResult;

        case MMIOM_SEEK:
                lResult = _llseek(pInfo->fh, (LONG)lParam1, (int)(LONG)lParam2);

                if (lResult != -1L)
                        pmmio->lDiskOffset = lResult;

                return (LRESULT) lResult;

	case MMIOM_RENAME:
		if (lrename((LPCSTR)lParam1, (LPCSTR)lParam2))
			return (LRESULT) MMIOERR_FILENOTFOUND;
		break;

	}

	return (LRESULT) 0;
}


/* @doc INTERNAL

@api	LRESULT | mmioMEMIOProc | The 'MEM' I/O procedure, which handles I/O
	on memory files.

@parm	LPSTR | lpmmioinfo | A pointer to an MMIOINFO block that
	contains information about the open file.

@parm	UINT | wMsg | The message that the I/O procedure is being
	asked to execute.

@parm	LPARAM | lParam1 | Specifies additional message information.

@parm	LPARAM | lParam2 | Specifies additional message information.

@rdesc	Return value depends on <p wMsg>.
*/
static LRESULT CALLBACK
mmioMEMIOProc(LPSTR lpmmioStr, UINT wMsg, LPARAM lParam1, LPARAM lParam2)
{
	PMMIO		pmmio = (PMMIO) (UINT) (LONG) lpmmioStr; // only in DLL!

	switch (wMsg)
	{

        case MMIOM_OPEN:

		if (pmmio->dwFlags & ~(MMIO_CREATE | MMIO_READWRITE | MMIO_WRITE | MMIO_EXCLUSIVE | MMIO_DENYWRITE | MMIO_DENYREAD | MMIO_DENYNONE | MMIO_ALLOCBUF))
			return (LRESULT) MMSYSERR_INVALFLAG;

		/* all the data in the buffer is valid */
		if (!(pmmio->dwFlags & MMIO_CREATE))
			pmmio->pchEndRead = pmmio->pchEndWrite;
		return (LRESULT) 0;

	case MMIOM_CLOSE:

		/* nothing special to do on close */
		return (LRESULT) 0;

	case MMIOM_READ:
	case MMIOM_WRITE:
	case MMIOM_WRITEFLUSH:
	case MMIOM_SEEK:
                return (LRESULT) -1;
	}

	return (LRESULT) 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\mmsystem\mixmgri.h ===
//==========================================================================;
//
//  mixmgri.h
//
//  Copyright (C) 1992-1993 Microsoft Corporation.  All Rights Reserved.
//
//  Description:
//      This header file contains INTERNAL Mixer Manager defines and stuff.
//
//  History:
//       6/27/93    cjp     [curtisp]
//
//==========================================================================;

#ifndef _INC_MIXMGRI
#define _INC_MIXMGRI                // #defined if file has been included

#ifndef RC_INVOKED
#pragma pack(1)                     // assume byte packing throughout
#endif

#ifndef EXTERN_C
#ifdef __cplusplus
    #define EXTERN_C extern "C"
#else
    #define EXTERN_C extern
#endif
#endif

#ifdef __cplusplus
extern "C"                          // assume C declarations for C++
{
#endif

#ifdef DEBUG
    #define RDEBUG
#endif


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;


//
//
//
//
#ifndef FIELD_OFFSET
    #define FIELD_OFFSET(type, field)    ((LONG)&(((type *)0)->field))
#endif



//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

//
//  WARNING DANGER WARNING DANGER WARNING DANGER WARNING DANGER WARNING
//
//  if you change the order of the following defines, you must also fix
//  gapszMxMgrFunctions[] in idrvinit.c!
//
//  WARNING DANGER WARNING DANGER WARNING DANGER WARNING DANGER WARNING
//

enum {
        MXMGRTHUNK_GETNUMDEVS      =    0,
#ifdef WIN32
        MXMGRTHUNK_GETDEVCAPSA           ,
        MXMGRTHUNK_GETDEVCAPS            ,
#else
        MXMGRTHUNK_GETDEVCAPS            ,
#endif // WIN32
        MXMGRTHUNK_GETID                 ,
        MXMGRTHUNK_OPEN                  ,
        MXMGRTHUNK_CLOSE                 ,
        MXMGRTHUNK_MESSAGE               ,
#ifdef WIN32
        MXMGRTHUNK_GETLINEINFOA          ,
        MXMGRTHUNK_GETLINEINFO           ,
        MXMGRTHUNK_GETLINECONTROLSA      ,
        MXMGRTHUNK_GETLINECONTROLS       ,
        MXMGRTHUNK_GETCONTROLDETAILSA    ,
        MXMGRTHUNK_GETCONTROLDETAILS     ,
#else
        MXMGRTHUNK_GETLINEINFO           ,
        MXMGRTHUNK_GETLINECONTROLS       ,
        MXMGRTHUNK_GETCONTROLDETAILS     ,
#endif // WIN32
        MXMGRTHUNK_SETCONTROLDETAILS     ,
        MXMGRTHUNK_MAX_FUNCTIONS
};


extern FARPROC  gafnMxMgrFunctions[];


//
//
//
//
UINT FNGLOBAL IMixerGetNumDevs
(
    void
);

MMRESULT FNGLOBAL IMixerGetDevCaps
(
    UINT                    uMxId,
    LPMIXERCAPS             pmxcaps,
    UINT                    cbmxcaps
);

#ifdef WIN32
MMRESULT FNGLOBAL IMixerGetDevCapsA
(
    UINT                    uMxId,
    LPMIXERCAPSA            pmxcaps,
    UINT                    cbmxcaps
);
#endif // WIN32

MMRESULT FNGLOBAL IMixerGetID
(
    HMIXEROBJ               hmxobj,
    UINT               FAR *puMxId,
    LPMIXERLINE             pmxl,
    DWORD                   fdwId
);

MMRESULT FNGLOBAL IMixerOpen
(
    LPHMIXER                phmx,
    UINT                    uMxId,
    DWORD                   dwCallback,
    DWORD                   dwInstance,
    DWORD                   fdwOpen
);

MMRESULT FNGLOBAL IMixerClose
(
    HMIXER                  hmx
);

DWORD FNGLOBAL IMixerMessage
(
    HMIXER                  hmx,
    UINT                    uMsg,
    DWORD                   dwParam1,
    DWORD                   dwParam2
);

MMRESULT FNGLOBAL IMixerGetLineInfo
(
    HMIXEROBJ               hmxobj,
    LPMIXERLINE             pmxl,
    DWORD                   fdwInfo
);

MMRESULT FNGLOBAL IMixerGetLineControls
(
    HMIXEROBJ               hmxobj,
    LPMIXERLINECONTROLS     pmxlc,
    DWORD                   fdwControls
);

MMRESULT FNGLOBAL IMixerGetControlDetails
(
    HMIXEROBJ               hmxobj,
    LPMIXERCONTROLDETAILS   pmxcd,
    DWORD                   fdwDetails
);

#ifdef WIN32
MMRESULT FNGLOBAL IMixerGetLineInfoA
(
    HMIXEROBJ               hmxobj,
    LPMIXERLINEA            pmxl,
    DWORD                   fdwInfo
);

MMRESULT FNGLOBAL IMixerGetLineControlsA
(
    HMIXEROBJ               hmxobj,
    LPMIXERLINECONTROLSA    pmxlc,
    DWORD                   fdwControls
);

MMRESULT FNGLOBAL IMixerGetControlDetailsA
(
    HMIXEROBJ               hmxobj,
    LPMIXERCONTROLDETAILS   pmxcd,
    DWORD                   fdwDetails
);
#endif // WIN32

MMRESULT FNGLOBAL IMixerSetControlDetails
(
    HMIXEROBJ               hmxobj,
    LPMIXERCONTROLDETAILS   pmxcd,
    DWORD                   fdwDetails
);



//
//
//
//
//
BOOL FNGLOBAL IMixerUnloadDrivers
(
    HDRVR           hdrvr
);

BOOL FNGLOBAL IMixerLoadDrivers
(
    HDRVR           hdrvr
);

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  -= Handles =-
//
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  No multi-thread synchronization for 16-bit
//

#define ENTER_MM_HANDLE(x) TRUE
#define LEAVE_MM_HANDLE(x)

#define MIXMGR_ENTER
#define MIXMGR_LEAVE


//
//  typedef for mxdMessage
//
typedef DWORD (CALLBACK *DRIVERMSGPROC)
(
    UINT            uId,
    UINT            uMsg,
    DWORD           dwInstance,
    DWORD           dwParam1,
    DWORD           dwParam2
);


EXTERN_C DWORD FNWCALLBACK mxdMessageHack
(
    UINT                    uDevId,
    UINT                    uMsg,
    DWORD                   dwUser,
    DWORD                   dwParam1,
    DWORD                   dwParam2
);



//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  -= Parameter Validation =-
//
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

//
//  No error logging for Win32
//

#ifdef WIN32
#define LogParamError(a, b, c)
#endif // WIN32
//
//
//
BOOL FNGLOBAL ValidateReadPointer(const void FAR* p, DWORD len);
BOOL FNGLOBAL ValidateWritePointer(const void FAR* p, DWORD len);
BOOL FNGLOBAL ValidateDriverCallback(DWORD dwCallback, UINT uFlags);
BOOL FNGLOBAL ValidateCallback(FARPROC lpfnCallback);
BOOL FNGLOBAL ValidateString(LPCSTR lsz, UINT cbMaxLen);

//
//  unless we decide differently, ALWAYS do parameter validation--even
//  in retail. this is the 'safest' thing we can do. note that we still
//  LOG parameter errors in retail (see prmvalXX).
//
#if 1

#define V_HANDLE(h, t, r)       { if (!ValidateHandle(h, t)) return (r); }
#define V_RPOINTER(p, l, r)     { if (!ValidateReadPointer((p), (l))) return (r); }
#define V_WPOINTER(p, l, r)     { if (!ValidateWritePointer((p), (l))) return (r); }
#define V_DCALLBACK(d, w, r)    { if (!ValidateDriverCallback((d), (w))) return (r); }
#define V_CALLBACK(f, r)        { if (!ValidateCallback(f)) return (r); }
#define V_STRING(s, l, r)       { if (!ValidateString(s,l)) return (r); }
#define V_DFLAGS(t, b, f, r)    { if ((t) & ~(b)) {LogParamError(ERR_BAD_DFLAGS, (FARPROC)(f), (LPVOID)(DWORD)(t)); return (r); }}
#define V_FLAGS(t, b, f, r)     { if ((t) & ~(b)) {LogParamError(ERR_BAD_FLAGS, (FARPROC)(f), (LPVOID)(DWORD)(t)); return (r); }}

#else

#define V_HANDLE(h, t, r)       { if (!(h)) return (r); }
#define V_RPOINTER(p, l, r)     { if (!(p)) return (r); }
#define V_WPOINTER(p, l, r)     { if (!(p)) return (r); }
#define V_DCALLBACK(d, w, r)    0
#define V_CALLBACK(f, r)        { if (!(f)) return (r); }
#define V_STRING(s, l, r)       { if (!(s)) return (r); }
#define V_DFLAGS(t, b, f, r)    { if ((t) & ~(b))  return (r); }
#define V_FLAGS(t, b, f, r)     { if ((t) & ~(b))  return (r); }

#endif


//
//  the DV_xxxx macros are for INTERNAL DEBUG builds--aid to debugging.
//  we do 'loose' parameter validation in retail and retail debug builds.
//
#ifdef DEBUG

#define DV_HANDLE(h, t, r)      V_HANDLE(h, t, r)
#define DV_RPOINTER(p, l, r)    V_RPOINTER(p, l, r)
#define DV_WPOINTER(p, l, r)    V_WPOINTER(p, l, r)
#define DV_DCALLBACK(d, w, r)   V_DCALLBACK(d, w, r)
#define DV_CALLBACK(f, r)       V_CALLBACK(f, r)
#define DV_STRING(s, l, r)      V_STRING(s, l, r)
#define DV_DFLAGS(t, b, f, r)   V_DFLAGS(t, b, f, r)
#define DV_FLAGS(t, b, f, r)    V_FLAGS(t, b, f, r)

#else

#define DV_HANDLE(h, t, r)      { if (!(h)) return (r); }
#define DV_RPOINTER(p, l, r)    { if (!(p)) return (r); }
#define DV_WPOINTER(p, l, r)    { if (!(p)) return (r); }
#define DV_DCALLBACK(d, w, r)   0
#define DV_CALLBACK(f, r)       { if (!(f)) return (r); }
#define DV_STRING(s, l, r)      { if (!(s)) return (r); }
#define DV_DFLAGS(t, b, f, r)   { if ((t) & ~(b))  return (r); }
#define DV_FLAGS(t, b, f, r)    { if ((t) & ~(b))  return (r); }

#endif


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#ifndef RC_INVOKED
#pragma pack()                      // revert to default packing
#endif

#ifdef __cplusplus
}                                   // end of extern "C" {
#endif

#endif // _INC_MIXMGRI
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\mmsystem\mixer.c ===
//==========================================================================;
//
//  mixapi.c
//
//  Copyright (C) 1992-1993 Microsoft Corporation.  All Rights Reserved.
//
//  Description:
//
//
//  History:
//       6/27/93    cjp     [curtisp]
//
//==========================================================================;
#define _WINDLL
#include <windows.h>
#include <windowsx.h>
#include <string.h>

#include <mmsystem.h>
#include <mmddk.h>

#include "mmreg.h"
#include "mmsysi.h"

//
//  fix a conflict will a bad define in MMREG.H that shipped with NT
//  the define is bad for some Media Vision things...
//
//  why not just build MSMIXMGR with a NEW mmreg.h??
//
#ifdef MIXERR_BASE
#undef MIXERR_BASE
#endif // MIXERR_BASE


#define _INC_MMDDK
#include "msmixmgr.y"


#define WODM_MAPPER_STATUS                  (0x2000)
#define WAVEOUT_MAPPER_STATUS_DEVICE        0
#define WIDM_MAPPER_STATUS                  (0x2000)
#define WAVEIN_MAPPER_STATUS_DEVICE         0

#include "idrv.h"
#include "mixmgri.h"
#include "debug.h"

UINT FAR PASCAL
mmCallProc32(
    DWORD uId,
    DWORD uMsg,
    DWORD dwInst,
    DWORD dwP1,
    DWORD dwP2,
    DRIVERMSGPROC fp,
    DWORD dwDirChange );

/* -------------------------------------------------------------------------
**  thunking global variables
** -------------------------------------------------------------------------
*/
DWORD   mix32Lib;

BOOL FAR PASCAL
InitMixerThunks(
    void
    );

DWORD CALLBACK
mxdMessage(
    UINT uId,
    UINT uMsg,
    DWORD dwInstance,
    DWORD dwParam1,
    DWORD dwParam2
    );

#define CHECK_AND_INIT_THUNKS( _x_ )            \
    if ( (_x_) == 0L ) {            \
        if ( InitMixerThunks() == FALSE ) {     \
            return MMSYSERR_NODRIVER;           \
        }                                       \
    }

UINT guTotalMixerDevs;              // total mixer devices
DRIVERMSGPROC mix32Message;
typedef MMDRV MIXERDRV, *PMIXERDRV;


//
//
//
typedef struct tMIXERDEV {
    UINT                uHandleType;    // for parameter validation

    struct tMIXERDEV   *pmxdevNext;     /* How quaint, a linked list... */
    PMIXERDRV           pmxdrv;
    UINT                wDevice;
    DWORD               dwDrvUser;
    UINT                uDeviceID;

    DWORD               fdwSupport;     // from the driver's mixercaps
    DWORD               cDestinations;  // from the driver's mixercaps

    DWORD               dwCallback;     // client's callback and inst data
    DWORD               dwInstance;

    DWORD               fdwOpen;        /* The open flags the caller used */
} MIXERDEV, *PMIXERDEV;

PMIXERDEV gpMixerDevHeader = NULL;      /* A LL of open devices */

//
//  mixer device driver list--add one to accomodate the MIXER_MAPPER. note
//  that even if we are not compiling with mapper support we need to add
//  one because other code relies on it (for other device mappers).
//
MIXERDRV        mixerdrv[1];




//==========================================================================;
//
//  Mixer API's
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//
//  DWORD IMixerMapId
//
//  Description:
//      This function maps a logical id to a device driver table index and
//      physical id.
//
//  Arguments:
//      PMIXERDRV pmxdrv: The array of mixer drivers.
//
//      UINT uTotalNumDevs: The total number of mixer devices.
//
//      UINT uId: The logical id to be mapped.
//
//  Return (DWORD):
//      The return value contains the dev[] array element id in the high word
//      and the driver physical device number in the low word.
//
//      Out of range values map to FFFF:FFFF
//
//  History:
//      03/17/93    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

DWORD NEAR PASCAL IMixerMapId(
    PMIXERDRV       pmxdrv,
    UINT            uTotalNumDevs,
    UINT            uId
)
{
    UINT    u;

#ifdef MIXER_MAPPER
    //
    //  the mapper is always the last element of the MIXERDEV array.
    //
    if (uId == MIXER_MAPPER)
        return (MAKELONG(0, MAXMIXERDRIVERS));
#endif

    if (uId >= uTotalNumDevs)
        return ((DWORD)-1);

#ifdef DEBUG_RETAIL
    if (fIdReverse)
        uId = uTotalNumDevs - 1 - uId;
#endif

    for (u = 0; u < MAXMIXERDRIVERS; u++)
    {
        if (pmxdrv[u].bNumDevs > (BYTE)uId)
            return (MAKELONG(uId, u));

        uId -= pmxdrv[u].bNumDevs;
    }

    return ((DWORD)-1);
} // IMixerMapId()


//--------------------------------------------------------------------------;
//
//  DWORD IMixerMessageHandle
//
//  Description:
//
//
//  Arguments:
//      HMIXER hmx:
//
//      UINT uMsg:
//
//      DWORD dwP1:
//
//      DWORD dwP2:
//
//  Return (DWORD):
//
//  History:
//      03/17/93    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

DWORD NEAR PASCAL IMixerMessageHandle(
    HMIXER          hmx,
    UINT            uMsg,
    DWORD           dwP1,
    DWORD           dwP2
)
{
    PMIXERDEV   pmxd;
    DWORD       dwRc;

    pmxd = (PMIXERDEV)hmx;

    dwRc = ((*(pmxd->pmxdrv->drvMessage))
             (pmxd->wDevice, uMsg, pmxd->dwDrvUser, dwP1, dwP2));

    return dwRc;
} // IMixerMessageHandle()


//--------------------------------------------------------------------------;
//
//  DWORD IMixerMessageId
//
//  Description:
//
//
//  Arguments:
//      PMIXERDRV pmxdrv:
//
//      UINT uTotalNumDevs:
//
//      UINT uDeviceID:
//
//      UINT uMsg:
//
//      DWORD dwParam1:
//
//      DWORD dwParam2:
//
//  Return (DWORD):
//
//  History:
//      03/17/93    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

DWORD NEAR PASCAL IMixerMessageId(
    PMIXERDRV       pmxdrv,
    UINT            uTotalNumDevs,
    UINT            uDeviceID,
    UINT            uMsg,
    DWORD           dwParam1,
    DWORD           dwParam2
)
{
    DWORD   dwMap;
    DWORD   dwRc;

    dwMap = IMixerMapId(pmxdrv, uTotalNumDevs, uDeviceID);

    if (dwMap == (DWORD)-1)
        return (MMSYSERR_BADDEVICEID);

    pmxdrv = (PMIXERDRV)&pmxdrv[HIWORD(dwMap)];
    if (!pmxdrv->drvMessage)
        return (MMSYSERR_NODRIVER);

    dwRc = ((*(pmxdrv->drvMessage))
            ((UINT)dwMap, uMsg, 0L, dwParam1, dwParam2));

    return dwRc;

} // IMixerMessageId()

/******************************Public*Routine******************************\
* mixerGetNumDevs
*
*
*
* History:
* dd-mm-93 - StephenE - Created
*
\**************************************************************************/
UINT MIXAPI mixerGetNumDevs(
    void
)
{

    CHECK_AND_INIT_THUNKS(mix32Lib);

    return guTotalMixerDevs;
}



/******************************Public*Routine******************************\
* mixerGetDevCaps
*
*
*
* History:
* dd-mm-93 - StephenE - Created
*
\**************************************************************************/
MMRESULT MIXAPI mixerGetDevCaps(
    UINT                    uMxId,
    LPMIXERCAPS             pmxcaps,
    UINT                    cbmxcaps
)
{

    MMRESULT mmr;
    CHECK_AND_INIT_THUNKS(mix32Lib);

    if (0 == cbmxcaps)
        return (MMSYSERR_NOERROR);

    V_WPOINTER(pmxcaps, cbmxcaps, MMSYSERR_INVALPARAM);

    if (uMxId >= MAXMIXERDRIVERS)
    {
        V_HANDLE((HMIXER)uMxId, TYPE_MIXER, MMSYSERR_INVALHANDLE);

        mmr = (MMRESULT)IMixerMessageHandle((HMIXER)uMxId,
                                           MXDM_GETDEVCAPS,
                                           (DWORD)pmxcaps,
                                           (DWORD)cbmxcaps);
    }
    else
    {
        if (uMxId >= guTotalMixerDevs)
        {
            DebugErr1(DBF_ERROR, "mixerGetDevCaps: mixer device id is out of range (%u).", uMxId);
            return (MMSYSERR_BADDEVICEID);
        }

        mmr = (MMRESULT)IMixerMessageId(mixerdrv,
                                       guTotalMixerDevs,
                                       uMxId,
                                       MXDM_GETDEVCAPS,
                                       (DWORD)pmxcaps,
                                       (DWORD)cbmxcaps);
    }
    return mmr;
}



/******************************Public*Routine******************************\
* mixerGetID
*
*
*
* History:
* dd-mm-93 - StephenE - Created
*
\**************************************************************************/
MMRESULT MIXAPI mixerGetID(
    HMIXEROBJ               hmxobj,
    UINT               FAR *puMxId,
    DWORD                   fdwId
)
{
    CHECK_AND_INIT_THUNKS(mix32Lib);
    return IMixerGetID( hmxobj, puMxId, NULL, fdwId );
}


/*****************************Private*Routine******************************\
* IMixerGetID
*
*
*
* History:
* dd-mm-93 - StephenE - Created
*
\**************************************************************************/
MMRESULT FNGLOBAL IMixerGetID(
    HMIXEROBJ           hmxobj,
    UINT           FAR *puMxId,
    LPMIXERLINE         pmxl,
    DWORD               fdwId
)
{
    MMRESULT        mmr;
    MIXERLINE       mxl;
    UINT            u;

    V_DFLAGS(fdwId, MIXER_GETIDF_VALID, IMixerGetID, MMSYSERR_INVALFLAG);
    V_WPOINTER(puMxId, sizeof(UINT), MMSYSERR_INVALPARAM);


    //
    //  set to '-1' which would be the mixer mapper (if there was one)
    //  this way we will definitely fail any calls made on this id if
    //  this function fails and the caller doesn't check his return value.
    //
    *puMxId = (UINT)-1;


    //
    //
    //
    switch (MIXER_OBJECTF_TYPEMASK & fdwId)
    {
        case MIXER_OBJECTF_MIXER:
        case MIXER_OBJECTF_HMIXER:
            if ((UINT)hmxobj > MAXMIXERDRIVERS)
            {
                V_HANDLE(hmxobj, TYPE_MIXER, MMSYSERR_INVALHANDLE);

                *puMxId = ((PMIXERDEV)hmxobj)->uDeviceID;
                return (MMSYSERR_NOERROR);
            }

            if ((UINT)hmxobj >= guTotalMixerDevs)
            {
                DebugErr1(DBF_ERROR, "mixerGetID: mixer device id is out of range (%u).", hmxobj);
                return (MMSYSERR_BADDEVICEID);
            }

            *puMxId = (UINT)hmxobj;
            return (MMSYSERR_NOERROR);


        case MIXER_OBJECTF_HWAVEOUT:
        {
            UINT        uId;
            DWORD       dwId;

            mmr = waveOutGetID((HWAVEOUT)hmxobj, &uId);
            if (MMSYSERR_NOERROR != mmr)
            {
                return (MMSYSERR_INVALHANDLE);
            }

            if (WAVE_MAPPER == uId)
            {
                mmr = (MMRESULT)waveOutMessage((HWAVEOUT)hmxobj,
                                               WODM_MAPPER_STATUS,
                                               WAVEOUT_MAPPER_STATUS_DEVICE,
                                               (DWORD)(LPVOID)&dwId);

                if (MMSYSERR_NOERROR == mmr)
                {
                    uId = (UINT)dwId;
                }
            }

            hmxobj = (HMIXEROBJ)uId;
        }

        case MIXER_OBJECTF_WAVEOUT:
        {
            WAVEOUTCAPS     woc;

            mmr = waveOutGetDevCaps((UINT)hmxobj, &woc, sizeof(woc));
            if (MMSYSERR_NOERROR != mmr)
                return (MMSYSERR_BADDEVICEID);

            woc.szPname[SIZEOF(woc.szPname) - 1] = '\0';

            mxl.Target.dwType         = MIXERLINE_TARGETTYPE_WAVEOUT;
            mxl.Target.dwDeviceID     = (UINT)hmxobj;
            mxl.Target.wMid           = woc.wMid;
            mxl.Target.wPid           = woc.wPid;
            mxl.Target.vDriverVersion = woc.vDriverVersion;
            lstrcpy(mxl.Target.szPname, woc.szPname);
            break;
        }


        case MIXER_OBJECTF_HWAVEIN:
        {
            UINT        uId;
            DWORD       dwId;

            mmr = waveInGetID((HWAVEIN)hmxobj, &uId);
            if (MMSYSERR_NOERROR != mmr)
            {
                return (MMSYSERR_INVALHANDLE);
            }

            if (WAVE_MAPPER == uId)
            {
                mmr = (MMRESULT)waveInMessage((HWAVEIN)hmxobj,
                                              WIDM_MAPPER_STATUS,
                                              WAVEIN_MAPPER_STATUS_DEVICE,
                                              (DWORD)(LPVOID)&dwId);

                if (MMSYSERR_NOERROR == mmr)
                {
                    uId = (UINT)dwId;
                }
            }

            hmxobj = (HMIXEROBJ)uId;
        }

        case MIXER_OBJECTF_WAVEIN:
        {
            WAVEINCAPS      wic;

            mmr = waveInGetDevCaps((UINT)hmxobj, &wic, sizeof(wic));
            if (MMSYSERR_NOERROR != mmr)
                return (MMSYSERR_BADDEVICEID);

            wic.szPname[SIZEOF(wic.szPname) - 1] = '\0';

            mxl.Target.dwType         = MIXERLINE_TARGETTYPE_WAVEIN;
            mxl.Target.dwDeviceID     = (UINT)hmxobj;
            mxl.Target.wMid           = wic.wMid;
            mxl.Target.wPid           = wic.wPid;
            mxl.Target.vDriverVersion = wic.vDriverVersion;
            lstrcpy(mxl.Target.szPname, wic.szPname);
            break;
        }


        case MIXER_OBJECTF_HMIDIOUT:
            mmr = midiOutGetID((HMIDIOUT)hmxobj, (UINT FAR *)&hmxobj);
            if (MMSYSERR_NOERROR != mmr)
                return (MMSYSERR_INVALHANDLE);

        case MIXER_OBJECTF_MIDIOUT:
        {
            MIDIOUTCAPS     moc;

            mmr = midiOutGetDevCaps((UINT)hmxobj, &moc, sizeof(moc));
            if (MMSYSERR_NOERROR != mmr)
                return (MMSYSERR_BADDEVICEID);

            moc.szPname[SIZEOF(moc.szPname) - 1] = '\0';

            mxl.Target.dwType         = MIXERLINE_TARGETTYPE_MIDIOUT;
            mxl.Target.dwDeviceID     = (UINT)hmxobj;
            mxl.Target.wMid           = moc.wMid;
            mxl.Target.wPid           = moc.wPid;
            mxl.Target.vDriverVersion = moc.vDriverVersion;
            lstrcpy(mxl.Target.szPname, moc.szPname);
            break;
        }


        case MIXER_OBJECTF_HMIDIIN:
            mmr = midiInGetID((HMIDIIN)hmxobj, (UINT FAR *)&hmxobj);
            if (MMSYSERR_NOERROR != mmr)
                return (MMSYSERR_INVALHANDLE);

        case MIXER_OBJECTF_MIDIIN:
        {
            MIDIINCAPS      mic;

            mmr = midiInGetDevCaps((UINT)hmxobj, &mic, sizeof(mic));
            if (MMSYSERR_NOERROR != mmr)
                return (MMSYSERR_BADDEVICEID);

            mic.szPname[SIZEOF(mic.szPname) - 1] = '\0';

            mxl.Target.dwType         = MIXERLINE_TARGETTYPE_MIDIIN;
            mxl.Target.dwDeviceID     = (UINT)hmxobj;
            mxl.Target.wMid           = mic.wMid;
            mxl.Target.wPid           = mic.wPid;
            mxl.Target.vDriverVersion = mic.vDriverVersion;
            lstrcpy(mxl.Target.szPname, mic.szPname);
            break;
        }


        case MIXER_OBJECTF_AUX:
        {
            AUXCAPS         ac;

            mmr = auxGetDevCaps((UINT)hmxobj, &ac, sizeof(ac));
            if (MMSYSERR_NOERROR != mmr)
                return (MMSYSERR_BADDEVICEID);

            ac.szPname[SIZEOF(ac.szPname) - 1] = '\0';

            mxl.Target.dwType         = MIXERLINE_TARGETTYPE_AUX;
            mxl.Target.dwDeviceID     = (UINT)hmxobj;
            mxl.Target.wMid           = ac.wMid;
            mxl.Target.wPid           = ac.wPid;
            mxl.Target.vDriverVersion = ac.vDriverVersion;
            lstrcpy(mxl.Target.szPname, ac.szPname);
            break;
        }

        default:
            DebugErr1(DBF_ERROR, "mixerGetID: unknown mixer object flag (%.08lXh).",
                        MIXER_OBJECTF_TYPEMASK & fdwId);
            return (MMSYSERR_INVALFLAG);
    }


    //
    //
    //
    //
    mxl.cbStruct        = sizeof(mxl);
    mxl.dwDestination   = (DWORD)-1L;
    mxl.dwSource        = (DWORD)-1L;
    mxl.dwLineID        = (DWORD)-1L;
    mxl.fdwLine         = 0;
    mxl.dwUser          = 0;
    mxl.dwComponentType = (DWORD)-1L;
    mxl.cChannels       = 0;
    mxl.cConnections    = 0;
    mxl.cControls       = 0;
    mxl.szShortName[0]  = '\0';
    mxl.szName[0]       = '\0';


    for (u = 0; u < guTotalMixerDevs; u++)
    {
        mmr = (MMRESULT)IMixerMessageId(mixerdrv,
                                        guTotalMixerDevs,
                                        u,
                                        MXDM_GETLINEINFO,
                                        (DWORD)(LPVOID)&mxl,
                                        M_GLINFOF_TARGETTYPE);

        if (MMSYSERR_NOERROR == mmr)
        {
            *puMxId = u;

            if (NULL != pmxl)
            {
                DWORD       cbStruct;

                cbStruct = pmxl->cbStruct;

                _fmemcpy(pmxl, &mxl, (UINT)cbStruct);

                pmxl->cbStruct = cbStruct;
            }

            return (mmr);
        }
    }

    return (MMSYSERR_NODRIVER);
} // IMixerGetID()


/******************************Public*Routine******************************\
* mixerOpen
*
*
*
* History:
* dd-mm-93 - StephenE - Created
*
\**************************************************************************/
MMRESULT MIXAPI mixerOpen(
    LPHMIXER                phmx,
    UINT                    uMxId,
    DWORD                   dwCallback,
    DWORD                   dwInstance,
    DWORD                   fdwOpen
)
{
    MMRESULT        mmr;
    DWORD           dwMap;
    PMIXERDRV       pmxdrv;
    PMIXERDEV       pmxdev;
    MIXEROPENDESC   mxod;
    DWORD           dwDrvUser;
    MIXERCAPS       mxcaps;


    CHECK_AND_INIT_THUNKS(mix32Lib);

    //
    //
    //
    V_WPOINTER(phmx, sizeof(HMIXER), MMSYSERR_INVALPARAM);

    *phmx = NULL;

    //
    //  Don't allow callback functions - they're not useful and they
    //  cause headaches.   Specifically for Windows NT the only way
    //  to cause an asynchronous callback to 16-bit land from a 32-bit DLL
    //  is to cause an interrupt but we don't want to require mixer stuff
    //  to be locked down to allow for this.
    //

    if ((fdwOpen & CALLBACK_TYPEMASK) == CALLBACK_FUNCTION)
    {
        DebugErr(DBF_ERROR, "mixerOpen: CALLBACK_FUNCTION is not supported");
        return MMSYSERR_INVALFLAG;
    }

    V_DCALLBACK(dwCallback, HIWORD(fdwOpen & CALLBACK_TYPEMASK), MMSYSERR_INVALPARAM);
    V_DFLAGS(fdwOpen, MIXER_OPENF_VALID, mixerOpen, MMSYSERR_INVALFLAG);

    mmr = IMixerGetID((HMIXEROBJ)uMxId, &uMxId, NULL, (MIXER_OBJECTF_TYPEMASK & fdwOpen));
    if (MMSYSERR_NOERROR != mmr)
        return (mmr);


    //
    //
    //
    //
    dwMap = IMixerMapId(mixerdrv, guTotalMixerDevs, uMxId);
    if ((DWORD)-1 == dwMap)
        return (MMSYSERR_BADDEVICEID);

    pmxdrv = &mixerdrv[HIWORD(dwMap)];

#ifdef MIXER_MAPPER
    //
    //  Default Mixer Mapper:
    //
    //  If a mixer mapper is installed as a separate DLL then all mixer
    //  mapper messages are routed to it. If no mixer mapper is installed,
    //  simply loop through the mixer devices looking for a match.
    //
    if ((MIXER_MAPPER == uMxId) && (NULL == pmxdrv->drvMessage))
    {
        for (uMxId = 0; uMxId < guTotalMixerDevs; uMxId++)
        {
            // try to open it
            if (MMSYSERR_NOERROR == mmr)
                break;

        }

        return (mmr);
    }
#endif


    //
    // Get some memory for the dev structure
    //
    pmxdev = (PMIXERDEV)NewHandle(TYPE_MIXER, sizeof(MIXERDEV));
    if (NULL == pmxdev)
    {
       return (MMSYSERR_NOMEM);
    }

    //
    //  initialize our open instance struct for the client
    //
    pmxdev->uHandleType = TYPE_MIXER;
    pmxdev->pmxdrv      = pmxdrv;
    pmxdev->wDevice     = LOWORD(dwMap);
    pmxdev->uDeviceID   = uMxId;

    //
    //  save the client's callback info
    //
    pmxdev->dwCallback  = dwCallback;
    pmxdev->dwInstance  = dwInstance;
    pmxdev->fdwOpen     = fdwOpen;


    //
    //  this should probably be done when the driver is booted.. can change
    //  this later..
    //
    mmr = mixerGetDevCaps(uMxId, &mxcaps, sizeof(mxcaps));
    if (MMSYSERR_NOERROR != mmr)
    {
        DPF((0, "!mixerOpen() failing because mixerGetDevCaps() failed!"));

        FreeHandle((HMIXER)pmxdev);
        return (mmr);
    }

    //
    //  cache some stuff for parameter validation
    //
    pmxdev->fdwSupport    = mxcaps.fdwSupport;
    pmxdev->cDestinations = mxcaps.cDestinations;


    //
    // If we get here, no one has the device currently open.  Let's
    // go open it, then.
    //

    //
    // Load up our local MIXEROPENDESC struct
    //

    mxod.hmx         = (HMIXER)pmxdev;
    mxod.pReserved0  = (LPVOID)(fdwOpen & ~MIXER_OBJECTF_TYPEMASK);
    mxod.dwCallback  = dwCallback;
    mxod.dwInstance  = dwInstance;
    mmr = (MMRESULT)((*(pmxdrv->drvMessage))(LOWORD(dwMap),
                                             MXDM_OPEN,
                                             (DWORD)(LPDWORD)&dwDrvUser,
                                             (DWORD)(LPVOID)&mxod,
                                             (DWORD)uMxId ));


    if (MMSYSERR_NOERROR != mmr)
    {
        FreeHandle((HMIXER)pmxdev);
    }
    else
    {
        pmxdrv->bUsage++;
        pmxdev->dwDrvUser = dwDrvUser;
        *phmx = (HMIXER)pmxdev;

        //
        // Put this new device into the devlist chain.
        //

        MIXMGR_ENTER;

        pmxdev->pmxdevNext = gpMixerDevHeader;
        gpMixerDevHeader = pmxdev;

        MIXMGR_LEAVE;
    }
    return mmr;
}


/******************************Public*Routine******************************\
* mixerClose
*
*
*
* History:
* dd-mm-93 - StephenE - Created
*
\**************************************************************************/
MMRESULT MIXAPI mixerClose(
    HMIXER                  hmx
)
{
    MMRESULT    mmr;
    PMIXERDEV   pmxdev;
    PMIXERDEV   pmxdevT;

    CHECK_AND_INIT_THUNKS(mix32Lib);
    V_HANDLE(hmx, TYPE_MIXER, MMSYSERR_INVALHANDLE);


    //
    //  if last open instance, then close it
    //
    mmr = (MMRESULT)IMixerMessageHandle(hmx, MXDM_CLOSE, 0L, 0L);

    if (MMSYSERR_NOERROR != mmr)
        return (mmr);


    //
    //  remove the mixer handle from the linked list
    //

    MIXMGR_ENTER;

    pmxdev = (PMIXERDEV)hmx;
    if (pmxdev == gpMixerDevHeader)
    {
        gpMixerDevHeader = pmxdev->pmxdevNext;
    }
    else
    {
        for (pmxdevT = gpMixerDevHeader;
             pmxdevT && (pmxdevT->pmxdevNext != pmxdev);
             pmxdevT = pmxdevT->pmxdevNext)
            ;

        if (NULL == pmxdevT)
        {
            DebugErr1(DBF_ERROR, "mixerClose: invalid mixer handle (%.04Xh).", hmx);
            return (MMSYSERR_INVALHANDLE);
        }

        pmxdevT->pmxdevNext = pmxdev->pmxdevNext;
    }

    MIXMGR_LEAVE;

    //
    //  dec usage count
    //
    pmxdev->pmxdrv->bUsage--;


    //
    //  we're done with the memory block. now free the memory and return.
    //
    FreeHandle(hmx);
    return mmr;
}


/******************************Public*Routine******************************\
* mixerMessage
*
*
*
* History:
* dd-mm-93 - StephenE - Created
*
\**************************************************************************/
DWORD MIXAPI mixerMessage(
    HMIXER                  hmx,
    UINT                    uMsg,
    DWORD                   dwParam1,
    DWORD                   dwParam2
)
{
    DWORD       dw;

    CHECK_AND_INIT_THUNKS(mix32Lib);
    V_HANDLE(hmx, TYPE_MIXER, MMSYSERR_INVALHANDLE);

    //
    //  don't allow any non-user range messages through this API
    //
    if (MXDM_USER > uMsg)
    {
        DebugErr1(DBF_ERROR, "mixerMessage: message must be in MXDM_USER range--what's this (%u)?", uMsg);
        return (MMSYSERR_INVALPARAM);
    }


    dw = IMixerMessageHandle(hmx, uMsg, dwParam1, dwParam2);
    return dw;
}


//--------------------------------------------------------------------------;
//
//  BOOL IMixerIsValidComponentType
//
//  Description:
//
//
//  Arguments:
//      DWORD dwComponentType:
//
//      UINT uSrcDst:
//
//  Return (BOOL):
//
//  History:
//      10/06/93    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

BOOL FNLOCAL IMixerIsValidComponentType(
    DWORD           dwComponentType,
    DWORD           fdwLine
)
{

    if (0L == (MIXERLINE_LINEF_SOURCE & fdwLine))
    {
        if (dwComponentType > MLCT_DST_LAST)
            return (FALSE);

        return (TRUE);
    }
    else
    {
        if (dwComponentType < MLCT_SRC_FIRST)
            return (FALSE);

        if (dwComponentType > MLCT_SRC_LAST)
            return (FALSE);

        return (TRUE);
    }

    return (FALSE);
} // IMixerIsValidComponentType()



/******************************Public*Routine******************************\
* mixerGetLineInfo
*
*
*
* History:
* dd-mm-93 - StephenE - Created
*
\**************************************************************************/
MMRESULT MIXAPI mixerGetLineInfo(
    HMIXEROBJ               hmxobj,
    LPMIXERLINE             pmxl,
    DWORD                   fdwInfo
)
{
    DWORD               fdwMxObjType;
    MMRESULT            mmr;
    PMIXERDEV           pmxdev;
    UINT                uMxId;
    BOOL                fSourceLine;

    CHECK_AND_INIT_THUNKS(mix32Lib);

    V_DFLAGS(fdwInfo, M_GLINFOF_VALID, mixerGetLineInfo, MMSYSERR_INVALFLAG);
    V_WPOINTER(pmxl, sizeof(DWORD), MMSYSERR_INVALPARAM);
    if (sizeof(MIXERLINE) > (UINT)pmxl->cbStruct)
    {
        DebugErr1(DBF_ERROR, "mixerGetLineInfo: structure size too small or cbStruct not initialized (%lu).", pmxl->cbStruct);
        return (MMSYSERR_INVALPARAM);
    }
    V_WPOINTER(pmxl, pmxl->cbStruct, MMSYSERR_INVALPARAM);


    //
    //
    //
    fSourceLine = FALSE;
    switch (fdwInfo & M_GLINFOF_QUERYMASK)
    {
        case M_GLINFOF_DESTINATION:
            pmxl->dwSource        = (DWORD)-1L;
            pmxl->dwLineID        = (DWORD)-1L;
            pmxl->dwComponentType = (DWORD)-1L;
            break;

        case M_GLINFOF_SOURCE:
            fSourceLine = TRUE;
            pmxl->dwLineID        = (DWORD)-1L;
            pmxl->dwComponentType = (DWORD)-1L;
            break;

        case M_GLINFOF_LINEID:
            pmxl->dwSource        = (DWORD)-1L;
            pmxl->dwDestination   = (DWORD)-1L;
            pmxl->dwComponentType = (DWORD)-1L;
            break;

        case M_GLINFOF_COMPONENTTYPE:
            pmxl->dwSource        = (DWORD)-1L;
            pmxl->dwDestination   = (DWORD)-1L;
            pmxl->dwLineID        = (DWORD)-1L;

            if (!IMixerIsValidComponentType(pmxl->dwComponentType, 0) &&
                !IMixerIsValidComponentType(pmxl->dwComponentType, MIXERLINE_LINEF_SOURCE))
            {
                DebugErr1(DBF_ERROR, "mixerGetLineInfo: invalid dwComponentType (%lu).", pmxl->dwComponentType);
                return (MMSYSERR_INVALPARAM);
            }
            break;

        case M_GLINFOF_TARGETTYPE:
            pmxl->dwSource        = (DWORD)-1L;
            pmxl->dwDestination   = (DWORD)-1L;
            pmxl->dwLineID        = (DWORD)-1L;
            pmxl->dwComponentType = (DWORD)-1L;

            if ((DWORD)MIXERLINE_TARGETTYPE_AUX < pmxl->Target.dwType)
            {
                DebugErr1(DBF_ERROR, "mixerGetLineInfo: invalid Target.dwType (%lu).", pmxl->Target.dwType);
                return (MMSYSERR_INVALPARAM);
            }
            break;

        default:
            DebugErr1(DBF_ERROR, "mixerGetLineInfo: invalid query flag (%.08lXh).",
                        fdwInfo & M_GLINFOF_QUERYMASK);
            return (MMSYSERR_INVALFLAG);
    }



    //
    //
    //
    fdwMxObjType = (MIXER_OBJECTF_TYPEMASK & fdwInfo);

    mmr = IMixerGetID(hmxobj, &uMxId, pmxl, fdwMxObjType);
    if (MMSYSERR_NOERROR != mmr)
    {
        DPF((0, "!IMixerGetLineInfo: IMixerGetID() failed!"));
        return (mmr);
    }

    if ((MIXER_OBJECTF_MIXER  == fdwMxObjType) ||
        (MIXER_OBJECTF_HMIXER == fdwMxObjType))
    {
        //
        //  if a mixer device id was passed, then null hmx so we use the
        //  correct message sender below
        //
        if ((UINT)hmxobj == uMxId)
            hmxobj = NULL;
    }
    else
    {
        return (MMSYSERR_NOERROR);
    }


    //
    //  clear all fields before calling driver
    //
    if (NULL != hmxobj)
    {
        //
        //
        //
        pmxdev = (PMIXERDEV)hmxobj;
#if 0
        if (pmxdev->cDestinations <= pmxl->dwDestination)
        {
            DebugErr1(DBF_ERROR, "mixerGetLineInfo: invalid destination index (%lu).", pmxl->dwDestination);
            return (MMSYSERR_INVALPARAM);
        }
#endif

        mmr = (MMRESULT)IMixerMessageHandle((HMIXER)hmxobj,
                                            MXDM_GETLINEINFO,
                                            (DWORD)(LPVOID)pmxl,
                                            fdwInfo);
    }
    else
    {
#pragma message("----IMixerGetLineInfo: dwDestination not validated for ID's!!")
        mmr = (MMRESULT)IMixerMessageId(mixerdrv,
                                        guTotalMixerDevs,
                                        uMxId,
                                        MXDM_GETLINEINFO,
                                        (DWORD)(LPVOID)pmxl,
                                        fdwInfo);
    }

    if (MMSYSERR_NOERROR != mmr)
        return (mmr);

#pragma message("----IMixerGetLineInfo: should validate mixer driver didn't hose us!")


    //
    //  validate the driver's returned stuff...
    //
    //
    if (sizeof(MIXERLINE) != (UINT)pmxl->cbStruct)
    {
        DebugErr1(DBF_ERROR, "mixerGetLineInfo: buggy driver returned invalid cbStruct (%lu).", pmxl->cbStruct);
        pmxl->cbStruct = sizeof(MIXERLINE);
    }

    if ((DWORD)-1L == pmxl->dwDestination)
    {
        DebugErr(DBF_ERROR, "mixerGetLineInfo: buggy driver failed to init dwDestination member.");
    }
    if (fSourceLine)
    {
        if (0L == (MIXERLINE_LINEF_SOURCE & pmxl->fdwLine))
        {
            DebugErr(DBF_ERROR, "mixerGetLineInfo: buggy driver failed to set MIXERLINE_LINEF_SOURCE.");
            pmxl->fdwLine |= MIXERLINE_LINEF_SOURCE;
        }

        if ((DWORD)-1L == pmxl->dwSource)
        {
            DebugErr(DBF_ERROR, "mixerGetLineInfo: buggy driver failed to init dwSource member.");
        }
    }
    if ((DWORD)-1L == pmxl->dwLineID)
    {
        DebugErr(DBF_ERROR, "mixerGetLineInfo: buggy driver failed to init dwLineID member.");
    }
    if (pmxl->fdwLine & ~0x80008001L)
    {
        DebugErr1(DBF_ERROR, "mixerGetLineInfo: buggy driver set reserved line flags (%.08lXh)!", pmxl->fdwLine);
        pmxl->fdwLine &= 0x80008001L;
    }
    if (!IMixerIsValidComponentType(pmxl->dwComponentType, pmxl->fdwLine))
    {
        DebugErr1(DBF_ERROR, "mixerGetLineInfo: buggy driver returned invalid dwComponentType (%.08lXh).", pmxl->dwComponentType);
        pmxl->dwComponentType = MIXERLINE_TARGETTYPE_UNDEFINED;
    }
    if (0L == pmxl->cChannels)
    {
        DebugErr(DBF_ERROR, "mixerGetLineInfo: buggy driver returned zero channels?!?");
        pmxl->cChannels = 1;
    }
    if (fSourceLine)
    {
        if (0L != pmxl->cConnections)
        {
            DebugErr(DBF_ERROR, "mixerGetLineInfo: buggy driver returned non-zero connections on source?!?");
            pmxl->cConnections = 0;
        }
    }

    pmxl->szShortName[SIZEOF(pmxl->szShortName) - 1] = '\0';
    pmxl->szName[SIZEOF(pmxl->szName) - 1] = '\0';


    //
    // Does this really need to be done if TARGETTYPE was requested?
    //


    //
    //
    //
    if ((DWORD)MIXERLINE_TARGETTYPE_UNDEFINED != pmxl->Target.dwType)
    {
        UINT        u;

        pmxl->Target.dwDeviceID = (DWORD)-1L;


        //
        //  we have a wMid, wPid and szPname (supposedly) of type dwType
        //  so let's go find it...
        //
        switch (pmxl->Target.dwType)
        {
            case MIXERLINE_TARGETTYPE_WAVEOUT:
                u = waveOutGetNumDevs();
                while (u--)
                {
                    WAVEOUTCAPS     woc;

                    mmr = waveOutGetDevCaps(u, &woc, sizeof(woc));
                    if (MMSYSERR_NOERROR != mmr)
                        continue;

                    woc.szPname[SIZEOF(woc.szPname) - 1] = '\0';

                    if (woc.wMid != pmxl->Target.wMid)
                        continue;

                    if (woc.wPid != pmxl->Target.wPid)
                        continue;

                    if (woc.vDriverVersion != pmxl->Target.vDriverVersion)
                        continue;

                    if (lstrcmp(woc.szPname, pmxl->Target.szPname))
                        continue;

                    pmxl->Target.dwDeviceID = u;
                    break;
                }
                break;

            case MIXERLINE_TARGETTYPE_WAVEIN:
                u = waveInGetNumDevs();
                while (u--)
                {
                    WAVEINCAPS      wic;

                    mmr = waveInGetDevCaps(u, &wic, sizeof(wic));
                    if (MMSYSERR_NOERROR != mmr)
                        continue;

                    wic.szPname[SIZEOF(wic.szPname) - 1] = '\0';

                    if (wic.wMid != pmxl->Target.wMid)
                        continue;

                    if (wic.wPid != pmxl->Target.wPid)
                        continue;

                    if (wic.vDriverVersion != pmxl->Target.vDriverVersion)
                        continue;

                    if (lstrcmp(wic.szPname, pmxl->Target.szPname))
                        continue;

                    pmxl->Target.dwDeviceID = u;
                    break;
                }
                break;

            case MIXERLINE_TARGETTYPE_MIDIOUT:
                u = midiOutGetNumDevs();
                while (u--)
                {
                    MIDIOUTCAPS     moc;

                    mmr = midiOutGetDevCaps(u, &moc, sizeof(moc));
                    if (MMSYSERR_NOERROR != mmr)
                        continue;

                    moc.szPname[SIZEOF(moc.szPname) - 1] = '\0';

                    if (moc.wMid != pmxl->Target.wMid)
                        continue;

                    if (moc.wPid != pmxl->Target.wPid)
                        continue;

                    if (moc.vDriverVersion != pmxl->Target.vDriverVersion)
                        continue;

                    if (lstrcmp(moc.szPname, pmxl->Target.szPname))
                        continue;

                    pmxl->Target.dwDeviceID = u;
                    break;
                }
                break;

            case MIXERLINE_TARGETTYPE_MIDIIN:
                u = midiInGetNumDevs();
                while (u--)
                {
                    MIDIINCAPS      mic;

                    mmr = midiInGetDevCaps(u, &mic, sizeof(mic));
                    if (MMSYSERR_NOERROR != mmr)
                        continue;

                    mic.szPname[SIZEOF(mic.szPname) - 1] = '\0';

                    if (mic.wMid != pmxl->Target.wMid)
                        continue;

                    if (mic.wPid != pmxl->Target.wPid)
                        continue;

                    if (mic.vDriverVersion != pmxl->Target.vDriverVersion)
                        continue;

                    if (lstrcmp(mic.szPname, pmxl->Target.szPname))
                        continue;

                    pmxl->Target.dwDeviceID = u;
                    break;
                }
                break;

            case MIXERLINE_TARGETTYPE_AUX:
                u = auxGetNumDevs();
                while (u--)
                {
                    AUXCAPS     ac;

                    mmr = auxGetDevCaps(u, &ac, sizeof(ac));
                    if (MMSYSERR_NOERROR != mmr)
                        continue;

                    ac.szPname[SIZEOF(ac.szPname) - 1] = '\0';

                    if (ac.wMid != pmxl->Target.wMid)
                        continue;

                    if (ac.wPid != pmxl->Target.wPid)
                        continue;

                    if (ac.vDriverVersion != pmxl->Target.vDriverVersion)
                        continue;

                    if (lstrcmp(ac.szPname, pmxl->Target.szPname))
                        continue;

                    pmxl->Target.dwDeviceID = u;
                    break;
                }
                break;

            default:
                pmxl->Target.dwType = MIXERLINE_TARGETTYPE_UNDEFINED;
                break;
        }
    }

    return mmr;
}


/******************************Public*Routine******************************\
* mixerGetLineControls
*
*
*
* History:
* dd-mm-93 - StephenE - Created
*
\**************************************************************************/
MMRESULT MIXAPI mixerGetLineControls(
    HMIXEROBJ               hmxobj,
    LPMIXERLINECONTROLS     pmxlc,
    DWORD                   fdwControls
)
{
    DWORD               fdwMxObjType;
    UINT                uMxId;
    MMRESULT            mmr;

    CHECK_AND_INIT_THUNKS(mix32Lib);
    V_DFLAGS(fdwControls, M_GLCONTROLSF_VALID, mixerGetLineControls, MMSYSERR_INVALFLAG);
    V_WPOINTER(pmxlc, sizeof(DWORD), MMSYSERR_INVALPARAM);

    //
    //  the structure header for MIXERLINECONTROLS must be at least the
    //  minimum size
    //
    if (sizeof(MIXERLINECONTROLS) > (UINT)pmxlc->cbStruct)
    {
        DebugErr1(DBF_ERROR, "mixerGetLineControls: structure size too small or cbStruct not initialized (%lu).", pmxlc->cbStruct);
        return (MMSYSERR_INVALPARAM);
    }
    V_WPOINTER(pmxlc, pmxlc->cbStruct, MMSYSERR_INVALPARAM);

    if (sizeof(MIXERCONTROL) > (UINT)pmxlc->cbmxctrl)
    {
        DebugErr1(DBF_ERROR, "mixerGetLineControls: structure size too small or cbmxctrl not initialized (%lu).", pmxlc->cbmxctrl);
        return (MMSYSERR_INVALPARAM);
    }


    //
    //
    //
    switch (M_GLCONTROLSF_QUERYMASK & fdwControls)
    {
        case M_GLCONTROLSF_ALL:
            if (0L == pmxlc->cControls)
            {
                DebugErr(DBF_ERROR, "mixerGetLineControls: cControls cannot be zero.");
                return (MMSYSERR_INVALPARAM);
            }


            pmxlc->dwControlID  = (DWORD)-1L;
            break;

        case M_GLCONTROLSF_ONEBYID:
            pmxlc->dwLineID     = (DWORD)-1L;

            // -- fall through --

        case M_GLCONTROLSF_ONEBYTYPE:
            pmxlc->cControls    = (DWORD)1;
            break;

        default:
            DebugErr1(DBF_ERROR, "mixerGetLineControls: invalid query flags (%.08lXh).",
                        M_GLCONTROLSF_QUERYMASK & fdwControls);
            return (MMSYSERR_INVALFLAG);
    }

    V_WPOINTER(pmxlc->pamxctrl, pmxlc->cControls * pmxlc->cbmxctrl, MMSYSERR_INVALPARAM);


    //
    //
    //
    fdwMxObjType = (MIXER_OBJECTF_TYPEMASK & fdwControls);

    mmr = IMixerGetID(hmxobj, &uMxId, NULL, fdwMxObjType);
    if (MMSYSERR_NOERROR != mmr)
        return (mmr);

    if ((MIXER_OBJECTF_MIXER  == fdwMxObjType) ||
        (MIXER_OBJECTF_HMIXER == fdwMxObjType))
    {
        //
        //  if a mixer device id was passed, then null hmx so we use the
        //  correct message sender below
        //
        if ((UINT)hmxobj == uMxId)
            hmxobj = NULL;
    }
    else
    {
        hmxobj = NULL;
        fdwControls &= ~MIXER_OBJECTF_TYPEMASK;
        fdwControls |= MIXER_OBJECTF_MIXER;
    }



    //
    //
    //
    //
    if (NULL != hmxobj)
    {
        mmr = (MMRESULT)IMixerMessageHandle((HMIXER)hmxobj,
                                            MXDM_GETLINECONTROLS,
                                            (DWORD)pmxlc,
                                            fdwControls);
    }
    else
    {
        mmr = (MMRESULT)IMixerMessageId(mixerdrv,
                                        guTotalMixerDevs,
                                        uMxId,
                                        MXDM_GETLINECONTROLS,
                                        (DWORD)pmxlc,
                                        fdwControls);
    }

    return mmr;
}


/******************************Public*Routine******************************\
* mixerGetControlDetails
*
*
*
* History:
* dd-mm-93 - StephenE - Created
*
\**************************************************************************/
MMRESULT MIXAPI mixerGetControlDetails(
    HMIXEROBJ               hmxobj,
    LPMIXERCONTROLDETAILS   pmxcd,
    DWORD                   fdwDetails
)
{
    DWORD               fdwMxObjType;
    MMRESULT            mmr;
    UINT                uMxId;
    UINT                cDetails;

    CHECK_AND_INIT_THUNKS(mix32Lib);
    V_DFLAGS(fdwDetails, M_GCDSF_VALID, mixerGetControlDetails, MMSYSERR_INVALFLAG);
    V_WPOINTER(pmxcd, sizeof(DWORD), MMSYSERR_INVALPARAM);

    //
    //  the structure header for MIXERCONTROLDETAILS must be at least the
    //  minimum size
    //
    if (sizeof(MIXERCONTROLDETAILS) > (UINT)pmxcd->cbStruct)
    {
        DebugErr1(DBF_ERROR, "mixerGetControlDetails: structure size too small or cbStruct not initialized (%lu).", pmxcd->cbStruct);
        return (MMSYSERR_INVALPARAM);
    }
    V_WPOINTER(pmxcd, pmxcd->cbStruct, MMSYSERR_INVALPARAM);


    switch (M_GCDSF_QUERYMASK & fdwDetails)
    {
        case M_GCDSF_VALUE:
            //
            //  if both cChannels and cMultipleItems are zero, it is a
            //  custom control
            //
            if ((0L == pmxcd->cChannels) && (0L == pmxcd->cMultipleItems))
            {
                if (0L == pmxcd->cbDetails)
                {
                    DebugErr(DBF_ERROR, "mixerGetControlDetails: cbDetails cannot be zero.");
                    return (MMSYSERR_INVALPARAM);
                }

                V_WPOINTER(pmxcd->paDetails, pmxcd->cbDetails, MMSYSERR_INVALPARAM);

            }
            else
            {
                if (0L == pmxcd->cChannels)
                {
                    DebugErr(DBF_ERROR, "mixerGetControlDetails: cChannels for _VALUE cannot be zero.");
                    return (MMSYSERR_INVALPARAM);
                }


                if (pmxcd->cbDetails < sizeof(MIXERCONTROLDETAILS_SIGNED))
                {
                    DebugErr1(DBF_ERROR, "mixerGetControlDetails: structure size too small or cbDetails not initialized (%lu).", pmxcd->cbDetails);
                    return (MMSYSERR_INVALPARAM);
                }

                //
                //
                //
                cDetails = (UINT)pmxcd->cChannels;
                if (0L != pmxcd->cMultipleItems)
                {
                    cDetails *= (UINT)pmxcd->cMultipleItems;
                }

                V_WPOINTER(pmxcd->paDetails, cDetails * pmxcd->cbDetails, MMSYSERR_INVALPARAM);
            }
            break;

        case M_GCDSF_LISTTEXT:
            if (0L == pmxcd->cChannels)
            {
                DebugErr(DBF_ERROR, "mixerGetControlDetails: cChannels for _LISTTEXT cannot be zero.");
                return (MMSYSERR_INVALPARAM);
            }

            if (2L > pmxcd->cMultipleItems)
            {
                DebugErr(DBF_ERROR, "mixerGetControlDetails: cMultipleItems for _LISTTEXT must be 2 or greater.");
                return (MMSYSERR_INVALPARAM);
            }

            if (pmxcd->cbDetails < sizeof(MIXERCONTROLDETAILS_LISTTEXT))
            {
                DebugErr1(DBF_ERROR, "mixerGetControlDetails: structure size too small or cbDetails not initialized (%lu).", pmxcd->cbDetails);
                return (MMSYSERR_INVALPARAM);
            }

            cDetails = (UINT)pmxcd->cChannels * (UINT)pmxcd->cMultipleItems;
            V_WPOINTER(pmxcd->paDetails, cDetails * pmxcd->cbDetails, MMSYSERR_INVALPARAM);
            break;

        default:
            DebugErr1(DBF_ERROR, "mixerGetControlDetails: invalid query flags (%.08lXh).",
                        M_GCDSF_QUERYMASK & fdwDetails);
            return (MMSYSERR_INVALFLAG);
    }



    //
    //
    //
    fdwMxObjType = (MIXER_OBJECTF_TYPEMASK & fdwDetails);

    mmr = IMixerGetID(hmxobj, &uMxId, NULL, fdwMxObjType);
    if (MMSYSERR_NOERROR != mmr)
        return (mmr);

    if ((MIXER_OBJECTF_MIXER  == fdwMxObjType) ||
        (MIXER_OBJECTF_HMIXER == fdwMxObjType))
    {
        //
        //  if a mixer device id was passed, then null hmx so we use the
        //  correct message sender below
        //
        if ((UINT)hmxobj == uMxId)
            hmxobj = NULL;
    }
    else
    {
        hmxobj = NULL;
        fdwDetails &= ~MIXER_OBJECTF_TYPEMASK;
        fdwDetails |= MIXER_OBJECTF_MIXER;
    }

    //
    //
    //
    //
    if (NULL != hmxobj)
    {
        mmr = (MMRESULT)IMixerMessageHandle((HMIXER)hmxobj,
                                            MXDM_GETCONTROLDETAILS,
                                            (DWORD)pmxcd,
                                            fdwDetails);
    }
    else
    {
        mmr = (MMRESULT)IMixerMessageId(mixerdrv,
                                        guTotalMixerDevs,
                                        uMxId,
                                        MXDM_GETCONTROLDETAILS,
                                        (DWORD)pmxcd,
                                        fdwDetails);
    }

    return mmr;
}


/******************************Public*Routine******************************\
* mixerSetControlDetails
*
*
*
* History:
* dd-mm-93 - StephenE - Created
*
\**************************************************************************/
MMRESULT MIXAPI mixerSetControlDetails(
    HMIXEROBJ               hmxobj,
    LPMIXERCONTROLDETAILS   pmxcd,
    DWORD                   fdwDetails
)
{
    DWORD               fdwMxObjType;
    MMRESULT            mmr;
    UINT                uMxId;
    UINT                cDetails;

    CHECK_AND_INIT_THUNKS(mix32Lib);
    V_DFLAGS(fdwDetails, M_SCDF_VALID, mixerSetControlDetails, MMSYSERR_INVALFLAG);
    V_WPOINTER(pmxcd, sizeof(DWORD), MMSYSERR_INVALPARAM);

    //
    //  the structure header for MIXERCONTROLDETAILS must be at least the
    //  minimum size
    //
    if (sizeof(MIXERCONTROLDETAILS) > (UINT)pmxcd->cbStruct)
    {
        DebugErr1(DBF_ERROR, "mixerSetControlDetails: structure size too small or cbStruct not initialized (%lu).", pmxcd->cbStruct);
        return (MMSYSERR_INVALPARAM);
    }
    V_WPOINTER(pmxcd, pmxcd->cbStruct, MMSYSERR_INVALPARAM);



    switch (M_SCDF_QUERYMASK & fdwDetails)
    {
        case M_SCDF_VALUE:
            //
            //  cChannels is zero for custom controls
            //
            if (0L == pmxcd->cChannels)
            {
                if (0L == pmxcd->cbDetails)
                {
                    DebugErr(DBF_ERROR, "mixerSetControlDetails: cbDetails cannot be zero.");
                    return (MMSYSERR_INVALPARAM);
                }

                V_WPOINTER(pmxcd->paDetails, pmxcd->cbDetails, MMSYSERR_INVALPARAM);

                //
                //
                //
                if (0L != pmxcd->cMultipleItems)
                {
                    DebugErr(DBF_ERROR, "mixerSetControlDetails: cMultipleItems must be zero for custom controls.");
                    return (MMSYSERR_INVALPARAM);
                }
            }
            else
            {
                if (pmxcd->cbDetails < sizeof(MIXERCONTROLDETAILS_SIGNED))
                {
                    DebugErr1(DBF_ERROR, "mixerSetControlDetails: structure size too small or cbDetails not initialized (%lu).", pmxcd->cbDetails);
                    return (MMSYSERR_INVALPARAM);
                }

                cDetails = (UINT)pmxcd->cChannels;

                //
                //
                //
                if (0L != pmxcd->cMultipleItems)
                {
                    cDetails *= (UINT)(pmxcd->cMultipleItems);
                }

                V_WPOINTER(pmxcd->paDetails, cDetails * pmxcd->cbDetails, MMSYSERR_INVALPARAM);
            }
            break;

        case M_SCDF_CUSTOM:
            if (0L == pmxcd->cbDetails)
            {
                DebugErr(DBF_ERROR, "mixerSetControlDetails: cbDetails cannot be zero for custom controls.");
                return (MMSYSERR_INVALPARAM);
            }

            if (0L != pmxcd->cChannels)
            {
                DebugErr(DBF_ERROR, "mixerSetControlDetails: cChannels must be zero for custom controls.");
                return (MMSYSERR_INVALPARAM);
            }

            V_WPOINTER(pmxcd->paDetails, pmxcd->cbDetails, MMSYSERR_INVALPARAM);

            //
            //
            //
            if ((NULL != pmxcd->hwndOwner) && !IsWindow(pmxcd->hwndOwner))
            {
                DebugErr1(DBF_ERROR, "mixerSetControlDetails: hwndOwner must be a valid window handle (%.04Xh).", pmxcd->hwndOwner);
                return (MMSYSERR_INVALHANDLE);
            }
            break;

        default:
            DebugErr1(DBF_ERROR, "mixerSetControlDetails: invalid query flags (%.08lXh).",
                        M_SCDF_QUERYMASK & fdwDetails);
            return (MMSYSERR_INVALFLAG);
    }


    //
    //
    //
    fdwMxObjType = (MIXER_OBJECTF_TYPEMASK & fdwDetails);

    mmr = IMixerGetID(hmxobj, &uMxId, NULL, fdwMxObjType);
    if (MMSYSERR_NOERROR != mmr)
        return (mmr);

    if ((MIXER_OBJECTF_MIXER  == fdwMxObjType) ||
        (MIXER_OBJECTF_HMIXER == fdwMxObjType))
    {
        //
        //  if a mixer device id was passed, then null hmx so we use the
        //  correct message sender below
        //
        if ((UINT)hmxobj == uMxId)
            hmxobj = NULL;
    }
    else
    {
        fdwDetails &= ~MIXER_OBJECTF_TYPEMASK;
        fdwDetails |= MIXER_OBJECTF_MIXER;
        hmxobj = NULL;
    }

    //
    //
    //
    //
    if (NULL != hmxobj)
    {
        mmr = (MMRESULT)IMixerMessageHandle((HMIXER)hmxobj,
                                            MXDM_SETCONTROLDETAILS,
                                            (DWORD)pmxcd,
                                            fdwDetails);
    }
    else
    {
        mmr = (MMRESULT)IMixerMessageId(mixerdrv,
                                        guTotalMixerDevs,
                                        uMxId,
                                        MXDM_SETCONTROLDETAILS,
                                        (DWORD)pmxcd,
                                        fdwDetails);
    }

    return mmr;
}

/*****************************Private*Routine******************************\
* InitMixerThunks
*
* Initializes the thunking system.
*
* History:
* dd-mm-93 - StephenE - Created
*
\**************************************************************************/
BOOL FAR PASCAL
InitMixerThunks(
    void
    )
{

    /*
    ** For WOW we have a fake device driver (that actually lives inside
    ** this library).  When an applications makes an api call to this
    ** library we check to see is the WOW thunks are loaded.  If they are
    ** not loaded "InitWOWThunks" is called.  This function loads the 32
    ** bit library and determines the total number of mixer devices
    ** present in the system.  It then sets mixerdrv[0].bUsage
    ** and guTotalMixerDevs to this value.  This appears to the 16 bit code
    ** that we have one 16 bit device driver that supports all the
    ** 32 bit devices !!.  The entry point to this fake driver is
    ** mxdMessage, which just passes the message through to the 32 bit
    ** side.
    */

    mixerdrv[0].hDriver     = NULL;
    mixerdrv[0].bNumDevs    = (BYTE)0;
    mixerdrv[0].bUsage      = 0;
    mixerdrv[0].drvMessage  = mxdMessage;
    guTotalMixerDevs = 0;


    /*
    ** First try winmm.dll
    */
    mix32Lib = LoadLibraryEx32W( "winmm.dll", NULL, 0L );
    if ( mix32Lib ) {
        mix32Message = (DRIVERMSGPROC)GetProcAddress32W( mix32Lib,
                                                         "mxd32Message" );
        if ( mix32Message ) {

            mxdMessage( 0, MXDM_INIT, 0L, 0L, 0L );
            guTotalMixerDevs = (UINT)mxdMessage( 0, MXDM_GETNUMDEVS,
                                                 0L, 0L, 0L );

            mixerdrv[0].bNumDevs = (BYTE)guTotalMixerDevs;
            return TRUE;
        }
    }

    /*
    ** Then try msmix32.dll
    */
    mix32Lib = LoadLibraryEx32W( "msmix32.dll", NULL, 0L );
    if ( mix32Lib ) {

        mix32Message = (DRIVERMSGPROC)GetProcAddress32W( mix32Lib,
                                                         "mxd32Message" );
        if ( mix32Message ) {

            mxdMessage( 0, MXDM_INIT, 0L, 0L, 0L );
            guTotalMixerDevs = (UINT)mxdMessage( 0, MXDM_GETNUMDEVS,
                                                 0L, 0L, 0L );

            mixerdrv[0].bNumDevs = (BYTE)guTotalMixerDevs;
            return TRUE;
        }
    }

    /*
    ** Give up !!
    */
    return FALSE;

}


/*****************************Private*Routine******************************\
* mxdMessage
*
* Entry point for the fake WOW device driver.
*
* History:
* dd-mm-93 - StephenE - Created
*
\**************************************************************************/
DWORD CALLBACK
mxdMessage(
    UINT uId,
    UINT uMsg,
    DWORD dwInstance,
    DWORD dwParam1,
    DWORD dwParam2
    )
{
    return mmCallProc32( (DWORD)uId, (DWORD)uMsg, dwInstance,
                         dwParam1, dwParam2, mix32Message, 0L );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\mmsystem\mmioi.h ===
/* mmioi.h
 *
 * Definitions that are internal to the MMIO library.
 */

typedef MMIOINFO NEAR *PMMIO;

#define	PH(hmmio)	((PMMIO)(hmmio))
#define	HP(pmmio)	((HMMIO)(pmmio))

typedef struct _MMIODOSINFO		// How DOS IOProc uses MMIO.adwInfo[]
{
	HFILE		fh;		// DOS file handle
} MMIODOSINFO;

typedef struct _MMIOMEMINFO		// How MEM IOProc uses MMIO.adwInfo[]
{
	LONG		lExpand;	// increment to expand mem. files by
} MMIOMEMINFO;

#define	STATICIOPROC	0x0001

typedef struct _IOProcMapEntry
{
	FOURCC		fccIOProc;	// ID of installed I/O procedure
	LPMMIOPROC	pIOProc;	// I/O procedure address
	HTASK		hTask;		// task that called mmioRegisterIOProc()
	UINT		wFlags;
	struct _IOProcMapEntry *pNext;	// pointer to next IOProc entry
} IOProcMapEntry;

// standard I/O procedures
LRESULT CALLBACK mmioBNDIOProc(LPSTR, UINT, LPARAM, LPARAM);

/* prototypes from "hmemcpy.asm" */
LPVOID NEAR PASCAL MemCopy(LPVOID dest, const void FAR * source, LONG count);
LPSTR NEAR PASCAL fstrrchr(LPCSTR lsz, char c);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\mmsystem\playwav.h ===
/*****************************************************************************

    playwav.h

 ****************************************************************************/

BOOL    NEAR PASCAL soundPlay(HGLOBAL hSound, UINT wFlags);
void    NEAR PASCAL soundFree(HGLOBAL hSound);
HGLOBAL NEAR PASCAL soundLoadFile(LPCSTR szFileName);
HGLOBAL NEAR PASCAL soundLoadMemory(LPCSTR lpMem);

/*****************************************************************************

      STUFF TO SUPPORT MS-WAVE FORMAT FILES

 ****************************************************************************/

#define FOURCC( ch0, ch1, ch2, ch3 )                         \
		( (DWORD)(BYTE)(ch0) | ( (DWORD)(BYTE)(ch1) << 8 ) |	\
		( (DWORD)(BYTE)(ch2) << 16 ) | ( (DWORD)(BYTE)(ch3) << 24 ) )

typedef struct _FileHeader {
	DWORD	dwRiff;
	DWORD	dwSize;
	DWORD	dwWave;
} FileHeader;
typedef FileHeader FAR *FPFileHeader;

typedef struct _ChunkHeader {
	DWORD	dwCKID;
	DWORD	dwSize;
} ChunkHeader;
typedef ChunkHeader FAR *FPChunkHeader;

/*  Chunk Types  */
#define RIFF_FILE       FOURCC('R','I','F','F')
#define RIFF_WAVE       FOURCC('W','A','V','E')
#define RIFF_FORMAT     FOURCC('f','m','t',' ')
#define RIFF_CHANNEL    FOURCC('d','a','t','a')
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\mmsystem\mmwnd.c ===
/******************************************************************************

   Copyright (C) Microsoft Corporation 1985-1990. All rights reserved.

   Title:   mmwnd.c - contains the window procedure for the MMSYSTEM 'global'
                      window

                      the global window is used by sndPlaySound and MCI for
                      reciving notification messages.

   Version: 1.00

   Date:    04-Sep-1990

   Author:  ToddLa

*****************************************************************************/

#include <windows.h>
#include "mmsystem.h"
#include "mmddk.h"
#include "mmsysi.h"
#include "mmsysver.h"

#define CLASS_NAME MAKEINTATOM(42)

/*
   SOUND_DELAY is the number of ms to delay before closing the wave device
   after the buffer is done.
*/

#define SOUND_DELAY 300

typedef LRESULT (CALLBACK *LPWNDPROC)(HWND, UINT, WPARAM, LPARAM);

// Place the normal code in the _TEXT segment

static LRESULT CALLBACK mmWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);

#pragma alloc_text(_TEXT, mmWndProc)

HWND hwndNotify;


/****************************************************************************

    strings

****************************************************************************/

SZCODE  szStartupSound[]        = "SystemStart";


/***************************************************************************/

static BOOL PASCAL FAR CreateMMClass(void)
{
    WNDCLASS cls;

    cls.hCursor        = NULL;
    cls.hIcon          = NULL;
    cls.lpszMenuName   = NULL;
    cls.lpszClassName  = CLASS_NAME;
    cls.hbrBackground  = (HBRUSH)(COLOR_WINDOW + 1);
    cls.hInstance      = ghInst;
    cls.style          = CS_GLOBALCLASS;
    cls.lpfnWndProc    = (WNDPROC)mmWndProc;
    cls.cbWndExtra     = 0;
    cls.cbClsExtra     = 0;

    return RegisterClass(&cls);
}

/***************************************************************************
 *
 * @doc     INTERNAL    MMSYSTEM
 *
 * @api     BOOL | WndInit | called to create the MMSYSTEM global window.
 *
 * @comm    we need to create this window on be-half of the SHELL task
 *          so it will be around all the time.
 *
 ***************************************************************************/

BOOL NEAR PASCAL WndInit(void)
{
    if (hwndNotify)    // if we are init'ed already, just get out
        return TRUE;

    if (!CreateMMClass())
        return FALSE;

    if (!(hwndNotify = CreateWindowEx(0, CLASS_NAME, NULL, WS_OVERLAPPED,
        0, 0, 0, 0, NULL, NULL, ghInst, NULL))) {
        UnregisterClass(CLASS_NAME, ghInst);
        return FALSE;
    }


#ifdef DEBUGX
    {
    DPRINTF(("MMSYSTEM: Creating Notify Window: htask=%04X hwnd=%04X\r\n", GetCurrentTask(),hwndNotify));
    }
#endif // DEBUGX
    return TRUE;
}

/***************************************************************************
 *
 * @doc     INTERNAL    MMSYSTEM
 *
 * @api     void | WndTerminate | called when MMSYSTEM is terminating
 *
 ***************************************************************************/

void NEAR PASCAL WndTerminate(void)
{
    if (hwndNotify)
    {
        SendMessage(hwndNotify, WM_CLOSE, 0, 0L);
        UnregisterClass(CLASS_NAME, ghInst);
    }
}

/***************************************************************************
 *
 * @doc     INTERNAL    MMSYSTEM
 *
 * @api     LRESULT | mmWndProc | The Window procedure for the MMSYSTEM window
 *
 * @comm    mmWndProc calls DefWindowProc for all messages except:
 *
 *          MM_MCINOTIFY:       calls MciNotify()        in MCI.C
 *          MM_WOM_DONE:        calls WaveOutNotify()    in PLAYWAV.C
 *
 * @xref    sndPlaySound
 *
 ***************************************************************************/

static LRESULT CALLBACK mmWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    switch (msg)
    {
        case WM_CREATE:
            hwndNotify = hwnd;
            // sndPlaySound(szStartupSound, SND_ASYNC | SND_NODEFAULT);
            break;

        case WM_TIMER:
            KillTimer(hwnd, (UINT)wParam);
            WaveOutNotify(0,0);
            break;

        case MM_MCINOTIFY:
            MciNotify(wParam, lParam);
            break;

        case MM_WOM_DONE:

            /*
                The sound started with sndPlaySound has completed
                so we should call the cleanup routine. We delay
                this call for several hundred milliseconds because
                some sound drivers have a nasty characteristic - they
                will notify before the final DMA transfer is complete
                because the app. supplied buffer is no longer required.
                This means that they may have to spin inside a close
                request until the dma transfer completes. This hangs
                the system for hundreds of milliseconds.

            */

            SetTimer(hwndNotify, 1, SOUND_DELAY, NULL);
            break;

        case MM_SND_PLAY:
            return (LRESULT)(LONG)sndMessage((LPSTR)lParam, (UINT)wParam);

        case MM_MCISYSTEM_STRING:
            return (LRESULT)mciRelaySystemString ((LPMCI_SYSTEM_MESSAGE)lParam);

        default:
            return DefWindowProc(hwnd, msg, wParam,lParam);
    }

    return (LRESULT)0L;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\mmsystem\mmreg.h ===
/****************************************************************************
 *
 *   mmreg.h  - Registered Multimedia Information Public Header File
 *
 *   Copyright (c) 1991,1992,1993 Microsoft Corporation.  All Rights Reserved.
 *
 * Multimedia Registration
 *
 * Place this system include file in your INCLUDE path with the Windows SDK
 * include files.
 *
 * Obtain the Multimedia Developer Registration Kit from:
 *
 *  Microsoft Corporation
 *  Multimedia Systems Group
 *  Product Marketing
 *  One Microsoft Way
 *  Redmond, WA 98052-6399
 *
 * 800-227-4679 x11771
 *
 * Last Update:  01/21/93
 *
 ***************************************************************************/

// Define the following to skip definitions
//
// NOMMIDS    Multimedia IDs are not defined
// NONEWWAVE    No new waveform types are defined except WAVEFORMATEX
// NONEWRIFF    No new RIFF forms are defined
// NONEWIC    No new Image Compressor types are defined

#ifndef _INC_MMREG
/* use version number to verify compatibility */
#define _INC_MMREG     130    // version * 100 + revision

#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif  /* RC_INVOKED */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif    /* __cplusplus */

#ifndef NOMMIDS

/* manufacturer IDs */
#ifndef MM_MICROSOFT
#define MM_MICROSOFT            1   /* Microsoft Corporation */
#endif
#define MM_CREATIVE             2   /* Creative Labs Inc. */
#define MM_MEDIAVISION          3   /* Media Vision Inc. */
#define MM_FUJITSU              4
#define MM_ARTISOFT            20   /* Artisoft Inc. */
#define MM_TURTLE_BEACH        21
#define MM_IBM                 22   /* International Bussiness Machines Corp. */
#define MM_VOCALTEC            23   /* Vocaltec LTD. */
#define MM_ROLAND              24
#define MM_DIGISPEECH          25   /* Digispeech, Inc. */
#define MM_NEC                 26   /* NEC */
#define MM_ATI                 27   /* ATI */
#define MM_WANGLABS            28   /* Wang Laboratories, Inc. */
#define MM_TANDY               29   /* Tandy Corporation */
#define MM_VOYETRA             30   /* Voyetra */
#define MM_ANTEX               31   /* Antex */
#define MM_ICL_PS              32
#define MM_INTEL               33
#define MM_GRAVIS              34
#define MM_VAL                 35   /* Video Associates Labs */
#define MM_INTERACTIVE         36   /* InterActive, Inc. */
#define MM_YAMAHA              37   /* Yamaha Corp. of America */
#define MM_EVEREX              38   /* Everex Systems, Inc. */
#define MM_ECHO                39   /* Echo Speech Corporation */
#define MM_SIERRA              40   /* Sierra Semiconductor */
#define MM_CAT                 41   /* Computer Aided Technologies */
#define MM_APPS                42   /* APPS Software International */
#define MM_DSP_GROUP           43   /* DSP Group, Inc. */
#define MM_MELABS              44   /* microEngineering Labs */
#define MM_COMPUTER_FRIENDS    45   /* Computer Friends, Inc */

/* MM_MICROSOFT product IDs */
#ifndef MM_MIDI_MAPPER

#define MM_MIDI_MAPPER          1   /* MIDI Mapper */
#define MM_WAVE_MAPPER          2   /* Wave Mapper */
#define MM_SNDBLST_MIDIOUT      3   /* Sound Blaster MIDI output port */
#define MM_SNDBLST_MIDIIN       4   /* Sound Blaster MIDI input port */
#define MM_SNDBLST_SYNTH        5   /* Sound Blaster internal synthesizer */
#define MM_SNDBLST_WAVEOUT      6   /* Sound Blaster waveform output */
#define MM_SNDBLST_WAVEIN       7   /* Sound Blaster waveform input */
#define MM_ADLIB                9   /* Ad Lib-compatible synthesizer */
#define MM_MPU401_MIDIOUT      10   /* MPU401-compatible MIDI output port */
#define MM_MPU401_MIDIIN       11   /* MPU401-compatible MIDI input port */
#define MM_PC_JOYSTICK         12   /* Joystick adapter */
#endif

#define MM_PCSPEAKER_WAVEOUT           13  /* PC Speaker waveform output */

#define MM_MSFT_WSS_WAVEIN             14  /* MS Audio Board waveform input */
#define MM_MSFT_WSS_WAVEOUT            15  /* MS Audio Board waveform output */
#define MM_MSFT_WSS_FMSYNTH_STEREO     16  /* MS Audio Board Stereo FM synthesizer */
#define MM_MSFT_WSS_OEM_WAVEIN         18  /* MS OEM Audio Board waveform input */
#define MM_MSFT_WSS_OEM_WAVEOUT        19  /* MS OEM Audio Board waveform Output */
#define MM_MSFT_WSS_OEM_FMSYNTH_STEREO 20  /* MS OEM Audio Board Stereo FM synthesizer */
#define MM_MSFT_WSS_AUX                21  /* MS Audio Board Auxiliary Port */
#define MM_MSFT_WSS_OEM_AUX            22  /* MS OEM Audio Auxiliary Port */

#define MM_MSFT_GENERIC_WAVEIN         23  /* MS vanilla driver waveform input */
#define MM_MSFT_GENERIC_WAVEOUT        24  /* MS vanilla driver waveform output */
#define MM_MSFT_GENERIC_MIDIIN         25  /* MS vanilla driver MIDI input */
#define MM_MSFT_GENERIC_MIDIOUT        26  /* MS vanilla driver external MIDI output */
#define MM_MSFT_GENERIC_MIDISYNTH      27  /* MS vanilla driver MIDI synthesizer */
#define MM_MSFT_GENERIC_AUX_LINE       28  /* MS vanilla driver aux (line in) */
#define MM_MSFT_GENERIC_AUX_MIC        29  /* MS vanilla driver aux (mic) */
#define MM_MSFT_GENERIC_AUX_CD         30  /* MS vanilla driver aux (CD) */


/* MM_CREATIVE product IDs */
#define MM_CREATIVE_SB15_WAVEIN         1   /* SB (r) 1.5 waveform input */
#define MM_CREATIVE_SB20_WAVEIN         2   /* SB (r) 2.0 waveform input */
#define MM_CREATIVE_SBPRO_WAVEIN        3   /* SB Pro (r) waveform input */
#define MM_CREATIVE_SBP16_WAVEIN        4   /* SBP16 (r) waveform input */
#define MM_CREATIVE_SB15_WAVEOUT      101   /* SB (r) 1.5 waveform output */
#define MM_CREATIVE_SB20_WAVEOUT      102   /* SB (r) 2.0 waveform output */
#define MM_CREATIVE_SBPRO_WAVEOUT     103   /* SB Pro (r) waveform output */
#define MM_CREATIVE_SBP16_WAVEOUT     104   /* SBP16 (r) waveform output */
#define MM_CREATIVE_MIDIOUT           201   /* SB (r) MIDI output port */
#define MM_CREATIVE_MIDIIN            202   /* SB (r) MIDI input port */
#define MM_CREATIVE_FMSYNTH_MONO      301   /* SB (r) FM synthesizer */
#define MM_CREATIVE_FMSYNTH_STEREO    302   /* SB Pro (r) stereo FM synthesizer */
#define MM_CREATIVE_AUX_CD            401   /* SB Pro (r) aux (CD) */
#define MM_CREATIVE_AUX_LINE          402   /* SB Pro (r) aux (line in) */
#define MM_CREATIVE_AUX_MIC           403   /* SB Pro (r) aux (mic) */


/* MM_ARTISOFT product IDs */
#define MM_ARTISOFT_SBWAVEIN     1   /* Artisoft Sounding Board waveform input */
#define MM_ARTISOFT_SBWAVEOUT    2   /* Artisoft Sounding Board waveform output */

/* MM_IBM Product IDs */
#define MM_MMOTION_WAVEAUX       1    /* IBM M-Motion Auxiliary Device */
#define MM_MMOTION_WAVEOUT       2    /* IBM M-Motion Waveform Output */
#define MM_MMOTION_WAVEIN        3    /* IBM M-Motion Waveform Input */

/* MM_MEDIAVISION Product IDs */
#define MM_MEDIAVISION_PROAUDIO       0x10
#define MM_PROAUD_MIDIOUT             MM_MEDIAVISION_PROAUDIO+1
#define MM_PROAUD_MIDIIN              MM_MEDIAVISION_PROAUDIO+2
#define MM_PROAUD_SYNTH               MM_MEDIAVISION_PROAUDIO+3
#define MM_PROAUD_WAVEOUT             MM_MEDIAVISION_PROAUDIO+4
#define MM_PROAUD_WAVEIN              MM_MEDIAVISION_PROAUDIO+5
#define MM_PROAUD_MIXER               MM_MEDIAVISION_PROAUDIO+6
#define MM_PROAUD_AUX                 MM_MEDIAVISION_PROAUDIO+7

#define MM_MEDIAVISION_THUNDER        0x20
#define MM_THUNDER_WAVEOUT            MM_MEDIAVISION_THUNDER+1
#define MM_THUNDER_WAVEIN             MM_MEDIAVISION_THUNDER+2
#define MM_THUNDER_SYNTH              MM_MEDIAVISION_THUNDER+3

#define MM_MEDIAVISION_TPORT          0x40
#define MM_TPORT_WAVEOUT              MM_MEDIAVISION_TPORT+1
#define MM_TPORT_WAVEIN               MM_MEDIAVISION_TPORT+2
#define MM_TPORT_SYNTH                MM_MEDIAVISION_TPORT+3

// THIS CARD IS THE OEM VERSION OF THE NEXT PAS
#define MM_MEDIAVISION_PROAUDIO_PLUS  0x50
#define MM_PROAUD_PLUS_MIDIOUT        MM_MEDIAVISION_PROAUDIO_PLUS+1
#define MM_PROAUD_PLUS_MIDIIN         MM_MEDIAVISION_PROAUDIO_PLUS+2
#define MM_PROAUD_PLUS_SYNTH          MM_MEDIAVISION_PROAUDIO_PLUS+3
#define MM_PROAUD_PLUS_WAVEOUT        MM_MEDIAVISION_PROAUDIO_PLUS+4
#define MM_PROAUD_PLUS_WAVEIN         MM_MEDIAVISION_PROAUDIO_PLUS+5
#define MM_PROAUD_PLUS_MIXER          MM_MEDIAVISION_PROAUDIO_PLUS+6
#define MM_PROAUD_PLUS_AUX            MM_MEDIAVISION_PROAUDIO_PLUS+7


// THIS CARD IS THE NEW MEDIA VISION 16-bit card
#define MM_MEDIAVISION_PROAUDIO_16    0x60
#define MM_PROAUD_16_MIDIOUT          MM_MEDIAVISION_PROAUDIO_16+1
#define MM_PROAUD_16_MIDIIN           MM_MEDIAVISION_PROAUDIO_16+2
#define MM_PROAUD_16_SYNTH            MM_MEDIAVISION_PROAUDIO_16+3
#define MM_PROAUD_16_WAVEOUT          MM_MEDIAVISION_PROAUDIO_16+4
#define MM_PROAUD_16_WAVEIN           MM_MEDIAVISION_PROAUDIO_16+5
#define MM_PROAUD_16_MIXER            MM_MEDIAVISION_PROAUDIO_16+6
#define MM_PROAUD_16_AUX              MM_MEDIAVISION_PROAUDIO_16+7


// THIS CARD IS THE NEW MEDIA VISION CDPC card
#define MM_MEDIAVISION_CDPC           0x70
#define MM_CDPC_MIDIOUT               MM_MEDIAVISION_CDPC+1
#define MM_CDPC_MIDIIN                MM_MEDIAVISION_CDPC+2
#define MM_CDPC_SYNTH                 MM_MEDIAVISION_CDPC+3
#define MM_CDPC_WAVEOUT               MM_MEDIAVISION_CDPC+4
#define MM_CDPC_WAVEIN                MM_MEDIAVISION_CDPC+5
#define MM_CDPC_MIXER                 MM_MEDIAVISION_CDPC+6
#define MM_CDPC_AUX                   MM_MEDIAVISION_CDPC+7


//
// Opus MV1208 Chipset
//
#define MM_MEDIAVISION_OPUS1208       0x80
#define MM_OPUS401_MIDIOUT            MM_MEDIAVISION_OPUS1208+1
#define MM_OPUS401_MIDIIN             MM_MEDIAVISION_OPUS1208+2
#define MM_OPUS1208_SYNTH             MM_MEDIAVISION_OPUS1208+3
#define MM_OPUS1208_WAVEOUT           MM_MEDIAVISION_OPUS1208+4
#define MM_OPUS1208_WAVEIN            MM_MEDIAVISION_OPUS1208+5
#define MM_OPUS1208_MIXER             MM_MEDIAVISION_OPUS1208+6
#define MM_OPUS1208_AUX               MM_MEDIAVISION_OPUS1208+7


//
// Opus MV1216 Chipset
//
#define MM_MEDIAVISION_OPUS1216       0x90
#define MM_OPUS1216_MIDIOUT           MM_MEDIAVISION_OPUS1216+1
#define MM_OPUS1216_MIDIIN            MM_MEDIAVISION_OPUS1216+2
#define MM_OPUS1216_SYNTH             MM_MEDIAVISION_OPUS1216+3
#define MM_OPUS1216_WAVEOUT           MM_MEDIAVISION_OPUS1216+4
#define MM_OPUS1216_WAVEIN            MM_MEDIAVISION_OPUS1216+5
#define MM_OPUS1216_MIXER             MM_MEDIAVISION_OPUS1216+6
#define MM_OPUS1216_AUX               MM_MEDIAVISION_OPUS1216+7


//
// Mixer
//
#define MIXERR_BASE                   512

/* MM_VOCALTEC Product IDs */
#define MM_VOCALTEC_WAVEOUT       1    /* Vocaltec Waveform output port */
#define MM_VOCALTEC_WAVEIN        2    /* Vocaltec Waveform input port */

/* MM_ROLAND Product IDs */
#define MM_ROLAND_MPU401_MIDIOUT    15
#define MM_ROLAND_MPU401_MIDIIN     16
#define MM_ROLAND_SMPU_MIDIOUTA     17
#define MM_ROLAND_SMPU_MIDIOUTB     18
#define MM_ROLAND_SMPU_MIDIINA      19
#define MM_ROLAND_SMPU_MIDIINB      20
#define MM_ROLAND_SC7_MIDIOUT       21
#define MM_ROLAND_SC7_MIDIIN        22


/* MM_DIGISPEECH Product IDs */
#define MM_DIGISP_WAVEOUT    1    /* Digispeech Waveform output port */
#define MM_DIGISP_WAVEIN     2    /* Digispeech Waveform input port */

/* MM_NEC Product IDs */

/* MM_ATI Product IDs */

/* MM_WANGLABS Product IDs */

#define MM_WANGLABS_WAVEIN1    1
/* Input audio wave device present on the CPU board of the following Wang models: Exec 4010, 4030 and 3450; PC 251/25C, PC 461/25S and PC 461/33C */
#define MM_WANGLABS_WAVEOUT1   2
/* Output audio wave device present on the CPU board of the Wang models listed above. */

/* MM_TANDY Product IDs */

/* MM_VOYETRA Product IDs */

/* MM_ANTEX Product IDs */

/* MM_ICL_PS Product IDs */

/* MM_INTEL Product IDs */

#define MM_INTELOPD_WAVEIN       1    // HID2 WaveAudio Input driver
#define MM_INTELOPD_WAVEOUT    101    // HID2 WaveAudio Output driver
#define MM_INTELOPD_AUX        401    // HID2 Auxiliary driver (required for mixing functions)

/* MM_GRAVIS Product IDs */

/* MM_VAL Product IDs */

// values not defined by Manufacturer

// #define MM_VAL_MICROKEY_AP_WAVEIN    ???    // Microkey/AudioPort Waveform Input
// #define MM_VAL_MICROKEY_AP_WAVEOUT    ???    // Microkey/AudioPort Waveform Output

/* MM_INTERACTIVE Product IDs */

#define MM_INTERACTIVE_WAVEIN     0x45    // no comment provided by Manufacturer
#define MM_INTERACTIVE_WAVEOUT    0x45    // no comment provided by Manufacturer

/* MM_YAMAHA Product IDs */

#define MM_YAMAHA_GSS_SYNTH     0x01    // Yamaha Gold Sound Standard FM sythesis driver
#define MM_YAMAHA_GSS_WAVEOUT   0x02    // Yamaha Gold Sound Standard wave output driver
#define MM_YAMAHA_GSS_WAVEIN    0x03    // Yamaha Gold Sound Standard wave input driver
#define MM_YAMAHA_GSS_MIDIOUT   0x04    // Yamaha Gold Sound Standard midi output driver
#define MM_YAMAHA_GSS_MIDIIN    0x05    // Yamaha Gold Sound Standard midi input driver
#define MM_YAMAHA_GSS_AUX       0x06    // Yamaha Gold Sound Standard auxillary driver for mixer functions

/* MM_EVEREX Product IDs */

#define MM_EVEREX_CARRIER    0x01    // Everex Carrier SL/25 Notebook

/* MM_ECHO Product IDs */

#define MM_ECHO_SYNTH     0x01    // Echo EuSythesis driver
#define MM_ECHO_WAVEOUT   0x02    // Wave output driver
#define MM_ECHO_WAVEIN    0x03    // Wave input driver
#define MM_ECHO_MIDIOUT   0x04    // MIDI output driver
#define MM_ECHO_MIDIIN    0x05    // MIDI input driver
#define MM_ECHO_AUX       0x06    // auxillary driver for mixer functions


/* MM_SIERRA Product IDs */

#define MM_SIERRA_ARIA_MIDIOUT   0x14    // Sierra Aria MIDI output
#define MM_SIERRA_ARIA_MIDIIN    0x15    // Sierra Aria MIDI input
#define MM_SIERRA_ARIA_SYNTH     0x16    // Sierra Aria Synthesizer
#define MM_SIERRA_ARIA_WAVEOUT   0x17    // Sierra Aria Waveform output
#define MM_SIERRA_ARIA_WAVEIN    0x18    // Sierra Aria Waveform input
#define MM_SIERRA_ARIA_AUX       0x19    // Siarra Aria Auxiliary device

/* MM_CAT Product IDs */

/* MM_APPS Product IDs */

/* MM_DSP_GROUP Product IDs */

#define MM_DSP_GROUP_TRUESPEECH    0x01    // High quality 9.54:1 Speech Compression Vocoder

/* MM_MELABS Product IDs */

#define MM_MELABS_MIDI2GO    0x01    // parellel port MIDI interface

#endif

/*////////////////////////////////////////////////////////////////////////// */

#ifndef NONEWWAVE

/* WAVE form wFormatTag IDs */
#define WAVE_FORMAT_UNKNOWN                (0x0000)
#define WAVE_FORMAT_ADPCM                  (0x0002)
#define WAVE_FORMAT_IBM_CVSD               (0x0005)
#define WAVE_FORMAT_ALAW                   (0x0006)
#define WAVE_FORMAT_MULAW                  (0x0007)
#define WAVE_FORMAT_OKI_ADPCM              (0x0010)
#define WAVE_FORMAT_DVI_ADPCM              (0x0011)
#define WAVE_FORMAT_IMA_ADPCM              (WAVE_FORMAT_DVI_ADPCM)
#define WAVE_FORMAT_DIGISTD                (0x0015)
#define WAVE_FORMAT_DIGIFIX                (0x0016)
#define WAVE_FORMAT_YAMAHA_ADPCM           (0x0020)
#define WAVE_FORMAT_SONARC                 (0x0021)
#define WAVE_FORMAT_DSPGROUP_TRUESPEECH    (0x0022)
#define WAVE_FORMAT_ECHOSC1                (0x0023)
#define WAVE_FORMAT_CREATIVE_ADPCM         (0x0200)

#endif /* NONEWWAVE */


#ifndef WAVE_FORMAT_PCM

/* general waveform format structure (information common to all formats) */
typedef struct waveformat_tag {
    WORD    wFormatTag;        /* format type */
    WORD    nChannels;         /* number of channels (i.e. mono, stereo...) */
    DWORD   nSamplesPerSec;    /* sample rate */
    DWORD   nAvgBytesPerSec;   /* for buffer estimation */
    WORD    nBlockAlign;       /* block size of data */
} WAVEFORMAT;
typedef WAVEFORMAT      *PWAVEFORMAT;
typedef WAVEFORMAT NEAR *NPWAVEFORMAT;
typedef WAVEFORMAT FAR  *LPWAVEFORMAT;

/* flags for wFormatTag field of WAVEFORMAT */
#define WAVE_FORMAT_PCM     1

/* specific waveform format structure for PCM data */
typedef struct pcmwaveformat_tag {
    WAVEFORMAT  wf;
    WORD        wBitsPerSample;
} PCMWAVEFORMAT;
typedef PCMWAVEFORMAT       *PPCMWAVEFORMAT;
typedef PCMWAVEFORMAT NEAR *NPPCMWAVEFORMAT;
typedef PCMWAVEFORMAT FAR  *LPPCMWAVEFORMAT;


#endif /* WAVE_FORMAT_PCM */



/* general extended waveform format structure
   Use this for all NON PCM formats
   (information common to all formats)
*/

typedef struct waveformat_extended_tag {
    WORD    wFormatTag;        /* format type */
    WORD    nChannels;         /* number of channels (i.e. mono, stereo...) */
    DWORD   nSamplesPerSec;    /* sample rate */
    DWORD   nAvgBytesPerSec;   /* for buffer estimation */
    WORD    nBlockAlign;       /* block size of data */
    WORD    wBitsPerSample;    /* Number of bits per sample of mono data */
    WORD    cbSize;            /* The count in bytes of the size of
                                  extra information (after cbSize) */

} WAVEFORMATEX;
typedef WAVEFORMATEX      *PWAVEFORMATEX;
typedef WAVEFORMATEX NEAR *NPWAVEFORMATEX;
typedef WAVEFORMATEX FAR  *LPWAVEFORMATEX;


#ifndef NONEWWAVE

/* Define data for MS ADPCM */

typedef struct adpcmcoef_tag {
    short    iCoef1;
    short    iCoef2;
} ADPCMCOEFSET;
typedef ADPCMCOEFSET      *PADPCMCOEFSET;
typedef ADPCMCOEFSET NEAR *NPADPCMCOEFSET;
typedef ADPCMCOEFSET FAR  *LPADPCMCOEFSET;

typedef struct adpcmwaveformat_tag {
    WAVEFORMATEX    wfx;
    WORD            wSamplesPerBlock;
    WORD            wNumCoef;
    ADPCMCOEFSET    aCoef[];
} ADPCMWAVEFORMAT;
typedef ADPCMWAVEFORMAT      *PADPCMWAVEFORMAT;
typedef ADPCMWAVEFORMAT NEAR *NPADPCMWAVEFORMAT;
typedef ADPCMWAVEFORMAT FAR  *LPADPCMWAVEFORMAT;


//
//  Intel's DVI ADPCM structure definitions
//
//      for WAVE_FORMAT_DVI_ADPCM   (0x0011)
//
//

typedef struct dvi_adpcmwaveformat_tag {
    WAVEFORMATEX    wfx;
    WORD            wSamplesPerBlock;
} DVIADPCMWAVEFORMAT;
typedef DVIADPCMWAVEFORMAT      *PDVIADPCMWAVEFORMAT;
typedef DVIADPCMWAVEFORMAT NEAR *NPDVIADPCMWAVEFORMAT;
typedef DVIADPCMWAVEFORMAT FAR  *LPDVIADPCMWAVEFORMAT;


//
//  IMA endorsed ADPCM structure definitions--note that this is exactly
//  the same format as Intel's DVI ADPCM.
//
//      for WAVE_FORMAT_IMA_ADPCM   (0x0011)
//
//

typedef struct ima_adpcmwaveformat_tag {
    WAVEFORMATEX    wfx;
    WORD            wSamplesPerBlock;
} IMAADPCMWAVEFORMAT;
typedef IMAADPCMWAVEFORMAT      *PIMAADPCMWAVEFORMAT;
typedef IMAADPCMWAVEFORMAT NEAR *NPIMAADPCMWAVEFORMAT;
typedef IMAADPCMWAVEFORMAT FAR  *LPIMAADPCMWAVEFORMAT;


//
//  Speech Compression's Sonarc structure definitions
//
//      for WAVE_FORMAT_SONARC   (0x0021)
//
//

typedef struct sonarcwaveformat_tag {
    WAVEFORMATEX    wfx;
    WORD            wCompType;
} SONARCWAVEFORMAT;
typedef SONARCWAVEFORMAT      *PSONARCWAVEFORMAT;
typedef SONARCWAVEFORMAT NEAR *NPSONARCWAVEFORMAT;
typedef SONARCWAVEFORMAT FAR  *LPSONARCWAVEFORMAT;

//
//  DSP Groups's TRUESPEECH structure definitions
//
//      for WAVE_FORMAT_DSPGROUP_TRUESPEECH   (0x0022)
//
//

typedef struct truespeechwaveformat_tag {
    WAVEFORMATEX    wfx;
    WORD            nSamplesPerBlock;
} TRUESPEECHWAVEFORMAT;
typedef TRUESPEECHWAVEFORMAT      *PTRUESPEECHWAVEFORMAT;
typedef TRUESPEECHWAVEFORMAT NEAR *NPTRUESPEECHWAVEFORMAT;
typedef TRUESPEECHWAVEFORMAT FAR  *LPTRUESPEECHWAVEFORMAT;



//
//  Creative's ADPCM structure definitions
//
//      for WAVE_FORMAT_CREATIVE_ADPCM   (0x0200)
//
//

typedef struct creative_adpcmwaveformat_tag {
    WAVEFORMATEX    wfx;
    WORD            wRevision;
} CREATIVEADPCMWAVEFORMAT;
typedef CREATIVEADPCMWAVEFORMAT      *PCREATIVEADPCMWAVEFORMAT;
typedef CREATIVEADPCMWAVEFORMAT NEAR *NPCREATIVEADPCMWAVEFORMAT;
typedef CREATIVEADPCMWAVEFORMAT FAR  *LPCREATIVEADPCMWAVEFORMAT;

/*//////////////////////////////////////////////////////////////////////////
//
// New RIFF WAVE Chunks
//
*/

#define RIFFWAVE_inst    mmioFOURCC('i','n','s','t')

struct tag_s_RIFFWAVE_inst {
    BYTE    bUnshiftedNote;
    char    chFineTune;
    char    chGain;
    BYTE    bLowNote;
    BYTE    bHighNote;
    BYTE    bLowVelocity;
    BYTE    bHighVelocity;
};

typedef struct tag_s_RIFFWAVE_INST s_RIFFWAVE_inst;

#endif

/*//////////////////////////////////////////////////////////////////////////
//
// New RIFF Forms
//
*/

#ifndef NONEWRIFF

/* RIFF AVI */

//
// AVI file format is specified in a seperate file (AVIFMT.H),
// which is available from the sources listed in MSFTMM
//

/* RIFF CPPO */

#define RIFFCPPO         mmioFOURCC('C','P','P','O')

#define RIFFCPPO_objr    mmioFOURCC('o','b','j','r')
#define RIFFCPPO_obji    mmioFOURCC('o','b','j','i')

#define RIFFCPPO_clsr    mmioFOURCC('c','l','s','r')
#define RIFFCPPO_clsi    mmioFOURCC('c','l','s','i')

#define RIFFCPPO_mbr     mmioFOURCC('m','b','r',' ')

#define RIFFCPPO_char    mmioFOURCC('c','h','a','r')


#define RIFFCPPO_byte    mmioFOURCC('b','y','t','e')
#define RIFFCPPO_int     mmioFOURCC('i','n','t',' ')
#define RIFFCPPO_word    mmioFOURCC('w','o','r','d')
#define RIFFCPPO_long    mmioFOURCC('l','o','n','g')
#define RIFFCPPO_dwrd    mmioFOURCC('d','w','r','d')
#define RIFFCPPO_flt     mmioFOURCC('f','l','t',' ')
#define RIFFCPPO_dbl     mmioFOURCC('d','b','l',' ')
#define RIFFCPPO_str     mmioFOURCC('s','t','r',' ')


#endif

/*//////////////////////////////////////////////////////////////////////////
//
// DIB Compression Defines
//
*/

#ifndef BI_BITFIELDS
#define BI_BITFIELDS    3
#endif

#ifndef QUERYDIBSUPPORT

#define QUERYDIBSUPPORT   3073
#define QDI_SETDIBITS     0x0001
#define QDI_GETDIBITS     0x0002
#define QDI_DIBTOSCREEN   0x0004
#define QDI_STRETCHDIB    0x0008

#endif


/*//////////////////////////////////////////////////////////////////////////
//
// Defined IC types
*/

#ifndef NONEWIC

#ifndef ICTYPE_VIDEO
#define ICTYPE_VIDEO    mmioFOURCC('v', 'i', 'd', 'c')
#define ICTYPE_AUDIO    mmioFOURCC('a', 'u', 'd', 'c')
#endif

#endif

#ifndef RC_INVOKED
#pragma pack()          /* Revert to default packing */
#endif  /* RC_INVOKED */

#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif    /* __cplusplus */

#endif    /* _INC_MMREG */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\mmsystem\mmsysi.h ===
/*
    mmsysi.h

    private include file for mm kitchen sink

*/

#include <logerror.h>

#ifdef DEBUG
    #define DEBUG_RETAIL
#endif

#define WinFlags (WORD)(&__WinFlags)
extern short pascal __WinFlags;

extern HINSTANCE ghInst;

// Define the product version to be returned from
// mmsystemgetversion and any other messagebox or
// API that needs the public product version.

#define MMSYSTEM_VERSION 0X0101

#define MM_SND_PLAY     (WM_MM_RESERVED_FIRST+0x2B)

/* -------------------------------------------------------------------------
** Thunking stuff
** -------------------------------------------------------------------------
*/
DWORD
mciAppExit(
    HTASK hTask
    );

/****************************************************************************

    external interupt time data (in INTDS)

    this global data is in the FIXED DATA SEGMENT.

****************************************************************************/

extern WORD         FAR PASCAL gwStackFrames;           // in STACK.ASM
extern WORD         FAR PASCAL gwStackSize;             // in STACK.ASM
extern HGLOBAL      FAR PASCAL gwStackSelector;         // in STACK.ASM
extern WORD         FAR PASCAL gwStackUse;              // in STACK.ASM
extern HLOCAL       FAR PASCAL hdrvDestroy;             // in STACK.ASM
extern HDRVR        FAR PASCAL hTimeDrv;                // in TIMEA.ASM
extern FARPROC      FAR PASCAL lpTimeMsgProc;           // in TIMEA.ASM
extern WORD         FAR PASCAL fDebugOutput;            // in COMM.ASM

/****************************************************************************

KERNEL APIs we use that are not in WINDOWS.H

****************************************************************************/

//extern long WINAPI _hread(HFILE, void _huge*, long);
//extern long WINAPI _hwrite(HFILE, const void _huge*, long);

extern UINT FAR PASCAL LocalCountFree(void);
extern UINT FAR PASCAL LocalHeapSize(void);

/****************************************************************************

  API to install/remove a MMSYS driver

****************************************************************************/

#define MMDRVI_TYPE          0x000F  // low 4 bits give driver type
#define MMDRVI_WAVEIN        0x0001
#define MMDRVI_WAVEOUT       0x0002
#define MMDRVI_MIDIIN        0x0003
#define MMDRVI_MIDIOUT       0x0004
#define MMDRVI_AUX           0x0005

#define MMDRVI_MAPPER        0x8000  // install this driver as the mapper
#define MMDRVI_HDRV          0x4000  // hDriver is a installable driver
#define MMDRVI_REMOVE        0x2000  // remove the driver

// generic prototype for audio device driver entry-point functions
// midMessage(), modMessage(), widMessage(), wodMessage(), auxMessage()
typedef DWORD (CALLBACK *DRIVERMSGPROC)(UINT wDeviceID, UINT message, DWORD dwInstance, DWORD dwParam1, DWORD dwParam2);

BOOL WINAPI mmDrvInstall(HANDLE hDriver, DRIVERMSGPROC *drvMessage, UINT wFlags);
HDRVR NEAR PASCAL mmDrvOpen( LPSTR szAlias );

/****************************************************************************
****************************************************************************/

//
// exclude some stuff if MMDDK.H is not included
//
#ifdef MMDDKINC   // use this to test for MMDDK.H

    //
    // note this must be the same as MIDIDRV/WAVEDRV/AUXDRV
    //
    typedef struct {
        HDRVR hDriver;              // handle to the module
        DRIVERMSGPROC drvMessage;   // pointer to entry point
        BYTE bNumDevs;              // number of devices supported
        BYTE bUsage;                // usage count (number of handle's open)
    } MMDRV, *PMMDRV;

    #ifndef MMNOMIDI

    typedef MMDRV MIDIDRV, *PMIDIDRV;


    #endif //ifndef MMNOMIDI

    #ifndef MMNOWAVE

    typedef MMDRV WAVEDRV, *PWAVEDRV;

    //
    // Wave Mapper support
    //
    extern LPSOUNDDEVMSGPROC  PASCAL wodMapper;
    extern LPSOUNDDEVMSGPROC  PASCAL widMapper;

    #endif //ifndef MMNOWAVE

    #ifndef MMNOAUX

    typedef MMDRV AUXDRV, *PAUXDRV;

    #endif //ifndef MMNOAUX

    #ifdef DEBUG_RETAIL
    extern BYTE    fIdReverse;
    #endif //ifdef DEBUG_RETAIL

#endif //ifdef MMDDKINC

/****************************************************************************

    prototypes

****************************************************************************/

BOOL FAR  PASCAL JoyInit(void);
BOOL NEAR PASCAL TimeInit(void);

BOOL NEAR PASCAL MCIInit(void);
void NEAR PASCAL MCITerminate(void);

BOOL FAR  PASCAL StackInit(void);           // in init.c

#define IDS_TASKSTUB           2000
#define STR_MCIUNKNOWN         2001
//#define STR_WAVEINPUT          2004
//#define STR_WAVEOUTPUT         2005
//#define STR_MIDIINPUT          2006
//#define STR_MIDIOUTPUT         2007
#ifdef DEBUG
#define STR_MCISSERRTXT        2009
#define STR_MCISCERRTXT        2010
#endif

#define MAXPATHLEN	157	// 144 chars + "\12345678.123"

BOOL FAR PASCAL HugePageLock(LPVOID lpArea, DWORD dwLength);
void FAR PASCAL HugePageUnlock(LPVOID lpArea, DWORD dwLength);

/****************************************************************************

    MMSYSTEM global notify window

****************************************************************************/

extern HWND hwndNotify;                                     // in MMWND.C

BOOL NEAR PASCAL WndInit(void);                             // in MMWND.C
void NEAR PASCAL WndTerminate(void);                        // in MMWND.C

void FAR PASCAL MciNotify(WPARAM wParam, LPARAM lParam);    // in MCI.C
void FAR PASCAL WaveOutNotify(WPARAM wParam, LPARAM lParam);// in PLAYWAV.C
BOOL FAR PASCAL sndPlaySoundI(LPCSTR lszSoundName, UINT wFlags);// in SOUND.C
BOOL FAR PASCAL sndMessage(LPSTR lszSoundName, UINT wFlags);// in SOUND.C

/****************************************************************************

    MCI allocation stuff

****************************************************************************/

extern HGLOBAL FAR PASCAL HeapCreate(int cbSize);
extern void   FAR PASCAL HeapDestroy(HGLOBAL hHeap);
extern LPVOID FAR PASCAL HeapAlloc(HGLOBAL hHeap, int cbSize);
extern LPVOID FAR PASCAL HeapReAlloc(LPVOID lp, int cbSize);
extern void   FAR PASCAL HeapFree(LPVOID lp);

extern  HGLOBAL hMciHeap;            // in MCISYS.C

#define BMCIHEAP _based((_segment)hMciHeap)

#define mciAlloc(cb)            HeapAlloc(hMciHeap, cb)
#define mciReAlloc(lp, size)    HeapReAlloc (lp, size)
#define mciFree(lp)             HeapFree(lp)

/****************************************************************************

    strings

****************************************************************************/

#define SZCODE char _based(_segname("_CODE"))

/****************************************************************************

    handle apis's

****************************************************************************/

//
// all MMSYSTEM handles are tagged with the following structure.
//
// a MMSYSTEM handle is really a fixed local memory object.
//
// the functions NewHandle() and FreeHandle() create and release a MMSYSTEM
// handle.
//
//
//**************************************************************************;
//   IF YOU CHANGE THIS STRUCTURE YOU MUST ALSO CHANGE THE ONE IN DEBUG.ASM
//**************************************************************************;
typedef	struct tagHNDL {
	struct	tagHNDL *pNext;	// link to next handle
	WORD	wType;		// type of handle wave, midi, mmio, ...
	HTASK	hTask;		// task that owns it
}       HNDL,   NEAR *PHNDL;
//**************************************************************************;

#define	HtoPH(h)	((PHNDL)(h)-1)
#define	PHtoH(ph)	((ph) ? (HLOCAL)((PHNDL)(ph)+1) : 0)

//
// all wave and midi handles will be linked into
// a global list, so we can enumerate them latter if needed.
//
// all handle structures start with a HNDL structure, that contain common fields
//
// pHandleList points to the first handle in the list
//
// the NewHandle() and FreeHandle() functions are used to add/remove
// a handle to/from the list
//
extern PHNDL pHandleList;

extern HLOCAL FAR PASCAL NewHandle(WORD wType, WORD size);
extern HLOCAL FAR PASCAL FreeHandle(HLOCAL h);

#define GetHandleType(h)        (HtoPH(h)->wType)
#define GetHandleOwner(h)       (HtoPH(h)->hTask)
#define GetHandleFirst()        (PHtoH(pHandleList))
#define GetHandleNext(h)        (PHtoH(HtoPH(h)->pNext))
#define SetHandleOwner(h,hOwn)  (HtoPH(h)->hTask = (hOwn))

/****************************************************************************

    debug support

****************************************************************************/

#if 1   // was #ifdef DEBUG_RETAIL

#define MM_GET_DEBUG        DRV_USER
#define MM_GET_DEBUGOUT     DRV_USER+1
#define MM_SET_DEBUGOUT     DRV_USER+2
#define MM_GET_MCI_DEBUG    DRV_USER+3
#define MM_SET_MCI_DEBUG    DRV_USER+4
#define MM_GET_MM_DEBUG     DRV_USER+5
#define MM_SET_MM_DEBUG     DRV_USER+6

#define MM_HINFO_NEXT       DRV_USER+10
#define MM_HINFO_TASK       DRV_USER+11
#define MM_HINFO_TYPE       DRV_USER+12
#define MM_HINFO_MCI        DRV_USER+20

#define MM_DRV_RESTART      DRV_USER+30

//
// these validation routines can be found in DEBUG.ASM
//
extern BOOL   FAR PASCAL ValidateHandle(HANDLE h, WORD wType);
extern BOOL   FAR PASCAL ValidateHeader(const void FAR* p, UINT wSize, WORD wType);
extern BOOL   FAR PASCAL ValidateReadPointer(const void FAR* p, DWORD len);
extern BOOL   FAR PASCAL ValidateWritePointer(const void FAR* p, DWORD len);
extern BOOL   FAR PASCAL ValidateDriverCallback(DWORD dwCallback, UINT wFlags);
extern BOOL   FAR PASCAL ValidateCallback(FARPROC lpfnCallback);
extern BOOL   FAR PASCAL ValidateString(LPCSTR lsz, UINT max_len);

#ifndef MMNOTIMER
extern BOOL   FAR PASCAL ValidateTimerCallback(LPTIMECALLBACK lpfn);
#endif

#define	V_HANDLE(h, t, r)	{ if (!ValidateHandle(h, t)) return (r); }
#define	V_HEADER(p, w, t, r)	{ if (!ValidateHeader((p), (w), (t))) return (r); }
#define	V_RPOINTER(p, l, r)	{ if (!ValidateReadPointer((p), (l))) return (r); }
#define	V_RPOINTER0(p, l, r)	{ if ((p) && !ValidateReadPointer((p), (l))) return (r); }
#define	V_WPOINTER(p, l, r)	{ if (!ValidateWritePointer((p), (l))) return (r); }
#define	V_WPOINTER0(p, l, r)	{ if ((p) && !ValidateWritePointer((p), (l))) return (r); }
#define	V_DCALLBACK(d, w, r)	{ if (!ValidateDriverCallback((d), (w))) return (r); }
#define	V_TCALLBACK(d, r)	{ if (!ValidateTimerCallback((d))) return (r); }
#define	V_CALLBACK(f, r)	{ if (!ValidateCallback(f)) return (r); }
#define	V_CALLBACK0(f, r)	{ if ((f) && !ValidateCallback(f)) return (r); }
#define V_STRING(s, l, r)       { if (!ValidateString(s,l)) return (r); }
#define V_FLAGS(t, b, f, r)     { if ((t) & ~(b)) {LogParamError(ERR_BAD_FLAGS, (FARPROC)(f), (LPVOID)(DWORD)(t)); return (r); }}

#else //ifdef DEBUG_RETAIL

#define	V_HANDLE(h, t, r)	{ if (!(h)) return (r); }
#define	V_HEADER(p, w, t, r)	{ if (!(p)) return (r); }
#define	V_RPOINTER(p, l, r)	{ if (!(p)) return (r); }
#define	V_RPOINTER0(p, l, r)	0
#define	V_WPOINTER(p, l, r)	{ if (!(p)) return (r); }
#define	V_WPOINTER0(p, l, r)	0
#define	V_DCALLBACK(d, w, r)	0
#define	V_TCALLBACK(d, r)	0
#define	V_CALLBACK(f, r)	{ if (!(f)) return (r); }
#define	V_CALLBACK0(f, r)	0
#define V_STRING(s, l, r)       { if (!(s)) return (r); }
#define	V_FLAGS(t, b, f, r)	0

#endif //ifdef DEBUG_RETAIL

//**************************************************************************;
//   IF YOU CHANGE THESE TYPES YOU MUST ALSO CHANGE THE ONES IN DEBUG.ASM
//**************************************************************************;
#define TYPE_WAVEOUT            1
#define TYPE_WAVEIN             2
#define TYPE_MIDIOUT            3
#define TYPE_MIDIIN             4
#define TYPE_MMIO               5
#define TYPE_IOPROC             6
#define TYPE_MCI                7
#define TYPE_DRVR               8
#define TYPE_MIXER              9
//**************************************************************************;

/****************************************************************************

    support for debug output

****************************************************************************/

#ifdef DEBUG_RETAIL

    #define ROUT(sz)                    {static SZCODE ach[] = sz; DebugOutput(DBF_TRACE | DBF_MMSYSTEM, ach); }
    #define ROUTS(sz)                   {DebugOutput(DBF_TRACE | DBF_MMSYSTEM, sz);}
    #define DebugErr(flags, sz)         {static SZCODE ach[] = "MMSYSTEM: "sz; DebugOutput((flags)   | DBF_MMSYSTEM, ach); }
    #define DebugErr1(flags, sz, a)     {static SZCODE ach[] = "MMSYSTEM: "sz; DebugOutput((flags)   | DBF_MMSYSTEM, ach,a); }
    #define DebugErr2(flags, sz, a, b)  {static SZCODE ach[] = "MMSYSTEM: "sz; DebugOutput((flags)   | DBF_MMSYSTEM, ach,a,b); }

    #define RPRINTF1(sz,x)              {static SZCODE ach[] = sz; DebugOutput(DBF_TRACE | DBF_MMSYSTEM, ach, x); }
    #define RPRINTF2(sz,x,y)            {static SZCODE ach[] = sz; DebugOutput(DBF_TRACE | DBF_MMSYSTEM, ach, x, y); }

#else //ifdef DEBUG_RETAIL

    #define ROUT(sz)
    #define ROUTS(sz)
    #define DebugErr(flags, sz)
    #define DebugErr1(flags, sz, a)
    #define DebugErr2(flags, sz, a, b)

    #define RPRINTF1(sz,x)
    #define RPRINTF2(sz,x,y)

#endif //ifdef DEBUG_RETAIL

#ifdef DEBUG

    extern void FAR cdecl  dprintf(LPSTR, ...);           // in COMM.ASM
    extern void FAR PASCAL dout(LPSTR);                   // in COMM.ASM

    #define DOUT(sz)            {static SZCODE buf[] = sz; dout(buf); }
    #define DOUTS(sz)           dout(sz);
    #define DPRINTF(x)          dprintf x
    #define DPRINTF1(sz,a)      {static SZCODE buf[] = sz; dprintf(buf, a); }
    #define DPRINTF2(sz,a,b)    {static SZCODE buf[] = sz; dprintf(buf, a, b); }

#else //ifdef DEBUG

    #define DOUT(sz)	0
    #define DOUTS(sz)	0
    #define DPRINTF(x)  0
    #define DPRINTF1(sz,a)   0
    #define DPRINTF2(sz,a,b) 0

#endif //ifdef DEBUG

#ifndef MMNOMCI
/****************************************************************************

    Internal MCI stuff

****************************************************************************/

#define MCI_VALID_DEVICE_ID(wID) ((wID) > 0 && (wID) < MCI_wNextDeviceID && MCI_lpDeviceList[wID])

#define MCI_MAX_PARAM_SLOTS 30

#define MCI_TOLOWER(c)  ((char)((c) >= 'A' && (c) <= 'Z' ? (c) + 0x20 : (c)))

typedef struct
{
    HGLOBAL             hResource;
    HINSTANCE           hModule;        // If not NULL then free module
                                        // when device is free'd
    UINT                wType;
    UINT FAR *          lpwIndex;
    LPSTR               lpResource;
#ifdef DEBUG
    WORD                wLockCount;     // Used for debugging
#endif //ifdef DEBUG
} command_table_type;

#define MCINODE_ISCLOSING       0x00000001   // Lock out all cmd's during close
#define MCINODE_ISAUTOCLOSING   0x00010000   // Lock out all cmd's during close
                                             // except internally generated close
#define MCINODE_ISAUTOOPENED    0x00020000   // Device was auto opened
#define MCINODE_16BIT_DRIVER    0x80000000   // Device is a 16-bit driver

typedef struct {
    LPSTR   lpstrName;      // The name used in subsequent calls to
                            // mciSendString to refer to the device
    LPSTR   lpstrInstallName;// The device name from system.ini
    DWORD   dwMCIOpenFlags; // Flags set on open may be:
    DWORD   lpDriverData;   // DWORD of driver instance data
    DWORD   dwElementID;    // The element ID set by MCI_OPEN_ELEMENT_ID
    YIELDPROC fpYieldProc;  // The current yield procedure if any
    DWORD   dwYieldData;    // Data send to the current yield procedure
    UINT    wDeviceID;      // The ID used in subsequent calls to
                            // mciSendCommand to refer to the device
    UINT    wDeviceType;    // The type returned from the DRV_OPEN call
                            // MCI_OPEN_SHAREABLE
                            // MCI_OPEN_ELEMENT_ID
    UINT    wCommandTable;  // The device type specific command table
    UINT    wCustomCommandTable;    // The custom device command table if any
                                    //(-1 if none)
    HINSTANCE  hDriver;     // Module instance handle for the driver
    HTASK   hCreatorTask;   // The task context the device is in
    HTASK   hOpeningTask;   // The task context which send the open command
    HDRVR   hDrvDriver;     // The installable driver handle
    DWORD   dwMCIFlags;     // Internal MCI flags
} MCI_DEVICE_NODE;

typedef MCI_DEVICE_NODE FAR      *LPMCI_DEVICE_NODE;
typedef MCI_DEVICE_NODE BMCIHEAP *PMCI_DEVICE_NODE;

typedef struct {
    LPSTR               lpstrParams;
    LPSTR FAR *         lpstrPointerList;
    HTASK               hCallingTask;
    UINT                wParsingError;
} MCI_INTERNAL_OPEN_INFO;
typedef MCI_INTERNAL_OPEN_INFO FAR *LPMCI_INTERNAL_OPEN_INFO;

typedef struct {
    LPSTR   lpstrCommand;
    LPSTR   lpstrReturnString;
    UINT    wReturnLength;
    HTASK   hCallingTask;
    LPSTR   lpstrNewDirectory;      // The current directory of the calling
                                    // task
    int     nNewDrive;              // The current drive of the calling task
} MCI_SYSTEM_MESSAGE;
typedef MCI_SYSTEM_MESSAGE FAR *LPMCI_SYSTEM_MESSAGE;

#define MCI_INIT_DEVICE_LIST_SIZE   4
#define MCI_DEVICE_LIST_GROW_SIZE   4

#define MAX_COMMAND_TABLES 20

extern BOOL MCI_bDeviceListInitialized;

extern LPMCI_DEVICE_NODE FAR *MCI_lpDeviceList;
extern UINT MCI_wDeviceListSize;

extern UINT MCI_wNextDeviceID;   // the next device ID to use for a new device

extern command_table_type command_tables[MAX_COMMAND_TABLES];

// In mciparse.c
extern void PASCAL NEAR mciToLower (LPSTR lpstrString);

extern UINT NEAR PASCAL mciLoadTableType(UINT wType);

extern LPSTR PASCAL NEAR FindCommandInTable (UINT wTable, LPCSTR lpstrCommand,
                                      UINT FAR * lpwMessage);

extern LPSTR PASCAL NEAR FindCommandItem (UINT wDeviceID, LPCSTR lpstrType,
                                   LPCSTR lpstrCommand, UINT FAR * lpwMessage,
                                   UINT FAR* lpwTable);

extern UINT PASCAL NEAR mciEatToken (LPCSTR FAR *lplpstrInput, char cSeparater,
                              LPSTR FAR *lplpstrOutput, BOOL bMustFind);

extern UINT PASCAL NEAR mciParseParams (LPCSTR lpstrParams,
                                 LPCSTR lpCommandList,
                                 LPDWORD lpdwFlags,
                                 LPSTR lpOutputParams,
                                 UINT wParamsSize,
                                 LPSTR FAR * FAR * lpPointerList,
                                 UINT FAR* lpwParsingError);

extern void NEAR PASCAL mciParserFree (LPSTR FAR *lpstrPointerList);

extern UINT NEAR PASCAL mciEatCommandEntry(LPCSTR lpEntry, LPDWORD lpValue,
                                    UINT FAR* lpID);

extern UINT NEAR PASCAL mciParseCommand (UINT wDeviceID,
                                         LPSTR lpstrCommand,
                                         LPCSTR lpstrDeviceName,
                                         LPSTR FAR * lpCommandList,
                                         UINT FAR* lpwTable);

extern UINT PASCAL NEAR mciGetParamSize (DWORD dwValue, UINT wID);

extern BOOL PASCAL NEAR mciUnlockCommandTable (UINT wCommandTable);

// In mcisys.c
extern BOOL NEAR PASCAL mciInitDeviceList(void);

extern UINT NEAR PASCAL mciOpenDevice(DWORD dwFlags,
                                     LPMCI_OPEN_PARMS lpOpenParms,
                                     LPMCI_INTERNAL_OPEN_INFO lpOpenInfo);

extern UINT NEAR PASCAL mciCloseDevice(UINT wID, DWORD dwFlags,
                                      LPMCI_GENERIC_PARMS lpGeneric,
                                      BOOL bCloseDriver);

extern UINT NEAR PASCAL mciExtractTypeFromID (LPMCI_OPEN_PARMS lpOpen);

extern DWORD PASCAL NEAR mciSysinfo (UINT wDeviceID, DWORD dwFlags,
                              LPMCI_SYSINFO_PARMS lpSysinfo);

extern UINT PASCAL NEAR mciLookUpType (LPCSTR lpstrTypeName);

extern BOOL PASCAL NEAR mciExtractDeviceType (LPCSTR lpstrDeviceName,
                                       LPSTR lpstrDeviceType,
                                       UINT wBufLen);

extern UINT NEAR PASCAL mciSetBreakKey (UINT wDeviceID, int nVirtKey, HWND hwndTrap);

extern UINT NEAR PASCAL mciGetDeviceIDInternal (LPCSTR lpstrName, HTASK hTask);

extern BOOL NEAR PASCAL Is16bitDrv(UINT wDeviceID);
extern BOOL NEAR PASCAL CouldBe16bitDrv(UINT wDeviceID);

// In mci.c
extern DWORD FAR PASCAL mciRelaySystemString (LPMCI_SYSTEM_MESSAGE lpMessage);

#endif //ifndef MMNOMCI
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\mmsystem\mmioriff.c ===
/* mmioriff.c
 *
 * MMIO RIFF functions.
 */

#include <windows.h>
#include "mmsystem.h"
#include "mmsysi.h"
#include "mmioi.h"

#define BCODE BYTE _based(_segname("_CODE"))
static	BCODE bPad;

/* @doc EXTERNAL

@api	UINT | mmioDescend | This function descends into a chunk of a
	RIFF file opened with <f mmioOpen>. It can also search for a given
	chunk.

@parm	HMMIO | hmmio | Specifies the file handle of an open RIFF file.

@parm	LPMMCKINFO | lpck | Specifies a far pointer to a
	caller-supplied  <t MMCKINFO> structure that <f mmioDescend> fills
	with the following information:

	-- The <e MMCKINFO.ckid> field is the chunk ID of the chunk.

	-- The <e MMCKINFO.cksize> field is the size of the data portion
	of the chunk. The data size includes the form type or list type (if
	any), but does not include the 8-byte chunk header or the pad byte at
	the end of the data (if any).

	-- The <e MMCKINFO.fccType> field is the form type if 
	<e MMCKINFO.ckid> is "RIFF", or the list type if 
	<e MMCKINFO.ckid> is "LIST". Otherwise, it is NULL.

	-- The <e MMCKINFO.dwDataOffset> field is the file offset of the
	beginning of the data portion of the chunk.	If the chunk is a
	"RIFF" chunk or a "LIST" chunk, then <e MMCKINFO.dwDataOffset>
	is the offset of the form type or list type.

	-- The <e MMCKINFO.dwFlags> contains other information about the chunk.
	Currently, this information is not used and is set to zero.

	If the MMIO_FINDCHUNK, MMIO_FINDRIFF, or MMIO_FINDLIST flag is
	specified for <p wFlags>, then the <t MMCKINFO> structure is also
	used to pass parameters to <f mmioDescend>:

	-- The <e MMCKINFO.ckid> field specifies the four-character code
	of the chunk ID, form type, or list type to search for.

@parm	LPMMCKINFO | lpckParent | Specifies a far pointer to an
	optional caller-supplied <t MMCKINFO> structure identifying
	the parent of the chunk being searched for.
	A parent of a chunk is the enclosing chunk--only "RIFF" and "LIST"
	chunks can be parents.  If <p lpckParent> is not NULL, then 
	<f mmioDescend> assumes the <t MMCKINFO> structure it refers to
	was filled when <f mmioDescend> was called to descend into the parent
	chunk, and <f mmioDescend> will only search for a chunk within the
	parent chunk. Set <p lpckParent> to NULL if no parent chunk is
	being specified.

@parm	UINT | wFlags | Specifies search options. Contains up to one
	of the following flags. If no flags are specified, 
	<f mmioDescend> descends into the chunk beginning at the current file
	position. 

	@flag	MMIO_FINDCHUNK | Searches for a chunk with the specified chunk ID.

	@flag	MMIO_FINDRIFF | Searches for a chunk with chunk ID "RIFF"
		and with the specified form type.

	@flag	MMIO_FINDLIST | Searches for a chunk with chunk ID "LIST"
		and with the specified form type.

@rdesc	The return value is zero if the function is successful.
	Otherwise, the return value specifies an error code. If the end of
	the file (or the end of the parent chunk, if given) is reached before
	the desired chunk is found, the return value is
	MMIOERR_CHUNKNOTFOUND. 

@comm	A RIFF chunk consists of a four-byte chunk ID (type FOURCC),
	followed by a four-byte chunk size (type DWORD), followed
	by the data portion of the chunk, followed by a null pad byte if
	the size of the data portion is odd. If the chunk ID is "RIFF" or
	"LIST", the first four bytes of the data portion of the chunk are
	a form type or list type (type FOURCC).

	If <f mmioDescend> is used to search for a chunk, the file 
	position should be at the beginning of a
	chunk before calling <f mmioDescend>. The search begins at the
	current file position and continues to the end of the file. If a
	parent chunk is specified, the file position should be somewhere
	within the parent chunk before calling <f mmioDescend>. In this case,
	the search begins at the current file position and continues to the
	end of the parent chunk.

	If <f mmioDescend> is unsuccessful in searching for a chunk, the
	current file position is undefined. If <f mmioDescend> is
	successful, the current file position is changed. If the chunk 
	is a "RIFF" or "LIST" chunk, the new file position
	will be just after the form type or list type (12 bytes from the
	beginning of the chunk). For other chunks, the new file position will be
	the start of the data portion of the chunk (8 bytes from the
	beginning of the chunk).
		
	For efficient RIFF file I/O, use buffered I/O.

	@xref	mmioAscend MMCKINFO
*/
UINT WINAPI
mmioDescend(HMMIO hmmio, LPMMCKINFO lpck, const MMCKINFO FAR* lpckParent, UINT wFlags)
{
	FOURCC		ckidFind;	// chunk ID to find (or NULL)
	FOURCC		fccTypeFind;	// form/list type to find (or NULL)

	V_FLAGS(wFlags, MMIO_DESCEND_VALID, mmioDescend, MMSYSERR_INVALFLAG);
	V_WPOINTER(lpck, sizeof(MMCKINFO), MMSYSERR_INVALPARAM);
	V_RPOINTER0(lpckParent, sizeof(MMCKINFO), MMSYSERR_INVALPARAM);

	/* figure out what chunk id and form/list type to search for */
	if (wFlags & MMIO_FINDCHUNK)
		ckidFind = lpck->ckid, fccTypeFind = NULL;
	else
	if (wFlags & MMIO_FINDRIFF)
		ckidFind = FOURCC_RIFF, fccTypeFind = lpck->fccType;
	else
	if (wFlags & MMIO_FINDLIST)
		ckidFind = FOURCC_LIST, fccTypeFind = lpck->fccType;
	else
		ckidFind = fccTypeFind = NULL;
	
	lpck->dwFlags = 0L;

	while (TRUE)
	{
		UINT		w;

		/* read the chunk header */
		if (mmioRead(hmmio, (HPSTR) lpck, 2 * sizeof(DWORD)) !=
		    2 * sizeof(DWORD))
			return MMIOERR_CHUNKNOTFOUND;

		/* store the offset of the data part of the chunk */
		if ((lpck->dwDataOffset = mmioSeek(hmmio, 0L, SEEK_CUR)) == -1)
			return MMIOERR_CANNOTSEEK;
		
		/* see if the chunk is within the parent chunk (if given) */
		if ((lpckParent != NULL) &&
		    (lpck->dwDataOffset - 8L >=
		     lpckParent->dwDataOffset + lpckParent->cksize))
			return MMIOERR_CHUNKNOTFOUND;

		/* if the chunk if a 'RIFF' or 'LIST' chunk, read the
		 * form type or list type
		 */
		if ((lpck->ckid == FOURCC_RIFF) || (lpck->ckid == FOURCC_LIST))
		{
			if (mmioRead(hmmio, (HPSTR) &lpck->fccType,
				     sizeof(DWORD)) != sizeof(DWORD))
				return MMIOERR_CHUNKNOTFOUND;
		}
		else
			lpck->fccType = NULL;

		/* if this is the chunk we're looking for, stop looking */
		if ( ((ckidFind == NULL) || (ckidFind == lpck->ckid)) &&
		     ((fccTypeFind == NULL) || (fccTypeFind == lpck->fccType)) )
			break;
		
		/* ascend out of the chunk and try again */
		if ((w = mmioAscend(hmmio, lpck, 0)) != 0)
			return w;
	}

	return 0;
}


/* @doc EXTERNAL

@api	UINT | mmioAscend | This function ascends out of a chunk in a
	RIFF file descended into with <f mmioDescend> or created with 
	<f mmioCreateChunk>. 

@parm	HMMIO | hmmio | Specifies the file handle of an open RIFF file.

@parm	LPMMCKINFO | lpck | Specifies a far pointer to a
	caller-supplied <t MMCKINFO> structure previously filled by 
	<f mmioDescend> or <f mmioCreateChunk>.

@parm	UINT | wFlags | Is not used and should be set to zero.

@rdesc	The return value is zero if the function is successful.
	Otherwise, the return value specifies an error code. The error
	code can be one of the following codes:

	@flag MMIOERR_CANNOTWRITE | The contents of the buffer could
	not be written to disk.
	    
	@flag MMIOERR_CANNOTSEEK | There was an error while seeking to
	the end of the chunk.

@comm	If the chunk was descended into using <f mmioDescend>, then
	<f mmioAscend> seeks to the location following the end of the
	chunk (past the extra pad byte, if any).

	If the chunk was created and descended into using
	<f mmioCreateChunk>, or if the MMIO_DIRTY flag is set in the 
	<e MMCKINFO.dwFlags> field of the <t MMCKINFO> structure
	referenced by <p lpck>, then the current file position
	is assumed to be the end of the data portion of the chunk.
	If the chunk size is not the same as the value stored
	in the <e MMCKINFO.cksize> field when <f mmioCreateChunk>
	was called, then <f mmioAscend> corrects the chunk
	size in the file before ascending from the chunk. If the chunk
	size is odd, <f mmioAscend> writes a null pad byte at the end of the
	chunk. After ascending from the chunk, the current file position is
	the location following the end of the chunk (past the extra pad byte,
	if any).

@xref	mmioDescend mmioCreateChunk MMCKINFO
*/
UINT WINAPI
mmioAscend(HMMIO hmmio, LPMMCKINFO lpck, UINT wFlags)
{
	V_FLAGS(wFlags, 0, mmioAscend, MMSYSERR_INVALFLAG);
	V_WPOINTER(lpck, sizeof(MMCKINFO), MMSYSERR_INVALPARAM);

	if (lpck->dwFlags & MMIO_DIRTY)
	{
		/* <lpck> refers to a chunk created by mmioCreateChunk();
		 * check that the chunk size that was written when
		 * mmioCreateChunk() was called is the real chunk size;
		 * if not, fix it
		 */
		LONG		lOffset;	// current offset in file
		LONG		lActualSize;	// actual size of chunk data

		if ((lOffset = mmioSeek(hmmio, 0L, SEEK_CUR)) == -1)
			return MMIOERR_CANNOTSEEK;
		if ((lActualSize = lOffset - lpck->dwDataOffset) < 0)
			return MMIOERR_CANNOTWRITE;

		if (LOWORD(lActualSize) & 1)
		{
			/* chunk size is odd -- write a null pad byte */
			if (mmioWrite(hmmio, (HPSTR) &bPad, sizeof(bPad))
					!= sizeof(bPad))
				return MMIOERR_CANNOTWRITE;
			
		}

		if (lpck->cksize == (DWORD)lActualSize)
			return 0;

		/* fix the chunk header */
		lpck->cksize = lActualSize;
		if (mmioSeek(hmmio, lpck->dwDataOffset
				- sizeof(DWORD), SEEK_SET) == -1)
			return MMIOERR_CANNOTSEEK;
		if (mmioWrite(hmmio, (HPSTR) &lpck->cksize,
				sizeof(DWORD)) != sizeof(DWORD))
			return MMIOERR_CANNOTWRITE;
	}

	/* seek to the end of the chunk, past the null pad byte
	 * (which is only there if chunk size is odd)
	 */
	if (mmioSeek(hmmio, lpck->dwDataOffset + lpck->cksize
		+ (lpck->cksize & 1L), SEEK_SET) == -1)
		return MMIOERR_CANNOTSEEK;

	return 0;
}


/* @doc EXTERNAL

@api	UINT | mmioCreateChunk | This function creates a chunk in a
	RIFF file opened with <f mmioOpen>. The new chunk is created at the
	current file position. After the new chunk is created, the current
	file position is the beginning of the data portion of the new chunk.

@parm	HMMIO | hmmio | Specifies the file handle of an open RIFF
	file.

@parm	LPMMCKINFO | lpck | Specifies a pointer to a caller-supplied
	<t MMCKINFO> structure containing information about the chunk to be
	created. The <t MMCKINFO> structure should be set up as follows:

	-- The <e MMCKINFO.ckid> field specifies the chunk ID of the
	chunk. If <p wFlags> includes MMIO_CREATERIFF or MMIO_CREATELIST,
	this field will be filled by <f mmioCreateChunk>.

	-- The <e MMCKINFO.cksize> field specifies the size of the data
	portion of the chunk, including the form type or list type (if any).
	If this value is not correct when <f mmioAscend> is called to mark
	the end of the chunk, them <f mmioAscend> will correct the chunk
	size.

	-- The <e MMCKINFO.fccType> field specifies the form type or list
	type if the chunk is a "RIFF" or "LIST" chunk. If the chunk is not a
	"RIFF" or "LIST" chunk, this field need not be filled in.

	-- The <e MMCKINFO.dwDataOffset> field need not be filled in. The
	<f mmioCreateChunk> function will fill this field with the file
	offset of the data portion of the chunk.

	-- The <e MMCKINFO.dwFlags> field need not be filled in. The 
	<f mmioCreateChunk> function will set the MMIO_DIRTY flag in 
	<e MMCKINFO.dwFlags>.

@parm	UINT | wFlags | Specifies flags to optionally create either a
	"RIFF" chunk or a "LIST" chunk. Can contain one of the following
	flags: 

	@flag	MMIO_CREATERIFF | Creates a "RIFF" chunk.

	@flag	MMIO_CREATELIST | Creates a "LIST" chunk.

@rdesc	The return value is zero if the function is successful.
	Otherwise, the return value specifies an error code. The error
	code can be one of the following codes:

	@flag MMIOERR_CANNOTWRITE | Unable to write the chunk header.

	@flag MMIOERR_CANNOTSEEK | Uanble to determine offset of data
    portion of the chunk.

@comm	This function cannot insert a chunk into the middle of a
	file. If a chunk is created anywhere but the end of a file, 
	<f mmioCreateChunk> will overwrite existing information in the file.
*/
UINT WINAPI
mmioCreateChunk(HMMIO hmmio, LPMMCKINFO lpck, UINT wFlags)
{
	int		iBytes;			// bytes to write
	LONG		lOffset;	// current offset in file

	V_FLAGS(wFlags, MMIO_CREATE_VALID, mmioCreateChunk, MMSYSERR_INVALFLAG);
	V_WPOINTER(lpck, sizeof(MMCKINFO), MMSYSERR_INVALPARAM);

	/* store the offset of the data part of the chunk */
	if ((lOffset = mmioSeek(hmmio, 0L, SEEK_CUR)) == -1)
		return MMIOERR_CANNOTSEEK;
	lpck->dwDataOffset = lOffset + 2 * sizeof(DWORD);

	/* figure out if a form/list type needs to be written */
	if (wFlags & MMIO_CREATERIFF)
		lpck->ckid = FOURCC_RIFF, iBytes = 3 * sizeof(DWORD);
	else
	if (wFlags & MMIO_CREATELIST)
		lpck->ckid = FOURCC_LIST, iBytes = 3 * sizeof(DWORD);
	else
		iBytes = 2 * sizeof(DWORD);

	/* write the chunk header */
	if (mmioWrite(hmmio, (HPSTR) lpck, (LONG) iBytes) != (LONG) iBytes)
		return MMIOERR_CANNOTWRITE;

	lpck->dwFlags = MMIO_DIRTY;

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\mmsystem\sources.inc ===
TARGETNAME=
TARGETTYPE=NOTARGET
TARGETPATH=
SOURCES=

NTTARGETFILE1=buildall

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\mmsystem\playwav.c ===
#include <windows.h>
#define MMNOTIMER
#define MMNOSEQ
#define MMNOJOY
#define MMNOMIDI
#define MMNOMCI
#include "mmsystem.h"
#include "mmsysi.h"         // to get DOUT() and _hread()
#include "playwav.h"

//
// These globals are used to keep track of the currently playing sound, and
// the handle to the wave device.  only 1 sound can be playing at a time.
//

static HWAVEOUT    hWaveOut;         // handle to open wave device
LPWAVEHDR   lpWavHdr;         // current wave file playing

/* flags for _lseek */
#define  SEEK_CUR 1
#define  SEEK_END 2
#define  SEEK_SET 0

#define FMEM                (GMEM_MOVEABLE|GMEM_SHARE)

BOOL  NEAR PASCAL soundInitWavHdr(LPWAVEHDR lpwh, LPCSTR lpMem, DWORD dwLen);
BOOL  NEAR PASCAL soundOpen(HGLOBAL hSound, UINT wFlags);
BOOL  NEAR PASCAL soundClose(void);
void  NEAR PASCAL soundWait(void);

/*****************************************************************************
 * @doc INTERNAL
 *
 * @api void | WaveOutNotify  | called by mmWndProc when it recives a
 *                              MM_WOM_DONE message
 * @rdesc None.
 *
 ****************************************************************************/

void FAR PASCAL WaveOutNotify(WPARAM wParam, LPARAM lParam)
{
    if (hWaveOut && !(lpWavHdr->dwFlags & WHDR_DONE))
        return;         // wave is not done! get out

    //
    // wave file is done! release the device
    //

    DOUT("MMSYSTEM: ASYNC sound done, closing wave device\r\n");

    soundClose();
}

/*****************************************************************************
 * @doc INTERNAL
 *
 * @api BOOL | soundPlay   | Pretty much speaks for itself!
 *
 * @parm HGLOBAL | hSound | The sound resource to play.
 *
 * @parm wFlags | UINT | flags controlling sync/async etc.
 *
 *  @flag  SND_SYNC            | play synchronously (default)
 *  @flag  SND_ASYNC           | play asynchronously
 *
 * @rdesc Returns TRUE if successful and FALSE on failure.
 ****************************************************************************/
BOOL NEAR PASCAL soundPlay(HGLOBAL hSound, UINT wFlags)
{
    //
    // Before playing a sound release it
    //
    soundClose();

    //
    // open the sound device and write the sound to it.
    //
    if (!soundOpen(hSound, wFlags))
        return FALSE;

    if (!(wFlags & SND_ASYNC))
    {
        soundWait();
        soundClose();
    }
    return TRUE;
}

/*****************************************************************************
 * @doc INTERNAL
 *
 * @api BOOL | soundOpen  | Open the wave device and write a sound to it.
 *
 * @parm HGLOBAL | hSound | The sound resource to play.
 *
 * @rdesc Returns TRUE if successful and FALSE on failure.
 ****************************************************************************/
BOOL NEAR PASCAL soundOpen(HGLOBAL hSound, UINT wFlags)
{
    UINT        wErr;

    if (!hSound || !hwndNotify)
        return FALSE;

    if (hWaveOut)
    {
        DOUT("MMSYSTEM: soundOpen() wave device is currently open.\r\n");
        return FALSE;
    }

    lpWavHdr = (LPWAVEHDR)GlobalLock(hSound);

    if (!lpWavHdr)
        {
#ifdef DEBUG
        if ((GlobalFlags(hSound) & GMEM_DISCARDED))
            DOUT("MMSYSTEM: sound was discarded before play could begin.\r\n");
#endif
        return FALSE;
        }

    //
    // open the wave device, open any wave device that supports the
    // format
    //
    wErr = waveOutOpen(&hWaveOut,           // returns handle to device
            (UINT)WAVE_MAPPER,                    // device id (any device)
            (LPWAVEFORMAT)lpWavHdr->dwUser, // wave format
            (DWORD)(UINT)hwndNotify,        // callback function
            0L,                      // callback instance data
            WAVE_ALLOWSYNC | CALLBACK_WINDOW);               // flags

    if (wErr != 0)
    {
        DOUT("MMSYSTEM: soundOpen() unable to open wave device\r\n");
        GlobalUnlock(hSound);
        lpWavHdr = NULL;
        hWaveOut = NULL;
        return FALSE;
    }

    wErr = waveOutPrepareHeader(hWaveOut, lpWavHdr, sizeof(WAVEHDR));

    if (wErr != 0)
    {
        DOUT("MMSYSTEM: soundOpen() waveOutPrepare failed\r\n");
        soundClose();
        return FALSE;
    }

    //
    // Only allow sound looping if playing ASYNC sounds
    //
    if ((wFlags & SND_ASYNC) && (wFlags & SND_LOOP))
    {
        lpWavHdr->dwLoops  = 0xFFFFFFFF;     // infinite loop
        lpWavHdr->dwFlags |= WHDR_BEGINLOOP|WHDR_ENDLOOP;
    }
    else
    {
        lpWavHdr->dwLoops  = 0;
        lpWavHdr->dwFlags &=~(WHDR_BEGINLOOP|WHDR_ENDLOOP);
    }

    lpWavHdr->dwFlags &= ~WHDR_DONE;        // mark as not done!
    wErr = waveOutWrite(hWaveOut, lpWavHdr, sizeof(WAVEHDR));

    if (wErr != 0)
    {
        DOUT("MMSYSTEM: soundOpen() waveOutWrite failed\r\n");
        soundClose();
        return FALSE;
    }

    return TRUE;
}

/*****************************************************************************
 * @doc INTERNAL
 *
 * @func BOOL | soundClose | This function closes the sound device
 *
 * @rdesc Returns TRUE if successful and FALSE on failure.
 ****************************************************************************/
BOOL NEAR PASCAL soundClose(void)
{
    UINT        wErr;

    //
    // Do we have the sound device open?
    //
    if (!lpWavHdr || !hWaveOut)
        return TRUE;

    //
    // if the block is still playing, stop it!
    //
    if (!(lpWavHdr->dwFlags & WHDR_DONE))
        waveOutReset(hWaveOut);

#ifdef DEBUG
    if (!(lpWavHdr->dwFlags & WHDR_DONE))
    {
        DOUT("MMSYSTEM: soundClose() data is not DONE!???\r\n");
        lpWavHdr->dwFlags |= WHDR_DONE;
    }

    if (!(lpWavHdr->dwFlags & WHDR_PREPARED))
    {
        DOUT("MMSYSTEM: soundClose() data not prepared???\r\n");
    }
#endif

    //
    // unprepare the data anyway!
    //
    wErr = waveOutUnprepareHeader(hWaveOut, lpWavHdr, sizeof(WAVEHDR));

    if (wErr != 0)
    {
        DOUT("MMSYSTEM: soundClose() waveOutUnprepare failed?\r\n");
    }

    //
    // finaly actually close the device, and unlock the data
    //
    waveOutClose(hWaveOut);
    GlobalUnlock((HGLOBAL)HIWORD(lpWavHdr));

    //
    // update globals, claiming the device is closed.
    //
    hWaveOut = NULL;
    lpWavHdr = NULL;
    return TRUE;
}

/*****************************************************************************
 * @doc INTERNAL
 *
 * @api void | soundWait | wait for the sound device to complete
 *
 * @rdesc none
 ****************************************************************************/
void NEAR PASCAL soundWait(void)
{
    if (lpWavHdr)
        while (!(lpWavHdr->dwFlags & WHDR_DONE))
            ;
}

/*****************************************************************************
 * @doc INTERNAL
 *
 * @api void | soundFree | This function frees a sound resource created
 *      with soundLoadFile or soundLoadMemory
 *
 * @rdesc Returns TRUE if successful and FALSE on failure.
 ****************************************************************************/
void NEAR PASCAL soundFree(HGLOBAL hSound)
{
    if (!hSound)
        return;

    // !!! we should only close the sound device iff this hSound is playing!
    //
    soundClose();
    GlobalFree(hSound);
}

/*****************************************************************************
 * @doc INTERNAL
 *
 * @api HGLOBAL | soundLoadFile | Loads a specified sound resource from a
 *	file into a global, discardable object.
 *
 * @parm LPCSTR | lpszFile | The file from which to load the sound resource.
 *
 * @rdesc Returns NULL on failure, GLOBAL HANDLE to a WAVEHDR iff success
 ****************************************************************************/
HGLOBAL NEAR PASCAL soundLoadFile(LPCSTR szFileName)
{
    HFILE       fh;
    OFSTRUCT    of;
    DWORD       dwSize;
    LPSTR       lpData;
    HGLOBAL     h;
    UINT        wNameLen;

    // open the file
    fh = OpenFile(szFileName, &of, OF_READ | OF_SHARE_DENY_NONE);
    if (fh == HFILE_ERROR)
        return NULL;

    wNameLen = lstrlen(szFileName) + 1;
    dwSize = _llseek(fh, 0l, SEEK_END);   // get the size of file
    _llseek(fh, 0l, SEEK_SET);            // seek back to the start

    // allocate some discardable memory for a wave hdr, name and the file data.
    h = GlobalAlloc(FMEM+GMEM_DISCARDABLE, sizeof(WAVEHDR) + wNameLen + dwSize);
    if (!h)
        goto error1;

    // lock it down
    lpData = GlobalLock(h);

    // read the file into the memory block

    if (_hread(fh,lpData+sizeof(WAVEHDR)+wNameLen,(LONG)dwSize) != (LONG)dwSize)
        goto error3;

    // do the rest of it from the memory image
    if (!soundInitWavHdr((LPWAVEHDR)lpData, lpData+sizeof(WAVEHDR)+wNameLen, dwSize))
        goto error3;

    _lclose(fh);

    lstrcpy(lpData+sizeof(WAVEHDR), szFileName);
    GlobalUnlock(h);
    return h;

error3:
    GlobalUnlock(h);
    GlobalFree(h);
error1:
    _lclose(fh);
    return NULL;
}

/*****************************************************************************
 * @doc INTERNAL
 *
 * @api HGLOBAL | soundLoadMemory | Loads a user specified sound resource from a
 *	a memory block supplied by the caller.
 *
 * @parm LPCSTR | lpMem | Pointer to a memory image of the file
 *
 * @rdesc Returns NULL on failure, GLOBAL HANDLE to a WAVEHDR iff success
 ****************************************************************************/
HGLOBAL NEAR PASCAL soundLoadMemory(LPCSTR lpMem)
{
    HGLOBAL h;
    LPSTR lp;

    // allocate some memory, for a wave hdr
    h = GlobalAlloc(FMEM, (LONG)sizeof(WAVEHDR)+1);
    if (!h)
        goto error1;

    // lock it down
    lp = GlobalLock(h);

    //
    // we must assume the memory pointer is correct! (hence the -1l)
    //
    if (!soundInitWavHdr((LPWAVEHDR)lp, lpMem, (DWORD)-1l))
        goto error3;

    lp[sizeof(WAVEHDR)] = (char)0;        // No file name for memory file
    GlobalUnlock(h);
    return h;

error3:
    GlobalUnlock(h);
    GlobalFree(h);
error1:
    return NULL;
}

/*****************************************************************************
 * @doc INTERNAL
 *
 * @api BOOL | soundInitWavHdr | Initializes a WAVEHDR data structure from a
 *                         pointer to a memory image of a RIFF WAV file.
 *
 * @parm LPWAVHDR | lpwh | Pointer to a WAVEHDR
 *
 * @parm LPCSTR | lpMem | Pointer to a memory image of a RIFF WAV file
 *
 * @rdesc Returns FALSE on failure, TRUE on success.
 *
 * @comm the dwUser field of the WAVEHDR structure is initialized to point
 * to the WAVEFORMAT structure that is inside the RIFF data
 *
 ****************************************************************************/
BOOL NEAR PASCAL soundInitWavHdr(LPWAVEHDR lpwh, LPCSTR lpMem, DWORD dwLen)
{
    FPFileHeader fpHead;
    LPWAVEFORMAT lpFmt;
    LPCSTR	 lpData;
    DWORD	 dwFileSize,dwCurPos;
    DWORD        dwSize;

    if (dwLen < sizeof(FileHeader))
        return FALSE;

    // assume the first few bytes are the file header
    fpHead = (FPFileHeader) lpMem;

    // check that it's a valid RIFF file and a valid WAVE form.
    if (fpHead->dwRiff != RIFF_FILE || fpHead->dwWave != RIFF_WAVE ) {
        return FALSE;
    }

    dwFileSize = fpHead->dwSize;
    dwCurPos = sizeof(FileHeader);
    lpData = lpMem + sizeof(FileHeader);

    if (dwLen < dwFileSize)     // RIFF header
        return FALSE;

    // scan until we find the 'fmt' chunk
    while( 1 ) {
        if( ((FPChunkHeader)lpData)->dwCKID == RIFF_FORMAT )
            break; // from the while loop that's looking for it
        dwCurPos += ((FPChunkHeader)lpData)->dwSize + sizeof(ChunkHeader);
	if( dwCurPos >= dwFileSize )
            return FALSE;
        lpData += ((FPChunkHeader)lpData)->dwSize + sizeof(ChunkHeader);
    }

    // now we're at the beginning of the 'fmt' chunk data
    lpFmt = (LPWAVEFORMAT) (lpData + sizeof(ChunkHeader));

    // scan until we find the 'data' chunk
    lpData = lpData + ((FPChunkHeader)lpData)->dwSize + sizeof(ChunkHeader);
    while( 1 ) {
        if( ((FPChunkHeader)lpData)->dwCKID == RIFF_CHANNEL)
            break; // from the while loop that's looking for it
        dwCurPos += ((FPChunkHeader)lpData)->dwSize + sizeof(ChunkHeader);
	if( dwCurPos >= dwFileSize )
	    return NULL;
        lpData += ((FPChunkHeader)lpData)->dwSize + sizeof(ChunkHeader);
    }

    // now we're at the beginning of the 'data' chunk data
    dwSize = ((FPChunkHeader)lpData)->dwSize;
    lpData = lpData + sizeof(ChunkHeader);

    // initialize the WAVEHDR

    lpwh->lpData    = (LPSTR)lpData;    // pointer to locked data buffer
    lpwh->dwBufferLength  = dwSize;     // length of data buffer
    lpwh->dwUser    = (DWORD)lpFmt;     // for client's use
    lpwh->dwFlags   = WHDR_DONE;        // assorted flags (see defines)
    lpwh->dwLoops   = 0;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\mmsystem\mmsex.c ===
/*
**  MMSEX.C
**
**  Example applet DLL to be displayed by the Multimedia Control Panel.
**
**  History:
**
**  Wed Apr 18 1990 -by- MichaelE
**
*/

#ifndef DEBUG
    #define DEBUG
#endif

#include <windows.h>
#include "mmsystem.h"
#include <cpl.h>
#include "mmsysi.h"
#include "mmsex.dlg"

LRESULT FAR PASCAL _loadds _export CPlApplet   ( HWND, UINT, LPARAM, LPARAM );
BOOL FAR PASCAL _loadds            DebugDlg    ( HWND, UINT, WPARAM, LPARAM );

static SZCODE szMenuName[] = "mmse&x";
static SZCODE szInfoName[] = "change mmsystem debug settings 1.01";
static SZCODE szHelpFile[] = "";

#define MAX_TYPE 7
static SZCODE szTypes[] =
    "???????\0"         // 0
    "WaveOut\0"         // 1 TYPE_WAVEOUT
    "WaveIn \0"         // 2 TYPE_WAVEIN
    "MidiOut\0"         // 3 TYPE_MIDIOUT
    "MidiIn \0"         // 4 TYPE_MIDIIN
    "mmio   \0"         // 5 TYPE_MMIO
    "IOProc \0";        // 6 TYPE_IOPROC

int nLoadedCount = 0;
HDRVR hdrv;
int iNumHandles = 0;

/* This function is exported so CPL.EXE can do a GetProcAddress() on
** the label and send the messages described below.
** To make MMCPL.EXE load your DLL, and thus add your applets to its
** window, add a keyname under the [MMCPL] application in
** WIN.INI:
**
** [MMCPL]
** myapplets=c:\mydir\applet.dll
**
** CPL.EXE loads the WIN3 Control Panel applets first, followed by the
** applets named in WIN.INI, then those from the directory it was loaded,
** and finally those in the WIN3 SYSTEM directory.
**
*/
LRESULT FAR PASCAL _loadds _export CPlApplet(
HWND            hCPlWnd,
UINT            Msg,
LPARAM          lParam1,
LPARAM          lParam2)
{
    LPNEWCPLINFO   lpCPlInfo;
    int i;

    switch( Msg )
    {
        case CPL_INIT:
            if (!hdrv)
                hdrv = OpenDriver("mmsystem.dll", NULL, 0);

            if (!hdrv)
                return (LRESULT)FALSE;

// #if 0
            if (!SendDriverMessage(hdrv, MM_GET_DEBUG, 0, 0))
            {
                CloseDriver(hdrv,0,0);
                hdrv = NULL;
                return (LRESULT)FALSE;
            }
// #endif
            nLoadedCount++;

            // first message to CPlApplet(), sent once only
            return (LRESULT)TRUE;

        case CPL_GETCOUNT:
            // second message to CPlApplet(), sent once only
            return (LRESULT)1;

        case CPL_NEWINQUIRE:
            /* third message to CPlApplet().  It is sent as many times
               as the number of applets returned by CPL_GETCOUNT message
            */
            lpCPlInfo = (LPNEWCPLINFO)lParam2;

            // lParam1 is an index ranging from 0 to (NUM_APPLETS-1)
            i = (int)lParam1;

            lpCPlInfo->dwSize = sizeof(NEWCPLINFO);
            lpCPlInfo->dwFlags = 0;
            lpCPlInfo->dwHelpContext = 0;  // help context to use
            lpCPlInfo->lData = 0;          // user defined data
            lpCPlInfo->hIcon = LoadIcon(ghInst, MAKEINTATOM(DLG_MMSEX));
            lstrcpy(lpCPlInfo->szName, szMenuName);
            lstrcpy(lpCPlInfo->szInfo, szInfoName);
            lstrcpy(lpCPlInfo->szHelpFile, szHelpFile);

            return (LRESULT)TRUE;

        case CPL_SELECT:
            /* One of your applets has been selected.
               lParam1 is an index from 0 to (NUM_APPLETS-1)
               lParam2 is the lData value associated with the applet
            */
            break;

        case CPL_DBLCLK:
            /* One of your applets has been double-clicked.
               lParam1 is an index from 0 to (NUM_APPLETS-1)
               lParam2 is the lData value associated with the applet
            */
            DialogBox(ghInst,MAKEINTRESOURCE(DLG_MMSEX),hCPlWnd,DebugDlg);
            break;

        case CPL_STOP:
            /* Sent once for each applet prior to the CPL_EXIT msg.
               lParam1 is an index from 0 to (NUM_APPLETS-1)
               lParam2 is the lData value associated with the applet
            */
            break;

        case CPL_EXIT:
            /* Last message, sent once only, before MMCPL.EXE calls
               FreeLibrary() on your DLL.
            */
            nLoadedCount--;

            if (hdrv && !nLoadedCount)
            {
                CloseDriver(hdrv,0,0);
                hdrv = NULL;
            }
            break;

        default:
            break;
    }
    return( 0L );
}

int QueryRadioButton(HWND hdlg, int idFirst, int idLast)
{
    int id;

    for (id=idFirst; id<=idLast; id++)
    {
        if (IsDlgButtonChecked(hdlg, id))
            return id;
    }

    return 0;
}

#if 0   // API in win31

BOOL NEAR PASCAL IsTask(HANDLE hTask)
{
_asm {
;       push    si
        mov     ax,hTask
        or      ax,ax
        jz      error

        lsl     si,ax
        jnz     error

        call    GetCurrentTask
        lsl     ax,ax
        cmp     si,ax
        je      exit
error:
        xor     ax,ax
exit:
;       pop     si
}}

#endif


void NEAR PASCAL GetTaskName(HANDLE hTask, LPSTR pname)
{
    if (!IsTask(hTask))
    {
        lstrcpy(pname,"????");
    }
    else
    {
        ((LPDWORD)pname)[0] = ((LPDWORD)MAKELONG(0xF2,hTask))[0];
        ((LPDWORD)pname)[1] = ((LPDWORD)MAKELONG(0xF2,hTask))[1];
        pname[8] = 0;
    }
}

#define SLASH(c)   ((c) == '/' || (c) == '\\')

LPSTR FileName(LPSTR szPath)
{
    LPSTR   sz;

    for (sz=szPath; *sz; sz++)
	;
    for (; sz>=szPath && !SLASH(*sz) && *sz!=':'; sz--)
	;
    return ++sz;
}

int fQuestion(LPSTR sz,...)
{
    char ach[128];

    wvsprintf (ach,sz,(LPSTR)(&sz+1));    /* Format the string */
    return MessageBox(NULL,ach,"mmsex",MB_YESNO|MB_ICONQUESTION|MB_TASKMODAL);
}

void GetHandles(HWND hdlg)
{
    HLOCAL  h;
    HTASK   hTask;
    DWORD   wType;
    UINT    n;
    int     i;
    UINT    j;
    int     iSel;
    char    ach[80];
    char    szTask[80];
    char    szName[80];
    HWND    hlb;

    iNumHandles=0;

    hlb = GetDlgItem(hdlg, ID_HANDLES);

    iSel = (int)SendMessage(hlb,LB_GETCURSEL,0,0L);
    SendMessage(hlb, WM_SETREDRAW, (WPARAM)FALSE, 0);
    SendMessage(hlb, LB_RESETCONTENT, 0, 0);

    //
    // fill listbox with all active handles in system
    //
    for (h = (HLOCAL)(LONG)SendDriverMessage(hdrv, MM_HINFO_NEXT, NULL, 0);
         h;
         h = (HLOCAL)(LONG)SendDriverMessage(hdrv, MM_HINFO_NEXT, (LPARAM)(LONG)(UINT)h, 0) )
    {
        iNumHandles++;

        wType  = (UINT)SendDriverMessage(hdrv, MM_HINFO_TYPE, (LPARAM)(LONG)(UINT)h, 0);
        hTask  = (HTASK)(LONG)SendDriverMessage(hdrv, MM_HINFO_TASK, (LPARAM)(LONG)(UINT)h, 0);

        if (wType >= MAX_TYPE)
            wType = 0;

        GetTaskName(hTask, szTask);

        wsprintf(ach, "%ls %04X %ls",(LPSTR)szTypes + wType*(sizeof(szTypes)-1)/MAX_TYPE,h,(LPSTR)szTask);

        i = (int)(LONG)SendMessage(hlb, LB_ADDSTRING, 0, (LPARAM)(LPSTR)ach);
        SendMessage(hlb, LB_SETITEMDATA, (WPARAM)i, MAKELPARAM(h, wType));
    }

    //
    // add to that all MCI handles
    //
    n = (UINT)(LONG)SendDriverMessage(hdrv, MM_HINFO_MCI, 0, 0);

    for (j = 1; j < n; j++)
    {
        MCI_DEVICE_NODE node;

        if (!SendDriverMessage(hdrv, MM_HINFO_MCI, (LPARAM)j, (LPARAM)(LPVOID)&node))
            continue;

        iNumHandles++;

        if (node.lpstrName == NULL)
            node.lpstrName = "";
        if (node.lpstrInstallName == NULL)
            node.lpstrInstallName = "";

        GetTaskName(node.hCreatorTask, szTask);
        wsprintf(ach, "mci %04X %ls %ls %ls",j,(LPSTR)szTask,node.lpstrInstallName,node.lpstrName);

        i = (int)(LONG)SendMessage(hlb, LB_ADDSTRING, 0, (LPARAM)(LPSTR)ach);
        SendMessage(hlb, LB_SETITEMDATA, (WPARAM)i, MAKELPARAM(j, TYPE_MCI));
    }

    //
    // add to that all DRV handles
    //
    for (h=GetNextDriver(NULL, 0); h; h=GetNextDriver(h, 0))
    {
        if (GetDriverModuleHandle(h))
        {
            DRIVERINFOSTRUCT di;

            di.length = sizeof(di);
            di.szAliasName[0] = 0;
            GetDriverInfo(h, &di);

            iNumHandles++;

            GetModuleFileName(GetDriverModuleHandle(h), szName, sizeof(szName));

            wsprintf(ach, "Driver %04X %ls (%ls)",h,(LPSTR)di.szAliasName,(LPSTR)FileName(szName));
            i = (int)(LONG)SendDlgItemMessage(hdlg, ID_HANDLES, LB_ADDSTRING, 0, (LPARAM)(LPSTR)ach);
            SendDlgItemMessage(hdlg, ID_HANDLES, LB_SETITEMDATA, (WPARAM)i, MAKELPARAM(h,TYPE_DRVR));
        }
    }

    SendMessage(hlb,LB_SETCURSEL,(WPARAM)iSel,0L);
    SendMessage(hlb,WM_SETREDRAW,(WPARAM)TRUE,0);
    InvalidateRect(hlb, NULL, TRUE);
}

int CountHandles(void)
{
    HLOCAL  h;
    int     cnt=0;
    UINT    n;
    UINT    j;

    for (h = (HLOCAL)(LONG)SendDriverMessage(hdrv, MM_HINFO_NEXT, NULL, 0);
         h;
         h = (HLOCAL)(LONG)SendDriverMessage(hdrv, MM_HINFO_NEXT, (LPARAM)(LONG)(UINT)h, 0) )
    {
        cnt++;
    }

    n = (UINT)(LONG)SendDriverMessage(hdrv, MM_HINFO_MCI, 0, 0);

    for (j=1; j<n; j++)
    {
        MCI_DEVICE_NODE node;

        if (!SendDriverMessage(hdrv, MM_HINFO_MCI, (LPARAM)j, (LPARAM)(LPVOID)&node))
            continue;

        cnt++;
    }

    for (h=GetNextDriver(NULL,0); h; h=GetNextDriver(h, 0))
    {
        if (GetDriverModuleHandle(h))
            cnt++;
    }

    return cnt;
}

void CloseHandle(DWORD dw)
{
    HLOCAL h;
    h = (HLOCAL)LOWORD(dw);

    switch(HIWORD(dw))
    {
        case TYPE_WAVEOUT:
            if (IDYES == fQuestion("Close WaveOut handle %04X?",h))
            {
                waveOutReset(h);
                waveOutClose(h);
            }
            break;
        case TYPE_WAVEIN:
            if (IDYES == fQuestion("Close WaveIn handle %04X?",h))
            {
                waveInStop(h);
                waveInClose(h);
            }
            break;
        case TYPE_MIDIOUT:
            if (IDYES == fQuestion("Close MidiOut handle %04X?",h))
            {
                midiOutReset(h);
                midiOutClose(h);
            }
            break;
        case TYPE_MIDIIN:
            if (IDYES == fQuestion("Close MidiIn handle %04X?",h))
            {
                midiInStop(h);
                midiInClose(h);
            }
            break;
        case TYPE_MCI:
            if (IDYES == fQuestion("Close Mci device %04X?",h))
            {
                mciSendCommand((UINT)h, MCI_CLOSE, 0, 0);
            }
            break;
        case TYPE_MMIO:
            if (IDYES == fQuestion("Close MMIO handle %04X?",h))
            {
                mmioClose(h,MMIO_FHOPEN);
            }
            break;
        case TYPE_DRVR:
            break;
    }
}


BOOL FAR PASCAL _loadds DebugDlg(HWND hdlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    DWORD dw;
    int i;

    switch (msg)
    {
        case WM_INITDIALOG:
            SendDlgItemMessage(hdlg, ID_DEBUG_OUT, CB_ADDSTRING, 0, (LONG)(LPSTR)"(none)");
            SendDlgItemMessage(hdlg, ID_DEBUG_OUT, CB_ADDSTRING, 0, (LONG)(LPSTR)"COM1:");
            SendDlgItemMessage(hdlg, ID_DEBUG_OUT, CB_ADDSTRING, 0, (LONG)(LPSTR)"Mono Monitor");
            SendDlgItemMessage(hdlg, ID_DEBUG_OUT, CB_ADDSTRING, 0, (LONG)(LPSTR)"Windows");

            SendDlgItemMessage(hdlg, ID_DEBUG_OUT, CB_SETCURSEL, (int)(LONG)SendDriverMessage(hdrv, MM_GET_DEBUGOUT, 0, 0), 0L);

            CheckDlgButton(hdlg, ID_DEBUG_MCI, (int)(LONG)SendDriverMessage(hdrv, MM_GET_MCI_DEBUG, 0, 0));
            CheckDlgButton(hdlg, ID_DEBUG_MMSYS, (int)(LONG)SendDriverMessage(hdrv, MM_GET_MM_DEBUG, 0, 0));

            iNumHandles = CountHandles();
            GetHandles(hdlg);

            SetTimer(hdlg, 500, 500, NULL);
            return TRUE;

        case WM_TIMER:
            i = CountHandles();
            if (iNumHandles != i)
            {
                iNumHandles = i;
                GetHandles(hdlg);
            }
            break;

        case WM_COMMAND:
            switch ((UINT)wParam)
            {
                case IDOK:
                    SendDriverMessage(hdrv, MM_SET_DEBUGOUT,
                        (LPARAM)SendDlgItemMessage(hdlg, ID_DEBUG_OUT, CB_GETCURSEL, 0, 0), 0);

                    SendDriverMessage(hdrv, MM_SET_MCI_DEBUG,
                        (LPARAM)IsDlgButtonChecked(hdlg, ID_DEBUG_MCI),0);

                    SendDriverMessage(hdrv, MM_SET_MM_DEBUG,
                        (LPARAM)IsDlgButtonChecked(hdlg, ID_DEBUG_MMSYS),0);

                    // fall through
                case IDCANCEL:
                    EndDialog(hdlg, wParam);
                    break;

                case ID_RESTART:
                    SendDriverMessage(hdrv, MM_DRV_RESTART, 0, 0);
                    break;

                case ID_HANDLES:
                    if (HIWORD(lParam) != LBN_DBLCLK)
                        break;

                    i = (int)(LONG)SendDlgItemMessage(hdlg,wParam,LB_GETCURSEL,0,0L);
                    dw = (DWORD)SendDlgItemMessage(hdlg,wParam,LB_GETITEMDATA,(WPARAM)i,0L);

                    CloseHandle(dw);
                    GetHandles(hdlg);
                    break;
            }
            break;
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\mmsystem\thunks.h ===
/******************************Module*Header*******************************\
* Module Name: thunks.h
*
*  Function prototypes for Multi-Media thunk functions
*
*
* Created: 27-09-93
* Author:  Stephen Estrop [StephenE]
*
* Copyright (c) 1993 Microsoft Corporation
\**************************************************************************/
#include <wowmmcb.h>

extern DWORD FAR PASCAL mmwow32Lib;     // in stack.asm

/* -------------------------------------------------------------------------
** Wave stuff
** -------------------------------------------------------------------------
*/
#ifndef MMNOWAVE
extern DWORD NEAR PASCAL
waveOMessage(
    HWAVE hWave,
    UINT msg,
    DWORD dwP1,
    DWORD dwP2
    );

extern DWORD NEAR PASCAL
waveIMessage(
    HWAVE hWave,
    UINT msg,
    DWORD dwP1,
    DWORD dwP2
    );

extern UINT FAR PASCAL
waveOIDMessage(
    UINT wDeviceID,
    UINT wMessage,
    DWORD dwUser,
    DWORD dwParam1,
    DWORD dwParam2
    );

extern UINT FAR PASCAL
waveIIDMessage(
    UINT wDeviceID,
    UINT wMessage,
    DWORD dwUser,
    DWORD dwParam1,
    DWORD dwParam2
    );
#endif

/* -------------------------------------------------------------------------
** midi stuff
** -------------------------------------------------------------------------
*/
#ifndef MMNOWAVE
extern DWORD FAR PASCAL
midiOMessage(
    HMIDI hMidi,
    UINT msg,
    DWORD dwP1,
    DWORD dwP2
    );

extern UINT FAR PASCAL
midiOIDMessage(
    UINT wDeviceID,
    UINT wMessage,
    DWORD dwUser,
    DWORD dwParam1,
    DWORD dwParam2
    );
extern DWORD FAR PASCAL
midiIMessage(
    HMIDI hMidi,
    UINT msg,
    DWORD dwP1,
    DWORD dwP2
    );

extern UINT FAR PASCAL
midiIIDMessage(
    UINT wDeviceID,
    UINT wMessage,
    DWORD dwUser,
    DWORD dwParam1,
    DWORD dwParam2
    );
#endif

/* -------------------------------------------------------------------------
** Joystick stuff
** -------------------------------------------------------------------------
*/
typedef DWORD (FAR PASCAL *JOYMESSAGEPROC)( HDRVR, UINT, DWORD, DWORD );
extern UINT FAR PASCAL
joyMessage(
    HDRVR hdrv,
    UINT msg,
    LPARAM dw1,
   LPARAM dw2
    );

/* -------------------------------------------------------------------------
** Timer stuff
** -------------------------------------------------------------------------
*/
typedef LRESULT (FAR PASCAL *TIDMESSAGEPROC)( UINT, LPARAM, LPARAM );
extern TIDMESSAGEPROC FAR PASCAL tid32Message;              // stack.asm
extern DWORD FAR PASCAL                                     // stack.asm
timeMessage(
    UINT msg,
    LPARAM dw1,
    LPARAM dw2
    );


/* -------------------------------------------------------------------------
** MCI Stuff
** -------------------------------------------------------------------------
*/
typedef DWORD (CALLBACK MCIMESSAGE)( DWORD, DWORD, DWORD, DWORD, DWORD );
typedef MCIMESSAGE FAR *LPMCIMESSAGE;
extern LPMCIMESSAGE PASCAL mci32Message;

extern DWORD FAR PASCAL
mciMessage(
    UINT wMsg,
    DWORD dwP1,
    DWORD dwP2,
    DWORD dwP3,
    DWORD dwP4
    );

#define THUNK_MCI_SENDCOMMAND                0x0001
#define THUNK_MCI_SENDSTRING                 0x0002
#define THUNK_MCI_GETDEVICEID                0x0003
#define THUNK_MCI_GETDEVIDFROMELEMID         0x0004
#define THUNK_MCI_GETERRORSTRING             0x0005
#define THUNK_MCI_EXECUTE                    0x0006
#define THUNK_MCI_SETYIELDPROC               0x0007
#define THUNK_MCI_GETYIELDPROC               0x0008
#define THUNK_MCI_GETCREATORTASK             0x0009
#define THUNK_TIMEGETTIME                    0x000A
#define THUNK_APP_EXIT                       0x000B
#define THUNK_MCI_ALLOCATE_NODE              0x000C
#define THUNK_MCI_FREE_NODE                  0x000D

/* -------------------------------------------------------------------------
** Interrupt callback stuff
** -------------------------------------------------------------------------
*/
typedef VOID (CALLBACK CB32)( VPCALLBACK_DATA vpCallbackData );
typedef CB32 FAR *  LPCB32;
extern VPCALLBACK_DATA FAR PASCAL   vpCallbackData;          // in STACK.ASM
extern HGLOBAL         FAR PASCAL   hGlobal;                 // in STACK.ASM
int FAR PASCAL
InstallInterruptHandler(
    void
    );

int FAR PASCAL
DeInstallInterruptHandler(
    void
    );

VOID FAR PASCAL
Notify_Callback_Data(
    VPCALLBACK_DATA vpCallbackData
    );

BOOL FAR  PASCAL
    StackInit(
    void
    );

BOOL NEAR PASCAL
StackTerminate(
    void
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\mmsystem\time.c ===
/******************************************************************************

   Copyright (C) Microsoft Corporation 1985-1991. All rights reserved.

   Title:   TIME.C : MMSYSTEM TIMER API

   Version: 1.00

*****************************************************************************/

//
//  ***DANGER WARNING****
//
//  none of these functions in this file need the default data segment
//  so we undefine BUILDDLL, if you write code in this file that needs
//  DS == DGROUP be warned!
//
//  NOTE: most of this code is interupt time enterable, so we don't want
//  it touching DGROUP anyway!
//
#undef BUILDDLL

#include <windows.h>
#include "mmsystem.h"
#include "mmddk.h"
#include "mmsysi.h"
#include "drvr.h"
#include "thunks.h"


#define MIN_RES     1
#define MIN_DELAY   6

//
//  Define moveable code for timer interface.
//
#pragma alloc_text( RARE, timeGetDevCaps )

extern SZCODE  szTimerDrv[];    // see init.c

DWORD dwLastGetTime = 0;        // last TimeGetTime return value can be bigger than system TimeGetTime
DWORD dwRealLastGetTime = 0;    // last system TimeGetTime return value
DWORD pfnDelayTimeGetTime = 0;  // 32-bit function that sleeps for 1ms and returns if TimeGetTime flag applied 
                                // look in timeTimeGetTime and WOWDelayTimeGetTime in wow32                             
//
//  Define the init code for this file.
//
#pragma alloc_text( INIT, TimeInit )


/****************************************************************************

    @doc EXTERNAL

    @api UINT | timeGetSystemTime | This function retrieves the system time
    in milliseconds.  The system time is the time elapsed since
    Windows was started.

    @parm LPMMTIME | lpTime | Specifies a far pointer to an <t MMTIME> data
    structure.

    @parm UINT | wSize | Specifies the size of the <t MMTIME> structure.

    @rdesc Returns zero.
    The system time is returned in the <e MMTIME.ms> field of the <t MMTIME>
    structure.

    @comm The time is always returned in milliseconds.

    @xref timeGetTime
****************************************************************************/
UINT WINAPI
timeGetSystemTime(
    LPMMTIME lpTime,
    UINT wSize
    )
{
    //
    // !!!WARNING DS is not setup right!!! see above
    //
    if (wSize < sizeof(MMTIME))
        return TIMERR_STRUCT;

    lpTime->u.ms  = timeGetTime();
    lpTime->wType = TIME_MS;

    return TIMERR_NOERROR;
}


/****************************************************************************

    @doc EXTERNAL

    @api UINT | timeSetEvent | This function sets up a timed callback event.
    The event can be a one-time event or a periodic event.  Once activated,
    the event calls the specified callback function.

    @parm UINT | wDelay | Specifies the event period in milliseconds.
    If the delay is less than the minimum period supported by the timer,
    or greater than the maximum period supported by the timer, the
    function returns an error.

    @parm UINT | wResolution | Specifies the accuracy of the delay in
    milliseconds. The resolution of the timer event increases with
    smaller <p wResolution> values. To reduce system overhead, use
    the maximum <p wResolution> value appropriate for your application.

    @parm LPTIMECALLBACK | lpFunction | Specifies the procedure address of
    a callback function that is called once upon expiration of a one-shot
    event or periodically upon expiration of periodic events.

    @parm DWORD | dwUser | Contains user-supplied callback data.

    @parm UINT | wFlags | Specifies the type of timer event, using one of
    the following flags:

    @flag TIME_ONESHOT | Event occurs once, after <p wPeriod> milliseconds.

    @flag TIME_PERIODIC | Event occurs every <p wPeriod> milliseconds.

    @rdesc Returns an ID code that identifies the timer event. Returns
    NULL if the timer event was not created. The ID code is also passed to
        the callback function.

    @comm Using this function to generate a high-frequency periodic-delay
    event (with a period less than 10 milliseconds) can consume a
        significant portion of the system CPU bandwidth.  Any call to
    <f timeSetEvent> for a periodic-delay timer
    must be paired with a call to <f timeKillEvent>.

    The callback function must reside in a DLL.  You don't have to use
    <f MakeProcInstance> to get a procedure-instance address for the callback
    function.

    @cb void CALLBACK | TimeFunc | <f TimeFunc> is a placeholder for the
    application-supplied function name.  The actual name must be exported by
    including it in the EXPORTS statement of the module-definition file for
    the DLL.

    @parm UINT | wID | The ID of the timer event.  This is the ID returned
       by <f timeSetEvent>.

    @parm UINT | wMsg | Not used.

    @parm DWORD | dwUser | User instance data supplied to the <p dwUser>
    parameter of <f timeSetEvent>.

    @parm DWORD | dw1 | Not used.

    @parm DWORD | dw2 | Not used.

    @comm Because the callback is accessed at interrupt time, it must
    reside in a DLL, and its code segment must be specified as FIXED
    in the module-definition file for the DLL.  Any data that the
    callback accesses must be in a FIXED data segment as well.
    The callback may not make any system calls except for <f PostMessage>,
    <f timeGetSystemTime>, <f timeGetTime>, <f timeSetEvent>,
    <f timeKillEvent>, <f midiOutShortMsg>,
    <f midiOutLongMsg>, and <f OutputDebugStr>.

    @xref timeKillEvent timeBeginPeriod timeEndPeriod

****************************************************************************/
UINT WINAPI
timeSetEvent(
    UINT wDelay,
    UINT wResolution,
    LPTIMECALLBACK lpFunction,
    DWORD dwUser,
    UINT wFlags
    )
{
    //
    // !!!WARNING DS is not setup right!!! see above
    //
    TIMEREVENT timerEvent;

    V_TCALLBACK(lpFunction, MMSYSERR_INVALPARAM);

    //
    // the first time this is called init the stacks
    // !!!this assumes the first caller will not be at interupt time!!
    //
//  if (!(WinFlags & WF_ENHANCED))
//      timeStackInit();

    wDelay = max( MIN_DELAY, wDelay );
    wResolution = max( MIN_RES, wResolution );

    timerEvent.wDelay = wDelay;
    timerEvent.wResolution = wResolution;
    timerEvent.lpFunction = lpFunction;
    timerEvent.dwUser = dwUser;  
    timerEvent.wFlags = wFlags;

    return (UINT)timeMessage( TDD_SETTIMEREVENT, (LPARAM)(LPVOID)&timerEvent,
                              (LPARAM)GetCurrentTask() );
}



/****************************************************************************

    @doc EXTERNAL

    @api UINT | timeGetDevCaps | This function queries the timer device to
    determine its capabilities.

    @parm LPTIMECAPS | lpTimeCaps | Specifies a far pointer to a
        <t TIMECAPS> structure.  This structure is filled with information
        about the capabilities of the timer device.

    @parm UINT | wSize | Specifies the size of the <t TIMECAPS> structure.

    @rdesc Returns zero if successful. Returns TIMERR_NOCANDO if it fails
    to return the timer device capabilities.

****************************************************************************/
UINT WINAPI
timeGetDevCaps(
    LPTIMECAPS lpTimeCaps,
    UINT wSize
    )
{
    //
    // !!!WARNING DS is not setup right!!! see above
    //
    return (UINT)timeMessage( TDD_GETDEVCAPS, (LPARAM)lpTimeCaps,
                              (LPARAM)(DWORD)wSize);
}



/******************************Public*Routine******************************\
*  timeBeginPeriod
*
*  @doc EXTERNAL
*
*  @api WORD | timeBeginPeriod | This function sets the minimum (lowest
*  number of milliseconds) timer resolution that an application or
*  driver is going to use. Call this function immediately before starting
*  to use timer-event services, and call <f timeEndPeriod> immediately
*  after finishing with the timer-event services.
*
*  @parm WORD | wPeriod | Specifies the minimum timer-event resolution
*  that the application or driver will use.
*
*  @rdesc Returns zero if successful. Returns TIMERR_NOCANDO if the specified
*  <p wPeriod> resolution value is out of range.
*
*  @xref timeEndPeriod timeSetEvent
*
*  @comm For each call to <f timeBeginPeriod>, you must call
*  <f timeEndPeriod> with a matching <p wPeriod> value.
*  An application or driver can make multiple calls to <f timeBeginPeriod>,
*  as long as each <f timeBeginPeriod> call is matched with a
*  <f timeEndPeriod> call.
*
*
*
*
* History:
* dd-mm-93 - StephenE - Created
*
\**************************************************************************/
UINT WINAPI
timeBeginPeriod(
    UINT uPeriod
    )
{
    uPeriod = max( MIN_RES, uPeriod );
    return (UINT)timeMessage( TDD_BEGINMINPERIOD, (LPARAM)uPeriod, 0L );
}



/******************************Public*Routine******************************\
*  timeEndPeriod
*
*  @doc EXTERNAL
*
*  @api WORD | timeEndPeriod | This function clears a previously set
*  minimum (lowest number of milliseconds) timer resolution that an
*  application or driver is going to use. Call this function
*  immediately after using timer event services.
*
*  @parm WORD | wPeriod | Specifies the minimum timer-event resolution
*  value specified in the previous call to <f timeBeginPeriod>.
*
*  @rdesc Returns zero if successful. Returns TIMERR_NOCANDO if the specified
*  <p wPeriod> resolution value is out of range.
*
*  @xref timeBeginPeriod timeSetEvent
*
*  @comm For each call to <f timeBeginPeriod>, you must call
*  <f timeEndPeriod> with a matching <p wPeriod> value.
*  An application or driver can make multiple calls to <f timeBeginPeriod>,
*  as long as each <f timeBeginPeriod> call is matched with a
*  <f timeEndPeriod> call.
*
*
*
* History:
* dd-mm-93 - StephenE - Created
*
\**************************************************************************/
UINT WINAPI
timeEndPeriod(
    UINT uPeriod
    )
{
    uPeriod = max( MIN_RES, uPeriod );
    return (UINT)timeMessage( TDD_ENDMINPERIOD, (LPARAM)uPeriod, 0L );
}



/******************************Public*Routine******************************\
*
*  timeKillEvent
*
*  @doc EXTERNAL
*
*  @api WORD | timeKillEvent | This functions destroys a specified timer
*  callback event.
*
*  @parm WORD | wID | Identifies the event to be destroyed.
*
*  @rdesc Returns zero if successful. Returns TIMERR_NOCANDO if the
*  specified timer event does not exist.
*
*  @comm The timer event ID specified by <p wID> must be an ID
*      returned by <f timeSetEvent>.
*
*  @xref  timeSetEvent
*
*
*
* History:
* dd-mm-93 - StephenE - Created
*
\**************************************************************************/
UINT WINAPI
timeKillEvent(
    UINT wID
    )
{
    if ( 0 == wID ) {
        return 0;
    }
    return (UINT)timeMessage( TDD_KILLTIMEREVENT, (LPARAM)wID, 0L );
}

/******************************Public*Routine******************************\
* timeGetTime
*
* @doc EXTERNAL
*
* @api DWORD | timeGetTime | This function retrieves the system time
* in milliseconds.  The system time is the time elapsed since
* Windows was started.
*
* @rdesc The return value is the system time in milliseconds.
*
* @comm The only difference between this function and
*     the <f timeGetSystemTime> function is <f timeGetSystemTime>
*     uses the standard multimedia time structure <t MMTIME> to return
*     the system time.  The <f timeGetTime> function has less overhead than
*     <f timeGetSystemTime>.
*
* @xref timeGetSystemTime
*
*
* @comment: on faster machines timeGetTime can return the same value
* and some apps will take diff (0) to divide and fault  
* to prevent that call DelayTimeGetTime which will check if it is one
* of the known apps that do that and sleep if necessary 
*
* History:
* dd-mm-93 - StephenE - Created
*
\**************************************************************************/
DWORD WINAPI
timeGetTime(
    void
    )
{
    DWORD  dwGetTime;
    DWORD  bDelay = 0;

    if (pfnDelayTimeGetTime == 0) {
        DWORD hmodWow32;
        hmodWow32 = LoadLibraryEx32W("wow32.dll", 0, 0);
        pfnDelayTimeGetTime = GetProcAddress32W(hmodWow32, "WOWDelayTimeGetTime");
    }

RepeatTGT:
    dwGetTime = timeMessage( TDD_GETSYSTEMTIME, 0L, 0L );
    
    // check if it wrapped around
    if (dwGetTime < dwRealLastGetTime) {
        dwLastGetTime = dwRealLastGetTime = dwGetTime;
        return dwGetTime;
    }
    dwRealLastGetTime = dwGetTime;
    
    if (dwGetTime == dwLastGetTime) {
        if (!bDelay) {
                      
            bDelay = (DWORD) CallProc32W((LPVOID)pfnDelayTimeGetTime,(DWORD)0,(DWORD)0);        
            if(bDelay) {
               goto RepeatTGT;
            }
        }
        else {
            dwGetTime = ++dwLastGetTime;
        }
    } 
    dwLastGetTime = dwGetTime;
    return dwGetTime;
}


/****************************************************************************

    @doc INTERNAL

    @api BOOL | TimeInit | This function initialises the timer services.

    @rdesc The return value is TRUE if the services are initialised, FALSE
        if an error occurs.

    @comm it is not a FATAL error if a timer driver is not installed, this
          routine will allways return TRUE

****************************************************************************/
BOOL NEAR PASCAL TimeInit(void)
{
    OpenDriver(szTimerDrv, NULL, 0L) ;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\mmsystem\sound.c ===
/*
    sound.c

    Level 1 kitchen sink DLL sound driver functions

    Copyright (c) Microsoft Corporation 1990. All rights reserved

*/

#include <windows.h>
#include "mmsystem.h"
#include "mmddk.h"
#include "mmsysi.h"
#include "playwav.h"

BOOL WINAPI IsTaskLocked(void); // In Kernel

//
// place sndPlaySound in the _TEXT segment so the entire wave segment
// does not come in if no wave devices are loaded.
//

#pragma alloc_text(_TEXT, sndPlaySound)

static SZCODE szNull[]          = "";
static SZCODE szSoundSection[]  = "sounds";        // WIN.INI section for sounds
       SZCODE szSystemDefault[] = "SystemDefault"; // Name of the default sound

#define SOUNDNAMELEN 128
static HGLOBAL hCurrentSound;                      // handle to current sound.

extern LPWAVEHDR lpWavHdr;                  // current playing sound PLAYWAV.C

/****************************************************************************/

static void PASCAL NEAR GetSoundName(
	LPCSTR	lszSoundName,
	LPSTR	lszBuffer)
{
	OFSTRUCT	of;
	int	i;

        //
        //  if the sound is defined in the [sounds] section of WIN.INI
        //  get it and remove the description, otherwise assume it is a
        //  file and qualify it.
        //
        GetProfileString(szSoundSection, lszSoundName, lszSoundName, lszBuffer, SOUNDNAMELEN);

        // remove any trailing text first

        for (i = 0; lszBuffer[i] && (lszBuffer[i] != ' ') && (lszBuffer[i] != '\t') && (lszBuffer[i] != ','); i++)
                ;
        lszBuffer[i] = (char)0;

        if (OpenFile(lszBuffer, &of, OF_EXIST | OF_READ | OF_SHARE_DENY_NONE) != HFILE_ERROR)
            OemToAnsi(of.szPathName, lszBuffer);
}

/*****************************************************************************
 * @doc EXTERNAL
 *
 * @api BOOL | sndPlaySound | This function plays a waveform
 *      sound specified by a filename or by an entry in the [sounds] section
 *      of WIN.INI.  If the sound can't be found, it plays the
 *      default sound specified by the SystemDefault entry in the
 *      [sounds] section of WIN.INI. If there is no SystemDefault
 *      entry or if the default sound can't be found, the function
 *      makes no sound and returns FALSE.
 *
 * @parm LPCSTR | lpszSoundName | Specifies the name of the sound to play.
 *      The function searches the [sounds] section of WIN.INI for an entry
 *      with this name and plays the associated waveform file.
 *      If no entry by this name exists, then it assumes the name is
 *      the name of a waveform file. If this parameter is NULL, any
 *     currently playing sound is stopped.
 *
 * @parm UINT | wFlags | Specifies options for playing the sound using one
 *      or more of the following flags:
 *
 * @flag  SND_SYNC            | The sound is played synchronously and the
 *      function does not return until the sound ends.
 * @flag  SND_ASYNC           | The sound is played asynchronously and the
 *      function returns immediately after beginning the sound. To terminate
 *      an asynchronously-played sound, call <f sndPlaySound> with
 *      <p lpszSoundName> set to NULL.
 * @flag  SND_NODEFAULT       | If the sound can't be found, the function
 *      returns silently without playing the default sound.
 * @flag  SND_MEMORY          | The parameter specified by <p lpszSoundName>
 *      points to an in-memory image of a waveform sound.
 * @flag  SND_LOOP            | The sound will continue to play repeatedly
 *      until <f sndPlaySound> is called again with the
 *      <p lpszSoundName> parameter set to NULL.  You must also specify the
 *      SND_ASYNC flag to loop sounds.
 * @flag  SND_NOSTOP          | If a sound is currently playing, the
 *      function will immediately return FALSE without playing the requested
 *      sound.
 *
 * @rdesc Returns TRUE if the sound is played, otherwise
 *      returns FALSE.
 *
 * @comm The sound must fit in available physical memory and be playable
 *      by an installed waveform audio device driver. The directories
 *      searched for sound files are, in order: the current directory;
 *      the Windows directory; the Windows system directory; the directories
 *      listed in the PATH environment variable; the list of directories
 *      mapped in a network. See the Windows <f OpenFile> function for
 *      more information about the directory search order.
 *
 *      If you specify the SND_MEMORY flag, <p lpszSoundName> must point
 *      to an in-memory image of a waveform sound. If the sound is stored
 *      as a resource, use <f LoadResource> and <f LockResource> to load
 *      and lock the resource and get a pointer to it. If the sound is not
 *      a resource, you must use <f GlobalAlloc> with the GMEM_MOVEABLE and
 *      GMEM_SHARE flags set and then <f GlobalLock> to allocate and lock
 *      memory for the sound.
 *
 * @xref MessageBeep
 ****************************************************************************/

BOOL WINAPI sndPlaySound(LPCSTR szSoundName, UINT wFlags)
{
    //
    //  !!! quick exit for no wave devices !!!
    //
    static UINT wTotalWaveOutDevs = (UINT)-1;

    if (wTotalWaveOutDevs == -1 ) {
        wTotalWaveOutDevs = waveOutGetNumDevs();
    }

    if (wTotalWaveOutDevs)
        return sndPlaySoundI(szSoundName, wFlags);
    else
        return FALSE;
}

/****************************************************************************/
/*
@doc	INTERNAL

@func	BOOL | sndPlaySoundI | Internal version of <f>sndPlaySound<d> which
	resides in the WAVE segment instead.

	If the SND_NOSTOP flag is specifed and a wave file is currently
	playing, or if for some reason no mmsystem window is present, the
	function returns failure immediately.  The first condition ensures
	that a current sound is not interrupted if the flag is set.  The
	second condition is only in case of some start up error in which
	the notification window was not created, or mmsystem was not
	specified in the [drivers] line, and therefore never loaded.

	Next, if the <p>lszSoundName<d> parameter does not represent a memory
	file, and it is non-NULL, then it must represent a string.  Therefore
	the string must be parsed before sending the sound message to the
	mmsystem window.  This is because the mmsystem window may reside in a
	a different task than the task which is calling the function, and
	would most likely have a different current directory.

	In this case, the parameter is first checked to determine if it
	actually contains anything.  For some reason a zero length string
	was determined to be able to return TRUE from this function, so that
	is checked.

	Next the string is checked against INI entries, then parsed.

	After parsing the sound name, ensure that a task switch only occurs if
	the sound is asyncronous (SND_ASYNC), and a previous sound does not
	need to be discarded.

	If a task switch is needed, first ensure that intertask messages can
	be sent by checking to see that this task is not locked, or that the
	notification window is in the current task.

@parm	LPCSTR | lszSoundName | Specifies the name of the sound to play.

@parm	UINT | wFlags | Specifies options for playing the sound.

@rdesc	Returns TRUE if the function was successful, else FALSE if an error
	occurred.
*/
BOOL FAR PASCAL sndPlaySoundI(LPCSTR lszSoundName, UINT wFlags)
{
	BOOL	fPlayReturn;
        PSTR    szSoundName;

        V_FLAGS(wFlags, SND_VALID, sndPlaySound, NULL);

        if ((wFlags & SND_LOOP) && !(wFlags & SND_ASYNC)) {
            LogParamError(ERR_BAD_FLAGS, (FARPROC)sndPlaySound,  (LPVOID)(DWORD)wFlags);
            return FALSE;
        }

        if (!(wFlags & SND_MEMORY) && lszSoundName)
                V_STRING(lszSoundName, 128, FALSE);

#ifdef  DEBUG
        if (wFlags & SND_MEMORY) {
            DPRINTF1("MMSYSTEM: sndPlaySound(%lx)\r\n", lszSoundName);
        }
        else if (lszSoundName) {
            if (wFlags & SND_ASYNC) {
                if (wFlags & SND_LOOP) {
                    DPRINTF1("MMSYSTEM: sndPlaySound(%ls, SND_ASYNC|SND_LOOP)\r\n", lszSoundName);
                }
                else {
                    DPRINTF1("MMSYSTEM: sndPlaySound(%ls, SND_ASYNC)\r\n", lszSoundName);
                }
            }
            else
                DPRINTF1("MMSYSTEM: sndPlaySound(%ls, SND_SYNC)\r\n", lszSoundName);
        }
        else
            DOUT("MMSYSTEM: sndPlaySound(NULL)\r\n");

#endif  //ifdef DEBUG

	if (((wFlags & SND_NOSTOP) && lpWavHdr) || !hwndNotify)
                return FALSE;

	if (!(wFlags & SND_MEMORY) && lszSoundName) {
		if (!*lszSoundName)
			return TRUE;
                if (!(szSoundName = (PSTR)LocalAlloc(LMEM_FIXED, SOUNDNAMELEN)))
			return FALSE;
		GetSoundName(lszSoundName, szSoundName);
		lszSoundName = (LPCSTR)szSoundName;
	} else
                szSoundName = NULL;

	if (!(wFlags & SND_ASYNC) && !lpWavHdr)
		fPlayReturn = sndMessage((LPSTR)lszSoundName, wFlags);
	else {
		if (!IsTaskLocked() || (GetWindowTask(hwndNotify) == GetCurrentTask())) {
			fPlayReturn = (BOOL)(LONG)SendMessage(hwndNotify, MM_SND_PLAY, (WPARAM)wFlags, (LPARAM)lszSoundName);
		} else
			fPlayReturn = FALSE;
	}
	if (szSoundName)
                LocalFree((HLOCAL)szSoundName);

	return fPlayReturn;
}

/****************************************************************************/
static BOOL PASCAL NEAR SetCurrentSound(
	LPCSTR	lszSoundName)
{
	HGLOBAL	hSound;
        BOOL    f;
        LPSTR   lp;

        if (hCurrentSound && (lp = GlobalLock(hCurrentSound))) {
                f = lstrcmpi(lszSoundName, lp + sizeof(WAVEHDR)) == 0;
                GlobalUnlock(hCurrentSound);
                if (f)
                    return TRUE;
	}

        DPRINTF(("MMSYSTEM: soundLoadFile(%ls)\r\n",lszSoundName));

        if (hSound = soundLoadFile(lszSoundName)) {
		soundFree(hCurrentSound);
		hCurrentSound = hSound;
		return TRUE;
	}
	return FALSE;
}
/****************************************************************************/
/*
@doc	INTERNAL

@func	BOOL | sndMessage | This function is called in response to an
	MM_SND_PLAY message sent to the mmsystem window, and attempts to
	play the specified file, or dump current sound caching.

	If <p>lszSoundName<d> is NULL, any currently cached sound is
	discarded, and the function returns success.

	If the SND_MEMORY flag is set, then <p>lszSoundName<d> actually
	points to a buffer containing a RIFF format WAVE memory file, and
	the function attempts to play it.  The load function performs
	validation on this memory file.  Unlike playing sound names,
	memory files are not cached for future use.

	Otherwise the <p>lszSoundName<d> parameter is actually an INI entry
	or file name.  The function initially attempts to load that sound,
	and if it fails, attempts to load the system default sound.  Note of
	course that the SND_NODEFAULT flag is first checked to determine if
	the default sound is to be played when the original name cannot be
	located.  If no default is wanted, or the default cannot be located,
	the function returns failure.  Note that in calling <f>GetSoundName<d>,
	the <p>lszSoundName<d> parameter is modified.  This function assumes
	that the parameter passed has been previously allocated if a string is
	passed to this function, and is not the actual user's parameter passed
	to <f>sndPlaySound<d>.

@parm	LPSTR | lszSoundName | Specifies the name of the sound to play.

@parm	UINT | wFlags | Specifies options for playing the sound.

@rdesc	Returns TRUE if the function was successful, else FALSE if an error
	occurred.
*/
BOOL FAR PASCAL sndMessage(LPSTR lszSoundName, UINT wFlags)
{
	if (!lszSoundName) {
		soundFree(hCurrentSound);
		hCurrentSound = NULL;
		return TRUE;
	}
	if (wFlags & SND_MEMORY) {
                soundFree(hCurrentSound);
		hCurrentSound = soundLoadMemory(lszSoundName);
	} else if (!SetCurrentSound(lszSoundName)) {
		if (wFlags & SND_NODEFAULT)
			return FALSE;
		GetSoundName(szSystemDefault, lszSoundName);
		if (!SetCurrentSound(lszSoundName))
			return FALSE;
	}
	return soundPlay(hCurrentSound, wFlags);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\mmsystem\taska.asm ===
page    ,132
;-----------------------------Module-Header-----------------------------;
; Module Name:  TASKA.ASM - Some task functions
;
; Copyright (c) 1984-1991 Microsoft Corporation
;
;-----------------------------------------------------------------------;

        ?PLM    = 1
        ?WIN    = 0
        PMODE	= 1

	.xlist
	include cmacros.inc
        include windows.inc
        include mmsystem.inc
        .list

	externFP	Yield
	externFP	GetCurrentTask
	externFP	PostAppMessage
	externFP	PostMessage
        externFP        PeekMessage
	externFP	GetMessage
	externFP	DispatchMessage
	externFP	TranslateMessage

ifndef SEGNAME
	SEGNAME equ <_TEXT>
endif

;-----------------------------------------------------------------------;

createSeg %SEGNAME, CodeSeg, word, public, CODE

sBegin  CodeSeg
	assumes cs,CodeSeg
	assumes ds,nothing
	assumes es,nothing

;-----------------------------------------------------------------------;
;
; @doc     DDK    MMSYSTEM    TASK
;
; @api     void | mmTaskYield | This function causes the current task
;          to yield.
;
; @comm    For predictable results and future compatibility, use this
;          function rather than <f Yield> or the undocumented Kernel yield
;          function to yield within a task created with <f mmTaskCreate>.
;
;-----------------------------------------------------------------------;
cProc   mmTaskYield, <FAR, PUBLIC, PASCAL>, <>
	LocalV	msg, %(SIZE MSGSTRUCT)
cBegin
        ;
        ;   we need to call PeekMessage() so ScanSysQue gets called
        ;   and USER gets the mouse/keyboard input right
        ;
        ;   PeekMessage() may not Yield if there is a message in the
        ;   Queue so we yield if it did not.
        ;

        lea     ax, msg
        cCall   PeekMessage, <ss, ax, NULL, 0, 0, PM_NOREMOVE>
        or      ax,ax
        jz      mmTaskYieldExit

        cCall   Yield           ; PeekMessage() did not yield, so yield

mmTaskYieldExit:
cEnd

;-----------------------------------------------------------------------;
;
; @doc     DDK    MMSYSTEM    TASK
;
; @api     HTASK | mmGetCurrentTask |  This function returns the
;          handle of the currently executing task created with
;          <f mmTaskCreate>.
;
; @rdesc   Returns a task handle. For predictable results and future
;          compatibility, use this function rather than <f GetCurrentTask>
;          to get the task handle of a task created with <f mmTaskCreate>.
;
; @xref    mmTaskCreate
;
;-----------------------------------------------------------------------;
cProc	mmGetCurrentTask, <FAR, PUBLIC, PASCAL>, <>
cBegin <nogen>
	jmp	FAR PTR GetCurrentTask	; Jump directly to avoid returning to here
cEnd <nogen>

;-----------------------------------------------------------------------;
;
; @doc     DDK    MMSYSTEM    TASK
;
; @api     UINT | mmTaskBlock |  This function blocks the current
;          task context if its event count is 0.
;
;   @parm  HTASK | hTask | Task handle of the current task. For predictable
;          results, get the task handle from <f mmGetCurrentTask>.
;
; @xref    mmTaskSignal mmTaskCreate
;
; @comm    WARNING : For predictable results, must only be called from a
;          task created with <f mmTaskCreate>.
;
;-----------------------------------------------------------------------;
cProc	mmTaskBlock, <FAR, PUBLIC, PASCAL, NODATA>, <>
	ParmW	hTask
	LocalV	msg, %(SIZE MSGSTRUCT)
cBegin

mmTaskBlock_GetMessage:
	lea	ax, msg
	cCall	GetMessage, <ss, ax, NULL, 0, 0>; Retrieve any message for task
	cmp	msg.msHWND, 0			; Message sent to a window?
	je	mmTaskBlock_CheckMessage	; If so, dispatch it
	lea	ax, msg
        cCall   TranslateMessage, <ss, ax>      ; Probably a TaskMan message
	lea	ax, msg
        cCall   DispatchMessage, <ss, ax>
        jmp     mmTaskBlock_GetMessage

;
;   we got a message, wake up on any message >= WM_MM_RESERVED_FIRST
;
mmTaskBlock_CheckMessage:
        mov     ax,msg.msMESSAGE
        cmp     ax,WM_MM_RESERVED_FIRST
        jb      mmTaskBlock_GetMessage
cEnd

sEnd

;-----------------------------------------------------------------------;

createSeg FIX, FixSeg, word, public, CODE

sBegin	FixSeg
	assumes cs,FixSeg
	assumes ds,nothing
        assumes es,nothing

;-----------------------------------------------------------------------;
;
; @doc     DDK    MMSYSTEM    TASK
;
; @api     BOOL | mmTaskSignal |  This function signals the specified
;          task, incrementing its event count and unblocking
;          it.
;
; @parm    HTASK | hTask | Task handle. For predictable results, get the
;          task handle from <f mmGetCurrentTask>.
;
; @rdesc   Returns TRUE if the signal was sent, else FALSE if the message
;          queue was full.
;
; @xref    mmTaskBlock  mmTaskCreate
;
; @comm    Must be callable at interrupt time! WARNING : For
;          predictable results, must only be called from a task
;          created with <f mmTaskCreate>.
;
;-----------------------------------------------------------------------;
cProc	mmTaskSignal, <FAR, PUBLIC, PASCAL>, <>
;	ParmW	hTask
cBegin <nogen>
	pop	bx			; Fetch the return address
	pop	dx
	push	WM_USER			; Message
	xor	ax, ax
	push	ax			; wParam
	push	ax			; lParam
	push	ax
	push	dx			; Put return address back
	push	bx
	jmp	FAR PTR PostAppMessage	; Jump directly to avoid returning to here
cEnd <nogen>

;-----------------------------------------------------------------------;
;
; @doc     DDK MCI
; @api     BOOL | mciDriverNotify | Used by a driver to send
;          a notification message
;
; @parm    HWND | hwndCallback | The window to notify
;
; @parm    UINT | wDeviceID | The device ID which triggered the callback
;
; @parm    UINT | wStatus | The status of the callback.  May be one of
;          MCI_NOTIFY_SUCCESSFUL or MCI_NOTIFY_SUPERSEDED or MCI_NOTIFY_ABORTED
;          or MCI_NOTIFY_FAILURE
;
; @rdesc   Returns TRUE if notify was successfully sent, FALSE if the
;          application's message queue was full.
;
; @comm    This function is callable at interrupt time.
;
;-----------------------------------------------------------------------;

cProc	mciDriverNotify, <FAR, PUBLIC, PASCAL>, <>
;	ParmW	hwndCallback
;	ParmW	wDeviceID
;	ParmW	wStatus
cBegin <nogen>
	pop	bx			; Fetch the return address
	pop	dx
	pop	ax			; Fetch wStatus
	pop	cx			; Fetch wDeviceID
	push	MM_MCINOTIFY		; Message
	push	ax			; wParam == wStatus
	push	0			; HIWORD of lParam
	push	cx			; LOWORD of lParam == wDeviceID
	push	dx			; Put return address back
	push	bx
	jmp	FAR PTR PostMessage	; Jump directly to avoid returning to here
cEnd <nogen>

sEnd

;-----------------------------------------------------------------------;

END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\mmsystem\stack.asm ===
page 80,132
;***************************************************************************;
;
;   STACK.ASM
;
;   Copyright (c) Microsoft Corporation 1989, 1990. All rights reserved.
;
;   This module contains a routine that calls a callback function on a
;   internal stack.  This is designed to be used by MMSYSTEM drivers that
;   call user callback functions at async interupt time.
;
;   Revision history:
;
;   07/30/90        First created by ToddLa (moved from SndBlst driver)
;   04/24/91        MikeRo. Added stack usage stuff.
;   07/07/91        CurtisP. New stack switcher code that allows user to
;                   configure size and number of stacks.  Default is 3
;                   frames of 1.5kb each.  This is the minimum that MCISEQ
;                   needs in standard mode (running concurrent with wave).
;                   [mmsystem]!stackframes= and !stacksize=.  stackframes
;                   mul stacksize can not be > 64k.
;   07/24/91        ToddLa. even newer stack switcher code! export StackEnter
;                   and StackLeave
;   11/02/92        StephenE. Hacked the code to make it work on NT/WOW.
;
;***************************************************************************;

ifdef MYDEBUG
        DEBUG_RETAIL equ 1
endif

?PLM=1  ; pascal call convention
?WIN=0  ; NO! Windows prolog/epilog code

        .286p
        .xlist
        include wow.inc
        include wowmmcb.inc
        include wowmmed.inc
        include cmacros.inc

;       include windows.inc
;       include mmsystem.inc
;       include mmddk.inc
;       include wowmmcb.inc

	include vint.inc
        .list

OFFSEL	STRUC
Off	dw  ?
Sel	dw  ?
OFFSEL	ENDS

LOHI	STRUC
Lo	dw  ?
Hi	dw  ?
LOHI	ENDS

DCB_NOSWITCH    equ   0008h           ; don't switch stacks for callback
DCB_TYPEMASK    equ   0007h           ; callback type mask
DCB_NULL        equ   0000h           ; unknown callback type

; flags for wFlags parameter of DriverCallback()
DCB_WINDOW     equ    0001h           ; dwCallback is a HWND
DCB_TASK       equ    0002h           ; dwCallback is a HTASK
DCB_FUNCTION   equ    0003h           ; dwCallback is a FARPROC

        externFP        PostMessage         ; in USER
        externFP        PostAppMessage      ; in USER
        externFP        CALLPROC32W         ; in Kernel
        externFP        ThunkInit           ; in init.c
        externFP        WOW16Call           ; in Kernel

;******************************************************************************
;
;   SEGMENTS
;
;******************************************************************************
createSeg FIX,          CodeFix, word, public, CODE
createSeg INTDS,        DataFix, byte, public, DATA

;***************************************************************************;
;
;   equates and structure definitions
;
;***************************************************************************;

STACK_MAGIC         equ     0BBADh


;***************************************************************************;
;
;   Local data segment
;
;***************************************************************************;

sBegin DataFix
;
; This is the stack we will switch to whenever we are calling
; a user call back
;
        public  gwStackSize
        public  gwStackFrames
        public  gwStackUse
        public  gwStackSelector
        public  hdrvDestroy
        public  vpCallbackData
        public  hGlobal
        public  DoInterrupt
        public  tid32Message
        public  mmwow32Lib
        public  CheckThunkInit

gwStackSize     dw      0
gwStackFrames   dw      0
gwStackUse      dw      0
gwStackSelector dw      0
hdrvDestroy     dw      -1      ; this handle is being closed
vpCallbackData  dd      0
hGlobal         dd      0
tid32Message    dd      0       ; timer driver entry point
mmwow32Lib      dd      0

sEnd    DataFix

;-------------------------------------------------------------------------;
;
;   debug support
;
;-------------------------------------------------------------------------;
externFP        OutputDebugString

;--------------------------Private-Macro----------------------------------;
; DOUT String - send a debug message to the debugger
;
; Entry:
;       String      String to send to the COM port, does not need a CR,LF
;
; Registers Destroyed:
;       none
;
; NOTE no code is generated unless the MYDEBUG symbol is defined
;
; History:
;       Sun 31-Jul-1989  -by-  ToddLa
;        Wrote it.
;-------------------------------------------------------------------------;

DOUT    macro   text
        local string_buffer_stack
ifdef MYDEBUG
        push    cs
        push    offset string_buffer_stack
        call    OutputDebugString
        jmp     @F
string_buffer_stack label byte
        db      "mmsystem: "
        db      "&text&",13,10,0
@@:
endif
        endm


;***************************************************************************;
;
;   code segment
;
;***************************************************************************;

sBegin CodeFix
        assumes cs, CodeFix
        assumes ds, nothing
        assumes es, nothing

externA     __WinFlags

public      CodeFixWinFlags
public      CodeFixDS

CodeFixWinFlags     dw      __WinFlags
CodeFixDS           dw      DataFixBASE

;***************************************************************************;
;
;   @doc DDK MMSYSTEM
;
;   @asm StackEnter |
;
;   This function switches to the next internal mmsystem interupt stack
;   available.
;
;   if one is not available we stay on the current stack.
;
;   the size and number of mmsystem stacks is controlable from SYSTEM.INI
;   (these are the defaults)
;
;       [mmsystem]
;           StackSize   = 1536
;           StackFrames = 3
;
;   for every call to StackEnter a call to StackLeave *must* be made (even
;   if StackEnter fails!)
;
;   this function is intended to be used as the first thing done by a ISR
;
;       MyISR proc far
;
;               call    StackEnter          ; switch to a safe stack
;
;               pusha                       ; save registers we use
;
;               <handle IRQ>
;
;               popa                        ; restore registers
;
;               call    StackLeave          ; return to interupt stack
;               iret                        ; done with ISR
;
;       MyISR endp
;
;   The old SS:SP is pushed onto the new stack, and the function returns.
;
;   @rdesc NC   ** succesfuly switced to a new stack
;           C   ** you are hosed jack, no stacks left
;                  (you remain on current stack)
;
;   @uses flags
;
;   @saves all
;
;   @xref StackLeave, DriverCallback
;
;***************************************************************************;

        assumes ds, nothing
        assumes es, nothing

cProc   StackEnter, <FAR, PUBLIC>, <>
cBegin  nogen

        ;
        ; On WOW we only emulate Standard mode therefore I won't bother
        ; with the test described below.
        ;
        ; if we are in 386 mode or better (ie *not* standard mode) then, just
        ; get out.
        ;
;       test    cs:[CodeFixWinFlags],WF_WIN286
;       jz      stack_enter_retf

        push    ds

        mov     ds,[CodeFixDS]
        assumes ds,DataFix

        cmp     [gwStackUse], 0                     ; are we out of stacks?
        jne     stack_enter_have_stack_will_travel  ; ..no go grab it

;**********************************************************************-;
;
;  We are out of internal stacks.  To give us the greates chance
;  of coming out of this condition alive, we stay on the current
;  stack.  This could fail miserably if we are on a very small
;  stack**but it is better than crashing outright.
;
;**********************************************************************-;

ifdef DEBUG_RETAIL
        cmp     [gwStackSelector], 0
        je      stack_enter_stay_here

        DOUT    <StackEnter: All stacks in use, increase StackFrames>
        int     3
endif

ifdef MYDEBUG
        call    dump_stack_users
endif

stack_enter_stay_here:
        pop     ds
        assumes ds,nothing
        push    bp
        mov     bp,sp
        push    ax

        xor     ax,ax
        xchg    [bp+4],ax
        xchg    [bp+2],ax
        xchg    [bp],ax
        xchg    [bp-2],ax

        pop     bp
stack_enter_retf:
        stc
        retf

;**********************************************************************-;
;
;   we have a stack to use, allocate stack FIRST, then muck with it
;   leave no window for interrupts to blast us.
;
;   It does this by using the contents of the gwStackUse variable as
;   the new SP.  This initially contains the address of the start (ie top)
;   of the internal stack area, and is subtracted from each time a StackEnter
;   occurs.  It is of course added to again when StackLeave is called
;   freeing up that area of stack for the next use.
;
;   Note that the stack usage counter is modified before anything is
;   is pushed onto the new stack.  If an interrupt occurs after the stack
;   switch, but before the usage is set, it will be fine.
;
;**********************************************************************-;
        assumes ds,DataFix

stack_enter_have_stack_will_travel:
        push    ax
        push    bx
        mov     bx,sp

        mov     ax, [gwStackSize]
        sub     [gwStackUse], ax        ; reserve stack before using
        add     ax, [gwStackUse]        ; get current value and hang onto it

;**********************************************************************-;
;
;   debug code, in the debug version we do crazy things like filling
;   the stack with magic numbers.
;
;**********************************************************************-;
ifdef MYDEBUG
;       **  This code will fill the stack with the magic cookie**this
;       **  is used to see how much stack space is being used at any
;       **  time.

        push    es
        push    di
        push    ax
        push    cx
        mov     di, ax                  ; es:di -> top of stack
        mov     es, [gwStackSelector]
        mov     cx, [gwStackSize]       ; get size to fill
        sub     di, cx                  ; es:di -> bottom of stack
        shr     cx, 1                   ; in words
        mov     ax, STACK_MAGIC         ; what to fill with
        cld                             ; bottom up
        rep     stosw
        pop     cx                      ; restore munged regs
        pop     ax
        pop     di
        pop     es
endif

ifdef DEBUG_RETAIL
;       **  This code puts a single magic cookie at the end of the stack.
;       **  This is used by the stack leave routine to check for overflow.
;       **  If the above code (the fill) is running, then this code is
;       **  redundant.

        push    es
        push    bx
        mov     es,[gwStackSelector]
        mov     bx,[gwStackUse]         ;   new stack
        mov     es:[bx], STACK_MAGIC
        pop     bx
        pop     es
endif

;**********************************************************************-;
;
;   time to switch to the *new* stack, [gwStackSelector]:AX contains
;   the new SS:SP, but first save the *old* SS:SP and restore
;   the registers we nuked to get here
;
;**********************************************************************-;

        push    [gwStackSelector]       ; push *new* ss

        push    ss                      ; save current ss in ds
        pop     ds
        assumes ds, nothing

        pop     ss                      ; switch to new stack
        mov     sp, ax                  ; ints off until after this on >= 286

;**********************************************************************-;
;
;   now that we are on the new stack, copy some important info from
;   the old stack to this one.  note DS:[BX] points to the old stack
;
;       [BX+0]        ==> saved  BX
;       [BX+2]        ==> saved  AX
;       [BX+4]        ==> saved  DS
;       [BX+6]        ==> return IP
;       [BX+8]        ==> return CS
;
;   in the MYDEBUG version we save the callers CS:IP on the stack so we
;   can (in dump_stack_users) walk all the stacks
;
;**********************************************************************-;

ifdef MYDEBUG
        push    [bx+8]                  ; push a CS:IP for dumping stack users
        push    [bx+6]
endif
        add     bx,10                   ; 10 = ax+bx+dx+retf
        push    ds                      ; save old SS:SP (SP = BX+N)
        push    bx
        sub     bx,10

        push    [bx+8]                  ; push return addr
        push    [bx+6]

        push    [bx+4]                  ; push saved DS
        push    [bx]                    ; push saved BX

        mov     ax,[bx+2]               ; restore ax
        pop     bx                      ; restore bx
        pop     ds                      ; restore ds
        clc                             ; show success
stack_leave_retf:
        retf                            ; return to caller

cEnd    nogen

;***************************************************************************;
;
;   @doc DDK MMSYSTEM
;
;   @asm StackLeave |
;
;   This function returns the stack to the original stack saved by StackEnter
;
;   @uses flags
;
;   @saves all
;
;   @xref   StackEnter, DriverCallback
;
;***************************************************************************;

        assumes ds, nothing
        assumes es, nothing

cProc   StackLeave, <FAR, PUBLIC>, <>
cBegin  nogen
        ;
        ; if we are in 386 mode or better (ie *not* standard mode) then, just
        ; get out.
        ;
;       test    cs:[CodeFixWinFlags],WF_WIN286
;       jz      stack_leave_retf

        push    bx
        mov     bx,sp

;**********************************************************************-;
;
;   here is the state of things:
;
;       [BX+0]        ==> saved  BX
;       [BX+2]        ==> return IP
;       [BX+4]        ==> return CS
;       [BX+6]        ==> saved  SP
;       [BX+8]        ==> saved  SS
;
;   the first thing we must check for is EnterStack running out of
;   stacks.  in this case StackEnter pushed a single zero where the
;   saved SS should be
;
;**********************************************************************-;

        cmp     word ptr ss:[bx+6],0    ; check saved SP
        jnz     stack_leave_normal

;**********************************************************************-;
;
;   StackEnter ran out of stacks, stay on the current stack, but remove
;   the bogus SS
;
;**********************************************************************-;
stack_leave_abby_normal:
        pop     bx                      ; return to caller taking the
        retf    2                       ; bogus zero SP with us

;**********************************************************************-;
;
;   we need to return to the stack saved by StackEnter
;
;**********************************************************************-;
stack_leave_normal:
        push    ds                      ; [BX-2] ==> saved DS

        push    ss                      ; DS = old stack
        pop     ds
        assumes ds,nothing

ifdef MYDEBUG
        push    ax
        mov     ax,[bx+8]
        lar     ax,ax
        jz      @f
        DOUT    <StackLeave: invalid stack>
        int     3
@@:     pop     ax
endif

        mov     ss,[bx+8]               ; switch to new stack
        mov     sp,[bx+6]               ; ints off until after this on >= 286

        push    [bx+4]                  ; push return addr
        push    [bx+2]

        push    [bx]                    ; push old BX
        push    [bx-2]                  ; push old DS

;**********************************************************************-;
;
;   we are back on the original stack, now it is time to deallocate
;   the stack.
;
;   The stack usage must only be released after all
;   values have been removed from the stack so that an interrupt can be
;   serviced without writing over any values.
;
;**********************************************************************-;

        mov     ds,[CodeFixDS]          ; get at our globals
        assumes ds,DataFix

ifdef DEBUG_RETAIL
        push    es
        push    bx
        mov     bx,[gwStackUse]         ; before we release it
        mov     es,[gwStackSelector]
        cmp     es:[bx], STACK_MAGIC
        mov     es:[bx], STACK_MAGIC    ; and try to recover...
        pop     bx
        pop     es
        je      @f                      ; true if magic cookie existed

        DOUT    <StackLeave: STACK OVERFLOW>
        int     3
ifdef MYDEBUG
        call    dump_stack_users
endif
@@:
endif
        mov     bx, [gwStackSize]       ; get the size of the stacks
        add     [gwStackUse], bx        ; release stack frame after use

        pop     ds
        assumes ds,nothing
        pop     bx
        retf

cEnd nogen

;****************************************************************************
;   FUNCTION:  DoInterrupt()
;
;   PURPOSE:
;       This routine is called by the ISR in the InstallInerruptHandler
;       routine.
;
;   void DoInterrupt( void )
;   {
;       VPCALLBACK_ARGS     pArgs;
;       WORD                wSendCount = vpCallbackData->wSendCount;
;       WORD                wTempRecvCount;
;
;       /*
;       ** At entry to this function the receive count should be one less than
;       ** than the send count.  However, it is possible that we have lost some
;       ** interrupts in which case we should try to "catch up" here.
;       **
;       ** The 32 bit side does not increament wSendCount until the
;       ** callback data buffer has been updated. This means that although it
;       ** is possible that it could have been changed before this interrupt
;       ** was generated it will never point to an invalid buffer location.
;       ** We simply process two interrupt request from the first interrupt,
;       ** when the second interrupt goes off we return straight away.
;       */
;       vpCallbackData->wIntsCount++;
;
;       while ( vpCallbackData->wRecvCount != wSendCount ) {
;
;           /*
;           ** Increment the recv count.  Use of the % operator to makes sure
;           ** that we wrap around to the begining of the array correctly.
;           */
;           wTempRecvCount = (vpCallbackData->wRecvCount + 1)
;                               % CALLBACK_ARGS_SIZE;
;
;           pArgs = &vpCallbackData->args[ wTempRecvCount ];
;           DriverCallback( pArgs->dwFunctionAddr,
;                           LOWORD( pArgs->dwFlags ),
;                           pArgs->wHandle,
;                           pArgs->wMessage,
;                           pArgs->dwInstance,
;                           pArgs->dwParam1,
;                           pArgs->dwParam2 );
;
;           vpCallbackData->wRecvCount = wTempRecvCount;
;       }
;
;   }
;
;****************************************************************************
cProc DoInterrupt, <FAR,PUBLIC>, <si,di>

localW  wSendCount                     ;number of interrupts sent

cBegin  DoInt

        DOUT    <Multi-Media Interupt called>

;
;       Now we take the parameters from the global callback data array
;       and increment the dwRecvCount field.  Then we make the
;       callback into the apps routine.  Note that the es:bx registers are used
;       instead of the local variable pArgs.
;

        mov     es,[CodeFixDS]
        assumes es,DataFix

;
;       wSendCount = vpCallbackData->wSendCount
;       vpCallbackData->wIntsCount++;
;
	les	bx,DWORD PTR es:vpCallbackData
	mov	ax,WORD PTR es:[bx+2]
	mov	wSendCount,ax	
        inc     WORD PTR es:[bx+388]    ; increment the count of interrupts rcv

        jmp     DoIntMakeTheTest

;
;       Make es:bx point to the correct slot in the callback data table.
;

DoIntMakeTheCall:

;
;       Increment the recv count.  Use of the % operator above makes sure
;       that we wrap around to the begining of the array correctly.
;
;       wTempRecvCount = (vpCallbackData->wRecvCount + 1) % CALLBACK_ARGS_SIZE;
;

	mov	al,BYTE PTR es:[bx]
	inc	al
	and	ax,15
        mov     cx,ax

;
;       pArgs = &vpCallbackData->args[ vpCallbackData->wRecvCount ];
;       vpCallbackData->wRecvCount = wTempRecvCount;
;       Note that pArgs is really es:bx.
;

        mov     es,[CodeFixDS]
	les	bx,DWORD PTR es:vpCallbackData
	imul	ax,WORD PTR es:[bx],24  ;ax = wRecvCount * sizeof(CALLBACKDATA)

;
;       Note: our caller saves ALL registers.  We do not need to preserve si
;
        mov     si,bx
	add	bx,ax                   ;bx = bx + ax
	add	bx,4                    ;bx += sizeof(WORD) * 2

;
;       Set up the stack frame for DriverCallback
;
	push	WORD PTR es:[bx+6]
	push	WORD PTR es:[bx+4]
	push	WORD PTR es:[bx]
	push	WORD PTR es:[bx+8]
	push	WORD PTR es:[bx+10]
	push	WORD PTR es:[bx+14]
	push	WORD PTR es:[bx+12]
	push	WORD PTR es:[bx+18]
	push	WORD PTR es:[bx+16]
	push	WORD PTR es:[bx+22]
	push	WORD PTR es:[bx+20]

;
;       We have to set up the stack frame before incrementing wRecvCount to
;       prevent the 32 bit code from eating our slot in the buffer.
;
	mov	WORD PTR es:[si],cx      ;wRecvCount = wTempRecvCount

	call	FAR PTR DriverCallback


;
;       Reload es:bx and ax ready for the loop test
;
	mov	ax,wSendCount
        mov     es,[CodeFixDS]
	les	bx,DWORD PTR es:vpCallbackData

DoIntMakeTheTest:
	cmp	WORD PTR es:[bx],ax
	jne     DoIntMakeTheCall

cEnd    DoInt


ifdef XDEBUG
public  stack_enter_stay_here
public  stack_enter_have_stack_will_travel
public  stack_leave_abby_normal
public  stack_leave_normal
endif

;***************************************************************************;
;
;   @doc DDK MMSYSTEM
;
;   @api BOOL | DriverCallback | This function notifies a client
;     application by sending a message to a window or callback
;     function or by unblocking a task.
;
;   @parm   DWORD   | dwCallBack    | Specifies either the address of
;     a callback function, a window handle, or a task handle, depending on
;     the flags specified in the <p wFlags> parameter.
;
;   @parm   WORD    | wFlags        | Specifies how the client
;     application is notified, according to one of the following flags:
;
;   @flag   DCB_FUNCTION        | The application is notified by
;     sending a message to a callback function.  The <p dwCallback>
;     parameter specifies a procedure-instance address.
;   @flag   DCB_WINDOW          | The application is notified by
;     sending a message to a window.  The low-order word of the
;     <p dwCallback> parameter specifies a window handle.
;
;   @flag   DCB_NOSWITCH | DriverCallback should *not* switch to a new stack
;
;   @parm   WORD    | hDevice       | Specifies a handle to the device
;     associated with the notification.  This is the handle assigned by
;     MMSYSTEM when the device was opened.
;
;   @parm   WORD    | wMsg          | Specifies a message to send to the
;     application.
;
;   @parm   DWORD   | dwUser        | Specifies the DWORD of user instance
;     data supplied by the application when the device was opened.
;
;   @parm   DWORD   | dwParam1      | Specifies a message-dependent parameter.
;   @parm   DWORD   | dwParam2      | Specifies a message-dependent parameter.
;
;   @rdesc Returns TRUE if the callback was performed, else FALSE if an invalid
;     parameter was passed, or the task's message queue was full.
;
;   @comm  This function can be called at interrupt time.
;
;   The flags DCB_FUNCTION and DCB_WINDOW are equivalent to the
;   high-order word of the corresponding flags CALLBACK_FUNCTION
;   and CALLBACK_WINDOW specified when the device was opened.
;
;   If notification is done with a callback function, <p hDevice>,
;   <p wMsg>, <p dwUser>, <p dwParam1>, and <p dwParam2> are passed to
;   the callback.  If notification is done with a window, only <p wMsg>,
;   <p hDevice>, and <p dwParam1> are passed to the window.
;***************************************************************************;

        assumes ds, nothing
        assumes es, nothing

cProc DriverCallback, <FAR, PASCAL, PUBLIC>, <>

        parmD dwCallBack                ; callback procedure to call
        parmW fCallBack                 ; callback flags
        parmW hdrv                      ; handle to the driver
        parmW msg                       ; driver message
        parmD dwUser                    ; user instance data
        parmD dw1                       ; message specific
        parmD dw2                       ; message specific

cBegin
        cld                      ; lets not make any assumptions about this!!!!

;**************************************************************************-;
;   check for quick exit cases and get out fast
;**************************************************************************-;
        mov     ax,dwCallback.lo        ; check for dwCallback == NULL
        or      ax,dwCallback.hi
        jz      dcb_error_exit_now      ; if NULL get out fast

        mov     ax,fCallback            ; get flags and mask out the type bits
        test    ax,DCB_TYPEMASK
        jz      dcb_error_exit_now      ; if NULL get out fast

ifdef NEVER
;**************************************************************************-;
;   if this handle is being NUKED don't allow callbacks into the app
;
;   I won't bother with this test on WOW either.   -- StephenE 2nd Nov 1992
;**************************************************************************-;
        mov     es,[CodeFixDS]
        assumes es,DataFix
        mov     bx,hdrv
        cmp     bx,es:[hdrvDestroy]     ; same as the handle being nuked?
        je      dcb_error_exit_now      ; if yes, get out'a here
        assumes es,nothing
endif

;**************************************************************************-;
;   set up ES == SS, so we can access stack params after switching
;   stacks, NOTE!! ES:[bp+##] *must* be used to access parameters!
;**************************************************************************-;
        mov     cx,ss                   ; set ES == callers stack
        mov     es,cx                   ;   use ES to get at local vars
        assumes es,nothing

;**************************************************************************-;
;   We won't switch stacks on WOW since DPMI does this for us. Win 3.1
;   would only switch stacks in Standard mode which we no longer support.
;**************************************************************************-;

;        test    ax,DCB_NOSWITCH         ; should we switch stacks?
;        jnz     dcb_on_stack

;        call    StackEnter              ; switch to new stack

;**************************************************************************-;
;   determine the type of the callback, dwCallback is either a FARPROC, HWND
;   or HTASK depending on the value of fCallback
;**************************************************************************-;
dcb_on_stack:
                                        ;
        pushf                           ; Save the interrupt flag state
        FSTI                            ; ** Enable interrupts here **
                                        ;

;        push    ax                      ; save flags for StackLeave test

        and     ax,DCB_TYPEMASK         ; mask out the type bits

        cmp     ax,DCB_WINDOW           ; is it a window handle?
        je      dcb_post_message

        cmp     ax,DCB_TASK             ; is it a task handle?
        je      dcb_post_event

        cmp     ax,DCB_FUNCTION         ; is it a procedure?
        je      dcb_call_callback

        DOUT    <DriverCallback: Invalid flags #ax>
        xor     ax,ax
        jmp     dcb_exit

dcb_error_exit_now:
        xor     ax,ax
        jmp     dcb_exit_now

ifdef NEVER
;**************************************************************************-;
;   the Callback flags are NULL determine the callback type by the HIWORD
;   of dwCallback, if it is NULL assume it is a WINDOW otherwise it is a
;   FARPROC
;**************************************************************************-;
dcb_null_flags:
        mov     ax,es:dwCallback.hi     ; get selector of callback
        or      ax,ax
        jnz     dcb_call_callback       ; if NULL then assume it is a window
        errn$   dcb_post_message        ;   otherwise assume a FARPROC
endif

;**************************************************************************-;
;   dwCallback is a window handle, call PostMessage() to insert a message in
;   the applications message Que
;**************************************************************************-;
dcb_post_event:
        cmc
dcb_post_message:
        push    es:dwCallback.lo            ; hwnd
        push    es:msg                      ; message
        push    es:hdrv                     ; wParam = hdrv
        push    es:dw1.hi                   ; lParam = dw1
        push    es:dw1.lo

        jc      dcb_post_app_message
        call    PostMessage
        jmp     dcb_exit

;**************************************************************************-;
;   dwCallback is a task handle, call PostAppMessage() to 'wake' the task up
;**************************************************************************-;
dcb_post_app_message:
        call    PostAppMessage
        jmp     dcb_exit

;**************************************************************************-;
;   dwCallback is a callback procedure, we will call it.
;**************************************************************************-;
dcb_call_callback:
        ;
        ; is the callback a valid function?
        ;
        lar     ax,es:dwCallback.hi
        jnz     dcb_invalid_callback
        test    ax,0800H                    ; test for code/data selector
        jnz     dcb_valid_callback

dcb_invalid_callback:
ifdef MYDEBUG_RETAIL
        mov     ax,es:dwCallback.lo
        mov     dx,es:dwCallback.hi
        DOUT    <DriverCallback: Invalid callback function #dx:#ax>
        int     3
endif
        xor     ax,ax
        jmp     dcb_exit

dcb_valid_callback:
        push    es:hdrv
        push    es:msg
        push    es:dwUser.hi
        push    es:dwUser.lo
        push    es:dw1.hi
        push    es:dw1.lo
        push    es:dw2.hi
        push    es:dw2.lo
        call    es:dwCallback
        mov     ax,1
        errn$   dcb_exit

dcb_exit:
                                            ;
        popf                                ; ** restore the interrupt flag **
                                            ;

;        pop     bx                          ; restore flags
;        test    bx,DCB_NOSWITCH             ; should we switch back?
;        jnz     dcb_exit_now

;        call    StackLeave                  ; return to previous stack
        errn$   dcb_exit_now

dcb_exit_now:
cEnd

ifdef MYDEBUG
;**************************************************************************-;
;
; each mmsystem stack has a SS:SP and in MYDEBUG a CS:IP of the caller of
; StackEnter, the top of each stack looks like this.
;
;   +-------------------------------------+
;   | CS:IP of caller of StackEnter() (in MYDEBUG)
;   +-------------------------------------+
;   | SS:SP to restore
;   +-------------------------------------+
;
;**************************************************************************-;
        assumes ds,DataFix
        assumes es,nothing

        public  dump_stack_users
dump_stack_users proc near

        cmp     [gwStackSelector],0
        jne     @f
        ret

@@:     pusha
        push    es

        mov     cx,[gwStackFrames]
        mov     di,[gwStackSize]
        mov     si,[gwStackUse]
        mov     es,gwStackSelector

        DOUT    <StackUsers: Frames[#cx] Size[#di] Use[#si]>

dump_stack_loop:
        lar     ax,es:[di-4].sel
        jnz     dump_stack_next

        mov     ax,es:[di-4].off        ; get CS:IP of StackEnter caller
        mov     dx,es:[di-4].sel

        mov     si,es:[di-8].off        ; get SS:SP of StackEnter caller
        mov     bx,es:[di-8].sel

        DOUT    <StackUser #cx is CS:IP = #dx:#ax SS:SP = #bx:#si>

dump_stack_next:
        add     di,[gwStackSize]
        loop    dump_stack_loop

        pop     es
        popa
        ret

dump_stack_users endp

endif

;-----------------------------------------------------------------------;
;
;    @doc INTERNAL
;
;    @api DWORD | CheckThunkInit | send a message to the timer driver
;
;    @rdesc Returns 0 if successful, otherwise an error code,
;           (typically MMSYSERR_NODRIVER).
;
;-----------------------------------------------------------------------;
	assumes ds,nothing
        assumes es,nothing

cProc   CheckThunkInit, <FAR, PUBLIC, PASCAL>, <>
cBegin
        mov     es,[CodeFixDS]
        assumes es,DataFix

        sub     ax,ax                           ; assume sucess
        mov     bx,WORD PTR es:[mmwow32Lib]     ; is mmwow32Lib loaded ?
        mov     cx,WORD PTR es:[mmwow32Lib+2]   ; try to load it
        or      cx,bx                           ; ThunkInit returns ax=1
        jnz     @F                              ; if it loaded OK, otherwise
        call    ThunkInit                       ; ax=MMSYSERR_NODRIVER
@@:
cEnd


;-----------------------------------------------------------------------;
;
;    @doc INTERNAL
;
;    @api DWORD | timeMessage | send a message to the timer driver
;
;    @parm WORD | msg | message to send
;
;    @parm DWORD | dw1 | first DWORD
;
;    @parm DWORD | dw2 | first DWORD
;
;    @rdesc Returns zero if successful, error code otherwise
;
;-----------------------------------------------------------------------;
	assumes ds,nothing
        assumes es,nothing

cProc   timeMessage, <FAR, PUBLIC, PASCAL>, <>
        ParmW   msg
        ParmD   dw1
        ParmD   dw2
cBegin
        mov     es,[CodeFixDS]
        assumes es,DataFix

        sub     ax,ax                           ; assume sucess
        mov     bx,WORD PTR es:[mmwow32Lib]     ; is mmwow32Lib loaded ?
        mov     cx,WORD PTR es:[mmwow32Lib+2]   ; try to load it
        or      cx,bx                           ; ThunkInit returns ax=1
        jnz     timer_have_thunks               ; if it loaded OK, otherwise
        push    es
        call    ThunkInit                       ; ax=MMSYSERR_NODRIVER
        pop     es
        or      ax,ax
        jnz     timeMessageExit

timer_have_thunks:

        push    ax                              ; uDevID
        push    ax                              ;

        push    ax                              ; Message passed
        push    msg                             ;

        push    ax                              ; dwInstance
        push    ax                              ;

        push    dw1.hi                          ; dwParam1
        push    dw1.lo                          ;

        push    dw2.hi                          ; dwParam2
        push    dw2.lo                          ;

        push    WORD PTR es:[tid32Message+2]    ; Address of function to call
        push    WORD PTR es:[tid32Message]      ;

        push    ax                              ; No directory change
        push    ax

      	call	FAR PTR MMCALLPROC32
timeMessageExit:
cEnd

       MMediaThunk    MMCALLPROC32

sEnd CodeFix

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\mmsystem\task.c ===
/******************************************************************************

   Copyright (C) Microsoft Corporation 1985-1990. All rights reserved.

   Title:   task.c - support for task creation and blocking

   Version: 1.00

   Date:    05-Mar-1990

   Author:  ROBWI

------------------------------------------------------------------------------

   Change log:

      DATE        REV            DESCRIPTION
   -----------   ----- -----------------------------------------------------------
   05-MAR-1990   ROBWI First Version - APIs and structures
   18-APR-1990   ROBWI Ported from Resman to mmsystem
   25-JUN-1990   ROBWI Added mmTaskYield
   07-JUL-1991   CJP   Modified to work with new stack switcher code

*****************************************************************************/

#include <windows.h>
#include "mmsystem.h"
#include "mmsysi.h"
#include "mmddk.h"
#include "mmtask\mmtask.h"

UINT  FAR PASCAL BWinExec(LPSTR lpModuleName, UINT wCmdShow, LPVOID lpParameters);

/***************************************************************************
 *
 * @doc     DDK    MMSYSTEM    TASK
 *
 * @api     UINT | mmTaskCreate | This function creates a new task.
 * 
 *   @parm    LPTASKCALLBACK | lpfn |  Points to a program supplied
 *            function and represents the starting address of the new
 *            task.
 *
 *   @parm    HTASK FAR * | lph | Points to the variable that receives the
 *            task identifier. This may be NULL in some versions. This
 *            is not an error it simply means that the system could not
 *            determine the task handle of the newly created task.
 *
 *   @parm    DWORD | dwStack | Specifies the size of the stack to be
 *            provided to the task.
 *
 *   @parm    DWORD | dwInst | DWORD of instance data to pass to the task
 *            routine.
 *
 *   @rdesc   Returns zero if the function is successful. Otherwise it
 *            returns an error value which may be one of the following:
 *
 *     @flag    TASKERR_NOTASKSUPPORT | Task support is not available.
 *     @flag    TASKERR_OUTOFMEMORY | Not enough memory to create task.
 *            
 * @comm    When a mmsystem task is created, the system will make a far
 *          call to the program-supplied function whose address is
 *          specified by the lpfn parameter. This function may include
 *          local variables and may call other functions as long as
 *          the stack has sufficient space.
 *
 *          The task terminates when it returns.
 *
 * @xref    mmTaskSignal mmTaskBlock
 *
 ***************************************************************************/

UINT WINAPI mmTaskCreate(LPTASKCALLBACK lpfn, HTASK FAR * lph, DWORD dwInst)
{
    MMTaskStruct     TaskStruct;
    char             szName[20];
    UINT             wRes;
    HTASK            hTask;

    /*
        create another app. so that we can run the stream outside of
        the context of the app. 
    */

    if (!LoadString(ghInst, IDS_TASKSTUB, szName, sizeof(szName)))
        return TASKERR_NOTASKSUPPORT;

    TaskStruct.cb = sizeof(TaskStruct);
    TaskStruct.lpfn = lpfn;
    TaskStruct.dwInst = dwInst;
    TaskStruct.dwStack = 0L;

    wRes = BWinExec(szName, SW_SHOWNOACTIVATE, &TaskStruct);

    if (wRes > 32)
    {
        hTask = wRes;
        wRes = MMSYSERR_NOERROR;
    }
    else if (wRes == 0)
    {
        wRes = TASKERR_OUTOFMEMORY;
        hTask = NULL;
    }
    else
    {
        wRes  = TASKERR_NOTASKSUPPORT;
        hTask = NULL;
    }
    
    if (lph)
        *lph = hTask;

    DPRINTF2("mmTaskCreate: hTask = %04X, wErr = %04X\r\n", hTask, wRes);

    return wRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\mmsystem\thunks.asm ===
page    ,132
;-----------------------------Module-Header-----------------------------;
; Module Name:  thunks.asm - Passes control to 32 bit code.
;
;
; Created:  27-09-93
; Author:   Stephen Estrop [StephenE]
;
; Copyright (c) 1993 Microsoft Corporation
;
;-----------------------------------------------------------------------;

        ?PLM    = 1
        ?WIN    = 0
        PMODE   = 1

        .xlist
        include cmacros.inc
        include windows.inc
        .list

;-----------------------------------------------------------------------;
;
;-----------------------------------------------------------------------;
        externFP    MMCALLPROC32                ; in Stack.asm
        externFP    wod32Message
        externFP    wid32Message
        externFP    mod32Message
        externFP    mid32Message
        externFP    joy32Message                ; in joy.c
        externFP    aux32Message                ; in init.c
        externFP    mci32Message                ; in mci.c
        externFP    cb32                        ; in init.c
        externFP    CheckThunkInit              ; in stack.asm
        externFP    wodMapper                   ; in init.c
        externFP    widMapper                   ; in init.c

WAVE_MAPPER    equ   (-1)                       ;
;
; The following structure should be used to access high and low
; words of a DWORD.  This means that "word ptr foo[2]" -> "foo.hi".
;
LONG    struc
lo      dw      ?
hi      dw      ?
LONG    ends

FARPOINTER      struc
off     dw      ?
sel     dw      ?
FARPOINTER      ends



createSeg WAVE, WaveSeg, word, public, CODE

sBegin  WaveSeg
        assumes cs,WaveSeg
        assumes ds,nothing
        assumes es,nothing


;-----------------------------------------------------------------------;
; @doc INTERNAL  WAVE
;
; @func DWORD | waveOMessage | This function sends messages to the waveform
;   output device drivers.
;
; @parm HWAVE | hWave | The handle to the audio device.
;
; @parm UINT | wMsg | The message to send.
;
; @parm DWORD | dwP1 | Parameter 1.
;
; @parm DWORD | dwP2 | Parameter 2.
;
; @rdesc Returns the value returned from the thunk.
;-----------------------------------------------------------------------;
cProc waveOMessage, <NEAR, PUBLIC, PASCAL>, <>
        ParmW   hWave
        ParmW   wMsg
        ParmD   dw1
        ParmD   dw2
cBegin
        call    CheckThunkInit          ; returns ax=0 if sucessful
        or      ax,ax
        jnz     waveOMessage_exit

        mov     bx,hWave                ; bx = hWave
        mov     ax,WORD PTR [bx+8]      ; ax = bx->wDeviceID


        cmp     ax,WAVE_MAPPER          ; Is this the wave mapper
        jnz     @f                      ; No so thunk to the 32 bit code.

        cmp     [wodMapper].hi,0        ; No wave mapper loaded
        jz      @f                      ; so jump to 32 bit code

        push    ax                      ; push device id
        push    wMsg                    ; push message

        push    WORD PTR [bx+6]         ; push bx->dwDrvUser.hi
        push    WORD PTR [bx+4]         ; push bx->dwDrvUser.lo

        push    dw1.hi
        push    dw1.lo

        push    dw2.hi
        push    dw2.lo

        call    DWORD PTR [wodMapper]

        jmp     waveOMessage_exit

@@:
        sub     dx,dx                   ; dx = 0
        push    dx
        push    ax

        push    dx
        push    wMsg

        push    WORD PTR [bx+6]         ; push bx->dwDrvUser.hi
        push    WORD PTR [bx+4]         ; push bx->dwDrvUser.lo

        push    dw1.hi
        push    dw1.lo

        push    dw2.hi
        push    dw2.lo

        push    wod32Message.sel
        push    wod32Message.off

        push    dx
        push    dx                       ; no directory change

        call    FAR PTR MMCALLPROC32     ; call the 32 bit code
waveOMessage_exit:
cEnd


;-----------------------------------------------------------------------;
; @doc INTERNAL  WAVE
;
; @func UINT | waveOIDMessage | This function opens a 32 bit wave device
; on behalf of a 16 bit application.
;
; @parm UINT | wDeviceID | Device ID to send message to.
;
; @parm UINT | wMessage | The message to send.
;
; @parm DWORD | dwUser | The users private DWORD.
;
; @parm DWORD | dwParam1 | Parameter 1.
;
; @parm DWORD | dwParam2 | Parameter 2.
;
; @rdesc The return value is the low word of the returned message.
;-----------------------------------------------------------------------;
cProc waveOIDMessage, <FAR, PUBLIC, PASCAL>, <>
        ParmW   wDeviceID
        ParmW   wMsg
        ParmD   dwUser
        ParmD   dw1
        ParmD   dw2
cBegin
        call    CheckThunkInit
        or      ax,ax
        jnz     waveOIDMessage_exit


        mov     ax,wDeviceID
        cmp     ax,WAVE_MAPPER          ; Is this the wave mapper
        jnz     @f                      ; No so thunk to the 32 bit code.

        cmp     [wodMapper].hi,0        ; No wave mapper loaded
        jz      @f                      ; so jump to 32 bit code

        push    ax                      ; push device id
        push    wMsg                    ; push message

        push    dwUser.hi
        push    dwUser.lo
        push    dw1.hi
        push    dw1.lo
        push    dw2.hi
        push    dw2.lo

        call    DWORD PTR [wodMapper]

        jmp     waveOIDMessage_exit

@@:
        sub     dx,dx
        push    dx
        push    ax

        push    dx
        push    wMsg

        push    dwUser.hi
        push    dwUser.lo

        push    dw1.hi
        push    dw1.lo

        push    dw2.hi
        push    dw2.lo

        push    wod32Message.sel
        push    wod32Message.off

        push    dx
        push    dx                       ; no directory change

        call    FAR PTR MMCALLPROC32     ; call the 32 bit code
waveOIDMessage_exit:
cEnd

;-----------------------------------------------------------------------;
; @doc INTERNAL  WAVE
;
; @func DWORD | waveIMessage | This function sends messages to the waveform
;   output device drivers.
;
; @parm HWAVE | hWave | The handle to the audio device.
;
; @parm UINT | wMsg | The message to send.
;
; @parm DWORD | dwP1 | Parameter 1.
;
; @parm DWORD | dwP2 | Parameter 2.
;
; @rdesc Returns the value returned from the thunk.
;-----------------------------------------------------------------------;
cProc waveIMessage, <NEAR, PUBLIC, PASCAL>, <>
        ParmW   hWave
        ParmW   wMsg
        ParmD   dw1
        ParmD   dw2
cBegin
        call    CheckThunkInit
        or      ax,ax
        jnz     waveIMessage_exit

        mov     bx,hWave                ; bx = hWave
        mov     ax,WORD PTR [bx+8]      ; ax = bx->wDeviceID

        cmp     ax,WAVE_MAPPER          ; Is this the wave mapper
        jnz     @f                      ; No so thunk to the 32 bit code.

        cmp     [widMapper].hi,0        ; No wave mapper loaded
        jz      @f                      ; so jump to 32 bit code

        push    ax                      ; push device id
        push    wMsg                    ; push message

        push    WORD PTR [bx+6]         ; push bx->dwDrvUser.hi
        push    WORD PTR [bx+4]         ; push bx->dwDrvUser.lo

        push    dw1.hi
        push    dw1.lo

        push    dw2.hi
        push    dw2.lo

        call    DWORD PTR [widMapper]

        jmp     waveIMessage_exit

@@:
        sub     dx,dx                   ; dx = 0

        push    dx
        push    ax

        push    dx
        push    wMsg

        push    WORD PTR [bx+6]         ; push bx->dwDrvUser.hi
        push    WORD PTR [bx+4]         ; push bx->dwDrvUser.lo

        push    dw1.hi
        push    dw1.lo

        push    dw2.hi
        push    dw2.lo

        push    wid32Message.sel
        push    wid32Message.off

        push    dx
        push    dx                       ; no directory change

        call    FAR PTR MMCALLPROC32     ; call the 32 bit code
waveIMessage_exit:
cEnd


;-----------------------------------------------------------------------;
; @doc INTERNAL  WAVE
;
; @func UINT | waveIIDMessage | This function opens a 32 bit wave device
; on behalf of a 16 bit application.
;
; @parm UINT | wDeviceID | Device ID to send message to.
;
; @parm UINT | wMessage | The message to send.
;
; @parm DWORD | dwUser | The users private DWORD.
;
; @parm DWORD | dwParam1 | Parameter 1.
;
; @parm DWORD | dwParam2 | Parameter 2.
;
; @rdesc The return value is the low word of the returned message.
;-----------------------------------------------------------------------;
cProc waveIIDMessage, <FAR, PUBLIC, PASCAL>, <>
        ParmW   wDeviceID
        ParmW   wMsg
        ParmD   dwUser
        ParmD   dw1
        ParmD   dw2
cBegin
        call    CheckThunkInit
        or      ax,ax
        jnz     waveIIDMessage_exit

        mov     ax,wDeviceID
        cmp     ax,WAVE_MAPPER          ; Is this the wave mapper
        jnz     @f                      ; No so thunk to the 32 bit code.

        cmp     [widMapper].hi,0        ; No wave mapper loaded
        jz      @f                      ; so jump to 32 bit code

        push    ax                      ; push device id
        push    wMsg                    ; push message

        push    dwUser.hi
        push    dwUser.lo
        push    dw1.hi
        push    dw1.lo
        push    dw2.hi
        push    dw2.lo

        call    DWORD PTR [widMapper]

        jmp     waveIIDMessage_exit

@@:
        sub     dx,dx
        push    dx
        push    ax

        push    dx
        push    wMsg

        push    dwUser.hi
        push    dwUser.lo

        push    dw1.hi
        push    dw1.lo

        push    dw2.hi
        push    dw2.lo

        push    wid32Message.sel
        push    wid32Message.off

        push    dx
        push    dx                       ; no directory change

        call    FAR PTR MMCALLPROC32     ; call the 32 bit code
waveIIDMessage_exit:
cEnd

sEnd


createSeg FIX, CodeFix, word, public, CODE

sBegin  CodeFix
        assumes cs,CodeFix
        assumes ds,nothing
        assumes es,nothing


;-----------------------------------------------------------------------;
; @doc INTERNAL  MIDI
;
; @func DWORD | midiOMessage | This function sends messages to the midiform
;   output device drivers.
;
; @parm HMIDI | hMidi | The handle to the audio device.
;
; @parm UINT | wMsg | The message to send.
;
; @parm DWORD | dwP1 | Parameter 1.
;
; @parm DWORD | dwP2 | Parameter 2.
;
; @rdesc Returns the value returned from the thunk.
;-----------------------------------------------------------------------;
cProc midiOMessage, <FAR, PUBLIC, PASCAL>, <>
        ParmW   hMidi
        ParmW   wMsg
        ParmD   dw1
        ParmD   dw2
cBegin
        call    CheckThunkInit
        or      ax,ax
        jnz     @F

        mov     bx,hMidi                ; bx = hMidi
        mov     ax,WORD PTR [bx+8]      ; ax = bx->wDeviceID
        sub     dx,dx                   ; dx = 0

        push    dx
        push    ax

        push    dx
        push    wMsg

        push    WORD PTR [bx+6]         ; push bx->dwDrvUser.hi
        push    WORD PTR [bx+4]         ; push bx->dwDrvUser.lo

        push    dw1.hi
        push    dw1.lo

        push    dw2.hi
        push    dw2.lo

        push    mod32Message.sel
        push    mod32Message.off

        push    dx
        push    dx                       ; no directory change

        call    FAR PTR MMCALLPROC32     ; call the 32 bit code
@@:
cEnd

;-----------------------------------------------------------------------;
; @doc INTERNAL  MIDI
;
; @func DWORD | midiIMessage | This function sends messages to the midiform
;   output device drivers.
;
; @parm HMIDI | hMidi | The handle to the audio device.
;
; @parm UINT | wMsg | The message to send.
;
; @parm DWORD | dwP1 | Parameter 1.
;
; @parm DWORD | dwP2 | Parameter 2.
;
; @rdesc Returns the value returned from the thunk.
;-----------------------------------------------------------------------;
cProc midiIMessage, <FAR, PUBLIC, PASCAL>, <>
        ParmW   hMidi
        ParmW   wMsg
        ParmD   dw1
        ParmD   dw2
cBegin
        call    CheckThunkInit
        or      ax,ax
        jnz     @F

        mov     bx,hMidi                ; bx = hMidi
        mov     ax,WORD PTR [bx+8]      ; ax = bx->wDeviceID
        sub     dx,dx                   ; dx = 0

        push    dx
        push    ax

        push    dx
        push    wMsg

        push    WORD PTR [bx+6]         ; push bx->dwDrvUser.hi
        push    WORD PTR [bx+4]         ; push bx->dwDrvUser.lo

        push    dw1.hi
        push    dw1.lo

        push    dw2.hi
        push    dw2.lo

        push    mid32Message.sel
        push    mid32Message.off

        push    dx
        push    dx                       ; no directory change

        call    FAR PTR MMCALLPROC32     ; call the 32 bit code
@@:
cEnd
sEnd


createSeg MIDI, MidiSeg, word, public, CODE

sBegin  MidiSeg
        assumes cs,MidiSeg
        assumes ds,nothing
        assumes es,nothing

;-----------------------------------------------------------------------;
; @doc INTERNAL  MIDI
;
; @func UINT | midiOIDMessage | This function opens a 32 bit midi device
; on behalf of a 16 bit application.
;
; @parm UINT | wDeviceID | Device ID to send message to.
;
; @parm UINT | wMessage | The message to send.
;
; @parm DWORD | dwUser | The users private DWORD.
;
; @parm DWORD | dwParam1 | Parameter 1.
;
; @parm DWORD | dwParam2 | Parameter 2.
;
; @rdesc The return value is the low word of the returned message.
;-----------------------------------------------------------------------;
cProc midiOIDMessage, <FAR, PUBLIC, PASCAL>, <>
        ParmW   wDeviceID
        ParmW   wMsg
        ParmD   dwUser
        ParmD   dw1
        ParmD   dw2
cBegin
        call    CheckThunkInit
        sub     dx,dx

        push    dx
        push    wDeviceID

        push    dx
        push    wMsg

        push    dwUser.hi
        push    dwUser.lo

        push    dw1.hi
        push    dw1.lo

        push    dw2.hi
        push    dw2.lo

        push    mod32Message.sel
        push    mod32Message.off

        push    dx
        push    dx                       ; no directory change

        call    FAR PTR MMCALLPROC32     ; call the 32 bit code
cEnd

;-----------------------------------------------------------------------;
; @doc INTERNAL  MIDI
;
; @func UINT | midiIIDMessage | This function opens a 32 bit midi device
; on behalf of a 16 bit application.
;
; @parm UINT | wDeviceID | Device ID to send message to.
;
; @parm UINT | wMessage | The message to send.
;
; @parm DWORD | dwUser | The users private DWORD.
;
; @parm DWORD | dwParam1 | Parameter 1.
;
; @parm DWORD | dwParam2 | Parameter 2.
;
; @rdesc The return value is the low word of the returned message.
;-----------------------------------------------------------------------;
cProc midiIIDMessage, <FAR, PUBLIC, PASCAL>, <>
        ParmW   wDeviceID
        ParmW   wMsg
        ParmD   dwUser
        ParmD   dw1
        ParmD   dw2
cBegin
        call    CheckThunkInit
        or      ax,ax
        jnz     @F

        sub     dx,dx
        push    dx
        push    wDeviceID

        push    dx
        push    wMsg

        push    dwUser.hi
        push    dwUser.lo

        push    dw1.hi
        push    dw1.lo

        push    dw2.hi
        push    dw2.lo

        push    mid32Message.sel
        push    mid32Message.off

        push    dx
        push    dx                       ; no directory change

        call    FAR PTR MMCALLPROC32    ; call the 32 bit code
@@:
cEnd

sEnd


createSeg MCI, MciSeg, word, public, CODE

sBegin MciSeg
        assumes cs,MciSeg
        assumes ds,nothing
        assumes es,nothing

;-----------------------------------------------------------------------;
; mciMessage
;
;
;-----------------------------------------------------------------------;
cProc mciMessage, <FAR, PUBLIC, PASCAL>, <>
        ParmW   wMsg
        ParmD   dw1
        ParmD   dw2
        ParmD   dw3
        ParmD   dw4
cBegin
        call    CheckThunkInit
        or      ax,ax
        jnz     @F

        sub     dx,dx
        push    dx
        push    wMsg

        push    dw1.hi
        push    dw1.lo

        push    dw2.hi
        push    dw2.lo

        push    dw3.hi
        push    dw3.lo

        push    dw4.hi
        push    dw4.lo

        push    mci32Message.sel
        push    mci32Message.off

        push    dx
        push    1                       ; set directory change

        call    FAR PTR MMCALLPROC32    ; call the 32 bit code
@@:
cEnd
sEnd


createSeg RARE, RareSeg, word, public, CODE

sBegin  RareSeg
        assumes cs,RareSeg
        assumes ds,nothing
        assumes es,nothing

;-----------------------------------------------------------------------;
; @doc INTERNAL  AUX
;
; @func UINT | auxOutMessage | This function opens a 32 bit midi device
; on behalf of a 16 bit application.
;
; @parm FARPROC | lpProc | The 32 bit function that will get called.
;
; @parm UINT | wDeviceID | Device ID to send message to.
;
; @parm UINT | wMessage | The message to send.
;
; @parm DWORD | dwParam1 | Parameter 1.
;
; @parm DWORD | dwParam2 | Parameter 2.
;
; @rdesc The return value is the low word of the returned message.
;-----------------------------------------------------------------------;
cProc auxOutMessage, <FAR, PUBLIC, PASCAL, LOADDS>, <>
        ParmW   wDeviceID
        ParmW   wMsg
        ParmD   dw1
        ParmD   dw2
cBegin
        call    CheckThunkInit
        or      ax,ax
        jnz     @F

        sub     dx,dx
        push    dx
        push    wDeviceID

        push    dx
        push    wMsg

        push    dx
        push    dx

        push    dw1.hi
        push    dw1.lo

        push    dw2.hi
        push    dw2.lo

        push    aux32Message.sel
        push    aux32Message.off

        push    dx
        push    dx                       ; no directory change

        call    FAR PTR MMCALLPROC32     ; call the 32 bit code
@@:
cEnd

;*****************************Private*Routine******************************\
; joyMessage
;
;
;
; History:
; 27-09-93 - StephenE - Created
;
;**************************************************************************/
cProc joyMessage, <FAR, PUBLIC, PASCAL>, <>
        ParmW hdrv,
        ParmW wMsg,
        ParmD dw1,
        ParmD dw2
cBegin
        call    CheckThunkInit
        or      ax,ax
        jnz     @F

        sub     dx,dx
        push    dx
        mov     ax,hdrv

        dec     ax                       ; uDevID
        push    ax                       ;

        push    dx                       ; uMsg
        push    wMsg                     ;

        push    dx                       ; dummy dwInstance
        push    dx                       ;

        push    dw1.hi                   ; dwParam1
        push    dw1.lo                   ;

        push    dw2.hi                   ; dwParam2
        push    dw2.lo                   ;

        push    joy32Message.sel         ; Address of function to be called
        push    joy32Message.off         ;

        push    dx
        push    dx                       ; no directory change

        call    FAR PTR MMCALLPROC32     ; call the 32 bit code
@@:
cEnd

;******************************Public*Routine******************************\
; Notify_Callback_Data
;
;
;
; History:
; 27-09-93 - StephenE - Created
;
;**************************************************************************/
cProc Notify_Callback_Data, <FAR, PUBLIC, PASCAL>, <>
        ParmD CallbackData
cBegin
        sub     dx,dx

        push    dx                       ; Dummy uDevId
        push    dx                       ;

        push    dx                       ; Dummy uMsg
        push    dx                       ;

        push    dx                       ; Dummy dwInstance
        push    dx                       ;

        push    dx                       ; Dummy dwParam1
        push    dx                       ;

        push    CallbackData.hi          ; Real dwParam2
        push    CallbackData.lo          ;

        push    cb32.sel                 ; Address of function to be called
        push    cb32.off                 ;

        push    dx
        push    dx                       ; no directory change

        call    FAR PTR MMCALLPROC32     ; call the 32 bit code
cEnd

sEnd

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\mmsystem\usa\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH)
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\mmsystem\wave.c ===
/****************************************************************************
    wave.c

    Level 1 kitchen sink DLL wave support module

    Copyright (c) Microsoft Corporation 1990. All rights reserved

****************************************************************************/

#include <windows.h>
#include "mmsystem.h"
#include "mmddk.h"
#include "mmsysi.h"
#include "thunks.h"

/* -------------------------------------------------------------------------
** Local functions
** -------------------------------------------------------------------------
*/
static UINT NEAR PASCAL
waveGetErrorText(
    UINT wError,
    LPSTR lpText,
    UINT wSize
    );

/* -------------------------------------------------------------------------
** Local structures
** -------------------------------------------------------------------------
*/
typedef struct wavedev_tag {
    PWAVEDRV    wavedrv;
    UINT    wDevice;
    DWORD   dwDrvUser;
    UINT    wDeviceID;
} WAVEDEV, *PWAVEDEV;

/* -------------------------------------------------------------------------
** @doc INTERNAL  WAVE validation code for WAVEHDRs
** -------------------------------------------------------------------------
*/
#define IsWaveHeaderPrepared(hWave, lpwh)      \
    ((lpwh)->dwFlags &  WHDR_PREPARED)

#define MarkWaveHeaderPrepared(hWave, lpwh)    \
    ((lpwh)->dwFlags |= WHDR_PREPARED)

#define MarkWaveHeaderUnprepared(hWave, lpwh)  \
    ((lpwh)->dwFlags &=~WHDR_PREPARED)


/*****************************************************************************
 * @doc INTERNAL  WAVE
 *
 * @api UINT | wavePrepareHeader | This function prepares the header and data
 *   if the driver returns MMSYSERR_NOTSUPPORTED.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it
 *   specifies an error number.
 ****************************************************************************/
static UINT NEAR PASCAL
wavePrepareHeader(
    LPWAVEHDR lpWaveHdr,
    UINT wSize
    )
{
    if (!HugePageLock(lpWaveHdr, (DWORD)sizeof(WAVEHDR))) {
        return MMSYSERR_NOMEM;
    }

    if (!HugePageLock(lpWaveHdr->lpData, lpWaveHdr->dwBufferLength)) {
        HugePageUnlock(lpWaveHdr, (DWORD)sizeof(WAVEHDR));
        return MMSYSERR_NOMEM;
    }

//  lpWaveHdr->dwFlags |= WHDR_PREPARED;

    return MMSYSERR_NOERROR;
}

/*****************************************************************************
 * @doc INTERNAL  WAVE
 *
 * @api UINT | waveUnprepareHeader | This function unprepares the header and
 *   data if the driver returns MMSYSERR_NOTSUPPORTED.
 *
 * @rdesc Currently always returns MMSYSERR_NOERROR.
 ****************************************************************************/
static UINT NEAR PASCAL
waveUnprepareHeader(
    LPWAVEHDR lpWaveHdr,
    UINT wSize
    )
{
    HugePageUnlock(lpWaveHdr->lpData, lpWaveHdr->dwBufferLength);
    HugePageUnlock(lpWaveHdr, (DWORD)sizeof(WAVEHDR));

//  lpWaveHdr->dwFlags &= ~WHDR_PREPARED;

    return MMSYSERR_NOERROR;
}


//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////

/*****************************************************************************
 * @doc EXTERNAL  WAVE
 *
 * @api UINT | waveOutGetNumDevs | This function retrieves the number of
 *   waveform output devices present in the system.
 *
 * @rdesc Returns the number of waveform output devices present in the system.
 *
 * @xref waveOutGetDevCaps
 ****************************************************************************/
UINT WINAPI
waveOutGetNumDevs(
    void
    )
{
    return waveOIDMessage( 0, WODM_GETNUMDEVS, 0L, 0L, 0L );
}

/*****************************************************************************
 * @doc EXTERNAL WAVE
 *
 * @api DWORD | waveOutMessage | This function sends messages to the waveform
 *   output device drivers.
 *
 * @parm HWAVEOUT | hWaveOut | The handle to the audio device.
 *
 * @parm UINT | msg  | The message to send.
 *
 * @parm DWORD | dw1 | Parameter 1.
 *
 * @parm DWORD | dw2 | Parameter 2.
 *
 * @rdesc Returns the value returned from the driver.
 ****************************************************************************/
DWORD WINAPI
waveOutMessage(
    HWAVEOUT hWaveOut,
    UINT msg,
    DWORD dw1,
    DWORD dw2
    )
{
    V_HANDLE(hWaveOut, TYPE_WAVEOUT, 0L);

    return waveOMessage( (HWAVE)hWaveOut, msg, dw1, dw2);
}

/*****************************************************************************
 * @doc EXTERNAL  WAVE
 *
 * @api UINT | waveOutGetDevCaps | This function queries a specified waveform
 *   device to determine its capabilities.
 *
 * @parm UINT | wDeviceID | Identifies the waveform output device.
 *
 * @parm LPWAVEOUTCAPS | lpCaps | Specifies a far pointer to a <t WAVEOUTCAPS>
 *   structure.  This structure is filled with information about the
 *   capabilities of the device.
 *
 * @parm UINT | wSize | Specifies the size of the <t WAVEOUTCAPS> structure.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_BADDEVICEID | Specified device ID is out of range.
 *   @flag MMSYSERR_NODRIVER | The driver was not installed.
 *
 * @comm Use <f waveOutGetNumDevs> to determine the number of waveform output
 *   devices present in the system.  The device ID specified by <p wDeviceID>
 *   varies from zero to one less than the number of devices present.
 *   The WAVE_MAPPER constant may also be used as a device id. Only
 *   <p wSize> bytes (or less) of information is copied to the location
 *   pointed to by <p lpCaps>.  If <p wSize> is zero, nothing is copied, and
 *   the function returns zero.
 *
 * @xref waveOutGetNumDevs
 ****************************************************************************/
UINT WINAPI
waveOutGetDevCaps(
    UINT wDeviceID,
    LPWAVEOUTCAPS lpCaps,
    UINT wSize
    )
{
    if (wSize == 0)
        return MMSYSERR_NOERROR;

    V_WPOINTER(lpCaps, wSize, MMSYSERR_INVALPARAM);

    if (ValidateHandle((HWAVEOUT)wDeviceID, TYPE_WAVEOUT)) {
       return((UINT)waveOMessage((HWAVE)wDeviceID,
                                 WODM_GETDEVCAPS,
                                 (DWORD)lpCaps,
                                 (DWORD)wSize));
    }

    return waveOIDMessage( wDeviceID, WODM_GETDEVCAPS, 0L,
                          (DWORD)lpCaps, (DWORD)wSize);
}

/*****************************************************************************
 * @doc EXTERNAL WAVE
 *
 * @api UINT | waveOutGetVolume | This function queries the current volume
 *   setting of a waveform output device.
 *
 * @parm UINT | wDeviceID | Identifies the waveform output device.
 *
 * @parm LPDWORD | lpdwVolume | Specifies a far pointer to a location to
 *   be filled with the current volume setting.  The low-order word of
 *   this location contains the left channel volume setting, and the high-order
 *   WORD contains the right channel setting. A value of 0xFFFF represents
 *   full volume, and a value of 0x0000 is silence.
 *
 *   If a device does not support both left and right volume
 *   control, the low-order word of the specified location contains
 *   the mono volume level.
 *
 *   The full 16-bit setting(s)
 *   set with <f waveOutSetVolume> is returned, regardless of whether
 *   the device supports the full 16 bits of volume-level control.
 *
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_INVALHANDLE | Specified device handle is invalid.
 *   @flag MMSYSERR_NOTSUPPORTED | Function isn't supported.
 *   @flag MMSYSERR_NODRIVER | The driver was not installed.
 *
 * @comm Not all devices support volume changes. To determine whether the
 *   device supports volume control, use the WAVECAPS_VOLUME
 *   flag to test the <e WAVEOUTCAPS.dwSupport> field of the <t WAVEOUTCAPS>
 *   structure (filled by <f waveOutGetDevCaps>).
 *
 *   To determine whether the device supports volume control on both
 *   the left and right channels, use the WAVECAPS_VOLUME
 *   flag to test the <e WAVEOUTCAPS.dwSupport> field of the <t WAVEOUTCAPS>
 *   structure (filled by <f waveOutGetDevCaps>).
 *
 * @xref waveOutSetVolume
 ****************************************************************************/
UINT WINAPI
waveOutGetVolume(
    UINT wDeviceID,
    LPDWORD lpdwVolume
    )
{
    V_WPOINTER(lpdwVolume, sizeof(DWORD), MMSYSERR_INVALPARAM);

    if (ValidateHandle((HWAVEOUT)wDeviceID, TYPE_WAVEOUT)) {

       return ( (UINT)waveOMessage( (HWAVE)wDeviceID,
                                    WODM_GETVOLUME,
                                    (DWORD)lpdwVolume,
                                    0
                                  ));

    }

    return waveOIDMessage( wDeviceID,
                          WODM_GETVOLUME, 0L, (DWORD)lpdwVolume, 0);
}

/*****************************************************************************
 * @doc EXTERNAL WAVE
 *
 * @api UINT | waveOutSetVolume | This function sets the volume of a
 *   waveform output device.
 *
 * @parm UINT | wDeviceID | Identifies the waveform output device.
 *
 * @parm DWORD | dwVolume | Specifies the new volume setting.  The
 *   low-order word contains the left channel volume setting, and the
 *   high-order word contains the right channel setting. A value of
 *   0xFFFF represents full volume, and a value of 0x0000 is silence.
 *
 *   If a device does
 *   not support both left and right volume control, the low-order word of
 *   <p dwVolume> specifies the volume level, and the high-order word is
 *   ignored.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_INVALHANDLE | Specified device handle is invalid.
 *   @flag MMSYSERR_NOTSUPPORTED | Function isn't supported.
 *   @flag MMSYSERR_NODRIVER | The driver was not installed.
 *
 * @comm Not all devices support volume changes. To determine whether the
 *   device supports volume control, use the WAVECAPS_VOLUME
 *   flag to test the <e WAVEOUTCAPS.dwSupport> field of the <t WAVEOUTCAPS>
 *   structure (filled by <f waveOutGetDevCaps>).
 *
 *   To determine whether the device supports volume control on both the
 *   left and right channels, use the WAVECAPS_LRVOLUME flag
 *   flag to test the <e WAVEOUTCAPS.dwSupport> field of the <t WAVEOUTCAPS>
 *   structure (filled by <f waveOutGetDevCaps>).
 *
 *   Most devices don't support the full 16 bits of volume level control
 *   and will not use the high-order bits of the requested volume setting.
 *   For example, for a device that supports 4 bits of volume control,
 *   requested volume level values of 0x4000, 0x4fff, and 0x43be
 *   all produce the same physical volume setting, 0x4000. The
 *   <f waveOutGetVolume> function returns the full 16-bit setting set
 *   with <f waveOutSetVolume>.
 *
 *   Volume settings are interpreted logarithmically. This means the
 *   perceived increase in volume is the same when increasing the
 *   volume level from 0x5000 to 0x6000 as it is from 0x4000 to 0x5000.
 *
 * @xref waveOutGetVolume
 ****************************************************************************/
UINT WINAPI
waveOutSetVolume(
    UINT wDeviceID,
    DWORD dwVolume
    )
{

   if (ValidateHandle((HWAVEOUT)wDeviceID, TYPE_WAVEOUT)) {
      return((UINT)waveOMessage((HWAVE)wDeviceID, WODM_SETVOLUME, dwVolume, 0));
   }

   return waveOIDMessage( wDeviceID, WODM_SETVOLUME, 0L, dwVolume, 0);
}

/*****************************************************************************
 * @doc INTERNAL WAVE
 *
 * @func UINT | waveGetErrorText | This function retrieves a textual
 *   description of the error identified by the specified error number.
 *
 * @parm UINT | wError | Specifies the error number.
 *
 * @parm LPSTR | lpText | Specifies a far pointer to a buffer which
 *   is filled with the textual error description.
 *
 * @parm UINT | wSize | Specifies the length of the buffer pointed to by
 *   <p lpText>.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_BADERRNUM | Specified error number is out of range.
 *
 * @comm If the textual error description is longer than the specified buffer,
 *   the description is truncated.  The returned error string is always
 *   null-terminated. If <p wSize> is zero, nothing is copied and MMSYSERR_NOERROR
 *   is returned.
 ****************************************************************************/
static UINT NEAR PASCAL
waveGetErrorText(
    UINT wError,
    LPSTR lpText,
    UINT wSize
    )
{
    lpText[0] = 0;

#if MMSYSERR_BASE
    if ( ((wError < MMSYSERR_BASE) || (wError > MMSYSERR_LASTERROR))
      && ((wError < WAVERR_BASE) || (wError > WAVERR_LASTERROR))) {

        return MMSYSERR_BADERRNUM;
    }
#else
    if ( (wError > MMSYSERR_LASTERROR)
     && ((wError < WAVERR_BASE) || (wError > WAVERR_LASTERROR))) {

        return MMSYSERR_BADERRNUM;
    }
#endif

    if (wSize > 1) {
        if (!LoadString(ghInst, wError, lpText, wSize)) {
            return MMSYSERR_BADERRNUM;
        }
    }

    return MMSYSERR_NOERROR;
}

/*****************************************************************************
 * @doc EXTERNAL  WAVE
 *
 * @api UINT | waveOutGetErrorText | This function retrieves a
 *   textual description of the error identified by the specified
 *   error number.
 *
 * @parm UINT | wError | Specifies the error number.
 *
 * @parm LPSTR | lpText | Specifies a far pointer to a buffer to be
 *   filled with the textual error description.
 *
 * @parm UINT | wSize | Specifies the length of the buffer pointed
 *   to by <p lpText>.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_BADERRNUM | Specified error number is out of range.
 *
 * @comm If the textual error description is longer than the specified buffer,
 *   the description is truncated.  The returned error string is always
 *   null-terminated. If <p wSize> is zero, nothing is copied, and the function
 *   returns zero. All error descriptions are less than MAXERRORLENGTH characters long.
 ****************************************************************************/
UINT WINAPI
waveOutGetErrorText(
    UINT wError,
    LPSTR lpText,
    UINT wSize
    )
{
    if (wSize == 0) {
        return MMSYSERR_NOERROR;
    }

    V_WPOINTER(lpText, wSize, MMSYSERR_INVALPARAM);

    return waveGetErrorText(wError, lpText, wSize);
}

/*****************************************************************************
 * @doc EXTERNAL  WAVE
 *
 * @api UINT | waveOutOpen | This function opens a specified waveform output
 *   device for playback.
 *
 * @parm LPHWAVEOUT | lphWaveOut | Specifies a far pointer to an HWAVEOUT
 *   handle.  This location is filled with a handle identifying the opened
 *   waveform output device.  Use the handle to identify the device when
 *   calling other waveform output functions.  This parameter may be
 *   NULL if the WAVE_FORMAT_QUERY flag is specified for <p dwFlags>.
 *
 * @parm UINT | wDeviceID | Identifies the waveform output device to open.
 *  Use a valid device ID or the following flag:
 *
 *   @flag WAVE_MAPPER | If this flag is specified, the function
 *     selects a waveform output device
 *     capable of playing the given format.
 *
 * @parm LPWAVEFORMAT | lpFormat | Specifies a pointer to a <t WAVEFORMAT>
 *   structure that identifies the format of the waveform data
 *   to be sent to the waveform output device.
 *
 * @parm DWORD | dwCallback | Specifies the address of a callback
 *   function or a handle to a window called during waveform
 *   playback to process messages related to the progress of the playback.
 *   Specify NULL for this parameter if no callback is desired.
 *
 * @parm DWORD | dwCallbackInstance | Specifies user instance data
 *   passed to the callback.  This parameter is not used with
 *   window callbacks.
 *
 * @parm DWORD | dwFlags | Specifies flags for opening the device.
 *   @flag WAVE_FORMAT_QUERY | If this flag is specified, the device is
 *   queried to determine if it supports the given format but is not
 *      actually opened.
 *   @flag WAVE_ALLOWSYNC | If this flag is not specified, then the
 *   device will fail to open if it is a synchronous device.
 *   @flag CALLBACK_WINDOW | If this flag is specified, <p dwCallback> is
 *      assumed to be a window handle.
 *   @flag CALLBACK_FUNCTION | If this flag is specified, <p dwCallback> is
 *      assumed to be a callback procedure address.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_BADDEVICEID | Specified device ID is out of range.
 *   @flag MMSYSERR_ALLOCATED | Specified resource is already allocated.
 *   @flag MMSYSERR_NOMEM | Unable to allocate or lock memory.
 *   @flag WAVERR_BADFORMAT | Attempted to open with an unsupported wave format.
 *
 * @comm Use <f waveOutGetNumDevs> to determine the number of waveform output
 *   devices present in the system.  The device ID specified by <p wDeviceID>
 *   varies from zero to one less than the number of devices present.
 *   The WAVE_MAPPER constant may also be used as a device id.
 *
 *   The <t WAVEFORMAT> structure pointed to by <p lpFormat> may be extended
 *   to include type-specific information for certain data formats.
 *   For example, for PCM data, an extra UINT is added to specify the number
 *   of bits per sample.  Use the <t PCMWAVEFORMAT> structure in this case.
 *
 *   If a window is chosen to receive callback information, the following
 *   messages are sent to the window procedure function to indicate the
 *   progress of waveform output:  <m MM_WOM_OPEN>, <m MM_WOM_CLOSE>,
 *   <m MM_WOM_DONE>
 *
 *   If a function is chosen to receive callback information, the following
 *   messages are sent to the function to indicate the progress of waveform
 *   output: <m WOM_OPEN>, <m WOM_CLOSE>, <m WOM_DONE>.  The callback function
 *   must reside in a DLL.  You do not have to use <f MakeProcInstance> to get
 *   a procedure-instance address for the callback function.
 *
 * @cb void CALLBACK | WaveOutFunc | <f WaveOutFunc> is a placeholder for the
 *   application-supplied function name.  The actual name must be exported by
 *   including it in an EXPORTS statement in the DLL's module-definition file.
 *
 * @parm HWAVEOUT | hWaveOut | Specifies a handle to the waveform device
 *   associated with the callback.
 *
 * @parm UINT | wMsg | Specifies a waveform output message.
 *
 * @parm DWORD | dwInstance | Specifies the user instance data
 *   specified with <f waveOutOpen>.
 *
 * @parm DWORD | dwParam1 | Specifies a parameter for the message.
 *
 * @parm DWORD | dwParam2 | Specifies a parameter for the message.
 *
 * @comm Because the callback is accessed at interrupt time, it must reside
 *   in a DLL and its code segment must be specified as FIXED in the
 *   module-definition file for the DLL.  Any data that the callback accesses
 *   must be in a FIXED data segment as well. The callback may not make any
 *   system calls except for <f PostMessage>, <f timeGetSystemTime>,
 *   <f timeGetTime>, <f timeSetEvent>, <f timeKillEvent>,
 *   <f midiOutShortMsg>, <f midiOutLongMsg>, and <f OutputDebugStr>.
 *
 * @xref waveOutClose
 ****************************************************************************/
UINT WINAPI
waveOutOpen(
    LPHWAVEOUT lphWaveOut,
    UINT wDeviceID,
    const WAVEFORMAT FAR* lpFormat,
    DWORD dwCallback,
    DWORD dwInstance,
    DWORD dwFlags
    )
{
    WAVEOPENDESC wo;
    PWAVEDEV     pdev;
    UINT         wRet;
    DWORD        dwDrvUser;

    V_RPOINTER(lpFormat, sizeof(WAVEFORMAT), MMSYSERR_INVALPARAM);
    V_DCALLBACK(dwCallback, HIWORD(dwFlags), MMSYSERR_INVALPARAM);
    V_FLAGS(LOWORD(dwFlags), WAVE_VALID, waveOutOpen, MMSYSERR_INVALFLAG);

    if (!(dwFlags & WAVE_FORMAT_QUERY)) {
        V_WPOINTER(lphWaveOut, sizeof(HWAVEOUT), MMSYSERR_INVALPARAM);
        *lphWaveOut = NULL;
    }


    /*
    ** Check for no devices
    */
//  if (wTotalWaveOutDevs == 0 ) {
//      return MMSYSERR_BADDEVICEID;
//  }
//
//  /*
//  ** check for device ID being to large
//  */
//  if ( wDeviceID != WAVE_MAPPER ) {
//      if ( wDeviceID >= wTotalWaveOutDevs ) {
//          return MMSYSERR_BADDEVICEID;
//      }
//  }

    if (dwFlags & WAVE_FORMAT_QUERY) {
        pdev = NULL;
    }
    else {

        if (!(pdev = (PWAVEDEV)NewHandle(TYPE_WAVEOUT, sizeof(WAVEDEV)))) {
            return MMSYSERR_NOMEM;
        }

        pdev->wDevice = wDeviceID;
        pdev->wDeviceID = wDeviceID;

    }

    wo.hWave      = (HWAVE)pdev;
    wo.dwCallback = dwCallback;
    wo.dwInstance = dwInstance;
    wo.lpFormat   = lpFormat;

    if ( (wDeviceID == WAVE_MAPPER) && (wodMapper != NULL) ) {

        wRet = (UINT)((*(wodMapper))(0, WODM_OPEN,
                                     (DWORD)(LPDWORD)&dwDrvUser,
                                     (DWORD)(LPWAVEOPENDESC)&wo,
                                     dwFlags));
    }
    else {

        wRet = waveOIDMessage( wDeviceID, WODM_OPEN, (DWORD)(LPDWORD)&dwDrvUser,
                               (DWORD)(LPWAVEOPENDESC)&wo, dwFlags );
    }

    if (pdev) {
        if (wRet) {
            FreeHandle((HWAVEOUT)pdev);
        }
        else {
            *lphWaveOut = (HWAVEOUT)pdev;
            pdev->dwDrvUser = dwDrvUser;
        }
    }

    return wRet;
}

/*****************************************************************************
 * @doc EXTERNAL  WAVE
 *
 * @api UINT | waveOutClose | This function closes the specified waveform
 *   output device.
 *
 * @parm HWAVEOUT | hWaveOut | Specifies a handle to the waveform output
 *   device. If the function is successful, the handle is no
 *   longer valid after this call.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_INVALHANDLE | Specified device handle is invalid.
 *   @flag WAVERR_STILLPLAYING | There are still buffers in the queue.
 *
 * @comm If the device is still playing a waveform, the close
 *   operation will fail.  Use <f waveOutReset> to terminate waveform
 *   playback before calling <f waveOutClose>.
 *
 * @xref waveOutOpen waveOutReset
 ****************************************************************************/
UINT WINAPI waveOutClose(HWAVEOUT hWaveOut)
{
    UINT         wRet;

    V_HANDLE(hWaveOut, TYPE_WAVEOUT, MMSYSERR_INVALHANDLE);

    wRet = (UINT)waveOMessage( (HWAVE)hWaveOut, WODM_CLOSE, 0L,0L);

    if (!wRet) {
        FreeHandle(hWaveOut);
    }
    return wRet;
}

/*****************************************************************************
 * @doc EXTERNAL  WAVE
 *
 * @api UINT | waveOutPrepareHeader | This function prepares a
 *   waveform data block for playback.
 *
 * @parm HWAVEOUT | hWaveOut | Specifies a handle to the waveform output
 *   device.
 *
 * @parm LPWAVEHDR | lpWaveOutHdr | Specifies a pointer to a
 *   <t WAVEHDR> structure that identifies the data block to be prepared.
 *
 * @parm UINT | wSize | Specifies the size of the <t WAVEHDR> structure.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_INVALHANDLE | Specified device handle is invalid.
 *   @flag MMSYSERR_NOMEM | Unable to allocate or lock memory.
 *
 * @comm The <t WAVEHDR> data structure and the data block pointed to by its
 *   <e WAVEHDR.lpData> field must be allocated with <f GlobalAlloc> using the
 *   GMEM_MOVEABLE and GMEM_SHARE flags, and locked with <f GlobalLock>.
 *   Preparing a header that has already been prepared has no effect, and
 *   the function returns zero.
 *
 * @xref waveOutUnprepareHeader
 ****************************************************************************/
UINT WINAPI
waveOutPrepareHeader(
    HWAVEOUT hWaveOut,
    LPWAVEHDR lpWaveOutHdr,
    UINT wSize
    )
{
    UINT         wRet;

    V_HANDLE(hWaveOut, TYPE_WAVEOUT, MMSYSERR_INVALHANDLE);
    V_HEADER(lpWaveOutHdr, wSize, TYPE_WAVEOUT, MMSYSERR_INVALPARAM);

    if (IsWaveHeaderPrepared(hWaveOut, lpWaveOutHdr)) {
        DebugErr(DBF_WARNING,"waveOutPrepareHeader: header is already prepared.");
        return MMSYSERR_NOERROR;
    }

    lpWaveOutHdr->dwFlags &= (WHDR_BEGINLOOP | WHDR_ENDLOOP);

    wRet = wavePrepareHeader(lpWaveOutHdr, wSize);

    if (wRet == MMSYSERR_NOERROR) {
        wRet = (UINT)waveOMessage( (HWAVE)hWaveOut, WODM_PREPARE,
                                   (DWORD)lpWaveOutHdr, (DWORD)wSize);
    }

    return wRet;
}

/*****************************************************************************
 * @doc EXTERNAL  WAVE
 *
 * @api UINT | waveOutUnprepareHeader | This function cleans up the
 *   preparation performed by <f waveOutPrepareHeader>. The function
 *   must be called after
 *   the device driver is finished with a data block. You must call this
 *   function before freeing the data buffer.
 *
 * @parm HWAVEOUT | hWaveOut | Specifies a handle to the waveform output
 *   device.
 *
 * @parm LPWAVEHDR | lpWaveOutHdr |  Specifies a pointer to a <t WAVEHDR>
 *   structure identifying the data block to be cleaned up.
 *
 * @parm UINT | wSize | Specifies the size of the <t WAVEHDR> structure.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_INVALHANDLE | Specified device handle is invalid.
 *   @flag WAVERR_STILLPLAYING | <p lpWaveOutHdr> is still in the queue.
 *
 * @comm This function is the complementary function to
 * <f waveOutPrepareHeader>. You must call this function before freeing the
 *  data buffer with <f GlobalFree>.
 *   After passing a buffer to the device driver with <f waveOutWrite>, you
 *   must wait until the driver is finished with the buffer before calling
 *   <f waveOutUnprepareHeader>.
 *
 *  Unpreparing a buffer that has not been
 *  prepared has no effect, and the function returns zero.
 *
 * @xref waveOutPrepareHeader
 ****************************************************************************/
UINT WINAPI
waveOutUnprepareHeader(
    HWAVEOUT hWaveOut,
    LPWAVEHDR lpWaveOutHdr,
    UINT wSize
    )
{
    UINT         wRet;

    V_HANDLE(hWaveOut, TYPE_WAVEOUT, MMSYSERR_INVALHANDLE);
    V_HEADER(lpWaveOutHdr, wSize, TYPE_WAVEOUT, MMSYSERR_INVALPARAM);

    if(lpWaveOutHdr->dwFlags & WHDR_INQUEUE) {
        DebugErr(DBF_WARNING,"waveOutUnprepareHeader: header still in queue.");
        return WAVERR_STILLPLAYING;
    }

    if (!IsWaveHeaderPrepared(hWaveOut, lpWaveOutHdr)) {
        DebugErr(DBF_WARNING,"waveOutUnprepareHeader: header is not prepared.");
        return MMSYSERR_NOERROR;
    }

    wRet = waveUnprepareHeader(lpWaveOutHdr, wSize);

    if (wRet == MMSYSERR_NOERROR) {
        wRet = (UINT)waveOMessage( (HWAVE)hWaveOut, WODM_UNPREPARE,
                                   (DWORD)lpWaveOutHdr, (DWORD)wSize);
    }

    return wRet;
}

/*****************************************************************************
 * @doc EXTERNAL  WAVE
 *
 * @api UINT | waveOutWrite | This function sends a data block to the
 *   specified waveform output device.
 *
 * @parm HWAVEOUT | hWaveOut | Specifies a handle to the waveform output
 *  device.
 *
 * @parm LPWAVEHDR | lpWaveOutHdr | Specifies a far pointer to a <t WAVEHDR>
 *   structure containing information about the data block.
 *
 * @parm UINT | wSize | Specifies the size of the <t WAVEHDR> structure.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_INVALHANDLE | Specified device handle is invalid.
 *   @flag WAVERR_UNPREPARED | <p lpWaveOutHdr> hasn't been prepared.
 *
 * @comm The data buffer must be prepared with <f waveOutPrepareHeader> before
 *   it is passed to <f waveOutWrite>.  The <t WAVEHDR> data structure
 *   and the data buffer pointed to by its <e WAVEHDR.lpData> field must be allocated
 *   with <f GlobalAlloc> using the GMEM_MOVEABLE and GMEM_SHARE flags, and
 *   locked with <f GlobalLock>.  Unless the device is paused by calling
 *   <f waveOutPause>, playback begins when the first data block is sent to
 *   the device.
 *
 * @xref waveOutPrepareHeader waveOutPause waveOutReset waveOutRestart
 ****************************************************************************/
UINT WINAPI
waveOutWrite(
    HWAVEOUT hWaveOut,
    LPWAVEHDR lpWaveOutHdr,
    UINT wSize
    )
{
    V_HANDLE(hWaveOut, TYPE_WAVEOUT, MMSYSERR_INVALHANDLE);
    V_HEADER(lpWaveOutHdr, wSize, TYPE_WAVEOUT, MMSYSERR_INVALPARAM);

    if (!IsWaveHeaderPrepared(hWaveOut, lpWaveOutHdr)) {
        DebugErr(DBF_WARNING,"waveOutWrite: header not prepared");
        return WAVERR_UNPREPARED;
    }

    if (lpWaveOutHdr->dwFlags & WHDR_INQUEUE) {
        DebugErr(DBF_WARNING,"waveOutWrite: header is still in queue");
        return WAVERR_STILLPLAYING;
    }

    lpWaveOutHdr->dwFlags &= ~WHDR_DONE;

    return (UINT)waveOMessage( (HWAVE)hWaveOut, WODM_WRITE,
                               (DWORD)lpWaveOutHdr, (DWORD)wSize );
}

/*****************************************************************************
 * @doc EXTERNAL  WAVE
 *
 * @api UINT | waveOutPause | This function pauses playback on a specified
 *   waveform output device.  The current playback position is saved.  Use
 *   <f waveOutRestart> to resume playback from the current playback position.
 *
 * @parm HWAVEOUT | hWaveOut | Specifies a handle to the waveform output
 *   device.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_INVALHANDLE | Specified device handle is invalid.
 *
 * @comm Calling this function when the output is already paused has no
 *   effect, and the function returns zero.
 *
 * @xref waveOutRestart waveOutBreakLoop
 ****************************************************************************/
UINT WINAPI
waveOutPause(
    HWAVEOUT hWaveOut
    )
{
    V_HANDLE(hWaveOut, TYPE_WAVEOUT, MMSYSERR_INVALHANDLE);

    return (UINT)waveOMessage( (HWAVE)hWaveOut, WODM_PAUSE, 0L, 0L);
}

/*****************************************************************************
 * @doc EXTERNAL  WAVE
 *
 * @api UINT | waveOutRestart | This function restarts a paused waveform
 *   output device.
 *
 * @parm HWAVEOUT | hWaveOut | Specifies a handle to the waveform output
 *   device.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_INVALHANDLE | Specified device handle is invalid.
 *
 * @comm Calling this function when the output is not paused has no
 *   effect, and the function returns zero.
 *
 * @xref waveOutPause waveOutBreakLoop
 ****************************************************************************/
UINT WINAPI
waveOutRestart(
    HWAVEOUT hWaveOut
    )
{
    V_HANDLE(hWaveOut, TYPE_WAVEOUT, MMSYSERR_INVALHANDLE);

    return (UINT)waveOMessage( (HWAVE)hWaveOut, WODM_RESTART, 0L, 0L);
}

/*****************************************************************************
 * @doc EXTERNAL  WAVE
 *
 * @api UINT | waveOutReset | This function stops playback on a given waveform
 *   output device and resets the current position to 0.  All pending
 *   playback buffers are marked as done and returned to the application.
 *
 * @parm HWAVEOUT | hWaveOut | Specifies a handle to the waveform output
 *   device.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_INVALHANDLE | Specified device handle is invalid.
 *
 * @xref waveOutWrite waveOutClose
/****************************************************************************/
UINT WINAPI
waveOutReset(
    HWAVEOUT hWaveOut
    )
{
    V_HANDLE(hWaveOut, TYPE_WAVEOUT, MMSYSERR_INVALHANDLE);

    return (UINT)waveOMessage( (HWAVE)hWaveOut, WODM_RESET, 0L, 0L);
}

/*****************************************************************************
 * @doc EXTERNAL  WAVE
 *
 * @api UINT | waveOutBreakLoop | This function breaks a loop on a
 *   given waveform output device and allows playback to continue with the
 *   next block in the driver list.
 *
 * @parm HWAVEOUT | hWaveOut | Specifies a handle to the waveform output
 *   device.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_INVALHANDLE | Specified device handle is invalid.
 *
 * @comm Waveform looping is controlled by the <e WAVEHDR.dwLoops> and
 *   <e WAVEHDR.dwFlags> fields in the <t WAVEHDR> structures passed to the device
 *   with <f waveOutWrite>. Use the WHDR_BEGINLOOP and WHDR_ENDLOOP flags
 *   in the <e WAVEHDR.dwFlags> field to specify the beginning and ending data
 *   blocks for looping.
 *
 *   To loop on a single block, specify both flags for the same block.
 *   To specify the number of loops, use the <e WAVEHDR.dwLoops> field in
 *   the <t WAVEHDR> structure for the first block in the loop.
 *
 *   The blocks making up the loop are played to the end before the loop
 *   is terminated.
 *
 *   Calling this function when the nothing is playing or looping has no
 *   effect, and the function returns zero.
 *
 * @xref waveOutWrite waveOutPause waveOutRestart
/****************************************************************************/
UINT WINAPI
waveOutBreakLoop(
    HWAVEOUT hWaveOut
    )
{
    V_HANDLE(hWaveOut, TYPE_WAVEOUT, MMSYSERR_INVALHANDLE);

    return (UINT)waveOMessage( (HWAVE)hWaveOut, WODM_BREAKLOOP, 0L, 0L );
}

/*****************************************************************************
 * @doc EXTERNAL  WAVE
 *
 * @api UINT | waveOutGetPosition | This function retrieves the current
 *   playback position of the specified waveform output device.
 *
 * @parm HWAVEOUT | hWaveOut | Specifies a handle to the waveform output
 *   device.
 *
 * @parm LPMMTIME | lpInfo | Specifies a far pointer to an <t MMTIME>
 *   structure.
 *
 * @parm UINT | wSize | Specifies the size of the <t MMTIME> structure.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_INVALHANDLE | Specified device handle is invalid.
 *
 * @comm Before calling <f waveOutGetPosition>, set the <e MMTIME.wType> field of the
 *   MMTIME structure to indicate the time format that you desire.  After
 *   calling <f waveOutGetPosition>, check the <e MMTIME.wType> field
 *   to determine if the desired time format is supported.  If the desired
 *   format is not supported, <e MMTIME.wType> will specify an alternative format.
 *
 *  The position is set to zero when the device is opened or reset.
 ****************************************************************************/
UINT WINAPI
waveOutGetPosition(
    HWAVEOUT hWaveOut,
    LPMMTIME lpInfo,
    UINT wSize
    )
{
    V_HANDLE(hWaveOut, TYPE_WAVEOUT, MMSYSERR_INVALHANDLE);
    V_WPOINTER(lpInfo, wSize, MMSYSERR_INVALPARAM);

    return (UINT)waveOMessage( (HWAVE)hWaveOut, WODM_GETPOS,
                              (DWORD)lpInfo, (DWORD)wSize );
}

/*****************************************************************************
 * @doc EXTERNAL WAVE
 *
 * @api UINT | waveOutGetPitch | This function queries the the current pitch
 *   setting of a waveform output device.
 *
 * @parm HWAVEOUT | hWaveOut | Specifies a handle to the waveform output
 *   device.
 *
 * @parm LPDWORD | lpdwPitch | Specifies a far pointer to a location
 *   to be filled with the current pitch multiplier setting. The pitch
 *   multiplier indicates the current change in pitch from the original
 *   authored setting. The pitch multiplier must be a positive value.
 *
 * The pitch multiplier is specified as a fixed-point value. The high-order word
 * of the DWORD location contains the signed integer part of the number,
 * and the low-order word contains the fractional part. The fraction is
 * expressed as a WORD in which a value of 0x8000 represents one half,
 * and 0x4000 represents one quarter. For example, the value 0x00010000
 * specifies a multiplier of 1.0 (no pitch change), and a value of
 * 0x000F8000 specifies a multiplier of 15.5.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_INVALHANDLE | Specified device handle is invalid.
 *   @flag MMSYSERR_NOTSUPPORTED | Function isn't supported.
 *
 * @comm Changing the pitch does not change the playback rate, sample
 *   rate, or playback time.  Not all devices support
 *   pitch changes. To determine whether the device supports pitch control,
 *   use the WAVECAPS_PITCH flag to test the <e WAVEOUTCAPS.dwSupport>
 *   field of the <t WAVEOUTCAPS> structure (filled by <f waveOutGetDevCaps>).
 *
 * @xref waveOutSetPitch waveOutGetPlaybackRate waveOutSetPlaybackRate
 ****************************************************************************/
UINT WINAPI
waveOutGetPitch(
    HWAVEOUT hWaveOut,
    LPDWORD lpdwPitch
    )
{
    V_HANDLE(hWaveOut, TYPE_WAVEOUT, MMSYSERR_INVALHANDLE);
    V_WPOINTER(lpdwPitch, sizeof(DWORD), MMSYSERR_INVALPARAM);

    return (UINT)waveOMessage( (HWAVE)hWaveOut, WODM_GETPITCH,
                               (DWORD)lpdwPitch, 0L);
}

/*****************************************************************************
 * @doc EXTERNAL WAVE
 *
 * @api UINT | waveOutSetPitch | This function sets the pitch of a waveform
 *   output device.
 *
 * @parm HWAVEOUT | hWaveOut | Specifies a handle to the waveform
 *   output device.
 *
 * @parm DWORD | dwPitch | Specifies the new pitch multiplier setting.
 *  The pitch multiplier setting indicates the current change in pitch
 *  from the original authored setting. The pitch multiplier must be a
 *  positive value.
 *
 * The pitch multiplier is specified as a fixed-point value. The high-order word
 * location contains the signed integer part of the number,
 * and the low-order word contains the fractional part. The fraction is
 * expressed as a WORD in which a value of 0x8000 represents one half,
 * and 0x4000 represents one quarter.
 * For example, the value 0x00010000 specifies a multiplier
 * of 1.0 (no pitch change), and a value of 0x000F8000 specifies a
 * multiplier of 15.5.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_INVALHANDLE | Specified device handle is invalid.
 *   @flag MMSYSERR_NOTSUPPORTED | Function isn't supported.
 *
 * @comm Changing the pitch does not change the playback rate or the sample
 *   rate.  The playback time is also unchanged. Not all devices support
 *   pitch changes. To determine whether the device supports pitch control,
 *   use the WAVECAPS_PITCH flag to test the <e WAVEOUTCAPS.dwSupport>
 *   field of the <t WAVEOUTCAPS> structure (filled by <f waveOutGetDevCaps>).
 *
 * @xref waveOutGetPitch waveOutSetPlaybackRate waveOutGetPlaybackRate
 ****************************************************************************/
UINT WINAPI
waveOutSetPitch(
    HWAVEOUT hWaveOut,
    DWORD dwPitch
    )
{
    V_HANDLE(hWaveOut, TYPE_WAVEOUT, MMSYSERR_INVALHANDLE);

    return (UINT)waveOMessage( (HWAVE)hWaveOut, WODM_SETPITCH, dwPitch, 0L );
}

/*****************************************************************************
 * @doc EXTERNAL WAVE
 *
 * @api UINT | waveOutGetPlaybackRate | This function queries the
 *   current playback rate setting of a waveform output device.
 *
 * @parm HWAVEOUT | hWaveOut | Specifies a handle to the waveform output
 *   device.
 *
 * @parm LPDWORD | lpdwRate | Specifies a far pointer to a location
 *   to be filled with the current playback rate. The playback rate setting
 *  is a multiplier indicating the current change in playback rate from
 *  the original authored setting. The playback rate multiplier must be
 *  a positive value.
 *
 * The rate is specified as a fixed-point value. The high-order word
 * of the DWORD location contains the signed integer part of the number,
 * and the low-order word contains the fractional part. The fraction is
 * expressed as a WORD in which a value of 0x8000 represents one half,
 * and 0x4000 represents one quarter. For example, the value 0x00010000
 * specifies a multiplier of 1.0 (no playback rate change), and a value
 * of 0x000F8000 specifies a multiplier of 15.5.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_INVALHANDLE | Specified device handle is invalid.
 *   @flag MMSYSERR_NOTSUPPORTED | Function isn't supported.
 *
 * @comm Changing the playback rate does not change the sample rate but does
 *   change the playback time.
 *
 *   Not all devices support playback rate changes. To determine whether a
 *   device supports playback rate changes, use
 *   the WAVECAPS_PLAYBACKRATE flag to test the <e WAVEOUTCAPS.dwSupport> field of the
 *   <t WAVEOUTCAPS> structure (filled by <f waveOutGetDevCaps>).
 *
 * @xref waveOutSetPlaybackRate waveOutSetPitch waveOutGetPitch
 ****************************************************************************/
UINT WINAPI
waveOutGetPlaybackRate(
    HWAVEOUT hWaveOut,
    LPDWORD lpdwRate
    )
{
    V_HANDLE(hWaveOut, TYPE_WAVEOUT, MMSYSERR_INVALHANDLE);
    V_WPOINTER(lpdwRate, sizeof(DWORD), MMSYSERR_INVALPARAM);

    return (UINT)waveOMessage( (HWAVE)hWaveOut,
                               WODM_GETPLAYBACKRATE, (DWORD)lpdwRate, 0L );
}

/*****************************************************************************
 * @doc EXTERNAL WAVE
 *
 * @api UINT | waveOutSetPlaybackRate | This function sets the
 *   playback rate of a waveform output device.
 *
 * @parm HWAVEOUT | hWaveOut | Specifies a handle to the waveform
 *   output device.
 *
 * @parm DWORD | dwRate | Specifies the new playback rate setting.
 *  The playback rate setting is a multiplier indicating the current
 *  change in playback rate from the original authored setting. The playback
 *  rate multiplier must be a positive value.
 *
 * The rate is specified as a fixed-point value. The high-order word
 * contains the signed integer part of the number,
 * and the low-order word contains the fractional part. The fraction is
 * expressed as a WORD in which a value of 0x8000 represents one half,
 * and 0x4000 represents one quarter.
 * For example, the value 0x00010000 specifies a multiplier of 1.0 (no
 * playback rate change), and a value of 0x000F8000 specifies a
 * multiplier of 15.5.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_INVALHANDLE | Specified device handle is invalid.
 *   @flag MMSYSERR_NOTSUPPORTED | Function isn't supported.
 *
 * @comm Changing the playback rate does not change the sample rate but does
 *   change the playback time.
 *
 * Not all devices support playback rate changes. To determine whether a
 *   device supports playback rate changes,
 *   use the WAVECAPS_PLAYBACKRATE flag to test the <e WAVEOUTCAPS.dwSupport> field of the
 *   <t WAVEOUTCAPS> structure (filled by <f waveOutGetDevCaps>).
 *
 * @xref waveOutGetPlaybackRate waveOutSetPitch waveOutGetPitch
 ****************************************************************************/
UINT WINAPI
waveOutSetPlaybackRate(
    HWAVEOUT hWaveOut,
    DWORD dwRate
    )
{
    V_HANDLE(hWaveOut, TYPE_WAVEOUT, MMSYSERR_INVALHANDLE);

    return (UINT)waveOMessage( (HWAVE)hWaveOut, WODM_SETPLAYBACKRATE, dwRate, 0L );
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

/*****************************************************************************
 * @doc EXTERNAL  WAVE
 *
 * @api UINT | waveInGetNumDevs | This function returns the number of waveform
 *   input devices.
 *
 * @rdesc Returns the number of waveform input devices present in the system.
 *
 * @xref waveInGetDevCaps
 ****************************************************************************/
UINT WINAPI
waveInGetNumDevs(
    void
    )
{
   return waveIIDMessage( 0, WIDM_GETNUMDEVS, 0L, 0L, 0L );
}

/*****************************************************************************
 * @doc EXTERNAL WAVE
 *
 * @api DWORD | waveInMessage | This function sends messages to the waveform
 *   output device drivers.
 *
 * @parm HWAVEIN | hWave | The handle to the audio device.
 *
 * @parm UINT | wMsg | The message to send.
 *
 * @parm DWORD | dw1 | Parameter 1.
 *
 * @parm DWORD | dw2 | Parameter 2.
 *
 * @rdesc Returns the value returned from the driver.
 ****************************************************************************/
DWORD WINAPI
waveInMessage(
    HWAVEIN hWaveIn,
    UINT msg,
    DWORD dw1,
    DWORD dw2
    )
{
    V_HANDLE(hWaveIn, TYPE_WAVEIN, 0L);

    return waveIMessage((HWAVE)hWaveIn, msg, dw1, dw2);
}

/*****************************************************************************
 * @doc EXTERNAL  WAVE
 *
 * @api UINT | waveInGetDevCaps | This function queries a specified waveform
 *   input device to determine its capabilities.
 *
 * @parm UINT | wDeviceID | Identifies the waveform input device.
 *
 * @parm LPWAVEINCAPS | lpCaps | Specifies a far pointer to a <t WAVEINCAPS>
 *   structure.  This structure is filled with information about the
 *   capabilities of the device.
 *
 * @parm UINT | wSize | Specifies the size of the <t WAVEINCAPS> structure.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_BADDEVICEID | Specified device ID is out of range.
 *   @flag MMSYSERR_NODRIVER | The driver was not installed.
 *
 * @comm Use <f waveInGetNumDevs> to determine the number of waveform input
 *   devices present in the system.  The device ID specified by <p wDeviceID>
 *   varies from zero to one less than the number of devices present.
 *   The WAVE_MAPPER constant may also be used as a device id. Only
 *   <p wSize> bytes (or less) of information is copied to the location
 *   pointed to by <p lpCaps>.  If <p wSize> is zero, nothing is copied, and
 *   the function returns zero.
 *
 * @xref waveInGetNumDevs
 ****************************************************************************/
UINT WINAPI
waveInGetDevCaps(
    UINT wDeviceID,
    LPWAVEINCAPS lpCaps,
    UINT wSize
    )
{
    if (wSize == 0) {
        return MMSYSERR_NOERROR;
    }

    V_WPOINTER(lpCaps, wSize, MMSYSERR_INVALPARAM);

    if (ValidateHandle((HWAVEIN)wDeviceID, TYPE_WAVEIN)) {
       return((UINT)waveIMessage((HWAVE)wDeviceID,
                                 WIDM_GETDEVCAPS,
                                 (DWORD)lpCaps,
                                 (DWORD)wSize));
    }

    return waveIIDMessage( wDeviceID, WIDM_GETDEVCAPS,
                           0L, (DWORD)lpCaps, (DWORD)wSize);
}

/*****************************************************************************
 * @doc EXTERNAL  WAVE
 *
 * @api UINT | waveInGetErrorText | This function retrieves a textual
 *   description of the error identified by the specified error number.
 *
 * @parm UINT | wError | Specifies the error number.
 *
 * @parm LPSTR | lpText | Specifies a far pointer to the buffer to be
 *   filled with the textual error description.
 *
 * @parm UINT | wSize | Specifies the size of the buffer pointed
 *   to by <p lpText>.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_BADERRNUM | Specified error number is out of range.
 *
 * @comm If the textual error description is longer than the specified buffer,
 *   the description is truncated.  The returned error string is always
 *   null-terminated. If <p wSize> is zero, nothing is copied, and the function
 *   returns zero. All error descriptions are less than MAXERRORLENGTH characters long.
 ****************************************************************************/
UINT WINAPI
waveInGetErrorText(
    UINT wError,
    LPSTR lpText,
    UINT wSize
    )
{
    if (wSize == 0) {
        return MMSYSERR_NOERROR;
    }

    V_WPOINTER(lpText, wSize, MMSYSERR_INVALPARAM);

    return waveGetErrorText(wError, lpText, wSize);
}

/*****************************************************************************
 * @doc EXTERNAL  WAVE
 *
 * @api UINT | waveInOpen | This function opens a specified waveform
 *   input device for recording.
 *
 * @parm LPHWAVEIN | lphWaveIn | Specifies a far pointer to a HWAVEIN
 *   handle.  This location is filled with a handle identifying the opened
 *   waveform input device.  Use this handle to identify the device when
 *   calling other waveform input functions.  This parameter may be NULL
 *   if the WAVE_FORMAT_QUERY flag is specified for <p dwFlags>.
 *
 * @parm UINT | wDeviceID | Identifies the waveform input device to open. Use
 *  a valid device ID or the following flag:
 *
 * @flag WAVE_MAPPER | If this flag is specified, the function
 *   selects a waveform input device capable of recording in the
 *   given format.
 *
 * @parm LPWAVEFORMAT | lpFormat | Specifies a pointer to a <t WAVEFORMAT>
 *   data structure that identifies the desired format for recording
 *   waveform data.
 *
 * @parm DWORD | dwCallback | Specifies the address of a callback
 *   function or a handle to a window called during waveform
 *   recording to process messages related to the progress of recording.
 *
 * @parm DWORD | dwCallbackInstance | Specifies user
 *  instance data passed to the callback.  This parameter is not
 *  used with window callbacks.
 *
 * @parm DWORD | dwFlags | Specifies flags for opening the device.
 *   @flag WAVE_FORMAT_QUERY | If this flag is specified, the device will
 *   be queried to determine if it supports the given format but will not
 *      actually be opened.
 *   @flag WAVE_ALLOWSYNC | If this flag is not specified, then the
 *   device will fail to open if it is a synchronous device.
 *   @flag CALLBACK_WINDOW | If this flag is specified, <p dwCallback> is
 *      assumed to be a window handle.
 *   @flag CALLBACK_FUNCTION | If this flag is specified, <p dwCallback> is
 *      assumed to be a callback procedure address.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_BADDEVICEID | Specified device ID is out of range.
 *   @flag MMSYSERR_ALLOCATED | Specified resource is already allocated.
 *   @flag MMSYSERR_NOMEM | Unable to allocate or lock memory.
 *   @flag WAVERR_BADFORMAT | Attempted to open with an unsupported wave format.
 *
 * @comm Use <f waveInGetNumDevs> to determine the number of waveform input
 *   devices present in the system.  The device ID specified by <p wDeviceID>
 *   varies from zero to one less than the number of devices present.
 *   The WAVE_MAPPER constant may also be used as a device id.
 *
 *   If a window is chosen to receive callback information, the following
 *   messages are sent to the window procedure function to indicate the
 *   progress of waveform input:  <m MM_WIM_OPEN>, <m MM_WIM_CLOSE>,
 *   <m MM_WIM_DATA>
 *
 *   If a function is chosen to receive callback information, the following
 *   messages are sent to the function to indicate the progress of waveform
 *   input: <m WIM_OPEN>, <m WIM_CLOSE>, <m WIM_DATA>.  The callback function
 *   must reside in a DLL.  You do not have to use <f MakeProcInstance> to get
 *   a procedure-instance address for the callback function.
 *
 * @cb void CALLBACK | WaveInFunc | <f WaveInFunc> is a placeholder for the
 *   application-supplied function name.  The actual name must be exported by
 *   including it in an EXPORTS statement in the DLL's module-definition file.
 *
 * @parm HWAVEIN | hWaveIn | Specifies a handle to the waveform device
 *   associated with the callback.
 *
 * @parm UINT | wMsg | Specifies a waveform input device.
 *
 * @parm DWORD | dwInstance | Specifies the user instance
 *   data specified with <f waveInOpen>.
 *
 * @parm DWORD | dwParam1 | Specifies a parameter for the message.
 *
 * @parm DWORD | dwParam2 | Specifies a parameter for the message.
 *
 * @comm Because the callback is accessed at interrupt time, it must reside
 *   in a DLL and its code segment must be specified as FIXED in the
 *   module-definition file for the DLL.  Any data that the callback accesses
 *   must be in a FIXED data segment as well. The callback may not make any
 *   system calls except for <f PostMessage>, <f timeGetSystemTime>,
 *   <f timeGetTime>, <f timeSetEvent>, <f timeKillEvent>,
 *   <f midiOutShortMsg>, <f midiOutLongMsg>, and <f OutputDebugStr>.
 *
 * @xref waveInClose
 ****************************************************************************/
UINT WINAPI
waveInOpen(
    LPHWAVEIN lphWaveIn,
    UINT wDeviceID,
    const WAVEFORMAT FAR* lpFormat,
    DWORD dwCallback,
    DWORD dwInstance,
    DWORD dwFlags
    )
{
    WAVEOPENDESC wo;
    PWAVEDEV     pdev;
    UINT         wRet;
    DWORD        dwDrvUser;

    V_RPOINTER(lpFormat, sizeof(WAVEFORMAT), MMSYSERR_INVALPARAM);
    V_DCALLBACK(dwCallback, HIWORD(dwFlags), MMSYSERR_INVALPARAM);
    V_FLAGS(LOWORD(dwFlags), WAVE_VALID, waveInOpen, MMSYSERR_INVALFLAG);

    if (!(dwFlags & WAVE_FORMAT_QUERY)) {
        V_WPOINTER(lphWaveIn, sizeof(HWAVEIN), MMSYSERR_INVALPARAM);
        *lphWaveIn = NULL;
    }

    /*
    ** Check for no devices
    */
//  if (wTotalWaveInDevs == 0 ) {
//      return MMSYSERR_BADDEVICEID;
//  }
//
//  /*
//  ** check for device ID being to large
//  */
//  if ( wDeviceID != WAVE_MAPPER ) {
//      if ( wDeviceID >= wTotalWaveInDevs ) {
//          return MMSYSERR_BADDEVICEID;
//      }
//  }


    if (dwFlags & WAVE_FORMAT_QUERY) {
        pdev = NULL;
    }
    else {
        if (!(pdev = (PWAVEDEV)NewHandle(TYPE_WAVEIN, sizeof(WAVEDEV))))
            return MMSYSERR_NOMEM;

        pdev->wDevice = wDeviceID;
        pdev->wDeviceID = wDeviceID;
    }

    wo.hWave        = (HWAVE)pdev;
    wo.dwCallback   = dwCallback;
    wo.dwInstance   = dwInstance;
    wo.lpFormat     = lpFormat;

    if ( (wDeviceID == WAVE_MAPPER) && (wodMapper != NULL) ) {

        wRet = (UINT)((*(widMapper))(0, WIDM_OPEN,
                                     (DWORD)(LPDWORD)&dwDrvUser,
                                     (DWORD)(LPWAVEOPENDESC)&wo,
                                     dwFlags));
    }
    else {

        wRet = waveIIDMessage( wDeviceID, WIDM_OPEN,
                               (DWORD)(LPDWORD)&dwDrvUser,
                               (DWORD)(LPWAVEOPENDESC)&wo, dwFlags );
    }

    if (pdev) {

        if (wRet)
            FreeHandle((HWAVEIN)pdev);
        else {
            *lphWaveIn = (HWAVEIN)pdev;
            pdev->dwDrvUser = dwDrvUser;
        }
    }

    return wRet;
}

/*****************************************************************************
 * @doc EXTERNAL  WAVE
 *
 * @api UINT | waveInClose | This function closes the specified waveform
 *   input device.
 *
 * @parm HWAVEIN | hWaveIn | Specifies a handle to the waveform input device.
 *  If the function is successful, the handle is no longer
 *   valid after this call.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_INVALHANDLE | Specified device handle is invalid.
 *   @flag WAVERR_STILLPLAYING | There are still buffers in the queue.
 *
 * @comm If there are input buffers that have been sent with
 *   <f waveInAddBuffer>, and haven't been returned to the application,
 *   the close operation will fail.  Call <f waveInReset> to mark all
 *   pending buffers as done.
 *
 * @xref waveInOpen waveInReset
 ****************************************************************************/
UINT WINAPI
waveInClose(
    HWAVEIN hWaveIn
    )
{
    UINT         wRet;

    V_HANDLE(hWaveIn, TYPE_WAVEIN, MMSYSERR_INVALHANDLE);

    wRet = (UINT)waveIMessage( (HWAVE)hWaveIn, WIDM_CLOSE, 0L, 0L);
    if (!wRet) {
        FreeHandle(hWaveIn);
    }
    return wRet;
}

/*****************************************************************************
 * @doc EXTERNAL  WAVE
 *
 * @api UINT | waveInPrepareHeader | This function prepares a buffer
 *   for waveform input.
 *
 * @parm HWAVEIN | hWaveIn | Specifies a handle to the waveform input
 *   device.
 *
 * @parm LPWAVEHDR | lpWaveInHdr | Specifies a pointer to a
 *   <t WAVEHDR> structure that identifies the buffer to be prepared.
 *
 * @parm UINT | wSize | Specifies the size of the <t WAVEHDR> structure.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_INVALHANDLE | Specified device handle is invalid.
 *   @flag MMSYSERR_NOMEM | Unable to allocate or lock memory.
 *
 * @comm The <t WAVEHDR> data structure and the data block pointed to by its
 *   <e WAVEHDR.lpData> field must be allocated with <f GlobalAlloc> using the
 *   GMEM_MOVEABLE and GMEM_SHARE flags, and locked with <f GlobalLock>.
 *   Preparing a header that has already been prepared will have no effect,
 *   and the function will return zero.
 *
 * @xref waveInUnprepareHeader
 ****************************************************************************/
UINT WINAPI
waveInPrepareHeader(
    HWAVEIN hWaveIn,
    LPWAVEHDR lpWaveInHdr,
    UINT wSize
    )
{
    UINT         wRet;

    V_HANDLE(hWaveIn, TYPE_WAVEIN, MMSYSERR_INVALHANDLE);
    V_HEADER(lpWaveInHdr, wSize, TYPE_WAVEIN, MMSYSERR_INVALPARAM);

    if (IsWaveHeaderPrepared(hWaveIn, lpWaveInHdr)) {
        DebugErr(DBF_WARNING,"waveInPrepareHeader: header is already prepared.");
        return MMSYSERR_NOERROR;
    }

    lpWaveInHdr->dwFlags = 0;

    wRet = wavePrepareHeader(lpWaveInHdr, wSize);

    if (wRet == MMSYSERR_NOERROR) {
        wRet = (UINT)waveIMessage( (HWAVE)hWaveIn, WIDM_PREPARE,
                                   (DWORD)lpWaveInHdr, (DWORD)wSize);
    }

    return wRet;
}

/*****************************************************************************
 * @doc EXTERNAL  WAVE
 *
 * @api UINT | waveInUnprepareHeader | This function cleans up the
 * preparation performed by <f waveInPrepareHeader>. The function must
 * be called after the device
 *   driver fills a data buffer and returns it to the application. You
 *  must call this function before freeing the data buffer.
 *
 * @parm HWAVEIN | hWaveIn | Specifies a handle to the waveform input
 *   device.
 *
 * @parm LPWAVEHDR | lpWaveInHdr |  Specifies a pointer to a <t WAVEHDR>
 *   structure identifying the data buffer to be cleaned up.
 *
 * @parm UINT | wSize | Specifies the size of the <t WAVEHDR> structure.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_INVALHANDLE | Specified device handle is invalid.
 *   @flag WAVERR_STILLPLAYING | <p lpWaveInHdr> is still in the queue.
 *
 * @comm This function is the complementary function to <f waveInPrepareHeader>.
 * You must call this function before freeing the data buffer with <f GlobalFree>.
 *   After passing a buffer to the device driver with <f waveInAddBuffer>, you
 *   must wait until the driver is finished with the buffer before calling
 *   <f waveInUnprepareHeader>. Unpreparing a buffer that has not been
 *   prepared has no effect, and the function returns zero.
 *
 * @xref waveInPrepareHeader
 ****************************************************************************/
UINT WINAPI
waveInUnprepareHeader(
    HWAVEIN hWaveIn,
    LPWAVEHDR lpWaveInHdr,
    UINT wSize
    )
{
    UINT         wRet;

    V_HANDLE(hWaveIn, TYPE_WAVEIN, MMSYSERR_INVALHANDLE);
    V_HEADER(lpWaveInHdr, wSize, TYPE_WAVEIN, MMSYSERR_INVALPARAM);

    if (lpWaveInHdr->dwFlags & WHDR_INQUEUE) {
        DebugErr(DBF_WARNING, "waveInUnprepareHeader: buffer still in queue.");
        return WAVERR_STILLPLAYING;
    }

    if (!IsWaveHeaderPrepared(hWaveIn, lpWaveInHdr)) {
        DebugErr(DBF_WARNING,"waveInUnprepareHeader: header is not prepared.");
        return MMSYSERR_NOERROR;
    }

    wRet = waveUnprepareHeader(lpWaveInHdr, wSize);

    if (wRet == MMSYSERR_NOERROR) {
        wRet = (UINT)waveIMessage( (HWAVE)hWaveIn, WIDM_UNPREPARE,
                                   (DWORD)lpWaveInHdr, (DWORD)wSize);
    }

    return wRet;
}

/*****************************************************************************
 * @doc EXTERNAL  WAVE
 *
 * @api UINT | waveInAddBuffer | This function sends an input buffer to a
 *   waveform input device.  When the buffer is filled, it is sent back
 *   to the application.
 *
 * @parm HWAVEIN | hWaveIn | Specifies a handle to the waveform input device.
 *
 * @parm LPWAVEHDR | lpWaveInHdr | Specifies a far pointer to a <t WAVEHDR>
 *   structure that identifies the buffer.
 *
 * @parm UINT | wSize | Specifies the size of the <t WAVEHDR> structure.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_INVALHANDLE | Specified device handle is invalid.
 *   @flag WAVERR_UNPREPARED | <p lpWaveInHdr> hasn't been prepared.
 *
 * @comm The data buffer must be prepared with <f waveInPrepareHeader> before
 *   it is passed to <f waveInAddBuffer>.  The <t WAVEHDR> data structure
 *   and the data buffer pointed to by its <e WAVEHDR.lpData> field must be allocated
 *   with <f GlobalAlloc> using the GMEM_MOVEABLE and GMEM_SHARE flags, and
 *   locked with <f GlobalLock>.
 *
 * @xref waveInPrepareHeader
 ****************************************************************************/
UINT WINAPI
waveInAddBuffer(
    HWAVEIN hWaveIn,
    LPWAVEHDR lpWaveInHdr,
    UINT wSize
    )
{
    V_HANDLE(hWaveIn, TYPE_WAVEIN, MMSYSERR_INVALHANDLE);
    V_HEADER(lpWaveInHdr, wSize, TYPE_WAVEIN, MMSYSERR_INVALPARAM);

    if (!IsWaveHeaderPrepared(hWaveIn, lpWaveInHdr)) {
        DebugErr(DBF_WARNING, "waveInAddBuffer: buffer not prepared.");
        return WAVERR_UNPREPARED;
    }

    if (lpWaveInHdr->dwFlags & WHDR_INQUEUE) {
        DebugErr(DBF_WARNING, "waveInAddBuffer: buffer already in queue.");
        return WAVERR_STILLPLAYING;
    }

    return (UINT)waveIMessage( (HWAVE)hWaveIn, WIDM_ADDBUFFER,
                               (DWORD)lpWaveInHdr, (DWORD)wSize);
}

/*****************************************************************************
 * @doc EXTERNAL  WAVE
 *
 * @api UINT | waveInStart | This function starts input on the specified
 *   waveform input device.
 *
 * @parm HWAVEIN | hWaveIn | Specifies a handle to the waveform input device.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_INVALHANDLE | Specified device handle is invalid.
 *
 * @comm Buffers are returned to the client when full or when <f waveInReset>
 *   is called (the <e WAVEHDR.dwBytesRecorded> field in the header will contain the
 *   actual length of data). If there are no buffers in the queue, the data is
 *   thrown away without notification to the client, and input continues.
 *
 *   Calling this function when input is already started has no effect, and
 *   the function returns zero.
 *
 * @xref waveInStop waveInReset
 ****************************************************************************/
UINT WINAPI
waveInStart(
    HWAVEIN hWaveIn
    )
{
    V_HANDLE(hWaveIn, TYPE_WAVEIN, MMSYSERR_INVALHANDLE);

    return (UINT)waveIMessage( (HWAVE)hWaveIn, WIDM_START, 0L, 0L);
}

/*****************************************************************************
 * @doc EXTERNAL  WAVE
 *
 * @api UINT | waveInStop | This function stops waveform input.
 *
 * @parm HWAVEIN | hWaveIn | Specifies a handle to the waveform input
 *   device.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_INVALHANDLE | Specified device handle is invalid.
 *
 * @comm If there are any buffers in the queue, the current buffer will be
 *   marked as done (the <e WAVEHDR.dwBytesRecorded> field in the header will contain
 *   the actual length of data), but any empty buffers in the queue will remain
 *   there.  Calling this function when input is not started has no effect,
 *   and the function returns zero.
 *
 * @xref waveInStart waveInReset
 ****************************************************************************/
UINT WINAPI
waveInStop(
    HWAVEIN hWaveIn
    )
{
    V_HANDLE(hWaveIn, TYPE_WAVEIN, MMSYSERR_INVALHANDLE);

    return (UINT)waveIMessage( (HWAVE)hWaveIn, WIDM_STOP, 0L, 0L );
}

/*****************************************************************************
 * @doc EXTERNAL  WAVE
 *
 * @api UINT | waveInReset | This function stops input on a given waveform
 *   input device and resets the current position to 0.  All pending
 *   buffers are marked as done and returned to the application.
 *
 * @parm HWAVEIN | hWaveIn | Specifies a handle to the waveform input device.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_INVALHANDLE | Specified device handle is invalid.
 *
 * @xref waveInStart waveInStop waveInAddBuffer waveInClose
/****************************************************************************/
UINT WINAPI
waveInReset(
    HWAVEIN hWaveIn
    )
{
    V_HANDLE(hWaveIn, TYPE_WAVEIN, MMSYSERR_INVALHANDLE);

    return (UINT)waveIMessage( (HWAVE)hWaveIn, WIDM_RESET, 0L, 0L );
}

/*****************************************************************************
 * @doc EXTERNAL  WAVE
 *
 * @api UINT | waveInGetPosition | This function retrieves the current input
 *   position of the specified waveform input device.
 *
 * @parm HWAVEIN | hWaveIn | Specifies a handle to the waveform input device.
 *
 * @parm LPMMTIME | lpInfo | Specifies a far pointer to an <t MMTIME>
 *   structure.
 *
 * @parm UINT   | wSize | Specifies the size of the <t MMTIME> structure.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_INVALHANDLE | Specified device handle is invalid.
 *
 * @comm Before calling <f waveInGetPosition>, set the <e MMTIME.wType> field of the
 *   <t MMTIME> structure to indicate the time format that you desire.  After
 *   calling <f waveInGetPosition>, be sure to check the <e MMTIME.wType> field to
 *   determine if the desired time format is supported.  If the desired
 *   format is not supported, <e MMTIME.wType> will specify an alternative format.
 *
 *  The position is set to zero when the device is opened or reset.
 ****************************************************************************/
UINT WINAPI
waveInGetPosition(
    HWAVEIN hWaveIn,
    LPMMTIME lpInfo,
    UINT wSize
    )
{
    V_HANDLE(hWaveIn, TYPE_WAVEIN, MMSYSERR_INVALHANDLE);
    V_WPOINTER(lpInfo, wSize, MMSYSERR_INVALPARAM);

    return (UINT)waveIMessage( (HWAVE)hWaveIn,
                               WIDM_GETPOS, (DWORD)lpInfo, (DWORD)wSize );
}

/*****************************************************************************
 * @doc EXTERNAL WAVE
 *
 * @api UINT | waveInGetID | This function gets the device ID for a
 * waveform input device.
 *
 * @parm HWAVEIN | hWaveIn | Specifies the handle to the waveform
 * input device.
 * @parm UINT FAR*  | lpwDeviceID | Specifies a pointer to the UINT-sized memory
 * location to be filled with the device ID.
 *
 * @rdesc Returns zero if successful. Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_INVALHANDLE | The <p hWaveIn> parameter specifies an
 * invalid handle.
 *
 ****************************************************************************/
UINT WINAPI
waveInGetID(
    HWAVEIN hWaveIn,
    UINT FAR* lpwDeviceID
    )
{
    V_HANDLE(hWaveIn, TYPE_WAVEIN, MMSYSERR_INVALHANDLE);
    V_WPOINTER(lpwDeviceID, sizeof(UINT), MMSYSERR_INVALPARAM);

    *lpwDeviceID = ((PWAVEDEV)hWaveIn)->wDeviceID;

    return MMSYSERR_NOERROR;
}

/*****************************************************************************
 * @doc EXTERNAL WAVE
 *
 * @api UINT | waveOutGetID | This function gets the device ID for a
 * waveform output device.
 *
 * @parm HWAVEOUT | hWaveOut | Specifies the handle to the waveform
 * output device.
 * @parm UINT FAR* | lpwDeviceID | Specifies a pointer to the UINT-sized memory
 * location to be filled with the device ID.
 *
 * @rdesc Returns zero if successful. Otherwise, it returns
 *   an error number.  Possible error returns are:
 * @flag MMSYSERR_INVALHANDLE | The <p hWaveOut> parameter specifies an
 * invalid handle.
 ****************************************************************************/
UINT WINAPI
waveOutGetID(
    HWAVEOUT hWaveOut,
    UINT FAR* lpwDeviceID
    )
{
    V_HANDLE(hWaveOut, TYPE_WAVEOUT, MMSYSERR_INVALHANDLE);
    V_WPOINTER(lpwDeviceID, sizeof(UINT), MMSYSERR_INVALPARAM);

    *lpwDeviceID = ((PWAVEDEV)hWaveOut)->wDeviceID;

    return MMSYSERR_NOERROR;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\mmsystem\mmtask\mmtask.h ===
/*****************************************************************************

   Copyright (C) Microsoft Corporation 1985-1990. All rights reserved.

   Title:      mmtask.h - header file for mmtask app!

   Version:    1.00

   Date:       12-Mar-1990

   Author:     ROBWI

-----------------------------------------------------------------------------

   Change log:

      DATE     REV            DESCRIPTION
   ----------- ---   --------------------------------------------------------
   12-Mar-1990 ROBWI First Version 
   18-Apr-1990 ROBWI Moved to mmtask

****************************************************************************/

/* 
   The mmtask app. expects this structure to be passed as the 
   command tail when the app. is exec'd
*/

typedef struct _MMTaskStruct {
    BYTE        cb;             
    LPTASKCALLBACK    lpfn;
    DWORD       dwInst;
    DWORD       dwStack;
} MMTaskStruct;

#define MMTASK_STACK 4096
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\ole\client\defcreat.c ===
/****************************** Module Header ******************************\
* Module Name: defcreat.c
*
* Purpose: Handles the various object creation routines, which are exported
*          to the DLL writers.
*
* Created: November 1990
*
* Copyright (c) 1985, 1986, 1987, 1988, 1989  Microsoft Corporation
*
* History:
*   Srinik (11/12/90)   Original
*
\***************************************************************************/

#include <windows.h>
#include "dll.h"

extern  OLECLIPFORMAT   cfOwnerLink;
extern  OLECLIPFORMAT   cfObjectLink;
extern  OLECLIPFORMAT   cfNative;


RENDER_ENTRY stdRender[NUM_RENDER] = {
    { "METAFILEPICT",   0, MfLoadFromStream}, 
    { "DIB",            0, DibLoadFromStream},
    { "BITMAP",         0, BmLoadFromStream}
};


OLESTATUS  FARINTERNAL  DefLoadFromStream (lpstream, lpprotocol, lpclient, lhclientdoc, lpobjname, lplpobj, objType, aClass, cfFormat)
LPOLESTREAM         lpstream;
LPSTR               lpprotocol;
LPOLECLIENT         lpclient;
LHCLIENTDOC         lhclientdoc;
LPSTR               lpobjname;
LPOLEOBJECT FAR *   lplpobj;
LONG                objType;
ATOM                aClass;
OLECLIPFORMAT       cfFormat;
{
    OLESTATUS   retVal;
    int         i;

    *lplpobj = NULL;        

    if ((objType == CT_PICTURE) || (objType == CT_STATIC)) {
        for (i = 0; i < NUM_RENDER; i++) {
            if (stdRender[i].aClass == aClass) {
                retVal = (*stdRender[i].Load) (lpstream, lpclient, 
                                lhclientdoc, lpobjname, lplpobj, objType);
                if (aClass)
                    GlobalDeleteAtom (aClass);
                return retVal;
            }
        }
        
        return GenLoadFromStream (lpstream, lpclient, lhclientdoc, lpobjname,
                        lplpobj, objType, aClass, cfFormat);
    }
    else {
        return LeLoadFromStream (lpstream, lpclient, lhclientdoc, lpobjname,
                        lplpobj, objType, aClass, cfFormat);
    }
}


OLESTATUS FAR PASCAL DefCreateFromClip (lpprotocol, lpclient, lhclientdoc, lpobjname, lplpobj, optRender, cfFormat, objType)
LPSTR               lpprotocol;
LPOLECLIENT         lpclient;
LHCLIENTDOC         lhclientdoc;
LPSTR               lpobjname;
LPOLEOBJECT FAR *   lplpobj;
OLEOPT_RENDER       optRender;
OLECLIPFORMAT       cfFormat;
LONG                objType;
{
    if (objType == CT_EMBEDDED)
        return EmbPaste (lpclient, lhclientdoc, lpobjname, lplpobj, 
                    optRender, cfFormat);
    
    if (objType == CT_LINK)
        return LnkPaste (lpclient, lhclientdoc, lpobjname, lplpobj, 
                    optRender, cfFormat, cfOwnerLink);

    return OLE_ERROR_CLIPBOARD;                          
}




OLESTATUS FAR PASCAL DefCreateLinkFromClip (lpprotocol, lpclient, lhclientdoc, lpobjname, lplpobj, optRender, cfFormat)
LPSTR               lpprotocol;
LPOLECLIENT         lpclient;
LHCLIENTDOC         lhclientdoc;
LPSTR               lpobjname;
LPOLEOBJECT FAR *   lplpobj;
OLEOPT_RENDER       optRender;
OLECLIPFORMAT       cfFormat;
{
    return LnkPaste (lpclient, lhclientdoc, lpobjname, lplpobj, 
                optRender, cfFormat, cfObjectLink);
}


OLESTATUS FAR PASCAL DefCreateFromTemplate (lpprotocol, lpclient, lptemplate, lhclientdoc, lpobjname, lplpoleobject, optRender, cfFormat)
LPSTR               lpprotocol;
LPOLECLIENT         lpclient;
LPSTR               lptemplate;
LHCLIENTDOC         lhclientdoc;
LPSTR               lpobjname;
LPOLEOBJECT FAR *   lplpoleobject;
OLEOPT_RENDER       optRender;
OLECLIPFORMAT       cfFormat;
{
    return LeCreateFromTemplate (lpclient,
                    lptemplate,
                    lhclientdoc,
                    lpobjname,
                    lplpoleobject,
                    optRender,
                    cfFormat);
}


OLESTATUS FAR PASCAL DefCreate (lpprotocol, lpclient, lpclass, lhclientdoc, lpobjname, lplpoleobject, optRender, cfFormat)
LPSTR               lpprotocol;
LPOLECLIENT         lpclient;
LPSTR               lpclass;
LHCLIENTDOC         lhclientdoc;
LPSTR               lpobjname;
LPOLEOBJECT FAR *   lplpoleobject;
OLEOPT_RENDER       optRender;
OLECLIPFORMAT       cfFormat;
{
    return LeCreate (lpclient,
                lpclass,
                lhclientdoc,
                lpobjname,
                lplpoleobject,
                optRender,
                cfFormat);
}



OLESTATUS FAR PASCAL DefCreateFromFile (lpprotocol, lpclient, lpclass, lpfile, lhclientdoc, lpobjname, lplpoleobject, optRender, cfFormat)
LPSTR               lpprotocol;
LPOLECLIENT         lpclient;
LPSTR               lpclass;
LPSTR               lpfile;
LHCLIENTDOC         lhclientdoc;
LPSTR               lpobjname;
LPOLEOBJECT FAR *   lplpoleobject;
OLEOPT_RENDER       optRender;
OLECLIPFORMAT       cfFormat;
{
    return CreateEmbLnkFromFile (lpclient,
                        lpclass,
                        lpfile,
                        NULL,
                        lhclientdoc,
                        lpobjname,
                        lplpoleobject,
                        optRender,
                        cfFormat,
                        CT_EMBEDDED);
}


OLESTATUS FAR PASCAL DefCreateLinkFromFile (lpprotocol, lpclient, lpclass, lpfile, lpitem, lhclientdoc, lpobjname, lplpoleobject, optRender, cfFormat)
LPSTR               lpprotocol;
LPOLECLIENT         lpclient;
LPSTR               lpclass;
LPSTR               lpfile;
LPSTR               lpitem;
LHCLIENTDOC         lhclientdoc;
LPSTR               lpobjname;
LPOLEOBJECT FAR *   lplpoleobject;
OLEOPT_RENDER       optRender;
OLECLIPFORMAT       cfFormat;
{
    return CreateEmbLnkFromFile (lpclient,
                        lpclass,
                        lpfile,
                        lpitem,
                        lhclientdoc,
                        lpobjname,
                        lplpoleobject,
                        optRender,
                        cfFormat,
                        CT_LINK);
}


OLESTATUS FAR PASCAL DefCreateInvisible (lpprotocol, lpclient, lpclass, lhclientdoc, lpobjname, lplpoleobject, optRender, cfFormat, fActivate)
LPSTR               lpprotocol;
LPOLECLIENT         lpclient;
LPSTR               lpclass;
LHCLIENTDOC         lhclientdoc;
LPSTR               lpobjname;
LPOLEOBJECT FAR *   lplpoleobject;
OLEOPT_RENDER       optRender;
OLECLIPFORMAT       cfFormat;
BOOL                fActivate;
{
    return LeCreateInvisible (lpclient,
                        lpclass,
                        lhclientdoc,
                        lpobjname,
                        lplpoleobject,
                        optRender,
                        cfFormat,
                        fActivate);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\mmsystem\rinc\mmsysver.h ===
/*
 *  mmsysver.h - internal header file to define the build version for sonic
 *
 */

/*
 *  All strings MUST have an explicit \0
 *
 *  MMSYSRELEASE should be changed every build
 *
 *  Version string should be changed each build
 *
 *  Remove build extension on final release
 */

#define OFFICIAL                1
#define FINAL                   1

#define MMSYSVERSION            03
#define MMSYSREVISION           10
#define MMSYSRELEASE            103

#define MMSYSVERSIONSTR         "3.1\0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\ole\client\dde.c ===
/****************************** Module Header ******************************\
* Module Name: DDE.C (Extensible Compound Documents -DDE)
*
* Copyright (c) 1985 - 1991 Microsoft Corporation
*
* PURPOSE: Handles all API routines for the dde sub-dll of the ole dll.
*
* History:
*   Raor,Srinik  (../../90,91)  Designed and coded
*
\***************************************************************************/

#include <windows.h>
#include "dde.h"
#include "dll.h"

#define WIN32S

/* #define GRAPHBUG */


// ### may not need seperate wndproc for system topic!
HANDLE  GetDDEDataHandle (DDEDATA FAR *, WORD, HANDLE);

extern  ATOM        aSystem;
extern  ATOM        aOle;
extern  HANDLE      hInstDLL;


// DocWndProc: Window procedure used to document DDE conversations
long FAR PASCAL DocWndProc(hwnd, message, wParam, lParam)
HWND        hwnd;
unsigned    message;
WORD        wParam;
LONG        lParam;

{
    PEDIT_DDE   pedit = NULL;
    LPOBJECT_LE lpobj  = NULL;



    Puts("DocWndProc");

    if (lpobj  = (LPOBJECT_LE) GetWindowLong (hwnd, 0))
        pedit = lpobj->pDocEdit;

    switch (message){

        case WM_DDE_ACK:
#ifdef  FIREWALLS
        ASSERT (pedit, "Doc conv channel missing");
#endif
            DEBUG_OUT ("WM_DDE_ACK ", 0);
            if (pedit->bTerminating){
                // ### this error recovery may not be correct.
                DEBUG_OUT ("No action due to termination process",0)
                break;
            }

            switch(pedit->awaitAck){

                case AA_INITIATE:
                    HandleAckInitMsg (pedit, (HWND)wParam);
                    if (LOWORD(lParam))
                        GlobalDeleteAtom (LOWORD(lParam));
                    if (HIWORD(lParam))
                        GlobalDeleteAtom (HIWORD(lParam));
                    break;

                case AA_REQUEST:
                case AA_UNADVISE:
                case AA_EXECUTE:
                case AA_ADVISE:
                    HandleAck (lpobj, pedit, lParam);
                    break;

                case AA_POKE:

                    // freeing pokedata is done in handleack
                    HandleAck (lpobj, pedit, lParam);
                    break;

                default:
                    DEBUG_OUT ("received ACK We don't know how to handle ",0)
                    break;

            } // end of switch
            break;

        case WM_TIMER:
            HandleTimerMsg (lpobj, pedit);
            break;

        case WM_DDE_DATA:
#ifdef  FIREWALLS
        ASSERT (pedit, "Doc conv channel missing");
#endif
            DEBUG_OUT ("WM_DDE_DATA",0);
            HandleDataMsg (lpobj, LOWORD(lParam), HIWORD(lParam));
            break;

        case WM_DDE_TERMINATE:

#ifdef  FIREWALLS
        ASSERT (pedit, "Doc conv channel missing");
#endif
            DEBUG_OUT ("WM_DDE_TERMINATE",0);
            HandleTermMsg (lpobj, pedit, (HWND)wParam, TRUE);
            break;

        case WM_DESTROY:

#ifdef  FIREWALLS
        ASSERT (pedit, "Doc conv channel missing");
#endif
            DEBUG_OUT ("Client window being destroyed", 0)
            pedit->hClient = NULL;
            break;

        default:
            return DefWindowProc (hwnd, message, wParam, lParam);

    }
    return 0L;
}



// SrvrWndProc: Window Procedure for System Topic DDE conversations
// wndproc for system topic

long FAR PASCAL SrvrWndProc(hwnd, message, wParam, lParam)
HWND        hwnd;
unsigned    message;
WORD        wParam;
LONG        lParam;

{
    PEDIT_DDE   pedit = NULL;
    LPOBJECT_LE lpobj  = NULL;

    Puts("SysWndProc");

    if (lpobj  = (LPOBJECT_LE) GetWindowLong (hwnd, 0))
        pedit = lpobj->pSysEdit;

    switch (message){

       case WM_DDE_ACK:

#ifdef  FIREWALLS
        ASSERT (pedit, "sys conv edit block missing");
#endif

            DEBUG_OUT ("SYS: WM_DDE_ACK",0);

            if(pedit->bTerminating){
                //### Error recovery may not be OK.
                DEBUG_OUT ("No action due to termination process",0)
                break;
            }

            switch (pedit->awaitAck) {


                case AA_INITIATE:

#ifdef      HISTORY
                    if (GetWindowWord ((HWND)wParam, GWW_HINSTANCE) == pedit->hInst ||
                            IsSrvrDLLwnd ((HWND)wParam, pedit->hInst)) {
                        // For exact instance match or for
                        // DLL instance match, keep the new one
#ifdef  FIREWALLS
        ASSERT (!pedit->hServer, "Two instances are matching");
#endif

                        pedit->hServer = (HWND)wParam;
                    } else {

                        ++pedit->extraTerm;
                        // This post directly is alright since we are
                        // terminating extra initiates.

                        PostMessage ((HWND)wParam,
                                WM_DDE_TERMINATE, hwnd, 0);
                    }
#else

                    HandleAckInitMsg (pedit, (HWND)wParam);
#endif
                    if (LOWORD(lParam))
                        GlobalDeleteAtom (LOWORD(lParam));
                    if (HIWORD(lParam))
                        GlobalDeleteAtom (HIWORD(lParam));

                    break;

                case AA_EXECUTE:
                    HandleAck(lpobj, pedit, lParam);
                    break;


                default:
                    DEBUG_OUT ("received ACK We don't know how to handle ",0)
                    break;


            }

            break;

       case WM_TIMER:
            HandleTimerMsg (lpobj, pedit);
            break;

       case WM_DDE_TERMINATE:

#ifdef  FIREWALLS
        ASSERT (pedit, "sys conv edit block missing");
#endif
            HandleTermMsg (lpobj, pedit, (HWND)wParam, FALSE);
            break;

       case WM_DESTROY:
#ifdef  FIREWALLS
        ASSERT (pedit, "sys conv edit block missing");
#endif
            DEBUG_OUT ("destroy window for the sys connection", 0);
            pedit->hClient = NULL;
            break;


       default:
            return DefWindowProc (hwnd, message, wParam, lParam);

       }
       return 0L;
}

void    INTERNAL    HandleTimerMsg (lpobj, pedit)
PEDIT_DDE   pedit;
LPOBJECT_LE lpobj;
{


    // Since there is only one timer for each client, just
    // repost the message and delete the timer.

    KillTimer (pedit->hClient, 1);
    pedit->wTimer = 0;

    if (PostMessageToServer(pedit, pedit->msg, pedit->lParam))
        return ; // return something.

    // Postmessage failed. We need to getback to the main stream of
    // commands for the object.
    HandleAck (lpobj, pedit, pedit->lParam);
    return ;
}


void INTERNAL   HandleTermMsg (lpobj, pedit, hwndPost, bDoc)
LPOBJECT_LE     lpobj;
PEDIT_DDE       pedit;
HWND            hwndPost;
BOOL            bDoc;
{
    WORD    asyncCmd;
    BOOL    bBusy;

    if (pedit->hServer != hwndPost){
        DEBUG_OUT ("Got terminate for extra conversation",0)
        if (--pedit->extraTerm == 0 && pedit->bTerminating)
            ScheduleAsyncCmd (lpobj);
        return;

    }

    if (!pedit->bTerminating){

        // If we are waiting for any ack, then goto next step with error

        // delete any data if we were in busy mode.
        bBusy = DeleteBusyData (lpobj, pedit);

        asyncCmd = lpobj->asyncCmd;
        PostMessageToServer(pedit, WM_DDE_TERMINATE, NULL);
        pedit->hServer = NULL;
        if (pedit->awaitAck || bBusy) {
            // Set error and goto next step.
            lpobj->subErr = OLE_ERROR_COMM;
            pedit->awaitAck = NULL;
            ScheduleAsyncCmd (lpobj);
        }

        // If the command is delete, do not delete
        // the edit blocks. It will be deleted
        // in the OleLnkDelete routine and for delete it is
        // possible that by the time we come here, the object
        // may not exist at all.

        if (asyncCmd != OLE_DELETE){
            // QueryOpen() is done because excel is sending WM_DDE_TERMINATE
            // for system without sending for doc in case of failure.

            if (bDoc || QueryOpen (lpobj)) {
                // if the termination is for document and no async command
                // terminate the server conversation also.
                if ((asyncCmd == OLE_NONE) || (asyncCmd == OLE_REQUESTDATA)
                       || (asyncCmd == OLE_OTHER) || (asyncCmd == OLE_SETDATA)
                       || (asyncCmd == OLE_RUN) || (asyncCmd == OLE_SHOW)
                       || (asyncCmd == OLE_SETUPDATEOPTIONS)) {
                    if (lpobj->pDocEdit->awaitAck)
                        // we are waiting for an ack on Doc channel. So start
                        // the unlaunch process after we get the ack.
                        lpobj->bUnlaunchLater = TRUE;
                    else
                        CallEmbLnkDelete (lpobj);
                } else {
                    if (bDoc)
                        DeleteDocEdit (lpobj);

                }
            }else
                DeleteSrvrEdit (lpobj);

        }
    } else {
        pedit->hServer = NULL;
        if (pedit->extraTerm == 0)
            ScheduleAsyncCmd (lpobj);
    }
}

#ifdef FIREWALLS
BOOL INTERNAL CheckAtomValid (ATOM aItem)
{
    char    buffer[MAX_ATOM];
    int     len, val;


        Puts("CheckAtomValid");

    if (aItem == NULL)
             return TRUE;

    val = GlobalGetAtomName (aItem, buffer, MAX_ATOM);
    len = lstrlen (buffer);
    return ((val != 0) && (val == len));
}
#endif




//  HandleAckInitMsg: Handles WM_DDE_ACKs received while in initiate state.  If
//  this is the first reply, save its window handle.  If multiple replies
//  are received, take the one with the prefered instance, if there is
//  one.  Keep a count of WM_DDE_TERMINATEs we send so that we don't shut
//  the window until we get all of the responses for  WM_DDE_TERMINATEs.

void INTERNAL HandleAckInitMsg (pedit, hserver)
PEDIT_DDE      pedit;
HWND           hserver;
{

    Puts("HandleAckInitMsg");

    if (pedit->hServer){
        // just take the very first one. Direct post is OK
        PostMessage (hserver, WM_DDE_TERMINATE, pedit->hClient, 0);
        ++pedit->extraTerm;
    } else
        pedit->hServer = hserver;

}


// HandleAck: returns 0 if <ack> is not positive, else non-0.  Should probably be
//  a macro.

BOOL INTERNAL HandleAck (lpobj, pedit, lParam)
LPOBJECT_LE     lpobj;
PEDIT_DDE       pedit;
DWORD           lParam;
{

    BOOL    retval = TRUE;


    // check for busy bit
    if ((LOWORD (lParam) & 0x4000) && ContextCallBack (lpobj, OLE_QUERY_RETRY)){
        // we got busy from the server. create a timer and wait for time out.

        // We do not need makeprocinstance since, DLLs are single insance, all
        // we need to do is export for this function.

        if (pedit->wTimer = SetTimer (pedit->hClient, 1, 3000, NULL))
            return TRUE;
    }

    // even if the client got terminate we have to go thru this path.

    if (pedit->wTimer) {
        KillTimer (pedit->hClient, 1);
        pedit->wTimer = 0;
    }

    if (pedit->awaitAck == AA_POKE)
        // We have to free the data first. Handleack can trigger
        // another Poke (like pokehostnames)
        FreePokeData (lpobj, pedit);

    if (pedit->awaitAck == AA_EXECUTE)
        GlobalFree (HIWORD (lParam));
    else {
        ASSERT (CheckAtomValid(HIWORD(lParam)),"Invalid atom in ACK")
        if (HIWORD (lParam))
            GlobalDeleteAtom (HIWORD (lParam));
    }

    if (!(LOWORD (lParam) & 0x8000)) {
        // error case. set the error
        DEBUG_OUT ("DDE ACK with failure", 0)

        if (lpobj->errHint){
            lpobj->subErr = lpobj->errHint;
            lpobj->errHint = OLE_OK;
        } else
            lpobj->subErr = OLE_ERROR_COMM;

        retval = FALSE;

        if (pedit->awaitAck == AA_ADVISE) {

#ifdef  ASSERT
        ASSERT (pedit->hopt, "failed advise, options block missing");
#endif
           GlobalFree (pedit->hopt);
        }
    }

    pedit->hopt = NULL;
    pedit->awaitAck = NULL;
    ScheduleAsyncCmd (lpobj);
    return retval;
}

// HandleDataMsg: Called for WM_DDE_DATA message.  If data is from an
//  ADVISE-ON-CLOSE and this is there are no more outstanding
//  ADVISE-ON-CLOSE requests, close the document and end the
//  conversation.

void INTERNAL HandleDataMsg (lpobj, hdata, aItem)
LPOBJECT_LE     lpobj;
HANDLE          hdata;
ATOM            aItem;
{
    DDEDATA         far *lpdata = NULL;
    BOOL            fAck;
    BOOL            fRelease;
    int             options;
    PEDIT_DDE       pedit;

    Puts("HandleDataMsg");

    if (ScanItemOptions (aItem, (int far *)&options) != OLE_OK) {
        DEBUG_OUT (FALSE, "Improper item options");
        return;
    }

    pedit = lpobj->pDocEdit;

    if (hdata) {
        if (!(lpdata = (DDEDATA FAR *) GlobalLock(hdata)))
            return;

        fAck = lpdata->fAckReq;
        fRelease = lpdata->fRelease;

        if (pedit->bTerminating) {
            DEBUG_OUT ("Got DDE_DATA in terminate sequence",0)
            fRelease = TRUE;
        }
        else {
            if (lpdata->cfFormat == (int)cfBinary && aItem == aStdDocName) {
                ChangeDocName (lpobj, (LPSTR)lpdata->Value);
            }
            else
                SetData (lpobj, hdata, options);

            #ifdef  FIREWALLS
                ASSERT (IsWindowValid(pedit->hServer),
                    "Server window missing in HandleDataMsg")
                ASSERT (CheckAtomValid(aItem),"HandleDataMsg invalid atom")
            #endif

            // important that we post the acknowledge first. Otherwist the
            // messages are not in sync.

            if (fAck)
                PostMessageToServer (pedit, WM_DDE_ACK,
                        MAKELONG(POSITIVE_ACK,aItem));
            else if (aItem)
                GlobalDeleteAtom (aItem);

            if ((lpdata->fResponse) && (pedit->awaitAck == AA_REQUEST)) {
                // we sent the request. So, schedule next step.
                pedit->awaitAck = NULL;
                ScheduleAsyncCmd (lpobj);
            }
        }

        GlobalUnlock (hdata);
        if (fRelease)
            GlobalFree (hdata);
    }
    else {
        if (CanCallback (lpobj, options)) {
            if (options != OLE_CLOSED)
                ContextCallBack (lpobj, options);
            else
                lpobj->bSvrClosing = FALSE;

        }
    }

    if (options == OLE_CLOSED && (lpobj->pDocEdit->nAdviseClose <= 2)
            && (lpobj->asyncCmd == OLE_NONE)) {
        InitAsyncCmd (lpobj, OLE_SERVERUNLAUNCH, EMBLNKDELETE);
        EmbLnkDelete (lpobj);
    }
}


HANDLE  GetDDEDataHandle (lpdata, cfFormat, hdata)
DDEDATA far     *lpdata;
WORD            cfFormat;
HANDLE          hdata;
{
    if (cfFormat == CF_BITMAP || cfFormat == CF_METAFILEPICT)
         return *(LPHANDLE)lpdata->Value;

    if (cfFormat == CF_DIB)
        return GlobalReAlloc (*(LPHANDLE)lpdata->Value, 0L,
                    GMEM_MODIFY|GMEM_SHARE);

    return CopyData (((LPSTR)lpdata)+4, GlobalSize (hdata) - 4);
}

// SetData: Given the DDEDATA structure from a WM_DDE_DATA message, set up the
//  appropriate data in lpobj.  If the native is in native format, add
//  that field, otherwise, if it is in picture format, ask the picture
//  to add it itself.

void INTERNAL SetData (lpobj, hdata, options)
LPOBJECT_LE     lpobj;
HANDLE          hdata;
int             options;
{
    DDEDATA far     *lpdata   = NULL;
    OLESTATUS       retVal = OLE_ERROR_MEMORY;
    HANDLE          hdataDDE;

    Puts("SetData");

    if (!(lpdata = (DDEDATA far *) (GlobalLock (hdata))))
        goto errrtn;


    if (!(hdataDDE =  GetDDEDataHandle (lpdata, lpdata->cfFormat, hdata))) {
        lpobj->subErr = OLE_ERROR_MEMORY;
        goto errrtn;
    }

    if (lpdata->cfFormat == (int)cfNative) {
        retVal = (*lpobj->head.lpvtbl->ChangeData) ( lpobj,
                        hdataDDE,
                        lpobj->head.lpclient,
                        TRUE);  // use this data, don't copy

    }
    else if (lpdata->cfFormat && (lpdata->cfFormat == GetPictType (lpobj))) {

            retVal = (*lpobj->lpobjPict->lpvtbl->ChangeData) (lpobj->lpobjPict,
                        hdataDDE,
                        lpobj->head.lpclient,
                        lpdata->fRelease);

    } else {
        // case of extra data in the object.
        DeleteExtraData (lpobj);
        lpobj->cfExtra = lpdata->cfFormat;
        lpobj->hextraData = hdataDDE;
        goto end;
    }

    if (retVal == OLE_OK) {
        SetExtents (lpobj);
        if (CanCallback (lpobj, options)) {
            if (options == OLE_CLOSED) {
                ContextCallBack (lpobj, OLE_CHANGED);
                ContextCallBack (lpobj, OLE_CLOSED);
                lpobj->bSvrClosing = FALSE;
            }
            else
                ContextCallBack (lpobj, options);
        }
    }

end:
errrtn:
    if (lpdata)
        GlobalUnlock (hdata);

    return;
}


// SysStartConvDDE: Starts a system conversation.  Returns a handle to that
//  conversation, or NULL.

BOOL INTERNAL InitSrvrConv (lpobj, hInst)
LPOBJECT_LE     lpobj;
HANDLE          hInst;
{
    HANDLE      hedit = NULL;
    PEDIT_DDE   pedit = NULL;

    Puts("InitSrvrConv");

    if (!lpobj->hSysEdit) {
        hedit = LocalAlloc (LMEM_MOVEABLE | LMEM_ZEROINIT, sizeof (EDIT_DDE));

        if (hedit == NULL || ((pedit = (PEDIT_DDE) LocalLock (hedit)) == NULL))
            goto errRtn;

    } else {
#ifdef  FIREWALLS
    ASSERT (!lpobj->pSysEdit->hClient, "Sys conv lptr is present");
#endif
        hedit  =  lpobj->hSysEdit;
        pedit =   lpobj->pSysEdit;
        UtilMemClr ((PSTR) pedit, sizeof (EDIT_DDE));
    }

    if((pedit->hClient = CreateWindow ("OleSrvrWndClass", "",
        WS_OVERLAPPED,0,0,0,0,NULL,NULL, hInstDLL, NULL)) == NULL)
        goto errRtn;


    lpobj->hSysEdit     = hedit;
    lpobj->pSysEdit     = pedit;
    pedit->hInst        = hInst;
    pedit->awaitAck     = AA_INITIATE;

    SetWindowLong (pedit->hClient, 0, (LONG)lpobj);
    SendMessage (-1, WM_DDE_INITIATE, pedit->hClient,
             MAKELONG (lpobj->app, aOle));

    ASSERT (CheckAtomValid(aOle),"systopic invalid atom")

    pedit->awaitAck    = NULL;
    if (pedit->hServer == NULL) {
        pedit->awaitAck    = AA_INITIATE;
        // Now try the System topic
        SendMessage (-1, WM_DDE_INITIATE, pedit->hClient,
                 MAKELONG (lpobj->app, aSystem));

        ASSERT (CheckAtomValid(aSystem),"systopic invalid atom")

        pedit->awaitAck    = NULL;
        if (pedit->hServer == NULL) {
            DEBUG_OUT ("Srver connection failed", 0);
            goto errRtn;
        }
    }

    // Put the long ptr handle in the object.
    return TRUE;

errRtn:
    if (pedit->hClient)
        DestroyWindow (pedit->hClient);

    if (pedit)
        LocalUnlock (hedit);

    if (hedit)
        LocalFree (hedit);

    lpobj->hSysEdit     = NULL;
    lpobj->pSysEdit    = NULL;

    return FALSE;
}


// TermSrvrConv: Ends conversation indicated by hedit.
void INTERNAL TermSrvrConv (lpobj)
LPOBJECT_LE    lpobj;
{
    PEDIT_DDE pedit;

    Puts("TermSrvrConv");


    if (!(pedit = lpobj->pSysEdit))
        return;

    if (PostMessageToServer (pedit, WM_DDE_TERMINATE, 0)){
        lpobj->bAsync        = TRUE;
        pedit->bTerminating = TRUE;
    } else {
        pedit->bTerminating = FALSE;
        lpobj->subErr = OLE_ERROR_TERMINATE;
    }
    return;
}


void INTERNAL  DeleteAbortData (lpobj, pedit)
LPOBJECT_LE    lpobj;
PEDIT_DDE     pedit;
{

    // kill if any timer active.
    if (pedit->wTimer) {
        KillTimer (pedit->hClient, 1);
        pedit->wTimer = 0;
    }
    return;


}

BOOL INTERNAL   DeleteBusyData (lpobj, pedit)
LPOBJECT_LE    lpobj;
PEDIT_DDE     pedit;
{

    // kill if any timer active.
    if (pedit->wTimer) {
        KillTimer (pedit->hClient, 1);
        pedit->wTimer = 0;

        if (pedit->hData) {
            GlobalFree (pedit->hData);
            pedit->hData = NULL;
        }

        if (pedit->hopt) {
            GlobalFree (pedit->hopt);
            pedit->hopt = NULL;
        }

        if (pedit->awaitAck && (HIWORD(pedit->lParam))) {
            if (pedit->awaitAck == AA_EXECUTE)
                GlobalFree (HIWORD (pedit->lParam));
            else {
                ASSERT (CheckAtomValid(HIWORD(pedit->lParam)),
                    "Invalid atom in ACK")
                if (HIWORD(pedit->lParam))
                    GlobalDeleteAtom (HIWORD(pedit->lParam));
            }

            // we want to wipe out the HIWORD of lParam
            pedit->lParam &= 0x0000FFFF;
        }

        return TRUE;
    }

    return FALSE;
}

void INTERNAL   DeleteSrvrEdit (lpobj)
LPOBJECT_LE    lpobj;
{

    PEDIT_DDE pedit;

    Puts("deleteSrvrEdit");

    if (!(pedit = lpobj->pSysEdit))
        return;


    // delete any data if we were in busy mode.
    DeleteBusyData (lpobj, pedit);

    if (pedit->hClient)
        DestroyWindow (pedit->hClient);

    if (lpobj->pSysEdit)
        LocalUnlock (lpobj->hSysEdit);

    if (lpobj->hSysEdit)
        LocalFree (lpobj->hSysEdit);

    lpobj->hSysEdit  = NULL;
    lpobj->pSysEdit = NULL;

    return;
}


void INTERNAL   SendStdExit (lpobj)
LPOBJECT_LE    lpobj;
{


    Puts("SendSrvrExit");

    if (!lpobj->pSysEdit)
        return;

    SrvrExecute (lpobj, MapStrToH ("[StdExit]"));

}

void INTERNAL   SendStdClose (lpobj)
LPOBJECT_LE    lpobj;
{


    Puts("SendDocClose");

    if (!lpobj->pDocEdit)
        return;

    DocExecute (lpobj, MapStrToH ("[StdCloseDocument]"));

}


// SrvrExecute: Sends execute command to system conversation.
BOOL INTERNAL SrvrExecute (lpobj, hdata)
LPOBJECT_LE    lpobj;
HANDLE      hdata;
{
    PEDIT_DDE   pedit = NULL;
    int         retval = FALSE;

    Puts("SrvrExecute");

#ifdef  FIREWALLS

    ASSERT (lpobj->hSysEdit, "Sys conv handle missing");
    ASSERT (lpobj->pSysEdit, "sys conv lptr is missing");

#endif
    pedit = lpobj->pSysEdit;

    if (hdata == NULL || pedit == NULL) {
        lpobj->subErr = OLE_ERROR_MEMORY;
        return FALSE;
    }

#ifdef  FIREWALLS
    ASSERT (!pedit->bTerminating, "In terminate state")
    ASSERT (pedit->awaitAck == NULL, "trying to Post msg while waiting for ack")
#endif

    if (lpobj->bOldLink) {
        GlobalFree (hdata);
        return TRUE;
    }


    if (PostMessageToServer (pedit, WM_DDE_EXECUTE, MAKELONG (0, hdata))) {
        // data is being freed in the acknowledge
        lpobj->bAsync    = TRUE;
        pedit->awaitAck = AA_EXECUTE;
        return TRUE;
    } else {
        lpobj->subErr = OLE_ERROR_COMMAND;
        GlobalFree (hdata);
        return FALSE;
    }
}

// StartConvDDE: Starts the document conversation for an object based on
// .app and .topic atoms.
BOOL FARINTERNAL InitDocConv (lpobj, fNetDlg)
LPOBJECT_LE lpobj;
BOOL        fNetDlg;
{

    // ### This routine looks very similar to IitSrvrConv
    // combine with the it

    HANDLE      hedit = NULL;
    PEDIT_DDE   pedit = NULL;
    char        buf[MAX_NET_NAME];
    int         nDrive = 2;     // drive C
    char        cOldDrive;

    Puts("InitDocConv");

    if (QueryOpen (lpobj)){
        DEBUG_OUT ("Attempt to start already existing conversation",0);
        return FALSE;
    }

    cOldDrive = lpobj->cDrive;
    if (CheckNetDrive (lpobj, fNetDlg) != OLE_OK)
        return FALSE;

    if (!lpobj->pDocEdit) {
        hedit = LocalAlloc (LMEM_MOVEABLE | LMEM_ZEROINIT, sizeof (EDIT_DDE));

        if (hedit == NULL || ((pedit = (PEDIT_DDE) LocalLock (hedit)) == NULL)){
            lpobj->subErr = OLE_ERROR_MEMORY;
            goto errRtn;
        }
    } else {
#ifdef  FIREWALLS
    ASSERT (!lpobj->pDocEdit->hClient, "Doc conv lptr is present");
#endif
        hedit  =  lpobj->hDocEdit;
        pedit =  lpobj->pDocEdit;
        UtilMemClr ((PSTR) pedit, sizeof (EDIT_DDE));
    }

    if ((pedit->hClient = CreateWindow ("OleDocWndClass", "Window Name",
        WS_OVERLAPPED,0,0,0,0,NULL,NULL, hInstDLL, NULL)) == NULL) {
        lpobj->subErr = OLE_ERROR_MEMORY;
        goto errRtn;
    }
    lpobj->hDocEdit     = hedit;
    lpobj->pDocEdit     = pedit;
    SetWindowLong (pedit->hClient, 0, (LONG)lpobj);

    // buf will filled by netname in the first call to SetNextNetDrive()
    buf[0] = '\0';
    do {
        pedit->awaitAck = AA_INITIATE;

        // !!! Where are the atom counts bumped?

        SendMessage (-1, WM_DDE_INITIATE, pedit->hClient,
                MAKELONG (lpobj->app, lpobj->topic));

        pedit->awaitAck = NULL;

        if (pedit->hServer) {
            if ((cOldDrive != lpobj->cDrive)
                    && (lpobj->asyncCmd != OLE_CREATEFROMFILE))
                ContextCallBack (lpobj, OLE_RENAMED);
            return TRUE;
        }

    } while ((lpobj->head.ctype == CT_LINK) && (lpobj->aNetName)
                && SetNextNetDrive (lpobj, &nDrive, buf)) ;

errRtn:
    if (cOldDrive != lpobj->cDrive) {
        // put back the old drive
        lpobj->cDrive = cOldDrive;
        ChangeTopic (lpobj);
    }

    if (pedit->hClient)
        DestroyWindow (pedit->hClient);

    if (pedit)
        LocalUnlock (hedit);

    if (hedit)
        LocalFree (hedit);

    lpobj->hDocEdit     = NULL;
    lpobj->pDocEdit     = NULL;
    return FALSE;
}


// Execute: Sends an execute string WM_DDE_EXECUTE to the document conversation.
BOOL INTERNAL DocExecute (lpobj, hdata)
LPOBJECT_LE    lpobj;
HANDLE          hdata;
{
    PEDIT_DDE  pedit;

    Puts("DocExecute");
    pedit = lpobj->pDocEdit;

    if (hdata == NULL || pedit == NULL)
        return FALSE;


#ifdef  FIREWALLS
    ASSERT (!pedit->bTerminating, "Execute: terminating")
    ASSERT (pedit->hClient, "Client null")
    ASSERT (IsWindowValid(pedit->hClient),"Invalid client")
    ASSERT (pedit->awaitAck == NULL, "trying to Post msg while waiting for ack")
#endif

    if (lpobj->bOldLink) {
        GlobalFree (hdata);
        return TRUE;
    }

    if (PostMessageToServer (pedit, WM_DDE_EXECUTE, MAKELONG (0, hdata))) {
        // data is being freed in the execute command
        pedit->awaitAck    = AA_EXECUTE;
        lpobj->bAsync       = TRUE;
        return TRUE;
    } else {
        lpobj->subErr    = OLE_ERROR_COMMAND;
        GlobalFree (hdata);
        return FALSE;
    }
}


// EndConvDDE: terminates the doc level conversation.
void INTERNAL TermDocConv (lpobj)
LPOBJECT_LE    lpobj;
{
    PEDIT_DDE pedit;

    Puts ("TermDocConv");

    DEBUG_OUT ("About to terminate convs from destroy",0)

    if (!(pedit = lpobj->pDocEdit))
        return;

    if (PostMessageToServer (pedit, WM_DDE_TERMINATE, 0)) {
        pedit->bTerminating = TRUE;
        lpobj->bAsync        = TRUE;
    } else
        lpobj->subErr = OLE_ERROR_TERMINATE;

    return;

}

// Deletes the document conversdation memory.
void INTERNAL DeleteDocEdit (lpobj)
LPOBJECT_LE    lpobj;
{

    PEDIT_DDE pedit;

    Puts ("DeleteDocEdit");

    if (!(pedit = lpobj->pDocEdit))
        return;

    // delete any data if we were in busy mode.
    DeleteBusyData (lpobj, pedit);

    // Delete if any data blocks.
    if (pedit->hClient)
        DestroyWindow (pedit->hClient);

    if (lpobj->pDocEdit)
        LocalUnlock (lpobj->hDocEdit);

    if (lpobj->hDocEdit)
        LocalFree (lpobj->hDocEdit);

    lpobj->hDocEdit  = NULL;
    lpobj->pDocEdit = NULL;

    return;
}


// LeLauchApp: Launches app based on the ClassName in lpobj.
HANDLE INTERNAL  LeLaunchApp (lpobj)
LPOBJECT_LE lpobj;
{
    struct CMDSHOW
    {
        WORD first;
        WORD second;
    } cmdShow = {2, SW_SHOWNORMAL};

    struct
    {
        WORD wEnvSeg;
        LPSTR lpcmdline;
        struct CMDSHOW FAR *lpCmdShow;
        DWORD dwReserved;
    } paramBlock;

    char    cmdline[MAX_STR];
    char    exeName[MAX_STR];
#ifdef WIN32S
    char    execCmdLine[MAX_STR];
#endif
    HANDLE  hInst;

    #define EMB_STR     " -Embedding "

    Puts("LeLaunchApp");

    GlobalGetAtomName (lpobj->aServer, exeName, MAX_STR);

    if (lpobj->bOldLink) {
        cmdShow.second = SW_SHOWMINIMIZED;
        cmdline[0] = ' ';
        GlobalGetAtomName (lpobj->topic, cmdline + 1, MAX_STR);
    } else {
        lstrcpy ((LPSTR)cmdline, (LPSTR) EMB_STR);

        // For all link servers we want to give the filename on the command
        // line. But Excel is not registering the document before returning
        // from WinMain, if it has auto load macros. So, we want send StdOpen
        // for the old servers, instead of giving the file name on the command
        // line.

        if (lpobj->bOleServer && (lpobj->fCmd & LN_MASK) == LN_LNKACT)
            GlobalGetAtomName (lpobj->topic, cmdline+sizeof(EMB_STR)-1,
                    MAX_STR-sizeof(EMB_STR));
        if (lpobj->fCmd & ACT_MINIMIZE)
            cmdShow.second = SW_SHOWMINIMIZED;
        else if (!(lpobj->fCmd & (ACT_SHOW | ACT_DOVERB))
                    // we want to launch with show in create invisible case
                    // even though ACT_SHOW flag will be false
                    && ((lpobj->fCmd & LN_MASK) != LN_NEW))
            cmdShow.second = SW_HIDE;
    }

    paramBlock.wEnvSeg      = NULL;
    paramBlock.lpcmdline    = (LPSTR)cmdline;
    paramBlock.lpCmdShow    = &cmdShow;
    paramBlock.dwReserved   = NULL;

#ifdef WIN32S
    if (wWinVer != 0x0003) {
        lstrcpy( (LPSTR)execCmdLine, (LPSTR)exeName);
        lstrcat( (LPSTR)execCmdLine, (LPSTR)" ");
        lstrcat( (LPSTR)execCmdLine, (LPSTR)paramBlock.lpcmdline);
        if ((hInst =  WinExec ((LPSTR)execCmdLine, cmdShow.second)) <= 32)
            hInst = NULL;
    } else
#endif
    if ((hInst =  LoadModule ((LPSTR)exeName, &paramBlock)) <= 32)
        hInst = NULL;

    if (!hInst) {
        LPSTR   lptmp;
        char    ch;

        // strip off the path and try again
        lptmp = (LPSTR)exeName;
        lptmp += lstrlen ((LPSTR) exeName);
        ch = *lptmp;
        while (ch != '\\' && ch != ':') {
            if (lptmp == (LPSTR) exeName) {
                // exe did not have path in it's name. we already tried
                // loading and it failed, no point trying again.
                return NULL;
            }
            else
                ch = *--lptmp;
        }

#ifdef WIN32S
        if (wWinVer != 0x0003) {
            lstrcpy( (LPSTR)execCmdLine, (LPSTR)++lptmp);
            lstrcat( (LPSTR)execCmdLine, (LPSTR)" ");
            lstrcat( (LPSTR)execCmdLine, (LPSTR)paramBlock.lpcmdline);
            if ((hInst =  WinExec ((LPSTR)execCmdLine, cmdShow.second)) <= 32)
                hInst = NULL;
        } else
#endif
        if ((hInst =  LoadModule (++lptmp, &paramBlock)) <= 32)
            hInst = NULL;
    }

    return hInst;
}



//ScanItemOptions: Scan for the item options like Close/Save etc.

int INTERNAL ScanItemOptions (aItem, lpoptions)
ATOM    aItem;
int far *lpoptions;
{

    ATOM    aModifier;

    LPSTR   lpbuf;
    char    buf[MAX_STR];

    *lpoptions = OLE_CHANGED;

    if (!aItem) {
        // NULL item with no modifier means OLE_CHANGED for NULL item
        return OLE_OK;
    }

    GlobalGetAtomName (aItem, (LPSTR)buf, MAX_STR);
    lpbuf = (LPSTR)buf;

    while ( *lpbuf && *lpbuf != '/')
           lpbuf++;

    // no modifier same as /change

    if (*lpbuf == NULL)
        return OLE_OK;

    *lpbuf++ = NULL;        // seperate out the item string
                            // We are using this in the caller.

    if (!(aModifier = GlobalFindAtom (lpbuf)))
        return OLE_ERROR_SYNTAX;

    if (aModifier == aChange)
        return OLE_OK;

    // Is it a save?
    if (aModifier == aSave){
        *lpoptions = OLE_SAVED;
        return  OLE_OK;
    }
    // Is it a Close?
    if (aModifier == aClose){
        *lpoptions = OLE_CLOSED;
        return OLE_OK;
    }

    // unknown modifier
    return OLE_ERROR_SYNTAX;

}

void   INTERNAL   ChangeDocName (lpobj, lpdata)
LPOBJECT_LE     lpobj;
LPSTR           lpdata;
{
    ATOM        aOldTopic;
    OLESTATUS   retVal;

    aOldTopic = lpobj->topic;
    lpobj->topic = GlobalAddAtom (lpdata);
    if ((retVal = SetNetName (lpobj)) != OLE_OK) {
        if (lpobj->topic)
            GlobalDeleteAtom (lpobj->topic);
        lpobj->topic = aOldTopic;
        return;
        // !!! what should we do in case of error? Currently, we will not
        // change the topic if SetNetName fails.
    }

    if (aOldTopic)
        GlobalDeleteAtom (aOldTopic);

    // Delete the link data block
    if (lpobj->hLink) {
        GlobalFree (lpobj->hLink);
        lpobj->hLink = NULL;
    }

    ContextCallBack (lpobj, OLE_RENAMED);

}


BOOL INTERNAL CanCallback (lpobj, options)
LPOBJECT_LE lpobj;
int         options;
{
    LPINT    lpCount;

    if (options == OLE_CLOSED) {
        lpobj->bSvrClosing = TRUE;
        lpCount = &(lpobj->pDocEdit->nAdviseClose);
    }
    else if (options == OLE_SAVED) {
        if (lpobj->head.ctype == CT_LINK)
            return TRUE;
        lpCount = &(lpobj->pDocEdit->nAdviseSave);
    }
    else {
        // it must be due to request
        if ((lpobj->pDocEdit->awaitAck == AA_REQUEST)
                && lpobj->pDocEdit->bCallLater)
            return FALSE;

        return TRUE;
    }

    switch (*lpCount) {
        case 1:
            break;

        case 2:
            ++(*lpCount);
            return FALSE;

        case 3:
            --(*lpCount);
            break;

        default:
            return FALSE;
    }

    return TRUE;
}


void  FARINTERNAL CallEmbLnkDelete (lpobj)
LPOBJECT_LE lpobj;
{
    InitAsyncCmd (lpobj, OLE_SERVERUNLAUNCH,EMBLNKDELETE);
    EmbLnkDelete (lpobj);

    if (lpobj->head.ctype == CT_EMBEDDED) {
        lpobj->bSvrClosing = TRUE;
        ContextCallBack (lpobj, OLE_CLOSED);
        if (FarCheckObject ((LPOLEOBJECT)lpobj))
            lpobj->bSvrClosing = FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\ole\client\cmacs.h ===
/****************************** Module Header ******************************\
* Module Name: CMACS.H
*
* This module contains common macros used by C routines.
*
* Created: 9-Feb-1989
*
* Copyright (c) 1985 - 1989  Microsoft Corporation
*
* History:
*   Created by Raor
*
\***************************************************************************/

#undef _WINDOWS
#define _WINDOWS
#define  DLL_USE

#define INTERNAL        PASCAL NEAR
#define FARINTERNAL     PASCAL FAR

#ifdef FIREWALLS
extern short ole_flags;

#define DEBUG_PUTS          0x01
#define DEBUG_DEBUG_OUT     0x02
#define DEBUG_MESSAGEBOX    0x04

extern char    szDebugBuffer[];

#define DEBUG_OUT(parm1,parm2){\
    if(ole_flags & DEBUG_DEBUG_OUT){\
            wsprintf(szDebugBuffer,parm1,parm2);\
        OutputDebugString(szDebugBuffer);\
            OutputDebugString ("^^^  ");\
        }\
    }

#define ASSERT(x,y) {\
    if (!(x)) { \
        wsprintf (szDebugBuffer, "Assert Failure file %s, line %d\r\n     ", \
            (LPSTR) __FILE__, __LINE__);\
        OutputDebugString (szDebugBuffer);\
        OutputDebugString ((LPSTR) (y));\
        OutputDebugString ("@@@  ");\
    } \
}

#define Puts(msg) {\
                    if(ole_flags & DEBUG_PUTS){\
                        OutputDebugString ((LPSTR)(msg));\
                        OutputDebugString ("**  ");\
                    }\
                  }

#else

#define DEBUG_OUT(err, val) ;
#define ASSERT(cond, msg)
#define Puts(msg)

#endif /* FIREWALLS */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\mmsystem\mmtask\mmtask.asm ===
PAGE 58,132
;*****************************************************************************
TITLE MMTASK.ASM - Windows MultiMedia Systems Task Stub
;*****************************************************************************
;
;   Copyright (C) Microsoft Corporation 1985-1990. All rights reserved.
;
;   Title:      MMTASK.asm - a windows application that acts as a
;               task stub.
;
;   Version:    1.00
;
;   Date:       12-Mar-1990
;
;   Author:     ROBWI
;
;-----------------------------------------------------------------------------
;
;   Change log:
;
;      DATE     REV            DESCRIPTION
;   ----------- ---   --------------------------------------------------------
;   12-Mar-1990 ROBWI First Version 
;   18-APR-1990 ROBWI Moved from idle.asm to mmtask.asm
;
;=============================================================================


?WIN=0
?PLM=1

    
    PMODE = 1
    
    .xlist
    include cmacros.inc
    .list

wptr equ WORD PTR

; The following structure should be used to access high and low
; words of a DWORD.  This means that "word ptr foo[2]" -> "foo.hi".

LONG    struc
lo      dw      ?
hi      dw      ?
LONG    ends

FARPOINTER      struc
off     dw      ?
sel     dw      ?
FARPOINTER      ends


;----------------------------------------------------------------------
;
; MMTASKSTRUC : The following structure should be passed to mmtask (in
; the command line) when it is exec'd.


MMTASKSTRUC       struc
lpfn    dd      ?           ; fp to function to call. 
inst    dd      ?           ; instance data to pass to lpfn
dwstck  dd      ?           ; stack size.
MMTASKSTRUC       ends

EXIT_PROCESS equ 1

;-----------------------------------------------------------------------;
;
; externals from KERNEL

        externFP    WaitEvent
        externFP    PostEvent
        externFP    OldYield
        externFP    InitTask
        externFP    InitApp     ; to get a msg q so that we can call user
        externFP    OutputDebugString

        externFP    SetMessageQueue


sBegin  DATA
assumes DS,DATA

; Stuff needed to avoid the C runtime coming in

            DD  0               ; So null pointers get 0
maxRsrvPtrs = 5
            DW  maxRsrvPtrs
usedRsrvPtrs = 0
labelDP     <PUBLIC,rsrvptrs>

DefRsrvPtr  MACRO   name
globalW     name,0
usedRsrvPtrs = usedRsrvPtrs + 1
ENDM

DefRsrvPtr  pLocalHeap          ; Local heap pointer
DefRsrvPtr  pAtomTable          ; Atom table pointer
DefRsrvPtr  pStackTop           ; top of stack
DefRsrvPtr  pStackMin           ; minimum value of SP
DefRsrvPtr  pStackBot           ; bottom of stack

if maxRsrvPtrs-usedRsrvPtrs
            DW maxRsrvPtrs-usedRsrvPtrs DUP (0)
endif

public  __acrtused
	__acrtused = 1

loadparams  DB  (SIZE MMTASKSTRUC) DUP (0)

sEnd        DATA


sBegin Code
        assumes cs, Code
        assumes ds, Data
        assumes es, nothing
        assumes ss, nothing

;--------------------------Private-Routine-----------------------------;
;
; @doc      INTERNAL    MMTASKAPP
; 
; @asm      AppEntry | called when the APP is loaded
;
;   @reg      CX    | size of heap
;   @reg      DI    | module handle
;   @reg      DS    | automatic data segment
;   @reg      ES:SI | address of command line (not used)
;   @reg     
; 
; @rdesc    Register values at return
;
;   @reg      AX | 1 if success, 0 if error
; 
; @uses     AX BX CX DX FLAGS
;
; @comm     Preserves: SI DI DS BP
; 
;           Calls: None
;       
;           History:
;
;           06-27-89 -by-       Todd Laney [ToddLa] Created shell appentry 
;                               routine
;           03-13-90 -stolen-   Rob Williams [RobWi] Added all kinds o'
;                               stuff for making it an MMTASK application.
;
;-----------------------------------------------------------------------;
cProc   AppEntry,<FAR,PUBLIC,NODATA>,<>

cBegin

; Copy the parameters out of the command line before
; InitTask gets a chance to modify them.

        push    di                            
        push    si
        push    cx

; switch ds and es so that we can do a string move
; into the data segment

        push    ds                      ; save ds o
        mov     ax, es                  
        mov     ds, ax                  ; ds = es 0
        pop     es                      ; es = ds 0

; copy the command line if it is the correct length

        mov     si, 81h
        lea     di, loadparams
        mov     cx, SIZE MMTASKSTRUC / 2
        xor     ax, ax
        mov     al, byte ptr ds:[80h]
        shr     ax, 1
        cmp     ax, cx                  ; Q: structure size correct
        jne     Skip_Copy               ;    N: Skip the copy

.ERRNZ SIZE MMTASKSTRUC MOD 2

        cld                             ;    Y: Copy the structure
        rep     movsw

Skip_Copy:

; restore original es and ds
        
        push    es
        mov     ax, ds
        mov     es, ax                  ; es = ds = es 0
        pop     ds
        pop     cx
        pop     si
        pop     di

; pretend the command string is 0 length.

        xor     ax, ax
        mov     es:[80h], ax

; initialize the task and the event queue
        
        cCall   InitTask
        cCall   InitApp, <di>

        cCall   SetMessageQueue, <64>
        or      ax,ax
        jz      MMTASKexit

; DX is now the CmdShow value. 
; CX is stack size.

; event count is initially one so call waitevent to clear the event count

        cCall   WaitEvent, <0>  

; check parameters
        
        mov     dx, loadparams.lpfn.hi
        or      dx, dx                  ; callback ok?
        jz      MMTASKExit              ; N: out'a here

        cCall   OldYield                ; be polite.

        mov     ax, loadparams.inst.lo
        mov     dx, loadparams.inst.hi
        cCall   loadparams.lpfn, <dx, ax>

MMTASKExit:

ifdef DEBUG
        ; lets make sure the app did not do anything evil

        cmp     wptr ds:[0],0
        jne     evil
        cmp     wptr ds:[2],0
        jne     evil
        cmp     wptr ds:[4],5
        jne     evil
        je      not_evil
evil:
        lea     ax,evil_str
        cCall   OuputDebugString, <cs,ax>
        int 3
        jmp     not_evil
evil_str:
        db      "MMTASK: NULL pointer assignment!",13,10,0
not_evil:
endif
        ; before we actualy exit lets yield, so we don't re-enter
        ; USERS AppExit code.....

        cCall   OldYield
        cCall   OldYield
        cCall   OldYield

        mov     ah, 4Ch
        int     21h
cEnd

sEnd

end     AppEntry
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\ole\client\bm.c ===
/****************************** Module Header ******************************\
* Module Name: BM.C
*
* Handles all API routines for the bitmap sub-dll of the ole dll.
*
* Created: 1990
*
* Copyright (c) 1990, 1991  Microsoft Corporation
*
* History:
*   Raor,Srinik  (../../1990,91)    Designed, coded
*
\***************************************************************************/

#include <windows.h>
#include "dll.h"
#include "pict.h"

extern int   maxPixelsX, maxPixelsY;
void INTERNAL GetHimetricUnits(HBITMAP, LPPOINT);

#pragma alloc_text(_TEXT, BmSaveToStream, BmStreamWrite, BmLoadFromStream, BmStreamRead, GetBytes, PutBytes, PutStrWithLen, BmQueryBounds, BmChangeData, BmCopy, BmDuplicate, BmUpdateStruct, GetHimetricUnits)


OLEOBJECTVTBL    vtblBM  = {

        ErrQueryProtocol,  // check whether the speced protocol is supported

        BmRelease,         // Release
        ErrShow,           // Show
        ErrPlay,           // play
        BmGetData,         // Get the object data
        ErrSetData,        // Set the object data
        ErrSetTargetDevice,//
    
        ErrSetBounds,      // set viewport bounds
        BmEnumFormat,      // enumerate supported formats
        ErrSetColorScheme, //   
        BmRelease,         // delete
        ErrSetHostNames,   //

        BmSaveToStream,    // write to file
        BmClone,           // clone object
        ErrCopyFromLink,   // Create embedded from Link

        BmEqual,           // compares the given objects for data equality

        BmCopy,            // copy to clip

        BmDraw,            // draw the object
            
        ErrActivate,       // open
        ErrExecute,        // excute 
        ErrClose,          // Stop
        ErrUpdate,         // Update
        ErrReconnect,      // Reconnect

        ErrObjectConvert,  // convert object to specified type

        ErrGetUpdateOptions,// update options
        ErrSetUpdateOptions,// update options

        ObjRename,         // Change Object name
        ObjQueryName,      // Get current object name

        ObjQueryType,      // Object type
        BmQueryBounds,     // QueryBounds
        ObjQuerySize,      // Find the size of the object
        ErrQueryOpen,      // Query open
        ErrQueryOutOfDate, // query whether object is current
            
        ErrQueryRelease,      // release related stuff
        ErrQueryRelease,
        ErrQueryRelease,

        ErrRequestData,    // requestdata
        ErrObjectLong,     // objectLong
        BmChangeData        // change data of the existing object
};



OLESTATUS  FARINTERNAL BmRelease (lpobj)
LPOBJECT_BM     lpobj;
{
    HOBJECT hobj;

    if (lpobj->hBitmap) {
        DeleteObject (lpobj->hBitmap);
        lpobj->hBitmap = NULL;
    }

    if (lpobj->head.lhclientdoc)
        DocDeleteObject ((LPOLEOBJECT) lpobj);
    
    if (hobj = lpobj->head.hobj){
        lpobj->head.hobj = NULL;
        GlobalUnlock (hobj);
        GlobalFree (hobj);
    }

    return OLE_OK;
}



OLESTATUS FARINTERNAL BmSaveToStream (lpobj, lpstream)
LPOBJECT_BM     lpobj;
LPOLESTREAM     lpstream;
{
    if (!lpobj->hBitmap || !lpobj->sizeBytes)
        return OLE_ERROR_BLANK;
    
    if (PutBytes (lpstream, (LPSTR) &dwVerToFile, sizeof(LONG)))
        return OLE_ERROR_STREAM;

    if (PutBytes (lpstream, (LPSTR) &lpobj->head.ctype, sizeof(LONG)))
        return  OLE_ERROR_STREAM;

    if (PutStrWithLen(lpstream, (LPSTR)"BITMAP"))
        return OLE_ERROR_STREAM;

    if (!PutBytes (lpstream, (LPSTR) &lpobj->head.cx, sizeof(LONG))) {
        if (!PutBytes (lpstream, (LPSTR) &lpobj->head.cy, sizeof(LONG)))
            if (!PutBytes (lpstream, (LPSTR) &lpobj->sizeBytes, sizeof(DWORD)))
            return BmStreamWrite (lpstream, lpobj);
    }
    return OLE_ERROR_STREAM;
}


OLESTATUS FARINTERNAL  BmClone (lpobjsrc, lpclient, lhclientdoc, lpobjname, lplpobj)
LPOBJECT_BM         lpobjsrc;
LPOLECLIENT         lpclient;
LHCLIENTDOC         lhclientdoc;
LPSTR               lpobjname;
LPOBJECT_BM  FAR *  lplpobj;
{
    if (!CheckClientDoc ((LPCLIENTDOC)lhclientdoc))
        return OLE_ERROR_HANDLE;
    
    if (!(*lplpobj = BmCreateObject (lpobjsrc->hBitmap, lpclient, FALSE,
                            lhclientdoc, lpobjname, lpobjsrc->head.ctype)))
        return OLE_ERROR_MEMORY;
    else
        return OLE_OK;
}


OLESTATUS FARINTERNAL  BmEqual (lpobj1, lpobj2)
LPOBJECT_BM lpobj1;
LPOBJECT_BM lpobj2;
{
    HANDLE      hBits1 = NULL, hBits2 = NULL;
    LPSTR       lpBits1 = NULL, lpBits2 = NULL;
    OLESTATUS   retVal;
    DWORD       dwBytes1, dwBytes2;

    if (lpobj1->sizeBytes != lpobj2->sizeBytes)
        return OLE_ERROR_NOT_EQUAL;
    
    retVal = OLE_ERROR_MEMORY;
    
    if (!(hBits1 = GlobalAlloc (GMEM_MOVEABLE, lpobj1->sizeBytes)))
        goto errEqual;
    
    if (!(lpBits1 = GlobalLock (hBits1)))
        goto errEqual;
    
    if (!(hBits2 = GlobalAlloc (GMEM_MOVEABLE, lpobj2->sizeBytes)))
        goto errEqual;
    
    if (!(lpBits2 = GlobalLock (hBits2)))
        goto errEqual;
        
    dwBytes1 = GetBitmapBits (lpobj1->hBitmap, lpobj1->sizeBytes, lpBits1);
    dwBytes2 = GetBitmapBits (lpobj2->hBitmap, lpobj2->sizeBytes, lpBits2);
    
    if (dwBytes1 != dwBytes2) {
        retVal = OLE_ERROR_NOT_EQUAL;
        goto errEqual;
    }
    
    // !!! UtilMemCmp has to be redone for >64k bitmaps
    if (UtilMemCmp (lpBits1, lpBits2, dwBytes1))
        retVal = OLE_ERROR_NOT_EQUAL;
    else
        retVal = OLE_OK;

errEqual:   
    if (lpBits1)
        GlobalUnlock (hBits1);
    
    if (lpBits2)
        GlobalUnlock (hBits2);
    
    if (hBits1)
        GlobalFree (hBits1);
    
    if (hBits2)
        GlobalFree (hBits2);
    
    return retVal;
}



OLESTATUS FARINTERNAL BmCopy (lpobj)
LPOBJECT_BM lpobj;
{
    HBITMAP hBitmap;
    DWORD   size;
    
    if (!lpobj->hBitmap)
        return OLE_ERROR_BLANK;

    if(!(hBitmap = BmDuplicate (lpobj->hBitmap, &size, NULL)))
        return OLE_ERROR_MEMORY;

    SetClipboardData(CF_BITMAP, hBitmap);
    return OLE_OK;
}


OLESTATUS FARINTERNAL BmQueryBounds (lpobj, lpRc)
LPOBJECT_BM     lpobj;
LPRECT          lpRc;
{
    Puts("BmQueryBounds");
    
    if (!lpobj->hBitmap)
        return OLE_ERROR_BLANK;

    lpRc->left      = 0;
    lpRc->top       = 0;
    lpRc->right     = (int) lpobj->head.cx;
    lpRc->bottom    = (int) lpobj->head.cy;
    return OLE_OK;
}



OLECLIPFORMAT FARINTERNAL BmEnumFormat (lpobj, cfFormat)
LPOBJECT_BM lpobj;
OLECLIPFORMAT    cfFormat;
{
    if (!cfFormat)
        return CF_BITMAP;
    
    return NULL;
}



OLESTATUS FARINTERNAL BmGetData (lpobj, cfFormat, lphandle)
LPOBJECT_BM     lpobj;
OLECLIPFORMAT   cfFormat;
LPHANDLE        lphandle;
{
    if (cfFormat != CF_BITMAP) 
        return OLE_ERROR_FORMAT;
    
    if (!(*lphandle = lpobj->hBitmap))
        return OLE_ERROR_BLANK;
    return OLE_OK;

}




OLESTATUS FARINTERNAL BmLoadFromStream (lpstream, lpclient, lhclientdoc, lpobjname, lplpoleobject, objType)
LPOLESTREAM         lpstream;
LPOLECLIENT         lpclient;
LHCLIENTDOC         lhclientdoc;
LPSTR               lpobjname;
LPOLEOBJECT FAR *   lplpoleobject;
LONG                objType;
{
    LPOBJECT_BM lpobj = NULL;

    *lplpoleobject = NULL;

    if (!(lpobj = BmCreateBlank (lhclientdoc, lpobjname, objType)))
        return OLE_ERROR_MEMORY;

    lpobj->head.lpclient = lpclient;

    if (!GetBytes (lpstream, (LPSTR) &lpobj->head.cx, sizeof(LONG))) {
        if (!GetBytes (lpstream, (LPSTR) &lpobj->head.cy, sizeof(LONG))) 
            if (!GetBytes (lpstream, (LPSTR) &lpobj->sizeBytes, sizeof(DWORD))) 
            if (BmStreamRead (lpstream, lpobj)) {
                *lplpoleobject = (LPOLEOBJECT)lpobj;
                return OLE_OK;
            }
    }
    
    OleDelete ((LPOLEOBJECT)lpobj);
    return OLE_ERROR_STREAM;;
}



OLESTATUS INTERNAL BmStreamWrite (lpstream, lpobj)
LPOLESTREAM     lpstream;
LPOBJECT_BM     lpobj;
{
    HANDLE      hBits;
    LPSTR       lpBits;
    int         retVal = OLE_ERROR_STREAM;
    BITMAP      bm;
    DWORD       dwSize;  // size of bit array

    dwSize = lpobj->sizeBytes - sizeof(BITMAP);
    
    if (hBits = GlobalAlloc (GMEM_MOVEABLE, dwSize)) {
        if (lpBits = (LPSTR) GlobalLock (hBits)) {
            if (GetBitmapBits (lpobj->hBitmap, dwSize, lpBits)) {
                GetObject (lpobj->hBitmap, sizeof(BITMAP), (LPSTR) &bm);
                if (!PutBytes (lpstream, (LPSTR) &bm, sizeof(BITMAP)))
                    if (!PutBytes (lpstream, (LPSTR) lpBits, dwSize))
                        retVal = OLE_OK;
            }
            GlobalUnlock(hBits);
        } else
            retVal = OLE_ERROR_MEMORY;
        GlobalFree(hBits);
    } else
        retVal = OLE_ERROR_MEMORY;

    return retVal;
}



BOOL INTERNAL BmStreamRead (lpstream, lpobj)
LPOLESTREAM     lpstream;
LPOBJECT_BM     lpobj;
{
    HANDLE      hBits;
    LPSTR       lpBits;
    BOOL        retVal = FALSE;
    BITMAP      bm;
    POINT       point;

    if (GetBytes (lpstream, (LPSTR)&bm, sizeof(BITMAP)))
        return FALSE;

    lpobj->sizeBytes = ((DWORD) bm.bmHeight) * ((DWORD) bm.bmWidthBytes) * 
                       ((DWORD) bm.bmPlanes) * ((DWORD) bm.bmBitsPixel);
    
    if (hBits = GlobalAlloc (GMEM_MOVEABLE, lpobj->sizeBytes)) {
        if (lpBits = (LPSTR) GlobalLock (hBits)) {
            if (!GetBytes(lpstream, lpBits, lpobj->sizeBytes)) {
                if (lpobj->hBitmap = CreateBitmap (bm.bmWidth,
                                            bm.bmHeight,
                                            bm.bmPlanes, 
                                            bm.bmBitsPixel, 
                                            lpBits)) {
                    retVal = TRUE;
                    lpobj->xSize = point.x = bm.bmWidth;
                    lpobj->ySize = point.y = bm.bmHeight;
                    
                    // size of (bitmap header + bits)
                    lpobj->sizeBytes += sizeof(BITMAP);
#ifdef OLD                    
                    // !!! We shouldn't do the conversion. The info should be
                    // part of the stream.
                    if (!lpobj->head.cx) {
                        ConvertToHimetric (&point);
                        lpobj->head.cx = (LONG) point.x;
                        lpobj->head.cy = (LONG) point.y;
                    }
#endif                  
                 }
             }
             GlobalUnlock(hBits);
        }
        GlobalFree(hBits);
    }
    return  retVal;
}


OLESTATUS FARINTERNAL BmPaste (lpclient, lhclientdoc, lpobjname, lplpoleobject, objType)
LPOLECLIENT         lpclient;
LHCLIENTDOC         lhclientdoc;
LPSTR               lpobjname;
LPOLEOBJECT FAR *   lplpoleobject;
LONG                objType;
{
    HBITMAP     hBitmap;

    *lplpoleobject = NULL;

    if ((hBitmap = (HBITMAP) GetClipboardData(CF_BITMAP)) == NULL)
        return OLE_ERROR_MEMORY;

    if (!(*lplpoleobject = (LPOLEOBJECT) BmCreateObject (hBitmap, 
                                                lpclient, FALSE, lhclientdoc,
                                                lpobjname, objType)))
        return OLE_ERROR_MEMORY;
    
    return OLE_OK;

}


LPOBJECT_BM INTERNAL BmCreateObject (hBitmap, lpclient, fDelete, lhclientdoc, lpobjname, objType)
HBITMAP     hBitmap;
LPOLECLIENT lpclient;
BOOL        fDelete;
LHCLIENTDOC lhclientdoc;
LPSTR       lpobjname;
LONG        objType;
{
    LPOBJECT_BM     lpobj;
    
    if (lpobj = BmCreateBlank (lhclientdoc, lpobjname, objType)) {
        if (BmChangeData (lpobj, hBitmap, lpclient, fDelete) != OLE_OK) {
            BmRelease (lpobj);
            lpobj = NULL;
        }
    }

    return lpobj;
}


// If the routine fails then the object will be left with it's old data.
// If fDelete is TRUE, then hNewBitmap will be deleted whether the routine
// is successful or not.

OLESTATUS FARINTERNAL BmChangeData (lpobj, hNewBitmap, lpclient, fDelete)
LPOBJECT_BM lpobj;
HBITMAP     hNewBitmap;
LPOLECLIENT lpclient;
BOOL        fDelete;
{
    BITMAP      bm;
    DWORD       dwSize;
    HBITMAP     hOldBitmap;
    
    hOldBitmap = lpobj->hBitmap; 

    if (!fDelete) {
        if (!(hNewBitmap = BmDuplicate (hNewBitmap, &dwSize, &bm)))
            return OLE_ERROR_MEMORY;
    }
    else {
        if (!GetObject (hNewBitmap, sizeof(BITMAP), (LPSTR) &bm)) {
            DeleteObject (hNewBitmap);
            return OLE_ERROR_MEMORY;
        }

        dwSize = ((DWORD) bm.bmHeight) * ((DWORD) bm.bmWidthBytes) * 
                 ((DWORD) bm.bmPlanes) * ((DWORD) bm.bmBitsPixel);
    }

    BmUpdateStruct (lpobj, lpclient, hNewBitmap, &bm, dwSize);
    if (hOldBitmap)
        DeleteObject (hOldBitmap);
    
    return OLE_OK;
}


void INTERNAL BmUpdateStruct (lpobj, lpclient, hBitmap, lpBm, dwBytes)
LPOBJECT_BM lpobj;
LPOLECLIENT lpclient;
HBITMAP     hBitmap;
LPBITMAP    lpBm;
DWORD       dwBytes;
{
    POINT       point;

    lpobj->head.lpclient = lpclient;
    lpobj->xSize = point.x = lpBm->bmWidth;
    lpobj->ySize = point.y = lpBm->bmHeight;
    GetHimetricUnits (hBitmap, &point);
    lpobj->head.cx = (LONG) point.x;
    lpobj->head.cy = (LONG) point.y;
    lpobj->sizeBytes = dwBytes + sizeof(BITMAP);
    lpobj->hBitmap = hBitmap;
}



LPOBJECT_BM FARINTERNAL BmCreateBlank (lhclientdoc, lpobjname, objType)
LHCLIENTDOC lhclientdoc;
LPSTR       lpobjname;
LONG        objType;
{
    HOBJECT hobj;
    LPOBJECT_BM lpobj;

    if ((hobj = GlobalAlloc (GMEM_MOVEABLE|GMEM_ZEROINIT,sizeof (OBJECT_BM)))
            == NULL)
        return NULL;

    if (!(lpobj = (LPOBJECT_BM) GlobalLock (hobj))){
        GlobalFree (hobj);
        return NULL;
    }

    lpobj->head.objId[0]    = 'L';
    lpobj->head.objId[1]    = 'E';
    lpobj->head.mm          = MM_TEXT;
    lpobj->head.ctype       = objType;
    lpobj->head.lpvtbl      = (LPOLEOBJECTVTBL)&vtblBM;
    lpobj->head.iTable      = INVALID_INDEX;
    lpobj->head.hobj        = hobj;
    
    if (objType == CT_STATIC) 
        DocAddObject ((LPCLIENTDOC) lhclientdoc, 
                    (LPOLEOBJECT) lpobj, lpobjname);

    return lpobj;
}



HBITMAP FARINTERNAL BmDuplicate (hold, lpdwSize, lpBm)
HBITMAP     hold;
DWORD FAR * lpdwSize;
LPBITMAP    lpBm;
{
    HBITMAP     hnew;
    HANDLE      hMem;
    LPSTR       lpMem;
    LONG        retVal = TRUE;
    DWORD       dwSize;
    BITMAP      bm;
    DWORD       dwExtents = NULL;
    
     // !!! another way to duplicate the bitmap

    GetObject (hold, sizeof(BITMAP), (LPSTR) &bm);
    dwSize = ((DWORD) bm.bmHeight) * ((DWORD) bm.bmWidthBytes) * 
             ((DWORD) bm.bmPlanes) * ((DWORD) bm.bmBitsPixel);

    if (!(hMem = GlobalAlloc (GMEM_MOVEABLE, dwSize)))
        return NULL;

    if (!(lpMem = GlobalLock (hMem))){
        GlobalFree (hMem);
        return NULL;
    }
    
    GetBitmapBits (hold, dwSize, lpMem);
    if (hnew = CreateBitmap (bm.bmWidth, bm.bmHeight, 
                    bm.bmPlanes, bm.bmBitsPixel, NULL))
        retVal = SetBitmapBits (hnew, dwSize, lpMem);

    GlobalUnlock (hMem);
    GlobalFree (hMem);

    if (hnew && (!retVal)) {
        DeleteObject (hnew);
        hnew = NULL;
    }
    *lpdwSize = dwSize;
    if (lpBm)
        *lpBm = bm;
    
    if (dwExtents = GetBitmapDimension (hold))
        SetBitmapDimension (hnew, LOWORD(dwExtents), HIWORD(dwExtents));
        
    return hnew;
}


void INTERNAL GetHimetricUnits(HBITMAP hBitmap, LPPOINT lpPoint)
{
    HDC     hdc;
    DWORD   dwDim;
    
    if (dwDim = GetBitmapDimension (hBitmap)) {
        lpPoint->x = 10 * LOWORD(dwDim);
        lpPoint->y = - (10 * HIWORD(dwDim));
        return;
    }
    
    // clip if it exceeds maxPixels. Note that we have a limitation of 
    // 0x8FFF HIMETRIC units in OLE1.0
        
    if (lpPoint->x > maxPixelsX)
        lpPoint->x = maxPixelsX;
    
    if (lpPoint->y > maxPixelsY)
        lpPoint->y = maxPixelsY;
    
    if (hdc = GetDC (NULL)) {
        lpPoint->x = MulDiv (lpPoint->x, 2540, 
                         GetDeviceCaps (hdc, LOGPIXELSX));
        lpPoint->y = - MulDiv (lpPoint->y, 2540,
                         GetDeviceCaps (hdc, LOGPIXELSY));
        ReleaseDC (NULL, hdc);
    }
    else {
        lpPoint->x = 0;
        lpPoint->y = 0;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\ole\client\dib.c ===
/****************************** Module Header ******************************\
* Module Name: DIB.C
*
* Handles all API routines for the device independent bitmap sub-dll of 
* the ole dll.
*
* Created: Oct-1990
*
* Copyright (c) 1990, 1991  Microsoft Corporation
*
* History:
*   Srinik, Raor  (../../1990,91)   Designed, coded
*
\***************************************************************************/

#include <windows.h>
#include "dll.h"
#include "pict.h"

void FARINTERNAL DibGetExtents (LPSTR, LPPOINT);

#pragma alloc_text(_TEXT, DibSaveToStream, DibLoadFromStream, DibStreamRead, GetBytes, PutBytes, PutStrWithLen, DibGetExtents)

OLEOBJECTVTBL    vtblDIB  = {

        ErrQueryProtocol,   // check whether the speced protocol is supported

        DibRelease,         // Release          
        ErrShow,            // Show
        ErrPlay,            // show
        DibGetData,         // Get the object data
        ErrSetData,         // Set the object data
        ErrSetTargetDevice, //
    
        ErrSetBounds,       // set viewport bounds
        DibEnumFormat,      // enumerate supported formats
        ErrSetColorScheme,  //
        DibRelease,         // delete
        ErrSetHostNames,    //

        DibSaveToStream,    // write to file
        DibClone,           // clone object
        ErrCopyFromLink,    // Create embedded from Lnk

        DibEqual,           // compares the given objects for data equality

        DibCopy,            // copy to clip

        DibDraw,            // draw the object
            
        ErrActivate,        // open
        ErrExecute,         // excute 
        ErrClose,           // Stop
        ErrUpdate,          // Update
        ErrReconnect,       // Reconnect

        ErrObjectConvert,   // convert object to specified type

        ErrGetUpdateOptions, // update options
        ErrSetUpdateOptions, // update options

        ObjRename,         // Change Object name
        ObjQueryName,      // Get current object name
            
        ObjQueryType,      // Object type
        DibQueryBounds,    // QueryBounds
        ObjQuerySize,      // Find the size of the object
        ErrQueryOpen,      // Query open
        ErrQueryOutOfDate, // query whether object is current
            
        ErrQueryRelease,      // release related stuff
        ErrQueryRelease,
        ErrQueryRelease,

        ErrRequestData,    // requestdata
        ErrObjectLong,     // objectLong
        DibChangeData        // change data of the existing object
};



OLESTATUS  FARINTERNAL DibRelease (lpobj)
LPOBJECT_DIB     lpobj;
{
    HOBJECT hobj;

    if (lpobj->hDIB){
        GlobalFree (lpobj->hDIB);
        lpobj->hDIB = NULL;
    }

    if (lpobj->head.lhclientdoc)
        DocDeleteObject ((LPOLEOBJECT) lpobj);
    
    if (hobj = lpobj->head.hobj){
        lpobj->head.hobj = NULL;
        GlobalUnlock (hobj);
        GlobalFree (hobj);
    }

    return OLE_OK;
}



OLESTATUS FARINTERNAL DibSaveToStream (lpobj, lpstream)
LPOBJECT_DIB    lpobj;
LPOLESTREAM     lpstream;
{
    LPSTR   lpDIBbuf;
    
    if (!lpobj->hDIB)
        return OLE_ERROR_BLANK;
    
    if (PutBytes (lpstream, (LPSTR) &dwVerToFile, sizeof(LONG)))
        return OLE_ERROR_STREAM;

    if (PutBytes (lpstream, (LPSTR) &lpobj->head.ctype, sizeof(LONG)))
        return  OLE_ERROR_STREAM;

    if (PutStrWithLen (lpstream, (LPSTR)"DIB"))
        return OLE_ERROR_STREAM;

    if (PutBytes (lpstream, (LPSTR) &lpobj->head.cx, sizeof(LONG)))
        return OLE_ERROR_STREAM;
    
    if (PutBytes (lpstream, (LPSTR) &lpobj->head.cy, sizeof(LONG)))
        return OLE_ERROR_STREAM;

    lpobj->sizeBytes = GlobalSize (lpobj->hDIB);
    if (PutBytes (lpstream, (LPSTR) &lpobj->sizeBytes, sizeof(LONG)))
        return OLE_ERROR_STREAM;
    
    if (!(lpDIBbuf = GlobalLock (lpobj->hDIB)))
        return OLE_ERROR_MEMORY;

    if (PutBytes (lpstream, lpDIBbuf, lpobj->sizeBytes))
        return OLE_ERROR_STREAM;
    
    GlobalUnlock (lpobj->hDIB);
    return OLE_OK;
}



OLESTATUS FARINTERNAL  DibClone (lpobjsrc, lpclient, lhclientdoc, lpobjname, lplpobj)
LPOBJECT_DIB        lpobjsrc;
LPOLECLIENT         lpclient;
LHCLIENTDOC         lhclientdoc;
LPSTR               lpobjname;
LPOBJECT_DIB FAR *  lplpobj;
{
    if (!CheckClientDoc ((LPCLIENTDOC) lhclientdoc))
        return OLE_ERROR_HANDLE;
    
    if (!(*lplpobj = DibCreateObject (lpobjsrc->hDIB, lpclient, FALSE,
                            lhclientdoc, lpobjname, lpobjsrc->head.ctype)))
        return OLE_ERROR_MEMORY;
    else
        return OLE_OK;
}



OLESTATUS FARINTERNAL  DibEqual (lpobj1, lpobj2)
LPOBJECT_DIB lpobj1;
LPOBJECT_DIB lpobj2;
{
    if (CmpGlobals (lpobj1->hDIB, lpobj1->hDIB))
        return OLE_OK;
    
    return OLE_ERROR_NOT_EQUAL;
}


OLESTATUS FARINTERNAL DibCopy (lpobj)
LPOBJECT_DIB    lpobj;
{
    HANDLE hDIB;

    if (!lpobj->hDIB)
        return OLE_ERROR_BLANK;

    if (!(hDIB = DuplicateGlobal (lpobj->hDIB, GMEM_MOVEABLE)))
        return OLE_ERROR_MEMORY;

    SetClipboardData (CF_DIB, hDIB);
    return OLE_OK;
}


OLESTATUS FARINTERNAL DibQueryBounds (lpobj, lpRc)
LPOBJECT_DIB    lpobj;
LPRECT          lpRc;
{
    Puts("DibQueryBounds");

    if (!lpobj->hDIB)
        return OLE_ERROR_BLANK;

    lpRc->left     = 0;
    lpRc->top      = 0;
    lpRc->right    = (int) lpobj->head.cx;
    lpRc->bottom   = (int) lpobj->head.cy;
    return OLE_OK;
}



OLECLIPFORMAT FARINTERNAL DibEnumFormat (lpobj, cfFormat)
LPOBJECT_DIB    lpobj;
OLECLIPFORMAT   cfFormat;
{
    if (!cfFormat)
        return CF_DIB;
    
    return NULL;
}


OLESTATUS FARINTERNAL DibGetData (lpobj, cfFormat, lphandle)
LPOBJECT_DIB    lpobj;
OLECLIPFORMAT   cfFormat;
LPHANDLE        lphandle;
{
    if (cfFormat != CF_DIB) 
        return OLE_ERROR_FORMAT;
    
    if (!(*lphandle = lpobj->hDIB))
        return OLE_ERROR_BLANK;
    
    return OLE_OK;
}



LPOBJECT_DIB FARINTERNAL DibCreateObject (hDIB, lpclient, fDelete, lhclientdoc, lpobjname, objType)
HANDLE      hDIB;
LPOLECLIENT lpclient;
BOOL        fDelete;
LHCLIENTDOC lhclientdoc;
LPSTR       lpobjname;
LONG        objType;
{
    LPOBJECT_DIB    lpobj;

    if (lpobj = DibCreateBlank (lhclientdoc, lpobjname, objType)) { 
        if (DibChangeData (lpobj, hDIB, lpclient, fDelete) != OLE_OK) {
            DibRelease (lpobj);
            lpobj = NULL;
        }
    }
    
    return lpobj;
}



// If the routine fails then the object will be left with it's old data.
// If fDelete is TRUE, then hNewDIB will be deleted whether the routine
// is successful or not.

OLESTATUS FARINTERNAL DibChangeData (lpobj, hNewDIB, lpclient, fDelete)
LPOBJECT_DIB    lpobj;
HANDLE          hNewDIB;
LPOLECLIENT     lpclient;
BOOL            fDelete;
{
    BITMAPINFOHEADER    bi;
    DWORD               dwSize;
    LPBITMAPINFOHEADER  lpBi;

    if (!hNewDIB)
        return OLE_ERROR_BLANK;
    
    lpBi = (LPBITMAPINFOHEADER) &bi;
    if (!fDelete) {
        if (!(hNewDIB = DuplicateGlobal (hNewDIB, GMEM_MOVEABLE)))
            return OLE_ERROR_MEMORY;
    }
    else {
        // change the ownership to yourself

        HANDLE htmp;
        
        if (!(htmp = GlobalReAlloc (hNewDIB, 0L, GMEM_MODIFY|GMEM_SHARE))) {
            htmp = DuplicateGlobal (hNewDIB, GMEM_MOVEABLE);
            GlobalFree (hNewDIB);
            if (!htmp)
                return OLE_ERROR_MEMORY;
        }
        
        hNewDIB = htmp;
    }
    
    if (!(lpBi = (LPBITMAPINFOHEADER) GlobalLock (hNewDIB))) {
        GlobalFree (hNewDIB);
        return OLE_ERROR_MEMORY;
    }

    dwSize = GlobalSize (hNewDIB);
    if (lpobj->hDIB)
        GlobalFree (lpobj->hDIB);
    DibUpdateStruct (lpobj, lpclient, hNewDIB, lpBi, dwSize);
    return OLE_OK;
}


void INTERNAL DibUpdateStruct (lpobj, lpclient, hDIB, lpBi, dwBytes)
LPOBJECT_DIB        lpobj;
LPOLECLIENT         lpclient;
HANDLE              hDIB;
LPBITMAPINFOHEADER  lpBi;
DWORD               dwBytes;
{
    POINT       point;

    lpobj->head.lpclient = lpclient;
    lpobj->sizeBytes = dwBytes;
    
#ifdef OLD  
    lpobj->xSize = point.x = (int) lpBi->biWidth;
    lpobj->ySize = point.y = (int) lpBi->biHeight; 
    ConvertToHimetric (&point);
#else
    DibGetExtents ((LPSTR) lpBi, &point);
#endif

    lpobj->head.cx = (LONG) point.x;
    lpobj->head.cy = (LONG) point.y;
    lpobj->hDIB = hDIB;
}



OLESTATUS FARINTERNAL DibLoadFromStream (lpstream, lpclient, lhclientdoc, lpobjname, lplpoleobject, objType)
LPOLESTREAM         lpstream;
LPOLECLIENT         lpclient;
LHCLIENTDOC         lhclientdoc;
LPSTR               lpobjname;
LPOLEOBJECT FAR *   lplpoleobject;
LONG                objType;
{
    LPOBJECT_DIB lpobj = NULL;

    *lplpoleobject = NULL;

    if (!(lpobj = DibCreateBlank (lhclientdoc, lpobjname, objType)))
        return OLE_ERROR_MEMORY;

    lpobj->head.lpclient = lpclient;
    if (GetBytes (lpstream, (LPSTR) &lpobj->head.cx, sizeof(LONG)))
        goto errLoad;
    
    if (GetBytes (lpstream, (LPSTR) &lpobj->head.cy, sizeof(LONG)))
        goto errLoad;
    
    if (GetBytes (lpstream, (LPSTR) &lpobj->sizeBytes, sizeof(LONG)))
        goto errLoad;
    
     if (DibStreamRead (lpstream, lpobj)) {
         *lplpoleobject = (LPOLEOBJECT) lpobj;
         return OLE_OK;
    }

errLoad:    
    OleDelete ((LPOLEOBJECT) lpobj);
    return OLE_ERROR_STREAM;
}



LPOBJECT_DIB FARINTERNAL DibCreateBlank (lhclientdoc, lpobjname, objType)
LHCLIENTDOC lhclientdoc;
LPSTR       lpobjname;
LONG        objType;
{
    HOBJECT hobj;
    LPOBJECT_DIB lpobj;

    if((hobj = GlobalAlloc (GMEM_MOVEABLE|GMEM_ZEROINIT,sizeof (OBJECT_DIB)))
            == NULL)
        return NULL;

    if (!(lpobj = (LPOBJECT_DIB) GlobalLock (hobj))){
        GlobalFree (hobj);
        return NULL;
    }

    // The structure is ZERO initialized at allocation time. So only the 
    // fields that need to be filled with values other than ZEROS are
    // initialized below
        
    lpobj->head.objId[0]    = 'L';
    lpobj->head.objId[1]    = 'E';
    lpobj->head.mm          = MM_TEXT;
    lpobj->head.ctype       = objType;
    lpobj->head.lpvtbl      = (LPOLEOBJECTVTBL)&vtblDIB;
    lpobj->head.iTable      = INVALID_INDEX;
    lpobj->head.hobj        = hobj;
    
    if (objType == CT_STATIC)
        DocAddObject ((LPCLIENTDOC) lhclientdoc, 
                (LPOLEOBJECT) lpobj, lpobjname);
    return lpobj;
}




BOOL INTERNAL DibStreamRead (lpstream, lpobj)
LPOLESTREAM     lpstream;
LPOBJECT_DIB    lpobj;
{
    HANDLE              hDIBbuf;
    LPSTR               lpDIBbuf;
    BOOL                retVal = FALSE;
    BITMAPINFOHEADER    bi;

    if (GetBytes (lpstream, (LPSTR) &bi, sizeof(bi)))
        return FALSE;

    if (hDIBbuf = GlobalAlloc (GMEM_MOVEABLE, lpobj->sizeBytes)) {
        if (lpDIBbuf = (LPSTR)GlobalLock (hDIBbuf)){
            *((LPBITMAPINFOHEADER) lpDIBbuf) = bi;
            if (!GetBytes (lpstream, lpDIBbuf+sizeof(bi), 
                     (lpobj->sizeBytes - sizeof(bi)))) {

                lpobj->hDIB = hDIBbuf;
#ifdef OLD
                //!!! this info should be part of the stream
                if (!lpobj->head.cx) {
                    DibGetExtents ((LPSTR) lpDIBbuf, &point);
                    lpobj->head.cx = (LONG) point.x;
                    lpobj->head.cy = (LONG) point.y;
                }
#endif
                retVal = TRUE;
            }
            GlobalUnlock(hDIBbuf);
        }
        //* Hang on to the memory allocated for the DIB
    }               
    return  retVal;
}


OLESTATUS FARINTERNAL DibPaste (lpclient, lhclientdoc, lpobjname, lplpoleobject, objType)
LPOLECLIENT         lpclient;
LHCLIENTDOC         lhclientdoc;
LPSTR               lpobjname;
LPOLEOBJECT FAR *   lplpoleobject;
LONG                objType;
{
    HANDLE     hDIB;

    if ((hDIB = GetClipboardData (CF_DIB)) == NULL)
        return  OLE_ERROR_MEMORY;

    *lplpoleobject = (LPOLEOBJECT) DibCreateObject (hDIB, lpclient, FALSE,
                                        lhclientdoc, lpobjname, objType);

    return OLE_OK;

}


void FARINTERNAL DibGetExtents (lpData, lpPoint)
LPSTR   lpData;
LPPOINT lpPoint;
{
    #define HIMET_PER_METER     100000L  // number of HIMETRIC units / meter
        
    LPBITMAPINFOHEADER  lpbmi;
        
    lpbmi = (LPBITMAPINFOHEADER)lpData;
    
    if (!(lpbmi->biXPelsPerMeter && lpbmi->biYPelsPerMeter)) {
        HDC hdc;
        
        hdc = GetDC (NULL);
        lpbmi->biXPelsPerMeter = MulDiv (GetDeviceCaps (hdc, LOGPIXELSX),
                                    10000, 254);
        lpbmi->biYPelsPerMeter = MulDiv (GetDeviceCaps (hdc, LOGPIXELSY),
                                    10000, 254);
                                    
        ReleaseDC (NULL, hdc);
    }

    lpPoint->x = (int) (lpbmi->biWidth * HIMET_PER_METER
                            / lpbmi->biXPelsPerMeter);
    lpPoint->y = -(int) (lpbmi->biHeight * HIMET_PER_METER
                            / lpbmi->biYPelsPerMeter);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\ole\client\doc.c ===
/****************************** Module Header ******************************\
* Module Name: doc.c 
*
* PURPOSE: Contains client document maipulation routines.
*
* Created: Jan 1991
*
* Copyright (c) 1991  Microsoft Corporation
*
* History:
*   Srinik  01/11/1191  Orginal
*
\***************************************************************************/

#include <windows.h>
#include "dll.h"

#ifdef FIREWALLS
extern BOOL     bShowed;
extern void FARINTERNAL ShowVersion (void);
#endif

LPCLIENTDOC lpHeadDoc = NULL;
LPCLIENTDOC lpTailDoc  = NULL;

extern ATOM aClipDoc;
extern int  iUnloadableDll;

#pragma alloc_text(_TEXT, CheckClientDoc, CheckPointer)


OLESTATUS FAR PASCAL OleRegisterClientDoc (lpClassName, lpDocName, future, lplhclientdoc)
LPSTR               lpClassName;
LPSTR               lpDocName;
LONG                future;
LHCLIENTDOC FAR *   lplhclientdoc;
{
    HANDLE      hdoc = NULL;
    LPCLIENTDOC lpdoc;
    OLESTATUS   retVal;
    ATOM        aClass, aDoc;
    
    
#ifdef FIREWALLS
    if (!bShowed && (ole_flags & DEBUG_MESSAGEBOX))
        ShowVersion ();
#endif

    Puts ("OleRegisterClientDoc");

    PROBE_MODE(bProtMode);
    FARPROBE_WRITE(lplhclientdoc);
    *lplhclientdoc = NULL;
    FARPROBE_READ(lpClassName);
    FARPROBE_READ(lpDocName);
    if (!lpDocName[0])
        return OLE_ERROR_NAME;
    
    aDoc = GlobalAddAtom (lpDocName); 
    aClass = GlobalAddAtom (lpClassName);

    if (!(hdoc = GlobalAlloc (GMEM_MOVEABLE | GMEM_ZEROINIT | GMEM_SHARE, 
                        sizeof(CLIENTDOC)))
            || !(lpdoc = (LPCLIENTDOC) GlobalLock (hdoc))) {
        retVal =  OLE_ERROR_MEMORY;
        goto err;
    }

    lpdoc->docId[0] = 'C';
    lpdoc->docId[1] = 'D';
    lpdoc->aClass   = aClass;
    lpdoc->aDoc     = aDoc;
    lpdoc->hdoc     = hdoc;
        
    // Documents are doubly linked
        
    if (!lpHeadDoc) {
#ifdef FIREWALLS        
        ASSERT(!lpTailDoc, "lpTailDoc is not NULL");
#endif  
        lpHeadDoc = lpTailDoc = lpdoc;
    }
    else {
        lpTailDoc->lpNextDoc = lpdoc;
        lpdoc->lpPrevDoc = lpTailDoc;
        lpTailDoc = lpdoc;
    }
    
    *lplhclientdoc = (LHCLIENTDOC) lpdoc;

    // inform the link manager;
    return OLE_OK;
    
err:
    if (aClass) 
        GlobalDeleteAtom (aClass);

    if (aDoc)
        GlobalDeleteAtom (aDoc);    
    
    if (hdoc)
        GlobalFree (hdoc);

    return retVal;
}


OLESTATUS FAR PASCAL OleRevokeClientDoc (lhclientdoc)
LHCLIENTDOC lhclientdoc;
{
    LPCLIENTDOC lpdoc;
    
    Puts ("OleRevokeClientDoc");

    // if there is any handler dll that can be freed up, free it now. 
    // Otherwise it might become too late if the app quits.
    if (iUnloadableDll) 
        UnloadDll ();
    
    if (!CheckClientDoc (lpdoc = (LPCLIENTDOC) lhclientdoc))
        return OLE_ERROR_HANDLE;
    
    if (lpdoc->lpHeadObj) {
        ASSERT (0, "OleRevokeClientDoc() called without freeing all objects");
        return OLE_ERROR_NOT_EMPTY;
    }
    
    if (lpdoc->aClass)
        GlobalDeleteAtom (lpdoc->aClass);   

    if (lpdoc->aDoc)
        GlobalDeleteAtom (lpdoc->aDoc);

    // if only one doc is in the list then it's prev and next docs are NULL
        
    if (lpdoc == lpHeadDoc)
        lpHeadDoc = lpdoc->lpNextDoc;

    if (lpdoc == lpTailDoc)
        lpTailDoc = lpdoc->lpPrevDoc;       

    if (lpdoc->lpPrevDoc)
        lpdoc->lpPrevDoc->lpNextDoc = lpdoc->lpNextDoc;

    if (lpdoc->lpNextDoc)   
        lpdoc->lpNextDoc->lpPrevDoc = lpdoc->lpPrevDoc;     

    GlobalUnlock (lpdoc->hdoc);
    GlobalFree (lpdoc->hdoc);
    
    // inform link manager
    return OLE_OK;
}


OLESTATUS FAR PASCAL OleRenameClientDoc (lhclientdoc, lpNewDocName)
LHCLIENTDOC lhclientdoc;
LPSTR       lpNewDocName;
{
    LPCLIENTDOC lpdoc;
    ATOM        aNewDoc;
    LPOLEOBJECT lpobj = NULL;
    
    if (!CheckClientDoc (lpdoc = (LPCLIENTDOC) lhclientdoc))
        return OLE_ERROR_HANDLE;
    
    FARPROBE_READ(lpNewDocName);
    
    aNewDoc = GlobalAddAtom (lpNewDocName);
    if (aNewDoc == lpdoc->aDoc) {
        if (aNewDoc)
            GlobalDeleteAtom (aNewDoc);
        return OLE_OK;
    }
    
    // Document name has changed. So, change the topic of all embedded objects
    if (lpdoc->aDoc)
        GlobalDeleteAtom (lpdoc->aDoc);
    lpdoc->aDoc = aNewDoc;
    
    while (lpobj = DocGetNextObject (lpdoc, lpobj)) {
        if (lpobj->ctype == CT_EMBEDDED)
            if (OleQueryReleaseStatus (lpobj) != OLE_BUSY)
                SetEmbeddedTopic ((LPOBJECT_LE) lpobj);
    }
    
    return OLE_OK;
}


OLESTATUS FAR PASCAL OleRevertClientDoc (lhclientdoc)
LHCLIENTDOC lhclientdoc;
{
    // if there is any handler dll that can be freed up, free it now.
    // Otherwise it might become too late if the app quits.
    if (iUnloadableDll) 
        UnloadDll ();
    
    if (!CheckClientDoc ((LPCLIENTDOC) lhclientdoc))
        return OLE_ERROR_HANDLE;

    return OLE_OK;
}


OLESTATUS FAR PASCAL OleSavedClientDoc (lhclientdoc)
LHCLIENTDOC lhclientdoc;
{
    if (!CheckClientDoc ((LPCLIENTDOC) lhclientdoc))
        return OLE_ERROR_HANDLE;

    return OLE_OK;
}

OLESTATUS FAR PASCAL OleEnumObjects (lhclientdoc, lplpobj)
LHCLIENTDOC         lhclientdoc;
LPOLEOBJECT FAR *   lplpobj;
{
    if (!CheckClientDoc ((LPCLIENTDOC) lhclientdoc))
        return OLE_ERROR_HANDLE;

    FARPROBE_WRITE(lplpobj);

    if (*lplpobj) {
        // we are making lhclientdoc field of the object NULL at deletion 
        // time. The check (*lpobj->lhclientdoc != lhclientdoc) will take care
        // of the case where same chunk of memory is allocated again for the
        // same pointer and old contents are not erased yet.
        if (!FarCheckObject (*lplpobj) 
                || ((*lplpobj)->lhclientdoc != lhclientdoc))
            return OLE_ERROR_OBJECT;    
    }
    
    *lplpobj = DocGetNextObject ((LPCLIENTDOC) lhclientdoc, *lplpobj);
    return OLE_OK;
}


    
LPOLEOBJECT INTERNAL DocGetNextObject (lpdoc, lpobj)
LPCLIENTDOC lpdoc;
LPOLEOBJECT lpobj;
{
    if (!lpobj)
        return lpdoc->lpHeadObj;
    
    return lpobj->lpNextObj;
}


BOOL FARINTERNAL CheckClientDoc (lpdoc)
LPCLIENTDOC lpdoc;
{
    if (!CheckPointer(lpdoc, WRITE_ACCESS))
        return FALSE;

    if ((lpdoc->docId[0] == 'C') && (lpdoc->docId[1] == 'D'))
        return TRUE;
    return FALSE;
}


void FARINTERNAL DocAddObject (lpdoc, lpobj, lpobjname)
LPCLIENTDOC lpdoc;
LPOLEOBJECT lpobj;
LPSTR       lpobjname;
{
    if (lpobjname) 
        lpobj->aObjName = GlobalAddAtom (lpobjname);
    else
        lpobj->aObjName = NULL;
    
    // Objects of a doc are doubly linked
        
    if (!lpdoc->lpHeadObj)
        lpdoc->lpHeadObj = lpdoc->lpTailObj = lpobj;
    else {
        lpdoc->lpTailObj->lpNextObj = lpobj;
        lpobj->lpPrevObj = lpdoc->lpTailObj;
        lpdoc->lpTailObj = lpobj;
    }
    lpobj->lhclientdoc = (LHCLIENTDOC)lpdoc;
}


void FARINTERNAL DocDeleteObject (lpobj)
LPOLEOBJECT lpobj;
{
    LPCLIENTDOC lpdoc;

    if (!(lpdoc = (LPCLIENTDOC) lpobj->lhclientdoc))
        return;

    if (lpobj->aObjName) {
        GlobalDeleteAtom (lpobj->aObjName);
        lpobj->aObjName = NULL;
    }
    
    // Remove this obj from object chain of the relevant client doc.
    // The objects of a doc are doubly linked.
                
    if (lpdoc->lpHeadObj == lpobj)
        lpdoc->lpHeadObj = lpobj->lpNextObj;

    if (lpdoc->lpTailObj == lpobj)
        lpdoc->lpTailObj = lpobj->lpPrevObj;       

    if (lpobj->lpPrevObj)
        lpobj->lpPrevObj->lpNextObj = lpobj->lpNextObj;

    if (lpobj->lpNextObj)   
        lpobj->lpNextObj->lpPrevObj = lpobj->lpPrevObj;     

    lpobj->lhclientdoc = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\ole\client\error.c ===
/****************************** Module Header ******************************\
* Module Name: ERROR.C
*
* PURPOSE:  Contains routines which are commonly used, as method functions, by
*           bm.c, mf.c and dib.c. These routines do nothing more than 
*           returning an error code.
*
* Created: November 1990
*
* Copyright (c) 1990, 1991  Microsoft Corporation
*
* History:
*   Raor, Srinik (11/20/90)   Original
*
\***************************************************************************/

#include <windows.h>
#include "dll.h"
#include "pict.h"

OLESTATUS FARINTERNAL ErrQueryRelease (lpobj)
LPOLEOBJECT lpobj;
{
    return OLE_ERROR_STATIC;
}

OLESTATUS FARINTERNAL ErrPlay (lpobj, verb, fShow, fAct)
WORD      verb;
LPOLEOBJECT lpobj;
BOOL      fAct;
BOOL      fShow;
{
    return OLE_ERROR_STATIC;
}


OLESTATUS FARINTERNAL ErrShow (lpobj, fAct)
LPOLEOBJECT lpobj;
BOOL        fAct;
{
    return OLE_ERROR_STATIC;
}

OLESTATUS FARINTERNAL ErrAbort (lpobj)
LPOLEOBJECT lpobj;
{
    return OLE_ERROR_STATIC;
}

OLESTATUS FARINTERNAL  ErrCopyFromLink(lpobj, lpclient, lhclientdoc, lpobjname, lplpobj)
LPOLEOBJECT         lpobj;
LPOLECLIENT         lpclient;
LHCLIENTDOC         lhclientdoc;
LPSTR               lpobjname;
LPOLEOBJECT FAR *   lplpobj;
{
    return OLE_ERROR_STATIC;
}


OLESTATUS FARINTERNAL  ErrSetHostNames (lpobj, lpclientName, lpdocName)
LPOLEOBJECT lpobj;
LPSTR       lpclientName;
LPSTR       lpdocName;
{
    return OLE_ERROR_STATIC;
}


OLESTATUS   FARINTERNAL  ErrSetTargetDevice (lpobj, hDevInfo)
LPOLEOBJECT lpobj;
HANDLE      hDevInfo;
{
    return OLE_ERROR_STATIC;
}


OLESTATUS   FARINTERNAL  ErrSetColorScheme (lpobj, lplogpal)
LPOLEOBJECT     lpobj;
LPLOGPALETTE    lplogpal;
{
    return OLE_ERROR_STATIC;
}


OLESTATUS FARINTERNAL  ErrSetBounds(lpobj, lprc)
LPOLEOBJECT lpobj;
LPRECT      lprc;
{
    return OLE_ERROR_MEMORY;
}


OLESTATUS FARINTERNAL  ErrQueryOpen (lpobj)
LPOLEOBJECT lpobj;
{
    return OLE_ERROR_STATIC;      // static object
}


OLESTATUS FARINTERNAL  ErrActivate (lpobj, verb, fShow, fAct, hWnd, lprc)
LPOLEOBJECT lpobj;
WORD        verb;
BOOL        fShow;
BOOL        fAct;
HWND        hWnd;
LPRECT      lprc;
{
    return OLE_ERROR_STATIC;      // static object
}

OLESTATUS FARINTERNAL  ErrEdit (lpobj, fShow, hWnd, lprc)
LPOLEOBJECT lpobj;
BOOL        fShow;
HWND        hWnd;
LPRECT      lprc;
{
    return OLE_ERROR_STATIC;      // static object
}

OLESTATUS FARINTERNAL  ErrClose (lpobj)
LPOLEOBJECT lpobj;
{
    return OLE_ERROR_STATIC;      // static object
}


OLESTATUS FARINTERNAL  ErrUpdate (lpobj)
LPOLEOBJECT lpobj;
{
    return OLE_ERROR_STATIC;      // static object
}


OLESTATUS FARINTERNAL  ErrReconnect (lpobj)
LPOLEOBJECT lpobj;
{
    return OLE_ERROR_STATIC;      // static object

}


OLESTATUS FARINTERNAL ErrSetData (lpobj, cfFormat, hData)
LPOLEOBJECT     lpobj;
OLECLIPFORMAT   cfFormat;
HANDLE          hData;
{
    return OLE_ERROR_MEMORY;
}


OLESTATUS   FARINTERNAL  ErrReadFromStream (lpobj, cfFormat, lpstream)
LPOLEOBJECT     lpobj;
OLECLIPFORMAT   cfFormat;
LPOLESTREAM     lpstream;
{
    return OLE_ERROR_STREAM;
}



OLESTATUS FARINTERNAL ErrQueryOutOfDate (lpobj)
LPOLEOBJECT lpobj;
{
    return OLE_OK;
}


OLESTATUS FARINTERNAL ErrObjectConvert (lpobj, lpprotocol, lpclient, lhclientdoc, lpobjname, lplpobj)
LPOLEOBJECT         lpobj;
LPSTR               lpprotocol;
LPOLECLIENT         lpclient;
LHCLIENTDOC         lhclientdoc;
LPSTR               lpobjname;
LPOLEOBJECT FAR *   lplpobj;
{
    return OLE_ERROR_STATIC;
}


OLESTATUS FARINTERNAL ErrGetUpdateOptions (lpobj, lpoptions)
LPOLEOBJECT         lpobj;
OLEOPT_UPDATE  FAR  *lpoptions;
{
    return OLE_ERROR_STATIC;

}

OLESTATUS FARINTERNAL ErrSetUpdateOptions (lpobj, options)
LPOLEOBJECT         lpobj;
OLEOPT_UPDATE       options;
{
    return OLE_ERROR_STATIC;

}

LPVOID  FARINTERNAL ErrQueryProtocol (lpobj, lpprotocol)
LPOLEOBJECT lpobj;
LPSTR       lpprotocol;
{
    return NULL;
}

OLESTATUS FARINTERNAL ErrRequestData (lpobj, cfFormat)
LPOLEOBJECT     lpobj;
OLECLIPFORMAT   cfFormat;
{
    return OLE_ERROR_STATIC;

}

OLESTATUS FARINTERNAL ErrExecute (lpobj, hData, wReserved)
LPOLEOBJECT     lpobj;
HANDLE          hData;
WORD            wReserved;
{
    return OLE_ERROR_STATIC;
}



OLESTATUS FARINTERNAL ErrObjectLong (lpobj, wFlags, lplong)
LPOLEOBJECT     lpobj;
WORD            wFlags;
LPLONG          lplong;
{
    return OLE_ERROR_STATIC;
}


HANDLE FARINTERNAL DuplicateGDIdata (hSrcData, cfFormat)
HANDLE          hSrcData;
OLECLIPFORMAT   cfFormat;
{
    if (cfFormat == CF_METAFILEPICT) {
        LPMETAFILEPICT  lpSrcMfp;
        LPMETAFILEPICT  lpDstMfp = NULL;        
        HANDLE          hMF = NULL;
        HANDLE          hDstMfp = NULL;
        
        if (!(lpSrcMfp = (LPMETAFILEPICT) GlobalLock(hSrcData)))
            return NULL;
        
        GlobalUnlock (hSrcData);
        
        if (!(hMF = CopyMetaFile (lpSrcMfp->hMF, NULL)))
            return NULL;
        
        if (!(hDstMfp = GlobalAlloc (GMEM_MOVEABLE, sizeof(METAFILEPICT))))
            goto errMfp;    

        if (!(lpDstMfp = (LPMETAFILEPICT) GlobalLock (hDstMfp)))
            goto errMfp;
        
        GlobalUnlock (hDstMfp);
        
        *lpDstMfp = *lpSrcMfp;
        lpDstMfp->hMF = hMF;
        return hDstMfp;
errMfp:
        if (hMF)
            DeleteMetaFile (hMF);
        
        if (hDstMfp)
            GlobalFree (hDstMfp);
        
        return NULL;
    }
    
    if (cfFormat == CF_BITMAP) {
        DWORD dwSize;
        
        return BmDuplicate (hSrcData, &dwSize, NULL);
    }
    
    if (cfFormat == CF_DIB) 
        return DuplicateGlobal (hSrcData, GMEM_MOVEABLE);
    
    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\ole\client\funchead.c ===
//////////////////////////////////////////////////////////////////////////////
//
//  int FAR PASCAL LibMain (hInst, wDataSeg, cbHeapSize, lpszCmdLine)
//   
//  The main library entry point. This routine is called when the library 
//  is loaded.
//   
//  Arguments:
// 
//      hInst       -
//      wDataSeg    -
//      cbHeapSize  -
//      lpszCmdLine -
//
//  Returns:   
//   
//  Effects:     
//   
//////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\ole\client\draw.c ===
/****************************** Module Header ******************************\
* Module Name: DRAW.C 
*
* PURPOSE: Contains all the drawing related routines
*
* Created: March 1991
*
* Copyright (c) 1990, 1991  Microsoft Corporation
*
* History:
*       (03/21/91) Srinik  Original
*       (03/22/91) Srinik  Added support for drawing metafile in a metafile
*
\***************************************************************************/

#include <windows.h>
#include "dll.h"
#include "pict.h"

#define RECORD_COUNT    16

int       INTERNAL    PaletteSize (int);
HANDLE    INTERNAL    DibMakeLogPalette(LPSTR, WORD, LPLOGPALETTE FAR *);
OLESTATUS FARINTERNAL wDibDraw (HANDLE, HDC, LPRECT, LPRECT, HDC, BOOL);
OLESTATUS INTERNAL    wDrawBitmap (LPOBJECT_BM, HDC, HDC, LPRECT);
OLESTATUS INTERNAL    wDrawBitmapUsingDib (LPOBJECT_BM, HDC, HDC, HDC, LPRECT, LPRECT);

void SetPictOrg (LPOBJECT_MF, HDC, int, int, BOOL);
void SetPictExt (LPOBJECT_MF, HDC, int, int);
void ScalePictExt (LPOBJECT_MF, HDC, int, int, int, int);
void ScaleRectExt (LPOBJECT_MF, HDC, int, int, int, int);

void CleanStack(LPOBJECT_MF, HANDLE);
BOOL PopDc (LPOBJECT_MF);
BOOL PushDc (LPOBJECT_MF);

#ifdef META_DEBUG
void PutMetaFuncName (WORD);
#endif      

OLESTATUS  FARINTERNAL BmDraw (lpobj, hdc, lprc, lpWrc, hdcTarget)
LPOBJECT_BM     lpobj;
HDC             hdc;
LPRECT          lprc;
LPRECT          lpWrc;
HDC             hdcTarget;
{
    HDC         hMemDC, hScreenDC;
    int         iScreenDevCaps;
    OLESTATUS   ret = OLE_OK;
    
    if (!lpobj->hBitmap)
        return OLE_ERROR_BLANK;

    hScreenDC = GetDC (NULL);
    
    iScreenDevCaps = GetDeviceCaps (hScreenDC, TECHNOLOGY);
    if (!OleIsDcMeta (hdc) 
            && (iScreenDevCaps != GetDeviceCaps (hdc, TECHNOLOGY))) {
        ret = wDrawBitmapUsingDib (lpobj, hdc, hScreenDC, 
                        hdcTarget, lprc, lpWrc);
    }
    else {
        hMemDC = CreateCompatibleDC (hdc);
        ret = wDrawBitmap (lpobj, hdc, hMemDC, lprc);
        DeleteDC (hMemDC);
    }
    
    ReleaseDC (NULL, hScreenDC);
    return ret;
}


OLESTATUS INTERNAL wDrawBitmap (lpobj, hdc, hMemDC, lprc)
LPOBJECT_BM lpobj;
HDC         hdc;
HDC         hMemDC;
LPRECT      lprc;
{
    HBITMAP     hOldBitmap;
    OLESTATUS   ret = OLE_OK;

    if (!hMemDC)
        return OLE_ERROR_MEMORY;

    if (!(hOldBitmap = SelectObject(hMemDC, lpobj->hBitmap)))
        return OLE_ERROR_DRAW;

    if (!StretchBlt(hdc, 
            lprc->left, lprc->top, 
            (lprc->right - lprc->left), (lprc->bottom - lprc->top),
            hMemDC, 0, 0, lpobj->xSize, lpobj->ySize, SRCCOPY)) {
        ret = OLE_ERROR_DRAW;
    }
    
    SelectObject (hMemDC, hOldBitmap);
    return ret;
}

        
OLESTATUS INTERNAL wDrawBitmapUsingDib (
LPOBJECT_BM     lpobj,
HDC             hdc,
HDC             hScreenDC,
HDC             hTargetDC,
LPRECT          lprc,
LPRECT          lpWrc)
{
    BITMAP              bm;
    LPBITMAPINFOHEADER  lpBmi;
    HANDLE              hBmi, hDib = NULL;
    WORD                wBmiSize;
    OLESTATUS           retVal = OLE_ERROR_MEMORY;
    
    if (!GetObject(lpobj->hBitmap, sizeof(BITMAP), (LPSTR) &bm))
        return OLE_ERROR_HANDLE;
    
    wBmiSize = sizeof(BITMAPINFOHEADER) 
                    + PaletteSize(bm.bmPlanes * bm.bmBitsPixel);
    
    if (!(hBmi = GlobalAlloc (GMEM_MOVEABLE|GMEM_ZEROINIT, (DWORD) wBmiSize)))
        return OLE_ERROR_MEMORY;
    
    if (!(lpBmi = (LPBITMAPINFOHEADER) GlobalLock (hBmi))) {
        GlobalFree (hBmi);
        return OLE_ERROR_MEMORY;
    }
    
    GlobalUnlock (hBmi);
                
    lpBmi->biSize          = (LONG) sizeof(BITMAPINFOHEADER);
    lpBmi->biWidth         = (LONG) bm.bmWidth;
    lpBmi->biHeight        = (LONG) bm.bmHeight;
    lpBmi->biPlanes        = 1;
    lpBmi->biBitCount      = bm.bmPlanes * bm.bmBitsPixel;
    lpBmi->biCompression   = BI_RGB;
    lpBmi->biSizeImage     = 0L;
    lpBmi->biXPelsPerMeter = 0L;
    lpBmi->biYPelsPerMeter = 0L;
    lpBmi->biClrUsed       = 0L;
    lpBmi->biClrImportant  = 0L;
    
    // Call GetDIBits with a NULL lpBits parm, so that it will calculate 
    // the biSizeImage field for us
    if (!GetDIBits(hScreenDC, lpobj->hBitmap, 0, bm.bmHeight, NULL, 
            (LPBITMAPINFO)lpBmi, DIB_RGB_COLORS))
        return OLE_ERROR_HANDLE;

    // Realloc the buffer to provide space for the bits
    if (!(hDib = GlobalReAlloc (hBmi, (wBmiSize + lpBmi->biSizeImage),
                        GMEM_MOVEABLE))) {
        GlobalFree (hBmi);
        return OLE_ERROR_MEMORY;
    }
    
    // If reallocation gave a new handle then lock that handle and get the 
    // long pointer to it.
    if (hDib != hBmi) {
        if (!(lpBmi = (LPBITMAPINFOHEADER) GlobalLock (hDib)))
            goto errRtn;
        GlobalUnlock (hDib);
    }
    
    // Call GetDIBits with a NON-NULL lpBits parm, and get the actual bits

    if (!GetDIBits(hScreenDC, lpobj->hBitmap, 0, (WORD) lpBmi->biHeight, 
             ((LPSTR)lpBmi)+wBmiSize,
             (LPBITMAPINFO) lpBmi, 
             DIB_RGB_COLORS)) {
        retVal = OLE_ERROR_HANDLE;       
        goto errRtn;
    }
    
    retVal = wDibDraw (hDib, hdc, lprc, lpWrc, hTargetDC, FALSE);
    
errRtn:
    if (hDib)
        GlobalFree (hDib);
    return retVal;
}
        

OLESTATUS  FARINTERNAL DibDraw (lpobj, hdc, lprc, lpWrc, hdcTarget)
LPOBJECT_DIB    lpobj;
HDC             hdc;
LPRECT          lprc;
LPRECT          lpWrc;
HDC             hdcTarget;
{
    return wDibDraw (lpobj->hDIB, hdc, lprc, lpWrc, hdcTarget, FALSE);
}



OLESTATUS  FARINTERNAL wDibDraw (hData, hdc, lprc, lpWrc, hdcTarget, bPbrushData)
HANDLE  hData;
HDC     hdc;
LPRECT  lprc;
LPRECT  lpWrc;
HDC     hdcTarget;
BOOL    bPbrushData;
{
    // !!! current implementation is not using hdcTarget 
    OLESTATUS       ret = OLE_ERROR_DRAW;
    LPSTR           lpData;
    HANDLE          hPalette = NULL;
    HPALETTE        hLogPalette = NULL, hOldPalette = NULL;
    LPLOGPALETTE    lpLogPalette;
    WORD            wPalSize;
    int             iOffBits;
    
    if (!hData)
        return OLE_ERROR_BLANK;     
            
    if (!(lpData = GlobalLock (hData)))
        return OLE_ERROR_MEMORY;

    if (bPbrushData)
        lpData += sizeof(BITMAPFILEHEADER);
    
    wPalSize = PaletteSize (((LPBITMAPINFOHEADER)lpData)->biBitCount);
    iOffBits  = sizeof(BITMAPINFOHEADER) + wPalSize;

    // if color palette exits do the following 
    if (wPalSize) {
        if (!(hLogPalette = DibMakeLogPalette(lpData+sizeof(BITMAPINFOHEADER),
                                    wPalSize, &lpLogPalette))) {
            ret = OLE_ERROR_MEMORY;
            goto end;
        }
    
        if (!(hPalette = CreatePalette (lpLogPalette)))
            goto end;

        // select as a background palette
        if (!(hOldPalette = SelectPalette (hdc, hPalette, TRUE))) 
            goto end;

        RealizePalette(hdc);
    }
    
    if (!StretchDIBits(hdc, 
            lprc->left, lprc->top, 
            (lprc->right - lprc->left), (lprc->bottom - lprc->top),
            0, 0,
            (WORD) ((LPBITMAPINFOHEADER)lpData)->biWidth,
            (WORD) ((LPBITMAPINFOHEADER)lpData)->biHeight,
            lpData + iOffBits,
            ((LPBITMAPINFO) lpData),
            DIB_RGB_COLORS,
            SRCCOPY)) {    
        ret = OLE_ERROR_DRAW;
    }
    else 
        ret = OLE_OK;
    
end:
    // if color palette exists do the following
    if (wPalSize) {
        hOldPalette = (OleIsDcMeta (hdc) ? GetStockObject(DEFAULT_PALETTE)
                                         : hOldPalette);
        if (hOldPalette) {
            // select as a background palette
            SelectPalette (hdc, hOldPalette, TRUE);
            RealizePalette (hdc);
        }
    
        if (hPalette)
            DeleteObject (hPalette);

        if (hLogPalette)
            GlobalFree (hLogPalette);
    }
    
    GlobalUnlock (hData);
    return ret;
}





HANDLE INTERNAL DibMakeLogPalette (lpColorData, wDataSize, lplpLogPalette)
LPSTR               lpColorData;
WORD                wDataSize;
LPLOGPALETTE FAR *  lplpLogPalette;
{
    HANDLE          hLogPalette=NULL;
    LPLOGPALETTE    lpLogPalette;
    DWORD           dwLogPalSize = wDataSize +  2 * sizeof(WORD);
    LPPALETTEENTRY  lpPE;
    RGBQUAD FAR *   lpQuad;

    if (!(hLogPalette = GlobalAlloc(GMEM_MOVEABLE,dwLogPalSize)))
        return NULL;

    if (!(lpLogPalette = (LPLOGPALETTE) GlobalLock (hLogPalette))) {
        GlobalFree (hLogPalette);
        return NULL;
    }
    
    GlobalUnlock (hLogPalette);
    *lplpLogPalette = lpLogPalette;
    
    lpLogPalette->palVersion = 0x300;
    lpLogPalette->palNumEntries = wDataSize / sizeof(PALETTEENTRY);

    /* now convert RGBQUAD to PALETTEENTRY as we copy color info */
    for (lpQuad = (RGBQUAD far *)lpColorData, 
            lpPE   = (LPPALETTEENTRY)lpLogPalette->palPalEntry,
            wDataSize /= sizeof(RGBQUAD);
            wDataSize--;
            ++lpQuad,++lpPE) {
        lpPE->peFlags=0;
        lpPE->peRed = lpQuad->rgbRed;
        lpPE->peBlue = lpQuad->rgbBlue;
        lpPE->peGreen = lpQuad->rgbGreen;
    }

    return hLogPalette;
}


int INTERNAL PaletteSize (int iBitCount)
{
    switch (iBitCount) {
        case 1:     
            return (2*sizeof(RGBQUAD));
            
        case 4:     
            return (16*sizeof(RGBQUAD));

        case 8:     
            return (256*sizeof(RGBQUAD));
            
        default:   
            return 0;   /* A 24 bitcount DIB has no color table */
    }
}


OLESTATUS  FARINTERNAL GenDraw (lpobj, hdc, lprc, lpWrc, hdcTarget)
LPOBJECT_GEN    lpobj;
HDC             hdc;
LPRECT          lprc;
LPRECT          lpWrc;
HDC             hdcTarget;
{
    return OLE_ERROR_GENERIC;
}







//*** All the following routines are relevant for metafile drawing only


OLESTATUS FARINTERNAL MfDraw (lpobj,  hdc,  lprc, lpWrc, hdcTarget)
LPOBJECT_MF lpobj;
HDC         hdc;
LPRECT      lprc; 
LPRECT      lpWrc; 
HDC         hdcTarget;
{
    HANDLE  hInfo;
    int     iOldDc;
    RECT    rect;
    LPRECT  lpRrc = (LPRECT) &rect;
    
    rect.left   = lprc->left;
    rect.right  = lprc->right;
    rect.top    = lprc->top;
    rect.bottom = lprc->bottom;
    
    if (!lpobj->mfp.hMF)
        return OLE_ERROR_BLANK;

    lpobj->nRecord = RECORD_COUNT;
    lpobj->fMetaDC = OleIsDcMeta (hdc);

    if (!(iOldDc = SaveDC (hdc)))
        return OLE_ERROR_MEMORY;
    
    IntersectClipRect (hdc, lpRrc->left, lpRrc->top,  
        lpRrc->right, lpRrc->bottom);
    
    if (!lpobj->fMetaDC) {
        LPtoDP (hdc, (LPPOINT) lpRrc, 2);
        SetMapMode (hdc, MM_ANISOTROPIC);
        SetViewportOrg (hdc, lpRrc->left, lpRrc->top);
        SetViewportExt (hdc, lpRrc->right - lpRrc->left, 
            lpRrc->bottom - lpRrc->top);
    }
    else {
        
        iOldDc = -1;
        
        if (!lpWrc) {
#ifdef FIREWALLS            
            ASSERT(0, "Pointer to rect is null")
#endif              
            return OLE_ERROR_DRAW;
        }
        
        if (!(hInfo = LocalAlloc (LMEM_MOVEABLE | LMEM_ZEROINIT, 
                            sizeof(METAINFO))))
            return OLE_ERROR_MEMORY;
        
        if (!(lpobj->pMetaInfo = (PMETAINFO) LocalLock (hInfo))) {
            LocalFree (hInfo);
            return OLE_ERROR_MEMORY;
        }

        LocalUnlock (hInfo);
        
        lpobj->pCurMdc          = (PMETADC) (lpobj->pMetaInfo);
        
        lpobj->pMetaInfo->xwo   = lpWrc->left;
        lpobj->pMetaInfo->ywo   = lpWrc->top;
        lpobj->pMetaInfo->xwe   = lpWrc->right;
        lpobj->pMetaInfo->ywe   = lpWrc->bottom;    

        lpobj->pMetaInfo->xro   = lpRrc->left - lpWrc->left;
        lpobj->pMetaInfo->yro   = lpRrc->top - lpWrc->top;

        lpobj->pCurMdc->xre     = lpRrc->right - lpRrc->left;
        lpobj->pCurMdc->yre     = lpRrc->bottom - lpRrc->top;   
        
    }
    
    lpobj->error = OLE_OK;
    MfInterruptiblePaint(lpobj, hdc);

    if (lpobj->fMetaDC) 
        CleanStack (lpobj, hInfo);
    
    RestoreDC (hdc, iOldDc);
    return lpobj->error;
}


void INTERNAL MfInterruptiblePaint (lpobj, hdc)
LPOBJECT_MF lpobj;
HDC         hdc;
{
    FARPROC     lpCallbackFunc;
    
    if (!(lpCallbackFunc = MakeProcInstance (MfCallbackFunc, hInstDLL)))
        PlayMetaFile (hdc, lpobj->mfp.hMF);
    else {
        EnumMetaFile (hdc,lpobj->mfp.hMF, lpCallbackFunc, (LPARAM) lpobj);
        FreeProcInstance (lpCallbackFunc);
    }
}



int FARINTERNAL MfCallbackFunc (hdc, lpHTable, lpMFR, nObj, lpobj)
HDC             hdc;
LPHANDLETABLE   lpHTable;
LPMETARECORD    lpMFR;
int             nObj;
BYTE FAR *      lpobj;
{
    LPOBJECT_MF lpobjMf;
    
    lpobjMf = (LPOBJECT_MF) lpobj;
    if (!--lpobjMf->nRecord) {
        lpobjMf->nRecord = RECORD_COUNT;
        if (!ContextCallBack ((lpobjMf->head.lpParent 
                                    ? lpobjMf->head.lpParent
                                    : (LPOLEOBJECT) lpobjMf),
                        OLE_QUERY_PAINT)) {
            lpobjMf->error = OLE_ERROR_ABORT;         
            return FALSE;
        }
    }
    
    if (lpobjMf->fMetaDC) {

#ifdef META_DEBUG
        PutMetaFuncName (lpMFR->rdFunction);
#endif      

        switch (lpMFR->rdFunction) {
            case META_SETWINDOWORG:
                SetPictOrg (lpobjMf, hdc, lpMFR->rdParm[1], 
                    lpMFR->rdParm[0], FALSE);
                return TRUE;

            case META_OFFSETWINDOWORG:
                SetPictOrg (lpobjMf, hdc, lpMFR->rdParm[1], 
                    lpMFR->rdParm[0], TRUE);
                return TRUE;
            
            case META_SETWINDOWEXT:
                SetPictExt (lpobjMf, hdc, lpMFR->rdParm[1], lpMFR->rdParm[0]);
                return TRUE;
            
            case META_SCALEWINDOWEXT:
                ScalePictExt (lpobjMf, hdc, 
                    lpMFR->rdParm[3], lpMFR->rdParm[2],
                    lpMFR->rdParm[1], lpMFR->rdParm[0]);
                return TRUE;
            
            case META_SAVEDC:
                if (!PushDc (lpobjMf))
                    return FALSE;
                break;
                
            case META_RESTOREDC:                
                PopDc (lpobjMf);
                break;

            case META_SCALEVIEWPORTEXT:
                ScaleRectExt (lpobjMf, hdc, 
                    lpMFR->rdParm[3], lpMFR->rdParm[2],
                    lpMFR->rdParm[1], lpMFR->rdParm[0]);
                return TRUE;
                
            case META_OFFSETVIEWPORTORG:
#ifdef FIREWALLS                
                ASSERT(0, "OffsetViewportOrg() in metafile");
#endif              
                return TRUE;
                
            case META_SETVIEWPORTORG:
#ifdef FIREWALLS                                
                ASSERT(0, "SetViewportOrg() in metafile");
#endif          
                return TRUE;
                
            case META_SETVIEWPORTEXT:
#ifdef FIREWALLS                                
                ASSERT(0, "SetViewportExt() in metafile");
#endif          
                return TRUE;
                
            case META_SETMAPMODE:
#ifdef FIREWALLS                                
                ASSERT(lpMFR->rdParm[0] == MM_ANISOTROPIC,
                    "SetmapMode() in metafile with invalid mapping mode");
#endif          
                return TRUE;

            default:
                break;
        }
    }
    else {
        switch (lpMFR->rdFunction) {
            DWORD exts;
            
            case META_SCALEWINDOWEXT:
                exts = GetWindowExt (hdc);
                SetWindowExt (hdc, 
                    MulDiv(LOWORD(exts), lpMFR->rdParm[3], lpMFR->rdParm[2]), 
                    MulDiv(HIWORD(exts), lpMFR->rdParm[1], lpMFR->rdParm[0]));
                return TRUE;
            
            case META_SCALEVIEWPORTEXT:
                exts = GetViewportExt (hdc);
                SetViewportExt (hdc, 
                    MulDiv(LOWORD(exts), lpMFR->rdParm[3], lpMFR->rdParm[2]), 
                    MulDiv(HIWORD(exts), lpMFR->rdParm[1], lpMFR->rdParm[0]));
                return TRUE;
                
            default:
                break;
        }
    }
    
    PlayMetaFileRecord (hdc, lpHTable, lpMFR, nObj);
    return TRUE;
}


void SetPictOrg (lpobj, hdc, xOrg, yOrg, fOffset)
LPOBJECT_MF lpobj;
HDC         hdc;
int         xOrg;
int         yOrg;
BOOL        fOffset;
{
    if (fOffset) {
        // it's OffsetWindowOrg() call
        lpobj->pCurMdc->xMwo += xOrg;
        lpobj->pCurMdc->yMwo += yOrg;
    }
    else {
        // it's SetWindowOrg()
        lpobj->pCurMdc->xMwo = xOrg;
        lpobj->pCurMdc->yMwo = yOrg;
    }

    if (lpobj->pCurMdc->xMwe && lpobj->pCurMdc->yMwe) {
        SetWindowOrg (hdc, 
            (lpobj->pCurMdc->xMwo - MulDiv (lpobj->pMetaInfo->xro, 
                                        lpobj->pCurMdc->xMwe,
                                        lpobj->pCurMdc->xre)),
            (lpobj->pCurMdc->yMwo - MulDiv (lpobj->pMetaInfo->yro, 
                                        lpobj->pCurMdc->yMwe,
                                        lpobj->pCurMdc->yre)));
    }
}


void SetPictExt (lpobj, hdc, xExt, yExt)
LPOBJECT_MF lpobj;
HDC         hdc;
int         xExt;
int         yExt;
{
    lpobj->pCurMdc->xMwe = xExt;
    lpobj->pCurMdc->yMwe = yExt;

    SetWindowExt (hdc, 
        MulDiv (lpobj->pMetaInfo->xwe, xExt, lpobj->pCurMdc->xre),
        MulDiv (lpobj->pMetaInfo->ywe, yExt, lpobj->pCurMdc->yre));

    SetWindowOrg (hdc, 
        (lpobj->pCurMdc->xMwo 
            - MulDiv (lpobj->pMetaInfo->xro, xExt, lpobj->pCurMdc->xre)),
        (lpobj->pCurMdc->yMwo 
            - MulDiv (lpobj->pMetaInfo->yro, yExt, lpobj->pCurMdc->yre)));
}


void ScalePictExt (lpobj, hdc, xNum, xDenom, yNum, yDenom)
LPOBJECT_MF lpobj;
HDC         hdc;
int         xNum;
int         xDenom;
int         yNum;
int         yDenom;
{
    SetPictExt (lpobj, hdc, MulDiv (lpobj->pCurMdc->xMwe, xNum, xDenom),
        MulDiv (lpobj->pCurMdc->yMwe, yNum, yDenom));
}


void ScaleRectExt (lpobj, hdc, xNum, xDenom, yNum, yDenom)
LPOBJECT_MF lpobj;
HDC         hdc;
int         xNum;
int         xDenom;
int         yNum;
int         yDenom;
{
    lpobj->pCurMdc->xre = MulDiv (lpobj->pCurMdc->xre, xNum, xDenom);
    lpobj->pCurMdc->yre = MulDiv (lpobj->pCurMdc->yre, yNum, yDenom);
    
    SetPictExt (lpobj, hdc, lpobj->pCurMdc->xMwe, lpobj->pCurMdc->yMwe); 
}



BOOL PushDc (lpobj)
LPOBJECT_MF lpobj;
{
    HANDLE  hNode = NULL;
    PMETADC pNode = NULL;
        
    if ((hNode = LocalAlloc (LMEM_MOVEABLE, sizeof (METADC)))
            && (pNode = (PMETADC) LocalLock (hNode))) {
        *pNode =  *lpobj->pCurMdc;
        lpobj->pCurMdc->pNext = pNode;
        pNode->pNext = NULL;
        lpobj->pCurMdc = pNode;
        LocalUnlock (hNode);
        return TRUE;
    }
    
    if (pNode)
        LocalFree (hNode);

    lpobj->error = OLE_ERROR_MEMORY;    
    return FALSE;
}


BOOL PopDc (lpobj)
LPOBJECT_MF lpobj;
{
    PMETADC pPrev = (PMETADC) (lpobj->pMetaInfo);
    PMETADC pCur  = ((PMETADC) (lpobj->pMetaInfo))->pNext;
    HANDLE  hCur;
        
    if (!pCur)
        // more Pops than Pushes
        return FALSE;
    
    while (pCur->pNext) {
        pPrev = pCur;
        pCur  = pCur->pNext;
    }

    if (hCur = LocalHandle ((WORD) pCur))
        LocalFree (hCur);
    pPrev->pNext    = NULL;
    lpobj->pCurMdc  = pPrev;
}


void CleanStack(lpobj, hMetaInfo)
LPOBJECT_MF lpobj;
HANDLE      hMetaInfo;
{
    PMETADC pCur = ((PMETADC) (lpobj->pMetaInfo))->pNext;
    HANDLE  hCur;
    
    while (pCur) {
        hCur = LocalHandle ((WORD) pCur);
        ((PMETADC) (lpobj->pMetaInfo))->pNext = pCur = pCur->pNext;
        if (hCur)
            LocalFree (hCur);
    }

    LocalFree (hMetaInfo);
    lpobj->fMetaDC      = FALSE;
    lpobj->pCurMdc      = NULL;
    lpobj->pMetaInfo    = NULL;
}

#ifdef META_DEBUG
void PutMetaFuncName (value)
WORD value;
{
    switch (value) {
        case META_SETBKCOLOR:
             OutputDebugString ("SetBkColor ");
             break;
                 
        case META_SETBKMODE:
             OutputDebugString ("SetBkMode ");
             break;
                            
        case META_SETMAPMODE:
             OutputDebugString ("SetMapMode ");
             break;
                        
        case META_SETROP2:
             OutputDebugString ("SetRop2 ");
             break;
                            
        case META_SETRELABS:
             OutputDebugString ("SetRelabs ");
             break;
                            
        case META_SETPOLYFILLMODE:
             OutputDebugString ("SetPolyfillMode ");
             break;
                            
        case META_SETSTRETCHBLTMODE:
             OutputDebugString ("SetStretchBltMode ");
             break;
                            
        case META_SETTEXTCHAREXTRA:
             OutputDebugString ("SetTextCharExtra ");
             break;
                            
        case META_SETTEXTCOLOR:
             OutputDebugString ("SetTextColor ");
             break;
                            
        case META_SETTEXTJUSTIFICATION:
             OutputDebugString ("SetTextJustification ");
             break;
                            
        case META_SETWINDOWORG:
             OutputDebugString ("SetWindowOrg ");
             break;
                            
        case META_SETWINDOWEXT:
             OutputDebugString ("SetWindowExt ");
             break;
                            
        case META_SETVIEWPORTORG:
             OutputDebugString ("SetViewportOrg ");
             break;
                            
        case META_SETVIEWPORTEXT:
             OutputDebugString ("SetViewportExt ");
             break;
                            
        case META_OFFSETWINDOWORG:
             OutputDebugString ("OffsetWindowOrg ");
             break;
                            
        case META_SCALEWINDOWEXT:
             OutputDebugString ("ScaleWindowExt ");
             break;
                            
        case META_OFFSETVIEWPORTORG:
             OutputDebugString ("OffsetViewportOrg ");
             break;
                            
        case META_SCALEVIEWPORTEXT:
             OutputDebugString ("ScaleViewportExt ");
             break;
                            
        case META_LINETO:
             OutputDebugString ("LineTo ");
             break;
                            
        case META_MOVETO:
             OutputDebugString ("MoveTo ");
             break;
                            
        case META_EXCLUDECLIPRECT:
             OutputDebugString ("ExcludeCliprect ");
             break;
                            
        case META_INTERSECTCLIPRECT:
             OutputDebugString ("IntersectCliprect ");
             break;
                            
        case META_ARC:
             OutputDebugString ("Arc ");
             break;
                            
        case META_ELLIPSE:
             OutputDebugString ("Ellipse ");
             break;
                            
        case META_FLOODFILL:
             OutputDebugString ("FloodFill ");
             break;
                            
        case META_PIE:
             OutputDebugString ("Pie ");
             break;
                            
        case META_RECTANGLE:
             OutputDebugString ("Rectangle ");
             break;
                            
        case META_ROUNDRECT:
             OutputDebugString ("RoundRect ");
             break;
                            
        case META_PATBLT:
             OutputDebugString ("PatBlt ");
             break;
                            
        case META_SAVEDC:
             OutputDebugString ("SaveDC ");
             break;
                            
        case META_SETPIXEL:
             OutputDebugString ("SetPixel ");
             break;
                            
        case META_OFFSETCLIPRGN:
             OutputDebugString ("OffsetClipRegion ");
             break;
                            
        case META_TEXTOUT:
             OutputDebugString ("TextOut ");
             break;
                            
        case META_BITBLT:
             OutputDebugString ("BitBlt ");
             break;
                            
        case META_STRETCHBLT:
             OutputDebugString ("StrechBlt ");
             break;
                            
        case META_POLYGON:
             OutputDebugString ("Polygon ");
             break;
                            
        case META_POLYLINE:
             OutputDebugString ("PolyLine ");
             break;
                            
        case META_ESCAPE:
             OutputDebugString ("Escape ");
             break;
                            
        case META_RESTOREDC:
             OutputDebugString ("RestoreDC ");
             break;
                            
        case META_FILLREGION:
             OutputDebugString ("FillRegion ");
             break;
                            
        case META_FRAMEREGION:
             OutputDebugString ("FrameRegion ");
             break;
                            
        case META_INVERTREGION:
             OutputDebugString ("InvertRegion ");
             break;
                            
        case META_PAINTREGION:
             OutputDebugString ("PaintRegion ");
             break;
                            
        case META_SELECTCLIPREGION:
             OutputDebugString ("SelectClipRegion ");
             break;
                            
        case META_SELECTOBJECT:
             OutputDebugString ("SelectObject ");
             break;
                            
        case META_SETTEXTALIGN:
             OutputDebugString ("SetTextAlign ");
             break;
                            
        case META_DRAWTEXT:
             OutputDebugString ("DrawText");
             break;
                            
        case META_CHORD:
             OutputDebugString ("Chord ");
             break;
                            
        case META_SETMAPPERFLAGS:
             OutputDebugString ("SetMapperFlags ");
             break;
                            
        case META_EXTTEXTOUT:
             OutputDebugString ("ExtTextOut ");
             break;
                            
        case META_SETDIBTODEV:
             OutputDebugString ("SetDIBitsToDevice ");
             break;
                            
        case META_SELECTPALETTE:
             OutputDebugString ("SelectPalette ");
             break;
                            
        case META_REALIZEPALETTE:
             OutputDebugString ("RealizePalette ");
             break;
                            
        case META_ANIMATEPALETTE:
             OutputDebugString ("AnimatePalette ");
             break;
                            
        case META_SETPALENTRIES:
             OutputDebugString ("SetPaletteEntries ");
             break;
                            
        case META_POLYPOLYGON:
             OutputDebugString ("PolyPolygon ");
             break;
                            
        case META_RESIZEPALETTE:
             OutputDebugString ("ResizePalette ");
             break;
                            
        case META_DIBBITBLT:
             OutputDebugString ("DibBitBlt ");
             break;
                            
        case META_DIBSTRETCHBLT:
             OutputDebugString ("DibStrechBlt ");
             break;
                            
        case META_DIBCREATEPATTERNBRUSH:
             OutputDebugString ("DibCreatePatternBrush ");
             break;
                            
        case META_STRETCHDIB:
             OutputDebugString ("StretchDIBits ");
             break;
                            
        case META_DELETEOBJECT:
             OutputDebugString ("DeleteObject ");
             break;
                            
        case META_CREATEPALETTE:
             OutputDebugString ("CreatePalette ");
             break;
                            
        case META_CREATEBRUSH:
             OutputDebugString ("CreateBrush ");
             break;
                            
        case META_CREATEPATTERNBRUSH:
             OutputDebugString ("CreatePatternBrush ");
             break;
                            
        case META_CREATEPENINDIRECT:
             OutputDebugString ("CreatePenIndirect ");
             break;
                            
        case META_CREATEFONTINDIRECT:
             OutputDebugString ("CreateFontIndirect ");
             break;
                            
        case META_CREATEBRUSHINDIRECT:
             OutputDebugString ("CreateBrushIndirect ");
             break;
                            
        case META_CREATEBITMAPINDIRECT:
             OutputDebugString ("CreateBitmapIndirect ");
             break;
                            
        case META_CREATEBITMAP:
             OutputDebugString ("CreateBitmap ");
             break;
                            
        case META_CREATEREGION:
             OutputDebugString ("CreateRegion ");
             break;
             
        default:
             OutputDebugString ("Invalid+Function+encountered ");
             break;
                            
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\ole\client\dll.h ===
/****************************** Module Header ******************************\
* Module Name: dll.h
*
* PURPOSE: Private definitions file for ole.c
*
* Created: 1990
*
* Copyright (c) 1990, 1991  Microsoft Corporation
*
* History:
*  Raor, Srinik  (../../90,91)  Original
*
\***************************************************************************/

#define  OLE_INTERNAL

#include    "cmacs.h"
#include    "ole.h"

/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// Defines, Object methods table and Structures.                           //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////


#ifndef HUGE
#define HUGE    huge
#endif

// Different OS version numbers. One of these values will be in the HIWORD
// of the OLE version field

#define OS_WIN16    0x0000
#define OS_MAC      0x0001
#define OS_WIN32    0x0002


// Characteristics Type Field
#define CT_NULL     0L
#define CT_LINK     1L
#define CT_EMBEDDED 2L
#define CT_STATIC   3L
#define CT_OLDLINK  4L
#define CT_PICTURE  5L

#define OLE_NO          0   // for boolean query functions
#define OLE_YES         1   // for boolean query functions

#define MAX_STR         256
#define MAX_NET_NAME    MAX_STR
#define INVALID_INDEX   -1
#define MAX_ATOM        256

#define NUM_RENDER      3

#define PROTOCOL_EDIT       ((LPSTR)"StdFileEditing")
#define PROTOCOL_STATIC     ((LPSTR)"Static")
#define PROTOCOL_EXECUTE    ((LPSTR)"StdExecute")
    
#define READ_ACCESS     0 
#define WRITE_ACCESS    1   

#define POPUP_NETDLG    1

extern  WORD  CheckPointer (LPVOID, int);
WORD FARINTERNAL  FarCheckPointer (LPVOID, int);

#define PROBE_OLDLINK(lpobj){\
        if (lpobj->bOldLink)\
            return OLE_ERROR_OBJECT;\
}


#define PROBE_READ(lp){\
        if (!CheckPointer(lp, READ_ACCESS))\
            return OLE_ERROR_ADDRESS;  \
}

#define PROBE_WRITE(lp){\
        if (!CheckPointer(lp, WRITE_ACCESS))\
            return OLE_ERROR_ADDRESS;  \
}


#define FARPROBE_READ(lp){\
        if (!FarCheckPointer(lp, READ_ACCESS))\
            return OLE_ERROR_ADDRESS;  \
}

#define FARPROBE_WRITE(lp){\
        if (!FarCheckPointer(lp, WRITE_ACCESS))\
            return OLE_ERROR_ADDRESS;  \
}

#define PROBE_MODE(bProtMode) {\
        if (!bProtMode) \
            return OLE_ERROR_PROTECT_ONLY; \
}

extern  OLECLIPFORMAT   cfBinary;
extern  OLECLIPFORMAT   cfOwnerLink;
extern  OLECLIPFORMAT   cfObjectLink;
extern  OLECLIPFORMAT   cfLink;
extern  OLECLIPFORMAT   cfNative;

extern  ATOM            aStdHostNames;
extern  ATOM            aStdTargetDevice ;
extern  ATOM            aStdDocDimensions;
extern  ATOM            aStdDocName;
extern  ATOM            aStdColorScheme;
extern  ATOM            aNullArg;
extern  ATOM            aSave;
extern  ATOM            aChange;
extern  ATOM            aClose;
extern  ATOM            aPackage;

extern  HANDLE          hInstDLL;
extern  DWORD           dwVerToFile;
extern  DWORD           dwVerFromFile;
extern  WORD            wWinVer;
extern  BOOL            bProtMode;

// Used by QuerySize() API;
extern  DWORD           dwObjSize;

extern  OLESTREAM       dllStream;
extern  BOOL            bWLO;

////////////////////////////////////////////////////////////////////////////
//
// Note: Whenever this table is changed, then we need to update the
// method table in ole.h. Otherwise we are in trouble.
//
////////////////////////////////////////////////////////////////////////////

typedef struct _OLEOBJECTVTBL{
    LPVOID          (FAR PASCAL *QueryProtocol)     (LPVOID, LPSTR);
    OLESTATUS       (FAR PASCAL *Release)           (LPVOID);
    OLESTATUS       (FAR PASCAL *Show)              (LPVOID, BOOL);
    OLESTATUS       (FAR PASCAL *DoVerb)            (LPVOID, WORD, BOOL, BOOL);
    OLESTATUS       (FAR PASCAL *GetData)           (LPVOID, OLECLIPFORMAT, LPHANDLE);
    OLESTATUS       (FAR PASCAL *SetData)           (LPVOID, OLECLIPFORMAT, HANDLE);
    OLESTATUS       (FAR PASCAL *SetTargetDevice)   (LPVOID, HANDLE);
    OLESTATUS       (FAR PASCAL *SetBounds)         (LPVOID, LPRECT);
    OLECLIPFORMAT   (FAR PASCAL *EnumFormats)       (LPVOID, OLECLIPFORMAT);

    OLESTATUS       (FAR PASCAL *SetColorScheme)    (LPVOID, LPLOGPALETTE);
    OLESTATUS       (FAR PASCAL *Delete)            (LPVOID);   
    OLESTATUS       (FAR PASCAL *SetHostNames)      (LPVOID, LPSTR, LPSTR);
    
    OLESTATUS       (FAR PASCAL *SaveToStream)      (LPVOID, LPOLESTREAM);
    OLESTATUS       (FAR PASCAL *Clone)             (LPVOID, LPOLECLIENT, LHCLIENTDOC, LPSTR, LPVOID);
    OLESTATUS       (FAR PASCAL *CopyFromLink)      (LPVOID, LPOLECLIENT, LHCLIENTDOC, LPSTR, LPVOID);
    OLESTATUS       (FAR PASCAL *Equal)             (LPVOID, LPVOID);
    OLESTATUS       (FAR PASCAL *CopyToClipboard)   (LPVOID);
    OLESTATUS       (FAR PASCAL *Draw)              (LPVOID, HDC, LPRECT, LPRECT, HDC);
    OLESTATUS       (FAR PASCAL *Activate)          (LPVOID, WORD, BOOL, BOOL, HWND, LPRECT);
    OLESTATUS       (FAR PASCAL *Execute)           (LPVOID, HANDLE, WORD);
    OLESTATUS       (FAR PASCAL *Close)             (LPVOID);
    OLESTATUS       (FAR PASCAL *Update)            (LPVOID);
    OLESTATUS       (FAR PASCAL *Reconnect)         (LPVOID);

    OLESTATUS       (FAR PASCAL *ObjectConvert)     (LPVOID, LPSTR, LPOLECLIENT, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *);

    OLESTATUS       (FAR PASCAL *GetLinkUpdateOptions)      (LPVOID, OLEOPT_UPDATE FAR *);
    OLESTATUS       (FAR PASCAL *SetLinkUpdateOptions)      (LPVOID, OLEOPT_UPDATE);
    OLESTATUS       (FAR PASCAL *Rename)                    (LPVOID, LPSTR);
    OLESTATUS       (FAR PASCAL *QueryName)                 (LPVOID, LPSTR, WORD FAR *);
    OLESTATUS       (FAR PASCAL *QueryType)                 (LPVOID, LPLONG);
    OLESTATUS       (FAR PASCAL *QueryBounds)               (LPVOID, LPRECT);
    OLESTATUS       (FAR PASCAL *QuerySize)                 (LPVOID, DWORD FAR *);    
    OLESTATUS       (FAR PASCAL *QueryOpen)                 (LPVOID);
    OLESTATUS       (FAR PASCAL *QueryOutOfDate)            (LPVOID);
    
    OLESTATUS       (FAR PASCAL *QueryReleaseStatus)        (LPVOID);
    OLESTATUS       (FAR PASCAL *QueryReleaseError)         (LPVOID);
    OLE_RELEASE_METHOD  (FAR PASCAL *QueryReleaseMethod)    (LPVOID);
    
    OLESTATUS       (FAR PASCAL *RequestData)   (LPVOID, OLECLIPFORMAT);
    OLESTATUS       (FAR PASCAL *ObjectLong)    (LPVOID, WORD, LPLONG);
    OLESTATUS       (FAR PASCAL *ChangeData)    (LPVOID, HANDLE, LPOLECLIENT, BOOL);

} OLEOBJECTVTBL;

typedef  OLEOBJECTVTBL  FAR   *LPOLEOBJECTVTBL;


typedef struct _OLEOBJECT { /*object */
    LPOLEOBJECTVTBL lpvtbl;
    char            objId[2];
    HOBJECT         hobj;
    LPOLECLIENT     lpclient;
    LONG            ctype;
    LONG            cx;
    LONG            cy;
    LONG            mm;
    int             iTable;           // Index into the dll table
    ATOM            aObjName;      //** Client
    LHCLIENTDOC     lhclientdoc;   //      Document
    LPOLEOBJECT     lpPrevObj;     //      related
    LPOLEOBJECT     lpNextObj;     //** fileds
    LPOLEOBJECT     lpParent;      // NULL for LE or Static objects.
} OBJECT;



typedef struct _CF_NAME_ATOM {
    char *  cfName;
    ATOM    cfAtom;
} CF_NAME_ATOM;

extern  CF_NAME_ATOM    cfNameAtom[];


typedef struct _METADC {
    int     xMwo;
    int     yMwo;
    int     xMwe;
    int     yMwe;
    int     xre;
    int     yre;
    struct _METADC * pNext;
} METADC, *PMETADC;

typedef struct _METAINFO {
    METADC  headDc;
    int         xwo;
    int         ywo;
    int         xwe;
    int         ywe;
    int         xro;
    int         yro;
} METAINFO, *PMETAINFO;

typedef struct OBJECT_MF { /* object_mf */
    OBJECT          head;
    DWORD           sizeBytes;
    METAFILEPICT    mfp;
    HANDLE          hmfp;
    BOOL            fMetaDC;
    OLESTATUS       error;
    int             nRecord;
    PMETAINFO       pMetaInfo;
    PMETADC         pCurMdc;
} OBJECT_MF;

typedef OBJECT_MF  FAR * LPOBJECT_MF;



typedef struct
{
    OBJECT  head;
    DWORD   sizeBytes;
    int     xSize;  // width in pixels
    int     ySize;  // height in pixels
    HBITMAP hBitmap;    
} OBJECT_BM;

typedef OBJECT_BM FAR * LPOBJECT_BM;



typedef struct _OBJECT_DIB {
    OBJECT  head;
    DWORD   sizeBytes;
    int     xSize;
    int     ySize;
    HANDLE  hDIB;   
} OBJECT_DIB;

typedef OBJECT_DIB FAR * LPOBJECT_DIB;



typedef struct
{
    OBJECT          head;
    OLECLIPFORMAT   cfFormat;
    ATOM            aClass;
    DWORD           sizeBytes;
    HANDLE          hData;
} OBJECT_GEN;

typedef OBJECT_GEN FAR * LPOBJECT_GEN;



typedef struct  _RENDER_ENTRY { /* dll_entry */
    LPSTR       lpClass;
    ATOM        aClass; 
    OLESTATUS   (FARINTERNAL *Load) (LPOLESTREAM, LPOLECLIENT, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, LONG);
} RENDER_ENTRY;


typedef struct _DLL_ENTRY { 
    ATOM        aDll;     /* global atom for dll name with full path */
    HANDLE      hDll;     /* handle to the dll module */
    int         cObj;     /* count of objects, unload dll when this is 0 */
    OLESTATUS   (FAR PASCAL *Load) (LPOLESTREAM, LPSTR, LPOLECLIENT, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, LONG, ATOM, OLECLIPFORMAT);

    OLESTATUS   (FAR PASCAL *Clip) (LPSTR, LPOLECLIENT, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, OLEOPT_RENDER, OLECLIPFORMAT, LONG);

    OLESTATUS   (FAR PASCAL *Link) (LPSTR, LPOLECLIENT, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, OLEOPT_RENDER, OLECLIPFORMAT);

    OLESTATUS   (FAR PASCAL *CreateFromTemplate) (LPSTR, LPOLECLIENT, LPSTR, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, OLEOPT_RENDER, OLECLIPFORMAT);

    OLESTATUS   (FAR PASCAL *Create) (LPSTR, LPOLECLIENT, LPSTR, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, OLEOPT_RENDER, OLECLIPFORMAT);

    OLESTATUS   (FAR PASCAL *CreateFromFile) (LPSTR, LPOLECLIENT, LPSTR, LPSTR, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, OLEOPT_RENDER, OLECLIPFORMAT);

    OLESTATUS   (FAR PASCAL *CreateLinkFromFile) (LPSTR, LPOLECLIENT, LPSTR, LPSTR, LPSTR, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, OLEOPT_RENDER, OLECLIPFORMAT);
    OLESTATUS   (FAR PASCAL *CreateInvisible) (LPSTR, LPOLECLIENT, LPSTR, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, OLEOPT_RENDER, OLECLIPFORMAT, BOOL);

} DLL_ENTRY;





/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// Routines in OLE.C                                                       //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////

BOOL      INTERNAL      CheckObject(LPOLEOBJECT);
BOOL      FARINTERNAL   FarCheckObject(LPOLEOBJECT);
OLESTATUS INTERNAL      LeQueryCreateFromClip (LPSTR, OLEOPT_RENDER, OLECLIPFORMAT, LONG);


/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// Routines in DEFCREAT.C                                                  //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////


OLESTATUS FAR PASCAL   DefLoadFromStream (LPOLESTREAM, LPSTR, LPOLECLIENT, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, LONG, ATOM, OLECLIPFORMAT);

OLESTATUS FAR PASCAL   DefCreateFromClip (LPSTR, LPOLECLIENT, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, OLEOPT_RENDER, OLECLIPFORMAT, LONG);

OLESTATUS FAR PASCAL   DefCreateLinkFromClip (LPSTR, LPOLECLIENT, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, OLEOPT_RENDER, OLECLIPFORMAT);

OLESTATUS FAR PASCAL   DefCreateFromTemplate (LPSTR, LPOLECLIENT, LPSTR, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, OLEOPT_RENDER, OLECLIPFORMAT);

OLESTATUS FAR PASCAL   DefCreate (LPSTR, LPOLECLIENT, LPSTR, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, OLEOPT_RENDER, OLECLIPFORMAT);

OLESTATUS FAR PASCAL   DefCreateFromFile (LPSTR, LPOLECLIENT, LPSTR, LPSTR, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, OLEOPT_RENDER, OLECLIPFORMAT);

OLESTATUS FAR PASCAL   DefCreateLinkFromFile (LPSTR, LPOLECLIENT, LPSTR, LPSTR, LPSTR, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, OLEOPT_RENDER, OLECLIPFORMAT);

OLESTATUS FAR PASCAL   DefCreateInvisible (LPSTR, LPOLECLIENT, LPSTR, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, OLEOPT_RENDER, OLECLIPFORMAT, BOOL);


/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// Routines in PBHANDLR.C                                                  //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////


OLESTATUS FAR PASCAL   PbLoadFromStream (LPOLESTREAM, LPSTR, LPOLECLIENT, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, LONG, ATOM, OLECLIPFORMAT);

OLESTATUS FAR PASCAL   PbCreateFromClip (LPSTR, LPOLECLIENT, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, OLEOPT_RENDER, OLECLIPFORMAT, LONG);

OLESTATUS FAR PASCAL   PbCreateLinkFromClip (LPSTR, LPOLECLIENT, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, OLEOPT_RENDER, OLECLIPFORMAT);

OLESTATUS FAR PASCAL   PbCreateFromTemplate (LPSTR, LPOLECLIENT, LPSTR, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, OLEOPT_RENDER, OLECLIPFORMAT);

OLESTATUS FAR PASCAL   PbCreate (LPSTR, LPOLECLIENT, LPSTR, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, OLEOPT_RENDER, OLECLIPFORMAT);

OLESTATUS FAR PASCAL   PbCreateFromFile (LPSTR, LPOLECLIENT, LPSTR, LPSTR, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, OLEOPT_RENDER, OLECLIPFORMAT);

OLESTATUS FAR PASCAL   PbCreateLinkFromFile (LPSTR, LPOLECLIENT, LPSTR, LPSTR, LPSTR, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, OLEOPT_RENDER, OLECLIPFORMAT);

OLESTATUS FAR PASCAL   PbCreateInvisible (LPSTR, LPOLECLIENT, LPSTR, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, OLEOPT_RENDER, OLECLIPFORMAT, BOOL);





/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// Defines common for le.c, ledde.c, dde.c, doc.c                          //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////


// Constants for chekcing whether the instance is SrvrDLL instance.

#define   WW_LPTR           0       // ptr tosrvr/doc/item
#define   WW_LE             4       // signature
#define   WW_HANDLE         6       // instance handle

#define   WC_LE             0x4c45  // LE chars


// command flags
#define     ACT_SHOW        0x0001      // show the window
#define     ACT_ACTIVATE    0x0002      // activate
#define     ACT_DOVERB      0x0004      // Run the item
#define     ACT_ADVISE      0x0008      // advise for data
#define     ACT_REQUEST     0x0010      // request for data
#define     ACT_CLOSE       0x0020      // request for advise only on close
#define     ACT_UNLAUNCH    0x0040      // unload the server after all the
#define     ACT_TERMSRVR    0x0080      // terminate server
#define     ACT_TERMDOC     0x0100      // terminate document

#define     ACT_NATIVE      0x0200      // only for LNKed objects, if we
                                        // need native data.

#define     ACT_MINIMIZE    0x0400      // launch the app minimized

#define     ACT_NOLAUNCH    0x0800      // don't launch the server

                                            
#define     LN_TEMPLATE     0x0000       // create from template
#define     LN_NEW          0x1000       // create new
#define     LN_EMBACT       0x2000       // activate emb
#define     LN_LNKACT       0x3000       // activate link
#define     LN_MASK         0xf000       // launch mask
#define     LN_SHIFT        12            // shift count for LN_MASK

typedef struct _EDIT_DDE { /* edit_dde */
    HANDLE      hInst;
    int         extraTerm;
    HWND        hClient;
    HWND        hServer;
    BOOL        bTerminating;
    BOOL        bAbort;
    BOOL        bCallLater;     // used in request cases. if this is FALSE
                                // then OLE_CHANGED is sent to client
    int         awaitAck;
    HANDLE      hopt;           // Memory block I may have to free
    int         nAdviseClose;   // count of outstanding advises on closes
    int         nAdviseSave;    // count of outstanding advises on save
    HANDLE      hData;          // Poked data/ temp for holding the
                                // handle in DDE messages

                                // busy parameters
    LONG        lParam;         // lparam value in case we need to
                                // repost the message
    WORD        msg;            // busy repost message

    WORD        wTimer;         // timer id.
} EDIT_DDE;

typedef EDIT_DDE NEAR   *PEDIT_DDE;
typedef EDIT_DDE FAR    *LPEDIT_DDE;

typedef struct _OBJECT_LE { /* object_le */
    OBJECT          head;
    ATOM            app;
    ATOM            topic;
    ATOM            item;
    ATOM            aServer;
    BOOL            bOldLink;           // whether a linked object for old link
    BOOL            bOleServer;         // server which supports the verbs
    WORD            verb;               // verb nuymber;
    WORD            fCmd;               // Command flags;
    OLEOPT_UPDATE   optUpdate;
    OLEOPT_UPDATE   optNew;             // new update options
    LPSTR           lptemplate;         // ptr to the template string, if
                                        // create from template
                                        
    ATOM            aNetName;           // network name on which the doc is
    char            cDrive;             // local drive for that network
    DWORD           dwNetInfo;          // LOW WORD = Net type
                                        // HIGH WORD = Driver version

    LPOLEOBJECT     lpobjPict;

    LONG            lAppData;           // apps data
    LONG            lHandlerData;       // handler data

    HANDLE          hnative;
    HANDLE          hLink;
    HANDLE          hhostNames;         // host name block
    HANDLE          htargetDevice;      // target device info
    HANDLE          hdocDimensions;     // document dimensions
    HANDLE          hextraData;         // reqestdata handle
    WORD            cfExtra;            // extra format data
    HANDLE          hlogpal;          // logiccal palette


    WORD            oldasyncCmd;        // previous asynchronous command
    WORD            asyncCmd;           // asynchronous command
    BOOL            endAsync;           // true if we need to send END_RELEASE.
    BOOL            bAsync;             // true if async command on.
    WORD            mainRtn;            // main async routine
    WORD            subRtn;             // step within the main async routine
    WORD            mainErr;            // failure error
    WORD            subErr;             // step error
    WORD            errHint;            // ;error hint

    BOOL            bSvrClosing;        // TRUE - server in the process of
                                        // closing down
    BOOL            bUnlaunchLater;     // Call EmbLnkDelete from EndAsyncCmd
                                        // if this flag is TRUE
                                            
    HANDLE          hSysEdit;           // handle to system edit.
    PEDIT_DDE       pSysEdit;           // near ptr to system edit.
    HANDLE          hDocEdit;           // handle to doc level channel
    PEDIT_DDE       pDocEdit;           // near ptr to the doc level channel

} OBJECT_LE;
typedef OBJECT_LE  FAR * LPOBJECT_LE;


typedef struct _CLIENTDOC { /* object_le */
    char                    docId[2];
    LPOLEOBJECT             lpHeadObj;
    LPOLEOBJECT             lpTailObj;
    ATOM                    aClass; 
    ATOM                    aDoc;
    HANDLE                  hdoc;
    struct _CLIENTDOC FAR * lpPrevDoc;  
    struct _CLIENTDOC FAR * lpNextDoc;
} CLIENTDOC;
typedef CLIENTDOC  FAR * LPCLIENTDOC;


typedef struct _HOSTNAMES {
    WORD    clientNameOffset;
    WORD    documentNameOffset;
    BYTE    data[];
} HOSTNAMES;

typedef HOSTNAMES FAR * LPHOSTNAMES;

typedef struct _BOUNDSRECT {
    WORD    defaultWidth;
    WORD    defaultHeight;
    WORD    maxWidth;
    WORD    maxHeight;
} BOUNDSRECT;

typedef BOUNDSRECT FAR *LPBOUNDSRECT;


// AwaitAck values
#define AA_REQUEST  1
#define AA_ADVISE   2
#define AA_POKE     3
#define AA_EXECUTE  4
#define AA_UNADVISE 5
#define AA_INITIATE 6

// Bits for Positive WM_DDE_ACK
#define POSITIVE_ACK 0x8000



/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// Routines in LE.C                                                        //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////


LPVOID      FARINTERNAL LeQueryProtocol (LPOBJECT_LE, LPSTR);
OLESTATUS   FARINTERNAL LeRelease (LPOBJECT_LE);
OLESTATUS   FARINTERNAL LeClone (LPOBJECT_LE, LPOLECLIENT, LHCLIENTDOC, LPSTR, LPOBJECT_LE FAR *);
OLESTATUS   FARINTERNAL LeCopyFromLink (LPOBJECT_LE, LPOLECLIENT, LHCLIENTDOC, LPSTR, LPOBJECT_LE FAR *);
OLESTATUS   FARINTERNAL LeEqual (LPOBJECT_LE, LPOBJECT_LE);
OLESTATUS   FARINTERNAL LeCopy (LPOBJECT_LE);
OLESTATUS   FARINTERNAL LeQueryBounds (LPOBJECT_LE, LPRECT);
OLESTATUS   FARINTERNAL LeDraw (LPOBJECT_LE, HDC, LPRECT, LPRECT, HDC);
OLECLIPFORMAT   FARINTERNAL LeEnumFormat (LPOBJECT_LE, OLECLIPFORMAT);
OLESTATUS   FARINTERNAL LeGetData (LPOBJECT_LE, OLECLIPFORMAT, HANDLE FAR *);
OLESTATUS   FARINTERNAL LeRequestData (LPOBJECT_LE, OLECLIPFORMAT);
OLESTATUS   FARINTERNAL LeQueryOutOfDate (LPOBJECT_LE);
OLESTATUS   FARINTERNAL LeObjectConvert (LPOBJECT_LE, LPSTR, LPOLECLIENT, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *); 
OLESTATUS   FARINTERNAL LeChangeData (LPOBJECT_LE, HANDLE, LPOLECLIENT, BOOL);
LPOBJECT_LE FARINTERNAL LeCreateBlank(LHCLIENTDOC, LPSTR, LONG);
void        FARINTERNAL SetExtents (LPOBJECT_LE);
OLESTATUS   FARINTERNAL LeSaveToStream (LPOBJECT_LE, LPOLESTREAM);
OLESTATUS   FARINTERNAL LeLoadFromStream (LPOLESTREAM, LPOLECLIENT, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, LONG, ATOM, OLECLIPFORMAT);
OLESTATUS   INTERNAL    LeStreamRead (LPOLESTREAM, LPOBJECT_LE);
OLESTATUS   INTERNAL    LeStreamWrite (LPOLESTREAM, LPOBJECT_LE);
int         FARINTERNAL ContextCallBack (LPVOID, OLE_NOTIFICATION);
void        INTERNAL    DeleteObjectAtoms (LPOBJECT_LE);
void        FARINTERNAL DeleteExtraData (LPOBJECT_LE);

OLESTATUS   FARINTERNAL LeGetUpdateOptions (LPOBJECT_LE, OLEOPT_UPDATE FAR *);
OLESTATUS   FARINTERNAL LnkPaste (LPOLECLIENT, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, OLEOPT_RENDER, OLECLIPFORMAT, OLECLIPFORMAT);
OLESTATUS   FARINTERNAL EmbPaste (LPOLECLIENT, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, OLEOPT_RENDER, OLECLIPFORMAT);
BOOL        INTERNAL    SetLink (LPOBJECT_LE, HANDLE, LPSTR FAR *);
HANDLE      INTERNAL    GetLink (LPOBJECT_LE);
void        FARINTERNAL SetEmbeddedTopic (LPOBJECT_LE);

OLESTATUS   FAR PASCAL  LeQueryReleaseStatus (LPOBJECT_LE);
OLESTATUS   FAR PASCAL  LeQueryReleaseError (LPOBJECT_LE);
OLE_RELEASE_METHOD FAR PASCAL LeQueryReleaseMethod (LPOBJECT_LE);

OLESTATUS   FARINTERNAL LeQueryType (LPOBJECT_LE, LPLONG);
OLESTATUS   FARINTERNAL LeObjectLong (LPOBJECT_LE, WORD, LPLONG);


void SetNetDrive (LPOBJECT_LE);




/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// Routines in LEDDE.C                                                     //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////


OLESTATUS   FARINTERNAL LeDoVerb  (LPOBJECT_LE, WORD, BOOL, BOOL);
OLESTATUS   FARINTERNAL LeShow (LPOBJECT_LE, BOOL);
OLESTATUS   FARINTERNAL LeQueryOpen (LPOBJECT_LE);
BOOL        INTERNAL    QueryOpen (LPOBJECT_LE); 
OLESTATUS   FARINTERNAL LeActivate (LPOBJECT_LE, WORD, BOOL, BOOL, HWND, LPRECT);
OLESTATUS   FARINTERNAL LeUpdate (LPOBJECT_LE);
OLESTATUS   FARINTERNAL EmbOpen (LPOBJECT_LE, BOOL, BOOL, HWND, LPRECT);
OLESTATUS   FARINTERNAL EmbUpdate (LPOBJECT_LE);
OLESTATUS   FARINTERNAL EmbOpenUpdate (LPOBJECT_LE);
OLESTATUS   FARINTERNAL LnkOpen (LPOBJECT_LE, BOOL, BOOL, HWND, LPRECT);
OLESTATUS   FARINTERNAL LnkUpdate (LPOBJECT_LE);
OLESTATUS   FARINTERNAL LnkOpenUpdate (LPOBJECT_LE);
OLESTATUS   FARINTERNAL LeClose (LPOBJECT_LE);
OLESTATUS   FARINTERNAL LeReconnect (LPOBJECT_LE);
OLESTATUS   INTERNAL    PokeNativeData (LPOBJECT_LE);
BOOL        INTERNAL    PostMessageToServer (PEDIT_DDE, WORD, LONG);

OLESTATUS   FARINTERNAL LeCreateFromTemplate (LPOLECLIENT, LPSTR, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, OLEOPT_RENDER, OLECLIPFORMAT);

OLESTATUS   FARINTERNAL LeCreate (LPOLECLIENT, LPSTR, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, OLEOPT_RENDER, OLECLIPFORMAT);

OLESTATUS   FARINTERNAL LeCreateInvisible (LPOLECLIENT, LPSTR, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, OLEOPT_RENDER, OLECLIPFORMAT, BOOL);

OLESTATUS   FARINTERNAL CreateFromClassOrTemplate (LPOLECLIENT, LPSTR, LPOLEOBJECT FAR *, OLEOPT_RENDER, OLECLIPFORMAT, WORD, LPSTR, LHCLIENTDOC, LPSTR);

OLESTATUS   FARINTERNAL CreateEmbLnkFromFile (LPOLECLIENT, LPSTR, LPSTR, LPSTR, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, OLEOPT_RENDER, OLECLIPFORMAT, LONG);

OLESTATUS   FARINTERNAL LeSetUpdateOptions (LPOBJECT_LE, OLEOPT_UPDATE);

void        INTERNAL    AdvisePict (LPOBJECT_LE, ATOM);
void        INTERNAL    UnAdvisePict (LPOBJECT_LE);
int         INTERNAL    GetPictType (LPOBJECT_LE);
void        INTERNAL    AdviseOn (LPOBJECT_LE, int, ATOM);
void        INTERNAL    UnAdviseOn (LPOBJECT_LE, int);
void        INTERNAL    RequestOn (LPOBJECT_LE, int);
void        INTERNAL    RequestPict (LPOBJECT_LE);
OLESTATUS   FARINTERNAL LeSetHostNames (LPOBJECT_LE, LPSTR, LPSTR);
OLESTATUS   INTERNAL    PokeHostNames (LPOBJECT_LE);
OLESTATUS   INTERNAL    SetHostNamesHandle (LPOBJECT_LE, LPSTR, LPSTR);
void        INTERNAL    FreePokeData (LPOBJECT_LE, PEDIT_DDE);
OLESTATUS   INTERNAL    SendPokeData (LPOBJECT_LE, ATOM, HANDLE, OLECLIPFORMAT);
OLESTATUS   FARINTERNAL LeSetTargetDevice (LPOBJECT_LE, HANDLE);
OLESTATUS   INTERNAL    PokeTargetDeviceInfo (LPOBJECT_LE);
OLESTATUS   INTERNAL    PokeDocDimensions (LPOBJECT_LE);
OLESTATUS   FARINTERNAL LeSetBounds (LPOBJECT_LE, LPRECT);
OLESTATUS   FARINTERNAL LeSetData (LPOBJECT_LE, OLECLIPFORMAT, HANDLE);
BOOL        INTERNAL SendSrvrMainCmd (LPOBJECT_LE, LPSTR);
ATOM        INTERNAL    ExtendAtom (LPOBJECT_LE, ATOM);
BOOL        INTERNAL    CreatePictObject (LHCLIENTDOC, LPSTR, LPOBJECT_LE, OLEOPT_RENDER, OLECLIPFORMAT, LPSTR);
BOOL        INTERNAL    IsSrvrDLLwnd (HWND, HANDLE);
OLESTATUS   INTERNAL    ChangeDocAndItem (LPOBJECT_LE, HANDLE);
BOOL                    QueryUnlaunch (LPOBJECT_LE);
BOOL                    QueryClose (LPOBJECT_LE);
OLESTATUS   FARINTERNAL LeSetColorScheme (LPOBJECT_LE, LPLOGPALETTE);
OLESTATUS   INTERNAL    PokeColorScheme (LPOBJECT_LE);
OLESTATUS   FARINTERNAL ProbeAsync (LPOBJECT_LE);
BOOL        INTERNAL    IsServerValid (LPOBJECT_LE);
BOOL        INTERNAL    IsWindowValid (HWND);
OLESTATUS   FARINTERNAL LeExecute (LPOBJECT_LE, HANDLE, WORD);
void        INTERNAL    FreeGDIdata (HANDLE, OLECLIPFORMAT);
BOOL        INTERNAL    CanPutHandleInPokeBlock (LPOBJECT_LE, OLECLIPFORMAT);


/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// Routines in DDE.C                                                       //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////


long        FARINTERNAL DocWndProc(HWND, unsigned, WORD, LONG );
long        FARINTERNAL SrvrWndProc(HWND, unsigned, WORD, LONG );
BOOL        INTERNAL    CheckAtomValid (ATOM);
void        INTERNAL    HandleAckInitMsg (PEDIT_DDE, HWND);
BOOL        INTERNAL    HandleAck (LPOBJECT_LE, PEDIT_DDE, DWORD);
void        INTERNAL    HandleDataMsg (LPOBJECT_LE, HANDLE, ATOM);
void        INTERNAL    HandleTermMsg (LPOBJECT_LE, PEDIT_DDE, HWND, BOOL);
void        INTERNAL    HandleTimerMsg (LPOBJECT_LE, PEDIT_DDE);
void        INTERNAL    SetData (LPOBJECT_LE, HANDLE, int);
BOOL        INTERNAL    DeleteBusyData (LPOBJECT_LE, PEDIT_DDE);
void        INTERNAL    DeleteAbortData (LPOBJECT_LE, PEDIT_DDE);

BOOL        INTERNAL    WaitDDE (HWND, BOOL);
BOOL        INTERNAL    WaitDDEAck (PEDIT_DDE);

BOOL        INTERNAL    InitSrvrConv (LPOBJECT_LE, HANDLE);
void        INTERNAL    TermSrvrConv (LPOBJECT_LE);
void        INTERNAL    DeleteSrvrEdit (LPOBJECT_LE);
BOOL        INTERNAL    SrvrExecute (LPOBJECT_LE, HANDLE);
void        INTERNAL    SendStdExit (LPOBJECT_LE);
void        INTERNAL    SendStdClose (LPOBJECT_LE);
void        INTERNAL    SendStdExit  (LPOBJECT_LE);

BOOL        FARINTERNAL InitDocConv (LPOBJECT_LE, BOOL);
BOOL        INTERNAL    DocExecute (LPOBJECT_LE, HANDLE);
void        INTERNAL    TermDocConv (LPOBJECT_LE);
void        INTERNAL    DeleteDocEdit (LPOBJECT_LE);

HANDLE      INTERNAL    LeLaunchApp (LPOBJECT_LE);
HANDLE      INTERNAL    LoadApp (LPSTR, WORD);

int         INTERNAL    ScanItemOptions (ATOM, int FAR *);
void        INTERNAL    ChangeDocName (LPOBJECT_LE, LPSTR);
BOOL        INTERNAL    CanCallback (LPOBJECT_LE, int);

void        FARINTERNAL CallEmbLnkDelete (LPOBJECT_LE);


/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// Picture Object routines used by routines in other modules               //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////


LPOBJECT_BM  FARINTERNAL BmCreateBlank (LHCLIENTDOC, LPSTR, LONG);
OLESTATUS    FARINTERNAL BmLoadFromStream (LPOLESTREAM, LPOLECLIENT, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, LONG);
OLESTATUS    FARINTERNAL BmPaste (LPOLECLIENT, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, LONG);


LPOBJECT_DIB FARINTERNAL DibCreateBlank (LHCLIENTDOC, LPSTR, LONG);
LPOBJECT_DIB FARINTERNAL DibCreateObject (HANDLE, LPOLECLIENT, BOOL, LHCLIENTDOC, LPSTR, LONG);
OLESTATUS    FARINTERNAL DibLoadFromStream (LPOLESTREAM, LPOLECLIENT, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, LONG);
OLESTATUS    FARINTERNAL DibPaste (LPOLECLIENT, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, LONG);


LPOBJECT_MF  FARINTERNAL MfCreateBlank (LHCLIENTDOC, LPSTR, LONG);
LPOBJECT_MF  FARINTERNAL MfCreateObject (HANDLE, LPOLECLIENT, BOOL, LHCLIENTDOC, LPSTR, LONG);

OLESTATUS    FARINTERNAL MfLoadFromStream (LPOLESTREAM, LPOLECLIENT, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, LONG);
OLESTATUS    FARINTERNAL MfPaste (LPOLECLIENT, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, LONG);


LPOBJECT_GEN FARINTERNAL GenCreateBlank (LHCLIENTDOC, LPSTR, LONG, ATOM);
OLESTATUS    FARINTERNAL GenLoadFromStream (LPOLESTREAM, LPOLECLIENT, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, LONG, ATOM, OLECLIPFORMAT);
OLESTATUS    FARINTERNAL GenPaste (LPOLECLIENT, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, LPSTR, OLECLIPFORMAT, LONG);



/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// Routines in MAIN.C                                                      //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////

void    FARINTERNAL UnloadDll (void);
int     FARINTERNAL LoadDll (LPSTR);
void    FARINTERNAL DecreaseHandlerObjCount (int);

void    FARINTERNAL RemoveLinkStringFromTopic (LPOBJECT_LE);

OLESTATUS FARINTERNAL CreatePictFromClip (LPOLECLIENT, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, OLEOPT_RENDER, OLECLIPFORMAT, LPSTR, LONG);

OLESTATUS FARINTERNAL CreatePackageFromClip (LPOLECLIENT, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, OLEOPT_RENDER, OLECLIPFORMAT, LONG);




/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// Routines in UTILS.C                                                     //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////


BOOL        PutStrWithLen (LPOLESTREAM, LPSTR);
BOOL        GetStrWithLen (LPOLESTREAM, LPSTR);
ATOM        GetAtomFromStream (LPOLESTREAM);
BOOL        PutAtomIntoStream (LPOLESTREAM, ATOM);
BOOL        GetBytes (LPOLESTREAM, LPSTR, LONG);
BOOL        PutBytes (LPOLESTREAM, LPSTR, LONG);
BOOL        QueryApp (LPSTR, LPSTR, LPSTR);
HANDLE      MapStrToH (LPSTR);
void        UtilMemClr (PSTR, WORD);
BOOL        QueryHandler (WORD);

OLESTATUS INTERNAL      FileExists (LPOBJECT_LE);
ATOM      FARINTERNAL   GetAppAtom (LPSTR);
HANDLE    FARINTERNAL   DuplicateGlobal (HANDLE, WORD);
HANDLE    FARINTERNAL   CopyData (LPSTR, DWORD);
ATOM      FARINTERNAL   DuplicateAtom (ATOM);
BOOL      FARINTERNAL   UtilQueryProtocol (LPOBJECT_LE, LPSTR);
BOOL      FARINTERNAL   CmpGlobals (HANDLE, HANDLE);
void      FARINTERNAL   ConvertToHimetric(LPPOINT);
BOOL      FARINTERNAL   QueryVerb (LPOBJECT_LE, WORD, LPSTR, LONG);
BOOL      FARINTERNAL   MapExtToClass (LPSTR, LPSTR, int);
int       FARINTERNAL   GlobalGetAtomLen (ATOM);
void      FARINTERNAL   UtilMemCpy (LPSTR, LPSTR, DWORD);
BOOL      FARINTERNAL   UtilMemCmp (LPSTR, LPSTR, DWORD);
BOOL      FARINTERNAL   IsObjectBlank (LPOBJECT_LE);

OLESTATUS FARINTERNAL   ObjQueryName (LPOLEOBJECT, LPSTR, WORD FAR *);
OLESTATUS FARINTERNAL   ObjRename (LPOLEOBJECT, LPSTR);
void      INTERNAL      SetExeAtom (LPOBJECT_LE);


// !!!make a routine and let the macro call the routine
// definitions related to the asynchronous operations.
#define WAIT_FOR_ASYNC_MSG(lpobj) {  \
    lpobj->subRtn++;                 \
    if (lpobj->bAsync){              \
        lpobj->endAsync = TRUE;      \
        return OLE_WAIT_FOR_RELEASE; \
    }                                \
}

#define STEP_NOP(lpobj)     lpobj->subRtn++;

// !!! Assumes all the creates are in order
#define PROBE_CREATE_ASYNC(lpobj)        \
    if (lpobj->asyncCmd >= OLE_CREATE &&  \
            lpobj->asyncCmd <= OLE_CREATEINVISIBLE) {\
        if(ProbeAsync(lpobj) == OLE_BUSY)\
            return OLE_BUSY;\
    }
        
#define PROBE_OBJECT_BLANK(lpobj)        \
    if (lpobj->asyncCmd >= OLE_CREATE &&  \
            lpobj->asyncCmd <= OLE_CREATEFROMFILE) { \
        if ((ProbeAsync(lpobj) == OLE_BUSY) && IsObjectBlank(lpobj)) \
            return OLE_ERROR_BLANK;\
    }       

#define PROBE_ASYNC(lpobj)\
        if(ProbeAsync(lpobj) == OLE_BUSY)\
            return OLE_BUSY;

#define IS_SVRCLOSING(lpobj)\
        ((lpobj->bUnlaunchLater || lpobj->bSvrClosing) ? TRUE : FALSE) 
            
#define PROBE_SVRCLOSING(lpobj)\
        if (IS_SVRCLOSING(lpobj)) \
            return OLE_ERROR_NOT_OPEN; \
            

#define CLEAR_STEP_ERROR(lpobj) lpobj->subErr = OLE_OK;


#define   SKIP_TO(a, b)    if (a) goto b;
#define   RESETERR(lpobj)  lpobj->mainErr = OLE_OK
#define   SETSTEP(lpobj, no)  lpobj->subRtn = no
#define   SETERRHINT(lpobj, no) lpobj->errHint = no
#define   CLEARASYNCCMD(lpobj)  lpobj->asyncCmd = OLE_NONE

// routines.
BOOL        ProcessErr          (LPOBJECT_LE);
void        InitAsyncCmd        (LPOBJECT_LE, WORD, WORD);
void        NextAsyncCmd        (LPOBJECT_LE, WORD);
void        ScheduleAsyncCmd    (LPOBJECT_LE);
OLESTATUS   EndAsyncCmd         (LPOBJECT_LE);
OLESTATUS   DocShow             (LPOBJECT_LE);
OLESTATUS   DocRun              (LPOBJECT_LE);
void        SendStdShow         (LPOBJECT_LE);
OLESTATUS   EmbLnkClose         (LPOBJECT_LE);
OLESTATUS   LnkSetUpdateOptions (LPOBJECT_LE);
OLESTATUS   EmbSrvrUnlaunch     (LPOBJECT_LE);
OLESTATUS   LnkChangeLnk        (LPOBJECT_LE);
OLESTATUS   RequestData         (LPOBJECT_LE, OLECLIPFORMAT);

OLESTATUS   FARINTERNAL EmbLnkDelete(LPOBJECT_LE);

void FARINTERNAL FarInitAsyncCmd(LPOBJECT_LE, WORD, WORD);

// async command routines.
#define  EMBLNKDELETE           1
#define  LNKOPENUPDATE          2
#define  DOCSHOW                3
#define  EMBOPENUPDATE          4
#define  EMBLNKCLOSE            5
#define  LNKSETUPDATEOPTIONS    6
#define  LNKCHANGELNK           7
#define  REQUESTDATA            8
#define  DOCRUN                 9

/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// Routines in DOC.C                                                       //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////


BOOL        FARINTERNAL     CheckClientDoc (LPCLIENTDOC);
void        FARINTERNAL     DocAddObject (LPCLIENTDOC, LPOLEOBJECT, LPSTR);
void        FARINTERNAL     DocDeleteObject (LPOLEOBJECT);
LPOLEOBJECT INTERNAL        DocGetNextObject (LPCLIENTDOC, LPOLEOBJECT);



/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// Routines in NET.C                                                       //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////

#define     IDD_DRIVE       500
#define     IDD_PASSWORD    501
#define     IDD_PATH        502

#define     IDS_NETERR          600
#define     IDS_NETCONERRMSG    601
#define     IDS_FILENOTFOUNDMSG 602
#define     IDS_BADPATHMSG      603

OLESTATUS   FARINTERNAL SetNetName (LPOBJECT_LE);
BOOL        FARINTERNAL SetNextNetDrive (LPOBJECT_LE, int FAR *, LPSTR);
OLESTATUS   FARINTERNAL CheckNetDrive (LPOBJECT_LE, BOOL);
OLESTATUS   INTERNAL    FixNet (LPOBJECT_LE, LPSTR, BOOL);
OLESTATUS   INTERNAL    ConnectNet (LPOBJECT_LE, LPSTR);
BOOL        FARINTERNAL ChangeTopic (LPOBJECT_LE);
VOID        INTERNAL    FillDrives (HWND);
int         FAR PASCAL  ConnectDlgProc(HWND, WORD, WORD, DWORD);


/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// Routines in OLE.ASM                                                     //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////

WORD    GetGDIds (DWORD);
WORD    IsMetaDC (HDC, WORD);


/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// Routines in ERROR.C                                                     //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////

OLESTATUS FARINTERNAL   ObjQueryType (LPOLEOBJECT, LPLONG);
OLESTATUS FARINTERNAL   ObjQuerySize (LPOLEOBJECT, DWORD FAR *);
DWORD     PASCAL FAR    DllPut (LPOLESTREAM, LPSTR, DWORD);
HANDLE    FARINTERNAL   DuplicateGDIdata (HANDLE, OLECLIPFORMAT);





/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// Routines in BM.C                                                        //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////

HBITMAP   FARINTERNAL   BmDuplicate (HBITMAP, DWORD FAR *, LPBITMAP);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\ole\client\generic.c ===
/****************************** Module Header ******************************\
* Module Name: GENERIC.C
*
* Handles all API routines for the generic sub-dll of the ole dll.
* Since the data format is unknown, all the routines are written with the
* assumption that all the relevant data is placed in a single global data 
* segment. Note that this assumption is not valid for metafiles, bitmaps, and
* and there can always be some other formats with such idiosyncracies. To
* accommodate those cases the rendering dll writer should replace the relevant
* routines after the creation of the generic object. If for a given class this
* assumption (about data format) is valid then the dll writer need to replace
* only the Draw and QueryBounds functions. 
*
* Created: November-1990
*
* Copyright (c) 1990, 1991 Microsoft Corporation
*
* History:
*
*  Srinik, Raor  (11/05/90) Designed, coded
*
\***************************************************************************/

#include <windows.h>
#include "dll.h"
#include "pict.h"

char aMacText[4] = {'T', 'E', 'X', 'T'};
char aMacRtf[4]  = "RTF";

extern OLESTATUS FARINTERNAL wCreateDummyMetaFile (LPOBJECT_MF, int, int);

#pragma alloc_text(_TEXT, GenSaveToStream, GenLoadFromStream, GetBytes, PutBytes, PutStrWithLen, PutAtomIntoStream, GenQueryBounds)


OLEOBJECTVTBL    vtblGEN  = {

        ErrQueryProtocol,   // check whether the speced protocol is supported

        GenRelease,         // Release
        ErrShow,            // Show
        ErrPlay,            // plat
        GenGetData,         // Get the object data
        GenSetData,         // Set the object data
        ErrSetTargetDevice, //
    
        ErrSetBounds,       // set viewport bounds
        GenEnumFormat,      // enumerate supported formats
        ErrSetColorScheme,  //
        GenRelease,         // delete
        ErrSetHostNames,    //

        GenSaveToStream,    // write to file
        GenClone,           // clone object
        ErrCopyFromLink,    // Create embedded from Link

        GenEqual,           // compares the given objects for data equality

        GenCopy,            // copy to clip

        GenDraw,            // draw the object
            
        ErrActivate,        // open
        ErrExecute,         // excute 
        ErrClose,           // Stop
        ErrUpdate,          // Update
        ErrReconnect,       // Reconnect

        ErrObjectConvert,   // convert object to specified type

        ErrGetUpdateOptions, // update options
        ErrSetUpdateOptions, // update options

        ObjRename,          // Change Object name
        ObjQueryName,       // Get current object name

        GenQueryType,       // Object type
        GenQueryBounds,     // QueryBounds        
        ObjQuerySize,       // Find the size of the object
        ErrQueryOpen,       // Query open
        ErrQueryOutOfDate,  // query whether object is current
            
        ErrQueryRelease,     // release related stuff
        ErrQueryRelease,
        ErrQueryRelease,

        ErrRequestData,    // requestdata
        ErrObjectLong,     // objectLong
        GenChangeData      // change data of the existing object
};


OLESTATUS  FARINTERNAL GenRelease (lpobj)
LPOBJECT_GEN     lpobj;
{
    HOBJECT hobj;

    if (lpobj->hData) {
        GlobalFree (lpobj->hData);
        lpobj->hData = NULL;
    }
    
    if (lpobj->aClass)
        GlobalDeleteAtom (lpobj->aClass);
    
    if (lpobj->head.lhclientdoc)
        DocDeleteObject ((LPOLEOBJECT) lpobj);
    
    if (hobj = lpobj->head.hobj){
        lpobj->head.hobj = NULL;
        GlobalUnlock (hobj);
        GlobalFree (hobj);
    }

    return OLE_OK;
}



OLESTATUS FARINTERNAL GenSaveToStream (lpobj, lpstream)
LPOBJECT_GEN    lpobj;
LPOLESTREAM     lpstream;
{
    LPSTR       lpData;
    OLESTATUS   retVal = OLE_OK;
    DWORD       dwClipFormat = NULL;     
    char        formatName[MAX_STR];
    
    if (!lpobj->hData)
        return OLE_ERROR_BLANK;
    
    if (PutBytes (lpstream, (LPSTR) &dwVerToFile, sizeof(LONG)))
        return OLE_ERROR_STREAM;

    if (PutBytes (lpstream, (LPSTR) &lpobj->head.ctype, sizeof(LONG)))
        return  OLE_ERROR_STREAM;

    if (PutAtomIntoStream (lpstream, lpobj->aClass))
        return OLE_ERROR_STREAM;

    if (lpobj->cfFormat < 0xC000) 
        // then it is a predefined format
        dwClipFormat = lpobj->cfFormat;

    if (PutBytes (lpstream, (LPSTR) &dwClipFormat, sizeof(DWORD)))
        return OLE_ERROR_STREAM;
    
    if (!dwClipFormat) {
        if (!GetClipboardFormatName (lpobj->cfFormat, (LPSTR) formatName,
                        sizeof(formatName)))
            return OLE_ERROR_FORMAT;
        
        if (PutStrWithLen (lpstream, formatName))
            return OLE_ERROR_STREAM;
    }
            
    if (!lpobj->sizeBytes) 
        return OLE_ERROR_BLANK;

    if (PutBytes (lpstream, (LPSTR) &lpobj->sizeBytes, sizeof(DWORD)))
        return OLE_ERROR_STREAM;
    
    if (!(lpData = GlobalLock (lpobj->hData)))
        return OLE_ERROR_MEMORY;
    
    if (PutBytes (lpstream, lpData, lpobj->sizeBytes))
        retVal = OLE_ERROR_STREAM;
        
    GlobalUnlock (lpobj->hData);
    return retVal;
}


OLESTATUS FARINTERNAL  GenClone (lpobjsrc, lpclient, lhclientdoc, lpobjname, lplpobj)
LPOBJECT_GEN        lpobjsrc;
LPOLECLIENT         lpclient;
LHCLIENTDOC         lhclientdoc;
LPSTR               lpobjname;
LPOBJECT_GEN  FAR * lplpobj;
{
    if (!lpobjsrc->hData)
        return OLE_ERROR_BLANK;
    
    if (!CheckClientDoc ((LPCLIENTDOC) lhclientdoc))
        return OLE_ERROR_HANDLE;
    
    if (!(*lplpobj = GenCreateObject (lpobjsrc->hData, lpclient, 
                            FALSE, lhclientdoc, 
                            lpobjname, lpobjsrc->head.ctype)))
        return OLE_ERROR_MEMORY;
    else {
        (*lplpobj)->cfFormat = lpobjsrc->cfFormat;
        (*lplpobj)->aClass = DuplicateAtom (lpobjsrc->aClass);
        return OLE_OK;
    }
}



OLESTATUS FARINTERNAL  GenEqual (lpobj1, lpobj2)
LPOBJECT_GEN lpobj1;
LPOBJECT_GEN lpobj2;
{
    if (CmpGlobals (lpobj1->hData, lpobj2->hData))
        return OLE_OK; 
        
    return  OLE_ERROR_NOT_EQUAL;
}



OLESTATUS FARINTERNAL GenCopy (lpobj)
LPOBJECT_GEN lpobj;
{
    HANDLE  hData;
    
    if (!lpobj->hData)
        return OLE_ERROR_BLANK;

    if (!(hData = DuplicateGlobal (lpobj->hData, GMEM_MOVEABLE)))
        return OLE_ERROR_MEMORY;
    
    SetClipboardData (lpobj->cfFormat, hData);
    return OLE_OK;
}


OLESTATUS FARINTERNAL GenLoadFromStream (lpstream, lpclient, lhclientdoc, lpobjname, lplpobj, objType, aClass, cfFormat)
LPOLESTREAM         lpstream;
LPOLECLIENT         lpclient;
LHCLIENTDOC         lhclientdoc;
LPSTR               lpobjname;
LPOLEOBJECT FAR *   lplpobj;
LONG                objType;
ATOM                aClass;
OLECLIPFORMAT       cfFormat;
{
    LPOBJECT_GEN    lpobj = NULL;
    OLESTATUS       retVal = OLE_ERROR_STREAM;
    HANDLE          hData;
    LPSTR           lpData;    
    DWORD           dwClipFormat; 
    char            formatName[MAX_STR];
    LONG            length;
    
    if (!(*lplpobj = (LPOLEOBJECT) (lpobj = GenCreateBlank(lhclientdoc, 
                                                    lpobjname, objType, 
                                                    aClass)))) {
        if (aClass)
            GlobalDeleteAtom(aClass);
        return OLE_ERROR_MEMORY;
    }

    if (GetBytes (lpstream, (LPSTR) &dwClipFormat, sizeof (DWORD))) 
        goto errLoad;

    // If object is from MAC then we will keep the data intact if the data
    // format is either TEXT or RTF 
    if (HIWORD(dwVerFromFile) == OS_MAC) {
        if (dwClipFormat ==  *((DWORD *) aMacText))
            lpobj->cfFormat = CF_TEXT;
        else if (dwClipFormat == *((DWORD *) aMacRtf))
            lpobj->cfFormat = RegisterClipboardFormat ((LPSTR) "Rich Text Format");
        else 
            lpobj->cfFormat = NULL;
    }
    else {
        // object is created on windows
        if (!dwClipFormat) {
            // this is new file format. format name string follows
            if (GetBytes (lpstream, (LPSTR) &length, sizeof (LONG))
                    || GetBytes (lpstream, (LPSTR)formatName, length)
                    || (!(lpobj->cfFormat = RegisterClipboardFormat ((LPSTR) formatName))))
                goto errLoad;
        }
        else if ((lpobj->cfFormat = (WORD) dwClipFormat) >= 0xc000) {
            // if format is not predefined and file format is old, then use
            // what value is passed to you through "cfFormat" argument
            lpobj->cfFormat = cfFormat;
        }
    }
    
    if (GetBytes (lpstream, (LPSTR) &lpobj->sizeBytes, sizeof (DWORD))) 
        goto errLoad;

    lpobj->head.lpclient = lpclient;
    
    retVal = OLE_ERROR_MEMORY;
    if (!(hData = GlobalAlloc (GMEM_MOVEABLE, lpobj->sizeBytes)))
        goto errLoad;
    
    if (!(lpData = GlobalLock (hData)))
        goto errMem;
    
    if (GetBytes (lpstream, lpData, lpobj->sizeBytes)) {
        retVal = OLE_ERROR_STREAM;
        GlobalUnlock (hData);
        goto errMem;
    }
    
    lpobj->hData = hData;
    GlobalUnlock (hData);
    
    // if the object is from MAC then we want delete this and create blank
    // metafile object, which draws a rectangle
    if ((HIWORD(dwVerFromFile) == OS_MAC) && !lpobj->cfFormat) {
        LPOBJECT_MF lpobjMf;
        
        OleDelete ((LPOLEOBJECT)lpobj);  // delete generic object
            
        // Now create a dummy metafile object which draws a rectangle of size
        // 1" x 1". Note that 1" = 2540 HIMETRIC units
        lpobjMf = MfCreateBlank (lhclientdoc, lpobjname, objType);
        lpobjMf->head.cx = lpobjMf->mfp.xExt = 2540;
        lpobjMf->head.cy = - (lpobjMf->mfp.yExt = 2540);
        if ((retVal = wCreateDummyMetaFile (lpobjMf, lpobjMf->mfp.xExt,
                                    lpobjMf->mfp.yExt)) != OLE_OK) {
            OleDelete ((LPOLEOBJECT) lpobjMf);
            return retVal;
        }
        
        *lplpobj = (LPOLEOBJECT) lpobjMf; 
    }
    
    return OLE_OK;

errMem:
    GlobalFree (hData);
    
errLoad:        
    OleDelete ((LPOLEOBJECT)lpobj);
    *lplpobj = NULL;
    return OLE_ERROR_STREAM;
}




LPOBJECT_GEN INTERNAL GenCreateObject (hData, lpclient, fDelete, lhclientdoc, lpobjname, objType)
HANDLE      hData;
LPOLECLIENT lpclient;
BOOL        fDelete;
LHCLIENTDOC lhclientdoc;
LPSTR       lpobjname;
LONG        objType;
{
    LPOBJECT_GEN     lpobj;
    
    if (!hData)
        return NULL;
    
    if (lpobj = GenCreateBlank (lhclientdoc, lpobjname, objType, NULL)) {
        if (GenChangeData (lpobj, hData, lpclient, fDelete) != OLE_OK) {
            GenRelease (lpobj);
            lpobj = NULL;
        }
    }

    return lpobj;
}


// If the routine fails then the object will be left with it's old data.
// If fDelete is TRUE, then hNewData will be deleted whether the routine
// is successful or not.

OLESTATUS FARINTERNAL GenChangeData (lpobj, hSrcData, lpclient, fDelete)
LPOBJECT_GEN    lpobj;
HANDLE          hSrcData;
LPOLECLIENT     lpclient;
BOOL            fDelete;
{
    HANDLE      hDestData;
    
    if (!fDelete) {
        if (!(hDestData = DuplicateGlobal (hSrcData, GMEM_MOVEABLE))) 
            return OLE_ERROR_MEMORY;
    }
    else {
        // change the ownership to yourself
        if (!(hDestData = GlobalReAlloc(hSrcData,0L,GMEM_MODIFY|GMEM_SHARE))){
            hDestData = DuplicateGlobal (hSrcData, GMEM_MOVEABLE);
            GlobalFree (hSrcData);
            if (!hDestData)
                return OLE_ERROR_MEMORY;
        }
    }
    
    lpobj->head.lpclient = lpclient;
    if (lpobj->hData)
        GlobalFree (lpobj->hData);
    lpobj->hData = hDestData;
    lpobj->sizeBytes = GlobalSize (hDestData);
    
    return OLE_OK;
}



LPOBJECT_GEN FARINTERNAL GenCreateBlank(lhclientdoc, lpobjname, objType, aClass)
LHCLIENTDOC lhclientdoc;
LPSTR       lpobjname;
LONG        objType;
ATOM        aClass;
{
    HOBJECT         hobj;
    LPOBJECT_GEN    lpobj;

    if ((hobj = GlobalAlloc (GMEM_MOVEABLE|GMEM_ZEROINIT,sizeof (OBJECT_GEN)))
            == NULL)
        return NULL;

    if (!(lpobj = (LPOBJECT_GEN) GlobalLock (hobj))){
        GlobalFree (hobj);
        return NULL;
    }

    lpobj->head.objId[0]    = 'L';
    lpobj->head.objId[1]    = 'E';
    lpobj->head.mm          = MM_TEXT;
    lpobj->head.ctype       = objType;
    lpobj->head.lpvtbl      = (LPOLEOBJECTVTBL)&vtblGEN;
    lpobj->head.iTable      = INVALID_INDEX;
    lpobj->head.hobj        = hobj;
    lpobj->aClass           = aClass;
    
    if (objType == CT_STATIC)
        DocAddObject ((LPCLIENTDOC) lhclientdoc, 
            (LPOLEOBJECT) lpobj, lpobjname);
        
    return lpobj;
}


OLESTATUS FARINTERNAL GenPaste (lpclient, lhclientdoc, lpobjname, lplpobj, lpClass, cfFormat, objType)
LPOLECLIENT         lpclient;
LHCLIENTDOC         lhclientdoc;
LPSTR               lpobjname;
LPOLEOBJECT FAR *   lplpobj;
LPSTR               lpClass;
OLECLIPFORMAT       cfFormat;
LONG                objType;
{
    HANDLE  hData = NULL;

    *lplpobj = NULL;
    if (!cfFormat) 
        return OLE_ERROR_FORMAT;
    
    if (!(hData = GetClipboardData(cfFormat)))
        return OLE_ERROR_MEMORY;

    if (!(*lplpobj = (LPOLEOBJECT) GenCreateObject (hData, lpclient, 
                                        FALSE, lhclientdoc, 
                                        lpobjname, objType)))
        return OLE_ERROR_MEMORY;
    
    ((LPOBJECT_GEN)(*lplpobj))->cfFormat = cfFormat;
    ((LPOBJECT_GEN)(*lplpobj))->aClass = GlobalAddAtom (lpClass);
    return OLE_OK;

}



OLESTATUS FARINTERNAL GenQueryType (lpobj, lptype)
LPOLEOBJECT lpobj;
LPLONG      lptype;
{
    return OLE_ERROR_GENERIC;;
}



OLESTATUS FARINTERNAL GenSetData (lpobj, cfFormat, hData)
LPOBJECT_GEN    lpobj;
OLECLIPFORMAT   cfFormat;
HANDLE          hData;
{

    if (lpobj->cfFormat != cfFormat)
        return OLE_ERROR_FORMAT;
    
    if (!hData)
        return OLE_ERROR_BLANK;
    
    GlobalFree (lpobj->hData);
    lpobj->hData = hData;
    lpobj->sizeBytes = GlobalSize (hData);
    return OLE_OK;
}


OLESTATUS FARINTERNAL GenGetData (lpobj, cfFormat, lphandle)
LPOBJECT_GEN    lpobj;
OLECLIPFORMAT   cfFormat;
LPHANDLE        lphandle;
{
    if (cfFormat != lpobj->cfFormat)
        return OLE_ERROR_FORMAT;

    if (!(*lphandle = lpobj->hData))
        return OLE_ERROR_BLANK;
    
    return OLE_OK;

}


OLECLIPFORMAT FARINTERNAL GenEnumFormat (lpobj, cfFormat)
LPOBJECT_GEN    lpobj;
OLECLIPFORMAT   cfFormat;
{
    if (!cfFormat)
        return lpobj->cfFormat;
    
    return NULL;
}


OLESTATUS FARINTERNAL GenQueryBounds (lpobj, lpRc)
LPOBJECT_GEN    lpobj;
LPRECT          lpRc;
{
    lpRc->right     = 0;
    lpRc->left      = 0;
    lpRc->top       = 0;
    lpRc->bottom    = 0;
    return OLE_ERROR_GENERIC;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\ole\client\le.c ===
/****************************** Module Header ******************************\
* Module Name: le.c
*
* Purpose: Handles all API routines for the dde L&E sub-dll of the ole dll.
*
* Created: 1990
*
* Copyright (c) 1990, 1991  Microsoft Corporation
*
* History:
*   Raor, srinik (../../1990,91)    Designed and coded
*
\***************************************************************************/

#include <windows.h>
#include "dll.h"

#define EMB_ID_INDEX    3          // index of ones digit in #000
char    embStr[]        = "#000";

extern  HANDLE          hInfo;
extern  OLECLIPFORMAT   cfNetworkName;

HANDLE  GetNetNameHandle (LPOBJECT_LE);
BOOL    AreTopicsEqual (LPOBJECT_LE, LPOBJECT_LE);

ATOM FARINTERNAL wAtomCat (ATOM, ATOM);

#pragma alloc_text(_RARETEXT, LeObjectLong, LeQueryProtocol, LeEqual, AreTopicsEqual, LeObjectConvert, wAtomCat)

#pragma alloc_text(_DDETEXT, LeRequestData, RequestData, LeChangeData, ContextCallBack, DeleteExtraData, NextAsyncCmd, InitAsyncCmd, FarInitAsyncCmd, EndAsyncCmd, ProcessErr, ScheduleAsyncCmd, LeQueryReleaseStatus, EmbLnkDelete, LeRelease, DeleteObjectAtoms, QueryClose, SendStdClose, TermDocConv, DeleteDocEdit, QueryUnlaunch, SendStdExit, QueryOpen, GetPictType, RequestOn, DocShow, EmbLnkClose, LnkSetUpdateOptions, LnkChangeLnk, TermSrvrConv, DeleteSrvrEdit, LeCopyFromLink)

OLEOBJECTVTBL    vtblLE  = {
        
        LeQueryProtocol,   // check whether the speced protocol is supported
            
        LeRelease,         // release           
        LeShow,            // Show
        LeDoVerb,          // run
        LeGetData,
        LeSetData,
        LeSetTargetDevice, //

        LeSetBounds,       // set viewport bounds
        LeEnumFormat,      // returns format
        LeSetColorScheme,  // set color scheme
        LeRelease,         // delete
        LeSetHostNames,    //
        LeSaveToStream,    // write to file
        LeClone,           // clone object
        LeCopyFromLink,    // Create embedded from Link

        LeEqual,           // test whether the object data is similar

        LeCopy,            // copy to clip

        LeDraw,            // draw the object
            
        LeActivate,        // activate
        LeExecute,         // excute the given commands
        LeClose,           // stop
        LeUpdate,          // Update
        LeReconnect,       // Reconnect
            
        LeObjectConvert,        // convert object to specified type

        LeGetUpdateOptions,     // Get Link Update options
        LeSetUpdateOptions,     // Set Link Update options

        ObjRename,              // Change Object name
        ObjQueryName,           // Get current object name

        LeQueryType,            // object Type
        LeQueryBounds,          // QueryBounds
        ObjQuerySize,           // Find the size of the object
        LeQueryOpen,            // Query open
        LeQueryOutOfDate,       // query whether object is current

        LeQueryReleaseStatus,   // returns release status
        LeQueryReleaseError,    // assynchronusrelease error
        LeQueryReleaseMethod,   // the method/proc which is in assynchronus
                                // operation.
        LeRequestData,          // requestdata
        LeObjectLong,           // objectLong
        LeChangeData            // change native data of existing object
};



//////////////////////////////////////////////////////////////////////////////
//
//  OLESTATUS   FAR PASCAL LeObjectLong (lpobj, wFlags, lpData)
//
//   
//  Returns whether a given object is still processing a previous
//  asynchronous command.  returns OLE_BUSY if the object is still
//  processing the previous command
//   
//  Arguments:
// 
//      lpobj       -   object handle
//      wFlags      -   get, set flags
//      lpData      -   long pointer to data
//
//  Returns:
//
//      OLE_OK
//      OLE_ERROR_OBJECT
//   
//  Effects:     
//   
//////////////////////////////////////////////////////////////////////////////


OLESTATUS   FARINTERNAL LeObjectLong (lpobj, wFlags, lpData)
LPOBJECT_LE lpobj;
WORD        wFlags;
LPLONG      lpData;
{
    LONG    lData;
    
    Puts("LeObjectLong");

    if (!FarCheckObject((LPOLEOBJECT) lpobj))
        return OLE_ERROR_OBJECT;

    if ((lpobj->head.ctype != CT_EMBEDDED) && (lpobj->head.ctype != CT_LINK))
        return OLE_ERROR_OBJECT;
    
    if (wFlags & OF_HANDLER) {
        lData = lpobj->lHandlerData;
        if (wFlags & OF_SET) 
            lpobj->lHandlerData = *lpData;

        if (wFlags & OF_GET) 
            *lpData = lData;
    }
    else {
        lData = lpobj->lAppData;
        if (wFlags & OF_SET) 
            lpobj->lAppData = *lpData;

        if (wFlags & OF_GET) 
            *lpData = lData;
    }
    
    return OLE_OK;
}

//////////////////////////////////////////////////////////////////////////////
//
//  OLESTATUS   FAR PASCAL LeQueryReleaseStatus (lpobj)
//
//   
//  Returns whether a given object is still processing a previous
//  asynchronous command.  returns OLE_BUSY if the object is still
//  processing the previous command
//   
//  Arguments:
// 
//      lpobj       -   object handle
//
//  Returns:
//
//      OLE_BUSY    -   object is busy
//      OLE_OK      -   not busy
//   
//  Effects:     
//   
//////////////////////////////////////////////////////////////////////////////


OLESTATUS   FAR PASCAL LeQueryReleaseStatus (lpobj)
LPOBJECT_LE lpobj;
{

    // probe async will clean up the channels
    // if the server died.


    PROBE_ASYNC (lpobj);
    return OLE_OK;
}

//////////////////////////////////////////////////////////////////////////////
//
//  OLESTATUS   FAR PASCAL LeQueryReleaseError (lpobj)
//   
//  returns the errors of an asynchronous command.
//   
//  Arguments:
// 
//      lpobj       -   object handle
//
//  Returns:
//
//      OLE_ERROR_..    -   if there is any error
//      OLE_OK          -   no error
//   
//  Note: This api is typically valid only during the callback of
//        OLE_RELEASE.
//   
//////////////////////////////////////////////////////////////////////////////

OLESTATUS   FAR PASCAL LeQueryReleaseError (lpobj)
LPOBJECT_LE lpobj;
{
    return lpobj->mainErr;
}

//////////////////////////////////////////////////////////////////////////////
//
//  OLE_RELEASE_METHOD   FAR PASCAL LeQueryReleaseMethod (lpobj)
//   
//  returns the method/command of the asynchronous command which
//  resulted in the OLE_RELEASE call back.
//
//  Arguments:
// 
//      lpobj       -   object handle
//
//  Returns:
//      OLE_RELEASE_METHOD
//   
//  Note: This api is typically valid only during the callback of
//        OLE_RELEASE. Using this api, clients can decide which previous
//        asynchronous command resulted in OLE_RELEASE.
//   
//////////////////////////////////////////////////////////////////////////////
OLE_RELEASE_METHOD   FAR PASCAL LeQueryReleaseMethod (lpobj)
LPOBJECT_LE lpobj;
{
    return lpobj->oldasyncCmd;
}



//////////////////////////////////////////////////////////////////////////////
//
//  LPVOID  FARINTERNAL LeQueryProtocol (lpobj, lpprotocol)
//   
//  Given an oject, returns the new object handle for the new protocol.
//  Does the conversion of objects from one protocol to another one.
//
//  Arguments:
// 
//      lpobj       -   object handle
//      lpprotocol  -   ptr to new protocol string
//
//  Returns:
//      lpobj       -   New object handle
//      null        -   if the protocol is not supported.
//   
//   
//////////////////////////////////////////////////////////////////////////////

LPVOID FARINTERNAL  LeQueryProtocol (lpobj, lpprotocol)
LPOBJECT_LE lpobj;
LPSTR       lpprotocol;
{
    if (lpobj->bOldLink)
        return NULL;
    
    if (!lstrcmp (lpprotocol, PROTOCOL_EDIT))
        return lpobj;

    if  (!lstrcmp (lpprotocol, PROTOCOL_EXECUTE)) {
        if (UtilQueryProtocol (lpobj, lpprotocol))
            return lpobj;
        
        return NULL;
    }
    
    return NULL;
}


//////////////////////////////////////////////////////////////////////////////
//
//  OLESTATUS EmbLnkDelete (lpobj)
//   
//  Routine for the object termination/deletion. Schedules differnt
//  asynchronous commands depending on different conditions.
//  Arguments:
//
//  Sends "StdClose" only if it is Ok to close the document. Sends
//  "StdExit" only if the server has to be unlaunched.  Deletes the object
//  only if the original command is OLE_DELETE.  No need to call back the
//  client if the deletion is internal.
//
//  While delete, this routine is entered several times. EAIT_FOR_ASYNC_MSG
//  results in going back to from where it is called and the next DDE message
//  brings back the control to this routine.
//
//  Arguments:
// 
//      lpobj       -   object handle
//
//  Returns:
//   
//   
//////////////////////////////////////////////////////////////////////////////

OLESTATUS FARINTERNAL EmbLnkDelete (lpobj)
LPOBJECT_LE    lpobj;
{
    HOBJECT     hobj;

    switch (lpobj->subRtn) {

        case    0:

            SKIP_TO (!QueryClose (lpobj), step1);
            // Send "StdCloseDocument"
            SendStdClose (lpobj);
            WAIT_FOR_ASYNC_MSG (lpobj);

        case    1:

            step1:
            SETSTEP (lpobj, 1);
            
            // End the doc conversation
            TermDocConv (lpobj);
            WAIT_FOR_ASYNC_MSG (lpobj);


        case    2:


            // delete the doc edit block. It is Ok even if the object
            // is not actually getting deleted.
            DeleteDocEdit (lpobj);

            // if need to unluanch the app, send stdexit.
            SKIP_TO (!QueryUnlaunch (lpobj), step3);
            SendStdExit (lpobj);
            WAIT_FOR_ASYNC_MSG (lpobj);

        case    3:

            step3:
            SETSTEP (lpobj, 3);

            // Do not set any errors.
            // Terminate the server conversation.
            TermSrvrConv (lpobj);
            WAIT_FOR_ASYNC_MSG (lpobj);

        case    4:

            // delete the server edit block
            DeleteSrvrEdit (lpobj);
            if (lpobj->asyncCmd != OLE_DELETE) {

                // if this delete is called because of unlauncinh of
                // object because of some error, no need to
                // call end asynchronous. It  should have been already
                // called from somewhere else.

                if (lpobj->asyncCmd == OLE_SERVERUNLAUNCH){
                    // send the async cmd;
                    CLEARASYNCCMD (lpobj);
                } else
                    EndAsyncCmd (lpobj);
                return OLE_OK;
            }



            // for real delete delete the atoms and space.
            DeleteObjectAtoms (lpobj);

            if (lpobj->lpobjPict)
                (*lpobj->lpobjPict->lpvtbl->Delete) (lpobj->lpobjPict);

            if (lpobj->hnative)
                GlobalFree (lpobj->hnative);

            if (lpobj->hLink)
                GlobalFree (lpobj->hLink);

            if (lpobj->hhostNames)
                GlobalFree (lpobj->hhostNames);

            if (lpobj->htargetDevice)
                GlobalFree (lpobj->htargetDevice);

            if (lpobj->hdocDimensions)
                GlobalFree (lpobj->hdocDimensions);
            
            DeleteExtraData (lpobj);

            DocDeleteObject ((LPOLEOBJECT) lpobj);
            // send the async cmd;
            EndAsyncCmd (lpobj);

            if (lpobj->head.iTable != INVALID_INDEX)
                DecreaseHandlerObjCount (lpobj->head.iTable);

            hobj = lpobj->head.hobj;
            ASSERT (hobj, "Object handle NULL in delete")

            GlobalUnlock (hobj);
            GlobalFree (hobj);

            return OLE_OK;
    }
}

//////////////////////////////////////////////////////////////////////////////
//
//  OLESTATUS FARINTERNAL LeRelease (lpobj)
//
//  Deletes the given object. This is can be asynchronous operation.
//
//  Arguments:
// 
//      lpobj       -   object handle
//
//  Returns:
//
//      OLE_WAIT_FOR_RELASE: If any DDE_TRANSACTIONS have been queued
//      OLE_OK             : If deletion successfully
//      OLE_ERROR_...      : If any error
//   
//////////////////////////////////////////////////////////////////////////////

OLESTATUS FARINTERNAL LeRelease (lpobj)
LPOBJECT_LE    lpobj;
{


    // For delete allow if the object has been aborted.

    PROBE_ASYNC (lpobj);
    
    // reset the flags so that we do not delete the object based on the old
    // flags
    lpobj->fCmd = 0;
    InitAsyncCmd (lpobj, OLE_DELETE, EMBLNKDELETE);
    return  EmbLnkDelete (lpobj);
}



//////////////////////////////////////////////////////////////////////////////
//
//  OLESTATUS FARINTERNAL  LeClone (lpobjsrc, lpclient, lhclientdoc, lpobjname, lplpobj)
//
//  Clones a given object.
//
//  Arguments:
//
//      lpobjsrc:       ptr to the src object.
//      lpclient:       client callback handle
//      lhclientdoc:    doc handle
//      lpobjname:      object name
//      lplpobj:        holder for returning object.
//
//  Returns:
//      OLE_OK             : successful
//      OLE_ERROR_...      : error
//   
//  Note: If the object being cloned is connected to the server, then
//        the cloned object is not connected to the server. For linked
//        objects, OleConnect has to be called.
//
//
//////////////////////////////////////////////////////////////////////////////

OLESTATUS FARINTERNAL  LeClone (lpobjsrc, lpclient, lhclientdoc, lpobjname, lplpobj)
LPOBJECT_LE         lpobjsrc;
LPOLECLIENT         lpclient;
LHCLIENTDOC         lhclientdoc;
LPSTR               lpobjname;
LPOBJECT_LE  FAR *  lplpobj;
{

    LPOBJECT_LE    lpobj = NULL;
    int            retval = OLE_ERROR_MEMORY;

    // Assumes all the creates are in order
//    PROBE_OBJECT_BLANK(lpobjsrc);

    PROBE_CREATE_ASYNC(lpobjsrc);
    
    if (!(lpobj = LeCreateBlank(lhclientdoc, lpobjname, 
                        lpobjsrc->head.ctype)))
        goto errRtn;

    lpobj->head.lpclient = lpclient;
    lpobj->head.iTable  = lpobjsrc->head.iTable; //!!! dll loading
    lpobj->head.lpvtbl  = lpobjsrc->head.lpvtbl;

    // set the atoms.
    lpobj->app          = DuplicateAtom (lpobjsrc->app);
    lpobj->topic        = DuplicateAtom (lpobjsrc->topic);
    lpobj->item         = DuplicateAtom (lpobjsrc->item);
    lpobj->aServer      = DuplicateAtom (lpobjsrc->aServer);

    lpobj->bOleServer   = lpobjsrc->bOleServer;
    lpobj->verb         = lpobjsrc->verb;
    lpobj->fCmd         = lpobjsrc->fCmd;

    lpobj->aNetName     = DuplicateAtom (lpobjsrc->aNetName);
    lpobj->cDrive       = lpobjsrc->cDrive;
    lpobj->dwNetInfo    = lpobjsrc->dwNetInfo;

    if (lpobjsrc->htargetDevice)
        lpobj->htargetDevice = DuplicateGlobal (lpobjsrc->htargetDevice, 
                                    GMEM_MOVEABLE);
    
    if (lpobjsrc->head.ctype == CT_EMBEDDED) {
        if (lpobjsrc->hnative) {
            if (!(lpobj->hnative = DuplicateGlobal (lpobjsrc->hnative, 
                                        GMEM_MOVEABLE)))
                goto errRtn;
        }
        
        if (lpobjsrc->hdocDimensions) 
            lpobj->hdocDimensions = DuplicateGlobal (lpobjsrc->hdocDimensions,
                                            GMEM_MOVEABLE);     
        if (lpobjsrc->hlogpal) 
            lpobj->hlogpal = DuplicateGlobal (lpobjsrc->hlogpal, 
                                            GMEM_MOVEABLE);     
        SetEmbeddedTopic (lpobj);                                       
    }
    else {
        lpobj->bOldLink     = lpobjsrc->bOldLink;
        lpobj->optUpdate    = lpobjsrc->optUpdate;
    }
    
    retval = OLE_OK;
    // if picture is needed clone the picture object.
    if ((!lpobjsrc->lpobjPict) ||
         ((retval = (*lpobjsrc->lpobjPict->lpvtbl->Clone)(lpobjsrc->lpobjPict,
                                    lpclient, lhclientdoc, lpobjname,
                                    (LPOLEOBJECT FAR *)&lpobj->lpobjPict)) 
                    == OLE_OK)) {
        SetExtents (lpobj);
        *lplpobj = lpobj;
        if (lpobj->lpobjPict)
            lpobj->lpobjPict->lpParent = (LPOLEOBJECT) lpobj;
    }
    
    return retval;

errRtn:

    // This oledelete should not result in any async communication.
    if (lpobj)
        OleDelete ((LPOLEOBJECT)lpobj);

    return retval;
}


//////////////////////////////////////////////////////////////////////////////
//
//  OLESTATUS FARINTERNAL  LeCopyFromLink (lpobjsrc, lpclient, lhclientdoc, lpobjname, lplpobj)
//
//  Creates an embedded object from a lonked object. If the linked object
//  is not activated, then launches the server, gets the native data and
//  unlaunches the server. All these operations are done silently.
//
//  Arguments:
//
//      lpobjsrc:       ptr to the src object.
//      lpclient:       client callback handle
//      lhclientdoc:    doc handle
//      lpobjname:      object name
//      lplpobj:        holder for returning object.
//
//  Returns:
//      OLE_OK             : successful
//      OLE_ERROR_...      : error
//      OLE_WAITF_FOR_RELEASE : if DDE transcation is queued
//   
//  Note: Could result in asynchronous operation if there is any
//        DDE operaion involved in getting any data from the server.
//
//        Also, If there is any error in getting the native data, the
//        client is expected delete the object after the OLE_RELEASE
//        call back
//
//////////////////////////////////////////////////////////////////////////////

OLESTATUS FARINTERNAL  LeCopyFromLink (lpobjsrc, lpclient, lhclientdoc, lpobjname, lplpobj)
LPOBJECT_LE         lpobjsrc;
LPOLECLIENT         lpclient;
LHCLIENTDOC         lhclientdoc;
LPSTR               lpobjname;
LPOBJECT_LE  FAR *  lplpobj;
{

    LPOBJECT_LE    lpobj;
    int            retval;


    *lplpobj = NULL;
    PROBE_OLDLINK (lpobjsrc);
    if (lpobjsrc->head.ctype != CT_LINK)
        return OLE_ERROR_NOT_LINK;

    PROBE_ASYNC (lpobjsrc);
    PROBE_SVRCLOSING(lpobjsrc);
    
    if ((retval = LeClone (lpobjsrc, lpclient, lhclientdoc, lpobjname,
                    (LPOBJECT_LE FAR *)&lpobj)) != OLE_OK)
        return retval;


    // we successfully cloned the object. if picture object has native data
    // then grab it and put it in LE object. otherwise activate and get native
    // data also.
    
    if (lpobj->lpobjPict 
            && (*lpobj->lpobjPict->lpvtbl->EnumFormats)
                                (lpobj->lpobjPict, NULL) == cfNative){
        // Now we know that the picture object is of native format, and it
        // means that it is a generic object. So grab the handle to native
        // data and put it in LE object.

        lpobj->hnative = ((LPOBJECT_GEN) (lpobj->lpobjPict))->hData; 
        ((LPOBJECT_GEN) (lpobj->lpobjPict))->hData = NULL;
        (*lpobj->lpobjPict->lpvtbl->Delete) (lpobj->lpobjPict);
        lpobj->lpobjPict = NULL;
        SetEmbeddedTopic (lpobj);
        *lplpobj = lpobj;
        return OLE_OK;
    } else {
    
        // if necessary launch, get native data and unlaunch the app.
        lpobj->fCmd = LN_LNKACT | ACT_REQUEST | ACT_NATIVE | (QueryOpen(lpobjsrc) ? ACT_TERMDOC : ACT_UNLAUNCH);
        InitAsyncCmd (lpobj, OLE_COPYFROMLNK, LNKOPENUPDATE);
        if ((retval = LnkOpenUpdate (lpobj)) > OLE_WAIT_FOR_RELEASE)
            LeRelease (lpobj);
        else
            *lplpobj = lpobj;
        
        return retval;
        
        // we will be changing the topic in end conversation.
    }
}


//////////////////////////////////////////////////////////////////////////////
//
//  OLESTATUS FARINTERNAL  LeEqual (lpobj1, lpobj2)
//
//  Checks whethere two objects are equal. Checks for equality
//  of links, native data and picture data.
//
//  Arguments:
//
//      lpobj1:      first object
//      lpobj2:      second object
//
//  Returns:
//      OLE_OK              : equal
//      OLE_ERROR_NOT_EQUAL : if not equal
//      OLE_ERROR_.....     : any errors
//   
//  Note: If any of the objects are connectd to the servers, leequal operaion
//        may not make much sense because the data might be changing from the
//        the server
//
//////////////////////////////////////////////////////////////////////////////

OLESTATUS FARINTERNAL  LeEqual (lpobj1, lpobj2)
LPOBJECT_LE lpobj1;
LPOBJECT_LE lpobj2;
{
    
    if (lpobj1->app != lpobj2->app)
        return OLE_ERROR_NOT_EQUAL;
    
    // type of the objects is same. Otherwise this routine won't be called
    if (lpobj1->head.ctype == CT_LINK) {
        if (AreTopicsEqual (lpobj1, lpobj2) && (lpobj1->item == lpobj2->item))
            return OLE_OK;
            
        return OLE_ERROR_NOT_EQUAL;
    }
    else {
        ASSERT (lpobj1->head.ctype == CT_EMBEDDED, "Invalid ctype in LeEqual")
            
        if (lpobj1->item != lpobj2->item)  
            return OLE_ERROR_NOT_EQUAL;
        
        if (CmpGlobals (lpobj1->hnative, lpobj2->hnative))
            return OLE_OK;
        else
            return OLE_ERROR_NOT_EQUAL;
    }   
    
    //### we may have to compare the picture data also
}


//////////////////////////////////////////////////////////////////////////////
//
//  OLESTATUS FARINTERNAL  LeCopy (lpobj)
//
//  Copies the object to the clipboard. Even for linked objects
//  we do not render the objectlink. It is up to the client app
//  to render object link
//
//  Arguments:
//
//      lpobj:      object handle
//
//  Returns:
//      OLE_OK              : successful
//      OLE_ERROR_.....     : any errors
//   
//  Note: Library does not open the clipboard. Client is supposed to
//        open the librray before this call is made
//
//////////////////////////////////////////////////////////////////////////////

OLESTATUS FARINTERNAL  LeCopy (lpobj)
LPOBJECT_LE    lpobj;
{
    HANDLE      hlink    = NULL;
    HANDLE      hnative  = NULL;
    
    PROBE_OLDLINK (lpobj);
    // Assumes all the creates are in order
//    PROBE_OBJECT_BLANK(lpobj);

    PROBE_CREATE_ASYNC(lpobj);
    
    if (lpobj->head.ctype == CT_EMBEDDED){
        if (!(hnative = DuplicateGlobal (lpobj->hnative, GMEM_MOVEABLE)))
            return OLE_ERROR_MEMORY;
        SetClipboardData (cfNative, hnative);
    }
    
    hlink = GetLink (lpobj);
    if (!(hlink = DuplicateGlobal (hlink, GMEM_MOVEABLE)))
        return OLE_ERROR_MEMORY;
    SetClipboardData (cfOwnerLink, hlink);
    
    // copy network name if it exists
    if (lpobj->head.ctype == CT_LINK  && lpobj->aNetName) {
        HANDLE hNetName;
        
        if (hNetName = GetNetNameHandle (lpobj))
            SetClipboardData (cfNetworkName, hNetName);
    }
        
    if (lpobj->lpobjPict)
        return (*lpobj->lpobjPict->lpvtbl->CopyToClipboard)(lpobj->lpobjPict);

    return OLE_OK;
}


//////////////////////////////////////////////////////////////////////////////
//
//  OLESTATUS FARINTERNAL LeQueryBounds (lpobj, lpRc)
//
//  Returns the bounding rectangle of the object. Returns topleft
//  as zero always and the units are himetric units.
//
//  Arguments:
//
//      lpobj:      object handle
//
//  Returns:
//      OLE_OK              : successful
//      OLE_ERROR_.....     : any errors
//   
//  Note: Library does not open the clipboard. Client is supposed to
//        open the librray before this call is made
//
//////////////////////////////////////////////////////////////////////////////


OLESTATUS FARINTERNAL LeQueryBounds (lpobj, lpRc)
LPOBJECT_LE    lpobj;
LPRECT         lpRc;
{
    Puts("LeQueryBounds");

    // MM_HIMETRIC units

    lpRc->left     =  0;
    lpRc->top      =  0;
    lpRc->right    =  (int) lpobj->head.cx;
    lpRc->bottom   =  (int) lpobj->head.cy;

    if (lpRc->right || lpRc->bottom)
        return OLE_OK;

    if (!lpobj->lpobjPict)
        return OLE_ERROR_BLANK;
    
    return (*lpobj->lpobjPict->lpvtbl->QueryBounds) (lpobj->lpobjPict, lpRc);
}


//////////////////////////////////////////////////////////////////////////////
//
//  OLESTATUS FARINTERNAL  LeDraw (lpobj, hdc, lprc, lpWrc, hdcTarget)
//
//  Draws the object. Calls the picture object for drawing the object
//
//
//  Arguments:
//
//       lpobj:       source object
//       hdc:         handle to dest dc. Could be metafile dc
//       lprc:        rectangle into which the object should be drawn
//                    should be in himetric units and topleft
//                    could be nonzero.
//       hdctarget:   Target dc for which the object should be drawn
//                    (Ex: Draw metafile on the dest dc using the attributes
//                         of traget dc).
//
//  Returns:
//      OLE_OK              : successful
//      OLE_ERROR_BLANK     : no picture
//   
//
//////////////////////////////////////////////////////////////////////////////

OLESTATUS FARINTERNAL  LeDraw (lpobj, hdc, lprc, lpWrc, hdcTarget)
LPOBJECT_LE     lpobj;
HDC             hdc;
LPRECT          lprc;
LPRECT          lpWrc;
HDC             hdcTarget;
{   
    if (lpobj->lpobjPict)
        return (*lpobj->lpobjPict->lpvtbl->Draw) (lpobj->lpobjPict, 
                                        hdc, lprc, lpWrc, hdcTarget);
    return OLE_ERROR_BLANK;
}


//////////////////////////////////////////////////////////////////////////////
//
//  OLECLIPFORMAT FARINTERNAL LeEnumFormat (lpobj, cfFormat)
//
//  Enumerates the object formats.
//
//
//  Arguments:
//
//       lpobj      :  source object
//       cfFormat   :  ref fprmat
//
//  Returns:
//      NULL        :  no more formats or if we do not understand the
//                     given format.
//
//  Note: Even if the object is connected, we do not enumerate all the formats
//        the server can render. Server protocol can render the format list
//        only on system channel. Object can be connected only on the doc
//        channel
//
//////////////////////////////////////////////////////////////////////////////

OLECLIPFORMAT FARINTERNAL LeEnumFormat (lpobj, cfFormat)
LPOBJECT_LE    lpobj;
OLECLIPFORMAT  cfFormat;
{
    Puts("LeEnumFormat");
    
    ASSERT((lpobj->head.ctype == CT_LINK)||(lpobj->head.ctype == CT_EMBEDDED),
        "Invalid Object Type");  

    // switch is not used because case won't take variable argument
    if (cfFormat == NULL) {
        if (lpobj->head.ctype == CT_EMBEDDED) 
            return cfNative;
        else
            return (lpobj->bOldLink ? cfLink : cfObjectLink);
    }

    if (cfFormat == cfNative) {
        if (lpobj->head.ctype == CT_EMBEDDED) 
            return cfOwnerLink;
        else
            return NULL;    
    }

    if (cfFormat == cfObjectLink) {
        if (lpobj->aNetName)
            return cfNetworkName;
        else
            cfFormat = NULL;
    }
    else if  (cfFormat == cfOwnerLink || cfFormat == cfLink 
                        || cfFormat == cfNetworkName)
        cfFormat = NULL;

    if (lpobj->lpobjPict)
        return (*lpobj->lpobjPict->lpvtbl->EnumFormats) (lpobj->lpobjPict, cfFormat);
    
    return NULL;
}

////////////////////////////////////////////////////////////////////////////////
//
//
//  OLESTATUS FARINTERNAL LeRequestData (lpobj, cfFormat)
//
//  Requests data from the server for a given format, if the server
//  is connected. If the server is not connected returns error.
//
//
//  Arguments:
//
//       lpobj:       source object
//       cfFormat:    ref fprmat
//
//  Returns:
//       OLE_WAIT_FOR_RELEASE : If the data request data is sent to
//                              the server.
//       OLE_ERROR_NOT_OPEN   : Server is not open for data
//
//  Note: If the server is ready, sends request to the server. When the
//        the data comes back from the server OLE_DATA_READY is sent in
//        the callback and the client can use Getdata to get the data.
//
//
//////////////////////////////////////////////////////////////////////////////



OLESTATUS FARINTERNAL LeRequestData (lpobj, cfFormat)
LPOBJECT_LE     lpobj;
OLECLIPFORMAT   cfFormat;
{

    // Assumes all the creates are in order
    PROBE_ASYNC(lpobj);
    PROBE_SVRCLOSING(lpobj);
    
    if (!QueryOpen (lpobj))
        return  OLE_ERROR_NOT_OPEN;

    if (cfFormat == cfOwnerLink || cfFormat == cfObjectLink)
        return OLE_ERROR_FORMAT;
    
    if (!(cfFormat == cfNative && lpobj->head.ctype == CT_EMBEDDED)
            && (cfFormat != (OLECLIPFORMAT) GetPictType (lpobj))) {
        DeleteExtraData (lpobj);
        lpobj->cfExtra = cfFormat;
    }

    InitAsyncCmd (lpobj, OLE_REQUESTDATA, REQUESTDATA);
    lpobj->pDocEdit->bCallLater = FALSE;    
    return RequestData(lpobj, cfFormat);
}


OLESTATUS  RequestData (lpobj, cfFormat)
LPOBJECT_LE     lpobj;
OLECLIPFORMAT   cfFormat;
{
    switch (lpobj->subRtn) {

        case 0:
            RequestOn (lpobj, cfFormat);
            WAIT_FOR_ASYNC_MSG (lpobj);

        case 1:
            ProcessErr (lpobj);
            return EndAsyncCmd (lpobj);

        default:
            ASSERT (TRUE, "unexpected step in Requestdata");
            return OLE_ERROR_GENERIC;
    }
}



////////////////////////////////////////////////////////////////////////////////
//
//
//  OLESTATUS FARINTERNAL LeGetData (lpobj, cfFormat, lphandle)
//
//  Returns the data handle for a given format
//
//  Arguments:
//
//       lpobj:       source object
//       cfFormat:    ref fprmat
//       lphandle:    handle return
//
//  Returns:
//      NULL                : no more formats or if we do not understand the
//                            given format.
//
//  Note: Even if the object is connected, we do not get the data from the
//        server. Getdata can not be used for getting data in any other
//        format other than the formats available with the object on
//        the client side.
//
//////////////////////////////////////////////////////////////////////////////

OLESTATUS FARINTERNAL LeGetData (lpobj, cfFormat, lphandle)
LPOBJECT_LE     lpobj;
OLECLIPFORMAT   cfFormat;
LPHANDLE        lphandle;
{

    // Assumes all the creates are in order
//    PROBE_OBJECT_BLANK(lpobj);

    PROBE_CREATE_ASYNC(lpobj);
    
    *lphandle = NULL;

    // The assumption made here is that the native data can be in either
    // LE object or picture object.
    if ((cfFormat == cfNative) && (lpobj->hnative)) {
        ASSERT ((lpobj->head.ctype == CT_EMBEDDED) || (!lpobj->lpobjPict) ||
            ((*lpobj->lpobjPict->lpvtbl->EnumFormats) (lpobj->lpobjPict, NULL)
                        != cfNative), "Native data at wrong Place");
        *lphandle = lpobj->hnative;
        return OLE_OK;
    }
    
    if (cfFormat == cfOwnerLink && lpobj->head.ctype == CT_EMBEDDED) {
        if (*lphandle = GetLink (lpobj))
            return OLE_OK;
        
        return OLE_ERROR_BLANK;
    }

    if ((cfFormat == cfObjectLink || cfFormat == cfLink) &&
            lpobj->head.ctype == CT_LINK) {
        if (*lphandle = GetLink (lpobj))
            return OLE_OK;
        
        return OLE_ERROR_BLANK;
    }
    
    if (cfFormat == cfNetworkName) {
        if (lpobj->aNetName && (*lphandle = GetNetNameHandle (lpobj)))
            return OLE_WARN_DELETE_DATA;

        return OLE_ERROR_BLANK;
    }
    
    if (cfFormat == lpobj->cfExtra) {
        if (*lphandle = lpobj->hextraData)
            return OLE_OK;

        return OLE_ERROR_BLANK;
    }

    if (!lpobj->lpobjPict && cfFormat)
        return OLE_ERROR_FORMAT;
    
    return (*lpobj->lpobjPict->lpvtbl->GetData) (lpobj->lpobjPict, cfFormat, lphandle);
}




OLESTATUS FARINTERNAL LeQueryOutOfDate (lpobj)
LPOBJECT_LE    lpobj;
{
    return OLE_OK;
}


////////////////////////////////////////////////////////////////////////////////
//
//  OLESTATUS FARINTERNAL LeObjectConvert (lpobj, lpprotocol, lpclient, lhclientdoc, lpobjname, lplpobj)
//
//  Converts a given  linked/embedded object to static object.
//
//  Arguments:
//          lpobj      : source object
//          lpprotocol : protocol
//          lpclient   : client callback for the new object
//          lhclientdoc: client doc
//          lpobjname  : object name
//          lplpobj    : object return
//
//
//  Returns:
//      OLE_OK          :  successful
//      OLE_ERROR_....  :  any errors
//
//////////////////////////////////////////////////////////////////////////////

OLESTATUS FARINTERNAL LeObjectConvert (lpobj, lpprotocol, lpclient, lhclientdoc, lpobjname, lplpobj)
LPOBJECT_LE         lpobj;
LPSTR               lpprotocol;
LPOLECLIENT         lpclient;
LHCLIENTDOC         lhclientdoc;
LPSTR               lpobjname;
LPOLEOBJECT FAR *   lplpobj;
{
    OLESTATUS       retVal;

    PROBE_ASYNC (lpobj);
    
    *lplpobj = NULL;
    
    if (lstrcmp (lpprotocol, PROTOCOL_STATIC))
        return OLE_ERROR_PROTOCOL;

    if (!lpobj->lpobjPict || 
            ((*lpobj->lpobjPict->lpvtbl->QueryType) (lpobj->lpobjPict, NULL)
                    == OLE_ERROR_GENERIC)) {
        // Either no picture object or non-standard picture object.
        // Create a metafile Object.
    
        HDC             hMetaDC;
        RECT            rc; 
        HANDLE          hMF = NULL, hmfp = NULL;
        LPMETAFILEPICT  lpmfp;
    
        OleQueryBounds ((LPOLEOBJECT) lpobj, &rc);
        if (!(hMetaDC = CreateMetaFile (NULL)))
            goto Cleanup;
        
        SetWindowOrg (hMetaDC, rc.left, rc.top);
        SetWindowExt (hMetaDC, rc.right - rc.left, rc.bottom - rc.top);
        retVal = OleDraw ((LPOLEOBJECT) lpobj, hMetaDC, &rc, &rc, NULL);
        hMF = CloseMetaFile (hMetaDC);
        if ((retVal != OLE_OK) ||  !hMF)
            goto Cleanup;
        
        if (!(hmfp = GlobalAlloc (GMEM_MOVEABLE, sizeof (METAFILEPICT))))
            goto Cleanup;
            
        if (!(lpmfp = (LPMETAFILEPICT) GlobalLock (hmfp)))
            goto Cleanup;
        
        lpmfp->hMF  = hMF;
        lpmfp->mm   = MM_ANISOTROPIC;
        lpmfp->xExt = rc.right - rc.left;
        lpmfp->yExt = rc.top - rc.bottom;
        GlobalUnlock (hmfp);
        
        if (*lplpobj = (LPOLEOBJECT) MfCreateObject (hmfp, lpclient, TRUE, 
                                        lhclientdoc, lpobjname, CT_STATIC))
            return OLE_OK;

Cleanup:        
        if (hMF) 
            DeleteMetaFile (hMF);
        
        if (hmfp)
            GlobalFree (hmfp);
        
        return OLE_ERROR_MEMORY;
    }

    
    // Picture object is one of the standard objects
    if ((retVal = (*lpobj->lpobjPict->lpvtbl->Clone) (lpobj->lpobjPict, 
                                lpclient, lhclientdoc, 
                                lpobjname, lplpobj)) == OLE_OK) {
        (*lplpobj)->ctype = CT_STATIC;
        DocAddObject ((LPCLIENTDOC) lhclientdoc, *lplpobj, lpobjname);
    }
    
    return retVal;
}



// internal method used for changing picture/native data
OLESTATUS FARINTERNAL LeChangeData (lpobj, hnative, lpoleclient, fDelete)
LPOBJECT_LE     lpobj;
HANDLE          hnative;
LPOLECLIENT     lpoleclient;
BOOL            fDelete;
{
    if (!fDelete) {
        if (!(hnative = DuplicateGlobal (hnative, GMEM_MOVEABLE)))
            return OLE_ERROR_MEMORY;
    }

    // In case of a CopyFromLink, eventhough the object type is CT_LINK, the
    // native data should go to LE object rather than the picture object, as
    // we are going to change the object type to embedded after the required
    // data is recieved.
        
    if ((lpobj->head.ctype == CT_LINK) 
            && (lpobj->asyncCmd != OLE_COPYFROMLNK)
            && (lpobj->asyncCmd != OLE_CREATEFROMFILE)) {
        if (lpobj->lpobjPict)
            return  (*lpobj->lpobjPict->lpvtbl->SetData) 
                            (lpobj->lpobjPict, cfNative, hnative);
    }
    else { // It must be embedded.
        if (lpobj->hnative)
            GlobalFree (lpobj->hnative);
        lpobj->hnative = hnative;
        return OLE_OK;
    }
    
    return OLE_ERROR_BLANK;
}



////////////////////////////////////////////////////////////////////////////////
//
//  LPOBJECT_LE FARINTERNAL LeCreateBlank (lhclientdoc, lpobjname, ctype)
//
//  Create a blank object. Global block is used for the object and it is
//  locked once sucessful. Unlocking is done only while deletion. Object
//  is added to the corresponding doc.
//
//  'LE' signature is used for object validation.
//
//  Arguments:
//      lhclientdoc     :  client doc handle
//      lpobjname       :  object name
//      ctype           :  type of object to be created
//
//  Returns:
//      LPOBJECT        :  successful
//      NULL            :  any errors
//
//////////////////////////////////////////////////////////////////////////////

LPOBJECT_LE FARINTERNAL LeCreateBlank (lhclientdoc, lpobjname, ctype)
LHCLIENTDOC lhclientdoc;
LPSTR       lpobjname;
LONG        ctype;
{
    HOBJECT        hobj;
    LPOBJECT_LE    lpobj;

    if (!(ctype == CT_LINK || ctype == CT_EMBEDDED || ctype == CT_OLDLINK))
        return NULL;

    if (!(hobj = GlobalAlloc (GMEM_MOVEABLE|GMEM_ZEROINIT, 
                        sizeof (OBJECT_LE))))
        return NULL;

    if (!(lpobj = (LPOBJECT_LE) GlobalLock (hobj))) {
        GlobalFree (hobj);
        return NULL;
    }

    if (ctype == CT_OLDLINK) {
        ctype = CT_LINK;
        lpobj->bOldLink = TRUE;
    }

    lpobj->head.objId[0] = 'L';
    lpobj->head.objId[1] = 'E';
    lpobj->head.ctype    = ctype;
    lpobj->head.iTable   = INVALID_INDEX;

    lpobj->head.lpvtbl  = (LPOLEOBJECTVTBL)&vtblLE;
 
    if (ctype == CT_LINK){
        lpobj->optUpdate = oleupdate_always;

    }else {
        lpobj->optUpdate = oleupdate_onclose;
    }
    lpobj->head.hobj = hobj;
    DocAddObject ((LPCLIENTDOC) lhclientdoc, (LPOLEOBJECT) lpobj, lpobjname);
    return lpobj;
}


void FARINTERNAL SetExtents (LPOBJECT_LE lpobj)
{   
    RECT    rc = {0, 0, 0, 0};

    if (lpobj->lpobjPict) {
        if ((*lpobj->lpobjPict->lpvtbl->QueryBounds) (lpobj->lpobjPict, 
                                        (LPRECT)&rc) == OLE_OK) {   
            // Bounds are in MM_HIMETRIC units  
            lpobj->head.cx = (LONG) (rc.right - rc.left);  
            lpobj->head.cy = (LONG) (rc.bottom - rc.top);  
        }
        return;
    }
}


////////////////////////////////////////////////////////////////////////////////
//
//  OLESTATUS FARINTERNAL  LeSaveToStream (lpobj, lpstream)
//
//  Save the object to the stream. Uses the stream functions provided
//  in the lpclient.
//
//  Format: (!!! Document the fomrat here).
//
//
//
//  Arguments:
//      lhclientdoc     :  client doc handle
//      lpobjname       :  object name
//      ctype           :  type of object to be created
//
//  Returns:
//      LPOBJECT        :  successful
//      NULL            :  any errors
//
//////////////////////////////////////////////////////////////////////////////

OLESTATUS FARINTERNAL  LeSaveToStream (lpobj, lpstream)
LPOBJECT_LE    lpobj;
LPOLESTREAM    lpstream;
{

//    PROBE_OBJECT_BLANK(lpobj);
    
    PROBE_CREATE_ASYNC(lpobj);
    
    if (lpobj->head.ctype == CT_LINK && lpobj->bOldLink)
        lpobj->head.ctype = CT_OLDLINK;

    if (PutBytes (lpstream, (LPSTR) &dwVerToFile, sizeof(LONG)))
        return OLE_ERROR_STREAM;

    if (PutBytes (lpstream, (LPSTR) &lpobj->head.ctype, sizeof(LONG)))
        return OLE_ERROR_STREAM;
    
    if (lpobj->bOldLink)
        lpobj->head.ctype = CT_OLDLINK;

    return LeStreamWrite (lpstream, lpobj);
}



////////////////////////////////////////////////////////////////////////////////
//
//  OLESTATUS  FARINTERNAL  LeLoadFromStream (lpstream, lpclient, lhclientdoc, lpobjname, lplpoleobject, ctype, aClass, cfFormat)
//
//  Create an object, loading the object from the stream.
//
//  Arguments:
//      lpstream            : stream table
//      lpclient            : client callback table
//      lhclientdoc         : Doc handle foe which the object should be created
//      lpobjname           : Object name
//      lplpoleobject       : object return
//      ctype               : Type of object
//      aClass              : class atom
//      cfFormat            : render format
//
//  Returns:
//      LPOBJECT        :  successful
//      NULL            :  any errors
//
//////////////////////////////////////////////////////////////////////////////

OLESTATUS  FARINTERNAL  LeLoadFromStream (lpstream, lpclient, lhclientdoc, lpobjname, lplpoleobject, ctype, aClass, cfFormat)
LPOLESTREAM         lpstream;
LPOLECLIENT         lpclient;
LHCLIENTDOC         lhclientdoc;
LPSTR               lpobjname;
LPOLEOBJECT FAR *   lplpoleobject;
LONG                ctype;
ATOM                aClass;
OLECLIPFORMAT       cfFormat;
{
    LPOBJECT_LE lpobj = NULL;
    OLESTATUS   retval = OLE_ERROR_STREAM;
    LONG        type;   // this not same as ctype
    LONG        ver;
    char        chVerb [2];

    *lplpoleobject = NULL;        

    if (!(lpobj = LeCreateBlank (lhclientdoc, lpobjname, ctype)))
        return OLE_ERROR_MEMORY;

    lpobj->head.lpclient = lpclient;
    lpobj->app = aClass; 
    // if the entry is present, then it is
    lpobj->bOleServer = QueryVerb (lpobj, 0, (LPSTR)&chVerb, 2);

    if (LeStreamRead (lpstream, lpobj) == OLE_OK) {

        // Get exe name from aClass and set it as aServer
        SetExeAtom (lpobj);
        if (!GetBytes (lpstream, (LPSTR) &ver, sizeof(LONG))) {
            if (!GetBytes (lpstream, (LPSTR) &type, sizeof(LONG))) {
                if (type == CT_NULL) 
                    retval = OLE_OK;
                else if (aClass = GetAtomFromStream (lpstream)) {
                    retval = DefLoadFromStream (lpstream, NULL, lpclient, 
                                        lhclientdoc, lpobjname,
                                        (LPOLEOBJECT FAR *)&lpobj->lpobjPict,
                                        CT_PICTURE, aClass, cfFormat);
                }
            }
        }
        
        if (retval == OLE_OK) {
            SetExtents (lpobj);
            *lplpoleobject = (LPOLEOBJECT) lpobj;
            if (lpobj->lpobjPict)
                lpobj->lpobjPict->lpParent = (LPOLEOBJECT) lpobj;
            
            if ((lpobj->head.ctype != CT_LINK)
                    || (!InitDocConv (lpobj, !POPUP_NETDLG))
                    || (lpobj->optUpdate >= oleupdate_oncall))
                return OLE_OK;
            
            lpobj->fCmd = ACT_ADVISE;
            
            // If it's auto update, then get the latest data.
            if (lpobj->optUpdate == oleupdate_always)  
                lpobj->fCmd |= ACT_REQUEST;         

            FarInitAsyncCmd (lpobj, OLE_LOADFROMSTREAM, LNKOPENUPDATE);
            return LnkOpenUpdate (lpobj);
        }
    }

    // This delete will not run into async command. We did not even
    // even connect.
    OleDelete ((LPOLEOBJECT) lpobj);
    return OLE_ERROR_STREAM;
}



//

OLESTATUS INTERNAL LeStreamRead (lpstream, lpobj)
LPOLESTREAM lpstream;
LPOBJECT_LE lpobj;
{
    DWORD          dwBytes;
    LPSTR          lpstr;
    OLESTATUS      retval = OLE_OK;

    if (!(lpobj->topic = GetAtomFromStream(lpstream))
            && (lpobj->head.ctype != CT_EMBEDDED))
        return OLE_ERROR_STREAM;
    
    // !!! This atom could be NULL. How do we distinguish the
    // error case

    lpobj->item = GetAtomFromStream(lpstream);

    if (lpobj->head.ctype == CT_EMBEDDED)  {
        if (GetBytes (lpstream, (LPSTR) &dwBytes, sizeof(LONG)))
            return OLE_ERROR_STREAM;

        if (!(lpobj->hnative = GlobalAlloc (GMEM_MOVEABLE, dwBytes)))
            return OLE_ERROR_MEMORY;
        else if (!(lpstr = GlobalLock (lpobj->hnative))) {
            GlobalFree (lpobj->hnative);
            return OLE_ERROR_MEMORY;
        }
        else {
            if (GetBytes(lpstream, lpstr, dwBytes))
                retval = OLE_ERROR_STREAM;
            GlobalUnlock (lpobj->hnative);
        }
        
        if (retval == OLE_OK)
            SetEmbeddedTopic (lpobj);
    }
    else {
        if (lpobj->aNetName = GetAtomFromStream (lpstream)) {
            if (HIWORD(dwVerFromFile) == OS_MAC) {
                // if it is a mac file this field will have "ZONE:MACHINE:"
                // string. Lets prepend this to the topic, so that server 
                // app or user can fix the string
                    
                ATOM    aTemp;

                aTemp = wAtomCat (lpobj->aNetName, lpobj->topic);
                GlobalDeleteAtom (lpobj->aNetName);
                lpobj->aNetName = NULL;
                GlobalDeleteAtom (lpobj->topic);
                lpobj->topic = aTemp;
            }
            else 
                SetNetDrive (lpobj);
        }
            
        if (HIWORD(dwVerFromFile) != OS_MAC) { 
            if (GetBytes (lpstream, (LPSTR) &lpobj->dwNetInfo, sizeof(LONG)))
                return OLE_ERROR_STREAM;
        }
        
        if (GetBytes (lpstream, (LPSTR) &lpobj->optUpdate, sizeof(LONG)))
            return OLE_ERROR_STREAM;
    }
    return retval;
}



OLESTATUS INTERNAL LeStreamWrite (lpstream, lpobj)
LPOLESTREAM lpstream;
LPOBJECT_LE lpobj;
{
    LPSTR   lpstr;
    DWORD   dwBytes = 0L;
    LONG    nullType = CT_NULL;
    int     error;
    
    if (PutAtomIntoStream(lpstream, lpobj->app))
        return OLE_ERROR_STREAM;
   
    if (lpobj->head.ctype == CT_EMBEDDED) { 
        // we set the topic at load time, no point in saving it
        if (PutBytes (lpstream, (LPSTR) &dwBytes, sizeof(LONG)))
            return OLE_ERROR_STREAM;
    }
    else {
        if (PutAtomIntoStream(lpstream, lpobj->topic))
            return OLE_ERROR_STREAM;
    }
    
#ifdef OLD
    if (PutAtomIntoStream(lpstream, lpobj->topic))
        return OLE_ERROR_STREAM;            
#endif          
            
    if (PutAtomIntoStream(lpstream, lpobj->item))
        return OLE_ERROR_STREAM;

    // !!! deal with objects > 64k

    if (lpobj->head.ctype == CT_EMBEDDED) {
        
        if (!lpobj->hnative)
            return OLE_ERROR_BLANK;

        // assumption low bytes are first
        dwBytes = GlobalSize (lpobj->hnative);

        if (PutBytes (lpstream, (LPSTR)&dwBytes, sizeof(LONG)))
            return OLE_ERROR_STREAM;
        
        if (!(lpstr = GlobalLock (lpobj->hnative)))
            return OLE_ERROR_MEMORY;

        error = PutBytes (lpstream, lpstr, dwBytes);
        GlobalUnlock (lpobj->hnative);

        if (error)
            return OLE_ERROR_STREAM;
    }
    else {
        if (PutAtomIntoStream(lpstream, lpobj->aNetName))
            return OLE_ERROR_STREAM;

        if (PutBytes (lpstream, (LPSTR) &lpobj->dwNetInfo, sizeof(LONG)))
            return OLE_ERROR_STREAM;
        
        if (PutBytes (lpstream, (LPSTR) &lpobj->optUpdate, sizeof(LONG)))
            return OLE_ERROR_STREAM;
    }
    
    if (lpobj->lpobjPict)
        return (*lpobj->lpobjPict->lpvtbl->SaveToStream) (lpobj->lpobjPict, 
                                                    lpstream);

    if (PutBytes (lpstream, (LPSTR) &dwVerToFile, sizeof(LONG)))
        return OLE_ERROR_STREAM;

    if (PutBytes (lpstream, (LPSTR) &nullType, sizeof(LONG)))
        return OLE_ERROR_STREAM;

    return OLE_OK;
}


/***************************** Public  Function ****************************\
* OLESTATUS FARINTERNAL LeQueryType (lpobj, lptype)
*
* Effects:
*
* History:
* Wrote it.
\***************************************************************************/

OLESTATUS FARINTERNAL LeQueryType (lpobj, lptype)
LPOBJECT_LE lpobj;
LPLONG      lptype;
{
    Puts("LeQueryType");

    if ((lpobj->head.ctype == CT_EMBEDDED)
            || (lpobj->asyncCmd == OLE_COPYFROMLNK)
            || (lpobj->asyncCmd == OLE_CREATEFROMFILE)) 
        *lptype = CT_EMBEDDED;
    else if ((lpobj->head.ctype == CT_LINK) 
                || (lpobj->head.ctype == CT_OLDLINK))
        *lptype = CT_LINK;
    else 
        return OLE_ERROR_OBJECT;
    
    return OLE_OK;
}



// ContextCallBack: internal function. Calls callback function of <hobj>
// with flags.

int FARINTERNAL ContextCallBack (lpobj, flags)
LPOLEOBJECT         lpobj;
OLE_NOTIFICATION    flags;
{
    LPOLECLIENT     lpclient;
    
    Puts("ContextCallBack");

    if (!FarCheckObject(lpobj))
        return FALSE;

    if (!(lpclient = lpobj->lpclient))
        return FALSE;

    ASSERT (lpclient->lpvtbl->CallBack, "Client Callback ptr is NULL");
    
    return ((*lpclient->lpvtbl->CallBack) (lpclient, flags, lpobj));
}


void FARINTERNAL DeleteExtraData (lpobj)
LPOBJECT_LE lpobj;
{
    if (lpobj->hextraData == NULL)
        return;

    switch (lpobj->cfExtra) {
        case CF_BITMAP:
            DeleteObject (lpobj->hextraData);           
            break;
            
        case CF_METAFILEPICT:
        {
            LPMETAFILEPICT  lpmfp;
            
            if (!(lpmfp = (LPMETAFILEPICT) GlobalLock (lpobj->hextraData)))
                break;
            
            DeleteMetaFile (lpmfp->hMF);
            GlobalUnlock (lpobj->hextraData);
            GlobalFree (lpobj->hextraData);
            break;
        }
            
        default:
            GlobalFree (lpobj->hextraData);
    }
    
    lpobj->hextraData = NULL;
}


void   INTERNAL DeleteObjectAtoms(lpobj)
LPOBJECT_LE lpobj;
{
    if (lpobj->app) {
        GlobalDeleteAtom (lpobj->app);
        lpobj->app = NULL;
    }
    
    if (lpobj->topic) {
        GlobalDeleteAtom (lpobj->topic);
        lpobj->topic = NULL;
    }
    
    if (lpobj->item) {
        GlobalDeleteAtom (lpobj->item);
        lpobj->item  = NULL;
    }
    
    if (lpobj->aServer) {
        GlobalDeleteAtom (lpobj->aServer);
        lpobj->aServer = NULL;
    }
    
    if (lpobj->aNetName) {
        GlobalDeleteAtom (lpobj->aNetName);
        lpobj->aNetName = NULL;
    }
}


// LeGetUpdateOptions: Gets the update options.

OLESTATUS   FARINTERNAL LeGetUpdateOptions (lpobj, lpOptions)
LPOBJECT_LE         lpobj;
OLEOPT_UPDATE   FAR *lpOptions;
{
    if (lpobj->head.ctype != CT_LINK)
        return OLE_ERROR_OBJECT;

    *lpOptions = lpobj->optUpdate;
    return OLE_OK;
}




OLESTATUS FARINTERNAL  LnkPaste (lpclient, lhclientdoc, lpobjname, lplpoleobject, optRender, cfFormat, sfFormat)
LPOLECLIENT         lpclient;
LHCLIENTDOC         lhclientdoc;
LPSTR               lpobjname;
LPOLEOBJECT FAR *   lplpoleobject;
OLEOPT_RENDER       optRender;
OLECLIPFORMAT       cfFormat;
OLECLIPFORMAT       sfFormat;
{
    LPOBJECT_LE lpobj  = NULL;
    OLESTATUS   retval = OLE_ERROR_MEMORY;
    LPSTR       lpClass = NULL;
    
    if (!(lpobj = LeCreateBlank (lhclientdoc, lpobjname, CT_LINK)))
        goto errRtn;

    lpobj->head.lpclient = lpclient;

#ifdef OLD    
    if (!bWLO) {
        // we are not running under WLO
        if (!(hInfo = GetClipboardData (sfFormat))) {
            if (hInfo = GetClipboardData (cfLink))
                lpobj->bOldLink = TRUE;
        }
    }
#endif

    if (!hInfo)
        goto errRtn;

    if (!IsClipboardFormatAvailable (sfFormat))
        lpobj->bOldLink = TRUE;

    if (!SetLink (lpobj, hInfo, &lpClass))
        goto errRtn;

    if ((retval = SetNetName(lpobj)) != OLE_OK) {    
        // see whether network name is on the clipboard and try to use it
        HANDLE  hNetName;
        LPSTR   lpNetName;
        
        if (!IsClipboardFormatAvailable (cfNetworkName))
            goto errRtn;
        
        if (!(hNetName = GetClipboardData (cfNetworkName))) 
            goto errRtn;
    
        if (!(lpNetName = GlobalLock (hNetName)))
            goto errRtn;
        
        GlobalUnlock (hNetName);
        if (!(lpobj->aNetName = GlobalAddAtom (lpNetName)))
            goto errRtn;
        
        SetNetDrive (lpobj);
    }

    retval = CreatePictFromClip (lpclient, lhclientdoc, lpobjname, 
                        (LPOLEOBJECT FAR *)&lpobj->lpobjPict, optRender,
                         cfFormat, lpClass, CT_PICTURE);
    
    if (retval == OLE_OK) {
        SetExtents (lpobj);
                // why do we have to update the link, do we show it?

        // Reconnect if we could and advise for updates
        *lplpoleobject = (LPOLEOBJECT)lpobj;
        if (lpobj->lpobjPict)
            lpobj->lpobjPict->lpParent = (LPOLEOBJECT) lpobj;
        
        if (!InitDocConv (lpobj, !POPUP_NETDLG))
             return OLE_OK;             // document is not loaded , it is OK.

        lpobj->fCmd = ACT_ADVISE | ACT_REQUEST;
        FarInitAsyncCmd (lpobj, OLE_LNKPASTE, LNKOPENUPDATE);
        return LnkOpenUpdate (lpobj);

    } 
    else {
errRtn:
        if (lpobj)
            OleDelete ((LPOLEOBJECT)lpobj);
    }

    return retval;
}



// !!! EmbPaste and LnkPaste Can be combined
OLESTATUS FARINTERNAL  EmbPaste (lpclient, lhclientdoc, lpobjname, lplpoleobject, optRender, cfFormat)
LPOLECLIENT         lpclient;
LHCLIENTDOC         lhclientdoc;
LPSTR               lpobjname;
LPOLEOBJECT FAR *   lplpoleobject;
OLEOPT_RENDER       optRender;
OLECLIPFORMAT       cfFormat;
{
    LPOBJECT_LE lpobj = NULL;
    HANDLE      hnative;
    OLESTATUS   retval = OLE_ERROR_MEMORY;
    LPSTR       lpClass = NULL;

    if (!IsClipboardFormatAvailable (cfOwnerLink))
        return OLE_ERROR_CLIPBOARD;
    
    if (!(lpobj = LeCreateBlank (lhclientdoc, lpobjname, CT_EMBEDDED)))
        goto errRtn;

    lpobj->head.lpclient = lpclient;

#ifdef OLD    
    if (!bWLO) {
        // we are not running under WLO
        hInfo = GetClipboardData (cfOwnerLink);
    }
#endif

    if (!hInfo)
        goto errRtn;

    if (!SetLink (lpobj, hInfo, &lpClass))
        goto errRtn;

    SetEmbeddedTopic (lpobj);

    hnative = GetClipboardData (cfNative);
    if (!(lpobj->hnative = DuplicateGlobal (hnative, GMEM_MOVEABLE)))
        goto errRtn;

    retval = CreatePictFromClip (lpclient, lhclientdoc, lpobjname,
                        (LPOLEOBJECT FAR *)&lpobj->lpobjPict, optRender,
                         cfFormat, lpClass, CT_PICTURE);

    if (retval == OLE_OK) {
        SetExtents (lpobj);
        *lplpoleobject = (LPOLEOBJECT) lpobj;
        if (lpobj->lpobjPict)
            lpobj->lpobjPict->lpParent = (LPOLEOBJECT) lpobj;
    } 
    else {
errRtn:
        // Note:  This oledelete should not result in any async commands.
        if  (lpobj)
            OleDelete ((LPOLEOBJECT)lpobj);
    }

#ifdef EXCEL_BUG    
    // Some server apps (ex: Excel) copy picture (to clipboard) which is
    // formatted for printer DC. So, we want to update the picture if the
    // server app is running, and the it's a old server
        
    if ((retval == OLE_OK) && (!lpobj->bOleServer)) {
        lpobj->fCmd =  LN_EMBACT | ACT_NOLAUNCH | ACT_REQUEST | ACT_UNLAUNCH;
        FarInitAsyncCmd (lpobj, OLE_EMBPASTE, EMBOPENUPDATE);
        if ((retval = EmbOpenUpdate (lpobj)) > OLE_WAIT_FOR_RELEASE)
            return OLE_OK;
    }
#endif

    return retval;
}



BOOL INTERNAL SetLink (lpobj, hinfo, lpLpClass)
LPOBJECT_LE     lpobj;
HANDLE          hinfo;
LPSTR FAR *     lpLpClass;
{
    LPSTR   lpinfo;
    char    chVerb[2];
    // If there exits a conversation, then terminate it.

    if (!(lpinfo = GlobalLock (hinfo)))
        return FALSE;
    
    *lpLpClass = lpinfo;
    
#if FIREWALLS
     if (lpobj->pDocEdit)
        ASSERT (!lpobj->pDocEdit->hClient, "unexpected client conv exists");
#endif

    lpobj->app = GlobalAddAtom (lpinfo);
    SetExeAtom (lpobj);
    lpobj->bOleServer = QueryVerb (lpobj, 0, (LPSTR)&chVerb, 2);

//  lpobj->aServer = GetAppAtom (lpinfo);
        
    lpinfo += lstrlen (lpinfo) + 1;
    lpobj->topic = GlobalAddAtom (lpinfo);
    lpinfo += lstrlen (lpinfo) + 1;
    if (*lpinfo)
        lpobj->item = GlobalAddAtom (lpinfo);
    else
        lpobj->item = NULL;
    
    if (lpobj->hLink) {             // As the atoms have already changed, 
        GlobalFree (lpobj->hLink);  // lpobj->hLink becomes irrelevant.
        lpobj->hLink = NULL;
    }
    
    if (lpinfo)
        GlobalUnlock(hinfo);

    if (!lpobj->app)
        return FALSE;

    if (!lpobj->topic && (lpobj->head.ctype == CT_LINK))
        return FALSE;
    
    lpobj->hLink = DuplicateGlobal (hinfo, GMEM_MOVEABLE);
    return TRUE;
}



HANDLE INTERNAL GetLink (lpobj)
LPOBJECT_LE    lpobj;
{
    HANDLE  hLink = NULL;
    LPSTR   lpLink;
    int     len;
    WORD    size;

    if (lpobj->hLink)
        return lpobj->hLink;

    size = 4;    // three nulls and one null at the end
    size += GlobalGetAtomLen (lpobj->app);
    size += GlobalGetAtomLen (lpobj->topic);
    size += GlobalGetAtomLen (lpobj->item);

    if (!(hLink = GlobalAlloc (GMEM_MOVEABLE, (DWORD) size)))
        return NULL;
    
    if (!(lpLink = GlobalLock (hLink))) {
        GlobalFree (hLink);
        return NULL;
    }
    
    len = (int) GlobalGetAtomName (lpobj->app, lpLink, size);
    lpLink += ++len;

    len = (int) GlobalGetAtomName (lpobj->topic, lpLink, (size -= len));
    lpLink += ++len;

    if (!lpobj->item) 
        *lpLink = NULL;
    else {
        len = (int) GlobalGetAtomName (lpobj->item, lpLink, size - len);
        lpLink += len;
    }
    
    *++lpLink = NULL;     // put another null the end
    GlobalUnlock (hLink);
    return (lpobj->hLink = hLink);

}


void FARINTERNAL SetEmbeddedTopic (lpobj)
LPOBJECT_LE    lpobj;
{
    LPCLIENTDOC lpdoc;
    char        buf[MAX_STR];
    char        buf1[MAX_STR];
    LPSTR       lpstr, lptmp;
    int         len;
    
    if (lpobj->topic) 
        GlobalDeleteAtom (lpobj->topic);

    if (lpobj->aNetName) {
        GlobalDeleteAtom (lpobj->aNetName);
        lpobj->aNetName = NULL;
    }
    
    lpobj->cDrive       = NULL;
    lpobj->dwNetInfo    = NULL;
    lpobj->head.ctype   = CT_EMBEDDED;
    
    lpdoc = (LPCLIENTDOC) lpobj->head.lhclientdoc;
    lpstr = (LPSTR) buf;
    lptmp = (LPSTR) buf1;
    ASSERT(lpdoc->aDoc, "lpdoc->aDoc is null");
    GlobalGetAtomName (lpdoc->aDoc, lpstr, sizeof(buf));
    
    // strip the path
    lpstr += (len = lstrlen(lpstr)); 
    while (--lpstr != (LPSTR) buf) {
        if ((*lpstr == '\\') || (*lpstr == ':')) {
            lpstr++;
            break;
        }
    }
    
    GlobalGetAtomName (lpdoc->aClass, lptmp, sizeof(buf1));
    lstrcat (lptmp, "%");
    lstrcat (lptmp, lpstr);
    lstrcat (lptmp, "%");
    lpstr = lptmp;
    lptmp += lstrlen (lptmp);
    
    if (lpobj->head.aObjName) {
        GlobalGetAtomName (lpobj->head.aObjName, lptmp, sizeof(buf)-(len+1));
    }
    
    if ((embStr[EMB_ID_INDEX] += 1) > '9') {
        embStr[EMB_ID_INDEX] = '0';
        if ((embStr[EMB_ID_INDEX - 1] += 1) > '9') {
            embStr[EMB_ID_INDEX - 1] = '0';
            if ((embStr[EMB_ID_INDEX - 2] += 1) > '9')
                embStr[EMB_ID_INDEX - 2] = '0';
        }
    }
    
    lstrcat (lptmp, embStr);

    lpobj->topic = GlobalAddAtom (lpstr);
    
    // Topic, item have changed, lpobj->hLink is out of date.
    if (lpobj->hLink) {             
        GlobalFree (lpobj->hLink);
        lpobj->hLink = NULL;
    }
}


/////////////////////////////////////////////////////////////////////
//                                                                 //
// Routines related to the asynchronous processing.                 //
//                                                                 //
/////////////////////////////////////////////////////////////////////

void NextAsyncCmd (lpobj, mainRtn)
LPOBJECT_LE lpobj;
WORD        mainRtn;
{
    lpobj->mainRtn  = mainRtn;
    lpobj->subRtn   = 0;

}

void  InitAsyncCmd (lpobj, cmd, mainRtn)
LPOBJECT_LE lpobj;
WORD        cmd;
WORD        mainRtn;
{
        lpobj->asyncCmd = cmd;
        lpobj->mainErr  = OLE_OK;
        lpobj->mainRtn  = mainRtn;
        lpobj->subRtn   = 0;
        lpobj->subErr   = 0;
        lpobj->bAsync   = 0;
        lpobj->endAsync = 0;
        lpobj->errHint  = 0;
}

void  FARINTERNAL FarInitAsyncCmd (lpobj, cmd, mainRtn)
LPOBJECT_LE lpobj;
WORD        cmd;
WORD        mainRtn;
{
    return (InitAsyncCmd(lpobj, cmd, mainRtn));
}


OLESTATUS EndAsyncCmd (lpobj)
LPOBJECT_LE lpobj;
{

    OLESTATUS   olderr;


    if (!lpobj->endAsync) {
        lpobj->asyncCmd = OLE_NONE;
        return OLE_OK;
    }


    // this is an asynchronous operation. Send callback with or without
    // error.

    switch (lpobj->asyncCmd) {

        case    OLE_DELETE:
            break;

        case    OLE_COPYFROMLNK:
        case    OLE_CREATEFROMFILE:
            // change the topic name to embedded.
            SetEmbeddedTopic (lpobj);
            break;

        case    OLE_LOADFROMSTREAM:
        case    OLE_LNKPASTE:
        case    OLE_RUN:
        case    OLE_SHOW:
        case    OLE_ACTIVATE:
        case    OLE_UPDATE:
        case    OLE_CLOSE:
        case    OLE_RECONNECT:
        case    OLE_CREATELINKFROMFILE:
        case    OLE_CREATEINVISIBLE:                        
        case    OLE_CREATE:
        case    OLE_CREATEFROMTEMPLATE:
        case    OLE_SETUPDATEOPTIONS:
        case    OLE_SERVERUNLAUNCH:
        case    OLE_SETDATA:
        case    OLE_REQUESTDATA:
        case    OLE_OTHER:
            break;

        case    OLE_EMBPASTE:
            lpobj->mainErr = OLE_OK;
            break;
            
        default:
            DEBUG_OUT ("unexpected maincmd", 0);
            break;

    }

    lpobj->bAsync   = FALSE;
    lpobj->endAsync = FALSE;
    lpobj->oldasyncCmd = lpobj->asyncCmd;
    olderr          = lpobj->mainErr;
    lpobj->asyncCmd = OLE_NONE;  // no async command in progress.

    if (lpobj->head.lpclient)
        ContextCallBack (lpobj, OLE_RELEASE);

    lpobj->mainErr  = OLE_OK;
    return olderr;
}


BOOL   ProcessErr   (lpobj)
LPOBJECT_LE  lpobj;
{

    if (lpobj->subErr == OLE_OK)
        return FALSE;

    if (lpobj->mainErr == OLE_OK)
        lpobj->mainErr = lpobj->subErr;

    lpobj->subErr = OLE_OK;
    return TRUE;
}


void ScheduleAsyncCmd (lpobj)
LPOBJECT_LE  lpobj;
{

    // replacs this with direct proc jump later on.
#ifdef  FIREWALLS
    ASSERT (lpobj->bAsync, "Not an asynchronous command");
#endif
    lpobj->bAsync = FALSE;

    // if the object is active and we do pokes we go thru this path
    // !!! We may have to go thru the endasynccmd.

    if ((lpobj->asyncCmd == OLE_OTHER) 
            || ((lpobj->asyncCmd == OLE_SETDATA) && !lpobj->mainRtn)) {
        lpobj->endAsync = TRUE;
        lpobj->mainErr = lpobj->subErr;     
        EndAsyncCmd (lpobj);
        if (lpobj->bUnlaunchLater) {
            lpobj->bUnlaunchLater = FALSE;
            CallEmbLnkDelete(lpobj);
        }
        
        return;
    }
    
    switch (lpobj->mainRtn) {

        case EMBLNKDELETE:
            EmbLnkDelete (lpobj);
            break;

        case LNKOPENUPDATE:
            LnkOpenUpdate (lpobj);
            break;

        case DOCSHOW:
            DocShow (lpobj);
            break;


        case EMBOPENUPDATE:
            EmbOpenUpdate (lpobj);
            break;


        case EMBLNKCLOSE:
            EmbLnkClose (lpobj);
            break;

        case LNKSETUPDATEOPTIONS:
            LnkSetUpdateOptions (lpobj);
            break;

        case LNKCHANGELNK:
            LnkChangeLnk (lpobj);
            break;

        case REQUESTDATA:
            RequestData (lpobj, NULL);
            break;

        default:
            DEBUG_OUT ("Unexpected asyn command", 0);
            break;
    }

    return;
}

void SetNetDrive (lpobj)
LPOBJECT_LE lpobj;
{
    char    buf[MAX_STR];
    
    if (GlobalGetAtomName (lpobj->topic, buf, sizeof(buf))
            && (buf[1] == ':')) {
        AnsiUpperBuff ((LPSTR) buf, 1);
        lpobj->cDrive = buf[0];
    }
}

HANDLE GetNetNameHandle (lpobj)
LPOBJECT_LE lpobj;
{
    HANDLE  hNetName;
    LPSTR   lpNetName;
    WORD    size;
    
    if (!(size = GlobalGetAtomLen (lpobj->aNetName)))
        return NULL;

    size++;
    if (!(hNetName = GlobalAlloc (GMEM_MOVEABLE, (DWORD) size)))
        return NULL;
    
    if (lpNetName = GlobalLock (hNetName)) {
        GlobalUnlock (hNetName);
        if (GlobalGetAtomName(lpobj->aNetName, lpNetName, size)) 
            return hNetName;
    }

    // error case
    GlobalFree (hNetName);
    return NULL;
}

BOOL AreTopicsEqual (lpobj1, lpobj2)
LPOBJECT_LE lpobj1;
LPOBJECT_LE lpobj2;
{
    char    buf1[MAX_STR];
    char    buf2[MAX_STR];
    
    if (lpobj1->aNetName != lpobj2->aNetName)
        return FALSE;
    
    if (!lpobj1->aNetName) {
        if (lpobj1->topic == lpobj2->topic)
            return TRUE;
        
        return FALSE;
    }
    
    if (!GlobalGetAtomName (lpobj1->topic, buf1, MAX_STR))
        return FALSE;
    
    if (!GlobalGetAtomName (lpobj2->topic, buf2, MAX_STR))
        return FALSE;
    
    if (!lstrcmpi (&buf1[1], &buf2[1]))
        return TRUE;
    
    return FALSE;
}
    

ATOM FARINTERNAL wAtomCat (
ATOM        a1, 
ATOM        a2)
{
    char    buf[MAX_STR+MAX_STR];
    LPSTR   lpBuf = (LPSTR)buf;
    
    if (!GlobalGetAtomName (a1, lpBuf, MAX_STR+MAX_STR))
        return NULL;
    
    lpBuf += lstrlen(lpBuf);
    
    if (!GlobalGetAtomName(a2, lpBuf, MAX_STR))
        return NULL;
    
    return GlobalAddAtom ((LPSTR) buf);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\ole\client\main.c ===
/****************************** Module Header ******************************\
* Module Name: MAIN.C
*
* PURPOSE: WinMain, WEP and some other misc routines
*
* Created: 1991
*
* Copyright (c) 1990, 1991  Microsoft Corporation
*
* History:
*   Srinik   (04/01/91)  Pulled some routines, into this, from ole.c.
*
\***************************************************************************/

#include <windows.h>
#include <shellapi.h>

#include "dll.h"

#ifndef WF_WLO
#define WF_WLO  0x8000
#endif

// ordinal number new win31 API IsTask
#define ORD_IsTask  320

#define NUM_DLL     30  /* space for this many DLL_ENTRYs is created on */
                        /* each alloc/realloc */

OLECLIPFORMAT   cfOwnerLink     = 0;     // global variables for clip frmats
OLECLIPFORMAT   cfObjectLink    = 0;
OLECLIPFORMAT   cfLink          = 0;
OLECLIPFORMAT   cfNative        = 0;
OLECLIPFORMAT   cfBinary        = 0;
OLECLIPFORMAT   cfFileName      = 0;
OLECLIPFORMAT   cfNetworkName   = 0;

ATOM            aStdHostNames;
ATOM            aStdTargetDevice ;
ATOM            aStdDocDimensions;
ATOM            aStdDocName;
ATOM            aStdColorScheme;
ATOM            aNullArg = 0;
ATOM            aSave;
ATOM            aChange;
ATOM            aClose;
ATOM            aSystem;
ATOM            aOle;
ATOM            aClipDoc;
ATOM            aPackage;

// Used in work around for MSDraw bug
ATOM            aMSDraw;

extern LPCLIENTDOC  lpHeadDoc;
extern LPCLIENTDOC  lpTailDoc;

extern RENDER_ENTRY stdRender[];

HANDLE          hInstDLL;
BOOL            bProtMode;
BOOL            bWLO = FALSE;

/* HANDLE   hDllTable;          !!! Add this when bug in WEP is fixed */
DLL_ENTRY   lpDllTable[NUM_DLL]; //!!! change this when WEP bug is fixed
DWORD       dllTableSize;
int         iLast = 0;
int         iMax = NUM_DLL -1;
int         iUnloadableDll =  NULL; // index to handler than can be freed up

char        packageClass[] = "Package";

// For QuerySize() API & methods.
extern  OLESTREAMVTBL  dllStreamVtbl;
extern  CLIENTDOC      lockDoc;

#ifdef FIREWALLS
BOOL        bShowed = FALSE;
char        szDebugBuffer[80];
short       ole_flags;

void FARINTERNAL    ShowVersion (void);
void FARINTERNAL    SetOleFlags(void);
#endif

// LOWWORD - BYTE 0 major verision, BYTE1 minor version,
// HIWORD reserved

DWORD  dwOleVer = 0x2001L;  // change this when we want to update dll version
                            // number


DWORD  dwVerToFile = 0x0501L; // This is used while object is being saved to
                              // file. There is no need to change this value
                              // whenever we change ole dll version number



static BOOL  bLibInit = FALSE;


WORD    wWinVer;

HANDLE  hModule;

#define MAX_HIMETRIC    0x7FFF

int     maxPixelsX = MAX_HIMETRIC;
int     maxPixelsY = MAX_HIMETRIC;
void    SetMaxPixel (void);

VOID FAR PASCAL WEP (int);

#pragma alloc_text(WEP_TEXT, WEP)


FARPROC lpfnIsTask = NULL;          // the API IsTask() became available from
                                    // win31 onwards, hence we are trying to
                                    // get it's address through GetProcAddress



//////////////////////////////////////////////////////////////////////////////
//
//  int FAR PASCAL LibMain (hInst, wDataSeg, cbHeapSize, lpszCmdLine)
//
//  The main library entry point. This routine is called when the library
//  is loaded.
//
//  Arguments:
//
//      hInst       -   dll's instance handle
//      wDataSeg    -   DS register value
//      cbHeapSize  -   heap size defined def file
//      lpszCmdLine -   command line info
//
//  Returns:
//
//      0   -   failure
//      1   -   success
//
//  Effects:
//
//////////////////////////////////////////////////////////////////////////////


int FAR PASCAL LibMain (hInst, wDataSeg, cbHeapSize, lpszCmdLine)
HANDLE  hInst;
WORD    wDataSeg;
WORD    cbHeapSize;
LPSTR   lpszCmdLine;
{
    WNDCLASS  wc;
    int     i;

    Puts("LibMain");

#ifdef  FIREWALLS
    SetOleFlags();
#endif

    bLibInit  = TRUE;
    hInstDLL  = hInst;
    hModule = GetModuleHandle ("OLECLI");

    bProtMode = (BOOL) (GetWinFlags() & WF_PMODE);
    bWLO      = (BOOL) (GetWinFlags() & WF_WLO);
    wWinVer   = (WORD) GetVersion();

    // REGISTER LINK FORMAT

    cfObjectLink    = RegisterClipboardFormat("ObjectLink");
    cfLink          = RegisterClipboardFormat("Link");
    cfOwnerLink     = RegisterClipboardFormat("OwnerLink");
    cfNative        = RegisterClipboardFormat("Native");
    cfBinary        = RegisterClipboardFormat("Binary");
    cfFileName      = RegisterClipboardFormat("FileName");
    cfNetworkName   = RegisterClipboardFormat("NetworkName");

    if (!(cfObjectLink && cfOwnerLink && cfNative && cfLink))
        return 0;

    // SET UP OLEWNDCLASS
    wc.style        = NULL;
    wc.lpfnWndProc  = DocWndProc;
    wc.cbClsExtra   = 0;
    wc.cbWndExtra   = sizeof(LONG);     //we are storing longs
    wc.hInstance    = hInst;
    wc.hIcon        = NULL;
    wc.hCursor      = NULL;
    wc.hbrBackground= NULL;
    wc.lpszMenuName =  NULL;
    wc.lpszClassName= "OleDocWndClass";
    if (!RegisterClass(&wc))
             return 0;

    wc.lpfnWndProc = SrvrWndProc;
    wc.lpszClassName = "OleSrvrWndClass";

    if (!RegisterClass(&wc))
        return 0;
/*
    // !!! Add this when bug in WEP is fixed.
    // Allocate memory for DLL table
    dllTableSize = NUM_DLL * sizeof(DLL_ENTRY);
    if (!(hDllTable = GlobalAlloc (GMEM_MOVEABLE | GMEM_ZEROINIT,
                            dllTableSize)))
        return 0;

    if (!(lpDllTable = (DLL_ENTRY FAR *) GlobalLock (hDllTable)))
        return 0;
*/

    // !!! remove the following when WEP bug is fixed
    for (i = 0; i < NUM_DLL; i++)
        lpDllTable[i].aDll = 0;

    // !!! BEGIN hack for Pbrush.

    lpDllTable[0].hDll                  = NULL;
    lpDllTable[0].aDll                  = GlobalAddAtom ((LPSTR) "ole");
    lpDllTable[0].Load                  = PbLoadFromStream;
    lpDllTable[0].Clip                  = PbCreateFromClip;
    lpDllTable[0].Link                  = PbCreateLinkFromClip;
    lpDllTable[0].Create                = PbCreate;
    lpDllTable[0].CreateFromTemplate    = PbCreateFromTemplate;
    lpDllTable[0].CreateFromFile        = PbCreateFromFile;
    lpDllTable[0].CreateLinkFromFile    = PbCreateLinkFromFile;
    lpDllTable[0].CreateInvisible       = PbCreateInvisible;


    // !!! END hack for pbrush

    // For ObjectSize API
    dllStream.lpstbl = (LPOLESTREAMVTBL) &dllStreamVtbl;
    dllStream.lpstbl->Put = DllPut;

    // add the atoms required.
    aStdDocName       = GlobalAddAtom ((LPSTR)"StdDocumentName");
    aSave             = GlobalAddAtom ((LPSTR)"Save");
    aChange           = GlobalAddAtom ((LPSTR)"Change");
    aClose            = GlobalAddAtom ((LPSTR)"Close");
    aSystem           = GlobalAddAtom ((LPSTR)"System");
    aOle              = GlobalAddAtom ((LPSTR)"OLEsystem");
    aPackage          = GlobalAddAtom ((LPSTR) packageClass);

    // Used in work around for MSDraw bug
    aMSDraw           = GlobalAddAtom ((LPSTR) "MSDraw");

    // clipboard document name atom
    aClipDoc          = GlobalAddAtom ((LPSTR)"Clipboard");

    stdRender[0].aClass = GlobalAddAtom ("METAFILEPICT");
    stdRender[1].aClass = GlobalAddAtom ("DIB");
    stdRender[2].aClass = GlobalAddAtom ("BITMAP");

    SetMaxPixel();

    if (wWinVer != 0x0003) {
        HANDLE  hModule;

        if (hModule = GetModuleHandle ("KERNEL"))
            lpfnIsTask = GetProcAddress (hModule,
                                (LPSTR) MAKELONG (ORD_IsTask, 0));
    }

    if (cbHeapSize != 0)
        UnlockData(0);

    return 1;
}



//////////////////////////////////////////////////////////////////////////////
//
//  VOID FAR PASCAL WEP (nParameter)
//
//  Called just before the library is being unloaded. Delete all the atoms
//  added by this dll and also frees up all unloaded handler dlls.
//
//  Arguments:
//
//      nParameter  -   Termination code
//
//  Returns:
//
//      none
//
//  Effects:
//
//////////////////////////////////////////////////////////////////////////////


VOID FAR PASCAL WEP (nParameter)
int nParameter;
{
    int i;


    Puts("LibExit");

    // case when the DLLs are missing
    if (!bLibInit)
        return;

    if (nParameter == WEP_SYSTEM_EXIT)
        DEBUG_OUT ("---L&E DLL EXIT on system exit---",0)
    else if (nParameter == WEP_FREE_DLL)
        DEBUG_OUT ("---L&E DLL EXIT---\n",0)
    else
        return;

    // Delete atoms added by us

    for (i = 0; i < NUM_RENDER; i++) {
        if (stdRender[i].aClass)
            GlobalDeleteAtom (stdRender[i].aClass);
    }

    if (aStdDocName)
        GlobalDeleteAtom (aStdDocName);
    if (aSave)
        GlobalDeleteAtom (aSave);
    if (aChange)
        GlobalDeleteAtom (aChange);
    if (aClose)
        GlobalDeleteAtom (aClose);
    if (aSystem)
        GlobalDeleteAtom (aSystem);
    if (aOle)
        GlobalDeleteAtom (aOle);
    if (aPackage)
        GlobalDeleteAtom (aPackage);
    if (aClipDoc)
        GlobalDeleteAtom (aClipDoc);
    if (aMSDraw)
        GlobalDeleteAtom (aMSDraw);

    // Free handler dlls if there are any still loaded. Entry 0 is used for
    // Pbrush handler which is part of this dll.


    for (i = 0; i <= iLast; i++) {
        if (lpDllTable[i].aDll)
            GlobalDeleteAtom (lpDllTable[i].aDll);

        if (lpDllTable[i].hDll)
            FreeLibrary (lpDllTable[i].hDll);
    }


#ifdef FIREWALLS
    ASSERT(!lpHeadDoc, "Some client doc structures are not deleted");
    ASSERT(!lockDoc.lpHeadObj, "Some servers are left in a locked state");
#endif

/* !!! Add this when bug in WEP is fixed

    if (lpDllTable)
        GlobalUnlock (hDllTable);

    if (hDllTable)
        GlobalFree (hDllTable);
*/
}


//////////////////////////////////////////////////////////////////////////////
//
//  void FARINTERNAL SetOleFlags()
//
//  Sets the debug level flags for controlling the level of debug information
//  on the comm terminal. This will be included only in the debug version.
//
//  Arguments:
//
//      none
//
//  Returns:
//
//      none
//
//  Effects:
//
//////////////////////////////////////////////////////////////////////////////

#ifdef  FIREWALLS

void FARINTERNAL SetOleFlags()
{

    char    buffer[80];

    if(GetProfileString ("OLE",
        "Puts","", (LPSTR)buffer, 80))
        ole_flags = DEBUG_PUTS;
    else
        ole_flags = 0;


    if(GetProfileString ("OLE",
        "DEBUG_OUT","", (LPSTR)buffer, 80))
        ole_flags |= DEBUG_DEBUG_OUT;


    if(GetProfileString ("OLE",
        "MESSAGEBOX","", (LPSTR)buffer, 80))
        ole_flags |= DEBUG_MESSAGEBOX;

}



//////////////////////////////////////////////////////////////////////////////
//
//  void FARINTERNAL ShowVersion (void)
//
//  Displays version, date, time and copyright info in client app's window.
//  Called by all the object create functions after checking the flag bShowed.
//  This will be included only in the debug version.
//
//  Arguments:
//
//      none
//
//  Returns:
//
//      none
//
//  Effects:
//
//      sets bShowed
//
//////////////////////////////////////////////////////////////////////////////

void FARINTERNAL ShowVersion ()
{

    if (!bShowed && (ole_flags & DEBUG_MESSAGEBOX)) {
        MessageBox (NULL, "\
                       VER: 1.09.000\n\
                    TIME: 16:00:00\n\
                   DATE: 01/31/1992\n\
         Copyright (c) 1990, 1991 Microsoft Corp.\n\
                  All Rights Reserved.",
      "Ole Client Library",
      MB_OK | MB_TASKMODAL);
        bShowed = TRUE;
    }
}

#endif




int FARINTERNAL LoadDll (lpClass)
LPSTR   lpClass;
{
    char        str[MAX_STR];
    char        str1[MAX_STR];
    ATOM        aDll = NULL;
    int         index;
    int         iEmpty;
    BOOL        found = FALSE;
    HANDLE      hDll;
    int         refcnt;
    LONG        cb = MAX_STR;

    if (!lstrcmpi (lpClass, "Pbrush"))
        return 0;

    lstrcpy (str, lpClass);
    lstrcat (str, "\\protocol\\StdFileEditing\\handler");
    if (RegQueryValue (HKEY_CLASSES_ROOT, str, str1, &cb))
        return INVALID_INDEX;

    if (aDll = GlobalFindAtom (str1)) {
        for (index = 1; index <= iLast; index++) {
            if (lpDllTable[index].aDll == aDll) { // Dll already loaded
                lpDllTable[index].cObj ++;

                if (index == iUnloadableDll)  {
                    // since the object count is not zero anymore, this
                    // handler can not be freed up.
                    iUnloadableDll = NULL;
                }

                return index;
            }
        }
    }

    aDll = GlobalAddAtom (str1);

    // Look for an empty entry
    for (iEmpty = 1; iEmpty <= iLast; iEmpty++) {
        if (!lpDllTable[iEmpty].aDll) {
            found = TRUE;
            break;
        }
    }

    if (iEmpty > iMax)
        goto errLoad;
/*
    if (!found) {// no empty entry exists create a new one if necessary.
        if (iEmpty > iMax) {
            dllTableSize += (blockSize = NUM_DLL * sizeof(DLL_ENTRY));
            hTable = GlobalReAlloc (hDllTable, dllTableSize,
                                GMEM_MOVEABLE | GMEM_ZEROINIT);
            if (hTable == hDllTable)
                iMax += NUM_DLL;
            else {
                dllTableSize -= blockSize;
                iEmpty = INVALID_INDEX;
            }
        }
    }
*/

    // !!! reference count of OLECLI is increasing by 2 when the handlers are
    // are loaded, looks like windows bug. Following is a temporary fix.

    refcnt = GetModuleUsage (hModule);
    hDll = LoadLibrary ((LPSTR) str1);
    refcnt = (GetModuleUsage (hModule) - refcnt);

    while (refcnt > 1) {
        FreeModule (hModule);
        refcnt--;
    }

    if (hDll < 32)
        goto errLoad;

    if (!(lpDllTable[iEmpty].Load = GetProcAddress (hDll,
                                            "DllLoadFromStream")))
        goto errLoad;

    if (!(lpDllTable[iEmpty].Clip = GetProcAddress (hDll,
                                            "DllCreateFromClip")))
        goto errLoad;

    if (!(lpDllTable[iEmpty].Link = GetProcAddress (hDll,
                                            "DllCreateLinkFromClip")))
        goto errLoad;

    if (!(lpDllTable[iEmpty].CreateFromTemplate = GetProcAddress (hDll,
                                            "DllCreateFromTemplate")))
        goto errLoad;

    if (!(lpDllTable[iEmpty].Create = GetProcAddress (hDll, "DllCreate")))
        goto errLoad;

    if (!(lpDllTable[iEmpty].CreateFromFile = GetProcAddress (hDll,
                                                    "DllCreateFromFile")))
        goto errLoad;

    if (!(lpDllTable[iEmpty].CreateLinkFromFile = GetProcAddress (hDll,
                                            "DllCreateLinkFromFile")))
        goto errLoad;

    lpDllTable[iEmpty].CreateInvisible = GetProcAddress (hDll,
                                            "DllCreateInvisible");

    lpDllTable[iEmpty].aDll = aDll;
    lpDllTable[iEmpty].cObj = 1;
    lpDllTable[iEmpty].hDll = hDll;
    if (iEmpty > iLast)
        iLast++;
    return iEmpty;

errLoad:
    if (aDll)
        GlobalDeleteAtom (aDll);
    if (hDll >= 32)
        FreeLibrary (hDll);
    return INVALID_INDEX;
}


// unload the the handler that can be free up (whose object count is NULL)

void FARINTERNAL UnloadDll ()
{
    if (!iUnloadableDll)
        return;

    if (iUnloadableDll == iLast)
        iLast--;

    if (lpDllTable[iUnloadableDll].aDll)
        GlobalDeleteAtom (lpDllTable[iUnloadableDll].aDll);
    lpDllTable[iUnloadableDll].aDll = NULL;
    FreeLibrary (lpDllTable[iUnloadableDll].hDll);
    lpDllTable[iUnloadableDll].hDll = NULL;

    iUnloadableDll = NULL;
}


//
// Reduce the object count of the handler, refered to by the index, by one.
// If the object count becomes NULL, free up the handler that is ready to be
// freed (refered to by index iUnloadableDll), and then make this handler the
// freeable one.
//
// As you can see we are trying to implement a simple mechanism of caching.
//

void FARINTERNAL DecreaseHandlerObjCount (iTable)
int iTable;
{
    if (!iTable)
        return;

    if (iTable != INVALID_INDEX) {
        ASSERT (lpDllTable[iTable].cObj, "Handler Obj count is already NULL");
        if (!--lpDllTable[iTable].cObj) {
            UnloadDll ();
            iUnloadableDll = iTable;
        }
    }
}



/***************************** Public  Function ****************************\
*
* OLESTATUS FARINTERNAL CreatePictFromClip (lpclient, lhclientdoc, lpobjname, lplpoleobject, optRender, cfFormat, lpClass, ctype)
*
*  CreatePictFromClip: This function creates the LP to an object
*  from the clipboard.  It will try to create a static picture object if
*  it understands any rendering formats on the clipboard. Currently, it
*  understands only bitmaps and metafiles.
*
* Effects:
*
* History:
* Wrote it.
\***************************************************************************/

OLESTATUS FARINTERNAL CreatePictFromClip (lpclient, lhclientdoc, lpobjname, lplpobj, optRender, cfFormat, lpClass, objType)
LPOLECLIENT         lpclient;
LHCLIENTDOC         lhclientdoc;
LPSTR               lpobjname;
LPOLEOBJECT FAR *   lplpobj;
OLEOPT_RENDER       optRender;
OLECLIPFORMAT       cfFormat;
LPSTR               lpClass;
LONG                objType;
{
    OLESTATUS   retVal = OLE_ERROR_OPTION;

    *lplpobj = NULL;

    if (optRender == olerender_none)
        return OLE_OK;
    else if (optRender == olerender_format) {
        switch (cfFormat) {
            case NULL:
                return OLE_ERROR_FORMAT;

            case CF_METAFILEPICT:
                return MfPaste (lpclient, lhclientdoc, lpobjname,
                            lplpobj, objType);

            case CF_DIB:
                return DibPaste (lpclient, lhclientdoc, lpobjname,
                            lplpobj, objType);

            case CF_BITMAP:
                return BmPaste (lpclient, lhclientdoc, lpobjname,
                            lplpobj, objType);

            default:
                return GenPaste (lpclient, lhclientdoc, lpobjname, lplpobj,
                            lpClass, cfFormat, objType);
        }
    }
    else if (optRender == olerender_draw) {
        cfFormat = EnumClipboardFormats (NULL);
        while ((cfFormat) && (retVal > OLE_WAIT_FOR_RELEASE)) {
            switch (cfFormat) {
                case CF_METAFILEPICT:
                    retVal = MfPaste (lpclient, lhclientdoc,
                                lpobjname, lplpobj, objType);
                    break;

                case CF_DIB:
                    retVal = DibPaste (lpclient, lhclientdoc,
                                lpobjname, lplpobj, objType);
                    break;

                case CF_BITMAP:
                    retVal = BmPaste (lpclient, lhclientdoc,
                                lpobjname, lplpobj, objType);
                    break;
            }

            cfFormat = EnumClipboardFormats (cfFormat);
        }
    }

    return retVal;
}



OLESTATUS FARINTERNAL CreatePackageFromClip (lpclient, lhclientdoc, lpobjname, lplpobj, optRender, cfFormat, objType)
LPOLECLIENT         lpclient;
LHCLIENTDOC         lhclientdoc;
LPSTR               lpobjname;
LPOLEOBJECT FAR *   lplpobj;
OLEOPT_RENDER       optRender;
OLECLIPFORMAT       cfFormat;
LONG                objType;
{
    char    file[MAX_STR+6];
    HANDLE  hData;
    LPSTR   lpFileName;

    if (!(hData = GetClipboardData (cfFileName))
            || !(lpFileName = GlobalLock (hData)))
        return OLE_ERROR_CLIPBOARD;


    if (objType == OT_LINK) {
        lstrcpy (file, lpFileName);
        lstrcat (file, "/Link");
        lpFileName = (LPSTR) file;
    }

    GlobalUnlock (hData);

    return  CreateEmbLnkFromFile (lpclient, packageClass, lpFileName,
                        NULL, lhclientdoc, lpobjname, lplpobj,
                        optRender, cfFormat, OT_EMBEDDED);
}



void FARINTERNAL RemoveLinkStringFromTopic (lpobj)
LPOBJECT_LE lpobj;
{
    char    buf[MAX_STR+6];
    int     i = 0;

    if (GlobalGetAtomName (lpobj->topic, buf, sizeof(buf))) {
        // scan the topic for "/Link"
        while (buf[i] != '/') {
            if (!buf[i])
                return;
            i++;
        }

        buf[i] = '\0';
        if (lpobj->topic)
            GlobalDeleteAtom (lpobj->topic);
        lpobj->topic = GlobalAddAtom (buf);
    }
}

void SetMaxPixel ()
{
    HDC hdc;
    // find out the pixel equivalent of MAX_HIMETRIC in X and Y directions

    if (hdc = GetDC (NULL)) {
        maxPixelsX = MulDiv (MAX_HIMETRIC, GetDeviceCaps(hdc, LOGPIXELSX),
                        2540);
        maxPixelsY = MulDiv (MAX_HIMETRIC, GetDeviceCaps(hdc, LOGPIXELSY),
                        2540);
        ReleaseDC (NULL, hdc);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\ole\client\ole.asm ===
;\
    ;   ole.asm
    ;
    ;   Copyright (C) 1991, MicroSoft Corporation
    ;
    ;   Contains pointer vaildation routine
    ;       
    ;   History:  sriniK   02/01/1991 original
    ;             srinik   02/21/1991 added GetGDIds, IsMetaDC
   ;/               

.286p
.MODEL SMALL
.CODE

;**************************** _CheckPointer ****************************
;
;   WORD    CheckPointer (lp, access)
;
;   Args:
;       lp          pointer to be verified
;       access      0 test the pointer for read access
;                   1 test the pointer for write access
;   returns: 
;       FALSE       invalid pointer
;       TRUE        valid pointer
;
;
;
        public  _CheckPointer

_CheckPointer   proc

            push    bp
            mov     bp, sp
            
            xor     ax, ax                                              
            and     word ptr [bp+8], -1
            jnz     check_write_access

            verr    word ptr [bp+6]     ; check selector for read access
            jnz     error
            jmp short check_offset

check_write_access:
            verw    word ptr [bp+6]     ; check selector for write access
            jnz     error                                         
                                                                        
check_offset:
            lsl     bx, word ptr [bp+6] ; segment limit gets copied into BX
            jnz     error                                         
            cmp     [bp+4], bx          
            ja      error                                       
            or      ax, -1                                              
error:                  
            pop     bp
            ret

_CheckPointer   endp



;**************************** _GetGdiDS ****************************
;
;   WORD    GetGDIds (lpGdiFunc)
;
;   Args:
;       lpGdiFunc   long pointer to one of the GDI functions, with selector
;                   part being aliased to a data selector
;   returns: 
;       GDI DS value
;
        public  _GetGDIds

_GetGDIds   proc

            push    bp
            mov     bp, sp
            
            mov     ax, word ptr [bp+6] ; data selector
            push    ds
            mov     ds, ax
            mov     bx, word ptr [bp+4] 
            mov     ax, word ptr ds:[bx+1]
            pop     ds

            pop     bp
            ret

_GetGDIds   endp




;**************************** _IsMetaDC ****************************
;
;   WORD    IsMetaDC (hdc, wGDIds)
;
;   Args:
;       hdc     handle device context
;       wGDIds  GDI's data segment selector
;
;   returns: 
;       TRUE    if hdc is metafile dc
;       FALSE   otherwise
;
; ilObjHead       struc                                                       
;                       dw      ?           ; pointer to next obj in chain    
;       ilObjType       dw      ?           ; defines type of object
;       ilObjCount      dd      ?           ; the count of the object         
;       ilObjMetaList   dw      ?           ; handle to the list of metafile  
; ilObjHead       ends                                                  
;

        public  _IsMetaDC

OBJ_METAFILE    equ     10

_IsMetaDC   proc

            push    bp
            mov     bp, sp
            
            mov     ax, [bp+6] ; data selector
            push    ds
            mov     ds, ax
            mov     di, [bp+4] ; hdc
            mov     di, [di]
            cmp     word ptr [di+2], OBJ_METAFILE
            jz      metafile
            xor     ax, ax
metafile:
            pop     ds
            pop     bp
            ret

_IsMetaDC   endp

            end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\ole\client\ledde.c ===
/****************************** Module Header ******************************\
* Module Name: LEDDE.C
*
* Purpose: ?????
*              
* Created: 1990
*
* Copyright (c) 1990, 1991  Microsoft Corporation
*
* History:
*   Raor, Srinik   (../../1990,91)  Designed and coded
*
\***************************************************************************/

#include <windows.h>
#include "dde.h"
#include "dll.h"

#define LN_FUDGE        16      // [],(), 3 * 3 (2 double quotes and comma)
#define RUNITEM

#define OLEVERB_CONNECT     0xFFFF

// Definitions for sending the server sys command.
char *srvrSysCmd[] = {"StdNewFromTemplate",
                      "StdNewDocument",
                      "StdEditDocument",
                      "StdOpenDocument"
                      };

#define EMB_ID_INDEX    11          // index of ones digit in #00
extern  char    embStr[];
extern  BOOL    gbCreateInvisible;
extern  BOOL    gbLaunchServer;

extern  ATOM    aMSDraw;

extern  BOOL (FAR PASCAL *lpfnIsTask) (HANDLE);

// !!! set error hints

OLESTATUS FARINTERNAL LeDoVerb (lpobj, verb, fShow, fActivate)
LPOBJECT_LE lpobj;
WORD        verb;
BOOL        fShow;
BOOL        fActivate;
{

    PROBE_ASYNC (lpobj);
    PROBE_SVRCLOSING(lpobj);
    
    if (!QueryOpen(lpobj))
        return OLE_OK;

    lpobj->verb = verb;
    lpobj->fCmd = ACT_DOVERB;

    if (fActivate)
        lpobj->fCmd |= ACT_ACTIVATE;

    if (fShow)
        lpobj->fCmd |= ACT_SHOW;

    InitAsyncCmd (lpobj, OLE_RUN, DOCSHOW);
    return DocShow (lpobj);
}



OLESTATUS FARINTERNAL LeShow (lpobj, fActivate)
LPOBJECT_LE lpobj;
BOOL        fActivate;
{

    PROBE_ASYNC (lpobj);
    PROBE_SVRCLOSING(lpobj);
    
    if (!QueryOpen(lpobj))
        return OLE_OK;

    lpobj->fCmd = ACT_SHOW;
    InitAsyncCmd (lpobj, OLE_SHOW, DOCSHOW);
    return DocShow (lpobj);
}


// DocShow : If the server is connected, show the item
// for editing. For embedded objects us NULL Item.
OLESTATUS DocShow (lpobj)
LPOBJECT_LE lpobj;
{
    switch (lpobj->subRtn) {

        case 0:
            SendStdShow (lpobj);
            WAIT_FOR_ASYNC_MSG (lpobj);

        case 1:
            ProcessErr (lpobj);
            return EndAsyncCmd (lpobj);

        default:
            DEBUG_OUT ("Unexpected subroutine", 0);
            return OLE_ERROR_GENERIC;
    }
}


void SendStdShow (lpobj)
LPOBJECT_LE lpobj;
{

    WORD    len;
    WORD    size;
    LPSTR   lpdata = NULL;
    HANDLE  hdata = NULL;
    BOOL    bShow;

    lpobj->subErr = OLE_OK;
    
    if (lpobj->verb == OLEVERB_CONNECT) {
        lpobj->verb = NULL;
        return;
    }
    
    if (!(lpobj->fCmd & (ACT_SHOW | ACT_DOVERB)))
        return;

    if (bShow = (!lpobj->bOleServer || !(lpobj->fCmd & ACT_DOVERB))) {

        // show is off, do not show the server.
        if (!(lpobj->fCmd & ACT_SHOW))
            return;

        SETERRHINT(lpobj, OLE_ERROR_SHOW);
        //  and 18 "[StdShowItem(\"")for 5 extra for ",FALSE
        len = 18 + 7;
    } else {
        // 19 for the string [StdDoVerbItem(\"") and
        // 18 extra is for ",000,FALSE,FALSE
        SETERRHINT(lpobj, OLE_ERROR_DOVERB);
        len = 19 + 18;
    }

    len += GlobalGetAtomLen (lpobj->item);

    len +=  4;                 // ")]" + NULL

    hdata = GlobalAlloc (GMEM_DDESHARE, size = len);
    if (hdata == NULL || (lpdata = (LPSTR)GlobalLock (hdata)) == NULL)
        goto errRtn;

    if (bShow)
        lstrcpy (lpdata, "[StdShowItem(\"");
    else
        lstrcpy (lpdata, "[StdDoVerbItem(\"");

    len = lstrlen (lpdata);

    if (lpobj->item)
        GlobalGetAtomName (lpobj->item , lpdata + len, size - len);

    if (!bShow) {

        lstrcat (lpdata, (LPSTR)"\",");
        // assume that the number of verbs are < 10

        len = lstrlen (lpdata);
#ifdef  FIREWALLS
        ASSERT ( (lpobj->verb & 0x000f) < 9 , "Verb value more than 9");
#endif
        lpdata += len;
        *lpdata++ = (char)((lpobj->verb & 0x000f) + '0');
        *lpdata = 0;

        if (lpobj->fCmd & ACT_SHOW)
            lstrcat (lpdata, (LPSTR) ",TRUE");
        else
            lstrcat (lpdata, (LPSTR) ",FALSE");
                // StdVerbItem (item, verb, TRUE
        // add TRUE/FALSE constant for the activate
        if (!(lpobj->fCmd & ACT_ACTIVATE))
            lstrcat (lpdata, (LPSTR) ",TRUE)]");
        else
            lstrcat (lpdata, (LPSTR) ",FALSE)]");
            // [StdDoVerb ("item", verb, FALSE, FALSE)]
    } else
        lstrcat (lpdata, (LPSTR)"\")]");
        // apps like excel and wingraph do not suuport activate at
        // item level.


    GlobalUnlock (hdata);
    DocExecute (lpobj, hdata);
    return;

errRtn:
    if (lpdata)
        GlobalUnlock (hdata);

    if (hdata)
        GlobalFree (hdata);

    lpobj->subErr = OLE_ERROR_MEMORY;
    return;
}



OLESTATUS FARINTERNAL  LeQueryOpen (LPOBJECT_LE lpobj)
{

    if (QueryOpen(lpobj))
       return OLE_OK;
    else
       return OLE_ERROR_NOT_OPEN;

}


BOOL    INTERNAL  QueryOpen (LPOBJECT_LE lpobj)
{

    if (lpobj->pDocEdit &&  lpobj->pDocEdit->hClient) {
        if (IsServerValid (lpobj))
            return TRUE;
        // destroy the windows and pretend as if the server was never
        // connected.

        DestroyWindow (lpobj->pDocEdit->hClient);
        if (lpobj->pSysEdit && lpobj->pSysEdit->hClient)
            DestroyWindow (lpobj->pSysEdit->hClient);

    }
    return FALSE;
}



OLESTATUS FARINTERNAL  LeActivate (lpobj, verb, fShow, fActivate, hWnd, lprc)
LPOBJECT_LE lpobj;
WORD        verb;
BOOL        fShow;
BOOL        fActivate;
HWND        hWnd;
LPRECT      lprc;
{

    lpobj->verb = verb;
    if (lpobj->head.ctype == CT_EMBEDDED)
        return EmbOpen (lpobj, fShow, fActivate, hWnd, lprc);
    
#ifdef  FIREWALLS
    ASSERT (lpobj->head.ctype == CT_LINK, "unknown object");
#endif
    return LnkOpen (lpobj, fShow, fActivate, hWnd, lprc);
    
}


OLESTATUS FARINTERNAL  LeUpdate (lpobj)
LPOBJECT_LE lpobj;
{
    if (lpobj->head.ctype == CT_EMBEDDED)
        return EmbUpdate (lpobj);
    
#ifdef  FIREWALLS
    ASSERT (lpobj->head.ctype == CT_LINK, "unknown object");
#endif
    return LnkUpdate (lpobj);
}



OLESTATUS FARINTERNAL  EmbOpen (lpobj, fShow, fActivate, hWnd, lprc)
LPOBJECT_LE lpobj;
BOOL        fShow;
BOOL        fActivate;
HWND        hWnd;
LPRECT      lprc;
{

    PROBE_ASYNC (lpobj);
    PROBE_SVRCLOSING(lpobj);
    
    if(QueryOpen (lpobj))
        return LeDoVerb (lpobj, lpobj->verb, fShow, fActivate);

    // show the window
    // advise for data only on close
    // and shut down the conv  after the advises.

    lpobj->fCmd = LN_EMBACT | ACT_DOVERB | ACT_ADVISE | ACT_CLOSE;
    if (fActivate)
        lpobj->fCmd |= ACT_ACTIVATE;

    if (fShow)
        lpobj->fCmd |= ACT_SHOW;

    InitAsyncCmd (lpobj, OLE_ACTIVATE, EMBOPENUPDATE);
    return EmbOpenUpdate (lpobj);

}



/***************************** Public  Function ****************************\
* OLESTATUS FARINTERNAL  EmbUpdate (lpobj)
*
* This function updates an EMB object. If the server is connected
* simply send a request for the native as well as the display formats.
* If the server is connected, then tries to start the conversationa and
* get the data. If the conversation fails, then load the server and
* start the conversation. The embeded objects may have links in it.
*
* Effects:
*
* History:
* Wrote it.
\***************************************************************************/


OLESTATUS FARINTERNAL  EmbUpdate (lpobj)
LPOBJECT_LE lpobj;
{

    // if we are loading the server, then definitly unload.
    // if the connection is established, then unload if it is
    // to be unloaded, when  all the previous requests are satisfied.


    PROBE_ASYNC (lpobj);
    PROBE_SVRCLOSING(lpobj);
    
    lpobj->fCmd = LN_EMBACT | ACT_REQUEST | (QueryOpen(lpobj) ? 0 : ACT_UNLAUNCH);
    InitAsyncCmd (lpobj, OLE_UPDATE, EMBOPENUPDATE);
    return EmbOpenUpdate (lpobj);

}



OLESTATUS FARINTERNAL  EmbOpenUpdate (lpobj)
LPOBJECT_LE lpobj;
{

    switch (lpobj->subRtn) {

        case 0:

            SKIP_TO (QueryOpen(lpobj), step6);
            SendSrvrMainCmd  (lpobj, lpobj->lptemplate);
            lpobj->lptemplate = NULL;
            WAIT_FOR_ASYNC_MSG (lpobj);

        case 1:

            if (ProcessErr (lpobj))
                 goto errRtn;

            // Init doc conversation should set the failure error
            if (!InitDocConv (lpobj, !POPUP_NETDLG))
                 goto errRtn;

            // If there is no native data, do not do any poke.
            // creates will not have any poke data to start with

            SKIP_TO (!(lpobj->hnative), step6);
            PokeNativeData (lpobj);
            WAIT_FOR_ASYNC_MSG (lpobj);

        case 2:
            if (ProcessErr (lpobj))
                 goto errRtn;
            // Now poke the hostnames etc stuff.
            PokeHostNames (lpobj);
            WAIT_FOR_ASYNC_MSG (lpobj);

        case 3:

            // do not worry about the poke hostname errors
            PokeTargetDeviceInfo (lpobj);
            WAIT_FOR_ASYNC_MSG (lpobj);

        case 4:

            PokeDocDimensions (lpobj);
            WAIT_FOR_ASYNC_MSG (lpobj);

        case 5:

            PokeColorScheme (lpobj);
            WAIT_FOR_ASYNC_MSG (lpobj);


        case 6:

            step6:

            // wingraph does not accept the  doc dimensions
            // after sttedit.
            CLEAR_STEP_ERROR (lpobj);
            SETSTEP (lpobj, 6);
            STEP_NOP (lpobj);
            // step_nop simply increments the step numebr
            // merge the steps later on



        case 7:

            if (ProcessErr (lpobj))
                goto errRtn;

            SKIP_TO (!(lpobj->fCmd & ACT_ADVISE), step11);
            lpobj->optUpdate = oleupdate_onsave;
            lpobj->pDocEdit->nAdviseSave = 0;
            AdviseOn (lpobj, cfNative, aSave);
            WAIT_FOR_ASYNC_MSG (lpobj);

        case 8:

            // do not go for errors on /save. Some servers may not support
            // this.

            CLEAR_STEP_ERROR (lpobj);
            AdvisePict (lpobj, aSave);
            WAIT_FOR_ASYNC_MSG (lpobj);

        case 9:

            // do not worry about the error case for save. Ignore them

            CLEAR_STEP_ERROR (lpobj);
            lpobj->optUpdate = oleupdate_onclose;
            lpobj->pDocEdit->nAdviseClose = 0;
            AdviseOn (lpobj, cfNative, aClose);
            WAIT_FOR_ASYNC_MSG (lpobj);


        case 10:
            if (ProcessErr(lpobj))
                goto errRtn;

            AdvisePict (lpobj, aClose);
            WAIT_FOR_ASYNC_MSG (lpobj);

        case 11:

            step11:
            SETSTEP (lpobj, 11);
            if (ProcessErr(lpobj))
                goto errRtn;

            SKIP_TO (!(lpobj->fCmd & ACT_REQUEST), step13);
            
            // we don't want to send OLE_CHANGED when we get this data, if we
            // are going to request for picture data also.
            lpobj->pDocEdit->bCallLater = ((lpobj->lpobjPict) ? TRUE: FALSE);
            RequestOn (lpobj, cfNative);
            WAIT_FOR_ASYNC_MSG (lpobj);

            // If request pict fails, then native and pict are
            // not in sync.

        case 12:
            if (ProcessErr(lpobj))
                goto errRtn;

            lpobj->pDocEdit->bCallLater = FALSE;
            RequestPict (lpobj);
            WAIT_FOR_ASYNC_MSG (lpobj);


        case 13:

            step13:
            SETSTEP(lpobj, 13);

            if (ProcessErr(lpobj))
                goto errRtn;

            SendStdShow (lpobj);
            WAIT_FOR_ASYNC_MSG (lpobj);

        case 14:


            if (ProcessErr(lpobj))
                goto errRtn;

            SKIP_TO ((lpobj->fCmd & ACT_UNLAUNCH), step15);
            return EndAsyncCmd (lpobj);


        case 15:

errRtn:
            step15:
            ProcessErr (lpobj);

            if ((lpobj->asyncCmd == OLE_UPDATE) 
                    && (!(lpobj->fCmd & ACT_UNLAUNCH)))
                return EndAsyncCmd (lpobj);
                
            // if we launched and error, unlaunch (send stdexit)
            NextAsyncCmd (lpobj, EMBLNKDELETE);
            lpobj->fCmd |= ACT_UNLAUNCH;
            EmbLnkDelete (lpobj);
            return lpobj->mainErr;


      default:
            DEBUG_OUT ("Unexpected subroutine", 0);
            return OLE_ERROR_GENERIC;
    }
}




OLESTATUS FARINTERNAL  LnkOpen (lpobj, fShow, fActivate, hWnd, lprc)
LPOBJECT_LE    lpobj;
BOOL        fShow;
BOOL        fActivate;
HWND        hWnd;
LPRECT      lprc;
{

    PROBE_ASYNC (lpobj);
    PROBE_SVRCLOSING(lpobj);
    
    if(QueryOpen (lpobj))
        return LeDoVerb (lpobj, lpobj->verb, fShow, fActivate);

    // Just end the system conversation. we are not unloading
    // this instance at all.

    lpobj->fCmd = LN_LNKACT |  ACT_DOVERB;

    if (lpobj->optUpdate == oleupdate_always)
        lpobj->fCmd |= ACT_ADVISE | ACT_REQUEST;
    else if (lpobj->optUpdate == oleupdate_onsave)
        lpobj->fCmd |= ACT_ADVISE;
    
    if (fActivate)
        lpobj->fCmd |= ACT_ACTIVATE;

    if (fShow)
        lpobj->fCmd |= ACT_SHOW;

    InitAsyncCmd (lpobj, OLE_ACTIVATE, LNKOPENUPDATE);
    return LnkOpenUpdate (lpobj);

}


OLESTATUS FARINTERNAL  LnkUpdate (lpobj)
LPOBJECT_LE lpobj;
{
    // if we are loading the server, then definitly unload.
    // if the connection is established, then unload if it is
    // to be unloaded, when  all the previous requests are satisfied.


    PROBE_ASYNC (lpobj);
    PROBE_SVRCLOSING(lpobj);
    
    lpobj->fCmd = LN_LNKACT | ACT_REQUEST | (QueryOpen (lpobj) ? 0 : ACT_UNLAUNCH);
    InitAsyncCmd (lpobj, OLE_UPDATE, LNKOPENUPDATE);
    return LnkOpenUpdate (lpobj);
}



OLESTATUS FARINTERNAL  LnkOpenUpdate (lpobj)
LPOBJECT_LE lpobj;
{
    switch (lpobj->subRtn) {

        case 0:

            SKIP_TO (QueryOpen(lpobj), step2);
            InitDocConv (lpobj, !POPUP_NETDLG);
            if (QueryOpen(lpobj)) {
                if (lpobj->app == aPackage)
                    RemoveLinkStringFromTopic (lpobj);
                goto step2;
            }
            
            SendSrvrMainCmd (lpobj, NULL);
            WAIT_FOR_ASYNC_MSG (lpobj);


        case 1:

            if (ProcessErr (lpobj))
                 goto errRtn;

            if (lpobj->app == aPackage)
                RemoveLinkStringFromTopic (lpobj);
            
            if (!InitDocConv (lpobj, POPUP_NETDLG)) {
                lpobj->subErr = OLE_ERROR_OPEN;
                goto errRtn;
            }

        case 2:

            step2:

            SETSTEP (lpobj, 2);
            PokeTargetDeviceInfo (lpobj);
            WAIT_FOR_ASYNC_MSG (lpobj);
  
       case 3:

            if (ProcessErr (lpobj))
                goto errRtn;

            SKIP_TO (!(lpobj->fCmd & ACT_ADVISE), step6);
            SKIP_TO (!(lpobj->fCmd & ACT_NATIVE), step4);
            AdviseOn (lpobj, cfNative, NULL);
            WAIT_FOR_ASYNC_MSG (lpobj);

       case 4:
            step4:
            SETSTEP  (lpobj, 4);
            if (ProcessErr (lpobj))
                goto errRtn;

            AdvisePict (lpobj, NULL);
            WAIT_FOR_ASYNC_MSG (lpobj);

       case 5:

            if (ProcessErr (lpobj))
                goto errRtn;

            // Now send advise for renaming the documnet.
            AdviseOn (lpobj, cfBinary, aStdDocName);
            WAIT_FOR_ASYNC_MSG (lpobj);

       case 6:

            step6:
            // if name advise fails ignore it
            SETSTEP (lpobj, 6);

            CLEAR_STEP_ERROR (lpobj);
            SKIP_TO (!(lpobj->fCmd & ACT_REQUEST), step8);
            SKIP_TO (!(lpobj->fCmd & ACT_NATIVE), step7);
            
            // we don't want to send OLE_CHANGED when we get this data, if we
            // are going to request for picture data also.
            lpobj->pDocEdit->bCallLater = ((lpobj->lpobjPict) ? TRUE: FALSE);
            RequestOn (lpobj, cfNative);
            WAIT_FOR_ASYNC_MSG (lpobj);

       case 7:
            step7:

            SETSTEP (lpobj, 7);
            if (ProcessErr (lpobj))
                goto errRtn;

            lpobj->pDocEdit->bCallLater = FALSE;
            RequestPict (lpobj);
            WAIT_FOR_ASYNC_MSG (lpobj);

      case 8:

            step8:

            SETSTEP     (lpobj, 8);
            if (ProcessErr (lpobj))
                goto errRtn;

            SKIP_TO (!(lpobj->fCmd & ACT_TERMDOC), step10);
            // terminate the document conversataion.
            TermDocConv (lpobj);
            WAIT_FOR_ASYNC_MSG (lpobj);
    
      case 9:

            if (ProcessErr (lpobj))
                goto errRtn;

            // delete the server edit block
            DeleteDocEdit (lpobj);

            SKIP_TO ((lpobj->fCmd & ACT_UNLAUNCH), step14);
            return EndAsyncCmd (lpobj);

      case 10:

            step10:
            SETSTEP     (lpobj, 10);

            if (ProcessErr (lpobj))
                goto errRtn;

            SKIP_TO (!(lpobj->fCmd & ACT_TERMSRVR), step12);

            // terminate the server conversataion.
            TermSrvrConv (lpobj);
            WAIT_FOR_ASYNC_MSG (lpobj);

      case 11:

            if (ProcessErr (lpobj))
                goto errRtn;

            // delete the server edit block
            DeleteSrvrEdit (lpobj);
            return EndAsyncCmd (lpobj);


      case 12:

            step12:
            SETSTEP     (lpobj, 12);
            if (ProcessErr (lpobj))
                goto errRtn;

            SendStdShow (lpobj);
            WAIT_FOR_ASYNC_MSG (lpobj);

      case 13:

            if (ProcessErr (lpobj))
                goto errRtn;
            SKIP_TO ((lpobj->fCmd & ACT_UNLAUNCH), step14);
            return EndAsyncCmd (lpobj);


      case 14:

            errRtn:
            step14:
            ProcessErr (lpobj);

            if ((lpobj->asyncCmd == OLE_UPDATE) 
                    && (!(lpobj->fCmd & ACT_UNLAUNCH)))
                return EndAsyncCmd (lpobj);
                
            // if we launched and error, unlaunch (send stdexit)
            NextAsyncCmd (lpobj, EMBLNKDELETE);
            lpobj->fCmd |= ACT_UNLAUNCH;
            EmbLnkDelete (lpobj);
            return lpobj->mainErr;

       default:
            DEBUG_OUT ("Unexpected subroutine", 0);
            return OLE_ERROR_GENERIC;
    }
}



OLESTATUS EmbLnkClose (lpobj)
LPOBJECT_LE lpobj;
{
    switch (lpobj->subRtn) {

        case    0:
            TermDocConv (lpobj);
            WAIT_FOR_ASYNC_MSG (lpobj);

        case    1:

            // delete the edit block
            DeleteDocEdit (lpobj);
            TermSrvrConv (lpobj);
            WAIT_FOR_ASYNC_MSG (lpobj);

        case    2:

            // Do not set any errors, just delete the object.
            // delete the server edit block
            DeleteSrvrEdit (lpobj);
            return EndAsyncCmd (lpobj);


        default:
            DEBUG_OUT ("Unexpected subroutine", 0);
            return OLE_ERROR_GENERIC;
    }
}


OLESTATUS FARINTERNAL  LeClose (lpobj)
LPOBJECT_LE lpobj;
{
    PROBE_ASYNC (lpobj);
    if (IS_SVRCLOSING(lpobj))
        return OLE_OK;
    
    
    lpobj->fCmd = 0;
    
    if (lpobj->head.ctype == CT_EMBEDDED) {
        InitAsyncCmd (lpobj, OLE_CLOSE, EMBLNKDELETE);
        return EmbLnkDelete (lpobj);    
    }
    else {
        InitAsyncCmd (lpobj, OLE_CLOSE, EMBLNKCLOSE);
        return EmbLnkClose (lpobj);
    }
}



OLESTATUS FARINTERNAL  LeReconnect (lpobj)
LPOBJECT_LE    lpobj;
{
    // check for the existing conversation.
    // if the client window is non-null, then
    // connection exits.

    if (lpobj->head.ctype != CT_LINK)
        return OLE_ERROR_NOT_LINK;     // allow only for linked

    PROBE_ASYNC (lpobj);
    PROBE_SVRCLOSING(lpobj);
    
    if (QueryOpen (lpobj))
        return OLE_OK;

    // start just the conversation. Do not load
    // the app.

    if (!InitDocConv (lpobj, !POPUP_NETDLG))
         return OLE_OK;             // document is not loaded , it is OK.

    lpobj->fCmd = LN_LNKACT;
    if (lpobj->optUpdate == oleupdate_always)
        lpobj->fCmd |= ACT_ADVISE | ACT_REQUEST;
    
    InitAsyncCmd (lpobj, OLE_RECONNECT, LNKOPENUPDATE);
    return LnkOpenUpdate (lpobj);
}




OLESTATUS INTERNAL PokeNativeData (lpobj)
LPOBJECT_LE lpobj;
{
   SETERRHINT(lpobj, OLE_ERROR_POKE_NATIVE);
   return SendPokeData (lpobj,
                    lpobj->item,
                    lpobj->hnative,
                    cfNative);
}




BOOL INTERNAL PostMessageToServer (pedit, msg, lparam)
PEDIT_DDE   pedit;
WORD        msg;
LONG        lparam;
{

#ifdef  FIREWALLS
    ASSERT (pedit, "Dde edit block is NULL");
#endif
    // save the lparam and msg fpr possible reposting incase of error.

    // we are in abort state.  no messages except for terminate.

    if (pedit->bAbort && msg != WM_DDE_TERMINATE)
        return FALSE;

    pedit->lParam = lparam;
    pedit->msg    = msg;

    if (pedit->hClient && pedit->hServer) {
        while (TRUE){
            if (!IsWindowValid (pedit->hServer))
                return FALSE;
            if (PostMessage (pedit->hServer, msg, pedit->hClient, lparam) == FALSE)
                Yield ();
            else
                return TRUE;
        }
    }
    return FALSE;
}


OLESTATUS FARINTERNAL LeCreateFromTemplate (lpclient, lptemplate, lhclientdoc, lpobjname, lplpoleobject, optRender, cfFormat)
LPOLECLIENT         lpclient;
LPSTR               lptemplate;
LHCLIENTDOC         lhclientdoc;
LPSTR               lpobjname;
LPOLEOBJECT FAR *   lplpoleobject;
OLEOPT_RENDER       optRender;
OLECLIPFORMAT       cfFormat;
{
    char            buf[MAX_STR];

    if (!MapExtToClass (lptemplate, (LPSTR)buf, MAX_STR))
        return OLE_ERROR_CLASS;

    return CreateFromClassOrTemplate (lpclient, (LPSTR) buf, lplpoleobject, 
                        optRender, cfFormat, LN_TEMPLATE, lptemplate, 
                        lhclientdoc, lpobjname);
}


OLESTATUS FARINTERNAL LeCreate (lpclient, lpclass, lhclientdoc, lpobjname, lplpoleobject, optRender, cfFormat)
LPSTR               lpclass;
LPOLECLIENT         lpclient;
LHCLIENTDOC         lhclientdoc;
LPSTR               lpobjname;
LPOLEOBJECT FAR *   lplpoleobject;
OLEOPT_RENDER       optRender;
OLECLIPFORMAT       cfFormat;
{
    if (gbCreateInvisible) {
        // this is in fact a call for invisible create
        return LeCreateInvisible (lpclient, lpclass, lhclientdoc, lpobjname, 
                        lplpoleobject, optRender, cfFormat, gbLaunchServer);
    }
    
    return CreateFromClassOrTemplate (lpclient, lpclass, lplpoleobject, 
                        optRender, cfFormat, LN_NEW, NULL, 
                        lhclientdoc, lpobjname);
}



OLESTATUS FARINTERNAL CreateFromClassOrTemplate (lpclient, lpclass, lplpoleobject, optRender, cfFormat, lnType, lptemplate, lhclientdoc, lpobjname)
LPOLECLIENT         lpclient;
LPSTR               lpclass;
LPOLEOBJECT FAR *   lplpoleobject;
OLEOPT_RENDER       optRender;
OLECLIPFORMAT       cfFormat;
WORD                lnType;
LPSTR               lptemplate;
LHCLIENTDOC         lhclientdoc;
LPSTR               lpobjname;
{
    OLESTATUS       retval = OLE_ERROR_MEMORY;
    LPOBJECT_LE     lpobj = NULL;
    ATOM            aServer;
    char            chVerb [2];
    
    if (!(aServer = GetAppAtom (lpclass)))
        return OLE_ERROR_CLASS;
    
    if(!(lpobj = LeCreateBlank (lhclientdoc, lpobjname, CT_EMBEDDED))) {
        GlobalDeleteAtom (aServer);
        goto errRtn;
    }
    
    // Now set the server.

    lpobj->head.lpclient = lpclient;
    lpobj->app           = GlobalAddAtom (lpclass);
    SetEmbeddedTopic (lpobj);
    lpobj->item          = NULL;
    lpobj->bOleServer    = QueryVerb (lpobj, 0, (LPSTR)&chVerb, 2);
    lpobj->aServer       = aServer;

    // launch the app and start the system conversation.
        
    if (!CreatePictObject (lhclientdoc, lpobjname, lpobj, 
                optRender, cfFormat, lpclass))
        goto errRtn;

        
    // show the window. Advise for data and close on receiving data
    lpobj->fCmd = lnType | ACT_SHOW | ACT_ADVISE | ACT_CLOSE;
    InitAsyncCmd (lpobj, lptemplate? OLE_CREATEFROMTEMPLATE : OLE_CREATE, EMBOPENUPDATE);
    *lplpoleobject = (LPOLEOBJECT)lpobj;

    lpobj->lptemplate = lptemplate;
    
    if ((retval = EmbOpenUpdate (lpobj)) <= OLE_WAIT_FOR_RELEASE)
        return retval;

    // If there is error afterwards, then the client app should call
    // to delete the object.

errRtn:

    // for error termination OleDelete will terminate any conversation
    // in action.

    if (lpobj) {
        // This oledelete will not result in asynchronous command.
        OleDelete ((LPOLEOBJECT)lpobj); 
        *lplpoleobject = NULL;
    }
    
    return retval;
}



OLESTATUS FARINTERNAL CreateEmbLnkFromFile (lpclient, lpclass, lpfile, lpitem, lhclientdoc, lpobjname, lplpoleobject, optRender, cfFormat, objType)
LPOLECLIENT         lpclient;
LPSTR               lpclass;
LPSTR               lpfile;
LPSTR               lpitem;
LHCLIENTDOC         lhclientdoc;
LPSTR               lpobjname;
LPOLEOBJECT FAR *   lplpoleobject;
OLEOPT_RENDER       optRender;
OLECLIPFORMAT       cfFormat;
LONG                objType;
{
    OLESTATUS           retval = OLE_ERROR_MEMORY;
    LPOBJECT_LE         lpobj = NULL;
    ATOM                aServer;
    char                buf[MAX_STR];
    OLE_RELEASE_METHOD  releaseMethod;
    WORD                wFlags = NULL;
    char                chVerb[2];

    if (!lpclass && (lpclass = (LPSTR) buf) 
            && !MapExtToClass (lpfile, (LPSTR)buf, MAX_STR))
        return OLE_ERROR_CLASS;
    
    if (!(aServer = GetAppAtom (lpclass)))
        return OLE_ERROR_CLASS;
    
    if (!(lpobj = LeCreateBlank (lhclientdoc, lpobjname, CT_LINK))) {
        GlobalDeleteAtom (aServer);
        goto errFileCreate;
    }
    
    lpobj->head.lpclient = lpclient;
    lpobj->app           = GlobalAddAtom (lpclass);
    lpobj->topic         = GlobalAddAtom (lpfile);
    lpobj->aServer       = aServer;
    lpobj->bOleServer    = QueryVerb (lpobj, 0, (LPSTR)&chVerb, 2);
    if ((retval = SetNetName (lpobj)) != OLE_OK)
        goto errFileCreate;
    
    if (lpitem)
        lpobj->item = GlobalAddAtom (lpitem);

    if (!CreatePictObject (lhclientdoc, lpobjname, lpobj, 
                optRender, cfFormat, lpclass)) {
        retval = OLE_ERROR_MEMORY;
        goto errFileCreate;
    }
    
    *lplpoleobject = (LPOLEOBJECT) lpobj;
    
    if (objType == CT_EMBEDDED) {
        releaseMethod = OLE_CREATEFROMFILE;
        if ((optRender == olerender_format) && (cfFormat == cfNative))
            wFlags = 0;
        else
            wFlags = ACT_NATIVE;
    }
    else {          
        // caller wants linked object to be created
        
        // if no presentation data is requested and the link is to the whole
        // file, then there is no need to launch the server. 
            
        if ((optRender == olerender_none) && !lpobj->item)
            return FileExists (lpobj);
        
        // we want to establish hot link
        wFlags = ACT_ADVISE; 
        releaseMethod = OLE_CREATELINKFROMFILE;     
    }

    lpobj->fCmd = LN_LNKACT | ACT_REQUEST | ACT_UNLAUNCH | wFlags;      
    InitAsyncCmd (lpobj, releaseMethod , LNKOPENUPDATE);       
    
    if ((retval = LnkOpenUpdate (lpobj)) <= OLE_WAIT_FOR_RELEASE)
        return retval;
    
    // If there is error afterwards, then the client app should call
    // to delete the object.


errFileCreate:  

    if (lpobj) {
        // This oledelete will not result in asynchronous command.
        OleDelete ((LPOLEOBJECT)lpobj); 
        *lplpoleobject = NULL;
    }
    
    return retval;
}



//////////////////////////////////////////////////////////////////////////////
//
// OLESTATUS FARINTERNAL LeCreateInvisible (lpclient, lpclass, lhclientdoc, lpobjname, lplpoleobject, optRender, cfFormat, bActivate)
//
//  Arguments:
//
//     lpclient -   
//     lpclass  -   
//     lhclientdoc  -   
//     lpobjname    -   
//     lplpoleobject    -   
//     optRender    -   
//     cfFormat -   
//     fActivate    -
//
//  Returns:
//
//      OLE_ERROR_CLASS -   
//      OLE_OK  -   
//      EmbOpenUpdate (lpobj)   -   
//      retval  -   
//
//  Effects:
//
//////////////////////////////////////////////////////////////////////////////

OLESTATUS FARINTERNAL LeCreateInvisible (lpclient, lpclass, lhclientdoc, lpobjname, lplpoleobject, optRender, cfFormat, fActivate)
LPSTR               lpclass;
LPOLECLIENT         lpclient;
LHCLIENTDOC         lhclientdoc;
LPSTR               lpobjname;
LPOLEOBJECT FAR *   lplpoleobject;
OLEOPT_RENDER       optRender;
OLECLIPFORMAT       cfFormat;
BOOL                fActivate;
{
    OLESTATUS       retval = OLE_ERROR_MEMORY;
    LPOBJECT_LE     lpobj = NULL;
    ATOM            aServer;
    char            chVerb [2];
    
    if (!(aServer = GetAppAtom (lpclass)))
        return OLE_ERROR_CLASS;
    
    if(!(lpobj = LeCreateBlank (lhclientdoc, lpobjname, CT_EMBEDDED))) {
        GlobalDeleteAtom (aServer);
        goto errRtn;
    }
    
    // Now set the server.

    lpobj->head.lpclient = lpclient;
    lpobj->app           = GlobalAddAtom (lpclass);
    lpobj->item          = NULL;
    lpobj->bOleServer    = QueryVerb (lpobj, 0, (LPSTR)&chVerb, 2);
    lpobj->aServer       = aServer;
    lpobj->lptemplate    = NULL;
    SetEmbeddedTopic (lpobj);
    
    if (!CreatePictObject (lhclientdoc, lpobjname, lpobj, 
                optRender, cfFormat, lpclass))
        goto errRtn;

    *lplpoleobject = (LPOLEOBJECT)lpobj;
    
    if (!fActivate)
        return OLE_OK;

    // show the window. Advise for data and close on receiving data
    lpobj->fCmd = LN_NEW | ACT_ADVISE | ACT_CLOSE;
    InitAsyncCmd (lpobj, OLE_CREATEINVISIBLE, EMBOPENUPDATE);

    // launch the app and start the system conversation.
    if ((retval = EmbOpenUpdate (lpobj)) <= OLE_WAIT_FOR_RELEASE)
        return retval;

    // If there is error afterwards, then the client app should call
    // to delete the object.

errRtn:

    // for error termination OleDelete will terminate any conversation
    // in action.

    if (lpobj) {
        // This oledelete will not result in asynchronous command.
        OleDelete ((LPOLEOBJECT)lpobj);
        *lplpoleobject = NULL;
    }
    
    return retval;
}



// LeSetUpdateOptions: sets the update options. If the server
// is connectd then it unadvises for the current options and
// advises for the new options.

OLESTATUS   FARINTERNAL LeSetUpdateOptions (lpobj, options)
LPOBJECT_LE         lpobj;
OLEOPT_UPDATE       options;
{

    PROBE_OLDLINK (lpobj);
    PROBE_ASYNC (lpobj);
    
    //!!! make sure the options are within range.
    
    if (lpobj->head.ctype != CT_LINK)
        return (OLE_ERROR_OBJECT);

    if (options > oleupdate_oncall)
        return OLE_ERROR_OPTION;

    if (lpobj->optUpdate == options)
        return OLE_OK;

    if (!QueryOpen (lpobj) || IS_SVRCLOSING(lpobj)) {
       lpobj->optUpdate = options;
       return OLE_OK;
    }

    lpobj->optNew = options;
    lpobj->fCmd = 0;
    InitAsyncCmd (lpobj, OLE_SETUPDATEOPTIONS, LNKSETUPDATEOPTIONS);
    return LnkSetUpdateOptions (lpobj);

}

OLESTATUS   LnkSetUpdateOptions (lpobj)
LPOBJECT_LE         lpobj;
{

    switch (lpobj->subRtn) {

        case 0:

            if (lpobj->optUpdate == oleupdate_oncall)
                goto step1;

            // If the server is active then unadvise for old
            // options.

            UnAdvisePict (lpobj);
            WAIT_FOR_ASYNC_MSG (lpobj);

        case 1:
            step1:

            SETSTEP (lpobj, 1);
            ProcessErr (lpobj);

            lpobj->optUpdate = lpobj->optNew;
            if (lpobj->optUpdate == oleupdate_oncall)
                goto step3;

            AdvisePict (lpobj, NULL);
            WAIT_FOR_ASYNC_MSG (lpobj);

        case 2:
            SETSTEP (lpobj, 2);
            if (ProcessErr (lpobj))
                goto errRtn;
            
            if (lpobj->optUpdate == oleupdate_onsave)
                goto step3;

            RequestPict (lpobj);
            WAIT_FOR_ASYNC_MSG (lpobj);
            
        case 3:
            errRtn:
            step3:
            ProcessErr (lpobj);
            return EndAsyncCmd (lpobj);

        default:
            DEBUG_OUT ("Unexpected subroutine", 0);
            return OLE_ERROR_GENERIC;
    }
}



//AdvisePict: Sends advise for pict data

void    INTERNAL AdvisePict (lpobj, aAdvItem)
LPOBJECT_LE lpobj;
ATOM        aAdvItem;
{
    int         cftype;

    if (cftype = GetPictType (lpobj))
        AdviseOn (lpobj, cftype, aAdvItem);
}


//UnAdvisePict: Sends unadvise for pict data

void   INTERNAL UnAdvisePict (lpobj)
LPOBJECT_LE         lpobj;
{
    int         cftype;
    SETERRHINT (lpobj, OLE_ERROR_ADVISE_PICT);
    if (cftype = GetPictType (lpobj))
         UnAdviseOn (lpobj, cftype);
}

// GetPictType: Given the object, returns the pict type.

int     INTERNAL GetPictType (lpobj)
LPOBJECT_LE         lpobj;
{
    if (lpobj->lpobjPict)
        return (int)(*lpobj->lpobjPict->lpvtbl->EnumFormats)
                                (lpobj->lpobjPict, NULL);
    return NULL;
}


// AdviseOn : Sends advise for a given picture type
// Send advise only if the advise options is not on call.

void  INTERNAL AdviseOn (lpobj, cftype, advItem)
LPOBJECT_LE lpobj;
int         cftype;
ATOM        advItem;
{
    HANDLE          hopt   = NULL;
    DDEADVISE FAR   *lpopt = NULL;
    ATOM            item   = NULL;
    PEDIT_DDE       pedit;
    OLESTATUS       retval;

    if (cftype == (int)cfNative)
        SETERRHINT (lpobj, OLE_ERROR_ADVISE_NATIVE);
    else {
        if (cftype == (int)cfBinary)
            SETERRHINT (lpobj, OLE_ERROR_ADVISE_RENAME);
        else
            SETERRHINT (lpobj, OLE_ERROR_ADVISE_PICT);

    }
    
    if (lpobj->optUpdate == oleupdate_oncall)
        return;

    if(!(hopt = GlobalAlloc (GMEM_DDESHARE | GMEM_ZEROINIT, sizeof(DDEADVISE))))
        goto errRtn;

    retval = OLE_ERROR_MEMORY;
    if(!(lpopt = (DDEADVISE FAR *) GlobalLock (hopt)))
        goto errRtn;

    pedit = lpobj->pDocEdit;
    lpopt->fAckReq = TRUE;

    // get data always. Currently there is no way for the
    // deferred updates.

    lpopt->fDeferUpd = 0;
    lpopt->cfFormat = cftype;
    GlobalUnlock (hopt);

    pedit->hopt = hopt;
    
    if (advItem == aStdDocName)
        item = DuplicateAtom (advItem);
    else
        item = ExtendAtom (lpobj, lpobj->item);

    retval = OLE_ERROR_COMM;
    if (!PostMessageToServer(pedit, WM_DDE_ADVISE, MAKELONG (hopt, item)))
        goto errRtn;

#ifdef  FIREWALLS
    ASSERT (!pedit->bTerminating, "trying to post while termination")
    ASSERT (pedit->awaitAck == NULL, "Trying to Post msg while waiting for ack")
#endif
    pedit->awaitAck = AA_ADVISE;
    lpobj->bAsync    = TRUE;
    
    if (advItem == aClose)
       lpobj->pDocEdit->nAdviseClose++;
    else if (advItem == aSave)
       lpobj->pDocEdit->nAdviseSave++;     
   
    return;

errRtn:

    if (item)
        GlobalDeleteAtom (item);

    if (lpopt)
        GlobalUnlock (hopt);

    if (hopt)
        GlobalFree (hopt);
    lpobj->subErr = retval;

    return ;


}



//UnAdviseOn: Sends unadvise for an item.
void INTERNAL UnAdviseOn (lpobj, cftype)
LPOBJECT_LE lpobj;
int         cftype;
{
    ATOM        item;
    PEDIT_DDE   pedit;

    pedit  =  lpobj->pDocEdit;
    item    = ExtendAtom (lpobj, lpobj->item);

    if (!PostMessageToServer(pedit, WM_DDE_UNADVISE, MAKELONG (NULL, item)))
        lpobj->subErr = OLE_ERROR_COMM;
    else {
#ifdef  FIREWALLS
    ASSERT (!pedit->bTerminating, "trying to post while termination")
    ASSERT (pedit->awaitAck == NULL, "Trying to Post msg while waiting for ack")
#endif
        lpobj->bAsync    = TRUE;
        pedit->awaitAck = AA_UNADVISE;
    }
}

// RequestOn: Semd WM_DDE_REQUEST for the item of the
// for a given type;

void INTERNAL RequestOn (lpobj, cftype)
LPOBJECT_LE lpobj;
int         cftype;
{
    ATOM        item = NULL;
    PEDIT_DDE   pedit;
    OLESTATUS   retval = OLE_ERROR_COMM;

    if (cftype == (int)cfNative)
        SETERRHINT (lpobj, OLE_ERROR_REQUEST_NATIVE);
    else
        SETERRHINT (lpobj, OLE_ERROR_REQUEST_PICT);

    pedit = lpobj->pDocEdit;

    item = DuplicateAtom (lpobj->item);
    if (!PostMessageToServer (pedit, WM_DDE_REQUEST, MAKELONG (cftype, item)))
        goto errRtn;

#ifdef  FIREWALLS
    ASSERT (!pedit->bTerminating, "trying to post while termination")
    ASSERT (pedit->awaitAck == NULL, "Trying to Post msg while waiting for ack")
#endif

    lpobj->bAsync    = TRUE;
    pedit->awaitAck = AA_REQUEST;
    return;

errRtn:

    if (item)
        GlobalDeleteAtom (item);
    return ;

}


//RequestPict: Sends request for apicture type.
void INTERNAL RequestPict (lpobj)
LPOBJECT_LE         lpobj;
{
    int cftype;
    
    if (cftype = GetPictType (lpobj))
        RequestOn (lpobj, cftype);
}



// LeSetHostNames: Sets the host names. If the server is connected
// send the host names to the server.
OLESTATUS FARINTERNAL  LeSetHostNames (lpobj, lpclientName, lpdocName)
LPOBJECT_LE lpobj;
LPSTR       lpclientName;
LPSTR       lpdocName;
{
    OLESTATUS   retval = OLE_ERROR_MEMORY;

    if (lpobj->head.ctype != CT_EMBEDDED)
        return OLE_ERROR_OBJECT;

    PROBE_ASYNC (lpobj);
    if ((retval = SetHostNamesHandle (lpobj, lpclientName, lpdocName)) 
            != OLE_OK) 
        return retval;

    
    // If the server is connected poke the hostnames
    InitAsyncCmd (lpobj, OLE_OTHER, NULL);
    if ((retval = PokeHostNames (lpobj)) != OLE_WAIT_FOR_RELEASE)
        CLEARASYNCCMD(lpobj);

    return retval;
}



OLESTATUS   FARINTERNAL  LeSetTargetDevice (lpobj, hdata)
LPOBJECT_LE lpobj;
HANDLE      hdata;
{
    HANDLE      hdup = NULL;
    OLESTATUS   retval;

    PROBE_ASYNC (lpobj);
    
    if (!hdata) {
        // hdata == NULL means we should not make the target device sticky.
        // This will give the flexibility to the client app. Note that this
        // will not be effective till the next activation.
        if (lpobj->htargetDevice) {
            GlobalFree (lpobj->htargetDevice);
            lpobj->htargetDevice = NULL;
        }
        
        return OLE_OK;
    }
    
    if(!(hdup = DuplicateGlobal (hdata, GMEM_MOVEABLE)))
        return OLE_ERROR_MEMORY;

    if (lpobj->htargetDevice)
        GlobalFree (lpobj->htargetDevice);

    lpobj->htargetDevice = hdup;
    InitAsyncCmd (lpobj, OLE_OTHER, NULL);
    if ((retval = PokeTargetDeviceInfo (lpobj)) != OLE_WAIT_FOR_RELEASE)
        CLEARASYNCCMD(lpobj);
    
    return retval;
}



OLESTATUS FARINTERNAL  LeSetBounds(lpobj, lprcBounds)
LPOBJECT_LE        lpobj;
LPRECT             lprcBounds;
{
    OLESTATUS       retval = OLE_ERROR_MEMORY;
    HANDLE          hdata = NULL;
    LPBOUNDSRECT    lprc  = NULL;

    PROBE_ASYNC (lpobj);
    
    if (lpobj->head.ctype != CT_EMBEDDED)
        return OLE_ERROR_OBJECT;

    if(!(hdata = GlobalAlloc (GMEM_MOVEABLE, (WORD)sizeof (BOUNDSRECT))))
        return OLE_ERROR_MEMORY;

    if (!(lprc = (LPBOUNDSRECT)GlobalLock (hdata)))
        goto errrtn;

    // Now set the data

    lprc->defaultWidth    =  lprcBounds->right  - lprcBounds->left;;
    lprc->defaultHeight   =  -(lprcBounds->bottom - lprcBounds->top);
    lprc->maxWidth        =  lprcBounds->right  - lprcBounds->left;;
    lprc->maxHeight       =  -(lprcBounds->bottom - lprcBounds->top);

    GlobalUnlock (hdata);

    if (lpobj->hdocDimensions)
        GlobalFree (lpobj->hdocDimensions);

    lpobj->hdocDimensions = hdata;
    InitAsyncCmd (lpobj, OLE_OTHER, NULL);
    if ((retval = PokeDocDimensions (lpobj)) != OLE_WAIT_FOR_RELEASE)
        CLEARASYNCCMD(lpobj);

    return retval;
    
errrtn:
    if (lprc)
        GlobalUnlock (hdata);
    if (hdata)
        GlobalFree (hdata);
    
    return retval;
}


OLESTATUS FARINTERNAL LeSetData (lpobj, cfFormat, hData)
LPOBJECT_LE     lpobj;
OLECLIPFORMAT   cfFormat;
HANDLE          hData;
{
    OLESTATUS   retVal = OLE_OK;
    BOOL        fKnown = FALSE;
        
    PROBE_ASYNC (lpobj);
    
    if ((cfFormat == cfObjectLink) || (cfFormat == cfOwnerLink))
        return ChangeDocAndItem (lpobj, hData);
    
    if (fKnown = (cfFormat && (cfFormat == ((WORD) GetPictType (lpobj))))) {
        retVal =  (*lpobj->lpobjPict->lpvtbl->ChangeData) (lpobj->lpobjPict,
                                    hData, lpobj->head.lpclient, FALSE);
                                
        (*lpobj->lpobjPict->lpvtbl->GetData) (lpobj->lpobjPict, 
                                cfFormat, &hData);                      
    }
    else if (fKnown = (cfFormat == cfNative)) {
        retVal = LeChangeData (lpobj, hData, lpobj->head.lpclient, FALSE);
        hData = lpobj->hnative;
    }
    
    if (retVal != OLE_OK)
        return retVal;
    
    if (fKnown) 
        ContextCallBack (lpobj, OLE_CHANGED);
    
    if (!QueryOpen (lpobj) || IS_SVRCLOSING(lpobj)) {
        if (!fKnown)
            return OLE_ERROR_NOT_OPEN;
        return OLE_OK;
    }

    // except for the following formats all the other data will be copied
    // into DDEPOKE block. So there is no need to duplicate the data of the
    // other formats
    if ((cfFormat == CF_METAFILEPICT) || (cfFormat == CF_BITMAP)
            || (cfFormat == CF_DIB)) {
            
        if (!(hData = DuplicateGDIdata (hData, cfFormat)))
            return OLE_ERROR_MEMORY;
    }
    
    // *** The last parameter must be NULL, don't change it ***
    InitAsyncCmd (lpobj, OLE_SETDATA, NULL);
    if ((retVal = SendPokeData (lpobj, lpobj->item, hData, cfFormat))
            != OLE_WAIT_FOR_RELEASE)
        CLEARASYNCCMD(lpobj);
    
    return retVal;
}



OLESTATUS   FARINTERNAL  LeSetColorScheme (lpobj, lplogpal)
LPOBJECT_LE     lpobj;
LPLOGPALETTE    lplogpal;
{
    HANDLE      hdup = NULL;
    DWORD       cblogpal;
    OLESTATUS   retval;
    LPBYTE      lptemp;
    
    lptemp = (LPBYTE) lplogpal;
    
    if (lpobj->head.ctype != CT_EMBEDDED)
        return OLE_ERROR_OBJECT;

    PROBE_ASYNC (lpobj);
    
    if (!lplogpal) {
        // lplogpal == NULL means we should not make color scheme sticky.
        // This will give the flexibility to the client app. Note that this
        // will not be effective till next activation.
        if (lpobj->hlogpal) {
            GlobalFree (lpobj->hlogpal);
            lpobj->hlogpal = NULL;
        }
        
        return OLE_OK;
    }
    
    
    FARPROBE_READ(lptemp + (cblogpal = 2*sizeof(WORD)));
    cblogpal += ((sizeof(PALETTEENTRY) * lplogpal->palNumEntries) -1);
    if (!FarCheckPointer (lptemp + cblogpal, READ_ACCESS))
        return OLE_ERROR_PALETTE;

    if (!(hdup = CopyData ((LPSTR) lplogpal, cblogpal)))
        return OLE_ERROR_MEMORY;    
    
    if (lpobj->hlogpal)
        GlobalFree (lpobj->hlogpal);

    lpobj->hlogpal = hdup;
    InitAsyncCmd (lpobj, OLE_OTHER, NULL);
    if ((retval = PokeColorScheme (lpobj)) != OLE_WAIT_FOR_RELEASE)
        CLEARASYNCCMD(lpobj);

    return retval;
}



//PokeHostNames: Pokes hostname data to the server
OLESTATUS INTERNAL PokeHostNames (lpobj)
LPOBJECT_LE lpobj;
{
    OLESTATUS   retVal = OLE_ERROR_MEMORY;

    // if the server is connectd then poke the host names
    if (!QueryOpen (lpobj) || IS_SVRCLOSING(lpobj))
        return OLE_OK;

    if (!lpobj->hhostNames) 
        return OLE_OK;
    
    aStdHostNames = GlobalAddAtom ("StdHostNames");
    return SendPokeData (lpobj,aStdHostNames,lpobj->hhostNames,cfBinary);
}


OLESTATUS INTERNAL  PokeTargetDeviceInfo (lpobj)
LPOBJECT_LE lpobj;
{

   // if the server is connectd then poke the host names
   if (!QueryOpen (lpobj) || IS_SVRCLOSING(lpobj))
        return OLE_OK;

   if (!lpobj->htargetDevice)
        return OLE_OK;

   aStdTargetDevice = GlobalAddAtom ("StdTargetDevice");
   return SendPokeData (lpobj, aStdTargetDevice,
                    lpobj->htargetDevice,
                    cfBinary);
}


OLESTATUS INTERNAL  PokeDocDimensions (lpobj)
LPOBJECT_LE lpobj;
{

   // if the server is connectd then poke the host names
   if (!QueryOpen (lpobj) || IS_SVRCLOSING(lpobj))
        return OLE_OK;

   if (!lpobj->hdocDimensions)
        return OLE_OK;

   aStdDocDimensions = GlobalAddAtom ("StdDocDimensions");
   return SendPokeData (lpobj, aStdDocDimensions,
                    lpobj->hdocDimensions,
                    cfBinary);
}


OLESTATUS INTERNAL  PokeColorScheme (lpobj)
LPOBJECT_LE lpobj;
{
   // if the server is connected then poke the palette info
   if (!QueryOpen (lpobj) || IS_SVRCLOSING(lpobj))
        return OLE_OK;

   if (!lpobj->hlogpal)
        return OLE_OK;

   aStdColorScheme = GlobalAddAtom ("StdColorScheme"); 
   return SendPokeData (lpobj, aStdColorScheme,
                    lpobj->hlogpal,
                    cfBinary);
}


OLESTATUS INTERNAL SendPokeData (lpobj, aItem, hdata, cfFormat)
LPOBJECT_LE     lpobj;
ATOM            aItem;
HANDLE          hdata;
OLECLIPFORMAT   cfFormat;
{
    HANDLE      hdde = NULL;
    DDEPOKE FAR * lpdde = NULL;
    LPSTR       lpdst = NULL;
    LPSTR       lpsrc = NULL;
    OLESTATUS   retval = OLE_ERROR_MEMORY;
    DWORD       dwSize = NULL;
    PEDIT_DDE   pedit;
    BOOL        bGDIdata = FALSE;

    pedit = lpobj->pDocEdit;

    // If it is GDI data then we can stuff the handle into POKE block. 
    // Otherwise we have to copy the data into DDE data block. There
    // is a special case with old MSDraw, that will be handled by
    // the routine CanPutHandleInPokeBlock()
        
    if (!(bGDIdata = CanPutHandleInPokeBlock (lpobj, cfFormat))) {
        if (!(dwSize = GlobalSize (hdata)))
            return OLE_ERROR_MEMORY;
                
        if (!(lpsrc = (LPSTR) GlobalLock (hdata))) 
            return OLE_ERROR_MEMORY;
        
        GlobalUnlock (hdata);
    }
    
    // Now allocate the DDE data block

    if (!(hdde = GlobalAlloc (GMEM_DDESHARE | GMEM_ZEROINIT, 
                 (dwSize + sizeof(DDEPOKE) - sizeof(BYTE) + sizeof(HANDLE)))))
        goto errRtn;

    if (!(lpdde = (DDEPOKE FAR *)GlobalLock (hdde)))
        goto errRtn;

    GlobalUnlock (hdde);

    // !!! We may want to set it TRUE, for performance reasons. But it 
    // will require some rework on the server side
    lpdde->fRelease = 0;
    lpdde->cfFormat = cfFormat;

    if (bGDIdata) 
        *(LPHANDLE)lpdde->Value = hdata;
    else {
        lpdst = (LPSTR)lpdde->Value;
        UtilMemCpy (lpdst, lpsrc, dwSize);
        
        // For the CF_METAFILEPICT format, we would come here only if we are
        // dealing with the old version of MSDraw. In that case we want to
        // free the handle to METAFILEPICT strcuture, because we've already
        // copied its contents to DDEPOKE structure.
            
        // Note that that the old MSDraw expects the contents of METAFILEPICT
        // structure to be part of DDEPOKE, rather than the handle to it.

        if (cfFormat == CF_METAFILEPICT) {
            GlobalFree (hdata);
            hdata = NULL;
        }
    }

    // *** From here onwards if there is an error call FreePokeData(), don't
    // jump to errRtn
        
    aItem = DuplicateAtom (aItem);

    ASSERT(pedit->hData == NULL, "Poke data is not null");

    pedit->hData = hdde;
    if (!PostMessageToServer (pedit, WM_DDE_POKE, MAKELONG (hdde, aItem))) {
        if (aItem)
            GlobalDeleteAtom (aItem);
        FreePokeData (lpobj, pedit);
        return (lpobj->subErr = OLE_ERROR_COMM);
    }

#ifdef  FIREWALLS
    ASSERT (!pedit->bTerminating, "trying to post while termination")
    ASSERT (pedit->awaitAck == NULL, "Trying to Post msg while waiting for ack")
#endif
    if (lpobj->asyncCmd == OLE_NONE)
        lpobj->asyncCmd = OLE_OTHER;

    lpobj->bAsync    = TRUE;
    pedit->awaitAck = AA_POKE;
    // !!! after poke of the hostnames etc. we are not processing error.,

    // Data is freed after the Poke is acknowledged. OLE_RELEASE will be sent
    // to when ACK comes.
        
    return OLE_WAIT_FOR_RELEASE;

errRtn:
    if (hdata)
        FreeGDIdata (hdata, cfFormat);
    
    if (hdde)
        GlobalFree (hdde);

    pedit->hData = NULL;

    return (lpobj->subErr = retval);
}



// FreePokeData: Frees the poked data.
void  INTERNAL FreePokeData (lpobj, pedit)
LPOBJECT_LE lpobj;
PEDIT_DDE   pedit;
{
    DDEPOKE FAR * lpdde;
    
#ifdef  FIREWALLS
    ASSERT (pedit->hData, "Poke data handle is null");

#endif
    
    if (lpdde = (DDEPOKE FAR *) GlobalLock (pedit->hData)) {
        GlobalUnlock (pedit->hData);
        
        // The old version of MSDraw expects the contents of METAFILEPICT
        // structure to be part of DDEPOKE, rather than the handle to it.

        if (!lpobj->bOleServer && (lpobj->app == aMSDraw)
                && (lpdde->cfFormat == CF_METAFILEPICT)) {
            DeleteMetaFile (((LPMETAFILEPICT) ((LPSTR) &lpdde->Value))->hMF);
        }
        else { 
            FreeGDIdata (*(LPHANDLE)lpdde->Value, lpdde->cfFormat);
        }
    }
        
    GlobalFree (pedit->hData);
    pedit->hData = NULL;
}



BOOL INTERNAL  SendSrvrMainCmd (lpobj, lptemplate)
LPOBJECT_LE lpobj;
LPSTR       lptemplate;
{
    WORD        size;
    WORD        len;
    OLESTATUS   retval;
    int         cmd;
    HANDLE      hInst = NULL;
    LPSTR       lpdata= NULL;
    HANDLE      hdata = NULL;
    BOOL        bLaunch = TRUE;

    Puts("Launch App and Send Sys command");

#ifdef  FIREWALLS
    ASSERT (lpobj->aServer, "Serevr is NULL");
#endif

    if (!lpobj->aServer) {
        retval = OLE_ERROR_REGISTRATION;
        goto errRtn;
    }
    
    if (!lpobj->bOldLink) {
        bLaunch = !(lpobj->fCmd & ACT_NOLAUNCH);
        cmd = lpobj->fCmd & LN_MASK;
    }
    
    if (cmd == LN_LNKACT) {
        // take care of network based document        
        char    cDrive = lpobj->cDrive;
    
        if ((retval = CheckNetDrive (lpobj, POPUP_NETDLG)) != OLE_OK) {
            lpobj->cDrive = cDrive;
            goto errRtn;
        }
        
        if (cDrive != lpobj->cDrive)
            ContextCallBack (lpobj, OLE_RENAMED);
    }
    
    if (!InitSrvrConv (lpobj, hInst)) {

        if (!bLaunch)
            goto errRtn;
        
        if (!(hInst = LeLaunchApp (lpobj))) {
            // We failed to launch the app. If it is a linked object, see
            // whether the docname is valid for new servers.  We wouldn't
            // have given the doc name on the command line for the old
            // servers. So, there is no point in checking for file existance
            // in that case.
            if (lpobj->bOleServer && (lpobj->bOldLink || (cmd == LN_LNKACT))){
                if ((retval = FileExists (lpobj)) != OLE_OK)
                    goto errRtn;
            }
            
            retval = OLE_ERROR_LAUNCH;
            goto errRtn;
        }
        
        if (lpobj->bOldLink)
            return TRUE;

        if (lpobj->bOleServer && (cmd == LN_LNKACT)) {
            // We are not using any data blocks if the object is old link.
            // we launched with docname, and don't have to establish system
            // level and also we don't have to send exec strings.

            // for non-ole servers like excel, we do want to connect at
            // the system level, so that we can send "StdOpen". We also 
            // have to send "StdExit" for the server to exit in the
            // invisible launch case.

            return TRUE;
        }

        retval = OLE_ERROR_COMM;
        if(!InitSrvrConv (lpobj, hInst))
            goto errRtn;
#ifdef OLD
        if (!lpobj->bOleServer && (cmd == LN_LNKACT))
            return TRUE;
#endif
    }

    if (!lpobj->bOldLink) {
        cmd = lpobj->fCmd & LN_MASK;
        len =  lstrlen (srvrSysCmd[cmd >> LN_SHIFT]);

        // for template and new, add the class name also
        if (cmd == LN_NEW || cmd == LN_TEMPLATE)
            len += GlobalGetAtomLen (lpobj->app);

        // Now add the document length.
        len += GlobalGetAtomLen (lpobj->topic);

        // add the length of the template name
        if (lptemplate)
            len += lstrlen (lptemplate);

        // now add the fudge factor for the Quotes etc.
        len += LN_FUDGE;

        // allocate the buffer and set the command.
        hdata = GlobalAlloc (GMEM_DDESHARE, size = len);

        retval = OLE_ERROR_MEMORY;
        SETERRHINT(lpobj, OLE_ERROR_MEMORY);

        if (hdata == NULL || (lpdata = (LPSTR)GlobalLock (hdata)) == NULL)
            goto errRtn;
    }
    
    lstrcpy (lpdata, (LPSTR)"[");           // [
    lstrcat (lpdata, srvrSysCmd[cmd >> LN_SHIFT]);      // [Std....
    lstrcat (lpdata, "(\"");                // [std...("

    if (cmd == LN_NEW  || cmd == LN_TEMPLATE) {
        len = lstrlen (lpdata);
        GlobalGetAtomName (lpobj->app, (LPSTR)lpdata + len, size - len);
                                            // [std...("class
        lstrcat (lpdata, "\",\"");          // [std...("class", "
    }
    len = lstrlen (lpdata);
    // now get the topic name.
    GlobalGetAtomName (lpobj->topic, lpdata + len, (WORD)size - len);
                                            // [std...("class","doc
    if (lptemplate) {
        lstrcat (lpdata, "\",\"");          // [std...("class","doc","
        lstrcat  (lpdata, lptemplate);      // [std...("class","doc","temp
    }

    lstrcat (lpdata, "\")]");               // [std...("class","doc","temp")]

    GlobalUnlock (hdata);

    // !!!optimize with mapping.
    SETERRHINT(lpobj, (OLE_ERROR_TEMPLATE + (cmd >> LN_SHIFT)));

    return SrvrExecute (lpobj, hdata);

errRtn:
    if (lpdata)
        GlobalUnlock (hdata);

    if (hdata)
        GlobalFree (hdata);
    lpobj->subErr = retval;
    return FALSE;
}




// ExtendAtom: Create a new atom, which is the old one plus extension

ATOM INTERNAL ExtendAtom (lpobj, item)
LPOBJECT_LE lpobj;
ATOM    item;
{
    char    buffer[MAX_ATOM+1];
    LPSTR   lpext;

    Puts("ExtendAtom");

    buffer[0] = 0;
    if (item)
        GlobalGetAtomName (item, buffer, MAX_ATOM);

    switch (lpobj->optUpdate) {


        case oleupdate_always:
            lpext = (LPSTR)"";
            break;

        case oleupdate_onsave:
            lpext = (LPSTR)"/Save";
            break;

        case oleupdate_onclose:
            lpext = (LPSTR)"/Close";
            break;

        default:
            ASSERT (FALSE, "on call options not expected here");
            break;

    }
    
    lstrcat (buffer, lpext);
    if (buffer[0])
        return GlobalAddAtom (buffer);
    else
        return NULL;
}


BOOL INTERNAL CreatePictObject (lhclientdoc, lpobjname, lpobj, optRender, cfFormat, lpclass)
LHCLIENTDOC     lhclientdoc;
LPSTR           lpobjname;
LPOBJECT_LE     lpobj;
OLEOPT_RENDER   optRender;
OLECLIPFORMAT   cfFormat;
LPSTR           lpclass;
{
    LPOLEOBJECT lpPictObj = NULL;
    ATOM        aClass;
    
    lpobj->lpobjPict = NULL;
    if (optRender == olerender_format) {
        switch (cfFormat) {
            case NULL:
                return FALSE;
                
            case CF_METAFILEPICT:
                if (!(lpPictObj = (LPOLEOBJECT) MfCreateBlank (lhclientdoc, 
                                            lpobjname, CT_PICTURE))) 
                    return FALSE;
                break;

            case CF_DIB:
                if (!(lpPictObj = (LPOLEOBJECT) DibCreateBlank (lhclientdoc, 
                                            lpobjname, CT_PICTURE)))
                    return FALSE;
                break;
            
            case CF_BITMAP:
                if (!(lpPictObj = (LPOLEOBJECT) BmCreateBlank (lhclientdoc, 
                                            lpobjname, CT_PICTURE))) 
                    return FALSE;
                break;
                
            default:
                aClass = GlobalAddAtom (lpclass);
                if (!(lpPictObj = (LPOLEOBJECT) GenCreateBlank (lhclientdoc, 
                                            lpobjname, CT_PICTURE, aClass)))
                    return FALSE;

                ((LPOBJECT_GEN)lpPictObj)->cfFormat = cfFormat;
                break;
        }
    }
    else if (optRender == olerender_draw) {
          if (!(lpPictObj = (LPOLEOBJECT) MfCreateBlank (lhclientdoc, 
                                                lpobjname, CT_PICTURE))) 
                return FALSE;
#ifdef LATER
        if (AdviseOn (lpobj, (cfFormat = CF_METAFILEPICT), NULL))
            lpPictObj = (LPOLEOBJECT) MfCreateBlank (lhclientdoc, 
                                                lpobjname, CT_PICTURE);
        // !!! for the time being take assume we need to get metafile.
        else if (AdviseOn (lpobj, (cfFormat = CF_DIB), NULL))
            lpPictObj = (LPOLEOBJECT) DibCreateBlank (lhclientdoc, 
                                                lpobjname, CT_PICTURE);
        else if (AdviseOn (lpobj, (cfFormat = CF_BITMAP), NULL))
            lpPictObj = (LPOLEOBJECT) BmCreateBlank (lhclientdoc, 
                                                lpobjname, CT_PICTURE);
        else 
            goto errPict;
#endif
        
    }
    else
        return (optRender == olerender_none);

    if (lpobj->lpobjPict = lpPictObj)
        lpobj->lpobjPict->lpParent = (LPOLEOBJECT) lpobj;
    return TRUE;
}


OLESTATUS LnkChangeLnk (lpobj)
LPOBJECT_LE lpobj;
{

    switch (lpobj->subRtn) {

        case 0:
            TermDocConv (lpobj);
            WAIT_FOR_ASYNC_MSG (lpobj);

        case 1:

            // delete the edit block
            DeleteDocEdit (lpobj);
            TermSrvrConv (lpobj);
            WAIT_FOR_ASYNC_MSG (lpobj);

        case    2:

            // Do not set any errors, just delete the object.
            // delete the server edit block
            DeleteSrvrEdit (lpobj);

            // now try to activate the new link.
            SKIP_TO (!InitDocConv (lpobj, !POPUP_NETDLG), step3);
            lpobj->fCmd = LN_LNKACT | ACT_ADVISE | ACT_REQUEST;
            InitAsyncCmd (lpobj, OLE_SETDATA, LNKOPENUPDATE);
            return LnkOpenUpdate (lpobj);

        case    3:
            step3:
            return EndAsyncCmd (lpobj);

        default:
            DEBUG_OUT ("Unexpected subroutine", 0);
            return OLE_ERROR_GENERIC;
    }
}


OLESTATUS INTERNAL ChangeDocAndItem (lpobj, hinfo)
LPOBJECT_LE lpobj;
HANDLE      hinfo;
{
    LPSTR       lpinfo;
    ATOM        aNewTopic, aNewItem = NULL, aOldTopic;
    OLESTATUS   retVal = OLE_ERROR_BLANK;

    PROBE_SVRCLOSING(lpobj);
    
    if (!(lpinfo = GlobalLock (hinfo)))
        return OLE_ERROR_MEMORY;
    
    lpinfo += lstrlen (lpinfo) + 1;
    aNewTopic = GlobalAddAtom (lpinfo);
    lpinfo += lstrlen (lpinfo) + 1;
    if (*lpinfo)
        aNewItem = GlobalAddAtom (lpinfo);

    if (!aNewTopic && (lpobj->head.ctype == CT_LINK)) 
        goto errRtn;

    aOldTopic = lpobj->topic;
    lpobj->topic = aNewTopic;
    if ((retVal = SetNetName (lpobj)) != OLE_OK) {
        if (lpobj->topic)
            GlobalDeleteAtom (lpobj->topic);
        lpobj->topic = aOldTopic;
        goto errRtn;
    }

    if (aOldTopic)
        GlobalDeleteAtom (aOldTopic);
    
    if (lpobj->item)
        GlobalDeleteAtom (lpobj->item); 
    
    lpobj->item = aNewItem;
    
    // As the atoms have already changed, lpobj->hLink becomes irrelevant. 
    if (lpobj->hLink) {             
        GlobalFree (lpobj->hLink);
        lpobj->hLink = NULL;
    }
    
    GlobalUnlock(hinfo);
    
    // Now disconnect the old link and try to connect to the new one.
    lpobj->fCmd = 0;
    InitAsyncCmd (lpobj, OLE_SETDATA, LNKCHANGELNK);
    return LnkChangeLnk (lpobj);

errRtn:

    if (aNewItem)
        GlobalDeleteAtom (aNewItem);
    
    GlobalUnlock (hinfo);        
    return retVal;
}


BOOL    QueryUnlaunch (lpobj)
LPOBJECT_LE lpobj;
{
    if (!(lpobj->fCmd & ACT_UNLAUNCH))
        return FALSE;
    
    // only if we loaded the app
    if (lpobj->pSysEdit && lpobj->pSysEdit->hClient && lpobj->pSysEdit->hInst)
        return TRUE;
    
    return FALSE;
}


BOOL     QueryClose (lpobj)
LPOBJECT_LE lpobj;
{
    if (!((lpobj->fCmd & ACT_UNLAUNCH) ||
            (lpobj->head.ctype == CT_EMBEDDED)))
        return FALSE;

    // only if we loaded the documnet
    if (lpobj->pSysEdit && lpobj->pSysEdit->hClient)
        return TRUE;
    
    return FALSE;
}


OLESTATUS INTERNAL SetHostNamesHandle (lpobj, lpclientName, lpdocName)
LPOBJECT_LE lpobj;
LPSTR       lpclientName;
LPSTR       lpdocName;
{
    WORD        cbClient;
    WORD        size;
    HANDLE      hhostNames      = NULL;
    LPHOSTNAMES lphostNames     = NULL;
    LPSTR       lpdata;
  
    // 4 bytes  is for the two offsets
    size = (cbClient = lstrlen(lpclientName)+1) + (lstrlen(lpdocName)+1) + 4;

    if ((hhostNames = GlobalAlloc (GMEM_MOVEABLE, (DWORD) size))
            == NULL)
        goto errRtn;

    if ((lphostNames = (LPHOSTNAMES)GlobalLock (hhostNames)) == NULL)
        goto errRtn;

    lphostNames->clientNameOffset = 0;
    lphostNames->documentNameOffset = cbClient;

    lpdata = (LPSTR)lphostNames->data;
    lstrcpy (lpdata, lpclientName);
    lstrcpy (lpdata + cbClient, lpdocName);
    if (lpobj->hhostNames)
        GlobalFree ( lpobj->hhostNames);
    GlobalUnlock (hhostNames);
    lpobj->hhostNames = hhostNames;
    return OLE_OK;

errRtn:
    if (lphostNames)
        GlobalUnlock (hhostNames);

    if (hhostNames)
        GlobalFree (hhostNames);

    return  OLE_ERROR_MEMORY;
}


#if 0
OLESTATUS  FARINTERNAL LeAbort (lpobj)
LPOBJECT_LE lpobj;
{


    BOOL        bAbort = FALSE;
    PEDIT_DDE   pedit;


    // check whether the any transaction pending for
    // the document level.

    //  channel open
    //  any transaction pending.
    //  and we are not in terminate mode.


    if ((pedit = lpobj->pDocEdit)  &&   pedit->hServer &&
        pedit->awaitAck && !pedit->bTerminating) {
        pedit->bAbort = bAbort = TRUE;
        // delete any data we need to delete. Ricght now
        // we kill only the timer. We can not delete any
        // since the server could potentially look at the data.

        DeleteAbortData (lpobj, pedit);
    }

    if ((pedit = lpobj->pSysEdit)  &&   pedit->hServer &&
        pedit->awaitAck && !pedit->bTerminating) {
        pedit->bAbort = bAbort = TRUE;
        DeleteAbortData (lpobj, pedit);

    }

    if (!bAbort)
        return OLE_OK;

    // Now send the EndAsync
    lpobj->mainErr = OLE_ERROR_ABORT;
    EndAsyncCmd (lpobj);
    return OLE_OK;

}
#endif


OLESTATUS  FARINTERNAL ProbeAsync(lpobj)
LPOBJECT_LE lpobj;
{

    if (lpobj->asyncCmd == OLE_NONE)
        return OLE_OK;

    if (!IsServerValid (lpobj)) {

        // Now send the EndAsync
        lpobj->mainErr = OLE_ERROR_TASK;
        EndAsyncCmd (lpobj);
        return OLE_OK;
    }

    return OLE_BUSY;
}


BOOL    INTERNAL IsWindowValid (hwnd)
HWND    hwnd;
{

#define TASK_OFFSET 0x00FA

    LPSTR   lptask;
    HANDLE  htask;

    if (!IsWindow (hwnd))
        return FALSE;

    if (bWLO)
        return TRUE;
    
    // now get the task handle and find out it is valid.
    htask  = GetWindowTask (hwnd);

    if ((wWinVer == 0x0003) || !lpfnIsTask) {
        lptask = (LPSTR)(MAKELONG (TASK_OFFSET, htask));

        if (!FarCheckPointer(lptask, READ_ACCESS))
            return FALSE;

        // now check for the signature bytes of task block in kernel
        if (*lptask++ == 'T' && *lptask == 'D')
            return TRUE;
    }
    else {
        // From win31 onwards the API IsTask can be used for task validation
        if ((*lpfnIsTask)(htask))
            return TRUE;
    }

    return FALSE;
}



BOOL    INTERNAL IsServerValid (lpobj)
LPOBJECT_LE     lpobj;
{

    MSG msg;
    BOOL    retval = FALSE;


    if (lpobj->pDocEdit && lpobj->pDocEdit->hServer) {

        retval = TRUE;

        if (!IsWindowValid (lpobj->pDocEdit->hServer)) {
            if (!PeekMessage ((LPMSG)&msg, lpobj->pDocEdit->hClient, WM_DDE_TERMINATE, WM_DDE_TERMINATE,
                            PM_NOREMOVE | PM_NOYIELD)){
#ifdef  FIREWALLS
                ASSERT (FALSE, "Server truely died");
#endif
                return FALSE;
            }

        }

    }

    if (lpobj->pSysEdit && lpobj->pSysEdit->hServer) {
        retval = TRUE;

        if (!IsWindowValid (lpobj->pSysEdit->hServer)) {

            if (!PeekMessage ((LPMSG)&msg, lpobj->pSysEdit->hClient, WM_DDE_TERMINATE, WM_DDE_TERMINATE,
                                PM_NOREMOVE | PM_NOYIELD)){
#ifdef  FIREWALLS
                ASSERT (FALSE, "Server truely died");
#endif
                return FALSE;

            }


        }
    }

   return retval;
}


OLESTATUS FARINTERNAL LeExecute (lpobj, hCmds, wReserve)
LPOBJECT_LE lpobj;
HANDLE      hCmds;
WORD        wReserve;
{
    // Assumes all the creates are in order
    PROBE_CREATE_ASYNC(lpobj);
    PROBE_SVRCLOSING(lpobj);
    
    if (!(lpobj =  (*lpobj->head.lpvtbl->QueryProtocol) (lpobj, 
                                            PROTOCOL_EXECUTE)))
        return OLE_ERROR_PROTOCOL;

    if (!QueryOpen (lpobj))
        return OLE_ERROR_NOT_OPEN;
    
    if (!(hCmds = DuplicateGlobal (hCmds, GMEM_MOVEABLE|GMEM_DDESHARE)))
        return OLE_ERROR_MEMORY;
        
    InitAsyncCmd (lpobj, OLE_OTHER, NULL);
    SETERRHINT(lpobj, OLE_ERROR_COMMAND);
    if (DocExecute(lpobj, hCmds))
        return OLE_WAIT_FOR_RELEASE;
    else
        return OLE_ERROR_COMMAND;
}


void INTERNAL FreeGDIdata (hData, cfFormat)
HANDLE          hData;
OLECLIPFORMAT   cfFormat;
{
    if (cfFormat == CF_METAFILEPICT) {
        LPMETAFILEPICT  lpMfp;
        
        if (lpMfp = (LPMETAFILEPICT) GlobalLock (hData)) {
            GlobalUnlock (hData);
            DeleteMetaFile (lpMfp->hMF);
        }

        GlobalFree (hData);
    }
    
    else if (cfFormat == CF_BITMAP) 
        DeleteObject (hData);
    
    else if (cfFormat == CF_DIB)
        GlobalFree (hData);
}


// This routine figures out whether the handle to data block can be copied
// to DDEPOKE block rather than the contents of the handle

BOOL INTERNAL CanPutHandleInPokeBlock (lpobj, cfFormat)
LPOBJECT_LE     lpobj;
OLECLIPFORMAT   cfFormat;
{
    if (cfFormat == CF_BITMAP || cfFormat == CF_DIB)
        return TRUE;

    if (cfFormat == CF_METAFILEPICT) {
        // The old version of MSDraw expects the contents of METAFILEPICT
        // structure to be part of DDEPOKE, rather than the handle to it.

        if (!lpobj->bOleServer && lpobj->app == aMSDraw)
            return FALSE;
        
        return TRUE;
    }
    
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\ole\client\ole.h ===
/*****************************************************************************\
*                                                                             *
* ole.h -       Object Linking and Embedding functions, types, and definitions*
*                                                                             *
*               Version 1.0                                                   *
*                                                                             *
*               NOTE: windows.h must be #included first                       *
*                                                                             *
*               Copyright (c) 1990-1992, Microsoft Corp.  All rights reserved.*
*                                                                             *
\*****************************************************************************/

#ifndef _INC_OLE
#define _INC_OLE

#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif /* !RC_INVOKED */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */

#ifndef WINAPI          /* If not included with 3.1 headers... */
#define WINAPI      FAR PASCAL
#define CALLBACK    FAR PASCAL
#define LPCSTR      LPSTR
#define UINT        WORD
#define LPARAM      LONG
#define WPARAM      WORD
#define LRESULT     LONG
#define HMODULE     HANDLE
#define HINSTANCE   HANDLE
#define HLOCAL      HANDLE
#define HGLOBAL     HANDLE
#endif  /* _INC_WINDOWS */

#ifdef STRICT
#define OLE_LPCSTR  LPCSTR
#define OLE_CONST   const
#else   /* STRICT */
#define OLE_LPCSTR  LPSTR
#define OLE_CONST
#endif /* !STRICT */


/* Object types */
#define OT_LINK             1L
#define OT_EMBEDDED         2L
#define OT_STATIC           3L

/* activate verbs */
#define OLEVERB_PRIMARY     0

/* target device info structure */
typedef struct _OLETARGETDEVICE
{
    UINT otdDeviceNameOffset;
    UINT otdDriverNameOffset;
    UINT otdPortNameOffset;
    UINT otdExtDevmodeOffset;
    UINT otdExtDevmodeSize;
    UINT otdEnvironmentOffset;
    UINT otdEnvironmentSize;
    BYTE otdData[1];
} OLETARGETDEVICE;
typedef OLETARGETDEVICE FAR* LPOLETARGETDEVICE;

/* flags used in some methods */
#define OF_SET              0x0001
#define OF_GET              0x0002
#define OF_HANDLER          0x0004

/* return codes for OLE functions */
typedef enum
{
    OLE_OK,                     /* 0   Function operated correctly             */

    OLE_WAIT_FOR_RELEASE,       /* 1   Command has been initiated, client      */
                                /*     must wait for release. keep dispatching */
                                /*     messages till OLE_RELESE in callback    */

    OLE_BUSY,                   /* 2   Tried to execute a method while another */
                                /*     method is in progress.                  */

    OLE_ERROR_PROTECT_ONLY,     /* 3   Ole APIs are called in real mode        */
    OLE_ERROR_MEMORY,           /* 4   Could not alloc or lock memory          */
    OLE_ERROR_STREAM,           /* 5  (OLESTREAM) stream error                 */
    OLE_ERROR_STATIC,           /* 6   Non static object expected              */
    OLE_ERROR_BLANK,            /* 7   Critical data missing                   */
    OLE_ERROR_DRAW,             /* 8   Error while drawing                     */
    OLE_ERROR_METAFILE,         /* 9   Invalid metafile                        */
    OLE_ERROR_ABORT,            /* 10  Client chose to abort metafile drawing  */
    OLE_ERROR_CLIPBOARD,        /* 11  Failed to get/set clipboard data        */
    OLE_ERROR_FORMAT,           /* 12  Requested format is not available       */
    OLE_ERROR_OBJECT,           /* 13  Not a valid object                      */
    OLE_ERROR_OPTION,           /* 14  Invalid option(link update / render)    */
    OLE_ERROR_PROTOCOL,         /* 15  Invalid protocol                        */
    OLE_ERROR_ADDRESS,          /* 16  One of the pointers is invalid          */
    OLE_ERROR_NOT_EQUAL,        /* 17  Objects are not equal                   */
    OLE_ERROR_HANDLE,           /* 18  Invalid handle encountered              */
    OLE_ERROR_GENERIC,          /* 19  Some general error                      */
    OLE_ERROR_CLASS,            /* 20  Invalid class                           */
    OLE_ERROR_SYNTAX,           /* 21  Command syntax is invalid               */
    OLE_ERROR_DATATYPE,         /* 22  Data format is not supported            */
    OLE_ERROR_PALETTE,          /* 23  Invalid color palette                   */
    OLE_ERROR_NOT_LINK,         /* 24  Not a linked object                     */
    OLE_ERROR_NOT_EMPTY,        /* 25  Client doc contains objects.            */
    OLE_ERROR_SIZE,             /* 26  Incorrect buffer size passed to the api */
                                /*     that places some string in caller's     */
                                /*     buffer                                  */

    OLE_ERROR_DRIVE,            /* 27  Drive letter in doc name is invalid     */
    OLE_ERROR_NETWORK,          /* 28  Failed to establish connection to a     */
                                /*     network share on which the document     */
                                /*     is located                              */

    OLE_ERROR_NAME,             /* 29  Invalid name(doc name, object name),    */
                                /*     etc.. passed to the APIs                */

    OLE_ERROR_TEMPLATE,         /* 30  Server failed to load template          */
    OLE_ERROR_NEW,              /* 31  Server failed to create new doc         */
    OLE_ERROR_EDIT,             /* 32  Server failed to create embedded        */
                                /*     instance                                */
    OLE_ERROR_OPEN,             /* 33  Server failed to open document,         */
                                /*     possible invalid link                   */

    OLE_ERROR_NOT_OPEN,         /* 34  Object is not open for editing          */
    OLE_ERROR_LAUNCH,           /* 35  Failed to launch server                 */
    OLE_ERROR_COMM,             /* 36  Failed to communicate with server       */
    OLE_ERROR_TERMINATE,        /* 37  Error in termination                    */
    OLE_ERROR_COMMAND,          /* 38  Error in execute                        */
    OLE_ERROR_SHOW,             /* 39  Error in show                           */
    OLE_ERROR_DOVERB,           /* 40  Error in sending do verb, or invalid    */
                                /*     verb                                    */
    OLE_ERROR_ADVISE_NATIVE,    /* 41  Item could be missing                   */
    OLE_ERROR_ADVISE_PICT,      /* 42  Item could be missing or server doesn't */
                                /*     this format.                            */

    OLE_ERROR_ADVISE_RENAME,    /* 43  Server doesn't support rename           */
    OLE_ERROR_POKE_NATIVE,      /* 44  Failure of poking native data to server */
    OLE_ERROR_REQUEST_NATIVE,   /* 45  Server failed to render native data     */
    OLE_ERROR_REQUEST_PICT,     /* 46  Server failed to render presentation    */
                                /*     data                                    */
    OLE_ERROR_SERVER_BLOCKED,   /* 47  Trying to block a blocked server or     */
                                /*     trying to revoke a blocked server       */
                                /*     or document                             */

    OLE_ERROR_REGISTRATION,     /* 48  Server is not registered in regestation */
                                /*     data base                               */
    OLE_ERROR_ALREADY_REGISTERED,/*49  Trying to register same doc multiple    */
                                 /*    times                                   */
    OLE_ERROR_TASK,             /* 50  Server or client task is invalid        */
    OLE_ERROR_OUTOFDATE,        /* 51  Object is out of date                   */
    OLE_ERROR_CANT_UPDATE_CLIENT,/* 52 Embed doc's client doesn't accept       */
                                /*     updates                                 */
    OLE_ERROR_UPDATE,           /* 53  erorr while trying to update            */
    OLE_ERROR_SETDATA_FORMAT,   /* 54  Server app doesn't understand the       */
                                /*     format given to its SetData method      */
    OLE_ERROR_STATIC_FROM_OTHER_OS,/* 55 trying to load a static object created */
                                   /*    on another Operating System           */

    /*  Following are warnings */
    OLE_WARN_DELETE_DATA = 1000 /*     Caller must delete the data when he is  */
                                /*     done with it.                           */
} OLESTATUS;



/* Codes for CallBack events */
typedef enum
{
    OLE_CHANGED,            /* 0                                             */
    OLE_SAVED,              /* 1                                             */
    OLE_CLOSED,             /* 2                                             */
    OLE_RENAMED,            /* 3                                             */
    OLE_QUERY_PAINT,        /* 4  Interruptible paint support                */
    OLE_RELEASE,            /* 5  Object is released(asynchronous operation  */
                            /*    is completed)                              */
    OLE_QUERY_RETRY         /* 6  Query for retry when server sends busy ACK */
} OLE_NOTIFICATION;

typedef enum
{
    OLE_NONE,               /* 0  no method active                           */
    OLE_DELETE,             /* 1  object delete                              */
    OLE_LNKPASTE,           /* 2  PasteLink(auto reconnect)                  */
    OLE_EMBPASTE,           /* 3  paste(and update)                          */
    OLE_SHOW,               /* 4  Show                                       */
    OLE_RUN,                /* 5  Run                                        */
    OLE_ACTIVATE,           /* 6  Activate                                   */
    OLE_UPDATE,             /* 7  Update                                     */
    OLE_CLOSE,              /* 8  Close                                      */
    OLE_RECONNECT,          /* 9  Reconnect                                  */
    OLE_SETUPDATEOPTIONS,   /* 10 setting update options                     */
    OLE_SERVERUNLAUNCH,     /* 11 server is being unlaunched                 */
    OLE_LOADFROMSTREAM,     /* 12 LoadFromStream(auto reconnect)             */
    OLE_SETDATA,            /* 13 OleSetData                                 */
    OLE_REQUESTDATA,        /* 14 OleRequestData                             */
    OLE_OTHER,              /* 15 other misc async operations                */
    OLE_CREATE,             /* 16 create                                     */
    OLE_CREATEFROMTEMPLATE, /* 17 CreatefromTemplate                         */
    OLE_CREATELINKFROMFILE, /* 18 CreateLinkFromFile                         */
    OLE_COPYFROMLNK,        /* 19 CopyFromLink(auto reconnect)               */
    OLE_CREATEFROMFILE,     /* 20 CreateFromFile                             */
    OLE_CREATEINVISIBLE     /* 21 CreateInvisible                            */
} OLE_RELEASE_METHOD;

/* rendering options */
typedef enum
{
    olerender_none, 
    olerender_draw, 
    olerender_format 
} OLEOPT_RENDER;

/* standard clipboard format type */
typedef WORD OLECLIPFORMAT;

/* Link update options */
typedef enum
{
    oleupdate_always,
    oleupdate_onsave,
#ifndef OLE_INTERNAL
    oleupdate_oncall
#else
    oleupdate_oncall,
    oleupdate_onclose
#endif  /* OLE_INTERNAL */
} OLEOPT_UPDATE;

typedef HANDLE  HOBJECT;
typedef LONG    LHSERVER;
typedef LONG    LHCLIENTDOC;
typedef LONG    LHSERVERDOC;

typedef struct _OLEOBJECT FAR*  LPOLEOBJECT;
typedef struct _OLESTREAM FAR*  LPOLESTREAM;
typedef struct _OLECLIENT FAR*  LPOLECLIENT;


#ifndef OLE_INTERNAL
/* object method table definitions. */
typedef struct _OLEOBJECTVTBL
{
    void FAR*      (CALLBACK* QueryProtocol)        (LPOLEOBJECT, OLE_LPCSTR);
    OLESTATUS      (CALLBACK* Release)              (LPOLEOBJECT);
    OLESTATUS      (CALLBACK* Show)                 (LPOLEOBJECT, BOOL);
    OLESTATUS      (CALLBACK* DoVerb)               (LPOLEOBJECT, UINT, BOOL, BOOL);
    OLESTATUS      (CALLBACK* GetData)              (LPOLEOBJECT, OLECLIPFORMAT, HANDLE FAR*);
    OLESTATUS      (CALLBACK* SetData)              (LPOLEOBJECT, OLECLIPFORMAT, HANDLE);
    OLESTATUS      (CALLBACK* SetTargetDevice)      (LPOLEOBJECT, HGLOBAL);
    OLESTATUS      (CALLBACK* SetBounds)            (LPOLEOBJECT, OLE_CONST RECT FAR*);
    OLECLIPFORMAT  (CALLBACK* EnumFormats)          (LPOLEOBJECT, OLECLIPFORMAT);
    OLESTATUS      (CALLBACK* SetColorScheme)       (LPOLEOBJECT, OLE_CONST LOGPALETTE FAR*);
    /* Server has to implement only the above methods. */

#ifndef SERVERONLY
    /* Extra methods required for client. */
    OLESTATUS      (CALLBACK* Delete)               (LPOLEOBJECT);
    OLESTATUS      (CALLBACK* SetHostNames)         (LPOLEOBJECT, OLE_LPCSTR, OLE_LPCSTR);
    OLESTATUS      (CALLBACK* SaveToStream)         (LPOLEOBJECT, LPOLESTREAM);
    OLESTATUS      (CALLBACK* Clone)                (LPOLEOBJECT, LPOLECLIENT, LHCLIENTDOC, OLE_LPCSTR, LPOLEOBJECT FAR*);
    OLESTATUS      (CALLBACK* CopyFromLink)         (LPOLEOBJECT, LPOLECLIENT, LHCLIENTDOC, OLE_LPCSTR, LPOLEOBJECT FAR*);
    OLESTATUS      (CALLBACK* Equal)                (LPOLEOBJECT, LPOLEOBJECT);
    OLESTATUS      (CALLBACK* CopyToClipboard)      (LPOLEOBJECT);
    OLESTATUS      (CALLBACK* Draw)                 (LPOLEOBJECT, HDC, OLE_CONST RECT FAR*, OLE_CONST RECT FAR*, HDC);
    OLESTATUS      (CALLBACK* Activate)             (LPOLEOBJECT, UINT, BOOL, BOOL, HWND, OLE_CONST RECT FAR*);
    OLESTATUS      (CALLBACK* Execute)              (LPOLEOBJECT, HGLOBAL, UINT);
    OLESTATUS      (CALLBACK* Close)                (LPOLEOBJECT);
    OLESTATUS      (CALLBACK* Update)               (LPOLEOBJECT);
    OLESTATUS      (CALLBACK* Reconnect)            (LPOLEOBJECT);

    OLESTATUS      (CALLBACK* ObjectConvert)        (LPOLEOBJECT, OLE_LPCSTR, LPOLECLIENT, LHCLIENTDOC, OLE_LPCSTR, LPOLEOBJECT FAR*);
    OLESTATUS      (CALLBACK* GetLinkUpdateOptions) (LPOLEOBJECT, OLEOPT_UPDATE FAR*);
    OLESTATUS      (CALLBACK* SetLinkUpdateOptions) (LPOLEOBJECT, OLEOPT_UPDATE);
    
    OLESTATUS      (CALLBACK* Rename)               (LPOLEOBJECT, OLE_LPCSTR);
    OLESTATUS      (CALLBACK* QueryName)            (LPOLEOBJECT, LPSTR, UINT FAR*);

    OLESTATUS      (CALLBACK* QueryType)            (LPOLEOBJECT, LONG FAR*);
    OLESTATUS      (CALLBACK* QueryBounds)          (LPOLEOBJECT, RECT FAR*);
    OLESTATUS      (CALLBACK* QuerySize)            (LPOLEOBJECT, DWORD FAR*);
    OLESTATUS      (CALLBACK* QueryOpen)            (LPOLEOBJECT);
    OLESTATUS      (CALLBACK* QueryOutOfDate)       (LPOLEOBJECT);

    OLESTATUS      (CALLBACK* QueryReleaseStatus)   (LPOLEOBJECT);
    OLESTATUS      (CALLBACK* QueryReleaseError)    (LPOLEOBJECT);
    OLE_RELEASE_METHOD (CALLBACK* QueryReleaseMethod)(LPOLEOBJECT);

    OLESTATUS      (CALLBACK* RequestData)          (LPOLEOBJECT, OLECLIPFORMAT);
    OLESTATUS      (CALLBACK* ObjectLong)           (LPOLEOBJECT, UINT, LONG FAR*);
    
/* This method is internal only */
    OLESTATUS      (CALLBACK* ChangeData)           (LPOLEOBJECT, HANDLE, LPOLECLIENT, BOOL);
#endif  /* !SERVERONLY */
} OLEOBJECTVTBL;
typedef  OLEOBJECTVTBL FAR* LPOLEOBJECTVTBL;

typedef struct _OLEOBJECT
{
    LPOLEOBJECTVTBL    lpvtbl;
} OLEOBJECT;
#endif  /* !OLE_NTERNAL */

/* ole client definitions */
typedef struct _OLECLIENTVTBL
{
    int (CALLBACK* CallBack)(LPOLECLIENT, OLE_NOTIFICATION, LPOLEOBJECT);
} OLECLIENTVTBL;

typedef  OLECLIENTVTBL FAR*  LPOLECLIENTVTBL;

typedef struct _OLECLIENT
{
    LPOLECLIENTVTBL   lpvtbl;
} OLECLIENT;

/* Stream definitions */
typedef struct _OLESTREAMVTBL
{
    DWORD (CALLBACK* Get)(LPOLESTREAM, void FAR*, DWORD);
    DWORD (CALLBACK* Put)(LPOLESTREAM, OLE_CONST void FAR*, DWORD);
} OLESTREAMVTBL;
typedef  OLESTREAMVTBL FAR*  LPOLESTREAMVTBL;

typedef struct _OLESTREAM
{
    LPOLESTREAMVTBL      lpstbl;
} OLESTREAM;

/* Public Function Prototypes */
OLESTATUS   WINAPI  OleDelete(LPOLEOBJECT);
OLESTATUS   WINAPI  OleRelease(LPOLEOBJECT);
OLESTATUS   WINAPI  OleSaveToStream(LPOLEOBJECT, LPOLESTREAM);
OLESTATUS   WINAPI  OleEqual(LPOLEOBJECT, LPOLEOBJECT );
OLESTATUS   WINAPI  OleCopyToClipboard(LPOLEOBJECT);
OLESTATUS   WINAPI  OleSetHostNames(LPOLEOBJECT, LPCSTR, LPCSTR);
OLESTATUS   WINAPI  OleSetTargetDevice(LPOLEOBJECT, HGLOBAL);
OLESTATUS   WINAPI  OleSetBounds(LPOLEOBJECT, const RECT FAR*);
OLESTATUS   WINAPI  OleSetColorScheme(LPOLEOBJECT, const LOGPALETTE FAR*);
OLESTATUS   WINAPI  OleQueryBounds(LPOLEOBJECT, RECT FAR*);
OLESTATUS   WINAPI  OleQuerySize(LPOLEOBJECT, DWORD FAR*);
OLESTATUS   WINAPI  OleDraw(LPOLEOBJECT, HDC, const RECT FAR*, const RECT FAR*, HDC);
OLESTATUS   WINAPI  OleQueryOpen(LPOLEOBJECT);
OLESTATUS   WINAPI  OleActivate(LPOLEOBJECT, UINT, BOOL, BOOL, HWND, const RECT FAR*);
OLESTATUS   WINAPI  OleExecute(LPOLEOBJECT, HGLOBAL, UINT);
OLESTATUS   WINAPI  OleClose(LPOLEOBJECT);
OLESTATUS   WINAPI  OleUpdate(LPOLEOBJECT);
OLESTATUS   WINAPI  OleReconnect(LPOLEOBJECT);
OLESTATUS   WINAPI  OleGetLinkUpdateOptions(LPOLEOBJECT, OLEOPT_UPDATE FAR*);
OLESTATUS   WINAPI  OleSetLinkUpdateOptions(LPOLEOBJECT, OLEOPT_UPDATE);
void FAR*   WINAPI  OleQueryProtocol(LPOLEOBJECT, LPCSTR);

/* Routines related to asynchronous operations. */
OLESTATUS   WINAPI  OleQueryReleaseStatus(LPOLEOBJECT);
OLESTATUS   WINAPI  OleQueryReleaseError(LPOLEOBJECT);
OLE_RELEASE_METHOD WINAPI OleQueryReleaseMethod(LPOLEOBJECT);

OLESTATUS   WINAPI  OleQueryType(LPOLEOBJECT, LONG FAR*);

/* LOWORD is major version, HIWORD is minor version */
DWORD       WINAPI  OleQueryClientVersion(void);
DWORD       WINAPI  OleQueryServerVersion(void);

/* Converting to format (as in clipboard): */
OLECLIPFORMAT  WINAPI  OleEnumFormats(LPOLEOBJECT, OLECLIPFORMAT);
OLESTATUS   WINAPI  OleGetData(LPOLEOBJECT, OLECLIPFORMAT, HANDLE FAR*);
OLESTATUS   WINAPI  OleSetData(LPOLEOBJECT, OLECLIPFORMAT, HANDLE);
OLESTATUS   WINAPI  OleQueryOutOfDate(LPOLEOBJECT);
OLESTATUS   WINAPI  OleRequestData(LPOLEOBJECT, OLECLIPFORMAT);

/* Query apis for creation from clipboard */
OLESTATUS   WINAPI  OleQueryLinkFromClip(LPCSTR, OLEOPT_RENDER, OLECLIPFORMAT);
OLESTATUS   WINAPI  OleQueryCreateFromClip(LPCSTR, OLEOPT_RENDER, OLECLIPFORMAT);

/* Object creation functions */
OLESTATUS   WINAPI  OleCreateFromClip(LPCSTR, LPOLECLIENT, LHCLIENTDOC, LPCSTR,  LPOLEOBJECT FAR*, OLEOPT_RENDER, OLECLIPFORMAT);
OLESTATUS   WINAPI  OleCreateLinkFromClip(LPCSTR, LPOLECLIENT, LHCLIENTDOC, LPCSTR, LPOLEOBJECT FAR*, OLEOPT_RENDER, OLECLIPFORMAT);
OLESTATUS   WINAPI  OleCreateFromFile(LPCSTR, LPOLECLIENT, LPCSTR, LPCSTR, LHCLIENTDOC, LPCSTR, LPOLEOBJECT FAR*, OLEOPT_RENDER, OLECLIPFORMAT);
OLESTATUS   WINAPI  OleCreateLinkFromFile(LPCSTR, LPOLECLIENT, LPCSTR, LPCSTR, LPCSTR, LHCLIENTDOC, LPCSTR, LPOLEOBJECT FAR*, OLEOPT_RENDER, OLECLIPFORMAT);
OLESTATUS   WINAPI  OleLoadFromStream(LPOLESTREAM, LPCSTR, LPOLECLIENT, LHCLIENTDOC, LPCSTR, LPOLEOBJECT FAR*);
OLESTATUS   WINAPI  OleCreate(LPCSTR, LPOLECLIENT, LPCSTR, LHCLIENTDOC, LPCSTR, LPOLEOBJECT FAR*, OLEOPT_RENDER, OLECLIPFORMAT);
OLESTATUS   WINAPI  OleCreateInvisible(LPCSTR, LPOLECLIENT, LPCSTR, LHCLIENTDOC, LPCSTR, LPOLEOBJECT FAR*, OLEOPT_RENDER, OLECLIPFORMAT, BOOL);
OLESTATUS   WINAPI  OleCreateFromTemplate(LPCSTR, LPOLECLIENT, LPCSTR, LHCLIENTDOC, LPCSTR, LPOLEOBJECT FAR*, OLEOPT_RENDER, OLECLIPFORMAT);
OLESTATUS   WINAPI  OleClone(LPOLEOBJECT, LPOLECLIENT, LHCLIENTDOC, LPCSTR, LPOLEOBJECT FAR*);
OLESTATUS   WINAPI  OleCopyFromLink(LPOLEOBJECT, LPCSTR, LPOLECLIENT, LHCLIENTDOC, LPCSTR, LPOLEOBJECT FAR*);
OLESTATUS   WINAPI  OleObjectConvert(LPOLEOBJECT, LPCSTR, LPOLECLIENT, LHCLIENTDOC, LPCSTR, LPOLEOBJECT FAR*);
OLESTATUS   WINAPI  OleRename(LPOLEOBJECT, LPCSTR);
OLESTATUS   WINAPI  OleQueryName(LPOLEOBJECT, LPSTR, UINT FAR*);
OLESTATUS   WINAPI  OleRevokeObject(LPOLECLIENT);
BOOL        WINAPI  OleIsDcMeta(HDC);

/* client document API */
OLESTATUS   WINAPI  OleRegisterClientDoc(LPCSTR, LPCSTR, LONG, LHCLIENTDOC FAR*);
OLESTATUS   WINAPI  OleRevokeClientDoc(LHCLIENTDOC);
OLESTATUS   WINAPI  OleRenameClientDoc(LHCLIENTDOC, LPCSTR);
OLESTATUS   WINAPI  OleRevertClientDoc(LHCLIENTDOC);
OLESTATUS   WINAPI  OleSavedClientDoc(LHCLIENTDOC);
OLESTATUS   WINAPI  OleEnumObjects(LHCLIENTDOC, LPOLEOBJECT FAR*);

/* server usage definitions */
typedef enum {
    OLE_SERVER_MULTI,           /* multiple instances */
    OLE_SERVER_SINGLE           /* single instance(multiple document) */
} OLE_SERVER_USE;

/* Server API */
typedef struct _OLESERVER FAR*  LPOLESERVER;

OLESTATUS   WINAPI  OleRegisterServer(LPCSTR, LPOLESERVER, LHSERVER FAR*, HINSTANCE, OLE_SERVER_USE);
OLESTATUS   WINAPI  OleRevokeServer(LHSERVER);
OLESTATUS   WINAPI  OleBlockServer(LHSERVER);
OLESTATUS   WINAPI  OleUnblockServer(LHSERVER, BOOL FAR*);

/* APIs to keep server open */
OLESTATUS   WINAPI  OleLockServer(LPOLEOBJECT, LHSERVER FAR*);
OLESTATUS   WINAPI  OleUnlockServer(LHSERVER);

/* Server document API */

typedef struct _OLESERVERDOC FAR*  LPOLESERVERDOC;

OLESTATUS   WINAPI  OleRegisterServerDoc(LHSERVER, LPCSTR, LPOLESERVERDOC, LHSERVERDOC FAR*);
OLESTATUS   WINAPI  OleRevokeServerDoc(LHSERVERDOC);
OLESTATUS   WINAPI  OleRenameServerDoc(LHSERVERDOC, LPCSTR);
OLESTATUS   WINAPI  OleRevertServerDoc(LHSERVERDOC);
OLESTATUS   WINAPI  OleSavedServerDoc(LHSERVERDOC);

typedef struct _OLESERVERVTBL
{
    OLESTATUS (CALLBACK* Open)  (LPOLESERVER, LHSERVERDOC, OLE_LPCSTR, LPOLESERVERDOC FAR*);
                                    /* long handle to doc(privtate to DLL)  */
                                    /* lp to OLESERVER                      */
                                    /* document name                        */
                                    /* place holder for returning oledoc.   */

    OLESTATUS (CALLBACK* Create)(LPOLESERVER, LHSERVERDOC, OLE_LPCSTR, OLE_LPCSTR, LPOLESERVERDOC FAR*);
                                    /* long handle to doc(privtate to DLL)  */
                                    /* lp to OLESERVER                      */
                                    /* lp class name                        */
                                    /* lp doc name                          */
                                    /* place holder for returning oledoc.   */

    OLESTATUS (CALLBACK* CreateFromTemplate)(LPOLESERVER, LHSERVERDOC, OLE_LPCSTR, OLE_LPCSTR, OLE_LPCSTR, LPOLESERVERDOC FAR*);
                                    /* long handle to doc(privtate to DLL)  */
                                    /* lp to OLESERVER                      */
                                    /* lp class name                        */
                                    /* lp doc name                          */
                                    /* lp template name                     */
                                    /* place holder for returning oledoc.   */

    OLESTATUS (CALLBACK* Edit)  (LPOLESERVER, LHSERVERDOC, OLE_LPCSTR, OLE_LPCSTR, LPOLESERVERDOC FAR*);
                                    /* long handle to doc(privtate to DLL)  */
                                    /* lp to OLESERVER                      */
                                    /* lp class name                        */
                                    /* lp doc name                          */
                                    /* place holder for returning oledoc.   */

    OLESTATUS (CALLBACK* Exit)  (LPOLESERVER);
                                    /* lp OLESERVER                         */

    OLESTATUS (CALLBACK* Release)  (LPOLESERVER);
                                    /* lp OLESERVER                         */

    OLESTATUS (CALLBACK* Execute)(LPOLESERVER, HGLOBAL);
                                    /* lp OLESERVER                         */
                                    /* handle to command strings            */
} OLESERVERVTBL;
typedef  OLESERVERVTBL FAR*  LPOLESERVERVTBL;

typedef struct _OLESERVER
{
    LPOLESERVERVTBL    lpvtbl;
} OLESERVER;

typedef struct _OLESERVERDOCVTBL
{
    OLESTATUS (CALLBACK* Save)      (LPOLESERVERDOC);
    OLESTATUS (CALLBACK* Close)     (LPOLESERVERDOC);
    OLESTATUS (CALLBACK* SetHostNames)(LPOLESERVERDOC, OLE_LPCSTR, OLE_LPCSTR);
    OLESTATUS (CALLBACK* SetDocDimensions)(LPOLESERVERDOC, OLE_CONST RECT FAR*);
    OLESTATUS (CALLBACK* GetObject) (LPOLESERVERDOC, OLE_LPCSTR, LPOLEOBJECT FAR*, LPOLECLIENT);
    OLESTATUS (CALLBACK* Release)   (LPOLESERVERDOC);
    OLESTATUS (CALLBACK* SetColorScheme)(LPOLESERVERDOC, OLE_CONST LOGPALETTE FAR*);
    OLESTATUS (CALLBACK* Execute)  (LPOLESERVERDOC, HGLOBAL);
} OLESERVERDOCVTBL;
typedef  OLESERVERDOCVTBL FAR*  LPOLESERVERDOCVTBL;

typedef struct _OLESERVERDOC
{
    LPOLESERVERDOCVTBL lpvtbl;
} OLESERVERDOC;

#ifdef __cplusplus
}
#endif  /* __cplusplus */

#ifndef RC_INVOKED
#pragma pack()
#endif  /* !RC_INVOKED */

#endif  /* !_INC_OLE */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\ole\client\ole.c ===
/******************************* Module Header *******************************
* Module Name: OLE.C 
*
* Purpose: Handles all API routines for the dde L&E sub-dll of the ole dll.
*
* PURPOSE: API routines for handling generic objects (which may be static,
*    linked, or embedded).  These routines will be made into a DLL.
*
* Created: 1990
*
* Copyright (c) 1990, 1991  Microsoft Corporation
*
* History:
*   Raor, Srinik  (../../90, 91)    Designed/coded.
*
*****************************************************************************/

#include <windows.h>
#include <shellapi.h>

#include "dll.h"

extern DLL_ENTRY        lpDllTable[];
extern char             packageClass[];
extern OLECLIPFORMAT    cfFileName;
extern DWORD            dwOleVer;

DWORD           dwVerFromFile;
HANDLE          hInfo = NULL;
CLIENTDOC       lockDoc = {{'C', 'D'}, 0L, 0L, 0, 0, 0, 0L, 0L};
LHCLIENTDOC     lhLockDoc = (LHCLIENTDOC) ((LPCLIENTDOC) &lockDoc);
BOOL            gbCreateInvisible = FALSE;
BOOL            gbLaunchServer;


OLESTATUS INTERNAL LockServer (LPOBJECT_LE);

#pragma alloc_text(_DDETEXT, OleLockServer, OleUnlockServer, LockServer, IsServerValid, DeleteSrvrEdit, InitSrvrConv, LeLaunchApp)


//////////////////////////////////////////////////////////////////////////////
//
//  LPVOID FAR PASCAL OleQueryProtocol (lpobj, lpprotocol)
//   
//  Tells whether the object supports the specified protocol. 
//
//  Arguments:
//
//      lpobj       -   object pointer
//      lpprotocol  -   protocol string
//
//  Returns:
//
//      long ptr to object if the protocol is supported
//      NULL if not.
//
//  Effects:     
//
//////////////////////////////////////////////////////////////////////////////


LPVOID FAR PASCAL OleQueryProtocol (lpobj, lpprotocol)
LPOLEOBJECT lpobj;
LPSTR       lpprotocol;
{
    if (!CheckObject(lpobj))
        return NULL;

    return (*lpobj->lpvtbl->QueryProtocol) (lpobj, lpprotocol);
}



//////////////////////////////////////////////////////////////////////////////
//
//  OLESTATUS FAR PASCAL  OleDelete (lpobj)
//   
//  Deletes the given object and all memory associated with its sub-parts.  
//  The calling function should cease to use 'lpobj', as it is now invalid. 
//  If handler dll is used reference count is reduced by one, and if it 
//  reaches zero the hanlder dll will be freed up.
//
//  Arguments:
//
//      lpobj   -   object pointer
//
//  Returns:
//
//      OLE_OK 
//      OLE_ERROR_OBJECT
//      OLE_WAIT_FOR_RELEASE
//
//  Effects:     
//
//////////////////////////////////////////////////////////////////////////////

OLESTATUS FAR PASCAL  OleDelete (lpobj)
LPOLEOBJECT    lpobj;
{
    Puts("OleDelete");

    if (!CheckObject(lpobj))
        return OLE_ERROR_OBJECT;
    
    return (*lpobj->lpvtbl->Delete) (lpobj);
}



/***************************** Public  Function ****************************\
* OLESTATUS FAR PASCAL  OleRelease (lpobj)
*
* OleRelease: 
*
* Effects:
*
* History:
* Wrote it.
\***************************************************************************/

OLESTATUS FAR PASCAL  OleRelease (lpobj)
LPOLEOBJECT    lpobj;
{
    Puts("OleRelease");

    if (!CheckObject(lpobj))
        return OLE_ERROR_OBJECT;
    
    return (*lpobj->lpvtbl->Release) (lpobj);
}



/***************************** Public  Function ****************************\
*
* OLESTATUS FAR PASCAL OleSaveToStream (lpobj, lpstream)
*
* oleSaveToStream: This will read <hobj> to the stream based on the <hfile>
* structure.  It will return TRUE on success.  This is the only object
* function for which it is not an error to pass a NULL <hobj>.  In the case
* of NULL, this function will simply put a placemarker for an object.
* See oleLoadFromStream.
*
* Effects:
*
* History:
* Wrote it.
\***************************************************************************/

OLESTATUS FAR PASCAL OleSaveToStream (lpobj, lpstream)
LPOLEOBJECT    lpobj;
LPOLESTREAM    lpstream;
{
    Puts("OleSaveToStream");

    if (!CheckObject(lpobj))
        return OLE_ERROR_OBJECT;

    PROBE_READ(lpstream);

    return ((*lpobj->lpvtbl->SaveToStream) (lpobj, lpstream));
}


/***************************** Public  Function ****************************\
*
* OLESTATUS FAR PASCAL OleLoadFromStream (lpstream, lpprotcol, lpclient, lhclientdoc, lpobjname, lplpobj)
*
*  oleLoadFromStream: This will read an object out of the stream based on the
*  <hfile> structure.  It will return a HANDLE to the object it creates.
*  On error, the return value is NULL, but since NULL is also a valid object
*  in the file, the <error> parameter should be checked as well.
*
* Effects:
*
* History:
* Wrote it.
\***************************************************************************/

OLESTATUS FAR PASCAL OleLoadFromStream (lpstream, lpprotocol, lpclient, lhclientdoc, lpobjname, lplpobj)
LPOLESTREAM         lpstream;
LPSTR               lpprotocol;
LPOLECLIENT         lpclient;
LHCLIENTDOC         lhclientdoc;
LPSTR               lpobjname;
LPOLEOBJECT FAR *   lplpobj;
{
    LONG            len;
    OLESTATUS       retVal = OLE_ERROR_STREAM;
    char            class[100];
    ATOM            aClass;
    BOOL            bEdit = FALSE, bStatic = FALSE;
    LONG            ctype;
    int             objCount;
    int             iTable = INVALID_INDEX;
    
    Puts("OleLoadFromStream");

    *lplpobj = NULL;

    PROBE_MODE(bProtMode);

    if (!CheckClientDoc ((LPCLIENTDOC) lhclientdoc))
        return OLE_ERROR_HANDLE;
    
    PROBE_READ(lpstream);
    PROBE_WRITE(lplpobj);
    PROBE_READ(lpprotocol);
    PROBE_READ(lpclient);
    
#ifdef FIREWALLS    
    ASSERT (lpobjname, "NULL lpobjname passed to OleLoadFromStream\n");
#endif

    PROBE_READ(lpobjname);
    if (!lpobjname[0])
        return OLE_ERROR_NAME;
            
    if (!(bEdit = !lstrcmpi (lpprotocol, PROTOCOL_EDIT)))
        if (!(bStatic = !lstrcmpi (lpprotocol, PROTOCOL_STATIC)))
            return OLE_ERROR_PROTOCOL;

    if (GetBytes (lpstream, (LPSTR) &dwVerFromFile, sizeof(LONG)))
        return OLE_ERROR_STREAM;
    
    if (GetBytes (lpstream, (LPSTR)&ctype, sizeof(LONG)))
        return OLE_ERROR_STREAM;
    
    if (ctype == CT_NULL) 
        return (bStatic ? OLE_OK: OLE_ERROR_PROTOCOL);
            
    if (((ctype != CT_PICTURE) && (ctype != CT_STATIC) && bStatic) ||
            ((ctype != CT_LINK) && (ctype != CT_OLDLINK) 
                && (ctype != CT_EMBEDDED) && bEdit))
        return OLE_ERROR_PROTOCOL;

    if ((ctype == CT_STATIC) && ((HIWORD(dwVerFromFile)) != OS_WIN16))
        return OLE_ERROR_STATIC_FROM_OTHER_OS;
            
    //** Get Class 
    if (GetBytes(lpstream, (LPSTR)&len, sizeof(len)))
        return OLE_ERROR_STREAM;

    if (len == 0)
        return OLE_ERROR_STREAM;
    
    if (GetBytes(lpstream, (LPSTR)&class, len))
        return OLE_ERROR_STREAM;

    aClass = GlobalAddAtom (class);
    
    if ((ctype == CT_PICTURE) || (ctype == CT_STATIC)) 
        retVal = DefLoadFromStream (lpstream, lpprotocol, lpclient, 
                    lhclientdoc, lpobjname, lplpobj, ctype, aClass, NULL);

    //!!! It's the DLL's responsibility to delete the atom. But in case of 
    // failure we delete the atom if our DefLoadFromStream().
        
    else if ((iTable = LoadDll (class)) == INVALID_INDEX) {
        retVal = DefLoadFromStream (lpstream, lpprotocol, lpclient, 
                        lhclientdoc, lpobjname, lplpobj, ctype, aClass, NULL);
    }
    else { 
        objCount = lpDllTable[iTable].cObj;
        retVal = (*lpDllTable[iTable].Load) (lpstream, lpprotocol, lpclient, 
                       lhclientdoc, lpobjname, lplpobj, ctype, aClass, NULL);
        if (retVal > OLE_WAIT_FOR_RELEASE)
            lpDllTable[iTable].cObj = objCount - 1;
        else
            (*lplpobj)->iTable = iTable;        
    }

    return retVal;
}



OLESTATUS FAR PASCAL  OleClone (lpobjsrc, lpclient, lhclientdoc, lpobjname, lplpobj)
LPOLEOBJECT         lpobjsrc;
LPOLECLIENT         lpclient;
LHCLIENTDOC         lhclientdoc;
LPSTR               lpobjname;
LPOLEOBJECT FAR *   lplpobj;
{
    OLESTATUS   retVal;
    
    Puts("OleClone");

    if (!CheckObject(lpobjsrc))
        return OLE_ERROR_OBJECT;

    if (!CheckClientDoc ((LPCLIENTDOC) lhclientdoc))
        return OLE_ERROR_HANDLE;
    
    PROBE_READ(lpclient);
    
#ifdef FIREWALLS    
    ASSERT (lpobjname, "NULL lpobjname passed to OleClone\n");
#endif

    PROBE_READ(lpobjname);  
    
    if (!lpobjname[0])
        return OLE_ERROR_NAME;

    PROBE_WRITE(lplpobj);

    *lplpobj = NULL;   
    
    retVal = (*lpobjsrc->lpvtbl->Clone) (lpobjsrc, lpclient, 
                        lhclientdoc, lpobjname, lplpobj);
                    
    if ((lpobjsrc->iTable != INVALID_INDEX) && (retVal <= OLE_WAIT_FOR_RELEASE))
        lpDllTable[lpobjsrc->iTable].cObj++;
    
    return retVal;
}


OLESTATUS FAR PASCAL  OleCopyFromLink (lpobjsrc, lpprotocol, lpclient, lhclientdoc, lpobjname, lplpobj)
LPOLEOBJECT         lpobjsrc;
LPSTR               lpprotocol;
LPOLECLIENT         lpclient;
LHCLIENTDOC         lhclientdoc;
LPSTR               lpobjname;
LPOLEOBJECT FAR *   lplpobj;
{
    OLESTATUS   retVal;
    
    Puts("OleCopyFromLnk");

    if (!CheckObject(lpobjsrc))
        return(OLE_ERROR_OBJECT);

    if (!CheckClientDoc ((LPCLIENTDOC) lhclientdoc))
        return OLE_ERROR_HANDLE;
    
    PROBE_READ(lpprotocol);
    PROBE_WRITE(lplpobj);
    PROBE_READ(lpclient);
    
#ifdef FIREWALLS    
    ASSERT (lpobjname, "NULL lpobjname passed to OleCopyFromLink\n");
#endif

    PROBE_READ(lpobjname);
    if (!lpobjname[0])
        return OLE_ERROR_NAME;
    
    *lplpobj = NULL;
        
    if (lstrcmpi (lpprotocol, PROTOCOL_EDIT))
        return OLE_ERROR_PROTOCOL;
    
    retVal = (*lpobjsrc->lpvtbl->CopyFromLink) (lpobjsrc, lpclient, 
                        lhclientdoc, lpobjname, lplpobj);
    
    if ((lpobjsrc->iTable != INVALID_INDEX) && (retVal <= OLE_WAIT_FOR_RELEASE))
        lpDllTable[lpobjsrc->iTable].cObj++;


    return retVal;

}



OLESTATUS FAR PASCAL  OleEqual (lpobj1, lpobj2)
LPOLEOBJECT lpobj1;
LPOLEOBJECT lpobj2;
{
    if (!CheckObject(lpobj1))
        return OLE_ERROR_OBJECT;

    if (!CheckObject(lpobj2))
        return OLE_ERROR_OBJECT;

    if (lpobj1->ctype != lpobj2->ctype)
        return OLE_ERROR_NOT_EQUAL;
    
    return ((*lpobj1->lpvtbl->Equal) (lpobj1, lpobj2));
}


/***************************** Public  Function ****************************\
*
* OLESTATUS FAR PASCAL OleQueryLinkFromClip (lpprotcol, optRender, cfFormat)
*
* oleQueryFromClip: Returns OLE_OK if a linked object can be created.
*
*
* Effects:
*
* History:
* Wrote it.
\***************************************************************************/


OLESTATUS FAR PASCAL OleQueryLinkFromClip (lpprotocol, optRender, cfFormat)
LPSTR           lpprotocol;
OLEOPT_RENDER   optRender;
OLECLIPFORMAT   cfFormat;
{
    Puts("OleQueryLinkFromClip");
    return LeQueryCreateFromClip (lpprotocol, optRender, cfFormat, CT_LINK);
}



/***************************** Public  Function ****************************\
*
* OLESTATUS FAR PASCAL OleQueryCreateFromClip (lpprotcol, optRender, cfFormat)
*
* oleQueryCreateFromClip: Returns true if a non-linked object can be
* created.
*
*
* Effects:
*
* History:
* Wrote it.
\***************************************************************************/


OLESTATUS FAR PASCAL OleQueryCreateFromClip (lpprotocol, optRender, cfFormat)
LPSTR           lpprotocol;
OLEOPT_RENDER   optRender;
OLECLIPFORMAT   cfFormat;
{
    Puts("OleQueryCreateFromClip");
    return (LeQueryCreateFromClip (lpprotocol, optRender, 
                        cfFormat, CT_EMBEDDED));
}



/***************************** Public  Function ****************************\
*
* OLESTATUS FAR PASCAL OleCreateLinkFromClip (lpprotcol, lpclient, lhclientdoc, lpobjname, lplpoleobject, optRender, cfFormat)
*
*
*  oleCreateLinkFromClip: This function creates the LP to an object from the
*  clipboard.  It will try to create a linked object.  Return value is OLE_OK
*  is the object is successfully created it
*
* Effects:
*
* History:
* Wrote it.
\***************************************************************************/

OLESTATUS FAR PASCAL OleCreateLinkFromClip (lpprotocol, lpclient, lhclientdoc, lpobjname, lplpobj, optRender, cfFormat)
LPSTR               lpprotocol;
LPOLECLIENT         lpclient;
LHCLIENTDOC         lhclientdoc;
LPSTR               lpobjname;
LPOLEOBJECT  FAR *  lplpobj;
OLEOPT_RENDER       optRender;
OLECLIPFORMAT       cfFormat;
{
    int         objCount;
    int         iTable = INVALID_INDEX;
    OLESTATUS   retVal;
    LPSTR       lpInfo;
    
    Puts("OleCreateLinkFromClip");
    
    PROBE_MODE(bProtMode);

    if (!CheckClientDoc ((LPCLIENTDOC) lhclientdoc))
        return OLE_ERROR_HANDLE;
    
    PROBE_READ(lpprotocol);
    PROBE_READ(lpclient);   
    PROBE_WRITE(lplpobj);
    
#ifdef FIREWALLS    
    ASSERT (lpobjname, "NULL lpobjname passed to OleCreateLinkFromClip\n");
#endif

    PROBE_READ(lpobjname);

    if (!lpobjname[0])
        return OLE_ERROR_NAME;    
    
    *lplpobj = NULL;
    
    if (lstrcmpi (lpprotocol, PROTOCOL_EDIT))
        return OLE_ERROR_PROTOCOL;
    
    if (IsClipboardFormatAvailable (cfFileName))
        return CreatePackageFromClip (lpclient, lhclientdoc, lpobjname, 
                        lplpobj, optRender, cfFormat, CT_LINK);
                    
    if (!(hInfo = GetClipboardData (cfObjectLink)))
        return OLE_ERROR_CLIPBOARD;

    if (!(lpInfo = GlobalLock(hInfo)))
        return OLE_ERROR_CLIPBOARD;

    iTable = LoadDll (lpInfo);
    GlobalUnlock (hInfo);


    if (iTable == INVALID_INDEX)
        retVal = DefCreateLinkFromClip (lpprotocol, lpclient, lhclientdoc,
                        lpobjname, lplpobj, optRender, cfFormat);
    else { 
        objCount = lpDllTable[iTable].cObj;
        retVal = (*lpDllTable[iTable].Link) (lpprotocol, lpclient, 
                    lhclientdoc, lpobjname, lplpobj, optRender, cfFormat);
        if (retVal > OLE_WAIT_FOR_RELEASE)
            lpDllTable[iTable].cObj = objCount - 1;                         
        else
            (*lplpobj)->iTable = iTable;
    }
    
    hInfo = NULL;
    return retVal;
}



/***************************** Public  Function ****************************\
*
* OLESTATUS FAR PASCAL OleCreateFromClip (lpprotcol, lpclient, lplpoleobject, optRender, cfFormat)
*
*
* oleCreateFromClip: This function creates the LP to an object
*  from the clipboard.  It will try to create an embedded object if
*  OwnerLink and Native are available, otherwise it will create a static
*  picture.  Return value is OLE_OK if the object is successfully
*  created it.
*
* Effects:
*
* History:
* Wrote it.
\***************************************************************************/

OLESTATUS FAR PASCAL OleCreateFromClip (lpprotocol, lpclient, lhclientdoc, lpobjname, lplpobj, optRender, cfFormat)
LPSTR               lpprotocol;
LPOLECLIENT         lpclient;
LHCLIENTDOC         lhclientdoc;
LPSTR               lpobjname;
LPOLEOBJECT FAR *   lplpobj;
OLEOPT_RENDER       optRender;
OLECLIPFORMAT       cfFormat;
{
    OLESTATUS       retVal;
    LONG            ctype;
    int             iTable = INVALID_INDEX;
    LPSTR           lpInfo;
    LPSTR           lpClass = NULL;
    int             objCount;   
    OLECLIPFORMAT   cfEnum = NULL;

    Puts("OleCreateFromClip");

    PROBE_MODE(bProtMode);

    if (!CheckClientDoc ((LPCLIENTDOC) lhclientdoc))
        return OLE_ERROR_HANDLE;
    
    PROBE_READ(lpprotocol);
    PROBE_READ(lpclient);
    PROBE_WRITE(lplpobj);

#ifdef FIREWALLS    
    ASSERT (lpobjname, "NULL lpobjname passed to OleCreateFromClip\n");
#endif

    PROBE_READ(lpobjname);
    if (!lpobjname[0])
        return OLE_ERROR_NAME;    
    
    *lplpobj = NULL;

    if (!lstrcmpi (lpprotocol, PROTOCOL_STATIC)) {
        if (optRender == olerender_none) 
            return OLE_ERROR_OPTION;

        if ((optRender == olerender_format) && (cfFormat != CF_METAFILEPICT)
                && (cfFormat != CF_DIB) && (cfFormat != CF_BITMAP))
            return OLE_ERROR_FORMAT;
        
        if (!IsClipboardFormatAvailable (CF_METAFILEPICT)   
                && !IsClipboardFormatAvailable (CF_DIB)     
                && !IsClipboardFormatAvailable (CF_BITMAP))         
            return OLE_ERROR_FORMAT;

        return CreatePictFromClip (lpclient, lhclientdoc, 
                        lpobjname, lplpobj, optRender, 
                        cfFormat, NULL, CT_STATIC);
    }
    else if (!lstrcmpi (lpprotocol, PROTOCOL_EDIT)) {   
        if (IsClipboardFormatAvailable (cfFileName))
            return CreatePackageFromClip (lpclient, lhclientdoc, lpobjname, 
                            lplpobj, optRender, cfFormat, CT_EMBEDDED);
                
        if (!(hInfo = GetClipboardData (cfOwnerLink)))
            return OLE_ERROR_CLIPBOARD;
        
        while (TRUE) {
            cfEnum = EnumClipboardFormats (cfEnum);
            if (cfEnum == cfNative) {
                ctype = CT_EMBEDDED;
                break;
            }
            else if (cfEnum == cfOwnerLink) {
                ctype = CT_LINK;
                break;
            }
        }
        
        if (!(lpInfo = GlobalLock(hInfo)))
            return OLE_ERROR_CLIPBOARD;
        
        iTable = LoadDll (lpInfo);
        GlobalUnlock (hInfo);
    }
    else {
        return OLE_ERROR_PROTOCOL;
    }

    if (iTable == INVALID_INDEX)
        retVal = DefCreateFromClip (lpprotocol, lpclient, lhclientdoc, 
                        lpobjname, lplpobj, optRender, cfFormat, ctype);
    else { 
        objCount = lpDllTable[iTable].cObj;
        retVal = (*lpDllTable[iTable].Clip) (lpprotocol, lpclient, 
                            lhclientdoc, lpobjname, lplpobj, 
                            optRender, cfFormat, ctype);
                        
        if (retVal > OLE_WAIT_FOR_RELEASE)
            lpDllTable[iTable].cObj = objCount - 1;
        else 
            (*lplpobj)->iTable = iTable;
    }

    hInfo = NULL;
    return retVal;
}




/***************************** Public  Function ****************************\
*
* OLESTATUS FAR PASCAL OleCopyToClipboard (lpobj)
*
*
* oleCopyToClipboard: This routine executes the standard "Copy" menu item
* on the typical "Edit" menu. Returns TRUE if successful.
*
* Effects:
*
* History:
* Wrote it.
\***************************************************************************/

OLESTATUS FAR PASCAL OleCopyToClipboard (lpobj)
LPOLEOBJECT lpobj;
{
    Puts("OleCopyToClipboard");

    if (!CheckObject(lpobj))
        return(OLE_ERROR_OBJECT);

    return ((*lpobj->lpvtbl->CopyToClipboard) (lpobj));
}


OLESTATUS FAR PASCAL OleSetHostNames (lpobj, lpclientName, lpdocName)
LPOLEOBJECT lpobj;
LPSTR       lpclientName;
LPSTR       lpdocName;
{
    Puts ("OleSetHostNames");

    if (!CheckObject(lpobj))
        return(OLE_ERROR_OBJECT);
    
    PROBE_READ(lpclientName);
    PROBE_READ(lpdocName);
    
    return ((*lpobj->lpvtbl->SetHostNames) (lpobj, lpclientName, lpdocName));
}



OLESTATUS   FAR PASCAL OleSetTargetDevice (lpobj, hDevInfo)
LPOLEOBJECT lpobj;
HANDLE      hDevInfo;
{
    Puts("OleSetTargetDevice");
    
    if (!CheckObject(lpobj))
        return(OLE_ERROR_OBJECT);
    
    return ((*lpobj->lpvtbl->SetTargetDevice) (lpobj, hDevInfo));
}



OLESTATUS   FAR PASCAL OleSetColorScheme (lpobj, lplogpal)
LPOLEOBJECT     lpobj;
LPLOGPALETTE    lplogpal;
{
    Puts("OleSetColorScheme");
    
    if (!CheckObject(lpobj))
        return(OLE_ERROR_OBJECT);
    
    return ((*lpobj->lpvtbl->SetColorScheme) (lpobj, lplogpal));
}



OLESTATUS FAR PASCAL  OleSetBounds(lpobj, lprc)
LPOLEOBJECT     lpobj;
LPRECT          lprc;
{
    Puts("OleSetBounds");

    if (!CheckObject(lpobj))
        return OLE_ERROR_OBJECT;

    PROBE_READ(lprc);

    return ((*lpobj->lpvtbl->SetBounds) (lpobj, lprc));

}


/***************************** Public  Function ****************************\
* OLESTATUS FAR PASCAL OleQueryBounds (lpobj, lpRc)
*
* Returns the bounds of the object in question in MM_HIMETRIC mode. 
*           width  = lprc->right - lprc->left;  in HIMETRIC units
*           height = lprc->top - lprc->bottom;  in HIMETRIC units
*
* Returns OLE_OK or OLE_ERROR_MEMORY. 
*
*
* Effects:
*
* History:
* Wrote it.
\***************************************************************************/

OLESTATUS FAR PASCAL OleQueryBounds (lpobj, lprc)
LPOLEOBJECT    lpobj;
LPRECT         lprc;
{

    Puts("OleQueryBounds");

    if (!CheckObject(lpobj))
        return(OLE_ERROR_OBJECT);

    PROBE_WRITE(lprc);
    
    return (*lpobj->lpvtbl->QueryBounds) (lpobj, lprc);
}



/***************************** Public  Function ****************************\
* OLESTATUS FAR PASCAL OleQuerySize (lpobj, lpsize)
*
* Effects:
*
* History:
* Wrote it.
\***************************************************************************/

OLESTATUS FAR PASCAL OleQuerySize (lpobj, lpdwSize)
LPOLEOBJECT    lpobj;
DWORD FAR *    lpdwSize;
{
    Puts("OleQuerySize");

    if (!CheckObject(lpobj))
        return OLE_ERROR_OBJECT;

    PROBE_WRITE(lpdwSize);

    *lpdwSize = NULL; 
    return (*lpobj->lpvtbl->QuerySize) (lpobj, lpdwSize);
}




/***************************** Public  Function ****************************\
* OLESTATUS FAR PASCAL OleDraw (lpobj, hdc, lprc, lpWrc, lphdcTarget)
*
* oleObjectDraw: This displays the given object on the device context <hcd>.
* The <htargetdc> parameter is not currently used. Returns same as Draw().
*
* Expects rectangle coordinates in MM_HIMETRIC units.
*
*
* Effects:
*
* History:
* Wrote it.
\***************************************************************************/

OLESTATUS FAR PASCAL OleDraw (lpobj, hdc, lprc, lpWrc, hdcTarget)
LPOLEOBJECT     lpobj;
HDC             hdc;
LPRECT          lprc;
LPRECT          lpWrc;
HDC             hdcTarget;
{

    Puts("OleObjectDraw");

    if (!FarCheckObject(lpobj))
        return(OLE_ERROR_OBJECT);
    
    PROBE_READ(lprc);
    if (lpWrc)
        PROBE_READ(lpWrc);
    
    return ((*lpobj->lpvtbl->Draw) (lpobj, hdc, lprc, lpWrc, hdcTarget));
}



/***************************** Public  Function ****************************\
*
* OLESTATUS FAR PASCAL OleQueryOpen (lpobj)
*
* returns TRUE is an object has been activated.
*
*
* Effects:
*
* History:
* Wrote it.
\***************************************************************************/

OLESTATUS FAR PASCAL OleQueryOpen (lpobj)
LPOLEOBJECT lpobj;
{
    Puts("OleQueryOpen");

    if (!CheckObject(lpobj))
        return(OLE_ERROR_OBJECT);

    return (*lpobj->lpvtbl->QueryOpen) (lpobj);
}



/***************************** Public  Function ****************************\
*
* OLESTATUS FAR PASCAL OleActivate (lpobj)
*
* Activates an object. For embeded objects always a new instance is
* loaded and the instance is destroyed once the data is transferred
* at close time. For linked objects, an instance of the render is created
* only if one does not exist.
* Effects:
*
* History:
* Wrote it.
\***************************************************************************/

OLESTATUS FAR PASCAL OleActivate (lpobj, verb, fShow, fActivate, hWnd, lprc)
LPOLEOBJECT lpobj;
WORD        verb;
BOOL        fShow;
BOOL        fActivate;
HWND        hWnd;
LPRECT      lprc;
{

    Puts("OleActivate");

    if (!CheckObject(lpobj))
        return(OLE_ERROR_OBJECT);

    /* PROBE_READ(lprc); */
    
    return (*lpobj->lpvtbl->Activate) (lpobj, verb, fShow, fActivate, hWnd, lprc);
}




OLESTATUS FAR PASCAL OleClose (lpobj)
LPOLEOBJECT lpobj;
{

    Puts("OleClose");

    if (!CheckObject(lpobj))
        return(OLE_ERROR_OBJECT);

     return (*lpobj->lpvtbl->Close) (lpobj);
}



/***************************** Public  Function ****************************\
*
* OLESTATUS FAR PASCAL OleUpdate (lpobj)
*
* If there exists a link, sends advise for getting the latest rendering
* infromation. If there is no link, loads an instance, advises for the
* render information and closes the instance once the data is available.
* (If possible should not show the window).
*
* History:
* Wrote it.
\***************************************************************************/

OLESTATUS FAR PASCAL OleUpdate (lpobj)
LPOLEOBJECT lpobj;
{

    Puts("OleUpdate");

    if (!CheckObject(lpobj))
        return(OLE_ERROR_OBJECT);

    return (*lpobj->lpvtbl->Update) (lpobj);

}


/***************************** Public  Function ****************************\
*
* OLESTATUS FAR PASCAL OleReconnect (lpobj)
*
* Reconnects to the renderer if one does not exist already.
*
* History:
* Wrote it.
\***************************************************************************/

OLESTATUS FAR PASCAL OleReconnect (lpobj)
LPOLEOBJECT lpobj;
{
    Puts("OleReconnect");

    if (!CheckObject(lpobj))
        return(OLE_ERROR_OBJECT);

    return (*lpobj->lpvtbl->Reconnect) (lpobj);
}


OLESTATUS FAR PASCAL OleGetLinkUpdateOptions (lpobj, lpOptions)
LPOLEOBJECT         lpobj;
OLEOPT_UPDATE FAR * lpOptions;
{
    Puts("OleGetLinkUpdateOptions");

    if (!CheckObject(lpobj))
        return(OLE_ERROR_OBJECT);

    PROBE_WRITE(lpOptions);
    
    return (*lpobj->lpvtbl->GetLinkUpdateOptions) (lpobj, lpOptions);
}



OLESTATUS FAR PASCAL OleSetLinkUpdateOptions (lpobj, options)
LPOLEOBJECT         lpobj;
OLEOPT_UPDATE       options;
{
    Puts("OleSetLinkUpdateOptions");
        
    if (!CheckObject(lpobj))
        return(OLE_ERROR_OBJECT);

    return (*lpobj->lpvtbl->SetLinkUpdateOptions) (lpobj, options);

}




/***************************** Public  Function ****************************\
* OLESTATUS FAR PASCAL OleEnumFormats (lpobj, cfFormat)
*
* Returns OLE_YES if the object is of type LINK or EMBEDDED.
*
* Effects:
*
* History:
* Wrote it.
\***************************************************************************/

OLECLIPFORMAT FAR PASCAL OleEnumFormats (lpobj, cfFormat)
LPOLEOBJECT     lpobj;
OLECLIPFORMAT   cfFormat;
{
    Puts("OleEnumFormats");

    if (!CheckObject(lpobj))
        return NULL;

    return (*lpobj->lpvtbl->EnumFormats) (lpobj, cfFormat);
}

OLESTATUS FAR PASCAL OleRequestData (lpobj, cfFormat)
LPOLEOBJECT     lpobj;
OLECLIPFORMAT   cfFormat;
{
    Puts("OleGetData");

    if (!CheckObject(lpobj))
        return(OLE_ERROR_OBJECT);

    if (!cfFormat)
        return OLE_ERROR_FORMAT;
    
    return (*lpobj->lpvtbl->RequestData) (lpobj, cfFormat);
}


OLESTATUS FAR PASCAL OleGetData (lpobj, cfFormat, lphandle)
LPOLEOBJECT     lpobj;
OLECLIPFORMAT   cfFormat;
LPHANDLE        lphandle;
{
    Puts("OleGetData");

    if (!CheckObject(lpobj))
        return(OLE_ERROR_OBJECT);

    PROBE_WRITE(lphandle);
    
    return (*lpobj->lpvtbl->GetData) (lpobj, cfFormat, lphandle);
}


OLESTATUS FAR PASCAL OleSetData (lpobj, cfFormat, hData)
LPOLEOBJECT     lpobj;
OLECLIPFORMAT   cfFormat;
HANDLE          hData;
{
    Puts("OleSetData");

    if (!CheckObject(lpobj))
        return(OLE_ERROR_OBJECT);

    return (*lpobj->lpvtbl->SetData) (lpobj, cfFormat, hData);
}



OLESTATUS FAR PASCAL OleQueryOutOfDate (lpobj)
LPOLEOBJECT lpobj;
{
    if (!CheckObject(lpobj))
        return(OLE_ERROR_OBJECT);

    return (*lpobj->lpvtbl->QueryOutOfDate) (lpobj);
}


OLESTATUS FAR PASCAL OleLockServer (lpobjsrc, lplhsrvr)
LPOLEOBJECT     lpobjsrc;
LHSERVER FAR *  lplhsrvr;
{
    LPOBJECT_LE lpobj;
    OLESTATUS   retVal = OLE_OK;
    ATOM        aCliClass, aSvrClass;
    
    Puts ("OleLockServer");
    
    if (!FarCheckObject(lpobjsrc))
        return OLE_ERROR_OBJECT;    

    if (lpobjsrc->ctype == CT_STATIC)
        return OLE_ERROR_STATIC;
    
    // Assumes all the creates are in order
    PROBE_CREATE_ASYNC(((LPOBJECT_LE)lpobjsrc));
    FARPROBE_WRITE(lplhsrvr);

    aCliClass = ((LPCLIENTDOC)(lpobjsrc->lhclientdoc))->aClass;
    aSvrClass = ((LPOBJECT_LE)lpobjsrc)->app;

    // See whether the server is already locked
    lpobj = (LPOBJECT_LE) (lockDoc.lpHeadObj);
    while (lpobj) {
        if ((lpobj->app == aSvrClass) && (lpobj->topic == aCliClass)) {
            if (!lpobj->head.cx) {
                // The unlocking process of server handle has started. This
                // is an asynchronous process. We want to let it complete. 
                // Let's try the next handle
                    
                ;
            }
            else {
                if (!IsServerValid (lpobj)) {
                    DeleteSrvrEdit (lpobj); 
                    retVal = LockServer (lpobj);
                }
                else {
                    // Lock count
                    lpobj->head.cx++;   
                }

                if (retVal == OLE_OK) 
                    *lplhsrvr = (LHSERVER) lpobj;
            
                return retVal;
            }
        }
        
        lpobj = (LPOBJECT_LE) (lpobj->head.lpNextObj);            
    }
    
    
    if (!(lpobj = LeCreateBlank(lhLockDoc, NULL, OT_EMBEDDED)))
        return OLE_ERROR_MEMORY;

    lpobj->head.lpclient    = NULL;
    lpobj->head.lpvtbl      = lpobjsrc->lpvtbl;
    lpobj->app              = DuplicateAtom (aSvrClass);
    lpobj->topic            = DuplicateAtom (aCliClass);
    lpobj->aServer          = DuplicateAtom(((LPOBJECT_LE)lpobjsrc)->aServer);
    lpobj->bOleServer       = ((LPOBJECT_LE)lpobjsrc)->bOleServer;
    
    if ((retVal = LockServer (lpobj)) == OLE_OK) {
        // Change signature
        lpobj->head.objId[0] = 'S';
        lpobj->head.objId[1] = 'L';
        *lplhsrvr = (LHSERVER) lpobj;
    }
    else {
        LeRelease (lpobj);
    }
    
    return retVal;
}


OLESTATUS INTERNAL LockServer (lpobj)
LPOBJECT_LE lpobj;
{
    HANDLE hInst;
    
    if (!InitSrvrConv (lpobj, NULL)) {
        if (!lpobj->bOleServer)
            lpobj->fCmd = ACT_MINIMIZE;
        else
            lpobj->fCmd = NULL;
        
        if (!(hInst = LeLaunchApp (lpobj))) 
            return OLE_ERROR_LAUNCH;
        
        if (!InitSrvrConv (lpobj, hInst))
            return OLE_ERROR_COMM;

    }

    // lock count
    lpobj->head.cx++; 
    return OLE_OK;
}


OLESTATUS FAR PASCAL OleUnlockServer (lhsrvr)
LHSERVER lhsrvr;
{
    LPOBJECT_LE lpobj;
    OLESTATUS   retval;
    
    Puts ("OleUnlockServer");

    if (!FarCheckPointer ((lpobj = (LPOBJECT_LE)lhsrvr), WRITE_ACCESS))
        return OLE_ERROR_HANDLE;
    
    if (lpobj->head.objId[0] != 'S' || lpobj->head.objId[1] != 'L')
        return OLE_ERROR_HANDLE;

    if (!lpobj->head.cx)
        return OLE_OK;
    
    if (--lpobj->head.cx)
        return OLE_OK;
    
    //change signature 
    lpobj->head.objId[0] = 'L';
    lpobj->head.objId[1] = 'E';
    
    if ((retval = LeRelease (lpobj)) == OLE_WAIT_FOR_RELEASE)
        DocDeleteObject ((LPOLEOBJECT)lpobj);
    
    return retval;
}


OLESTATUS FAR PASCAL OleObjectConvert (lpobj, lpprotocol, lpclient, lhclientdoc, lpobjname, lplpobj)
LPOLEOBJECT         lpobj;
LPSTR               lpprotocol;
LPOLECLIENT         lpclient;
LHCLIENTDOC         lhclientdoc;
LPSTR               lpobjname;
LPOLEOBJECT FAR *   lplpobj;    
{
    if (!CheckObject(lpobj))
        return(OLE_ERROR_OBJECT);

    if (!CheckClientDoc ((LPCLIENTDOC) lhclientdoc))
        return OLE_ERROR_HANDLE;
    
    PROBE_READ(lpprotocol);
    PROBE_WRITE(lplpobj);
    
#ifdef FIREWALLS    
    ASSERT (lpobjname, "NULL lpobjname passed to OleObjectConvert\n");
#endif
    
    PROBE_READ(lpobjname);
    if (!lpobjname[0])
        return OLE_ERROR_NAME;    


    return (*lpobj->lpvtbl->ObjectConvert) (lpobj, lpprotocol, lpclient, 
                    lhclientdoc, lpobjname, lplpobj);
}


//OleCreateFromTemplate: Creates an embedded object from Template

OLESTATUS FAR PASCAL OleCreateFromTemplate (lpprotocol, lpclient, lptemplate, lhclientdoc, lpobjname, lplpoleobject, optRender, cfFormat )
LPSTR               lpprotocol;
LPOLECLIENT         lpclient;
LPSTR               lptemplate;
LHCLIENTDOC         lhclientdoc;
LPSTR               lpobjname;
LPOLEOBJECT FAR *   lplpoleobject;
OLEOPT_RENDER       optRender;
OLECLIPFORMAT       cfFormat;
{
    OLESTATUS   retval = OLE_ERROR_MEMORY;
    char        buf[MAX_STR];
    int         objCount;
    int         iTable = INVALID_INDEX;

    Puts("OleCreateFromTemplate");

    PROBE_MODE(bProtMode);

    if (!CheckClientDoc ((LPCLIENTDOC) lhclientdoc))
        return OLE_ERROR_HANDLE;
    
    PROBE_READ(lpprotocol);
    PROBE_READ(lpclient);
    PROBE_READ(lptemplate);
    PROBE_WRITE(lplpoleobject);

#ifdef FIREWALLS    
    ASSERT (lpobjname, "NULL lpobjname passed to OleCreateFromTemplate\n");
#endif

    PROBE_READ(lpobjname);
    if (!lpobjname[0])
        return OLE_ERROR_NAME;    
    
    if (lstrcmpi (lpprotocol, PROTOCOL_EDIT))
        return OLE_ERROR_PROTOCOL;

    if (!MapExtToClass (lptemplate, (LPSTR)buf, MAX_STR))
        return OLE_ERROR_CLASS;


    // !!! we found the class name. At this point, we need to load
    // the right library and call the right entry point;

    iTable = LoadDll ((LPSTR)buf);
    if (iTable == INVALID_INDEX)
        retval = DefCreateFromTemplate (lpprotocol, lpclient, lptemplate, 
                            lhclientdoc, lpobjname, lplpoleobject, 
                            optRender, cfFormat);
    else { 
        objCount = lpDllTable[iTable].cObj;
        retval   = (*lpDllTable[iTable].CreateFromTemplate) (lpprotocol, 
                                lpclient, lptemplate, 
                                lhclientdoc, lpobjname, lplpoleobject, 
                                optRender, cfFormat);
        if (retval > OLE_WAIT_FOR_RELEASE)
            lpDllTable[iTable].cObj = objCount - 1;
        else
            (*lplpoleobject)->iTable = iTable;
    }

    return retval;
}


//OleCreate: Creates an embedded object from the class.

OLESTATUS FAR PASCAL OleCreate (lpprotocol, lpclient, lpclass, lhclientdoc, lpobjname, lplpoleobject, optRender, cfFormat)
LPSTR               lpprotocol;
LPOLECLIENT         lpclient;
LPSTR               lpclass;
LHCLIENTDOC         lhclientdoc;
LPSTR               lpobjname;
LPOLEOBJECT FAR *   lplpoleobject;
OLEOPT_RENDER       optRender;
OLECLIPFORMAT       cfFormat;
{
    OLESTATUS   retval = OLE_ERROR_MEMORY;
    int         objCount;
    int         iTable = INVALID_INDEX;


    Puts("OleCreate");

    PROBE_MODE(bProtMode);

    if (!CheckClientDoc ((LPCLIENTDOC) lhclientdoc))
        return OLE_ERROR_HANDLE;
    
    PROBE_READ(lpprotocol);
    PROBE_READ(lpclient);
    PROBE_READ(lpclass);
    PROBE_WRITE(lplpoleobject);

#ifdef FIREWALLS    
    ASSERT (lpobjname, "NULL lpobjname passed to OleCreate\n");
#endif

    PROBE_READ(lpobjname);
    if (!lpobjname[0])
        return OLE_ERROR_NAME;    

    if (lstrcmpi (lpprotocol, PROTOCOL_EDIT))
        return OLE_ERROR_PROTOCOL;

    iTable = LoadDll (lpclass);
    if (iTable == INVALID_INDEX)
        retval = DefCreate (lpprotocol, lpclient, lpclass, 
                        lhclientdoc, lpobjname, lplpoleobject, 
                        optRender, cfFormat);
    else { 
        objCount = lpDllTable[iTable].cObj;
        retval   = (*lpDllTable[iTable].Create) (lpprotocol, 
                            lpclient, lpclass, 
                            lhclientdoc, lpobjname, lplpoleobject, 
                            optRender, cfFormat);
        if (retval > OLE_WAIT_FOR_RELEASE)
            lpDllTable[iTable].cObj = objCount - 1;
        else
            (*lplpoleobject)->iTable = iTable;
    }

    return retval;
}



//////////////////////////////////////////////////////////////////////////////
//
// OLESTATUS FAR PASCAL OleCreateInvisible (lpprotocol, lpclient, lpclass, lhclientdoc, lpobjname, lplpoleobject, optRender, cfFormat, bLaunchServer)
//
// Creates an embedded object from the class.
//
//  Arguments:
//
//     lpprotocol   -   
//     lpclient -   
//     lpclass  -   
//     lhclientdoc  -   
//     lpobjname    -   
//     lplpoleobject    -   
//     optRender    -   
//     cfFormat -
//     bLaunchServer -
//
//  Returns:
//
//      OLE_ERROR_HANDLE    -   
//      OLE_ERROR_NAME      -   
//      OLE_ERROR_PROTOCOL  -   
//
//  Effects:
//
//////////////////////////////////////////////////////////////////////////////

OLESTATUS FAR PASCAL OleCreateInvisible (lpprotocol, lpclient, lpclass, lhclientdoc, lpobjname, lplpoleobject, optRender, cfFormat, bLaunchServer)
LPSTR               lpprotocol;
LPOLECLIENT         lpclient;
LPSTR               lpclass;
LHCLIENTDOC         lhclientdoc;
LPSTR               lpobjname;
LPOLEOBJECT FAR *   lplpoleobject;
OLEOPT_RENDER       optRender;
OLECLIPFORMAT       cfFormat;
BOOL                bLaunchServer;
{
    OLESTATUS   retval = OLE_ERROR_MEMORY;
    int         objCount;
    int         iTable = INVALID_INDEX;


    Puts("OleCreateInvisible");

    PROBE_MODE(bProtMode);

    if (!CheckClientDoc ((LPCLIENTDOC) lhclientdoc))
        return OLE_ERROR_HANDLE;
    
    PROBE_READ(lpprotocol);
    PROBE_READ(lpclient);
    PROBE_READ(lpclass);
    PROBE_WRITE(lplpoleobject);

#ifdef FIREWALLS    
    ASSERT (lpobjname, "NULL lpobjname passed to OleCreate\n");
#endif

    PROBE_READ(lpobjname);
    if (!lpobjname[0])
        return OLE_ERROR_NAME;    

    if (lstrcmpi (lpprotocol, PROTOCOL_EDIT))
        return OLE_ERROR_PROTOCOL;

    iTable = LoadDll (lpclass);
    if (iTable == INVALID_INDEX) {
        retval = DefCreateInvisible (lpprotocol, lpclient, lpclass, 
                            lhclientdoc, lpobjname, lplpoleobject, 
                            optRender, cfFormat, bLaunchServer);
    }
    else {
        objCount = lpDllTable[iTable].cObj;
        
        if (!(lpDllTable[iTable].CreateInvisible)) {
            // dll didn't export this function. Lets call DllCreate, so that
            // handler will get a chance to replace the methods. The flag is
            // used to tell the internal functions that this call infact wants
            // to achieve the effect of CreateInvisble.
            gbCreateInvisible = TRUE;
            gbLaunchServer = bLaunchServer;
            retval = (*lpDllTable[iTable].Create) (lpprotocol, 
                                    lpclient, lpclass,
                                    lhclientdoc, lpobjname, lplpoleobject, 
                                    optRender, cfFormat);
            gbCreateInvisible = FALSE;
        }
        else {
            retval   = (*lpDllTable[iTable].CreateInvisible) (lpprotocol, 
                                    lpclient, lpclass, 
                                    lhclientdoc, lpobjname, lplpoleobject, 
                                    optRender, cfFormat, bLaunchServer);
        }
        
        if (retval > OLE_WAIT_FOR_RELEASE)
            lpDllTable[iTable].cObj = objCount - 1;
        else
            (*lplpoleobject)->iTable = iTable;
    }

    return retval;
}


//OleCreateFromFile: Creates an embedded object from file

OLESTATUS FAR PASCAL OleCreateFromFile (lpprotocol, lpclient, lpclass, lpfile, lhclientdoc, lpobjname, lplpoleobject, optRender, cfFormat )
LPSTR               lpprotocol;
LPOLECLIENT         lpclient;
LPSTR               lpclass;
LPSTR               lpfile;
LHCLIENTDOC         lhclientdoc;
LPSTR               lpobjname;
LPOLEOBJECT FAR *   lplpoleobject;
OLEOPT_RENDER       optRender;
OLECLIPFORMAT       cfFormat;
{
    OLESTATUS   retval = OLE_ERROR_MEMORY;
    char        buf[MAX_STR];
    int         objCount;
    int         iTable = INVALID_INDEX;

    Puts("OleCreateFromFile");

    PROBE_MODE(bProtMode);

    if (!CheckClientDoc ((LPCLIENTDOC) lhclientdoc))
        return OLE_ERROR_HANDLE;
    
    PROBE_READ(lpprotocol);
    PROBE_READ(lpclient);
    PROBE_READ(lpfile);
    PROBE_WRITE(lplpoleobject);

#ifdef FIREWALLS    
    ASSERT (lpobjname, "NULL lpobjname passed to OleCreateFromFile\n");
#endif

    PROBE_READ(lpobjname);
    if (!lpobjname[0])
        return OLE_ERROR_NAME;    
    if (lpclass)
        PROBE_READ(lpclass);

    if (lstrcmpi (lpprotocol, PROTOCOL_EDIT))
        return OLE_ERROR_PROTOCOL;

    if (lpclass) {
        if (!QueryApp (lpclass, lpprotocol, buf))
            return OLE_ERROR_CLASS;
        
        if (!lstrcmp (lpclass, packageClass))
            iTable = INVALID_INDEX;
        else
            iTable = LoadDll (lpclass);
    }
    else if (MapExtToClass (lpfile, (LPSTR)buf, MAX_STR))
        iTable = LoadDll (buf);
    else
        return OLE_ERROR_CLASS;

    if (iTable == INVALID_INDEX)
        retval = DefCreateFromFile (lpprotocol, 
                            lpclient, lpclass, lpfile,
                            lhclientdoc, lpobjname, lplpoleobject, 
                            optRender, cfFormat);
    else { 
        objCount = lpDllTable[iTable].cObj;
        retval   = (*lpDllTable[iTable].CreateFromFile) (lpprotocol, 
                                lpclient, lpclass, lpfile,
                                lhclientdoc, lpobjname, lplpoleobject, 
                                optRender, cfFormat);
        if (retval > OLE_WAIT_FOR_RELEASE)
            lpDllTable[iTable].cObj = objCount - 1;
        else
            (*lplpoleobject)->iTable = iTable;
    }

    return retval;
}


//OleCreateLinkFromFile: Creates a linked object from file

OLESTATUS FAR PASCAL OleCreateLinkFromFile (lpprotocol, lpclient, lpclass, lpfile, lpitem, lhclientdoc, lpobjname, lplpoleobject, optRender, cfFormat )
LPSTR               lpprotocol;
LPOLECLIENT         lpclient;
LPSTR               lpclass;
LPSTR               lpfile;
LPSTR               lpitem;
LHCLIENTDOC         lhclientdoc;
LPSTR               lpobjname;
LPOLEOBJECT FAR *   lplpoleobject;
OLEOPT_RENDER       optRender;
OLECLIPFORMAT       cfFormat;
{
    OLESTATUS   retval = OLE_ERROR_MEMORY;
    char        buf[MAX_STR+6];
    int         objCount;
    int         iTable = INVALID_INDEX;

    Puts("OleCreateLinkFromFile");

    PROBE_MODE(bProtMode);

    if (!CheckClientDoc ((LPCLIENTDOC) lhclientdoc))
        return OLE_ERROR_HANDLE;
    
    PROBE_READ(lpprotocol);
    PROBE_READ(lpclient);
    PROBE_READ(lpfile);
    PROBE_WRITE(lplpoleobject);

#ifdef FIREWALLS    
    ASSERT (lpobjname, "NULL lpobjname passed to OleCreateLinkFromFile\n");
#endif

    PROBE_READ(lpobjname);
    if (!lpobjname[0])
        return OLE_ERROR_NAME;    
    if (lpclass)
        PROBE_READ(lpclass);
    if (lpitem)
        PROBE_READ(lpitem);

    if (lstrcmpi (lpprotocol, PROTOCOL_EDIT))
        return OLE_ERROR_PROTOCOL;

    if (lpclass) {
        if (!QueryApp (lpclass, lpprotocol, buf))
            return OLE_ERROR_CLASS;

        if (!lstrcmp (lpclass, packageClass)) {
            lstrcpy (buf, lpfile);
            lstrcat (buf, "/Link");
            return  CreateEmbLnkFromFile (lpclient, packageClass, buf, 
                                NULL, lhclientdoc, lpobjname, lplpoleobject, 
                                optRender, cfFormat, OT_EMBEDDED);
        }
        else        
            iTable = LoadDll (lpclass);
    }
    else if (MapExtToClass (lpfile, (LPSTR)buf, MAX_STR))
        iTable = LoadDll (buf);
    else
        return OLE_ERROR_CLASS;

    if (iTable == INVALID_INDEX)
        retval = DefCreateLinkFromFile (lpprotocol, 
                            lpclient, lpclass, lpfile, lpitem,
                            lhclientdoc, lpobjname, lplpoleobject, 
                            optRender, cfFormat);

    else { 
        objCount = lpDllTable[iTable].cObj;
        retval   = (*lpDllTable[iTable].CreateLinkFromFile) (lpprotocol, 
                                lpclient, lpclass, lpfile, lpitem,
                                lhclientdoc, lpobjname, lplpoleobject, 
                                optRender, cfFormat);
        if (retval > OLE_WAIT_FOR_RELEASE)
            lpDllTable[iTable].cObj = objCount - 1;
        else
            (*lplpoleobject)->iTable = iTable;
    }

    return retval;
}



// Routines related to asynchronous operations.
OLESTATUS   FAR PASCAL  OleQueryReleaseStatus (lpobj)
LPOLEOBJECT lpobj;
{
    if (!CheckPointer (lpobj, WRITE_ACCESS))
        return OLE_ERROR_OBJECT;

    // make sure that it is a long pointer to L&E object or a lock handle
    if (!(lpobj->objId[0] == 'L' && lpobj->objId[1] == 'E')
            && !(lpobj->objId[0] == 'S' && lpobj->objId[1] == 'L'))
        return OLE_ERROR_OBJECT;

    return (*lpobj->lpvtbl->QueryReleaseStatus) (lpobj);
}


OLESTATUS   FAR PASCAL  OleQueryReleaseError  (lpobj)
LPOLEOBJECT lpobj;
{
    if (!CheckObject(lpobj))
        return(OLE_ERROR_OBJECT);

    return (*lpobj->lpvtbl->QueryReleaseError) (lpobj);
}

OLE_RELEASE_METHOD FAR PASCAL OleQueryReleaseMethod (lpobj)
LPOLEOBJECT lpobj;
{
    if (!CheckObject(lpobj))
        return(OLE_ERROR_OBJECT);

    return (*lpobj->lpvtbl->QueryReleaseMethod) (lpobj);
}


OLESTATUS FAR PASCAL OleRename (lpobj, lpNewName)
LPOLEOBJECT lpobj;
LPSTR       lpNewName;
{
    if (!CheckObject(lpobj))
        return OLE_ERROR_OBJECT;

    return (*lpobj->lpvtbl->Rename) (lpobj, lpNewName); 
}


OLESTATUS FAR PASCAL OleExecute (lpobj, hCmds, wReserved)
LPOLEOBJECT lpobj;
HANDLE      hCmds;
WORD        wReserved;
{
    if (!CheckObject(lpobj))
        return OLE_ERROR_OBJECT;

    return (*lpobj->lpvtbl->Execute) (lpobj, hCmds, wReserved); 
}


OLESTATUS FAR PASCAL OleQueryName (lpobj, lpBuf, lpcbBuf)
LPOLEOBJECT lpobj;
LPSTR       lpBuf;
WORD FAR *  lpcbBuf;
{
    if (!CheckObject(lpobj))
        return OLE_ERROR_OBJECT;
    
    return (*lpobj->lpvtbl->QueryName) (lpobj, lpBuf, lpcbBuf); 
}

OLESTATUS FAR PASCAL OleQueryType (lpobj, lptype)
LPOLEOBJECT lpobj;
LPLONG      lptype;
{
    Puts("OleQueryType");

    if (!CheckObject(lpobj))
        return(OLE_ERROR_OBJECT);

    PROBE_WRITE(lptype);
    
    return (*lpobj->lpvtbl->QueryType) (lpobj, lptype);
}



DWORD FAR PASCAL OleQueryClientVersion ()
{
    return dwOleVer;
}


OLESTATUS INTERNAL LeQueryCreateFromClip (lpprotocol, optRender, cfFormat, cType)
LPSTR               lpprotocol;
OLEOPT_RENDER       optRender;
OLECLIPFORMAT       cfFormat;
LONG                cType;
{
    OLESTATUS   retVal = TRUE;
    BOOL        bEdit = FALSE, bStatic = FALSE;

    PROBE_MODE(bProtMode);
    PROBE_READ(lpprotocol);
    
    if (bEdit = !lstrcmpi (lpprotocol, PROTOCOL_EDIT)) {
        if (IsClipboardFormatAvailable (cfFileName))
            return OLE_OK;
        
        if (cType == CT_LINK)
            retVal = IsClipboardFormatAvailable (cfObjectLink);
#ifdef OLD      
                        || IsClipboardFormatAvailable (cfLink) ;
#endif
        else if (cType == CT_EMBEDDED) 
            retVal = IsClipboardFormatAvailable (cfOwnerLink);

        if (!retVal)
            return OLE_ERROR_FORMAT;
        
        if (optRender == olerender_none) 
            return OLE_OK;
    }
    else if (bStatic = !lstrcmpi (lpprotocol, PROTOCOL_STATIC)) {
        if (cType == CT_LINK)
            return OLE_ERROR_PROTOCOL;
        
        if (optRender == olerender_none) 
            return OLE_ERROR_FORMAT;  
    }
    else {
        return OLE_ERROR_PROTOCOL;
    }
    
    if (optRender == olerender_draw) {
        if (!IsClipboardFormatAvailable (CF_METAFILEPICT) &&
                !IsClipboardFormatAvailable (CF_DIB)      &&
                !IsClipboardFormatAvailable (CF_BITMAP)   &&
                !(bEdit && QueryHandler((cType == CT_LINK) ? cfObjectLink : cfOwnerLink)))
            return OLE_ERROR_FORMAT;
    }
    else if (optRender == olerender_format) {
        if (!IsClipboardFormatAvailable (cfFormat))
            return OLE_ERROR_FORMAT;
        
        if (bStatic && (cfFormat != CF_METAFILEPICT) 
                && (cfFormat != CF_DIB) && (cfFormat != CF_BITMAP))
            return OLE_ERROR_FORMAT;
            
    }
    else {
        return OLE_ERROR_FORMAT;
    }
        
    return OLE_OK;
}



BOOL INTERNAL CheckObject(lpobj)
LPOLEOBJECT lpobj;
{
    if (!CheckPointer(lpobj, WRITE_ACCESS))
        return FALSE;
    
    if (lpobj->objId[0] == 'L' && lpobj->objId[1] == 'E')
        return TRUE;
    
    return FALSE;
}

BOOL FARINTERNAL FarCheckObject(lpobj)
LPOLEOBJECT lpobj;
{
    return (CheckObject (lpobj));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\ole\client\pbhandlr.c ===
/****************************** Module Header ******************************\
* Module Name: Pbhandlr.C -- Native data based handler (for Pbrush server) 
*
* PURPOSE: Contains handler routines for Pbrush server. This handler makes
*   use of most of the standard library methods. It replaces only the "Draw",
*   "QueryBounds", "CopyToClipboard" methods of the OLE object. Note that this
*   handler draws the picture from the native data.
*
* Created: December 1990
*
* Copyright (c) 1990  Microsoft Corporation
*
* History:
*   SriniK  (../12/1990)    Original
*
\***************************************************************************/

#include <windows.h>
#include "dll.h"


OLESTATUS FAR PASCAL _loadds PbDraw (LPOLEOBJECT, HDC, LPRECT, LPRECT, HDC);
OLESTATUS FAR PASCAL _loadds PbQueryBounds (LPOLEOBJECT, LPRECT);
OLESTATUS FAR PASCAL _loadds PbCopyToClipboard (LPOLEOBJECT);
OLESTATUS FAR PASCAL _loadds PbGetData (LPOLEOBJECT, OLECLIPFORMAT, HANDLE FAR *);
OLECLIPFORMAT FAR PASCAL _loadds PbEnumFormats (LPOLEOBJECT, OLECLIPFORMAT);

extern OLESTATUS  FARINTERNAL wDibDraw (HANDLE, HDC, LPRECT, LPRECT, HDC, BOOL);


void    PbGetExtents (LPSTR, LPPOINT);
void    PbReplaceFunctions (LPOLEOBJECT);
HANDLE  PbGetPicture (LPOLEOBJECT);
BOOL    IsStandardPict (LPOLEOBJECT);

extern void FARINTERNAL DibGetExtents(LPSTR, LPPOINT);

OLEOBJECTVTBL   vtblDLL;

extern  OLECLIPFORMAT   cfOwnerLink;
extern  OLECLIPFORMAT   cfObjectLink;
extern  OLECLIPFORMAT   cfNative;

OLESTATUS (FAR PASCAL *DefQueryBounds)      (LPVOID, LPRECT);
OLESTATUS (FAR PASCAL *DefDraw)             (LPVOID, HDC, LPRECT, LPRECT, HDC);
OLESTATUS (FAR PASCAL *DefCopyToClipboard)  (LPVOID);
OLECLIPFORMAT (FAR PASCAL *DefEnumFormats)  (LPVOID, OLECLIPFORMAT);
OLESTATUS (FAR PASCAL *DefGetData)          (LPVOID, OLECLIPFORMAT, HANDLE FAR *);


OLESTATUS FAR PASCAL PbLoadFromStream (lpstream, lpprotocol, lpclient, lhclientdoc, lpobjname, lplpobj, objType, aClass, cfFormat)
LPOLESTREAM         lpstream;
LPSTR               lpprotocol;
LPOLECLIENT         lpclient;
LHCLIENTDOC         lhclientdoc;
LPSTR               lpobjname;
LPOLEOBJECT FAR *   lplpobj;
LONG                objType;
ATOM                aClass;
OLECLIPFORMAT       cfFormat;
{
    OLESTATUS   retVal;
    
    if (objType == OT_LINK) 
        retVal = DefLoadFromStream (lpstream, lpprotocol, lpclient, 
                        lhclientdoc, lpobjname, lplpobj, 
                        objType, aClass, cfNative);
    else
        retVal = DefLoadFromStream (lpstream, lpprotocol, lpclient, 
                        lhclientdoc, lpobjname, lplpobj, 
                        objType, aClass, cfFormat);
                    
    if (retVal <= OLE_WAIT_FOR_RELEASE)
        PbReplaceFunctions (*lplpobj);

    return retVal;
}



OLESTATUS FAR PASCAL PbCreateFromClip (lpprotocol, lpclient, lhclientdoc, lpobjname, lplpobj, optRender, cfFormat, objType)
LPSTR               lpprotocol;
LPOLECLIENT         lpclient;
LHCLIENTDOC         lhclientdoc;
LPSTR               lpobjname;
LPOLEOBJECT FAR *   lplpobj;
OLEOPT_RENDER       optRender;
OLECLIPFORMAT       cfFormat;
LONG                objType;
{
    OLESTATUS   retVal;
    
    if ((optRender == olerender_draw) 
            && (IsClipboardFormatAvailable (cfNative))) {       
        if (objType == OT_EMBEDDED) 
            retVal =  DefCreateFromClip (lpprotocol, lpclient, 
                                lhclientdoc, lpobjname, lplpobj, 
                                olerender_none, NULL, objType);
        else
            retVal =  DefCreateFromClip (lpprotocol, lpclient, 
                                lhclientdoc, lpobjname, lplpobj, 
                                olerender_format, cfNative, objType);
    }
    else {
        retVal = DefCreateFromClip (lpprotocol, lpclient, 
                            lhclientdoc, lpobjname, lplpobj, 
                            optRender, cfFormat, objType);
    }
    
    if (retVal <= OLE_WAIT_FOR_RELEASE)
        PbReplaceFunctions (*lplpobj);
        
    return retVal;
}



OLESTATUS FAR PASCAL PbCreateLinkFromClip (lpprotocol, lpclient, lhclientdoc, lpobjname, lplpobj, optRender, cfFormat)
LPSTR               lpprotocol;
LPOLECLIENT         lpclient;
LHCLIENTDOC         lhclientdoc;
LPSTR               lpobjname;
LPOLEOBJECT FAR *   lplpobj;
OLEOPT_RENDER       optRender;
OLECLIPFORMAT       cfFormat;
{
    OLESTATUS       retVal;

    if ((optRender == olerender_draw) 
            && (IsClipboardFormatAvailable (cfNative))) {
        retVal =  DefCreateLinkFromClip (lpprotocol, lpclient, 
                            lhclientdoc, lpobjname, lplpobj, 
                            olerender_format, cfNative);
    }
    else {
        retVal =  DefCreateLinkFromClip (lpprotocol, lpclient, 
                            lhclientdoc, lpobjname, lplpobj, 
                            optRender, cfFormat);       
    }
    
    if (retVal <= OLE_WAIT_FOR_RELEASE)
        PbReplaceFunctions (*lplpobj);

    return retVal;
}



OLESTATUS FAR PASCAL PbCreateFromTemplate (lpprotocol, lpclient, lptemplate, lhclientdoc, lpobjname, lplpobj, optRender, cfFormat)
LPSTR               lpprotocol;
LPOLECLIENT         lpclient;
LPSTR               lptemplate;
LHCLIENTDOC         lhclientdoc;
LPSTR               lpobjname;
LPOLEOBJECT FAR *   lplpobj;
OLEOPT_RENDER       optRender;
OLECLIPFORMAT       cfFormat;
{
    OLESTATUS   retVal;
    
    if (optRender == olerender_draw) 
        retVal =  DefCreateFromTemplate (lpprotocol, lpclient, lptemplate, 
                            lhclientdoc, lpobjname, lplpobj, 
                            olerender_none, NULL);

    else 
        retVal = DefCreateFromTemplate (lpprotocol, lpclient, lptemplate, 
                            lhclientdoc, lpobjname, lplpobj, 
                            optRender, cfFormat);
                        
    if (retVal <= OLE_WAIT_FOR_RELEASE)
        PbReplaceFunctions (*lplpobj);

    return retVal;                          
}



OLESTATUS FAR PASCAL PbCreate (lpprotocol, lpclient, lpclass, lhclientdoc, lpobjname, lplpobj, optRender, cfFormat)
LPSTR               lpprotocol;
LPOLECLIENT         lpclient;
LPSTR               lpclass;
LHCLIENTDOC         lhclientdoc;
LPSTR               lpobjname;
LPOLEOBJECT FAR *   lplpobj;
OLEOPT_RENDER       optRender;
OLECLIPFORMAT       cfFormat;
{
    OLESTATUS   retVal;
    
    if (optRender == olerender_draw)
        retVal = DefCreate (lpprotocol, lpclient, lpclass, 
                        lhclientdoc, lpobjname, lplpobj, 
                        olerender_none, NULL);
    else 
        retVal = DefCreate (lpprotocol, lpclient, lpclass, 
                        lhclientdoc, lpobjname, lplpobj, 
                        optRender, cfFormat);
                    
    if (retVal <= OLE_WAIT_FOR_RELEASE)
        PbReplaceFunctions (*lplpobj);

    return retVal;
}



OLESTATUS FAR PASCAL PbCreateFromFile (lpprotocol, lpclient, lpclass, lpfile, lhclientdoc, lpobjname, lplpobj, optRender, cfFormat)
LPSTR               lpprotocol;
LPOLECLIENT         lpclient;
LPSTR               lpclass;
LPSTR               lpfile;
LHCLIENTDOC         lhclientdoc;
LPSTR               lpobjname;
LPOLEOBJECT FAR *   lplpobj;
OLEOPT_RENDER       optRender;
OLECLIPFORMAT       cfFormat;
{
    OLESTATUS   retVal;
    
    if (optRender == olerender_draw) 
        retVal =  DefCreateFromFile (lpprotocol, lpclient, lpclass, lpfile, 
                            lhclientdoc, lpobjname, lplpobj, 
                            olerender_none, NULL);

    else 
        retVal = DefCreateFromFile (lpprotocol, lpclient, lpclass, lpfile, 
                            lhclientdoc, lpobjname, lplpobj, 
                            optRender, cfFormat);
                        
    if (retVal <= OLE_WAIT_FOR_RELEASE)
        PbReplaceFunctions (*lplpobj);

    return retVal;                          
}


OLESTATUS FAR PASCAL PbCreateLinkFromFile (lpprotocol, lpclient, lpclass, lpfile, lpitem, lhclientdoc, lpobjname, lplpobj, optRender, cfFormat)
LPSTR               lpprotocol;
LPOLECLIENT         lpclient;
LPSTR               lpclass;
LPSTR               lpfile;
LPSTR               lpitem;
LHCLIENTDOC         lhclientdoc;
LPSTR               lpobjname;
LPOLEOBJECT FAR *   lplpobj;
OLEOPT_RENDER       optRender;
OLECLIPFORMAT       cfFormat;
{
    OLESTATUS   retVal;
    
    if (optRender == olerender_draw) 
        retVal =  DefCreateLinkFromFile (lpprotocol, lpclient, 
                            lpclass, lpfile, lpitem,
                            lhclientdoc, lpobjname, lplpobj, 
                            olerender_format, cfNative);

    else 
        retVal = DefCreateLinkFromFile (lpprotocol, lpclient, 
                            lpclass, lpfile, lpitem,
                            lhclientdoc, lpobjname, lplpobj, 
                            optRender, cfFormat);
                        
    if (retVal <= OLE_WAIT_FOR_RELEASE)
        PbReplaceFunctions (*lplpobj);

    return retVal;                          
}



OLESTATUS FAR PASCAL PbCreateInvisible (lpprotocol, lpclient, lpclass, lhclientdoc, lpobjname, lplpobj, optRender, cfFormat, fActivate)
LPSTR               lpprotocol;
LPOLECLIENT         lpclient;
LPSTR               lpclass;
LHCLIENTDOC         lhclientdoc;
LPSTR               lpobjname;
LPOLEOBJECT FAR *   lplpobj;
OLEOPT_RENDER       optRender;
OLECLIPFORMAT       cfFormat;
BOOL                fActivate;
{
    OLESTATUS   retVal;
    
    if (optRender == olerender_draw)
        retVal = DefCreateInvisible (lpprotocol, lpclient, lpclass, 
                        lhclientdoc, lpobjname, lplpobj, 
                        olerender_none, NULL, fActivate);
    else 
        retVal = DefCreateInvisible (lpprotocol, lpclient, lpclass, 
                        lhclientdoc, lpobjname, lplpobj, 
                        optRender, cfFormat, fActivate);
                    
    if (retVal <= OLE_WAIT_FOR_RELEASE)
        PbReplaceFunctions (*lplpobj);

    return retVal;
}


void PbReplaceFunctions (lpobj)
LPOLEOBJECT lpobj;
{
    if (IsStandardPict (lpobj))
        return;
    
    vtblDLL = *lpobj->lpvtbl;
    lpobj->lpvtbl = (LPOLEOBJECTVTBL) &vtblDLL;
    
    DefDraw                         = lpobj->lpvtbl->Draw;
    DefQueryBounds                  = lpobj->lpvtbl->QueryBounds;
    DefCopyToClipboard              = lpobj->lpvtbl->CopyToClipboard;
    DefEnumFormats                  = lpobj->lpvtbl->EnumFormats;
    DefGetData                      = lpobj->lpvtbl->GetData;   
    
    lpobj->lpvtbl->Draw             = PbDraw;
    lpobj->lpvtbl->QueryBounds      = PbQueryBounds;
    lpobj->lpvtbl->CopyToClipboard  = PbCopyToClipboard;
    lpobj->lpvtbl->EnumFormats      = PbEnumFormats;    
    lpobj->lpvtbl->GetData          = PbGetData;        
}



OLESTATUS  FAR PASCAL _loadds PbQueryBounds (lpobj, lprc)
LPOLEOBJECT lpobj;
LPRECT      lprc;
{
    OLESTATUS   retVal;
    HANDLE      hData;
    LPSTR       lpData;
    POINT       point;

    if ((retVal = (*DefQueryBounds) (lpobj, lprc)) == OLE_OK) {
        if (lprc->top || lprc->bottom || lprc->right || lprc->left)
            return OLE_OK;
    }
    
    if ((*DefGetData) (lpobj, cfNative, &hData) != OLE_OK)
        return retVal;

    if (!hData)
        return OLE_ERROR_BLANK;     
            
    if (!(lpData = GlobalLock (hData)))
        return OLE_ERROR_MEMORY;

    DibGetExtents ((lpData+sizeof(BITMAPFILEHEADER)), &point);
    GlobalUnlock (hData);    
    
    lprc->left     = 0;
    lprc->top      = 0;
    lprc->right    = point.x;
    lprc->bottom   = point.y;
    
    return OLE_OK;      
}


OLESTATUS  FAR PASCAL _loadds PbDraw (lpobj, hdc, lprc, lpWrc, hdcTarget)
LPOLEOBJECT     lpobj;
HDC             hdc;
LPRECT          lprc;
LPRECT          lpWrc;
HDC             hdcTarget;
{
    HANDLE  hData;
    
    if ((*DefGetData) (lpobj, cfNative, &hData) != OLE_OK)
        return (*DefDraw) (lpobj, hdc, lprc, lpWrc, hdcTarget);

    return wDibDraw (hData, hdc, lprc, lpWrc, hdcTarget, TRUE);
}


OLECLIPFORMAT FAR PASCAL _loadds PbEnumFormats (lpobj, cfFormat)
LPOLEOBJECT     lpobj;
OLECLIPFORMAT   cfFormat;
{
    OLECLIPFORMAT   retFormat = NULL;

    if (cfFormat == CF_METAFILEPICT)
        return NULL;
    
    if (!(retFormat =  (*DefEnumFormats) (lpobj, cfFormat))) 
        return CF_METAFILEPICT;
    
    return retFormat;
}


OLESTATUS  FAR PASCAL _loadds PbGetData (lpobj, cfFormat, lpHandle)
LPOLEOBJECT     lpobj;
OLECLIPFORMAT   cfFormat;
HANDLE FAR *    lpHandle;
{
    OLESTATUS retval;
    
    retval = (*DefGetData) (lpobj, cfFormat, lpHandle);

    if (retval == OLE_OK || retval == OLE_BUSY || retval  == OLE_ERROR_BLANK)
        return retval;
    
    if (cfFormat == CF_METAFILEPICT) {
        if (*lpHandle = PbGetPicture (lpobj))
            return OLE_WARN_DELETE_DATA;
        
        return OLE_ERROR_MEMORY;
    }

    return OLE_ERROR_FORMAT;
}



OLESTATUS  FAR PASCAL _loadds PbCopyToClipboard (lpobj)
LPOLEOBJECT     lpobj;
{
    OLESTATUS   retVal;
    HANDLE      hPict;
    
    if ((retVal = (*DefCopyToClipboard) (lpobj)) == OLE_OK) {
        if (hPict = PbGetPicture (lpobj))
            SetClipboardData (CF_METAFILEPICT, hPict);        
        else
            retVal = OLE_ERROR_MEMORY;
    }
    
    return retVal;
}

HANDLE PbGetPicture (lpobj)
LPOLEOBJECT lpobj;
{
    HANDLE          hMF, hMfp, hData;
    RECT            rc = {0, 0, 0, 0};
    POINT           point;
    HDC             hMetaDC;
    LPMETAFILEPICT  lpmfp;
    OLESTATUS       retVal;
    LPSTR           lpData;
    
    if ((*DefGetData) (lpobj, cfNative, &hData) != OLE_OK)
        return NULL;
    
    if (!hData)
        return NULL;
            
    if (!(lpData = GlobalLock (hData)))
        return NULL;

    lpData += sizeof(BITMAPFILEHEADER);
    rc.right  = (int) ((LPBITMAPINFOHEADER)lpData)->biWidth;
    rc.bottom = (int) ((LPBITMAPINFOHEADER)lpData)->biHeight;
    DibGetExtents(lpData, &point);
    GlobalUnlock (hData);    
    
    if (!(hMetaDC = CreateMetaFile (NULL)))
        return NULL;
    
    SetWindowOrg (hMetaDC, 0, 0);
    SetWindowExt (hMetaDC, rc.right, rc.bottom);
    retVal = PbDraw (lpobj, hMetaDC, &rc, NULL, NULL);
    hMF = CloseMetaFile (hMetaDC);

    if (retVal != OLE_OK) 
        goto error;

    if (hMF && (hMfp = GlobalAlloc (GMEM_MOVEABLE, sizeof(METAFILEPICT)))
            && (lpmfp = (LPMETAFILEPICT) GlobalLock (hMfp))) {
        lpmfp->hMF = hMF;
        lpmfp->xExt = point.x;
        lpmfp->yExt = -point.y;
        lpmfp->mm   = MM_ANISOTROPIC;
        GlobalUnlock (hMfp);
        return hMfp;
    }

error:  

    if (hMF)
        DeleteMetaFile (hMF);
    
    if (hMfp)
        GlobalFree (hMfp);

    return NULL;
}


// normal handler can't do this. since this handler is part of olecli.dll, we
// we are doing this.

BOOL IsStandardPict (lpobj)
LPOLEOBJECT lpobj;
{
    LPOBJECT_LE lpLEobj;
    LONG        type;
    
    lpLEobj = (LPOBJECT_LE) lpobj;
    if (!lpLEobj->lpobjPict)
        return FALSE;
    
    if ((*lpLEobj->lpobjPict->lpvtbl->QueryType) (lpLEobj->lpobjPict, &type)
            == OLE_ERROR_GENERIC)
        return FALSE;
    
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\ole\client\net.c ===
/****************************** Module Header ******************************\
* Module Name: net.c 
*
* PURPOSE: Contains routines  network support
*
* Created: Feb 1991
*
* Copyright (c) 1991  Microsoft Corporation
*
* History:
*   Srinik  02\12\1190  Orginal
*
\***************************************************************************/

#include <windows.h>
#include <winnet.h>

#include "dll.h"

#define MAX_DRIVE   26

char    szNULL[] = "";
char    szSS[] = "SS";
char    szOffset[] = "OFFSET";


BOOL FAR PASCAL GetTaskVisibleWindow (HWND, DWORD);
void INTERNAL RemoveNetName (LPOBJECT_LE);

// Gets the drive letter from topic (if one exists) and then gets the remote
// name for that drive and then saves it in the object.

OLESTATUS FARINTERNAL SetNetName (lpobj)
LPOBJECT_LE lpobj;
{
    char    buf[MAX_STR];
    WORD    cbBuf = sizeof(buf);
    WORD    driveType;
    char    szDrive[3];
    
    if (lpobj->head.ctype == CT_EMBEDDED) 
        return OLE_OK;

    if (!GlobalGetAtomName (lpobj->topic, buf, cbBuf))
        return OLE_ERROR_BLANK;
    
    if (buf[1] != ':') {
        RemoveNetName (lpobj);
        return OLE_OK;
    }

    szDrive[2] = NULL;
    szDrive[1] = ':';
    szDrive[0] = buf[0];
    AnsiUpperBuff ((LPSTR) szDrive, 1);
        
    if (!(driveType = GetDriveType (szDrive[0] - 'A'))) {
        // drive is non existent
        return OLE_ERROR_DRIVE;
    }

    if  (driveType == DRIVE_REMOTE) {
         if (WNetGetConnection (szDrive, buf, (WORD FAR *) &cbBuf)
                    != WN_SUCCESS)
             return OLE_ERROR_DRIVE;
            
         lpobj->cDrive = szDrive[0];
         if (lpobj->aNetName)
             GlobalDeleteAtom (lpobj->aNetName);
         lpobj->aNetName = GlobalAddAtom(buf);
         lpobj->dwNetInfo = MAKELONG((WNetGetCaps (WNNC_NET_TYPE)),
                                     (WNetGetCaps (WNNC_DRIVER_VERSION)));
    } 
    else {
        RemoveNetName (lpobj);
    }

    return OLE_OK;
}


// If netname exists for the given object, then it makes sure that drive 
// in topic corresponds to the netname. If it's not the drive letter will
// be fixed by calling FixNet()

OLESTATUS FARINTERNAL CheckNetDrive (lpobj, fNetDlg)
LPOBJECT_LE lpobj;
BOOL        fNetDlg;
{
    char    buf[MAX_NET_NAME];   
    char    netName[MAX_NET_NAME];
    WORD    cbBuf = sizeof(buf);
    char    szDrive[3];
    
    if (lpobj->head.ctype == CT_EMBEDDED) 
        return OLE_OK;

    if (!lpobj->aNetName)
        return OLE_OK;

    if (!GlobalGetAtomName (lpobj->aNetName, netName, sizeof(netName)))
        return OLE_ERROR_MEMORY;
    
    szDrive[2] = NULL;
    szDrive[1] = ':';
    if (!(szDrive[0] = lpobj->cDrive)) {
        if (GlobalGetAtomName (lpobj->topic, buf, sizeof(buf)))
            szDrive[0] = lpobj->cDrive = buf[0];
    }
    
    if ((WNetGetConnection (szDrive, buf, (WORD FAR *) &cbBuf) 
            == WN_SUCCESS)  && (!lstrcmp(netName, buf)))
        return OLE_OK;

    return FixNet (lpobj, netName, fNetDlg);
}


// Find if there is a drive connected to the given server. If so, get the 
// drive letter and set it in topic. If not try to make connection, and if 
// that attempt is successful the set the drive letter in topic.

OLESTATUS INTERNAL FixNet (lpobj, lpNetName, fNetDlg)
LPOBJECT_LE lpobj;
LPSTR       lpNetName;
BOOL        fNetDlg;
{
    int         nDrive = 2;     // drive 'C'
    OLESTATUS   retVal;
    
    if (SetNextNetDrive(lpobj, &nDrive, lpNetName))
        return OLE_OK;
    
    if (fNetDlg != POPUP_NETDLG)
        return OLE_ERROR_NETWORK;
    
    if ((retVal = ConnectNet (lpobj, lpNetName)) == OLE_OK) {
        if (!ChangeTopic (lpobj))
            return OLE_ERROR_BLANK;
    }
    
    return retVal;
}



BOOL FARINTERNAL SetNextNetDrive (lpobj, lpnDrive, lpNetName)
LPOBJECT_LE lpobj;
int FAR *   lpnDrive;
LPSTR       lpNetName;
{
    char    buf[MAX_STR];
    WORD    cbBuf = sizeof(buf);
    char    szDrive[3];

    if (!lpNetName[0]) {
        if (!GlobalGetAtomName(lpobj->aNetName, lpNetName, MAX_STR))
            return FALSE;
    }
    
    szDrive[2] = NULL;
    szDrive[1] = ':';
    while (*lpnDrive < MAX_DRIVE) {
        if (GetDriveType (++*lpnDrive) == DRIVE_REMOTE) {
            szDrive[0] = (char) ('A' + *lpnDrive);
            cbBuf = sizeof(buf);            
            if ((WNetGetConnection (szDrive, buf, (WORD FAR *) &cbBuf)
                        == WN_SUCCESS) && (!lstrcmp(lpNetName, buf))) {
                lpobj->cDrive = szDrive[0];
                return ChangeTopic (lpobj);
            }
        }
    }
    
    return FALSE;
}


BOOL FARINTERNAL ChangeTopic (lpobj)
LPOBJECT_LE lpobj;
{
    char buf[MAX_STR];   
  
    if (!GlobalGetAtomName(lpobj->topic, buf, sizeof(buf)))
        return FALSE;
    if (lpobj->topic)
        GlobalDeleteAtom(lpobj->topic);
    buf[0] = lpobj->cDrive;
    lpobj->topic = GlobalAddAtom (buf);
    if (lpobj->hLink) {
        GlobalFree (lpobj->hLink);
        lpobj->hLink = NULL;
    }
    
    return TRUE;
}



OLESTATUS INTERNAL ConnectNet (lpobj, lpNetName)
LPOBJECT_LE lpobj;
LPSTR       lpNetName;
{
    FARPROC     lpConnectDlg;
    FARPROC     lpGetTaskVisWnd;
    OLESTATUS   retVal = OLE_ERROR_MEMORY;
    HWND        hCurTask;
    HWND        hwndParent = NULL;
    
    if (!(lpConnectDlg = MakeProcInstance ((FARPROC) ConnectDlgProc, 
                                    hInstDLL)))
        return OLE_ERROR_MEMORY;


    hCurTask = GetCurrentTask();
    ASSERT (hCurTask, "Current task handle in NULL");
    
    if (!(lpGetTaskVisWnd = MakeProcInstance (GetTaskVisibleWindow,hInstDLL)))
        goto errRtn;
    
    // Get the container task's main window, and use that as parent for
    // the dlg box.
    EnumTaskWindows (hCurTask, lpGetTaskVisWnd,
        (DWORD) ((WORD FAR *) &hwndParent));

    if (lpobj->cDrive = (char) DialogBoxParam (hInstDLL, "CONNECTDLG", 
                                    hwndParent, lpConnectDlg, 
                                    (DWORD) lpNetName)) 
        retVal = OLE_OK;
    else
        retVal = OLE_ERROR_NETWORK;

    FreeProcInstance (lpGetTaskVisWnd);
    
errRtn: 
    FreeProcInstance (lpConnectDlg);
    return retVal;
}



int FAR PASCAL ConnectDlgProc(HWND hDlg, WORD wMsg, WORD wParam, DWORD lParam)
{
    char            szPassword[32];
    char            szTitle[64];
    
    switch (wMsg) {
        case WM_INITDIALOG: 
            SetProp (hDlg, szSS, HIWORD (lParam));
            SetProp (hDlg, szOffset, LOWORD (lParam));
            FillDrives (hDlg);
            SetDlgItemText (hDlg, IDD_PATH, (LPSTR) lParam);
            break;
            
        case WM_COMMAND:
            switch (wParam) {

                case IDOK:
                {
                    WORD    cch = 128;
                    char    szMessage[128];
                    char    szDrive[3];    
                    LPSTR   lpNetName;
                    
                    GetDlgItemText(hDlg, IDD_DRIVE, szDrive, sizeof(szDrive));
                    GetDlgItemText(hDlg, IDD_PASSWORD, szPassword, 
                                sizeof(szPassword));
                    lpNetName = (LPSTR) MAKELONG(((WORD) GetProp (hDlg, szOffset)), ((WORD) GetProp (hDlg, szSS)));
                    wParam = WNetAddConnection (lpNetName, 
                                (LPSTR) szPassword, szDrive);
                            
                    if (wParam == WN_SUCCESS)  {
                        RemoveProp (hDlg, szSS);
                        RemoveProp (hDlg, szOffset);
                        EndDialog (hDlg, szDrive[0]);
                        return TRUE;
                    }

                    LoadString (hInstDLL, IDS_NETERR, szTitle, 
                        sizeof(szTitle));
                    if (WNetGetErrorText (wParam, szMessage, &cch) 
                                    != WN_SUCCESS) 
                        LoadString (hInstDLL, IDS_NETCONERRMSG, 
                            szMessage, sizeof(szMessage));
                        
                    if (MessageBox (hDlg, szMessage, szTitle, 
                            MB_RETRYCANCEL | MB_SYSTEMMODAL) == IDCANCEL) 
                        goto error;

                    if (wParam == WN_ALREADY_CONNECTED)
                        FillDrives (hDlg);
                    SetDlgItemText (hDlg, IDD_PASSWORD, szNULL);
                    break;
                }

                case IDCANCEL:
error:                  
                    RemoveProp (hDlg, szSS);
                    RemoveProp (hDlg, szOffset);
                    EndDialog(hDlg, NULL);
                    return TRUE;

                case IDD_DRIVE:
                    break;

                case IDD_PATH:
                    if (HIWORD(lParam) == EN_KILLFOCUS) {
                        LPSTR   lpNetName;
                        
                        lpNetName = (LPSTR) MAKELONG(((WORD)GetProp (hDlg, szOffset)), ((WORD) GetProp (hDlg, szSS)));
                        
                        SendDlgItemMessage (hDlg, IDD_PATH, WM_SETTEXT, 0,
                                    (DWORD) lpNetName);
                    }
                    break;

                default:
                    break;
            }
            break;

        default:
            break;
    }
    
    return FALSE;
}


VOID INTERNAL FillDrives (hDlg)
HWND    hDlg;
{
    HWND    hwndCB;
    int     nDrive = 3;
    char    szDrive[3];

    hwndCB = GetDlgItem(hDlg, IDD_DRIVE); 
    SendMessage(hwndCB, CB_RESETCONTENT, 0, 0L);
    szDrive[2] = NULL;
    szDrive[1] = ':';
    while (nDrive < MAX_DRIVE) {
        szDrive[0] = (char) ('A' + nDrive); 
        if (!GetDriveType (nDrive))
            SendMessage(hwndCB, CB_ADDSTRING, 0, (DWORD)(LPSTR)szDrive);
        nDrive++;
    }
    SendMessage(hwndCB, CB_SETCURSEL, 0, 0L);
}


BOOL FAR PASCAL GetTaskVisibleWindow (hWnd, lpTaskVisWnd)
HWND    hWnd;
DWORD   lpTaskVisWnd; 
{
    if (IsWindowVisible (hWnd)) {
        *(WORD FAR *) lpTaskVisWnd = hWnd;
         return FALSE;
    }
    
    return TRUE;
}

void INTERNAL RemoveNetName (LPOBJECT_LE lpobj)
{
    if (lpobj->aNetName) {
        GlobalDeleteAtom (lpobj->aNetName);
        lpobj->aNetName = NULL;
    }
      
    lpobj->cDrive = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\ole\client\mf.c ===
/****************************** Module Header ******************************\
* Module Name:MF.C (Extensible Compound Documents - Metafile)
*
* PURPOSE:Handles all API routines for the metafile sub-dll of the ole dll.
*
* Created: 1990
*
* Copyright (c) 1990, 1991  Microsoft Corporation
*
* History:
*
*   Raor, Srinik    (../../1990,91)  Designed, coded
*
\***************************************************************************/

#include <windows.h>
#include "dll.h"
#include "pict.h"

WORD    wGDIds = NULL;

OLESTATUS FARINTERNAL wCreateDummyMetaFile (LPOBJECT_MF, int, int);

#pragma alloc_text(_TEXT, MfSaveToStream, MfLoadFromStream, GetBytes, PutBytes, PutStrWithLen, MfQueryBounds, OleIsDcMeta, GetGDIds, IsMetaDC)

OLEOBJECTVTBL    vtblMF = {

        ErrQueryProtocol,   // check whether the speced protocol is supported

        MfRelease,         // Release
        ErrShow,           // show
        ErrPlay,           // play
        MfGetData,         // Get the object data
        ErrSetData,        // Set the object data
        ErrSetTargetDevice,//
        ErrSetBounds,      // set viewport bounds
        MfEnumFormat,      // enumerate supported formats
        ErrSetColorScheme, //   
        MfRelease,         // delete
        ErrSetHostNames,   //
            
        MfSaveToStream,    // write to file
        MfClone,           // clone object
        ErrCopyFromLink,   // Create embedded from Lnk

        MfEqual,           // compares the given objects for data equality

        MfCopy,            // copy to clip

        MfDraw,            // draw the object

        ErrActivate,       // open
        ErrExecute,        // excute 
        ErrClose,          // stop 
        ErrUpdate,         // Update
        ErrReconnect,      // Reconnect

        ErrObjectConvert,  // convert object to specified type
            
        ErrGetUpdateOptions, // update options
        ErrSetUpdateOptions, // update options

        ObjRename,         // Change Object name
        ObjQueryName,      // Get current object name
        ObjQueryType,      // Object type
        MfQueryBounds,     // QueryBounds
        ObjQuerySize,      // Find the size of the object
        ErrQueryOpen,      // Query open
        ErrQueryOutOfDate, // query whether object is current
            
        ErrQueryRelease,      // release related stuff
        ErrQueryRelease,
        ErrQueryRelease,

        ErrRequestData,    // requestdata
        ErrObjectLong,     // objectLong
        MfChangeData       // change data of the existing object
};




OLESTATUS FARINTERNAL  MfRelease (lpobj)
LPOBJECT_MF lpobj;
{
    HOBJECT hobj;

    if (lpobj->mfp.hMF) {
        DeleteMetaFile (lpobj->mfp.hMF);
        lpobj->mfp.hMF = NULL;
    }
    
    if (lpobj->hmfp)
        GlobalFree (lpobj->hmfp);

    if (lpobj->head.lhclientdoc)
        DocDeleteObject ((LPOLEOBJECT)lpobj);
    
    if (hobj = lpobj->head.hobj) {
        lpobj->head.hobj = NULL;
        GlobalUnlock (hobj);
        GlobalFree (hobj);
    }

    return OLE_OK;
}


OLESTATUS FARINTERNAL  MfSaveToStream (lpobj, lpstream)
LPOBJECT_MF lpobj;
LPOLESTREAM lpstream;
{
    OLESTATUS   retVal = OLE_ERROR_STREAM;
    HANDLE      hBits;
    LPSTR       lpBits;
    
    if (!lpobj->mfp.hMF)
        return OLE_ERROR_BLANK;

    if (PutBytes (lpstream, (LPSTR) &dwVerToFile, sizeof(LONG)))
        return OLE_ERROR_STREAM;

    if (PutBytes (lpstream, (LPSTR) &lpobj->head.ctype, sizeof(LONG)))
        return  OLE_ERROR_STREAM;
    
    if (PutStrWithLen(lpstream, (LPSTR)"METAFILEPICT"))
        return  OLE_ERROR_STREAM;

    if (PutBytes (lpstream, (LPSTR) &lpobj->head.cx, sizeof(LONG))) 
        return  OLE_ERROR_STREAM;
    
    if (PutBytes (lpstream, (LPSTR) &lpobj->head.cy, sizeof(LONG)))
        return  OLE_ERROR_STREAM;
    
    if (PutBytes (lpstream, (LPSTR) &lpobj->sizeBytes, sizeof(LONG)))
        return  OLE_ERROR_STREAM;
    
    if (!(hBits = GetMetaFileBits (lpobj->mfp.hMF)))
        return OLE_ERROR_MEMORY;

    if (lpBits = (LPSTR) GlobalLock (hBits)) {
        if (!PutBytes (lpstream, (LPSTR)&lpobj->mfp, sizeof(METAFILEPICT)))
            if (!PutBytes (lpstream, (LPSTR)lpBits, 
                        lpobj->sizeBytes - sizeof(METAFILEPICT)))
                retVal = OLE_OK;

        GlobalUnlock(hBits);
    } 
    else
        retVal = OLE_ERROR_MEMORY;

    lpobj->mfp.hMF = SetMetaFileBits (hBits);
    return retVal;
}




OLESTATUS FARINTERNAL  MfClone (lpobjsrc, lpclient, lhclientdoc, lpobjname, lplpobj)
LPOBJECT_MF         lpobjsrc;
LPOLECLIENT         lpclient;
LHCLIENTDOC         lhclientdoc;
LPSTR               lpobjname;
LPOBJECT_MF  FAR *  lplpobj;
{
    LPOBJECT_MF lpobjMf;
    HANDLE      hmf;

    *lplpobj = NULL;
    
    if (!CheckClientDoc ((LPCLIENTDOC) lhclientdoc))
        return OLE_ERROR_HANDLE;
    
    if (!(hmf = CopyMetaFile (lpobjsrc->mfp.hMF, NULL)))
        return OLE_ERROR_MEMORY;

    if (lpobjMf = MfCreateBlank (lhclientdoc, lpobjname, 
                        lpobjsrc->head.ctype)) {
        lpobjMf->mfp            = lpobjsrc->mfp;
        lpobjMf->sizeBytes      = lpobjsrc->sizeBytes;
        lpobjMf->mfp.hMF        = hmf;
        lpobjMf->head.lpclient  = lpclient;
        lpobjMf->head.mm        = lpobjMf->mfp.mm;
        MfSetExtents (lpobjMf);

        *lplpobj = lpobjMf;
        return OLE_OK;
    }
    
    return OLE_ERROR_MEMORY;
}



OLESTATUS FARINTERNAL  MfEqual (lpobj1, lpobj2)
LPOBJECT_MF lpobj1;
LPOBJECT_MF lpobj2;
{
    HANDLE      hBits1 = NULL, hBits2 = NULL;
    OLESTATUS   retval = OLE_ERROR_NOT_EQUAL;
    
    if (!(hBits1 = GetMetaFileBits (lpobj1->mfp.hMF))) 
        goto errEqual;
    
    if (!(hBits2 = GetMetaFileBits (lpobj2->mfp.hMF)))
        goto errEqual;
    
    if (CmpGlobals (hBits1, hBits2))
        retval = OLE_OK;
    
errEqual:   
    if (hBits1)
        lpobj1->mfp.hMF = SetMetaFileBits (hBits1);
    
    if (hBits2)
        lpobj2->mfp.hMF = SetMetaFileBits (hBits2);     
    
    return retval;
}


OLESTATUS FARINTERNAL  MfCopy (LPOBJECT_MF lpobj)
{
    HANDLE          hMF;

    if (!(hMF = CopyMetaFile (lpobj->mfp.hMF, NULL)))
        return OLE_ERROR_MEMORY;

    return (MfCopyToClip (lpobj, hMF));
}



OLESTATUS FARINTERNAL MfQueryBounds (lpobj, lpRc)
LPOBJECT_MF     lpobj;
LPRECT          lpRc;
{
    Puts("MfQueryBounds");

    if (!lpobj->mfp.hMF)
        return OLE_ERROR_BLANK;
    
    // Bounds are given in MM_HIMETRIC mode. 
        
    lpRc->left      = 0;  
    lpRc->top       = 0;  
    lpRc->right     = (int) lpobj->head.cx;
    lpRc->bottom    = (int) lpobj->head.cy;
    return OLE_OK;
}



OLECLIPFORMAT FARINTERNAL  MfEnumFormat (lpobj, cfFormat)
LPOBJECT_MF     lpobj;
OLECLIPFORMAT   cfFormat;
{
    if (!cfFormat)
        return CF_METAFILEPICT;

    return NULL;
}


OLESTATUS FARINTERNAL MfGetData (lpobj, cfFormat, lphandle)
LPOBJECT_MF     lpobj;
OLECLIPFORMAT   cfFormat;
LPHANDLE        lphandle;
{
    if (cfFormat != CF_METAFILEPICT) 
        return OLE_ERROR_FORMAT;
    
    if (!(*lphandle = GetHmfp (lpobj)))
        return OLE_ERROR_BLANK;
    
    return OLE_OK;
}


LPOBJECT_MF FARINTERNAL  MfCreateObject (hMeta, lpclient, fDelete, lhclientdoc, lpobjname, objType)
HANDLE          hMeta;
LPOLECLIENT     lpclient;
BOOL            fDelete;
LHCLIENTDOC     lhclientdoc;
LPSTR           lpobjname;
LONG            objType;
{
    LPOBJECT_MF     lpobj;

    if (lpobj = MfCreateBlank (lhclientdoc, lpobjname, objType)) {
        if (MfChangeData (lpobj, hMeta, lpclient, fDelete) != OLE_OK) {
            MfRelease (lpobj);
            lpobj = NULL;
        }
    }
    
    return lpobj;
}

// If the routine fails then the object will be left with it's old data.
// If fDelete is TRUE, then hMeta, and the hMF it contains will be deleted
// whether the routine is successful or not.

OLESTATUS FARINTERNAL MfChangeData (lpobj, hMeta, lpclient, fDelete)
LPOBJECT_MF lpobj;
HANDLE      hMeta;
LPOLECLIENT lpclient;
BOOL        fDelete;
{
    HANDLE          hNewMF;
    LPMETAFILEPICT  lpMetaPict;
    
    if ((lpMetaPict = (LPMETAFILEPICT) GlobalLock (hMeta)) == NULL) {
        if (fDelete)
            GlobalFree (hMeta);
        return OLE_ERROR_MEMORY;
    }

    GlobalUnlock (hMeta);
    
    if (!fDelete) {
        if (!(hNewMF = CopyMetaFile (lpMetaPict->hMF, NULL)))
            return OLE_ERROR_MEMORY;
    }
    else {
        hNewMF = lpMetaPict->hMF;
    }
   
    return MfUpdateStruct (lpobj, lpclient, hMeta, lpMetaPict, hNewMF, fDelete);
}


OLESTATUS INTERNAL MfUpdateStruct (lpobj, lpclient, hMeta, lpMetaPict, hMF, fDelete)
LPOBJECT_MF     lpobj;
LPOLECLIENT     lpclient;
HANDLE          hMeta;
LPMETAFILEPICT  lpMetaPict;
HANDLE          hMF;
BOOL            fDelete;
{
    OLESTATUS   retVal;
    DWORD       size;
    HANDLE      hOldMF;

    hOldMF = lpobj->mfp.hMF;

    ASSERT(lpMetaPict->mm == MM_ANISOTROPIC, "Wrong mapping mode")
    if (lpMetaPict->mm != MM_ANISOTROPIC) 
        retVal = OLE_ERROR_METAFILE;
    else if (!(size = MfGetSize (&hMF))) 
        retVal = OLE_ERROR_BLANK;
    else {
        lpobj->mfp     = *lpMetaPict;
        lpobj->mfp.hMF = hMF;
        lpobj->sizeBytes = size + sizeof(METAFILEPICT);
        lpobj->head.lpclient = lpclient;
        lpobj->head.mm = lpobj->mfp.mm;
        if (lpobj->hmfp) {
            GlobalFree (lpobj->hmfp);
            lpobj->hmfp = NULL; 
        }
        MfSetExtents (lpobj);  
        if (hOldMF)
            DeleteMetaFile (hOldMF);
        retVal =  OLE_OK;
    }

    if (retVal != OLE_OK)
        DeleteMetaFile (hMF);

    if (fDelete)
        GlobalFree (hMeta);
    return retVal;
}


LPOBJECT_MF FARINTERNAL MfCreateBlank(lhclientdoc, lpobjname, objType)
LHCLIENTDOC lhclientdoc;
LPSTR       lpobjname;
LONG        objType;
{
    HOBJECT     hobj;
    LPOBJECT_MF lpobj;

    if(!(hobj = GlobalAlloc (GMEM_MOVEABLE|GMEM_ZEROINIT,sizeof (OBJECT_MF))))
        return NULL;

    if (!(lpobj = (LPOBJECT_MF) GlobalLock (hobj))){
        GlobalFree (hobj);
        return NULL;
    }

    lpobj->head.objId[0]    = 'L';
    lpobj->head.objId[1]    = 'E';
    lpobj->head.ctype       = objType;
    lpobj->head.lpvtbl      = (LPOLEOBJECTVTBL)&vtblMF;
    lpobj->head.iTable      = INVALID_INDEX;
    lpobj->head.mm          = MM_TEXT;
    lpobj->head.hobj        = hobj;

    if (objType == CT_STATIC)
        DocAddObject ((LPCLIENTDOC) lhclientdoc, 
                    (LPOLEOBJECT) lpobj, lpobjname);
                
    // Unlock will be done at object deletion time.
    return lpobj;
}


OLESTATUS  FARINTERNAL  MfLoadFromStream (lpstream, lpclient, lhclientdoc, lpobjname, lplpobj, objType)
LPOLESTREAM         lpstream;
LPOLECLIENT         lpclient;
LHCLIENTDOC         lhclientdoc;
LPSTR               lpobjname;
LPOLEOBJECT FAR *   lplpobj;
LONG                objType;
{
    LPOBJECT_MF lpobj = NULL;
    OLESTATUS   retVal = OLE_ERROR_STREAM;
    HANDLE      hBits;
    LPSTR       lpBits;
    DWORD       dwSizeMfp = NULL;
    
    // Class name would've been read by this time.
        
    *lplpobj = NULL;        
    
    if (!(lpobj = MfCreateBlank (lhclientdoc, lpobjname, objType)))
        return OLE_ERROR_MEMORY;

    lpobj->head.lpclient = lpclient;

    if (GetBytes (lpstream, (LPSTR) &lpobj->head.cx, sizeof(LONG)))
        goto errLoad;
    
    if (GetBytes (lpstream, (LPSTR) &lpobj->head.cy, sizeof(LONG))) 
        goto errLoad;
    
    if (GetBytes (lpstream, (LPSTR) &lpobj->sizeBytes, sizeof(LONG)))
        goto errLoad;
    
    if (!lpobj->sizeBytes) {
        retVal = OLE_ERROR_BLANK;
        goto errLoad;
    }

    // if we are reading a MAC object we want to skip this
    if (HIWORD(dwVerFromFile) == OS_WIN16) {
        if (GetBytes (lpstream, (LPSTR) &lpobj->mfp, sizeof(METAFILEPICT)))
            goto errLoad;
        
        dwSizeMfp = sizeof(METAFILEPICT);
    }
    
    retVal = OLE_ERROR_MEMORY;
    if (!(hBits = GlobalAlloc (GMEM_MOVEABLE, lpobj->sizeBytes - dwSizeMfp)))
        goto errLoad;
    
    if (!(lpBits = (LPSTR)GlobalLock (hBits))) 
        goto errMem;
    
    if (GetBytes (lpstream, (LPSTR)lpBits, lpobj->sizeBytes - dwSizeMfp)) {
        retVal = OLE_ERROR_MEMORY;
        GlobalUnlock (hBits);
        goto errMem;
    }
    
    lpobj->head.mm = lpobj->mfp.mm;
    GlobalUnlock (hBits);
    
    if (HIWORD(dwVerFromFile) == OS_WIN16) {
        if (!(lpobj->mfp.hMF = SetMetaFileBits (hBits)))
            goto errMem;
    }
    else {
        // if we are reading a MAC object we want to delete the original
        // presentation data and show some rectangle

        GlobalFree (hBits);
        lpobj->mfp.xExt = (int) lpobj->head.cx;
        lpobj->mfp.yExt = (int) lpobj->head.cy;
        
        if ((retVal = wCreateDummyMetaFile (lpobj, lpobj->mfp.xExt,
                                    lpobj->mfp.yExt)) != OLE_OK)
            goto errLoad;
    }
        
    MfSetExtents (lpobj);

    *lplpobj = (LPOLEOBJECT) lpobj;
    return OLE_OK;

errMem: 
    GlobalFree (hBits);
    
errLoad:    
    OleDelete ((LPOLEOBJECT)lpobj);
    return retVal;
}




OLESTATUS FARINTERNAL  MfPaste (lpclient, lhclientdoc, lpobjname, lplpoleobject, objType)
LPOLECLIENT         lpclient;
LHCLIENTDOC         lhclientdoc;
LPSTR               lpobjname;
LPOLEOBJECT FAR *   lplpoleobject;
LONG                objType;
{
    HANDLE      hMeta;

    *lplpoleobject = NULL;
    
    if((hMeta = GetClipboardData (CF_METAFILEPICT)) == NULL)
        return OLE_ERROR_MEMORY;

    if (!(*lplpoleobject = (LPOLEOBJECT) MfCreateObject (hMeta, lpclient, 
                                                FALSE, lhclientdoc, 
                                                lpobjname, objType)))
        return OLE_ERROR_MEMORY;

    return OLE_OK;
}




OLESTATUS INTERNAL MfCopyToClip (lpobj, hMF)
LPOBJECT_MF lpobj;
HANDLE      hMF;
{
    LPMETAFILEPICT  lpMeta;
    HANDLE          hMeta;
    
    if (!(hMeta = GlobalAlloc (GMEM_MOVEABLE, sizeof(METAFILEPICT))))
        return OLE_ERROR_MEMORY;

    if (lpMeta = (LPMETAFILEPICT) GlobalLock(hMeta)){
        *lpMeta = lpobj->mfp;
        if (hMF)
            lpMeta->hMF = hMF;
        else
            lpobj->mfp.hMF = NULL;
        GlobalUnlock (hMeta);
        SetClipboardData(CF_METAFILEPICT, hMeta);
        return OLE_OK;
    }
    
    GlobalFree(hMeta);
    return OLE_ERROR_MEMORY;
}



void FARINTERNAL MfSetExtents (LPOBJECT_MF lpobj)
{
    if (lpobj->mfp.xExt > 0) { 
        // The extents are assumed to be in MM_HIMETIRC units       
        lpobj->head.cx = (LONG) lpobj->mfp.xExt;
        lpobj->head.cy = (LONG) - lpobj->mfp.yExt;
    }
}


DWORD INTERNAL MfGetSize (lphmf)
LPHANDLE lphmf;
{
    HANDLE hBits;
    DWORD  size;
    
    if ((hBits = GetMetaFileBits (*lphmf)) == NULL)
        return NULL;
    
    size = GlobalSize(hBits);        
    *lphmf = SetMetaFileBits (hBits);       
    return size;
}



HANDLE INTERNAL GetHmfp (lpobj)
LPOBJECT_MF lpobj;
{
    HANDLE          hmfp;
    LPMETAFILEPICT  lpmfp = NULL;
    
    if (lpobj->hmfp)
        return lpobj->hmfp;
    
    if (!(hmfp = GlobalAlloc (GMEM_MOVEABLE, sizeof(METAFILEPICT))))
        return NULL;
    
    if (!(lpmfp = (LPMETAFILEPICT) GlobalLock (hmfp))) {
        GlobalFree (hmfp);
        return NULL;
    }   
    
    *lpmfp = lpobj->mfp;
    GlobalUnlock (hmfp);
    return (lpobj->hmfp = hmfp);
}


BOOL FAR PASCAL OleIsDcMeta (hdc)
HDC         hdc;
{
    if (!bWLO && (wWinVer == 0x0003)) {
        
        WORD    wDsAlias, wGDIcs = HIWORD(SaveDC);
        WORD    wOffset = LOWORD(((DWORD)SaveDC));
        WORD FAR PASCAL AllocCStoDSAlias (WORD);
        WORD FAR PASCAL FreeSelector (WORD);
        
        if (!wGDIds) {
            wDsAlias = AllocCStoDSAlias (wGDIcs);
            wGDIds = GetGDIds (MAKELONG(wOffset, wDsAlias));
            FreeSelector (wDsAlias);
        }
        
        return IsMetaDC (hdc, wGDIds);
    }
    else
        return (GetDeviceCaps (hdc, TECHNOLOGY) == DT_METAFILE);
}

OLESTATUS FARINTERNAL wCreateDummyMetaFile (
LPOBJECT_MF     lpobj,
int             xExt,
int             yExt)
{
    HDC hMetaDC;
    
    if (!(hMetaDC = CreateMetaFile (NULL)))
        return OLE_ERROR_MEMORY;
        
    SetWindowOrg (hMetaDC, 0, 0);
    SetWindowExt (hMetaDC, xExt, yExt);
    Rectangle (hMetaDC, 0, 0, xExt, yExt);
    if (!(lpobj->mfp.hMF = CloseMetaFile (hMetaDC)))
        return OLE_ERROR_MEMORY;
    lpobj->mfp.mm    = MM_ANISOTROPIC;
    lpobj->sizeBytes = MfGetSize (&lpobj->mfp.hMF) + sizeof(METAFILEPICT);
    return OLE_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\ole\client\pict.h ===
/****************************** Module Header ******************************\
* Module Name: pict.h
*
* PURPOSE: Private definitions file for presentation object related files
*
* Created: 1990
*
* Copyright (c) 1990, 1991  Microsoft Corporation
*
* History:
*  Raor, Srinik  (../../90,91)  Original
*
\***************************************************************************/


/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// Routines in MF.C                                                        //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////

OLESTATUS FARINTERNAL MfRelease (LPOBJECT_MF);
OLESTATUS FARINTERNAL MfSaveToStream (LPOBJECT_MF, LPOLESTREAM);
OLESTATUS FARINTERNAL MfClone (LPOBJECT_MF, LPOLECLIENT, LHCLIENTDOC, LPSTR, LPOBJECT_MF FAR *);
OLESTATUS FARINTERNAL MfEqual (LPOBJECT_MF, LPOBJECT_MF);
OLESTATUS FARINTERNAL MfCopy (LPOBJECT_MF);
OLESTATUS FARINTERNAL MfQueryBounds (LPOBJECT_MF, LPRECT);
OLESTATUS FARINTERNAL MfGetData (LPOBJECT_MF, OLECLIPFORMAT, LPHANDLE);
OLESTATUS FARINTERNAL MfSetData (LPOBJECT_MF, OLECLIPFORMAT, HANDLE);
OLESTATUS FARINTERNAL MfChangeData (LPOBJECT_MF, HANDLE, LPOLECLIENT, BOOL);
OLESTATUS INTERNAL    MfCopyToClip (LPOBJECT_MF, HANDLE);
void      FARINTERNAL MfSetExtents (LPOBJECT_MF);
DWORD     INTERNAL    MfGetSize (LPHANDLE);
HANDLE    INTERNAL    GetHmfp (LPOBJECT_MF);
OLESTATUS INTERNAL    MfUpdateStruct (LPOBJECT_MF, LPOLECLIENT, HANDLE, 
                            LPMETAFILEPICT, HANDLE, BOOL);
OLECLIPFORMAT FARINTERNAL MfEnumFormat (LPOBJECT_MF, OLECLIPFORMAT);




/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// Routines in DIB.C                                                       //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////

/* The DIB file will be of the following format:                        */
/*                                                                      */
/*      0004                                                            */
/*      "DIB"                                                           */
/*      4 bytes of xExtent in MM_HIMETIRC units (or) 0                  */
/*      4 bytes of yExtent in MM_HIMETIRC units (or) 0                  */
/*      4 bytes of size of (BITMAPINFOHEADER + RBGQUAD + bit array)     */
/*      BITMAPINFOHEADER structure                                      */
/*      RBGQUAD array                                                   */
/*      array of DI bits                                                */
/*                                                                      */

OLESTATUS FARINTERNAL DibRelease (LPOBJECT_DIB);
OLESTATUS FARINTERNAL DibSaveToStream (LPOBJECT_DIB, LPOLESTREAM);
OLESTATUS FARINTERNAL DibClone (LPOBJECT_DIB, LPOLECLIENT, LHCLIENTDOC, LPSTR, LPOBJECT_DIB FAR *);
OLESTATUS FARINTERNAL DibEqual (LPOBJECT_DIB, LPOBJECT_DIB);
OLESTATUS FARINTERNAL DibCopy (LPOBJECT_DIB);
OLESTATUS FARINTERNAL DibQueryBounds (LPOBJECT_DIB, LPRECT);
OLESTATUS FARINTERNAL DibGetData (LPOBJECT_DIB, OLECLIPFORMAT, LPHANDLE);
OLESTATUS FARINTERNAL DibChangeData (LPOBJECT_DIB, HANDLE, LPOLECLIENT, BOOL);
BOOL      INTERNAL    DibStreamRead (LPOLESTREAM,LPOBJECT_DIB);
void      INTERNAL    DibUpdateStruct (LPOBJECT_DIB, LPOLECLIENT, HANDLE, LPBITMAPINFOHEADER, DWORD);

OLECLIPFORMAT FARINTERNAL DibEnumFormat (LPOBJECT_DIB, OLECLIPFORMAT);




/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// Routines in BM.C                                                        //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////


/* The BM file will be of the following format:                         */
/*                                                                      */
/*      0007                                                            */
/*      "BITMAP"                                                        */
/*      4 bytes of xExtent in MM_HIMETIRC units (or) 0                  */
/*      4 bytes of yExtent in MM_HIMETIRC units (or) 0                  */
/*      4 bytes of size of (BITMAP + bits)                              */
/*      BITMAP structure                                                */
/*      bitmap bits                                                     */
/*                                                                      */

OLESTATUS FARINTERNAL BmRelease (LPOBJECT_BM);
OLESTATUS FARINTERNAL BmSaveToStream (LPOBJECT_BM, LPOLESTREAM);
OLESTATUS FARINTERNAL BmClone (LPOBJECT_BM, LPOLECLIENT, LHCLIENTDOC, LPSTR, LPOBJECT_BM FAR *);
OLESTATUS FARINTERNAL BmEqual (LPOBJECT_BM, LPOBJECT_BM);
OLESTATUS FARINTERNAL BmCopy (LPOBJECT_BM);
OLESTATUS FARINTERNAL BmQueryBounds (LPOBJECT_BM, LPRECT);
OLESTATUS FARINTERNAL BmGetData (LPOBJECT_BM, OLECLIPFORMAT, LPHANDLE);
OLESTATUS FARINTERNAL BmChangeData (LPOBJECT_BM, HBITMAP, LPOLECLIENT, BOOL);
OLESTATUS INTERNAL    BmStreamWrite (LPOLESTREAM, LPOBJECT_BM);
BOOL      INTERNAL    BmStreamRead (LPOLESTREAM, LPOBJECT_BM);
void      INTERNAL    BmUpdateStruct (LPOBJECT_BM, LPOLECLIENT, HBITMAP, LPBITMAP, DWORD);

OLECLIPFORMAT FARINTERNAL BmEnumFormat (LPOBJECT_BM, OLECLIPFORMAT);
LPOBJECT_BM   INTERNAL    BmCreateObject (HBITMAP, LPOLECLIENT, BOOL, 
                                LHCLIENTDOC, LPSTR, LONG);


/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// Routines in GENERIC.C                                                   //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////




/* The GENERIC file will be of the following format:                    */
/*                                                                      */
/*      0007                                                            */
/*      "GENERIC"                                                       */
/*      4 bytes of cfFormat                                             */

OLESTATUS FARINTERNAL GenRelease (LPOBJECT_GEN);
OLESTATUS FARINTERNAL GenSaveToStream (LPOBJECT_GEN, LPOLESTREAM);
OLESTATUS FARINTERNAL GenEqual (LPOBJECT_GEN, LPOBJECT_GEN);
OLESTATUS FARINTERNAL GenCopy (LPOBJECT_GEN);
OLESTATUS FARINTERNAL GenQueryBounds (LPOBJECT_GEN, LPRECT);
OLESTATUS FARINTERNAL GenGetData (LPOBJECT_GEN, OLECLIPFORMAT, LPHANDLE);
OLESTATUS FARINTERNAL GenSetData (LPOBJECT_GEN, OLECLIPFORMAT, HANDLE);
OLESTATUS FARINTERNAL GenChangeData (LPOBJECT_GEN, HANDLE, LPOLECLIENT, BOOL);
OLESTATUS INTERNAL    GenDeleteData (HANDLE);
OLESTATUS FARINTERNAL GenQueryType (LPOLEOBJECT, LPLONG);
OLESTATUS FARINTERNAL GenClone(LPOBJECT_GEN, LPOLECLIENT, LHCLIENTDOC, LPSTR, LPOBJECT_GEN FAR *);

OLECLIPFORMAT FARINTERNAL GenEnumFormat (LPOBJECT_GEN, OLECLIPFORMAT);
LPOBJECT_GEN  INTERNAL    GenCreateObject (HANDLE, LPOLECLIENT, BOOL, 
                                LHCLIENTDOC, LPSTR, LONG);



/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// Routines in ERROR.C                                                     //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////


OLESTATUS FARINTERNAL ErrPlay (LPOLEOBJECT, WORD, BOOL, BOOL);
OLESTATUS FARINTERNAL ErrShow (LPOLEOBJECT, BOOL);
OLESTATUS FARINTERNAL ErrSetHostNames (LPOLEOBJECT, LPSTR, LPSTR);
OLESTATUS FARINTERNAL ErrSetTargetDevice (LPOLEOBJECT, HANDLE);
OLESTATUS FARINTERNAL ErrSetColorScheme (LPOLEOBJECT, LPLOGPALETTE);
OLESTATUS FARINTERNAL ErrSetBounds (LPOLEOBJECT, LPRECT);
OLESTATUS FARINTERNAL ErrQueryOpen (LPOLEOBJECT);
OLESTATUS FARINTERNAL ErrActivate (LPOLEOBJECT, WORD, BOOL, BOOL, HWND, LPRECT);
OLESTATUS FARINTERNAL ErrClose (LPOLEOBJECT);
OLESTATUS FARINTERNAL ErrUpdate (LPOLEOBJECT);
OLESTATUS FARINTERNAL ErrReconnect (LPOLEOBJECT);
OLESTATUS FARINTERNAL ErrSetData (LPOLEOBJECT, OLECLIPFORMAT, HANDLE);
OLESTATUS FARINTERNAL ErrQueryOutOfDate (LPOLEOBJECT);
OLESTATUS FARINTERNAL ErrGetUpdateOptions (LPOLEOBJECT, OLEOPT_UPDATE FAR *);
OLESTATUS FARINTERNAL ErrSetUpdateOptions (LPOLEOBJECT, OLEOPT_UPDATE);
LPVOID    FARINTERNAL ErrQueryProtocol (LPOLEOBJECT, LPSTR);
OLESTATUS FARINTERNAL ErrQueryRelease (LPOLEOBJECT);
OLESTATUS FARINTERNAL ErrAbort (LPOLEOBJECT);
OLESTATUS FARINTERNAL ErrCopyFromLink (LPOLEOBJECT, LPOLECLIENT, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *);
OLESTATUS FARINTERNAL ErrRequestData (LPOLEOBJECT, OLECLIPFORMAT);
OLESTATUS FARINTERNAL ErrExecute (LPOLEOBJECT, HANDLE, WORD);

OLESTATUS FARINTERNAL ErrObjectConvert (LPOLEOBJECT, LPSTR, LPOLECLIENT, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *); 

OLESTATUS FARINTERNAL ErrObjectLong (LPOLEOBJECT, WORD, LPLONG);


/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// Routines in DRAW.C                                                      //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////
                    

OLESTATUS FARINTERNAL DibDraw (LPOBJECT_DIB, HDC, LPRECT, LPRECT, HDC);
OLESTATUS FARINTERNAL BmDraw (LPOBJECT_BM, HDC, LPRECT, LPRECT, HDC);
OLESTATUS FARINTERNAL GenDraw (LPOBJECT_GEN, HDC, LPRECT, LPRECT, HDC);
OLESTATUS FARINTERNAL MfDraw (LPOBJECT_MF, HDC, LPRECT, LPRECT, HDC);
void      INTERNAL    MfInterruptiblePaint (LPOBJECT_MF, HDC);
int       FARINTERNAL MfCallbackFunc (HDC, LPHANDLETABLE, LPMETARECORD, int, BYTE FAR *);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\ole\server\sources.inc ===
TARGETNAME=
TARGETTYPE=NOTARGET
TARGETPATH=
SOURCES=

NTTARGETFILE1=buildall

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\ole\client\utils.c ===
/****************************** Module Header ******************************\
* Module Name: utils.c
*
* Purpose: Conatains all the utility routines
*
* Created: 1990
*
* Copyright (c) 1990, 1991  Microsoft Corporation
*
* History:
*   Raor, srinik (../../1990,91)    Designed and coded
*
\***************************************************************************/

#include <windows.h>
#include <shellapi.h>

#include "dll.h"

#define KB_64   65536

extern ATOM  aPackage;
extern OLEOBJECTVTBL    vtblMF, vtblBM, vtblDIB, vtblGEN;

// QuerySize API support
DWORD           dwObjSize = NULL;
OLESTREAMVTBL   dllStreamVtbl;
OLESTREAM       dllStream;


#pragma alloc_text(_DDETEXT, UtilMemClr, MapStrToH, MapExtToClass, FileExists)

BOOL PutStrWithLen(lpstream, lpbytes)
LPOLESTREAM   lpstream;
LPSTR         lpbytes;
{
    LONG     len;

    len = (LONG) lstrlen(lpbytes) + 1;

    if (PutBytes (lpstream, (LPSTR)&len, sizeof(len)))
        return TRUE;

    return PutBytes(lpstream, lpbytes, len);

}

BOOL GetStrWithLen(lpstream, lpbytes)
LPOLESTREAM   lpstream;
LPSTR         lpbytes;
{
    if (GetBytes (lpstream, lpbytes, sizeof(LONG)))
        return TRUE;

    return GetBytes (lpstream, lpbytes + sizeof(LONG), (*(LONG FAR *)lpbytes));
}

ATOM GetAtomFromStream(lpstream)
LPOLESTREAM lpstream;
{
    BOOL    err = TRUE;
    LONG    len;
    char    str[MAX_STR+1];


    if (GetBytes (lpstream, (LPSTR)&len, sizeof(len)))
        return NULL;

    if (len == 0)
        return NULL;

    if (GetBytes(lpstream, (LPSTR)str, len))
        return NULL;

    return GlobalAddAtom(str);

}

BOOL PutAtomIntoStream(lpstream, at)
LPOLESTREAM     lpstream;
ATOM            at;
{
    LONG    len = 0;
    char    buf[MAX_STR + 1];

    if (at == 0)
        return  (PutBytes (lpstream, (LPSTR)&len, sizeof(len)));


    len = GlobalGetAtomName (at,(LPSTR)buf, MAX_STR) + 1;

    if (PutBytes (lpstream, (LPSTR)&len, sizeof(len)))
        return TRUE;

    return PutBytes(lpstream, buf, len);
}


// DuplicateAtom: Bump the use count up on a global atom.

ATOM FARINTERNAL DuplicateAtom (ATOM atom)
{
    char buffer[MAX_ATOM+1];

    Puts("DuplicateAtom");

    if (!atom)
        return NULL;

    GlobalGetAtomName (atom, buffer, MAX_ATOM);
    return GlobalAddAtom (buffer);
}



BOOL GetBytes(lpstream, lpstr, len)
LPOLESTREAM     lpstream;
LPSTR           lpstr;
LONG            len;
{

    ASSERT (lpstream->lpstbl->Get , "stream get function is null");
    return (((*lpstream->lpstbl->Get)(lpstream, lpstr, (DWORD)len)) != (DWORD)len);
}


BOOL PutBytes(lpstream, lpstr, len)
LPOLESTREAM     lpstream;
LPSTR           lpstr;
LONG            len;
{

    ASSERT (lpstream->lpstbl->Put , "stream get function is null");
    return (((*lpstream->lpstbl->Put)(lpstream, lpstr, (DWORD)len)) != (DWORD)len);
}


BOOL FARINTERNAL UtilMemCmp (lpmem1, lpmem2, dwCount)
LPSTR   lpmem1;
LPSTR   lpmem2;
DWORD   dwCount;
{
    WORD HUGE * hpmem1;
    WORD HUGE * hpmem2;
    WORD FAR  * lpwMem1;
    WORD FAR  * lpwMem2;
    DWORD       words;
    DWORD       bytes;
    
    bytes = dwCount %  2;
    words = dwCount >> 1;           //* we should compare DWORDS
                                    //* in the 32 bit version 
    if (dwCount <= KB_64) {
        lpwMem1 = (WORD FAR *) lpmem1;
        lpwMem2 = (WORD FAR *) lpmem2;
        
        while (words--) {
            if (*lpwMem1++ != *lpwMem2++)
                return FALSE;
        }

        if (bytes) {
            if (* (char FAR *) lpwMem1 != *(char FAR *) lpwMem2)
                return FALSE;
        }

    }
    else {
        hpmem1 = (WORD HUGE *) lpmem1;
        hpmem2 = (WORD HUGE *) lpmem2;
    
        while (words--) {
            if (*hpmem1++ != *hpmem2++)
                return FALSE;
        }

        if (bytes) {
            if (* (char HUGE *) hpmem1 != * (char HUGE *) hpmem2)
                return FALSE;
        }
    }
    
    return TRUE;
}


void FARINTERNAL UtilMemCpy (lpdst, lpsrc, dwCount)
LPSTR   lpdst;
LPSTR   lpsrc;
DWORD   dwCount;
{
    WORD HUGE * hpdst;
    WORD HUGE * hpsrc;
    WORD FAR  * lpwDst;
    WORD FAR  * lpwSrc;
    DWORD       words;
    DWORD       bytes;
    
    bytes = dwCount %  2;
    words = dwCount >> 1;           //* we should compare DWORDS
                                    //* in the 32 bit version 
    if (dwCount <= KB_64) {
        lpwDst = (WORD FAR *) lpdst;
        lpwSrc = (WORD FAR *) lpsrc;
        
        while (words--) 
            *lpwDst++ = *lpwSrc++;

        if (bytes) 
            * (char FAR *) lpwDst = * (char FAR *) lpwSrc;
    }
    else {
        hpdst = (WORD HUGE *) lpdst;
        hpsrc = (WORD HUGE *) lpsrc;
    
        while (words--) 
            *hpdst++ = *hpsrc++;

        if (bytes) 
            *(char HUGE *) hpdst = * (char HUGE *) hpsrc;
    }
}


//DuplicateData: Duplicates a given Global data handle.
HANDLE FARINTERNAL DuplicateGlobal (hdata, flags)
HANDLE  hdata;
WORD    flags;
{
    LPSTR   lpdst = NULL;
    LPSTR   lpsrc = NULL;
    HANDLE  hdup  = NULL;
    DWORD   size;
    BOOL    err   = TRUE;

    if (!hdata)
        return NULL;
    
    if(!(lpsrc = GlobalLock (hdata)))
        return NULL;

    hdup = GlobalAlloc (flags, (size = GlobalSize(hdata)));

    if(!(lpdst = GlobalLock (hdup)))
        goto errRtn;;

    err = FALSE;
    UtilMemCpy (lpdst, lpsrc, size);

errRtn:
    if(lpsrc)
        GlobalUnlock (hdata);

    if(lpdst)
        GlobalUnlock (hdup);

    if (err && hdup) {
        GlobalFree (hdup);
        hdup = NULL;
    }
    
    return hdup;
}


BOOL FARINTERNAL CmpGlobals (hdata1, hdata2)
HANDLE  hdata1;
HANDLE  hdata2;
{
    LPSTR       lpdata1 = NULL;
    LPSTR       lpdata2 = NULL;
    DWORD       size1;
    DWORD       size2;
    BOOL        retval = FALSE;


    size1 = GlobalSize (hdata1);
    size2 = GlobalSize (hdata2);

    if (size1 != size2)
        return FALSE;

    if (!(lpdata1 = GlobalLock (hdata1)))
        goto errRtn;

    if (!(lpdata2 = GlobalLock (hdata2)))
        goto errRtn;

    retval = UtilMemCmp (lpdata1, lpdata2, size1);

errRtn:
    if (lpdata1)
        GlobalUnlock (hdata1);

    if (lpdata2)
        GlobalUnlock (hdata2);

    return retval;
}


int  FARINTERNAL GlobalGetAtomLen (aItem)
ATOM    aItem;
{
    // !!! Change this
    char    buf[MAX_STR];

    if (!aItem)
        return NULL;
    
    return (GlobalGetAtomName (aItem, (LPSTR)buf, MAX_STR));

}


BOOL FARINTERNAL MapExtToClass (lptemplate, lpbuf, len)
LPSTR   lptemplate;
LPSTR   lpbuf;
int     len;
{
    LONG    cb;    
    
    while (*lptemplate && *lptemplate != '.')
        lptemplate++;
        
    cb = len;   
    if (*(lptemplate+1) == NULL)
        return FALSE;

    if (RegQueryValue (HKEY_CLASSES_ROOT, lptemplate, lpbuf, &cb)) 
        return FALSE;

    return TRUE;
}


// Get exe name from aClass and set it as aServer
void INTERNAL SetExeAtom (lpobj)
LPOBJECT_LE lpobj;
{
    char    key[MAX_STR];
    
    // if old link object assume the class same as the exe file name.
    if (lpobj->bOldLink)
        lpobj->aServer = DuplicateAtom (lpobj->app);
    else {
        if (GlobalGetAtomName (lpobj->app, key, sizeof(key)))
            lpobj->aServer = GetAppAtom ((LPSTR)key);
    }
}
    

ATOM FARINTERNAL GetAppAtom (lpclass)
LPSTR   lpclass;
{
    char    buf1[MAX_STR];
    

    if (!QueryApp (lpclass, PROTOCOL_EDIT, buf1)) {
        return NULL;
    }
    
    return GlobalAddAtom ((LPSTR)buf1);
}


BOOL FARINTERNAL QueryVerb (lpobj, verb, lpbuf, cbmax)
LPOBJECT_LE lpobj;
WORD        verb;
LPSTR       lpbuf;
LONG        cbmax;
{
    LONG    cb = MAX_STR;
    char    key[MAX_STR];
    // do not need 256 bytes buffer
    char    class[MAX_STR];
    int     len;

    if (!GlobalGetAtomName (lpobj->app, (LPSTR)class, sizeof(class)))
        return FALSE;

    lstrcpy (key, (LPSTR)class);
    lstrcat (key, "\\protocol\\StdFileEditing\\verb\\");
    len = lstrlen (key);
    key [len++] = (char) ('0' + verb);
    key [len++] = 0;

    if (RegQueryValue (HKEY_CLASSES_ROOT, key, lpbuf, &cbmax))
        return FALSE;        
    return TRUE;
}




BOOL QueryApp (lpclass, lpprotocol, lpbuf)
LPSTR   lpclass;
LPSTR   lpprotocol;
LPSTR   lpbuf;
{
    LONG    cb = MAX_STR;
    char    key[MAX_STR];

    lstrcpy (key, lpclass);
    lstrcat (key, "\\protocol\\");
    lstrcat (key, lpprotocol);
    lstrcat (key, "\\server");

    if (RegQueryValue (HKEY_CLASSES_ROOT, key, lpbuf, &cb))  
        return FALSE;        
    return TRUE;
}


HANDLE MapStrToH (lpstr)
LPSTR   lpstr;
{

    HANDLE  hdata  = NULL;
    LPSTR   lpdata = NULL;

    hdata = GlobalAlloc (GMEM_DDESHARE, lstrlen (lpstr) + 1);
    if (hdata == NULL || (lpdata = (LPSTR)GlobalLock (hdata)) == NULL)
        goto errRtn;

    lstrcpy (lpdata, lpstr);
    GlobalUnlock (hdata);
    return hdata;

errRtn:
    if (lpdata)
        GlobalUnlock (hdata);

    if (hdata)
        GlobalFree (hdata);
    return NULL;
}


HANDLE FARINTERNAL CopyData (lpsrc, dwBytes)
LPSTR       lpsrc;
DWORD       dwBytes;
{
    HANDLE  hnew;
    LPSTR   lpnew;
    BOOL    retval = FALSE;

    if (hnew = GlobalAlloc (GMEM_MOVEABLE, dwBytes)){
        if (lpnew = GlobalLock (hnew)){
            UtilMemCpy (lpnew, lpsrc, dwBytes);
            GlobalUnlock (hnew);
            return hnew;
        } 
        else
            GlobalFree (hnew);
    }
    
    return NULL;
}

void  UtilMemClr (pstr, size)
PSTR    pstr;
WORD    size;
{

    while (size--)
        *pstr++ = 0;

}


OLESTATUS FAR PASCAL ObjQueryName (lpobj, lpBuf, lpcbBuf)
LPOLEOBJECT lpobj;
LPSTR       lpBuf;
WORD FAR *  lpcbBuf;
{
    if (lpobj->ctype != CT_LINK && lpobj->ctype != CT_EMBEDDED 
            && lpobj->ctype != CT_STATIC)
        return OLE_ERROR_OBJECT;
    
    PROBE_WRITE(lpBuf);
    if (!*lpcbBuf)
        return OLE_ERROR_SIZE;
    
    if (!CheckPointer(lpBuf+*lpcbBuf-1, WRITE_ACCESS))
        return OLE_ERROR_SIZE;

    ASSERT(lpobj->aObjName, "object name ATOM is NULL\n");
    *lpcbBuf = GlobalGetAtomName (lpobj->aObjName, lpBuf, *lpcbBuf);
    return OLE_OK;
}


OLESTATUS FAR PASCAL ObjRename (lpobj, lpNewName)
LPOLEOBJECT lpobj;
LPSTR       lpNewName;
{
    if (lpobj->ctype != CT_LINK && lpobj->ctype != CT_EMBEDDED 
            && lpobj->ctype != CT_STATIC)
        return OLE_ERROR_OBJECT;
    
    PROBE_READ(lpNewName);
    if (!lpNewName[0])
        return OLE_ERROR_NAME;
    
    if (lpobj->aObjName)
        GlobalDeleteAtom (lpobj->aObjName);
    lpobj->aObjName = GlobalAddAtom (lpNewName);
    return OLE_OK;
}




BOOL QueryHandler(cfFormat)
WORD cfFormat;
{
    HANDLE  hInfo = NULL;
    LPSTR   lpInfo = NULL;
    BOOL    fRet = FALSE, fOpen = FALSE;
    LONG    cb = MAX_STR;
    char    str[MAX_STR];
    HKEY    hKey;
    
    // we don't have the client app window handle, use the screen handle
    fOpen = OpenClipboard (NULL);

    if (!(hInfo = GetClipboardData (cfFormat)))
        goto errRtn;
        
    if (!(lpInfo = GlobalLock(hInfo)))
        goto errRtn;
    
    // First string of lpInfo is CLASS. See whether any handler is installed
    // for this class.

    lstrcpy (str, lpInfo);
    lstrcat (str, "\\protocol\\StdFileEditing\\handler");       
    if (RegOpenKey (HKEY_CLASSES_ROOT, str, &hKey))
        goto errRtn;
    RegCloseKey (hKey);
    fRet = TRUE;

errRtn: 
    if (lpInfo)
        GlobalUnlock (hInfo);
    
    if (fOpen)
        CloseClipboard();
    return fRet;
}

OLESTATUS INTERNAL FileExists (lpobj)
LPOBJECT_LE lpobj;
{
    char        filename[MAX_STR];
    OFSTRUCT    ofstruct;
    
    if (!GlobalGetAtomName (lpobj->topic, filename, MAX_STR))
        return OLE_ERROR_MEMORY;
    
    // For package with link we append "/LINK" to the filename. We don't want
    // to check for it's existence here.
    if (lpobj->app != aPackage) {
        // when OF_EXIST is specified, file is opened and closed immediately
        if (OpenFile (filename, &ofstruct, OF_EXIST) == -1)
            return OLE_ERROR_OPEN;
    }
    
    return OLE_OK;
}


BOOL  FARINTERNAL UtilQueryProtocol (lpobj, lpprotocol)
LPOBJECT_LE lpobj;
LPSTR       lpprotocol;
{
    char    buf[MAX_STR];
    ATOM    aExe;
        
    if (!GlobalGetAtomName (lpobj->app, (LPSTR) buf, MAX_STR))
        return FALSE;
        
    if (!QueryApp (buf, lpprotocol, (LPSTR) buf))  
        return FALSE;
        
    aExe = GlobalAddAtom (buf);
    if (aExe)
        GlobalDeleteAtom (aExe);
    if (aExe != lpobj->aServer)
        return FALSE;
    
    return TRUE;
}

WORD FARINTERNAL FarCheckPointer (lp, iAccessType)
LPVOID  lp;
int     iAccessType;
{
    return (CheckPointer (lp, iAccessType));
}


DWORD PASCAL FAR DllPut (lpstream, lpstr, dwSize)
LPOLESTREAM lpstream;
LPSTR       lpstr;
DWORD       dwSize;
{
    dwObjSize += dwSize;
    return dwSize;
}



OLESTATUS FARINTERNAL ObjQueryType (lpobj, lptype)
LPOLEOBJECT lpobj;
LPLONG      lptype;
{
    Puts("ObjQueryType");

    if (lpobj->ctype != CT_STATIC)
        return OLE_ERROR_OBJECT;
    
    *lptype = lpobj->ctype;
    return OLE_OK;
}

OLESTATUS FARINTERNAL ObjQuerySize (lpobj, lpdwSize)
LPOLEOBJECT    lpobj;
DWORD FAR *    lpdwSize;
{
    Puts("ObjQuerySize");

    *lpdwSize = dwObjSize = NULL;    
    
    if ((*lpobj->lpvtbl->SaveToStream) (lpobj, &dllStream) == OLE_OK) {
        *lpdwSize = dwObjSize;
        return OLE_OK;
    }

    return OLE_ERROR_BLANK;
}

BOOL FARINTERNAL IsObjectBlank (lpobj)
LPOBJECT_LE lpobj;
{
    LPOLEOBJECT lpPictObj;
    BOOL        retval;
    
    // Cleaner way is to provide a method like QueryBlank()
        
    if (!lpobj->hnative)
        return TRUE;
    
    if (!(lpPictObj = lpobj->lpobjPict))
        return FALSE;
    
    if (lpPictObj->lpvtbl == (LPOLEOBJECTVTBL)&vtblMF)
        retval = (BOOL) (((LPOBJECT_MF)lpPictObj)->hmfp);
    else if (lpPictObj->lpvtbl == (LPOLEOBJECTVTBL)&vtblBM)
        retval = (BOOL) (((LPOBJECT_BM)lpPictObj)->hBitmap);
    if (lpPictObj->lpvtbl == (LPOLEOBJECTVTBL)&vtblDIB)
        retval = (BOOL) (((LPOBJECT_DIB)lpPictObj)->hDIB);
    if (lpPictObj->lpvtbl == (LPOLEOBJECTVTBL)&vtblGEN)
        retval = (BOOL) (((LPOBJECT_GEN)lpPictObj)->hData); 
    
    return retval;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\ole\server\give2gdi.asm ===
;\
    ;   give2gdi.asm
    ;
    ;   Copyright (C) 1991, MicroSoft Corporation
    ;
    ;   Contains code which changes memory metafile ownership to GDI
    ;
    ;   History:  sriniK   05/22/1991 
   ;/               


include cmacros.inc
include windows.inc

.286


;**************************** Data Segment ********************************

sBegin  data 
        assumes ds, data
        
szGDI   db  'GDI', 0
szWEP   db  'WEP', 0

sEnd    data


;*************************** Code Segment *********************************

externFP    GlobalRealloc
externFP    GlobalSize
externFP    GetModuleHandle
externFP    GetProcAddress

createSeg   Give2GDI, Give2GDI, para, public, code

sBegin      Give2GDI
            assumes cs,Give2GDI
            assumes ds,data
            assumes es,nothing

;**************************** Public Functions ****************************

cProc       GiveToGDI, <PUBLIC,FAR>
;
;
;   HANDLE  FAR PASCAL GiveToGDI(HANDLE hMem)
;
;   Assign ownership of the given global memory block to GDI
;
;   returns a handle to the memory block if successful, otherwise returns NULL
;

            parmW   hMem

            localD  lpGDIWEP
cBegin
            ;*************************************************************
            ;**     Get address of retf in fixed GDI code segment       **
            ;*************************************************************

            push    ds
            push    dataOFFSET szGDI
            cCall   GetModuleHandle

            push    ax
            push    ds
            push    dataOFFSET szWEP
            cCall   GetProcAddress

            mov     [word ptr lpGDIWEP[0]], ax
            mov     [word ptr lpGDIWEP[2]], dx

            ;*************************************************************
            ;**     Kludge a call to GlobalReAlloc with GDI as caller   **
            ;*************************************************************

            push    0                       ; Params for WEP

            push    cs                      ; GDI's WEP returns here
            push    offset  ReturnHere
            
            push    hMem                    ; Params to GlobalReAlloc
            push    0
            push    0
            push    [GMEM_MOVEABLE or GMEM_SHARE or GMEM_MODIFY]

            push    [word ptr lpGDIWEP[2]]  ; GlobalReAlloc returns here
            push    [word ptr lpGDIWEP[0]]  ; GlobalReAlloc returns here
            
            push    0                       ; Params for WEP

            push    seg    GlobalReAlloc    ; GDI's WEP returns here
            push    offset GlobalReAlloc

            jmp     lpGDIWEP                ; Dive off the end
ReturnHere:
            ;*************************************************************
            ;**     Return handle to reallocated block                  **
            ;*************************************************************

            mov     ax,hMem
cEnd

;*************************************************************************

sEnd        Give2GDI
end

;*************************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\ole\server\block.c ===
/****************************** Module Header ******************************\
* Module Name: Block.c
*
* Purpose: Includes OleServerBlock(), OleServerUnblock() and related routines.
*
* Created: Dec. 1990.
*
* Copyright (c) 1990, 1991  Microsoft Corporation
*
* History:
*    Srinik (../12/1990)    Designed, coded
*
\***************************************************************************/


#include "cmacs.h"
#include "windows.h"
#include "dde.h"
#include "ole.h"
#include "srvr.h"


OLESTATUS FAR PASCAL OleBlockServer (lhsrvr)
LHSERVER  lhsrvr;
{
    LPSRVR  lpsrvr;

    if (!CheckServer (lpsrvr = (LPSRVR) lhsrvr))
        return OLE_ERROR_HANDLE;

    PROBE_BLOCK(lpsrvr);
    lpsrvr->bBlock = TRUE;
    return OLE_OK;
}


// On return from this routine, if *lpStatus is TRUE it means that more
// messages are to be unblocked.

OLESTATUS FAR PASCAL OleUnblockServer (lhsrvr, lpStatus)
LHSERVER    lhsrvr;
BOOL FAR *  lpStatus;
{
    HANDLE  hq;
    PQUE    pq;
    LPSRVR  lpsrvr;

    if (!CheckServer (lpsrvr = (LPSRVR) lhsrvr))
        return OLE_ERROR_HANDLE;

    PROBE_WRITE(lpStatus);

    *lpStatus = lpsrvr->bBlock;
    if (hq = lpsrvr->hqHead) {
        if (!(pq = (PQUE) LocalLock (hq)))
            return OLE_ERROR_MEMORY;
        lpsrvr->bBlockedMsg = TRUE;
        lpsrvr->hqHead = pq->hqNext;
        SendMessage (pq->hwnd, pq->msg, pq->wParam, pq->lParam);
        LocalUnlock (hq);
        LocalFree (hq);

        // Server could've got freed up as a result of the above SendMessage
        // Validate server handle before trying to access it.
        if (CheckServer (lpsrvr)) {
            lpsrvr->bBlockedMsg = FALSE;

            if (!lpsrvr->hqHead) {
                lpsrvr->hqTail = NULL;
                *lpStatus = lpsrvr->bBlock = FALSE;
            }
        }
        else {
            *lpStatus = FALSE;
        }
    }
    else {
        *lpStatus = lpsrvr->bBlock = FALSE;
    }

    return OLE_OK;
}


BOOL INTERNAL AddMessage (hwnd, msg, wParam, lParam, wType)
HWND        hwnd;
unsigned    msg;
WORD        wParam;
LONG        lParam;
int         wType;
{
    LPSRVR  lpsrvr;
    HANDLE  hq = NULL;
    PQUE    pq = NULL, pqTmp = NULL;
    BOOL    bBlocked = TRUE;

    if ((msg <= WM_DDE_INITIATE) || (msg > WM_DDE_LAST))
        return FALSE;


    if (!(lpsrvr = (LPSRVR) GetWindowLong ((wType == WT_DOC) ? GetParent (hwnd) : hwnd, 0)))
        return FALSE;

    if (lpsrvr->bBlockedMsg || !lpsrvr->bBlock)
        return FALSE;

#ifdef LATER
    if ((msg == WM_DDE_INITIATE) && (lpsrvr->useFlags == OLE_SERVER_MULTI))
        return TRUE;
#endif

    // Create a queue node and fill up with data

    if (!(hq = LocalAlloc (LMEM_MOVEABLE, sizeof(QUE))))
        goto errRet;

    if (!(pq = (PQUE) LocalLock (hq)))
        goto errRet;

    pq->hwnd   = hwnd;
    pq->msg    = msg;
    pq->wParam = wParam;
    pq->lParam = lParam;
    pq->hqNext = NULL;
    LocalUnlock (hq);

    // Now we got a node that we can add to the queue

    if (!lpsrvr->hqHead) {
        // Queue is empty.
#ifdef FIREWALLS
        ASSERT (!lpsrvr->hqTail, "Tail is unexpectedly non NULL")
#endif
        lpsrvr->hqHead = lpsrvr->hqTail = hq;
    }
    else {
        if (!(pqTmp = (PQUE) LocalLock (lpsrvr->hqTail)))
            goto errRet;
        pqTmp->hqNext = hq;
        LocalUnlock(lpsrvr->hqTail);
        lpsrvr->hqTail = hq;
    }

    return TRUE;

errRet:

    if (pq)
        LocalUnlock (hq);

    if (hq)
        LocalFree (hq);

    while (bBlocked && !OleUnblockServer ((LHSERVER) lpsrvr, &bBlocked))
            ;

    return FALSE;
}



// dispatches the queued message, till all the messages are posted
// does yielding  if necessary. if bPeek is true, may allow some of
// incoming messages to get in.


BOOL INTERNAL  UnblockPostMsgs (hwnd, bPeek)
HWND    hwnd;
BOOL    bPeek;
{
    HANDLE  hq = NULL;
    PQUE    pq = NULL;
    LPSRVR  lpsrvr;
    HWND    hwndTmp;

    // get the parent windows
    while (hwndTmp = GetParent (hwnd))
           hwnd = hwndTmp;

    lpsrvr = (LPSRVR) GetWindowLong (hwnd, 0);

#ifdef  FIREWALLS
    ASSERT (lpsrvr, "No server window handle in server window");
    ASSERT (lpsrvr->hqPostHead, "Unexpectedly blocked queue is empty");
#endif


    while (hq = lpsrvr->hqPostHead) {

        if (!(pq = (PQUE) LocalLock (hq))) {

#ifdef  FIREWALLS
        ASSERT (FALSE, "Local lock failed for blocked messages");
#endif
            break;
        }
        if (IsWindowValid (pq->hwnd)) {
            if (!PostMessage (pq->hwnd, pq->msg, pq->wParam, pq->lParam)) {
                LocalUnlock (hq);
                break;
            }
        }

        lpsrvr->hqPostHead = pq->hqNext;
        LocalUnlock (hq);
        LocalFree (hq);
    }


    if (!lpsrvr->hqPostHead)
        lpsrvr->hqPostTail = NULL;

    return TRUE;
}


// Moves a message which can not be posted to a server to
// the internal queue. We use this when we have to enumerate
// the properties. When we change the properties stuff to
// some other form, this may not be necassry.

BOOL INTERNAL BlockPostMsg (hwnd, msg, wParam, lParam)
HWND        hwnd;
WORD        msg;
WORD        wParam;
LONG        lParam;
{
    LPSRVR  lpsrvr;
    HANDLE  hq = NULL;
    PQUE    pq = NULL, pqTmp = NULL;
    HWND    hwndTmp;
    HWND    hwndParent;

    hwndParent = (HWND)wParam;
    // get the parent windows
    while (hwndTmp = GetParent ((HWND)hwndParent))
           hwndParent = hwndTmp;

    lpsrvr = (LPSRVR) GetWindowLong (hwndParent, 0);

#ifdef  FIREWALLS
    ASSERT (lpsrvr, "No server window handle in server window");
#endif

    // Create a queue node and fill up with data

    if (!(hq = LocalAlloc (LMEM_MOVEABLE, sizeof(QUE))))
        goto errRet;

    if (!(pq = (PQUE) LocalLock (hq)))
        goto errRet;

    pq->hwnd   = hwnd;
    pq->msg    = msg;
    pq->wParam = wParam;
    pq->lParam = lParam;
    pq->hqNext = NULL;
    LocalUnlock (hq);

    // Now we got a node that we can add to the queue

    if (!lpsrvr->hqPostHead) {
        // Queue is empty.
#ifdef FIREWALLS
        ASSERT (!lpsrvr->hqPostTail, "Tail is unexpectedly non NULL")
#endif
        lpsrvr->hqPostHead = lpsrvr->hqPostTail = hq;

        // create a timer.
        if (!SetTimer (lpsrvr->hwnd, 1, 100, NULL))
            return FALSE;

    }
    else {
        if (!(pqTmp = (PQUE) LocalLock (lpsrvr->hqPostTail)))
            goto errRet;
        pqTmp->hqNext = hq;
        LocalUnlock(lpsrvr->hqPostTail);
        lpsrvr->hqPostTail = hq;
    }

    return TRUE;

errRet:

    if (pq)
        LocalUnlock (hq);

    if (hq)
        LocalFree (hq);
    return FALSE;
}


BOOL INTERNAL IsBlockQueueEmpty (hwnd)
HWND    hwnd;
{

    LPSRVR  lpsrvr;
    HWND    hwndTmp;

    // get the parent windows
    while (hwndTmp = GetParent ((HWND)hwnd))
            hwnd= hwndTmp;
    lpsrvr = (LPSRVR) GetWindowLong (hwnd, 0);
    return (!lpsrvr->hqPostHead);


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\ole\server\olesvr.asm ===
;\
    ;   ole.asm
    ;
    ;   Copyright (C) 1991, MicroSoft Corporation
    ;
    ;   Contains pointer vaildation routine
    ;       
    ;   History:  sriniK   02/26/1991 original
   ;/               

.286p
.MODEL SMALL
.CODE

;**************************** _CheckPointer ****************************
;
;   WORD    CheckPointer (lp, access)
;
;   Args:
;       lp          pointer to be verified
;       access      0 test the pointer for read access
;                   1 test the pointer for write access
;   returns: 
;       FALSE       invalid pointer
;       TRUE        valid pointer
;
;
;
        public  _CheckPointer

_CheckPointer   proc

            push    bp
            mov     bp, sp
            
            xor     ax, ax                                              
            and     word ptr [bp+8], -1
            jnz     check_write_access

            verr    word ptr [bp+6]     ; check selector for read access
            jnz     error
            jmp short check_offset

check_write_access:
            verw    word ptr [bp+6]     ; check selector for write access
            jnz     error                                         
                                                                        
check_offset:
            lsl     bx, word ptr [bp+6] ; segment limit gets copied into BX
            jnz     error                                         
            cmp     [bp+4], bx          
            ja      error                                       
            or      ax, -1                                              
error:                  
            pop     bp
            ret

_CheckPointer   endp
            end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\ole\server\item.c ===
/****************************** Module Header ******************************\
* Module Name: Item.c Object(item) main module
*
* Purpose: Includes All the object releated routiens.
*
* Created: Oct 1990.
*
* Copyright (c) 1990, 1991  Microsoft Corporation
*
* History:
*    Raor (../10/1990)    Designed, coded
*
*
\***************************************************************************/


#include "cmacs.h"
#include "windows.h"
#include "ole.h"
#include "dde.h"
#include "srvr.h"

extern HANDLE   hdllInst;
extern FARPROC  lpFindItemWnd;
extern FARPROC  lpItemCallBack;
extern FARPROC  lpSendDataMsg;
extern FARPROC  lpSendRenameMsg;
extern FARPROC  lpDeleteClientInfo;
extern FARPROC  lpEnumForTerminate;


extern  ATOM    cfNative;
extern  ATOM    cfBinary;
extern  ATOM    aClose;
extern  ATOM    aChange;
extern  ATOM    aSave;
extern  ATOM    aEditItems;
extern  ATOM    aStdDocName;

extern  WORD    cfLink;
extern  WORD    cfOwnerLink;

extern  BOOL    bWin30;

HWND            hwndItem;
HANDLE          hddeRename;
HWND            hwndRename;

WORD            enummsg;
WORD            enuminfo;
LPOLEOBJECT     enumlpoleobject;
OLECLIENTVTBL   clVtbl;
BOOL            bClientUnlink;

BOOL            fAdviseSaveDoc;
BOOL            fAdviseSaveItem;

char *  stdStrTable[STDHOSTNAMES+1] = {NULL,
                                       "StdTargetDevice",
                                       "StdDocDimensions",
                                       "StdColorScheme",
                                       "StdHostNames"};


extern HANDLE (FAR PASCAL *lpfnSetMetaFileBitsBetter) (HANDLE);

void ChangeOwner (HANDLE hmfp);

// !!!change child enumeration.
// !!!No consistency in errors (Sometimes Bools and sometimes OLESTATUS).


//SearchItem: Searches for a given item in a document tree.
//If found, returns the corresponding child windows handle.

HWND  INTERNAL SearchItem (lpdoc, lpitemname)
LPDOC               lpdoc;
LPSTR               lpitemname;
{
    ATOM    aItem;

    Puts ("SearchItem");

    // If the item passed is an atom, get its name.
    if (!HIWORD(lpitemname))
        aItem = (ATOM) (LOWORD((DWORD)lpitemname));
    else if (!lpitemname[0])
        aItem = NULL;
    else
        aItem = GlobalFindAtom (lpitemname);

    hwndItem = NULL;

    // !!! We should avoid hwndItem static. It should not cause
    // any problems since while enumerating we will not be calling
    // any window procs  or no PostMessages are entertained.

    EnumChildWindows (lpdoc->hwnd, lpFindItemWnd,
        MAKELONG (aItem, ITEM_FIND));

    return hwndItem;

}

// FindItem: Given the itemname and the document handle,
// searches for the the item (object) in the document tree.
// Items are child windows for the document window.

// !!! change the child windows to somekind of
// linked lists at the item level. This will free up
// the space taken by the item windows.

int  INTERNAL FindItem (lpdoc, lpitemname, lplpclient)
LPDOC               lpdoc;
LPSTR               lpitemname;
LPCLIENT FAR *      lplpclient;
{
    LPCLIENT    lpclient;
    HWND        hwnd;
    char        buf[MAX_STR];

    Puts ("FindItem");

    hwnd = SearchItem (lpdoc, lpitemname);

    if (!HIWORD(lpitemname)){
        if (LOWORD(lpitemname))
            GlobalGetAtomName ((ATOM)LOWORD((DWORD)lpitemname),
                        (LPSTR)buf, MAX_STR);
        else
            buf[0] = NULL;

        lpitemname = (LPSTR)buf;
    }

    if (hwnd) {
        // we found the item window
        lpclient = (LPCLIENT)GetWindowLong (hwnd, 0);

#ifdef  FIREWALLS
            ASSERT ((CheckPointer(lpclient, WRITE_ACCESS)),
                "In Item the client handle missing")
            ASSERT ((CheckPointer(lpclient->lpoleobject, WRITE_ACCESS)),
                "In Item object handle missing")

#endif
            *lplpclient = lpclient;
            return OLE_OK;

    }

    // Item (object)window is not create yet. Let us create one.
    return RegisterItem ((LHDOC)lpdoc, lpitemname, lplpclient, TRUE);
}



//RegisterItem: Given the document handle and the item string
//creates item with the given document.

int  INTERNAL RegisterItem (lhdoc, lpitemname, lplpclient, bSrvr)
LHDOC               lhdoc;
LPSTR               lpitemname;
LPCLIENT FAR *      lplpclient;
BOOL                bSrvr;
{


    LPDOC           lpdoc;
    HANDLE          hclient  = NULL;
    LPCLIENT        lpclient = NULL;
    int             retval   = OLE_ERROR_MEMORY;
    LPOLESERVERDOC  lpoledoc;
    LPOLEOBJECT     lpoleobject = NULL;


    Puts ("CreateItem");

    lpdoc = (LPDOC)lhdoc;

#ifdef FIREWALLS
    ASSERT ((CheckPointer (lplpclient, WRITE_ACCESS)), "invalid lplpclient");
#endif

    // First create the callback client structure.

    hclient = GlobalAlloc (GMEM_MOVEABLE | GMEM_ZEROINIT | GMEM_DDESHARE, sizeof (CLIENT));
    if(!(hclient && (lpclient = (LPCLIENT)GlobalLock (hclient))))
        goto errRtn;

    lpclient->hclient       = hclient;
    hclient                 = NULL;

    if (!HIWORD(lpitemname)) {
        ASSERT (!bSrvr, "invalid lpitemname in RegisterItem\n");
        lpclient->aItem = LOWORD((DWORD)lpitemname);
    }
    else if (!lpitemname[0])
        lpclient->aItem = NULL;
    else
        lpclient->aItem = GlobalAddAtom (lpitemname);

    lpclient->oleClient.lpvtbl = &clVtbl;
    lpclient->oleClient.lpvtbl->CallBack = (int (CALLBACK *)(LPOLECLIENT, OLE_NOTIFICATION, LPOLEOBJECT))lpItemCallBack;

    lpoledoc = lpdoc->lpoledoc;

    // Call the server app to create its own object structure and link
    // it to the given document.

    // Call the server if the item is not one of the standard items.

    if (bSrvr) {
        retval = (*lpoledoc->lpvtbl->GetObject)(lpoledoc, lpitemname,
                    (LPOLEOBJECT FAR *)&lpoleobject, (LPOLECLIENT)lpclient);
        if (retval != OLE_OK)
            goto errRtn;
    }

    lpclient->lpoleobject   = lpoleobject;

    lpclient->hwnd = CreateWindow ("ItemWndClass", "ITEM",
                        WS_CHILD,0,0,0,0,lpdoc->hwnd,NULL, hdllInst, NULL);

    if (lpclient->hwnd == NULL)
        goto errRtn;

    // save the ptr to the item in the window.
    SetWindowLong (lpclient->hwnd, 0, (LONG)lpclient);
    *lplpclient = lpclient;
    return OLE_OK;

errRtn:

    if (lpclient)
        RevokeObject ((LPOLECLIENT)lpclient, FALSE);

    else {
        if(hclient)
            GlobalFree (hclient);
    }

    return retval;

}


OLESTATUS  FAR PASCAL OleRevokeObject (lpoleclient)
LPOLECLIENT    lpoleclient;
{
    return RevokeObject (lpoleclient, TRUE);

}
// OleRevokeObject: Revokes an object (unregisres an object
// from the document tree.

OLESTATUS  INTERNAL RevokeObject (lpoleclient, bUnlink)
LPOLECLIENT    lpoleclient;
BOOL           bUnlink;
{

    HANDLE      hclient;
    LPCLIENT    lpclient;

    lpclient = (LPCLIENT)lpoleclient;

    PROBE_WRITE(lpoleclient);
    if (lpclient->lpoleobject) {
       // first call the object for deletetion.

#ifdef FIREWALLS
        if (!CheckPointer (lpclient->lpoleobject, WRITE_ACCESS))
            ASSERT (0, "Invalid LPOLEOBECT")

        if (!CheckPointer (lpclient->lpoleobject->lpvtbl, WRITE_ACCESS))
            ASSERT (0, "Invalid LPOLEOBJECTVTBL")
        else
            ASSERT(lpclient->lpoleobject->lpvtbl->Release,
                "Invalid pointer to Release method")
#endif

        (*lpclient->lpoleobject->lpvtbl->Release)(lpclient->lpoleobject);

    }

    if (ISATOM(lpclient->aItem)) {
        GlobalDeleteAtom (lpclient->aItem);
        lpclient->aItem = NULL;
    }

    if (lpclient->hwnd) {
        SetWindowLong (lpclient->hwnd, 0, (LONG)NULL);

        // another static for enumerating the properties.
        // we need to change these .
        bClientUnlink = bUnlink;

        EnumProps(lpclient->hwnd, lpDeleteClientInfo);
        // post all the messages with yield which have been collected in enum
        // UnblockPostMsgs (lpclient->hwnd, FALSE);
        DestroyWindow (lpclient->hwnd);
    }

    GlobalUnlock (hclient = lpclient->hclient);
    GlobalFree (hclient);
    return OLE_OK;

}

BOOL    FAR PASCAL  DeleteClientInfo (hwnd, lpstr, hclinfo)
HWND    hwnd;
LPSTR   lpstr;
HANDLE  hclinfo;
{
    PCLINFO     pclinfo = NULL;
    HWND        hwndDoc;
    LPDOC       lpdoc;

#ifdef FIREWALLS
    ASSERT (hclinfo, "Client info null in item property list");
#endif


    // delete the printer dev info block
    if(pclinfo = (PCLINFO)LocalLock (hclinfo)){
        if(pclinfo->hdevInfo)
            GlobalFree (pclinfo->hdevInfo);


        if (bClientUnlink) {
            // terminate the conversation for the client.
            TerminateDocClients ((hwndDoc = GetParent(hwnd)), NULL, pclinfo->hwnd);
            lpdoc = (LPDOC)GetWindowLong (hwndDoc, 0);
            // for some reason this delete is gving circular lists for properties

            //DeleteClient (hwndDoc, pclinfo->hwnd);
            //lpdoc->cClients--;
        }
        LocalUnlock (hclinfo);
    }
    LocalFree (hclinfo);
    RemoveProp (hwnd, lpstr);
    return TRUE;
}




// Call back for the Object windows numeration. data  field
// has the command and the extra information


BOOL    FAR PASCAL FindItemWnd (hwnd, data)
HWND    hwnd;
LONG    data;
{

    LPCLIENT    lpclient;
    int         cmd;
    HANDLE      hclinfo;
    PCLINFO    pclinfo;


    lpclient = (LPCLIENT)GetWindowLong (hwnd, 0);

#ifdef  FIREWALLS
    // ASSERT (lpclient, "In Item the client handle missing")
#endif

    cmd = HIWORD(data);
    switch (cmd) {
        case    ITEM_FIND:
            if (lpclient->aItem == (ATOM)(LOWORD (data))) {
                // we found the window we required. Remember the
                // object window.

                hwndItem = hwnd;
                return FALSE; // terminate enumeration.

            }
            break;

        case    ITEM_SAVED:
            if (lpclient->lpoleobject) {
                if (ItemCallBack ((LPOLECLIENT) lpclient, OLE_SAVED,
                        lpclient->lpoleobject) == OLE_ERROR_CANT_UPDATE_CLIENT)
                    fAdviseSaveDoc = FALSE;
            }
            break;

        case    ITEM_DELETECLIENT:

            // delete the client from our list if we have one

            hclinfo = FindClient (hwnd, (HWND) (LOWORD(data)));
            if (hclinfo){
                // delete the printer dev info block
                if(pclinfo = (PCLINFO)LocalLock (hclinfo)){
                    if(pclinfo->hdevInfo)
                        GlobalFree (pclinfo->hdevInfo);
                    LocalUnlock (hclinfo);
                }
                LocalFree (hclinfo);
                DeleteClient ( hwnd, (HWND) (LOWORD(data)));
            }
            break;

        case    ITEM_DELETE:
            // delete the client it self.
            RevokeObject ((LPOLECLIENT)lpclient, FALSE);
            break;

    }
    return TRUE;        // continue enumeration.
}



//DeleteFromItemsList: Deletes a client from the object lists of
//all the objects of a given  document. Thie client possibly
//is terminating the conversation with our doc window.


void INTERNAL   DeleteFromItemsList (hwndDoc, hwndClient)
HWND    hwndDoc;
HWND    hwndClient;
{

    EnumChildWindows (hwndDoc, lpFindItemWnd,
        MAKELONG (hwndClient, ITEM_DELETECLIENT));

}


// DeleteAllItems: Deletes all the objects of a given
// document window.


void INTERNAL   DeleteAllItems (hwndDoc)
HWND    hwndDoc;
{

    EnumChildWindows (hwndDoc, lpFindItemWnd,
            MAKELONG (NULL, ITEM_DELETE));

}


// Object widnow proc:

long FAR PASCAL ItemWndProc(hwnd, msg, wParam, lParam)
HWND        hwnd;
WORD        msg;
WORD        wParam;
LONG        lParam;
{

    LPCLIENT    lpclient;

    lpclient = (LPCLIENT)GetWindowLong (hwnd, 0);

    switch (msg) {
       case WM_DESTROY:
            DEBUG_OUT("Item: Destroy window",0)

#ifdef  FIREWALLS
            ASSERT (!lpclient, "while destroy Item client is not null")
#endif
            break;
       default:
            DEBUG_OUT("item:  Default message",0)
            return DefWindowProc (hwnd, msg, wParam, lParam);

    }
    return 0L;

}

// PokeData: Prepares and gives the data to the server app thru
// the SetData object method.

OLESTATUS    INTERNAL PokeData (lpdoc, hwndClient, lparam)
LPDOC       lpdoc;
HWND        hwndClient;
LONG        lparam;
{
    int             retval = OLE_ERROR_MEMORY;
    LPCLIENT        lpclient;
    DDEPOKE FAR *   lpPoke = NULL;
    HANDLE          hPoke = NULL;
    HANDLE          hnew   = NULL;
    int             format;
    BOOL            fRelease = FALSE;

    // Get the object handle first. Look in the registration
    // tree and if one is not created otherwise create one.

    retval = FindItem (lpdoc, (LPSTR) MAKEINTATOM(HIWORD(lparam)),
                (LPCLIENT FAR *)&lpclient);

    if (retval != OLE_OK)
        goto errRtn;

    hPoke = (HANDLE)(LOWORD (lparam));
    if(!(hPoke && (lpPoke = (DDEPOKE FAR *) GlobalLock (hPoke))))
        goto errRtn;

    GlobalUnlock (hPoke);

    format   = lpPoke->cfFormat;
    fRelease = lpPoke->fRelease;

    // We found the item. Now prepare the data to be given to the object
    if (!(hnew = MakeItemData (lpPoke, hPoke, format)))
        goto errRtn;

    // Now send the data to the object

#ifdef FIREWALLS
        if (!CheckPointer (lpclient->lpoleobject->lpvtbl, WRITE_ACCESS))
            ASSERT (0, "Invalid LPOLEOBJECTVTBL")
        else
            ASSERT (lpclient->lpoleobject->lpvtbl->SetData,
                "Invalid pointer to SetData method")
#endif

    retval = (*lpclient->lpoleobject->lpvtbl->SetData) (lpclient->lpoleobject,
                                                format, hnew);

    // We free the data if server returns OLE_ERROR_SETDATA_FORMAT.
    // Otherwise server must've deleted it.

    if (retval == OLE_ERROR_SETDATA_FORMAT) {
        if (!FreeGDIdata (hnew, format))
            GlobalFree (hnew);
    }


errRtn:
    if (retval == OLE_OK && fRelease) {
        if (hPoke)
            GlobalFree (hPoke);
    }

    return retval;
}




OLESTATUS  INTERNAL UnAdviseData (lpdoc, hwndClient, lparam)
LPDOC       lpdoc;
HWND        hwndClient;
LONG        lparam;
{


    char            buf[MAX_STR];
    int             options;
    LPCLIENT        lpclient;
    int             retval  = OLE_ERROR_MEMORY;
    HANDLE          hclinfo = NULL;
    PCLINFO         pclinfo = NULL;

    if (!(HIWORD (lparam)))
        buf[0] = NULL;
    else
        GlobalGetAtomName ((ATOM)(HIWORD (lparam)), (LPSTR)buf, MAX_STR);

    // Scan for the advise options like "Close", "Save" etc
    // at the end of the item.

    if((retval = ScanItemOptions ((LPSTR)buf, (int far *)&options)) !=
            OLE_OK)
        goto errRtn;


    if (buf[0] == NULL) {
        // Unadvise for null should terminate all the advises
        DeleteFromItemsList (lpdoc->hwnd, hwndClient);
        return OLE_OK;
    }

    // Now get the corresponding object.
    retval = FindItem (lpdoc, (LPSTR)buf, (LPCLIENT FAR *)&lpclient);
    if (retval != OLE_OK)
        goto errRtn;


    // Find the client structure to be attcahed to the object.
    if ((hclinfo = FindClient (lpclient->hwnd, hwndClient)) == NULL ||
        (pclinfo = (PCLINFO) LocalLock (hclinfo)) == NULL ){
            retval = OLE_ERROR_MEMORY;
            goto errRtn;
    }

    pclinfo->options &= (~(0x0001 << options));

errRtn:
    if (pclinfo)
        LocalUnlock (hclinfo);
    return retval;

}



// AdviseStdItems: This routine takes care of the DDEADVISE for a
//particular object in given document. Creates a client strutcure
//and attaches to the property list of the object window.

OLESTATUS INTERNAL  AdviseStdItems (lpdoc, hwndClient, lparam, lpfack)
LPDOC       lpdoc;
HWND        hwndClient;
LONG        lparam;
BOOL FAR *  lpfack;
{

    HANDLE              hopt   = NULL;
    DDEADVISE FAR       *lpopt;
    OLESTATUS           retval = OLE_ERROR_MEMORY;


    hopt = (HANDLE) (LOWORD (lparam));
    if(!(lpopt = (DDEADVISE FAR *) GlobalLock (hopt)))
        goto errrtn;

#ifdef  FIREWALLS
    ASSERT ((ATOM) (HIWORD (lparam) == aStdDocName), "AdviseStdItem is not Documentname");
#endif

    *lpfack = lpopt->fAckReq;
    retval = SetStdInfo (lpdoc, hwndClient, (LPSTR)"StdDocumentName",  NULL);

    if (lpopt)
        GlobalUnlock (hopt);

errrtn:

    if (retval == OLE_OK)
        // !!! make sure that we have to free the data for error case
        GlobalFree (hopt);
    return retval;
}



//AdviseData: This routine takes care of the DDEADVISE for a
//particular object in given document. Creates a client strutcure
//and attaches to the property list of the object window.

OLESTATUS INTERNAL  AdviseData (lpdoc, hwndClient, lparam, lpfack)
LPDOC       lpdoc;
HWND        hwndClient;
LONG        lparam;
BOOL FAR *  lpfack;
{


    HANDLE          hopt   = NULL;
    DDEADVISE FAR   *lpopt = NULL;
    int             format = NULL;
    char            buf[MAX_STR];
    int             options;
    LPCLIENT        lpclient;
    int             retval  = OLE_ERROR_MEMORY;
    HANDLE          hclinfo = NULL;
    PCLINFO         pclinfo = NULL;



    hopt = (HANDLE) (LOWORD (lparam));
    if(!(lpopt = (DDEADVISE FAR *) GlobalLock (hopt)))
        goto errRtn;

    if (!(HIWORD (lparam)))
        buf[0] = NULL;
    else
        GlobalGetAtomName ((ATOM)(HIWORD (lparam)), (LPSTR)buf, MAX_STR);

    // Scan for the advise options like "Close", "Save" etc
    // at the end of the item.

    if((retval = ScanItemOptions ((LPSTR)buf, (int far *)&options)) !=
            OLE_OK)
        goto errRtn;


    // Now get the corresponding object.
    retval = FindItem (lpdoc, (LPSTR)buf, (LPCLIENT FAR *)&lpclient);
    if (retval != OLE_OK)
        goto errRtn;

    if (!IsFormatAvailable (lpclient, lpopt->cfFormat)){
        retval = OLE_ERROR_DATATYPE;       // this format is not supported;
        goto errRtn;
    }

    *lpfack = lpopt->fAckReq;

    // Create the client structure to be attcahed to the object.
    if (!(hclinfo = FindClient (lpclient->hwnd, hwndClient)))
        hclinfo = LocalAlloc (LMEM_MOVEABLE | LMEM_ZEROINIT, sizeof (CLINFO));

    if (hclinfo == NULL || (pclinfo = (PCLINFO) LocalLock (hclinfo)) == NULL){
        retval = OLE_ERROR_MEMORY;
        goto errRtn;
    }

    // Remember the client window (Needed for sending DATA later on
    // when the data change message comes from the server)

    pclinfo->hwnd = hwndClient;
    if (lpopt->cfFormat == (int)cfNative)
        pclinfo->bnative = TRUE;
    else
        pclinfo->format = lpopt->cfFormat;

    // Remeber the data transfer options.
    pclinfo->options |= (0x0001 << options);
    pclinfo->bdata   = !lpopt->fDeferUpd;
    LocalUnlock (hclinfo);
    pclinfo = NULL;


    // if the entry exists already, delete it.
    DeleteClient (lpclient->hwnd, hwndClient);

    // Now add this client to item client list
    // !!! This error recovery is not correct.
    if(!AddClient (lpclient->hwnd, hwndClient, hclinfo))
        goto errRtn;


errRtn:
    if (lpopt)
        GlobalUnlock (hopt);

    if (pclinfo)
        LocalUnlock (hclinfo);

    if (retval == OLE_OK) {
        // !!! make sure that we have to free the data
        GlobalFree (hopt);

    }else {
        if (hclinfo)
            LocalFree (hclinfo);
    }
    return retval;

}

BOOL INTERNAL IsFormatAvailable (lpclient, cfFormat)
LPCLIENT        lpclient;
OLECLIPFORMAT   cfFormat;
{
      OLECLIPFORMAT  cfNext = 0;


      do{

#ifdef FIREWALLS
        if (!CheckPointer (lpclient->lpoleobject, WRITE_ACCESS))
            ASSERT (0, "Invalid LPOLEOBECT")
        else if (!CheckPointer (lpclient->lpoleobject->lpvtbl, WRITE_ACCESS))
            ASSERT (0, "Invalid LPOLEOBJECTVTBL")
        else
            ASSERT (lpclient->lpoleobject->lpvtbl->EnumFormats,
                "Invalid pointer to EnumFormats method")
#endif

        cfNext = (*lpclient->lpoleobject->lpvtbl->EnumFormats)
                                (lpclient->lpoleobject, cfNext);
        if (cfNext == cfFormat)
            return TRUE;

      }while (cfNext != 0);

      return FALSE;
}

//ScanItemOptions: Scan for the item options like Close/Save etc.

OLESTATUS INTERNAL ScanItemOptions (lpbuf, lpoptions)
LPSTR   lpbuf;
int far *lpoptions;
{

    ATOM    aModifier;

    *lpoptions = OLE_CHANGED;
    while ( *lpbuf && *lpbuf != '/')
    {
#if	defined(FE_SB)						//[J1]
	   lpbuf = AnsiNext( lpbuf );				//[J1]
#else								//[J1]
           lpbuf++;
#endif
    }								//[J1]

    // no modifier same as /change

    if (*lpbuf == NULL)
        return OLE_OK;

    *lpbuf++ = NULL;        // seperate out the item string
                            // We are using this in the caller.

    if (!(aModifier = GlobalFindAtom (lpbuf)))
        return OLE_ERROR_SYNTAX;

    if (aModifier == aChange)
        return OLE_OK;

    // Is it a save?
    if (aModifier == aSave){
        *lpoptions = OLE_SAVED;
        return  OLE_OK;
    }
    // Is it a Close?
    if (aModifier == aClose){
        *lpoptions = OLE_CLOSED;
        return OLE_OK;
    }

    // unknow modifier
    return OLE_ERROR_SYNTAX;

}

//RequestData: Sends data in response to a DDE Request message.
// for  agiven doc and an object.

OLESTATUS INTERNAL   RequestData (lpdoc, hwndClient, lparam, lphdde)
LPDOC       lpdoc;
HWND        hwndClient;
LONG        lparam;
LPHANDLE    lphdde;
{

    OLESTATUS   retval = OLE_OK;
    HANDLE      hdata;
    LPCLIENT    lpclient;
    char        buf[6];

    // If edit environment Send data if we can
    if ((HIWORD (lparam)) == aEditItems)
        return RequestDataStd (lparam, lphdde);

    // Get the object.
    retval = FindItem (lpdoc, (LPSTR) MAKEINTATOM(HIWORD(lparam)),
                (LPCLIENT FAR *)&lpclient);
    if (retval != OLE_OK)
        goto errRtn;

    retval = OLE_ERROR_DATATYPE;
    if (!IsFormatAvailable (lpclient, (int)(LOWORD (lparam))))
        goto errRtn;

    // Now ask the item for the given format  data

#ifdef FIREWALLS
    ASSERT (lpclient->lpoleobject->lpvtbl->GetData,
        "Invalid pointer to GetData method")
#endif

    MapToHexStr ((LPSTR)buf, hwndClient);
    SendDevInfo (lpclient, (LPSTR)buf);

    retval = (*lpclient->lpoleobject->lpvtbl->GetData) (lpclient->lpoleobject,
                (int)(LOWORD (lparam)), (LPHANDLE)& hdata);

    if (retval != OLE_OK)
        goto errRtn;

    if (LOWORD(lparam) == CF_METAFILEPICT)
        ChangeOwner (hdata);

    // Duplicate the DDE data
    if(MakeDDEData(hdata, (int)(LOWORD (lparam)), lphdde, TRUE)){
        // !!! Why do we have to duplicate the atom
        DuplicateAtom ((ATOM)(HIWORD (lparam)));
        return OLE_OK;
    }
    else
        return OLE_ERROR_MEMORY;

errRtn:
    return retval;

}

//MakeDDEData: Create a Global DDE data handle from the server
// app data handle.

BOOL    INTERNAL MakeDDEData (hdata, format, lph, fResponse)
HANDLE      hdata;
LPHANDLE    lph;
int         format;
BOOL        fResponse;
{
    DWORD       size;
    HANDLE      hdde   = NULL;
    DDEDATA FAR *lpdata= NULL;
    BOOL        bnative;
    LPSTR       lpdst;
    LPSTR       lpsrc;

    if (!hdata) {
        *lph = NULL;
        return TRUE;
    }

    if (bnative = !(format == CF_METAFILEPICT || format == CF_DIB ||
                            format == CF_BITMAP))
       size = GlobalSize (hdata) + sizeof (DDEDATA);
    else
       size = sizeof (LONG) + sizeof (DDEDATA);


    hdde = (HANDLE) GlobalAlloc (GMEM_DDESHARE | GMEM_ZEROINIT, size);
    if (hdde == NULL || (lpdata = (DDEDATA FAR *) GlobalLock (hdde)) == NULL)
        goto errRtn;

    // set the data otions. Ask the client to delete
    // it always.

    lpdata->fRelease = TRUE;  // release the data
    lpdata->cfFormat = format;
    lpdata->fResponse = fResponse;

    if (!bnative)
        // If not native, stick in the handle what the server gave us.
        *(LPHANDLE)lpdata->Value = hdata;

    else {
        // copy the native data junk here.
        lpdst = (LPSTR)lpdata->Value;
        if(!(lpsrc = (LPSTR)GlobalLock (hdata)))
            goto errRtn;

         size -= sizeof (DDEDATA);
         UtilMemCpy (lpdst, lpsrc, size);
         GlobalUnlock (hdata);
         GlobalFree (hdata);

    }

    GlobalUnlock (hdde);
    *lph = hdde;
    return TRUE;

errRtn:
    if (lpdata)
        GlobalUnlock (hdde);

    if (hdde)
        GlobalFree (hdde);

    if (bnative)
         GlobalFree (hdata);

    return FALSE;
}


// ItemCallback: Calback routine for the server to inform the
// data changes. When the change message is received, DDE data
// message is sent to each of the clients depending on the
// options.

int FAR PASCAL  ItemCallback (lpoleclient, msg, lpoleobject)
LPOLECLIENT     lpoleclient;
WORD            msg;        // notification message
LPOLEOBJECT     lpoleobject;
{

    LPCLIENT    lpclient;
    int         retval = OLE_OK;
    HANDLE      hdata  = NULL;
    LPSTR       lpdata = NULL;
    LPDOC       lpdoc;
    HWND        hStdWnd;

    lpclient  = (LPCLIENT)lpoleclient;
    lpdoc = (LPDOC)GetWindowLong (GetParent (lpclient->hwnd), 0);

    if (msg == OLE_RENAMED) {
#ifdef FIREWALLS
        if (!CheckPointer (lpoleobject, WRITE_ACCESS))
          ASSERT (0, "Invalid lpoleobject")
        else if (!CheckPointer (lpoleobject->lpvtbl, WRITE_ACCESS))
            ASSERT (0, "Invalid LPOLEOBJECTVTBL")
        else
            ASSERT (lpoleobject->lpvtbl->GetData,
                "Invalid pointer to GetData method")
#endif

        if (IsFormatAvailable (lpclient, cfLink)) {

            // Get the link data.

            retval = (*lpoleobject->lpvtbl->GetData) (lpoleobject,
                                (int)cfLink, (LPHANDLE)&hdata);
        }
        else {
            if(IsFormatAvailable (lpclient, cfOwnerLink)) {

                // Get the link data.
                retval = (*lpoleobject->lpvtbl->GetData) (lpoleobject,
                                    (int)cfOwnerLink, (LPHANDLE)& hdata);
#ifdef  FIREWALLS
                ASSERT (retval != OLE_BUSY, "Getdata returns with OLE_BUSY")
#endif


            } else
                retval = OLE_ERROR_DATATYPE;
        }

        if (retval != OLE_OK)
            goto errrtn;

        if (!(lpdata = (LPSTR)GlobalLock (hdata)))
            goto errrtn;

        if (lpdoc->aDoc) {
            GlobalDeleteAtom (lpdoc->aDoc);
            lpdoc->aDoc = NULL;
        }

        // Move the string to the beginning and still terminated by null;
        lstrcpy (lpdata, lpdata + lstrlen (lpdata) + 1);
        lpdoc->aDoc = GlobalAddAtom (lpdata);

        // Now make the DDE data block
        GlobalUnlock (hdata);
        lpdata = NULL;

        // find if any StdDocName item is present at all
        if (!(hStdWnd = SearchItem (lpdoc, (LPSTR) MAKEINTATOM(aStdDocName))))
            GlobalFree (hdata);
        else {

            // hdata is freed by Makeddedata
            if (!MakeDDEData (hdata, (int)cfBinary, (LPHANDLE)&hddeRename,
                        FALSE)) {
                retval = OLE_ERROR_MEMORY;
                goto errrtn;
            }

            EnumProps(hStdWnd, lpSendRenameMsg);
            // post all the messages with yield which have been collected in enum
            // UnblockPostMsgs (hStdWnd, FALSE);
            GlobalFree (hddeRename);
        }

        // static. Avoid this. This may not cause any problems for now.
        // if there is any better way, change it.
        hwndRename = hStdWnd;

        // Post termination for each of the doc clients.
        EnumProps (lpdoc->hwnd, lpEnumForTerminate);

        lpdoc->fEmbed = FALSE;

        // post all the messages with yield which have been collected in enum
        // UnblockPostMsgs (lpdoc->hwnd, FALSE);
        return OLE_OK;

     errrtn:
        if (lpdata)
            GlobalUnlock (hdata);

        if (hdata)
            GlobalFree (hdata);

        return retval;

    } else {

        // !!! any better way to do instead of putting in static
        // (There may not be any problems since we are not allowing
        // any messages to get thru while we are posting messages).


        if ((enummsg = msg) == OLE_SAVED)
            fAdviseSaveItem = FALSE;

        enumlpoleobject = lpoleobject;

#ifdef  FIREWALLS
        ASSERT (lpclient->hwnd && IsWindowValid (lpclient->hwnd), " Not valid object")
#endif

        // Enumerate all the clients and send DDE_DATA if necessary.
        EnumProps(lpclient->hwnd, lpSendDataMsg);
        // post all the messages with yield which have been collected in enum
        // UnblockPostMsgs (lpclient->hwnd, FALSE);

        if ((msg == OLE_SAVED) && lpdoc->fEmbed && !fAdviseSaveItem)
            return OLE_ERROR_CANT_UPDATE_CLIENT;

        return OLE_OK;
    }
}


BOOL    FAR PASCAL  EnumForTerminate (hwnd, lpstr, hdata)
HWND    hwnd;
LPSTR   lpstr;
HANDLE  hdata;
{

    LPDOC   lpdoc;

    lpdoc = (LPDOC)GetWindowLong (hwnd , 0);

    // This client is in the rename list. So, no terminate
    if(hwndRename && FindClient (hwndRename, (HWND)hdata))
        return TRUE;


    if (PostMessageToClientWithBlock ((HWND)hdata, WM_DDE_TERMINATE,  hwnd, NULL))
        lpdoc->termNo++;

    //DeleteClient (hwnd, (HWND)hdata);
    //lpdoc->cClients--;
    return TRUE;
}


BOOL    FAR PASCAL  SendRenameMsg (hwnd, lpstr, hclinfo)
HWND    hwnd;
LPSTR   lpstr;
HANDLE  hclinfo;
{
    ATOM        aData    = NULL;
    HANDLE      hdde     = NULL;
    PCLINFO     pclinfo = NULL;
    HWND        hwndClient;

    if (!(pclinfo = (PCLINFO) LocalLock (hclinfo)))
        goto errrtn;

    // Make the item atom with the options.
    aData =  DuplicateAtom (aStdDocName);
    hdde  = DuplicateData (hddeRename);

    hwndClient  = pclinfo->hwnd;
    LocalUnlock (hclinfo);

    // Post the message
    if (!PostMessageToClientWithBlock (hwndClient, WM_DDE_DATA, (HWND)GetParent (hwnd),
            MAKELONG (hdde, aData)))
        goto errrtn;

    return TRUE;

errrtn:

    if (hdde)
        GlobalFree (hdde);
    if (aData)
        GlobalDeleteAtom (aData);

    return TRUE;

}



//SendDataMsg: Send data to the clients, if the data change options
//match the data advise options.

BOOL    FAR PASCAL  SendDataMsg (hwnd, lpstr, hclinfo)
HWND    hwnd;
LPSTR   lpstr;
HANDLE  hclinfo;
{
    PCLINFO     pclinfo = NULL;
    HANDLE      hdde    = NULL;
    ATOM        aData   = NULL;
    int         retval;
    HANDLE      hdata;
    LPCLIENT    lpclient;


    if (!(pclinfo = (PCLINFO) LocalLock (hclinfo)))
        goto errRtn;

    lpclient = (LPCLIENT)GetWindowLong (hwnd, 0);

#ifdef  FIREWALLS
    ASSERT ((CheckPointer(lpclient, WRITE_ACCESS)),
        "In Item the client handle missing")
#endif

    // if the client dead, then no message
    if (!IsWindowValid(pclinfo->hwnd))
        goto errRtn;

    if (pclinfo->options & (0x0001 << enummsg)) {
        fAdviseSaveItem = TRUE;
        SendDevInfo (lpclient, lpstr);

        // send message if the client needs data for every change or
        // only for the selective ones he wants.

        // now look for the data option.
        if (pclinfo->bnative){
            // prepare native data
            if (pclinfo->bdata){

                // Wants the data with DDE_DATA message
                // Get native data from the server.

#ifdef FIREWALLS
                if (!CheckPointer (enumlpoleobject, WRITE_ACCESS))
                    ASSERT (0, "Invalid LPOLEOBECT")
                else if (!CheckPointer (enumlpoleobject->lpvtbl,WRITE_ACCESS))
                    ASSERT (0, "Invalid LPOLEOBJECTVTBL")
                else
                    ASSERT (enumlpoleobject->lpvtbl->GetData,
                        "Invalid pointer to GetData method")
#endif

                retval = (*enumlpoleobject->lpvtbl->GetData) (enumlpoleobject,
                            (int)cfNative, (LPHANDLE)& hdata);
#ifdef  FIREWALLS
                ASSERT (retval != OLE_BUSY, "Getdata returns with OLE_BUSY");
#endif
                if (retval != OLE_OK)
                    goto errRtn;

                // Prepare the DDE data block.
                if(!MakeDDEData (hdata, (int)cfNative, (LPHANDLE)&hdde, FALSE))
                    goto errRtn;

            }


            // Make the item atom with the options.
            aData =  MakeDataAtom (lpclient->aItem, enummsg);
            // Post the message
            if (!PostMessageToClientWithBlock (pclinfo->hwnd, WM_DDE_DATA,
                    (HWND)GetParent (hwnd), MAKELONG (hdde, aData)))
                goto errRtn;
            hdde = NULL;
            aData = NULL;
        }

        // Now post the data for the disply format
        if (pclinfo->format){
            if (pclinfo->bdata){
#ifdef FIREWALLS
                if (!CheckPointer (enumlpoleobject, WRITE_ACCESS))
                    ASSERT (0, "Invalid LPOLEOBECT")
                else if (!CheckPointer (enumlpoleobject->lpvtbl,WRITE_ACCESS))
                    ASSERT (0, "Invalid LPOLEOBJECTVTBL")
                else
                    ASSERT (enumlpoleobject->lpvtbl->GetData,
                        "Invalid pointer to GetData method")
#endif
                retval = (*enumlpoleobject->lpvtbl->GetData) (enumlpoleobject,
                            pclinfo->format, (LPHANDLE)& hdata);

#ifdef  FIREWALLS
                ASSERT (retval != OLE_BUSY, "Getdata returns with OLE_BUSY");
#endif
                if (retval != OLE_OK)
                    goto errRtn;

                if (pclinfo->format == CF_METAFILEPICT)
                    ChangeOwner (hdata);

                if(!MakeDDEData (hdata, pclinfo->format, (LPHANDLE)&hdde, FALSE))
                    goto errRtn;

            }

            // atom is deleted. So, we need to duplicate for every post
            aData =  MakeDataAtom (lpclient->aItem, enummsg);
            // now post the message to the client;
            if (!PostMessageToClientWithBlock (pclinfo->hwnd, WM_DDE_DATA,
                    (HWND)GetParent (hwnd), MAKELONG (hdde, aData)))
                goto errRtn;

            hdde = NULL;
            aData = NULL;

        }

    }


errRtn:
    if (pclinfo)
        LocalUnlock (hclinfo);

    if (hdde)
        GlobalFree (hdde);

    if (aData)
        GlobalDeleteAtom (aData);

    return TRUE;

}


// IsAdviseStdItems: returns true if the item is one of the standard items
// StdDocName;
BOOL    INTERNAL IsAdviseStdItems (aItem)
ATOM   aItem;
{

    if ( aItem == aStdDocName)
        return TRUE;
    else
        return FALSE;
}

// GetStdItemIndex: returns index to Stditems in the "stdStrTable" if the item
// is one of the standard items StdHostNames, StdTargetDevice,
// StdDocDimensions, StdColorScheme

int INTERNAL GetStdItemIndex (aItem)
ATOM   aItem;
{
    char    str[MAX_STR];

    if (!aItem)
        return NULL;

    if (!GlobalGetAtomName (aItem, (LPSTR) str, MAX_STR))
        return NULL;

    if (!lstrcmpi (str, stdStrTable[STDTARGETDEVICE]))
        return STDTARGETDEVICE;
    else if (!lstrcmpi (str, stdStrTable[STDHOSTNAMES]))
        return STDHOSTNAMES;
    else if (!lstrcmpi (str, stdStrTable[STDDOCDIMENSIONS]))
        return STDDOCDIMENSIONS;
    else if (!lstrcmpi (str, stdStrTable[STDCOLORSCHEME]))
        return STDCOLORSCHEME;

    return NULL;
}


// PokeStdItems: Pokes the data for the standard items.
// For StdHostnames, StdDocDimensions and SetColorScheme the data is
// sent immediately and for the the StdTargetDeviceinfo the
// data is set in each client block and the data is sent just
// before the GetData call for rendering the right data.


OLESTATUS    INTERNAL PokeStdItems (lpdoc, hwndClient, lparam)
LPDOC   lpdoc;
HWND    hwndClient;
LONG    lparam;
{
    int             index;
    DDEDATA FAR *   lpdata = NULL;
    HANDLE          hdata  = NULL;
    HANDLE          hnew   = NULL;
    LPOLESERVERDOC   lpoledoc;
    LPHOSTNAMES     lphostnames;
    OLESTATUS       retval = OLE_ERROR_MEMORY;
    int             format;
    BOOL            fRelease;
    RECT            rcDoc;

    index = HIWORD(lparam);
    hdata = (HANDLE)(LOWORD (lparam));
    if(!(hdata && (lpdata = (DDEDATA FAR *)GlobalLock (hdata))))
        goto errRtn;

    format   = lpdata->cfFormat;
    fRelease = lpdata->fRelease;

#ifdef FIREWALSS
    ASSERT (format == (int)cfBinary, "Format is not binary");
#endif

    // we have extracted the data successfully.
    lpoledoc = lpdoc->lpoledoc;
#ifdef FIREWALLS
        if (!CheckPointer (lpoledoc, WRITE_ACCESS))
            ASSERT (0, "Invalid LPOLESERVERDOC")
        else if (!CheckPointer (lpoledoc->lpvtbl, WRITE_ACCESS))
            ASSERT (0, "Invalid LPOLESERVERDOCVTBL")
#endif

    if (index == STDHOSTNAMES){
        lphostnames = (LPHOSTNAMES)lpdata->Value;
#ifdef FIREWALLS
        ASSERT (lpoledoc->lpvtbl->SetHostNames,
            "Invalid pointer to SetHostNames method")
#endif
        retval = (*lpoledoc->lpvtbl->SetHostNames)(lpdoc->lpoledoc,
                       (LPSTR)lphostnames->data,
                       ((LPSTR)lphostnames->data) +
                        lphostnames->documentNameOffset);
        goto end;
    }

    if (index == STDDOCDIMENSIONS){
#ifdef FIREWALLS
        ASSERT (lpoledoc->lpvtbl->SetDocDimensions,
            "Invalid pointer to SetDocDimensions method")
#endif
        rcDoc.left   = 0;
        rcDoc.top    = ((LPRECT)(lpdata->Value))->top;
        rcDoc.bottom = 0;
        rcDoc.right  = ((LPRECT)lpdata->Value)->left;

        retval = (*lpoledoc->lpvtbl->SetDocDimensions)(lpdoc->lpoledoc,
                                            (LPRECT)&rcDoc);

        goto end;

    }

    if (index == STDCOLORSCHEME) {
#ifdef FIREWALLS
        ASSERT (lpoledoc->lpvtbl->SetColorScheme,
            "Invalid pointer to SetColorScheme method")
#endif
        retval = (*lpoledoc->lpvtbl->SetColorScheme)(lpdoc->lpoledoc,
                                            (LPLOGPALETTE) lpdata->Value);
        goto end;
    }
#ifdef FIREWALLS
    ASSERT (index == STDTARGETDEVICE, "Unknown standard item");
#endif

    // case of the printer decvice info

    if (!(hnew = MakeItemData ((DDEPOKE FAR *)lpdata, hdata, format)))
        goto errRtn;

    // Go thru the all the items lists for this doc and replace the
    // printer device info information.
    // Free the block we duplicated.
    retval = SetStdInfo (lpdoc, hwndClient,
                (LPSTR) (MAKELONG(STDTARGETDEVICE,0)),hnew);


end:
errRtn:
    if (hnew)
        // can only be global memory block
        GlobalFree (hnew);

    if (lpdata) {
        GlobalUnlock (hdata);
        if (retval == OLE_OK && fRelease)
            GlobalFree (hdata);
    }
    return retval;
}


// SetStdInfo: Sets the targetdevice info. Creates a client
// for "StdTargetDevice". This item is created only within the
// lib and it is never visible in server app. When the change
// message comes from the server app, before we ask for
// the data, we send the targetdevice info if there is
// info for the client whom we are trying to send the data
// on advise.


int INTERNAL   SetStdInfo (lpdoc, hwndClient, lpitemname, hdata)
LPDOC   lpdoc;
HWND    hwndClient;
LPSTR   lpitemname;
HANDLE  hdata;
{
    HWND        hwnd;
    HANDLE      hclinfo  = NULL;
    PCLINFO    pclinfo = NULL;
    LPCLIENT    lpclient;
    OLESTATUS   retval   = OLE_OK;


    // first create/find the StdTargetDeviceItem.

    if ((hwnd = SearchItem (lpdoc, lpitemname))
                == NULL){
         retval = RegisterItem ((LHDOC)lpdoc, lpitemname,
                          (LPCLIENT FAR *)&lpclient, FALSE);

         if (retval != OLE_OK)
            goto errRtn;

         hwnd = lpclient->hwnd;

      }

#ifdef  FIREWALLS
      ASSERT (retval == OLE_OK, "No StdTragetDevice or StdDocname item");
#endif


    if(hclinfo = FindClient (hwnd, hwndClient)){
        if (pclinfo = (PCLINFO) LocalLock (hclinfo)){
            if (pclinfo->hdevInfo)
                GlobalFree (pclinfo->hdevInfo);
            pclinfo->bnewDevInfo = TRUE;
            if (hdata)
                pclinfo->hdevInfo = DuplicateData (hdata);
            else
                pclinfo->hdevInfo = NULL;
            pclinfo->hwnd = hwndClient;
            LocalUnlock (hclinfo);

            // We do not have to reset the client because we did not
            // change the handle it self.
        }
    } else {
        // Create the client structure to be attcahed to the object.
        hclinfo = LocalAlloc (LMEM_MOVEABLE | LMEM_ZEROINIT, sizeof (CLINFO));
        if (hclinfo == NULL || (pclinfo = (PCLINFO) LocalLock (hclinfo)) == NULL)
            goto errRtn;

        pclinfo->bnewDevInfo = TRUE;
        if (hdata)
            pclinfo->hdevInfo = DuplicateData (hdata);
        else
            pclinfo->hdevInfo = NULL;

        pclinfo->hwnd = hwndClient;
        LocalUnlock (hclinfo);


        // Now add this client to item client list
        // !!! This error recovery is not correct.
        if (!AddClient (hwnd, hwndClient, hclinfo))
            goto errRtn;

    }
    return OLE_OK;
errRtn:
    if (pclinfo)
        LocalUnlock (hclinfo);

    if (hclinfo)
        LocalFree (hclinfo);
    return OLE_ERROR_MEMORY;
}


// SendDevInfo: Sends targetdevice info to the  the object.
// Caches the last targetdevice info sent to the object.
// If the targetdevice block is same as the one in the
// cache, then no targetdevice info is sent.
// (!!! There might be some problem here getting back
// the same global handle).

void INTERNAL    SendDevInfo (lpclient, lppropname)
LPCLIENT    lpclient;
LPSTR       lppropname;
{

    HANDLE      hclinfo  = NULL;
    PCLINFO    pclinfo = NULL;
    HANDLE      hdata;
    OLESTATUS   retval;
    HWND        hwnd;
    LPDOC       lpdoc;



    lpdoc = (LPDOC)GetWindowLong (GetParent (lpclient->hwnd), 0);

    // find if any StdTargetDeviceInfo item is present at all
    hwnd = SearchItem (lpdoc, (LPSTR) (MAKELONG(STDTARGETDEVICE, 0)));
    if (hwnd == NULL)
        return;

    hclinfo = GetProp (hwnd, lppropname);

    // This client has not set any target device info. no need to send
    // any stdtargetdevice info
    if (hclinfo != NULL) {
        if (!(pclinfo = (PCLINFO)LocalLock (hclinfo)))
            goto end;

        // if we cached it, do not send it again.
        if ((!pclinfo->bnewDevInfo) && pclinfo->hdevInfo == lpclient->hdevInfo)
            goto end;

        pclinfo->bnewDevInfo = FALSE;
        if(!(hdata = DuplicateData (pclinfo->hdevInfo)))
            goto end;
    } else {

        // already screen
        if (!lpclient->hdevInfo)
            goto end;

        //for screen send NULL.
        hdata = NULL;
    }


    // Now send the targetdevice info
#ifdef FIREWALLS
        if (!CheckPointer (lpclient->lpoleobject, WRITE_ACCESS))
            ASSERT (0, "Invalid LPOLEOBECT")
        else if (!CheckPointer (lpclient->lpoleobject->lpvtbl, WRITE_ACCESS))
            ASSERT (0, "Invalid LPOLEOBJECTVTBL")
        else
            ASSERT (lpclient->lpoleobject->lpvtbl->SetTargetDevice,
                "Invalid pointer to SetTargetDevice method")
#endif
    retval = (*lpclient->lpoleobject->lpvtbl->SetTargetDevice)
                    (lpclient->lpoleobject, hdata);

    if (retval == OLE_OK) {
        if (pclinfo)
            lpclient->hdevInfo = pclinfo->hdevInfo;
        else
            lpclient->hdevInfo = NULL;

    }
    // !!! error case who frees the data?'

end:
    if (pclinfo)
        LocalUnlock (hclinfo);

    return;
}

void ChangeOwner (hmfp)
HANDLE hmfp;
{
    LPMETAFILEPICT  lpmfp;

    if (lpmfp = (LPMETAFILEPICT) GlobalLock (hmfp)) {
        if (bWin30)
            GiveToGDI (lpmfp->hMF);
        else {
            if (lpfnSetMetaFileBitsBetter)
                (*lpfnSetMetaFileBitsBetter) (lpmfp->hMF);
        }

        GlobalUnlock (hmfp);
    }
}


HANDLE INTERNAL MakeItemData (lpPoke, hPoke, cfFormat)
DDEPOKE FAR *   lpPoke;
HANDLE          hPoke;
OLECLIPFORMAT   cfFormat;
{
    HANDLE  hnew;
    LPSTR   lpnew;
    DWORD   dwSize;

    if (cfFormat == CF_METAFILEPICT)
        return DuplicateMetaFile (*(LPHANDLE)lpPoke->Value);

    if (cfFormat == CF_BITMAP)
        return DuplicateBitmap (*(LPHANDLE)lpPoke->Value);

    if (cfFormat == CF_DIB)
        return DuplicateData (*(LPHANDLE)lpPoke->Value);

    // Now we are dealing with normal case
    if (!(dwSize = GlobalSize (hPoke)))
        return NULL;

    dwSize = dwSize - sizeof (DDEPOKE) + sizeof(BYTE);

    if (hnew = GlobalAlloc (GMEM_MOVEABLE, dwSize)) {
        if (lpnew = GlobalLock (hnew)) {
            UtilMemCpy (lpnew, (LPSTR) lpPoke->Value, dwSize);
            GlobalUnlock (hnew);
        }
        else {
            GlobalFree (hnew);
            hnew = NULL;
        }
    }

    return hnew;
}



HANDLE INTERNAL DuplicateMetaFile (hSrcData)
HANDLE hSrcData;
{
    LPMETAFILEPICT  lpSrcMfp;
    LPMETAFILEPICT  lpDstMfp = NULL;
    HANDLE          hMF = NULL;
    HANDLE          hDstMfp = NULL;

    if (!(lpSrcMfp = (LPMETAFILEPICT) GlobalLock(hSrcData)))
        return NULL;

    GlobalUnlock (hSrcData);

    if (!(hMF = CopyMetaFile (lpSrcMfp->hMF, NULL)))
        return NULL;

    if (!(hDstMfp = GlobalAlloc (GMEM_MOVEABLE, sizeof(METAFILEPICT))))
        goto errMfp;

    if (!(lpDstMfp = (LPMETAFILEPICT) GlobalLock (hDstMfp)))
        goto errMfp;

    GlobalUnlock (hDstMfp);

    *lpDstMfp = *lpSrcMfp;
    lpDstMfp->hMF = hMF;
    return hDstMfp;
errMfp:
    if (hMF)
        DeleteMetaFile (hMF);

    if (hDstMfp)
        GlobalFree (hDstMfp);

     return NULL;
}



HBITMAP INTERNAL DuplicateBitmap (hold)
HBITMAP     hold;
{
    HBITMAP     hnew;
    HANDLE      hMem;
    LPSTR       lpMem;
    LONG        retVal = TRUE;
    DWORD       dwSize;
    BITMAP      bm;

     // !!! another way to duplicate the bitmap

    GetObject (hold, sizeof(BITMAP), (LPSTR) &bm);
    dwSize = ((DWORD) bm.bmHeight) * ((DWORD) bm.bmWidthBytes) *
             ((DWORD) bm.bmPlanes) * ((DWORD) bm.bmBitsPixel);

    if (!(hMem = GlobalAlloc (GMEM_MOVEABLE | GMEM_ZEROINIT, dwSize)))
        return NULL;

    if (!(lpMem = GlobalLock (hMem))){
        GlobalFree (hMem);
        return NULL;
    }

    GetBitmapBits (hold, dwSize, lpMem);
    if (hnew = CreateBitmap (bm.bmWidth, bm.bmHeight,
                    bm.bmPlanes, bm.bmBitsPixel, NULL))
        retVal = SetBitmapBits (hnew, dwSize, lpMem);

    GlobalUnlock (hMem);
    GlobalFree (hMem);

    if (hnew && (!retVal)) {
        DeleteObject (hnew);
        hnew = NULL;
    }

    return hnew;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\ole\server\chp\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake  /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DFE_SB -DDBCS -DPRC"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\ole\server\olever.h ===
#include <ver.h>

#ifndef DEBUG
#define OLEVER_DEBUG        0
#else
#define OLEVER_DEBUG        1
#endif


#ifndef OFFICIAL
#define OLEVER_PRIVATEBUILD 1
#else
#define OLEVER_PRIVATEBUILD 0
#endif


#ifndef FINAL
#define OLEVER_PRERELEASE   1
#else
#define OLEVER_PRERELEASE   0
#endif

#define OLEVER_FILEFLAGS    (OLEVER_PRIVATEBUILD|OLEVER_PRERELEASE|OLEVER_DEBUG)

#ifdef NT
#define OLEVER_FILEOS           VOS_WINDOWS32
#define OLEVER_FILEVERSION      1,03, 001
#define OLEVER_PRODUCTVERSION   3,10,0,043
#elseif PWIN
#define OLEVER_FILEOS           VOS_DOS_WINDOWS16
#define OLEVER_FILEVERSION      1,10
#define OLEVER_PRODUCTVERSION   3,10,0,043
#else
#define OLEVER_FILEOS           VOS_DOS_WINDOWS16
#define OLEVER_FILEVERSION      1,03, 001
#define OLEVER_PRODUCTVERSION   3,10,0,043
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\ole\server\srvr.c ===
/****************************** Module Header ******************************\
* Module Name: Srvr.c Server Main module
*
* Purpose: Includes All the server communication related routines.
*
* Created: Oct 1990.
*
* Copyright (c) 1985, 1986, 1987, 1988, 1989  Microsoft Corporation
*
* History:
*    Raor:   Wrote the original version.
*
*
\***************************************************************************/

#include <windows.h>
#include <shellapi.h>
#include "cmacs.h"
#include "ole.h"
#include "dde.h"
#include "srvr.h"

// LOWWORD - BYTE 0 major verision, BYTE1 minor version,
// HIWORD is reserved

#define OLE_VERSION 0x1001L


extern ATOM    aOLE;
extern ATOM    aSysTopic;
extern ATOM    aStdExit;
extern ATOM    aStdCreate;
extern ATOM    aStdOpen;
extern ATOM    aStdEdit;
extern ATOM    aStdCreateFromTemplate;
extern ATOM    aStdShowItem;
extern ATOM    aProtocols;
extern ATOM    aTopics;
extern ATOM    aFormats;
extern ATOM    aStatus;
extern ATOM    cfNative;
extern ATOM    aEditItems;
extern ATOM    aStdClose;


extern HANDLE  hdllInst;
extern BOOL    bProtMode;

extern FARPROC lpTerminateClients;

#ifdef FIREWALLS
BOOL    bShowed = FALSE;
void    ShowVersion (void);
#endif


DWORD FAR PASCAL  OleQueryServerVersion ()
{
    return OLE_VERSION;
}


/***************************** Public  Function ****************************\
* OLESTATUS FAR PASCAL  OleRegisterServer (lpclass, lpolesrvr, lplhsrvr)
*
* OleRegisterServer: Registers the server with the server library.
*
* Parameters:
*       1. Ptr to the server class.
*       2. Ptr to the olesrvr. This is private to the server app.
*          (Typically this is the ptr to the private storage area of
*           server app server related info).
*       3. Ptr to the LHSRVR. Place where to pass back the long
*          handle of the server in DLL (This is private to the DLL).
*
* return values:
*        returns OLE_OK if the server is successfully registered .
*        else returns the corresponding error.
*
*
* History:
*   Raor:   Wrote it,
\***************************************************************************/

OLESTATUS FAR PASCAL  OleRegisterServer (lpclass, lpolesrvr, lplhsrvr, hInst, useFlags)
LPCSTR          lpclass;            // class name
LPOLESERVER     lpolesrvr;          // ole srvr(private to srvr app)
LHSRVR FAR *    lplhsrvr;           // where we pass back our private handle
HANDLE          hInst;
OLE_SERVER_USE  useFlags;
{

    HANDLE  hsrvr  = NULL;
    LPSRVR  lpsrvr = NULL;
    ATOM    aExe = NULL;

    Puts ("OleRegisterServer");

    if (!bProtMode)
       return OLE_ERROR_PROTECT_ONLY;

    PROBE_READ((LPSTR)lpclass);
    PROBE_WRITE(lpolesrvr);
    PROBE_WRITE(lplhsrvr);

    // add the app atom to global list
    if (!ValidateSrvrClass ((LPSTR)lpclass, &aExe))
        return OLE_ERROR_CLASS;

    hsrvr = GlobalAlloc (GMEM_MOVEABLE | GMEM_ZEROINIT | GMEM_DDESHARE, sizeof (SRVR));
    if (! (hsrvr && (lpsrvr = (LPSRVR)GlobalLock (hsrvr))))
        goto errReturn;

    // set the signature handle and the app atom.
    lpsrvr->sig[0]      = 'S';
    lpsrvr->sig[1]      = 'R';
    lpsrvr->hsrvr       = hsrvr;
    lpsrvr->aClass      = GlobalAddAtom (lpclass);
    lpsrvr->lpolesrvr   = lpolesrvr;
    lpsrvr->relLock     = TRUE;     // set the release lock.
    lpsrvr->aExe        = aExe;
    lpsrvr->useFlags    = useFlags;

#ifdef   FIREWALLS
    ASSERT ((useFlags == OLE_SERVER_SINGLE  || useFlags == OLE_SERVER_MULTI), "invalid server options");
#endif

    // Create the servre window and do not show it.
    if (!(lpsrvr->hwnd = CreateWindow ("SrvrWndClass", "Srvr",
        WS_OVERLAPPED,0,0,0,0,NULL,NULL, hdllInst, NULL)))
        goto errReturn;

    // save the ptr to the srever struct in the window.
    SetWindowLong (lpsrvr->hwnd, 0, (LONG)lpsrvr);

    // Set the signature.
    SetWindowWord (lpsrvr->hwnd, WW_LE, WC_LE);
    SetWindowWord (lpsrvr->hwnd, WW_HANDLE, (WORD)hInst);
    *lplhsrvr = (LONG)lpsrvr;

    return OLE_OK;

errReturn:
    if (lpsrvr){
        if (lpsrvr->hwnd)
            DestroyWindow (lpsrvr->hwnd);

        if (lpsrvr->aClass)
            GlobalDeleteAtom (lpsrvr->aClass);

        if (lpsrvr->aExe)
            GlobalDeleteAtom (lpsrvr->aExe);

        GlobalUnlock (hsrvr);
    }

    if (hsrvr)
        GlobalFree (hsrvr);

    return OLE_ERROR_MEMORY;

}


// ValidateSrvrClass checks whether the given server class is valid by
// looking in the win.ini.

BOOL INTERNAL    ValidateSrvrClass (lpclass, lpAtom)
LPSTR       lpclass;
ATOM FAR *  lpAtom;
{

    char    buf[MAX_STR];
    LONG    cb = MAX_STR;
    char    key[MAX_STR];
    LPSTR   lptmp;
    LPSTR   lpbuf;
    char    ch;

    lstrcpy (key, lpclass);
    lstrcat (key, "\\protocol\\StdFileEditing\\server");

    if (RegQueryValue (HKEY_CLASSES_ROOT, key, buf, &cb))
        return FALSE;

    if (!buf[0])
        return FALSE;

    // Get exe name without path and then get an atom for that

    lptmp = lpbuf = (LPSTR)buf;


#if	defined(FE_SB)						//[J1]
    while ( ch = *lptmp ) {					//[J1]
	lptmp = AnsiNext( lptmp );				//[J1]
#else								//[J1]
    while ((ch = *lptmp++) && ch != '\0') {
#endif								//[J1]

        if (ch == '\\' || ch == ':')
            lpbuf = lptmp;
    }
    *lpAtom =  GlobalAddAtom (lpbuf);

    return TRUE;
}


/***************************** Public  Function ****************************\
* OLESTATUS FAR PASCAL  OleRevokeServer (lhsrvr)
*
* OlerevokeServer: Unregisters the server which has been registered.
*
* Parameters:
*       1. DLL server handle.
*
*
* return values:
*        returns OLE_OK if the server is successfully unregisterd.
*        ( It is Ok for the app free the associated space).
*        If the unregistration is intiated, returns  OLE_STARTED.
*        Calls the Server class release entry point when the server
*        can be released.
*
* History:
*   Raor:   Wrote it,
\***************************************************************************/

OLESTATUS FAR PASCAL  OleRevokeServer (lhsrvr)
LHSRVR  lhsrvr;
{

    HWND         hwndSrvr;
    LPSRVR       lpsrvr;

    Puts ("OleRevokeServer");

    if (!CheckServer (lpsrvr = (LPSRVR)lhsrvr))
        return OLE_ERROR_HANDLE;

    if (lpsrvr->bTerminate  && lpsrvr->termNo)
        return OLE_WAIT_FOR_RELEASE;

    hwndSrvr = lpsrvr->hwnd;

#ifdef  FIREWALLS
    ASSERT (hwndSrvr, "Illegal server handle ")
#endif

    // Terminate the conversation with all clients.
    // If there are any clients to be terminated
    // return back with OLE_STARTED and srvr relase
    // will be called for releasing the server finally.

    // we are terminating.
    lpsrvr->bTerminate  = TRUE;
    lpsrvr->termNo      = 0;

    // send ack if Revoke is done as a result of StdExit
    if (lpsrvr->fAckExit) {
        // Post the acknowledge to the client
        if (!PostMessageToClient (lpsrvr->hwndExit, WM_DDE_ACK, lpsrvr->hwnd,
                            MAKELONG (0x8000, lpsrvr->hDataExit)))
            // if the window died or post failed, delete the atom.
            GlobalFree (lpsrvr->hDataExit);
    }

    // revoks all the documents registered with this server.
    RevokeAllDocs (lpsrvr);

    // enumerate all the clients which are in your list and post the
    // termination.
    EnumProps (hwndSrvr, lpTerminateClients);
    // post all the messages with yield which have been collected in enum
    // UnblockPostMsgs (hwndSrvr, TRUE);

    // reset the release lock. Now it is ok to release the server
    // when all the doc clients and server clients have sent back the
    // termination.

    lpsrvr->relLock = FALSE;
    return ReleaseSrvr (lpsrvr);

}


// ReleaseSrvr: Called when ever a matching WM_TERMINATE is received
// from doc clients or the server clients of a particular server.
// If there are no more terminates pending, it is ok to release the server.
// Calls the server app "release" proc for releasing the server.

int INTERNAL    ReleaseSrvr (lpsrvr)
LPSRVR      lpsrvr;
{

    HANDLE  hsrvr;


    // release srvr is called only when everything is
    // cleaned and srvr app can post WM_QUIT

    if (lpsrvr->bTerminate){
        // only if we are  revoking server then see whether it is ok to
        // call Release.

        // First check whethere any docs are active.
        // Doc window is a child window for server window.

        if (lpsrvr->termNo || GetWindow (lpsrvr->hwnd, GW_CHILD))
            return OLE_WAIT_FOR_RELEASE;

        // if the block queue is not empty, do not quit
        if (!IsBlockQueueEmpty(lpsrvr->hwnd))
            return OLE_WAIT_FOR_RELEASE;

    }

    if (lpsrvr->relLock)
        return OLE_WAIT_FOR_RELEASE;  // server is locked. So, delay releasing

    // Inform server app it is time to clean up and post WM_QUIT.

#ifdef FIREWALLS
    if (!CheckPointer (lpsrvr->lpolesrvr, WRITE_ACCESS))
        ASSERT(0, "Invalid LPOLESERVER")
    else if (!CheckPointer (lpsrvr->lpolesrvr->lpvtbl, WRITE_ACCESS))
        ASSERT(0, "Invalid LPOLESERVERVTBL")
    else
        ASSERT (lpsrvr->lpolesrvr->lpvtbl->Release,
            "Invalid pointer to Release method")
#endif

    (*lpsrvr->lpolesrvr->lpvtbl->Release)(lpsrvr->lpolesrvr);

    if (lpsrvr->aClass)
        GlobalDeleteAtom (lpsrvr->aClass);
    if (lpsrvr->aExe)
        GlobalDeleteAtom (lpsrvr->aExe);
    DestroyWindow (lpsrvr->hwnd);
    GlobalUnlock (hsrvr = lpsrvr->hsrvr);
    GlobalFree (hsrvr);
    return OLE_OK;
}


//TerminateClients: Call back for the enum properties.

BOOL    FAR PASCAL  TerminateClients (hwnd, lpstr, hdata)
HWND    hwnd;
LPSTR   lpstr;
HANDLE  hdata;
{
    LPSRVR  lpsrvr;

    lpsrvr = (LPSRVR)GetWindowLong (hwnd, 0);

    // If the client already died, no terminate.
    if (IsWindowValid ((HWND)hdata)) {
        lpsrvr->termNo++;

        // irrespective of the post, incremet the count, so
        // that client does not die.

        PostMessageToClientWithBlock ((HWND)hdata, WM_DDE_TERMINATE,  hwnd, NULL);
    }
    else
        ASSERT (FALSE, "TERMINATE: Client's System chanel is missing");

    return TRUE;
}


long FAR PASCAL SrvrWndProc (hwnd, msg, wParam, lParam)
HWND        hwnd;
WORD        msg;
WORD        wParam;
LONG        lParam;
{

    LPSRVR      lpsrvr;
    WORD        status = NULL;
    HWND        hwndClient;
    HANDLE      hdata;
    OLESTATUS   retval;

    if (AddMessage (hwnd, msg, wParam, lParam, WT_SRVR))
        return 0L;

    lpsrvr = (LPSRVR)GetWindowLong (hwnd, 0);


    switch (msg){

       case  WM_TIMER:
            UnblockPostMsgs (hwnd, FALSE);

            // if no more blocked message empty the queue.
            if (IsBlockQueueEmpty (hwnd))
                KillTimer (hwnd, wParam);

            if (lpsrvr->bTerminate && IsBlockQueueEmpty(lpsrvr->hwnd))
                    // Now see wheteher we can release the server .
                    ReleaseSrvr (lpsrvr);
            break;

       case WM_CREATE:
            DEBUG_OUT ("Srvr create window", 0)
            break;

       case WM_DDE_INITIATE:
#ifdef  FIREWALLS
    ASSERT (lpsrvr, "No server window handle in server window");
#endif

            DEBUG_OUT ("Srvr: DDE init",0);
            if (lpsrvr->bTerminate){
                DEBUG_OUT ("Srvr: No action due to termination process",0)
                break;
            }

            // class is not matching, so it is not definitely for us.
            // for apps sending the EXE for initiate, do not allow if the app
            // is mutiple server.

            if (!(lpsrvr->aClass == (ATOM)(LOWORD(lParam)) ||
                  (lpsrvr->aExe == (ATOM)(LOWORD(lParam)) && IsSingleServerInstance ())))

                break;

            if (!HandleInitMsg (lpsrvr, lParam)) {
                if (!(aSysTopic == (ATOM)(HIWORD(lParam)))) {

                    // if the server window is not the right window for
                    // DDE conversation, then try with the doc windows.
                    SendMsgToChildren (hwnd, msg, wParam, lParam);

                }
                break;
            }

            // We can enterain this client. Put him in our client list
            // and acknowledge the intiate.

            if (!AddClient (hwnd, (HWND)wParam, (HWND)wParam))
                break;

            lpsrvr->cClients++;
            lpsrvr->bnoRelease = FALSE;
            // add the atoms and post acknowledge

            DuplicateAtom (LOWORD(lParam));
            DuplicateAtom (HIWORD(lParam));

            SendMessage ((HWND)wParam, WM_DDE_ACK, (WORD)hwnd, lParam);
            break;

       case WM_DDE_EXECUTE:
#ifdef  FIREWALLS
    ASSERT (lpsrvr, "No server window handle in server window");
#endif
            DEBUG_OUT ("srvr: execute", 0)

#ifdef  FIREWALLS
            // find the client in the client list.
            hwndClient = FindClient (lpsrvr->hwnd, (HWND)wParam);
            ASSERT (hwndClient, "Client is missing from the server")
#endif
            // Are we terminating
            if (lpsrvr->bTerminate) {
                DEBUG_OUT ("Srvr: sys execute after terminate posted",0)
                // !!! are we supposed to free the data
                GlobalFree (HIWORD(lParam));
                break;
            }


            retval = SrvrExecute (hwnd, HIWORD (lParam), (HWND)wParam);
            SET_MSG_STATUS (retval, status)

            if (!lpsrvr->bTerminate) {
                // Post the acknowledge to the client
                if (!PostMessageToClient ((HWND)wParam, WM_DDE_ACK, hwnd,
                            MAKELONG (status, HIWORD(lParam))))
                    // if the window died or post failed, delete the atom.
                    GlobalFree (HIWORD(lParam));
            }

            break;

       case WM_DDE_TERMINATE:
            DEBUG_OUT ("Srvr: DDE terminate",0)

#ifdef  FIREWALLS
            // find the client in the client list.
            hwndClient = FindClient (lpsrvr->hwnd, (HWND)wParam);
            ASSERT (hwndClient, "Client is missing from the server")
#endif
            DeleteClient (lpsrvr->hwnd, (HWND)wParam);
            lpsrvr->cClients--;

            if (lpsrvr->bTerminate){
                if ((--lpsrvr->termNo == 0) && (IsBlockQueueEmpty (lpsrvr->hwnd)))
                    // Now see wheteher we can release the server .
                    ReleaseSrvr (lpsrvr);

                    // if we released the server, then
                    // by the time we come here,, we have destroyed the window

            }else {
                // If client intiated the terminate. post matching terminate
                PostMessageToClient ((HWND)wParam, WM_DDE_TERMINATE,
                            hwnd, NULL);

                // callback release tell the srvr app, it can exit if needs.
                // Inform server app it is time to clean up and post WM_QUIT.
                // only if no docs present.
#if 0
                if (lpsrvr->cClients == 0
                        && (GetWindow (lpsrvr->hwnd, GW_CHILD) == NULL)) {
#endif
                if (QueryRelease (lpsrvr)){

#ifdef FIREWALLS
                    if (!CheckPointer (lpsrvr->lpolesrvr, WRITE_ACCESS))
                        ASSERT (0, "Invalid LPOLESERVER")
                    else if (!CheckPointer (lpsrvr->lpolesrvr->lpvtbl,
                                    WRITE_ACCESS))
                        ASSERT (0, "Invalid LPOLESERVERVTBL")
                    else
                        ASSERT (lpsrvr->lpolesrvr->lpvtbl->Release,
                            "Invalid pointer to Release method")
#endif

                    (*lpsrvr->lpolesrvr->lpvtbl->Release) (lpsrvr->lpolesrvr);
                }
            }
            break;


       case WM_DDE_REQUEST:
            if (lpsrvr->bTerminate || !IsWindowValid ((HWND) wParam))
                goto RequestErr;

            if(RequestDataStd (lParam, (HANDLE FAR *)&hdata) != OLE_OK){
                // if request failed, then acknowledge with error.
                if (!PostMessageToClient ((HWND)wParam, WM_DDE_ACK, hwnd,
                    MAKELONG(0x8000, HIWORD(lParam))))

            RequestErr:
                if (HIWORD(lParam))
                    GlobalDeleteAtom (HIWORD(lParam));
            } else {

                // post the data message and we are not asking for any
                // acknowledge.

                if (!PostMessageToClient ((HWND)wParam, WM_DDE_DATA, hwnd,
                            MAKELONG(hdata, HIWORD(lParam)))) {
                    GlobalFree (hdata);
                    goto RequestErr;
                }
            }
            break;



       case WM_DESTROY:
            DEBUG_OUT ("Srvr: Destroy window",0)
            break;

       default:
            DEBUG_OUT ("Srvr:  Default message",0)
            return DefWindowProc (hwnd, msg, wParam, lParam);

    }

    return 0L;

}

BOOL    INTERNAL    HandleInitMsg (lpsrvr, lParam)
LPSRVR  lpsrvr;
LONG    lParam;
{


    // If it is not system or Ole, this is not the server.
    if (!((aSysTopic == (ATOM)(HIWORD(lParam))) ||
            (aOLE == (ATOM)(HIWORD(lParam)))))

        return FALSE;


    // single instance MDI accept
    if (lpsrvr->useFlags == OLE_SERVER_SINGLE)
        return TRUE;


    // this server is multiple instance. So, check for any clients or docs.
    if (!GetWindow (lpsrvr->hwnd, GW_CHILD) && !lpsrvr->cClients)
        return TRUE;

    return FALSE;

}


// AddClient: Adds the client as property to the server
// window. Key is the string generated from the window
// handle and the data is the window itself.


BOOL    INTERNAL AddClient  (hwnd, hkey, hdata)
HWND    hwnd;
HANDLE  hkey;
HANDLE  hdata;
{
    char    buf[6];

    MapToHexStr ((LPSTR)buf, hkey);
    return SetProp (hwnd, (LPSTR)buf, hdata);

}


//DeleteClient: deletes the client from the server clients list.

BOOL    INTERNAL DeleteClient (hwnd, hkey)
HWND    hwnd;
HANDLE  hkey;
{

    char    buf[6];

    MapToHexStr ((LPSTR)buf, hkey);
    return RemoveProp (hwnd, (LPSTR)buf);


}

// FindClient: Finds  whether a given client is
// in the server client list.

HANDLE  INTERNAL FindClient (hwnd, hkey)
HWND    hwnd;
HANDLE  hkey;
{

    char    buf[6];


    MapToHexStr ((LPSTR)buf, hkey);
    return GetProp (hwnd, (LPSTR)buf);
}



// SrvrExecute: takes care of the WM_DDE_EXEXCUTE for the
// server.


OLESTATUS INTERNAL SrvrExecute (hwnd, hdata, hwndClient)
HWND        hwnd;
HANDLE      hdata;
HWND        hwndClient;
{
    ATOM            aCmd;
    BOOL            fActivate;

    LPSTR           lpdata = NULL;
    HANDLE          hdup   = NULL;
    int             retval = OLE_ERROR_MEMORY;

    LPSTR           lpdocname;
    LPSTR           lptemplate;

    LPOLESERVERDOC  lpoledoc = NULL;
    LPDOC           lpdoc    = NULL;
    LPSRVR          lpsrvr;
    LPOLESERVER     lpolesrvr;
    LPSTR           lpnextarg;
    LPSTR           lpclassname;
    LPSTR           lpitemname;
    LPSTR           lpopt;
    char            buf[MAX_STR];
    WORD            wCmdType;

    // !!! this code can be lot simplified if we do the argument scanning
    // seperately and return the ptrs to the args. Rewrite later on.

    if (!(hdup = DuplicateData (hdata)))
        goto errRtn;

    if (!(lpdata  = GlobalLock (hdup)))
        goto errRtn;

    DEBUG_OUT (lpdata, 0)

    lpsrvr = (LPSRVR)GetWindowLong (hwnd, 0);

#ifdef   FIREWALLS
    ASSERT (lpsrvr, "Srvr: srvr does not exist");
#endif

    lpolesrvr = lpsrvr->lpolesrvr;

#ifdef   FIREWALLS
    ASSERT ((CheckPointer (lpolesrvr, WRITE_ACCESS)),
        "Srvr: lpolesrvr does not exist");
#endif

    if (*lpdata++ != '[') // commands start with the left sqaure bracket
        goto  errRtn;

    retval = OLE_ERROR_SYNTAX;
    // scan upto the first arg
    if (!(wCmdType = ScanCommand (lpdata, WT_SRVR, &lpdocname, &aCmd)))
        goto  errRtn;

    if (wCmdType == NON_OLE_COMMAND) {
        if (!UtilQueryProtocol (lpsrvr->aClass, PROTOCOL_EXECUTE))
            retval = OLE_ERROR_PROTOCOL;
        else {
#ifdef FIREWALLS
            if (!CheckPointer (lpolesrvr->lpvtbl, WRITE_ACCESS))
                ASSERT (0, "Invalid LPOLESERVERVTBL")
            else
                ASSERT (lpolesrvr->lpvtbl->Execute,
                    "Invalid pointer to Exit method")
#endif

            retval =  (*lpolesrvr->lpvtbl->Execute) (lpolesrvr, hdata);
        }

        goto errRtn1;
    }

    if (aCmd == aStdExit){
        if (*lpdocname)
            goto errRtn1;

#ifdef FIREWALLS
        if (!CheckPointer (lpolesrvr->lpvtbl, WRITE_ACCESS))
            ASSERT (0, "Invalid LPOLESERVERVTBL")
        else
            ASSERT (lpolesrvr->lpvtbl->Exit, "Invalid pointer to Exit method")
#endif
        lpsrvr->fAckExit  = TRUE;
        lpsrvr->hwndExit  = hwndClient;
        lpsrvr->hDataExit = hdata;
        retval = (*lpolesrvr->lpvtbl->Exit) (lpolesrvr);
        lpsrvr->fAckExit = FALSE;
        goto end2;
    }

    // scan the next argument.
    if (!(lpnextarg = ScanArg(lpdocname)))
        goto errRtn;

    //////////////////////////////////////////////////////////////////////////
    //
    // [StdShowItem("docname", "itemname"[, "true"])]
    //
    //////////////////////////////////////////////////////////////////////////

    if (aCmd == aStdShowItem) {

        // first find the documnet. If the doc does not exist, then
        // blow it off.

        if (!(lpdoc = FindDoc (lpsrvr, lpdocname)))
            goto errRtn1;

        lpitemname = lpnextarg;

        if( !(lpopt = ScanArg(lpitemname)))
            goto errRtn1;

        // scan for the optional parameter
        // Optional can be only TRUE or FALSE.

        fActivate = FALSE;
        if (*lpopt) {

            if( !(lpnextarg = ScanBoolArg (lpopt, (BOOL FAR *)&fActivate)))
                goto errRtn1;

            if (*lpnextarg)
                goto errRtn1;

        }


        // scan it. But, igonre the arg.
        retval = DocShowItem (lpdoc, lpitemname, !fActivate);
        goto end2;



    }

    //////////////////////////////////////////////////////////////////////////
    //
    // [StdCloseDocument ("docname")]
    //
    //////////////////////////////////////////////////////////////////////////

    if (aCmd == aStdClose) {
        if (!(lpdoc = FindDoc (lpsrvr, lpdocname)))
            goto errRtn1;

        if (*lpnextarg)
            goto errRtn1;


#ifdef FIREWALLS
        if (!CheckPointer (lpdoc->lpoledoc, WRITE_ACCESS))
            ASSERT (0, "Invalid LPOLESERVERDOC")
        else if (!CheckPointer (lpdoc->lpoledoc->lpvtbl, WRITE_ACCESS))
            ASSERT (0, "Invalid LPOLESERVERDOCVTBL")
        else
            ASSERT (lpdoc->lpoledoc->lpvtbl->Close,
                "Invalid pointer to Close method")
#endif

        retval = (*lpdoc->lpoledoc->lpvtbl->Close)(lpdoc->lpoledoc);
        goto end2;
    }


    if (aCmd == aStdOpen) {
        // find if any document is already open.
        // if the doc is open, then no need to call srvr app.
        if (FindDoc (lpsrvr, lpdocname)){
            retval = OLE_OK;
            goto end1;

        }
    }

    if (aCmd == aStdCreate || aCmd == aStdCreateFromTemplate) {
        lpclassname = lpdocname;
        lpdocname   = lpnextarg;
        if( !(lpnextarg = ScanArg(lpdocname)))
            goto errRtn1;

    }

    // check whether we can create/open more than one doc.

    if ((lpsrvr->useFlags == OLE_SERVER_MULTI) &&
            GetWindow (lpsrvr->hwnd, GW_CHILD))
            goto errRtn;



    // No Doc. register the document. lpoledoc is being probed
    // for validity. So, pass some writeable ptr. It is not
    // being used to access anything yet

    if (OleRegisterServerDoc ((LHSRVR)lpsrvr, lpdocname,
        (LPOLESERVERDOC)NULL, (LHDOC FAR *)&lpdoc))
            goto errRtn;

    //////////////////////////////////////////////////////////////////////////
    //
    // [StdOpenDocument ("docname")]
    //
    //////////////////////////////////////////////////////////////////////////

    // Documnet does not exit.

    if(aCmd == aStdOpen) {

#ifdef FIREWALLS
        if (!CheckPointer (lpolesrvr->lpvtbl, WRITE_ACCESS))
            ASSERT (0, "Invalid LPOLESERVERVTBL")
        else
            ASSERT (lpolesrvr->lpvtbl->Open, "Invalid pointer to Open method")
#endif

        retval = (*lpolesrvr->lpvtbl->Open)(lpolesrvr, (LHDOC)lpdoc,
                lpdocname, (LPOLESERVERDOC FAR *) &lpoledoc);
        goto end;
    }
    else {
        lpdoc->fEmbed = TRUE;
    }



    //////////////////////////////////////////////////////////////////////////
    //
    // [StdNewDocument ("classname", "docname")]
    //
    //////////////////////////////////////////////////////////////////////////

    if (aCmd == aStdCreate) {
#ifdef FIREWALLS
        if (!CheckPointer (lpolesrvr->lpvtbl, WRITE_ACCESS))
            ASSERT (0, "Invalid LPOLESERVERVTBL")
        else
            ASSERT (lpolesrvr->lpvtbl->Create,
                "Invalid pointer to Create method")
#endif
        retval =  (*lpolesrvr->lpvtbl->Create) (lpolesrvr, (LHDOC)lpdoc,
                                    lpclassname, lpdocname,
                                    (LPOLESERVERDOC FAR *) &lpoledoc);

        goto end;
    }

    //////////////////////////////////////////////////////////////////////////
    //
    // [StdEditDocument ("docname")]
    //
    //////////////////////////////////////////////////////////////////////////
    if (aCmd == aStdEdit){

        GlobalGetAtomName (lpsrvr->aClass, (LPSTR)buf, MAX_STR);

#ifdef FIREWALLS
        if (!CheckPointer (lpolesrvr->lpvtbl, WRITE_ACCESS))
            ASSERT (0, "Invalid LPOLESERVERVTBL")
        else
            ASSERT (lpolesrvr->lpvtbl->Edit, "Invalid pointer to Edit method")
#endif

        retval = (*lpolesrvr->lpvtbl->Edit) (lpolesrvr, (LHDOC)lpdoc,
                                (LPSTR)buf, lpdocname,
                                (LPOLESERVERDOC FAR *) &lpoledoc);
        goto end;
    }

    //////////////////////////////////////////////////////////////////////////
    //
    // [StdNewFormTemplate ("classname", "docname". "templatename)]
    //
    //////////////////////////////////////////////////////////////////////////

    if (aCmd == aStdCreateFromTemplate){
        lptemplate = lpnextarg;
        if(!(lpnextarg = ScanArg(lpnextarg)))
            goto errRtn;

#ifdef FIREWALLS
        if (!CheckPointer (lpolesrvr->lpvtbl, WRITE_ACCESS))
            ASSERT (0, "Invalid LPOLESERVERVTBL")
        else
            ASSERT (lpolesrvr->lpvtbl->CreateFromTemplate,
                "Invalid pointer to CreateFromTemplate method")
#endif
        retval = (*lpolesrvr->lpvtbl->CreateFromTemplate)(lpolesrvr,
             (LHDOC)lpdoc, lpclassname, lpdocname, lptemplate,
             (LPOLESERVERDOC FAR *) &lpoledoc);

        goto end;

    }


    DEBUG_OUT ("Unknown command", 0);

end:

    if (retval != OLE_OK)
        goto errRtn;

    // Successful execute. remember the server app private doc handle here.

    lpdoc->lpoledoc = lpoledoc;

end1:
    // make sure that the srg string is indeed terminated by
    // NULL.
    if (*lpnextarg)
        retval = OLE_ERROR_SYNTAX;

errRtn:

   if ( retval != OLE_OK){
        // delete the oledoc structure
        if (lpdoc)
            OleRevokeServerDoc ((LHDOC)lpdoc);
   }

end2:
errRtn1:

   if (lpdata)
        GlobalUnlock (hdup);

   if (hdup)
        GlobalFree (hdup);

   if (retval == OLE_OK)
        lpsrvr->bnoRelease = TRUE;

   return retval;
}




void SendMsgToChildren (hwnd, msg, wParam, lParam)
HWND        hwnd;
WORD        msg;
WORD        wParam;
LONG        lParam;
{

    hwnd = GetWindow(hwnd, GW_CHILD);
    while (hwnd) {
        SendMessage (hwnd, msg, wParam, lParam);
        hwnd = GetWindow (hwnd, GW_HWNDNEXT);
    }
}


OLESTATUS INTERNAL   RequestDataStd (lparam, lphdde)
LONG        lparam;
LPHANDLE    lphdde;
{

    char    buf[MAX_STR];
    ATOM    item;
    HANDLE  hnew = NULL;

    if (!(item =  (ATOM)(HIWORD (lparam))))
        goto errRtn;

    GlobalGetAtomName (item, (LPSTR)buf, MAX_STR);

    if (item == aEditItems){
        hnew = MakeGlobal ((LPSTR)"StdHostNames\tStdDocDimensions\tStdTargetDevice");
        goto   PostData;

    }

    if (item == aProtocols) {
        hnew = MakeGlobal ((LPSTR)"Embedding\tStdFileEditing");
        goto   PostData;
    }

    if (item == aTopics) {
        hnew = MakeGlobal ((LPSTR)"Doc");
        goto   PostData;
    }

    if (item == aFormats) {
        hnew = MakeGlobal ((LPSTR)"Picture\tBitmap");
        goto   PostData;
    }

    if (item == aStatus) {
        hnew = MakeGlobal ((LPSTR)"Ready");
        goto   PostData;
    }

    // format we do not understand.
    goto errRtn;

PostData:

    // Duplicate the DDE data
    if (MakeDDEData (hnew, CF_TEXT, lphdde, TRUE)){
        // !!! why are we duplicating the atom.
        DuplicateAtom ((ATOM)(HIWORD (lparam)));
        return OLE_OK;
    }
errRtn:
    return OLE_ERROR_MEMORY;
}


BOOL INTERNAL QueryRelease (lpsrvr)
LPSRVR  lpsrvr;
{

    HWND    hwnd;
    LPDOC   lpdoc;


    // Incase the terminate is called immediately after
    // the Std at sys level clear this.

    if (lpsrvr->bnoRelease) {
        lpsrvr->bnoRelease = FALSE;
        return FALSE;
    }


    if (lpsrvr->cClients)
        return FALSE;

    hwnd = GetWindow (lpsrvr->hwnd, GW_CHILD);

    // if either the server or the doc has any clients
    // return FALSE;

    while (hwnd){
        lpdoc = (LPDOC)GetWindowLong (hwnd, 0);
        if (lpdoc->cClients)
            return FALSE;

        hwnd = GetWindow (hwnd, GW_HWNDNEXT);
    }
    return TRUE;

}


//IsSingleServerInstance: returns true if the app is single server app else
//false.

BOOL    INTERNAL  IsSingleServerInstance ()
{
    HWND    hwnd;
    WORD    cnt = 0;
    HANDLE  hTask;
    char    buf[MAX_STR];


    hwnd  = GetWindow (GetDesktopWindow(), GW_CHILD);
    hTask = GetCurrentTask();

    while (hwnd) {
        if (hTask == GetWindowTask (hwnd)) {
            GetClassName (hwnd, (LPSTR)buf, MAX_STR);
            if (lstrcmp ((LPSTR)buf, SRVR_CLASS) == 0)
                cnt++;
        }
        hwnd = GetWindow (hwnd, GW_HWNDNEXT);
    }
#ifdef  FIREWALLS
     ASSERT (cnt > 0, "srvr window instance count is zero");
#endif
    if (cnt == 1)
        return TRUE;
    else
        return FALSE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\ole\server\doc.c ===
/****************************** Module Header ******************************\
* Module Name: Doc.c Document Main module
*
* Purpose: Includes All the document communication related routines.
*
* Created: Oct 1990.
*
* Copyright (c) 1990, 1991  Microsoft Corporation
*
* History:
*    Raor (../10/1990)    Designed, coded
*
\***************************************************************************/

#include "cmacs.h"
#include "windows.h"
#include "ole.h"
#include "dde.h"
#include "srvr.h"

extern  ATOM     cfBinary;
extern  ATOM     aStdClose;
extern  ATOM     aStdShowItem;
extern  ATOM     aStdDoVerbItem;
extern  ATOM     aStdDocName;
extern  ATOM     aTrue;
extern  ATOM     aFalse;

extern  FARPROC  lpTerminateDocClients;
extern  FARPROC  lpSendRenameMsg;
extern  FARPROC  lpFindItemWnd;
extern  FARPROC  lpEnumForTerminate;

extern  HANDLE   hdllInst;
extern  HANDLE   hddeRename;
extern  HWND     hwndRename;


extern  BOOL     fAdviseSaveDoc;

// ### Do we have to create a seperate window for each doc conversation.
// EDF thinks so.

/***************************** Public  Function ****************************\
*
* OLESTATUS FAR PASCAL  OleRegisterServerDoc (lhsrvr, lpdocname, lpoledoc, lplhdoc)
*
* OleRegisterServerDoc: Registers the Document with the server lib.
*
* Parameters:
*       1. Server long handle(server with which the document should
*          be registered)
*       2. Document name.
*       3. Handle to the doc of the server app (private to the server app).
*       4. Ptr for returning the Doc handle of the lib (private to the lib).
*
* return values:
*        returns OLE_OK if the server is successfully registered .
*        else returns the corresponding error.
*
* History:
*   Raor:   Wrote it,
\***************************************************************************/

OLESTATUS FAR PASCAL  OleRegisterServerDoc (lhsrvr, lpdocname, lpoledoc, lplhdoc)
LHSRVR          lhsrvr;    // handle we passed back as part of registration.
LPCSTR           lpdocname; // document name
LPOLESERVERDOC  lpoledoc;  // Private doc handle of the server app.
LHDOC FAR *     lplhdoc;   // where we will be passing our doc private handle
{

    LPSRVR  lpsrvr = NULL;
    LPDOC   lpdoc  = NULL;
    HANDLE  hdoc   = NULL;


    Puts ("OleRegisterServerDoc");

    if (!CheckServer (lpsrvr = (LPSRVR)lhsrvr))
        return OLE_ERROR_HANDLE;

    // server's termination has already started.
    if (lpsrvr->bTerminate)
        return OLE_ERROR_TERMINATE;

    PROBE_READ((LPSTR)lpdocname);
    PROBE_WRITE(lplhdoc);

    // we are using the null from inside the server lib
    if (lpoledoc)
        PROBE_WRITE(lpoledoc);

    hdoc = GlobalAlloc (GMEM_MOVEABLE | GMEM_ZEROINIT | GMEM_DDESHARE, sizeof (DOC));

    if (!(hdoc && (lpdoc = (LPDOC)GlobalLock (hdoc))))
        goto errReturn;

    // set the signature, handle and the doc atom.
    lpdoc->sig[0]   = 'S';
    lpdoc->sig[1]   = 'D';
    lpdoc->hdoc     = hdoc;
    lpdoc->aDoc     = GlobalAddAtom (lpdocname);
    lpdoc->lpoledoc = lpoledoc;


    if (!(lpdoc->hwnd = CreateWindow ("DocWndClass", "Doc",
        WS_CHILD,0,0,0,0,lpsrvr->hwnd,NULL, hdllInst, NULL)))
        goto errReturn;

    // save the ptr to the struct in the window.
    SetWindowLong (lpdoc->hwnd, 0, (LONG)lpdoc);
    SetWindowWord (lpdoc->hwnd, WW_LE, WC_LE);
    SetWindowWord (lpdoc->hwnd, WW_HANDLE,
        (WORD) (GetWindowWord (lpsrvr->hwnd, WW_HANDLE)));
    *lplhdoc = (LONG)lpdoc;

    return OLE_OK;

errReturn:
    if (lpdoc){
        if (lpdoc->hwnd)
            DestroyWindow (lpsrvr->hwnd);

        if (lpdoc->aDoc)
            GlobalDeleteAtom (lpdoc->aDoc);

        GlobalUnlock(hdoc);
    }

    if (hdoc)
        GlobalFree (hdoc);

    return OLE_ERROR_MEMORY;
}


/***************************** Public  Function ****************************\
* OLESTATUS FAR PASCAL  OleRevokeServerDoc (lhdoc)
*
* OleRevokeServerDoc: Unregisters the document which has been registered.
*
* Parameters:
*       1. DLL Doc handle.
*
* return values:
*        returns OLE_OK if the document is successfully unregisterd.
*        ( It is Ok for the app to free the associated space).
*        If the unregistration is intiated, returns  OLE_STARTED.
*        Calls the Doc class release entry point when the doc
*        can be released. App should wait till the Release is called
*
* History:
*   Raor:   Wrote it,
\***************************************************************************/

OLESTATUS  FAR PASCAL  OleRevokeServerDoc (lhdoc)
LHDOC   lhdoc;
{
    HWND    hwndSrvr;
    LPSRVR  lpsrvr;
    HWND    hwndDoc;
    LPDOC   lpdoc;

    Puts ("OleRevokeServerDoc");

    if (!CheckServerDoc (lpdoc = (LPDOC)lhdoc))
        return OLE_ERROR_HANDLE;

    if (lpdoc->bTerminate  && lpdoc->termNo)
        return OLE_WAIT_FOR_RELEASE;

    // ### this code is very similar to the srvr code.
    // we should optimize.

    hwndDoc = lpdoc->hwnd;

#ifdef  FIREWALLS
    ASSERT (hwndDoc, "No doc window")
#endif

    hwndSrvr = GetParent (hwndDoc);
    lpsrvr = (LPSRVR) GetWindowLong (hwndSrvr, 0);
#ifdef  FIREWALLS
    ASSERT (hwndSrvr, "No srvr window")
    ASSERT (lpsrvr, "No srvr structure")
#endif

    // delete all the items(objects) for this doc
    DeleteAllItems (lpdoc->hwnd);

    // we are terminating.
    lpdoc->bTerminate = TRUE;
    lpdoc->termNo = 0;

    // send ack if Revoke is done as a result of StdClose
    if (lpdoc->fAckClose) {
        // Post the acknowledge to the client
        if (!PostMessageToClient (lpdoc->hwndClose, WM_DDE_ACK, lpdoc->hwnd,
                            MAKELONG (0x8000, lpdoc->hDataClose)))
            // if the window died or post failed, delete the atom.
            GlobalFree (lpdoc->hDataClose);
    }

    // Post termination for each of the doc clients.
    EnumProps (hwndDoc, lpTerminateDocClients);
    // post all the messages with yield which have been collected in enum
    // UnblockPostMsgs (hwndDoc, TRUE);

#ifdef  WAIT_DDE
    if (lpdoc->termNo)
        WaitForTerminate((LPSRVR)lpdoc);
#endif

    return ReleaseDoc (lpdoc);
}




/***************************** Public  Function ****************************\
* OLESTATUS FAR PASCAL  OleRenameServerDoc (lhdoc, lpNewName)
*
* OleRenameServerDoc: Changes the name of the document
*
* Parameters:
*       1. DLL Doc handle.
*       2. New name for document
*
* return values:
*        returns OLE_OK if the document is successfully renamed
*
* History:
*   Srinik:   Wrote it,
\***************************************************************************/

OLESTATUS FAR PASCAL  OleRenameServerDoc (lhdoc, lpNewName)
LHDOC   lhdoc;
LPCSTR   lpNewName;
{
    LPDOC       lpdoc;
    OLESTATUS   retVal = OLE_OK;
    HANDLE      hdata;
    HWND        hStdWnd;

    if (!CheckServerDoc (lpdoc = (LPDOC)lhdoc))
        return OLE_ERROR_HANDLE;

    PROBE_READ((LPSTR)lpNewName);

    if (!(hdata = MakeGlobal ((LPSTR)lpNewName)))
        return OLE_ERROR_MEMORY;

    if (lpdoc->aDoc)
        GlobalDeleteAtom (lpdoc->aDoc);
    lpdoc->aDoc = GlobalAddAtom (lpNewName);

    // if StdDocName item is present send rename to relevant clients
    if (hStdWnd = SearchItem (lpdoc, (LPSTR) MAKEINTATOM(aStdDocName))) {
        if (!MakeDDEData (hdata, (int)cfBinary, (LPHANDLE)&hddeRename,FALSE))
            retVal = OLE_ERROR_MEMORY;
        else {
            EnumProps (hStdWnd, lpSendRenameMsg);
            // post all the messages with yield which have been collected in enum
            // UnblockPostMsgs (hStdWnd, FALSE);
            GlobalFree (hddeRename);

        }
    }


    hwndRename = hStdWnd;
    // Post termination for each of the doc clients.
    EnumProps (lpdoc->hwnd, lpEnumForTerminate);
    // post all the messages with yield which have been collected in enum
    // UnblockPostMsgs (lpdoc->hwnd, TRUE);

    // If it was an embedded object, from now on it won't be
    lpdoc->fEmbed = FALSE;

    if (!hStdWnd || retVal != OLE_OK)
        GlobalFree(hdata);

    // Do link manager stuff
    return retVal;
}




/***************************** Public  Function ****************************\
* OLESTATUS FAR PASCAL  OleSavedServerDoc (lhdoc)
*
* OleSavedServerDoc: Changes the name of the document
*
* Parameters:
*       1. DLL Doc handle.
*
* return values:
*        returns OLE_OK if the link manager is successfully notified
*
* History:
*   Srinik:   Wrote it,
\***************************************************************************/

OLESTATUS FAR PASCAL  OleSavedServerDoc (lhdoc)
LHDOC   lhdoc;
{
    LPDOC   lpdoc;

    if (!CheckServerDoc (lpdoc = (LPDOC)lhdoc))
        return OLE_ERROR_HANDLE;

    fAdviseSaveDoc = TRUE;
    EnumChildWindows (lpdoc->hwnd, lpFindItemWnd,
        MAKELONG (NULL, ITEM_SAVED));

    if (lpdoc->fEmbed && !fAdviseSaveDoc)
        return OLE_ERROR_CANT_UPDATE_CLIENT;

    return OLE_OK;
}




/***************************** Public  Function ****************************\
* OLESTATUS FAR PASCAL  OleRevertServerDoc (lhdoc)
*
* OleRevertServerDoc: Changes the name of the document
*
* Parameters:
*       1. DLL Doc handle.
*
* return values:
*        returns OLE_OK if the link manager has been successfully informed
*
* History:
*   Srinik:   Wrote it,
\***************************************************************************/

OLESTATUS FAR PASCAL  OleRevertServerDoc (lhdoc)
LHDOC   lhdoc;
{
    LPDOC   lpdoc;

    if (!CheckServerDoc (lpdoc = (LPDOC)lhdoc))
        return OLE_ERROR_HANDLE;

    return OLE_OK;
}



// TerminateDocClients: Call back for the document window for
// enumerating all the clients. Posts terminate for each of
// the clients.

BOOL    FAR PASCAL  TerminateDocClients (hwnd, lpstr, hdata)
HWND    hwnd;
LPSTR   lpstr;
HANDLE  hdata;
{
    LPDOC   lpdoc;

    lpdoc = (LPDOC)GetWindowLong (hwnd, 0);
    if (IsWindowValid ((HWND)hdata)){
        lpdoc->termNo++;
        // irrespective of the post, incremet the count, so
        // that client does not die.
        PostMessageToClientWithBlock ((HWND)hdata, WM_DDE_TERMINATE,  hwnd, NULL);
    }
    else
        ASSERT(FALSE, "TERMINATE: Client's Doc channel is missing");
    return TRUE;
}


// ReleaseDoc: If there are no more matching terminates pending
// Call the server for its release. (Server might be waiting for the
// docs to be terminated. Called thru OleRevokeServer).


int INTERNAL    ReleaseDoc (lpdoc)
LPDOC      lpdoc;
{

    HWND        hwndSrvr;
    HANDLE      hdoc;
    LPSRVR      lpsrvr;


    // release srvr is called only when everything is
    // cleaned and srvr app can post WM_QUIT.

    if (lpdoc->bTerminate  && lpdoc->termNo)
        return OLE_WAIT_FOR_RELEASE;

    // Call Release for the app to release its space.


    if (lpdoc->lpoledoc){

#ifdef FIREWALLS
    if (!CheckPointer (lpdoc->lpoledoc, WRITE_ACCESS))
        ASSERT (0, "Invalid LPOLESERVERDOC")
    else if (!CheckPointer (lpdoc->lpoledoc->lpvtbl, WRITE_ACCESS))
        ASSERT (0, "Invalid LPOLESERVERDOCVTBL")
    else
        ASSERT (lpdoc->lpoledoc->lpvtbl->Release,
            "Invalid pointer to Release method")
#endif
        (*lpdoc->lpoledoc->lpvtbl->Release) (lpdoc->lpoledoc);

    }

    if (lpdoc->aDoc) {
        GlobalDeleteAtom (lpdoc->aDoc);
        lpdoc->aDoc = NULL;
    }

    hwndSrvr = GetParent (lpdoc->hwnd);
    DestroyWindow (lpdoc->hwnd);

    lpsrvr = (LPSRVR)GetWindowLong (hwndSrvr, 0);

    // if the server is waiting for us, inform the server
    // we are done
    if (!lpsrvr->bTerminate) {
        // if we are not in terminate mode, then send advise to the server
        // if server can be revoked. raor (04/09)

        if (QueryRelease (lpsrvr)){

#ifdef FIREWALLS
            if (!CheckPointer (lpsrvr->lpolesrvr, WRITE_ACCESS))
                ASSERT (0, "Invalid LPOLESERVER")
            else if (!CheckPointer (lpsrvr->lpolesrvr->lpvtbl,
                            WRITE_ACCESS))
                ASSERT (0, "Invalid LPOLESERVERVTBL")
            else
                ASSERT (lpsrvr->lpolesrvr->lpvtbl->Release,
                    "Invalid pointer to Release method")
#endif

            (*lpsrvr->lpolesrvr->lpvtbl->Release) (lpsrvr->lpolesrvr);
        }

    } else
        ReleaseSrvr (lpsrvr);

    GlobalUnlock (hdoc = lpdoc->hdoc);
    GlobalFree (hdoc);

    return OLE_OK;
}


//RevokeAllDocs : revokes all the documents attached to a given
//server.

int INTERNAL RevokeAllDocs (lpsrvr)
LPSRVR  lpsrvr;
{

    HWND    hwnd;
    HWND    hwndnext;

    hwnd = GetWindow (lpsrvr->hwnd, GW_CHILD);

    // Go thru each of the child windows and revoke the corresponding
    // document. Doc windows are child windows for the server window.

    while (hwnd){
        // sequence is important
        hwndnext = GetWindow (hwnd, GW_HWNDNEXT);
        OleRevokeServerDoc ((LHDOC)GetWindowLong (hwnd, 0));
        hwnd =  hwndnext;
    }
    return OLE_OK;
}



// FindDoc: Given a document, searches for the document
// in the given server document tree. returns true if the
// document is available.


LPDOC INTERNAL FindDoc (lpsrvr, lpdocname)
LPSRVR  lpsrvr;
LPSTR   lpdocname;
{

    ATOM    aDoc;
    HWND    hwnd;
    LPDOC   lpdoc;

    aDoc = (ATOM)GlobalFindAtom (lpdocname);
    hwnd = GetWindow (lpsrvr->hwnd, GW_CHILD);

    while (hwnd){
        lpdoc = (LPDOC)GetWindowLong (hwnd, 0);
        if (lpdoc->aDoc == aDoc)
            return lpdoc;
        hwnd = GetWindow (hwnd, GW_HWNDNEXT);
    }
    return NULL;
}



// DocWndProc: document window procedure.
// ### We might be able to merge this code with
// the server window proc.


long FAR PASCAL DocWndProc (hwnd, msg, wParam, lParam)
HWND        hwnd;
WORD        msg;
WORD        wParam;
LONG        lParam;
{

    LPDOC       lpdoc;
    WORD        status = NULL;
    HWND        hwndClient;
    BOOL        fack;
    HANDLE      hdata  = NULL;
    OLESTATUS   retval;
    LPSRVR      lpsrvr;

    if (AddMessage (hwnd, msg, wParam, lParam, WT_DOC))
        return 0L;

    lpdoc = (LPDOC)GetWindowLong (hwnd, 0);

    switch (msg){


       case WM_CREATE:
            DEBUG_OUT ("doc create window", 0)
            break;

       case WM_DDE_INITIATE:

            DEBUG_OUT ("doc: DDE init",0);
            if (lpdoc->bTerminate){
                DEBUG_OUT ("doc: No action due to termination process",0)
                break;
            }

            // if we are the documnet then respond.

            if (! (lpdoc->aDoc == (ATOM)(HIWORD(lParam))))
                break;

            // We can enterain this client. Put this window in the client list
            // and acknowledge the initiate.

            if (!AddClient (hwnd, (HWND)wParam, (HWND)wParam))
                break;

            lpdoc->cClients++;
            lpsrvr = (LPSRVR) GetWindowLong (GetParent(lpdoc->hwnd), 0);

            lpsrvr->bnoRelease = FALSE;

            // post the acknowledge
            DuplicateAtom (LOWORD(lParam));
            DuplicateAtom (HIWORD(lParam));
            SendMessage ((HWND)wParam, WM_DDE_ACK, (WORD)hwnd, lParam);

            break;

       case WM_DDE_EXECUTE:

            DEBUG_OUT ("doc: execute", 0)
#ifdef  FIREWALLS
            // find the client in the client list.
            hwndClient = FindClient (lpdoc->hwnd, (HWND)wParam);
            ASSERT (hwndClient, "Client is missing from the server")
#endif
            // Are we terminating
            if (lpdoc->bTerminate || !IsWindowValid  ((HWND)wParam)) {
                DEBUG_OUT ("doc: execute after terminate posted",0)
                // !!! are we supposed to free the data
                GlobalFree (HIWORD (lParam));
                break;

            }

            retval = DocExecute (hwnd, HIWORD (lParam), (HWND)wParam);
            SET_MSG_STATUS (retval, status);

#ifdef OLD
            // if we posted the terminate because of execute, do not send
            // ack.

            if (lpdoc->bTerminate) {
                // !!! We got close but, we are posting the
                // the terminate. Excel does not complain about
                // this. But powerpoint complains.
#ifdef  POWERPNT_BUG
                GlobalFree (HIWORD(lParam));
#endif
                break;
            }
#endif
            if (!lpdoc->bTerminate) {
                // Post the acknowledge to the client
                if (!PostMessageToClient ((HWND)wParam, WM_DDE_ACK, hwnd,
                                MAKELONG(status, HIWORD(lParam))))
                    // the window either died or post failed, delete the data
                    GlobalFree (HIWORD(lParam));
            }

            break;

       case WM_DDE_TERMINATE:
            DEBUG_OUT ("doc: DDE terminate",0)

#ifdef  FIREWALLS
            // find the client in the client list.
            hwndClient = FindClient (lpdoc->hwnd,(HWND)wParam);
            ASSERT(hwndClient || lpdoc->termNo, "Client is missing from the server")
#endif
            // We do not need this client any more. Delete him from the
            // client list.

            DeleteClient (lpdoc->hwnd, (HWND)wParam);
            lpdoc->cClients--;

            if (lpdoc->bTerminate){
                lpsrvr = (LPSRVR) GetWindowLong (GetParent(lpdoc->hwnd), 0);
                if (!--lpdoc->termNo)
                    // Release this Doc and may be the server also
                    // if the server is waiting to be released also.
                    ReleaseDoc (lpdoc);
            } else {
                if (lpdoc->termNo == 0){

                    // If client intiated the terminate. Post matching terminate

                    PostMessageToClient ((HWND)wParam, WM_DDE_TERMINATE,
                                    hwnd, NULL);
                } else
                    lpdoc->termNo--;

                //Client initiated the termination. So, we shoudl take him
                // out from any of our items client lists.
                DeleteFromItemsList (lpdoc->hwnd, (HWND)wParam);

                lpsrvr = (LPSRVR)GetWindowLong (GetParent (lpdoc->hwnd), 0);

                if (QueryRelease (lpsrvr)){

#ifdef FIREWALLS
                    if (!CheckPointer (lpsrvr->lpolesrvr, WRITE_ACCESS))
                        ASSERT (0, "Invalid LPOLESERVER")
                    else if (!CheckPointer (lpsrvr->lpolesrvr->lpvtbl,
                                    WRITE_ACCESS))
                        ASSERT (0, "Invalid LPOLESERVERVTBL")
                    else
                        ASSERT (lpsrvr->lpolesrvr->lpvtbl->Release,
                            "Invalid pointer to Release method")
#endif

                    (*lpsrvr->lpolesrvr->lpvtbl->Release) (lpsrvr->lpolesrvr);
                }

            }
            break;

       case WM_DESTROY:
            DEBUG_OUT ("doc: Destroy window",0)
            break;

       case WM_DDE_POKE: {
            int iStdItem;

            if (lpdoc->bTerminate || !IsWindowValid  ((HWND) wParam)) {
                // we are getting pke message after we have posted the
                // the termination or the client got deleted.
            PokeErr:
                FreePokeData ((HANDLE) (LOWORD (lParam)));
#ifdef OLD
                GlobalFree ((HANDLE) (LOWORD (lParam)));
#endif
                // !!! Are we supposed to delete the atoms also.
            PokeErr1:
                if (HIWORD(lParam))
                    GlobalDeleteAtom (HIWORD(lParam));
                break;

            }

            if (iStdItem = GetStdItemIndex (HIWORD(lParam)))
                retval = PokeStdItems (lpdoc, (HWND)wParam,
                                MAKELONG((LOWORD(lParam)), iStdItem));
            else
                retval = PokeData (lpdoc, (HWND)wParam, lParam);

            SET_MSG_STATUS (retval, status);
            // !!! If the fRelease is false and the post fails
            // then we are not freeing the hdata. Are we supposed to

            if (!PostMessageToClient ((HWND)wParam, WM_DDE_ACK, hwnd,
                        MAKELONG(status, HIWORD(lParam))))
                goto PokeErr1;

            break;
       }

       case WM_DDE_ADVISE:

            fack = TRUE;

            if (lpdoc->bTerminate || !IsWindowValid  ((HWND)wParam))
                goto PokeErr;

            if (IsAdviseStdItems (HIWORD(lParam)))
                retval = AdviseStdItems (lpdoc, (HWND)wParam, lParam, (BOOL FAR *)&fack);
            else
                // advise data will not have any OLE_BUSY
                retval = AdviseData (lpdoc, (HWND)wParam, lParam, (BOOL FAR *)&fack);

            SET_MSG_STATUS (retval, status);

            if (fack) {
                if (!PostMessageToClient ((HWND)wParam, WM_DDE_ACK, hwnd,
                                MAKELONG(status, HIWORD(lParam))))
                    goto PokeErr;

            }
            else if ((ATOM)(HIWORD (lParam)))
                GlobalDeleteAtom ((ATOM)(HIWORD (lParam)));

            break;

       case WM_DDE_UNADVISE:
            if (lpdoc->bTerminate || !IsWindowValid  ((HWND)wParam))
                goto PokeErr;

            retval = UnAdviseData (lpdoc, (HWND)wParam, lParam);
            SET_MSG_STATUS (retval, status);

            if (!PostMessageToClient ((HWND)wParam, WM_DDE_ACK, hwnd,
                        MAKELONG(status, HIWORD(lParam))))
                goto PokeErr;

            break;

       case WM_DDE_REQUEST:

            if (lpdoc->bTerminate || !IsWindowValid  ((HWND) wParam))
                goto PokeErr1;

            retval = RequestData (lpdoc, (HWND)wParam, lParam, (HANDLE FAR *)&hdata);

            if(retval == OLE_OK) {
                // post the data message and we are not asking for any
                // acknowledge.

                if (!PostMessageToClient ((HWND)wParam, WM_DDE_DATA, hwnd,
                            MAKELONG(hdata, HIWORD(lParam)))) {
                    GlobalFree (hdata);
                    goto PokeErr1;
                }
                break;
             }

             if (retval == OLE_BUSY)
                status = 0x4000;
             else
                status = 0;

             // if request failed, then acknowledge with error.
             if (!PostMessageToClient ((HWND)wParam, WM_DDE_ACK, hwnd,
                             MAKELONG(status, HIWORD(lParam))))
                 goto PokeErr1;


             break;

       default:
            DEBUG_OUT("doc:  Default message",0)
            return DefWindowProc (hwnd, msg, wParam, lParam);

    }

    return 0L;

}

//DocExecute: Interprets the execute command for the
//document conversation.


OLESTATUS INTERNAL DocExecute(hwnd, hdata, hwndClient)
HWND        hwnd;
HANDLE      hdata;
HWND        hwndClient;
{

    ATOM            acmd;
    BOOL            fShow;
    BOOL            fActivate;

    HANDLE          hdup   = NULL;
    int             retval = OLE_ERROR_MEMORY;
    LPDOC           lpdoc;
    LPOLESERVERDOC  lpoledoc;
    LPCLIENT        lpclient = NULL;

    LPSTR           lpitemname;
    LPSTR           lpopt;
    LPSTR           lpnextarg;
    LPSTR           lpdata = NULL;
    LPSTR           lpverb = NULL;
    WORD            verb;
    WORD            wCmdType;

    // !!!Can we modify the string which has been passed to us
    // rather than duplicating the data. This will get some speed
    // and save some space.

    if(!(hdup = DuplicateData(hdata)))
        goto    errRtn;

    if (!(lpdata  = GlobalLock (hdup)))
        goto    errRtn;

    DEBUG_OUT (lpdata, 0)

    lpdoc = (LPDOC)GetWindowLong (hwnd, 0);

#ifdef   FIREWALLS
    ASSERT (lpdoc, "doc: doc does not exist");
#endif
    lpoledoc = lpdoc->lpoledoc;

    retval = OLE_ERROR_SYNTAX;

    if(*lpdata++ != '[') // commands start with the left sqaure bracket
        goto  errRtn;

    // scan the command and scan upto the first arg.
    if (!(wCmdType = ScanCommand(lpdata, WT_DOC, &lpnextarg, &acmd)))
        goto errRtn;

    if (wCmdType == NON_OLE_COMMAND) {
        LPSRVR  lpsrvr;

        if (lpsrvr =  (LPSRVR) GetWindowLong (GetParent (hwnd), 0)) {
            if (!UtilQueryProtocol (lpsrvr->aClass, PROTOCOL_EXECUTE))
                retval = OLE_ERROR_PROTOCOL;
            else {
#ifdef FIREWALLS
                if (!CheckPointer (lpoledoc, WRITE_ACCESS))
                    ASSERT (0, "Invalid LPOLESERVERDOC")
                else if (!CheckPointer (lpoledoc->lpvtbl, WRITE_ACCESS))
                    ASSERT (0, "Invalid LPOLESERVERDOCVTBL")
                else
                    ASSERT (lpoledoc->lpvtbl->Execute,
                        "Invalid pointer to Execute method")
#endif

                retval = (*lpoledoc->lpvtbl->Execute) (lpoledoc, hdata);
            }
        }

        goto errRtn;
    }


    //////////////////////////////////////////////////////////////////////////
    //
    // [StdCloseDocument]
    //
    //////////////////////////////////////////////////////////////////////////
    if (acmd == aStdClose){

        // if not terminated by NULL error
        if (*lpnextarg)
            goto errRtn;

#ifdef FIREWALLS
        if (!CheckPointer (lpoledoc, WRITE_ACCESS))
            ASSERT (0, "Invalid LPOLESERVERDOC")
        else if (!CheckPointer (lpoledoc->lpvtbl, WRITE_ACCESS))
            ASSERT (0, "Invalid LPOLESERVERDOCVTBL")
        else
            ASSERT (lpoledoc->lpvtbl->Close,"Invalid pointer to Close method")
#endif
        lpdoc->fAckClose  = TRUE;
        lpdoc->hwndClose  = hwndClient;
        lpdoc->hDataClose = hdata;
        retval = (*lpoledoc->lpvtbl->Close) (lpoledoc);
        lpdoc->fAckClose  = FALSE;
        goto end;
    }

    //////////////////////////////////////////////////////////////////////////
    //
    // [StdDoVerbItem("itemname", verb, BOOL, BOOL]
    //
    //////////////////////////////////////////////////////////////////////////
    if (acmd == aStdDoVerbItem){
        lpitemname = lpnextarg;

        if(!(lpverb = ScanArg(lpnextarg)))
            goto errRtn;


        if(!(lpnextarg = ScanNumArg(lpverb, (LPINT)&verb)))
            goto errRtn;

#ifdef  FIREWALLS
        ASSERT (verb < 9 , "Unexpected verb number");
#endif

        // now scan the show BOOL

        if (!(lpnextarg = ScanBoolArg (lpnextarg, (BOOL FAR *)&fShow)))
            goto errRtn;

        fActivate = FALSE;

        // if activate BOOL is present, scan it.

        if (*lpnextarg) {
            if (!(lpnextarg = ScanBoolArg (lpnextarg, (BOOL FAR *)&fActivate)))
                goto errRtn;
        }

        if (*lpnextarg)
            goto errRtn;


        retval = DocDoVerbItem (lpdoc, lpitemname, verb, fShow, !fActivate);
        goto end;
    }





    //////////////////////////////////////////////////////////////////////////
    //
    // [StdShowItem("itemname"[, "true"])]
    //
    //////////////////////////////////////////////////////////////////////////
    if (acmd != aStdShowItem)
        goto errRtn;

    lpitemname = lpnextarg;

    if(!(lpopt = ScanArg(lpitemname)))
        goto errRtn;

    // Now scan for optional parameter.

    fActivate = FALSE;

    if (*lpopt) {

        if(!(lpnextarg = ScanBoolArg (lpopt, (BOOL FAR *)&fActivate)))
            goto errRtn;

        if (*lpnextarg)
            goto errRtn;


    }

    retval = DocShowItem (lpdoc, lpitemname, !fActivate);

end:
errRtn:
   if (lpdata)
        GlobalUnlock (hdup);

   if (hdup)
        GlobalFree (hdup);

   return retval;
}

int INTERNAL   DocShowItem (lpdoc, lpitemname, fAct)
LPDOC   lpdoc;
LPSTR   lpitemname;
BOOL    fAct;

{
    LPCLIENT   lpclient;
    int        retval;

    if ((retval = FindItem (lpdoc, lpitemname, (LPCLIENT FAR *)&lpclient))
           != OLE_OK)
       return retval;

#ifdef FIREWALLS
        if (!CheckPointer (lpclient->lpoleobject->lpvtbl, WRITE_ACCESS))
            ASSERT (0, "Invalid LPOLEOBJECTVTBL")
        else
            ASSERT (lpclient->lpoleobject->lpvtbl->Show,
                "Invalid pointer to Show method")
#endif

    // protocol sends false for activating and TRUE for not activating.
    // for api send TRUE for avtivating and FALSE for not activating.

    return (*lpclient->lpoleobject->lpvtbl->Show)(lpclient->lpoleobject, fAct);
}


int INTERNAL   DocDoVerbItem (lpdoc, lpitemname, verb, fShow, fAct)
LPDOC   lpdoc;
LPSTR   lpitemname;
WORD    verb;
BOOL    fShow;
BOOL    fAct;
{
    LPCLIENT   lpclient;
    int        retval = OLE_ERROR_PROTOCOL;

    if ((retval = FindItem (lpdoc, lpitemname, (LPCLIENT FAR *)&lpclient))
           != OLE_OK)
       return retval;

#ifdef FIREWALLS
        if (!CheckPointer (lpclient->lpoleobject->lpvtbl, WRITE_ACCESS))
            ASSERT (0, "Invalid LPOLEOBJECTVTBL")
        else
            ASSERT (lpclient->lpoleobject->lpvtbl->DoVerb,
                "Invalid pointer to Run method")
#endif

    // pass TRUE to activate and False not to activate. Differnt from
    // protocol.

    retval = (*lpclient->lpoleobject->lpvtbl->DoVerb)(lpclient->lpoleobject, verb, fShow, fAct);

    return retval;
}



// FreePokeData: Frees the poked dats.
void  INTERNAL FreePokeData (hdde)
HANDLE  hdde;
{
    DDEPOKE FAR * lpdde;

    if (hdde) {
        if (lpdde = (DDEPOKE FAR *) GlobalLock (hdde)) {
            GlobalUnlock (hdde);
            FreeGDIdata (*(LPHANDLE)lpdde->Value, lpdde->cfFormat);
        }

        GlobalFree (hdde);
    }
}



// Returns TRUE if GDI format else returns FALSE

BOOL INTERNAL FreeGDIdata (hData, cfFormat)
HANDLE          hData;
OLECLIPFORMAT   cfFormat;
{
    if (cfFormat == CF_METAFILEPICT) {
        LPMETAFILEPICT  lpMfp;

        if (lpMfp = (LPMETAFILEPICT) GlobalLock (hData)) {
            GlobalUnlock (hData);
            DeleteMetaFile (lpMfp->hMF);
        }

        GlobalFree (hData);
    }
    else if (cfFormat == CF_BITMAP)
        DeleteObject (hData);
    else if (cfFormat == CF_DIB)
        GlobalFree (hData);
    else
        return FALSE;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\ole\server\chs\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd ..
    nmake  /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DFE_SB -DDBCS -DPRC"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\ole\server\jpn\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DFE_SB -DDBCS -DJAPAN"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\ole\server\cht\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DFE_SB -DDBCS -DTAIWAN"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\ole\server\kor\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DFE_SB -DDBCS -DKOREA"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\ole\server\srvrmain.c ===
/****************************** Module Header ******************************\
* Module Name: Srvrmain.c Server Main module
*
* Purpose: Includes server intialization and termination code.
*
* Created: Oct 1990.
*
* Copyright (c) 1990, 1991  Microsoft Corporation
*
* History:
*    Raor (../10/1990)    Designed, coded
*
*
\***************************************************************************/

#include "cmacs.h"
#include "windows.h"
#include "ole.h"
#include "dde.h"
#include "srvr.h"

#ifndef WF_WLO  
#define WF_WLO  0x8000
#endif

// ordinal number of new Win31 API IsTask
#define ORD_IsTask  320

// ordinal number of new Win31 API SetMetaFileBitsBetter
#define ORD_SetMetaFileBitsBetter   196


#ifdef  FIREWALLS
short   ole_flags;
char    szDebugBuffer[80];
void    SetOleFlags(void);
#endif


// public vars.

// atomes used in the systems
ATOM    aStdExit;                      // "StdExit"
ATOM    aStdCreate;                    // "StdNewDicument"
ATOM    aStdOpen;                      // "StdOpenDocument"
ATOM    aStdEdit;                      // "StdOpenDocument"
ATOM    aStdCreateFromTemplate;        // "StdNewFromTemplate"
ATOM    aStdClose;                     // "StdCloseDocument"
ATOM    aStdShowItem;                  // "StdShowItem"
ATOM    aStdDoVerbItem;                // "StddoVerbItem"
ATOM    aSysTopic;                     // "System"
ATOM    aOLE;                          // "OLE"
ATOM    aStdDocName;                   // "StdDocumentName"

ATOM    cfBinary;                      // "Binary format"
ATOM    cfNative;                      // "NativeFormat"
ATOM    cfLink;                        // "ObjectLink"
ATOM    cfOwnerLink;                   // "Ownerlink"

ATOM    aChange;                       // "Change"
ATOM    aSave;                         // "Save"
ATOM    aClose;                        // "Close"
ATOM    aProtocols;                    // "Protocols"
ATOM    aTopics;                       // "Topics"
ATOM    aFormats;                      // "Formats"
ATOM    aStatus;                       // "Status"
ATOM    aEditItems;                    // "Edit items
ATOM    aTrue;                         // "True"
ATOM    aFalse;                        // "False"





// !!! free the proc instances.
FARPROC lpSendRenameMsg;               // Call back enum props for rename
FARPROC lpSendDataMsg;                 // Call back enum props for data
FARPROC lpFindItemWnd;                 // Callback in enum props of
FARPROC lpItemCallBack;                // CallBack for object
FARPROC lpTerminateClients;            // Callback in Doc enum properties
FARPROC lpTerminateDocClients;         // Callback in Doc enum properties
FARPROC lpDeleteClientInfo;            // proc for deleteing each item client
FARPROC lpEnumForTerminate;            // proc for terminating clients not in rename list

FARPROC lpfnSetMetaFileBitsBetter = NULL;
FARPROC lpfnIsTask = NULL;

HANDLE  hdllInst;
BOOL    bProtMode;
BOOL    bWLO = FALSE;
BOOL    bWin30 = FALSE;

VOID FAR PASCAL WEP (int);
#pragma alloc_text(WEP_TEXT, WEP)

int FAR PASCAL LibMain (hInst, wDataSeg, cbHeapSize, lpszCmdLine)
HANDLE  hInst;
WORD    wDataSeg;
WORD    cbHeapSize;
LPSTR   lpszCmdLine;
{
    WNDCLASS  wc;

    Puts("LibMain");

#ifdef  FIREWALLS
    SetOleFlags();
#endif

    hdllInst = hInst;

    bProtMode = (BOOL) (GetWinFlags() & WF_PMODE & 0x0000FFFF);
    bWLO      = (BOOL) (GetWinFlags() & WF_WLO);    
    bWin30    = (!bWLO && ((WORD) GetVersion()) <= 0x0003);
        
    // !!! Put all this stuff thru soemkind of table so that we can
    // save code.

    // register all the atoms.
    aStdExit                = GlobalAddAtom ((LPSTR)"StdExit");
    aStdCreate              = GlobalAddAtom ((LPSTR)"StdNewDocument");
    aStdOpen                = GlobalAddAtom ((LPSTR)"StdOpenDocument");
    aStdEdit                = GlobalAddAtom ((LPSTR)"StdEditDocument");
    aStdCreateFromTemplate  = GlobalAddAtom ((LPSTR)"StdNewfromTemplate");

    aStdClose               = GlobalAddAtom ((LPSTR)"StdCloseDocument");
    aStdShowItem            = GlobalAddAtom ((LPSTR)"StdShowItem");
    aStdDoVerbItem          = GlobalAddAtom ((LPSTR)"StdDoVerbItem");
    aSysTopic               = GlobalAddAtom ((LPSTR)"System");
    aOLE                    = GlobalAddAtom ((LPSTR)"OLEsystem");
    aStdDocName             = GlobalAddAtom ((LPSTR)"StdDocumentName");

    aProtocols              = GlobalAddAtom ((LPSTR)"Protocols");
    aTopics                 = GlobalAddAtom ((LPSTR)"Topics");
    aFormats                = GlobalAddAtom ((LPSTR)"Formats");
    aStatus                 = GlobalAddAtom ((LPSTR)"Status");
    aEditItems              = GlobalAddAtom ((LPSTR)"EditEnvItems");

    aTrue                   = GlobalAddAtom ((LPSTR)"True");
    aFalse                  = GlobalAddAtom ((LPSTR)"False");

    aChange                 = GlobalAddAtom ((LPSTR)"Change");
    aSave                   = GlobalAddAtom ((LPSTR)"Save");
    aClose                  = GlobalAddAtom ((LPSTR)"Close");

    // create the proc instances for the required entry pts.
    lpSendRenameMsg         = MakeProcInstance (SendRenameMsg, hdllInst);
    lpSendDataMsg           = MakeProcInstance (SendDataMsg, hdllInst);
    lpFindItemWnd           = MakeProcInstance (FindItemWnd, hdllInst);
    lpItemCallBack          = MakeProcInstance (ItemCallBack, hdllInst);
    lpTerminateClients      = MakeProcInstance (TerminateClients, hdllInst);
    lpTerminateDocClients   = MakeProcInstance (TerminateDocClients, hdllInst);
    lpDeleteClientInfo      = MakeProcInstance (DeleteClientInfo, hdllInst);
    lpEnumForTerminate      = MakeProcInstance (EnumForTerminate , hdllInst);

    // register the clipboard formats
    cfNative                = RegisterClipboardFormat("Native");
    cfBinary                = RegisterClipboardFormat("Binary");
    cfLink                  = RegisterClipboardFormat("ObjectLink");
    cfOwnerLink             = RegisterClipboardFormat("OwnerLink");



    wc.style        = NULL;
    wc.cbClsExtra   = 0;
    wc.cbWndExtra   = sizeof(LONG) +     //Ask for extra space for storing the
                                        //ptr to srvr/doc/iteminfo.
                      sizeof (WORD) +   // for LE chars
                      sizeof (WORD);    // for keeping the hDLLInst.

    wc.hInstance    = hInst;
    wc.hIcon        = NULL;
    wc.hCursor      = NULL;
    wc.hbrBackground= NULL;
    wc.lpszMenuName =  NULL;


    // Srvr window class
    wc.lpfnWndProc  = SrvrWndProc;
    wc.lpszClassName= SRVR_CLASS;
    if (!RegisterClass(&wc))
         return 0;

    // document window class
    wc.lpfnWndProc = DocWndProc;
    wc.lpszClassName = DOC_CLASS;

    if (!RegisterClass(&wc))
        return 0;

    // Item (object) window class
    wc.lpfnWndProc = ItemWndProc;
    wc.lpszClassName = ITEM_CLASS;

    wc.cbWndExtra   = sizeof(LONG); // for items do not need extra stuff.
    if (!RegisterClass(&wc))
        return 0;


    if (!bWin30) {
        HANDLE  hModule;
        
        if (hModule = GetModuleHandle ("GDI")) 
            lpfnSetMetaFileBitsBetter 
                = GetProcAddress (hModule,
                        (LPSTR) MAKELONG(ORD_SetMetaFileBitsBetter, 0));
                                   
        if (hModule = GetModuleHandle ("KERNEL")) 
            lpfnIsTask 
                = GetProcAddress (hModule, (LPSTR) MAKELONG(ORD_IsTask, 0));
    }
    
    if (cbHeapSize != 0)
        UnlockData(0);

    return 1;
}


VOID FAR PASCAL WEP (nParameter)
int nParameter;
{

    Puts("LibExit");

    if (nParameter == WEP_SYSTEM_EXIT)
        DEBUG_OUT ("---L&E DLL EXIT on system exit---",0)

    else {
        if (nParameter == WEP_FREE_DLL)
            DEBUG_OUT ("---L&E DLL EXIT---",0)

        else
            return;
    }

    // free the global atoms.
    if (aStdExit)
        GlobalDeleteAtom (aStdExit);
    if (aStdCreate)
        GlobalDeleteAtom (aStdCreate);
    if (aStdOpen)
        GlobalDeleteAtom (aStdOpen);
    if (aStdEdit)
        GlobalDeleteAtom (aStdEdit);
    if (aStdCreateFromTemplate)
        GlobalDeleteAtom (aStdCreateFromTemplate);
    if (aStdClose)
        GlobalDeleteAtom (aStdClose);
    if (aStdShowItem)
        GlobalDeleteAtom (aStdShowItem);
    if (aStdDoVerbItem)
        GlobalDeleteAtom (aStdDoVerbItem);
    if (aSysTopic)
        GlobalDeleteAtom (aSysTopic);
    if (aOLE)
        GlobalDeleteAtom (aOLE);
    if (aStdDocName)
        GlobalDeleteAtom (aStdDocName);

    if (aProtocols)
        GlobalDeleteAtom (aProtocols);
    if (aTopics)
        GlobalDeleteAtom (aTopics);
    if (aFormats)
        GlobalDeleteAtom (aFormats);
    if (aStatus)
        GlobalDeleteAtom (aStatus);
    if (aEditItems)
        GlobalDeleteAtom (aEditItems);

    if (aTrue)
        GlobalDeleteAtom (aTrue);
    if (aFalse)
        GlobalDeleteAtom (aFalse);

    if (aChange)
        GlobalDeleteAtom (aChange);
    if (aSave)
        GlobalDeleteAtom (aSave);
    if (aClose)
        GlobalDeleteAtom (aClose);

    // !!! for some reason these FreeprocInstances are crashing the system.
#if 0
    FreeProcInstance (lpSendRenameMsg);
    FreeProcInstance (lpSendDataMsg);
    FreeProcInstance (lpFindItemWnd);
    FreeProcInstance (lpItemCallBack);
    FreeProcInstance (lpTerminateClients);
    FreeProcInstance (lpTerminateDocClients);
    FreeProcInstance (lpDeleteClientInfo);
    FreeProcInstance (EnumForTerminate);
#endif

}



#ifdef  FIREWALLS
void SetOleFlags()
{

    char    buffer[80];

    if(GetProfileString ("OleDll",
        "Puts","", (LPSTR)buffer, 80))
        ole_flags = DEBUG_PUTS;
    else
        ole_flags = 0;


    if(GetProfileString ("OleDll",
        "DEBUG_OUT","", (LPSTR)buffer, 80))
        ole_flags |= DEBUG_DEBUG_OUT;

}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\ole\server\srvr.h ===
/****************************** Module Header ******************************\
* Module Name: srvr.h
*
* PURPOSE: Private definitions file for server code
*
* Created: 1990
*
* Copyright (c) 1990, 1991  Microsoft Corporation
*
* History:
*  Raor (../../90,91)  Original
*
\***************************************************************************/

#define DEFSTD_ITEM_INDEX   0
#define STDTARGETDEVICE     1
#define STDDOCDIMENSIONS    2
#define STDCOLORSCHEME      3
#define STDHOSTNAMES        4


#define PROTOCOL_EDIT       ((LPSTR)"StdFileEditing")
#define PROTOCOL_EXECUTE    ((LPSTR)"StdExecute")

#define SRVR_CLASS          ((LPSTR)"SrvrWndClass")
#define DOC_CLASS           ((LPSTR)"DocWndClass")
#define ITEM_CLASS          ((LPSTR)"ItemWndClass")


#define   ISATOM(a)     ((a >= 0xC000) && (a <= 0xFFFF))

#define   MAX_STR       124

#define   WW_LPTR       0       // ptr tosrvr/doc/item
#define   WW_LE         4       // signature
#define   WW_HANDLE     6       // instance handle

#define   WC_LE         0x4c45  // LE chars

// If we running under WLO, the HIGHWORD of version number will be >= 0x0A00
#define VER_WLO     0x0A00

extern  WORD CheckPointer (LPVOID, int);

#define READ_ACCESS     0 
#define WRITE_ACCESS    1   

#define PROBE_READ(lp){\
        if (!CheckPointer(lp, READ_ACCESS))\
            return OLE_ERROR_ADDRESS;  \
}

#define PROBE_WRITE(lp){\
        if (!CheckPointer(lp, WRITE_ACCESS))\
            return OLE_ERROR_ADDRESS;  \
}

#define   OLE_COMMAND       1
#define   NON_OLE_COMMAND   2


#define   WT_SRVR           0       // server window 
#define   WT_DOC            1       // document window

#define   PROBE_BLOCK(lpsrvr) {             \
    if (lpsrvr->bBlock)                     \
        return OLE_ERROR_SERVER_BLOCKED;    \
}


#define   SET_MSG_STATUS(retval, status) { \
    if (retval == OLE_OK)                 \
        status |= 0x8000;                  \
    if (retval == OLE_BUSY)                \
        status |= 0x4000;                  \
}


typedef   LHSERVER         LHSRVR;
typedef   LHSERVERDOC       LHDOC;

typedef struct _QUE {   // nodes in Block/Unblock queue
    HWND        hwnd;       //***
    unsigned    msg;        //      window 
    WORD        wParam;     //      procedure parameters
    LONG        lParam;     //***
    HANDLE      hqNext;     // handle to next node
} QUE;

typedef QUE NEAR *  PQUE;
typedef QUE FAR *   LPQUE;


typedef struct _SRVR { /*srvr*/     // private data
    LPOLESERVER     lpolesrvr;          // corresponding server
    char            sig[2];             // signature "SR"
    HANDLE          hsrvr;              // global handle
    ATOM            aClass;             // class atom
    ATOM            aExe;
    HWND            hwnd;               // corresponding window
    BOOL            bTerminate;         // Set if we are terminating.
    int             termNo;             // termination count
    BOOL            relLock;            // ok to release the server.
    BOOL            bnoRelease;         // Block release. call
    WORD            useFlags;           // instance usage flags
    int             cClients;           // no of clients;
    BOOL            bBlock;             // blocked if TRUE 
    BOOL            bBlockedMsg;        // msg from block queue if TRUE
    HANDLE          hqHead;             // Head and tail of the blocked
    HANDLE          hqTail;             //   messages queue.

    HANDLE          hqPostHead;         // Head and tail of the blocked post msg
    HANDLE          hqPostTail;         // .
    BOOL            fAckExit;           
    HWND            hwndExit;
    HANDLE          hDataExit;
} SRVR;

typedef  SRVR FAR   *LPSRVR;


LONG    FAR  PASCAL DocWndProc (HWND, WORD, WORD, LONG);
LONG    FAR  PASCAL ItemWndProc (HWND, WORD, WORD, LONG);
LONG    FAR  PASCAL SrvrWndProc (HWND, WORD, WORD, LONG);
BOOL    FAR  PASCAL TerminateClients (HWND, LPSTR, HANDLE);
void                SendMsgToChildren (HWND, WORD, WORD, LONG);


OLESTATUS   INTERNAL    RequestDataStd (LONG, HANDLE FAR *);
BOOL        INTERNAL    ValidateSrvrClass (LPSTR, ATOM FAR *);
ATOM        INTERNAL    GetExeAtom (LPSTR);
BOOL        INTERNAL    AddClient (HWND, HANDLE, HANDLE);
BOOL        INTERNAL    DeleteClient (HWND, HANDLE);
HANDLE      INTERNAL    FindClient (HWND, HANDLE);
BOOL        INTERNAL    MakeSrvrStr(LPSTR, int, LPSTR, HANDLE);
int         INTERNAL    RevokeAllDocs (LPSRVR);
int         INTERNAL    ReleaseSrvr (LPSRVR);
void        INTERNAL    WaitForTerminate (LPSRVR);
OLESTATUS   INTERNAL    SrvrExecute (HWND, HANDLE, HWND);
BOOL        INTERNAL    HandleInitMsg (LPSRVR, LONG);
BOOL        INTERNAL    QueryRelease (LPSRVR);
BOOL        INTERNAL    IsSingleServerInstance (void);

void    INTERNAL    MapToHexStr (LPSTR, HANDLE);
void    INTERNAL    UtilMemCpy (LPSTR, LPSTR, DWORD);
HANDLE  INTERNAL    DuplicateData (HANDLE);
LPSTR   INTERNAL    ScanBoolArg (LPSTR, BOOL FAR *);
LPSTR   INTERNAL    ScanNumArg (LPSTR, LPINT);
LPSTR   INTERNAL    ScanArg(LPSTR);
ATOM    INTERNAL    MakeDataAtom (ATOM, int);
ATOM    INTERNAL    DuplicateAtom (ATOM);


// doc stuff
typedef struct _DOC { /*doc*/       // private data
    LPOLESERVERDOC  lpoledoc;           // corresponding oledoc
    char            sig[2];             // signature "SD"
    HANDLE          hdoc;               // global handle
    ATOM            aDoc;
    HWND            hwnd;
    BOOL            bTerminate;
    int             termNo;
    int             cClients;           // no of clients;
    BOOL            fEmbed;             // TRUE if embedded document
    BOOL            fAckClose;
    HWND            hwndClose;
    HANDLE          hDataClose;
} DOC;

typedef  DOC  FAR   *LPDOC;


LPDOC       INTERNAL    FindDoc (LPSRVR, LPSTR);
int         INTERNAL    ReleaseDoc (LPDOC);
OLESTATUS   INTERNAL    DocExecute (HWND, HANDLE, HWND);
BOOL        FAR PASCAL  TerminateDocClients (HWND, LPSTR, HANDLE);
int         INTERNAL    DocShowItem (LPDOC, LPSTR, BOOL);
int         INTERNAL    DocDoVerbItem (LPDOC, LPSTR, WORD, BOOL, BOOL);


// client struct definitions.

typedef struct _CLIENT { /*doc*/    // private data
    OLECLIENT   oleClient;          // oleclient structure
    LPOLEOBJECT lpoleobject;        // corresponding oledoc
    HANDLE      hclient;            // global handle
    ATOM        aItem;              // item atom or index for some std items
    HWND        hwnd;               // item window
    HANDLE      hdevInfo;           // latest printer dev info sent
} CLIENT;

typedef  CLIENT FAR   *LPCLIENT;

typedef struct _CLINFO { /*clInfo*/ // client transaction info
    HWND        hwnd;               // client window handle
    BOOL        bnative;            // doe sthis client require native
    int         format;             // dusplay format
    int         options;            // transaction advise time otipns
    BOOL        bdata;              // need wdat with advise?
    HANDLE      hdevInfo;           // device info handle
    BOOL        bnewDevInfo;        // new device info
} CLINFO;

typedef  CLINFO  *PCLINFO;




BOOL    FAR PASCAL  FindItemWnd (HWND, LONG);
BOOL    FAR PASCAL  SendRenameMsg (HWND, LPSTR, HANDLE);
BOOL    FAR PASCAL  EnumForTerminate (HWND, LPSTR, HANDLE);
BOOL    FAR PASCAL  SendDataMsg(HWND, LPSTR, HANDLE);
BOOL    FAR PASCAL  DeleteClientInfo (HWND, LPSTR, HANDLE);
int     FAR PASCAL  ItemCallBack (LPOLECLIENT, int, LPOLEOBJECT);

int         INTERNAL    RegisterItem (LHDOC, LPSTR, LPCLIENT FAR *, BOOL);
int         INTERNAL    FindItem (LPDOC, LPSTR, LPCLIENT FAR *);
HWND        INTERNAL    SearchItem (LPDOC, LPSTR);
void        INTERNAL    DeleteFromItemsList (HWND, HWND);
void        INTERNAL    DeleteAllItems (HWND);
OLESTATUS   INTERNAL    PokeData (LPDOC, HWND, LONG);
HANDLE      INTERNAL    MakeItemData (DDEPOKE FAR *, HANDLE, OLECLIPFORMAT);
OLESTATUS   INTERNAL    AdviseData (LPDOC, HWND, LONG, BOOL FAR *);
OLESTATUS   INTERNAL    AdviseStdItems (LPDOC, HWND, LONG, BOOL FAR *);
OLESTATUS   INTERNAL    UnAdviseData (LPDOC, HWND, LONG);
OLESTATUS   INTERNAL    RequestData (LPDOC, HWND, LONG, HANDLE FAR *);
BOOL        INTERNAL    MakeDDEData (HANDLE, int, LPHANDLE, BOOL);
HANDLE      INTERNAL    MakeGlobal (LPSTR);
int         INTERNAL    ScanItemOptions (LPSTR, int far *);
OLESTATUS   INTERNAL    PokeStdItems (LPDOC, HWND, LONG);
int         INTERNAL    GetStdItemIndex (ATOM);
BOOL        INTERNAL    IsAdviseStdItems (ATOM);
int         INTERNAL    SetStdInfo (LPDOC, HWND, LPSTR, HANDLE);
void        INTERNAL    SendDevInfo (LPCLIENT, LPSTR);
BOOL        INTERNAL    IsFormatAvailable (LPCLIENT, OLECLIPFORMAT);
OLESTATUS   INTERNAL    RevokeObject (LPOLECLIENT, BOOL);


BOOL        INTERNAL    AddMessage (HWND, unsigned, WORD, LONG, int);

#define   ITEM_FIND          1      // find the item
#define   ITEM_DELETECLIENT  2      // delete the client from item clients
#define   ITEM_DELETE        3      // delete th item window itself
#define   ITEM_SAVED         4      // item saved

// host names data structcure
typedef struct _HOSTNAMES {
    WORD    clientNameOffset;
    WORD    documentNameOffset;
    BYTE    data[];
} HOSTNAMES;

typedef HOSTNAMES FAR * LPHOSTNAMES;


// routines in UTILS.C

void    INTERNAL    MapToHexStr (LPSTR, HANDLE);
void    INTERNAL    UtilMemCpy (LPSTR, LPSTR, DWORD);
HANDLE  INTERNAL    DuplicateData (HANDLE);
LPSTR   INTERNAL    ScanLastBoolArg (LPSTR);
LPSTR   INTERNAL    ScanArg(LPSTR);
WORD    INTERNAL    ScanCommand(LPSTR, WORD, LPSTR FAR *, ATOM FAR *);
ATOM    INTERNAL    MakeDataAtom (ATOM, int);
ATOM    INTERNAL    DuplicateAtom (ATOM);
WORD    INTERNAL    StrToInt (LPSTR);
BOOL    INTERNAL    CheckServer (LPSRVR);
BOOL    INTERNAL    CheckServerDoc (LPDOC);
BOOL    INTERNAL    PostMessageToClientWithBlock (HWND, WORD, WORD, DWORD);
BOOL    INTERNAL    PostMessageToClient (HWND, WORD, WORD, DWORD);
BOOL    INTERNAL    IsWindowValid (HWND);
BOOL    INTERNAL    IsOleCommand (ATOM, WORD);
BOOL    INTERNAL    UtilQueryProtocol (ATOM, LPSTR);


// routines for queueing messages and posting them
BOOL INTERNAL  UnblockPostMsgs(HWND, BOOL);
BOOL INTERNAL  BlockPostMsg (HWND, WORD, WORD, LONG);
BOOL INTERNAL  IsBlockQueueEmpty (HWND);

// routine in GIVE2GDI.ASM
HANDLE  FAR PASCAL   GiveToGDI (HANDLE);


// routine in item.c
HBITMAP INTERNAL DuplicateBitmap (HBITMAP);
HANDLE  INTERNAL DuplicateMetaFile (HANDLE);

// routines in doc.c
void    INTERNAL FreePokeData (HANDLE);
BOOL    INTERNAL FreeGDIdata (HANDLE, OLECLIPFORMAT);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\rasapi16\sources.inc ===
TARGETNAME=
TARGETTYPE=NOTARGET
TARGETPATH=
SOURCES=

NTTARGETFILE1=buildall

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\rasapi16\usa\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH)
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\ole\server\usa\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DFE_SB"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\ole\server\utils.c ===
/****************************** Module Header ******************************\
* Module Name: utils.c
*
* Purpose: Conatains all the utility routines
*
* Created: 1990
*
* Copyright (c) 1990, 1991  Microsoft Corporation
*
* History:
*   Raor, Srinik (../../1990)    Designed and coded
*
\***************************************************************************/

#include <windows.h>
#include "cmacs.h"
#include <shellapi.h>

#include "ole.h"
#include "dde.h"
#include "srvr.h"


#ifndef HUGE
#define HUGE    huge
#endif

#define KB_64   65536

extern ATOM    aTrue;
extern ATOM    aFalse;
extern BOOL    bWLO;
extern BOOL    bWin30;

extern ATOM    aStdCreateFromTemplate;
extern ATOM    aStdCreate;
extern ATOM    aStdOpen;
extern ATOM    aStdEdit;
extern ATOM    aStdShowItem;
extern ATOM    aStdClose;
extern ATOM    aStdExit;
extern ATOM    aStdDoVerbItem;

extern BOOL (FAR PASCAL *lpfnIsTask) (HANDLE);

// MapToHexStr: Converts  WORD to hex string.
void INTERNAL MapToHexStr (lpbuf, hdata)
LPSTR       lpbuf;
HANDLE      hdata;
{
    int     i;
    char    ch;

    *lpbuf++ = '@';
    for ( i = 3; i >= 0; i--) {

        ch = (char) ((((WORD)hdata) >> (i * 4)) & 0x000f);
        if(ch > '9')
            ch += 'A' - 10;
        else
            ch += '0';

        *lpbuf++ = ch;
    }

    *lpbuf++ = NULL;

}


void INTERNAL UtilMemCpy (lpdst, lpsrc, dwCount)
LPSTR   lpdst;
LPSTR   lpsrc;
DWORD   dwCount;
{
    WORD HUGE * hpdst;
    WORD HUGE * hpsrc;
    WORD FAR  * lpwDst;
    WORD FAR  * lpwSrc;
    DWORD       words;
    DWORD       bytes;
    
    bytes = dwCount %  2;
    words = dwCount >> 1;           //* we should compare DWORDS
                                    //* in the 32 bit version 
    if (dwCount <= KB_64) {
        lpwDst = (WORD FAR *) lpdst;
        lpwSrc = (WORD FAR *) lpsrc;
        
        while (words--) 
            *lpwDst++ = *lpwSrc++;

        if (bytes) 
            * (char FAR *) lpwDst = * (char FAR *) lpwSrc;
    }
    else {
        hpdst = (WORD HUGE *) lpdst;
        hpsrc = (WORD HUGE *) lpsrc;
    
        while (words--) 
            *hpdst++ = *hpsrc++;

        if (bytes) 
            *(char HUGE *) hpdst = * (char HUGE *) hpsrc;
    }
}


//DuplicateData: Duplicates a given Global data handle.
HANDLE  INTERNAL    DuplicateData (hdata)
HANDLE  hdata;
{
    LPSTR   lpsrc = NULL;
    LPSTR   lpdst = NULL;
    HANDLE  hdup  = NULL;
    DWORD   size;
    BOOL    err   = TRUE;
    
    if(!(lpsrc =  GlobalLock (hdata)))
        return NULL;

    hdup = GlobalAlloc (GMEM_MOVEABLE | GMEM_DDESHARE, (size = GlobalSize(hdata)));

    if(!(lpdst =  GlobalLock (hdup)))
        goto errRtn;;

    err = FALSE;
    UtilMemCpy (lpdst, lpsrc, size);
    
errRtn:
    if(lpsrc)
        GlobalUnlock (hdata);

    if(lpdst)
        GlobalUnlock (hdup);

    if (err && hdup)
        GlobalFree (hdup);

    return hdup;
}


//ScanBoolArg: scans the argument which is not included in
//the quotes. These args could be only TRUE or FALSE for
//the time being. !!!The scanning routines should be
//merged and it should be generalized.

LPSTR   INTERNAL    ScanBoolArg (lpstr, lpflag)
LPSTR   lpstr;
BOOL    FAR *lpflag;
{


    LPSTR   lpbool;
    ATOM    aShow;
    char    ch;

    lpbool = lpstr;

    // !!! These routines does not take care of quoted quotes.

    while((ch = *lpstr) && (!(ch == ')' || ch == ',')))
    {								//[J1]
#if	defined(FE_SB)						//[J1]
	lpstr = AnsiNext( lpstr );				//[J1]
#else								//[J1]
        lpstr++;
#endif								//[J1]
    }								//[J1]

    if(ch == NULL)
       return NULL;

    *lpstr++ = NULL;       // terminate the arg by null

    // if terminated by paren, then check for end of command
    // syntax.

    // Check for the end of the command string.
    if (ch == ')') {
        if (*lpstr++ != ']')
            return NULL;

        if(*lpstr != NULL)
            return NULL;             //finally should be terminated by null.

    }

    aShow = GlobalFindAtom (lpbool);
    if (aShow == aTrue)
        *lpflag = TRUE;

    else {
        if (aShow ==aFalse)
            *lpflag = FALSE;
        else
            return NULL;;
    }
    return lpstr;
}




//ScannumArg: Checks for the syntax of num arg in Execute and if
//the arg is syntactically correct, returns the ptr to the
//beginning of the next arg and also, returns the number
//Does not take care of the last num arg in the list.

LPSTR   INTERNAL    ScanNumArg (lpstr, lpnum)
LPSTR   lpstr;
LPINT   lpnum;
{

    WORD    val = 0;
    char    ch;

    while((ch = *lpstr++) && (ch != ',')) {
        if (ch < '0' || ch >'9')
            return NULL;
        val += val * 10 + (ch - '0');

    }

    if(!ch)
       return NULL;

    *lpnum = val;
    return lpstr;
}




//ScanArg: Checks for the syntax of arg in Execute and if
//the arg is syntactically correct, returns the ptr to the
//beginning of the next arg or to the end of the excute string.

LPSTR   INTERNAL    ScanArg (lpstr)
LPSTR   lpstr;
{


    // !!! These routines does not take care of quoted quotes.

    // first char should be quote.

    if (*(lpstr-1) != '\"')
        return NULL;

    while(*lpstr && *lpstr != '\"')
    {								//[J1]
#if	defined(FE_SB)						//[J1]
	lpstr = AnsiNext( lpstr );				//[J1]
#else								//[J1]
        lpstr++;
#endif								//[J1]
    }								//[J1]

    if(*lpstr == NULL)
       return NULL;

    *lpstr++ = NULL;       // terminate the arg by null

    if(!(*lpstr == ',' || *lpstr == ')'))
        return NULL;


    if(*lpstr++ == ','){

        if(*lpstr == '\"')
            return ++lpstr;
        // If it is not quote, leave the ptr on the first char
        return lpstr;
    }

    // terminated by paren
    // already skiped right paren

    // Check for the end of the command string.
    if (*lpstr++ != ']')
        return NULL;

    if(*lpstr != NULL)
        return NULL;             //finally should be terminated by null.

    return lpstr;
}

// ScanCommand: scanns the command string for the syntax
// correctness. If syntactically correct, returns the ptr
// to the first arg or to the end of the string.

WORD INTERNAL  ScanCommand (lpstr, wType, lplpnextcmd, lpAtom)
LPSTR       lpstr;
WORD        wType;
LPSTR FAR * lplpnextcmd;
ATOM FAR *  lpAtom;
{
    // !!! These routines does not take care of quoted quotes.
    // and not taking care of blanks arround the operators

    // !!! We are not allowing blanks after operators.
    // Should be allright! since this is arestricted syntax.

    char    ch;
    LPSTR   lptemp = lpstr;
    

    while(*lpstr && (!(*lpstr == '(' || *lpstr == ']')))
    {								//[J1]
#if	defined(FE_SB)						//[J1]
	lpstr = AnsiNext( lpstr );				//[J1]
#else								//[J1]
        lpstr++;
#endif								//[J1]
    }								//[J1]

    if(*lpstr == NULL)
       return NULL;

    ch = *lpstr;
    *lpstr++ = NULL;       // set the end of command

    *lpAtom = GlobalFindAtom (lptemp);

    if (!IsOleCommand (*lpAtom, wType))
        return NON_OLE_COMMAND;
    
    if (ch == '(') {

#if	defined(FE_SB)						//[J1]
	ch = *lpstr;						//[J1]
	lpstr = AnsiNext( lpstr );				//[J1]
#else								//[J1]
        ch = *lpstr++;
#endif								//[J1]

        if (ch == ')') {
             if (*lpstr++ != ']')
                return NULL;
        } 
        else {
            if (ch != '\"')
                return NULL;
        }
        
        *lplpnextcmd = lpstr;
        return OLE_COMMAND;
    }

    // terminated by ']'

    if (*(*lplpnextcmd = lpstr)) // if no nul termination, then it is error.
        return NULL;

    return OLE_COMMAND;
}


//MakeDataAtom: Creates a data atom from the item string
//and the item data otions.

ATOM INTERNAL MakeDataAtom (aItem, options)
ATOM    aItem;
int     options;
{
    char    buf[MAX_STR];

    if (options == OLE_CHANGED)
        return DuplicateAtom (aItem);

    if (!aItem)
        buf[0] = NULL;
    else
        GlobalGetAtomName (aItem, (LPSTR)buf, MAX_STR);

    if (options == OLE_CLOSED)
        lstrcat ((LPSTR)buf, (LPSTR) "/Close");
    else {
        if (options == OLE_SAVED)
           lstrcat ((LPSTR)buf, (LPSTR) "/Save");
    }

    if (buf[0])
        return GlobalAddAtom ((LPSTR)buf);
    else
        return NULL;
}

//DuplicateAtom: Duplicates an atom
ATOM INTERNAL DuplicateAtom (atom)
ATOM    atom;
{
    char buf[MAX_STR];

    Puts ("DuplicateAtom");

    if (!atom)
        return NULL;
    
    GlobalGetAtomName (atom, buf, MAX_STR);
    return GlobalAddAtom (buf);
}

// MakeGlobal: makes global out of strings.
// works only for << 64k

HANDLE  INTERNAL MakeGlobal (lpstr)
LPSTR   lpstr;
{

    int     len = 0;
    HANDLE  hdata  = NULL;
    LPSTR   lpdata = NULL;

    len = lstrlen (lpstr) + 1;

    hdata = GlobalAlloc (GMEM_MOVEABLE | GMEM_DDESHARE, len);
    if (hdata == NULL || (lpdata = (LPSTR) GlobalLock (hdata)) == NULL)
        goto errRtn;


    UtilMemCpy (lpdata, lpstr, (DWORD)len);
    GlobalUnlock (hdata);
    return hdata;

errRtn:

    if (lpdata)
        GlobalUnlock (hdata);


    if (hdata)
        GlobalFree (hdata);

     return NULL;

}



BOOL INTERNAL CheckServer (lpsrvr)
LPSRVR  lpsrvr;
{
    if (!CheckPointer(lpsrvr, WRITE_ACCESS))
        return FALSE;

    if ((lpsrvr->sig[0] == 'S') && (lpsrvr->sig[1] == 'R'))
        return TRUE;
    
    return FALSE;
}


BOOL INTERNAL CheckServerDoc (lpdoc)
LPDOC   lpdoc;
{
    if (!CheckPointer(lpdoc, WRITE_ACCESS))
        return FALSE;

    if ((lpdoc->sig[0] == 'S') && (lpdoc->sig[1] == 'D'))
        return TRUE;
    
    return FALSE;
}


BOOL INTERNAL PostMessageToClientWithBlock (hWnd, wMsg, wParam, lParam)
HWND    hWnd;
WORD    wMsg;
WORD    wParam;
DWORD   lParam;
{
    if (!IsWindowValid (hWnd)) {
        ASSERT(FALSE, "Client's window is missing");
        return FALSE;
    }
    
    if (IsBlockQueueEmpty ((HWND)wParam) && PostMessage (hWnd, wMsg, wParam, lParam))
        return TRUE;

    BlockPostMsg (hWnd, wMsg, wParam, lParam);
    return TRUE;
}



BOOL INTERNAL PostMessageToClient (hWnd, wMsg, wParam, lParam)
HWND    hWnd;
WORD    wMsg;
WORD    wParam;
DWORD   lParam;
{
    if (!IsWindowValid (hWnd)) {
        ASSERT(FALSE, "Client's window is missing");
        return FALSE;
    }

    if (IsBlockQueueEmpty ((HWND)wParam) && PostMessage (hWnd, wMsg, wParam, lParam))
        return TRUE;

    BlockPostMsg (hWnd, wMsg, wParam, lParam);
    return TRUE;
}


BOOL    INTERNAL IsWindowValid (hwnd)
HWND    hwnd;
{

#define TASK_OFFSET 0x00FA

    LPSTR   lptask;
    HANDLE  htask;

    if (!IsWindow (hwnd))
        return FALSE;

    if (bWLO) 
        return TRUE;

    // now get the task handle and find out it is valid.
    htask  = GetWindowTask (hwnd);

    if (bWin30 || !lpfnIsTask) {
        lptask = (LPSTR)(MAKELONG (TASK_OFFSET, htask));

        if (!CheckPointer(lptask, READ_ACCESS))
            return FALSE;

        // now check for the signature bytes of task block in kernel
        if (*lptask++ == 'T' && *lptask == 'D')
            return TRUE;
    }
    else {
        // From win31 onwards the API IsTask() can be used for task validation
        if ((*lpfnIsTask)(htask))
            return TRUE;
    }
    
    return FALSE;
}



BOOL INTERNAL UtilQueryProtocol (aClass, lpprotocol)
ATOM    aClass;
LPSTR   lpprotocol;
{
    HKEY    hKey;
    char    key[MAX_STR];
    char    class[MAX_STR];

    if (!aClass)
        return FALSE;
    
    if (!GlobalGetAtomName (aClass, class, MAX_STR))
        return FALSE;
    
    lstrcpy (key, class);
    lstrcat (key, "\\protocol\\");
    lstrcat (key, lpprotocol);
    lstrcat (key, "\\server");

    if (RegOpenKey (HKEY_CLASSES_ROOT, key, &hKey))
        return FALSE;
    
    RegCloseKey (hKey);     
    return TRUE;
}


BOOL INTERNAL IsOleCommand (aCmd, wType)
ATOM    aCmd;
WORD    wType;
{
    if (wType == WT_SRVR) {
        if ((aCmd == aStdCreateFromTemplate)
                || (aCmd == aStdCreate)
                || (aCmd == aStdOpen)
                || (aCmd == aStdEdit)               
                || (aCmd == aStdShowItem)
                || (aCmd == aStdClose)
                || (aCmd == aStdExit))
            return TRUE;
    }
    else {
        if ((aCmd == aStdClose)
                || (aCmd == aStdDoVerbItem)
                || (aCmd == aStdShowItem))
            return TRUE;
    }
    
    return FALSE;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\rasapi16\ras.h ===
/* Copyright (c) 1992, Microsoft Corporation, all rights reserved
**
** ras.h
** Remote Access external Win16 API
** Public header for external Win16 API clients
**
** Note: The 'dwSize' member of a data structure X must be set to sizeof(X)
**       before calling the associated API, otherwise ERROR_INVALID_SIZE is
**       returned.  The value expected by the API is listed next to each
**       'dwSize' member.
*/

#ifndef _RAS_H_
#define _RAS_H_

#ifndef RC_INVOKED
#pragma pack(2)
#endif

#ifndef NETCONS_INCLUDED
#define UNLEN 20
#define PWLEN 14
#define DNLEN 15
#endif

#ifndef APIENTRY
#define APIENTRY FAR PASCAL
#endif

#ifndef CHAR
#define CHAR char
#endif

#ifndef UINT
#define UINT unsigned int
#endif


#define RAS_MaxEntryName      20
#define RAS_MaxDeviceName     32
#define RAS_MaxDeviceType     16
#define RAS_MaxParamKey       32
#define RAS_MaxParamValue     128
#define RAS_MaxPhoneNumber    128
#define RAS_MaxCallbackNumber 48


#define HRASCONN   const void far*
#define LPHRASCONN HRASCONN FAR*


/* Pass this string to the RegisterWindowMessage() API to get the message
** number that will be used for notifications on the hwnd you pass to the
** RasDial() API.  WM_RASDIALEVENT is used only if a unique message cannot be
** registered.
*/
#define RASDIALEVENT    "RasDialEvent"
#define WM_RASDIALEVENT 0xCCCD


/* Identifies an active RAS connection.  (See RasConnectEnum)
*/
#define RASCONN struct tagRASCONN

RASCONN
{
    DWORD    dwSize;  /* 30 */
    HRASCONN hrasconn;
    CHAR     szEntryName[ RAS_MaxEntryName + 1 ];
};

#define LPRASCONN RASCONN FAR*


/* Enumerates intermediate states to a connection.  (See RasDial)
*/
#define RASCS_PAUSED 0x1000
#define RASCS_DONE   0x2000

#define RASCONNSTATE enum tagRASCONNSTATE

RASCONNSTATE
{
    RASCS_OpenPort = 0,
    RASCS_PortOpened,
    RASCS_ConnectDevice,
    RASCS_DeviceConnected,
    RASCS_AllDevicesConnected,
    RASCS_Authenticate,
    RASCS_AuthNotify,
    RASCS_AuthRetry,
    RASCS_AuthCallback,
    RASCS_AuthChangePassword,
    RASCS_AuthProject,
    RASCS_AuthLinkSpeed,
    RASCS_AuthAck,
    RASCS_ReAuthenticate,
    RASCS_Authenticated,
    RASCS_PrepareForCallback,
    RASCS_WaitForModemReset,
    RASCS_WaitForCallback,

    RASCS_Interactive = RASCS_PAUSED,
    RASCS_RetryAuthentication,
    RASCS_CallbackSetByCaller,
    RASCS_PasswordExpired,

    RASCS_Connected = RASCS_DONE,
    RASCS_Disconnected
};

#define LPRASCONNSTATE RASCONNSTATE FAR*


/* Describes the status of a RAS connection.  (See RasConnectionStatus)
*/
#define RASCONNSTATUS struct tagRASCONNSTATUS

RASCONNSTATUS
{
    DWORD        dwSize;  /* 60 */
    RASCONNSTATE rasconnstate;
    DWORD        dwError;
    CHAR         szDeviceType[ RAS_MaxDeviceType + 1 ];
    CHAR         szDeviceName[ RAS_MaxDeviceName + 1 ];
};

#define LPRASCONNSTATUS RASCONNSTATUS FAR*


/* Describes connection establishment parameters.  (See RasDial)
*/
#define RASDIALPARAMS struct tagRASDIALPARAMS

RASDIALPARAMS
{
    DWORD dwSize;  /* 256 */
    CHAR  szEntryName[ RAS_MaxEntryName + 1 ];
    CHAR  szPhoneNumber[ RAS_MaxPhoneNumber + 1 ];
    CHAR  szCallbackNumber[ RAS_MaxCallbackNumber + 1 ];
    CHAR  szUserName[ UNLEN + 1 ];
    CHAR  szPassword[ PWLEN + 1 ];
    CHAR  szDomain[ DNLEN + 1 ];
};

#define LPRASDIALPARAMS RASDIALPARAMS FAR*


/* Describes an enumerated RAS phone book entry name.  (See RasEntryEnum)
*/
#define RASENTRYNAME struct tagRASENTRYNAME

RASENTRYNAME
{
    DWORD dwSize;  /* 26 */
    CHAR  szEntryName[ RAS_MaxEntryName + 1 ];
};

#define LPRASENTRYNAME RASENTRYNAME FAR*


/* External RAS API function prototypes.
*/
DWORD APIENTRY RasDial( LPSTR, LPSTR, LPRASDIALPARAMS, LPVOID, HWND,
                   LPHRASCONN );

DWORD APIENTRY RasEnumConnections( LPRASCONN, LPDWORD, LPDWORD );

DWORD APIENTRY RasEnumEntries( LPSTR, LPSTR, LPRASENTRYNAME, LPDWORD,
                   LPDWORD );

DWORD APIENTRY RasGetConnectStatus( HRASCONN, LPRASCONNSTATUS );

DWORD APIENTRY RasGetErrorString( UINT, LPSTR, DWORD );

DWORD APIENTRY RasHangUp( HRASCONN );


#ifndef RC_INVOKED
#pragma pack()
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\rasapi16\bseerr.h ===
/****************************** Module Header ******************************\
*
* Module Name: BSEERR.H
*       
*      Copy of the Lanman BSEERR.H used for their base error codes.
*      Not used by anyone else.
*
\***************************************************************************/

#ifndef BSEERR_INCLUDED
#define BSEERR_INCLUDED

#define NO_ERROR			0
#define ERROR_INVALID_FUNCTION		1
#define ERROR_FILE_NOT_FOUND		2
#define ERROR_PATH_NOT_FOUND		3
#define ERROR_TOO_MANY_OPEN_FILES	4
#define ERROR_ACCESS_DENIED		5
#define ERROR_INVALID_HANDLE		6
#define ERROR_ARENA_TRASHED		7
#define ERROR_NOT_ENOUGH_MEMORY 	8
#define ERROR_INVALID_BLOCK		9
#define ERROR_BAD_ENVIRONMENT		10
#define ERROR_BAD_FORMAT		11
#define ERROR_INVALID_ACCESS		12
#define ERROR_INVALID_DATA		13
/* 14 is reserved			 */
#define ERROR_INVALID_DRIVE		15
#define ERROR_CURRENT_DIRECTORY 	16
#define ERROR_NOT_SAME_DEVICE		17
#define ERROR_NO_MORE_FILES		18
#define ERROR_WRITE_PROTECT		19
#define ERROR_BAD_UNIT			20
#define ERROR_NOT_READY 		21
#define ERROR_BAD_COMMAND		22
#define ERROR_CRC			23
#define ERROR_BAD_LENGTH		24
#define ERROR_SEEK			25
#define ERROR_NOT_DOS_DISK		26
#define ERROR_SECTOR_NOT_FOUND		27
#define ERROR_OUT_OF_PAPER		28
#define ERROR_WRITE_FAULT		29
#define ERROR_READ_FAULT		30
#define ERROR_GEN_FAILURE		31
#define ERROR_SHARING_VIOLATION 	32
#define ERROR_LOCK_VIOLATION		33
#define ERROR_WRONG_DISK		34
#define ERROR_FCB_UNAVAILABLE		35
#define ERROR_SHARING_BUFFER_EXCEEDED	36
#define ERROR_NOT_SUPPORTED		50
#define ERROR_REM_NOT_LIST		51 /* Remote computer not listening   */
#define ERROR_DUP_NAME			52 /* Duplicate name on network       */
#define ERROR_BAD_NETPATH		53 /* Network path not found	      */
#define ERROR_NETWORK_BUSY		54 /* Network busy		      */
#define ERROR_DEV_NOT_EXIST		55 /* Network device no longer exists */
#define ERROR_TOO_MANY_CMDS		56 /* Net BIOS command limit exceeded */
#define ERROR_ADAP_HDW_ERR		57 /* Network adapter hardware error  */
#define ERROR_BAD_NET_RESP		58 /* Incorrect response from network */
#define ERROR_UNEXP_NET_ERR		59 /* Unexpected network error	      */
#define ERROR_BAD_REM_ADAP		60 /* Incompatible remote adapter     */
#define ERROR_PRINTQ_FULL		61 /* Print queue full		      */
#define ERROR_NO_SPOOL_SPACE		62 /* Not enough space for print file */
#define ERROR_PRINT_CANCELLED		63 /* Print file was cancelled	      */
#define ERROR_NETNAME_DELETED		64 /* Network name was deleted	      */
#define ERROR_NETWORK_ACCESS_DENIED	65 /* Access denied		      */
#define ERROR_BAD_DEV_TYPE		66 /* Network device type incorrect   */
#define ERROR_BAD_NET_NAME		67 /* Network name not found	      */
#define ERROR_TOO_MANY_NAMES		68 /* Network name limit exceeded     */
#define ERROR_TOO_MANY_SESS		69 /* Net BIOS session limit exceeded */
#define ERROR_SHARING_PAUSED		70 /* Sharing temporarily paused      */
#define ERROR_REQ_NOT_ACCEP		71 /* Network request not accepted    */
#define ERROR_REDIR_PAUSED		72 /* Print|disk redirection is paused*/
#define ERROR_FILE_EXISTS		80
#define ERROR_DUP_FCB			81
#define ERROR_CANNOT_MAKE		82
#define ERROR_FAIL_I24			83
#define ERROR_OUT_OF_STRUCTURES 	84
#define ERROR_ALREADY_ASSIGNED		85
#define ERROR_INVALID_PASSWORD		86
#define ERROR_INVALID_PARAMETER 	87
#define ERROR_NET_WRITE_FAULT		88
#define ERROR_NO_PROC_SLOTS		89 /* no process slots available      */
#define ERROR_NOT_FROZEN		90
#define ERR_TSTOVFL			91 /* timer service table overflow    */
#define ERR_TSTDUP			92 /* timer service table duplicate   */
#define ERROR_NO_ITEMS			93 /* no items to operate upon	      */
#define ERROR_INTERRUPT 		95 /* interrupted system call	      */
#define ERROR_DEVICE_IN_USE		99 /* Device in use by another thread */
#define ERROR_TOO_MANY_SEMAPHORES	100
#define ERROR_EXCL_SEM_ALREADY_OWNED	101
#define ERROR_SEM_IS_SET		102
#define ERROR_TOO_MANY_SEM_REQUESTS	103
#define ERROR_INVALID_AT_INTERRUPT_TIME 104
#define ERROR_SEM_OWNER_DIED		105 /* waitsem found owner died       */
#define ERROR_SEM_USER_LIMIT		106 /* too many procs have this sem   */
#define ERROR_DISK_CHANGE		107
#define ERROR_DRIVE_LOCKED		108 /* drive locked by another process*/
#define ERROR_BROKEN_PIPE		109 /* write on pipe with no reader   */
#define ERROR_OPEN_FAILED		110 /* open/created failed due to     */
                                            /* explicit fail command          */
#define ERROR_BUFFER_OVERFLOW		111 /* buffer passed to system call   */
                                            /* is too small to hold return    */
                                            /* data.                          */
#define ERROR_DISK_FULL 		112 /* not enough space on the disk   */
                                            /* (DOSNEWSIZE/w_NewSize)         */
#define ERROR_NO_MORE_SEARCH_HANDLES	113 /* can't allocate another search  */
                                            /* structure and handle.          */
                                            /* (DOSFINDFIRST/w_FindFirst)     */
#define ERROR_INVALID_TARGET_HANDLE	114 /* Target handle in DOSDUPHANDLE  */
                                            /* is invalid                     */
#define ERROR_PROTECTION_VIOLATION	115 /* Bad user virtual address       */
#define ERROR_VIOKBD_REQUEST		116
#define ERROR_INVALID_CATEGORY		117 /* Category for DEVIOCTL in not   */
                                            /* defined                        */
#define ERROR_INVALID_VERIFY_SWITCH	118 /* invalid value passed for       */
                                            /* verify flag                    */
#define ERROR_BAD_DRIVER_LEVEL		119 /* DosDevIOCTL looks for a level  */
                                            /* four driver. If the driver     */
                                            /* is not level four we return    */
                                            /* this code                      */
#define ERROR_CALL_NOT_IMPLEMENTED	120 /* returned from stub api calls.  */
                                            /* This call will disappear when  */
                                            /* all the api's are implemented. */
#define ERROR_SEM_TIMEOUT		121 /* Time out happened from the     */
                                            /* semaphore api functions.       */
#define ERROR_INSUFFICIENT_BUFFER	122 /* Some calls require the	      */
                                       /* application to pass in a buffer     */
                                       /* filled with data.  This error is    */
                                       /* returned if the data buffer is too  */
                                       /* small.  For example: DosSetFileInfo */
                                       /* requires 4 bytes of data.  If a     */
                                       /* two byte buffer is passed in then   */
                                       /* this error is returned.             */
                                       /* error_buffer_overflow is used when  */
                                       /* the output buffer in not big enough.*/
#define ERROR_INVALID_NAME		123 /* illegal character or malformed */
                                            /* file system name               */
#define ERROR_INVALID_LEVEL		124 /* unimplemented level for info   */
                                            /* retrieval or setting           */
#define ERROR_NO_VOLUME_LABEL		125 /* no volume label found with     */
                                            /* DosQFSInfo command             */
#define ERROR_MOD_NOT_FOUND		126 /* w_getprocaddr,w_getmodhandle   */
#define ERROR_PROC_NOT_FOUND		127 /* w_getprocaddr		      */
#define ERROR_WAIT_NO_CHILDREN		128 /* CWait finds to children	      */
#define ERROR_CHILD_NOT_COMPLETE	129 /* CWait children not dead yet    */
#define ERROR_DIRECT_ACCESS_HANDLE	130 /* handle operation is invalid    */
                                            /* for direct disk access         */
                                            /* handles                        */
#define ERROR_NEGATIVE_SEEK		131 /* application tried to seek      */
                                            /* with negitive offset           */
#define ERROR_SEEK_ON_DEVICE		132 /* application tried to seek      */
                                            /* on device or pipe              */
#define ERROR_IS_JOIN_TARGET		133
#define ERROR_IS_JOINED 		134
#define ERROR_IS_SUBSTED		135
#define ERROR_NOT_JOINED		136
#define ERROR_NOT_SUBSTED		137
#define ERROR_JOIN_TO_JOIN		138
#define ERROR_SUBST_TO_SUBST		139
#define ERROR_JOIN_TO_SUBST		140
#define ERROR_SUBST_TO_JOIN		141
#define ERROR_BUSY_DRIVE		142
#define ERROR_SAME_DRIVE		143
#define ERROR_DIR_NOT_ROOT		144
#define ERROR_DIR_NOT_EMPTY		145
#define ERROR_IS_SUBST_PATH		146
#define ERROR_IS_JOIN_PATH		147
#define ERROR_PATH_BUSY 		148
#define ERROR_IS_SUBST_TARGET		149
#define ERROR_SYSTEM_TRACE		150 /* system trace error	      */
#define ERROR_INVALID_EVENT_COUNT	151 /* DosMuxSemWait errors	      */
#define ERROR_TOO_MANY_MUXWAITERS	152
#define ERROR_INVALID_LIST_FORMAT	153
#define ERROR_LABEL_TOO_LONG		154
#define ERROR_TOO_MANY_TCBS		155
#define ERROR_SIGNAL_REFUSED		156
#define ERROR_DISCARDED 		157
#define ERROR_NOT_LOCKED		158
#define ERROR_BAD_THREADID_ADDR 	159
#define ERROR_BAD_ARGUMENTS		160
#define ERROR_BAD_PATHNAME		161
#define ERROR_SIGNAL_PENDING		162
#define ERROR_UNCERTAIN_MEDIA		163
#define ERROR_MAX_THRDS_REACHED 	164
#define ERROR_MONITORS_NOT_SUPPORTED	165
#define ERROR_UNC_DRIVER_NOT_INSTALLED	166

/*	The following error codes refer to demand loading segments     */
#define ERROR_LOCK_FAILED		167
#define ERROR_SWAPIO_FAILED		168
#define ERROR_SWAPIN_FAILED		169
#define ERROR_BUSY			170

#define ERROR_INVALID_SEGMENT_NUMBER	180
#define ERROR_INVALID_CALLGATE		181
#define ERROR_INVALID_ORDINAL		182
#define ERROR_ALREADY_EXISTS		183
#define ERROR_NO_CHILD_PROCESS		184
#define ERROR_CHILD_ALIVE_NOWAIT	185
#define ERROR_INVALID_FLAG_NUMBER	186
#define ERROR_SEM_NOT_FOUND		187

/* following error codes make loader error messages distinct  */
#define ERROR_INVALID_STARTING_CODESEG	188
#define ERROR_INVALID_STACKSEG		189
#define ERROR_INVALID_MODULETYPE	190
#define ERROR_INVALID_EXE_SIGNATURE	191
#define ERROR_EXE_MARKED_INVALID	192
#define ERROR_BAD_EXE_FORMAT		193
#define ERROR_ITERATED_DATA_EXCEEDS_64K 194
#define ERROR_INVALID_MINALLOCSIZE	195
#define ERROR_DYNLINK_FROM_INVALID_RING 196
#define ERROR_IOPL_NOT_ENABLED		197
#define ERROR_INVALID_SEGDPL		198
#define ERROR_AUTODATASEG_EXCEEDS_64k	199
#define ERROR_RING2SEG_MUST_BE_MOVABLE	200
#define ERROR_RELOC_CHAIN_XEEDS_SEGLIM	201
#define ERROR_INFLOOP_IN_RELOC_CHAIN	202
#define ERROR_ENVVAR_NOT_FOUND		203
#define ERROR_NOT_CURRENT_CTRY		204
#define ERROR_NO_SIGNAL_SENT		205
#define ERROR_FILENAME_EXCED_RANGE	206 /* if filename > 8.3 */
#define ERROR_RING2_STACK_IN_USE	207 /* for FAPI 	 */
#define ERROR_META_EXPANSION_TOO_LONG	208 /* if "*a" > 8.3	 */
#define ERROR_INVALID_SIGNAL_NUMBER	209
#define ERROR_THREAD_1_INACTIVE 	210
#define ERROR_INFO_NOT_AVAIL		211
#define ERROR_LOCKED			212
#define ERROR_BAD_DYNALINK		213
#define ERROR_TOO_MANY_MODULES		214
#define ERROR_NESTING_NOT_ALLOWED	215
#define ERROR_CANNOT_SHRINK		216 /* attempt to shrink ring 2 stack */
#define ERROR_ZOMBIE_PROCESS		217
#define ERROR_STACK_IN_HIGH_MEMORY	218
#define ERROR_INVALID_EXITROUTINE_RING	219
#define ERROR_GETBUF_FAILED		220
#define ERROR_FLUSHBUF_FAILED		221
#define ERROR_TRANSFER_TOO_LONG 	222
#define ERROR_NO_CHILDREN		228
#define ERROR_INVALID_SCREEN_GROUP	229
/*
 * Error codes 230 - 249 are reserved
 */
#define ERROR_BAD_PIPE			230 /* Non-existant pipe or bad operation */
#define ERROR_PIPE_BUSY 		231 /* Pipe is busy		      */
#define ERROR_NO_DATA			232 /* No data on non-blocking read   */
#define ERROR_PIPE_NOT_CONNECTED	233 /* Pipe was disconnected by server*/
#define ERROR_MORE_DATA 		234 /* More data is available	      */

#define ERROR_VC_DISCONNECTED		240
#define ERROR_CIRCULARITY_REQUESTED	250 /* When renaming a dir which      */
                                            /* would cause a circularity      */
#define ERROR_DIRECTORY_IN_CDS		251 /* When renaming a dir	      */
                                            /* which is "in use"              */
#define ERROR_INVALID_FSD_NAME		252 /* when trying to access	      */
                                            /* nonexistent FSD                */
#define ERROR_INVALID_PATH		253 /* bad pseudo device	      */
#define ERROR_INVALID_EA_NAME		254 /* Illegal chars in name	      */
#define ERROR_EA_LIST_INCONSISTENT	255 /* Size or some field bad	      */
#define ERROR_EA_LIST_TOO_LONG		256 /* FEAlist > 64K-1 bytes	      */
#define ERROR_NO_META_MATCH		257 /* string doesn't match expression*/
#define ERROR_FINDNOTIFY_TIMEOUT	258 /* FindNotify request timeout     */
#define ERROR_NO_MORE_ITEMS		259 /* QFSAttach ordinal query	      */
#define ERROR_SEARCH_STRUC_REUSED	260 /* 3xbox findfirst/next
                                               search structure reused        */
#define ERROR_CHAR_NOT_FOUND		261 /* can not find character	      */
#define ERROR_TOO_MUCH_STACK		262 /* Stack request exceeds sys limit*/
#define ERROR_INVALID_ATTR		263 /* invalid FS_ATTRIBUTE	      */
#define ERROR_INVALID_STARTING_RING	264
#define ERROR_INVALID_DLL_INIT_RING	265
#define ERROR_CANNOT_COPY		266 /* doscopy */
#define ERROR_DIRECTORY 		267 /* doscopy */
#define ERROR_OPLOCKED_FILE		268
#define ERROR_OPLOCK_THREAD_EXISTS	269

/* error codes for DosFindNotify */
#define ERROR_VOLUME_CHANGED		270
#define ERROR_FINDNOTIFY_HANDLE_IN_USE	271
#define ERROR_FINDNOTIFY_HANDLE_CLOSED	272
#define ERROR_NOTIFY_OBJECT_REMOVED	273

/* Error to indicate that ShutDown already done */
#define ERROR_ALREADY_SHUTDOWN		274

/* error code for DOSFINDFIRST2/NEXT */
#define ERROR_EAS_DIDNT_FIT		275

/* error codes for EA file format change */
#define ERROR_EA_FILE_CORRUPT		276
#define ERROR_EA_TABLE_FULL		277
#define ERROR_INVALID_EA_HANDLE 	278
#define ERROR_NO_CLUSTER		279
#define ERROR_CREATE_EA_FILE		280
#define ERROR_CANNOT_OPEN_EA_FILE	281

#define ERROR_INVALID_PROCID		303
#define ERROR_INVALID_PDELTA		304
#define ERROR_NOT_DESCENDANT		305
#define ERROR_NOT_SESSION_MANAGER	306
#define ERROR_INVALID_PCLASS		307
#define ERROR_INVALID_SCOPE		308
#define ERROR_INVALID_THREADID		309
#define ERROR_DOSSUB_SHRINK		310
#define ERROR_DOSSUB_NOMEM		311
#define ERROR_DOSSUB_OVERLAP		312
#define ERROR_DOSSUB_BADSIZE		313
#define ERROR_DOSSUB_BADFLAG		314
#define ERROR_DOSSUB_BADSELECTOR	315
#define ERROR_MR_MSG_TOO_LONG		316
#define ERROR_MR_MID_NOT_FOUND		317
#define ERROR_MR_UN_ACC_MSGF		318
#define ERROR_MR_INV_MSGF_FORMAT	319
#define ERROR_MR_INV_IVCOUNT		320
#define ERROR_MR_UN_PERFORM		321
#define ERROR_TS_WAKEUP 		322
#define ERROR_TS_SEMHANDLE		323
#define ERROR_TS_NOTIMER		324
#define ERROR_TS_HANDLE 		326
#define ERROR_TS_DATETIME		327
#define ERROR_SYS_INTERNAL		328
#define ERROR_QUE_CURRENT_NAME		329
#define ERROR_QUE_PROC_NOT_OWNED	330
#define ERROR_QUE_PROC_OWNED		331
#define ERROR_QUE_DUPLICATE		332
#define ERROR_QUE_ELEMENT_NOT_EXIST	333
#define ERROR_QUE_NO_MEMORY		334
#define ERROR_QUE_INVALID_NAME		335
#define ERROR_QUE_INVALID_PRIORITY	336
#define ERROR_QUE_INVALID_HANDLE	337
#define ERROR_QUE_LINK_NOT_FOUND	338
#define ERROR_QUE_MEMORY_ERROR		339
#define ERROR_QUE_PREV_AT_END		340
#define ERROR_QUE_PROC_NO_ACCESS	341
#define ERROR_QUE_EMPTY 		342
#define ERROR_QUE_NAME_NOT_EXIST	343
#define ERROR_QUE_NOT_INITIALIZED	344
#define ERROR_QUE_UNABLE_TO_ACCESS	345
#define ERROR_QUE_UNABLE_TO_ADD 	346
#define ERROR_QUE_UNABLE_TO_INIT	347
#define ERROR_VIO_INVALID_MASK		349
#define ERROR_VIO_PTR			350
#define ERROR_VIO_APTR			351
#define ERROR_VIO_RPTR			352
#define ERROR_VIO_CPTR			353
#define ERROR_VIO_LPTR			354
#define ERROR_VIO_MODE			355
#define ERROR_VIO_WIDTH 		356
#define ERROR_VIO_ATTR			357
#define ERROR_VIO_ROW			358
#define ERROR_VIO_COL			359
#define ERROR_VIO_TOPROW		360
#define ERROR_VIO_BOTROW		361
#define ERROR_VIO_RIGHTCOL		362
#define ERROR_VIO_LEFTCOL		363
#define ERROR_SCS_CALL			364
#define ERROR_SCS_VALUE 		365
#define ERROR_VIO_WAIT_FLAG		366
#define ERROR_VIO_UNLOCK		367
#define ERROR_SGS_NOT_SESSION_MGR	368
#define ERROR_SMG_INVALID_SGID		369
#define ERROR_SMG_INVALID_SESSION_ID	369
#define ERROR_SMG_NOSG			370
#define ERROR_SMG_NO_SESSIONS		370
#define ERROR_SMG_GRP_NOT_FOUND 	371
#define ERROR_SMG_SESSION_NOT_FOUND	371
#define ERROR_SMG_SET_TITLE		372
#define ERROR_KBD_PARAMETER		373
#define ERROR_KBD_NO_DEVICE		374
#define ERROR_KBD_INVALID_IOWAIT	375
#define ERROR_KBD_INVALID_LENGTH	376
#define ERROR_KBD_INVALID_ECHO_MASK	377
#define ERROR_KBD_INVALID_INPUT_MASK	378
#define ERROR_MON_INVALID_PARMS 	379
#define ERROR_MON_INVALID_DEVNAME	380
#define ERROR_MON_INVALID_HANDLE	381
#define ERROR_MON_BUFFER_TOO_SMALL	382
#define ERROR_MON_BUFFER_EMPTY		383
#define ERROR_MON_DATA_TOO_LARGE	384
#define ERROR_MOUSE_NO_DEVICE		385
#define ERROR_MOUSE_INV_HANDLE		386
#define ERROR_MOUSE_INV_PARMS		387
#define ERROR_MOUSE_CANT_RESET		388
#define ERROR_MOUSE_DISPLAY_PARMS	389
#define ERROR_MOUSE_INV_MODULE		390
#define ERROR_MOUSE_INV_ENTRY_PT	391
#define ERROR_MOUSE_INV_MASK		392
#define NO_ERROR_MOUSE_NO_DATA		393
#define NO_ERROR_MOUSE_PTR_DRAWN	394
#define ERROR_INVALID_FREQUENCY 	395
#define ERROR_NLS_NO_COUNTRY_FILE	396
#define ERROR_NLS_OPEN_FAILED		397
#define ERROR_NLS_NO_CTRY_CODE		398
#define ERROR_NO_COUNTRY_OR_CODEPAGE	398
#define ERROR_NLS_TABLE_TRUNCATED	399
#define ERROR_NLS_BAD_TYPE		400
#define ERROR_NLS_TYPE_NOT_FOUND	401
#define ERROR_VIO_SMG_ONLY		402
#define ERROR_VIO_INVALID_ASCIIZ	403
#define ERROR_VIO_DEREGISTER		404
#define ERROR_VIO_NO_POPUP		405
#define ERROR_VIO_EXISTING_POPUP	406
#define ERROR_KBD_SMG_ONLY		407
#define ERROR_KBD_INVALID_ASCIIZ	408
#define ERROR_KBD_INVALID_MASK		409
#define ERROR_KBD_REGISTER		410
#define ERROR_KBD_DEREGISTER		411
#define ERROR_MOUSE_SMG_ONLY		412
#define ERROR_MOUSE_INVALID_ASCIIZ	413
#define ERROR_MOUSE_INVALID_MASK	414
#define ERROR_MOUSE_REGISTER		415
#define ERROR_MOUSE_DEREGISTER		416
#define ERROR_SMG_BAD_ACTION		417
#define ERROR_SMG_INVALID_CALL		418
#define ERROR_SCS_SG_NOTFOUND		419
#define ERROR_SCS_NOT_SHELL		420
#define ERROR_VIO_INVALID_PARMS 	421
#define ERROR_VIO_FUNCTION_OWNED	422
#define ERROR_VIO_RETURN		423
#define ERROR_SCS_INVALID_FUNCTION	424
#define ERROR_SCS_NOT_SESSION_MGR	425
#define ERROR_VIO_REGISTER		426
#define ERROR_VIO_NO_MODE_THREAD	427
#define ERROR_VIO_NO_SAVE_RESTORE_THD	428
#define ERROR_VIO_IN_BG 		429
#define ERROR_VIO_ILLEGAL_DURING_POPUP	430
#define ERROR_SMG_NOT_BASESHELL 	431
#define ERROR_SMG_BAD_STATUSREQ 	432
#define ERROR_QUE_INVALID_WAIT		433
#define ERROR_VIO_LOCK			434
#define ERROR_MOUSE_INVALID_IOWAIT	435
#define ERROR_VIO_INVALID_HANDLE	436
#define ERROR_VIO_ILLEGAL_DURING_LOCK	437
#define ERROR_VIO_INVALID_LENGTH	438
#define ERROR_KBD_INVALID_HANDLE	439
#define ERROR_KBD_NO_MORE_HANDLE	440
#define ERROR_KBD_CANNOT_CREATE_KCB	441
#define ERROR_KBD_CODEPAGE_LOAD_INCOMPL 442
#define ERROR_KBD_INVALID_CODEPAGE_ID	443
#define ERROR_KBD_NO_CODEPAGE_SUPPORT	444
#define ERROR_KBD_FOCUS_REQUIRED	445
#define ERROR_KBD_FOCUS_ALREADY_ACTIVE	446
#define ERROR_KBD_KEYBOARD_BUSY 	447
#define ERROR_KBD_INVALID_CODEPAGE	448
#define ERROR_KBD_UNABLE_TO_FOCUS	449
#define ERROR_SMG_SESSION_NON_SELECT	450
#define ERROR_SMG_SESSION_NOT_FOREGRND	451
#define ERROR_SMG_SESSION_NOT_PARENT	452
#define ERROR_SMG_INVALID_START_MODE	453
#define ERROR_SMG_INVALID_RELATED_OPT	454
#define ERROR_SMG_INVALID_BOND_OPTION	455
#define ERROR_SMG_INVALID_SELECT_OPT	456
#define ERROR_SMG_START_IN_BACKGROUND	457
#define ERROR_SMG_INVALID_STOP_OPTION	458
#define ERROR_SMG_BAD_RESERVE		459
#define ERROR_SMG_PROCESS_NOT_PARENT	460
#define ERROR_SMG_INVALID_DATA_LENGTH	461
#define ERROR_SMG_NOT_BOUND		462
#define ERROR_SMG_RETRY_SUB_ALLOC	463
#define ERROR_KBD_DETACHED		464
#define ERROR_VIO_DETACHED		465
#define ERROR_MOU_DETACHED		466
#define ERROR_VIO_FONT			467
#define ERROR_VIO_USER_FONT		468
#define ERROR_VIO_BAD_CP		469
#define ERROR_VIO_NO_CP 		470
#define ERROR_VIO_NA_CP 		471
#define ERROR_INVALID_CODE_PAGE 	472
#define ERROR_CPLIST_TOO_SMALL		473
#define ERROR_CP_NOT_MOVED		474
#define ERROR_MODE_SWITCH_INIT		475
#define ERROR_CODE_PAGE_NOT_FOUND	476
#define ERROR_UNEXPECTED_SLOT_RETURNED	477
#define ERROR_SMG_INVALID_TRACE_OPTION	478
#define ERROR_VIO_INTERNAL_RESOURCE	479
#define ERROR_VIO_SHELL_INIT		480
#define ERROR_SMG_NO_HARD_ERRORS	481
#define ERROR_CP_SWITCH_INCOMPLETE	482
#define ERROR_VIO_TRANSPARENT_POPUP	483
#define ERROR_CRITSEC_OVERFLOW		484
#define ERROR_CRITSEC_UNDERFLOW 	485
#define ERROR_VIO_BAD_RESERVE		486
#define ERROR_INVALID_ADDRESS		487
#define ERROR_ZERO_SELECTORS_REQUESTED	488
#define ERROR_NOT_ENOUGH_SELECTORS_AVA	489
#define ERROR_INVALID_SELECTOR		490
#define ERROR_SMG_INVALID_PROGRAM_TYPE	491
#define ERROR_SMG_INVALID_PGM_CONTROL	492
#define ERROR_SMG_INVALID_INHERIT_OPT	493
#define ERROR_VIO_EXTENDED_SG		494
#define ERROR_VIO_NOT_PRES_MGR_SG	495
#define ERROR_VIO_SHIELD_OWNED		496
#define ERROR_VIO_NO_MORE_HANDLES	497
#define ERROR_VIO_SEE_ERROR_LOG 	498
#define ERROR_VIO_ASSOCIATED_DC 	499
#define ERROR_KBD_NO_CONSOLE		500
#define ERROR_MOUSE_NO_CONSOLE		501
#define ERROR_MOUSE_INVALID_HANDLE	502
#define ERROR_SMG_INVALID_DEBUG_PARMS	503
#define ERROR_KBD_EXTENDED_SG		504
#define ERROR_MOU_EXTENDED_SG		505
#define ERROR_SMG_INVALID_ICON_FILE	506


#define ERROR_USER_DEFINED_BASE 	0xFF00

#define ERROR_I24_WRITE_PROTECT 	0
#define ERROR_I24_BAD_UNIT		1
#define ERROR_I24_NOT_READY		2
#define ERROR_I24_BAD_COMMAND		3
#define ERROR_I24_CRC			4
#define ERROR_I24_BAD_LENGTH		5
#define ERROR_I24_SEEK			6
#define ERROR_I24_NOT_DOS_DISK		7
#define ERROR_I24_SECTOR_NOT_FOUND	8
#define ERROR_I24_OUT_OF_PAPER		9
#define ERROR_I24_WRITE_FAULT		10
#define ERROR_I24_READ_FAULT		11
#define ERROR_I24_GEN_FAILURE		12
#define ERROR_I24_DISK_CHANGE		13
#define ERROR_I24_WRONG_DISK		15
#define ERROR_I24_UNCERTAIN_MEDIA	16
#define ERROR_I24_CHAR_CALL_INTERRUPTED 17
#define ERROR_I24_NO_MONITOR_SUPPORT	18
#define ERROR_I24_INVALID_PARAMETER	19
#define ERROR_I24_DEVICE_IN_USE 	20

#define ALLOWED_FAIL			0x0001
#define ALLOWED_ABORT			0x0002
#define ALLOWED_RETRY			0x0004
#define ALLOWED_IGNORE			0x0008
#define ALLOWED_ACKNOWLEDGE		0x0010
#define ALLOWED_DISPATCH		0x8000

#define I24_OPERATION			0x01
#define I24_AREA			0x06
#define I24_CLASS			0x80

/* Values for error CLASS */
#define ERRCLASS_OUTRES 		1   /* Out of Resource		      */
#define ERRCLASS_TEMPSIT		2   /* Temporary Situation	      */
#define ERRCLASS_AUTH			3   /* Permission problem	      */
#define ERRCLASS_INTRN			4   /* Internal System Error	      */
#define ERRCLASS_HRDFAIL		5   /* Hardware Failure 	      */
#define ERRCLASS_SYSFAIL		6   /* System Failure		      */
#define ERRCLASS_APPERR 		7   /* Application Error	      */
#define ERRCLASS_NOTFND 		8   /* Not Found		      */
#define ERRCLASS_BADFMT 		9   /* Bad Format		      */
#define ERRCLASS_LOCKED 		10  /* Locked			      */
#define ERRCLASS_MEDIA			11  /* Media Failure		      */
#define ERRCLASS_ALREADY		12  /* Collision with Existing Item   */
#define ERRCLASS_UNK			13  /* Unknown/other		      */
#define ERRCLASS_CANT			14
#define ERRCLASS_TIME			15

/* Values for error ACTION */
#define ERRACT_RETRY			1   /* Retry			      */
#define ERRACT_DLYRET			2   /* Delay Retry, retry after pause */
#define ERRACT_USER			3   /* Ask user to regive information */
#define ERRACT_ABORT			4   /* abort with clean up	      */
#define ERRACT_PANIC			5   /* abort immediately	      */
#define ERRACT_IGNORE			6   /* ignore			      */
#define ERRACT_INTRET			7   /* Retry after User Intervention  */

/* Values for error LOCUS */
#define ERRLOC_UNK			1   /* No appropriate value	      */
#define ERRLOC_DISK			2   /* Random Access Mass Storage     */
#define ERRLOC_NET			3   /* Network			      */
#define ERRLOC_SERDEV			4   /* Serial Device		      */
#define ERRLOC_MEM			5   /* Memory			      */

/* Abnormal termination codes */
#define TC_NORMAL		0
#define TC_HARDERR		1
#define TC_GP_TRAP		2
#define TC_SIGNAL		3

#define ERROR_SWAPPER_NOT_ACTIVE	32768
#define ERROR_INVALID_SWAPID		32769
#define ERROR_IOERR_SWAP_FILE		32770
#define ERROR_SWAP_TABLE_FULL		32771
#define ERROR_SWAP_FILE_FULL		32772
#define ERROR_CANT_INIT_SWAPPER 	32773
#define ERROR_SWAPPER_ALREADY_INIT	32774
#define ERROR_PMM_INSUFFICIENT_MEMORY	32775
#define ERROR_PMM_INVALID_FLAGS 	32776
#define ERROR_PMM_INVALID_ADDRESS	32777
#define ERROR_PMM_LOCK_FAILED		32778
#define ERROR_PMM_UNLOCK_FAILED 	32779
#define ERROR_PMM_MOVE_INCOMPLETE	32780
#define ERROR_UCOM_DRIVE_RENAMED	32781
#define ERROR_UCOM_FILENAME_TRUNCATED	32782
#define ERROR_UCOM_BUFFER_LENGTH	32783
#define ERROR_MON_CHAIN_HANDLE		32784
#define ERROR_MON_NOT_REGISTERED	32785
#define ERROR_SMG_ALREADY_TOP		32786
#define ERROR_PMM_ARENA_MODIFIED	32787
#define ERROR_SMG_PRINTER_OPEN		32788
#define ERROR_PMM_SET_FLAGS_FAILED	32789
#define ERROR_INVALID_DOS_DD		32790
#define ERROR_CPSIO_CODE_PAGE_INVALID	65026
#define ERROR_CPSIO_NO_SPOOLER		65027
#define ERROR_CPSIO_FONT_ID_INVALID	65028
#define ERROR_CPSIO_INTERNAL_ERROR	65033
#define ERROR_CPSIO_INVALID_PTR_NAME	65034
#define ERROR_CPSIO_NOT_ACTIVE		65037
#define ERROR_CPSIO_PID_FULL		65039
#define ERROR_CPSIO_PID_NOT_FOUND	65040
#define ERROR_CPSIO_READ_CTL_SEQ	65043
#define ERROR_CPSIO_READ_FNT_DEF	65045
#define ERROR_CPSIO_WRITE_ERROR 	65047
#define ERROR_CPSIO_WRITE_FULL_ERROR	65048
#define ERROR_CPSIO_WRITE_HANDLE_BAD	65049
#define ERROR_CPSIO_SWIT_LOAD		65074
#define ERROR_CPSIO_INV_COMMAND 	65077
#define ERROR_CPSIO_NO_FONT_SWIT	65078

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\rasapi16\rasapi16.c ===
/* Copyright (c) 1994, Microsoft Corporation, all rights reserved
**
** rasapi16.c
** Remote Access external APIs
** Windows NT WOW 16->32 thunks, 16-bit side
**
** 04/02/94 Steve Cobb
**
** This is Win16 code and all included headers are Win16 headers.  By it's
** nature, this code is sensitive to changes in either the Win16 or Win32
** versions of RAS.H and the system definitions used therein.  Numerous name
** conflicts make it unfeasible to include the Win32 headers here.  Win32
** definitions needed for mapping are defined locally with a "Win32: <header>"
** comment indicating the location of the duplicated Win32 definition.
*/

#include <bseerr.h>
#include <windows.h>
#include <ras.h>
#include <raserror.h>

//#define BREAKONENTRY

LPVOID AlignedAlloc( HGLOBAL FAR* ph, DWORD cb );
VOID   AlignedFree( HGLOBAL h );
DWORD  MapErrorCode( DWORD dwError );


/*---------------------------------------------------------------------------
** Win32 definitions
**---------------------------------------------------------------------------
*/

/* The Win32 RAS structures are packed on 4-byte boundaries.
*/
#pragma pack(4)


/* Win32: ras.h - RASCONNA
** Pads to different size.
*/
#define RASCONNA struct tagRASCONNA
RASCONNA
{
    DWORD    dwSize;
    HRASCONN hrasconn;
    CHAR     szEntryName[ RAS_MaxEntryName + 1 ];
};

#define LPRASCONNA RASCONNA FAR*

/* Win32: ras.h - RASCONNSTATUSA
** The size of the RASCONNSTATE enum is different.
** Pads to different size.
*/
#define RASCONNSTATUSA struct tagRASCONNSTATUSA
RASCONNSTATUSA
{
    DWORD dwSize;
    DWORD rasconnstate;
    DWORD dwError;
    CHAR  szDeviceType[ RAS_MaxDeviceType + 1 ];
    CHAR  szDeviceName[ RAS_MaxDeviceName + 1 ];
};

#define LPRASCONNSTATUSA RASCONNSTATUSA FAR*

/* Win32: lmcons.h - UNLEN, PWLEN, and DNLEN
*/
#define NTUNLEN 256
#define NTPWLEN 256
#define NTDNLEN 15

/* Win32: ras.h - RASDIALPARAMSA
** The credential constants are different.
*/
#define RASDIALPARAMSA struct tagRASDIALPARAMSA
RASDIALPARAMSA
{
    DWORD dwSize;
    CHAR  szEntryName[ RAS_MaxEntryName + 1 ];
    CHAR  szPhoneNumber[ RAS_MaxPhoneNumber + 1 ];
    CHAR  szCallbackNumber[ RAS_MaxCallbackNumber + 1 ];
    CHAR  szUserName[ NTUNLEN + 1 ];
    CHAR  szPassword[ NTPWLEN + 1 ];
    CHAR  szDomain[ NTDNLEN + 1 ];
};

#define LPRASDIALPARAMSA RASDIALPARAMSA FAR*


/* Win32: ras.h - RASENTRYNAMEA
** Pads to different size.
*/
#define RASENTRYNAMEA struct tagRASENTRYNAMEA
RASENTRYNAMEA
{
    DWORD dwSize;
    CHAR  szEntryName[ RAS_MaxEntryName + 1 ];
};

#define LPRASENTRYNAMEA RASENTRYNAMEA FAR*


#pragma pack()


/* Win32: <rasui>\extapi\src\wow.c - RASAPI32.DLL WOW entry point prototypes
*/
typedef DWORD (FAR PASCAL* RASDIALWOW)( LPSTR, LPRASDIALPARAMS, DWORD, LPRASCONN );
typedef DWORD (FAR PASCAL* RASENUMCONNECTIONSWOW)( LPRASCONN, LPDWORD, LPDWORD );
typedef DWORD (FAR PASCAL* RASENUMENTRIESWOW)( LPSTR, LPSTR, LPRASENTRYNAME, LPDWORD, LPDWORD );
typedef DWORD (FAR PASCAL* RASGETCONNECTSTATUSWOW)( HRASCONN, LPRASCONNSTATUS );
typedef DWORD (FAR PASCAL* RASGETERRORSTRINGWOW)( DWORD, LPSTR, DWORD );
typedef DWORD (FAR PASCAL* RASHANGUPWOW)( HRASCONN );


/*---------------------------------------------------------------------------
** Globals
**---------------------------------------------------------------------------
*/

/* The handle of the RASAPI32.DLL module returned by LoadLibraryEx32W.
*/
DWORD HRasApi32Dll = NULL;

/* The unique RasDial notification message as registered in the system at
** startup (WM_RASDIALEVENT is just a default).
*/
UINT UnRasDialEventMsg = WM_RASDIALEVENT;


/*---------------------------------------------------------------------------
** Standard DLL entry points
**---------------------------------------------------------------------------
*/

int FAR PASCAL
LibMain(
    HINSTANCE hInst,
    WORD      wDataSeg,
    WORD      cbHeapSize,
    LPSTR     lpszCmdLine )

    /* Standard DLL startup routine.
    */
{
#ifdef BREAKONENTRY
    { _asm int 3 }
#endif

    /* Don't even load on anything but NT WOW.
    */
    if (!(GetWinFlags() & WF_WINNT))
        return FALSE;

    /* Load the Win32 RAS API DLL.
    */
    HRasApi32Dll = LoadLibraryEx32W( "RASAPI32.DLL", NULL, 0 );

    if (!HRasApi32Dll)
        return FALSE;

    /* Register a unique message for RasDial notifications.
    */
    {
        UINT unMsg = RegisterWindowMessage( RASDIALEVENT );

        if (unMsg > 0)
            UnRasDialEventMsg = unMsg;
    }

    return TRUE;
}


int FAR PASCAL
WEP(
    int nExitType )

    /* Standard DLL exit routine.
    */
{
#ifdef BREAKONENTRY
    { _asm int 3 }
#endif

    if (HRasApi32Dll)
        FreeLibrary32W( HRasApi32Dll );

    return TRUE;
}


/*---------------------------------------------------------------------------
** 16->32 thunks
**---------------------------------------------------------------------------
*/

DWORD APIENTRY
RasDial(
    LPSTR           reserved,
    LPSTR           lpszPhonebookPath,
    LPRASDIALPARAMS lprasdialparams,
    LPVOID          reserved2,
    HWND            hwndNotify,
    LPHRASCONN      lphrasconn )
{
    DWORD            dwErr;
    RASDIALWOW       proc;
    LPRASDIALPARAMSA prdpa;
    HGLOBAL          hrdpa;
    LPHRASCONN       phrc;
    HGLOBAL          hhrc;

#ifdef BREAKONENTRY
    { _asm int 3 }
#endif

    proc =
        (RASDIALWOW )GetProcAddress32W(
            HRasApi32Dll, "RasDialWow" );

    if (!proc)
        return ERROR_INVALID_FUNCTION;

    (void )reserved;
    (void )reserved2;

    /* Account for the increased user name and password field lengths on NT.
    */
    if (!(prdpa = (LPRASDIALPARAMSA )AlignedAlloc(
             &hrdpa, sizeof(RASDIALPARAMSA) )))
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    prdpa->dwSize = sizeof(RASDIALPARAMSA);
    lstrcpy( prdpa->szEntryName, lprasdialparams->szEntryName );
    lstrcpy( prdpa->szPhoneNumber, lprasdialparams->szPhoneNumber );
    lstrcpy( prdpa->szCallbackNumber, lprasdialparams->szCallbackNumber );
    lstrcpy( prdpa->szUserName, lprasdialparams->szUserName );
    lstrcpy( prdpa->szPassword, lprasdialparams->szPassword );
    lstrcpy( prdpa->szDomain, lprasdialparams->szDomain );

    if (!(phrc = (LPHRASCONN )AlignedAlloc(
             &hhrc, sizeof(HRASCONN) )))
    {
        AlignedFree( hrdpa );
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    *phrc = *lphrasconn;

    dwErr =
        CallProc32W(
            /* 16 */ (DWORD )lpszPhonebookPath,
            /*  8 */ (DWORD )prdpa,
            /*  4 */ (DWORD )hwndNotify | 0xFFFF0000,
            /*  2 */ (DWORD )UnRasDialEventMsg,
            /*  1 */ (DWORD )phrc,
            (LPVOID )proc,
            (DWORD )(16 + 8 + 1),
            (DWORD )5 );

    *lphrasconn = *phrc;

    AlignedFree( hrdpa );
    AlignedFree( hhrc );

    return MapErrorCode( dwErr );
}


DWORD APIENTRY
RasEnumConnections(
    LPRASCONN lprasconn,
    LPDWORD   lpcb,
    LPDWORD   lpcConnections )
{
    DWORD                 dwErr;
    RASENUMCONNECTIONSWOW proc;
    LPRASCONNA            prca;
    HGLOBAL               hrca;
    LPDWORD               pcb;
    HGLOBAL               hcb;
    LPDWORD               pcConnections;
    HGLOBAL               hcConnections;

#ifdef BREAKONENTRY
    { _asm int 3 }
#endif

    proc =
        (RASENUMCONNECTIONSWOW )GetProcAddress32W(
            HRasApi32Dll, "RasEnumConnectionsWow" );

    if (!proc)
        return ERROR_INVALID_FUNCTION;

    /* Check for bad sizes on this side before setting up a substitute buffer.
    */
    if (!lprasconn || lprasconn->dwSize != sizeof(RASCONN))
        return ERROR_INVALID_SIZE;

    if (!lpcb)
        return ERROR_INVALID_PARAMETER;

    if (!(pcb = (LPDWORD )AlignedAlloc( &hcb, sizeof(DWORD) )))
        return ERROR_NOT_ENOUGH_MEMORY;

    *pcb = (*lpcb / sizeof(RASCONN)) * sizeof(RASCONNA);

    if (!(pcConnections = (LPDWORD )AlignedAlloc(
            &hcConnections, sizeof(DWORD) )))
    {
        AlignedFree( hcb );
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    if (lpcConnections)
        *pcConnections = *lpcConnections;

    if (!(prca = (LPRASCONNA )AlignedAlloc( &hrca, *pcb )))
    {
        AlignedFree( hcb );
        AlignedFree( hcConnections );
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    prca->dwSize = sizeof(RASCONNA);

    dwErr =
        CallProc32W(
            /* 4 */ (DWORD )prca,
            /* 2 */ (DWORD )pcb,
            /* 1 */ (DWORD )pcConnections,
            (LPVOID )proc,
            (DWORD )(4 + 2 + 1),
            (DWORD )3 );

    /* Copy result from substitute buffer back to caller's buffer.
    */
    *lpcb = (*pcb / sizeof(RASCONNA)) * sizeof(RASCONN);

    if (lpcConnections)
        *lpcConnections = *pcConnections;

    if (MapErrorCode( dwErr ) != ERROR_BUFFER_TOO_SMALL)
    {
        DWORD      i;
        LPRASCONNA lprcaSub = prca;
        LPRASCONN  lprcCaller = lprasconn;

        for (i = 0; i < *pcConnections; ++i)
        {
            lprcCaller->dwSize = sizeof(RASCONN);
            lprcCaller->hrasconn = lprcaSub->hrasconn;
            lstrcpy( lprcCaller->szEntryName, lprcaSub->szEntryName );

            ++lprcaSub;
            ++lprcCaller;
        }
    }

    AlignedFree( hcb );
    AlignedFree( hcConnections );
    AlignedFree( hrca );

    return MapErrorCode( dwErr );
}


DWORD APIENTRY
RasEnumEntries(
    LPSTR          reserved,
    LPSTR          lpszPhonebookPath,
    LPRASENTRYNAME lprasentryname,
    LPDWORD        lpcb,
    LPDWORD        lpcEntries )
{
    DWORD             dwErr;
    RASENUMENTRIESWOW proc;
    LPRASENTRYNAMEA   prena;
    HGLOBAL           hrena;
    LPDWORD           pcb;
    HGLOBAL           hcb;
    LPDWORD           pcEntries;
    HGLOBAL           hcEntries;

#ifdef BREAKONENTRY
    { _asm int 3 }
#endif

    proc =
        (RASENUMENTRIESWOW )GetProcAddress32W(
            HRasApi32Dll, "RasEnumEntriesWow" );

    if (!proc)
        return ERROR_INVALID_FUNCTION;

    /* Check for bad sizes on this side before setting up a substitute buffer.
    */
    if (!lprasentryname || lprasentryname->dwSize != sizeof(RASENTRYNAME))
        return ERROR_INVALID_SIZE;

    if (!lpcb)
        return ERROR_INVALID_PARAMETER;

    if (!(pcb = (LPDWORD )AlignedAlloc( &hcb, sizeof(DWORD) )))
        return ERROR_NOT_ENOUGH_MEMORY;

    *pcb = (*lpcb / sizeof(RASENTRYNAME)) * sizeof(RASENTRYNAMEA);

    if (!(pcEntries = (LPDWORD )AlignedAlloc(
            &hcEntries, sizeof(DWORD) )))
    {
        AlignedFree( hcb );
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    if (lpcEntries)
        *pcEntries = *lpcEntries;

    if (!(prena = (LPRASENTRYNAMEA )AlignedAlloc( &hrena, *pcb )))
    {
        AlignedFree( hcb );
        AlignedFree( hcEntries );
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    prena->dwSize = sizeof(RASENTRYNAMEA);

    dwErr =
        CallProc32W(
            /* 16 */ (DWORD )reserved,
            /*  8 */ (DWORD )lpszPhonebookPath,
            /*  4 */ (DWORD )prena,
            /*  2 */ (DWORD )pcb,
            /*  1 */ (DWORD )pcEntries,
            (LPVOID )proc,
            (DWORD )(16 + 8 + 4 + 2 + 1),
            (DWORD ) 5 );

    /* Copy result from substitute buffer back to caller's buffer.
    */
    *lpcb = (*pcb / sizeof(RASENTRYNAMEA)) * sizeof(RASENTRYNAME);

    if (lpcEntries)
        *lpcEntries = *pcEntries;

    if (MapErrorCode( dwErr ) != ERROR_BUFFER_TOO_SMALL)
    {
        DWORD           i;
        LPRASENTRYNAMEA lprenaSub = prena;
        LPRASENTRYNAME  lprenCaller = lprasentryname;

        for (i = 0; i < *pcEntries; ++i)
        {
            lprenCaller->dwSize = sizeof(RASENTRYNAME);
            lstrcpy( lprenCaller->szEntryName, lprenaSub->szEntryName );

            ++lprenaSub;
            ++lprenCaller;
        }
    }

    AlignedFree( hcb );
    AlignedFree( hcEntries );
    AlignedFree( hrena );

    return MapErrorCode( dwErr );
}


DWORD APIENTRY
RasGetConnectStatus(
    HRASCONN        hrasconn,
    LPRASCONNSTATUS lprasconnstatus )
{
    DWORD                  dwErr;
    RASGETCONNECTSTATUSWOW proc;
    LPRASCONNSTATUSA       prcsa;
    HGLOBAL                hrcsa;

#ifdef BREAKONENTRY
    { _asm int 3 }
#endif

    proc =
        (RASGETCONNECTSTATUSWOW )GetProcAddress32W(
            HRasApi32Dll, "RasGetConnectStatusWow" );

    if (!proc)
        return ERROR_INVALID_FUNCTION;

    /* Check for bad size on this side before setting up a substitute buffer.
    */
    if (!lprasconnstatus || lprasconnstatus->dwSize != sizeof(RASCONNSTATUS))
        return ERROR_INVALID_SIZE;

    if (!(prcsa = (LPRASCONNSTATUSA )AlignedAlloc(
            &hrcsa, sizeof(RASCONNSTATUSA) )))
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    prcsa->dwSize = sizeof(RASCONNSTATUSA);

    dwErr =
        CallProc32W(
            /* 2 */ (DWORD )hrasconn,
            /* 1 */ (DWORD )prcsa,
            (LPVOID )proc,
            (DWORD )1,
            (DWORD )2 );

    /* Copy result from substitute buffer back to caller's buffer.
    */
    lprasconnstatus->rasconnstate = (RASCONNSTATE )prcsa->rasconnstate;
    lprasconnstatus->dwError = prcsa->dwError;
    lstrcpy( lprasconnstatus->szDeviceType, prcsa->szDeviceType );
    lstrcpy( lprasconnstatus->szDeviceName, prcsa->szDeviceName );

    AlignedFree( hrcsa );

    return MapErrorCode( dwErr );
}


DWORD APIENTRY
RasGetErrorString(
    UINT  uErrorCode,
    LPSTR lpszBuf,
    DWORD cbBuf )
{
    DWORD                dwErr;
    RASGETERRORSTRINGWOW proc;

#ifdef BREAKONENTRY
    { _asm int 3 }
#endif

    proc =
        (RASGETERRORSTRINGWOW )GetProcAddress32W(
            HRasApi32Dll, "RasGetErrorStringWow" );

    if (!proc)
        return ERROR_INVALID_FUNCTION;

    dwErr =
        CallProc32W(
            /* 4 */ (DWORD )uErrorCode,
            /* 2 */ (DWORD )lpszBuf,
            /* 1 */ (DWORD )cbBuf,
            (LPVOID )proc,
            (DWORD )2,
            (DWORD )3 );

    return MapErrorCode( dwErr );
}


DWORD APIENTRY
RasHangUp(
    HRASCONN hrasconn )
{
    DWORD        dwErr;
    RASHANGUPWOW proc;

#ifdef BREAKONENTRY
    { _asm int 3 }
#endif

    proc =
        (RASHANGUPWOW )GetProcAddress32W(
            HRasApi32Dll, "RasHangUpWow" );

    if (!proc)
        return ERROR_INVALID_FUNCTION;

    dwErr =
        CallProc32W(
            /* 1 */ (DWORD )hrasconn,
            (LPVOID )proc,
            (DWORD )0,
            (DWORD )1 );

    return MapErrorCode( dwErr );
}


/*---------------------------------------------------------------------------
** Utilities
**---------------------------------------------------------------------------
*/

LPVOID
AlignedAlloc(
    HGLOBAL FAR* ph,
    DWORD        cb )

    /* Returns address of block of 'cb' bytes aligned suitably for all
    ** platforms, or NULL if out of memory.  If successful, callers '*ph' is
    ** set to the handle of the block, used with AllignedFree.
    */
{
    LPVOID pv = NULL;
    *ph = NULL;

    if (!(*ph = GlobalAlloc( GPTR, cb )))
        return NULL;

    if (!(pv = (LPVOID )GlobalLock( *ph )))
    {
        GlobalFree( *ph );
        *ph = NULL;
    }

    return pv;
}


VOID
AlignedFree(
    HGLOBAL h )

    /* Frees a block allocated with AlignedAlloc identified by the 'h'
    ** returned from same.
    */
{
    if (h)
    {
        GlobalUnlock( h );
        GlobalFree( h );
    }
}


DWORD
MapErrorCode(
    DWORD dwError )

    /* Map Win32 error codes to Win16.  (Win32: raserror.h)
    */
{
    /* These codes map, but the codes are different in Win16 and Win32.
    ** ERROR_NO_ISDN_CHANNELS_AVAILABLE truncated to 31 characters.  See
    ** raserror.h.
    */
    switch (dwError)
    {
        case 709: return ERROR_CHANGING_PASSWORD;
        case 710: return ERROR_OVERRUN;
        case 713: return ERROR_NO_ACTIVE_ISDN_LINES;
        case 714: return ERROR_NO_ISDN_CHANNELS_AVAILABL;
    }

    /* Pass everything else thru including codes that don't match up to
    ** anything on Win16 (e.g. RAS errors outside the 600 to 706 range).
    ** Reasoning is that an unmapped code is more valuable that some generic
    ** error like ERROR_UNKNOWN.
    */
    return dwError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\rasapi16\raserror.h ===
/* Copyright (c) 1993, Microsoft Corporation, all rights reserved
**
** raserror.h
** Remote Access external Win16 API
** RAS specific error codes
**
** Note: The constant names have been truncated at 31 characters to keep C6.0a
**       happy.  If there's a switch to get it to accept longer constants it
**       should be used.  I didn't find it.
*/

#ifndef _RASERROR_H_
#define _RASERROR_H_

#ifndef ERROR_INVALID_HANDLE
#define ERROR_INVALID_HANDLE 6
#endif

#ifndef ERROR_NOT_ENOUGH_MEMORY
#define ERROR_NOT_ENOUGH_MEMORY 8
#endif

#define RASBASE 600

#define SUCCESS 0

#define PENDING                         (RASBASE+0)
#define ERROR_INVALID_PORT_HANDLE       (RASBASE+1)
#define ERROR_PORT_ALREADY_OPEN         (RASBASE+2)
#define ERROR_BUFFER_TOO_SMALL          (RASBASE+3)
#define ERROR_WRONG_INFO_SPECIFIED      (RASBASE+4)
#define ERROR_CANNOT_SET_PORT_INFO      (RASBASE+5)
#define ERROR_PORT_NOT_CONNECTED        (RASBASE+6)
#define ERROR_EVENT_INVALID             (RASBASE+7)
#define ERROR_DEVICE_DOES_NOT_EXIST     (RASBASE+8)
#define ERROR_DEVICETYPE_DOES_NOT_EXIST (RASBASE+9)
#define ERROR_INVALID_BUFFER            (RASBASE+10)
#define ERROR_ROUTE_NOT_AVAILABLE       (RASBASE+11)
#define ERROR_ROUTE_NOT_ALLOCATED       (RASBASE+12)
#define ERROR_INVALID_COMPRESSION_SPECI (RASBASE+13)
#define ERROR_OUT_OF_BUFFERS            (RASBASE+14)
#define ERROR_PORT_NOT_FOUND            (RASBASE+15)
#define ERROR_ASYNC_REQUEST_PENDING     (RASBASE+16)
#define ERROR_ALREADY_DISCONNECTING     (RASBASE+17)
#define ERROR_PORT_NOT_OPEN             (RASBASE+18)
#define ERROR_PORT_DISCONNECTED         (RASBASE+19)
#define ERROR_NO_ENDPOINTS              (RASBASE+20)
#define ERROR_CANNOT_OPEN_PHONEBOOK     (RASBASE+21)
#define ERROR_CANNOT_LOAD_PHONEBOOK     (RASBASE+22)
#define ERROR_CANNOT_FIND_PHONEBOOK_ENT (RASBASE+23)
#define ERROR_CANNOT_WRITE_PHONEBOOK    (RASBASE+24)
#define ERROR_CORRUPT_PHONEBOOK         (RASBASE+25)
#define ERROR_CANNOT_LOAD_STRING        (RASBASE+26)
#define ERROR_KEY_NOT_FOUND             (RASBASE+27)
#define ERROR_DISCONNECTION             (RASBASE+28)
#define ERROR_REMOTE_DISCONNECTION      (RASBASE+29)
#define ERROR_HARDWARE_FAILURE          (RASBASE+30)
#define ERROR_USER_DISCONNECTION        (RASBASE+31)
#define ERROR_INVALID_SIZE              (RASBASE+32)
#define ERROR_PORT_NOT_AVAILABLE        (RASBASE+33)
#define ERROR_CANNOT_PROJECT_CLIENT     (RASBASE+34)
#define ERROR_UNKNOWN                   (RASBASE+35)
#define ERROR_WRONG_DEVICE_ATTACHED     (RASBASE+36)
#define ERROR_BAD_STRING                (RASBASE+37)
#define ERROR_REQUEST_TIMEOUT           (RASBASE+38)
#define ERROR_CANNOT_GET_LANA           (RASBASE+39)
#define ERROR_NETBIOS_ERROR             (RASBASE+40)
#define ERROR_SERVER_OUT_OF_RESOURCES   (RASBASE+41)
#define ERROR_NAME_EXISTS_ON_NET        (RASBASE+42)
#define ERROR_SERVER_GENERAL_NET_FAILUR (RASBASE+43)
#define WARNING_MSG_ALIAS_NOT_ADDED     (RASBASE+44)
#define ERROR_AUTH_INTERNAL             (RASBASE+45)
#define ERROR_RESTRICTED_LOGON_HOURS    (RASBASE+46)
#define ERROR_ACCT_DISABLED             (RASBASE+47)
#define ERROR_PASSWD_EXPIRED            (RASBASE+48)
#define ERROR_NO_DIALIN_PERMISSION      (RASBASE+49)
#define ERROR_SERVER_NOT_RESPONDING     (RASBASE+50)
#define ERROR_FROM_DEVICE               (RASBASE+51)
#define ERROR_UNRECOGNIZED_RESPONSE     (RASBASE+52)
#define ERROR_MACRO_NOT_FOUND           (RASBASE+53)
#define ERROR_MACRO_NOT_DEFINED         (RASBASE+54)
#define ERROR_MESSAGE_MACRO_NOT_FOUND   (RASBASE+55)
#define ERROR_DEFAULTOFF_MACRO_NOT_FOUN (RASBASE+56)
#define ERROR_FILE_COULD_NOT_BE_OPENED  (RASBASE+57)
#define ERROR_DEVICENAME_TOO_LONG       (RASBASE+58)
#define ERROR_DEVICENAME_NOT_FOUND      (RASBASE+59)
#define ERROR_NO_RESPONSES              (RASBASE+60)
#define ERROR_NO_COMMAND_FOUND          (RASBASE+61)
#define ERROR_WRONG_KEY_SPECIFIED       (RASBASE+62)
#define ERROR_UNKNOWN_DEVICE_TYPE       (RASBASE+63)
#define ERROR_ALLOCATING_MEMORY         (RASBASE+64)
#define ERROR_PORT_NOT_CONFIGURED       (RASBASE+65)
#define ERROR_DEVICE_NOT_READY          (RASBASE+66)
#define ERROR_READING_INI_FILE          (RASBASE+67)
#define ERROR_NO_CONNECTION             (RASBASE+68)
#define ERROR_BAD_USAGE_IN_INI_FILE     (RASBASE+69)
#define ERROR_READING_SECTIONNAME       (RASBASE+70)
#define ERROR_READING_DEVICETYPE        (RASBASE+71)
#define ERROR_READING_DEVICENAME        (RASBASE+72)
#define ERROR_READING_USAGE             (RASBASE+73)
#define ERROR_READING_MAXCONNECTBPS     (RASBASE+74)
#define ERROR_READING_MAXCARRIERBPS     (RASBASE+75)
#define ERROR_LINE_BUSY                 (RASBASE+76)
#define ERROR_VOICE_ANSWER              (RASBASE+77)
#define ERROR_NO_ANSWER                 (RASBASE+78)
#define ERROR_NO_CARRIER                (RASBASE+79)
#define ERROR_NO_DIALTONE               (RASBASE+80)
#define ERROR_IN_COMMAND                (RASBASE+81)
#define ERROR_WRITING_SECTIONNAME       (RASBASE+82)
#define ERROR_WRITING_DEVICETYPE        (RASBASE+83)
#define ERROR_WRITING_DEVICENAME        (RASBASE+84)
#define ERROR_WRITING_MAXCONNECTBPS     (RASBASE+85)
#define ERROR_WRITING_MAXCARRIERBPS     (RASBASE+86)
#define ERROR_WRITING_USAGE             (RASBASE+87)
#define ERROR_WRITING_DEFAULTOFF        (RASBASE+88)
#define ERROR_READING_DEFAULTOFF        (RASBASE+89)
#define ERROR_EMPTY_INI_FILE            (RASBASE+90)
#define ERROR_AUTHENTICATION_FAILURE    (RASBASE+91)
#define ERROR_PORT_OR_DEVICE            (RASBASE+92)
#define ERROR_NOT_BINARY_MACRO          (RASBASE+93)
#define ERROR_DCB_NOT_FOUND             (RASBASE+94)
#define ERROR_STATE_MACHINES_NOT_STARTE (RASBASE+95)
#define ERROR_STATE_MACHINES_ALREADY_ST (RASBASE+96)
#define ERROR_PARTIAL_RESPONSE_LOOPING  (RASBASE+97)
#define ERROR_UNKNOWN_RESPONSE_KEY      (RASBASE+98)
#define ERROR_RECV_BUF_FULL             (RASBASE+99)
#define ERROR_CMD_TOO_LONG              (RASBASE+100)
#define ERROR_UNSUPPORTED_BPS           (RASBASE+101)
#define ERROR_UNEXPECTED_RESPONSE       (RASBASE+102)
#define ERROR_INTERACTIVE_MODE          (RASBASE+103)
#define ERROR_BAD_CALLBACK_NUMBER       (RASBASE+104)
#define ERROR_INVALID_AUTH_STATE        (RASBASE+105)
#define ERROR_WRITING_INITBPS           (RASBASE+106)
#define ERROR_INVALID_WIN_HANDLE        (RASBASE+107)
#define ERROR_NO_PASSWORD               (RASBASE+108)
#define ERROR_NO_USERNAME               (RASBASE+109)
#define ERROR_CANNOT_START_STATE_MACHIN (RASBASE+110)
#define ERROR_GETTING_COMMSTATE         (RASBASE+111)
#define ERROR_SETTING_COMMSTATE         (RASBASE+112)
#define ERROR_COMM_FUNCTION             (RASBASE+113)
#define ERROR_CONFIGURATION_PROBLEM     (RASBASE+114)
#define ERROR_X25_DIAGNOSTIC            (RASBASE+115)
#define ERROR_TOO_MANY_LINE_ERRORS      (RASBASE+116)
#define ERROR_OVERRUN                   (RASBASE+117)
#define ERROR_ACCT_EXPIRED              (RASBASE+118)
#define ERROR_CHANGING_PASSWORD         (RASBASE+119)
#define ERROR_NO_ACTIVE_ISDN_LINES      (RASBASE+120)
#define ERROR_NO_ISDN_CHANNELS_AVAILABL (RASBASE+121)

#define RASBASEEND                           (RASBASE+121)


#endif // _RASERROR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\regedit\common.h ===
#ifndef REG_COMMON
#define REG_COMMON

#ifdef NOHELP

#define MyHelp( x , y , z)

#endif

#include <shellapi.h>


/*********************************************************/
/******************* Constants ***************************/
/*********************************************************/

#define OPENDLG			4096
#define MAINICON		4097
#define MAINMENU		4098
#define SDKMAINMENU		4099

#define ID_HELP			0x0400
#define ID_HELPBUTTON		0x0401

#define ID_MERGEFILE		0x0410
#define ID_EXIT			(ID_MERGEFILE+1)

#define ID_ADD			0x0420
#define ID_COPY			(ID_ADD+1)
#define ID_MODIFY		(ID_ADD+2)
#define ID_DELETE		(ID_ADD+3)
#define ID_EDITVAL		(ID_ADD+4)

#define ID_FINISHMERGE		0x0430
#define ID_IDLIST		(ID_FINISHMERGE+1)

#define ID_FIRSTREGEDIT		0x0500
#define ID_FIRSTSDKREGED	0x0600

/* The help ID's should be last */
#define ID_HELPINDEX		0x0700
#define ID_HELPSEARCH   	(ID_HELPINDEX+1)
#define ID_HELPUSINGHELP	(ID_HELPINDEX+2)
#define ID_ABOUT		(ID_HELPINDEX+3)

#define IDS_SHORTNAME		0x0100
#define IDS_WIDTH		(IDS_SHORTNAME+1)
#define IDS_HEIGHT		(IDS_SHORTNAME+2)

#define IDS_MEDIUMNAME		0x0110
#define IDS_DESCRIPTION		(IDS_MEDIUMNAME+1)

#define IDS_MERGETITLE		0x0120
#define IDS_REGS		(IDS_MERGETITLE+1)
#define IDS_CUSTREGS		(IDS_MERGETITLE+2)

#define IDS_OUTOFMEMORY		0x0130
#define IDS_LONGNAME		(IDS_OUTOFMEMORY+1)

#define IDS_CANTOPENFILE	0x0140
#define IDS_CANTREADFILE	(IDS_CANTOPENFILE+1)
#define IDS_REGHEADER		(IDS_CANTOPENFILE+2)
#define IDS_BADFORMAT		(IDS_CANTOPENFILE+3)
#define IDS_SUCCESSREAD		(IDS_CANTOPENFILE+4)

#define IDS_HELPFILE		0x0150
#define IDS_HELP		(IDS_HELPFILE+1)
#define IDS_HELPERR		(IDS_HELPFILE+2)
#define IDS_SDKHELPFILE		(IDS_HELPFILE+3)

#define IDS_BADDB		0x0160
#define IDS_BADKEY		(IDS_BADDB+1)
#define IDS_CANTOPENDB		(IDS_BADDB+2)
#define IDS_CANTREADDB		(IDS_BADDB)
#define IDS_CANTWRITEDB		(IDS_BADDB+3)
#define IDS_INVALIDPARM		(IDS_BADKEY)
#define IDS_ENDERROR		(IDS_BADDB+4)

#define IDS_BUSY		0x0170

#define IDS_FIRSTREGEDIT	0x0200
#define IDS_FIRSTSDKREGED	0x0300

#define FLAG_SILENT		0x0001
#define FLAG_NOMESSAGES		0x0002
#define FLAG_VERBOSE		0x0004
#define FLAG_WRITETHROUGH	0x0008
#define FLAG_LEAVECOMMAND	0x0010

#define IDH_SYSMENU		0x2000
#define IDW_MAIN		(IDH_SYSMENU+1)
#define IDW_SDKMAIN		(IDW_MAIN+0x80)

#define IDW_OPENREG		0x3000
#define IDW_OPENEXE		(IDW_OPENREG+1)
#define IDW_SAVEREG		(IDW_OPENREG+2)

#define IDW_MODIFY		0x4000

#define MAX_KEY_LENGTH		64


/*********************************************************/
/******************* Macros ******************************/
/*********************************************************/

#define OFFSET(x) ((PSTR)(LOWORD((DWORD)(x))))


/*********************************************************/
/******************* Globals *****************************/
/*********************************************************/

extern HANDLE hInstance;
extern HWND hWndMain, hWndDlg, hWndHelp;
extern LPSTR lpCmdLine;
extern WORD wCmdFlags, wHelpMenuItem, wHelpId;
extern LONG (FAR PASCAL *lpfnEditor)(HWND, WORD, WORD, LONG);
extern FARPROC lpOldHook;
extern FARPROC lpMainWndDlg;
extern WORD wHelpIndex;


/*********************************************************/
/******************* Functions ***************************/
/*********************************************************/

/***** cutils1.c *****/
extern HANDLE NEAR PASCAL StringToLocalHandle(LPSTR szStr, WORD wFlags);
extern LPSTR NEAR _fastcall MyStrTok(LPSTR szList, char cEnd);
extern int NEAR PASCAL DoDialogBoxParam(LPCSTR lpDialog, HWND hWnd,
      FARPROC lpfnProc, DWORD dwParam);
extern int NEAR PASCAL DoDialogBox(LPCSTR, HWND, FARPROC);
extern unsigned long NEAR PASCAL MyQueryValue(HKEY hKey, PSTR pSubKey,
      HANDLE *hBuf);
extern HANDLE NEAR PASCAL GetEditString(HWND hWndEdit);
extern HANDLE NEAR _fastcall MyLoadString(WORD wId, WORD *pwSize, WORD wFlags);
extern int NEAR cdecl MyMessageBox(HWND hWnd, WORD wText, WORD wType,
      WORD wExtra, ...);
extern VOID NEAR PASCAL WriteProfileInt(WORD wAppName, WORD wKey, int nVal);
extern int NEAR PASCAL MyGetProfileInt(WORD wAppName, WORD wKey, int nDefault);
extern HANDLE NEAR PASCAL StringToHandle(LPSTR szStr);
extern int FAR PASCAL MessageFilter(int nCode, WORD wParam, LPMSG lpMsg);

#ifndef NOHELP
extern VOID NEAR PASCAL MyHelp(HWND hWnd, WORD wCommand, DWORD wId);
#endif

extern HANDLE NEAR PASCAL GetListboxString(HWND hWndEdit, int nId);
extern unsigned long NEAR PASCAL MyEnumKey(HKEY hKey, WORD wIndex,
      HANDLE *hBuf);
extern WORD NEAR _fastcall GetErrMsg(WORD wRet);
extern VOID NEAR PASCAL RepeatMove(LPSTR lpDest, LPSTR lpSrc, WORD wBytes);

/***** merge.c *****/
extern VOID NEAR PASCAL ProcessFiles(HWND hDlg, HANDLE hCmdLine, WORD wFlags);

/***** filename.c *****/
extern BOOL NEAR PASCAL DoFileOpenDlg(HWND hWnd, WORD wTitle, WORD wFilter,
      WORD wCustomFilter, HANDLE *hCustomFilter, HANDLE *hFileName, BOOL bOpen);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\regedit\cutils1.c ===
#include <windows.h>
#include "common.h"

#define BLOCKLEN 100

#ifndef DBCS
#define AnsiNext(x) ((x)+1)
#endif

extern HANDLE hInstance;
extern FARPROC lpOldHook;
extern HWND hWndMain, hWndHelp;
extern WORD wHelpMain;

extern char *pszLongName;
extern char *pszOutOfMemory;

HANDLE NEAR PASCAL StringToLocalHandle(LPSTR szStr, WORD wFlags)
{
   HANDLE hStr;
   LPSTR lpStr;

   if(!(hStr=LocalAlloc(wFlags, lstrlen(szStr) + 1)))
      goto Error1;
   if(!(lpStr=LocalLock(hStr)))
      goto Error2;
   lstrcpy(lpStr, szStr);
   LocalUnlock(hStr);
   goto Error1;

Error2:
   LocalFree(hStr);
   hStr = NULL;
Error1:
   return(hStr);
}

LPSTR NEAR _fastcall MyStrTok(LPSTR szList, char cEnd)
{
   LPSTR szTemp;

   /* if there are no more tokens return NULL */
   if(!*szList)
      return NULL;

   /* find delimiter or end of string */
   while(*szList && *szList!=cEnd)
      szList = AnsiNext(szList);

   /* if we found a delimiter insert string terminator and skip */
   if(*szList) {
      szTemp = szList;
      szList = AnsiNext(szTemp);
      *szTemp = '\0';
   }

   /* return token */
   return(szList);
}

int NEAR PASCAL DoDialogBoxParam(LPCSTR lpDialog, HWND hWnd, FARPROC lpfnProc,
      DWORD dwParam)
{
   int result = -1;

   if(!(lpfnProc = MakeProcInstance(lpfnProc, hInstance)))
      goto Error1;
   result = DialogBoxParam(hInstance, lpDialog, hWnd, lpfnProc, dwParam);
   FreeProcInstance(lpfnProc);

Error1:
   return(result);
}

int NEAR PASCAL DoDialogBox(LPCSTR lpDialog, HWND hWnd, FARPROC lpfnProc)
{
   return(DoDialogBoxParam(lpDialog, hWnd, lpfnProc, 0L));
}

unsigned long NEAR PASCAL MyQueryValue(HKEY hKey, PSTR pSubKey, HANDLE *hBuf)
{
   HANDLE hTemp;
   PSTR pBuf;
   WORD wBufSize = BLOCKLEN;
   unsigned long result = ERROR_OUTOFMEMORY;
   LONG lSize;

   if(!(*hBuf=LocalAlloc(LMEM_MOVEABLE, wBufSize)))
      goto Error1;
   if(!(pBuf=LocalLock(*hBuf)))
      goto Error2;

   while((lSize=wBufSize, (result=RegQueryValue(hKey, pSubKey, pBuf, &lSize))
         ==ERROR_SUCCESS) && (WORD)lSize>wBufSize-10) {
      LocalUnlock(*hBuf);
      wBufSize += BLOCKLEN;
      if(!(hTemp=LocalReAlloc(*hBuf, wBufSize, LMEM_MOVEABLE))) {
         result = ERROR_OUTOFMEMORY;
         goto Error2;
      }
      pBuf = LocalLock(*hBuf=hTemp);
   }
   LocalUnlock(*hBuf);
   if(result!=ERROR_SUCCESS || !lSize)
      goto Error2;
   goto Error1;

Error2:
   LocalFree(*hBuf);
   *hBuf = NULL;
Error1:
   return(result);
}

HANDLE NEAR PASCAL GetEditString(HWND hWndEdit)
{
   HANDLE hEdit = NULL;
   PSTR pEdit;
   WORD wLen;

   wLen = LOWORD(SendMessage(hWndEdit, WM_GETTEXTLENGTH, 0, 0L)) + 1;
   if(!(hEdit=LocalAlloc(LMEM_MOVEABLE, wLen)))
      goto Error1;
   if(!(pEdit=LocalLock(hEdit)))
      goto Error2;

   SendMessage(hWndEdit, WM_GETTEXT, wLen, (DWORD)((LPSTR)pEdit));
   LocalUnlock(hEdit);
   goto Error1;

Error2:
   LocalFree(hEdit);
   hEdit = NULL;
Error1:
   return(hEdit);
}

HANDLE NEAR _fastcall MyLoadString(WORD wId, WORD *pwSize, WORD wFlags)
{
   char szString[258]; /* RC limits strings to 256 chars */
   WORD wSize;

   wSize = LoadString(hInstance, wId, szString, sizeof(szString));
   if(pwSize)
      *pwSize = wSize;
   return(StringToLocalHandle(szString, wFlags));
}

int NEAR cdecl MyMessageBox(HWND hWnd, WORD wText, WORD wType, WORD wExtra, ...)
{
   HANDLE hText, hRText;
   PSTR pText, pRText;
   WORD wSize;
   int result = 0;

   if(wText == IDS_OUTOFMEMORY)
      goto Error1;

   if(!(hText=MyLoadString(wText, &wSize, LMEM_MOVEABLE)))
      goto Error1;

   /* We allocate enough room for a bunch of numbers and the strings
    */
   if(!(hRText=LocalAlloc(LMEM_MOVEABLE, 2*wSize + wExtra)))
      goto Error2;
   if(!(pRText=LocalLock(hRText)))
      goto Error3;

   pText = LocalLock(hText);
   wvsprintf(pRText, pText, (LPSTR)(&wExtra+1));
   result = MessageBox(hWnd, pRText, pszLongName, wType);

   LocalUnlock(hText);
   LocalUnlock(hRText);
Error3:
   LocalFree(hRText);
Error2:
   LocalFree(hText);
Error1:
   if(!result) {
      MessageBox(hWnd, pszOutOfMemory, pszLongName,
            MB_ICONHAND | MB_SYSTEMMODAL | MB_OK);
   }

   return(result);
}

VOID NEAR PASCAL WriteProfileInt(WORD wAppName, WORD wKey, int nVal)
{
   HANDLE hAppName, hKey;
   char buf[10];

   if(!(hAppName=MyLoadString(wAppName, NULL, LMEM_MOVEABLE)))
      goto Error1;
   if(!(hKey=MyLoadString(wKey, NULL, LMEM_MOVEABLE)))
      goto Error2;

   wsprintf(buf, "%d", nVal);
   WriteProfileString(LocalLock(hAppName), LocalLock(hKey), buf);

   LocalUnlock(hKey);
   LocalUnlock(hAppName);
Error2:
   LocalFree(hKey);
Error1:
   LocalFree(hAppName);
}

int NEAR PASCAL MyGetProfileInt(WORD wAppName, WORD wKey, int nDefault)
{
   HANDLE hAppName, hKey;

   if(!(hAppName=MyLoadString(wAppName, NULL, LMEM_MOVEABLE)))
      goto Error1;
   if(!(hKey=MyLoadString(wKey, NULL, LMEM_MOVEABLE)))
      goto Error2;

   nDefault = GetProfileInt(LocalLock(hAppName), LocalLock(hKey), nDefault);

   LocalUnlock(hKey);
   LocalUnlock(hAppName);
Error2:
   LocalFree(hKey);
Error1:
   LocalFree(hAppName);
   return(nDefault);
}

HANDLE NEAR PASCAL StringToHandle(LPSTR szStr)
{
   HANDLE hStr;
   LPSTR lpStr;

   if(!(hStr=GlobalAlloc(GMEM_MOVEABLE|GMEM_DDESHARE,
         (DWORD)(lstrlen(szStr)+1))))
      goto Error1;
   if(!(lpStr=GlobalLock(hStr)))
      goto Error2;
   lstrcpy(lpStr, szStr);
   GlobalUnlock(hStr);
   goto Error1;

Error2:
   GlobalFree(hStr);
   hStr = NULL;
Error1:
   return(hStr);
}

int FAR PASCAL MessageFilter(int nCode, WORD wParam, LPMSG lpMsg)
{
   switch(nCode) {
   case MSGF_MENU:
   case MSGF_DIALOGBOX:
      if(lpMsg->message==WM_KEYDOWN && lpMsg->wParam==VK_F1
            && !(lpMsg->lParam&(1L<<30)))
         PostMessage(hWndHelp, WM_COMMAND, ID_HELP,
               MAKELONG(lpMsg->hwnd, nCode));
      break;

   default:
      DefHookProc(nCode, wParam, (DWORD)lpMsg, &lpOldHook);
      return(FALSE);
   }

   return(FALSE);
}

#ifndef NOHELP

// #define ONLYID
VOID NEAR PASCAL MyHelp(HWND hWnd, WORD wCommand, DWORD wId)
{
#ifdef ONLYID
   if(wCommand != HELP_QUIT)
      MyMessageBox(hWnd, IDS_HELP, MB_OK, 0, wId);
#else
   HANDLE hHelpFile;
   PSTR pHelpFile;

   if(!(hHelpFile=MyLoadString(wHelpMain==IDW_SDKMAIN ?
	 IDS_SDKHELPFILE : IDS_HELPFILE, NULL, LMEM_MOVEABLE)))
      return;

   if(!WinHelp(hWndMain, pHelpFile=LocalLock(hHelpFile), wCommand, wId))
      MyMessageBox(hWnd, IDS_HELPERR, MB_OK, 0);
   else
      WinHelp(hWndMain, pHelpFile, HELP_SETINDEX, wHelpIndex);

   LocalUnlock(hHelpFile);
   LocalFree(hHelpFile);
#endif
}

#endif

HANDLE NEAR PASCAL GetListboxString(HWND hWndEdit, int nId)
{
   HANDLE hEdit = NULL;
   PSTR pEdit;
   WORD wLen;

   wLen = LOWORD(SendMessage(hWndEdit, LB_GETTEXTLEN, nId, 0L)) + 1;
   if(!(hEdit=LocalAlloc(LMEM_MOVEABLE, wLen)))
      goto Error1;
   if(!(pEdit=LocalLock(hEdit)))
      goto Error2;

   SendMessage(hWndEdit, LB_GETTEXT, nId, (DWORD)((LPSTR)pEdit));
   LocalUnlock(hEdit);
   goto Error1;

Error2:
   LocalFree(hEdit);
   hEdit = NULL;
Error1:
   return(hEdit);
}

unsigned long NEAR PASCAL MyEnumKey(HKEY hKey, WORD wIndex, HANDLE *hBuf)
{
   HANDLE hTemp;
   PSTR pBuf;
   WORD wBufSize = BLOCKLEN, wSize;
   unsigned long result = ERROR_OUTOFMEMORY;

   if(!(*hBuf=LocalAlloc(LMEM_MOVEABLE, wBufSize)))
      goto Error1;
   if(!(pBuf=LocalLock(*hBuf)))
      goto Error2;

   while((result=RegEnumKey(hKey, wIndex, pBuf, (DWORD)wBufSize))
         ==ERROR_SUCCESS && (wSize=lstrlen(pBuf))>wBufSize-10) {
      LocalUnlock(*hBuf);
      wBufSize += BLOCKLEN;
      if(!(hTemp=LocalReAlloc(*hBuf, wBufSize, LMEM_MOVEABLE))) {
         result = ERROR_OUTOFMEMORY;
         goto Error2;
      }
      pBuf = LocalLock(*hBuf=hTemp);
   }
   LocalUnlock(*hBuf);
   if(result!=ERROR_SUCCESS || !wSize)
      goto Error2;
   goto Error1;

Error2:
   LocalFree(*hBuf);
   *hBuf = NULL;
Error1:
   return(result);
}

static WORD wErrMsgs[] = {
   0, IDS_BADDB, IDS_BADKEY, IDS_CANTOPENDB, IDS_CANTREADDB, IDS_CANTWRITEDB,
   IDS_OUTOFMEMORY, IDS_INVALIDPARM
} ;

WORD NEAR _fastcall GetErrMsg(WORD wRet)
{
   return(wRet>=sizeof(wErrMsgs)/sizeof(wErrMsgs[0]) ?
      IDS_INVALIDPARM : wErrMsgs[wRet]);
}

VOID NEAR PASCAL RepeatMove(LPSTR lpDest, LPSTR lpSrc, WORD wBytes)
{
/* WARNING: This assumes that the buffers are in different segments, or
 * the offset of the dest is less than the offset of the src
 */

/* Save DS, and load up ES:DI, DS:SI, and CX with the parameters */
_asm	push    ds
_asm	les     di,lpDest
_asm	lds     si,lpSrc
_asm	mov     cx,wBytes
_asm	cld

/* Do a movsb if CX is odd, and then do movsw for CX/2 */
_asm	shr	CX,1
_asm	jnc	repm1
_asm	movsb
_asm	repm1:
_asm	jcxz	repm2
_asm	rep	movsw
_asm	repm2:

/* Restore DS and return */
_asm	pop     ds
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\regedit\dbase.c ===
#include <windows.h>
#include "RegEdit.h"

#ifndef DBCS
#define AnsiNext(x) ((x)+1)
#endif

#define NUMACTIONS (ID_LASTACTIONRADIO-ID_FIRSTACTIONRADIO+1)
#define EDITSPERACTION (ID_LASTEDIT-ID_FIRSTACTIONEDIT+1)
#define OFFSET_COMMAND 0
#define OFFSET_FIRSTDDE 1
#define OFFSET_DDEEXEC 1
#define OFFSET_DDEIFEXEC 2
#define OFFSET_DDEAPP 3
#define OFFSET_DDETOPIC 4
#define BLOCKLEN 100

char szNull[] = "";

static char szShell[] = "shell";
static char szCommand[] = "command";
static char szDDEExec[] = "ddeexec";
static char szDDEIfExec[] = "ddeexec\\ifexec";
static char szDDEApplication[] = "ddeexec\\application";
static char szDDETopic[] = "ddeexec\\topic";
static char *ppCommands[] = {
   szCommand, szDDEExec, szDDEIfExec, szDDEApplication, szDDETopic
} ;
static char szOpen[] = "open";
static char szPrint[] = "print";
static char *ppActionIds[] = {
   szOpen, szPrint
} ;
static char szSystem[] = "System";

char cUsesDDE[NUMACTIONS];

HANDLE *pLocalVals = NULL;

WORD NEAR PASCAL CreateId(HANDLE hId)
{
   HKEY hKeyNew;
   PSTR pId, pTemp;
   WORD wErrMsg = IDS_INVALIDID;

   pId = LocalLock(hId);
   if(!*pId || *pId=='.')
      goto Error1;
   for(pTemp=pId; *pTemp; ++pTemp)
/* this excludes '\\' and all other chars except 33-127 */
      if(*pTemp=='\\' || *pTemp<=' ')
         goto Error1;

   wErrMsg = IDS_EXISTS;
   if(RegOpenKey(HKEY_CLASSES_ROOT, pId, &hKeyNew) == ERROR_SUCCESS)
      goto Error2;

   if(wErrMsg=GetErrMsg((WORD)RegCreateKey(HKEY_CLASSES_ROOT, pId, &hKeyNew)))
      goto Error1;
   wErrMsg = NULL;

Error2:
   RegCloseKey(hKeyNew);
Error1:
   LocalUnlock(hId);
   return(wErrMsg);
}

WORD NEAR PASCAL MyGetClassName(HANDLE hId, HANDLE *hName)
{
   WORD wErrMsg;

   wErrMsg = GetErrMsg((WORD)MyQueryValue(HKEY_CLASSES_ROOT, LocalLock(hId),
	 hName));
   LocalUnlock(hId);
   return(wErrMsg);
}

WORD NEAR PASCAL DeleteClassId(HANDLE hId)
{
   WORD wErrMsg;

   wErrMsg = GetErrMsg((WORD)RegDeleteKey(HKEY_CLASSES_ROOT, LocalLock(hId)));
   LocalUnlock(hId);
   return(wErrMsg);
}

WORD NEAR PASCAL MergeData(HWND hWndName, HANDLE hId)
{
   HANDLE hName;
   HANDLE *phTemp;
   WORD wErrMsg = IDS_OUTOFMEMORY;
   HKEY hKeyId, hKeyShell, hKeyAction;
   int i, j;

   if(!(hName=GetEditString(hWndName)))
      goto Error2;
   if(wErrMsg=GetErrMsg((WORD)RegOpenKey(HKEY_CLASSES_ROOT, LocalLock(hId),
	 &hKeyId)))
      goto Error3;
   if(wErrMsg=GetErrMsg((WORD)RegCreateKey(hKeyId, szShell, &hKeyShell)))
      goto Error4;
   if(wErrMsg=GetErrMsg((WORD)RegSetValue(hKeyId, szNull, (DWORD)REG_SZ,
         LocalLock(hName), 0L)))
      goto Error5;

   for(i=0, phTemp=pLocalVals; i<NUMACTIONS; ++i) {
      if(wErrMsg=GetErrMsg((WORD)RegCreateKey(hKeyShell, ppActionIds[i],
            &hKeyAction)))
         goto Error5;

      for(j=0; j<EDITSPERACTION; ++j, ++phTemp) {
         if(*phTemp && (j<OFFSET_FIRSTDDE || cUsesDDE[i])) {
            PSTR pTemp;

            pTemp = LocalLock(*phTemp);
            if((j==OFFSET_DDETOPIC && !lstrcmpi(pTemp, szSystem)) ||
                  (j==OFFSET_DDEAPP && !lstrcmpi(pTemp,
		  GetAppName(*(phTemp+OFFSET_COMMAND-OFFSET_DDEAPP)))))
               RegDeleteKey(hKeyAction, ppCommands[j]);
            else
               wErrMsg = GetErrMsg((WORD)RegSetValue(hKeyAction, ppCommands[j],
                     (DWORD)REG_SZ, pTemp, 0L));
            LocalUnlock(*phTemp);
            if(wErrMsg)
               goto Error5;
         } else {
            RegDeleteKey(hKeyAction, ppCommands[j]);
         }
      }

      RegCloseKey(hKeyAction);
   }
   wErrMsg = NULL;

Error5:
   LocalUnlock(hName);
   RegCloseKey(hKeyShell);
Error4:
   RegCloseKey(hKeyId);
Error3:
   LocalUnlock(hId);
   LocalFree(hName);
Error2:
   return(wErrMsg);
}

WORD NEAR PASCAL ResetClassList(HWND hWndIdList, HWND hWndNameList)
{
   HANDLE hClassId, hClassName;
   HKEY hKeyClasses;
   int i;
   WORD wErrMsg;

/* Reset the name list */
   SendMessage(hWndIdList, LB_RESETCONTENT, 0, 0L);
   SendMessage(hWndNameList, LB_RESETCONTENT, 0, 0L);

   if(wErrMsg=GetErrMsg((WORD)RegCreateKey(HKEY_CLASSES_ROOT, szNull,
         &hKeyClasses)))
      goto Error1;

   for(i=0; MyEnumKey(hKeyClasses, i, &hClassId)==ERROR_SUCCESS && !wErrMsg;
         ++i) {
      int nId;
      PSTR pClassId;

      pClassId = LocalLock(hClassId);
      if(*pClassId=='.' || (wErrMsg=MyGetClassName(hClassId, &hClassName)))
         goto Error2;

      wErrMsg = IDS_OUTOFMEMORY;
      if((nId=(int)SendMessage(hWndNameList, LB_ADDSTRING, 0,
            (DWORD)((LPSTR)LocalLock(hClassName))))==LB_ERR
            || SendMessage(hWndIdList, LB_INSERTSTRING, nId,
            (DWORD)((LPSTR)pClassId))==LB_ERR)
         goto Error3;

      wErrMsg = NULL;
Error3:
      LocalUnlock(hClassName);
      LocalFree(hClassName);
Error2:
      LocalUnlock(hClassId);
      LocalFree(hClassId);
   }

   SendMessage(hWndNameList, LB_SETTOPINDEX, 0, 0L);
   SendMessage(hWndNameList, LB_SETCURSEL, 0, 0L);

   RegCloseKey(hKeyClasses);
Error1:
   return(wErrMsg);
}

WORD NEAR PASCAL GetLocalCopies(HWND hWndName, HANDLE hId)
{
   HKEY hKeyId, hKeyShell, hSubKey;
   HANDLE hName, *phTemp;
   WORD wErrMsg = IDS_OUTOFMEMORY;
   int i, j;

   if(!pLocalVals) {
      HANDLE hLocalVals;

      if(!(hLocalVals=LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT,
            NUMACTIONS*EDITSPERACTION*sizeof(HANDLE)))
            || !(pLocalVals=(HANDLE *)LocalLock(hLocalVals)))
         goto Error1;
   }

   for(i=0, phTemp=pLocalVals; i<NUMACTIONS; ++i) {
      cUsesDDE[i] = 0;

      for(j=0; j<EDITSPERACTION; ++j, ++phTemp) {
         if(*phTemp) {
            LocalFree(*phTemp);
            *phTemp = NULL;
         }
      }
   }
   SendMessage(hWndName, WM_SETTEXT, 0, (DWORD)((LPSTR)szNull));
   if(!hId)
      return(NULL);

   if(wErrMsg=GetErrMsg((WORD)RegOpenKey(HKEY_CLASSES_ROOT, LocalLock(hId),
         &hKeyId)))
      goto Error3;
   if(wErrMsg=GetErrMsg((WORD)RegCreateKey(hKeyId, szShell, &hKeyShell)))
      goto Error4;

   if(wErrMsg=GetErrMsg((WORD)MyQueryValue(hKeyId, szNull, &hName)))
      goto Error5;
   SendMessage(hWndName, WM_SETTEXT, 0, (DWORD)((LPSTR)LocalLock(hName)));
   LocalUnlock(hName);
   LocalFree(hName);

   for(i=0, phTemp=pLocalVals; i<NUMACTIONS; ++i) {
      if(wErrMsg=GetErrMsg((WORD)RegCreateKey(hKeyShell, ppActionIds[i],
            &hSubKey)))
         goto Error5;

      for(j=0; j<EDITSPERACTION; ++j, ++phTemp) {
         if((wErrMsg=(WORD)MyQueryValue(hSubKey, ppCommands[j], phTemp))
               !=(WORD)ERROR_BADKEY && (wErrMsg=GetErrMsg(wErrMsg)))
            goto Error5;

         if(j>=OFFSET_FIRSTDDE) {
            if(*phTemp)
               cUsesDDE[i] = 1;
            else if(j == OFFSET_DDETOPIC) {
               *phTemp = StringToLocalHandle(szSystem, LMEM_MOVEABLE);
            } else if(j == OFFSET_DDEAPP) {
               HANDLE hTemp;

               if(hTemp = *(phTemp-(OFFSET_DDEAPP+OFFSET_COMMAND)))
                  *phTemp = StringToLocalHandle(GetAppName(hTemp),
                        LMEM_MOVEABLE);
            }
         }
      }

      RegCloseKey(hSubKey);
   }

   wErrMsg = NULL;
Error5:
   RegCloseKey(hKeyShell);
Error4:
   RegCloseKey(hKeyId);
Error3:
   LocalUnlock(hId);
Error1:
   return(wErrMsg);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\regedit\filename.c ===
#include <windows.h>
#include <commdlg.h>
#include <dlgs.h>
#include "common.h"

#ifndef DBCS
#define AnsiNext(x) ((x)+1)
#endif

#define MYMAXPATH 255

extern HANDLE hInstance;
extern HWND hWndHelp;
extern WORD wHelpId;

static VOID NEAR PASCAL ReplaceChar(LPSTR lpStr, char cOld, char cNew)
{
   for( ; *lpStr; lpStr=AnsiNext(lpStr))
      if(*lpStr == cOld)
         *lpStr = cNew;
}

int FAR PASCAL MyOpenDlgProc(HWND hWnd, WORD message, WORD wParam, DWORD lParam)
{
   switch(message) {
   case WM_ACTIVATE:
      if(wParam)
         hWndHelp = hWnd;
      return(FALSE);

   case WM_INITDIALOG:
      return(TRUE);

   case WM_COMMAND:
      switch(wParam) {
      case ID_HELP:
         if(GetParent(LOWORD(lParam)) != hWnd)
            break;
      case psh15:
         MyHelp(hWnd, HELP_CONTEXT, wHelpId);
         break;
      }
      break;
   }

   return(FALSE);
}

HANDLE NEAR PASCAL MyLoadGlobalString(HANDLE wString, WORD *wSize)
{
   HANDLE hlString, hString;

   if(!(hlString=MyLoadString(wString, wSize, LMEM_MOVEABLE)))
      goto Error1;
   hString = StringToHandle(LocalLock(hlString));
   LocalUnlock(hlString);
   LocalFree(hlString);

Error1:
   return(hString);
}

BOOL NEAR PASCAL DoFileOpenDlg(HWND hWnd, WORD wTitle, WORD wFilter,
      WORD wCustomFilter, HANDLE *hCustomFilter, HANDLE *hFileName, BOOL bOpen)
{
   HANDLE hOfn, hFilter, hTitle;
   LPOPENFILENAME lpOfn;
   LPSTR lpFileName, lpFilter;
   BOOL result = FALSE;
#ifdef USECUSTOMFILTER
   HANDLE hpFilter;
   LPSTR lpCustomFilter;
   WORD wSize;
#endif

   if(!(hOfn=GlobalAlloc(GMEM_FIXED, sizeof(OPENFILENAME))))
      goto Error1;
   if(!(lpOfn=(LPOPENFILENAME)GlobalLock(hOfn)))
      goto Error2;

   if(!(hFilter=MyLoadGlobalString(wFilter, NULL)))
      goto Error3;
   lpFilter = GlobalLock(hFilter);
   ReplaceChar(AnsiNext(lpFilter), *lpFilter, '\0');

   if(!(hTitle=MyLoadGlobalString(wTitle, NULL)))
      goto Error4;

   if(!(*hFileName=GlobalAlloc(GMEM_MOVEABLE, MYMAXPATH)))
      goto Error5;
   if(!(lpFileName=GlobalLock(*hFileName)))
      goto Error6;
   *lpFileName = '\0';

#ifdef USECUSTOMFILTER
   if(*hCustomFilter) {
      lpCustomFilter = GlobalLock(*hCustomFilter);
   } else {
      if(!(*hCustomFilter=MyLoadGlobalString(wCustomFilter, &wSize)))
         goto Error7;
      if(hpFilter=GlobalReAlloc(*hCustomFilter, 2*wSize, GMEM_MOVEABLE))
         *hCustomFilter = hpFilter;
      lpCustomFilter = GlobalLock(*hCustomFilter);
      ReplaceChar(AnsiNext(lpCustomFilter), *lpCustomFilter, '\0');
   }
#endif

   lpOfn->lStructSize = sizeof(OPENFILENAME);
   lpOfn->hwndOwner = hWnd;
   lpOfn->hInstance = hInstance;
   lpOfn->lpstrFilter = AnsiNext(lpFilter);
#ifdef USECUSTOMFILTER
   lpOfn->lpstrCustomFilter = AnsiNext(lpCustomFilter);
   lpOfn->nMaxCustFilter = GlobalSize(*hCustomFilter) - 1;
#else
   lpOfn->lpstrCustomFilter = NULL;
   lpOfn->nMaxCustFilter = 0;
#endif
   lpOfn->nFilterIndex = 0;
   lpOfn->lpstrFile = lpFileName;
   lpOfn->nMaxFile = MYMAXPATH;
   lpOfn->lpstrFileTitle = NULL;
   lpOfn->nMaxFileTitle = 0;
   lpOfn->lpstrInitialDir = NULL;
   lpOfn->lpstrTitle = GlobalLock(hTitle);
   lpOfn->Flags = OFN_HIDEREADONLY
#ifndef NOHELP
	 | OFN_SHOWHELP
#endif
	 | OFN_OVERWRITEPROMPT | OFN_ENABLEHOOK;
   lpOfn->lpstrDefExt = NULL;
   lpOfn->lCustData = 0;
   lpOfn->lpfnHook = (UINT (CALLBACK *)(HWND, UINT, WPARAM, LPARAM))MakeProcInstance(MyOpenDlgProc, hInstance);
   lpOfn->lpTemplateName = NULL;

   result = bOpen ? GetOpenFileName(lpOfn) : GetSaveFileName(lpOfn);

   if(lpOfn->lpfnHook)
      FreeProcInstance(lpOfn->lpfnHook);

   GlobalUnlock(hTitle);
#ifdef USECUSTOMFILTER
   GlobalUnlock(*hCustomFilter);
Error7:
#endif
   GlobalUnlock(*hFileName);
Error6:
   if(!result)
      GlobalFree(*hFileName);
Error5:
   GlobalFree(hTitle);
Error4:
   GlobalUnlock(hFilter);
   GlobalFree(hFilter);
Error3:
   GlobalUnlock(hOfn);
Error2:
   GlobalFree(hOfn);
Error1:
   return(result);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\regedit\merge.c ===
#include <windows.h>
#include "common.h"

#define BLOCKLEN 100

#ifndef DBCS
#define AnsiNext(x) ((x)+1)
#endif

LPSTR lpMerge;
char szDotClasses[] = "\\.classes\\";
char szHkeyClassesRoot[] = "HKEY_CLASSES_ROOT\\";

extern HWND hWndHelp;

extern unsigned long NEAR PASCAL MySetValue(HKEY hKey, PSTR pSubKey, PSTR pVal);

NEAR PASCAL
ImportWin40RegFile(
    VOID
    );

static PSTR NEAR PASCAL GetFileLine(void)
{
   static HANDLE hFile = NULL;
   static PSTR pFile;
   static WORD wLen;

   LPSTR lpStart;
   HANDLE hTemp;
   WORD wLineLen;
   char cFile;

/* We need a place to put the file line */
   if(!hFile) {
      if(!(hFile=LocalAlloc(LMEM_MOVEABLE, wLen=BLOCKLEN)))
         goto Error1;
      if(!(pFile=LocalLock(hFile)))
         goto Error2;
   }

/* If we have read the whole file, then clean up and return */
   if(!*lpMerge)
      goto Error3;

   for(lpStart=lpMerge; ; ) {
      cFile = *lpMerge;
      lpMerge = AnsiNext(lpMerge);

      switch(cFile) {
      case('\n'):
      case('\r'):
      case('\0'):
/* EOL so return */
         goto CopyLine;
      }
   }

CopyLine:
   wLineLen = lpMerge - lpStart - 1;
/* Make the buffer larger if necessary */
   if(wLineLen >= wLen) {
      LocalUnlock(hFile);
      wLen = wLineLen + BLOCKLEN;
      if(!(hTemp=LocalReAlloc(hFile, wLen, LMEM_MOVEABLE)))
         goto Error2;
      if(!(pFile=LocalLock(hFile=hTemp)))
         goto Error2;
   }
   RepeatMove(pFile, lpStart, wLineLen);
   pFile[wLineLen] = '\0';
   return(pFile);


Error3:
   LocalUnlock(hFile);
Error2:
   LocalFree(hFile);
   hFile = NULL;
Error1:
   return(NULL);
}

static VOID NEAR PASCAL MergeFileData(void)
{
  static struct tagKEYANDROOT
    {
      PSTR szKey;
      HKEY hKeyRoot;
    } krClasses[] =
    {
      szHkeyClassesRoot, HKEY_CLASSES_ROOT,
      szDotClasses, HKEY_CLASSES_ROOT
    } ;
#define NUM_KEYWORDS (sizeof(krClasses)/sizeof(krClasses[0]))

  PSTR pLine;
  PSTR pLast;
  HKEY hKeyRoot, hSubKey;
  int i;

  /* Get the initial line if this is the first time through */
  if(!(pLine=GetFileLine()))
      return;
  /* Otherwise, open a key so that we only do one write to the disk */
  if(RegCreateKey(HKEY_CLASSES_ROOT, NULL, &hSubKey) != ERROR_SUCCESS)
      return;

  do
    {
      for (i=0; i<NUM_KEYWORDS; ++i)
	{
	  char cTemp;
	  int nCmp, nLen;

	  cTemp = pLine[nLen=lstrlen(krClasses[i].szKey)];
	  pLine[nLen] = '\0';
	  nCmp = lstrcmp(krClasses[i].szKey, pLine);
	  pLine[nLen] = cTemp;
	  if (!nCmp)
	    {
	      pLine += nLen;
	      hKeyRoot = krClasses[i].hKeyRoot;
	      goto MergeTheData;
	    }
	}
      continue;

MergeTheData:
      /* This is a line that needs to get merged.
       * Find a space (and then skip spaces) or "= " */
      for(pLast=pLine; *pLast; pLast=AnsiNext(pLast))
	{
	  if(*pLast == ' ')
	    {
	      *pLast = '\0';
	      while(*(++pLast) == ' ')
		  /* find the first non-space */ ;
	      break;
	    }
	}

      /* There is an error if we don't have "= " */
      if(*pLast=='=' && *(++pLast)==' ')
	 ++pLast;

      /* Set the value */
      MySetValue(hKeyRoot, pLine, pLast);
    } while(pLine=GetFileLine()) ;

  RegCloseKey(hSubKey);
}


VOID NEAR PASCAL ProcessFiles(HWND hDlg, HANDLE hCmdLine, WORD wFlags)
{
   HANDLE hMerge, hHeader;
   PSTR pHeader;
   int hFile;
   LONG lSize;
   LPSTR lpFileName, lpTemp;
   OFSTRUCT of;
   WORD wErrMsg;

   lpFileName = GlobalLock(hCmdLine);
/* We need to process all file names on the command line */
   while(lpTemp=MyStrTok(lpFileName, ' ')) {
/* Open the file */
      wErrMsg = IDS_CANTOPENFILE;
      if((hFile=OpenFile(lpFileName, &of, OF_READ)) == -1)
         goto Error2;

/* Determine the file size; limit it to just less than 64K */
      wErrMsg = IDS_CANTREADFILE;
      if((lSize=_llseek(hFile, 0L, 2))==-1 || lSize>0xfff0)
         goto Error3;
      _llseek(hFile, 0L, 0);

/* Allocate a block of memory for the file */
      wErrMsg = IDS_OUTOFMEMORY;
      if(!(hMerge=GlobalAlloc(GHND, lSize+2)))
         goto Error3;
      if(!(lpMerge=GlobalLock(hMerge)))
         goto Error4;

/* Read in the file */
      wErrMsg = IDS_CANTREADFILE;
      if(_lread(hFile, lpMerge, LOWORD(lSize)) != LOWORD(lSize))
         goto Error5;

/* Look for the header */
      wErrMsg = IDS_OUTOFMEMORY;
      if(!(hHeader=MyLoadString(IDS_REGHEADER, NULL, LMEM_MOVEABLE)))
         goto Error5;
      pHeader = LocalLock(hHeader);

      wErrMsg = IDS_BADFORMAT;
      while(*lpMerge == ' ')
         ++lpMerge;
      while(*pHeader)
         if(*lpMerge++ != *pHeader++)
            goto Error6;
      if(*lpMerge=='4')
       {
        ImportWin40RegFile();
        wErrMsg = IDS_SUCCESSREAD;
        goto Error6;
       }
      while(*lpMerge == ' ')
         ++lpMerge;
      if(*lpMerge!='\r' && *lpMerge!='\n')
         goto Error6;

/* Merge the data */
      MergeFileData(); /* This makes the changes */

      wErrMsg = IDS_SUCCESSREAD;
Error6:
      LocalUnlock(hHeader);
      LocalFree(hHeader);
Error5:
      GlobalUnlock(hMerge);
Error4:
      GlobalFree(hMerge);
Error3:
      _lclose(hFile);
Error2:
/* Display the status message */
      if(!(wFlags&FLAG_SILENT) || wErrMsg!=IDS_SUCCESSREAD)
         MyMessageBox(hDlg, wErrMsg, MB_OK | MB_ICONEXCLAMATION,
	       lstrlen(lpFileName), lpFileName);

      lpFileName = lpTemp;
      while(*lpFileName == ' ')
         ++lpFileName;
   }

   GlobalUnlock(hCmdLine);

   GlobalFree(hCmdLine);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\regedit\reg1632.h ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1993-1994
*
*  TITLE:       REG1632.H
*
*  VERSION:     4.01
*
*  AUTHOR:      Tracy Sharpe
*
*  DATE:        06 Apr 1994
*
*  Win32 and MS-DOS compatibility macros for the Registry Editor.
*
********************************************************************************
*
*  CHANGE LOG:
*
*  DATE        REV DESCRIPTION
*  ----------- --- -------------------------------------------------------------
*  06 Apr 1994 TCS Original implementation.
*
*******************************************************************************/

#ifndef _INC_REG1632
#define _INC_REG1632

#ifndef LPCHAR
typedef CHAR FAR*                       LPCHAR;
#endif

#ifdef WIN32
#define WSPRINTF(x)                     wsprintf ##x
#else
#define WSPRINTF(x)                     sprintf ##x
#endif

#ifdef WIN32
#define STRCMP(string1, string2)        lstrcmp(string1, string2)
#else
#define STRCMP(string1, string2)        _fstrcmp(string1, string2)
#endif

#ifdef WIN32
#define STRCPY(string1, string2)        lstrcpy(string1, string2)
#else
#define STRCPY(string1, string2)        _fstrcpy(string1, string2)
#endif

#ifdef WIN32
#define STRLEN(string)                  lstrlen(string)
#else
#define STRLEN(string)                  _fstrlen(string)
#endif

#ifdef WIN32
#define STRCHR(string, character)       StrChr(string, character)
#else
#ifdef DBCS
#define STRCHR(string, character)       DBCSStrChr(string, character)
#else
#define STRCHR(string, character)       _fstrchr(string, character)
#endif
#endif

#ifdef WIN32
#define CHARNEXT(string)                CharNext(string)
#else
#define CHARNEXT(string)                (string + 1)
#endif

#ifdef WIN32
#define CHARUPPERSTRING(string)         CharUpper(string)
#else
#define CHARUPPERSTRING(string)         _fstrupr(string)
#endif

#ifdef WIN32
#define FILE_HANDLE                     HANDLE
#else
#define FILE_HANDLE                     int
#endif

#ifdef WIN32
#define FILE_NUMBYTES                   DWORD
#else
#define FILE_NUMBYTES                   unsigned
#endif

#if 1 //def WIN32
#define OPENREADFILE(pfilename, handle)                                     \
    ((handle = (FILE_HANDLE) OpenFile(pfilename, &OFStruct, OF_READ)) !=    \
        (FILE_HANDLE) HFILE_ERROR)
#else
#define OPENREADFILE(pfilename, handle)                                     \
    (_dos_open(pfilename, _O_RDONLY, &handle) == 0)
#endif

#ifdef WIN32
#define OPENWRITEFILE(pfilename, handle)                                    \
    ((handle = CreateFile(pfilename, GENERIC_WRITE, 0,                      \
        NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL)) !=               \
        INVALID_HANDLE_VALUE)
#else
#define OPENWRITEFILE(pfilename, handle)                                    \
    (HFILE_ERROR!=(handle=_lcreat(pfilename, 0)))
#endif

#ifdef WIN32
#define READFILE(handle, buffer, count, pnumbytes)                          \
    ReadFile(handle, buffer, count, pnumbytes, NULL)
#else
#define READFILE(handle, buffer, count, pnumbytes)                          \
    (count==(*pnumbytes=_hread(handle, buffer, count)))
#endif

#ifdef WIN32
#define WRITEFILE(handle, buffer, count, pnumbytes)                         \
    WriteFile(handle, buffer, count, pnumbytes, NULL)
#else
#define WRITEFILE(handle, buffer, count, pnumbytes)                         \
    (count==(*pnumbytes=_hwrite(handle, buffer, count)))
#endif

#ifdef WIN32
#define SEEKCURRENTFILE(handle, count)                                      \
    (SetFilePointer(handle, (LONG) count, NULL, FILE_CURRENT))
#else
#define SEEKCURRENTFILE(handle, count)                                      \
    (_llseek(handle, count, SEEK_CUR))
#endif

#ifdef WIN32
#define CLOSEFILE(handle)               CloseHandle(handle)
#else
#define CLOSEFILE(handle)               _lclose(handle)
#endif

#ifdef WIN32
#define GETFILESIZE(handle)             GetFileSize(handle, NULL)
#else
DWORD
NEAR PASCAL
GetFileSize(
    FILE_HANDLE hFile
    );
#define GETFILESIZE(handle)             GetFileSize(handle)
#endif

#endif // _INC_REG1632

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\regedit\regedit.h ===
#include "common.h"


/*********************************************************/
/******************* Constants ***************************/
/*********************************************************/

#define EDITDLG 200
#define MAINWND 201

#define ID_NAMELIST		(ID_FIRSTREGEDIT)

#define ID_CLASSID		(ID_FIRSTREGEDIT+0x10)
#define ID_STATCLASSID		(ID_CLASSID+1)
#define ID_USESDDE		(ID_CLASSID+2)
#define ID_BROWSE		(ID_CLASSID+3)
#define ID_SAVEACTION		(ID_CLASSID+4)
#define ID_GROUPDDE		(ID_CLASSID+5)

#define ID_FIRSTACTIONRADIO	(ID_FIRSTREGEDIT+0x20)
#define ID_OPENRADIO		(ID_FIRSTACTIONRADIO)
#define ID_PRINTRADIO		(ID_FIRSTACTIONRADIO+1)
#define ID_LASTACTIONRADIO	(ID_PRINTRADIO)

#define ID_FIRSTEDIT		(ID_FIRSTREGEDIT+0x30)
#define ID_CLASSNAME		(ID_FIRSTEDIT)
#define ID_FIRSTACTIONEDIT	(ID_FIRSTEDIT+1)
#define ID_COMMAND		(ID_FIRSTACTIONEDIT)
#define ID_FIRSTDDEEDIT		(ID_FIRSTEDIT+2)
#define ID_LASTEDIT		(ID_FIRSTEDIT+5)

#define CI_SUCCESS 0
#define CI_EXISTS 1
#define CI_CANTCREATE 2

#define IDS_BROWSETITLE		(IDS_FIRSTREGEDIT)
#define IDS_EXES		(IDS_BROWSETITLE+1)
#define IDS_CUSTEXES		(IDS_BROWSETITLE+2)

#define IDS_EXISTS		(IDS_FIRSTREGEDIT+0x10)
#define IDS_INVALIDID		(IDS_EXISTS+1)
#define IDS_INVALIDNAME		(IDS_EXISTS+2)

#define IDS_ADD			(IDS_FIRSTREGEDIT+0x20)
#define IDS_COPY		(IDS_ADD+1)

#define IDS_SUREDELETE		(IDS_FIRSTREGEDIT+0x30)

#define CC_INVALIDNAME -1
#define CC_OUTOFMEMORY -2
#define CC_ALREADYEXISTS -3
#define CC_CANTCREATE -4

#define FLAG_NEW (1)
#define FLAG_COPY (2)


/*********************************************************/
/******************* Functions ***************************/
/*********************************************************/

/***** regedit.c *****/
extern long FAR PASCAL MainWnd(HWND, WORD, WORD, LONG);

/***** dbase.c *****/
extern WORD NEAR PASCAL CreateId(HANDLE hId);
extern WORD NEAR PASCAL MyGetClassName(HANDLE hId, HANDLE *hName);
extern WORD NEAR PASCAL DeleteClassId(HANDLE hId);
extern WORD NEAR PASCAL MergeData(HWND hWndName, HANDLE hId);
extern WORD NEAR PASCAL ResetClassList(HWND hWndIdList, HWND hWndNameList);
extern WORD NEAR PASCAL GetLocalCopies(HWND hWndName, HANDLE hId);

/***** utils1.c *****/
extern PSTR NEAR PASCAL GetAppName(HANDLE hCommand);
extern HANDLE NEAR cdecl ConstructPath(PSTR pHead, ...);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\regedit\regdef.h ===
/* Do not include this before Windows.h */

/* ASM
; DO NOT INCLUDE THIS BEFORE WINDOWS.INC 
*/

#define Dereference(x)	x=x;

#ifdef _WIN32
/*XLATOFF*/
#pragma warning (disable:4209)		// turn off redefinition warning (with vmm.h)
/*XLATON*/
#endif // #ifdef _WIN32

#ifndef _WINREG_
//  WINREG.H uses DECLARE_HANDLE(HKEY) giving incompatible types.
typedef	DWORD		HKEY;
#endif

#ifdef _WIN32
/*XLATOFF*/
#pragma warning (default:4209)		// turn on redefinition warning (with vmm.h)
/*XLATON*/
#endif // #ifdef _WIN32

#define MAXKEYNAME		256
		// Max length of a key name string
#define MAXVALUENAME_LENGTH	MAXKEYNAME
		// Max length of a value name string
#define MAXDATA_LENGTH          1024L
		// Max length of a value data item
		

#ifndef REG_SZ
#define REG_SZ		0x0001
#endif

#ifndef REG_BINARY
#define REG_BINARY	0x0003
#endif

#ifndef REG_DWORD
#define REG_DWORD       0x0004
#endif

#ifndef FALSE
#define FALSE	0
#endif
#ifndef TRUE
#define TRUE	~FALSE
#endif

/* following equates are also defined in Windows.h. To avoid warnings
 * 	we should make these equates  conditional 
 */


#ifndef	ERROR_SUCCESS			
#define ERROR_SUCCESS			0L
#endif

#ifndef ERROR_FILE_NOT_FOUND
#define ERROR_FILE_NOT_FOUND		2L
#endif

#ifndef ERROR_ACCESS_DENIED
#define ERROR_ACCESS_DENIED              5L
#endif

#ifndef ERROR_BADDB
#define ERROR_BADDB                      1009L
#endif

#ifndef ERROR_MORE_DATA
#define ERROR_MORE_DATA                  234L    
#endif

#ifndef ERROR_BADKEY
#define ERROR_BADKEY			 1010L
#endif

#ifndef ERROR_CANTOPEN
#define ERROR_CANTOPEN                   1011L
#endif

#ifndef ERROR_CANTREAD
#define ERROR_CANTREAD                   1012L
#define ERROR_CANTWRITE                  1013L
#endif

#ifndef ERROR_REGISTRY_CORRUPT
#define ERROR_REGISTRY_CORRUPT           1015L
#define ERROR_REGISTRY_IO_FAILED         1016L
#endif

#ifndef ERROR_KEY_DELETED
#define ERROR_KEY_DELETED                1018L
#endif

#ifndef ERROR_OUTOFMEMORY
#define ERROR_OUTOFMEMORY		   14L
#endif

#ifndef ERROR_INVALID_PARAMETER
#define ERROR_INVALID_PARAMETER		   87L
#endif

#ifndef ERROR_LOCK_FAILED
#define ERROR_LOCK_FAILED                167L
#endif

#ifndef ERROR_NO_MORE_ITEMS
#define ERROR_NO_MORE_ITEMS		  259L
#endif	

// INTERNAL

#ifndef ERROR_CANTOPEN16_FILENOTFOUND32
#define ERROR_CANTOPEN16_FILENOTFOUND32	0xffff0000
#define ERROR_CANTREAD16_FILENOTFOUND32 0xffff0001
#endif

#ifndef HKEY_LOCAL_MACHINE	// to avoid compilation warnings
#define HKEY_CLASSES_ROOT		0x80000000
#define HKEY_CURRENT_USER		0x80000001
#define HKEY_LOCAL_MACHINE		0x80000002
#define HKEY_USERS			0x80000003
#define HKEY_PERFORMANCE_DATA		0x80000004
#define HKEY_CURRENT_CONFIG		0x80000005
#define HKEY_DYN_DATA		0x80000006
#endif		// ifndef HKEY_LOCAL_MACHINE

// INTERNAL

#ifndef HKEY_PREDEF_KEYS
#define HKEY_PREDEF_KEYS	7
#endif

#define MAXREGFILES		HKEY_PREDEF_KEYS	

// sub function indices for Registry services in VMM for 16 bit callers

#define RegOpenKey_Idx		0x100
#define RegCreateKey_Idx	0x101
#define RegCloseKey_Idx		0x102
#define RegDeleteKey_Idx	0x103
#define RegSetValue_Idx		0x104
#define RegQueryValue_Idx	0x105
#define RegEnumKey_Idx		0x106
#define RegDeleteValue_Idx	0x107
#define RegEnumValue_Idx	0x108
#define RegQueryValueEx_Idx	0x109
#define RegSetValueEx_Idx	0x10A
#define RegFlushKey_Idx		0x10B
#define RegLoadKey_Idx		0x10C
#define RegUnLoadKey_Idx	0x10D
#define RegSaveKey_Idx		0x10E
#define RegRestore_Idx		0x10F
#define RegRemapPreDefKey_Idx	0x110

// Data structure passed to SYSDM.CPL DMRegistryError function
//  After UI, the function is to call
//	RegRestore(DWORD iLevel, LPREGQRSTR lpRgRstr)
//

struct Reg_Query_Restore_s {
DWORD	dwRQR_Err;		// Error code
DWORD	hRQR_RootKey;		// Root key for file
DWORD	dwRQR_Reference;	// Reference data for RegRestore
char	szRQR_SubKey[MAXKEYNAME]; // Subkey (for hives) or NULL string
char	szRQR_FileName[256];	// File name of bad file
};
typedef struct Reg_Query_Restore_s REGQRSTR;
typedef REGQRSTR FAR * LPREGQRSTR;


// END INTERNAL
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\regedit\regresid.h ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1993-1994
*
*  TITLE:       REGRESID.H
*
*  VERSION:     4.01
*
*  AUTHOR:      Tracy Sharpe
*
*  DATE:        05 Mar 1994
*
*  Resource identifiers for the Registry Editor.
*
*******************************************************************************/

#ifndef _INC_REGRESID
#define _INC_REGRESID

#define HEXEDIT_CLASSNAME               "HEX"

//
//
//

#define IDD_REGEXPORT                   100
#define IDD_REGPRINT                    108

#define IDC_FIRSTREGCOMMDLGID           1280
#define IDC_RANGEALL                    1280
#define IDC_RANGESELECTEDPATH           1281
#define IDC_SELECTEDPATH                1282
#define IDC_EXPORTRANGE                 1283
#define IDC_LASTREGCOMMDLGID            1283

//
//
//

#define IDD_EDITSTRINGVALUE             102
#define IDD_EDITBINARYVALUE             103
#define IDD_EDITDWORDVALUE              111

#define IDC_VALUENAME                   1000
#define IDC_VALUEDATA                   1001
#define IDC_HEXADECIMAL                 1002
#define IDC_DECIMAL                     1003

//
//
//

#define IDD_REGCONNECT                  104

#define IDC_REMOTENAME                  1100
#define IDC_BROWSE                      1101

//
//
//

#define IDD_REGPRINTABORT               105

//
//  Dialog box for the Edit-> Find... menu option.
//

#define IDD_REGFIND                     106

#define IDC_FINDWHAT                    1150
#define IDC_WHOLEWORDONLY               1151
//  NOTE: The flags IDC_FOR* must be consecutive.
#define IDC_FORKEYS                     1152
#define IDC_FORVALUES                   1153
#define IDC_FORDATA                     1154
#define IDC_GROUPBOX                    1160

#define IDD_REGDISCONNECT               107
#define IDC_REMOTELIST                  1175

//
//  Dialog box for the find abort.
//

#define IDD_REGFINDABORT                109

//
//  Dialog box for Import Registry File progress display.
//

#define IDD_REGPROGRESS                 110

#define IDC_FILENAME                    100
#define IDC_PROGRESSBAR                 101

//
//  Menu resource identifiers.
//

#define IDM_REGEDIT                     103
#define IDM_KEY_CONTEXT                 104
#define IDM_VALUE_CONTEXT               105
#define IDM_VALUELIST_NOITEM_CONTEXT    106
#define IDM_COMPUTER_CONTEXT            107

//
//  HexEdit context menu identifier and items.  The IDKEY_* identifier
//  correspond to the WM_CHAR message that it corresponds to.  For example,
//  IDKEY_COPY would send a control-c to the HexEdit_OnChar routine.
//

#define IDM_HEXEDIT_CONTEXT             108

#define IDKEY_COPY                      3
#define IDKEY_PASTE                     22
#define IDKEY_CUT                       24
#define ID_SELECTALL                    0x0400

//
//  Popup menu item identifiers.  Used to determine the context menu help
//  string.
//

#define ID_FIRSTMENUPOPUPITEM           0x0200
#define ID_LASTMENUPOPUPITEM            0x027F

#define IDMP_REGISTRY                   0x0200
#define IDMP_EDIT                       0x0201
#define IDMP_VIEW                       0x0202
#define IDMP_HELP                       0x0203
#define IDMP_NEW                        0x0204

//
//  Main menu items.  If any of these items are selected from a context menu,
//  they will be automatically routed to the main window's command handler.
//

#define ID_FIRSTMAINMENUITEM            0x0280
#define ID_LASTMAINMENUITEM             0x02FF

//  Following are really keyboard accelerators.
#define ID_CYCLEFOCUS                   (ID_FIRSTMAINMENUITEM + 0x0000)

//  IMPORTANT:  Do not change the position of this identifier.  If Regedit is
//  already running and Regedit is then invoked through its commandline
//  interface, then the second instance will send a WM_COMMAND message with this
//  identifier to force a refresh.
#define ID_REFRESH                      (ID_FIRSTMAINMENUITEM + 0x0008)

#define ID_CONNECT                      (ID_FIRSTMAINMENUITEM + 0x0011)
#define ID_IMPORTREGFILE                (ID_FIRSTMAINMENUITEM + 0x0012)
#define ID_EXPORTREGFILE                (ID_FIRSTMAINMENUITEM + 0x0013)
#define ID_PRINT                        (ID_FIRSTMAINMENUITEM + 0x0014)
#define ID_EXIT                         (ID_FIRSTMAINMENUITEM + 0x0015)
#define ID_FIND                         (ID_FIRSTMAINMENUITEM + 0x0016)
#define ID_NEWKEY                       (ID_FIRSTMAINMENUITEM + 0x0017)
#define ID_NEWSTRINGVALUE               (ID_FIRSTMAINMENUITEM + 0x0018)
#define ID_NEWBINARYVALUE               (ID_FIRSTMAINMENUITEM + 0x0019)
#define ID_EXECCALC                     (ID_FIRSTMAINMENUITEM + 0x001A)
#define ID_ABOUT                        (ID_FIRSTMAINMENUITEM + 0x001B)
#define ID_STATUSBAR                    (ID_FIRSTMAINMENUITEM + 0x001C)
#define ID_SPLIT                        (ID_FIRSTMAINMENUITEM + 0x001E)
#define ID_FINDNEXT                     (ID_FIRSTMAINMENUITEM + 0x001F)
#define ID_HELPTOPICS                   (ID_FIRSTMAINMENUITEM + 0x0020)
#define ID_NETSEPARATOR                 (ID_FIRSTMAINMENUITEM + 0x0021)
#define ID_NEWDWORDVALUE                (ID_FIRSTMAINMENUITEM + 0x0022)

//
//  Dual menu items.  The routing of these items depends on whether it was
//  selected from the main menu or from a context menu.
//

#define ID_FIRSTDUALMENUITEM            0x0300
#define ID_LASTDUALMENUITEM             0x037F

#define ID_DISCONNECT                   (ID_FIRSTDUALMENUITEM + 0x0000)

//
//  Context menu items.  If any of these items are selected from the main menu,
//  they will be automatically routed to the focus pane's command handler.
//

#define ID_FIRSTCONTEXTMENUITEM         0x0380
#define ID_LASTCONTEXTMENUITEM          0x03FF

//  Following are really keyboard accelerators.
#define ID_CONTEXTMENU                  (ID_FIRSTCONTEXTMENUITEM + 0x0000)

#define ID_MODIFY                       (ID_FIRSTCONTEXTMENUITEM + 0x0010)
#define ID_DELETE                       (ID_FIRSTCONTEXTMENUITEM + 0x0011)
#define ID_RENAME                       (ID_FIRSTCONTEXTMENUITEM + 0x0012)
#define ID_TOGGLE                       (ID_FIRSTCONTEXTMENUITEM + 0x0013)
#define ID_SENDTOPRINTER                (ID_FIRSTCONTEXTMENUITEM + 0x0014)

//
//  String resource identifiers.
//

#define IDS_REGEDIT                     16
#define IDS_NAMECOLUMNLABEL             17
#define IDS_DATACOLUMNLABEL             18
#define IDS_COMPUTER                    19
#define IDS_DEFAULTVALUE                20
//  #define IDS_EMPTYSTRING                 21
#define IDS_EMPTYBINARY                 22
#define IDS_NEWKEYNAMETEMPLATE          23
#define IDS_NEWVALUENAMETEMPLATE        24
#define IDS_COLLAPSE                    25
#define IDS_MODIFY                      26
#define IDS_VALUENOTSET                 27
#define IDS_HELPFILENAME                28
#define IDS_DWORDDATAFORMATSPEC         29
#define IDS_INVALIDDWORDDATA            30

#define IDS_IMPORTREGFILETITLE          32
#define IDS_EXPORTREGFILETITLE          33
#define IDS_REGFILEFILTER               34
#define IDS_REGFILEDEFEXT               35

#define IDS_REGEDITDISABLED             40
#define IDS_SEARCHEDTOEND               41
#define IDS_COMPUTERBROWSETITLE         42

#define IDS_CONFIRMDELKEYTEXT           48
#define IDS_CONFIRMDELKEYTITLE          49
#define IDS_CONFIRMDELVALMULTITEXT      50
#define IDS_CONFIRMDELVALTITLE          51
#define IDS_CONFIRMDELVALTEXT           52

#define IDS_RENAMEKEYERRORTITLE         64
#define IDS_RENAMEPREFIX                65              //  Reserved
#define IDS_RENAMEKEYOTHERERROR         66
#define IDS_RENAMEKEYTOOLONG            67
#define IDS_RENAMEKEYEXISTS             68
#define IDS_RENAMEKEYBADCHARS           69

#define IDS_RENAMEVALERRORTITLE         72
#define IDS_RENAMEVALOTHERERROR         73
#define IDS_RENAMEVALEXISTS             74

#define IDS_DELETEKEYERRORTITLE         80
#define IDS_DELETEPREFIX                81              //  Reserved
#define IDS_DELETEKEYDELETEFAILED       82

#define IDS_DELETEVALERRORTITLE         88
#define IDS_DELETEVALDELETEFAILED       89

#define IDS_OPENKEYERRORTITLE           96
#define IDS_OPENKEYCANNOTOPEN           97

#define IDS_EDITVALERRORTITLE           112
#define IDS_EDITPREFIX                  113             //  Reserved
#define IDS_EDITVALCANNOTREAD           114
#define IDS_EDITVALCANNOTWRITE          115

#define IDS_IMPFILEERRSUCCESS           128
#define IDS_IMPFILEERRFILEOPEN          129
#define IDS_IMPFILEERRFILEREAD          130
#define IDS_IMPFILEERRREGOPEN           131
#define IDS_IMPFILEERRREGSET            132
#define IDS_IMPFILEERRFORMATBAD         133

#define IDS_EXPFILEERRSUCCESS           136
#define IDS_EXPFILEERRBADREGPATH        137
#define IDS_EXPFILEERRFILEOPEN          138
#define IDS_EXPFILEERRREGOPEN           139
#define IDS_EXPFILEERRREGENUM           140
#define IDS_EXPFILEERRFILEWRITE         141

#define IDS_PRINTERRNOMEMORY            144
#define IDS_PRINTERRPRINTER             145

#define IDS_ERRINVALIDREGPATH           148

#define IDS_CONNECTERRORTITLE           152
#define IDS_CONNECTNOTLOCAL             153
#define IDS_CONNECTBADNAME              154
#define IDS_CONNECTROOTFAILED           155
#define IDS_CONNECTACCESSDENIED         156

#define IDS_NEWKEYERRORTITLE            160
#define IDS_NEWKEYPARENTOPENFAILED      161
#define IDS_NEWKEYCANNOTCREATE          162
#define IDS_NEWKEYNOUNIQUE              163

#define IDS_NEWVALUEERRORTITLE          168
#define IDS_NEWVALUECANNOTCREATE        169
#define IDS_NEWVALUENOUNIQUE            170

//  The range IDS_FIRSTMENUPOPUPITEM through IDS_LASTMENUPOPUPITEM is reserved
//  for context menu help.  This must match up with ID_FIRSTMENUPOPUPITEM
//  through ID_LASTMENUPOPUPITEM.
#define IDS_FIRSTMENUPOPUPITEM          ID_FIRSTMENUPOPUPITEM
#define IDS_LASTMENUPOPUPITEM           ID_LASTMENUPOPUPITEM

//  The range IDS_FIRSTMAINMENUITEM through IDS_LASTMAINMENUITEM is reserved for
//  context menu help.  This must match up with ID_FIRSTMAINMENUITEM through
//  ID_LASTMAINMENUITEM.

#define IDS_FIRSTMAINMENUITEM           ID_FIRSTMAINMENUITEM
#define IDS_LASTMAINMENUITEM            ID_LASTMAINMENUITEM

//  The range IDS_FIRSTCONTEXTMENUITEM through IDS_LASTCONTEXTMENUITEM is
//  reserved for context menu help.  This must match up with
//  ID_FIRSTCONTEXTMENUITEM through ID_LASTCONTEXTMENUITEM.

#define IDS_FIRSTCONTEXTMENUITEM        ID_FIRSTCONTEXTMENUITEM
#define IDS_LASTCONTEXTMENUITEM         ID_LASTCONTEXTMENUITEM

//  The range IDS_FIRSTDUALMENUITEM through IDS_LASTDUALMENUITEM is reserved for
//  context menu help.  This must match up with ID_FIRSTDUALMENUITEM through
//  ID_LASTDUALMENUITEM.
#define IDS_FIRSTDUALMENUITEM           ID_FIRSTDUALMENUITEM
#define IDS_LASTDUALMENUITEM            ID_LASTDUALMENUITEM

//
//  Icon resource identifiers.
//

#define IDI_REGEDIT                     100
#define IDI_REGEDDOC                    101
#define IDI_REGFIND                     102

#define IDI_FIRSTIMAGE                  201
//  #define IDI_DIAMOND                     200
#define IDI_COMPUTER                    201
#define IDI_REMOTE                      202
#define IDI_FOLDER                      203
#define IDI_FOLDEROPEN                  204
#define IDI_STRING                      205
#define IDI_BINARY                      206
#define IDI_LASTIMAGE                   IDI_BINARY

//
//  Cursor resource identifiers.
//

#define IDC_SPLIT                       100

//
//  Accelerator resource identifiers.
//

#define IDACCEL_REGEDIT                 100

#endif // _INC_REGRESID
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\regedit\regedit.c ===
#define WIN31
#include <windows.h>
#include "RegEdit.h"

HWND hWndNames, hWndIds;
WORD fMode;

extern char cUsesDDE[];
extern HANDLE *pLocalVals;


WORD NEAR PASCAL StoreValue(HWND hWndEdit, HANDLE *pValue)
{
   HANDLE hTemp = NULL;

   if(!SendMessage(hWndEdit, EM_GETMODIFY, 0, 0L))
      return(0);

   SendMessage(hWndEdit, EM_SETMODIFY, 0, 0L);

   if(SendMessage(hWndEdit, WM_GETTEXTLENGTH, 0, 0L))
      if(!(hTemp=GetEditString(hWndEdit)))
	 return(IDS_OUTOFMEMORY);

   if(*pValue)
      LocalFree(*pValue);
   *pValue = hTemp;

   return(NULL);
}


VOID NEAR PASCAL SetValue(HWND hDlg, int i, HWND hWndEdit, HANDLE hValue,
      BOOL bEnable)
{
   if(bEnable) {
      if(i >= ID_FIRSTDDEEDIT)
	 EnableWindow(GetWindow(hWndEdit, GW_HWNDPREV), TRUE);
      EnableWindow(hWndEdit, TRUE);
      if(hValue) {
	 SendMessage(hWndEdit, WM_SETTEXT, 0, (LONG)(LPSTR)LocalLock(hValue));
	 LocalUnlock(hValue);
      } else
	 goto ClearEdit;
   } else {
      if(GetFocus() == hWndEdit)
	 SendMessage(hDlg, WM_NEXTDLGCTL, GetDlgItem(hDlg, ID_CLASSID), 1L);
      EnableWindow(GetWindow(hWndEdit, GW_HWNDPREV), FALSE);
      EnableWindow(hWndEdit, FALSE);
ClearEdit:
      SendMessage(hWndEdit, WM_SETTEXT, 0, (LONG)(LPSTR)"");
   }
}


int FAR PASCAL EditDlg(HWND hDlg, WORD message, WORD wParam, DWORD lParam)
{
   static HANDLE hCustExes = NULL;

   switch(message) {
   case WM_ACTIVATE:
      if(wParam)
         hWndHelp = hDlg;
      return(FALSE);

   case WM_DESTROY:
      GetLocalCopies(GetDlgItem(hDlg, ID_CLASSNAME), NULL);
      break;

   case WM_COMMAND:
      switch(wParam) {
      case ID_SAVEACTION:
         wParam = IsDlgButtonChecked(hDlg, ID_OPENRADIO)
               ? ID_OPENRADIO : ID_PRINTRADIO;
/* We fall through here */
      case ID_OPENRADIO:
      case ID_PRINTRADIO:
       {
         WORD wOld, wNew, wTemp, wErrMsg = NULL;
         BOOL bCheck;
         HWND hWndEdit;
         int i;

         wOld = (ID_LASTEDIT-ID_FIRSTACTIONEDIT+1) *
               (IsDlgButtonChecked(hDlg, ID_OPENRADIO) ? 0 : 1);
         wNew = wParam==ID_OPENRADIO ? 0 : 1;
         bCheck = cUsesDDE[wNew];
         wNew *= ID_LASTEDIT-ID_FIRSTACTIONEDIT+1;

         for(i=ID_FIRSTACTIONEDIT; i<=ID_LASTEDIT; ++i, ++wOld, ++wNew) {
	    if(wTemp=StoreValue(hWndEdit=GetDlgItem(hDlg, i), pLocalVals+wOld))
	       wErrMsg = wTemp;

	    SetValue(hDlg, i, hWndEdit, pLocalVals[wNew], i<ID_FIRSTDDEEDIT ||
		  (bCheck && (i!=(ID_FIRSTDDEEDIT+1) || SendDlgItemMessage(hDlg,
		  ID_FIRSTDDEEDIT, WM_GETTEXTLENGTH, 0, 0L))));
         }

         CheckDlgButton(hDlg, ID_USESDDE, bCheck);
         EnableWindow(GetDlgItem(hDlg, ID_GROUPDDE), bCheck);
         CheckRadioButton(hDlg, ID_OPENRADIO, ID_PRINTRADIO, wParam);

         if(wErrMsg)
            MyMessageBox(hDlg, wErrMsg, MB_OK, 0);
         break;
       }

      case ID_USESDDE:
       {
         WORD wOld;

         wOld = IsDlgButtonChecked(hDlg, ID_OPENRADIO) ? 0 : 1;
         cUsesDDE[wOld] = (char)(!IsDlgButtonChecked(hDlg, ID_USESDDE));
         SendMessage(hDlg, WM_COMMAND, ID_SAVEACTION, 0L);
         break;
       }

      case ID_FIRSTDDEEDIT:
	 if(HIWORD(lParam) == EN_CHANGE) {
	    BOOL bCheck, bEnabled;
	    HWND hWndEdit;
	    WORD wNew;

	    hWndEdit = GetDlgItem(hDlg, ID_FIRSTDDEEDIT+1);
	    bEnabled = IsWindowEnabled(hWndEdit);
	    bCheck = (BOOL)SendMessage(LOWORD(lParam), WM_GETTEXTLENGTH, 0, 0L);
	    if((bCheck && bEnabled) || (!bCheck && !bEnabled))
	       break;

	    wNew = ID_FIRSTDDEEDIT+1-ID_FIRSTACTIONEDIT;
	    if(!IsDlgButtonChecked(hDlg, ID_OPENRADIO))
	       wNew += ID_LASTEDIT-ID_FIRSTACTIONEDIT+1;

	    if(StoreValue(hWndEdit, pLocalVals+wNew))
	       break;
	    SetValue(hDlg, ID_FIRSTDDEEDIT+1, hWndEdit, pLocalVals[wNew],
		  bCheck);
	 }
	 break;

      case IDOK:
       {
         HANDLE hId;
	 HWND hWndName;
         WORD wErrMsg = IDS_INVALIDNAME;
	 WORD wErrCtl = ID_CLASSNAME;

         if(!SendMessage(hWndName=GetDlgItem(hDlg, ID_CLASSNAME),
	       WM_GETTEXTLENGTH, 0, 0L))
	    goto Error1_1;

         wErrMsg = IDS_OUTOFMEMORY;
	 wErrCtl = NULL;
	 /* Update our memory handles for the current action */
         SendMessage(hDlg, WM_COMMAND, ID_SAVEACTION, 0L);

	 /* Get the current class id */
         if(!(hId=GetEditString(GetDlgItem(hDlg, ID_CLASSID))))
            goto Error1_1;

         if((fMode&(FLAG_NEW|FLAG_COPY)) && (wErrMsg=CreateId(hId))) {
	    PSTR pId;

	    MyMessageBox(hDlg, wErrMsg, MB_OK, lstrlen(pId=LocalLock(hId)),
		  (LPSTR)pId);
	    SetFocus(GetDlgItem(hDlg, ID_CLASSID));

	    LocalUnlock(hId);
	    LocalFree(hId);
            break;
	 }

	 /* Merge the data with the given class */
         if(wErrMsg=MergeData(hWndName, hId))
            goto Error1_2;
         EndDialog(hDlg, hId);
         break;

Error1_2:
         LocalFree(hId);
Error1_1:
         MyMessageBox(hDlg, wErrMsg, MB_OK, 0);
	 if(wErrCtl)
	    SetFocus(GetDlgItem(hDlg, wErrCtl));
         break;
       }

      case IDCANCEL:
         EndDialog(hDlg, FALSE);
         break;

      case ID_BROWSE:
       {
         HANDLE hPath, hLocPath;
         LPSTR lpPath;
         HWND hWndEdit, hWndApp;

         wHelpId = IDW_OPENEXE;
         if(!DoFileOpenDlg(hDlg, IDS_BROWSETITLE, IDS_EXES, IDS_CUSTEXES,
               &hCustExes, &hPath, TRUE))
            break;
         lpPath = GlobalLock(hPath);

         hWndApp = GetDlgItem(hDlg, ID_FIRSTDDEEDIT+2);
         if(IsDlgButtonChecked(hDlg, ID_USESDDE) &&
               !SendMessage(hWndApp, WM_GETTEXTLENGTH, 0, 0L) &&
               (hLocPath=StringToLocalHandle(lpPath, LMEM_MOVEABLE))) {
            SendMessage(hWndApp, WM_SETTEXT, 0,
                  (DWORD)((LPSTR)GetAppName(hLocPath)));
            SendMessage(hWndApp, EM_SETMODIFY, 1, 0L);
            LocalFree(hLocPath);
         }
            
         hWndEdit = GetDlgItem(hDlg, ID_COMMAND);
         SendMessage(hWndEdit, WM_SETTEXT, 0, (DWORD)lpPath);
         SendMessage(hWndEdit, EM_SETMODIFY, 1, 0L);

         GlobalUnlock(hPath);
         GlobalFree(hPath);
         break;
       }

      case ID_HELP:
         if(GetParent(LOWORD(lParam)) != hDlg)
            break;
      case ID_HELPBUTTON:
         MyHelp(hDlg, HELP_CONTEXT, IDW_MODIFY+fMode);
         break;

      default:
         break;
      }
      return(FALSE);
      break;

   case WM_INITDIALOG:
    {
      HANDLE hId, hTitle;
      HWND hWndId, hWndName;
      WORD wErrMsg;

      hId = GetListboxString(hWndIds,
            (WORD)SendMessage(hWndNames, LB_GETCURSEL, 0, 0L));

      hWndName = GetDlgItem(hDlg, ID_CLASSNAME);
      if(fMode&FLAG_NEW) {
         if(wErrMsg=GetLocalCopies(hWndName, NULL))
            goto Error2_1;
         cUsesDDE[0] = cUsesDDE[1] = 1;
      } else {
         wErrMsg = IDS_OUTOFMEMORY;
         if(!hId || (wErrMsg=GetLocalCopies(hWndName, hId)))
            goto Error2_1;
      }

      hWndId = GetDlgItem(hDlg, ID_CLASSID);
      SendMessage(hWndId, EM_LIMITTEXT, MAX_KEY_LENGTH-1, 0L);
      if(fMode&(FLAG_NEW|FLAG_COPY)) {
         DestroyWindow(GetDlgItem(hDlg, ID_STATCLASSID));

         wErrMsg = IDS_OUTOFMEMORY;
         if(!(hTitle=MyLoadString(fMode&FLAG_NEW ? IDS_ADD : IDS_COPY, NULL,
               LMEM_MOVEABLE)))
            goto Error2_1;
         SendMessage(hDlg, WM_SETTEXT, 0, (DWORD)((LPSTR)LocalLock(hTitle)));
         LocalUnlock(hTitle);
         LocalFree(hTitle);

         SetFocus(hWndId);
      } else {
         DestroyWindow(hWndId);
         hWndId = GetDlgItem(hDlg, ID_STATCLASSID);
         SetWindowWord(hWndId, GWW_ID, ID_CLASSID);

         SendMessage(hWndId, WM_SETTEXT, 0, (DWORD)((LPSTR)LocalLock(hId)));
         LocalUnlock(hId);

         SetFocus(GetDlgItem(hDlg, ID_CLASSNAME));
      }

      CheckRadioButton(hDlg, ID_OPENRADIO, ID_PRINTRADIO, ID_OPENRADIO);
      SendMessage(hDlg, WM_COMMAND, ID_OPENRADIO, 0L);

      if(hId)
         LocalFree(hId);
      return(FALSE);

Error2_1:
      MyMessageBox(hDlg, wErrMsg, MB_OK, 0);
      PostMessage(hDlg, WM_COMMAND, IDCANCEL, 0L);
      if(hId)
         LocalFree(hId);
      break;
    }

   default:
      return(FALSE);
   }

   return(TRUE);
}


int FAR PASCAL MainWndDlg(HWND hDlg, WORD message, WORD wParam, DWORD lParam)
{
   static int nTop;

   switch(message) {
   case WM_COMMAND:
      switch(wParam) {
      case ID_NAMELIST:
         if(HIWORD(lParam) == LBN_DBLCLK)
            SendMessage(hWndMain, WM_COMMAND, ID_MODIFY, 0L);
         break;

      default:
         break;
      }
      return(FALSE);
      break;

   case WM_SIZE:
    {
      RECT rcList, rcWnd;
      int hgtWnd, hgt;

      hgtWnd = HIWORD(lParam) + 1;
      hgt = hgtWnd - nTop;
      SetWindowPos(hWndNames, NULL, -1, nTop, LOWORD(lParam)+2, hgt,
            SWP_NOZORDER);
      GetWindowRect(hWndNames, &rcList);
      ScreenToClient(hDlg, (POINT *)(&rcList) + 1);
      if(rcList.bottom != hgtWnd) {
         GetWindowRect(hDlg, &rcWnd);
         SetWindowPos(hDlg, NULL, 0, 0, rcWnd.right-rcWnd.left,
               rcWnd.bottom-rcWnd.top-hgtWnd+rcList.bottom,
               SWP_NOMOVE | SWP_NOZORDER);
      }
      break;
    }

   case WM_INITDIALOG:
    {
      RECT rcTemp;

      GetWindowRect(GetDlgItem(hDlg, ID_NAMELIST), &rcTemp);
      ScreenToClient(hDlg, (POINT *)&rcTemp);
      nTop = rcTemp.top;
      break;
    }

   default:
      return(FALSE);
   }

   return(TRUE);
}


long FAR PASCAL MainWnd(HWND hWnd, WORD iMessage, WORD wParam, LONG lParam)
{
   HCURSOR oldCursor;

   switch(iMessage) {
   case WM_ACTIVATE:
      if(wParam)
	 break;
      goto DoDefault;

   case WM_CREATE:
    {
      WORD wErrMsg = IDS_OUTOFMEMORY;

      if(!(lpMainWndDlg=MakeProcInstance(MainWndDlg, hInstance)))
         goto Error1_1;
      if(!(hWndDlg=CreateDialog(hInstance, MAKEINTRESOURCE(MAINWND), hWnd,
            lpMainWndDlg)))
         goto Error1_1;

      hWndNames = GetDlgItem(hWndDlg, ID_NAMELIST);
      hWndIds = GetDlgItem(hWndDlg, ID_IDLIST);

      if(wErrMsg=ResetClassList(hWndIds, hWndNames))
         goto Error1_1;

      ShowWindow(hWndDlg, SW_SHOW);
      goto DoDefault;

Error1_1:
      MyMessageBox(hWnd, wErrMsg, MB_OK, 0);
      DestroyWindow(hWnd);
      break;
    }

   /* Return 1 to say it's OK to close
    */
   case WM_CLOSE:
   case WM_QUERYENDSESSION:
      return(1L);

   case WM_COMMAND:
      oldCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));

      switch(wParam) {
      case ID_FINISHMERGE:
       {
         WORD wErrMsg;

         if(wErrMsg=ResetClassList(hWndIds, hWndNames))
            MyMessageBox(GetLastActivePopup(hWnd), wErrMsg, MB_OK, 0);
         break;
       }

      case ID_ADD:
         fMode = FLAG_NEW;
         goto DoDlg;
      case ID_COPY:
         fMode = FLAG_COPY;
         goto DoDlg;
      case ID_MODIFY:
         fMode = 0;
DoDlg:
       {
         HANDLE hId, hName;
         PSTR pId, pName;
         WORD wErrMsg = IDS_OUTOFMEMORY;
         int nNewId;

         if(!(hId=DoDialogBox(MAKEINTRESOURCE(EDITDLG), hWnd, EditDlg)))
            break;
         if(hId == 0xffff)
            goto Error2_1;

         if(wErrMsg=MyGetClassName(hId, &hName))
            goto Error2_2;

         if(wParam == ID_MODIFY) {
            int nClassId;

            nClassId = (WORD)SendMessage(hWndNames, LB_GETCURSEL, 0, 0L);

            SendMessage(hWndNames, WM_SETREDRAW, 0, 0L);
            SendMessage(hWndNames, LB_DELETESTRING, nClassId, 0L);
            SendMessage(hWndIds, LB_DELETESTRING, nClassId, 0L);
            SendMessage(hWndNames, WM_SETREDRAW, 1, 0L);
         }

         pName = LocalLock(hName);
         pId = LocalLock(hId);

         wErrMsg = IDS_OUTOFMEMORY;
         if((nNewId=(int)SendMessage(hWndNames, LB_ADDSTRING, 0,
               (DWORD)((LPSTR)pName)))!=LB_ERR
               && SendMessage(hWndIds, LB_INSERTSTRING, nNewId,
                  (DWORD)((LPSTR)pId))!=LB_ERR)
            wErrMsg = NULL;
         SendMessage(hWndNames, LB_SETCURSEL, nNewId, 0L);

         LocalUnlock(hId);
         LocalUnlock(hName);
         LocalFree(hName);
Error2_2:
         LocalFree(hId);
Error2_1:
         if(wErrMsg)
            MyMessageBox(hWnd, wErrMsg, MB_OK, 0);
         break;
       }

      case ID_DELETE:
       {
         HANDLE hId, hName;
         WORD wErrMsg = IDS_OUTOFMEMORY;
	 PSTR pName;
         int nClassId;

         if((nClassId=(int)SendMessage(hWndNames, LB_GETCURSEL, 0, 0L))
               == LB_ERR)
            break;
         if(!(hId=GetListboxString(hWndIds, nClassId)))
            goto Error4_1;
         if(!(hName=GetListboxString(hWndNames, nClassId)))
            goto Error4_2;
	 pName = LocalLock(hName);

         wErrMsg = NULL;
         if(MyMessageBox(hWnd, IDS_SUREDELETE, MB_ICONEXCLAMATION | MB_YESNO,
               lstrlen(pName), (LPSTR)pName) != IDYES)
            goto Error4_3;
         if(wErrMsg=DeleteClassId(hId))
            goto Error4_3;

         SendMessage(hWndIds, LB_DELETESTRING, nClassId, 0L);
         SendMessage(hWndNames, LB_DELETESTRING, nClassId, 0L);
         if(SendMessage(hWndNames, LB_SETCURSEL, nClassId, 0L) == LB_ERR)
            SendMessage(hWndNames, LB_SETCURSEL, --nClassId, 0L);

Error4_3:
         LocalUnlock(hName);
         LocalFree(hName);
Error4_2:
         LocalFree(hId);
Error4_1:
         if(wErrMsg)
            MyMessageBox(hWnd, wErrMsg, MB_OK, 0);
         break;
       }

      default:
         break;
      }

      SetCursor(oldCursor);
      break;

   default:
DoDefault:
      return(DefWindowProc(hWnd, iMessage, wParam, lParam));
      break;
   }
   return 0L;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\regedit\regmain.c ===
#define WIN31
#include <windows.h>
#include "RegEdit.h"
#include "SDKRegEd.h"


/*********************************************************/
/******************* Globals *****************************/
/*********************************************************/

char szAppName[] = "Registration Editor" ;
char szSDKRegEd[] = "SDKRegEd";
char *pszLongName;
char *pszOutOfMemory;

extern char szNull[];

HANDLE hInstance;
HWND hWndMain, hWndDlg = NULL, hWndHelp;
LPSTR lpCmdLine;
WORD wCmdFlags, wHelpMenuItem, wHelpId, wHelpMain;
LONG (FAR PASCAL *lpfnEditor)(HWND, WORD, WORD, LONG);
FARPROC lpOldHook;
FARPROC lpMainWndDlg = NULL;
WORD wHelpIndex;
HANDLE hAcc;
BOOL fOpenError = FALSE;


/*********************************************************/
/******************* Functions ***************************/
/*********************************************************/

unsigned long NEAR PASCAL RetSetValue(HKEY hKey, PSTR pSubKey, PSTR pVal)
{
   return(RegSetValue(hKey, pSubKey, REG_SZ, pVal, 0L));
}

#ifndef REGLOAD
unsigned long NEAR PASCAL WriteThroughSetValue(HKEY hKey, PSTR pSubKey,
      PSTR pVal)
{
   long lRet;

   if (!(lRet=RegSetValue(hKey, pSubKey, REG_SZ, pVal, 0L)))
      lRet = SDKSetValue(hKey, pSubKey, pVal);
   return(lRet);
}
#endif

unsigned long (NEAR PASCAL *lpfnSetValue)(HKEY, PSTR, PSTR) = RetSetValue;


unsigned long NEAR PASCAL MySetValue(HKEY hKey, PSTR pSubKey, PSTR pVal)
{
  return((*lpfnSetValue)(hKey, pSubKey, pVal));
}


VOID NEAR PASCAL GetCommandFlags(void)
{
   wCmdFlags = 0;

   while(1) {
/* skip spaces */
      while(*lpCmdLine == ' ')
	 ++lpCmdLine;
/* check if this is a command line switch */
      if(*lpCmdLine!='/' && *lpCmdLine!='-')
	 break;
      ++lpCmdLine;

/* set known flags */
      while(*lpCmdLine && *lpCmdLine!=' ') {
	 switch(*lpCmdLine) {
	 case('s'): /* for silent */
	 case('S'): /* for silent */
	    wCmdFlags |= FLAG_SILENT;
	    break;

	 case('v'): /* use tree editor */
	 case('V'): /* use tree editor */
	    wCmdFlags |= FLAG_VERBOSE;
	    break;

	 case('u'): /* update, don't overwrite existing path entries */
	 case('U'): /* in shell\open\command or shell\open\print */
	    wCmdFlags |= FLAG_LEAVECOMMAND;
	    break;
	 }

	 lpCmdLine = AnsiNext(lpCmdLine);
      }
   }
}


#ifndef REGLOAD
long FAR PASCAL WndProc(HWND hWnd, WORD wMessage, WORD wParam, LONG lParam)
{
   static HANDLE hCustRegs = NULL;

   HCURSOR oldCursor;

   switch(wMessage) {
   case WM_ACTIVATE:
      if(wParam) {
	 hWndHelp = hWnd;
	 SetFocus(hWndDlg);
      }
      break;

   case WM_CREATE:
    {
      RECT rcWnd, rcClt;

      DragAcceptFiles(hWnd, TRUE);

      lpfnEditor(hWnd, wMessage, wParam, lParam);

      if((rcWnd.right=MyGetProfileInt(IDS_SHORTNAME, IDS_WIDTH, 0))<=0 ||
	    (rcWnd.bottom=MyGetProfileInt(IDS_SHORTNAME, IDS_HEIGHT, 0))<=0) {
	 GetWindowRect(hWndDlg, &rcWnd);
	 rcWnd.right -= rcWnd.left;
	 rcWnd.bottom -= rcWnd.top;
      }
      GetClientRect(hWnd, &rcClt);
      rcClt.right -= rcWnd.right;
      rcClt.bottom -= rcWnd.bottom;
      GetWindowRect(hWnd, &rcWnd);

      SetWindowPos(hWnd, NULL, 0, 0, rcWnd.right-rcWnd.left-rcClt.right,
	    rcWnd.bottom-rcWnd.top-rcClt.bottom, SWP_NOMOVE | SWP_NOZORDER);

      return(DefWindowProc(hWnd, wMessage, wParam, lParam));
    }

   case WM_CLOSE:
   case WM_QUERYENDSESSION:
    {
      HKEY hKeyRoot;
      WORD wErrMsg;
      int nReturn;

      if(!fOpenError) {
	 if(!lpfnEditor(hWnd, wMessage, wParam, lParam))
	    return(0L);

	 if(RegOpenKey(HKEY_CLASSES_ROOT, NULL, &hKeyRoot) == ERROR_SUCCESS) {
	    if(wErrMsg=GetErrMsg((WORD)RegCloseKey(hKeyRoot))) {
	       PSTR pError;

	       if(pError=(PSTR)MyLoadString(wErrMsg, NULL, LMEM_FIXED)) {
		  nReturn = MyMessageBox(hWnd, IDS_ENDERROR,
			MB_YESNO|MB_ICONHAND|MB_SYSTEMMODAL, lstrlen(pError),
			(LPSTR)pError);
		  LocalFree((HANDLE)pError);
	       } else
		  /* Notice the flags are ignored for OOM
		   */
		  nReturn = MyMessageBox(hWnd, IDS_OUTOFMEMORY,
			MB_OK|MB_ICONHAND|MB_SYSTEMMODAL, 0);

	       if(nReturn != IDYES)
		  return(0L);
	    }
	 }
      }

      return(DefWindowProc(hWnd, wMessage, wParam, lParam));
    }

   case WM_DESTROY:
      if(hWndDlg)
	 DestroyWindow(hWndDlg);
      if(lpMainWndDlg)
	 FreeProcInstance(lpMainWndDlg);

#ifndef NOHELP
      WinHelp(hWnd, NULL, HELP_QUIT, 0L);
#endif

      DragAcceptFiles(hWnd, FALSE);
      PostQuitMessage(0);
      break;

   case WM_SIZE:
    {
      RECT rcDlg, rcWnd;
      int hgt;

      if(wParam == SIZEICONIC)
	 break;

      if(!hWndDlg) {
	 /* This should only happen during the create message
	  */
	 PostMessage(hWnd, wMessage, wParam, lParam);
	 break;
      }

      if(wParam == SIZENORMAL) {
	 WriteProfileInt(IDS_SHORTNAME, IDS_WIDTH, LOWORD(lParam));
	 WriteProfileInt(IDS_SHORTNAME, IDS_HEIGHT, HIWORD(lParam));
      }

      hgt = HIWORD(lParam);
      SetWindowPos(hWndDlg, NULL, 0, 0, LOWORD(lParam), hgt, SWP_NOZORDER);
      GetWindowRect(hWndDlg, &rcDlg);
      ScreenToClient(hWnd, (POINT *)(&rcDlg) + 1);
      if((WORD)rcDlg.bottom != HIWORD(lParam)) {
	 GetWindowRect(hWnd, &rcWnd);
	 SetWindowPos(hWnd, NULL, 0, 0, rcWnd.right-rcWnd.left,
	       rcWnd.bottom-rcWnd.top-HIWORD(lParam)+rcDlg.bottom,
	       SWP_NOMOVE | SWP_NOZORDER);
      }
      break;
    }

   case WM_DROPFILES:
    {
      int result, i, nFileName;
      HANDLE hFileName;
      WORD wFlags;

      wFlags = (GetKeyState(VK_CONTROL)&0x8000) ? FLAG_SILENT : 0;

      lpfnEditor(hWnd, wMessage, wParam, lParam);

      for(result=DragQueryFile(wParam, (UINT)-1, NULL, 0), i=0; i<result; ++i) {
	 if(!(hFileName=GlobalAlloc(GMEM_MOVEABLE,
	       (DWORD)(nFileName=DragQueryFile(wParam, i, NULL, 0)+1))))
	    continue;
	 DragQueryFile(wParam, i, GlobalLock(hFileName), nFileName);
	 GlobalUnlock(hFileName);
	 SendMessage(hWnd, WM_COMMAND, ID_FINISHMERGE,
	       MAKELONG(hFileName,wFlags));
      }

      DragFinish(wParam);

      return(TRUE);
    }

   case WM_COMMAND:
      oldCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));
      switch(wParam) {
      case ID_HELP:
	 if(HIWORD(lParam)==MSGF_MENU && IsWindowEnabled(hWnd)
	       && wHelpMenuItem) {
	    WORD m = wHelpMenuItem;

/* Get outta menu mode if help for a menu item */
	    SendMessage(hWnd, WM_CANCELMODE, 0, 0L);

	    MyHelp(hWnd, HELP_CONTEXT, m);
	 }
	 break;

      case ID_FINISHMERGE:
       {
     unsigned long (NEAR PASCAL *lpfnSave)(HKEY, PSTR, PSTR);

	 /* If there was a file selected then merge it; otherwise,
	  * just let lpfnEditor do its cleanup (at the end of the switch)
	  */
	 if (LOWORD(lParam)) {
	    lpfnSave = lpfnSetValue;
	    if (HIWORD(lParam)&FLAG_WRITETHROUGH && lpfnSetValue==SDKSetValue)
		lpfnSetValue = WriteThroughSetValue;

	    lpfnEditor(hWnd, WM_COMMAND, ID_MERGEFILE, 0L);

	    ProcessFiles(GetLastActivePopup(hWnd), LOWORD(lParam),
		  HIWORD(lParam));
	    lpfnSetValue = lpfnSave;
	 }
	 break;
       }

      case ID_MERGEFILE:
       {
	 HANDLE hPath;

	 lpfnEditor(hWnd, wMessage, wParam, lParam);

	 wHelpId = IDW_OPENREG;
	 if(!DoFileOpenDlg(hWnd, IDS_MERGETITLE, IDS_REGS, IDS_CUSTREGS,
	       &hCustRegs, &hPath, TRUE))
	    hPath = NULL;
	 SendMessage(hWnd, WM_COMMAND, ID_FINISHMERGE, MAKELONG(hPath, 0));

	 return(TRUE);
       }

      case ID_WRITEFILE:
       {
	 HANDLE hPath;

	 wHelpId = IDW_SAVEREG;
	 if(DoFileOpenDlg(hWnd, IDS_WRITETITLE, IDS_REGS, IDS_CUSTREGS,
	       &hCustRegs, &hPath, FALSE))
	    lParam = (LONG)hPath;
	 else
	    lParam = NULL;
	 break;
       }

      case ID_EXIT:
	 PostMessage(hWnd, WM_CLOSE, 0, 0L);
	 break;

      case ID_HELPINDEX:
	 MyHelp(hWnd, HELP_CONTEXT, wHelpIndex);
	 break;

      case ID_HELPSEARCH:
	 MyHelp(hWnd, HELP_PARTIALKEY, (DWORD)(LPSTR)"");
	 break;

      case ID_HELPUSINGHELP:
	 MyHelp(hWnd, HELP_HELPONHELP, 0);
	 break;

      case ID_ABOUT:
       {
	 HANDLE hShortName, hDesc;

	 if(!(hShortName=MyLoadString(IDS_MEDIUMNAME, NULL, LMEM_MOVEABLE)))
	    goto Error3_1;
	 if(!(hDesc=MyLoadString(IDS_DESCRIPTION, NULL, LMEM_MOVEABLE)))
	    goto Error3_2;

	 ShellAbout(hWnd, LocalLock(hShortName), LocalLock(hDesc),
	       LoadIcon(hInstance, MAKEINTRESOURCE(MAINICON)));

	 LocalUnlock(hDesc);
	 LocalUnlock(hShortName);
	 LocalFree(hDesc);
Error3_2:
	 LocalFree(hShortName);
Error3_1:
	 break;
       }

      default:
	 break;
      }
      SetCursor(oldCursor);
      break;

   case WM_MENUSELECT:
      if(LOWORD(lParam)&MF_POPUP)
	 wHelpMenuItem = 0;
      else if(LOWORD(lParam)&MF_SYSMENU)
	 wHelpMenuItem = IDH_SYSMENU;
      else
	 wHelpMenuItem = wHelpMain+wParam;
      break;

   default:
      break;
   }

   return(lpfnEditor(hWnd, wMessage, wParam, lParam));
}


BOOL NEAR PASCAL CreateMainWindow(void)
{
   WNDCLASS wndclass;

   wndclass.style         = 0;
   wndclass.lpfnWndProc   = (WNDPROC)WndProc;
   wndclass.cbClsExtra    = 0;
   wndclass.cbWndExtra    = 0;
   wndclass.hInstance     = hInstance;
   wndclass.hIcon         = LoadIcon(hInstance, MAKEINTRESOURCE(MAINICON));
   wndclass.hCursor       = LoadCursor(NULL, IDC_ARROW);
   wndclass.hbrBackground = COLOR_APPWORKSPACE + 1;
   wndclass.lpszClassName = szAppName;

   if(wCmdFlags&FLAG_VERBOSE) {
      wndclass.lpszMenuName  = MAKEINTRESOURCE(SDKMAINMENU);
      lpfnEditor = SDKMainWnd;
      lpfnSetValue = SDKSetValue;
      wHelpMain = IDW_SDKMAIN;
      wHelpIndex = IDW_SDKMAIN + 0x0100 + ID_HELPINDEX;
   } else {
      wndclass.lpszMenuName  = MAKEINTRESOURCE(MAINMENU);
      lpfnEditor = MainWnd;
      wHelpMain = IDW_MAIN;
      wHelpIndex = IDW_MAIN + 0x0100 + ID_HELPINDEX;
   }

   return(RegisterClass(&wndclass)
	 && (hWndMain=CreateWindow(szAppName, pszLongName,
	    WS_OVERLAPPEDWINDOW, CW_USEDEFAULT, CW_USEDEFAULT,
	    CW_USEDEFAULT, CW_USEDEFAULT, NULL, NULL, hInstance, NULL)));
}
#endif


int PASCAL WinMain (HANDLE hInst, HANDLE hPrevInstance,
      LPSTR lpszCmdLine, int nCmdShow)
{
   HANDLE hTemp, hCmd = NULL;
#ifndef REGLOAD
   FARPROC lpMessageFilter;
   MSG msg;
   VOID (FAR PASCAL *lpfnRegisterPenApp)(WORD, BOOL) = NULL;
#endif

   hInstance = hInst;

   lpCmdLine = lpszCmdLine;
   GetCommandFlags();

   if(!(hTemp=MyLoadString(IDS_LONGNAME, NULL, LMEM_FIXED)))
      return(FALSE);
   pszLongName = LocalLock(hTemp);
   if(!(hTemp=MyLoadString(IDS_OUTOFMEMORY, NULL, LMEM_FIXED)))
      return(FALSE);
   pszOutOfMemory = LocalLock(hTemp);

   if(*lpCmdLine && !(hCmd=StringToHandle(lpCmdLine)))
      return(FALSE);

#ifdef REGLOAD
   if ((hTemp=GetModuleHandle("REGEDIT")) > 1) {
      PSTR pLocal;
      WORD wFileLen = 130;
      WORD wCmdLen = lstrlen(lpCmdLine) + 1;

      while(1) {
	 if(!(pLocal=(PSTR)LocalAlloc(LMEM_FIXED, wFileLen+wCmdLen))) {
	    MyMessageBox(NULL, IDS_OUTOFMEMORY,
		  MB_OK|MB_ICONHAND|MB_SYSTEMMODAL, 0);
	    return(FALSE);
	 }
	 if(GetModuleFileName(hTemp, pLocal, wFileLen) < (int)wFileLen-5)
	    break;

	 LocalFree((HANDLE)pLocal);
	 wFileLen += 130;
      }

      lstrcat(pLocal, " ");
      lstrcat(pLocal, lpCmdLine);

      return(WinExec(pLocal, SW_SHOWNORMAL) > 32);
   }
#else
   if(hPrevInstance) {
      GetInstanceData(hPrevInstance, (PSTR)&hWndMain, sizeof(hWndMain));
      if(hCmd)
	 PostMessage(hWndMain, WM_COMMAND, ID_FINISHMERGE,
	       MAKELONG(hCmd, wCmdFlags | FLAG_WRITETHROUGH));
      else {
	 SetWindowPos(hWndMain, NULL, 0, 0, 0, 0,
	       SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE);
	 if(IsIconic(hWndMain))
	    ShowWindow(hWndMain, SW_RESTORE);
	 else
	    SetActiveWindow(GetLastActivePopup(hWndMain));
      }
      return(TRUE);
   }
#endif

   if(hCmd) {
      ProcessFiles(NULL, hCmd, wCmdFlags);
      return(TRUE);
   }

#ifdef REGLOAD
   return(TRUE);
#else
   if(!CreateMainWindow())
      return(FALSE);

   if(fOpenError)
      PostMessage(hWndMain, WM_COMMAND, ID_EXIT, 0L);
   else {
      ShowWindow(hWndMain, nCmdShow);
      UpdateWindow(hWndMain);
   }

   if(lpMessageFilter=MakeProcInstance(MessageFilter, hInstance))
      lpOldHook = SetWindowsHook(WH_MSGFILTER, lpMessageFilter);

   hAcc = LoadAccelerators(hInstance, wCmdFlags&FLAG_VERBOSE ?
	 szSDKRegEd : "RegEdit");

   if (lpfnRegisterPenApp = (VOID (FAR PASCAL *)(WORD, BOOL))GetProcAddress(GetSystemMetrics(SM_PENWINDOWS),
	 "RegisterPenApp"))
       (*lpfnRegisterPenApp)(1, TRUE);

   while(GetMessage(&msg, NULL, 0, 0)) {
      if(!hAcc || !TranslateAccelerator(hWndMain, hAcc, &msg)) {
	 if(!hWndDlg || !IsDialogMessage(hWndDlg, &msg)) {
	    TranslateMessage(&msg);
	    DispatchMessage(&msg);
	 }
      }
   }

   if (lpfnRegisterPenApp)
       (*lpfnRegisterPenApp)(1, FALSE);

   if(lpMessageFilter) {
      UnhookWindowsHook(WH_MSGFILTER, lpMessageFilter);
      FreeProcInstance(lpMessageFilter);
   }

   return(msg.wParam);
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\regedit\regporte.c ===
#include <windows.h>
#include <shellapi.h>
#include <stdlib.h>
#include <string.h>
#ifndef CHAR
#define CHAR char
#endif // ifndef CHAR
// from winreg.h:
// HKEY_CLASSES_ROOT already defined
#define HKEY_CURRENT_USER           (( HKEY ) 0x80000001 )
#define HKEY_LOCAL_MACHINE          (( HKEY ) 0x80000002 )
#define HKEY_USERS                  (( HKEY ) 0x80000003 )
#define HKEY_PERFORMANCE_DATA       (( HKEY ) 0x80000004 )
#define HKEY_CURRENT_CONFIG         (( HKEY ) 0x80000005 )
#define HKEY_DYN_DATA               (( HKEY ) 0x80000006 )

#include "regdef.h" // regdef.h from \\guilo\slm\src\dev\inc)

//from pch.h, remove extern
CHAR g_ValueNameBuffer[MAXVALUENAME_LENGTH];
BYTE g_ValueDataBuffer[MAXDATA_LENGTH];

// interface to regmain values
extern LPSTR lpMerge;

#include "reg1632.h"
#include "regporte.h"
#include "regresid.h"


/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1993-1994
*
*  TITLE:       REGPORTE.C
*
*  VERSION:     4.01
*
*  AUTHOR:      Tracy Sharpe
*
*  DATE:        06 Apr 1994
*
*  File import and export engine routines for the Registry Editor.
*
*******************************************************************************/

//#include "pch.h"
//#include "regresid.h"
//#include "reg1632.h"

//  When building for the Registry Editor, put all of the following constants
//  in a read-only data section.
#ifdef WIN32
#pragma data_seg(DATASEG_READONLY)
#endif

//  Association between the ASCII name and the handle of the registry key.
const REGISTRY_ROOT g_RegistryRoots[] = {
    "HKEY_CLASSES_ROOT", HKEY_CLASSES_ROOT,
    "HKEY_CURRENT_USER", HKEY_CURRENT_USER,
    "HKEY_LOCAL_MACHINE", HKEY_LOCAL_MACHINE,
    "HKEY_USERS", HKEY_USERS,
//    "HKEY_PERFORMANCE_DATA", HKEY_PERFORMANCE_DATA,
    "HKEY_CURRENT_CONFIG", HKEY_CURRENT_CONFIG,
    "HKEY_DYN_DATA", HKEY_DYN_DATA
};

const CHAR s_RegistryHeader[] = "REGEDIT";

const CHAR s_OldWin31RegFileRoot[] = ".classes";

const CHAR s_Win40RegFileHeader[] = "REGEDIT4\n\n";

const CHAR s_HexPrefix[] = "hex";
const CHAR s_DwordPrefix[] = "dword:";
const CHAR g_HexConversion[16] = {'0', '1', '2', '3', '4', '5', '6', '7', '8',
    '9', 'a', 'b', 'c', 'd', 'e', 'f'};
const CHAR s_FileLineBreak[] = ",\\\n  ";

#ifdef WIN32
#pragma data_seg()
#endif

#define SIZE_FILE_IO_BUFFER             512

typedef struct _FILE_IO {
    CHAR Buffer[SIZE_FILE_IO_BUFFER];
    FILE_HANDLE hFile;
    int BufferOffset;
    int CurrentColumn;
    int CharsAvailable;
    DWORD FileSizeDiv100;
    DWORD FileOffset;
    UINT LastPercentage;
#ifdef DEBUG
    BOOL fValidateUngetChar;
#endif
}   FILE_IO;

FILE_IO s_FileIo;

UINT g_FileErrorStringID;

VOID
NEAR PASCAL
ImportWin31RegFile(
    VOID
    );

VOID
NEAR PASCAL
ImportWin40RegFile(
    VOID
    );

VOID
NEAR PASCAL
ParseHeader(
    LPHKEY lphKey
    );

VOID
NEAR PASCAL
ParseValuename(
    HKEY hKey
    );

VOID
NEAR PASCAL
ParseDefaultValue(
    HKEY hKey
    );

BOOL
NEAR PASCAL
ParseString(
    LPSTR lpString,
    LPDWORD cbStringData
    );

BOOL
NEAR PASCAL
ParseHexSequence(
    LPBYTE lpHexData,
    LPDWORD lpcbHexData
    );

BOOL
NEAR PASCAL
ParseHexDword(
    LPDWORD lpDword
    );

BOOL
NEAR PASCAL
ParseHexByte(
    LPBYTE lpByte
    );

BOOL
NEAR PASCAL
ParseHexDigit(
    LPBYTE lpDigit
    );

BOOL
NEAR PASCAL
ParseEndOfLine(
    VOID
    );

VOID
NEAR PASCAL
SkipWhitespace(
    VOID
    );

VOID
NEAR PASCAL
SkipPastEndOfLine(
    VOID
    );

BOOL
NEAR PASCAL
GetChar(
    LPCHAR lpChar
    );

VOID
NEAR PASCAL
UngetChar(
    VOID
    );

BOOL
NEAR PASCAL
MatchChar(
    CHAR CharToMatch
    );

BOOL
NEAR PASCAL
IsWhitespace(
    CHAR Char
    );

BOOL
NEAR PASCAL
IsNewLine(
    CHAR Char
    );

VOID
NEAR PASCAL
PutBranch(
    HKEY hKey,
    LPSTR lpKeyName
    );

VOID
NEAR PASCAL
PutLiteral(
    LPCSTR lpString
    );

VOID
NEAR PASCAL
PutString(
    LPCSTR lpString
    );

VOID
NEAR PASCAL
PutBinary(
    CONST BYTE FAR* lpBuffer,
    DWORD Type,
    DWORD cbBytes
    );

VOID
NEAR PASCAL
PutDword(
    DWORD Dword,
    BOOL fLeadingZeroes
    );

VOID
NEAR PASCAL
PutChar(
    CHAR Char
    );

VOID
NEAR PASCAL
FlushIoBuffer(
    VOID
    );

#ifdef DBCS
#ifndef WIN32
LPSTR
NEAR PASCAL
DBCSStrChr(
    LPSTR string,
    CHAR chr
    );

BOOL
NEAR PASCAL
IsDBCSLeadByte(
    BYTE chr
    );
#endif
#endif

/*******************************************************************************
*
*  CreateRegistryKey
*
*  DESCRIPTION:
*     Parses the pFullKeyName string and creates a handle to the registry key.
*
*  PARAMETERS:
*     lphKey, location to store handle to registry key.
*     lpFullKeyName, string of form "HKEY_LOCAL_MACHINE\Subkey1\Subkey2".
*     fCreate, TRUE if key should be created, else FALSE for open only.
*     (returns), ERROR_SUCCESS, no errors occurred, phKey is valid,
*                ERROR_CANTOPEN, registry access error of some form,
*                ERROR_BADKEY, incorrectly formed pFullKeyName.
*
*******************************************************************************/

DWORD
PASCAL
CreateRegistryKey(
    LPHKEY lphKey,
    LPSTR lpFullKeyName,
    BOOL fCreate
    )
{

    LPSTR lpSubKeyName;
    CHAR PrevChar;
    HKEY hRootKey;
    UINT Counter;
    DWORD Result;

    if ((lpSubKeyName = (LPSTR) STRCHR(lpFullKeyName, '\\')) != NULL) {

        PrevChar = *lpSubKeyName;
        *lpSubKeyName++ = '\0';

    }

    CHARUPPERSTRING(lpFullKeyName);

    hRootKey = NULL;

    for (Counter = 0; Counter < NUMBER_REGISTRY_ROOTS; Counter++) {

        if (STRCMP(g_RegistryRoots[Counter].lpKeyName, lpFullKeyName) == 0) {

            hRootKey = g_RegistryRoots[Counter].hKey;
            break;

        }

    }

    if (hRootKey) {

        Result = ERROR_CANTOPEN;

        if (fCreate) {

            if (RegCreateKey(hRootKey, lpSubKeyName, lphKey) == ERROR_SUCCESS)
                Result = ERROR_SUCCESS;

        }

        else {

            if (RegOpenKey(hRootKey, lpSubKeyName, lphKey) == ERROR_SUCCESS)
                Result = ERROR_SUCCESS;

        }

    }

    else
        Result = ERROR_BADKEY;

    if (lpSubKeyName != NULL) {

        lpSubKeyName--;
        *lpSubKeyName = PrevChar;

    }

    return Result;

}

/*******************************************************************************
*
*  ImportRegFile
*
*  DESCRIPTION:
*
*  PARAMETERS:
*     lpFileName, address of name of file to be imported.
*
*******************************************************************************/
#ifdef WIN95
VOID
PASCAL
ImportRegFile(
    LPSTR lpFileName
    )
{

    CHAR Char;
    LPCCH lpHeader;
    BOOL fNewRegistryFile;
#ifdef WIN32
    OFSTRUCT OFStruct;
#endif

    g_FileErrorStringID = IDS_IMPFILEERRSUCCESS;

    if (OPENREADFILE(lpFileName, s_FileIo.hFile)) {

        s_FileIo.FileSizeDiv100 = GETFILESIZE(s_FileIo.hFile) / 100;
        s_FileIo.FileOffset = 0;
        s_FileIo.LastPercentage = 0;

        //
        //  The following will force GetChar to read in the first block of data.
        //

        s_FileIo.BufferOffset = SIZE_FILE_IO_BUFFER;

        SkipWhitespace();

        lpHeader = s_RegistryHeader;

        while (*lpHeader != '\0') {

            if (MatchChar(*lpHeader))
                lpHeader++;

            else
                break;

        }

        if (*lpHeader == '\0') {

            fNewRegistryFile = MatchChar('4');

            SkipWhitespace();

            if (GetChar(&Char) && IsNewLine(Char)) {

                if (fNewRegistryFile)
                    ImportWin40RegFile();

                else
                    ImportWin31RegFile();

            }

        }

        else
            g_FileErrorStringID = IDS_IMPFILEERRFORMATBAD;

        CLOSEFILE(s_FileIo.hFile);

    }

    else
        g_FileErrorStringID = IDS_IMPFILEERRFILEOPEN;

}

/*******************************************************************************
*
*  ImportWin31RegFile
*
*  DESCRIPTION:
*     Imports the contents of a Windows 3.1 style registry file into the
*     registry.
*
*     We scan over the file looking for lines of the following type:
*        HKEY_CLASSES_ROOT\keyname = value_data
*        HKEY_CLASSES_ROOT\keyname =value_data
*        HKEY_CLASSES_ROOT\keyname value_data
*        HKEY_CLASSES_ROOT\keyname                          (null value data)
*
*     In all cases, any number of spaces may follow 'keyname'.  Although we
*     only document the first syntax, the Windows 3.1 Regedit handled all of
*     these formats as valid, so this version will as well (fortunately, it
*     doesn't make the parsing any more complex!).
*
*     Note, we also support replacing HKEY_CLASSES_ROOT with \.classes above
*     which must come from some early releases of Windows.
*
*  PARAMETERS:
*     (none).
*
*******************************************************************************/

VOID
NEAR PASCAL
ImportWin31RegFile(
    VOID
    )
{

    HKEY hKey;
    CHAR Char;
    BOOL fSuccess;
    LPCSTR lpClassesRoot;
    CHAR KeyName[MAXKEYNAME];
    UINT Index;

    //
    //  Keep an open handle to the classes root.  We may prevent some
    //  unneccessary flushing.
    //

    if (RegOpenKey(HKEY_CLASSES_ROOT, NULL, &hKey) != ERROR_SUCCESS) {

        g_FileErrorStringID = IDS_IMPFILEERRREGOPEN;
        return;

    }

    while (TRUE) {

        //
        //  Check for the end of file condition.
        //

        if (!GetChar(&Char))
            break;

        UngetChar();                    //  Not efficient, but works for now.

        //
        //  Match the beginning of the line against one of the two aliases for
        //  HKEY_CLASSES_ROOT.
        //

        if (MatchChar('\\'))
            lpClassesRoot = s_OldWin31RegFileRoot;

        else
            lpClassesRoot = g_RegistryRoots[INDEX_HKEY_CLASSES_ROOT].lpKeyName;

        fSuccess = TRUE;

        while (*lpClassesRoot != '\0') {

            if (!MatchChar(*lpClassesRoot++)) {

                fSuccess = FALSE;
                break;

            }

        }

        //
        //  Make sure that we have a backslash seperating one of the aliases
        //  from the keyname.
        //

        if (fSuccess)
            fSuccess = MatchChar('\\');

        if (fSuccess) {

            //
            //  We've found one of the valid aliases, so read in the keyname.
            //

            //  fSuccess = TRUE;        //  Must be TRUE if we're in this block
            Index = 0;

            while (GetChar(&Char)) {

                if (Char == ' ' || IsNewLine(Char))
                    break;

                //
                //  Make sure that the keyname buffer doesn't overflow.  We must
                //  leave room for a terminating null.
                //

                if (Index >= sizeof(KeyName) - 1) {

                    fSuccess = FALSE;
                    break;

                }

                KeyName[Index++] = Char;

            }

            if (fSuccess) {

                KeyName[Index] = '\0';

                //
                //  Now see if we have a value to assign to this keyname.
                //

                SkipWhitespace();

                if (MatchChar('='))
                    MatchChar(' ');

                //  fSuccess = TRUE;    //  Must be TRUE if we're in this block
                Index = 0;

                while (GetChar(&Char)) {

                    if (IsNewLine(Char))
                        break;

                    //
                    //  Make sure that the value data buffer doesn't overflow.
                    //  Because this is always string data, we must leave room
                    //  for a terminating null.
                    //

                    if (Index >= MAXDATA_LENGTH - 1) {

                        fSuccess = FALSE;
                        break;

                    }

                    g_ValueDataBuffer[Index++] = Char;

                }

                if (fSuccess) {

                    g_ValueDataBuffer[Index] = '\0';

                    if (RegSetValue(hKey, KeyName, REG_SZ, g_ValueDataBuffer,
                        Index) != ERROR_SUCCESS)
                        g_FileErrorStringID = IDS_IMPFILEERRREGSET;

                }

            }

        }

        //
        //  Somewhere along the line, we had a parsing error, so resynchronize
        //  on the next line.
        //

        if (!fSuccess)
            SkipPastEndOfLine();

    }

    RegFlushKey(hKey);
    RegCloseKey(hKey);

}
#endif // ifdef WIN95
/*******************************************************************************
*
*  ImportWin40RegFile
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

VOID
NEAR PASCAL
ImportWin40RegFile(
    VOID
    )
{

    HKEY hLocalMachineKey;
    HKEY hUsersKey;
    HKEY hKey;
    CHAR Char;

    //
    //  Keep open handles for the predefined roots to prevent the registry
    //  library from flushing after every single RegOpenKey/RegCloseKey
    //  operation.
    //

    RegOpenKey(HKEY_LOCAL_MACHINE, NULL, &hLocalMachineKey);
    RegOpenKey(HKEY_USERS, NULL, &hUsersKey);

#ifdef DEBUG
    if (hLocalMachineKey == NULL)
        OutputDebugString("Unable to open HKEY_LOCAL_MACHINE\n\r");
    if (hUsersKey == NULL)
        OutputDebugString("Unable to open HKEY_USERS\n\r");
#endif

    hKey = NULL;

    while (TRUE) {

        SkipWhitespace();

        //
        //  Check for the end of file condition.
        //

        if (!GetChar(&Char))
            break;

        switch (Char) {

            case '[':
                //
                //  If a registry key is currently open, we must close it first.
                //  If ParseHeader happens to fail (for example, no closing
                //  bracket), then hKey will be NULL and any values that we
                //  parse must be ignored.
                //

                if (hKey != NULL) {

                    RegCloseKey(hKey);
                    hKey = NULL;

                }

                ParseHeader(&hKey);

                break;

            case '"':
                //
                //  As noted above, if we don't have an open registry key, then
                //  just skip the line.
                //

                if (hKey != NULL)
                    ParseValuename(hKey);

                else
                    SkipPastEndOfLine();

                break;

            case '@':
                //
                //
                //

                if (hKey != NULL)
                    ParseDefaultValue(hKey);

                else
                    SkipPastEndOfLine();

                break;

            case ';':
                //
                //  This line is a comment so just dump the rest of it.
                //

                SkipPastEndOfLine();

                break;

            default:
                if (IsNewLine(Char))
                    break;

                SkipPastEndOfLine();

                break;

        }

    }

    if (hKey != NULL)
        RegCloseKey(hKey);

    if (hUsersKey != NULL)
        RegCloseKey(hUsersKey);

    if (hLocalMachineKey != NULL)
        RegCloseKey(hLocalMachineKey);

}

/*******************************************************************************
*
*  ParseHeader
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

#define SIZE_FULL_KEYNAME (MAXKEYNAME + 40)

VOID
NEAR PASCAL
ParseHeader(
    LPHKEY lphKey
    )
{

    CHAR FullKeyName[SIZE_FULL_KEYNAME];
    int CurrentIndex;
    int LastRightBracketIndex;
    CHAR Char;

    CurrentIndex = 0;
    LastRightBracketIndex = -1;

    while (GetChar(&Char)) {

        if (IsNewLine(Char))
            break;

        if (Char == ']')
            LastRightBracketIndex = CurrentIndex;

        FullKeyName[CurrentIndex++] = Char;

        if (CurrentIndex == SIZE_FULL_KEYNAME) {

            do {

                if (Char == ']')
                    LastRightBracketIndex = -1;

                if (IsNewLine(Char))
                    break;

            }   while (GetChar(&Char));

            break;

        }

    }

    if (LastRightBracketIndex != -1) {

        FullKeyName[LastRightBracketIndex] = '\0';

        switch (CreateRegistryKey(lphKey, FullKeyName, TRUE)) {

            case ERROR_CANTOPEN:
                g_FileErrorStringID = IDS_IMPFILEERRREGOPEN;
                break;

        }

    }

}

/*******************************************************************************
*
*  ParseValuename
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

VOID
NEAR PASCAL
ParseValuename(
    HKEY hKey
    )
{

    DWORD Type;
    CHAR ValueName[MAXVALUENAME_LENGTH];
    DWORD cbData;
    LPCSTR lpPrefix;

    cbData = sizeof(ValueName);

    if (!ParseString(ValueName, &cbData))
        goto ParseError;

    SkipWhitespace();

    if (!MatchChar('='))
        goto ParseError;

    SkipWhitespace();

    //
    //  REG_SZ.
    //
    //  "ValueName" = "string of text"
    //

    if (MatchChar('"')) {

        //  LATER:  Line continuations for strings?

        cbData = MAXDATA_LENGTH;

        if (!ParseString(g_ValueDataBuffer, &cbData) || !ParseEndOfLine())
            goto ParseError;

        Type = REG_SZ;

    }

    //
    //  REG_DWORD.
    //
    //  "ValueName" = dword: 12345678
    //

    else if (MatchChar(s_DwordPrefix[0])) {

        lpPrefix = &s_DwordPrefix[1];

        while (*lpPrefix != '\0')
            if (!MatchChar(*lpPrefix++))
                goto ParseError;

        SkipWhitespace();

        if (!ParseHexDword((LPDWORD) g_ValueDataBuffer) || !ParseEndOfLine())
            goto ParseError;

        Type = REG_DWORD;
        cbData = sizeof(DWORD);

    }

    //
    //  REG_BINARY and other.
    //
    //  "ValueName" = hex: 00 , 11 , 22
    //  "ValueName" = hex(12345678): 00, 11, 22
    //

    else {

        lpPrefix = s_HexPrefix;

        while (*lpPrefix != '\0')
            if (!MatchChar(*lpPrefix++))
                goto ParseError;

        //
        //  Check if this is a type of registry data that we don't directly
        //  support.  If so, then it's just a dump of hex data of the specified
        //  type.
        //

        if (MatchChar('(')) {

            if (!ParseHexDword(&Type) || !MatchChar(')'))
                goto ParseError;

        }

        else
            Type = REG_BINARY;

        if (!MatchChar(':') || !ParseHexSequence(g_ValueDataBuffer, &cbData) ||
            !ParseEndOfLine())
            goto ParseError;

    }

    if (RegSetValueEx(hKey, ValueName, 0, Type, g_ValueDataBuffer, cbData) !=
        ERROR_SUCCESS)
        g_FileErrorStringID = IDS_IMPFILEERRREGSET;

    return;

ParseError:
    SkipPastEndOfLine();

}

/*******************************************************************************
*
*  ParseDefaultValue
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

VOID
NEAR PASCAL
ParseDefaultValue(
    HKEY hKey
    )
{

    BOOL fSuccess;
    DWORD cbData;

    fSuccess = FALSE;

    SkipWhitespace();

    if (MatchChar('=')) {

        SkipWhitespace();

        if (MatchChar('"')) {

            //  LATER:  Line continuations for strings?

            cbData = MAXDATA_LENGTH;

            if (ParseString(g_ValueDataBuffer, &cbData) && ParseEndOfLine()) {

                if (RegSetValue(hKey, NULL, REG_SZ, g_ValueDataBuffer,
                    cbData) != ERROR_SUCCESS)
                    g_FileErrorStringID = IDS_IMPFILEERRREGSET;

                fSuccess = TRUE;

            }

        }

    }

    if (!fSuccess)
        SkipPastEndOfLine();

}

/*******************************************************************************
*
*  ParseString
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

BOOL
NEAR PASCAL
ParseString(
    LPSTR lpString,
    LPDWORD lpcbStringData
    )
{

    CHAR Char;
    DWORD cbMaxStringData;
    DWORD cbStringData;

    cbMaxStringData = *lpcbStringData;
    cbStringData = 1;                   //  Account for the null terminator

    while (GetChar(&Char)) {

        if (cbStringData >= cbMaxStringData)
            return FALSE;

        switch (Char) {

            case '\\':
                if (!GetChar(&Char))
                    return FALSE;

                switch (Char) {

                    case '\\':
                        *lpString++ = '\\';
                        break;

                    case '"':
                        *lpString++ = '"';
                        break;

                    default:
                        OutputDebugString("ParseString:  Invalid escape sequence");
                        return FALSE;

                }
                break;

            case '"':
                *lpString = '\0';
                *lpcbStringData = cbStringData;
                return TRUE;

            default:
                if (IsNewLine(Char))
                    return FALSE;

                *lpString++ = Char;

#ifdef DBCS
		if (IsDBCSLeadByte((BYTE)Char))
		{
		    if (!GetChar(&Char))
			return FALSE;
		    *lpString++ = Char;
		}
#endif

                break;

        }

        cbStringData++;

    }

    return FALSE;

}

/*******************************************************************************
*
*  ParseHexSequence
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

BOOL
NEAR PASCAL
ParseHexSequence(
    LPBYTE lpHexData,
    LPDWORD lpcbHexData
    )
{

    DWORD cbHexData;

    cbHexData = 0;

    do {

        if (cbHexData >= MAXDATA_LENGTH)
            return FALSE;

        SkipWhitespace();

        if (MatchChar('\\') && !ParseEndOfLine())
            return FALSE;

        SkipWhitespace();

        if (!ParseHexByte(lpHexData++))
            break;

        cbHexData++;

        SkipWhitespace();

    }   while (MatchChar(','));

    *lpcbHexData = cbHexData;

    return TRUE;

}

/*******************************************************************************
*
*  ParseHexDword
*
*  DESCRIPTION:
*     Parses a one dword hexadecimal string from the registry file stream and
*     converts it to a binary number.  A maximum of eight hex digits will be
*     parsed from the stream.
*
*  PARAMETERS:
*     lpByte, location to store binary number.
*     (returns), TRUE if a hexadecimal dword was parsed, else FALSE.
*
*******************************************************************************/

BOOL
NEAR PASCAL
ParseHexDword(
    LPDWORD lpDword
    )
{

    UINT CountDigits;
    DWORD Dword;
    BYTE Byte;

    Dword = 0;
    CountDigits = 0;

    while (TRUE) {

        if (!ParseHexDigit(&Byte))
            break;

        Dword = (Dword << 4) + (DWORD) Byte;

        if (++CountDigits == 8)
            break;

    }

    *lpDword = Dword;

    return CountDigits != 0;

}

/*******************************************************************************
*
*  ParseHexByte
*
*  DESCRIPTION:
*     Parses a one byte hexadecimal string from the registry file stream and
*     converts it to a binary number.
*
*  PARAMETERS:
*     lpByte, location to store binary number.
*     (returns), TRUE if a hexadecimal byte was parsed, else FALSE.
*
*******************************************************************************/

BOOL
NEAR PASCAL
ParseHexByte(
    LPBYTE lpByte
    )
{

    BYTE SecondDigit;

    if (ParseHexDigit(lpByte)) {

        if (ParseHexDigit(&SecondDigit))
            *lpByte = (BYTE) ((*lpByte << 4) | SecondDigit);

        return TRUE;

    }

    else
        return FALSE;

}

/*******************************************************************************
*
*  ParseHexDigit
*
*  DESCRIPTION:
*     Parses a hexadecimal character from the registry file stream and converts
*     it to a binary number.
*
*  PARAMETERS:
*     lpDigit, location to store binary number.
*     (returns), TRUE if a hexadecimal digit was parsed, else FALSE.
*
*******************************************************************************/

BOOL
NEAR PASCAL
ParseHexDigit(
    LPBYTE lpDigit
    )
{

    CHAR Char;
    BYTE Digit;

    if (GetChar(&Char)) {

        if (Char >= '0' && Char <= '9')
            Digit = (BYTE) (Char - '0');

        else if (Char >= 'a' && Char <= 'f')
            Digit = (BYTE) (Char - 'a' + 10);

        else if (Char >= 'A' && Char <= 'F')
            Digit = (BYTE) (Char - 'A' + 10);

        else {

            UngetChar();

            return FALSE;

        }

        *lpDigit = Digit;

        return TRUE;

    }

    return FALSE;

}

/*******************************************************************************
*
*  ParseEndOfLine
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

BOOL
NEAR PASCAL
ParseEndOfLine(
    VOID
    )
{

    CHAR Char;
    BOOL fComment;
    BOOL fFoundOneEndOfLine;

    fComment = FALSE;
    fFoundOneEndOfLine = FALSE;

    while (GetChar(&Char)) {

        if (IsWhitespace(Char))
            continue;

        if (IsNewLine(Char)) {

            fComment = FALSE;
            fFoundOneEndOfLine = TRUE;

        }

        //
        //  Like .INIs and .INFs, comments begin with a semicolon character.
        //

        else if (Char == ';')
            fComment = TRUE;

        else if (!fComment) {

            UngetChar();

            break;

        }

    }

    return fFoundOneEndOfLine;

}

/*******************************************************************************
*
*  SkipWhitespace
*
*  DESCRIPTION:
*     Advances the registry file pointer to the first character past any
*     detected whitespace.
*
*  PARAMETERS:
*     (none).
*
*******************************************************************************/

VOID
NEAR PASCAL
SkipWhitespace(
    VOID
    )
{

    CHAR Char;

    while (GetChar(&Char)) {

        if (!IsWhitespace(Char)) {

            UngetChar();
            break;

        }

    }

}

/*******************************************************************************
*
*  SkipPastEndOfLine
*
*  DESCRIPTION:
*     Advances the registry file pointer to the first character past the first
*     detected new line character.
*
*  PARAMETERS:
*     (none).
*
*******************************************************************************/

VOID
NEAR PASCAL
SkipPastEndOfLine(
    VOID
    )
{

    CHAR Char;

    while (GetChar(&Char)) {

        if (IsNewLine(Char))
            break;

    }

    while (GetChar(&Char)) {

        if (!IsNewLine(Char)) {

            UngetChar();
            break;

        }

    }

}

/*******************************************************************************
*
*  GetChar
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

BOOL
NEAR PASCAL
GetChar(
    LPCHAR lpChar
    )
{
#ifdef WIN95

    FILE_NUMBYTES NumberOfBytesRead;
    UINT NewPercentage;

    if (s_FileIo.BufferOffset == SIZE_FILE_IO_BUFFER) {

        if (!READFILE(s_FileIo.hFile, s_FileIo.Buffer,
            sizeof(s_FileIo.Buffer), &NumberOfBytesRead)) {

            g_FileErrorStringID = IDS_IMPFILEERRFILEREAD;
            return FALSE;

        }

        s_FileIo.BufferOffset = 0;
        s_FileIo.CharsAvailable = ((int) NumberOfBytesRead);

        s_FileIo.FileOffset += NumberOfBytesRead;

        if (s_FileIo.FileSizeDiv100 != 0) {

            NewPercentage = ((UINT) (s_FileIo.FileOffset /
                s_FileIo.FileSizeDiv100));

            if (NewPercentage > 100)
                NewPercentage = 100;

        }

        else
            NewPercentage = 100;

        if (s_FileIo.LastPercentage != NewPercentage) {

            s_FileIo.LastPercentage = NewPercentage;
            ImportRegFileUICallback(NewPercentage);

        }

    }

    if (s_FileIo.BufferOffset >= s_FileIo.CharsAvailable)
        return FALSE;

    *lpChar = s_FileIo.Buffer[s_FileIo.BufferOffset++];

    return TRUE;
#else
    if (*lpMerge) {
      *lpChar=*lpMerge++;
      return TRUE;
    } else
      return FALSE;
#endif // ifdef WIN95

}

/*******************************************************************************
*
*  UngetChar
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

VOID
NEAR PASCAL
UngetChar(
    VOID
    )
{
#ifdef WIN95
#ifdef DEBUG
    if (s_FileIo.fValidateUngetChar)
        OutputDebugString("REGEDIT ERROR: Too many UngetChar's called!\n\r");
#endif // ifdef DEBUG

    s_FileIo.BufferOffset--;
#else
    lpMerge--;
#endif // ifdef WIN95

}

/*******************************************************************************
*
*  MatchChar
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

BOOL
NEAR PASCAL
MatchChar(
    CHAR CharToMatch
    )
{

    BOOL fMatch;
    CHAR NextChar;

    fMatch = FALSE;

    if (GetChar(&NextChar)) {

        if (CharToMatch == NextChar)
            fMatch = TRUE;

        else
            UngetChar();

    }

    return fMatch;

}

/*******************************************************************************
*
*  IsWhitespace
*
*  DESCRIPTION:
*     Checks if the given character is whitespace.
*
*  PARAMETERS:
*     Char, character to check.
*     (returns), TRUE if character is whitespace, else FALSE.
*
*******************************************************************************/

BOOL
NEAR PASCAL
IsWhitespace(
    CHAR Char
    )
{

    return Char == ' ' || Char == '\t';

}

/*******************************************************************************
*
*  IsNewLine
*
*  DESCRIPTION:
*     Checks if the given character is a new line character.
*
*  PARAMETERS:
*     Char, character to check.
*     (returns), TRUE if character is a new line, else FALSE.
*
*******************************************************************************/

BOOL
NEAR PASCAL
IsNewLine(
    CHAR Char
    )
{

    return Char == '\n' || Char == '\r';

}
#ifdef WIN95
/*******************************************************************************
*
*  ExportWin40RegFile
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

VOID
PASCAL
ExportWin40RegFile(
    LPSTR lpFileName,
    LPSTR lpSelectedPath
    )
{

    HKEY hKey;
    CHAR SelectedPath[SIZE_SELECTED_PATH];

    g_FileErrorStringID = IDS_EXPFILEERRSUCCESS;

    if (lpSelectedPath != NULL && CreateRegistryKey(&hKey, lpSelectedPath,
        FALSE) != ERROR_SUCCESS) {

        g_FileErrorStringID = IDS_EXPFILEERRBADREGPATH;
        return;

    }

    if (OPENWRITEFILE(lpFileName, s_FileIo.hFile)) {

        s_FileIo.BufferOffset = 0;
        s_FileIo.CurrentColumn = 0;

        PutLiteral(s_Win40RegFileHeader);

        if (lpSelectedPath != NULL) {

            STRCPY(SelectedPath, lpSelectedPath);
            PutBranch(hKey, SelectedPath);

        }

        else {

            STRCPY(SelectedPath,
                g_RegistryRoots[INDEX_HKEY_LOCAL_MACHINE].lpKeyName);
            PutBranch(HKEY_LOCAL_MACHINE, SelectedPath);

            STRCPY(SelectedPath,
                g_RegistryRoots[INDEX_HKEY_USERS].lpKeyName);
            PutBranch(HKEY_USERS, SelectedPath);

        }

        FlushIoBuffer();

        CLOSEFILE(s_FileIo.hFile);

    }

    else
        g_FileErrorStringID = IDS_EXPFILEERRFILEOPEN;

    if (lpSelectedPath != NULL)
        RegCloseKey(hKey);

}

/*******************************************************************************
*
*  PutBranch
*
*  DESCRIPTION:
*     Writes out all of the value names and their data and recursively calls
*     this routine for all of the key's subkeys to the registry file stream.
*
*  PARAMETERS:
*     hKey, registry key to write to file.
*     lpFullKeyName, string that gives the full path, including the root key
*        name, of the hKey.
*
*******************************************************************************/

VOID
NEAR PASCAL
PutBranch(
    HKEY hKey,
    LPSTR lpFullKeyName
    )
{

    LONG RegError;
    DWORD EnumIndex;
    DWORD cbValueName;
    DWORD cbValueData;
    DWORD Type;
    LPSTR lpSubKeyName;
    int MaximumSubKeyLength;
    HKEY hSubKey;

    //
    //  Write out the section header.
    //

    PutChar('[');
    PutLiteral(lpFullKeyName);
    PutLiteral("]\n");

    //
    //  Write out all of the value names and their data.
    //

    EnumIndex = 0;

    while (TRUE) {

        cbValueName = sizeof(g_ValueNameBuffer);
        cbValueData = MAXDATA_LENGTH;

        if ((RegError = RegEnumValue(hKey, EnumIndex++, g_ValueNameBuffer,
            &cbValueName, NULL, &Type, g_ValueDataBuffer, &cbValueData))
            != ERROR_SUCCESS)
            break;

        //
        //  If cbValueName is zero, then this is the default value of
        //  the key, or the Windows 3.1 compatible key value.
        //

        if (cbValueName)
            PutString(g_ValueNameBuffer);

        else
            PutChar('@');

        PutChar('=');

        switch (Type) {

            case REG_SZ:
                PutString((LPSTR) g_ValueDataBuffer);
                break;

            case REG_DWORD:
                if (cbValueData == sizeof(DWORD)) {

                    PutLiteral(s_DwordPrefix);
                    PutDword(*((LPDWORD) g_ValueDataBuffer), TRUE);
                    break;

                }
                //  FALL THROUGH

            case REG_BINARY:
            default:
                PutBinary((LPBYTE) g_ValueDataBuffer, Type, cbValueData);
                break;

        }

        PutChar('\n');

        if (g_FileErrorStringID == IDS_EXPFILEERRFILEWRITE)
            return;

    }

    PutChar('\n');

    if (RegError != ERROR_NO_MORE_ITEMS)
        g_FileErrorStringID = IDS_EXPFILEERRREGENUM;

    //
    //  Write out all of the subkeys and recurse into them.
    //

    lpSubKeyName = lpFullKeyName + STRLEN(lpFullKeyName);
    *lpSubKeyName++ = '\\';
    MaximumSubKeyLength = MAXKEYNAME - STRLEN(lpSubKeyName);

    EnumIndex = 0;

    while (TRUE) {

        if ((RegError = RegEnumKey(hKey, EnumIndex++, lpSubKeyName,
            MaximumSubKeyLength)) != ERROR_SUCCESS)
            break;

        if (RegOpenKey(hKey, lpSubKeyName, &hSubKey) == ERROR_SUCCESS) {

            PutBranch(hSubKey, lpFullKeyName);

            RegCloseKey(hSubKey);

            if (g_FileErrorStringID == IDS_EXPFILEERRFILEWRITE)
                return;

        }

        else
            g_FileErrorStringID = IDS_EXPFILEERRREGOPEN;

    }

    if (RegError != ERROR_NO_MORE_ITEMS)
        g_FileErrorStringID = IDS_EXPFILEERRREGENUM;

}

/*******************************************************************************
*
*  PutLiteral
*
*  DESCRIPTION:
*     Writes a literal string to the registry file stream.  No special handling
*     is done for the string-- it is written out as is.
*
*  PARAMETERS:
*     lpLiteral, null-terminated literal to write to file.
*
*******************************************************************************/

VOID
NEAR PASCAL
PutLiteral(
    LPCSTR lpLiteral
    )
{

    while (*lpLiteral != '\0')
        PutChar(*lpLiteral++);

}

/*******************************************************************************
*
*  PutString
*
*  DESCRIPTION:
*     Writes a string to the registry file stream.  A string is surrounded by
*     double quotes and some characters may be translated to escape sequences
*     to enable a parser to read the string back in.
*
*  PARAMETERS:
*     lpString, null-terminated string to write to file.
*
*******************************************************************************/

VOID
NEAR PASCAL
PutString(
    LPCSTR lpString
    )
{

    CHAR Char;

    PutChar('"');

    while ((Char = *lpString++) != '\0') {

        switch (Char) {

            case '\\':
            case '"':
                PutChar('\\');
                //  FALL THROUGH

            default:
                PutChar(Char);
#ifdef DBCS
		if (IsDBCSLeadByte((BYTE)Char))
			PutChar(*lpString++);
#endif
                break;

        }

    }

    PutChar('"');

}

/*******************************************************************************
*
*  PutBinary
*
*  DESCRIPTION:
*     Writes a sequence of hexadecimal bytes to the registry file stream.  The
*     output is formatted such that it doesn't exceed a defined line length.
*
*  PARAMETERS:
*     lpBuffer, bytes to write to file.
*     Type, value data type.
*     cbBytes, number of bytes to write.
*
*******************************************************************************/

VOID
NEAR PASCAL
PutBinary(
    CONST BYTE FAR* lpBuffer,
    DWORD Type,
    DWORD cbBytes
    )
{

    BOOL fFirstByteOnLine;
    BYTE Byte;

    PutLiteral(s_HexPrefix);

    if (Type != REG_BINARY) {

        PutChar('(');
        PutDword(Type, FALSE);
        PutChar(')');

    }

    PutChar(':');

    fFirstByteOnLine = TRUE;

    while (cbBytes--) {

        if (s_FileIo.CurrentColumn > 75) {

            PutLiteral(s_FileLineBreak);

            fFirstByteOnLine = TRUE;

        }

        if (!fFirstByteOnLine)
            PutChar(',');

        Byte = *lpBuffer++;

        PutChar(g_HexConversion[Byte >> 4]);
        PutChar(g_HexConversion[Byte & 0x0F]);

        fFirstByteOnLine = FALSE;

    }

}

/*******************************************************************************
*
*  PutChar
*
*  DESCRIPTION:
*     Writes a 32-bit word to the registry file stream.
*
*  PARAMETERS:
*     Dword, dword to write to file.
*
*******************************************************************************/

VOID
NEAR PASCAL
PutDword(
    DWORD Dword,
    BOOL fLeadingZeroes
    )
{

    int CurrentNibble;
    CHAR Char;
    BOOL fWroteNonleadingChar;

    fWroteNonleadingChar = fLeadingZeroes;

    for (CurrentNibble = 7; CurrentNibble >= 0; CurrentNibble--) {

        Char = g_HexConversion[(Dword >> (CurrentNibble * 4)) & 0x0F];

        if (fWroteNonleadingChar || Char != '0') {

            PutChar(Char);
            fWroteNonleadingChar = TRUE;

        }

    }

    //
    //  We need to write at least one character, so if we haven't written
    //  anything yet, just spit out one zero.
    //

    if (!fWroteNonleadingChar)
        PutChar('0');

}

/*******************************************************************************
*
*  PutChar
*
*  DESCRIPTION:
*     Writes one character to the registry file stream using an intermediate
*     buffer.
*
*  PARAMETERS:
*     Char, character to write to file.
*
*******************************************************************************/

VOID
NEAR PASCAL
PutChar(
    CHAR Char
    )
{

    //
    //  Keep track of what column we're currently at.  This is useful in cases
    //  such as writing a large binary registry record.  Instead of writing one
    //  very long line, the other Put* routines can break up their output.
    //

    if (Char != '\n')
        s_FileIo.CurrentColumn++;

    else {

        //
        //  Force a carriage-return, line-feed sequence to keep things like, oh,
        //  Notepad happy.
        //

        PutChar('\r');

        s_FileIo.CurrentColumn = 0;

    }

    s_FileIo.Buffer[s_FileIo.BufferOffset++] = Char;

    if (s_FileIo.BufferOffset == SIZE_FILE_IO_BUFFER)
        FlushIoBuffer();

}

/*******************************************************************************
*
*  FlushIoBuffer
*
*  DESCRIPTION:
*     Flushes the contents of the registry file stream to the disk and resets
*     the buffer pointer.
*
*  PARAMETERS:
*     (none).
*
*******************************************************************************/

VOID
NEAR PASCAL
FlushIoBuffer(
    VOID
    )
{

    FILE_NUMBYTES NumberOfBytesWritten;

    if (s_FileIo.BufferOffset) {

        if (!WRITEFILE(s_FileIo.hFile, s_FileIo.Buffer, s_FileIo.BufferOffset,
            &NumberOfBytesWritten) || (FILE_NUMBYTES) s_FileIo.BufferOffset !=
            NumberOfBytesWritten)
            g_FileErrorStringID = IDS_EXPFILEERRFILEWRITE;

    }

    s_FileIo.BufferOffset = 0;

}
#endif // ifdef WIN95
#ifndef WIN32
/*******************************************************************************
*
*  GetFileSize
*
*  DESCRIPTION:
*     Returns the file size for the given file handle.
*
*     DESTRUCTIVE:  After this call, the file pointer will be set to byte zero.
*
*  PARAMETERS:
*     hFile, file handle opened via MS-DOS.
*     (returns), size of file.
*
*******************************************************************************/

DWORD
NEAR PASCAL
GetFileSize(
    FILE_HANDLE hFile
    )
{

    DWORD FileSize;

    FileSize = _llseek(hFile, 0, SEEK_END);
    _llseek(hFile, 0, SEEK_SET);

    return FileSize;

}
#endif

#ifdef DBCS
#ifndef WIN32
/*******************************************************************************
*
*  DBCSSTRCHR
*
*  DESCRIPTION:
*     DBCS enabled STRCHR
*
*******************************************************************************/

LPSTR
NEAR PASCAL
DBCSStrChr(
    LPSTR string,
    CHAR chr
    )
{
    LPSTR p;

    p = string;
    while (*p)
    {
	if (IsDBCSLeadByte((BYTE)*p))
	{
	    p++;
	    if (*p == 0)
		break;
	}
	else if (*p == chr)
	    return (p);
	p++;
    }
    if (*p == chr)
	return (p);
    return NULL;
}

/*******************************************************************************
*
*  IsDBCSLeadByte
*
*  DESCRIPTION:
*     Test if the character is DBCS lead byte
*
*******************************************************************************/

BOOL
NEAR PASCAL
IsDBCSLeadByte(
    BYTE chr
    )
{
    static unsigned char far *DBCSLeadByteTable = NULL;

    WORD off,segs;
    LPSTR p;

    if (DBCSLeadByteTable == NULL)
    {
        _asm {
            push ds
            mov ax,6300h
            int 21h
            mov off,si
            mov segs,ds
            pop ds
        }
        FP_OFF(DBCSLeadByteTable) = off;
        FP_SEG(DBCSLeadByteTable) = segs;
    }

    p = DBCSLeadByteTable;
    while (p[0] || p[1])
    {
        if (chr >= p[0] && chr <= p[1])
            return TRUE;
        p += 2;
    }
    return FALSE;
}
#endif    // WIN32
#endif    // DBCS
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\regedit\sources.inc ===
TARGETNAME=
TARGETTYPE=NOTARGET
TARGETPATH=
SOURCES=

NTTARGETFILE1=buildall

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\regedit\regthunk.c ===
/*
 RegThunk.c

 Created by Lee Hart, 4/27/95

 Purpose: Generic Thunks to Win32 Registry APIs that are not
 supported in Win16

*/

#include <windows.h>
#include <shellapi.h>
#include <wownt16.h>

#ifndef CHAR
#define CHAR char
#endif // ifndef CHAR

#include "regporte.h"

LONG RegSetValueEx(
    HKEY             hKey,        // handle of key to set value for
    LPCSTR           lpValueName, // address of value to set
    DWORD            Reserved,    // reserved
    DWORD            dwType,      // flag for value type
    CONST BYTE FAR * lpData,      // address of value data
    DWORD            cbData       // size of value data
   )
{
 DWORD hAdvApi32=LoadLibraryEx32W("ADVAPI32.DLL", NULL, 0);
 DWORD pFn;
 DWORD dwResult = ERROR_ACCESS_DENIED; //random error if fail

 if ((DWORD)0!=hAdvApi32)
  {
   pFn=GetProcAddress32W(hAdvApi32, "RegSetValueExA"); // call ANSI version
   if ((DWORD)0!=pFn)
    {
     dwResult=CallProcEx32W( CPEX_DEST_STDCALL | 6, 0x12, pFn, hKey, lpValueName, Reserved, dwType, lpData, cbData );
    }
  }
 if (hAdvApi32) FreeLibrary32W(hAdvApi32);
 return(dwResult);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\regedit\regporte.h ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1993-1994
*
*  TITLE:       REGPORTE.H
*
*  VERSION:     4.01
*
*  AUTHOR:      Tracy Sharpe
*
*  DATE:        06 Apr 1994
*
*  File import and export engine routines for the Registry Editor.
*
*******************************************************************************/

#ifndef _INC_REGPORTE
#define _INC_REGPORTE

#ifndef LPHKEY
#define LPHKEY                          HKEY FAR*
#endif

typedef struct _REGISTRY_ROOT {
    LPSTR lpKeyName;
    HKEY hKey;
}   REGISTRY_ROOT;

#define INDEX_HKEY_CLASSES_ROOT         0
#define INDEX_HKEY_CURRENT_USER         1
#define INDEX_HKEY_LOCAL_MACHINE        2
#define INDEX_HKEY_USERS                3
//  #define INDEX_HKEY_PERFORMANCE_DATA     4
#define INDEX_HKEY_CURRENT_CONFIG       5
#define INDEX_HKEY_DYN_DATA             6

//  #define NUMBER_REGISTRY_ROOTS           7
#define NUMBER_REGISTRY_ROOTS           6

//  This is supposed to be enough for one keyname plus one predefined
//  handle name.  The longest predefined handle name is < 25 characters, so
//  this gives us room for growth should more predefined keys be added.

#define SIZE_SELECTED_PATH              (MAXKEYNAME + 40)

extern const CHAR g_HexConversion[];

extern UINT g_FileErrorStringID;

DWORD
PASCAL
CreateRegistryKey(
    LPHKEY lphKey,
    LPSTR lpFullKeyName,
    BOOL fCreate
    );

VOID
PASCAL
ImportRegFile(
    LPSTR lpFileName
    );

VOID
PASCAL
ExportWin40RegFile(
    LPSTR lpFileName,
    LPSTR lpSelectedPath
    );

VOID
PASCAL
ImportRegFileUICallback(
    UINT Percentage
    );

LONG RegSetValueEx(
    HKEY             hKey,        // handle of key to set value for
    LPCSTR           lpValueName, // address of value to set
    DWORD            Reserved,    // reserved
    DWORD            dwType,      // flag for value type
    CONST BYTE FAR * lpData,      // address of value data
    DWORD            cbData       // size of value data
   );

#endif // _INC_REGPORTE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\regedit\usa\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH)
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\regedit\sdkreged.c ===
#define WIN31
#include <windows.h>
#include "SDKRegEd.h"

#define RONSPACE 3
#define misParam ((MEASUREITEMSTRUCT FAR *)lParam)
#define disParam ((DRAWITEMSTRUCT FAR *)lParam)

extern char szNull[];
extern char szSDKRegEd[];

static char szEquals[] = " = ";

static WORD wKey=0;
static HANDLE hSearchString = NULL;

static BOOL bDoUpdate = TRUE;

static HWND hStat1, hEdit1, hEdit2;

extern BOOL bChangesMade;
extern HWND hWndIds;
extern HANDLE hAcc;
extern BOOL fOpenError;

#pragma warning(4:4146)     // unary minus operator applied to unsigned type, result still unsigned


VOID NEAR PASCAL MySetSel(HWND hWndList, int index)
{
   if (!bDoUpdate)
       return;

   if(index == -2)
      index = (int)SendMessage(hWndList, LB_GETCURSEL, 0, 0L);
   else
      SendMessage(hWndList, LB_SETCURSEL, index, 0L);

   SendMessage(GetParent(hWndList), WM_COMMAND, GetWindowWord(hWndList, GWW_ID),
         MAKELONG(hWndList, LBN_SELCHANGE));
}

int FAR PASCAL SDKMainWndDlg(HWND hDlg, WORD message, WORD wParam, DWORD lParam)
{
   static int xSpace;
   static int nTop, nLeft, nValHgt, nPthHgt;

   switch(message) {
   case WM_COMMAND:
      switch(wParam) {
      case IDCANCEL:
	 SendDlgItemMessage(hDlg, ID_VALUE, EM_SETMODIFY, 0, 0L);
	 goto NewSelection;

      case ID_VALUE:
	 if (HIWORD(lParam) == EN_KILLFOCUS) {
	    hAcc = LoadAccelerators(hInstance, szSDKRegEd);
	    goto NewSelection;
	 } else if (HIWORD(lParam) == EN_SETFOCUS)
	    hAcc = LoadAccelerators(hInstance, "SDKRegEdVal");
	 break;

      case ID_IDLIST:
         if(HIWORD(lParam) == LBN_SELCHANGE) {
            HANDLE hTmp;
            HWND hWndTmp;
	    WORD wErrMsg, wNewKey;

NewSelection:
            wNewKey = (WORD)SendMessage(hWndIds, LB_GETCURSEL, 0, 0L);

            hWndTmp = GetDlgItem(hDlg, ID_VALUE);
	    if (SendMessage(hWndTmp, EM_GETMODIFY, 0, 0L)) {
	       SendMessage(hWndTmp, EM_SETMODIFY, 0, 0L);
	       bDoUpdate = FALSE;

	       wErrMsg = IDS_OUTOFMEMORY;
	       if(hEdit1 = GetEditString(hWndTmp)) {
		  wErrMsg = GetErrMsg((WORD)SDKSetValue(-wKey, szNull,
			LocalLock(hEdit1)));
		  LocalUnlock(hEdit1);
	       }

	       if(wErrMsg) {
		  MyMessageBox(hWndMain, wErrMsg, MB_OK, 0);
		  break;
	       }
	       bDoUpdate = TRUE;

	       InvalidateRect(hWndIds, NULL, TRUE);
	    }
	
            if((wKey=wNewKey)!=(WORD)SendMessage(hWndIds, LB_GETCURSEL, 0, 0L))
               SendMessage(hWndIds, LB_SETCURSEL, wKey, 0L);

            if(!MyGetValue(wKey, &hTmp)) {
               SendMessage(hWndTmp, WM_SETTEXT, 0,
                     (DWORD)((LPSTR)LocalLock(hTmp)));
               LocalUnlock(hTmp);
               LocalFree(hTmp);
            } else
               SendMessage(hWndTmp, WM_SETTEXT, 0, (DWORD)((LPSTR)szNull));

            hWndTmp = GetDlgItem(hDlg, ID_FULLPATH);
            if(hTmp=MyGetPath(wKey)) {
               SendMessage(hWndTmp, WM_SETTEXT, 0,
                     (DWORD)((LPSTR)LocalLock(hTmp)));
               LocalUnlock(hTmp);
               LocalFree(hTmp);
            } else
               SendMessage(hWndTmp, WM_SETTEXT, 0, (DWORD)((LPSTR)szNull));
         }
         break;

      default:
         break;
      }
      return(FALSE);
      break;

   case WM_SIZE:
    {
      HWND hWndTmp;
      RECT rcList, rcWnd;
      int hgtWnd, hgt;

      hgtWnd = HIWORD(lParam) + 1;
      hgt = hgtWnd - nTop;

      SetWindowPos(hWndIds, NULL, -1, nTop, LOWORD(lParam)+2, hgt,
            SWP_NOZORDER);
      GetWindowRect(hWndIds, &rcList);
      ScreenToClient(hDlg, (POINT *)(&rcList) + 1);
      if(rcList.bottom != hgtWnd) {
         GetWindowRect(hDlg, &rcWnd);
         SetWindowPos(hDlg, NULL, 0, 0, rcWnd.right-rcWnd.left,
               rcWnd.bottom-rcWnd.top-hgtWnd+rcList.bottom,
               SWP_NOMOVE | SWP_NOZORDER);
      }

      hWndTmp = GetDlgItem(hDlg, ID_VALUE);
      SetWindowPos(hWndTmp, NULL, 0, 0, LOWORD(lParam)-nLeft,
            nValHgt, SWP_NOMOVE | SWP_NOZORDER);
      InvalidateRect(hWndTmp, NULL, TRUE);

      hWndTmp = GetDlgItem(hDlg, ID_FULLPATH);
      SetWindowPos(hWndTmp, NULL, 0, 0, LOWORD(lParam)-nLeft,
            nPthHgt, SWP_NOMOVE | SWP_NOZORDER);
      InvalidateRect(hWndTmp, NULL, TRUE);
      break;
    }

   case WM_INITDIALOG:
    {
      RECT rcTemp;
      WORD wErrMsg;

      hWndIds = GetDlgItem(hDlg, ID_IDLIST);

      SendMessage(hWndIds, WM_SETREDRAW, 0, 0L);
      if(wErrMsg=MyResetIdList(hDlg)) {
         MyMessageBox(hWndMain, wErrMsg, MB_OK, 0);
	 fOpenError = TRUE;
      }
      SendMessage(hWndIds, WM_SETREDRAW, 1, 0L);
      InvalidateRect(hWndIds, NULL, TRUE);

      GetWindowRect(hWndIds, &rcTemp);
      ScreenToClient(hDlg, (POINT FAR *)&rcTemp);
      nTop = rcTemp.top;

      GetWindowRect(GetDlgItem(hDlg, ID_VALUE), &rcTemp);
      nValHgt = rcTemp.bottom - rcTemp.top;
      GetWindowRect(GetDlgItem(hDlg, ID_FULLPATH), &rcTemp);
      nPthHgt = rcTemp.bottom - rcTemp.top;
      ScreenToClient(hDlg, (POINT FAR *)&rcTemp);
      nLeft = rcTemp.left;
      break;
    }

   case WM_MEASUREITEM:
    {
      HDC hDC;

      hDC = GetDC(hWndIds);
      misParam->itemHeight = HIWORD(GetTextExtent(hDC, "Ag", 2));
      xSpace = LOWORD(GetTextExtent(hDC, " ", 1));
      ReleaseDC(hWndIds, hDC);
      break;
    }

   case WM_DRAWITEM:
    {
      HDC hDC;
      HANDLE hKeyName, hValue;
      PSTR pKeyName;
      WORD wSize;
      int theLevel;
      RECT rcTextExt;
      DWORD dwMarkers, thisMarker;
      DWORD dwRGBBkGnd, dwRGBText;

      hDC = disParam->hDC;

      if(!(hKeyName=GetListboxString(disParam->hwndItem, disParam->itemID)))
         break;
      pKeyName = LocalLock(hKeyName);
      wSize = lstrlen(pKeyName);

      if(!MyGetValue(disParam->itemID, &hValue)) {
	 PSTR pValue;
	 HANDLE hTemp;
	 WORD wTemp;

	 if(*(pValue = LocalLock(hValue))) {
	    LocalUnlock(hKeyName);
	    wTemp = wSize + sizeof(szEquals) - 1 + lstrlen(pValue);
	    if(hTemp=LocalReAlloc(hKeyName, wTemp+1, LMEM_MOVEABLE)) {
	       hKeyName = hTemp;
	       pKeyName = LocalLock(hKeyName);
	       lstrcat(pKeyName, szEquals);
	       lstrcat(pKeyName, pValue);
	       wSize = wTemp;
	    } else {
	       pKeyName = LocalLock(hKeyName);
	    }
	 }

	 LocalUnlock(hValue);
	 LocalFree(hValue);
      }

      theLevel = GetLevel(disParam->itemID);

      rcTextExt.left   = disParam->rcItem.left + RONSPACE*theLevel*xSpace;
      rcTextExt.top    = disParam->rcItem.top;
      rcTextExt.right  = rcTextExt.left + LOWORD(GetTextExtent(hDC,
            pKeyName, wSize)) + 2*xSpace;
      rcTextExt.bottom = disParam->rcItem.bottom;

      if(disParam->itemAction & (ODA_DRAWENTIRE | ODA_SELECT)) {
         if(disParam->itemID>0 && (disParam->itemAction&ODA_DRAWENTIRE)) {
            HPEN hPen, hOldPen;
            int theLeft, theMiddle;

            if(theLevel <= 32)
               dwMarkers = GetTreeMarkers(disParam->itemID);
            else
               dwMarkers = 0;

            --theLevel;
            theLeft = disParam->rcItem.left + RONSPACE*theLevel*xSpace + xSpace;
            theMiddle = (rcTextExt.top+rcTextExt.bottom)/2;
            thisMarker = 1L << (LONG)theLevel;

            if(hPen=CreatePen(PS_SOLID, 1, GetTextColor(hDC)))
               hOldPen = SelectObject(hDC, hPen);

            MoveTo(hDC, theLeft, theMiddle);
            LineTo(hDC, theLeft+(RONSPACE-1)*xSpace, theMiddle);
            MoveTo(hDC, theLeft, rcTextExt.top);
            LineTo(hDC, theLeft,
                  (dwMarkers&thisMarker) ? rcTextExt.bottom : theMiddle);
            goto NextLevel;

            for( ; theLevel>=0;
                  --theLevel, thisMarker>>=1, theLeft-=RONSPACE*xSpace) {
               if(dwMarkers&thisMarker) {
                  MoveTo(hDC, theLeft, rcTextExt.top);
                  LineTo(hDC, theLeft, rcTextExt.bottom);
               }
NextLevel:
               ;
            }

            if(hPen) {
               if(hOldPen)
                  SelectObject(hDC, hOldPen);
               DeleteObject(hPen);
            }
         }

         if(disParam->itemState & ODS_SELECTED) {
            dwRGBBkGnd = SetBkColor(hDC, GetSysColor(COLOR_HIGHLIGHT));
            dwRGBText = SetTextColor(hDC, GetSysColor(COLOR_HIGHLIGHTTEXT));
         }

         ExtTextOut(hDC, rcTextExt.left+xSpace, rcTextExt.top+1,
  	       ETO_CLIPPED | ETO_OPAQUE, &rcTextExt, pKeyName, wSize, 0L);

         if(disParam->itemState & ODS_SELECTED) {
            SetBkColor(hDC, dwRGBBkGnd);
            SetTextColor(hDC, dwRGBText);
         }

         if(disParam->itemState & ODS_FOCUS)
            disParam->itemAction |= ODA_FOCUS;
      }

      if(disParam->itemAction & ODA_FOCUS)
         DrawFocusRect(disParam->hDC, &rcTextExt);

      LocalUnlock(hKeyName);
      LocalFree(hKeyName);
      break;
    }

   default:
      return(FALSE);
   }

   return(TRUE);
}


VOID NEAR _fastcall FillDlgItem(HWND hDlg, WORD wId, HANDLE hTemp)
{
   if(hTemp) {
      SendDlgItemMessage(hDlg, wId, WM_SETTEXT, 0,
            (DWORD)((LPSTR)LocalLock(hTemp)));
      LocalUnlock(hTemp);
      LocalFree(hTemp);
   }
}


int FAR PASCAL GetKeyProc(HWND hDlg, WORD message, WORD wParam, DWORD lParam)
{
   switch(message) {
   case WM_ACTIVATE:
      if(wParam)
         hWndHelp = hDlg;
      return(FALSE);

   case WM_COMMAND:
      switch(wParam) {
      case IDOK:
       {
         HWND hWndEdit2;

         if(!(hEdit1=GetEditString(GetDlgItem(hDlg, ID_EDIT1))))
            goto Error1;
         if((hWndEdit2=GetDlgItem(hDlg, ID_EDIT2)) &&
               !(hEdit2 = GetEditString(hWndEdit2)))
            goto Error2;
       }

      case IDCANCEL:
         EndDialog(hDlg, wParam);
         break;

Error2:
         LocalFree(hEdit1);
Error1:
         MyMessageBox(hDlg, IDS_OUTOFMEMORY, MB_OK, 0);
         break;

      case ID_HELP:
         if(GetParent(LOWORD(lParam)) != hDlg)
            break;
      case ID_HELPBUTTON:
         MyHelp(hDlg, HELP_CONTEXT, wHelpId);
         break;
      }
      break;

   case WM_INITDIALOG:
      FillDlgItem(hDlg, ID_STAT1, hStat1);
      FillDlgItem(hDlg, ID_EDIT1, hEdit1);
      FillDlgItem(hDlg, ID_EDIT2, hEdit2);

      return(TRUE);

   default:
      return(FALSE);
   }

   return(TRUE);
}


long FAR PASCAL SDKMainWnd(HWND hWnd, WORD message, WORD wParam, LONG lParam)
{
   HCURSOR oldCursor;

   switch(message) {
   case WM_ACTIVATE:
      if(wParam)
	 break;
      goto DoDefault;

   case WM_CREATE:
    {
      hWndMain = hWnd;
      if(!(lpMainWndDlg=MakeProcInstance(SDKMainWndDlg, hInstance)))
         goto Error1_1;
      if(!(hWndDlg=CreateDialog(hInstance, MAKEINTRESOURCE(SDKMAINWND), hWnd,
            lpMainWndDlg)))
         goto Error1_1;

      ShowWindow(hWndDlg, SW_SHOW);
      goto DoDefault;
    }

Error1_1:
      /* BUG: There should be a MessageBox here
       */
      DestroyWindow(hWnd);
      break;

   /* We need to return 1 if it is OK to close, 0 otherwise
    */
   case WM_CLOSE:
   case WM_QUERYENDSESSION:
    {
      MySetSel(hWndIds, -2);

      if(bChangesMade) {
         int nReturn;

         nReturn = MyMessageBox(hWnd, IDS_SAVECHANGES, MB_YESNOCANCEL, 0);
         if(nReturn == IDYES) {
	    if(!SendMessage(hWnd, WM_COMMAND, ID_SAVE, 0L))
	       break;
	 } else if(nReturn == IDCANCEL)
            break;
      }
      return(1L);
    }

   case WM_DROPFILES:
      goto DoMergeFile;

   case WM_COMMAND:
      oldCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));
      switch(wParam) {
      case ID_MODIFY:
	 SetFocus(GetDlgItem(hWndDlg, ID_IDLIST));
	 break;

      case ID_EDITVAL:
	 SetFocus(GetDlgItem(hWndDlg, ID_VALUE));
	 break;

      case ID_SAVE:
       {
         WORD wErrMsg;

	 MySetSel(hWndIds, -2);

         if(wErrMsg=MySaveChanges()) {
            MyMessageBox(hWnd, wErrMsg, MB_OK, 0);
            break;
         }

	 /* Now we reset our local version of the database to make sure
	  * we are all talking about the same thing
	  */
	 PostMessage(hWnd, WM_COMMAND, ID_DORESTORE, 0L);
	 return(1L);
       }

      case ID_RESTORE:
         if(MyMessageBox(hWnd, IDS_SURERESTORE, MB_OKCANCEL, 0)
               != IDOK)
            break;

	 /* Fall through */
      case ID_DORESTORE:
       {
	 WORD wErrMsg;

	 SendMessage(hWnd, WM_ACTIVATEAPP, 0, 0L);
         SendMessage(hWndIds, WM_SETREDRAW, 0, 0L);
         if(wErrMsg=MyResetIdList(hWndDlg)) {
            MyMessageBox(hWnd, wErrMsg, MB_OK, 0);
	    PostMessage(hWnd, WM_COMMAND, ID_EXIT, 0L);
	    fOpenError = TRUE;
         }
         SendMessage(hWndIds, WM_SETREDRAW, 1, 0L);
         InvalidateRect(hWndIds, NULL, TRUE);
	 SendMessage(hWnd, WM_ACTIVATEAPP, 1, 0L);
	 break;
       }

      case ID_MERGEFILE:
DoMergeFile:
	 MySetSel(hWndIds, -2);
	 SendMessage(hWndIds, WM_SETREDRAW, 0, 0L);
	 break;

      case ID_FINISHMERGE:
         SendMessage(hWndIds, WM_SETREDRAW, 1, 0L);
         InvalidateRect(hWndIds, NULL, TRUE);
         break;

      case ID_WRITEFILE:
       {
         WORD wErrMsg;

	 MySetSel(hWndIds, -2);

	 if(!LOWORD(lParam))
	    break;

         if(wErrMsg=DoWriteFile(wKey, LOWORD(lParam)))
            MyMessageBox(hWnd, wErrMsg, MB_OK, 0);
         GlobalUnlock(LOWORD(lParam));
         GlobalFree(LOWORD(lParam));
         break;
       }

      case ID_ADD:
       {
         int nResult;
	 WORD wErrMsg;

	 MySetSel(hWndIds, -2);

         if(!(hStat1=MyGetPath(wKey)))
            goto Error6_1;
         hEdit1 = hEdit2 = NULL;
         wHelpId = IDW_ADDKEY;
         if((nResult=DoDialogBox(MAKEINTRESOURCE(AddKey), hWnd, GetKeyProc))
               < 0)
            goto Error6_2;
         else if(nResult == IDCANCEL)
            break;

         SendMessage(hWndIds, WM_SETREDRAW, 0, 0L);
         if (wErrMsg=GetErrMsg((WORD)SDKSetValue(-wKey, LocalLock(hEdit1),
	       LocalLock(hEdit2))))
	    MyMessageBox(hWnd, wErrMsg, MB_OK, 0);
         SendMessage(hWndIds, WM_SETREDRAW, 1, 0L);
         InvalidateRect(hWndIds, NULL, TRUE);

         LocalUnlock(hEdit2);
         LocalFree(hEdit2);
         LocalUnlock(hEdit1);
         LocalFree(hEdit1);
         break;

Error6_2:
         LocalFree(hStat1);
Error6_1:
         MyMessageBox(hWnd, IDS_OUTOFMEMORY, MB_OK, 0);
	 break;
       }

      case ID_DELETE:
      /* Fall through */
      case ID_COPY:
       {
         int nNewKey, nOldKey, nResult;
         PSTR pEdit1, pEdit2;

	 MySetSel(hWndIds, -2);

/* Get the key name to copy to */
         if(!(hEdit1=MyGetPath(wKey)))
            goto Error5_1;
         hStat1 = hEdit2 = NULL;
         wHelpId = wParam==ID_COPY ? IDW_COPYKEY : IDW_DELETE;
         if((nResult=DoDialogBox(wParam==ID_COPY ? MAKEINTRESOURCE(CopyKey) :
               MAKEINTRESOURCE(DeleteKey), hWnd, GetKeyProc)) < 0)
            goto Error5_2;
         else if(nResult == IDCANCEL)
            break;

/* Do the operation and clean up */
         pEdit1 = LocalLock(hEdit1);

         if((nOldKey=FindKey(pEdit1)) < 0) {
            MyMessageBox(hWnd, IDS_SOURCENOTEXIST, MB_OK, lstrlen(pEdit1),
		   (LPSTR)pEdit1);
	    goto Error5_3;
	 }

         SendMessage(hWndIds, WM_SETREDRAW, 0, 0L);
         if(wParam == ID_COPY) {
	    /* hEdit2 is only set in the copy dialog; not the delete
	     */
	    pEdit2 = LocalLock(hEdit2);
            if((nNewKey=DoCopyKey(nOldKey, pEdit2)) < 0)
               MyMessageBox(hWnd, -nNewKey, MB_OK, 0);
	    LocalUnlock(hEdit2);
	    LocalFree(hEdit2);
         } else {
	    nNewKey = IDS_NODELROOT;
	    if(!nOldKey || (nNewKey=MyDeleteKey(nOldKey)))
               MyMessageBox(hWnd, nNewKey, MB_OK, 0);
            if(nOldKey >= (int)SendMessage(hWndIds, LB_GETCOUNT, 0, 0L))
               --nOldKey;
            MySetSel(hWndIds, nOldKey);
         }
         SendMessage(hWndIds, WM_SETREDRAW, 1, 0L);
         InvalidateRect(hWndIds, NULL, TRUE);

Error5_3:
         LocalUnlock(hEdit1);
         LocalFree(hEdit1);
         break;

/* WARNING: ID_FIND also uses these error labels */
Error5_2:
         LocalFree(hEdit1);
Error5_1:
         MyMessageBox(hWnd, IDS_OUTOFMEMORY, MB_OK, 0);
	 break;
       }

      case ID_FINDKEY:
       {
         int nResult;

         if(!(hEdit1=StringToLocalHandle(LocalLock(hSearchString),
               LMEM_MOVEABLE)))
            goto Error5_1;
         LocalUnlock(hSearchString);
         hStat1 = hEdit2 = NULL;
         wHelpId = IDW_FINDKEY;
         if((nResult=DoDialogBox(MAKEINTRESOURCE(FindKeyDlg), hWnd,
               GetKeyProc)) < 0)
            goto Error5_2;
         else if(nResult == IDCANCEL)
            break;

         if(hSearchString)
            LocalFree(hSearchString);
         hSearchString = hEdit1;
       }
/* Fall through */
      case ID_FINDNEXT:
       {
         int index = LB_ERR;
         PSTR pSearchString;

         if(!hSearchString)
            goto Error2_1;
         pSearchString = LocalLock(hSearchString);

         if(*pSearchString == '\\') {
            if((index=FindKey(pSearchString)) == -1)
               goto Error2_2;
         } else {
            if((index=(int)SendMessage(hWndIds, LB_FINDSTRING, wKey,
                  (DWORD)((LPSTR)pSearchString)))==LB_ERR)
               goto Error2_2;
         }
         MySetSel(hWndIds, index);

Error2_2:
         LocalUnlock(hSearchString);
Error2_1:
         if(index < 0)
            MessageBeep(0);
         break;
       }

      default:
	 break;
      }
      SetCursor(oldCursor);
      break;

   default:
DoDefault:
      return(DefWindowProc(hWnd, message, wParam, lParam));
      break;
   }

   return(0L);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\shell\sources.inc ===
TARGETNAME=
TARGETTYPE=NOTARGET
TARGETPATH=
SOURCES=

NTTARGETFILE1=buildall

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\regedit\sdbase.c ===
#include <windows.h>
#include "SDKRegEd.h"

extern HWND hWndIds;
extern HANDLE hPars;

extern char szHkeyClassesRoot[];

DWORD NEAR PASCAL GetTreeMarkers(int nId)
{
   int *pPars;
   int nKeys, nLevel, nTemp;
   DWORD dwMarkers, thisMarker;
   int i, j;

   nKeys = (WORD)SendMessage(hWndIds, LB_GETCOUNT, 0, 0L);
   pPars = (WORD *)LocalLock(hPars);

   for(i=nId, nLevel= -1; i>=0; i=pPars[i], ++nLevel)
      /* do nothing */ ;

   dwMarkers = 0L;
   for(thisMarker=1; nLevel>0; thisMarker<<=1, --nLevel) {
      for(i=nId, nTemp=nLevel; nTemp>0; i=pPars[i], --nTemp)
         /* do nothing */ ;

      for(j=nId+1; j<nKeys; ++j) {
         if(pPars[j] == i) {
            dwMarkers |= thisMarker;
            break;
         }
      }
      nKeys = j;
   }

   LocalUnlock(hPars);
   return(dwMarkers);
}

int NEAR PASCAL GetLevel(int nId)
{
   int nLevel;
   int *pPars;

   if(!hPars || !(pPars=(WORD *)LocalLock(hPars)))
      return(0);
   for(nLevel= -1; nId>=0; nId=pPars[nId], ++nLevel)
      /* do nothing */ ;
   LocalUnlock(hPars);
   return(nLevel);
}

HANDLE NEAR PASCAL MyGetPartialPath(int index, int nParent)
{
   BOOL bFirst;
   HANDLE hPath;
   PSTR pPath;
   int nLevel, nTemp, i;
   DWORD dwLen;
   WORD wLen = 2;
   int *pPars;

   if(!hPars || !(pPars=(WORD *)LocalLock(hPars)))
      goto Error1;

   for(i=index, nLevel=0; i!=nParent; i=pPars[i], ++nLevel) {
      if((dwLen=SendMessage(hWndIds, LB_GETTEXTLEN, i, 0L)) == LB_ERR)
         goto Error2;
      wLen += LOWORD(dwLen) + 1;
   }

   if(!(hPath=LocalAlloc(LMEM_MOVEABLE, wLen)))
      goto Error2;
   if(!(pPath=LocalLock(hPath)))
      goto Error3;

   if(nParent == 0)
      *pPath++ = '\\';
   *pPath = '\0';
   for(--nLevel, bFirst=TRUE; nLevel>=0; --nLevel) {
      for(i=index, nTemp=nLevel; nTemp>0; i=pPars[i], --nTemp)
         /* do nothing */ ;

      if(bFirst)
         bFirst = FALSE;
      else
         *pPath++ = '\\';
      dwLen = SendMessage(hWndIds, LB_GETTEXT, i, (DWORD)((LPSTR)pPath));
      pPath += LOWORD(dwLen);
   }

   LocalUnlock(hPath);
   goto Error2;

Error3:
   LocalFree(hPath);
   hPath = NULL;
Error2:
   LocalUnlock(hPars);
Error1:
   return(hPath);
}

HANDLE NEAR PASCAL MyGetPath(int i)
{
   return(MyGetPartialPath(i, 0));
}

int NEAR PASCAL FindKey(PSTR pKey)
{
   HANDLE hPath;
   PSTR pLast, pTemp;
   int nLast, index, nCmp;

   pLast = pKey;
   if(*(pKey+1)) {
      for(pTemp=pKey; *pTemp; pTemp=OFFSET(AnsiNext(pTemp))) {
         if(*pTemp == '\\') {
            pLast = pTemp + 1;
         }
      }
   }

   nLast = index = -1;
   do {
      if((index=(int)SendMessage(hWndIds, LB_FINDSTRING, index,
            (DWORD)((LPSTR)pLast)))==LB_ERR ||
            index<=nLast || !(hPath=MyGetPath(index)))
         return(-1);

      nLast = index;
      nCmp = lstrcmpi(pKey, LocalLock(hPath));
      LocalUnlock(hPath);
      LocalFree(hPath);
   } while(nCmp) ;

   return(index);
}

int NEAR PASCAL FindLastExistingKey(int nParent, PSTR pPath)
{
   HANDLE hPath, hTemp;
   PSTR pEnd, pLast, pFullPath;
   int nFound, nResult = -1;
   WORD wLen;

   if(!(hPath=MyGetPath(nParent)))
      goto Error1;
   wLen = lstrlen(LocalLock(hPath));
   LocalUnlock(hPath);
   if(!(hTemp=LocalReAlloc(hPath, wLen+lstrlen(pPath)+2, LMEM_MOVEABLE)))
      goto Error2;
   if(!(pFullPath=LocalLock(hPath=hTemp)))
      goto Error2;

   pEnd = pFullPath + wLen;
   if(nParent) {
      *pEnd++ = '\\';
      *pEnd = '\0';
   }
   lstrcpy(pEnd, pPath);

   for(pLast=pEnd; *pEnd; pEnd=OFFSET(AnsiNext(pEnd))) {
      if(*pEnd == '\\') {
         *pEnd = '\0';
         nFound = FindKey(pFullPath);
         *pEnd = '\\';
         if(nFound == -1)
            goto FoundLast;

         pLast = pEnd + 1;
         nParent = nFound;
      }
   }

/* If we got to the end of the string, try the whole thing */
   if((nFound=FindKey(pFullPath)) >= 0) {
/* The key already exists */
      nParent = nFound;
      pLast = pEnd;
   }
FoundLast:

   nResult = nParent;
   lstrcpy(pPath, pLast);

   LocalUnlock(hPath);
Error2:
   LocalFree(hPath);
Error1:
   return(nResult);
}

#define BIGBLOCK 1024L

static WORD NEAR PASCAL BufferedWrite(int hFile, PSTR pWrite, WORD wBytes)
{
   static HANDLE hBuffer = NULL;
   static WORD wOffset;
   static DWORD dwSize;

   LPSTR lpBuffer;

/* wBytes = 0 means to write out the buffer and clean up */
   if(!wBytes) {
      WORD wErrMsg = NULL;

      if(hBuffer) {
         if(lpBuffer=GlobalLock(hBuffer)) {
            if(_lwrite(hFile, lpBuffer, wOffset) != wOffset)
               wErrMsg = IDS_CANTWRITEFILE;
            GlobalUnlock(hBuffer);
         } else
            wErrMsg = IDS_OUTOFMEMORY;

         GlobalFree(hBuffer);
         hBuffer = NULL;
      }
      return(wErrMsg);
   }

/* hBuffer = NULL means we need to allocate a buffer */
   if(!hBuffer) {
      if(!(hBuffer=GlobalAlloc(GMEM_MOVEABLE, dwSize=BIGBLOCK)))
         return(IDS_OUTOFMEMORY);
      wOffset = 0;
   }

/* If the total is > 64K, flush the buffer */
   if((DWORD)wBytes+(DWORD)wOffset > 0xffffL) {
      if(lpBuffer=GlobalLock(hBuffer)) {
         WORD wTemp;

         wTemp = _lwrite(hFile, lpBuffer, wOffset);
         GlobalUnlock(hBuffer);
         if(wTemp != wOffset)
            return(IDS_CANTWRITEFILE);
      } else
         return(IDS_OUTOFMEMORY);
      wOffset = 0;
   }

/* If the total is greater than the size we have allocated, try to
 * increase the buffer size to fit.  If we cannot, then flush the
 * buffer, and if wBytes is still too big, then write it straight to
 * disk.
 */
   if((DWORD)(wBytes+wOffset) > dwSize) {
      HANDLE hTemp;
      DWORD dwTemp;

      dwTemp = (((wBytes+wOffset)/BIGBLOCK) + 1) * BIGBLOCK;
      if(hTemp=GlobalReAlloc(hBuffer, dwTemp, GMEM_MOVEABLE)) {
         hBuffer = hTemp;
         dwSize = dwTemp;
      } else {
         WORD wTemp;

         if(wOffset) {
            if(!(lpBuffer=GlobalLock(hBuffer)))
               return(IDS_OUTOFMEMORY);
            wTemp = _lwrite(hFile, lpBuffer, wOffset);
            wOffset = 0;
            GlobalUnlock(hBuffer);
            if(wTemp != wOffset)
               return(IDS_CANTWRITEFILE);
         }
         if(wBytes > LOWORD(dwSize)) {
            if(_lwrite(hFile, pWrite, wBytes) == wBytes)
               return(NULL);
            else
               return(IDS_CANTWRITEFILE);
         }
      }
   }

/* If we got to here, then there is room in the buffer */
   if(!(lpBuffer=GlobalLock(hBuffer)))
      return(IDS_OUTOFMEMORY);
   RepeatMove(lpBuffer+wOffset, pWrite, wBytes);
   wOffset += wBytes;
   GlobalUnlock(hBuffer);

   return(NULL);
}

WORD NEAR PASCAL DoWriteFile(int nId, HANDLE hFileName)
{
   HANDLE hHeader;
   PSTR pHeader;
   WORD wErrMsg;
   int *pPars;
   LPSTR lpFileName;
   int hFile, nKeys, i, j;
   OFSTRUCT of;
   WORD wRootLen = lstrlen(szHkeyClassesRoot);

/* Open the file */
   wErrMsg = IDS_CANTOPENFILE;
   lpFileName = GlobalLock(hFileName);
   if((hFile=OpenFile(lpFileName, &of, OF_CREATE)) == -1)
      goto Error1;

   pPars = (WORD *)LocalLock(hPars);
   nKeys = (WORD)SendMessage(hWndIds, LB_GETCOUNT, 0, 0L);

/* Find the first key that does not have nId in its parent chain */
   for(i=nId+1; i<nKeys; ++i) {
      for(j=pPars[i]; j>=0 && j!=nId; j=pPars[j])
         /* do nothing */ ;
      if(j != nId)
         break;
   }

   wErrMsg = IDS_OUTOFMEMORY;
   if(!(hHeader=MyLoadString(IDS_REGHEADER, NULL, LMEM_MOVEABLE)))
      goto Error2;
   pHeader = LocalLock(hHeader);
   wErrMsg = BufferedWrite(hFile, pHeader, lstrlen(pHeader));
   LocalUnlock(hHeader);
   LocalFree(hHeader);
   if(wErrMsg || (wErrMsg=BufferedWrite(hFile, "\r\n", 2)))
      goto Error2;
   
/* Write the strings */
   for(j=nId, wErrMsg=NULL; j<i && !wErrMsg; ++j) {
      HANDLE hPath, hValue;
      PSTR pPath, pValue;

/* Get the path and the value */
      wErrMsg = IDS_OUTOFMEMORY;
      if(!(hPath=MyGetPath(j)))
         goto Error2;
      pPath = LocalLock(hPath);
      if(MyGetValue(j, &hValue))
         goto Error3;
      pValue = LocalLock(hValue);

/* We don't need to write this key if it has subkeys but no value */
      wErrMsg = NULL;
      if(!(*pValue) && pPars[j+1]==j)
         goto Error4;

/* Write HKEY_CLASSES_ROOT<path> = <value>\r\n */
      if((wErrMsg=BufferedWrite(hFile, szHkeyClassesRoot, wRootLen)) ||
	    (wErrMsg=BufferedWrite(hFile, pPath+1, lstrlen(pPath+1))) ||
            (wErrMsg=BufferedWrite(hFile, " = ", 3)))
         goto Error4;

/* Don't write the value if it is of 0 length */
      if(*pValue && (wErrMsg=BufferedWrite(hFile, pValue, lstrlen(pValue))))
         goto Error4;
      wErrMsg = BufferedWrite(hFile, "\r\n", 2);

Error4:
      LocalUnlock(hValue);
      LocalFree(hValue);
Error3:
      LocalUnlock(hPath);
      LocalFree(hPath);
Error2:
      ;
   }

/* One last write with 0 length to clean up */
   wErrMsg = BufferedWrite(hFile, NULL, 0);
   LocalUnlock(hPars);
   _lclose(hFile);

/* Delete the file if there was an error */
   if(wErrMsg)
      OpenFile(lpFileName, &of, OF_DELETE);
Error1:
   GlobalUnlock(hFileName);
   return(wErrMsg);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\shell\usa\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH)
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\regedit\utils1.c ===
#include <windows.h>
#include <commdlg.h>
#include <shellapi.h>

#ifndef DBCS
#define AnsiNext(x) ((x)+1)
#endif

#define BLOCKLEN 100

PSTR NEAR PASCAL GetAppName(HANDLE hCommand)
{
   static char szApp[17];

   PSTR pLast, pCommand, pDot;
   char cSave;

   for(pCommand=LocalLock(hCommand); *pCommand==' ';
         pCommand=AnsiNext(pCommand))
      /* skip spaces */ ;

   for(pDot=pLast=pCommand; ; pCommand=AnsiNext(pCommand)) {
      switch(*pCommand) {
      case ':':
      case '\\':
         pLast = pCommand + 1;
         break;

      case '.':
         pDot = pCommand;
         break;

      case '\0':
      case ' ':
      case '/':
         goto FoundEnd;
      }
   }
FoundEnd:

/* If there was a dot in the name or the name was too long */
   if(pDot > pLast)
      pCommand = pDot;
   if(pCommand-pLast > 8)
      pCommand = pLast+8;

   cSave = *pCommand;
   *pCommand = '\0';
   lstrcpy(szApp, pLast);
   *pCommand = cSave;

   AnsiUpper(szApp);
   pLast = AnsiNext(szApp);
   AnsiLower(pLast);

   LocalUnlock(hCommand);
   return(szApp);
}

HANDLE NEAR cdecl ConstructPath(PSTR pHead, ...)
{
   HANDLE hBuf = NULL;
   PSTR *ppName, pBuf, pTemp;
   WORD wLen;

   if(!pHead)
      goto Error1;

   for(ppName=&pHead, wLen=0; *ppName; ++ppName)
      wLen += lstrlen(*ppName) + 1;

   if(!(hBuf=LocalAlloc(LMEM_MOVEABLE, wLen)))
      goto Error1;
   if(!(pBuf=LocalLock(hBuf)))
      goto Error2;

   for(ppName=&pHead, wLen=0, pTemp=pBuf; *ppName; ++ppName) {
      lstrcpy(pTemp, *ppName);
      pTemp += lstrlen(pTemp);
      *pTemp++ = '\\';
   }
   *(pTemp-1) = '\0';

   LocalUnlock(hBuf);
   goto Error1;

Error2:
   LocalFree(hBuf);
   hBuf = NULL;
Error1:
   return(hBuf);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\regedit\sdkreged.h ===
#include "common.h"


/*********************************************************/
/******************* Constants ***************************/
/*********************************************************/

#define SDKMAINWND		300
#define ModifyKey		301
#define AddKey			302
#define CopyKey			303
#define DeleteKey		304
#define FindKeyDlg		305

#define ID_SAVE			(ID_FIRSTSDKREGED)
#define ID_RESTORE		(ID_SAVE+1)
#define ID_WRITEFILE		(ID_SAVE+2)
#define ID_DORESTORE		(ID_SAVE+3)

#define ID_FINDKEY		(ID_FIRSTSDKREGED+0x10)
#define ID_FINDNEXT		(ID_FINDKEY+1)

#define ID_VALUE		(ID_FIRSTSDKREGED+0x20)
#define ID_VALLIST		(ID_VALUE+1)
#define ID_DELLIST		(ID_VALUE+2)
#define ID_FULLPATH		(ID_VALUE+3)

#define ID_STAT1		(ID_FIRSTSDKREGED+0x30)
#define ID_EDIT1		(ID_STAT1+1)
#define ID_EDIT2		(ID_STAT1+2)

#define IDS_NOSUBKEY		(IDS_FIRSTSDKREGED)
#define IDS_ALREADYEXIST	(IDS_NOSUBKEY+1)

#define IDS_WRITETITLE		(IDS_FIRSTSDKREGED+0x10)
#define IDS_CANTWRITEFILE	(IDS_WRITETITLE+1)

#define IDS_SAVECHANGES		(IDS_FIRSTSDKREGED+0x20)
#define IDS_ERRORSAVING		(IDS_SAVECHANGES+1)
#define IDS_SURERESTORE		(IDS_SAVECHANGES+2)
#define IDS_NODELROOT		(IDS_SAVECHANGES+3)

#define IDS_SOURCENOTEXIST	(IDS_FIRSTSDKREGED+0x30)

#define IDW_ADDKEY		(IDW_MODIFY-1)
#define IDW_COPYKEY		(IDW_MODIFY-2)
#define IDW_DELETE		(IDW_MODIFY-3)
#define IDW_FINDKEY		(IDW_MODIFY-4)


/*********************************************************/
/******************* Functions ***************************/
/*********************************************************/

/***** sdkreged.c *****/
extern long FAR PASCAL SDKMainWnd(HWND, WORD, WORD, LONG);

/***** sdbase.c *****/
extern DWORD NEAR PASCAL GetTreeMarkers(int nId);
extern int NEAR PASCAL GetLevel(int nId);
extern HANDLE NEAR PASCAL MyGetPartialPath(int index, int nParent);
extern HANDLE NEAR PASCAL MyGetPath(int i);
extern int NEAR PASCAL FindKey(PSTR pKey);
extern int NEAR PASCAL FindLastExistingKey(int nParent, PSTR pPath);
extern WORD NEAR PASCAL DoWriteFile(int nId, HANDLE hFileName);

/***** virt.c *****/
extern WORD NEAR PASCAL MyResetIdList(HWND hDlg);
extern WORD NEAR PASCAL MySaveChanges(void);
extern WORD NEAR PASCAL MyDeleteKey(int nId);
extern unsigned long NEAR PASCAL MyGetValue(int nId, HANDLE *hValue);
extern unsigned long NEAR PASCAL SDKSetValue(HKEY, PSTR, PSTR);
extern int NEAR PASCAL DoCopyKey(int nId, PSTR pPath);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\regedit\virt.c ===
#include <windows.h>
#include "SDKRegEd.h"

#ifndef DBCS
#define AnsiNext(x) ((x)+1)
#endif

HANDLE hPars = NULL;
WORD maxKeys = 0;
BOOL bChangesMade = FALSE;

static HWND hWndVals, hWndDels;
char szListbox[] = "listbox";

extern HANDLE hInstance;
extern HWND hWndIds, hWndMain;
extern char szNull[];

extern VOID NEAR PASCAL MySetSel(HWND hWndList, int index);

static int NEAR PASCAL AddKeyToList(PSTR szPath, int index, int nLevel)
{
   PSTR szLast, pNext;
   DWORD dwResult;
   int nResult = -IDS_OUTOFMEMORY;
   WORD *pPars;
   int i, nKeys, nParent, nLevels;

/* Create the list of parents if necessary */
   if(!hPars) {
      if(!(hPars=LocalAlloc(LMEM_MOVEABLE, 8*sizeof(WORD))))
         goto Error1;
      else
         maxKeys = 8;
   }

/* Get the current number of keys, and check index
 * index == -1 means to add to the end of the list
 */
   if((nKeys=(WORD)SendMessage(hWndIds, LB_GETCOUNT, 0, 0L)) == LB_ERR)
      nKeys = 0;
   if(index == 0xffff)
      index = nKeys;
   else if(index > nKeys)
      goto Error1;

   if(!(pPars=(WORD *)LocalLock(hPars)))
      goto Error1;

   szLast = szPath;

   if(*szPath == '\\') {
/* This is a full path name, which will be inserted the first
 * place it can be.  The level and index are ignored: they will
 * need to be determined
 * if this is the root, set the variables and jump to the adding part
 * otherwise, find the existing parent and the new tail
 */
      if(!*(szPath+1)) {
	 /* If the root exists, just return its index
	  */
	 if((nResult=FindKey(szPath)) >= 0)
	    goto Error2;
         nParent = -1;
         nLevels = 0;
         pNext = szPath + 1;
         goto AddNewKey;
      } else {
         ++szLast;
         if((nParent=FindLastExistingKey(0, szLast)) < 0)
            goto Error2;
         index = nParent + 1;
      }
   } else {
/* Not an absolute path
 * nLevel == -1 means the preceding index is the parent, so nLevel is ignored
 * otherwise, find the ancestor of the preceding key with a lower
 * level than nLevel, and that is the parent
 * Finally, check for existing keys, and adjust nParent and index if necessary
 */
      if(nLevel == -1) {
         nParent = index - 1;
      } else {
         for(i=index-1; i>=0; i=pPars[i], --nLevel)
            /* do nothing */ ;
         if(nLevel > 0)
            goto Error2;

         for(i=index-1; nLevel<0; i=pPars[i], ++nLevel)
            /* do nothing */ ;
         nParent = i;
      }

      if(index < nKeys) {
         if((nParent=FindLastExistingKey(nParent, szLast)) < 0)
            goto Error2;
         else if(nParent >= index)
            index = nParent + 1;
      }
   }

/* At this point, index should be set to the intended index,
 * nParent should be set to the parent of the new key,
 * and szLast is the path for the new key (which may have subkeys)
 */
   for(nLevels=0; pNext=OFFSET(MyStrTok(szLast, '\\'));
	 ++nLevels, szLast=pNext) {
AddNewKey:
      if (pNext-szLast > MAX_KEY_LENGTH) {
	 nResult = -IDS_BADKEY;
	 goto CleanUp;
      }

      /* Make sure we have room for the new parents */
      if(nKeys+nLevels+1 > (int)maxKeys) {
         HANDLE hTemp;

         LocalUnlock(hPars);
         if(!(hTemp=LocalReAlloc(hPars,(maxKeys+8)*sizeof(WORD),LMEM_MOVEABLE)))
            goto Error1;
         hPars = hTemp;
         if(!(pPars=(WORD *)LocalLock(hPars)))
            goto Error1;
         maxKeys += 8;
      }

      if((dwResult=SendMessage(hWndIds, LB_INSERTSTRING, index+nLevels,
            (DWORD)((LPSTR)szLast)))==LB_ERR)
         break;
      if((dwResult=SendMessage(hWndVals, LB_INSERTSTRING, index+nLevels,
            (DWORD)((LPSTR)szNull)))==LB_ERR) {
         SendMessage(hWndIds, LB_DELETESTRING, index+nLevels, 0L);
         break;
      }
      SendMessage(hWndVals, LB_SETITEMDATA, index+nLevels, 1L);
   }

/* If the new key already exists, return it */
   if(!nLevels)
      nResult = nParent;
   else if(dwResult != LB_ERR)
      nResult = LOWORD(dwResult);

CleanUp:
   /* update the parent list */
   for(--nKeys; nKeys>=index; --nKeys) {
      if(pPars[nKeys] >= (WORD)index)
         pPars[nKeys+nLevels] = pPars[nKeys] + nLevels;
      else
         pPars[nKeys+nLevels] = pPars[nKeys];
   }
   for(--nLevels; nLevels>=0; --nLevels)
      pPars[index+nLevels] = nParent+nLevels;

Error2:
   LocalUnlock(hPars);
Error1:
   return(nResult);
}

static WORD NEAR PASCAL ListRegs(HWND hWnd, HKEY hKey, int wLevel)
{
   HANDLE hTail;
   PSTR pTail;
   int i;
   HKEY hSubKey;
   WORD wErrMsg = NULL;

   for(i=0; !wErrMsg; ++i) {
      if(MyEnumKey(hKey, i, &hTail) != ERROR_SUCCESS)
         break;
      pTail = LocalLock(hTail);

      if((int)(wErrMsg=-AddKeyToList(pTail, -1, wLevel))>0 ||
            (wErrMsg=GetErrMsg((WORD)RegOpenKey(hKey, pTail, &hSubKey))))
         goto Error1;
      wErrMsg = ListRegs(hWnd, hSubKey, wLevel+1);
      RegCloseKey(hSubKey);

Error1:
      LocalUnlock(hTail);
      LocalFree(hTail);
   }
   return(wErrMsg);
}

WORD NEAR PASCAL MyResetIdList(HWND hDlg)
{
   HKEY hKey;
   int i, nNum;
   WORD wErrMsg = IDS_OUTOFMEMORY;

   if((!hWndVals && !(hWndVals=GetDlgItem(hDlg, ID_VALLIST))) ||
         (!hWndDels && !(hWndDels=GetDlgItem(hDlg, ID_DELLIST))))
      goto Error1;

   bChangesMade = FALSE;

   SendMessage(hWndIds, LB_RESETCONTENT, 0, 0L);
   SendMessage(hWndVals, LB_RESETCONTENT, 0, 0L);
   SendMessage(hWndDels, LB_RESETCONTENT, 0, 0L);

   if((int)(wErrMsg=-AddKeyToList("\\", 0, 0)) <= 0) {
      if(!(wErrMsg=GetErrMsg((WORD)RegCreateKey(HKEY_CLASSES_ROOT,
	    NULL, &hKey)))) {
	 wErrMsg = ListRegs(hWndIds, hKey, 1);
	 RegCloseKey(hKey);

	 nNum = (int)SendMessage(hWndVals, LB_GETCOUNT, 0, 0L);
	 for(i=0; i<nNum; ++i)
	    SendMessage(hWndVals, LB_SETITEMDATA, i, 0L);

      }

      MySetSel(hWndIds, 0);
   }

Error1:
   return(wErrMsg);
}

WORD NEAR PASCAL MySaveChanges(void)
{
   HKEY hKeyTemp;
   HANDLE hPath, hVal;
   WORD wNum, wErrMsg;
   DWORD dwTemp;
   int i;

   if(wErrMsg=GetErrMsg((WORD)RegOpenKey(HKEY_CLASSES_ROOT, NULL, &hKeyTemp)))
      goto Error1;

   wNum = (WORD)SendMessage(hWndDels, LB_GETCOUNT, 0, 0L);
   for(i=0; !wErrMsg && (WORD)i<wNum; ++i) {
      wErrMsg = IDS_OUTOFMEMORY;
      if(!(hPath=GetListboxString(hWndDels, i)))
         break;
      dwTemp = RegDeleteKey(HKEY_CLASSES_ROOT, LocalLock(hPath)+1);
      wErrMsg = dwTemp==ERROR_BADKEY ? NULL : GetErrMsg((WORD)dwTemp);

      LocalUnlock(hPath);
      LocalFree(hPath);
   }

   wNum = GetErrMsg((WORD)RegCloseKey(hKeyTemp));
   if(wErrMsg || (wErrMsg=wNum) ||
         (wErrMsg=GetErrMsg((WORD)RegCreateKey(HKEY_CLASSES_ROOT, NULL,
	       &hKeyTemp))))
      goto Error1;

   wNum = (WORD)SendMessage(hWndVals, LB_GETCOUNT, 0, 0L);
   for(i=wNum-1; !wErrMsg && i>=0; --i) {
      if(!SendMessage(hWndVals, LB_GETITEMDATA, i, 0L))
         continue;

      wErrMsg = IDS_OUTOFMEMORY;
      if(!(hPath=MyGetPath(i)))
         break;
      if(!(hVal=GetListboxString(hWndVals, i)))
         goto Error2;

      wErrMsg = GetErrMsg((WORD)RegSetValue(HKEY_CLASSES_ROOT,
	    LocalLock(hPath)+1, REG_SZ, LocalLock(hVal), 0L));

      LocalUnlock(hVal);
      LocalUnlock(hPath);

      LocalFree(hVal);
Error2:
      LocalFree(hPath);
   }

   wNum = GetErrMsg((WORD)RegCloseKey(hKeyTemp));
Error1:
   return(wErrMsg ? wErrMsg : wNum);
}

WORD NEAR PASCAL MyDeleteKey(int nId)
{
   HANDLE hPath;
   WORD *pPars;
   int nKeys, i, j;
   WORD wErrMsg = IDS_OUTOFMEMORY;

/* Get the path and try to delete it */
   if(!(hPath=MyGetPath(nId)))
      goto Error1;
   if(SendMessage(hWndDels, LB_ADDSTRING, 0, (DWORD)((LPSTR)LocalLock(hPath)))
         == LB_ERR)
      goto Error2;

   pPars = (WORD *)LocalLock(hPars);
   nKeys = (WORD)SendMessage(hWndIds, LB_GETCOUNT, 0, 0L);

/* Find the first key that does not have nId in its parent chain */
   for(i=nId+1; i<nKeys; ++i) {
      for(j=pPars[i]; j>=0 && j!=nId; j=pPars[j])
         /* do nothing */ ;
      if(j != nId)
         break;
   }

/* Do not delete the root from the list */
   if(!nId)
      ++nId;

/* Delete the string from the listbox */
   for(j=nId; j<i; ++j) {
      SendMessage(hWndIds, LB_DELETESTRING, nId, 0L);
      SendMessage(hWndVals, LB_DELETESTRING, nId, 0L);
   }

/* Update the parent list */
   i -= nId;
   nKeys -= i;
   for(j=nId; j<nKeys; ++j) {
      if(pPars[j+i] >= (WORD)nId)
         pPars[j] = pPars[j+i] - i;
      else
         pPars[j] = pPars[j+i];
   }
   bChangesMade = TRUE;
   wErrMsg = NULL;

   LocalUnlock(hPars);
Error2:
   LocalUnlock(hPath);
   LocalFree(hPath);
Error1:
   return(wErrMsg);
}

unsigned long NEAR PASCAL MyGetValue(int nId, HANDLE *hValue)
{
   unsigned long result;
   HANDLE hPath;

   if(SendMessage(hWndVals, LB_GETITEMDATA, nId, 0L)) {
      if(!(*hValue=GetListboxString(hWndVals, nId)))
         return(ERROR_OUTOFMEMORY);
      result = ERROR_SUCCESS;
   } else {
      if(!(hPath=MyGetPath(nId)))
         return(ERROR_OUTOFMEMORY);
      result = MyQueryValue(HKEY_CLASSES_ROOT, LocalLock(hPath)+1, hValue);
      LocalUnlock(hPath);
      LocalFree(hPath);
   }

   return(result);
}

/* Strip off leading and trailing spaces, and return
 * -1 if there are any invalid characters, otherwise the address
 * of the first non-blank.
 */
PSTR NEAR PASCAL VerifyKey(PSTR lpK)
{
  PSTR lpT;
  char cLast = '\0';

  /* skip some spaces, just to be wierd
   */
  while (*lpK == ' ')
      lpK++;

  /* Special case the string "\"
   */
  if (*(unsigned int *)lpK == (unsigned int)'\\')
      return(lpK);

  /* Note that no extended characters are allowed, so no DBCS
   * characters are allowed in a key
   */
  for (lpT=lpK; ; ++lpT)
    {
      switch (*lpT)
	{
	  case '\0':
	    /* We do not allow a \ as the last char
	     */
	    return(cLast=='\\' ? (PSTR)-1 : lpK);

	  case '\\':
	    /* We do not allow two \'s in a row
	     */
	    if (cLast == '\\')
		return((PSTR)-1);
	    break;

	  default:
	    /* If we get a control or extended character, return -1.
	     */
	    if ((char)(*lpT) <= ' ')
		return((PSTR)-1);
	    break;
	}

      cLast = *lpT;
    }
}

unsigned long NEAR PASCAL SDKSetValue(HKEY hKey, PSTR pSubKey, PSTR pVal)
{
   WORD wNewKey;

   if (hKey == HKEY_CLASSES_ROOT)
      hKey = 0L;
   else
      hKey = -(long)hKey;

   if ((pSubKey=VerifyKey(pSubKey)) == (PSTR)-1)
      return(ERROR_BADKEY);

   if((int)(wNewKey=(WORD)AddKeyToList(pSubKey, (WORD)hKey+1, -1))>=0 &&
         SendMessage(hWndVals, LB_INSERTSTRING, wNewKey, (LONG)(LPSTR)pVal)
	 !=LB_ERR) {
      SendMessage(hWndVals, LB_DELETESTRING, wNewKey+1, 0L);
      SendMessage(hWndVals, LB_SETITEMDATA, wNewKey, 1L);
      MySetSel(hWndIds, wNewKey);
      bChangesMade = TRUE;

      return(ERROR_SUCCESS);
   }

   return(ERROR_OUTOFMEMORY);
}

int NEAR PASCAL DoCopyKey(int nId, PSTR pPath)
{
   WORD *pPars;
   int nParent, result, i, j, nKeys, nNewKey;

   pPars = (WORD *)LocalLock(hPars);

/* Cannot copy the whole tree */
   result = -IDS_NOSUBKEY;
   if(!nId)
      goto Error1;

/* Find the longest path that currently exists
 * return an error if that is the whole string
 * or a subkey of the key to be copied
 */
   if(*pPath == '\\') {
      ++pPath;
      if((result=nParent=FindLastExistingKey(0, pPath)) < 0)
         goto Error1;
   } else {
      if((result=nParent=FindLastExistingKey(pPars[nId], pPath)) < 0)
         goto Error1;
   }
   result = -IDS_NOSUBKEY;
   for(i=nParent; i>=0; i=pPars[i])
      if(i == nId)
         goto Error1;
   result = -IDS_ALREADYEXIST;
   if(!*pPath)
      goto Error1;

/* Find the first key that does not have nId in its parent chain */
   nKeys = (WORD)SendMessage(hWndIds, LB_GETCOUNT, 0, 0L);
   for(i=nId+1; i<nKeys; ++i) {
      for(j=pPars[i]; j>=0 && j!=nId; j=pPars[j])
         /* do nothing */ ;
      if(j != nId)
         break;
   }

/* Add the new keys
 * hPars should be unlocked in case it needs to grow
 */
   LocalUnlock(hPars);
   pPars = NULL;
   if(SDKSetValue(-nParent, pPath, szNull) != ERROR_SUCCESS)
      goto Error1;
   nNewKey = (int)SendMessage(hWndIds, LB_GETCURSEL, 0, 0L);

   for(--i, result=nId; i>=nId && result==nId; --i) {
      HANDLE hPart, hValue;
      PSTR pPart;

      if(nNewKey <= nId) {
         int nDiff;

/* Need to update i and nId if keys were added before them */
         nDiff = (WORD)SendMessage(hWndIds, LB_GETCOUNT, 0, 0L) - nKeys;
         nKeys += nDiff;
         i += nDiff;
         nId += nDiff;
      }

      result = -IDS_OUTOFMEMORY;
      if(!(hPart=MyGetPartialPath(i, nId)))
         goto Error2;
      pPart = LocalLock(hPart);
      if(MyGetValue(i, &hValue) != ERROR_SUCCESS)
         goto Error3;

      if(SDKSetValue(-nNewKey, pPart, LocalLock(hValue)) != ERROR_SUCCESS)
         goto Error4;

      result = nId;
Error4:
      LocalUnlock(hValue);
      LocalFree(hValue);
Error3:
      LocalUnlock(hPart);
      LocalFree(hPart);
Error2:
      ;
   }

Error1:
   if(pPars)
      LocalUnlock(hPars);
   return(result);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\shell\shell.asm ===
;++
;
;   WOW v1.0
;
;   Copyright (c) 1991, Microsoft Corporation
;
;   SHELL.ASM
;   Win16 SHELL thunks
;
;   History:
;
;   Created 14-April-1992 by Chandan S. Chauhan (ChandanC)
;
;--

        TITLE   SHELL.ASM
        PAGE    ,132

        ; Some applications require that USER have a heap.  This means
        ; we must always have: LIBINIT equ 1
        LIBINIT equ 1

        .286p

        .xlist
        include wow.inc
        include wowshell.inc
        include cmacros.inc
        .list

        __acrtused = 0
        public  __acrtused      ;satisfy external C ref.

externFP WOW16Call

ifdef LIBINIT
externFP LocalInit
endif

createSeg   _TEXT,CODE,WORD,PUBLIC,CODE
createSeg   _DATA,DATA,WORD,PUBLIC,DATA,DGROUP
defgrp      DGROUP,DATA


sBegin  DATA
Reserved    db  16 dup (0)      ;reserved for Windows
SHELL_Identifier        db      'SHELL16 Data Segment'
sEnd    DATA


sBegin	CODE
assumes	CS,CODE
assumes DS,NOTHING
assumes ES,NOTHING


cProc   SHELL16,<PUBLIC,FAR,PASCAL,NODATA,NOWIN,ATOMIC>

        cBegin <nogen>

        IFDEF   LIBINIT
        ; push params and call user initialisation code

        push di                 ;hModule

        ; if we have a local heap declared then initialize it

        jcxz no_heap

        push 0                  ;segment
        push 0                  ;start
        push cx                 ;length
        call LocalInit

no_heap:
        pop di
        mov ax, 1
        ELSE
        mov  ax,1               ;are we dressed for success or WHAT?!
        ENDIF
        ret
        cEnd <nogen>


cProc   WEP,<PUBLIC,FAR,PASCAL,NODATA,NOWIN,ATOMIC>
        parmW   iExit           ;DLL exit code

        cBegin
        mov     ax,1            ;always indicate success
        cEnd


assumes DS,NOTHING

        SHELLThunk      REGOPENKEY
        SHELLThunk      REGCREATEKEY
        SHELLThunk      REGCLOSEKEY
        SHELLThunk      REGDELETEKEY
        SHELLThunk      REGSETVALUE
        SHELLThunk      REGQUERYVALUE
        SHELLThunk      REGENUMKEY
        SHELLThunk      DRAGACCEPTFILES
        SHELLThunk      DRAGQUERYFILE
FUN_DragFinishWOW equ FUN_DragFinish
        SHELLThunk      DRAGFINISHWOW, %(size DRAGFINISH16)
;;;     SHELLThunk      DRAGQUERYPOINT
        SHELLThunk      SHELLEXECUTE            ;internal private for shell
        SHELLThunk      FINDEXECUTABLE          ;internal private for shell
        SHELLThunk      SHELLABOUT              ;internal private for shell
        SHELLThunk      WCI, 0                  ;internal
        SHELLThunk      ABOUTDLGPROC, 0         ;internal
        SHELLThunk      EXTRACTICON
        SHELLThunk      EXTRACTASSOCIATEDICON   ;internal private for shell
        SHELLThunk      DOENVIRONMENTSUBST
        SHELLThunk      FINDENVIRONMENTSTRING, 0
        SHELLThunk      INTERNALEXTRACTICON, 0  ;internal private for shell
        SHELLThunk      HERETHARBETYGARS, 0     ;internal
        SHELLThunk      FINDEXEDLGPROC, 0
        SHELLThunk      REGISTERSHELLHOOK, 0
        SHELLThunk      SHELLHOOKPROC, 0

; New for Win95

        SHELLThunk      EXTRACTICONEX
        SHELLThunk      RESTARTDIALOG
        SHELLThunk      PICKICONDLG
        SHELLThunk      DRIVETYPE
        SHELLThunk      SH16TO32DRIVEIOCTL
        SHELLThunk      SH16TO32INT2526
        SHELLThunk      SHGETFILEINFO
        SHELLThunk      SHFORMATDRIVE
        SHELLThunk      SHCHECKDRIVE
        SHELLThunk      _RUNDLLCHECKDRIVE

sEnd	CODE

end	SHELL16

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\shell\dragdrop.c ===
/*
 *  dragdrop.c -
 *
 *  Code for Drag/Drop API's.
 *
 *  This code assumes something else does all the dragging work; it just
 *  takes a list of files after all the extra stuff.
 *
 *  The File Manager is responsible for doing the drag loop, determining
 *  what files will be dropped, formatting the file list, and posting
 *  the WM_DROPFILES message.
 *
 *  The list of files is a sequence of zero terminated filenames, fully
 *  qualified, ended by an empty name (double NUL).  The memory is allocated
 *  DDESHARE.
 */

#include <windows.h>
#include "shellapi.h"

void WINAPI DragFinishWOW(HDROP hDrop);

//
// Make sure that we correctly alias wParam of WM_DROPFILES, because that's
// the handle in hDrop
//

BOOL WINAPI DragQueryPoint(HDROP hDrop, LPPOINT lppt)
{
    LPDROPFILESTRUCT lpdfs;
    BOOL fNC;

    lpdfs = (LPDROPFILESTRUCT)GlobalLock((HGLOBAL)hDrop);

    *lppt = lpdfs->pt;
    fNC = lpdfs->fNC;
    GlobalUnlock((HGLOBAL)hDrop);
    return !fNC;
}


void WINAPI DragFinish(HDROP hDrop)
{
    GlobalFree((HGLOBAL)hDrop);

//  The call to 32-bit DragFinish is not needed as GlobalFree is hooked
//  and will allow for the release of an alias (see wow32\wshell.c)
//    DragFinishWOW(hDrop);

}



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\sherlock\drwatson.c ===
/* sherlock.c - Help deduce cause of Unrecoverable Application Errors
   (C) Copyright 1991, Microsoft Corp
   Written by Don Corbitt, based upon work of Cameron Stevens and others.
   Features -
     Help Script
     Dialog box to change options
     Option to trap Ctrl-Alt-SysRq to break endless loops
     Disassembler should look up symbols for CALL instructions
     Button could call up editor - file extension associations
     Toggle Icon when message occurs
     Write formal spec - (Program is done, so write the spec)
     Disable operation in Real Mode
     Dump stack bytes
     If all is blown, dump message to text monitor
     Data Symbols in disassembly

   Bugs -
     Doesn't buffer file output - this could be slow (but how many GP/hour?)
     Need to watch for invalid memory
     Need to handle Jump to bad address
     What if there aren't any file handles left at fault time???
     Need to handle no file handles available for .SYM file reader
     Should open files (.sym, .log) with proper share flags
     Could dump config.sys and autoexec.bat also
     Can't handle fault in Sherlock - locks up machine - very ugly
     Need to check InDOS flag
     Some errors not detected
       Jump/Call to invalid address
       Load invalid selector
     Run twice in Real Mode causes system hang
     GP Continue doesn't update 32 bit registers for string moves
*/

#define DRWATSON_C
#define STRICT
#include <windows.h>
#include <string.h>     /* strcpy() */
#include <stdarg.h>	/* va_stuff() */
#include <io.h>		/* dup() - why is this spread over 3 files ??? */
#include "toolhelp.h"	/* all the good stuff */
#include "disasm.h"	/* DisAsm86(), memXxxx vars */
#include "drwatson.h"
#include "str.h"        /* Support for string resources */

#define STATIC /*static */

char far foo[1];        /* force far data seg, make single instance */
// Does this make sense considering we have code and strings to
// tell the user they're in error to run two copies of Dr. Watson?


/******************/
/***** Macros *****/
/******************/
#define version "1.00b"

  /* This string is concatenated with other strings in various places */
  /* so it can't be an array variable.  It must stay a #define. */
  /* These strings are not localized. */
#define szAppNameMacro  "Dr. Watson"
#define szAppNameShortMacro "drwatson"
STATIC char szAppName[] = szAppNameMacro;
STATIC char szAppNameShort[] = szAppNameShortMacro;
STATIC char szAppNameShortLog[] = szAppNameShortMacro ".log";
static char szAppNameVers[] = szAppNameMacro " " version;

#define YOO_HOO (WM_USER+22)		/* user activated Dr. Watson */
#define HEAP_BIG_FILE (WM_USER+23)	/* log file is getting large */
#define JUST_THE_FACTS (WM_USER+24)	/* tell me about your problem */
#define BIG_FILE 100000L

  /* Don't like MSC-style FP macros, use my own */
#undef MK_FP
#undef FP_SEG
#undef FP_OFF
#define MK_FP(seg, off) (void far *)(((long)(seg) << 16) | (unsigned short)(off))
#define FP_SEG(fp) (unsigned)((long)(fp) >> 16)
#define FP_OFF(fp) (unsigned)(long)fp

/***************************/
/***** Data Structures *****/
/***************************/

LPSTR aszStrings[STRING_COUNT];

  /* This points to the stack the GP fault handler should use */
char *newsp;

  /* These structures are used by Watson.asm and Disasm.c - don't change */
  /* Also, they can't be static.  They contain the CPU register contents */
  /* at the time the fault occurred. */
struct {
  word ax, cx, dx, bx, sp, bp, si, di, ip, flags;
  word es, cs, ss, ds, fs, gs, intNum;
} regs;

  /* If we have a 32 bit CPU, the full 32 bit values will be stored here. */
  /* The lower 16 bits will still be in the generic regs above.		*/
struct {
  DWORD eax, ecx, edx, ebx, esp, ebp, esi, edi, eip, eflags;
} regs32;

  /* Each of these flags disables a part of the error output report	*/
  /* The error report itself indicates how each section is named.	*/
  /* The word in () can be added to the [Dr. Watson] section of WIN.INI	*/
  /* to disable that section of the report.				*/
  /* clu Clues dialog box */
  /* deb OutputDebugString trapping */
  /* dis Simple disassembly */
  /* err Error logging */
  /* inf System info */
  /* loc Local vars on stack dump */
  /* mod Module dump */
  /* par Parameter error logging */
  /* reg Register dump */
  /* sum 3 line summary */
  /* seg not visible to users, but available */
  /* sou But I _like_ the sound effects! */
  /* sta Stack trace */
  /* tas Task dump */
  /* tim Time start/stop */
  /* 32b 32 bit register dump */

STATIC char syms[] =
  "clu deb dis err inf lin loc mod par reg sum seg sou sta tas tim 32b ";
#define cntFlag (sizeof(syms)/4)
  /* This array is used to decode the flags in WIN.INI.  I only check	*/
  /* the first 3 chars of an entry.  Each entry must be separated by a	*/
  /* space from the previous one.                                       */

unsigned long ddFlag;

int retflag; /* used in watson.asm */

struct {
  char bit, name;
} flBit[] = {
  11, 'O',
  10, 'D',
  9, 'I',
  7, 'S',
  6, 'Z',
  4, 'A',
  2, 'P',
  0, 'C',
};
#define cntFlBit (sizeof(flBit)/sizeof(flBit[0]))

STATIC int disLen = 8;		/* Number of instructions to disassemble */
STATIC int trapZero = 0;	/* Should I trap divide by 0 faults	*/
STATIC int iFeelLucky = 1;	/* Should we restart after GP fault?	*/
	/* 1 = allow continue
	   2 = skip report
	   4 = continue in Kernel
	   8 = continue in User
	   16 = allow sound
	*/
STATIC int imTrying;		/* trying to continue operation */

STATIC struct {
  FARPROC adr;
  WORD code;
	HTASK task;
  DWORD parm;
} lastErr;

STATIC int disStack = 2;	/* Disassemble 2 levels of stack trace	*/
int cpu32;			/* True if cpu has 32 bit regs		*/
STATIC int fh = -1;		/* Handle of open log file		*/
STATIC int level;		/* if >0, in nested FileOpen() call	*/
STATIC int bugCnt, sound;
STATIC int pending;		/* If a pending Clues dialog */
STATIC int whined;		/* If already warned about a large file */
STATIC long pitch, deltaPitch = 250L << 16;
STATIC HINSTANCE hInst;

STATIC char logFile[80];	/* Default log file is "drwatson.log"	*/
				/* and is stored in the windows dir */

STATIC struct {                 /* Help print out value of CPU flags */
  WORD mask;
  LPSTR name;
} wf[] = {
  WF_80x87,    (LPSTR) IDSTRCoprocessor,  // IDSTRs are fixed up to pointers
  WF_CPU086,   (LPSTR) IDSTR8086,         // by LoadStringResources
  WF_CPU186,   (LPSTR) IDSTR80186,
  WF_CPU286,   (LPSTR) IDSTR80286,
  WF_CPU386,   (LPSTR) IDSTR80386,
  WF_CPU486,   (LPSTR) IDSTR80486,
  WF_ENHANCED, (LPSTR) IDSTREnhancedMode,
  WF_PMODE,    (LPSTR) IDSTRProtectMode,
  WF_STANDARD, (LPSTR) IDSTRStandardMode,
  WF_WINNT,    (LPSTR) IDSTRWindowsNT,
};
#define wfCnt (sizeof(wf)/sizeof(wf[0]))

HWND hWnd;			/* Handle to main window */
HANDLE hTask;			/* current task (me) */

/***********************/
/***** Extern Defs *****/
/***********************/

  /* Get base 32 bit linear address of a memory segment - calls DPMI */
extern DWORD SegBase(WORD segVal);

  /* Get segment flags - 0 if error */
extern WORD SegRights(WORD segVal);

  /* Get (segment length -1) */
extern DWORD SegLimit(WORD segVal);

  /* Fills in regs32 structure with value from regs struct and current high */
  /* word of registers - don't do any 32 bit ops before calling this func */
extern void GetRegs32(void);

  /* Fills in non-standard time/date structure using DOS calls.  The C	*/
  /* run-time has a similar function (asctime()), but it pulls in over	*/
  /* 6K of other functions.  This is much smaller and faster, and	*/
  /* doesn't depend on environment variables, etc.			*/
extern void GetTimeDate(void *tdstruc);

  /* Called by ToolHelp as a notify hook */
extern BOOL far /*pascal*/ CallMe(WORD, DWORD);

char *LogParamErrorStr(WORD err, FARPROC lpfn, DWORD param);

extern int FindFile(void *ffstruct, char *name);

  /* This routine is called by ToolHelp when a GP fault occurs.  It 	*/
  /* switches stacks and calls Sherlock() to handle the fault.          */
extern void CALLBACK GPFault(void);

  /* Return name of nearest symbol in file, or 0 */
extern char *NearestSym(int segIndex, unsigned offset, char *exeName);

STATIC void cdecl Show(const LPSTR format, ...);

/************************************/
/***** Segment Helper Functions *****/
/************************************/

/************************************
Name:   LPSTR SegFlags(WORD segVal)
Desc:	Given a selector, SegFlags checks for validity and then returns
	an ascii string indicating whether it is a code or data selector,
	and read or writeable.
Bugs:	Should check other flags (accessed), and call gates.
	Returns pointer to static array, overwritten on each new call.
*************************************/
STATIC LPSTR SegFlags(WORD segVal) {
  static char flag[10];

  if (segVal == 0) return STR(NullPtr);

  segVal = SegRights(segVal);
  if (segVal == 0) return STR(Invalid);

  segVal >>= 8;
  if (!(0x80 & segVal)) return STR(NotPresent);

  if (segVal & 8) {
    lstrcpy(flag, STR(Code));
    lstrcat(flag, segVal & 2 ? STR(ExR) : STR(ExO));
  } else {
    lstrcpy(flag, STR(Data));
    lstrcat(flag, segVal&2 ? STR(RW) : STR(RO));
  }
  return flag;
} /* SegFlags */

/************************************
Name:	char *SegInfo(WORD seg)
Desc:	Given a selector, SegInfo returns an ascii string indicating the
	linear base address, limit, and attribute flags of the selector.
Bugs:	Returns pointer to static array, overwritten on each new call.
*************************************/
STATIC char *SegInfo(WORD seg) {
  static char info[30];
  if (noSeg) return "";

  wsprintf(info, "%8lx:%04lx %-9s",
    SegBase(seg), SegLimit(seg), (FP)SegFlags(seg));
  return info;
} /* SegInfo */

/************************************
Name:	WORD SegNum(WORD segVal)
Desc:	Returns the index of this segment in the module table.  Used to
	translate between a physical segment number and the index as
	seen in e.g. the map file.
Bugs:	Don't know what ToolHelp returns for data or GlobalAlloc segments.
	This is mainly useful for converting a code segment value.
	Check for GT_DATA - will also be valid index.
*************************************/
STATIC WORD SegNum(HGLOBAL segVal) {
  GLOBALENTRY ge;
  ge.dwSize = sizeof(ge);
  if (GlobalEntryHandle(&ge, segVal) && (ge.wType == GT_CODE)) {
    return ge.wData;			/* defined to be 'file segment index' */
  }
  return (WORD)-1;
} /* SegNum */

/************************************
Name:   LPSTR ModuleName(WORD segVal)
Desc:	Returns name of this code segment's module
Bugs:
*************************************/
STATIC LPSTR ModuleName(WORD segVal) {
  static char name[12];
  GLOBALENTRY ge;
  MODULEENTRY me;
  ge.dwSize = sizeof(ge);
  me.dwSize = sizeof(me);
  if (GlobalEntryHandle(&ge, (HGLOBAL)segVal) && (ge.wType == GT_CODE)) {
    if (ModuleFindHandle(&me, ge.hOwner)) {
      strcpy(name, me.szModule);
      return name;
    } /* else Show("ModuleFindHandle() failed\n"); */
  } /* else Show("GlobalEntryHandle() failed\n"); */
  return STR(Unknown);
} /* ModuleName */

/**********************************/
/***** Other Helper Functions *****/
/**********************************/

/************************************
Name:	char *FaultType(void)
Desc:	Returns ascii string indicating what kind of fault caused ToolHelp
	to call our GPFault handler.
Bugs:	May not handle Ctrl-Alt-SysR nicely (we shouldn't trap it)
*************************************/
/* static char *FaultType(void) {
  switch (regs.intNum) {
    case 0: return STR(DivideByZero);
    case 6: return STR(InvalidOpcode);
    case 13: return STR(GeneralProtection);
    default: return STR(Unknown);
  }
} /* FaultType */

/************************************
Name:	char *DecodeFault(int op, word seg, dword offset, word size)
Desc:	Pokes at memory address passed in, trying to determine fault cause
		Segment wrap-around
		Null selector
		Write to read only data
		Write to code segment
		Read from execute only code segment
		Exceed segment limit
		Invalid selector
Bugs:		Jump, string, call, and stack memory adr's aren't set by DisAsm
*************************************/
STATIC LPSTR DecodeFault(int op, word seg, dword offset, word size) {
  int v;
  dword lim;

  switch (op) {
    case memNOP:
      break;			/* since no mem access, no fault */

    case memSegMem:     	/* load seg reg from memory */
      seg = *(short far *)MK_FP(seg, offset);
      /* fall through */
    case memSegReg:		/* load seg reg with value */
      v = SegRights(seg);	/* lets see if this is a selector */
      if (!v) return STR(InvalidSelector);
      break;			/* See no evil... */

    case memRead:
    case memRMW:
    case memWrite:
      if (seg == 0) return STR(NullSelector);

      v = SegRights(seg);
      if (!v) return STR(InvalidSelector);

      v >>= 8;
      if (!(0x80 & v)) return STR(SegmentNotPresent);

      lim = SegLimit(seg);
      if (lim < (offset+size)) return STR(ExceedSegmentBounds);

      if (v & 8) {	/* code segment */
	if ((op == memRMW) || (op == memWrite))
          return /* Write to */ STR(CodeSegment);
        else if (!(v&2)) return /* Read */ STR(ExecuteOnlySegment);

      } else {		/* data segment */
	if (((op == memRMW) || (op == memWrite)) && !(v&2))
          return /* Write to */ STR(ReadOnlySegment);
      }
      break;
    default:
      return 0;			/* obviously unknown condition */
  }
  return 0;
} /* DecodeFault */


LPSTR SafeDisAsm86(void far *code, int *len) {
  unsigned long limit = SegLimit(FP_SEG(code));
  if ((unsigned long)(FP_OFF(code)+10) > limit) {
    *len = 1;
    return STR(SegNotPresentOrPastEnd);
  }
  return DisAsm86(code, (int *)len);
} /* SafeDisAsm86 */


/************************************
Name:   LPSTR FaultCause(void)
Desc:	Decodes the actual cause of the fault.  This is trivial for Div0
	and Invalid Opcode, but much trickier for GP Faults.  I need to
	try to detect at least the following:
		Segment wrap-around
		Null selector
		Write to read only data
		Write to code segment
		Read from execute only code segment
		Exceed segment limit
		Invalid selector
Bugs:
*************************************/
STATIC LPSTR FaultCause(void) {
  int foo;
  LPSTR s, s1;
  static char cause[54];

  switch (regs.intNum) {
    case 0: return STR(DivideByZero);
    case 6: return STR(InvalidOpcode);
    case 20: return STR(ErrorLog);
    case 21: return STR(ParameterErrorLog);
    case 13:
      SafeDisAsm86(MK_FP(regs.cs, regs.ip), &foo);	/* Set global memXxxx vars */

	/* See if first memory access caused fault */
      s = DecodeFault(memOp, memSeg, memLinear, memSize);
      s1 = memName[memOp];

	/* no, see if second memory access caused fault */
      if (!s && memDouble) {
	s = DecodeFault(memOp2, memSeg2, memLinear2, memSize2);
	s1 = memName[memOp2];
      }

      if (s) {
        wsprintf(cause, "%s (%s)", s, s1);
	return cause;
      }
  }
  return STR(Unknown);
} /* FaultCause */

/************************************
Name:   LPSTR CurModuleName(hTask task)
Desc:	Call ToolHelp to find name of faulting module
Bugs:
*************************************/
STATIC LPSTR CurModuleName(HTASK hTask) {
  TASKENTRY te;
  static char name[10];

  te.dwSize = sizeof(te);
  if (!TaskFindHandle(&te, hTask))	/* Thanks, ToolHelp */
    return STR(Unknown);
  strcpy(name, te.szModule);
  return name;
} /* ModuleName */

/************************************
Name:   LPSTR FileInfo(char *name)
Desc:	Find file time, date, and size
Bugs:
*************************************/
STATIC LPSTR FileInfo(char *name) {
  struct {
    char resv[21];
    char attr;
    unsigned time;
    unsigned date;
    long len;
    char name[13];
    char resv1[10];
  } f;
  static char buf[30];

  if (FindFile(&f, name)) return STR(FileNotFound);
  wsprintf(buf, "%7ld %02d-%02d-%02d %2d:%02d",
		f.len,
		(f.date >> 5) & 15, f.date & 31, (f.date >> 9) + 80,
		f.time >> 11, (f.time >> 5) & 63);
  return buf;
} /* FileInfo */

/************************************
Name:   char *CurFileName(void)
Desc:	Call ToolHelp to find filename and path of faulting module
Bugs:
*************************************/
/* STATIC char *CurFileName(void) {
  TASKENTRY te;
  MODULEENTRY me;
  static char name[80];
  te.dwSize = sizeof(te);
  me.dwSize = sizeof(me);
  if (!TaskFindHandle(&te, GetCurrentTask()) ||
      !ModuleFindName(&me, te.szModule))
    return STR(Unknown);
  strcpy(name, me.szExePath);
  return name;
} /* FileName */

/************************************
Name:	char *CurTime(void)
Desc:	Generates string with current time and date.  Similar to asctime(),
        except it doesn't pull in another 6K of run-time library code :-)
Bugs:   Magic structure passed to asm routine
*************************************/
STATIC char *CurTime(void) {
  static char t[48];
  struct {			/* This magic struct is hard-coded to */
    char week, resv;		/* match the assembly language in */
    short year;			/* watson.asm GetTimeDate() */
    char day, month;		/* This means I recommend you don't */
    char minute, hour;		/* change the size or order of the */
    char hund, second;		/* fields! */
  } td;
  GetTimeDate(&td);
  wsprintf(t, "%s %s %2d %02d:%02d:%02d %d",
        aszStrings[IDSTRSun + td.week], aszStrings[IDSTRJan + td.month - 1],
        td.day, td.hour, td.minute, td.second, td.year);
  return t;
} /* CurTime */


/************************************
Name:   LPSTR Tab2Spc(LPSTR temp)
Desc:	Converts tabs found in string 'temp' into the proper number of
	spaces.  I need this since DisAsm86() returns a string with tabs
	in it, and TextOut() didn't like them.  This was easier than
	getting TabbedTextOut() set up to work.  Since I'm no longer dumping
	to the screen, this routine may be superfluous.
Bugs:
*************************************/
STATIC LPSTR Tab2Spc(LPSTR temp) {
  char newbuf[80];
  LPSTR s1, s2;

  s1 = temp;
  s2 = newbuf;
  while ((*s2 = *s1++) != 0) {
    if (*s2++ == 9) {
      s2[-1] = ' ';
      while ((s2-(LPSTR)newbuf) & 7) *s2++ = ' ';
    }
  }
  lstrcpy(temp, newbuf);
  return temp;
} /* Tab2Spc */


/************************************
Name:   void Show(const LPSTR format, ...)
Desc:	Think of this as (minor) shortcut fprintf().  I originally had this
	dumping info to a Windows window, and then changed it to write to
	the file we want.  All output goes through this func, so if you
	want to change something, this is the place.
Bugs:	Now writing to a file handle, opened in text mode so it does the
	  LF->CR/LF translation for me.
	No buffering performed on writes, except for what DOS might do.
	Blows up if stuff passed in expands to longer than 200 chars.
*************************************/
STATIC void cdecl Show(const LPSTR format, ...) {
  char line[CCH_MAX_STRING_RESOURCE];
  char *prev, *cur;
  wvsprintf(line, format, (LPSTR)(&format + 1));
  if (fh != -1) {
    prev = cur = line;
    while (*cur) {			/* expand LF to CR/LF */
      if (cur[0] == '\n' &&		/* at LF */
	 ((prev == cur) ||		/* and first of line */
	  (cur[-1] != '\r'))) {		/* or previous wasn't CR */
	cur[0] = '\r';			/* append CR to text up to LF */
	_lwrite(fh, prev, cur-prev+1);
	cur[0] = '\n';			/* leave LF for next write */
	prev = cur;
      }
      cur++;
    }
    if (prev != cur)			/* write trailing part */
      _lwrite(fh, prev, cur-prev);
  }
} /* Show */

/************************************
Name:	void MyFlush(void)
Desc:	Any routine named MyXxxx() had better be a private hack, and this
	one is.  It just appends an extra CRLF to the output file, and makes
	sure that the info written so far makes it to disk.  This way, if
	a later part of the program blows up, at least you will know this
	much.
Bugs:
*************************************/
STATIC void MyFlush(void) {
  int h;
  Show("\n");
  if (fh != -1) {
    h = dup(fh);
    if (h != -1) _lclose(h);
  }
  if (sound) {
    StopSound();
    SetVoiceSound(1, pitch, 20);
    pitch += deltaPitch;
    StartSound();
  }
} /* MyFlush */

/************************************
Name:	void DisAsmAround(char far *cp, int count)
Desc:	The 'cp' parameter is a pointer to a code segment in memory.  This
	routine backs up a few instructions from the current point, and
	dumps a disassembly showing the context of the selected instruction.
Bugs:	Needs to check for segmentation problems, such as invalid selector.
*************************************/
STATIC void DisAsmAround(byte far *cp, int count) {
  int len, back;
  byte far *oldcp = cp;
  byte far *cp1;
  GLOBALENTRY ge;
  MODULEENTRY me;
  char *szSym = 0;
  long limit;
  unsigned segLim;
  char symBuf[40];

  ge.dwSize = sizeof(ge);
  me.dwSize = sizeof(me);
  if (GlobalEntryHandle(&ge, (HGLOBAL)FP_SEG(cp)) && (ge.wType == GT_CODE)) {
    if (ModuleFindHandle(&me, ge.hOwner)) {
      szSym = NearestSym(ge.wData, FP_OFF(cp), me.szExePath);
      if (!szSym) {		/* if we know module name, but no syms */
	sprintf(symBuf, "%d:%04x", ge.wData, FP_OFF(cp));
	szSym = symBuf;
      }
    }
  }

  cp -= count*2 + 10;     		/* back up */
  if ((FP_OFF(cp) & 0xff00) == 0xff00)	/* if wrapped around, trunc to 0 */
    cp = MK_FP(FP_SEG(cp), 0);
  cp1 = cp;

  limit = SegLimit(FP_SEG(cp));
  segLim = limit > 0xffffL ? 0xffff : (int)limit;
  if (segLim == 0) {
    Show(STR(CodeSegmentNPOrInvalid));
    return;
  }

  back = 0;
  while (cp < oldcp) {			/* count how many instructions to point */
    SafeDisAsm86(cp, &len);
    cp += len;
    back++;
  }
  cp = cp1;
  back -= (count >> 1);
  while (back>0) {			/* step forward until (len/2) remain */
    SafeDisAsm86(cp, &len);		/* before desired instruction point */
    cp += len;
    back--;
  }

  while (count--) {			/* display desired instructions */
    if (cp == oldcp) {
      if (szSym) Show("(%s:%s)\n", (FP)me.szModule, (FP)szSym);
      else Show(STR(NoSymbolsFound));
    }
    Show("%04x:%04x %-22s %s\n",
	 FP_SEG(cp), FP_OFF(cp),	/* address */
	 (FP)hexData,			/* opcodes in hex */
	 (FP)/*Tab2Spc*/(SafeDisAsm86(cp, &len)));/* actual disassembly */
    cp += len;
  }
} /* DisAsmAround */

/************************************
Name:	int MyOpen(void)
Desc:	Tries to open logFile for append.  If this fails, tries to
	create it.
Bugs:	Should set sharing flags?
*************************************/
STATIC int MyOpen(void) {
  if (fh != -1) return fh;		/* Already open */
  fh = _lopen(logFile, OF_WRITE | OF_SHARE_DENY_WRITE);
  if (fh == -1) {
    fh = _lcreat(logFile, 0);
  } else _llseek(fh, 0L, 2);
  if (fh != -1) level++;
  return fh != -1;
} /* MyOpen */

/************************************
Name:	void MyClose(void)
Desc:	close output file, clear handle to -1
Bugs:	Should set sharing flags?
*************************************/
STATIC void MyClose(void) {
  if (--level == 0) {
    if (fh != -1) _lclose(fh);
    fh = -1;
  }
} /* MyClose */

void PutDate(LPSTR msg) {
  MyOpen();
  if (fh == -1) return;
  Show("%s %s - %s\n", (FP)msg, (FP)szAppNameVers, (FP)CurTime());
  MyClose();
} /* PutDate */

int far pascal SherlockDialog(HWND hDlg, WORD wMsg, WPARAM wParam, LPARAM lParam) {
  char line[255];
  int i, len, count;
  HWND hItem;

  lParam = lParam;
  if (wMsg == WM_INITDIALOG) return 1;

  if ((wMsg != WM_COMMAND) ||
      (wParam != IDOK && wParam != IDCANCEL))
    return 0;

  if (wParam == IDOK) {
    MyOpen();
    if (fh != -1) {
      hItem = GetDlgItem(hDlg, 102);
      if (hItem) {
	count = (int)SendMessage(hItem, EM_GETLINECOUNT, 0, 0L);
	for (i=0; i<count; i++) {
	  *(int *)line = sizeof(line) - sizeof(int) -1;
	  len = (int)SendMessage(hItem, EM_GETLINE, i, (long)((void far *)line));
	  line[len] = 0;
	  Show("%d> %s\n", i+1, (FP)line);
	}
      }
      MyClose();
    }
  }
  EndDialog(hDlg, 0);
  return 1;
} /* SherlockDialog */


extern int far pascal SysErrorBox(char far *text, char far *caption,
		int b1, int b2, int b3);
#define  SEB_OK         1  /* Button with "OK".     */
#define  SEB_CANCEL     2  /* Button with "Cancel"  */
#define  SEB_YES        3  /* Button with "&Yes"     */
#define  SEB_NO         4  /* Button with "&No"      */
#define  SEB_RETRY      5  /* Button with "&Retry"   */
#define  SEB_ABORT      6  /* Button with "&Abort"   */
#define  SEB_IGNORE     7  /* Button with "&Ignore"  */
#define  SEB_CLOSE      8  /* Button with "Close"    */

#define  SEB_DEFBUTTON  0x8000  /* Mask to make this button default */

#define  SEB_BTN1       1  /* Button 1 was selected */
#define  SEB_BTN2       2  /* Button 1 was selected */
#define  SEB_BTN3       3  /* Button 1 was selected */


/************************************
Name:   int PrepareToParty(LPSTR modName, LPSTR appName)
Desc:	Checks whether we can continue the current app by skipping an
	instruction.  If so, it performs the side effects of the
	instruction.  This must be called after a call to DisAsm86() has
	set the gpXxxx global vars.
	Checks value of iFeelLucky, bit 0 must be set to continue a fault.
Bugs:	Should do more checking, should check for within a device driver,
	shouldn't require that DisAsm86() be called for the failing
	instruction immediately before call.
*************************************/
int PrepareToParty(LPSTR modName, LPSTR appName) {

  if (!(iFeelLucky&1)) return 0;
  if (!gpSafe) return 0;

  /* compare module to KERNEL */
  if (!(iFeelLucky&4) && !lstrcmp(modName, "KERNEL")) return 0;

  /* compare module to USER */
  if (!(iFeelLucky&8) && !lstrcmp(modName, "USER")) return 0;

  /* already asked, trying to continue, skip this fault */
  if (imTrying>0) return 1;

  if (3 != SysErrorBox(STR(GPText), appName, SEB_CLOSE|SEB_DEFBUTTON, 0, SEB_IGNORE))
    return 0;

  imTrying = 100;
  return 1;
} /* PrepareToParty */

STATIC void DumpInfo(void) {
  WORD w = (int)GetVersion();
  DWORD lw = GetWinFlags();
  SYSHEAPINFO si;
  int i;
  MEMMANINFO mm;

  Show(STR(SystemInfoInfo));
  Show(STR(WindowsVersion), w&0xff, w>>8);
  if (GetSystemMetrics(SM_DEBUG)) Show(STR(DebugBuild));
  else Show(STR(RetailBuild));
  {
    HANDLE hUser = GetModuleHandle("USER");
    char szBuffer[80];
    if (LoadString(hUser, 516, szBuffer, sizeof(szBuffer)))
      Show(STR(WindowsBuild), (FP)szBuffer);

    if (LoadString(hUser, 514, szBuffer, sizeof(szBuffer)))
      Show(STR(Username), (FP)szBuffer);

    if (LoadString(hUser, 515, szBuffer, sizeof(szBuffer)))
      Show(STR(Organization), (FP)szBuffer);
  }


  Show(STR(SystemFreeSpace), GetFreeSpace(0));

  if (SegLimit(regs.ss) > 0x10) {
    int far *ip = MK_FP(regs.ss, 0);
    Show(STR(StackBaseTopLowestSize),
	 ip[5], ip[7], ip[6], ip[7]-ip[5]);
  }

  si.dwSize = sizeof(si);
  if (SystemHeapInfo(&si))
    Show(STR(SystemResourcesUserGDI),
	  si.wUserFreePercent, si.hUserSegment,
      si.wGDIFreePercent, si.hGDISegment);

  mm.dwSize = sizeof(mm);
  if (MemManInfo(&mm)) {
    Show(STR(MemManInfo1),
      mm.dwLargestFreeBlock, mm.dwMaxPagesAvailable, mm.dwMaxPagesLockable);
    Show(STR(MemManInfo2),
      mm.dwTotalLinearSpace, mm.dwTotalUnlockedPages, mm.dwFreePages);
    Show(STR(MemManInfo3),
      mm.dwTotalPages, mm.dwFreeLinearSpace, mm.dwSwapFilePages);
    Show(STR(MemManInfo4), mm.wPageSize);
  }
  Show(STR(TasksExecuting), GetNumTasks());
  Show(STR(WinFlags));
  for (i=0; i<wfCnt; i++) if (lw & wf[i].mask)
    Show("  %s\n", (FP)wf[i].name);
  MyFlush();
} /* DumpInfo */

LPSTR GetProcName(FARPROC fn) {
  GLOBALENTRY ge;
  MODULEENTRY me;
  LPSTR szSym = STR(UnknownAddress);
  static char symBuf[80];

  ge.dwSize = sizeof(ge);
  me.dwSize = sizeof(me);
  if (GlobalEntryHandle(&ge, (HGLOBAL)FP_SEG(fn)) && (ge.wType == GT_CODE)) {
    if (ModuleFindHandle(&me, ge.hOwner)) {
      szSym = NearestSym(ge.wData, FP_OFF(fn), me.szExePath);
      if (!szSym) {		/* if we know module name, but no syms */
        sprintf(symBuf, "%s %d:%04x", (FP)me.szModule, ge.wData, FP_OFF(fn));
      } else sprintf(symBuf, "%s %s", (FP)me.szModule, szSym);
      szSym = symBuf;
    }
  }
  return szSym;
} /* GetProcName */

STATIC void DumpStack(int disCnt, int parmCnt, int cnt, int first) {
  STACKTRACEENTRY ste;
  MODULEENTRY me;
  int frame = 0;
  unsigned oldsp = regs.sp+16;

  ste.dwSize = sizeof(ste);
  me.dwSize = sizeof(me);

  Show(STR(StackDumpStack));
  if (StackTraceCSIPFirst(&ste, regs.ss, regs.cs, regs.ip, regs.bp)) do {
    if (frame >= first--) {
      me.szModule[0] = 0;
      ModuleFindHandle(&me, ste.hModule);
      Show(STR(StackFrameInfo),
	frame++,
	(FP)GetProcName((FARPROC)MK_FP(ste.wCS, ste.wIP)),
	ste.wSS, ste.wBP);
      if (!noLocal && (parmCnt-- > 0)) {
	if (oldsp & 15) {
	  int i;
          Show("ss:%04x ", oldsp & ~15);
	  for (i=0; i < (int)(oldsp & 15); i++) Show("   ");
	}
	while (oldsp < ste.wBP) {
	  if (!(oldsp & 15)) Show("\nss:%04x ", oldsp);
	  Show("%02x ", *(byte far *)MK_FP(regs.ss, oldsp++));
	}
	Show("\n");
      }
      if (frame <= disStack && (disCnt-- >0)) {
        Show("\n");
	DisAsmAround(MK_FP(ste.wCS, ste.wIP), 8);
      }
      MyFlush();
    } /* if after first to show */
  } while (StackTraceNext(&ste) && (cnt-- > 0));
} /* DumpStack */

int BeginReport(LPSTR time) {
  int i;

  MyOpen();
  if (fh == -1) {			/* maybe we're out of handles */
    _lclose(4);				/* trash one at random */
    MyOpen();				/* and try again */
  }
  if (fh == -1) return 0;

  for (i=0; i<4; i++) Show("*******************");
  Show(STR(FailureReport), (FP)szAppNameVers, (FP)time);
  MyFlush();
  if (!noSound) {
    sound = OpenSound();
    pitch = 1000L << 16;
  } else sound = 0;
  return 1;
} /* BeginReport */

void EndReport(void) {
  if (fh != -1) {
    if (!whined && _llseek(fh, 0L, 2) > BIG_FILE) {
      PostMessage(hWnd, HEAP_BIG_FILE, 0, 0);
      whined = 1;
    }
    MyClose();
  }
  if (sound) {
    StopSound();
    CloseSound();
    sound = 0;
  }
} /* EndReport */

void ShowParamError(int sync) {
  if (GetCurrentTask() == lastErr.task)
    Show("$param$, %s %s\n",
      sync ? (FP)"" : (FP)STR(LastParamErrorWas),
      (FP)LogParamErrorStr(lastErr.code, lastErr.adr, lastErr.parm));
  lastErr.task = 0;
} /* ShowParamError */

/************************************
Name:	void Sherlock(void)
Desc:	Handles GP faults in applications by dumping as much system
	information as I can think of to a log file.
	This is the big routine.
Bugs:
*************************************/
enum {s_prog, s_fault, s_name, s_instr, s_time, s_last};
int Sherlock(void) {
  int i, faultlen, party;
  LPSTR s[s_last];

  if ((!trapZero || regs.intNum != 0) &&
       regs.intNum != 6 &&
       regs.intNum != 13)
    return 0;

  if (imTrying>0) {
    s[s_prog] = CurModuleName(GetCurrentTask());
    SafeDisAsm86(MK_FP(regs.cs, regs.ip), &faultlen);
    party = PrepareToParty(ModuleName(regs.cs), s[s_prog]);
    imTrying--;
    if (party) goto SkipReport;
  }

  if (++bugCnt > 20) return 0;

  if (!BeginReport(s[s_time] = CurTime()))
    return 0;

  s[s_prog] = CurModuleName(GetCurrentTask());
  s[s_fault] = FaultCause();
  s[s_name] = GetProcName((FARPROC)MK_FP(regs.cs, regs.ip));

  Show(STR(HadAFaultAt),
       (FP)s[s_prog],
       (FP)s[s_fault],
       (FP)s[s_name]);

  if (!noSummary) Show("$tag$%s$%s$%s$",
	 (FP)s[s_prog],
	 (FP)s[s_fault],
	 (FP)s[s_name]);

  s[s_instr] = Tab2Spc(SafeDisAsm86(MK_FP(regs.cs, regs.ip), &faultlen));
  Show("%s$%s\n", (FP)s[s_instr], (FP)s[s_time]);
  ShowParamError(0);
  MyFlush();

  party = PrepareToParty(ModuleName(regs.cs), s[s_prog]);
  if ((bugCnt > 3) || ((party>0) && (iFeelLucky & 2))) {
    goto SkipReport;
  }

  if (!noReg) {
    Show(STR(CPURegistersRegs));
    Show("ax=%04x  bx=%04x  cx=%04x  dx=%04x  si=%04x  di=%04x\n",
	regs.ax, regs.bx, regs.cx, regs.dx, regs.si, regs.di);
    Show("ip=%04x  sp=%04x  bp=%04x  ", regs.ip, regs.sp+16, regs.bp);
    for (i=0; i<cntFlBit; i++)
      Show("%c%c ", flBit[i].name, regs.flags & (1 << flBit[i].bit) ? '+' : '-');
    Show("\n");
    Show("cs = %04x  %s\n", regs.cs, (FP)SegInfo(regs.cs));
    Show("ss = %04x  %s\n", regs.ss, (FP)SegInfo(regs.ss));
    Show("ds = %04x  %s\n", regs.ds, (FP)SegInfo(regs.ds));
    Show("es = %04x  %s\n", regs.es, (FP)SegInfo(regs.es));
    MyFlush();
  }

  if (cpu32 && !noReg32) {
    Show(STR(CPU32bitRegisters32bit));
    Show("eax = %08lx  ebx = %08lx  ecx = %08lx  edx = %08lx\n",
	regs32.eax, regs32.ebx, regs32.ecx, regs32.edx);
    Show("esi = %08lx  edi = %08lx  ebp = %08lx  esp = %08lx\n",
	regs32.esi, regs32.edi, regs32.ebp, regs32.esp);
    Show("fs = %04x  %s\n", regs.fs, (FP)SegInfo(regs.fs));
    Show("gs = %04x  %s\n", regs.gs, (FP)SegInfo(regs.gs));
    Show("eflag = %08lx\n", regs32.eflags);
    MyFlush();
  }

  if (!noDisasm) {
    Show(STR(InstructionDisasm));
    DisAsmAround(MK_FP(regs.cs, regs.ip), disLen);
    MyFlush();
  }

  if (!noInfo)
    DumpInfo();

  if (!noStack)
    DumpStack(disStack, 0x7fff, 0x7fff, 0);

  if (!noTasks) {
    TASKENTRY te;
    MODULEENTRY me;

    te.dwSize = sizeof(te);
    me.dwSize = sizeof(me);

    Show(STR(SystemTasksTasks));
    if (TaskFirst(&te)) do {
      ModuleFindName(&me, te.szModule);
      Show(STR(TaskHandleFlagsInfo),
	    (FP)te.szModule, te.hTask, me.wcUsage,
	    (FP)FileInfo(me.szExePath));
      Show(STR(Filename), (FP)me.szExePath); /* */
    } while (TaskNext(&te));
    MyFlush();
  }

  if (!noModules) {
    MODULEENTRY me;

    Show(STR(SystemModulesModules));
    me.dwSize = sizeof(me);
    if (ModuleFirst(&me)) do {
      Show(STR(ModuleHandleFlagsInfo),
            (FP)me.szModule, me.hModule, me.wcUsage,
	    (FP)FileInfo(me.szExePath));
      Show(STR(File), (FP)me.szExePath); /* */
    } while (ModuleNext(&me));
    MyFlush();
  }

SkipReport:
  if (party>0) {
    int len;
    word far * stack = MK_FP(regs.ss, regs.sp);
    Show(STR(ContinuingExecution), (FP)CurTime());
    MyFlush();
    /* fix up regs */
    if (gpRegs & segDS) regs.ds = 0;
    if (gpRegs & segES) regs.es = 0;
    if (gpRegs & segFS) regs.fs = 0;
    if (gpRegs & segGS) regs.gs = 0;
    regs.ip += faultlen;		/* set at top of func - don't reuse */
    if ((int)gpStack < 0) {
      for (i=0; i<8; i++) stack[i+gpStack] = stack[i];
    } else if (gpStack) {
      for (i=7; i>=0; i--) stack[i+gpStack] = stack[i];
    }
    regs.sp += gpStack << 1;
    if (gpRegs & strCX) {
      len = regs.cx * memSize;
      regs.cx = 0;
    } else len = memSize;
    if (gpRegs & strSI) {		/* doesn't handle 32 bit regs */
      regs.si += len;
      if (regs.si < (word)len)		/* if overflow, set to big value */
	regs.si = 0xfff0;		/* so global vars in heap don't get */
    }					/* trashed when we continue */
    if (gpRegs & strDI) {
      regs.di += len;
      if (regs.di < (word)len) regs.di = 0xfff0;
    }
  }

  EndReport();
  if (!noClues &&			/* if we want clues */
      !pending &&			/* no clues waited for */
      (!party || !(iFeelLucky & 2))) {	/* and we aren't quiet partiers */
    PostMessage(hWnd, JUST_THE_FACTS, (WPARAM)GetCurrentTask(), party);
    pending++;
  }
  if (party < 0) TerminateApp(GetCurrentTask(), NO_UAE_BOX);
  return party;
} /* Sherlock */

void far *bogus;

int CallMeToo(WORD wID, DWORD dwData) {
  NFYLOGPARAMERROR far *lpep;
  LPSTR s[s_last];

  if (wID == NFY_OUTSTR) {
    if (noDebStr)
      return FALSE;
    MyOpen();
    if (fh == -1) return FALSE;
    Show(STR(DebugString), dwData);
    MyClose();
    return TRUE;
  }

  if (wID == NFY_LOGERROR && noErr)
    return FALSE;

  lpep = (void far *)dwData;		/* Get the data for next log entry */
  lastErr.adr = lpep->lpfnErrorAddr;
  lastErr.code = lpep->wErrCode;
  lastErr.parm = (DWORD)(lpep->lpBadParam);
  lastErr.task = GetCurrentTask();
  if ((lastErr.code & 0x3000) == 0x1000)
    lastErr.parm = (WORD)lastErr.parm;
  else if ((lastErr.code & 0x3000) == 0)
    lastErr.parm = (BYTE)lastErr.parm;

  if (wID == NFY_LOGPARAMERROR && noParam) {
    return FALSE;
  }

  if (bugCnt++ > 60)
    return FALSE;
  if (!BeginReport(s[s_time] = CurTime())) /* Can't open file */
    return FALSE;

  switch (wID) {
    case NFY_LOGERROR:
#if 0
      lep = (void far *)dwData;
      cs = ip = 0;
      parm = 0;
      code = lep->wErrCode;
      s[s_fault] = STR(ApplicationError);
#endif
      break;
    case NFY_LOGPARAMERROR:
      s[s_fault] = STR(InvalidParameter);
      break;
    default:
      return FALSE;
  }

  s[s_prog] = CurModuleName(lastErr.task);
  s[s_name] = GetProcName(lastErr.adr);
  s[s_instr] = STR(NA);      /* not interesting */
  Show(STR(HadAFaultAt2),
       (FP)s[s_prog],
       (FP)s[s_fault], lastErr.code,
       (FP)s[s_name]);
  if (!noSummary) Show("$tag$%s$%s (%x)$%s$",
	 (FP)s[s_prog],
	 (FP)s[s_fault], lastErr.code,
	 (FP)s[s_name]);
  Show(STR(ParamIs), lastErr.parm, (FP)s[s_time]);

  ShowParamError(1);
  MyFlush();

  if (!noInfo && bugCnt < 2)
    DumpInfo();

  if (!noStack)
    DumpStack(0, 0, 0x7fff, 4);

  EndReport();
  return TRUE;
} /* CallMe */

  /* Parse SkipInfo= and ShowInfo= lines into flags array */
void ParseInfo(char *s, int val) {
  int i;
  strlwr(s);
  while (*s) {
    for (i=0; i<cntFlag; i++) if (0 == strncmp(s, syms+(i<<2), 3)) {
      if (val) SetFlag(i);
      else ClrFlag(i);
      break;
    }
    while (*s && *s++ != ' ')
      if (s[-1] == ',') break;
    while (*s && *s == ' ') s++;
  }
} /* ParseInfo */


/************************************
Name:   BOOL LoadStringResources(void)
Desc:   Load all string resources into GlobalAlloc'd buffer and
        initialize aszStrings array with pointers to each string.
        Also fixes up string IDs in wf (winflags) array to pointers.
        Note that we don't free the memory allocated, we count on
        kernel to clean up for us on termination.
Bugs:
*************************************/
BOOL LoadStringResources(void)
{
    int n;
    HANDLE h;
    LPSTR lp;
    WORD cbTotal;
    WORD cbUsed;
    WORD cbStrLen;

    //
    // Allocate too much memory for strings (maximum possible) at first,
    // reallocate to the real size when we're done loading strings.
    //

#if (STRING_COUNT * CCH_MAX_STRING_RESOURCE > 65536 - 64)
#error Need to use HUGE pointer for lp and DWORD for cb in LoadStringResources
#endif

    cbTotal = STRING_COUNT;

    cbTotal *= CCH_MAX_STRING_RESOURCE;

    h = GlobalAlloc(GMEM_FIXED, cbTotal);

    if ( ! h ) {
        return FALSE;
    }

    lp = GlobalLock(h);

    cbUsed = 0;

    for ( n = 0; n < STRING_COUNT; n++ ) {

        cbStrLen = LoadString(hInst, n, lp, CCH_MAX_STRING_RESOURCE);

        if ( ! cbStrLen ) {
            return FALSE;
        }

        aszStrings[n] = lp;

        lp += cbStrLen + 1;  // LoadString return doesn't count null terminator
        cbUsed += cbStrLen + 1;

    }

    GlobalReAlloc(h, cbUsed, 0);


    //
    // Fix up winflags array elements from string resource IDs to pointers
    //

    for ( n = 0; n < wfCnt; n++ ) {
        wf[n].name = aszStrings[ (int)(DWORD)wf[n].name ];
    }

    return TRUE;
}



/************************************
Name:	void DumpIni(void)
Desc:	Write profile strings to log file
Bugs:
*************************************/
#if 0
void DumpIni() {
  int i;
  char buf[4];

  buf[3] = 0;
  MyOpen();
  Show("Re-read win.ini\nshowinfo=");        // move to resource file if ever used
  for (i=0; i<cntFlag; i++) {
    if (!flag(i)) {
      memcpy(buf, syms+(i<<2), 3);
      Show("%s ", (FP)buf);
    }
  }
  Show("\nskipinfo=");
  for (i=0; i<cntFlag; i++) {
    if (flag(i)) {
      memcpy(buf, syms+(i<<2), 3);
      Show("%s ", (FP)buf);
    }
  }
  Show("\n");
  MyClose();
} /* DumpIni */

#endif

/************************************
Name:	int ReadWinIni(void)
Desc:	Read profile strings from WIN.INI.
	Return 0 if failure.
Bugs:
*************************************/
STATIC int ReadWinIni(void) {
  char line[80];
  int len;

    /* how many instructions should I disassemble by default? */
  disLen = GetProfileInt(szAppName, "dislen", 8);

    /* should I trap divide by 0 faults? */
  trapZero = GetProfileInt(szAppName, "trapzero", 0);

    /* should we allow restarting apps? */
  iFeelLucky = GetProfileInt(szAppName, "GPContinue", 1);
  /* if (!(iFeelLucky & 16)) noSound = 1; */

    /* how many stack frames should be disassembled? */
  disStack = GetProfileInt(szAppName, "DisStack", 2);

    /* where should I write the log file to? */
  GetProfileString(szAppName, "logfile", szAppNameShortLog, logFile, sizeof(logFile));
  len = strlen(logFile);

  if ((len == 0) ||			// logfile=
      (logFile[len-1] == '\\') ||	// directory only (boo, hiss)
      (logFile[len-1] == '/') ||	
      (logFile[len-1] == ':')) {	// drive only
    if (len && (logFile[len-1] == ':')) {	// drive only, put in root
      strcat(logFile, "\\");
    }
    strcat(logFile, szAppNameShortLog);	// append a file name
  }
  if (!(strchr(logFile, '\\')		// if no path specified, put in WinDir
     || strchr(logFile, ':')
     || strchr(logFile, '/'))) {
    char logname[80];
    int n;
    GetWindowsDirectory(logname, sizeof(logname));
    n = strlen(logname);
    if (n && logname[n-1] != '\\')
      strcat(logname, "\\");
    strcat(logname, logFile);
    strcpy(logFile, logname);
  }

    /* Set default flag values - see DrWatson.h for default values */
  ddFlag = DefFlag;

    /* do I really have to print out all this information? */
  if (GetProfileString(szAppName, "skipinfo", "", line, sizeof(line)))
    ParseInfo(line, 1);

  if (GetProfileString(szAppName, "showinfo", "", line, sizeof(line)))
    ParseInfo(line, 0);

#if 0
  DumpIni();
#endif
  return 1;
} /* ReadWinIni */

/************************************
Name:	int InitSherlock(void)
Desc:	Initialize Sherlock processing.  Install GP fault handler.
	Return 0 if failure.
Bugs:
*************************************/
STATIC int InitSherlock(void) {

    /* do I have 32 bit registers? */
  cpu32 = (GetWinFlags() & (WF_CPU386|WF_CPU486)) != 0;

    /* see what WIN.INI [drwatson] has to say */
  if (!ReadWinIni()) return 0;

  NotifyRegister(hTask, (LPFNNOTIFYCALLBACK)CallMe, NF_NORMAL);

    /* Now get ToolHelp to do the dirty work */
  return InterruptRegister(hTask, GPFault);
} /* InitSherlock */

/************************************
Name:	void Moriarty
Desc:	Destroy any evidence Sherlock was loaded.
Bugs:	Am I freeing all resources I used?
*************************************/
int init;
STATIC void Moriarty(void) {
  if (init) {
    if (!noTime) PutDate(STR(Stop));
    InterruptUnRegister(hTask);
    NotifyUnRegister(hTask);
    init = 0;
  }
} /* Moriary */

/************************************
Name:	WINAPI SherlockWndProc(hWnd, wMessage, wParam, lParam)
Desc:	Handle sherlock icon, close processing
Bugs:	Should pull up dialog boxes for About and GetInfo
*************************************/
LRESULT CALLBACK SherlockWndProc (HWND hWnd, UINT iMessage,
	WPARAM wParam, LPARAM lParam) {
  char msg[200];
  /* int (FAR PASCAL *dfp)(HWND, WORD, WORD, DWORD); */
	FARPROC dfp;

  switch (iMessage) {
    case WM_ENDSESSION:
      if (wParam) Moriarty();
      break;

    case WM_DESTROY: /* Quit Sherlock */
      PostQuitMessage (0);
      break;

    case WM_QUERYOPEN:	/* never open a window??? */
      PostMessage(hWnd, YOO_HOO, 0, 1);
      ReadWinIni();
      break;

    case WM_WININICHANGE:  /* Re-read WIN.INI parameters */
      ReadWinIni();
      break;

    case YOO_HOO:
      if (bugCnt) {
        wsprintf(msg, STR(Faulty), bugCnt, (FP)logFile);
	MessageBox(hWnd, msg, szAppNameVers,
		   MB_ICONINFORMATION | MB_OK | MB_TASKMODAL);
      } else {
        MessageBox(hWnd, STR(NoFault), szAppNameVers,
		   MB_ICONINFORMATION | MB_OK | MB_TASKMODAL);
      }
      break;

    case HEAP_BIG_FILE:
      wsprintf(msg, STR(LogFileGettingLarge),
	      (FP)logFile);
      MessageBox(hWnd, msg, szAppNameVers,
		 MB_ICONEXCLAMATION | MB_OK | MB_TASKMODAL);
      break;

    case JUST_THE_FACTS:
      dfp = MakeProcInstance((FARPROC)SherlockDialog, hInst);
      DialogBox(hInst, "SherDiag", hWnd, (DLGPROC)dfp);
      FreeProcInstance(dfp);
      pending = 0;			/* finished all old business */
      break;

    default:
      return DefWindowProc (hWnd,iMessage,wParam,lParam);
  }
  return 0L;
}

/************************************
Name:	WinMain(hInst, hPrevInst, cmdLine, cmdShow)
Desc:	Init Sherlock - this is where it all begins
Bugs:
*************************************/
int PASCAL WinMain (HINSTANCE hInstance, HINSTANCE hPrevInstance,
	LPSTR lpszCmdLine, int nCmdShow) {
  MSG msg;			/* Message returned from message loop */
  WNDCLASS wndclass;		/* Sherlock window class */
  char watsonStack[4096];

  nCmdShow = nCmdShow;
  lpszCmdLine = lpszCmdLine;
  newsp = watsonStack + sizeof(watsonStack);
  hInst = hInstance;
  hTask = GetCurrentTask();

  /* Check if Sherlock is already running */
  if (!hPrevInstance) {

    if (!LoadStringResources()) {
      MessageBox(NULL, "Dr. Watson could not load all string resources",
                 szAppNameVers, MB_ICONEXCLAMATION | MB_OK | MB_SYSTEMMODAL);
      return 1;
    }

    /* Define a new window class */
    wndclass.style = CS_HREDRAW | CS_VREDRAW | CS_DBLCLKS;
    wndclass.lpfnWndProc = SherlockWndProc;
    wndclass.cbClsExtra = 0;
    wndclass.cbWndExtra = 0;
    wndclass.hInstance = hInstance;
    wndclass.hIcon = LoadIcon (hInstance, szAppNameShortMacro "Icon");
    wndclass.hCursor = LoadCursor (NULL,IDC_ARROW);
    wndclass.hbrBackground = GetStockObject (WHITE_BRUSH);
    wndclass.lpszMenuName = NULL;
    wndclass.lpszClassName = szAppName;

    if (!RegisterClass (&wndclass)) {
      MessageBox(NULL, STR(ClassMsg), szAppNameVers, MB_ICONEXCLAMATION | MB_OK |
		MB_SYSTEMMODAL);
      return 1;
    }
  } else {
    /* Instance is already running, issue warning and terminate */
    MessageBox (NULL, STR(ErrMsg), szAppNameVers, MB_ICONEXCLAMATION | MB_OK |
		MB_SYSTEMMODAL);
    return 1;
  }

  /* Create window and display in iconic form */
  hWnd = CreateWindow (szAppName, szAppName, WS_OVERLAPPEDWINDOW, CW_USEDEFAULT,
		       0, CW_USEDEFAULT, 0, NULL, NULL, hInstance, NULL);

  ShowWindow (hWnd, SW_SHOWMINNOACTIVE);
  UpdateWindow (hWnd);

  if (!InitSherlock()) {
    MessageBox (/*NULL*/hWnd, STR(Vers), szAppNameVers, MB_ICONEXCLAMATION | MB_OK |
		MB_SYSTEMMODAL);
    DestroyWindow(hWnd);
    return 1;
  }

  if (!noTime) PutDate(STR(Start));
  init = 1;

  while (GetMessage (&msg, NULL, 0, 0)) {/* Enter message loop */
     TranslateMessage (&msg);
     DispatchMessage (&msg);
     imTrying = 0;
  }

  Moriarty();	/* Remove Sherlock GP Handler from GP Handler chain */

  return msg.wParam;
} /* WinMain */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\sherlock\disasm.h ===
/* Disasm.h - definitions for Don's Tiny Disassembler */

typedef unsigned long dword;
typedef unsigned short word;
typedef unsigned char byte;


extern word memOp;	/* actual operation performed */
extern char *memName[];	/* name corresponding to memOp */
enum { memNOP, memRead, memWrite, memRMW, memSegReg, memSegMem};

extern word memSeg;	/* value of segment of memory address */
extern dword memLinear,	/* offset of operand */
  memLinear2;
extern word memSeg2,	/* duplicate of above if dual mem op */
  memSize2, memOp2,
  memDouble;		/* true if two-mem-operand instruction */

extern word memSize;	/* bytes of memory of operation */
enum { MemByte=1, MemWord=2, MemDWord=4, MemQWord=8, MemTword=10,
	Adr4, Adr6=6};

enum { memNoSeg, memES, memCS, memSS, memDS, memFS, memGS};

enum {strCX=1, strSI=2, strDI=4, segDS=8, segES=16, segFS=32, segGS=64};
extern word gpSafe,	/* 1 if may continue instruction */
  gpRegs,		/* regs which instruction modifies as side effect */
  gpStack;		/* amount stack is changed by */

  /* DisAsm86 is my nifty 80x86 disassembler (even handles 32 bit code)	*/
  /* Given current CS:IP, it disassembles the instruction, and returns	*/
  /* the number of code bytes used, and a pointer to a static array of	*/
  /* chars holding the disassembly.  It also sets up a bunch of global	*/
  /* vars indicating what memory operations occurred, to aid in decoding */
  /* the fault type.							*/
extern char *DisAsm86(byte far *cp, int *len);


  /* Same as DisAsm86, but assumes 32 bit code and data */
extern char *DisAsm386(byte far *cp, int *len);

extern char hexData[];

#if !defined(MS_DOS)
#define sprintf wsprintf
#define vsprintf wvsprintf
#define FP void far *
#else
#define FP void *
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\sherlock\disasm.c ===
/* disasm.c
   Future Features -

   Current bugs -
     Data32 for
       (callf  fword ptr [mem]), (jmpf  fword ptr [mem])
     Floating point insns
     Call not tested
     jecxz disassembled as large_address, not large_data
     lidt/lgdt are 6-byte operands
     segload doesn't set memXxxxx vars
     some 0x0f opcodes should set gpSafe flag
       bt, bts, btr, btc
       SetBcc [mem]
       SHD[l,r]
*/

#include <string.h>
#include <windows.h>	/* wsprintf() */
#include "disasm.h"

#define STATIC /* static */

STATIC byte lookup[256];	/* lookup table for first byte of opcode */

STATIC int dataSize, adrSize,	/* flag to indicate 32 bit data/code */
  segSize;			/* flag if 32 bit code segment */
STATIC char *preSeg = "";	/* segment prefix string */
/* static char *prefix = "";	/* REP/REPE prefix string */

enum {				/* operand decoding classes */
	UNK, 	NOOP, 	BREG, 	VREG, 	SREG,	BWI, 	BRI, 	WRI,
	SMOV, 	IMOV, 	IBYTE, 	IWORD,	JMPW,	JMPB, 	LEA,	JCond,
	GrpF,	Grp1,	Grp2,	Grp3,	Grp4,	Grp5,	IADR,	MOVABS,
	RRM,	RRMW,	IMUL,	POPMEM,	TEST,	ENTER,	FLOP,	ARPL,
	INOUT,	IWORD1, ASCII,	XLAT,
};

STATIC char bregs[8][3] = {"al", "cl", "dl", "bl", "ah", "ch", "dh", "bh"};
STATIC char wregs[8][3] = {"ax", "cx", "dx", "bx", "sp", "bp", "si", "di"};
STATIC char dregs[8][4] = {"eax", "ecx", "edx", "ebx", "esp", "ebp", "esi", "edi"};

STATIC char sregs[8][3] = {"es", "cs", "ss", "ds", "fs", "gs", "?", "?"};
STATIC char grp1[8][4] = {"add", "or", "adc", "sbb", "and", "sub", "xor", "cmp"};
STATIC char grp2[8][4] = {"rol", "ror", "rcl", "rcr", "shl", "shr", "shl", "sar"};
STATIC char grp3[8][5] = {"test", "?", "not", "neg", "mul", "imul", "div", "idiv"};
STATIC char grp5[8][6] = {"inc", "dec", "call", "callf", "jmp", "jmpf", "push", "?"};
STATIC char grp6[8][5] = {"sldt", "str", "lldt", "ltr", "verr", "verw", "?", "?"};
STATIC char grp7[8][7] = {"sgdt", "sidt", "lgdt", "lidt", "smsw", "?", "lmsw", "invlpg"};
STATIC char grp8[8][4] = {"?", "?", "?", "?", "bt", "bts", "btr", "btc"};
STATIC char *jcond[] = {"jo", "jno", "jb", "jae", "jz", "jnz", "jbe", "ja",
			"js", "jns", "jp", "jnp", "jl", "jge", "jle", "jg"};

#define opBase 0
STATIC struct {
  char *name;		/* opcode mnemonic */
  byte base, count;	/* first table entry, number of entries */
  byte operand;		/* operand class */
} ops[] = {
  "?UNKNOWN", 0, 0, UNK,	"add", 0x00, 6, BWI,
  "or",  0x08, 6, BWI,		"FGrp", 0x0f, 1, GrpF,
  "adc", 0x10, 6, BWI,		"sbb", 0x18, 6, BWI,
  "and", 0x20, 6, BWI,		"sub", 0x28, 6, BWI,
  "xor", 0x30, 6, BWI,		"cmp", 0x38, 6, BWI,
  "inc", 0x40, 8, VREG,		"dec", 0x48, 8, VREG,
  "push", 0x50, 8, VREG,	"pop", 0x58, 8, VREG,
  "bound", 0x62, 1, RRMW,	"arpl", 0x63, 1, ARPL,
  "push", 0x68, 1, IWORD,	"imul", 0x69, 3, IMUL,
  "push", 0x6a, 1, IBYTE,	"jcond", 0x70, 16, JCond,
  "Grp1", 0x80, 4, Grp1,	"test", 0x84, 2, RRM,
  "xchg", 0x86, 2, RRM,		"mov", 0x88, 4, BWI,
  "mov", 0x8c, 3, SMOV,		"lea", 0x8d, 1, LEA,
  "pop", 0x8f, 1, POPMEM,       "xchg", 0x90, 8, VREG,
  "callf", 0x9a, 1, IADR,	"mov", 0xa0, 4, MOVABS,
  "test", 0xa8, 2, TEST,	"mov", 0xb0, 8, BRI,
  "mov", 0xb8, 8, WRI,		"Grp2", 0xc0, 2, Grp2,
  "retn", 0xc2, 1, IWORD1,	"les", 0xc4, 1, RRMW,
  "lds", 0xc5, 1, RRMW,		"mov", 0xc6, 2, IMOV,
  "enter", 0xc8, 1, ENTER,	"retf", 0xca, 1, IWORD1,
  "int", 0xcd, 1, IBYTE,	"Grp2", 0xd0, 4, Grp2,
  "aam", 0xd4, 1, ASCII,	"aad", 0xd5, 1, ASCII,
  "xlat", 0xd7, 1, XLAT,
  "float", 0xd8, 8, FLOP,	"loopne", 0xe0, 1, JMPB,
  "loope", 0xe1, 1, JMPB,	"loop", 0xe2, 1, JMPB,
  "jcxz", 0xe3, 1, JMPB,	"in", 0xe4, 2, INOUT,
  "out", 0xe6, 2, INOUT,	"call", 0xe8, 1, JMPW,
  "jmp", 0xe9, 1, JMPW,		"jmpf", 0xea, 1, IADR,
  "jmp", 0xeb, 1, JMPB,		"Grp3", 0xf6, 2, Grp3,
  "Grp4", 0xfe, 1, Grp4,	"Grp5", 0xff, 1, Grp5,
};
#define opCnt (sizeof(ops)/sizeof(ops[0]))

#define simpleBase (opBase + opCnt)
STATIC struct {			/* these are single byte opcodes, no decode */
  byte val;
  char *name;
} simple[] = {
  0x06, "push	es",
  0x07, "pop	es",
  0x0e, "push	cs",
  0x16, "push	ss",
  0x17,	"pop	ss",
  0x1e, "push	ds",
  0x1f, "pop	ds",
  0x27, "daa",
  0x2f, "das",
  0x37, "aaa",
  0x3f, "aas",
  0x90, "nop",
  0x9b, "wait",
  0x9e, "sahf",
  0x9f, "lahf",
  0xc3, "retn",
  0xc9, "leave",
  0xcb, "retf",
  0xcc, "int	3",
  0xce, "into",
  0xec, "in	al, dx",
  0xee, "out	dx, al",
  0xf0, "lock",
  0xf2, "repne",
  0xf3, "rep/repe",
  0xf4, "hlt",
  0xf5, "cmc",
  0xf8, "clc",
  0xf9, "stc",
  0xfa, "cli",
  0xfb, "sti",
  0xfc, "cld",
  0xfd, "std",
};
#define simpleCnt (sizeof(simple)/sizeof(simple[0]))

#define dSimpleBase (simpleBase + simpleCnt)
STATIC struct {			/* these are simple opcodes that change */
  byte val;			/* based on current data size */
  char *name, *name32;
} dsimple[] = {
  0x60, "pusha", "pushad",
  0x61, "popa", "popad",
  0x98, "cbw", "cwde",
  0x99, "cwd", "cdq",
  0x9c, "pushf", "pushfd",
  0x9d, "popf", "popfd",
  0xcf, "iret", "iretd",
  0xed, "in	ax, dx", "in	eax, dx",
  0xef, "out	dx, ax", "out	dx, eax",
};
#define dSimpleCnt (sizeof(dsimple)/sizeof(dsimple[0]))

#define STR_S 1				/* string op, source regs */
#define STR_D 2				/* string op, dest regs */
#define STR_D_Read	4		/* string op, reads from dest regs */
#define STR_NO_COND	8		/* rep ignores flags */
#define stringOpBase (dSimpleBase+ dSimpleCnt)
STATIC struct {
  byte val;
  char *name;
  byte flag;		/* should be 'next' to op, to pack nicely */
} stringOp[] = {
  0x6c, "ins", STR_D | STR_NO_COND,
  0x6e, "outs", STR_S | STR_NO_COND,
  0xa4, "movs", STR_S | STR_D | STR_NO_COND,
  0xa6, "cmps", STR_S | STR_D | STR_D_Read,
  0xaa, "stos", STR_D | STR_NO_COND,
  0xac, "lods", STR_S | STR_NO_COND,
  0xae, "scas", STR_D | STR_D_Read,
};
#define stringOpCnt (sizeof(stringOp)/sizeof(stringOp[0]))

STATIC void InitDisAsm86(void) {
  int i, j;
  for (i=0; i<opCnt; i++) {		/* Init complex entries */
    for (j=0; j<(int)ops[i].count; j++)
      lookup[ops[i].base+j] = (byte)i + opBase;
  }

  for (i=0; i<simpleCnt; i++)		/* Init simple entries */
    lookup[simple[i].val] = (byte)(i + simpleBase);

  for (i=0; i<dSimpleCnt; i++)		/* Init simple 16/32 bit entries */
    lookup[dsimple[i].val] = (byte)(i + dSimpleBase);

  for (i=0; i<stringOpCnt; i++)	{	/* Init string op table */
    lookup[stringOp[i].val] = (byte)(i + stringOpBase);
    lookup[stringOp[i].val+1] = (byte)(i + stringOpBase);
  }
} /* InitDisAsm86 */

STATIC byte far *code;		/* this is ugly - it saves passing current */
				/* code position to all the GetByte() funcs */

#define Mid(v) (((v) >> 3) & 7)	/* extract middle 3 bits from a byte */

word gpSafe, gpRegs, gpStack;	/* indicate side effects of instruction */

extern word regs[];		/* this is a lie - this is really a struct - */
extern dword regs32[];		/* and so is this - but array access is more */
				/* convenient in this module */

  /* If you don't want to return memory access info, #def NO_MEM */
#if !defined(NO_MEM)
  /* global vars set by DisAsm() to indicate current instruction's memory */
  /* access type. */
word memSeg, memSize, memOp;	/* segment value, operand size, operation */
word memSeg2, memSize2, memOp2,	/* instruction may have two memory accesses */
  memDouble;
dword memLinear, memLinear2;	/* offset from segment of access */

STATIC dword memReg, memDisp;	/* used to pass information from GetReg()... */
char *memName[] = {		/* used to convert 'enum memOp' to ascii */
  "NOP",
  "Read",
  "Write",
  "RMW",
  "MovStr",
};

#define SetMemSize(s) memSize = s
#define SetMemSeg(s) memSeg = regs[s+9]
#define SetMemOp(o) memOp = o
#define SetMemLinear(l) memLinear = l
#define SetMemSeg2(s) memSeg2 = regs[s+9]
#define SetMemOp2(o) memOp2 = o
#define SetMemLinear2(l) memLinear2 = l
#define ModMemLinear(l) memLinear += l
#define SetMemReg(r) memReg = r
#define SetMemDisp(d) memDisp = d
#define Read_RMW(o) ((o) ? memRead : memRMW)

#else

#define SetMemSeg(s)
#define SetMemSize(s)
#define SetMemOp(o)
#define SetMemLinear(l)
#define SetMemSeg2(s)
#define SetMemOp2(o)
#define SetMemLinear2(l)
#define ModMemLinear(l)
#define SetMemReg(r)
#define SetMemDisp(d)
#define Read_RMW(o)	0

#endif

/******************** Register Decode *******************************/
/* These helper functions return char pointers to register names.
   They are safe to call multiple times, as the return values are not
   stored in a single buffer.  The ?Reg() functions are passed a register
   number.  They mask this with 7, so you can pass in the raw opcode.
   The ?Mid() functions extract the register field from e.g. a ModRM byte.
   The Vxxx() functions look at dataSize to choose between 16 and 32 bit
   registers.  The Xxxx() functions look at the passed in W bit, and then
   the dataSize global, do decide between 8, 16, and 32 bit registers.
*/

STATIC char *BReg(int reg) {			/* Byte Registers */
  reg &= 7;
  SetMemReg(((byte *)regs)[reg]);
  return bregs[reg];
} /* BReg */

STATIC char *BMid(int reg) {
  return BReg(Mid(reg));
} /* BMid */

STATIC char *WReg(int reg) {			/* Word Registers */
  reg &= 7;
  SetMemReg(regs[reg]);
  return wregs[reg];
} /* WReg */

/* STATIC char *WMid(int op) {
  return WReg(Mid(op));
} /* WMid */

STATIC char *DReg(int reg) {			/* DWord Registers */
  reg &= 7;
  SetMemReg(regs32[reg]);
  return dregs[reg];
} /* DReg */

STATIC char *DMid(int op) {
  return DReg(Mid(op));
} /* DMid */

STATIC char *VReg(int reg) {			/* Word or DWord Registers */
  if (dataSize) return DReg(reg);
  return WReg(reg);
} /* VReg */

STATIC char *VMid(int op) {
  return VReg(Mid(op));
} /* VMid */

STATIC char *XReg(int w, int reg) {		/* Byte, Word, DWord Registers */
  if (!w) return BReg(reg);
  return VReg(reg);
} /* XReg */

STATIC char *XMid(int w, int op) {
  return XReg(w, Mid(op));
} /* XMid */

/************************* Opcode Fetch ***************************/

  /* hexData is a global array, containing a hexadecimal dump of the */
  /* opcodes of the last instruction disassembled. */
char hexData[40];		/* We dump the opcode fetched here */
STATIC int hexPos;		/* current position in hexData buffer */

  /* GetByte(), GetWord(), and GetDWord() read from the code segment */
  /* and increment the pointer appropriately.  They also add the current */
  /* value to the hexData display, and set the MemDisp global in case the */
  /* value fetched was a memory displacement */
STATIC byte GetByte(void) {             /* Read one byte from code segment */
  sprintf(hexData+hexPos, " %02x", *code);
  hexPos += 3;
  SetMemDisp(*code);
  return *code++;
} /* GetByte */

STATIC word GetWord(void) {		/* Read two bytes from code seg */
  word w = *(word far *)code;
  sprintf(hexData+hexPos, " %04x", w);
  hexPos += 5;
  code += 2;
  SetMemDisp(w);
  return w;
} /* GetWord */

STATIC long GetDWord(void) {		/* Read four bytes from code seg */
  unsigned long l = *(long far *)code;
  sprintf(hexData+hexPos, " %08lx", l);
  hexPos += 9;
  code += 4;
  SetMemDisp(l);
  return l;
} /* GetDWord */


STATIC char immData[9];			/* Get Immediate values from code */


  /* GetImmByte(), GetImmWord(), and GetImmDWord() all get the proper size */
  /* data object, convert it to hex/ascii, and return the string created. */
  /* They return a pointer to a shared static object, so don't combine */
  /* multiple calls to these functions in a single expression. */
STATIC char *GetImmByte(void) {
  sprintf(immData, "%02x", GetByte());
  return immData;
} /* GetImmByte */

STATIC char *GetSImmByte(void) {
  sprintf(immData, "%02x", (char)GetByte());
  memDisp = (signed char)memDisp;	/* sign extend */
  return immData;
} /* GetSImmByte */

STATIC char *GetImmWord(void) {
  sprintf(immData, "%04x", GetWord());
  return immData;
} /* GetImmWord */

STATIC char *GetImmDWord(void) {
  sprintf(immData, "%08lx", GetDWord());
  return immData;
} /* GetImmDWord */

  /* GetImmAdr() and GetImmData() call GetImm????() as required by the */
  /* 'width' flag passed in, and the adrSize or dataSize global flags. */
  /* They return the proper character string - note that these just call */
  /* GetImm????(), and use the same static buffer, so don't call more than */
  /* once in a single expression */
STATIC char *GetImmAdr(int w) {		/* Get an immediate address value */
  if (!w) return GetImmByte();
  else if (!adrSize) return GetImmWord();
  return GetImmDWord();
} /* GetImmAdr */

STATIC char *GetImmData(int w) {	/* Get an immediate data value */
  if (!w) return GetImmByte();
  else if (!dataSize) return GetImmWord();
  return GetImmDWord();
} /* GetImmData */

/************************* Helper Functions **************************/

STATIC char *JRel(int jsize) {		/* Perform relative jump sizing */
  long rel;
  static char adr[9];
  char *s;

  if (jsize < 2) {
    rel = (char)GetByte();
    s = "short ";
  } else if (!adrSize) {
    rel = (short)GetWord();
    s = "near ";
  } else {
    rel = GetDWord();
    s = "";
  }
  rel += (word)(long)code;
  sprintf(adr, adrSize ? "%s%08lx" : "%s%04lx", (FP)s, rel);
  return adr;
} /* JRel */


enum {
  RegAX, RegCX, RegDX, RegBX, RegSP, RegBP, RegSI, RegDI
};

#define Reg1(r1) (r1) | 0x80
#define Reg2(r1, r2) (r1 | (r2 << 4))
#define RegSS 8

STATIC byte rms[] = {			/* 16 bit addressing modes */
  Reg2(RegBX, RegSI),
  Reg2(RegBX, RegDI),
  Reg2(RegBP|RegSS, RegSI),		/* if base reg is BP, def seg is SS */
  Reg2(RegBP|RegSS, RegDI),
  Reg1(RegSI),
  Reg1(RegDI),
  Reg1(RegBP|RegSS),
  Reg1(RegBX),
};

  /* Based on the second byte of opcode, width flag, adrSize and dataSize, */
  /* determine the disassembly of the current instruction, and what */
  /* memory address was referenced */
  /* needinfo indicates that we need a size override on a memory operand */
  /* for example, "mov [bx], ax" is obviously a 16 bit move, while */
  /* "mov [bx], 0" could be 8, 16, or 32 bit.  We add the proper */
  /* "mov word ptr [bx], 0" information. */
  /* The 'mem' parameter indicates the kind of operation, Read, Write, RMW */

  /* don't bother trying to understand this code without an Intel manual */
  /* and assembler nearby. :-) */
STATIC char *ModRMGeneral(byte op, int w, int needInfo, int mem) {
  static char m[30];			/* write result to this static buf */
  int mod = op >> 6;
  int rm = op & 7;
  char *size, *base, *index, *disp;
  char indexBuf[6];

  base = index = disp = "";
  if (!w) {				/* set mem size, and info string */
    size = "byte ptr ";
    SetMemSize(1);
  } else if (!dataSize) {
    size = "word ptr ";
    SetMemSize(2);
  } else {
    size = "dword ptr ";
    SetMemSize(4);
  }
  if (!needInfo) size = "";		/* never-mind */

  if (adrSize) {			/* do 32 bit addressing */
    if (mod == 3) return XReg(w, rm);	/* register operand */

    if (rm == 4) {			/* [esp+?] is special S-I-B style */
      byte sib = GetByte();
      int scaleVal = sib >> 6, indexVal = Mid(sib), baseVal = sib & 7;

      SetMemLinear(0);
      if (baseVal == 5 && mod == 0)	/* [ebp+{s_i}] becomes [d32+{s_i}] */
	mod = 2;
      else {
	base = DReg(baseVal);
	ModMemLinear(memReg);
      }

      if (indexVal != 4) {		/* [base+esp*X] is undefined */
	sprintf(indexBuf, "%s*%d", (FP)DMid(sib), 1 << scaleVal);
	index = indexBuf;
	ModMemLinear(memReg << scaleVal);
      }
    } else {				/* not S-I-B */
      if (mod == 0 && rm == 5) mod = 2;	/* [ebp] becomes [d32] */
      else base = DReg(rm);
    }

    if (mod==1) disp = GetImmAdr(0);
    else if (mod == 2) disp = GetImmAdr(1);
    if (mod) ModMemLinear(memDisp);

  } else {				/* do 16 bit addressing */
    if (mod == 3) return XReg(w, rm);	/* register operand */
    if (mod == 0 && rm == 6) {		/* [bp] becomes [mem16] */
      disp = GetImmAdr(1);
      SetMemLinear(memDisp);
    } else {
      base = WReg(rms[rm] & 7);
      SetMemLinear(memReg);
      if (!(rms[rm] & 0x80)) {		/* if two-reg effective address */
	index = WReg(rms[rm] >> 4);
	ModMemLinear(memReg);
      }
      if (rms[rm] & RegSS && !preSeg[0]) { /* BP is relative to SS */
	SetMemSeg(memSS);
      }
      if (mod) {			/* (mod3 already returned) */
	disp = GetImmAdr(mod-1);	/* mod==1 is byte, mod==2 is (d)word */
	ModMemLinear(memDisp);
      }
    }
  }
  sprintf(m, "%s%s[%s", (FP)size, (FP)preSeg, (FP)base);
  if (*index) strcat(strcat(m, "+"), index);
  if (*disp) {
    if (*base || *index) strcat(m, "+");
    strcat(m, disp);
  }
  SetMemOp(mem);
  strcat(m, "]");
  return m;
} /* ModRMGeneral */

  /* magic func that sets 'info-required' flag to ModRMGeneral */
STATIC char *ModRMInfo(byte op, int w, int mem) {
  return ModRMGeneral(op, w, 1, mem);
} /* ModRMInfo */

  /* magic func that doesn't require info */
STATIC char *ModRM(byte op, int w, int mem) {
  return ModRMGeneral(op, w, 0, mem);
} /* ModRM */


STATIC char line[80];	/* this is bad - global var where insn is created */

  /* CatX() - combine opcode and 0 to 3 operands, store in line[] */
  /* It places the TAB after the opcode, and ', ' between operands */

STATIC char *Cat0(char *s0) {
  return strcat(line, s0);
#if 0
  if (prefix[0]) {
    char temp[80];
    if (s0 == line) {
      strcpy(temp, s0);
      s0 = temp;
    }
    strcat(strcpy(line, prefix), s0);
    prefix = "";
  } else strcpy(line, s0);
  return line;
#endif
} /* Cat0 */

STATIC char *Cat1(char *s0, char *s1) {
  return strcat(strcat(Cat0(s0), "\t"), s1);
} /* Cat1 */

STATIC char *Cat2(char *s0, char *s1, char *s2) {
  return strcat(strcat(Cat1(s0, s1), ", "), s2);
} /* Cat2 */

STATIC char *Cat3(char *s0, char *s1, char *s2, char *s3) {
  return strcat(strcat(Cat2(s0, s1, s2), ", "), s3);
} /* Cat3 */

#define SetGroup(g) /* group = g */
/* STATIC int group; */

  /* Disassemble the 386 instructions whose first opcode is 0x0f */
  /* Sorry, but this is just too ugly to comment */
STATIC char *DisAsmF(void) {
  byte op0, op1;
  char temp[8];
  char *s0, *s1;
  int mask;

  op0 = GetByte();
  switch (op0 >> 4) {			/* switch on top 4 bits of opcode */
    case 0:
      switch (op0 & 0xf) {
	case 0: /* grp6 */
	  SetGroup(2);
	  op1 = GetByte();
	  dataSize = 0;
	  return Cat1(grp6[Mid(op1)], ModRMInfo(op1, 1, Read_RMW(Mid(op1) >= 2)));
	case 1: /* grp7 */
	  SetGroup(2);
	  op1 = GetByte();
	  dataSize = 0;
	  return Cat1(grp7[Mid(op1)], ModRMInfo(op1, 1, Read_RMW(Mid(op1) & 2)));
	case 2:
	  op1 = GetByte();
	  s1 = VMid(op1);
	  /* dataSize = 0; */
	  return Cat2("lar", s1, ModRMInfo(op1, 1, memRead));
	case 3:
	  op1 = GetByte();
	  s1 = VMid(op1);
	  /* dataSize = 0; */
	  return Cat2("lsl", s1, ModRMInfo(op1, 1, memRead));
	case 6: return "clts";
	case 8: return "invd";
	case 9: return "wbinvd";
      }
      break;

    case 2:	/* Mov C/D/Treg, reg */
      op1 = GetByte();
      switch (op0 & 0xf) {
	case 0:
	case 2:
	  s1 = "c";
	  mask = 1 + 4 + 8;
	  break;
	case 1:
	case 3:
	  s1 = "d";
	  mask = 1 + 2 + 4 + 8 + 64 + 128;
	  break;
	case 4:
	case 6:
	  s1 = "t";
	  mask = 8 + 16 + 32 + 64 + 128;
	  break;
	default:
	  s1 = "??";
	  mask = 0;
      }
      if (!((1 << Mid(op1)) & mask))	/* various legal register combos */
	return "Illegal reg";

      s0 = DReg(op1);
      if (op0 & 2) sprintf(line, "mov\t%sr%d, %s", (FP)s1, Mid(op1), (FP)s0);
      else sprintf(line, "mov\t%s, %sr%d", (FP)s0, (FP)s1, Mid(op1));
      return line;

    case 8: /* long displacement jump on condition */
      return Cat1(jcond[op0&0xf], JRel(2));

    case 9: /* byte set on condition */
      strcpy(temp, "set");
      strcat(temp, jcond[op0&0xf]+1);
      return Cat1(temp, ModRMInfo(GetByte(), 0, memWrite));

    case 0xa:
      switch (op0 & 0xf) {
	case 0: return "push	fs";
	case 1: return "pop	fs";
	case 3: case 0xb:
	  s0 = op0 & 8 ? "bts" : "bt";
	  op1 = GetByte();
	  return Cat2(s0, ModRM(op1, 1, memRMW), VMid(op1));
	case 4: case 0xc:
	  s0 = op0 & 8 ? "shrd" : "shld";
	  op1 = GetByte();
	  s1 = ModRM(op1, 1, memRMW);
	  return Cat3(s0, s1, VMid(op1), GetImmData(0));
	case 5: case 0xd:
	  s0 = op0 & 8 ? "shrd" : "shld";
	  op1 = GetByte();
	  s1 = ModRM(op1, 1, memRMW);
	  return Cat3(s0, s1, VMid(op1), "cl");
	case 6:
	  op1 = GetByte();
	  return Cat2("cmpxchg", ModRM(op1, 0, memRMW), BMid(op1));
	case 7:
	  op1 = GetByte();
	  return Cat2("cmpxchg", ModRM(op1, 1, memRMW), VMid(op1));
	case 8: return "push	gs";
	case 9: return "pop	gs";
	case 0xf:
	  op1 = GetByte();
	  return Cat2("imul", VMid(op1), ModRM(op1, 1, memRead));
      }
      break;

    case 0xb:
      switch (op0 & 0xf) {
	case 2:	case 4: case 5:
	  s0 = (op0 & 2) ? "lss" : (op0 &1) ? "lgs" : "lfs";
	  op1 = GetByte();
	  return Cat2(s0, VMid(op1), ModRM(op1, 1, memRead));
	case 3: case 0xb:
	  s0 = (op0 & 8) ? "btc": "btr";
	  op1 = GetByte();
	  return Cat2(s0, ModRM(op1, 1, memRMW), VMid(op1));
	case 6: case 7: case 0xe: case 0xf:
	  s0 = (op0 & 8) ? "movsx" : "movzx";
	  op1 = GetByte();
	  s1 = VMid(op1);
	  dataSize = 0;
	  return Cat2(s0, s1, ModRMInfo(op1, op0&1, memRead));
	case 0xa:
	  SetGroup(2);
	  op1 = GetByte();
	  s0 = grp8[Mid(op1)];
	  s1 = ModRMInfo(op1, 1, memRMW);
	  return Cat2(s0, s1, GetImmData(0));
	case 0xc: case 0xd:
	  op1 = GetByte();
	  s0 = (op0 & 1) ? "bsr" : "bsf";
	  return Cat2(s0, VMid(op1), ModRM(op1, 1, memRead));
      }
      break;

    case 0xc:
      if (op0 > 0xc7) return Cat1("bswap", DReg(op0 & 7));
      if (op0 < 0xc2) {
	op1 = GetByte();
	return Cat2("xadd", ModRM(op1, op0&1, memRMW), XMid(op0&1, op1));
      }
      break;
    default:
      break;
  }
  sprintf(line, "?Unknown 0f %02x", op0);
  return line;
} /* DisAsmF */

int IsPrefix(byte op0) {
  switch (op0) {			/* check for prefix bytes */

#define CSEG 0x2e
#define DSEG 0x3e
#define ESEG 0x26
#define SSEG 0x36
#define FSEG 0x64
#define GSEG 0x65
#define REP 0xf3
#define REPNE 0xf2
#define DATA32 0x66
#define ADR32 0x67

    case CSEG:  preSeg = "cs:"; SetMemSeg(memCS); break;
    case DSEG:  preSeg = "ds:"; SetMemSeg(memDS); break;
    case ESEG:  preSeg = "es:"; SetMemSeg(memES); break;
    case SSEG:  preSeg = "ss:"; SetMemSeg(memSS); break;
    case FSEG:  preSeg = "fs:"; SetMemSeg(memFS); break;
    case GSEG:  preSeg = "gs:"; SetMemSeg(memGS); break;
    case REP:   strcpy(line, "repe\t"); gpRegs |= strCX; break;
    case REPNE: strcpy(line, "repne\t"); gpRegs |= strCX; break;
    case ADR32:
      /* printf("Adr32\n"); */
      adrSize = !adrSize; break;
    case DATA32:
      /* printf("Data32\n"); */
      dataSize = !dataSize; break;
    default:
      return 0;
  }
  return 1;
} /* IsPrefix */

  /* like, call this with a pointer to the instruction, it will return */
  /* the opcode bytes used in *len, and a pointer to the disassembled insn */
char *DisAsm86(byte far *codeParm, int *len) {
  byte far *oldcode;
  byte op0, op1;
  byte opclass;
  static int init;
  char operand[40];
  char *(*Reg)(int);
  char *s0, *s1, *s2, *s3;

  if (!init) {
    InitDisAsm86();
    init = 1;
  }
  adrSize = dataSize = segSize;
  preSeg = "";
  hexPos = 0;
  memDouble = 0;
  line[0] = 0;
  gpSafe = gpRegs = gpStack = 0;
  code = oldcode = codeParm;
  do {
    op0 = GetByte();
  } while (IsPrefix(op0));
  opclass = lookup[op0];

  SetMemOp(memNOP);
  if (!preSeg[0]) SetMemSeg(memDS);

  if (opclass >= simpleBase) {		/* is it special */
    if (opclass >= stringOpBase) {	/* string operations? */
      char cmd;

      opclass -= stringOpBase;
      cmd = stringOp[opclass].flag;
      if (cmd & STR_NO_COND) strcpy(line+3, "\t");
      if (cmd & STR_S) {
	gpRegs |= strSI;
	SetMemOp(memRead);
	/* DS already set */
	VReg(RegSI);
	SetMemLinear(memReg);
	if (cmd & STR_D) {
	  gpRegs |= strDI;
	  SetMemOp2(cmd & STR_D_Read ? memRead : memWrite);
	  SetMemSeg2(memES);
	  VReg(RegDI);
	  SetMemLinear2(memReg);
	  memDouble = 1;
	}
      } else {
	gpRegs |= strDI;
	SetMemOp(cmd & STR_D_Read ? memRead : memWrite);
	SetMemSeg(memES);
	VReg(RegDI);
	SetMemLinear(memReg);
      }

      if (op0 & 1) {
	if (dataSize) { s1 = "d"; SetMemSize(4); }
	else { s1 = "w"; SetMemSize(2); }
      } else { s1 = "b"; SetMemSize(1); }


      s0 = strcat(strcpy(operand, stringOp[opclass].name), s1);
    } else if (opclass >= dSimpleBase) {
      opclass -= dSimpleBase;
      s0 = dataSize ? dsimple[opclass].name32 : dsimple[opclass].name;
    } else {
      s0 = simple[opclass-simpleBase].name;
      if (op0 == 7) {			/* pop ES */
	gpRegs = segES;
	gpSafe = 1;
	gpStack = 1;
      } else if (op0 == 0x1f) {		/* pop DS */
	gpRegs = segDS;
	gpSafe = 1;
	gpStack = 1;
      }
    }
    Cat0(s0);
    goto DisAsmDone;
  }

  if (op0 == 0x0f) {			/* is it an extended opcode? */
    s0 = DisAsmF();
    strcpy(line, s0);
    goto DisAsmDone;
  }

  s0 = ops[opclass].name;
  switch (ops[opclass].operand) {
    case NOOP:
      Cat0(s0);
      break;

    case VREG:	/* inc, dec, push, pop, xchg */
      if ((op0 & ~7) == 0x90) Cat2(s0, "ax", VReg(op0&7));
      else Cat1(s0, VReg(op0&7));
      /* Set memop for Push/Pop as modifying stack values */
      break;

    case BWI:	/* byte/word/immediate */
      gpSafe = 1;
      if (!(op0&1)) Reg = BReg;
      else if (!dataSize) Reg = WReg;
      else Reg = DReg;
      if (op0 & 4) {
	Cat2(s0, Reg(0), GetImmData(op0&1));
      } else {
	int i;
	op1 = GetByte();
	if ((op0 & 0xf8) == 0x38) i = memRead;
	else if ((op0 & 0xfe) == 0x88) i = memWrite;
	else i = Read_RMW(op0 & 2);
	s1 = ModRM(op1, op0&1, i);
	s2 = Reg(Mid(op1));
	if (op0 & 2) {
	  s3 = s2; s2 = s1; s1 = s3;
	}
	Cat2(s0, s1, s2);
      }
      break;

    case BRI:	/* byte reg immediate */
      Cat2(s0, BReg(op0 & 7), GetImmData(0));
      break;

    case WRI:	/* word reg immediate */
      Cat2(s0, VReg(op0 & 7), GetImmData(1));
      break;

    case Grp1:	/* group 1 instructions */
      gpSafe = 1;
      SetGroup(1);
      op1 = GetByte();
      s1 = ModRMInfo(op1, op0&1, Mid(op1) == 7 ? memRead : memRMW);
      Cat2(grp1[Mid(op1)], s1, GetImmData((op0&3)==1));
      break;

    case Grp2:	/* group 2 instructions */
      gpSafe = 1;
      SetGroup(1);
      op1 = GetByte();
      s1 = ModRMInfo(op1, op0&1, memRMW);
      s2 = (op0 & 0x10) ? (op0 & 2 ? "cl" : "1")  : GetImmData(0);
      Cat2(grp2[Mid(op1)], s1, s2);
      break;

    case Grp3:	/* group 3 instructions */
      gpSafe = 1;
      SetGroup(1);
      op1 = GetByte();
      s1 = ModRMInfo(op1, op0&1, Read_RMW(Mid(op1) <2 || Mid(op1) >3));
      s0 = grp3[Mid(op1)];
      if (Mid(op1) < 2) Cat2(s0, s1, GetImmData(op0&1));
      else Cat1(s0, s1);
      break;

    case Grp4:	/* group 4 instructions */
      SetGroup(1);
      op1 = GetByte();
      if (Mid(op1) > 1) Cat0("?");
      else {
	Cat1(grp5[Mid(op1)], ModRMInfo(op1, op0&1, memRMW));
	gpSafe = 1;
      }
      break;

    case Grp5:	/* group 5 instructions */
      op1 = GetByte();
      if (Mid(op1) < 3) {
	gpSafe = 1;
	if (Mid(op1) == 2) {
	  gpStack = -1 << dataSize;
	}
      }
      SetGroup(1);
      Cat1(grp5[Mid(op1)], ModRMInfo(op1, op0&1, Read_RMW(Mid(op1) >= 2)));
      break;

    case SMOV:	/* segment move */
      gpSafe = 1;
      op1 = GetByte();
      dataSize = 0;
      s1 = ModRM(op1, 1, Read_RMW(op0&2));
      s2 = sregs[Mid(op1)];
      if (op0 & 2) {			/* if moving _to_ SREG */
	s3 = s2; s2 = s1; s1 = s3;	/* switch operands */
	switch (Mid(op1)) {
	  case 0: gpRegs = segES; break;
	  case 3: gpRegs = segDS; break;
	  case 4: gpRegs = segFS; break;
	  case 5: gpRegs = segGS; break;
	  default: gpSafe = 0;
	}
      }
      Cat2(s0, s1, s2);
      break;

    case IMOV:	/* immediate move to reg/mem */
      gpSafe = 1;
      op1 = GetByte();
      s1 = ModRMInfo(op1, op0&1, memWrite);
      Cat2(s0, s1, GetImmData(op0&1));
      break;

    case IBYTE:	/* immediate byte to reg */
      sprintf(line, "%s\t%02x", (FP)s0, (char)GetByte());
      break;

    case IWORD:	/* immediate word to reg - size of data */
      Cat1(s0, GetImmData(1));
      break;

    case IWORD1: /* immediate word - always 16 bit */
      Cat1(s0, GetImmWord());
      break;

    case JMPW:
      Cat1(s0, JRel(2));
      break;

    case JMPB:
      Cat1(s0, JRel(1));
      break;

    case LEA:
      op1 = GetByte();
      Cat2(s0, VMid(op1), ModRM(op1, 1, memNOP));
      break;

    case JCond:
      Cat1(jcond[op0&0xf], JRel(1));
      break;

    case IADR:
      s2 = GetImmAdr(1);
      sprintf(line, "%s\t%04x:%s", (FP)s0, GetWord(), (FP)s2);
      break;

    case MOVABS: /* move between accum and abs mem address */
      gpSafe = 1;
      s1 = XReg(op0 & 1, 0);
      sprintf(operand, "[%s%s]", (FP)preSeg, (FP)GetImmAdr(1));
      SetMemLinear(memDisp);
      SetMemSize(!(op0&1) ? 1 : (!dataSize ? 2 : 4));
      SetMemOp(op0&2 ? memWrite : memRead);
      s2 = operand;
      if (op0 & 2) {
	s3 = s2; s2 = s1; s1 = s3;
      }
      Cat2(s0, s1, s2);
      break;

    case IMUL:
      op1 = GetByte();
      s1 = VMid(op1);
      s2 = ModRM(op1, 1, memRead);
      s3 = GetImmData(!(op0&2));
      Cat3(s0, s1, s2, s3);
      break;

    case POPMEM:
      gpSafe = 1;
      gpStack = 1 << dataSize;
      Cat1(s0, ModRMInfo(GetByte(), 1, memWrite));
      break;

    case RRM:	/* test and xchg */
      gpSafe = 1;
      op1 = GetByte();
      s2 = ModRM(op1, op0&1, memRMW);
      Cat2(s0, XMid(op0&1, op1), s2);
      break;

    case RRMW:	/* bound, les, lds */
      op1 = GetByte();
      switch (op0) {
	case 0xc4:	/* les reg, [mem] */
	  gpRegs = segES;
	  gpSafe = 1;
	  break;
	case 0xc5:	/* lds reg, [mem] */
	  gpRegs = segDS;
	  gpSafe = 1;
	  break;
      }
      Cat2(s0, VMid(op1), ModRM(op1, 1, memRead));
      break;

    case TEST:	/* test al/ax/eax, imm */
      Cat2(s0, XReg(op0&1, 0), GetImmData(op0&1));
      break;

    case ENTER:
      strcpy(operand, GetImmWord());
      Cat2(s0, operand, GetImmData(0));
      break;

    case FLOP:
      op1 = GetByte();
      Cat1(s0, ModRMInfo(op1, 1, memNOP));
      break;

    case ARPL:
      op1 = GetByte();
      dataSize = 0;
      s1 = ModRM(op1, 1, memRMW);
      s2 = VMid(op1);
      Cat2(s0, s1, s2);
      break;

    case INOUT:
      s1 = XReg(op0&1, 0);
      s2 = GetImmAdr(0);
      if (op0 & 2) {
	s3 = s2; s2 = s1; s1 = s3;
      }
      Cat2(s0, s1, s2);
      break;

    case ASCII:
      Cat0(GetByte() == 10 ? s0 : "?");
      break;

    case XLAT:
      gpSafe = 1;
      SetMemOp(memRead);
      SetMemLinear(regs[RegBX] + (regs[RegAX] & 0xff));
      break;

    default:
      sprintf(line, "?Unknown opcode %02x", op0);
  }
DisAsmDone:
  *len = (int)(code - oldcode);
  return line;
} /* DisAsm86 */

  /* if you're in a 32 bit code segment, call DisAsm386 which sets */
  /* default data and address size to 32 bit */
char *DisAsm386(byte far *code, int *len) {
  adrSize = dataSize = 1;
  return DisAsm86(code, len);
} /* DisAsm386 */

/* #define FOOBAR */
#if defined(FOOBAR)

STATIC int GroupSize(int op) {
  if (op == 0xf) return 256;
/*  op = lookup[op];
  if (op > 0x80) return 1;
  if (ops[op].name[0] == 'G') return 8;
  if (ops[op].name[0] == 'F') return 256; */
  return 1;
} /* IsGroup */

/* #pragma inline */

void testfunc() {
/*  asm {
	.386p
	mov	eax, ss:[si+33h]
	rep	movsb
	mov	eax, ds:[ebp+eax*2+1234h]
  } */
}


byte foo[10];

/* #include <dos.h> */

extern void DisTest(), EndTest();

word regs[] = {1, 2, 4, 8, 0x10, 0x20, 0x40, 0x80, -1, -1,
  0xeeee, 0xcccc, 0x5555, 0xdddd, 0xffff, 0x6666};
dword regs32[] = {0x100, 0x200, 0x400, 0x800, 0x1000, 0x2000, 0x4000, 0x8000};

STATIC char *Tab2Spc(char *temp) {
  char newbuf[80], *s1, *s2;
  s1 = temp;
  s2 = newbuf;
  while ((*s2 = *s1++) != 0) {
    if (*s2++ == 9) {
      s2[-1] = ' ';
      while ((s2-newbuf) & 7) *s2++ = ' ';
    }
  }
  strcpy(temp, newbuf);
  return temp;
} /* Tab2Spc */


void MemTest(void) {
  void far *vp = (void far *)DisTest;
  byte far *cp = vp, far *ep;
  int len;
  char *s;

  vp = (void far *)EndTest;
  ep = vp;

  while (cp < ep) {
    s = DisAsm86(cp, &len);
    Tab2Spc(s);
    printf("\n%04x\t%-28s", (int)cp, s);
    if (memOp) {
      printf("%04x:%04lx(%d) %-6s  ",
	    memSeg, memLinear, memSize, memName[memOp]);
      if (memDouble) {
	printf("%04x:%04lx(%d) %-6s",
	      memSeg2, memLinear2, memSize, memName[memOp2]);
      }
    }
    memSeg = memLinear = memSize = memOp = 0;
    cp += len;
  }
} /* MemTest */

void main(void) {
#if 0
  int i, j, g;
  void far *vp = (void far *)DisTest;
  byte far *cp = vp;
  byte far *ep;
  int len = 3, count;
  char *s;
#endif
  MemTest();
#if 0
  vp = (void far *)EndTest;
  ep = vp;
  printf("DisAsm86\n", (int)foo << len);

  for (i=0; i<9; i++) foo[i] = i;
/* #define CHECK */
#if defined(CHECK)
  for (i=0x0; i<256; i++) {
    foo[0] = i;
    count = GroupSize(i);
    for (j=0; j<count; j++) {
      if (((count > 1) && ((j & 7) == 0)) ||
	  ((count == 1) && ((i & 7) == 0)))
	printf("\n");
      foo[1] = j;
      foo[2] = 0;
      s = DisAsm386(foo, &len);
      if (*s != '?') printf("%02x\t%s\n", i, (FP)s);
      if (group) {
	for (g = 1; g<8; g++) {
	  foo[group] = g << 3;
	  s = DisAsm386(foo, &len);
	  if (*s != '?') printf("%02x %02x\t%s\n", i, foo[group], (FP)s);
	}
	group = 0;
      }
    }
#else
  /* for (i=0; i<10; i++) { */
  while (cp < ep) {
    s = DisAsm86(cp, &len);
    printf("%04x\t%s\n", (word)cp, (FP)s);
    cp += len;
#endif
  }
#endif
} /* main */

void far foobar() {}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\sherlock\drwatson.h ===
/* DrWatson.h - global info for Dr. Watson */

enum { 
  eClu, eDeb, eDis, eErr, eInf, eLin, eLoc, eMod,
  ePar, eReg, eSum, eSeg, eSou, eSta, eTas, eTim,
  e32b
};

#define bClu (1L << eClu)
#define bDeb (1L << eDeb)
#define bDis (1L << eDis)
#define bErr (1L << eErr)
#define bInf (1L << eInf)
#define bLin (1L << eLin)
#define bLoc (1L << eLoc)
#define bMod (1L << eMod)
#define bPar (1L << ePar)
#define bReg (1L << eReg)
#define bSum (1L << eSum)
#define bSeg (1L << eSeg)
#define bSou (1L << eSou)
#define bSta (1L << eSta)
#define bTas (1L << eTas)
#define bTim (1L << eTim)
#define b32b (1L << e32b)


#define flag(b) (((char *)&ddFlag)[b >> 3] & 1 << (b & 7))
#define SetFlag(b) ((char *)&ddFlag)[b >> 3] |= 1 << (b&7)
#define ClrFlag(b) ((char *)&ddFlag)[b >> 3] &= ~(1 << (b&7))


#define noClues flag(eClu)        /* Clues dialog box */
#define noDebStr flag(eDeb)       /* OutputDebugString trapping */
#define noDisasm flag(eDis)       /* Simple disassembly */
#define noErr flag(eErr)          /* Error logging */
#define noInfo flag(eInf)         /* System info */
#define noLine flag(eLin)         /* Lookup line# in SYM file */
#define noLocal flag(eLoc)        /* Local vars on stack dump */
#define noModules flag(eMod)      /* Module dump */

#define noParam flag(ePar)        /* Parameter error logging */
#define noReg flag(eReg)          /* Register dump */
#define noSummary flag(eSum)      /* 3 line summary */
#define noSeg flag(eSeg)          /* not visible to users, but available */
#define noSound flag(eSou)        /* But I _like_ the sound effects! */
#define noStack flag(eSta)        /* Stack trace */
#define noTasks flag(eTas)        /* Task dump */
#define noTime flag(eTim)         /* Time start/stop */

#define noReg32 flag(e32b)        /* 32 bit register dump */

#define DefFlag (bDeb | bDis | bErr | bMod | bLin | bLoc | bPar | bSou)

extern unsigned long ddFlag;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\sherlock\sources.inc ===
TARGETNAME=
TARGETTYPE=NOTARGET
TARGETPATH=
SOURCES=

NTTARGETFILE1=buildall

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\sherlock\usa\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH)
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\sherlock\error.c ===
#include <windows.h>
#include <logerror.h>
#include "str.h"

#ifdef API
#undef API
#endif
#define API _far _pascal _loadds


#define SELECTOROF(lp)	    HIWORD(lp)
#define OFFSETOF(lp)	    LOWORD(lp)

static WORD wErrorOpts = 0;

static char rgch[80];

char *LogErrorStr(WORD err, VOID FAR* lpInfo) {
    void DebugLogError(WORD err, VOID FAR* lpInfo);

	if (err & ERR_WARNING)
            wsprintf(rgch, STR(WarningError), err);
	else
            wsprintf(rgch, STR(FatalError), err);
    return rgch;
}

LPSTR GetProcName(FARPROC fn);

char *LogParamErrorStr(WORD err, FARPROC lpfn, VOID FAR* param) {
    LPSTR rgchProcName;

    rgchProcName = GetProcName(lpfn);


	switch ((err & ~ERR_FLAGS_MASK) | ERR_PARAM)
	{
	case ERR_BAD_VALUE:
	case ERR_BAD_INDEX:
            wsprintf(rgch, STR(ParamErrorBadInt), rgchProcName, (WORD)(DWORD)param);
	    break;

	case ERR_BAD_FLAGS:
	case ERR_BAD_SELECTOR:
            wsprintf(rgch, STR(ParamErrorBadFlags), rgchProcName, (WORD)(DWORD)param);
	    break;

	case ERR_BAD_DFLAGS:
	case ERR_BAD_DVALUE:
	case ERR_BAD_DINDEX:
            wsprintf(rgch, STR(ParamErrorBadDWord), rgchProcName, (DWORD)param);
	    break;

	case ERR_BAD_PTR:
	case ERR_BAD_FUNC_PTR:
	case ERR_BAD_STRING_PTR:
            wsprintf(rgch, STR(ParamErrorBadPtr), rgchProcName,
		    SELECTOROF(param), OFFSETOF(param));
	    break;

	case ERR_BAD_HINSTANCE:
	case ERR_BAD_HMODULE:
	case ERR_BAD_GLOBAL_HANDLE:
	case ERR_BAD_LOCAL_HANDLE:
	case ERR_BAD_ATOM:
	case ERR_BAD_HWND:
	case ERR_BAD_HMENU:
	case ERR_BAD_HCURSOR:
	case ERR_BAD_HICON:
	case ERR_BAD_GDI_OBJECT:
	case ERR_BAD_HDC:
	case ERR_BAD_HPEN:
	case ERR_BAD_HFONT:
	case ERR_BAD_HBRUSH:
	case ERR_BAD_HBITMAP:
	case ERR_BAD_HRGN:
	case ERR_BAD_HPALETTE:
	case ERR_BAD_HANDLE:
            wsprintf(rgch, STR(ParamErrorBadHandle), rgchProcName, (WORD)(DWORD)param);
	    break;

	default:
            wsprintf(rgch, STR(ParamErrorParam), rgchProcName, (DWORD)param);
	    break;
	}
    return rgch;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\sherlock\getsym.c ===
#include <windows.h>
#include <stdio.h>
#include <string.h>
#include "disasm.h"	/* wsprintf() */
#include "drwatson.h"

#define _lread(h, adr, cnt) _lread(h, (LPSTR)(adr), cnt)

/* Last entry in .SYM file */

typedef struct tagMAPEND {
   unsigned chnend;     /* end of map chain (0) */
   char	rel;	        /* release */
   char	ver;	        /* version */
} MAPEND;

/* Structure of .SYM file symbol entry */

typedef struct tagSYMDEF {
   unsigned sym_val;    /* 16 bit symbol addr or const */
   char	nam_len;        /*  8 bit symbol name length */
} SYMDEF;

/* Structure of a .SYM file segment entry */

typedef struct tagSEGDEF {
   unsigned nxt_seg;    /* 16 bit ptr to next segment(0 if end) */
   int sym_cnt;         /* 16 bit count of symbols in sym list  */
   unsigned sym_ptr;    /* 16 bit ptr to symbol list */
   unsigned seg_lsa;    /* 16 bit Load Segment address */
   unsigned seg_in0;    /* 16 bit instance 0 physical address */
   unsigned seg_in1;    /* 16 bit instance 1 physical address */
   unsigned seg_in2;    /* 16 bit instance 2 physical address */
   unsigned seg_in3;    /* 16 bit instance 3 physical address */
   unsigned seg_lin;    /* 16 bit ptr to line number record   */
   char	seg_ldd;        /*  8 bit boolean 0 if seg not loaded */
   char	seg_cin;        /*  8 bit current instance	      */
   char	nam_len;        /*  8 bit Segment name length	      */
} SEGDEF;

/* Structure of a .SYM file MAP entry */

typedef struct tagMAPDEF {
   unsigned map_ptr;    /* 16 bit ptr to next map (0 if end) */
   unsigned lsa	 ;      /* 16 bit Load Segment address */
   unsigned pgm_ent;    /* 16 bit entry point segment value */
   int abs_cnt;         /* 16 bit count of constants in map */
   unsigned abs_ptr;    /* 16 bit ptr to constant chain */
   int seg_cnt;         /* 16 bit count of segments in map */
   unsigned seg_ptr;    /* 16 bit ptr to segment chain */
   char	nam_max;        /*  8 bit Maximum Symbol name length */
   char	nam_len;        /*  8 bit Symbol table name length */
} MAPDEF;

/* should cache last 4 files, last 4 segments, last 4 symbol blocks */

void cdecl Show(char *foo, ...);

#define MAXSYM 64
char *FindSym(unsigned segIndex, unsigned offset, int h) {
  static char sym_name[MAXSYM+5];
  char name[MAXSYM+3];
  int i;
  MAPDEF mod;
  SEGDEF seg;
  SYMDEF sym, *sp;

  if (sizeof(mod) != _lread(h, &mod, sizeof(mod))) return 0;
  if (segIndex > (unsigned)mod.seg_cnt) return 0;
  seg.nxt_seg = mod.seg_ptr;
  for (i=0; i<mod.seg_cnt; i++) {
    _llseek(h, (long)seg.nxt_seg << 4, SEEK_SET);
    _lread(h, &seg, sizeof(seg));
    if (seg.seg_lsa == segIndex) break;
  }
  if (seg.seg_lsa != segIndex) return 0;
  _llseek(h, seg.nam_len, SEEK_CUR);
  sym_name[0] = 0;
  sym.sym_val = 0xffff;
  sym.nam_len = 0;
  for (i=0; i<seg.sym_cnt; i++) {
    unsigned len = sizeof(sym) + sym.nam_len;
    if (len >= sizeof(name)) return 0;
    if (len != _lread(h, name, len)) return 0;
    sp = (SYMDEF *)(name + sym.nam_len);
    if (sp->sym_val > offset)
      break;
    sym = *sp;
  }
  name[sym.nam_len] = 0;
  if (name[0] == 0) return 0;
  if (sym.sym_val == offset) strcpy(sym_name, name);
  else sprintf(sym_name, "%s+%04x", (FP)name, offset-sym.sym_val);
  return sym_name;
} /* FindSym */

char *NearestSym(int segIndex, unsigned offset, char *exeName) {
  char fName[80];
  /* OFSTRUCT reOpen; */
  char *s;
  int h;

  strcpy(fName, exeName);
  strcpy(fName+strlen(fName)-4, ".sym");

  h = _lopen(fName, OF_READ | OF_SHARE_DENY_WRITE);

  if (h == -1) return 0;
  s = FindSym(segIndex, offset, h);
  _lclose(h);
  return s;
} /* NearestSym */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\system\sources.inc ===
TARGETNAME=
TARGETTYPE=NOTARGET
TARGETPATH=
SOURCES=

NTTARGETFILE1=buildall

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\sherlock\watson.asm ===
; Watson.asm - Helper routines for Sherlock

	memS = 1
	?PLM = 0
	?WIN = 0
        ?QUIET = 1
include	cmacros.inc
include toolhelp.inc
	.286p
	.model	small

	.data?
;newStack db	4096 dup (?)
externW	newsp
externW	cpu32
externW retflag
;newsp	=	(newStack+4096)

externW	regs
	val	= 0
irp	reg, <ax,cx,dx,bx,sp,bp,si,di,ip,flag,es,cs,ss,ds,fs,gs,int>
	r&reg	= val
	val	= val+2
endm


externD	regs32
	val	= 0
irp	reg, <ax, cx, dx, bx, sp, bp, si, di, ip, flags>
	re&reg	= val
	val	= val+4
endm

	.code
externP	Sherlock

cProc   SegLimit, <PUBLIC>,
	parmW	segVal
cBegin
	cmp	[cpu32], 0
	jnz	SegLimit32
	xor	ax, ax
	xor	dx, dx
        lsl     ax, [segVal]
	jmp short	done
SegLimit32:
	.386p
	push	edx			; save EDX.hi
	pop	dx

	push	eax			; save EAX.hi
	pop	ax

	xor	edx, edx		; return 0 if failure
	movzx	eax, [segVal]
	lsl	edx, eax		; EDX = return result

	push	dx			; push ans.lo
	pop	eax			; EAX.lo = ans.lo, EAX.hi restored

	push	edx			; stack is ans.lo, ans.hi, EDX.hi
	pop	dx			; discard ans.lo (already in EAX.lo)
	pop	edx			; DX has ans.hi, EDX.hi restored
	.286p
done:
cEnd

cProc	SegBase, <PUBLIC>
	parmW	segVal
cBegin
	mov	ax, 6
	mov	bx, [segVal]
	or	bx, bx			; DPMI whines on a 0 selector
	jz	baseBad
	int	31h			; call DPMI
	jnc	baseOK
baseBad:
	xor	dx, dx
	xor	cx, cx
baseOK:
	mov	ax, dx
	mov	dx, cx
cEnd

cProc	SegRights, <PUBLIC>
	parmW	segVal
cBegin
	lar	ax, [segVal]
	jz	rightOK
	xor	ax, ax
rightOK:
cEnd

externNP CallMeToo

cProc	CallMe,<PUBLIC,FAR>		; I was a big Blondie fan
;	parmD	foo			; BP+6, BP+8
;	parmW	id			; BP+10
cBegin nogen
	push	bp
	mov	bp, sp
id	equ	word ptr [bp+10]
seg_foo	equ	word ptr [bp+8]
off_foo	equ	word ptr [bp+6]
	xor	ax, ax
	cmp	id, NFY_LOGERROR
	jz	cm_stay
	cmp	id, NFY_LOGPARAMERROR
;        jz      cm_stay
;        cmp     id, NFY_OUTSTR
	jnz	cm_go			; "if I go there will be trouble"
cm_stay:				; "if I stay it will be double"
	mov	ax, DGROUP
	mov	bx, ss
	cmp	ax, bx
	jz	cm_go
	push	ds			; I like The Clash too
	mov	ds, ax
	mov	dx, SEG_foo
	mov	cx, OFF_foo
	mov	bx, id
	mov	[regs+rss], ss		; for stack trace, and to continue
	mov	[regs+rsp], sp
	mov	[regs+rbp], bp
	mov	[regs+rcs], cs
	mov	[regs+rip], offset cm_stay
	mov	ss, ax
	mov	sp, [newsp]
	mov	bp, 0
	push	dx
	push	cx
	push	bx
	cCall	CallMeToo
	mov	bp, [regs+rbp]
	mov	ss, [regs+rss]
	mov	sp, [regs+rsp]
	pop	ds
cm_go:
	pop	bp
	retf	6
cEnd	nogen

; GPFault - called as part of gpfault chain by ToolHelp
;	Ret IP		Far ret back to ToolHelp fault handler
;	Ret CS
;	AX		Saved in case prolog trashes AX
;6	IntNum		Number of interrupt that occurred
;	Resv		Magic value, don't trash
;10	Fault IP	IRET back to faulting instruction
;12	Fault CS
;14	Fault Flags

fint	= 6
fip	= 10
fcs	= 12
fflag	= 14

GPFAULT proc	far ; pascal
public	GPFAULT
	push	ds			; save ds
	push	ax
	push	bp
	mov	bp, sp
	mov	ax, [bp+12]
	cmp	ax, 0			; only save regs if int Div0,
	jz	keeper
	cmp	ax, 6			; invalid opcode
	jz	keeper
	cmp	ax, 13			; GP fault
	jz	keeper
nokeep:	pop	bp			; don't like this fault, chain on
	pop	ax
	pop	ds
	ret

keeper:	push	bx
	mov	bx, ss
	mov	ax, DGROUP		; and address our group
	cmp	ax, bx
	pop	bx
	je	nokeep			; don't go re-entrant
	mov	ds, ax
	pop	[regs+rbp]
	pop	[regs+rax]		;save AX
	pop	[regs+rds]		; and DS in regs[]

irp	reg, <cx,dx,bx, sp, si,di, es,ss>
	mov	[regs+r&reg], reg	; all but ip, flag, intNum,
endm					;   cs, fs, gs, int
	mov	bp, sp			; nothing local on stack
irp	reg, <cs, ip, flag, int>
	mov	bx, [bp+f&reg]
	mov	[regs+r&reg], bx
endm

; Save away 32 bit registers if required
	cmp	[cpu32], 0
	jz	NoSave32
	.386p
	mov	ax, [regs+rax]
irp	reg, <eax, ecx, edx, esi, edi>
	mov	[regs32+r&reg], reg
endm
irp	reg, <bx, sp, bp>
	mov	eax, e&reg
	mov	ax, [regs+r&reg]
	mov	[regs32+re&reg], eax
endm
	pushfd
	pop	[regs32+reflags]
	mov	[regs+rfs], fs
	mov	[regs+rgs], gs
	.286p
NoSave32:
	mov	ax, ds
	mov	ss, ax	
	mov	sp, [newsp]
	mov	bp, 0

	cmp	ax, [regs+rss]		; can't debug ourselves
	jz	oh_no

; Save high halves of registers if required
        cmp     [cpu32], 0
        jz      CallSherlock286
	.386p
	pushad
	call	Sherlock		; Display the info
	mov	retflag, ax
	popad
	mov	eax, [regs32+reax]
	.286p
	
        jmp     short DoneWithSherlock

CallSherlock286:
        pusha
        call    Sherlock                ; Display the info
        mov     retflag, ax
        popa

DoneWithSherlock:
        mov     ax, retflag
        or      ax, ax                  ; 0 - fault, 1 = continue
	jz	oh_no
	mov	es, [regs+rss]
	mov	bx, [regs+rsp]
	mov	ax, [regs+rip]
	mov	es:[bx+10], ax
oh_no:					; restore all regs, then test again
irp	reg, <ax,cx,dx,bx, ss,sp, bp,si,di, es,ds>
	mov	reg, [regs+r&reg]
endm
	jz	oh_no_2
	add	sp, 10
	iret
oh_no_2:
	ret
GPFAULT	endp

	.386p
cProc	GetRegs32, <PUBLIC>
cBegin
cEnd

irp	reg, <sp, bp, si, di>
	mov	eax, [regs32+re&reg]
	mov	ax, reg
	mov	e&reg, eax
endm

irp	reg, <ebx, edx, ecx, eax>
	mov	reg, [regs32+r&reg]
endm
cEnd
	.286p

cProc	GetTimeDate, <PUBLIC>
	parmW	buf
cBegin
	mov	ah, 2ah
	int	21h
	mov	bx, [buf]
	mov	[bx], ax
	mov	[bx+2], cx
	mov	[bx+4], dx
	mov	ah, 2ch
	int	21h
	mov	bx, [buf]
	mov	[bx+6], cx
	mov	[bx+8], dx
cEnd

cProc	FindFile, <PUBLIC>
	parmW	buf
	parmW	_name
	localW	dtaSeg
	localW	dtaOff
cBegin
	mov	ah, 2fh			;get DTA
	int	21h
	mov	[dtaSeg], es
	mov	[dtaOff], bx

	mov	ah, 1ah
	mov	dx, buf
	int	21h			; set DTA to caller's buffer

	mov	ah, 4eh			; find first matching file
	mov	cx, 0
	mov	dx, _name
	int	21h
	sbb	ax, ax
	push	ax

	push	ds			; restore DTA
	mov	ds, [dtaSeg]
	mov	dx, [dtaOff]
	mov	ah, 1ah
	int	21h

	pop	ds
	pop	ax			; return value, 0 == OK
cEnd
	end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\system\envect.asm ===
.xlist
include cmacros.inc
;
;~~vvr 091989
;
SYS=1
include	equate.inc
;~~
include vecsys.inc
include int31.inc
.list

page
;======= EnableVectra ========================================================
;
; If we have a Vectra A, A+, or A++ with EX-BIOS, save the current HPEntry
; vector, HPHIL state and set HPentry=6Fh, Turn ON HPHIL.
;
; Entry:
;   DS:		Code segment
;
;
; Exit:
;   CurHPentry, CurHILState
;
; Regs:
;   AX,
;
;=============================================================================

		assumes	cs, code
sBegin		DATA

fFirst		dw	0		; =0: First time in
;
;~~vvr 091989
;
fVectra		db	0	; bit0 =1: We have a Vectra with EX-BIOS
CurHPEntry	db	0	; Current HPEntry vector (usually 6Fh)
CurHILState	db	0	; bit6 =1: HIL is OFF
		db	?	; Word aligned

RealMode_Word_Struc Real_Mode_Call_Struc <>

externA		WinFlags
externA 	__ROMBIOS
WF_PMODE	equ	01h		
sEnd

sBegin CODE
assumes cs, CODE
externW MyCSDS

cProc	EnableVectra, <PUBLIC,NEAR>

cBegin
	push	CX
	push	BX
	push	BP
	push	DS

	mov ds, MyCSDS
	assumes	ds,DATA

	test	[fVectra], 10000000B	; Any previous Vectra check?
	jne	EnVNext			; Yes, proceed
;
;  Check if the PC is a Vectra. If Yes, then call HPSystem to get the
;  current size of the HP state

	or 	[fVectra], 80H	; Mark as gone through the identification
					; ..process
	push	ES			; Save it
	mov	AX, __ROMBIOS
	mov	ES, AX			; ES: Segment of ID code
	cmp	Word Ptr ES:[ID_OFFSET], 'PH'
	pop	ES			; Restore entry ES
	jz	EnVCont1
	jmp	EnVRet  		; Not a Vectra, so no extra HP processing
EnVCont1:
;
;  Check if EX-BIOS is present
;
	
	mov	AX, F16_INQUIRE
	mov	BX, AX
	int	INT_KBD
	cmp	BX, 'HP'		; EX-BIOS present?
	je	EnVCont
	jmp	EnVRet			; No, finish
EnVCont:
	or 	[fVectra], 1 	; Yes, flag we have a Vectra

EnvNext:
	test	[fVectra], 1
	jnz	EnVContinue
	jmp 	EnVRet			; No special processing if not a vectra
EnVContinue:
;
; We need to save the EX-BIOS vector and the HIL state only once since it is
; assumed that these parameters will not be changed while running under 
; Windows, especially by an old app.
;
	xor	BH, BH
	cmp	[CurHPEntry], BH	; first time?
	jnz	EnVSet			; no, don't have to save it again
;
; Save current HP entry and set it to be 6Fh
;
	mov	AX, F16_GET_INT_NUMBER
	int	INT_KBD
	inc	BH			; Flag as the first time
	mov	[CurHPEntry], HPENTRY ; Assume we have HPentry= 6Fh
	cmp	AH, RS_UNSUPPORTED
	je	EnVSet    		; We have a Vectra A, A+ if unsupported
	mov	[CurHPEntry], AH	; Save it if valid
;
EnVSet:
	mov	BL, HPENTRY
	mov	AX, F16_SET_INT_NUMBER
	int	INT_KBD			; BH preserved
;
; Save current HPHIL state and set it ON
;		  
	mov	cx, WinFlags
	and	cx, WF_PMODE 
	cmp	cx, WF_PMODE 			; prot-mode only
	jne	sys_real_mode

sys_prot_mode:
	or	BH, BH			; BH= 0: Not the first time 
	jz 	EnVSetHIL_PM		;	 so don't save state
	HPSysCall V_HPHIL, F_SYSTEM, SF_REPORT_STATE 
	mov	[CurHILState], BH
;
; Bit 14 of BX (Status Word) = 1: HPHIL OFF
;			       0: 	ON
;
EnVSetHIL_PM:
	HPSysCall V_HPHIL, F_IO_CONTROL, SF_HIL_ON 
	jmp	EnVret

sys_real_mode:
	or	BH, BH			; BH= 0: Not the first time 
	jz 	EnVSetHIL		;	 so don't save state
	mov	AH, F_SYSTEM
	mov	AL, SF_REPORT_STATE
	mov	BP, V_HPHIL
	int	HPENTRY			; int 6f to get the state
;
; Bit 14 of BX (Status Word) = 1: HPHIL OFF
;			       0: 	ON
;
	mov	[CurHILState], BH
;
; Turn HIL ON
;
EnVSetHIL:
	mov	AH, F_IO_CONTROL
	mov	AL, SF_HIL_ON
	mov	BP, V_HPHIL
	int	HPENTRY
;
EnVret:	
	pop	DS
	pop	BP
	pop	BX
	pop	CX
;
cEnd	EnableVectra


page
;======= DisableVectra =======================================================
;
; Restore the Vectra environment according to CurHPEntry and CurHILState
; Assume that HPENTRY is always 6Fh
;
; Entry:
;   DS:		Code Segment
;
; Exit:
;
;
; Regs:
;   AX,
;
;=============================================================================

cProc	DisableVectra, <PUBLIC,NEAR>

cBegin
	push	BX
	push	BP
	push	DS

						; make it run in both 
	mov	ds,MyCSDS			; real and prot modes
	assumes	ds,DATA

	test	[fVectra], 1			; are we on a Vectra ?
	jnz	DisVCont
	jmp 	DisVRet				; no 
DisVCont:

; check if we are prot or real mode

	mov	bx, WinFlags			; get mode flag
	and	bx, WF_PMODE 
	cmp	bx, WF_PMODE 			; is it prot_mode ?
	jne	sys_dis_real_mode		; we are in real mode

sys_dis_prot_mode:	

	test	[CurHILState], B_HIL_STATE
	je	DisVHIL_PM
	HPSysCall	V_HPHIL, F_IO_CONTROL, SF_HIL_OFF
	jmp	DisRestHIL
DisVHIL_PM:
	HPSysCall	V_HPHIL, F_IO_CONTROL, SF_HIL_ON
	jmp	DisRestHIL

sys_dis_real_mode:
;
;
; Restore the HIL state according to CurHILState
;
	mov	AH, F_IO_CONTROL
	mov	BP, V_HPHIL
	mov	AL, SF_HIL_ON		; Assume HIL is ON
	test	[CurHILState], B_HIL_STATE
	je	DisVHIL			; 0= correct assumption
	mov	AL, SF_HIL_OFF

DisVHIL:
	push	ds
	int	HPENTRY
	pop	ds
;
; Restore the Saved HPEntry
;
DisRestHIL:

	mov	AX, F16_SET_INT_NUMBER
	mov	BL, [CurHPEntry]
	int	INT_KBD
;
DisVRet:
	pop	DS
	pop	BP
	pop	BX

;
cEnd	DisableVectra

Send	code
	end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\system\romstuff.inc ===
;;
;;  macros and equates intended for ROM differences
;;

ifndef ROM
ROM = 0
endif

if ROM

if1
%out Creating Data Segment For ROM System
endif

SDSEG macro
sBegin DATA
endm

AssumeData macro
assumes ds, DATA
endm

DSEG equ DATA
doffset EQU <DataOffset>

else

SDSEG macro
sBegin CODE
endm

AssumeData macro
assumes ds, CODE
endm

DSEG equ CODE
doffset EQU <CodeOffset>

endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\sherlock\str.h ===
//
// str.h for Dr. Watson
//
// Created by DaveHart 31-Aug-95 to allow localization of Dr. Watson
//

#define CCH_MAX_STRING_RESOURCE 512

//
// IDSTR manifests start at zero and are consecutive to allow
// the ID to be an index into an array of string pointers at
// runtime.
//

#define IDSTRNoFault                                     0
#define IDSTRFaulty                                      1
#define IDSTRGPText                                      2
#define IDSTRErrMsg                                      3
#define IDSTRVers                                        4
#define IDSTRClassMsg                                    5
#define IDSTRCoprocessor                                 6
#define IDSTR8086                                        7
#define IDSTR80186                                       8
#define IDSTR80286                                       9
#define IDSTR80386                                       10
#define IDSTR80486                                       11
#define IDSTREnhancedMode                                12
#define IDSTRProtectMode                                 13
#define IDSTRStandardMode                                14
#define IDSTRWindowsNT                                   15
#define IDSTRNullPtr                                     16
#define IDSTRInvalid                                     17
#define IDSTRNotPresent                                  18
#define IDSTRCode                                        19
#define IDSTRExR                                         20
#define IDSTRExO                                         21
#define IDSTRData                                        22
#define IDSTRRW                                          23
#define IDSTRRO                                          24
#define IDSTRUnknown                                     25
#define IDSTRDivideByZero                                26
#define IDSTRInvalidOpcode                               27
#define IDSTRGeneralProtection                           28
#define IDSTRInvalidSelector                             29
#define IDSTRNullSelector                                30
#define IDSTRSegmentNotPresent                           31
#define IDSTRExceedSegmentBounds                         32
#define IDSTRCodeSegment                                 33
#define IDSTRExecuteOnlySegment                          34
#define IDSTRReadOnlySegment                             35
#define IDSTRSegNotPresentOrPastEnd                      36
#define IDSTRErrorLog                                    37
#define IDSTRParameterErrorLog                           38
#define IDSTRFileNotFound                                39
#define IDSTRCodeSegmentNPOrInvalid                      40
#define IDSTRNoSymbolsFound                              41
#define IDSTRSystemInfoInfo                              42
#define IDSTRWindowsVersion                              43
#define IDSTRDebugBuild                                  44
#define IDSTRRetailBuild                                 45
#define IDSTRWindowsBuild                                46
#define IDSTRUsername                                    47
#define IDSTROrganization                                48
#define IDSTRSystemFreeSpace                             49
#define IDSTRStackBaseTopLowestSize                      50
#define IDSTRSystemResourcesUserGDI                      51
#define IDSTRMemManInfo1                                 52
#define IDSTRMemManInfo2                                 53
#define IDSTRMemManInfo3                                 54
#define IDSTRMemManInfo4                                 55
#define IDSTRTasksExecuting                              56
#define IDSTRWinFlags                                    57
#define IDSTRUnknownAddress                              58
#define IDSTRStackDumpStack                              59
#define IDSTRStackFrameInfo                              60
#define IDSTRFailureReport                               61
#define IDSTRLastParamErrorWas                           62
#define IDSTRHadAFaultAt                                 63
#define IDSTRCPURegistersRegs                            64
#define IDSTRCPU32bitRegisters32bit                      65
#define IDSTRInstructionDisasm                           66
#define IDSTRSystemTasksTasks                            67
#define IDSTRTaskHandleFlagsInfo                         68
#define IDSTRFilename                                    69
#define IDSTRSystemModulesModules                        70
#define IDSTRModuleHandleFlagsInfo                       71
#define IDSTRFile                                        72
#define IDSTRContinuingExecution                         73
#define IDSTRDebugString                                 74
#define IDSTRApplicationError                            75
#define IDSTRInvalidParameter                            76
#define IDSTRNA                                          77
#define IDSTRHadAFaultAt2                                78
#define IDSTRParamIs                                     79
#define IDSTRStop                                        80
#define IDSTRLogFileGettingLarge                         81
#define IDSTRStart                                       82
#define IDSTRWarningError                                83
#define IDSTRFatalError                                  84
#define IDSTRParamErrorParam                             85
#define IDSTRParamErrorBadInt                            86
#define IDSTRParamErrorBadFlags                          87
#define IDSTRParamErrorBadDWord                          88
#define IDSTRParamErrorBadHandle                         89
#define IDSTRParamErrorBadPtr                            90

// These must be numerically in order Jan - Dec.

#define IDSTRJan                                         91
#define IDSTRFeb                                         92
#define IDSTRMar                                         93
#define IDSTRApr                                         94
#define IDSTRMay                                         95
#define IDSTRJun                                         96
#define IDSTRJul                                         97
#define IDSTRAug                                         98
#define IDSTRSep                                         99
#define IDSTROct                                         100
#define IDSTRNov                                         101
#define IDSTRDec                                         102

// These must be numerically in order Sun - Sat

#define IDSTRSun                                         103
#define IDSTRMon                                         104
#define IDSTRTue                                         105
#define IDSTRWed                                         106
#define IDSTRThu                                         107
#define IDSTRFri                                         108
#define IDSTRSat                                         109


//
// Since IDSTR's start at zero, STRING_COUNT is one more than the highest ID
//

#define STRING_COUNT                                     110

//
// Macro to fetch string pointer based on name without preceeding IDSTR
//

#define STR(name)      (aszStrings[IDSTR##name])

#ifndef DRWATSON_C
extern LPSTR aszStrings[];
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\system\equate.inc ===
page	,132

;**************************************************************************
; This file contains equates, data structures and definitions needed to
; access both the Standard BIOS (STD-BIOS) and the Extended BIOS (EX-BIOS)
; of Vectra using MASM 3.0. Depending on what part of the BIOS you are
; accessing you might not need all the equates.  The equates are organized
; as follows:
;
;  o Usefull macros.
;  o 80286 Support Macros and Equates.
;  o EX-BIOS Equates:
;      1) Generic Structures and equates used by all drivers.
;      2) Equates for Vector Addressed.
;      3) Function and SubFunction Equates common to all drivers.
;      4) Function and Subfunction Equates individual to drivers. These
;         are order by vector number.
;  o Industry Standard (STD-BIOS) Interrupt numbers and function equates.
;  o Industry Standard (STD-BIOS) Data Area
;
; The major reason for organizing the equate file in this form is that
; the programmer can extract only those equates that he needs to create
; a tailored equate file.
;**************************************************************************

;**************************************************************************
; Useful macros. 
;**************************************************************************
;  none at this time


;**************************************************************************
; 80286 Support macros and equates.
;**************************************************************************
;**************************************************************************
; The following macro is used to compensate for a bug in the 80286
; hardware interrupt system.  It seems that during a normal
; POPF instruction cycle interrupts are always enabled regardless
; of the state of the interrupt enable flag prior to the pop or after
; the pop. 
;**************************************************************************
POPPF       macro
            jmp   $+3
            iret
            push  cs
            call $-2
            endm

;**************************************************************************
; EX-BIOS support macros and equates.
;**************************************************************************

; Equates for EX-BIOS interrupt number and vector address.  
HPENTRY                 equ     6FH
F_HPENTRY               equ     HPENTRY

BIOS_SEG		EQU	0F000H		; Vectra BIOS ROM Segment
ID_OFFSET		EQU	0F8H		; Vectra ROM ID Offset
;
;**************************************************************************
;                       SYSCALL [vector_address]
;**************************************************************************
syscall                 macro   vector
 ifnb                    <vector>
                        mov     bp,vector
 endif
                        int     HPENTRY
                        endm

ifndef SYS
;
;**************************************************************************
; HP_VECTOR_TABLE Entry
;**************************************************************************
HP_TABLE_ENTRY          struc   ;<1,2,3>
HP_ENTRY_IP             dw      0
HP_ENTRY_CS             dw      0
HP_ENTRY_DS             dw      0
HP_TABLE_ENTRY          ends
;**********************************************************************
; Structure of Data Header for HP's vectors.
;**********************************************************************
HP_SHEADER              STRUC  ;<1,2,3,4,5,6,7,8,9,0>
DH_ATR                  dw  0   ; Attribute
DH_NAME_INDEX           dw  0   ; Name index of driver.
DH_V_DEFAULT            dw  0   ; Driver vector position in HPtable
DH_P_CLASS              dw  0   ; Parent class
DH_C_CLASS              dw  0   ; Child class
DH_V_PARENT             dw  0   ; Vector used when the driver cannot handle
                                ; an F_ISR function call
DH_V_CHILD              dw  0   ; Vector used when the driver cannot handle
                                ; a regular function call
DH_MAJOR                db  0   ; Driver's major address if any.
DH_MINOR                db  0   ; Driver's minor address if any.
HP_SHEADER              ENDS
                        
;**********************************************************************
; DH_ATR bit record
;**********************************************************************
ATR_HP            equ  1000000000000000B ; 1- The Rest of header is valid
ATR_DEVCFG        equ  0100000000000000B ; 1- Present in DEVCONFG
ATR_ISR           equ  0010000000000000B ; 1- Replace My ISR   (Child)
ATR_ENTRY         equ  0001000000000000B ; 1- Replace My ENTRY (Parent)
ATR_RSVD          equ  0000000000000000B ; 0 - Available on allocation from HP
ATR_FREE          equ  0000001000000000B ; 1 - Available Vector
ATR_SRVC          equ  0000010000000000B ; 2 - Service Vector
ATR_LOG           equ  0000011000000000B ; 3 - Logical Device Start DEVCONFG CHA
ATR_IND           equ  0000100000000000B ; 4 - Filter, show driver (options)
ATR_BOT           equ  0000101000000000B ; 5 - End of Chain
ATR_ESC           equ  0000110000000000B ; 6 - Filter, Pass thru , No options
ATR_TYPE7         equ  0000111000000000B ; 7 - Available
ATR_TYPE_MASK     equ  0000111000000000B
ATR_INP           equ  0000000100000000B ;  1 - Chain ISR ( to Parents )
                                         ;  0 - Chain Entry ( Child)
ATR_SUBADD        equ  0000000000000000B
ATR_MAJOR         equ  0000000000100000B
ATR_MINOR         equ  0000000001000000B
ATR_MID           equ  0000000001100000B
ATR_PSHARE        equ  0000000000010000B
ATR_CSHARE        equ  0000000000001000B
ATR_ROM           equ  0000000000000100B
ATR_YIELD         equ  0000000000000010B ;
ATR_0             equ  0000000000000001B

;**********************************************************************
;  DH_Class
;**********************************************************************
CL_KBDFC           equ  1000000000000000B       ; 1 - HP Softkey Transaltor
CL_KBD             equ  0100000000000000B       ; 1 - Keyboard
CL_CCP             equ  0010000000000000B       ; 1 - Cursor Control pad
CL_CON             equ  0001000000000000B       ; 1 - Console Device
CL_BYTE            equ  0000100000000000B       ; 1 - PRN device
CL_COMM            equ  0000010000000000B       ; 1 - COMM device
CL_INTERFACE       equ  0000001000000000B       ; 1 - interface, HPHIL, HPIB
CL_FILT            equ  0000000100000000B       ; 1 - charachter filter
CL_BLK             equ  0000000010000000B       ; 1 - block device
CL_BOOT            equ  0000000001000000B       ; 1 - boot block device
CL_LGID            equ  0000000000100000B       ; 1 - logical physical gid
                                                ; e.g. ccp to gid translator
CL_PGID            equ  0000000000010000B       ; 1 - physical gid
CL_GID             equ  0000000000001000B       ; 1 - any graphics input device
CL_PTS             equ  0000000000000100B       ; 1 - physical touch screen
CL_ASCII           equ  0000000000000010B       ; 1 - ascii input device
CL_EXTEND          equ  0000000000000001B       ; 0 - set of classes above
                                                ; 1 - alternate class set
CL_ALL             equ  1111111111111111B       ; Member of all classes
CL_NULL            equ  0000000000000000B       ; Member No Classes

;***************************************************************************
; Vector Addresses
;***************************************************************************
V_SCOPY                 equ     0000H           ; Copyright Notice
V_DOLITTLE              equ     0006H           ; Nop Routine
V_PNULL                 equ     000CH           ; No Device 
V_SYSTEM                equ     0012H           ; System Intrinsics
V_SINPUT                equ     002AH           ; Input Inquire routines
V_SQWERTY               equ     0036H           ; Qwerty KBD Translator
V_PSOFTKEY              equ     003CH           ; HP f1-f8 Translator
V_PFUNCTION             equ     0042H           ; IBM F1-F10 Translator
V_PNUM_PAD              equ     0048H           ; Numeric Pad Translator
V_SPCCP                 equ     004EH           ; CCP Translator Driver
V_PVIDEO                equ     0054H           ; Video Intrinsics
V_STRACK                equ     005AH           ; Common cursor control funcs.
V_EVENT_TOUCH           equ     0060H           ; Touch Event Intercept
V_EVENT_TABLET          equ     0066H           ; Tablet Event Intercept
V_EVENT_POINTER         equ     006CH           ; Pointer Event Intercept
V_LCCP_CURSOR           equ     008AH           ; CCP to Cursor Always Filter (Default)
V_RAW                   equ     0090H           ; CCP+Softkey RAW Mode Filter
V_LCCP_NUMPAD           equ     0096H           ; CCP to Numeric Pad Filter
V_OFF                   equ     009CH           ; CCP+Softkey Off Filter
V_LCCP_GID              equ     00A2H           ; CCP to GID Filter ( Not Implemented)
V_LFUNCTION             equ     00A8H           ; Softkey (f1-f8) to Function
                                                ;  key (F1-F8) Filter (Default)
V_L8041                 equ     00AEH           ; 8041 Interface
V_PGID_CCP              equ     00B4H           ; Graphic to CCP Filter
V_LTABLET               equ     00BAH           ; Tablet driver
V_LPOINTER              equ     00C0H           ; Pointer driver
V_LTOUCH                equ     00C6H           ; Touch driver
V_LHPMOUSE              equ     00CCH           ; Microsoft/Mouse System's
                                                ;   Compatible Driver
V_LNULL                 equ     0108H           ; No Driver
 
endif	; SYS
 
V_HPHIL                 equ     0114H           ; HPHIL Driver
;
V_WINDOWS  		equ	168H		; HP Windows protocol driver
V_SCANDOOR		equ	016EH		; Scan Door driver	
;
;~~tqn	060887
;
;*********************************************************************
; Extended Keyboard functions (int 16h)
;*********************************************************************

INT_KBD			equ	16H		; Int 16h vetor 
F16_INQUIRE  	        equ	6F00H		; EX-BIOS presence
F16_GET_INT_NUMBER	equ	6F0DH		; Get HPentry vector
F16_SET_INT_NUMBER	equ	6F0EH		; Set HPentry vector
;
;~~
;*********************************************************************
; Common Function Codes for HP Routines.
;*********************************************************************
F_ISR                   equ     00H*2           ; Interrupt service call
F_SYSTEM                equ     01H*2           ; System func. call,
                                                ;   Subfunction required
F_IO_CONTROL            equ     02H*2           ; Device/Driver Dependent
                                                ;   Functions
F_ITF_TO_ENVOY          equ     F_IO_CONTROL    ; Translation function for
                                                ;   SITF_ENVOY service.
F_PUT_BYTE              equ     03H*2           ; Write one byte of data:
                                                ;   Byte is in AL
F_GET_BYTE              equ     04H*2           ; Read a byte of data:
                                                ;   Byte returned in AL
F_PUT_BUFFER            equ     05H*2           ; Write a buffer of data,
                                                ;   ES,DI pointer, CX count
F_GET_BUFFER            equ     06H*2           ; Read a buffer if data,
                                                ;   ES,DI pointer, CX count
F_PUT_WORD              equ     07H*2           ; Write word of data, BX data
F_GET_WORD              equ     08H*2           ; Read word of data, BX data
F_GETTRM_BUFFER         equ    009H*2           ; Reads buffer of data,
                                                ;   ES,DI pointer, CX count
                                                ; BH upper bound, BL lower bound
F_PUT_BLOCK             equ     F_PUT_BUFFER    ;used for disk applications
F_GET_BLOCK             equ     F_GET_BUFFER

;*********************************************************************
; Common Subfunction codes of the F_SYSTEM Function.
;*********************************************************************
SF_INIT                 equ     00H*2   ;Initialize command
SF_START                equ     01H*2   ;Secondary Init--initialize dependent
                                        ; upon other drivers/data structures         
SF_REPORT_STATE         equ     02H*2   ;Reports state of driver
SF_VERSION_DESC         equ     03H*2   ;Report version and option describe
                                        ;  record
SF_DEF_ATTR             equ     04H*2   ;Reports default Configuration
                                        ;   (Baud Rate)
SF_GET_ATTR             equ     05H*2   ;Reports Current Configuration
                                        ;   ES,DI pointer
SF_SET_ATTR             equ     06H*2   ;Sets Next Configuration ES,DI, CX
SF_OPEN                 equ     07H*2   ;Reserve Driver for exclusive access
SF_CLOSE                equ     08H*2   ;Release  "   from    "        "
SF_TIMEOUT              equ     09H*2   ;Notify Driver Timeout Occurred
SF_INTERVAL             equ     0AH*2   ;Notify Driver Interval Occurred
SF_TEST                 equ     0BH*2   ;Test Function

;*********************************************************************
; Common Subfunction Codes for the F_IO_CONTROL function.
;*********************************************************************
SF_LOCK                 equ     00H*2   ; Lock Device for exclusive access
SF_UNLOCK               equ     01H*2   ; Unlock Device for exclusivce access
;
;~~tqn 060887
;
SF_HIL_ON		equ	26H	; Turn ON HIL  (A++)
SF_HIL_OFF		equ	28H	; Turn OFF HIL (A++)
B_HIL_STATE		equ	01000000B ; HIL OFF state from SF_REPORT_STATE
;
;~~
;*********************************************************************
; HP Routines Return Status: Sucessful codes are positive and failure
; are negative.
;*********************************************************************
RS_BREAK         equ    00CH            ; Break -- IFC
RS_DATA_NREADY   equ    00AH            ; RS232 Data Not Ready=>Retry Operation
RS_OVERRUN       equ    008H            ; RS232 Port Data Overrun =>Retry Operation
RS_DONE          equ    006H            ; indicates all done return child
RS_NOT_SERVICED  equ    004H            ; indicates a chained ISR--not handled
RS_UNSUPPORTED   equ    002H            ; indicates function is NOPed/not valid
                                        ; for this driver
RS_SUCCESSFUL    equ    F_ISR           ; indicates executed just fine
RS_SERVICED      equ    rs_SUCCESSFUL   ; indicates chained ISR done
RS_PASSTHRU      equ    rs_SERVICED     ; indicates launch data to parent


ifndef SYS
;
;************************************************************************
RS_FAIL          equ    0FEH            ; To be used with hardware failure
RS_TIMEOUT       equ    0FCH            ; to indicate remote device timeout
RS_BAD_PARAMETER equ    0FAH            ; to indicate a bad parameter
RS_BUSY          equ    0F8H            ; to indicate driver/device is busy
RS_NO_VECTOR     equ    0F6H            ; out of hp_VT vectors
RS_OFFLINE       equ    0F4H            ; device is offline
RS_OUT_OF_PAPER  equ    0F2H            ; out of paper on printer device
RS_PARITY        equ    0F0H            ; parity error in transmission
RS_FRAME         equ    0EEH            ; framing error

;******************************************************************************
; Function Number Equates for the EX-BIOS routines and its Data Structures.
;******************************************************************************

;*********************************************************************
; V_SYSTEM (0012H) function codes.
;*********************************************************************
F_INS_BASEHPVT          equ     0004H
F_INS_XCHGFIX           equ     0006H
F_INS_XCHGRSVD          equ     0008H
F_INS_XCHGFREE          equ     000AH
F_INS_FIXOWNDS          equ     000CH
F_INS_FIXGETDS          equ     000EH
F_INS_FIXGLBDS          equ     0010H
F_INS_FREEOWNDS         equ     0012H
F_INS_FREEGETDS         equ     0014H
F_INS_FREEGLBDS         equ     0016H
F_INS_FIND              equ     0018H
F_INS_FINDALL           equ     001AH
F_INS_NXTLOGBLK         equ     001CH
F_RAM_GET               equ     001EH
F_RAM_RET               equ     0020H
F_CMOS_GET              equ     0022H
F_CMOS_RET              equ     0024H
F_CMOS_HPDFLTS          equ     0026H
F_CMOS_IBMDFLTS         equ     0028H
F_YIELD                 equ     002AH
F_INS_ADR               equ     002CH
F_RESERVE_STRING3       equ     002EH
F_SND_CLICK_ENABLE      equ     0030H
F_SND_CLICK_DISABLE     equ     0032H
F_SND_CLICK             equ     0034H
F_SND_BEEP_ENABLE       equ     0036H
F_SND_BEEP_DISABLE      equ     0038H
F_SND_BEEP              equ     003AH
F_SND_SET_BEEP          equ     003CH
F_SND_TONE              equ     003EH
F_STR_GET_FREE_INDEX    equ     0040H
F_STR_DEL_BUCKET        equ     0042H
F_STR_PUT_BUCKET        equ     0044H
F_STR_GET_STRING        equ     0046H
F_STR_GET_INDEX         equ     0048H

;**********************************************************************
;  String Bucket Header. This structure is usefull if using the
; following V_SYSTEM functions: F_STR_DEL_BUCKET and F_STR_PUT_BUCKET.
;**********************************************************************
STR_HEADER              STRUC
STR_NXT_HDR             dd      (?)
STR_UPPER_BOUND         dw      (?)
STR_LOWER_BOUND         dw      (?)
STR_LIST_PTR            dd      (?)
STR_SEGMENT             dw      (?)
STR_HEADER              ENDS

;**********************************************************************
;  V_SYSTEM Global Data Segment
;**********************************************************************
HP_GLB_HEADER           STRUC
T_HP_HEADER             dw      (?)
T_USED_AND_RESERVED     dw      6 dup (?)
T_HP_LAST_DS            dw      (?)
T_HP_MAX_DS             dw      (?)
T_HP_NXT_VCTR           dw      (?)
T_SND_FLAG              db      (?) ;
T_SND_CLICK_COUNT       db      (?) ;
T_SND_CLICK_DURA        db      (?) ;
T_SND_CLICK_VOLUME      db      (?) ;
T_SND_BEEP_CYCLE        dw      (?) ;
T_SND_BEEP_DURA         dw      (?) ;
T_SND_BEEP_COUNT        db      (?) ;
                        db      (?) ;  1 reserved byte for volume
T_STR_NEXT_INDEX        dw      (?)
T_STR_ROOT              dd      (?)
T_STR_VCT_HDR           db      size STR_HEADER dup (?) ; Area vector's name and
T_STR_MSG_HDR           db      size STR_HEADER dup (?) ; ROM message strings
T_8259_FLAGS            db      (?)
                        db      31 dup (?) ; reserve 2 paragraph
HP_GLB_HEADER           ENDS

;*********************************************************************
; V_SINPUT (2AH) Function and subfunction codes.
;*********************************************************************
; F_ISR, F_SYSTEM and F_IO_CONTROL are functions common to all drivers.
F_INQUIRE               equ     0006H
F_INQUIRE_ALL           equ     0008H ; Reports ID's of devices
F_INQUIRE_FIRST         equ     000AH ; Reports (V_HPHIL1) offset
F_REPORT_ENTRY          equ     000CH ; Reports entrypoint of (V_PGID)

;
; Extra subfunctions under F_IO_CONTROL.
;
SF_DEF_LINKS            equ     0000H ; Sets default cofiguration
SF_GET_LINKS            equ     0002H ; Reports current configuration
SF_SET_LINKS            equ     0004H ; Sets Next Configuation
;
SF_MOUSE_DSIZE		equ	0006H ; Return sizes of HPMouse and HPTrack

;**********************************************************************
; V_LGID Fucntion Codes. This is a common driver for: V_LTABLET, 
; V_LPOINTER and V_LTOUCH.
;**********************************************************************
F_SAMPLE                equ     06
; F_IO_CONTROL:
SF_TRACK_ON             equ     4
SF_TRACK_OFF            equ     6
SF_CREATE_EVENT         equ     8
SF_EVENT_ON             equ     0Ah
SF_EVENT_OFF            equ     0Ch
SF_CLIPPING_ON          equ     0Eh
SF_CLIPPING_OFF         equ     10h
;**********************************************************************
; V_LGID LD_DEVICE_STATE
;**********************************************************************
EVENT_ENABLED           equ     10h
TRACK_ENABLED           equ     08h
CLIP_ENABLED            equ     04h
BUTTON_ERROR            equ     02H
ISR_IN_PROGRESS         equ     01H

;*********************************************************************
; V_PGID Data Structures
;*********************************************************************
DESCRIBE        STRUC
                db      size HP_SHEADER dup (?) ; this data is always offset by
D_SOURCE        db      ?       ; 7-4 (high nibble) contains the GID type
                                ; 3-0 (low nibble) is the address of the device
D_HPHIL_ID      db      ?       ; device id byte returned by an HPHIL device
D_DESC_MASK     db      ?       ; describe header from HPHIL device
D_IO_MASK       db      ?       ; I/O descriptor byte from device
D_XDESC_MASK    db      ?       ; extended describe byte from device
D_MAX_AXIS      db      ?       ; maximum number of axis reported
D_CLASS         db      ?       ; device class
                                ; 7-4 (high nibble) contains current class
                                ; 3-0 (low nibble) contain the default class
D_PROMPTS       db      ?       ; number of buttons/prompts
                                ; 7-4 (high nibble) is the number of prompts
                                ; 3-0 (low nibble) is the number of buttons
D_RESERVED      db      ?       ; reserved for future
D_BURST_LEN     db      ?       ; maximum burst length output to a device
                                ; if devices supports more than 255 bytes then
                                ; 255 bytes is the default maximum
D_WR_REG        db      ?       ; number of write registers supported by a device
D_RD_REG        db      ?       ; number of read registers supported by a device
D_TRANSITION    db      ?       ; transitions reported per button
D_STATE         db      ?       ; current state of buttons
D_RESOLUTION    dw      ?       ; counts / cm (m) returned by HPHIL device
D_SIZE_X        dw      ?       ; Maximum count of in units of resolution
D_SIZE_Y        dw      ?       ;
D_ABS_X         dw      ?       ; data reported from device
D_ABS_Y         dw      ?       ; that reports absolute data
D_REL_X         dw      ?       ; data reported from device
D_REL_Y         dw      ?       ; that is relitive
D_ACCUM_X       dw      ?       ; these are used to accumulate scaling
D_ACCUM_Y       dw      ?       ; remainder
DESCRIBE        ENDS

DESCRIBE_SIZE   	equ     size DESCRIBE
D_CCP_STATE             equ     D_STATE + 1
D_SIZE                  equ     D_SIZE_X
D_SAMPLE_ABSOLUTE       equ     D_ABS_X
D_SAMPLE_RELATIVE       equ     D_REL_X
D_REMAINDER_ACCUM       equ     D_ACCUM_X
D_BUFFER                equ     D_SIZE_X        ; offset where buffer begins
D_CLASS_CURRENT 	equ     0F0H
D_CLASS_DEFAULT 	equ     00FH
; The field LD_SOURCE uses the following to access the defined nibbles
D_ADDR_MASK             equ     00FH
D_TYPE_MASK             equ     0F0H
;*********************************************************************
; V_LGID Data Structures
;*********************************************************************
LDESCRIBE       STRUC
                db      size HP_SHEADER dup (?) ; this data is always offset by
LD_SOURCE       db      ?       ; 7-4 (high nibble) contains the GID type
                                ; 3-0 reserved
LD_HPHIL_ID     db      ?       ; device id byte returned by an HPHIL device
LD_DEVICE_STATE dw      ?       ; status bits for logical device
LD_INDEX        db      ?       ; vector index of invoking driver
LD_MAX_AXIS     db      ?       ; maximum number of axis reported
LD_CLASS        db      ?       ; device class
                                ; 7-4 (high nibble) contains current class
                                ; 3-0 (low nibble) contain the default class
LD_PROMPTS      db      ?       ; number of buttons/prompts
                                ; 7-4 (high nibble) is the number of prompts
                                ; 3-0 (low nibble) is the number of buttons
LD_RESERVED     db      ?       ; reserved for future
LD_RES2         db      ?
LD_RES3         db      ?
LD_RES4         db      ?
LD_TRANSITION   db      ?       ; transitions reported per button
LD_STATE        db      ?       ; current state of buttons
LD_RESOLUTION   dw      ?       ; counts / cm (m) returned by HPHIL device
LD_SIZE_X       dw      ?       ; Maximum count of in units of resolution
LD_SIZE_Y       dw      ?       ;
LD_ABS_X        dw      ?       ; data reported from device
LD_ABS_Y        dw      ?       ; that reports absolute data
LD_REL_X        dw      ?       ; data reported from device
LD_REL_Y        dw      ?       ; that is relitive
LD_ACCUM_X      dw      ?       ; these are used to accumulate scaling
LD_ACCUM_Y      dw      ?       ; remainders
LDESCRIBE       ENDS
LDESCRIBE_SIZE 		equ     size LDESCRIBE

LD_SIZE                 equ     LD_SIZE_X
LD_SAMPLE_ABSOLUTE      equ     LD_ABS_X
LD_SAMPLE_RELATIVE      equ     LD_REL_X
LD_REMAINDER_ACCUM      equ     LD_ACCUM_X
LD_BUFFER               equ     LD_RESOLUTION   ; offset where buffer begins
; the following mask are used in the field LD_CLASS
LD_CLASS_CURRENT        equ     0F0H
LD_CLASS_DEFAULT        equ     00FH

;************************************************************************
; V_LHPMOUSE (00CCH) Function and subfunction codes.
;************************************************************************
; F_ISR, F_SYSTEM and F_IO_CONTROL are functions common to all drivers.
; Subfunction under F_IO_CONTROL particular to this driver.
SF_MOUSE_COM            equ     0000H   ; This function is used during the 
                                        ; reinit call from DOS.  It is used
                                        ; to set up INT 33H.  This is done  
                                        ; because DOS takes INT 33H when it
                                        ; is initialized.
SF_MOUSE_OVERRIDE       equ     0002H   ; This function is used to force the
                                        ; V_LHPMOUSE driver to install INT 33
                                        ; even when the mouse is not present.
                                        ; This allows a programmer to map
                                        ; devices to the V_LHPMOUSE driver if
                                        ; a mouse is not present.

;************************************************************************
; V_STRACK (05AH) Function and subfunction codes.
;************************************************************************
F_TRACK_INIT            equ     0004H   ; used to perform a soft initialization
                                        ; of the tracking driver.
F_TRACK_ON              equ     0006H   ; enables tracking
F_TRACK_OFF             equ     0008H   ; disables tracking
F_DEF_MASKS             equ     000AH   ; define masks for sprite
F_SET_LIMITS_X          equ     000CH   ; define X limit of screen coordinates
F_SET_LIMITS_Y          equ     000EH   ; define Y limits
F_PUT_SPRITE            equ     0010H   ; Used to put the sprite on the screen
F_REMOVE_SPRITE         equ     0012H   ; removes the sprite from the screen

;************************************************************************
; V_HPHIL (0114H) Function and subfunction codes.
;************************************************************************
; F_ISR, F_SYSTEM and F_IO_CONTROL are functions common to all drivers.
; Subfunction under F_IO_CONTROL particular to this driver.
;
SF_CRV_CRV_MAJ_MIN      equ     0004    ; This is used to set a default
                                        ; major and minor addresses
SF_CRV_RECONFIGURE      equ     0006    ; Funtion id used to force the HPHIL
                                        ; link to reconfigure the devices
SF_CRV_WR_PROMPTS       equ     0008    ; Used to write a prompt to a device
SF_CRV_WR_ACK           equ     000A    ; Used to write an acknowledge to a
                                        ; device
SF_CRV_REPEAT           equ     000C    ; Function is used to set a 30 Hz or
                                        ; 60 Hz repeat for keyboards
SF_CRV_DISABLE_REPEAT   equ     000E    ; Used to cancel the repeat rates in 
                                        ; keyboards
SF_CRV_SELF_TEST        equ     0010    ; Used to issue a selftest command
                                        ; to a physical device
SF_CRV_REPORT_STATUS    equ     0012    ; Used to get the status information 
                                        ; that an HPHIL device might wish to
                                        ; report.  For specific information
                                        ; on what is reported, see the specs
                                        ; for the device.
SF_CRV_REPORT_NAME      equ     0014    ; This function is used to return the
                                        ; ascii name that a device has.
SF_ENVOY_REPEAT         equ     0016    ; Used to set the keyboard repeat
                                        ; and delay rates
SF_ENVOY_LED            equ     0018    ; Used to set the keyboard LEDs

;************************************************************************
; V_SCANDOOR (016EH) Function and subfunction codes.
;************************************************************************
; F_ISR, F_SYSTEM and F_IO_CONTROL are functions common to all drivers.
; Subfunction under F_STATE_IOCTL particular to this driver.
;
F_STATE_IOCTL		equ	0008H	; Get and set the state

SF_GET_STATE		equ	0000H	; 
SF_SET_STATE		equ	0002H	; 

;**********************************************************************
; V_HPHIL Data Structure - do not tread lightly in this data structure
;**********************************************************************
HPHIL_DATA              struc
                        db      size HP_SHEADER DUP (?) ; dirver header
CRV_STATUS              dw      ?
CRV_ENVOY_STATUS        db      ?     ; status bits used to support
                                      ; the envoy keyboard
CRV_CURRENT_STATE       db      ?     ; current configuration address
CRV_ADDRESS             db      ?     ; configuration address
CRV_POLL_ADDRESS        db      ?     ; address of device whose poll
CRV_POLL_HEADER         db      ?     ; poll header of data being proc
CRV_MAJOR               db      ?     ; default major address
CRV_MINOR               db      ?     ; default minor address
CRV_EXPECTED_CMD        db      ?     ; command expected to return
CRV_KBD_ADDRESS         db      ?     ; address of the keyboard
CRV_MAX_DEVICES         db      ?     ; status byte of itf keycode tra
CRV_KC_STATE            db      ?     ; state of itf kc translation
CRV_POLL_RECORD         db      32 DUP (?)      ; poll record buffer
RQ_ENV_REPEAT           db      ?     ; envoy special command for repe
RQ_ENV_DELAY            db      ?     ; envoy special command for dela
RQ_ENV_LED              db      ?     ; envoy special command for led'
RQ_RequEST              db      ?
RQ_REGISTER             db      ?
RQ_ADDRESS              db      ?
RQ_DATA                 db      ?
RQ_MAX_BURST            dw      ?
RQ_COUNT                dw      ?
RQ_OFFSET               dw      ?
RQ_SEGMENT              dw      ?
RQ_SPECIAL              db      ?
RQ_TIMEOUT              db      ?
HPHIL_DATA      ends
;
endif	; SYS
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\system\system.inc ===
;***************************************************************************
;                                                                          *
;   Copyright (C) 1983,1984 by Microsoft Inc.                              *
;                                                                          *
;***************************************************************************

;***************************************************************************
;                                                                          *
;   Header file for IBM/PC timer device driver.  Contains all machine      *
;   specific constant and data structure definitions.                      *
;                                                                          *
;***************************************************************************

	.xlist
	include cmacros.inc
ifdef   NEC_98
	include windefs.inc
else    ; NEC_98
;	 include windefs.inc
endif   ; NEC_98
	.list

; picked off romstuff.inc

DSEG equ DATA
doffset EQU <DataOffset>

; Approximate value of timer tic in milliseconds * 1000.

ifdef   NEC_98
res_low     EQU 25000
else    ; NEC_98
res_low     EQU 54925
endif   ; NEC_98
res_high    EQU 0

; equates for disk status

REMOVEABLE  equ 2
FIXED       equ 3
REMOTE	    equ 4

; Offset of Single Diskette indicator from beginning of Bios Data Area, 400h

SingleDrive equ 104h

; Timer structure

tiblock     STRUC
tirate      DW  ?       ; -1 means not used, 0 means call as fast as possible
ticount     DW  ?       ; -1 means end of table.
tiproc      DD  ?       ; far proc to call.
tiblock     ENDS

ifdef   NEC_98
;
;	DELAY MACRO FOR 80386
; This macro is defined in SYSMAC.INC(V23 ROM BIOS)		<880203 ver2.1
;
DELAY	MACRO	DEV,ACT,MOD

	IFIDN	<DEV>,<8237>
		IFIDN	<ACT>,<O-O>
	JMP	SHORT	$+2
		ENDIF
		IFIDN	<ACT>,<O-I>
	JMP	SHORT	$+2
		ENDIF
		IFIDN	<ACT>,<>
	JMP	SHORT	$+2
		ENDIF
	ENDIF

	IFIDN	<DEV>,<8253>
		IFIDN	<ACT>,<O-O>
	REPT	2
	JMP	SHORT	$+2
	ENDM
		ENDIF
		IFIDN	<ACT>,<I-I>
	JMP	SHORT	$+2
		ENDIF
		IFIDN	<ACT>,<O-I>
	REPT	2
	JMP	SHORT	$+2
	ENDM
		ENDIF
		IFIDN	<ACT>,<I-O>
	JMP	SHORT	$+2
		ENDIF
		IFIDN	<ACT>,<>
	REPT	2
	JMP	SHORT	$+2
	ENDM
		ENDIF
	ENDIF

	IFIDN	<DEV>,<8255>
		IFIDN	<ACT>,<O-O>
	REPT	2
	JMP	SHORT	$+2
	ENDM
		ENDIF
		IFIDN	<ACT>,<I-I>
	JMP	SHORT	$+2
		ENDIF
		IFIDN	<ACT>,<O-I>
	REPT	2
	JMP	SHORT	$+2
	ENDM
		ENDIF
		IFIDN	<ACT>,<I-O>
	JMP	SHORT	$+2
		ENDIF
		IFIDN	<ACT>,<>
	REPT	2
	JMP	SHORT	$+2
	ENDM
		ENDIF
	ENDIF

	IFIDN	<DEV>,<8259>
		IFIDN	<ACT>,<O-O>
	JMP	SHORT	$+2
		ENDIF
		IFIDN	<ACT>,<I-I>
		ENDIF
		IFIDN	<ACT>,<O-I>
	JMP	SHORT	$+2
		ENDIF
		IFIDN	<ACT>,<I-O>
		ENDIF
		IFIDN	<ACT>,<>
	JMP	SHORT	$+2
		ENDIF
	ENDIF

	IFIDN	<DEV>,<8251>
		IFIDN	<ACT>,<O-O>
			IFIDN	<MOD>,<INIT>
	REPT	4
	JMP	SHORT	$+2
	ENDM
			ENDIF
			IFIDN	<MOD>,<ASYNC>
	REPT	5
	JMP	SHORT	$+2
	ENDM
			ENDIF
			IFIDN	<MOD>,<SYNC>
	REPT	10
	JMP	SHORT	$+2
	ENDM
			ENDIF
		ENDIF
	ENDIF

	IFIDN	<DEV>,<765>
	ENDIF

	IFIDN	<DEV>,<7220>
		IFIDN	<ACT>,<O-O>
			IFIDN	<MOD>,<GRAPH>
	REPT	4
	JMP	SHORT	$+2
	ENDM
			ENDIF
			IFIDN	<MOD>,<TEXT>
	REPT	2
	JMP	SHORT	$+2
	ENDM
			ENDIF
		ENDIF
		IFIDN	<ACT>,<I-I>
			IFIDN	<MOD>,<GRAPH>
	REPT	3
	JMP	SHORT	$+2
	ENDM
			ENDIF
			IFIDN	<MOD>,<TEXT>
	JMP	SHORT	$+2
			ENDIF
		ENDIF
		IFIDN	<ACT>,<O-I>
			IFIDN	<MOD>,<GRAPH>
	REPT	4
	JMP	SHORT	$+2
	ENDM
			ENDIF
			IFIDN	<MOD>,<TEXT>
	REPT	2
	JMP	SHORT	$+2
	ENDM
			ENDIF
		ENDIF
		IFIDN	<ACT>,<I-O>
			IFIDN	<MOD>,<GRAPH>
	REPT	3
	JMP	SHORT	$+2
	ENDM
			ENDIF
			IFIDN	<MOD>,<TEXT>
	JMP	SHORT	$+2
			ENDIF
		ENDIF
	ENDIF

	IFIDN	<DEV>,<7201>
		IFIDN	<ACT>,<O-O>
	JMP	SHORT	$+2
		ENDIF
		IFIDN	<ACT>,<O-I>
	JMP	SHORT	$+2
		ENDIF
	ENDIF

	IFIDN	<DEV>,<7210>
		IFIDN	<ACT>,<O-O>
	JMP	SHORT	$+2
		ENDIF
		IFIDN	<ACT>,<O-I>
	JMP	SHORT	$+2
		ENDIF
	ENDIF

	IFIDN	<DEV>,<4990>
		REPT	3
		JMP	SHORT	$+2
		ENDM
	ENDIF

	ENDM

; dummy delay
DELAY2	MACRO	CNT
	local	l1
	push	cx
	mov	cx, CNT
l1:
	out	5fh, al
	loop	l1
	pop	cx
	ENDM
endif   ; NEC_98
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\system\chp\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake  /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DPRC"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\system\chs\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd ..
    nmake  /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DPRC"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\system\jpn\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DJAPAN"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\system\cht\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DTAIWAN"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\system\kor\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DKOREA"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\system\system.asm ===
;** SYSTEM.ASM **********************************************************
;									*
;   Copyright (C) 1983,1984,1985,1986,1987,1988 by Microsoft Inc.	*
;									*
;************************************************************************
;	History
;	18 oct 88	peterbe		Added fBootDrive and test for it,
;					for diskless workstations.
;************************************************************************

	TITLE SYSTEM - InquireSystem procedure to return info about devices

	include system.inc

;; AT&T Machines running DOS 3.10, revisions 1.0 and 1.01 place
;; this value into SingleDriveLoc

ATT31Loc	EQU    10d0h

ifdef   NEC_98
IOSYSSEG	EQU	0060H
LPTABLEOFF	EQU	006CH
EXLPTABLE	EQU	2C86H		;EXPANDED LPTABLEOFF
SNGDRV_FLG	EQU	0038H

BIOS_FLAG	EQU	ES:BYTE PTR[0100H]	; offset by seg 40h 
BIOS_FLAG1	EQU	ES:BYTE PTR[0080H]	;	"

EX_CPU_TYPE	EQU	00001000B
V30_BIT		EQU	01000000B
BIT286		EQU	00000001B
endif   ; NEC_98

MultHIMEM		EQU	43h	; HIMEM.SYS int 2fh multiplex
MHM_ReqInstall		EQU	00h	; Installation check
MHM_ReqInstall_Ret	EQU	0FFh	; I'm here Return

ifndef  NEC_98
externA 	__ROMBIOS
endif   ; NEC_98

externA 	__0040h

externFP	NoHookDOSCall

ifdef   NEC_98
externFP	GetPrivateProfileInt	; 930206
endif   ; NEC_98

ifdef	HPSYSTEM
ExternNP	<EnableVectra, DisableVectra>	;~~vvr 091989
endif

assumes CS,CODE

sBegin DATA

externB timerTable

;
; InquireSystem(what,which) - returns oem specific information
;	what is the code for the device
;	which specifies which one of those devices
;
;   WHAT = 0	    Timer resolution
;	Return the resolution of the timer specified by the which
;	parameter in DX:AX.  Windows always uses which == 0
;
;   WHAT = 1	    Disk Drive Information (Drive A = 0)
;	which is the disk drive (A = 0)
;	Returns:
;	    ax = 0 means the drive does not exist.  if dx != 0 then the drive
;		maps to the drive in dx instead (A = 1) AND the drive is
;		REMOVEABLE.
;	    ax = 1 means the drive does not exist.  if dx != 0 then the drive
;		maps to the drive in dx instead (A = 1) AND the drive is
;		FIXED.
;	    ax = 2 means the drive is removable media
;	    ax = 3 means the drive is fixed media
;	    ax = 4 means the drive is fixed media and remote
;
;   WHAT = 2	    Enable/Disable one drive logic
;	which = 0 means disable, which <> 0 means enable
;	This code enables/disables the RAM BIOS message:
;	"Please insert disk for drive B:"
;
ifdef   NEC_98
;   WHAT = 3        Coprocessor exception vector information
;       which is unused.
;       Returns:
;         ax = 1 means we must save & restore coprocessor error vector
;                  ( really,always return 1 )
;         dx : coprocessor exception interrrupt vector number
;
endif   ; NEC_98

;
; The following flag deals with some unpleasantness in the fast boot code.
;   The fast boot code delays our INIT call till to late because some code
;   in KERNEL which uses InquireSystem is called first. We fix this problem
;   with this flag......
;
globalB 	SystemIsInited,0

; Following from RAMDRIVE
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Unfortunately the code in ramdrive is very machine dependent
; necessitating the use of a system flag to store the machine
; configuration. The system flag is initialised during init time
; and used when the caching services are requested. One bit which
; is set and tested during caching is the state of the a20 line
; when the cache code is entered. This is used because there are
; applications which enable the a20 line and leave it enabled 
; throughout the duration of execution.  Since ramdrive is a device
; driver it shouldn't change the state of the environment.
;
; The system flag bit assignments are:
;
;	-------------------------------------------------
;	|  7  |  6  |  5  |  4  |  3  |  2  |  1  |  0  |
;	-------------------------------------------------
;	   |-----|     |     |	   |	 |     |     |
;	      |        |     |	   |	 |     |     -----286 (and AT)
;	      |        |     |	   |	 |     -----------386 (later than B0)
;	     not       |     |	   |	 -----------------PS/2 machine
;	    used       |     |	   -----------------------Olivetti (not used)
;		       |     -----------------------------A20 state (enabled ?)
;		       -----------------------------------DOS 3.x >= 3.3

; The Olivetti guys have defined a flag of their own. This should be removed
; and the bit assigned out here for them should be used. 
;
sys_flg		db	0
;
;	equates used for the system flag
;
M_286		equ	00000001B
M_386		equ	00000010B
M_PS2		equ	00000100B
M_OLI		equ	00001000B
A20_ST		equ	00010000B
DOS_33		equ	00100000B
HAVE_FFFE	equ	01000000B
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; A20 address line state determination addresses
;
low_mem label	dword
	dw	20h*4
	dw	0

high_mem label	dword
	dw	20h*4 + 10h
	dw	0ffffh

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; A20 PS2 equates
;
PS2_PORTA   equ 0092h
GATE_A20    equ 010b

; End RAMDRIVE stuff

globalB		numFloppies,0
globalB		fBootDrive,0
globalB		oneDriveFlag,0
globalW		coProcFlag,0
globalD 	HiMem,0
globalW 	DosVer,0

ifdef   NEC_98
savelptable	db	0
NDP_CONTROL	DW	0

EMM_DEVICE_NAME	DB	"EMMXXXX0"
	PUBLIC	EMM_FLAG
EMM_FLAG	DB	0

DRVCNT		DB	10H		;16 DRIVE

		PUBLIC	reflected
reflected	DB  0		; 0 not reflected    	930206
profinit	DB  0		; 0 is no initalized	930206
endif   ; NEC_98

;; SingleDriveLoc defaults to the value of SingleDrive (104h) on other
;; than AT&T machines.	Otherwise the value is changed during
;; the execution of single drive enable/disable.

SingleDriveLoc	dw	SingleDrive

sEnd

sBegin CODE

GlobalW     MyCSDS, _DATA

;-----------------------------------------------------------------------;
; InquireSystem
;
;
; Entry:
;
; Returns:
;
; Registers Destroyed:
;
; History:
;  Mon 21-Nov-1988 14:57:21  -by-  David N. Weise  [davidw]
;
;-----------------------------------------------------------------------;

	assumes ds,nothing
	assumes es,nothing

cProc	InquireSystem,<FAR,PUBLIC,NODATA>
	parmW	what
	parmW	which
cBegin
	push	ds
	mov	ds, MyCSDS
	assumes ds,DATA

	cmp	SystemIsInited,0	; Are we ready for this call?
	jnz	DoInq			; Yes
	call	far ptr InitSystem	; No, Set up
DoInq:
	mov	ax,what

;---------------------------------------
;
;  Timer information
;
	or	ax,ax
	jnz	is1
	mov	dx,res_high
	mov	ax,res_low
	jmp	ISDone

;---------------------------------------
;
;  Drive information
;
is1:	dec	ax		; ax = 1?
	jz	DriveInfo
	jmp	is5

DriveInfo:
	mov	ah,19h		; get the current disk
	cCall	NoHookDOSCall
	mov	bx,Which	; try to set to this disk
	cmp	al,bl		; already there?
	jz	DriveData	; yes, drive is good

	push	ax
	mov	dx,bx
	mov	ah,0Eh		; set to new disk
	cCall	NoHookDOSCall
	mov	ah,19h		; get the current disk
	cCall	NoHookDOSCall
	mov	bh,al
	pop	dx
	mov	ah,0Eh		; restore current disk
	cCall	NoHookDOSCall
	cmp	bh,bl		; Drive good?
	jz	DriveData	; yes
	jmp	is9		; no, this drive totally bad

; First check if this is network. We must do this first because
;  the removeable and phantom IOCTL calls return errors if you feed
;  them network drives. If it is network then we know it is non-removable
;  and not phantom.

DriveData:
	cmp	DosVer,0400h
	jb	no_4
	cmp	DosVer,0401h
	ja	no_4
	cCall	Dos4IsRemote,<Which>
	or	ax,ax
	jmp	short well_is_it

no_4:	mov	ax,4409h	; IOCTL is Remote
	mov	bx,Which
	inc	bx		; A = 1
	cCall	NoHookDOSCall
	jc	DoRem		; Call didn't work, go ahead
	test	dx,0001000000000000B
well_is_it:
	jz	DoRem		; Drive is local
	mov	cx,REMOTE	; Drive is not removeable
	jmp	short NoRemap	; Drive is not phantom

; Now Check "removeability"

DoRem:
	mov	ax,4408h	; IOCTL is removeable
	mov	bx,Which
	inc	bx		; A = 1
	cCall	NoHookDOSCall
	jc	OLDRemove	; Call didn't work, use old method
	mov	cx,FIXED
	test	ax,1
	jnz	DrivePhantom
	mov	cx,REMOVEABLE

; The drive is removable ...
; This code accounts for the fact that the code above on a PS/2
; Mod 50 diskless workstation reports the existence of a floppy
; drive on A: or B: even if it's unplugged.  If this is drive A:
; or B:, we need to test fBootDrive to see if this drive REALLY
; exists.

ifdef   NEC_98
	push	es		; ins <91.01.14> Y.Ueno
	mov	ax, 40h		;	"
	mov	es, ax		;	"
	push	si		;	"
	mov	si, Which	;
	mov	al, byte ptr es:[si+26ch]
	and	al, 0f0h
	cmp	al, 0a0h
	pop	si		;
	pop	es		;
	jne	DrivePhantom	;
	mov	cx,FIXED	;
else    ; NEC_98
	cmp	Which, 2	; this isn't likely, but..
	jae	DrivePhantom	;  there ARE removable hard drives.
	test	fBootDrive,1	; Must be a floppy, does this system have any?
	jnz	DrivePhantom	; if 0,
	jmp	Is9		;  we assume there are none
endif   ; NEC_98

; Now check for phantom drives

DrivePhantom:
	mov	ax,440EH	; IOCTL get logical map
	mov	bx,Which
	inc	bx		; A = 1
	cCall	NoHookDOSCall
	jc	OLDPhantom	; Call didn't work, use old method
	or	al,al		; If AL=0, drive is NOT phantom
	jz	NoRemap
	cmp	bl,al		; Drive maps to self?
	jz	NoRemap		; Yes, drive is not phantom
	xor	ah,ah
	mov	dx,ax		; DX is real drive
SetPhantomRet:
	xor	ax,ax		; Set removeable return
	cmp	cx,REMOVEABLE
	jz	IsDoneV
	inc	ax		; Set fixed return
	jmp	short IsDoneV

NoRemap:
	xchg	ax,cx		; AX = type of drive
	xor	dx,dx		; Indicate no remapping
IsDoneV:
	jmp	ISDone


; Check removeability with equipment word

OLDRemove:
ifdef   NEC_98
	mov	cx,FIXED
else    ; NEC_98
	xor	ax,ax
	or	al,numFloppies	; just one floppy on system?
	jnz	OLDR1		; no, continue
	inc	ax		; pretend we have two floppies...
OLDR1:
	cmp	ax,which
	mov	cx,FIXED
	jb	DrivePhantom
	mov	cx,REMOVEABLE
endif   ; NEC_98
	jmp	short DrivePhantom

; Check phantomness with equipment word

OLDPhantom:
ifdef   NEC_98
	jmp	short NoRemap	; No, drive B is real
else    ; NEC_98
	cmp	Which,1		; Drive B is only phantom
	jnz	NoRemap		; Not drive B, so not phantom
	cmp	numFloppies,0	; Single floppy system?
	jnz	NoRemap		; No, drive B is real
	mov	dx,1		; Drive B is really drive A
	jmp	short SetPhantomRet
endif   ; NEC_98

;---------------------------------------------------
;
;  Single Floppy enable/disable
;
is5:	dec	ax		; floppy enable disable?
ifdef   NEC_98
	jnz	is9a		; 	"
else    ; NEC_98
	jnz	is9
endif   ; NEC_98

is5b:	cmp	which,0 	; 0=disable
	jnz	is6

;  Disable various OEM things

	cmp	DosVer,0314h	; Below DOS 3.20?
	jae	nosingdrv1	; No, no ROM area diddle

;;
;;  AT&T MS-DOS 3.10 does not keep information on the last floppy
;;  drive accessed at 504h. The purpose of this section
;;  of code is to locate the bytes and patch them accordingly.
;;

ifndef  NEC_98
	mov	ax,__ROMBIOS		;; is this an AT&T machine ?
	mov	es,ax			;; look for start of 'OLIVETTI'
	cmp	es:[0C050h],'LO'
	jnz	ATTCheckDone		;; No, continue
	mov	SingleDriveLoc,ATT31Loc
ATTCheckDone:

	mov	ax,__0040h
	mov	es,ax
	mov	bx,SingleDriveLoc	;; set to drive A
	xor	ah, ah			;  set to drive A: also! (A=0)
	xchg	ah,es:[bx]
	mov	oneDriveFlag,ah 	; remember previous setting
endif   ; NEC_98
nosingdrv1:
	jmp	short is9

;   Enable various OEM things

is6:	cmp	DosVer,0314h		; Below DOS 3.20?
	jae	nosingdrv2		; No, no ROM diddle
ifndef  NEC_98
	mov	ax,__0040h
	mov	es,ax
	mov	bx,SingleDriveLoc	;; pointer to value
	mov	ah,oneDriveFlag
	mov	es:[bx],ah		;; restore to correct drive
endif   ; NEC_98
nosingdrv2:
ifdef   NEC_98
is9a:
	dec	ax
	jz	is9b	; what == 3 ?
	jmp	is9
is9b:
	push	es
	mov	ax,40h		; get ROM BIOS segment
	mov	es,ax
	test	BIOS_FLAG1,BIT286
	mov	ax,1
	jz	I_V30
	mov	dx,10h		;80286/80386 coprocess error vector
	jmp	short IOK
I_V30:
	mov	dx,16h		;8086/V30 coprocess error vector
IOK:
	pop	es
	jmp	ISDone
endif

is9:	xor	dx,dx
	xor	ax,ax
ISDone:
	pop	ds

cEnd	Inquire


;-----------------------------------------------------------------------;
; Get80x87SaveSize                                                      ;
; 									;
; 									;
; Arguments:								;
; 									;
; Returns:								;
; 									;
; Error Returns:							;
; 									;
; Registers Preserved:							;
; 									;
; Registers Destroyed:							;
; 									;
; Calls:								;
; 									;
; History:								;
; 									;
;  Thu Feb 05, 1987 10:15:13p  -by-  David N. Weise   [davidw]          ;
; Wrote it.								;
;-----------------------------------------------------------------------;

	assumes ds,nothing
	assumes es,nothing

cProc	Get80x87SaveSize,<PUBLIC,FAR>
cBegin nogen
	push	ds
	mov	ds, MyCSDS
	assumes ds, DATA
	mov	ax,CoProcFlag
	pop	ds
	ret	
cEnd nogen


;-----------------------------------------------------------------------;
; Save80x87State                                                        ;
; 									;
; 									;
; Arguments:								;
; 									;
; Returns:								;
; 									;
; Error Returns:							;
; 									;
; Registers Preserved:							;
; 									;
; Registers Destroyed:							;
; 									;
; Calls:								;
; 									;
; History:								;
; 									;
;  Thu Feb 05, 1987 10:15:17p  -by-  David N. Weise   [davidw]          ;
; Wrote it.								;
;-----------------------------------------------------------------------;

	assumes ds,nothing
	assumes es,nothing

cProc	Save80x87State,<PUBLIC,FAR>
;	parmD	savearea
cBegin nogen
	mov	bx,sp
	les	bx,[bx][4]
	fsave	es:[bx]
	ret	4
cEnd nogen


;-----------------------------------------------------------------------;
; Restore80x87State                                                     ;
; 									;
; 									;
; Arguments:								;
; 									;
; Returns:								;
; 									;
; Error Returns:							;
; 									;
; Registers Preserved:							;
; 									;
; Registers Destroyed:							;
; 									;
; Calls:								;
; 									;
; History:								;
; 									;
;  Thu Feb 05, 1987 10:15:23p  -by-  David N. Weise   [davidw]          ;
; Wrote it.								;
;-----------------------------------------------------------------------;

	assumes ds,nothing
	assumes es,nothing

cProc	Restore80x87State,<PUBLIC,FAR>
;	parmD	savearea
cBegin nogen
	mov	bx,sp
	les	bx,[bx][4]
	frstor	es:[bx]
	ret	4
cEnd nogen

if2
%out	Dummy A20 handler still here
endif

	assumes ds,nothing
	assumes es,nothing

cProc	A20_Proc,<PUBLIC,FAR>
;	parmW	enable
cBegin nogen
	mov	ax, 2			; No himem area error code
	ret	2
cEnd nogen


; the following routine is added per DavidW's suggestion that the disable
; calls be made through WEP routine and this WEP will call any clean-up
; to be done by the driver.

ifdef HPSYSTEM

cProc	WEP, <PUBLIC, FAR>
	parmW	dummy
cBegin	
	call	DisableVectra		;~~vvr 091989
	mov	ax, 1			; by convention
cEnd

else

cProc	WEP,<PUBLIC,FAR>
;	parmW	dummy
cBegin nogen
	mov	ax,1
	ret	2
cEnd nogen

endif ;HPSYSTEM


;-----------------------------------------------------------------------;
;									;
; BOOL Dos4IsRemote(int);						;
;									;
; ENTRY:  Word, iPDrive: must be of the form ( logical volume A = 0 )	;
;		Physical Drive Spec.			      B = 1	;
;							      C = 2	;
;							      ect.	;
; EXIT: BOOL  returned in AX True  = Remote				;
;			     False = Local				;
;									;
; DESTROYS: AX. (preserves all registers except AX for return value)	;
;									;
;  Wed 27-Sep-1989 20:08:18  -by-  David N. Weise  [davidw]		;
; Stole this from setup, made it smaller.				;
;									;
; AUTHOR: MC								;
;-----------------------------------------------------------------------;

cProc	Dos4IsRemote,<NEAR,PUBLIC.ATOMIC,NODATA>, <si,di,ds,es>

	ParmW	iPDrive 		; Int Physical drive spec 0 - 25
	localV	local_name,16		; Buffer to hold redirected local name.
	localV	net_name,128		; Buffer to hold remote device name.
					; redirected local device names.
cBegin

; We have to use DOS call int 21h/5f02h because DOS call int 21h/4409h
; is not reliable under DOS versions 4.00 and 4.01.

        xor     cx,cx
	mov	ax,ss			; Load segs for stack vars.
        mov     es,ax
        mov     ds,ax

next_entry:
        mov     bx,cx                 ; CX = redirection list index.
        lea     si,local_name         ; ds:si = local_name
        lea     di,net_name           ; es:di = net_name
        push    cx                    ; save CX
	mov	ax,5F02h	      ; func 5f/02 Get redirection list.
	call	NoHookDOSCall
        pop     cx                    ; restore CX
	mov	ax,0		      ; don't change flags
	jc	IsRemoteDone	      ; error, not supported or end of list.

        cmp     bl,04h                ; Is redirected device a drive ?
        jne     not_a_drive           ; If not, we don't care !

	mov	al,ds:[si]	      ; Grab volume name.
        sub     al,41h                ; Convert to volume number A=0 ect.
	cmp	ax,iPDrive
	jz	remote_found

not_a_drive:
        inc     cx                    ; CX = redirection list index.
        jmp     short next_entry

remote_found:
        mov     ax,1                  ; Indicate Volume is remote !

IsRemoteDone:

cEnd

;-----------------------------------------------------------------------;
; InitSystem
;
;
; Entry:
;
; Returns:
;
; Registers Destroyed:
;
; History:
;  Mon 21-Nov-1988 14:57:21  -by-  David N. Weise  [davidw]
;
;-----------------------------------------------------------------------;

	assumes ds,nothing
	assumes es,nothing

ifdef   NEC_98
sSysIni         db      "system.ini",0          ; name of file.	930206
sSystem         db      "system",0              ; [system] section.930206
sTimer          db      "reflecttimer", 0       ; 0 : no 1:yes	930206
endif   ; NEC_98

cProc	InitSystem,<PUBLIC,FAR>
cBegin	nogen
	push	ds

	mov	ds, MyCSDS
	assumes ds, DATA

ifdef   NEC_98
  ;930206
	cmp	[profinit],0
	jnz	profinitdone
	inc	[profinit]
	push	es
        ; Get keyboard table type from WIN.INI.
        lea	si, sSystem
        lea	di, sTimer
        lea	bx, sSysIni
        regptr  cssi,cs,si                      ; lpAppName = "keyboard"
        regptr  csdi,cs,di                      ; lpKeyName = "type"
        regptr  csbx,cs,bx                      ; lpFile = "SYSTEM.INI"
	mov	ax, 0				; defualt is not reflect
	cCall	GetPrivateProfileInt,<cssi, csdi, ax, csbx>

	mov	byte ptr [reflected], al
	pop	es
profinitdone:
  ;930206
endif   ; NEC_98

	cmp	SystemIsInited,0	; Have we already done this?
	jnz	no_80x87		; Yes
	inc	SystemIsInited		; We will now init

	mov	ah,30h		; Get DOS version
	int	21h
	xchg	ah,al		; major <-> minor
	mov	DosVer,ax

ifdef	HPSYSTEM
	call	EnableVectra		;~~vvr 091889
endif

ifndef  NEC_98
	int	11h			; get equipment word
	push	ax
	mov	cl,6
	shr	ax,cl
	and	al,00000011b		; isolate drive count
	mov	numFloppies,al
	pop	ax

; Set fBootDrive

	mov	fBootDrive,al		; bit 0 has boot volume installed flag
endif   ; NEC_98

; Set CoProcFlag

	mov	CoProcFlag,0
ifdef   NEC_98
	FINIT
	FINIT
	delay2	14
	xor	ax, ax
	mov	NDP_CONTROL, ax		; clear temp
	FSTCW	NDP_CONTROL
	delay2	14
	and	NDP_CONTROL, 0f3fh	;
	cmp	NDP_CONTROL, 033fh	;
	jne	no_80X87
	FSTSW	NDP_CONTROL
	delay2	14
	inc	ax
	test	NDP_CONTROL, 0b8bfh
	jnz	no_80X87
else    ; NEC_98
	test	al,2			; this is the IBM approved method
	jz	no_80x87		;   to check for an 8087
endif   ; NEC_98
	mov	CoProcFlag,94		; size of save area
	FNINIT
no_80x87:
	mov	ax,1
	pop	ds
	ret

cEnd nogen

ifdef	JAPAN
;-----------------------------------------------------------------------;
; JapanInquireSystem( what, which )
;   Get system information - Japanese specific.
;
; Entry:
;	what - function code as;
;		0 - Inquire interrupt vector modification
;			'which' contains interrupt vector number (0-FF)
;			to get it is can be changed. Returns zero if a
;			vector cannot be changed
;		1 - Get Boot drive
;			Returns boot drive. 0=A,1=B...etc.
;
;-----------------------------------------------------------------------;

	assumes ds,nothing
	assumes es,nothing

cProc	JapanInquireSystem,<PUBLIC,FAR>
	parmW	what
	parmW	which
ifdef   NEC_98
	localW 	WKDRV			; 92.11.17 Win31 NEC
endif   ; NEC_98
cBegin
	mov	ax,what
	test	ax,ax		; what=1?
	jnz	jis2		; jump if not
ifndef  NEC_98
	mov	ax,which	; get vector number to examine
	cmp	al,1bh		; try to change 1b?
	jz	jis1		; jump if so - cannot modify
	cmp	al,1ch		; try to change 1c?
	jz	jis1		; jump if so - channot modify
endif   ; NEC_98
	mov	ax,1		; OK to modify
	jmp	jisx
jis1:
	xor	ax,ax		; cannot modify
	jmp	jisx
jis2:
	dec	ax		; what=2?
	jnz	jis3		; jump if not
ifdef   NEC_98
	mov	ax,3000H	; Get DOS Version
	int	21H		;
	cmp	al,05H
	jb	jis3
	mov	ah,33H		; Get Boot Drive DOS5
	mov	al,05H
	int	21H
	mov	dh,00h
	mov	WKDRV,dx
	mov	ax,WKDRV
	dec	ax
else    ; NEC_98
	mov	ax,2		; drive 'C:' is a default boot drive for
				; industrial standard PC
endif   ; NEC_98
	jmp	jisx
jis3:
	mov	ax,-1		; error!
jisx:
cEnd

endif	;JAPAN


sEnd	CODE		; End of code segment


END	InitSystem
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\system\usa\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH)
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\system\timer.inc ===
;/************************************************************************
;*									*
;* 		< SYSTEM Application Program  >				*
;*									*
;*									*
;*		COPYRIGHT (C) NEC CORPORATION 1989			*
;*									*
;*		NEC CONFIDENTAL AND PROPRIETARY				*
;*									*
;*		All rights reserved by NEC Corporation.			*
;*		this program must be used solely for			*
;*		the purpose for which it was furnished			*
;*		by NEC Corporation.  No part of this program		*
;*		may be reproduced or disclosed to others,		*
;*		in any from, without the prior written			*
;*		permission of NEC Corporation.				*
;*		Use of copyright notice does not evidence		*
;*		publication of this program.				*
;*									*
;*************************************************************************/
;------------------------------ Module Header ------------------------------;
; Module Name: Timer interface procedures
;
; Created: 03-08-90 NEC Y.Ueno

INTMASK		EQU	2
TIMODESET	EQU	77H
TICNTSET	EQU	71H
EOI		EQU	20H
EOIPORT		EQU	0
TIMERMASK	EQU	01H

mask macro	code
	cli				; mask timer int
	in	al,02h
	delay	8259,I-O
	or	al,code
	out	02h,al
	jmp	$+2
	sti
	endm

unmask macro	code
	cli				; mask timer int
	in	al,02h
	delay	8259,I-O
	and	al,not code
	out	02h,al
	jmp	$+2
	sti
	endm

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\system\timer.asm ===
;------------------------------ Module Header ------------------------------;
; Module Name: Timer interface procedures
;
; Created: ??-???-83
;
; Copyright (c) 1983, 1984, 1985, 1986, 1987  Microsoft Corporation
;
; History:
;  10-Jan-87 by ronm  Adusted StackBase to be even
;   9-Jan-87 by ronm  Patches to support HiTime.asm
;---------------------------------------------------------------------------;

	TITLE	Timer interface procedures

include system.inc
include wow.inc
include wowusr.inc
include vint.inc
ifdef   NEC_98
include timer.inc
externA 	__ROMBIOS
endif   ; NEC_98

externFP WOW16Call

; Interrupt vector to use

VECTOR	    equ 08h

assumes CS,CODE

sBegin DATA

		PUBLIC	timerTable
timerTable	LABEL	BYTE
tiblock     <-1,0,0>
tiblock     <-1,0,0>
tiblock     <-1,0,0>
tiblock     <-1,0,0>
tiblock     <-1,0,0>
tiblock     <-1,0,0>
tiblock     <-1,0,0>
tiblock     <-1,0,0>
	    DW	    -1
	    DW	    -1

ifdef WOW
cTimers         DW  0
endif

enabled 	DB  0		; 0 means int 8 hook not installed
				; 1 means int 8 hook installed
				; >1 means inside our int 8 hook

ifdef   NEC_98
externB		reflected	; 930206
endif   ; NEC_98

if 0
;
;   no longer used
;
	public	StackBase
		EVEN		; Put the stack at a word boundary!
StackBase	DB  64	DUP (-1)

	PUBLIC	prevInt8Proc,prevSSSP,enabled
	PUBLIC	cms, cmsRound

		DB  128 DUP (?)
int8stack	LABEL	BYTE	; Stack to use inside our int 8 hook

prevSSSP	DD  0		; Previous stack when inside our hook
endif

prevInt8Proc	DD  0		; Previous int 8 interrupt handler
cms		DD  0		; msec count.
cmsRound	DW  0		; for rounding off the msec count.
ifdef   NEC_98
		DB  '@@@@'
TIINTFLAG1	DW  0
TIINTFLAG2	DW  0
endif   ; NEC_98

sEnd

sBegin	CODE	    ; Beginning of code segment
assumes CS,CODE

externW  MyCSDS     ; always in CS (even in ROM)

;--- timer hardware service -----------------------
;
noevent:
ifdef   NEC_98
	assumes ds, DATA
	cmp	[reflected],0
	jne	@f

NoReflect:
	push	ax
	mov	al,20h		; eoi
	out	0,al
	pop	ax
	pop	ds
	iret

@@:	assumes ds,nothing
	push	ds
	push	ax
	mov	ax, __ROMBIOS
	mov	ds, ax
	cmp	word ptr ds:[018ah], 1	; Q : timer counter end ?
	pop	ax
	pop	ds
	je	short NoReflect
endif   ; NEC_98
	assumes ds, DATA
	; push address
	push	word ptr prevInt8Proc[2]
	push	word ptr prevInt8Proc[0]

	; restore ds out of stack
	push	bp
	mov	bp, sp
	mov	ds, [bp+6]
	assumes ds,nothing
	pop	bp

	; jump to prev proc popping saved ds
	retf	2

;----------------------------- Private Function ----------------------------;
;
; Entry:	call	far ptr timer_int
;
; Returns:	nothing
;
; Registers Destroyed: none
;
; History:
;  09-Jan-87 by ronm  Added hooks for the high resolution timer fns
;		      in hitime.asm
;  ??-???-?? by ????  Wrote it
;---------------------------------------------------------------------------;

	assumes	ds,nothing
	assumes	es,nothing

cProc	timer_int,<FAR,PUBLIC>

cBegin nogen

; Don't trash any registers.

	push	ds
	mov	ds,MyCSDS
	assumes ds, DATA
	add	word ptr [cms][0],(res_low / 1000)
	adc	word ptr [cms][2],0
	add	[cmsRound],(res_low - ((res_low / 1000) * 1000))
	cmp	[cmsRound],1000
	jb	ti0
	sub	[cmsRound],1000
	inc	word ptr [cms][0]
	jnz	ti0
	inc	word ptr [cms][2]
ti0:
ifdef   NEC_98
	push	dx		; clear int share reg.
	push	ax
	mov	dx,879h
	in	al,dx
	pop	ax
	pop	dx
endif   ; NEC_98
	cmp	[enabled],1
	jne	noevent
	inc	[enabled]
ifdef   NEC_98
	cmp	[reflected],0
	je	short ti01
endif   ; NEC_98

	pushf

	; enable IF flag in stack flags to prevInt8Proc if they were
	; on when this routine was entered -- this allows the 286 DOS
	; extender to enable ints after running real mode Int 8 handler.

	FLAGS1 = 3			;	 +0   +2   +4	+6   +8  +10
	FLAGS2 = 11			; BP -> [bp] [fl] [ds] [ip] [cs] [fl]

	push	bp
	mov	bp,sp
	test	byte ptr FLAGS2[bp],02h
	jz	@f
	or	byte ptr FLAGS1[bp],02h
@@:	pop	bp


	call	[prevInt8Proc]	; call previous Int 8 routine

ifdef   NEC_98
	push	ax
	mask	TIMERMASK
	mov	al,36h
	out	timodeset,al		; Timer mode set
	delay	8253,O-O
	mov	ax,0f000h		;count(25msec * 2457.6)
	push	es
	push	ax
	mov	ax,40h
	mov	es,ax
	test	byte ptr es:[101h],80h	; Q : clock 2.5 MHz ?
	pop	ax
	pop	es
	jz	@f			;5MHz,10MHz,12MHz,20MHz 25MHz set
	mov	ax,0c300h		;8MHz,16MHz  set
@@:
	out	ticntset,al
	delay	8253,O-O
	xchg	ah,al
	out	ticntset,al
	unmask	TIMERMASK
	pop	ax
	jmp	short ti1
ti01:
	push	ax
	mov	al,20h			; eoi
	out	0,al
	pop	ax
endif   ; NEC_98

	public	ti1
ti1:

comment ~
        FCLI
	mov	word ptr [prevSSSP][2],ss
	mov	word ptr [prevSSSP][0],sp
	push	ds
	pop	ss
	mov	sp,codeOffset int8stack
        FSTI                     ; Allow interrupts

end comment ~

	push	ax

	mov	al,00001011b	; ask for 8259 status
ifdef   NEC_98
	out	00h,al
	jmp	$+2
	jmp	$+2
	in	al,00h		; get the status
else    ; NEC_98
	out	20h,al
	jmp	$+2
	in	al,20h		; get the status
endif   ; NEC_98
	or	al,al
	jnz	TheEnd		; if other pending EOIs, just exit

	push	bp
	push	es
	push	bx
	push	cx
	push	dx
	push	si
	push	di

	xor	bp,bp		    ; No valid BP chain
	mov	si,doffset TimerTable
nextent:
	cld
	lodsw			    ; Get timer rate
	.errnz	tirate
	inc	ax		    ; -1 means unused entry
	jnz	checkent	    ; no, check used entry
	lodsw			    ; yes, get timer count
	.errnz	2-ticount
	inc	ax		    ; another -1 means end of table
	jz	lastent 	    ; yes, all done
	add	si,4		    ; o.w. skip to next entry
	jmp	nextent
checkent:
	dec	ax		    ; 0 means call at maximum rate
	jz	callent
	dec	word ptr DS:[si]    ; o.w. decrement rate counter
	.errnz	2-ticount
	jz	callent 	    ; zero means timer has gone off
	add	si,6		    ; o.w. skip to next entry
	jmp	nextent
callent:
	mov	DS:[si],ax
	inc	si
	inc	si
	lea	ax,[si-4]	    ; Pass timer handle in AX
	.errnz	4-tiproc
	call	dword ptr DS:[si]
	add	si,4
	jmp	nextent
lastent:
	pop	di
	pop	si
	pop	dx
	pop	cx
	pop	bx
	pop	es
	pop	bp
TheEnd:
	pop	ax
	dec	[enabled]

comment ~
        FCLI
	mov	ss,word ptr [prevSSSP][2]
	mov	sp,word ptr [prevSSSP][0]
        FSTI

end comment ~

	pop	ds


	iret

cEnd nogen


;============================================================================
; DWORD GetSystemMsecCount(void) - returns msec count.
;

	assumes ds,nothing
	assumes	es,nothing

    DUserThunk  GETSYSTEMMSECCOUNT,0

;LabelFP <PUBLIC, GetSystemMsecCount>
;
;	 push	 ds
;	 mov	 ds, MyCSDS
;	 assumes ds, DATA
;
;	 mov	 ax,word ptr [cms][0]
;	 mov	 dx,word ptr [cms][2]
;	 pop	 ds
;	 retf

;----------------------------- Private Function ----------------------------;
;
; EnableSystemTimers() - enable hardware timer interrupts
;
; Entry:    cCall   far ptr EnableSystemTimers
;
; Returns:  nothing
;
; Registers Destroyed:	??
;
; History:
;  09-Jan-87 by ronm  Patched to support hitime.asm
;  ??-???-?? by ????  Wrote it
;---------------------------------------------------------------------------;


	assumes	ds,nothing
	assumes	es,nothing

cProc	EnableSystemTimers,<FAR,PUBLIC>
cBegin	nogen

; All done if just already enabled

	push	ds
	mov	ds,MyCSDS
	assumes ds, DATA

ifdef WOW
        ; see if we're being called by Create to really enable tics
        cmp     cTimers, 1
        je      est_doit
endif

	cmp	enabled,0
	jne	edone

est_doit:
	mov	[enabled],1

ifdef WOW
        ; don't install the tic handler if no systemtimers registered
        cmp     cTimers, 0
        je      edone
endif

; Save away current timer interrupt vector value

	mov	ax,3500h or VECTOR
	int	21h
	mov	word ptr [PrevInt8Proc][0],bx
	mov	word ptr [PrevInt8Proc][2],es

; Setup timer interrupt vector to point to our interrupt routine

	mov	ax,2500h or VECTOR
	push	cs
	pop	ds
	mov	dx,codeOFFSET timer_int
	int	21h
ifdef   NEC_98
	mask	TIMERMASK
	mov	al,36h
	out	timodeset,al		; Timer mode set
	delay	8253,O-O
	mov	ax,0f000h		;count(25msec * 2457.6)
	push	es
	push	ax
	mov	ax,40h
	mov	es,ax
	test	byte ptr es:[101h],80h		; Q : clock 2.5 MHz ?
	pop	ax
	pop	es
	jz	@f			;5MHz,10MHz,12MHz,20MHz 25MHz set
	mov	ax,0c300h		;8MHz,16MHz  set
@@:
	out	ticntset,al
	delay	8253,O-O
	xchg	ah,al
	out	ticntset,al
	unmask	TIMERMASK
	sti
endif   ; NEC_98
edone:
	pop	ds
	ret
cEnd	nogen


;-----------------------------------------------------------------------;
; DisableSystemTimers
;
; DisableSystemTimers() - disable system timer interrupts, restoring
; the previous timer interrupt handler.
;
; Entry:
;
; Returns:
;
; Registers Destroyed:
;
; History:
;  Mon 21-Nov-1988 18:44:44  -by-  David N. Weise  [davidw]
; Added this nifty comment block.
;-----------------------------------------------------------------------;

	assumes ds,nothing
	assumes es,nothing

cProc	DisableSystemTimers,<FAR,PUBLIC>
cBegin	nogen

	push	ds
	mov	ds,MyCSDS
	assumes ds, DATA

; Do nothing if not enabled

	cmp	[enabled],0
	je	ddone
ifdef   NEC_98
	mask	TIMERMASK
endif   ; NEC_98
	mov	[enabled],0

; Restore the timer interrupt vector to point to previous value

	mov	ax,2500h or VECTOR
	lds	dx,prevInt8Proc
	int	21h
ddone:
	pop	ds
	ret
cEnd	nogen

;-----------------------------------------------------------------------;
; CreateSystemTimer
;
;
; Entry:
;
; Returns:
;
; Registers Destroyed:
;
; History:
;  Mon 21-Nov-1988 18:44:44  -by-  David N. Weise  [davidw]
; Added this nifty comment block.
;-----------------------------------------------------------------------;

	assumes ds,nothing
	assumes es,nothing

cProc	CreateSystemTimer,<PUBLIC,FAR>
	ParmW	rate
	ParmD	lpproc
cBegin
	mov	ds,MyCSDS
	assumes ds, DATA
	mov	bx,doffset timerTable
	mov	ax,rate
	or	ax,ax
	jz	ctfirst
	mov	cx,1000 		; change msecs into ticks.
	mul	cx
	mov	cx,res_low
	div	cx
ctfirst:
        FCLI                             ; beginning of critical section
ctloop:
	cmp	ds:[bx].tirate,-1
	jne	ctnext
	cmp	ds:[bx].ticount,-1
	je	ctfail
	mov	cx,OFF_lpproc
	mov	dx,SEG_lpproc
	mov	word ptr ds:[bx].tiproc[0],cx
	mov	word ptr ds:[bx].tiproc[2],dx
	mov	ds:[bx].ticount,ax
	mov	ds:[bx].tirate,ax	   ; Set this last

ifdef WOW
        ; turn on tics if the count is going from 0 -> 1 and they're
        ; supposed to be enabled

        inc     cTimers
        cmp     cTimers, 1
        jne     @f

        cmp     enabled, 0      ; need to turn on tics?
        je      @f              ; -> nope

        push    bx
        call    EnableSystemTimers
        pop     bx
@@:
endif

	jmp	short ctexit

ctnext: add	bx,SIZE tiblock
	jmp	ctloop

ctfail: xor	bx,bx

ctexit: FSTI                                ; end of critical section
	mov	ax,bx
	mov	cx,bx
cEnd

;-----------------------------------------------------------------------;
; KillSystemTimer
;
;
; Entry:
;
; Returns:
;
; Registers Destroyed:
;
; History:
;  Mon 21-Nov-1988 18:44:44  -by-  David N. Weise  [davidw]
; Added this nifty comment block.
;-----------------------------------------------------------------------;

	assumes ds,nothing
	assumes es,nothing

cProc	KillSystemTimer,<PUBLIC,FAR>,<di>
	parmW	htimer
cBegin
	mov	es,MyCSDS
	assumes es,nothing
	mov	di,doffset TimerTable
	mov	ax,htimer

ktloop: cmp	es:[di].tirate,-1
	jne	ktmatch
	cmp	es:[di].ticount,-1
	jne	ktnext
	jmp	short ktexit
ktmatch:
	cmp	di,ax
	jne	ktnext
	cld
	mov	ax,-1
	stosw
	not	ax
	stosw
	stosw
	stosw
ifdef WOW
        dec     es:[cTimers]     ; was this the last one?
        jnz     @f                ;  -> nope

        cmp     es:[enabled], 0  ; are tics on?
        je      @f                ;  -> nope

; Restore the timer interrupt vector to point to previous value

        push    ax

	mov	ax,2500h or VECTOR
        lds     dx,es:[prevInt8Proc]
	int	21h

        pop     ax
@@:
endif

	jmp	short ktexit

ktnext: add	di,SIZE tiblock
	jmp	ktloop

ktexit: mov	cx,ax
cEnd

ifdef   NEC_98
LabelFP <PUBLIC, InquireLongInts>
;------- '88/01/07 -----------------------------------
	MOV	AX,1
;	mov	ax,cs:[AT_DOS30]
;------------------------------------------------------
	mov	cx,ax
	retf
endif   ; NEC_98

sEnd	CODE		; End of code segment

END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\system\vecsys.inc ===
;------------------------------------------------------------------
;
; HPsysCall(Service, Function, Subfunction)
;
; Purpose	General purpose HP system calling routine
;
; Parameters	Service - HP vector
;		Function
;		Subfunction - function numbers
;
; Results	returns AH which is 0 for success
;		
;-------------------------------------------------------------------	
HPSysCall macro	Device, Function, SubFunc
	
	push	ds
	push	bp
	push	ax

	mov	bx, offset RealMode_Word_Struc
	pushf
	pop	RealMode_flags[bx]
	mov	RealMode_BP[bx], Device
	mov	RealMode_AH[bx], Function
	mov	RealMode_AL[bx], SubFunc
	mov	ax, ds
	mov	es, ax				; make es = ds
	mov	di, bx
	mov	bl, 6fh
	xor	bh, bh
	xor	cx, cx
	mov	ax, 0300h
	int	31h
	mov	bx, offset RealMode_Word_Struc
	mov	ax, es
	mov	ds, ax
	mov	bx, RealMode_BX[bx]

	pop	ax
	pop	bp
	pop	ds

	endm 	


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\timer\sources.inc ===
TARGETNAME=
TARGETTYPE=NOTARGET
TARGETPATH=
SOURCES=

NTTARGETFILE1=buildall

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\system\windefs.inc ===
;***************************************************************************
;                                                                          *
;   Copyright (C) 1983,1984 by Microsoft Inc.                              *
;                                                                          *
;***************************************************************************

;       Macros for disabling and restoring hardware interrupt enable flag
;
;       The LeaveCrit macro has been updated for the mask problem on
;       the 80286 processor.


include vint.inc

EnterCrit   MACRO
        pushf
        FCLI
ENDM

LeaveCrit   MACRO
        POPFF
ENDM

POPFF   MACRO
        local   a
        jmp     $+3
a       label   near
        iret
        push    cs
        call    a
ENDM





;***************************************************************************
;                                                                          *
;   Inquire data structures for Timer, Keyboard, Mouse and Cursor modules  *
;                                                                          *
;***************************************************************************

TIMERINFO       STRUC
tiResolution    DD      0       ; #microseconds each timer tick
TIMERINFO       ENDS

KBINFO          STRUC
kbRanges        DB      4 dup (0)  ; Far East ranges for KANJI
kbStateSize     DW      0       ; #bytes of state info maintained by TOASCII
kbNumFuncKeys   DW      0       ; How many function keys are on the keyboard
kbHasBreak      DW      0       ; true => keyboard supplies make and break
kbRate          DW      0       ; maximum rate of keyboard input events
KBINFO          ENDS


MOUSEINFO       STRUC
msExists        DB      0       ; true => mouse exists
msRelative      DB      0       ; true => relative coordinate
msNumButtons    DW      0       ; number of buttons on the mouse
msRate          DW      0       ; maximum rate of mouse input events
msXThresh       DW      0       ; threshold before acceleration
msYThresh       DW      0       ;
msXRes          DW      0       ; x resolution
msYRes          DW      0       ; y resolution
MOUSEINFO       ENDS


CURSORINFO      STRUC
dpXRate         DW      0       ; horizontal mickey/pixel ratio
dpYRate         DW      0       ; vertical mickey/pixel ratio
CURSORINFO      ENDS


;***************************************************************************
;                                                                          *
; Cursor data structure passed to OEM routines.  Defines a graphics display*
; cursor in terms of a hotspot, an AND mask and an XOR mask.  The hot      *
; spot defines the pixel within the cursor that is the cursor is "pointing"*
; to.  So when displaying a cursor at location X,Y the pixel that          *
; is the hot spot should be painted at that X,Y coordinate.  The "shape"   *
; of the cursor is defined by two pixel masks.  The first mask is ANDed    *
; with the bits in the display bitmap and the second mask is XORed with    *
; the result to determine the bits that will be placed in the display      *
; bitmap.  The bits for the masks are in the byte array that begins        *
; at the csBits field, with the AND mask bits first, followed by the       *
; XOR mask bits.  The csWidthBytes field is the width of ONE mask, in      *
; bytes.  Currently, MS-WIN will only generate cursors whose width and     *
; height are both 16.                                                      *
;                                                                          *
;***************************************************************************

cursorShape     STRUC
csHotX          DW      0
csHotY          DW      0
csWidth         DW      0
csHeight        DW      0
csWidthBytes    DW      0
csColor         DW      0
    ; Beginning of an array of bytes that contain the bits for the AND and
    ; XOR masks.  The first csHeight * csWidthBytes bytes contain the bits
    ; for the AND mask and the next csHeight * csWidthBytes bytes contain
    ; the bits for the XOR mask.
;csBits          DB  2*2*16 DUP (?)
cursorShape     ENDS
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\timer\math.asm ===
page    ,132
;---------------------------Module-Header-------------------------------;
; Module Name: MATH.ASM
;
; Contains FIXED point math routines.
;
; Created:  Sun 30-Aug-1987 19:28:30
; Author: Charles Whitmer [chuckwh]
;
; Copyright (c) 1987  Microsoft Corporation
;-----------------------------------------------------------------------;

?WIN	= 0
?PLM	= 1
?NODATA = 0
?DF=1
PMODE=1

        .xlist
        include cmacros.inc
;       include windows.inc
        include timer.inc
        .list

UQUAD   struc
uq0     dw      ?
uq1     dw      ?
uq2     dw      ?
uq3     dw      ?
UQUAD	ends

; The following structure should be used to access high and low
; words of a DWORD.  This means that "word ptr foo[2]" -> "foo.hi".

LONG    struc
lo      dw      ?
hi      dw      ?
LONG    ends

sBegin  Code286
        assumes cs,Code286
	assumes ds,nothing
        assumes es,nothing

;---------------------------Public-Routine------------------------------;
; qdiv
;
; This is an extended precision divide routine which is intended to
; emulate the 80386 64 bit/32 bit DIV instruction.  We don't have the
; 32 bit registers to work with, but we pack the arguments and results
; into what registers we do have.  We will divide two unsigned numbers
; and return the quotient and remainder.  We will do INT 0 for overflow,
; just like the 80386 microcode.  This should ease conversion later.
;
; Entry:
;       DX:CX:BX:AX = UQUAD Numerator
;       SI:DI       = ULONG Denominator
; Returns:
;       DX:AX = quotient
;       CX:BX = remainder
; Registers Destroyed:
;       none
; History:
;  Tue 26-Jan-1988 00:02:09  -by-  Charles Whitmer [chuckwh]
; Wrote it.
;-----------------------------------------------------------------------;
        assumes ds,nothing
        assumes es,nothing

cProc   qdiv,<PUBLIC,NEAR>,<si,di>
        localQ  uqNumerator
        localD  ulDenominator
        localD  ulQuotient
        localW  cShift
cBegin

; stuff the quad word into local memory

        mov     uqNumerator.uq0,ax
        mov     uqNumerator.uq1,bx
        mov     uqNumerator.uq2,cx
        mov     uqNumerator.uq3,dx


; check for a zero Numerator

        or      ax,bx
        or      ax,cx
        or      ax,dx
        jz      qdiv_exit_relay         ; quotient = remainder = 0

; handle the special case when the denominator lives in the low word

        or      si,si
        jnz     not_that_special

; calculate (DX=0):CX:BX:uqNumerator.uq0 / (SI=0):DI

        cmp     di,1                    ; separate out the trivial case
        jz      div_by_one
        xchg    dx,cx                   ; CX = remainder.hi = 0
        mov     ax,bx
        div     di
        mov     bx,ax                   ; BX = quotient.hi
        mov     ax,uqNumerator.uq0
        div     di                      ; AX = quotient.lo
        xchg    bx,dx                   ; DX = quotient.hi, BX = remainder.lo
ifdef WIMP
        or      ax,ax           ; clear OF
endif
qdiv_exit_relay:
        jmp     qdiv_exit

; calculate (DX=0):(CX=0):BX:uqNumerator.uq0 / (SI=0):(DI=1)

div_by_one:
        xchg    dx,bx                   ; DX = quotient.hi, BX = remainder.lo = 0
        mov     ax,uqNumerator.uq0      ; AX = quotient.lo
        jmp     qdiv_exit
not_that_special:

; handle the special case when the denominator lives in the high word

        or      di,di
        jnz     not_this_special_either

; calculate DX:CX:BX:uqNumerator.uq0 / SI:(DI=0)

        cmp     si,1                    ; separate out the trivial case
        jz      div_by_10000h
        mov     ax,cx
        div     si
        mov     cx,ax                   ; CX = quotient.hi
        mov     ax,bx
        div     si                      ; AX = quotient.lo
        xchg    cx,dx                   ; DX = quotient.hi, CX = remainder.hi
        mov     bx,uqNumerator.uq0      ; BX = remainder.lo
ifdef WIMP
        or      ax,ax           ; clear OF
endif
        jmp     qdiv_exit

; calculate (DX=0):CX:BX:uqNumerator.uq0 / (SI=1):(DI=0)

div_by_10000h:
        xchg    cx,dx                   ; DX = quotient.hi, CX = remainder.hi = 0
        mov     ax,bx                   ; AX = quotient.lo
        mov     bx,uqNumerator.uq0      ; BX = remainder.lo
        jmp     qdiv_exit
not_this_special_either:

; normalize the denominator

        mov     dx,si
        mov     ax,di
        call    ulNormalize             ; DX:AX = normalized denominator
        mov     cShift,cx               ; CX < 16
        mov     ulDenominator.lo,ax
        mov     ulDenominator.hi,dx


; shift the Numerator by the same amount

        jcxz    numerator_is_shifted
        mov     si,-1
        shl     si,cl
        not     si                      ; SI = mask
        mov     bx,uqNumerator.uq3
        shl     bx,cl
        mov     ax,uqNumerator.uq2
        rol     ax,cl
        mov     di,si
        and     di,ax
        or      bx,di
        mov     uqNumerator.uq3,bx
        xor     ax,di
        mov     bx,uqNumerator.uq1
        rol     bx,cl
        mov     di,si
        and     di,bx
        or      ax,di
        mov     uqNumerator.uq2,ax
        xor     bx,di
        mov     ax,uqNumerator.uq0
        rol     ax,cl
        mov     di,si
        and     di,ax
        or      bx,di
        mov     uqNumerator.uq1,bx
        xor     ax,di
        mov     uqNumerator.uq0,ax
numerator_is_shifted:

; set up registers for division

        mov     dx,uqNumerator.uq3
        mov     ax,uqNumerator.uq2
        mov     di,uqNumerator.uq1
        mov     cx,ulDenominator.hi
        mov     bx,ulDenominator.lo

; check for case when Denominator has only 16 bits

        or      bx,bx
        jnz     must_do_long_division
        div     cx
        mov     si,ax
        mov     ax,uqNumerator.uq1
        div     cx
        xchg    si,dx                   ; DX:AX = quotient
        mov     di,uqNumerator.uq0      ; SI:DI = remainder (shifted)
        jmp     short unshift_remainder
must_do_long_division:

; do the long division, part IZ@NL@%

        cmp     dx,cx                   ; we only know that DX:AX < CX:BX!
        jb      first_division_is_safe
        mov     ulQuotient.hi,0         ; i.e. 10000h, our guess is too big
        mov     si,ax
        sub     si,bx                   ; ... remainder is negative
        jmp     short first_adjuster
first_division_is_safe:
        div     cx
        mov     ulQuotient.hi,ax
        mov     si,dx
        mul     bx                      ; fix remainder for low order term
        sub     di,ax
        sbb     si,dx
        jnc     first_adjuster_done     ; The remainder is UNSIGNED!  We have
first_adjuster:                         ; to use the carry flag to keep track
        dec     ulQuotient.hi           ; of the sign.  The adjuster loop
        add     di,bx                   ; watches for a change to the carry
        adc     si,cx                   ; flag which would indicate a sign
        jnc     first_adjuster          ; change IF we had more bits to keep
first_adjuster_done:                    ; a sign in.

; do the long division, part II

        mov     dx,si
        mov     ax,di
        mov     di,uqNumerator.uq0
        cmp     dx,cx                   ; we only know that DX:AX < CX:BX!
        jb      second_division_is_safe
        mov     ulQuotient.lo,0         ; i.e. 10000h, our guess is too big
        mov     si,ax
        sub     si,bx                   ; ... remainder is negative
        jmp     short second_adjuster
second_division_is_safe:
        div     cx
        mov     ulQuotient.lo,ax
        mov     si,dx
        mul     bx                      ; fix remainder for low order term
        sub     di,ax
        sbb     si,dx
        jnc     second_adjuster_done
second_adjuster:
        dec     ulQuotient.lo
        add     di,bx
        adc     si,cx
        jnc     second_adjuster
second_adjuster_done:
        mov     ax,ulQuotient.lo
        mov     dx,ulQuotient.hi

; unshift the remainder in SI:DI

unshift_remainder:
        mov     cx,cShift
        jcxz    remainder_unshifted
        mov     bx,-1
        shr     bx,cl
        not     bx
        shr     di,cl
        ror     si,cl
        and     bx,si
        or      di,bx
        xor     si,bx
remainder_unshifted:
        mov     cx,si
        mov     bx,di
ifdef WIMP
        or      ax,ax           ; clear OF
endif
qdiv_exit:
cEnd

;---------------------------Public-Routine------------------------------;
; ulNormalize
;
; Normalizes a ULONG so that the highest order bit is 1.  Returns the
; number of shifts done.  Also returns ZF=1 if the ULONG was zero.
;
; Entry:
;       DX:AX = ULONG
; Returns:
;       DX:AX = normalized ULONG
;       CX    = shift count
;       ZF    = 1 if the ULONG is zero, 0 otherwise
; Registers Destroyed:
;       none
; History:
;  Mon 25-Jan-1988 22:07:03  -by-  Charles Whitmer [chuckwh]
; Wrote it.
;-----------------------------------------------------------------------;
        assumes ds,nothing
        assumes es,nothing

cProc   ulNormalize,<PUBLIC,NEAR>
cBegin

; shift by words

        xor     cx,cx
        or      dx,dx
        js      ulNormalize_exit
        jnz     top_word_ok
        xchg    ax,dx
        or      dx,dx
        jz      ulNormalize_exit        ; the zero exit
        mov     cl,16
        js      ulNormalize_exit
top_word_ok:

; shift by bytes

        or      dh,dh
        jnz     top_byte_ok
        xchg    dh,dl
        xchg    dl,ah
        xchg    ah,al
        add     cl,8
        or      dh,dh
        js      ulNormalize_exit
top_byte_ok:

; do the rest by bits

next_byte:
        inc     cx
        add     ax,ax
        adc     dx,dx
        jns     next_byte
ulNormalize_exit:
cEnd

sEnd

       end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\timer\local.asm ===
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;   LOCAL.ASM
;
;   Copyright (c) Microsoft Corporation 1989, 1990. All rights reserved.
;
;   This module contains the routines which interface with the
;   timer counter hardware itself.
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

?PLM=1  ; pascal call convention
?WIN=0  ; Windows prolog/epilog code
?DF=1
PMODE=1

.xlist
include cmacros.inc
include windows.inc
include mmddk.inc
include mmsystem.inc
include timer.inc
.list

        externFP    DriverCallback      ; in MMSYSTEM.DLL
	externFP    StackEnter		; in MMSYSTEM.DLL
	externFP    StackLeave		; in MMSYSTEM.DLL
        externFP    tddEndMinPeriod     ; timer.asm
        externA     __WinFlags          ; Somewhere in Kernel ?

        .286p

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;   Local data segment
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

externW     Events
externD     lpOLDISR
externB     PS2_MCA

sBegin Data

; Current Time
public CurTime
CurTime         dw  3 dup(0)    ; 48 bit current tick count.

public wProgTime
wProgTime       dw  0           ; Time currently programmed into timer chip
                                ; ...NOTE 0=64k !!!
public	wNextTime
wNextTime       dw  0           ; Time next programmed into timer chip

public nInt8Count
nInt8Count      dw  0           ; # times int8 handler re-entered

ifdef DEBUG
public          RModeIntCount, PModeIntCount
RModeIntCount   dd  0
PModeIntCount   dd  0
endif

public          IntCount
IntCount        dw  0
fBIOSCall       dw  0           ; Bios callback needed: TRUE or FALSE
fIntsOn         dw  0		; Interrupts have already been turned back on
ifdef	RMODE_INT
dRModeTicks	dd  ?		; Temporary storage for Rmode ticks
endif

public		dTickUpdate
dTickUpdate	dd	0	; Amount to actually update times with

sEnd Data

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;   Code segment
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


sBegin  Code286
    assumes cs,Code286
    assumes ds,data
    assumes es,nothing

CodeFixWinFlags     dw      __WinFlags

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;   Local (private) functions
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;   @doc INTERNAL
;
;   @asm tddRModeISR | Service routine for timer interrupts on IRQ 0.
;        when in REAL mode
;
;   @comm
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

ifdef	RMODE_INT
	assumes ds,nothing
        assumes es,nothing

externD RModeOldISR

public RModeDataSegment
RModeDataSegment        dw      0

public	tddRmodeISR
tddRmodeISR	proc far
	push	ds
	push	ax
	push	bx

	mov	ax,cs:[RModeDataSegment]
	mov	ds,ax
	assumes	ds,Data

	inc	[IntCount]

ifdef	DEBUG
	add	[RModeIntCount].lo,1
	adc	[RModeIntCount].hi,0
endif

	mov	ax,[wNextTime]	; Next time programmed into timer chip
	xchg	ax,[wProgTime]	; Update current time if it was reset

	xor	bx,bx
	dec	ax			; convert 0 -> 64k
	add	ax,1
	adc	bx,bx

	cmp	[nInt8Count],1		; Do not allow multiple re-entrancy
	jge	tddRmodeISRNormalExit

	cld
	push	di
	push	cx
	mov	di,DataOFFSET Events	; DS:DI --> first event
	mov	cx,MAXEVENTS

tddRmodeISRLoop:
	cmp	[di].evID,0		; is this event active?
	jz	tddRmodeISRNext
	cmp	[di].evDestroy,EVENT_DESTROYING
	je	tddRmodeISRNext
	test	[di].evFlags,TIME_BIOSEVENT
	jz	tddRmodeISRNext

	mov	dRModeTicks.lo,ax
	mov	dRModeTicks.hi,bx
	add	ax,[dTickUpdate.lo]
	adc	bx,[dTickUpdate.hi]
	cmp	[di].evTime.hi,bx
	jg	@f
	jl	tddRmodeISRChain
	cmp	[di].evTime.lo,ax
	jle	tddRmodeISRChain

@@:
	mov	ax,dRModeTicks.lo
	mov	bx,dRModeTicks.hi
	jmp	tddRmodeISRSearchExit

tddRmodeISRChain:
	pop	cx
	pop	di
	pop	bx
	pop	ax
	push	[RModeOldISR.hi]
	push	[RModeOldISR.lo]

	push	bp		; Restore DS from stack
	mov	bp,sp
	mov	ds,[bp+6]	; stack: [ds] [RModeOldISR.hi] [RModeOldISR.lo] [bp]
	assumes	ds,nothing
	pop	bp

	retf	2

tddRmodeISRNext:
	assumes	ds,Data
	add	di,SizeEvent	; Increment to next event slot
	loop	tddRmodeISRLoop

tddRmodeISRSearchExit:
	pop	cx
	pop	di

tddRmodeISRNormalExit:
	add	CurTime[0],ax
	adc	CurTime[2],bx
	adc	CurTime[4],0

	add	[dTickUpdate.lo],ax	; Update total needed to be added
	adc	[dTickUpdate.hi],bx

ifndef   NEC_98
	cmp	PS2_MCA,0	; Check for a PS/2 Micro Channel
	jz	@f
	in	al,PS2_SysCtrlPortB	; Get current System Control Port status
	or	al,PS2_LatchBit	; Set latch clear bit
	IO_Delay
	out	PS2_SysCtrlPortB,al	; Set new System Control Port status
@@:
endif   ; NEC_98
	mov	al,SPECIFIC_EOI	; specific EOI for IRQ 0 interrupt line
	out	PICDATA,al	; send End-Of-Interrupt to PIC DATA port

	pop	bx
	pop	ax
	pop	ds
	assumes	ds,nothing
	iret

tddRmodeISR	endp
endif

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;@doc	INTERNAL TIMER
;
;@asm	tddISR |
;       Service routine for timer interrupts on IRQ 0.
;
;	The ISR runs through all the event slots available, looking for
;	slots that are currently in used, and are not currently being
;	destroyed.  For each valid event found the callback time is updated.
;	After all times have been updated, the table is run through again,
;	calling all events that are due, and removing any due events that are
;	oneshots.  By updating all the events first, any new events that are
;	created during a callback will not be accidentally called too early.
;
;	Note that interrupts are not immediately restored, as this causes even
;	more problems with slow machines.  Also, the EOI is not sent to the
;	PIC, as the BIOS interrupt handler does a non-specific EOI, and this
;	would in turn EOI the last outstanding interrupt.
;
;	First there is a special check for the presence of a Micro Channel,
;	in which case, the System Control Port B must have bit 7 set in order
;	to have the IRQ 0 latch released.  This flag is aquired during Enable
;	time with an int 15h service C0h, requesting machine information, which
;	includes the presence of a Micro Channel.
;
;	The ISR then updates the tick count based on the count that was in
;	the timer's CE register.  While retrieving that previously programmed
;	time, it updates it to the new time that is contained in the timer's
;	CR register, in case these to items are different.  Note that the
;	maximum CE value of 0 is converted to 65536 through the decrement and
;	adding with carry.
;
;	Next, the ISR must determine if it is re-entering itself.  If this is
;	so, callbacks are not performed, and only a "missed ticks" count is
;	updated, indicating how many additional ticks should be subtracted
;	from each event due time.  This allows the ISR to finish immediately
;	if a timer interrupt is currently being serviced.  This is important
;	for both speed in general, and for slow machines that might generate
;	mouse events during timer events.  Note that only 6 bytes have been
;	pushed onto the stack for this case, and that everything but DS must
;	be removed before jumping to the exit label.  In this case, the
;	function can safely EOI the PIC, as the BIOS call will not be
;	performed, then the function will just return.
;
;	In the normal case, the ISR is not being re-entered, and timer event
;	due times are updated, and callbacks are made.  In this case, the
;	number of "missed ticks" is added to the CE tick count, bringing the
;	total up to the number of ticks passed since the last time the event
;	times were updated.  This global counter is then zeroed for the next
;	time re-entrancy occurs.  Note that interrupts are still turned off
;	at this point, and there is no need to fear bad things happening.
;
;	When checking for a valid event ID, the Destroy flag must be checked
;	in case the interrupt occured during a kill timer function call after
;	the Destroy flag was grabbed the second time, but before the actual ID
;	could be reset.
;
;	When a valid ID is found, its due time is updated with the CE value,
;	plus the amount of ticks that were missed because of re-entrancy, if
;	any.
;
;	After updating times, the event list is checked again, this time to
;	perform any of the callbacks that are due.  To make things easy, a
;	global flag is used to determine if interrupts have been turned back
;	on, and thus stacks have been switched.
;
;	If a valid event is found that is also due, meaning that the callback
;	time is <= 0, the fIntsOn flag is checked to determine if the stack
;	has already been switched and interrupts are already on.  If not, then
;	just that occurs.  The <f>tddEvent<d> function is then called to
;	service the event.
;
;	After all events have been called, interrupts are turned back off if
;	needed, and the original stack restored.  If no callback actually
;	occurred, then the stack is never switched.  The function then either
;	exits as a normal ISR would, or it chains to the BIOS ISR.  This is
;	done if the BIOS event was up for being called, and the fBIOSCall flag
;	was set because of that.  Since the flag cannot be set when this ISR
;	is being pre-entered, as callbacks are not performed, there is no need
;	to do a test and set proceedure on the fBIOSCall flag, just a simple
;	compare will do.  Note though that the nInt8Count re-entrancy count is
;	not decremented until after interrupts are turned off.
;
;	Interrupts are also cleared to ensure that the BIOS ISR is not
;	re-entered itself, since there is no re-entrancy control after this
;	function chains to BIOS.  Notice that DS was the first register pushed
;	onto the stack, and therefore the last item to get rid of, which is
;	done with the "retf 2".  DS itself is restored from stack before
;	chaining so that lpOLDISR (BIOS) can be accessed and pushed onto stack
;	as the return address.
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	assumes ds,nothing
	assumes es,nothing

public	tddISR
tddISR	proc far

	push	ds		; This is pushed first for the case of BIOS

;----------------------------------------------------------------------------
;If we are on a 386 save all registers.
;----------------------------------------------------------------------------
        test    cs:[CodeFixWinFlags],WF_WIN286
        jnz     @F
.386
        pushad
        push    fs
        push    gs
.286p
@@:

	push	ax
	push	bx

	mov	ax,DGROUP	; set up local DS
	mov	ds,ax
	assumes	ds,Data

ifndef  NEC_98
	cmp	PS2_MCA,0	; Check for a PS/2 Micro Channel
	jz	@f
	in	al,PS2_SysCtrlPortB	; Get current System Control Port status
	or	al,PS2_LatchBit	; Set latch clear bit
	IO_Delay
	out	PS2_SysCtrlPortB,al	; Set new System Control Port status

@@:
endif   ; NEC_98
	inc	[IntCount]	; Ever-increasing Int counter
	inc	[nInt8Count]	; Number of times int 8 re-entered

	mov	ax,[wNextTime]	; Next time programmed into timer chip
	xchg	ax,[wProgTime]	; Update current time if it was reset

	xor	bx,bx
	dec	ax		; convert 0 -> 64k
	add	ax,1		; Force carry flag
	adc	bx,bx		; Set bx:ax == current tick count

	add	CurTime[0],ax	; Add tick count to total ticks
	adc	CurTime[2],bx
	adc	CurTime[4],0

ifdef	DEBUG
;	cmp	[nInt8Count],1		; Re-entrancy counter
;	je	@f			
;	add	[RModeIntCount].lo,1
;	adc	[RModeIntCount].hi,0
;@@:
	add	[PModeIntCount].lo,1	; For debug Pmode count message
	adc	[PModeIntCount].hi,0
endif
	cmp	[nInt8Count],1		; Do not allow multiple re-entrancy
	je	tddISRCheckCallbacks
	add	[dTickUpdate.lo],ax	; Update total needed to be added
	adc	[dTickUpdate.hi],bx
	pop	bx
	jmp	tddISREOIExit		; EOI before exiting

tddISRCheckCallbacks:
	add	ax,[dTickUpdate.lo]	; Add any extra ticks from re-entrancy
	adc	bx,[dTickUpdate.hi]
	push	cx
	xor	cx,cx
	mov	[dTickUpdate.lo],cx	; Reset tick re-entrant counter
	mov	[dTickUpdate.hi],cx

	cld			; never assume the value of this in an ISR!
	push	di
	mov	di,DataOFFSET Events	; DS:DI --> first event
	mov	cx,MAXEVENTS

tddISRUpdateTimeLoop:
	cmp	[di].evID,0		; is this event active?
	jz	tddISRUpdateTimeNext
	sub	[di].evTime.lo,ax	; Subtract the amount of ticks gone by
	sbb	[di].evTime.hi,bx

tddISRUpdateTimeNext:
	add	di,SizeEvent	; Increment to next event slot
	loop	tddISRUpdateTimeLoop

	mov	fIntsOn,0		; Initialize interrupts set flag
	mov	di,DataOFFSET Events	; DS:DI --> first event
	mov	cx,MAXEVENTS

tddISRCallLoop:
	cmp	[di].evID,0		; is this event active?
	jz	tddISRNextEvent
	cmp	[di].evDestroy,EVENT_DESTROYING
	je	tddISRNextEvent
	cmp	[di].evTime.hi,0	; Is it time to call the event?
	jg	tddISRNextEvent		; evTime <= 0
	jl	tddISREvent
	cmp	[di].evTime.lo,0
	jg	tddISRNextEvent

tddISREvent:
	test	[di].evFlags,TIME_BIOSEVENT
	jnz	tddISRCallEvent		; No need to switch, as no call will be made.
	cmp	fIntsOn,0	; Have interrupts been turned on already?
	jnz	tddISRCallEvent
	inc	fIntsOn		; fIntsOn == TRUE
	cCall	StackEnter	; Switch to a new stack
	sti			; Can be re-entered now with new stack

;	A timer callback needs to be called, but first before calling it,
;	we need to check to determine if the original timer interrupt function
;	is to be called during this interrupt.  The reason is that a timer
;	callback could take a long time, and the PIC should be EOI'ed as soon
;	as possible.
;	It is not possible to just do a specific EOI, as the BIOS timer
;	interrupt performs a non-specific EOI, which would turn back on some
;	other random interrupt.  So if the the BIOS needs to be called, it
;	is done now, else the EOI is performed now.  This assumes that the
;	BIOS callback is the first item in the list of callbacks.
;	If the BIOS callback occurs now, then the fBIOSCall flag is reset,
;	as there is no need to chain to it at the end of this interrupt.  So
;	if no other callbacks are to be performed, the BIOS interrupt is
;	chained to, else it is just called before the first timer callback
;	is performed.

	cmp	[fBIOSCall],0	; Does BIOS need to be called?
	je	tddISREOI
	mov	[fBIOSCall],0	; No need to call BIOS again at the end
	pushf			; Simulate an interrupt call
	call	lpOLDISR	; Call original timer interrupt
	jmp	tddISRCallEvent	; Do actual timer callback

;	No BIOS interrupt call is to be performed, so do EOI.
tddISREOI:
	mov	al,SPECIFIC_EOI	; specific EOI for IRQ 0 interrupt line
	out	PICDATA,al	; send End-Of-Interrupt to PIC DATA port
tddISRCallEvent:
	call	tddEvent		; handle the event

tddISRNextEvent:
	add	di,SizeEvent	; Increment to next event slot
	loop	tddISRCallLoop

	cmp	fIntsOn,0	; Where interrupts turned back on?
	jz	@f
	cli			; Interrupts were turned on, so remove them
	cCall	StackLeave	; Switch back to old stack

@@:
	pop	di		; Restore everything except DS
	pop	cx
	pop	bx
	cmp	[fBIOSCall],0	; Does BIOS need to be called?
	je	tddISREOIExit
	pop	ax
	mov	[fBIOSCall],0

;----------------------------------------------------------------------------
;If we are on a 386 restore all registers.
;----------------------------------------------------------------------------
        test    cs:[CodeFixWinFlags],WF_WIN286
        jnz     @F
.386
        pop     gs
        pop     fs
        popad
.286p
@@:
	push	[lpOLDISR.hi]	; Push return address
	push	[lpOLDISR.lo]
	dec	[nInt8Count]	; exiting, decrement entry count

	push	bp		; Restore DS from stack
	mov	bp,sp
	mov	ds,[bp+6]	; stack: [ds] [lpOLDISR.hi] [lpOLDISR.lo] [bp]
	assumes	ds,nothing
	pop	bp

	retf	2		; Chain to BIOS ISR, removing DS from stack

tddISREOIExit:
	mov	al,SPECIFIC_EOI	; specific EOI for IRQ 0 interrupt line
	out	PICDATA,al	; send End-Of-Interrupt to PIC DATA port
	pop	ax
	assumes ds,Data
	dec	[nInt8Count]	; exiting, decrement entry count

;----------------------------------------------------------------------------
;If we are on a 386 restore all registers.
;----------------------------------------------------------------------------
        test    cs:[CodeFixWinFlags],WF_WIN286
        jnz     @F
.386
        pop     gs
        pop     fs
        popad
.286p
@@:
	pop	ds
	assumes ds,nothing

	iret

tddISR	endp

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;@doc	INTERNAL TIMER
;
;@asm	tddEvent |
;	Handle an event when it is due.
;
;	For a valid event, the ID is saved in case the slot needs to be zeroed
;	and the type of event is checked.  If this is a oneshot event
;	timer, the entry is freed.  Note that at this point, as in the kill
;	event function, the Destroy flag must be checked to determine if the
;	slot is currently being checked.  If so, the EVENT_DESTROYED flag must
;	be set instead of resetting the flag so that the function that was
;	interrupted can determine that the entry was killed while being
;	checked.
;
;	After saving the event handle, the function checks to see if the event
;	is a One Shot, in which case it is destroyed, and the event's
;	resolution is removed from resolution the table.
;
;	If on the other hand the event is a periodic one, the next calling
;	time is updated with the delay period.  Note that if the event is far
;	behind, or the last minimum resolution was very large, many delay
;	periods are added to the next call time.
;
;	If this is a BIOS event, then the fBIOSCall flag is set so that the
;	ISR chains to the old BIOS ISR instead of returning normally.  If this
;	is a normal event, the parameters are pushed, and the driver callback
;	function is called using the DCB_FUNCTION flag.
;
;	After returning from the callback, the return value from
;	<f>DriverCallback<d> is checked to determine if the callback succeeded.
;	If it did not, then the timer event needs to be removed.  The timer
;	event however may have been a oneshot, in which case it was already
;	been removed before the call was made, and the EVENT_DESTROYED flag
;	may have been set, so it is just left alone.  If the event is still
;	present however, it is destroyed after doing the checking to see if
;	this interrupt came while the event was being destroyed.  Note that
;	there is no check to see if the event IDs are the same before destroying
;	the event.  This is because if the callback failed, then the timer
;	structure cannot have changed, and no check is needed.
;
;@parm	DS:DI |
;	Points to the event slot.
;
;@comm	Uses AX,BX.
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	assumes	es,nothing
	assumes	ds,Data

cProc	tddEvent, <NEAR, PUBLIC>, <>
cBegin
	push	dx

	mov	dx,[di].evID
	test	[di].evFlags,TIME_PERIODIC
	jnz	tddEventPeriodic

tddEventKillOneShot:
	xor	ax,ax
	mov	[di].evID,ax			; Invalidate slot
	cmp	[di].evDestroy,EVENT_CHECKING	; Did this interrupt a Kill?
	jne	@f
	mov	al,EVENT_DESTROYED		; Let the interrupted Kill know
@@:
	mov	[di].evDestroy,al
	mov	[di].evCreate,ah		; pEvent->evCreate = FALSE
	push	dx
	push	cx
	cCall	tddEndMinPeriod,<[di].evResolution>
	pop	cx
	pop	dx
	jmp	tddEventCallback

tddEventPeriodic:
	mov	ax,[di].evDelay.lo
	mov	bx,[di].evDelay.hi
@@:
	add	[di].evTime.lo,ax
	adc	[di].evTime.hi,bx
	jl	@b

tddEventCallback:
	test	[di].evFlags,TIME_BIOSEVENT
	jz	tddEventDriverCallback
	inc	[fBIOSCall]
	jmp	tddEventExit

tddEventDriverCallback:
	push	cx
	push	es
	;
	;  call DriverCallback() in MMSYSTEM
	;
	push	[di].evCallback.hi	; execute callback function
	push	[di].evCallback.lo
	push	DCB_FUNCTION or DCB_NOSWITCH; callback flags
	push	dx			; idTimer
	xor	dx,dx
	push	dx			; msg = 0
	push	[di].evUser.hi		; dwUser
	push	[di].evUser.lo
	push	dx			; dw1 = 0
	push	dx
	push	dx			; dw2 = 0
	push	dx
	call	DriverCallback		; execute callback function
	pop	es
	or	ax,ax			; Check for a successful return
	jnz	tddEventSucceed		; If callback succeeded, just continue
	cmp	[di].evID,ax		; If the timer was already destroyed,
	jz	tddEventSucceed		; just leave
	mov	[di].evID,ax		; Else destroy the event
	cmp	[di].evDestroy,EVENT_CHECKING	; Did this interrupt a Kill?
	jne	@f
	mov	al,EVENT_DESTROYED	; Let the interrupted Kill know
@@:
	mov	[di].evDestroy,al
	mov	[di].evCreate,ah	; pEvent->evCreate = FALSE
	cCall	tddEndMinPeriod,<[di].evResolution>

tddEventSucceed:
	pop	cx

tddEventExit:
	pop	dx
cEnd

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;   @doc INTERNAL
;
;   @asm GetCounterElement | Low level routine which loads the tick count
;	from the timer counter device, and returns the number of ticks that
;	have already passed.
;
;   @rdesc Returns the tick count in AX.
;
;   @comm All registers preserved.
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

public	GetCounterElement
GetCounterElement	proc near

	; Get rid of any latched count if this is called during interrupt time
	cmp	[nInt8Count],1
	jb	@f
	in	al,TMR_CNTR_0
	IO_Delay
	in	al,TMR_CNTR_0

@@:
	; read counter first time
	xor	ax,ax			; LATCH counter 0 command
	out	TMR_CTRL_REG,al		; send command

	in	al,TMR_CNTR_0		; read low byte
	mov	ah,al
	in	al,TMR_CNTR_0		; read high byte
	xchg	al,ah
	sub	ax,wProgTime		; Convert to number of ticks already past
	neg	ax

	ret

GetCounterElement	endp

sEnd

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\timer\usa\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH)
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\timer\startend.asm ===
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;   STARTEND.ASM
;
;   Copyright (c) Microsoft Corporation 1989, 1990. All rights reserved.
;
;   This module contains the routines which initialize, and clean
;   up the driver after Libentry/WEP/Enable/Diable called by windows.
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

?PLM=1  ; pascal call convention
?WIN=0  ; Windows prolog/epilog code
?DF=1

	PMODE=1
	.xlist
	include  cmacros.inc
        include  int31.inc
	include  windows.inc
        include  mmddk.inc
	include  mmsystem.inc
	include  timer.inc
        .list

        externA     __WinFlags

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;   Local data segment
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


sBegin DATA

	; ISR support

	public	lpOLDISR
	lpOldISR    dd	?

ifdef RMODE_INT
        public  RModeOldISR
        RModeOldISR   dd  0

        public  RModeCodeSegment
        RModeCodeSegment dw ?

endif   ;RMODE_INT

	externW     Events
	externW     wNextTime
ifdef   NEC_98
        externB     bClockFlag                  ; 5Mhz = 0 ; 8Mhz = other
endif   ; NEC_98

sEnd DATA

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;   Code segment
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

        externFP    tddISR                      ; in local.asm
        externFP    tddSetInterruptPeriodFar    ; in timer.asm

ifdef   RMODE_INT
        externW     RmodeDataSegment            ; in local.asm
        externFP    tddRModeISR                 ; in local.asm
endif
        externFP    GetSelectorBase             ; kernel
        externFP    AllocCStoDSAlias            ; kernel
        externFP    FreeSelector                ; kernel

sBegin  CodeInit
        assumes cs,CodeInit
        assumes ds,Data
        assumes es,nothing

;----------------------------Private-Routine----------------------------;
; SegmentFromSelector
;
;   Converts a selector to a segment...note that this routine assumes
;   the memory pointed to by the selector is below the 1Meg line!
;
; Params:
;   AX = selector to convert to segment
;
; Returns:
;   AX = segment of selector given
;
; Error Returns:
;   None
;
; Registers Destroyed:
;   none
;
;-----------------------------------------------------------------------;

assumes ds,Data
assumes es,nothing

SegmentFromSelector proc near

    cCall   GetSelectorBase,<ax>        ;DX:AX = base of selector
rept 4
    shr     dx,1
    rcr     ax,1
endm
    ;AX now points to *segment* (iff selector is based below 1Mb)

    ret

SegmentFromSelector endp

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;   @doc INTERNAL
;
;   @api WORD | Enable | This function enables the driver.  It
;       will hook interrupts and validate the hardware.
;
;   @rdesc Returns 1 if successfull, and 0 otherwise.
;
;   @comm This function is automatically invoked when the library is
;       first loaded. It is included so that win386 could call it
;       when it switches VMs.
;
;   @xref Disable
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

cProc Enable286 <FAR, PUBLIC> <si, di>

cBegin
	; make sure clock interrupts are disabled until after
	; service routine has been initialized!!
	AssertSLI
	cli

	; get the currently owned timer interrupt vector

	; get interrupt vector, and specify timer interrupt number
;       mov	ax,03500H + TIMERINTERRUPT
;       push	es
;       int	21h 			; get the current vector in ES:BX
;       mov	lpOldISR.Sel,es
;       mov	lpOldISR.Off,bx		; save the old vector
;       pop	es
;
;       ; set vector to our isr
;
;       ; set interrupt vector function, and specify the timer interrupt number
;       mov	ax,02500h + TIMERINTERRUPT
;       push	ds
;       mov     dx,seg tddISR
;       mov	ds,dx
;       assumes	ds,nothing
;       mov     dx,offset tddISR
;       int	21h			; set the new vector
;       pop	ds
;       assumes	ds,DATA
;
;       mov	ax,[wNextTime]
;       not	ax
;       mov	[wNextTime],ax		; force set of period
;       call    tddSetInterruptPeriodFar

ifdef	RMODE_INT
	;
	; if running under DOSX set the RMODE interrupt too
	;
	mov	ax,__WinFlags
	test	ax,WF_PMODE
	jz	enable_no_dosx

	mov	ax,seg tddRModeISR
	call	SegmentFromSelector

	or	dx,dx		; ACK! above 1Mb
	jnz	enable_no_dosx

	mov	[RModeCodeSegment],ax	; save the segment of the code segment

	mov	ax,ds			; get SEGMENT of our data segment
	call	SegmentFromSelector
	push	ax			; save on stack

	mov	ax,seg tddRModeISR	; write data SEGMENT into _INTERRUPT
	cCall	AllocCStoDSAlias,<ax>	; code segment -- requires a data alias
	mov	es,ax
	pop	ax
	mov	es:[RModeDataSegment],ax
	cCall	FreeSelector,<es>	; don't need CS alias any longer

	mov	ax,Get_RM_IntVector	; get the real mode IRQ0 vector
	mov	bl,DOSX_IRQ + TIMERINTERRUPT
	int	31h			; DOSX get real mode vector in CX:DX

	mov	RModeOldISR.lo,dx	; save old ISR
	mov	RModeOldISR.hi,cx

	mov	cx,RModeCodeSegment	; CX:DX --> real mode ISR
	mov	dx,offset tddRModeISR

	mov	ax,Set_RM_IntVector	; DOSX Set Vector Function
	int	31h			; Set the DOS vector real mode

enable_no_dosx:
endif
	sti

	mov	ax,1
cEnd

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;   @doc INTERNAL
;
;   @api WORD | Disable | This function disables the driver.
;	It disables the hardware, unhooks interrupts and removes
;	all time events from the queue.
;
;   @rdesc Returns 1 if successfull, and 0 otherwise.
;
;   @comm This function is called automatically when Windows unloads
;       the library and invokes the WEP() function.  It is included
;       here so that WIN386 can use it when switching VMs.
;
;   @xref Enable
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


cProc Disable286 <FAR, PUBLIC> <si, di>

    ; note that all this is in the reverse order to Enable

cBegin
    AssertSLI
    cli
ifdef   NEC_98
    setmask TIMERMASK
    mov     al,36h
    out     timodeset,al                ; Timer mode set
    delay   8253,O-O
    mov     ax,0f000h                   ; count(25msec * 2457.6)
    cmp     byte ptr bClockFlag,00h     ; Q : clock 5 MHz ?
    jz      @f                          ; 5MHz,10MHz,12MHz,20MHz,25MHz set
    mov     ax,0c300h                   ; 8MHz,16MHz set
@@:
    out     ticntset,al
    delay   8253,O-O
    xchg    ah,al
    out     ticntset,al
    unmask  TIMERMASK
else    ; NEC_98
    ; set timer back to 55ms BIOS service
    xor     cx,cx		; 65536 ticks per period

    mov     al,TMR_MODE3_RW	; Read/Write counter 0 mode 3 (two bytes)
    out     TMR_CTRL_REG,al

    mov     al,cl
    out     TMR_CNTR_0,al	; write low byte

    mov     al,ch
    out     TMR_CNTR_0,al       ; write high byte
endif   ; NEC_98

ifdef RMODE_INT
    ;
    ; check for a REAL mode int handler and un-hook it.
    ;
    mov     dx,RModeOldISR.lo
    mov     cx,RModeOldISR.hi
    jcxz    disable_no_dosx

    mov     bl,DOSX_IRQ + TIMERINTERRUPT
    mov     ax,Set_RM_IntVector     ;DOSX Set Vector Function
    int     31h                     ;Set the DOS vector real mode

disable_no_dosx:
endif

    ; restore the old interrupt vector

    mov     ax,02500h + TIMERINTERRUPT
    ; set interrupt vector function, and specify the timer interrupt number

    push    ds
    lds     dx,lpOldISR
    assumes ds,nothing
    int     21h 		; reset the old vector
    pop ds
    assumes ds,DATA

    sti
    mov     ax,1
cEnd

sEnd

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\timer\libinit.asm ===
;
;  LibInit.asm	library stub to do local init for a Dynamic linked library
;
;  NOTE!!!! link this MODULE first or you will be sorry!!!!
;
?PLM=1  ; pascal call convention
?WIN=0  ; Windows prolog/epilog code
?DF=1
PMODE=1

.286
.xlist
include cmacros.inc
include windows.inc
include sysinfo.inc
include mmddk.inc
include mmsystem.inc
include timer.inc
;include vtdapi.inc
.list

.list

sBegin  Data
;
; Stuff needed to avoid the C runtime coming in
;
; also known as "MAGIC THAT SAVED ME" - Glenn Steffler 2/7/90
;
; Do not remove!!
;
            DD  0               ; So null pointers get 0
maxRsrvPtrs = 5
            DW  maxRsrvPtrs
usedRsrvPtrs = 0
labelDP     <PUBLIC,rsrvptrs>

DefRsrvPtr  MACRO   name
globalW     name,0
usedRsrvPtrs = usedRsrvPtrs + 1
ENDM

DefRsrvPtr  pLocalHeap          ; Local heap pointer
DefRsrvPtr  pAtomTable          ; Atom table pointer
DefRsrvPtr  pStackTop           ; top of stack
DefRsrvPtr  pStackMin           ; minimum value of SP
DefRsrvPtr  pStackBot           ; bottom of stack

if maxRsrvPtrs-usedRsrvPtrs
            DW maxRsrvPtrs-usedRsrvPtrs DUP (0)
endif

public  __acrtused
	__acrtused = 1

sEnd    Data

;
;
; END of nasty stuff...
;

externA     WinFlags
externFP    LocalInit
externFP    Disable286
externFP    Enable286
externW     wMaxResolution
externW     wMinPeriod

; here lies the global data

sBegin  Data

public wEnabled
wEnabled	dw  0		; enable = 1 ;disable = 0

public PS2_MCA
ifdef   NEC_98
PS2_MCA         db      0       ; Micro Channel Flag
public bClockFlag               ; save machine clock
bClockFlag      db      0       ; 5Mhz = 0 ; 8Mhz = other
else    ; NEC_98
PS2_MCA         db      ?       ; Micro Channel Flag
endif   ; NEC_98

sEnd    Data

    assumes es,nothing

sBegin  CodeInit
    assumes cs,CodeInit
    assumes ds,Data

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;   Library unload function
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Disable routine is same as WEP

cProc   WEP,<FAR,PUBLIC>,<>
;   parmW   silly_param
cBegin nogen

    errn$   Disable

cEnd nogen

cProc   Disable,<FAR,PUBLIC>,<>
;   parmW   silly_param
cBegin nogen
    push    ds
    mov     ax,DGROUP           ; set up DS==DGROUP for exported funcs
    mov     ds,ax
    assumes ds,Data

    xor     ax,ax		; return value = no error

    cmp     wEnabled,ax 	; Q: enabled ?
    jz	    dis_done		; N: exit

    mov     wEnabled,ax 	; disabled now

    mov     ax,WinFlags
    test    ax,WF_WIN386
    jnz     dis_386

    ; running under win286
dis_286:
    call    Disable286
    jmp     dis_done

    ; running under win386
dis_386:
    call    Disable286

dis_done:
    pop     ds
    ret     2

cEnd nogen

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;   Library Enable function
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

cProc	Enable,<FAR,PUBLIC>,<>
;   parmW   silly_param
cBegin nogen
    mov     ax,wEnabled
    or      ax,ax               ; Q: already enabled ?
    jnz     enable_done 	; Y: exit

    inc     wEnabled		; mark as being enabled

ifdef   NEC_98
;
; Get system clock
;
    mov     ax,0002h
    mov     bx,0040h    ; get segment addres
                        ; make descriptor(real mode segment)
                        ; return the segment descriptor
                        ; in the case of exist the appointed segment descriptor already
                        ; (not make sure repeatedly)
    int     31h
    jc      error_exit  ; in the case of failed  ->jmp

    push    es
    mov     es,ax
    mov     al,byte ptr es:[101h]           ; get system info
    and     al,80h
    mov     byte ptr bClockFlag,al          ; save clock
    pop     es
endif   ; NEC_98

    mov     ax,WinFlags
    test    ax,WF_WIN386
    jnz     enable_386

    ; running under win286
enable_286:
    call    Enable286
    jmp     enable_done

    ; running under win386
enable_386:
    call    Enable286

enable_done:
    ret     2

ifdef   NEC_98
error_exit:
    dec     wEnabled       ; mark as being enabled
    xor     ax,ax
    ret 2
endif   ; NEC_98

cEnd nogen

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;       Library entry point
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

public LibInit
LibInit proc far

    ; CX    = size of heap
    ; DI    = module handle
    ; DS    = automatic data segment
    ; ES:SI = address of command line (not used)

    jcxz    lib_heapok	    ; heap size zero? jump over unneeded LocalInit call

    cCall   LocalInit,<ds,ax,cx>    ; dataseg, 0, heapsize
    or	    ax,ax
    jnz     lib_heapok	    ; if heap set continue on

lib_error:
    xor     ax,ax
    ret 		    ; return FALSE (ax = 0) -- couldn't init

lib_heapok:
    mov     ax,WinFlags
    test    ax,WF_WIN386
    jnz     lib_386

    ; running under win286
lib_286:
    call    Lib286Init
    jmp     lib_realdone    ; win 286 will enable timer on first event request

    ; running under win386
lib_386:
    call    Lib286Init

lib_realdone:
    ret

LibInit endp

sEnd

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;   Win 386 timer VTD code for initialization, and removal
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

        externFP        GetVersion          ; in KERNEL
        externFP        MessageBox          ; in USER
        externFP        LoadString          ; in USER

sBegin  CodeInit
assumes cs,CodeInit
assumes ds,Data

;externNP    VTDAPI_GetEntryPt

; Assumes DI contains module handle
cProc WarningMessage <NEAR,PASCAL> <>
    LocalV aszErrorTitle, 32
    LocalV aszErrorMsg, 256
cBegin
    lea     ax, WORD PTR aszErrorTitle
    cCall   LoadString, <di, IDS_ERRORTITLE, ss, ax, 32>
    lea     ax, WORD PTR aszErrorMsg
    cCall   LoadString, <di, IDS_ERRORTEXT, ss, ax, 256>
    lea     ax, WORD PTR aszErrorTitle
    lea     bx, WORD PTR aszErrorMsg
    cCall   MessageBox, <NULL, ss, bx, ss, ax, MB_SYSTEMMODAL+MB_OK+MB_ICONHAND>
cEnd

if 0
Lib386Init proc near

    call    VTDAPI_GetEntryPt       ; this will return 0 if the VxD is not loaded

    or      ax,ax
    jnz     Lib386InitOk

ifndef  NEC_98
    DOUT    <TIMER: *** unable to find vtdapi.386 ***>
endif   ; NEC_98

    ;
    ;   warn the USER that we can't find our VxD, under windows 3.0
    ;   we can't bring up a message box, so only do this in win 3.1
    ;

    cCall   GetVersion
    xchg    al,ah
    cmp     ax,030Ah
    jb      Lib386InitFail

    cCall   WarningMessage,<>

Lib386InitFail:
    xor     ax,ax

Lib386InitOk:

    ret

Lib386Init endp
endif

Disable386 proc near

    errn$   Enable386               ; fall through

Disable386 endp

Enable386 proc near

    mov     ax,1		    ; nothing to do
    ret

Enable386 endp

sEnd	Code386

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;   Win 286 timer drv code for initialization, and removal
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

    externW     Events
    externFP    tddISR                  ; in local.asm

    externFP    GlobalWire              ; in KERNEL
    externFP    GlobalPageLock          ; in KERNEL

sBegin  CodeInit
    assumes cs,CodeInit
    assumes ds,Data

Lib286Init proc near
    ; get the system configuration

    ;
    ;   the FIXED_286 segment is not loaded, load it and pagelock it.
    ;
    mov     dx,seg tddISR               ; get the 286 code segment
    mov     es,dx
    mov     ax,es:[0]                   ; load it!
    cCall   GlobalWire, <dx>            ; get it low in memory
    cCall   GlobalPageLock, <dx>        ; and nail it down!

ifndef  NEC_98
    mov     PS2_MCA,0			; Initialize PS2_MCA = FALSE
    stc					; Set this in case BIOS doesn't
    mov     ah,GetSystemConfig
    int     15h
    jc      Lib286Init_NoMicroChannel	; Successful call?
    or      ah,ah			; Valid return?
    jnz     Lib286Init_NoMicroChannel
    test    es:[bx.SD_feature1],SF1_MicroChnPresent
    jz      Lib286Init_NoMicroChannel
    inc     PS2_MCA			; PS2_MCA = TRUE
endif   ; NEC_98
Lib286Init_NoMicroChannel:

    push    di

    push    ds
    pop     es
    mov     di,DataOFFSET Events	; ES:DI --> Events
    xor     ax,ax
    mov     cx,(MAXEVENTS * SizeEvent)/2
    rep     stosw			; zero out event structures.

    ; set up one event as the standard call-back routine for the
    ; BIOS timer service
    ;
ifdef   NEC_98
    mov     ax,0002h
    mov     bx,0040h
    int     31h
    jc      error_init
    push    es
    mov     es,ax
    test    byte ptr es:[101h],80h
    pop     es
    mov     cx,0f000h
    jz      @f
    mov     cx,0c300h
@@:
    xor     bx,bx
else    ; NEC_98
    xor     bx,bx			; BX:CX = 64k
    xor     cx,cx
    inc     bx
endif   ; NEC_98

    mov     di,DataOFFSET Events	; DS:DI --> Events

    mov     [di].evTime.lo,cx		; Program next at ~= 55ms
    mov     [di].evTime.hi,bx		; standard 18.2 times per second event
    mov     [di].evDelay.lo,cx		; First event will be set off
    mov     [di].evDelay.hi,bx		; at 55ms (65536 ticks)
    mov     [di].evResolution,TDD_MINRESOLUTION	; Allow 55ms either way
    mov     [di].evFlags,TIME_BIOSEVENT+TIME_PERIODIC

    mov     ax,WinFlags
    test    ax,WF_CPU286
    jz      @f
    mov     wMaxResolution,TDD_MAX286RESOLUTION
    mov	    wMinPeriod,TDD_MIN286PERIOD
@@:
ifdef   NEC_98
    mov     ax,0001h
else    ; NEC_98
    mov     ax,bx                       ; Return TRUE
endif   ; NEC_98
    mov     [di].evID,ax		; enable event

    pop     di
    ret

ifdef   NEC_98
error_init:
    xor     ax,ax
    pop     di
    ret
endif   ; NEC_98

Lib286Init endp

sEnd

    end LibInit
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\timer\timer.asm ===
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;	TIMER.ASM
;
;	Copyright (c) Microsoft Corporation 1991. All rights reserved.
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


?PLM=1	; pascal call convention
?WIN=0	; Windows prolog/epilog code
?DF=1
PMODE=1

.xlist
include cmacros.inc
include windows.inc
include mmddk.inc
include mmsystem.inc
include timer.inc
.list

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;   External functions
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

externNP	GetCounterElement

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;   Local data segment
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


sBegin DATA

externW	CurTime
externW	nInt8Count
externW	wProgTime
externW	wNextTime
externW	IntCount
externD	dTickUpdate
ifdef   NEC_98
        externB bClockFlag
endif   ; NEC_98

public	Events,wNextID

;	This structure is used in keeping track of all the current events,
;	including any BIOS event.
;
Events	EventStruct MAXEVENTS DUP (<>)

;	This value is used as an ever incrementing counter that is OR'ed into
;	handles returned from <f>tddSetTimerEvent<d>.  This is so that events
;	can be uniquely identified in <f>tddKillTimerEvent<d>.
;
wNextID         dw	0

;
;	The following is a table of timer resolution byte counters.  Each entry
;	N represents an interest in having the timer resolution set to N+1 MS.
;	Thus there are TDD_MAX386RESOLUTION to TDD_MINRESOLUTION entries to
;	represent 1..55 MS.  Each time <f>tddBeginMinPeriod<d> is called with
;	a timer period, the appropriate entry is incremented, and each time
;	<f>tddEndMinPeriod<d> is called with a timer period, that entry is
;	decremented.  Presumably there is a one to one match on the Begin and
;	End minimum period calls.
;
;	This is of course all a workaround for the fact that the timer chip
;	cannot be immediately reprogrammed the way it is wired in PCs in the
;	mode in which it needs to be run, thus a separate resolution table
;	must be kept in order to allow applications to set up a minimum
;	resolution before actually setting any events.
;
tddIntPeriodTable	db	TDD_MINRESOLUTION dup (0)

public	wMaxResolution,wMinPeriod
wMaxResolution	dw	TDD_MAX386RESOLUTION
wMinPeriod	dw	TDD_MIN386PERIOD

sEnd DATA

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;   Code segment
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


sBegin	Code286
	assumes cs,Code286
	assumes ds,data
	assumes es,nothing

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;       Public exported functions
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;@doc	INTERNAL TIMER
;
;@api	DWORD | tddBeginMinPeriod |
;	Increments sets the specified resolution in the table of period
;	resolutions.  This optionally programming the timer for a new
;	higher resolution if the parameter passed is a new minimum.
;
;@parm	WORD | wPeriod |
;	Contains a resolution period from wMaxResolution through 55
;	milliseconds.
;
;@rdesc	Returns 0 for success, else TIMERR_NOCANDO if the resolution period
;	passed was out of range.
;
;@uses	ax,bx,dx.
;
;@xref	tddEndMinPeriod,tddSetInterruptPeriod.
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	assumes es,nothing
	assumes ds,Data

cProc	tddBeginMinPeriod <PUBLIC,FAR> <>
	parmW	wPeriod
cBegin
	mov	ax,TIMERR_NOCANDO	; Initialize return to error return

	mov	bx,wPeriod
	cmp	bx,[wMaxResolution]
	jb	tddBeginMinPeriodExit	; Return TIMERR_NOCANDO
	cmp	bx,TDD_MINRESOLUTION
	ja	tddBeginMinPeriodExit	; Return TIMERR_NOCANDO
	dec	bx			; Zero based resolution slot entries
	cmp	tddIntPeriodTable[bx],0FFh
ifdef DEBUG
	jne	tddBeginMinPeriodInRange
        inc     bx			; Show correct period in error
	DOUT	<tddBeginMinPeriod(#bx) overflow>
	jmp	tddBeginMinPeriodExit	; Return TIMERR_NOCANDO
tddBeginMinPeriodInRange:
else
	je	tddBeginMinPeriodExit	; Return TIMERR_NOCANDO
endif

	inc	tddIntPeriodTable[bx]	; Increment resolution[entry - 1]
	cmp	tddIntPeriodTable[bx],1	; Don't set period if entry is >1
	jne	@f
	call	tddSetInterruptPeriod
@@:
	xor	ax,ax			; Return ok (FALSE)

tddBeginMinPeriodExit:
	cwd				; Set to zero
cEnd

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;@doc	INTERNAL TIMER
;
;@api	DWORD | tddEndMinPeriod |
;	Decrements the specified resolution in the table of period resolutions
;	that was presumably set previously with a <f>tddBeginMinPeriod<d> call.
;	This optionally programming the timer for a new lower resolution if
;	the parameter passed removed the current minimum.
;
;@parm	WORD | wPeriod |
;	Contains a resolution period from 1 through 55 milliseconds.
;
;@rdesc	Returns 0 for success, else TIMERR_NOCANDO if the resolution period
;	passed was out of range.
;
;@uses	ax,bx,dx.
;
;@xref	tddBeginMinPeriod,tddSetInterruptPeriod.
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	assumes es,nothing
	assumes ds,Data

cProc	tddEndMinPeriod <PUBLIC,FAR> <>
	parmW	wPeriod
cBegin
	mov	ax,TIMERR_NOCANDO	; Initialize return to error return

	mov	bx,wPeriod
	cmp	bx,[wMaxResolution]
	jb	tddEndMinPeriodExit	; Return TIMERR_NOCANDO
	cmp	bx,TDD_MINRESOLUTION
	ja	tddEndMinPeriodExit	; Return TIMERR_NOCANDO
	dec	bx			; Zero based resolution slot entries
	cmp	tddIntPeriodTable[bx],0
ifdef DEBUG
	jne	tddEndMinPeriodInRange
        inc     bx			; Show correct period in error
	DOUT	<tddEndMinPeriod(#bx) underflow>
	jmp	tddEndMinPeriodExit	; Return TIMERR_NOCANDO
tddEndMinPeriodInRange:
else
	je	tddEndMinPeriodExit	; Return TIMERR_NOCANDO
endif

	dec	tddIntPeriodTable[bx]	; Decrement resolution[entry - 1]
	jnz	@f			; No need to set interrupt period
	call	tddSetInterruptPeriod
@@:
	xor	ax,ax			; Return ok (FALSE)

tddEndMinPeriodExit:
	cwd				; Set to zero
cEnd

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;@doc	INTERNAL TIMER
;
;@func	void | tddSetInterruptPeriod |
;	This function optionally programs the timer with a new interrupt
;	period if the maximum resolution in the resolution table has changed.
if 0	; !!!
;
;	If the function is being called outside of interrupt time, the function
;	must first turn off interrupts so that the resolution table is not
;	changed between the time the the function finds a resolution to set,
;	and the time it starts to program the timer.  Once the timer begins to
;	be programmed, it won't send any more interrupts until programming is
;	finished.  The documentation does not specify that, but it was verified
;	through testing the timer.  If however the function is being called
;	during a timer interrupt, there is no need to turn off interrupts, as
;	the resolution table will not be changed at that time.
;
endif
;	In any case, the resolution table is searched, looking for the first
;	non-zero entry, which is taken as the maximum resolution the timer
;	should currently be programmed to.  If nothing is set in the table,
;	then the programming defaults to the minimum resolution of 55 MS.
;
;	Once an entry is found, it is compared to the previous programmed
;	time, not the currently programmed time.  This is in case an interrupt
;	has not occurred since the last time the timer was programmed using
;	this function.  Note that in converting to clock ticks, any period
;	that overflows a single word is taken to be 65536 ticks, which is the
;	maximum number allowable in the timer, and is equal to almost 55 MS.
;
;	If a new time must be programmed, the new resolution is sent out to
;	the timer, and eventually interrupts are set again.
;
;@rdesc	Nothing.
;
;@uses	ax,bx,dx.
;
;@xref	tddBeginMinPeriod,tddEndMinPeriod.
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	assumes es,nothing
        assumes ds,Data

cProc   tddSetInterruptPeriodFar <PUBLIC,FAR> <>
cBegin
        call tddSetInterruptPeriod
cEnd

cProc	tddSetInterruptPeriod <PUBLIC,NEAR> <>

cBegin
	xor	bx, bx			; Start at the beginning of the table

	EnterCrit			; !!!

tdd_sip_loop:
	cmp	bx,TDD_MINRESOLUTION	; Has the last entry been passed up?
	je	tdd_sip_Set_This_Period	; Jump out using TDD_MINRESOLUTION
	inc	bx
	cmp	tddIntPeriodTable[bx-1],0
	je	tdd_sip_loop

tdd_sip_Set_This_Period:
	mov	ax,bx
	call	tddMsToTicks

	or	dx,dx			; Check for overflow of WORD
ifdef   NEC_98
        jz      short @f
        mov     ax,0ffffh
@@:
        cmp     byte ptr bClockFlag,0
        mov     dx,0f000h               ; 5MHz tick count
        jz      @f
        mov     dx,0c300h               ; 8MHz tick count
@@:
        cmp     ax,dx
        jc      tdd_sip_period_ok
        mov     ax,dx                   ; Set to 25msec tick count
else    ; NEC_98
	jz	tdd_sip_period_ok
	xor	ax,ax                   ; Set to 64k instead.
endif   ; NEC_98
tdd_sip_period_ok:

	cmp	ax,[wNextTime]		; Compare with last programmed time
	je	tdd_sip_exit		; No need to reprogram

	DOUT	<tddSetInterruptPeriod: ms=#bx ticks=#ax>

	mov	bx,ax			; Save this value
	mov	[wNextTime],bx		; This is now the last programmed time

	mov	al, TMR_MODE2_RW	; Set counter 0 to mode 2
	out	TMR_CTRL_REG, al

	mov	al, bl
	out	TMR_CNTR_0, al
	mov	al, bh
	out	TMR_CNTR_0, al

tdd_sip_exit:
	LeaveCrit			; !!!
cEnd

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;@doc	INTERNAL TIMER
;
;@api	DWORD | tddSetTimerEvent |
;	Adds a timer event, possibly periodic to the event queue.
;
;	A timer event is set by first looking through the table of external
;	event slots, trying to locate a currently vacant slot that is not
;	currently being checked or deleted.  If one is found, the Create flag
;	is test-and-set in order to try and grab the slot.
;
;	If this succeeds, the slot can be set up with the information, and the
;	resolution entered into the event resolution table.  The very last
;	thing that occurs is setting the ID element of the slot.  This is so
;	that an inturrupt will not try to execute this event until all the
;	parameters are set.  This means that the event could be executed
;	immediately after the ID is set, but before this function actually
;	returns to the caller.
;
;	If the function fails to grab the event slot, it means that either an
;	interrupt occurred, and another event was created in this slot, or that
;	this function is running during an interrupt that occurred while a new
;	event was being created.  In any case, the slot must be passed by.
;
;	If an interrupt had occurred during this function, it also means that
;	some other event could have been freed, but already passed by, so the
;	function misses it.  The function cannot go back though, because it
;	might actually be processing during an interrupt, and the slot being
;	passed by would continue in its present state, and thus cause an
;	infinite loop to occur.
;
;	When checking for a free event slot, not only is the ID checked, but
;	also the state of the Destroy flag.  This flag is used during the kill
;	event function to indicate that an event slot is currently being
;	checked or destroyed, or was destroyed during an interrupt while the
;	slot was being checked.  In either case, it indicates that this
;	function is being called during interrupt time, and the slot cannot be
;	re-used until the flag is removed by the kill event function.  This
;	means that during the kill event function, there is one less event
;	slot that can be used than normal.
;
;	Once the ID of the event slot is set, the event can be called.  Note
;	that the event may then be called before this function even returns.
;
;@rdesc	Returns a handle which identifies the timer event, or NULL if the
;	requested event is invalid, or the event queue is full.
;
;@xref	tddKillTimerEvent
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	assumes ds,Data
	assumes es,nothing

cProc	tddSetTimerEvent <PUBLIC,FAR> <si,di,es>
	parmD	pTIMEREVENT
	localW	wResolution
	localW	wEventID
cBegin
	les	si,pTIMEREVENT		; timer event structure
	mov	ax,es
	or	ax,si
	; (pTIMEREVENT != NULL)
	jz	SetEventError		; NULL pointer, exit

	mov	bx,es:[si].te_wDelay

	; ((te_wDelay >= wMinPeriod) && (te_wDelay <= TDD_MAXPERIOD))
	cmp	bx,[wMinPeriod]		; delay less than min period?
	jb	SetEventError		; Yes, error

	cmp	bx,TDD_MAXPERIOD	; delay greater than max period?
	ja	SetEventError		; Yes, error

	; (!te_wResolution)
	mov	ax,es:[si].te_wResolution
	or	ax,ax			; resolution not set?
	jz	SetDefaultResolution	; Yes, set default resolution

	; ((te_wResolution >= TDD_MINRESOLUTION) && (te_wResolution <= wMaxResolution))
	cmp	ax,TDD_MINRESOLUTION	; resolution less than min resolution?
	jb	@f			; No, skip to next check
	mov	ax,TDD_MINRESOLUTION

@@:
	cmp	ax,[wMaxResolution]	; resolution greater than max resolution?
	ja	@f			; No, skip to next check
	mov	ax,[wMaxResolution]

@@:
	; (te_wResolution > te_wDelay)
	cmp	bx,ax			; delay less than resolution?
	jb	SetDefaultResolution	; Yes, set default resolution

	jmp	short SetEventValidParms

SetEventError:
	xor	ax,ax			; Return NULL
	jmp	SetEventExit

SetDefaultResolution:
	; te_wResolution = min(TDD_MINRESOLUTION, te_wDelay)
	mov	ax,TDD_MINRESOLUTION
	cmp	bx,ax			; delay less than min resolution?
	ja	SetEventValidParms  	; No, just use min resolution then
	mov	ax,bx			; Yes, use the period as the resolution

;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -;
SetEventValidParms:
	mov	wResolution,ax		; save calculated resolution

	lea	di,Events		; DS:DI --> events
	xor	ax,ax			; event slot = 0

SetEventFindLoop:
	; if (!pEvent->evID && !pEvent->evDestroy)
	cmp	[di].evID,0
	jne	SetEventFindLoopNext
	cmp	BYTE PTR [di].evDestroy,0
	jne	SetEventFindLoopNext
	mov	bl,1
	xchg	BYTE PTR [di].evCreate,bl	; Test and set Create flag
	or	bl,bl
	jz	SetEventFindLoopFound

SetEventFindLoopNext:
	; pEvent++, wEventID++
	add	di,SizeEvent
	inc	ax
	; wEventID < MAXEVENTS
	cmp	ax,MAXEVENTS
	jb	SetEventFindLoop

	; Return NULL
	xor	ax,ax			; Slot not found, return NULL
	jmp	SetEventExit
	
SetEventFindLoopFound:
	;
	; combine the slot index and wNextID to produce a unique id to
	; return to the caller
	;
	add	[wNextID],MASKINCREMENT
	jz	SetEventFindLoopFound		; Ensure a non-zero mask
	or	ax,[wNextID]			; Add in the mask
	mov	wEventID,ax			; Save the event
	errnz	MAXEVENTS-16

	; tddBeginMinPeriod(pEvent->evResolution)
	mov	ax,wResolution
	mov	[di].evResolution,ax
	cCall	tddBeginMinPeriod <ax>

	; pEvent->evDelay = tddMsToTicks(pTIMEREVENT->te_wDelay)
	mov	ax,es:[si].te_wDelay
	call	tddMsToTicks
	mov	[di].evDelay.lo,ax
	mov	[di].evDelay.hi,dx

	; pEvent->evCallback = pTIMEREVENT->te_lpFunction
	mov	ax,es:[si].te_lpFunction.lo
	mov	dx,es:[si].te_lpFunction.hi
	mov	[di].evCallback.lo,ax
	mov	[di].evCallback.hi,dx

	; pEvent->evUser = pTIMEREVENT->te_dwUser
	mov	ax,es:[si].te_dwUser.lo
	mov	dx,es:[si].te_dwUser.hi
	mov	[di].evUser.lo,ax
	mov	[di].evUser.hi,dx

	; pEvent->evFlags = pTIMEREVENT->te_wFlags
	mov	ax,es:[si].te_wFlags
	mov	[di].evFlags,ax

@@:
	mov	bx,[IntCount]		; check for interrupt occurring
	call	GetCounterElement	; Get number of ticks passed
	xor	cx,cx
	add	ax,dTickUpdate.lo	; Add extra currently skipped.
	adc	cx,dTickUpdate.hi
	cmp	bx,[IntCount]
	jne	@b			; If interrupt occurred try again
	
	; pEvent->evTime = pEvent->evDelay + GetCounterElement + dTickUpdate
	mov	bx,[di].evDelay.lo
	mov	dx,[di].evDelay.hi
	add	bx,ax
	adc	dx,cx
	mov	[di].evTime.lo,bx
	mov	[di].evTime.hi,dx

	; pEvent->evID = wEventID
	mov	ax,wEventID
	mov	[di].evID,ax
	; Return wEventID

SetEventExit:
	xor	dx,dx
cEnd

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;@doc	INTERNAL TIMER
;
;@api	DWORD | tddKillTimerEvent |
;	Removes a timer event from the event queue.  If the event was periodic,
;	this is the only way to discontinue operation.	Otherwise, this may be
;	used to remove an unwanted one shot event in case of application
;	termination.
;	
;	A timer event it killed by trying to grab the Destroy flag in a two
;	step process, which succeeds only if the function was able to grab
;	the slot before any interrupt destroyed the event.
;
;	After verifying that the event handle is valid, the function checks the
;	Destroy flag to determine if this function is being called during
;	interrupt time, and interrupted another process killing the same
;	timer.  If this is so, the function just aborts before wasting time
;	doing any other flag setting.
;
;	The function then sets the Destroy flag to a EVENT_CHECKING state,
;	grabbing the current state of the flag in order to use when setting
;	the final state of the Destroy flag if the function succeeds.
;
;	If the event handles match, the Destroy flag is set to a
;	EVENT_DESTROYING state.  At this point, the Destroy flag is either in
;	the state in which this function left it, or an interrupt occurred, and
;	the flag was set to a EVENT_DESTROYED state durring interrupt time.  If
;	an interrupt ended up destroying the event out from under this call,
;	the function is exited after clearing the Destroy flag so that the
;	event slot can be used.  Note that the event slot cannot be used until
;	the function exits so that the EVENT_DESTROYED flag is not disturbed.
;
;	If the flag is grabbed, no other call can destroy the event, and the
;	event will not be executed during interrupt time.  As was previously
;	mentioned, the Destroy flag is either reset, or if this function was
;	called during interrupt time while the event was being checked, the
;	flag is set to EVENT_DESTROYED.
;
;	The resolution entered into the event resolution table is removed.
;	The very last thing to occur is resetting the Create flag.  At that
;	point the event slot could be re-used if the Destroy flag was reset.
;
;	Note that if the event handles do not match, the Destroyed flag is also
;	reset so that it can be used in creating a new event when this event
;	is destroyed, which may have happened while checking the handles.
;
;@parm	WORD | wID | The event handle returned by the <f>tddSetTimerEvent<d>
;	function which identifies the event to destroy.
;
;@rdesc	Returns 0 if timer event destroyed, or TIMERR_NOCANDO if the
;	event was not registered in the system event queue.
;
;@xref	tddSetTimerEvent
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	assumes ds,Data
	assumes es,nothing

cProc	tddKillTimerEvent <PUBLIC,FAR> <si,di>
	parmW	wID
cBegin
	mov	ax,wID
	and	ax,MASKFILTER			; Remove ID mask first
	errnz	MAXEVENTS-16

	imul	ax,SizeEvent			; Retrieve slot address
	lea	di,Events
	add	di,ax

	; if (pEvent->evDestroy == EVENT_DESTROYING)
	cmp	BYTE PTR [di].evDestroy,EVENT_DESTROYING	; If interrupting a destroy,
	je	KillEventError			; Leave with error

	mov	bl,EVENT_CHECKING
	xchg	BYTE PTR [di].evDestroy,bl	; Test and set Destroy check

	; if (pEvent->evID == wID)
	mov	ax,wID
	cmp	[di].evID,ax
	jne	KillEventRelease		; Wrong ID

	mov	bh,EVENT_DESTROYING
	xchg	BYTE PTR [di].evDestroy,bh	; Test and set Destroying

	cmp	bh,EVENT_CHECKING	; Was destroy interrupted?
	jne	KillEventRelease	; Slot has already been deleted

	mov	[di].evID,0		; Invalidate ID

	cmp	bl,EVENT_CHECKING	; Did this interrupt a destroy?
	jne	@f			; No, was already ZERO
	mov	bl,EVENT_DESTROYED	; Let the interrupted destroy know
@@:
	mov	BYTE PTR [di].evDestroy,bl
	cCall	tddEndMinPeriod,<[di].evResolution>

	; pEvent->evCreate = FALSE
	mov	BYTE PTR [di].evCreate,0	; Free up slot
	xor	ax,ax				; Return 0
	jmp	KillEventExit

KillEventRelease:
	; Free up checking flag
	mov	BYTE PTR [di].evDestroy,0

KillEventError:
	; Invalid ID or was deleted during interrupt time (test and set failed)
	mov	ax,TIMERR_NOCANDO

KillEventExit:
	cwd				; Set to zero
cEnd

	assumes	ds,Data
	assumes	es,nothing

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

public	GetTickCount
GetTickCount	proc near

@@:
	mov	cx,[IntCount]		; Save current interrupt count
	call	GetCounterElement	; Get number of ticks passed

	xor	dx,dx
	xor	bx,bx
	add	ax,CurTime[0]		; Add total tick count to current number past
	adc	dx,CurTime[2]
	adc	bx,CurTime[4]

	cmp	cx,[IntCount]		; Interrupt occurred while getting count
	jne	@b			; Get the count again
	ret
GetTickCount	endp

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;@doc	INTERNAL TIMER
;
;@api	DWORD | tddGetSystemTime |
;	Returns a system time in milliseconds.
;
;@rdesc	Returns a 32 bit value in dx:ax representing the number of milliseconds
;	since the timer driver was started.
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	assumes ds,Data
	assumes es,nothing

cProc	tddGetSystemTime <PUBLIC,FAR> <>

cBegin
	call	GetTickCount
	call	tddTicksToMs
cEnd

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;@doc	INTERNAL TIMER
;
;@asm	tddGetTickCount |
;	Returns a system time in clock ticks.
;
;@rdesc	Returns a 48 bit value in bx:dx:ax representing the number of clock
;	ticks since the timer driver was started.  A C interface would only
;	be able to access the lower 32 bits of this value.
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	assumes ds,Data
	assumes es,nothing

cProc	tddGetTickCount <PUBLIC,FAR> <>

cBegin
	call	GetTickCount
cEnd

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;@doc	INTERNAL TIMER
;
;@api	DWORD | tddGetDevCaps |
;	Fills in TIMECAPS structure.
;
;@parm	<t>LPTIMECAPS<d> | lpTIMECAPS |
;	Points to the structure to fill.
;
;@parm	WORD | wSize |
;	Indicates the size of the structure passed.  Normally this should be
;	the size of the <t>TIMECAPS<d> structure this module was compiled with.
;
;@rdesc	Returns 0 on success, or TIMERR_NOCANDO on failure.
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	assumes ds,nothing
	assumes es,nothing

cProc	tddGetDevCaps <PUBLIC,FAR> <si,ds>
	parmD	lpTIMECAPS
	parmW	wSize
cBegin
	mov	ax,TIMERR_NOCANDO	; Initialize return to an error state

	cmp	wSize,(SIZE TIMECAPS)	; Check the size of the structure passed
	jne	Caps_Exit

	lds	si,lpTIMECAPS		; timer event structure

	push	ds
	mov	ax,DGROUP
	mov	ds,ax
	assumes	ds,Data
	mov	ax,[wMinPeriod]		; Fill in the structure
	pop	ds
	assumes	ds,nothing

	mov	dx,TDD_MAXPERIOD
	mov	[si].tc_wPeriodMin,ax
	mov	[si].tc_wPeriodMax,dx
	xor	ax,ax			; Return success

Caps_Exit:
	cwd				; Set to zero
cEnd

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;@doc	INTERNAL TIMER
;
;@api	DWORD | tddTicksToMs |
;	Convert clock ticks (1.19318 MHz) to milliseconds (1000 Hz)
;
;@parm	BX:DX:AX |
;	Tick count to convert to milliseconds.
;
;@rdesc	DX:AX |
;	Converted millisecond count.
;
;@comm	There is a 0.0000005% positive error in the approximation of
;	1193.18 ticks per millisecond by the process to avoid floating point
;	arithmetic, which effectively divides by 1193.179993 instead.
;
;	time `Ms' = clock ticks `T' / 1193.18
;
;	In order to be able to use fixed point, the math actually done is:
;
;	Ms = (T * 10000h) / (DWORD)(1193.18 * 10000h)
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	assumes ds,Data
	assumes es,nothing

cProc	tddTicksToMs <PUBLIC,NEAR> <si,di>

cBegin
	externNP	qdiv		; In math.asm

; qdiv
;
; Entry:
;       DX:CX:BX:AX = QUAD Numerator
;       SI:DI       = LONG Denominator
; Returns:
;       DX:AX = quotient
;       CX:BX = remainder

	; multiply BX:DX:AX by 10000h and place result in DX:CX:BX:AX for qdiv
	mov	cx,dx
	mov	dx,bx
	mov	bx,ax
	xor	ax,ax

ifdef   NEC_98
        cmp     byte ptr bClockFlag,0
        jnz     set_8Mhz

set_5Mhz:
        ; SI:DI = 2457.6 * 10000h (essentially in 16.16 fixed notation)
        mov     si,2457         ; 2457 * 10000h
        mov     di,39321        ; 0.6 * 10000h = 39321.6
        jmp     short @f

set_8Mhz:
                                ; 8MHz,16MHz set
        ; SI:DI = 1996.8 * 10000h (essentially in 16.16 fixed notation)
        mov     si,1996         ; 1996 * 10000h
        mov     di,52428        ; 0.8 * 10000h = 52428.8
@@:
else    ; NEC_98
	; SI:DI = 1193.18 * 10000h (essentially in 16.16 fixed notation)
	mov	si,1193		; 1193 * 10000h
	mov	di,11796	; 0.18 * 10000h = 11796.48
endif   ; NEC_98

	call	qdiv		; (T * 10000h) / (DWORD)(1193.18 * 10000h)
cEnd

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;@doc	INTERNAL TIMER
;
;@api	DWORD | tddMsToTicks |
;	Convert milliseconds (1000 Hz) to clock ticks (1.193 MHz).
;
;@parm	AX |
;	Millisecond count to convert to clock ticks
;
;@rdesc	DX:AX |
;	Converted clock tick count.
;
;@comm	There is a slight error in the approximation of 1193.18 ticks per
;	millisecond by the process to avoid floating point arithmetic, which
;	effectively multiplies by 1193.1875 instead.
;
;	clock ticks `T' = time `Ms' * 1193.18
;
;	In order to be able to use fixed point, the math actually done is
;
;	T = (Ms * (WORD)(1193.18 * 20h)) / 20h
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	assumes ds,Data
	assumes es,nothing

cProc	tddMsToTicks <PUBLIC,NEAR> <>

cBegin
ifdef   NEC_98
        cmp     byte ptr bClockFlag,0
        jnz     set2_8Mhz

set2_5Mhz:
        mov     dx,39322       ; 2457.6 * 10h = 39321.6
        jmp     short @f

set2_8Mhz:
                               ; 8MHz,16MHz set
        mov     dx,31949       ; 1996.8 * 10h = 31948.8

@@:
        mul     dx             ; Ms * (WORD)(1996.8 * 10h)
        shr     ax,4           ; Divide the result by 10h
        mov     cx,dx          ; Save original first
        shl     cx,12          ; Keep only the bottom part
        shr     dx,4           ; Shift top part of return
        or      ax,cx          ; Put two halves of bottom part together

else    ; NEC_98
	mov	dx,38182	; 1193.18 * 20h = 38181.76
	mul	dx		; Ms * (WORD)(1193.18 * 20h)
	shr	ax,5		; Divide the result by 20h
	mov	cx,dx		; Save original first
	shl	cx,11		; Keep only the bottom part
	shr	dx,5		; Shift top part of return
	or	ax,cx		; Put two halves of bottom part together
endif   ; NEC_98
cEnd

sEnd	Code286

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\timer\api.asm ===
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;   API.ASM
;
;   Copyright (c) Microsoft Corporation 1989, 1990. All rights reserved.
;
;   Contains the routine tddMessage which communicates to either
;   the 386 timer API's of the 286 timer API's depending on the
;   WinFlags settings WF_WIN286,WF_WIN386.
;
;
;   Revision history:
;
;   2/12/90	     First created by w-glenns
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

?PLM=1	; pascal call convention
?WIN=0  ; Windows prolog/epilog code
?DF=1
PMODE=1

.xlist
include cmacros.inc
include windows.inc
include mmsystem.inc
include mmddk.inc
include timer.inc
.list

	.286p

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;   External functions
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

externFP    Enable
externFP    Disable

ifdef DEBUG
externFP    tddGetTickCount
endif

externFP    tddSetTimerEvent
externFP    tddKillTimerEvent
externFP    tddGetSystemTime
externFP    tddGetDevCaps
externFP    tddBeginMinPeriod
externFP    tddEndMinPeriod

;externFP    vtdSetTimerEvent
;externFP    vtdKillTimerEvent
;externFP    vtdGetSystemTime
;externFP    vtdGetDevCaps
;externFP    vtdBeginMinPeriod
;externFP    vtdEndMinPeriod

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;   Local data segment
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

externA     WinFlags

sBegin  Data

        externW     wEnabled

	errnz  <TDD_KILLTIMEREVENT-DRV_RESERVED>
	errnz  <TDD_SETTIMEREVENT-4-DRV_RESERVED>
	errnz  <TDD_GETSYSTEMTIME-8-DRV_RESERVED>
	errnz  <TDD_GETDEVCAPS-12-DRV_RESERVED>
	errnz  <TDD_BEGINMINPERIOD-16-DRV_RESERVED>
	errnz  <TDD_ENDMINPERIOD-20-DRV_RESERVED>

	tblCall286  dd tddKillTimerEvent,tddSetTimerEvent,tddGetSystemTime,tddGetDevCaps,tddBeginMinPeriod, tddEndMinPeriod
	tblCall386  dd tddKillTimerEvent,tddSetTimerEvent,tddGetSystemTime,tddGetDevCaps,tddBeginMinPeriod, tddEndMinPeriod
;       tblCall386  dd vtdKillTimerEvent,vtdSetTimerEvent,vtdGetSystemTime,vtdGetDevCaps,vtdBeginMinPeriod, vtdEndMinPeriod
        tblCallLen  equ ($-tblCall286)/2

ifdef DEBUG
        externD     RModeIntCount
        externD     PModeIntCount
endif

sEnd    Data

sBegin  CodeFixed
        assumes cs,CodeFixed
        assumes ds,Data
	assumes es,nothing

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;   @doc INTERNAL
;
;   @api DWORD | DriverProc | Pass messages to functions that really do work
;
;   @parm DWORD | nDevice | The id of the device to get the message.
;
;   @parm WORD | msg | The message.
;
;   @parm LONG | lParam1 | Parameter 1.
;
;   @parm LONG | lParam2 | Parameter 2.
;
;   @rdesc The return value depends on the message being sent.
;
;   @comm Devices not supporting a message should return 0.
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;
;   driver message handler table
;
;   These two tables define which routine handles which driver message.
;
;   NOTE WARNING: ProcTbl must IMMEDIATELY follow MsgTbl.
;
MsgTbl  dw      TDD_GETSYSTEMTIME
        dw      TDD_BEGINMINPERIOD
        dw      TDD_ENDMINPERIOD
        dw      TDD_KILLTIMEREVENT
        dw      TDD_SETTIMEREVENT
        dw      TDD_GETDEVCAPS

        dw      DRV_LOAD
        dw      DRV_OPEN
        dw      DRV_CLOSE
        dw      DRV_ENABLE
        dw      DRV_DISABLE
        dw      DRV_QUERYCONFIGURE
        dw      DRV_INSTALL
ifdef DEBUG
        dw      TDD_GETTICK
        dw      TDD_GETRINTCOUNT
        dw      TDD_GETPINTCOUNT
endif
        dw      -1

MsgLen  equ     $-MsgTbl

ProcTbl dw	msg_TDD_GETSYSTEMTIME	; TDD_GETSYSTEMTIME
	dw	msg_TDD_BEGINMINPERIOD	; TDD_BEGINMINPERIOD
	dw	msg_TDD_ENDMINPERIOD	; TDD_ENDMINPERIOD
	dw	msg_TDD_KILLTIMEREVENT	; TDD_KILLTIMEREVENT
	dw	msg_TDD_SETTIMEREVENT	; TDD_SETTIMEREVENT
	dw	msg_TDD_GETDEVCAPS	; TDD_GETDEVCAPS
                                        ;
        dw      msg_DRV_LOAD            ; DRV_OPEN
	dw	msg_DRV_OPEN		; DRV_OPEN
	dw	msg_DRV_CLOSE		; DRV_CLOSE
	dw	msg_DRV_ENABLE		; DRV_ENABLE
	dw	msg_DRV_DISABLE 	; DRV_DISABLE
        dw      msg_DRV_QUERYCONFIGURE  ; DRV_QUERYCONFIGURE
        dw      msg_DRV_INSTALL		; DRV_INSTALL
ifdef DEBUG
        dw      msg_TDD_GETTICK         ; TDD_GETTICK
        dw      msg_TDD_GETRINTCOUNT    ; TDD_GETRINTCOUNT
        dw      msg_TDD_GETPINTCOUNT    ; TDD_GETPINTCOUNT
endif
        dw      msg_fail                ; default

ProcLen equ     $-ProcTbl

errnz   <ProcLen-MsgLen>                ; these had better be the same!
errnz   <ProcTbl-MsgTbl-MsgLen>         ; ProcTbl *must* follow MsgTbl

cProc DriverProc <PUBLIC,FAR,LOADDS> <di>
	ParmD	id
	ParmW	hDriver
	ParmW	msg
	ParmD	lParam1
	ParmD	lParam2
cBegin
	mov	ax,cs			; es == Code
	mov	es,ax
        assumes es,CodeFixed

	mov	ax,msg			; AX = Message number
	cmp	ax,DRV_RESERVED 	; messages below DRV_RESERVED dont
	jl	msg_dispatch		; ...need driver to be enabled

	cmp	wEnabled,0		; must be enabled for msgs > DRV_RESERVED
	jz	msg_error

msg_dispatch:
        mov     di,CodeFixedOFFSET MsgTbl
	mov	cx,MsgLen/2
	cld
	repnz	scasw
	lea	bx,[di+MsgLen-2]
	jmp	cs:[bx]
	assumes es,nothing

msg_error:
	mov	ax, TIMERR_NOCANDO
	jmp	short msg_makelong

;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -;
; handle std. installable driver messages.
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -;
msg_DRV_ENABLE:
	cCall	Enable, <ax>		    ; enable driver
	jmp	short msg_makelong

msg_DRV_DISABLE:
	cCall	Disable, <ax>
	jmp	short msg_makelong

msg_DRV_LOAD:
msg_DRV_OPEN:
msg_DRV_CLOSE:
msg_success:
	mov	ax,1			    ; return 1 for all others
	jmp	short msg_makelong

msg_fail:
msg_DRV_QUERYCONFIGURE:
	xor	ax, ax			    ; no - return 0
	jmp	short msg_makelong

msg_DRV_INSTALL:
	mov	ax, DRVCNF_RESTART	    ; restart after install
	errn$	msg_makelong

msg_makelong:
	cwd				    ; make sure high word (dx) is set
        jmp     short msg_done

;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -;
; handle timer driver specific massages
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -;
ifdef DEBUG
msg_TDD_GETTICK:
        cCall   tddGetTickCount
        jmp     short msg_done

msg_TDD_GETRINTCOUNT:
        mov     ax,RModeIntCount.lo
        mov     dx,RModeIntCount.hi
        jmp     short msg_done

msg_TDD_GETPINTCOUNT:
        mov     ax,PModeIntCount.lo
        mov     dx,PModeIntCount.hi
        jmp     short msg_done
endif

msg_TDD_GETDEVCAPS:
	push	lParam1.hi
	push	lParam1.lo
	push	lParam2.lo
	jmp	short msg_call

msg_TDD_SETTIMEREVENT:
	push	lParam1.hi

msg_TDD_BEGINMINPERIOD:
msg_TDD_ENDMINPERIOD:
msg_TDD_KILLTIMEREVENT:
	push	lParam1.lo

msg_TDD_GETSYSTEMTIME:
	errn$	msg_call

;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -;
msg_call:
	sub	ax,DRV_RESERVED 	    ; map msg into table index
	mov	di,offset DGROUP:tblCall286
	add	di,ax
	mov	ax,WinFlags
	test	ax,WF_WIN386
	jz	@f			    ; jump if not win386
	add	di,tblCallLen
@@:	call	dword ptr [di]		    ; index into table
	errn$	msg_done

msg_done:
cEnd

sEnd

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\timer\sysinfo.inc ===
;******************************************************************************
;
;   (C) Copyright MICROSOFT Corp., 1989-1990
;
;   Title:	sysinfo.inc - structure & equates for INT 15h service 0C0h
;
;   Version:	1.00
;
;   Date:	28-Mar-1989
;
;   Author:	RAP
;
;------------------------------------------------------------------------------
;
;   Change log:
;
;      DATE	REV		    DESCRIPTION
;   ----------- --- -----------------------------------------------------------
;   28-Mar-1989 RAP
;
;==============================================================================

; System Descriptor Structure returned from INT 15h, service C0h

SysDescStruc STRUC
SD_len	    dw	?
SD_model    db	?
SD_submodel db	?
SD_ROM_rev  db	?
SD_feature1 db	?
SD_feature2 db	?
SD_feature3 db	?
SD_feature4 db	?
SD_feature5 db	?
SysDescStruc ENDS


; Feature byte 1 bits assignments:

SF1_FD_uses_DMA3	= 10000000b
SF1_FD_uses_DMA3_bit	= 7
SF1_PIC_2_present	= 01000000b
SF1_PIC_2_present_bit	=  6
SF1_RealTimeClock	= 00100000b
SF1_RealTimeClock_bit	=   5
SF1_INT15s_called	= 00010000b
SF1_INT15s_called_bit	=    4
SF1_ExtEventWait	= 00001000b
SF1_ExtEventWait_bit	=     3
SF1_EBIOS_allocated	= 00000100b
SF1_EBIOS_allocated_bit =      2
SF1_MicroChnPresent	= 00000010b
SF1_MicroChnPresent_bit =	1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\timer\timer.inc ===
;
;    timer.inc
;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;   segments
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

createSeg FIXED_TEXT,Code386,   word, public, CODE
createSeg FIXED_TEXT,CodeFixed, word, public, CODE
createSeg FIXED_286, Code286,   word, public, CODE
createSeg INIT_CODE, CodeInit,  word, public, CODE

createSeg _DATA,Data,word,public,DATA,DGROUP
defgrp DGROUP,Data

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;   Equates and structure definitions
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

IDS_ERRORTITLE	equ	1
IDS_ERRORTEXT	equ	2

;RMODE_INT	equ	1

ifdef DEBUG
    TDD_GETTICK         equ     42
    TDD_GETRINTCOUNT    equ     43
    TDD_GETPINTCOUNT    equ     44
endif

ifdef   NEC_98
TDD_MINRESOLUTION       equ     25      ; minimun resolution.(ms)
else    ; NEC_98
TDD_MINRESOLUTION	equ	55	; minimum resolution. (ms)
endif   ; NEC_98
TDD_MAX386RESOLUTION	equ	1	; maximum resolution. (ms)
TDD_MAX286RESOLUTION	equ	2	; maximum resolution. (ms)

TDD_MAXPERIOD		equ	0FFFFh	; maximum ms period.
TDD_MIN386PERIOD	equ	01h	; minimum ms period.
TDD_MIN286PERIOD	equ	02h	; minimum ms period.

ifdef   NEC_98
TMR_CNTR_0      equ     071h    ; counter 0 - programmable system interrupt
TMR_CTRL_REG    equ     077h    ; timer control word register
else    ; NEC_98
TMR_CNTR_0	equ	040h	; counter 0 - programmable system interrupt
TMR_CTRL_REG	equ	043h	; timer control word register
endif   ; NEC_98

TMR_MODE2_RW	equ   00110100b ; Read/Write counter 0 mode 2 (two bytes)
				; (countdown mode)

TMR_MODE3_RW	equ   00110110b ; Read/Write counter 0 mode 3 (two bytes)
				; (square wave mode)


PS2_SysCtrlPortB equ	61h	; IBM PS2 System Control Port B
PS2_LatchBit	equ	80h	; Latch clear bit for PS2
ifdef   NEC_98
PICDATA         equ     00h             ; Programmable interrupt controller port
SPECIFIC_EOI    equ     00100000b       ; IRQ 0 end-of-interrupt PIC command
else    ; NEC_98
PICDATA 	equ	020h	; Programmable interrupt controller port
SPECIFIC_EOI	equ	01100000b	; IRQ 0 end-of-interrupt PIC command
EOI_STATUS	equ	00001011b	; Status of pending EOIs
endif   ; NEC_98

TIME_BIOSEVENT  equ     8000h   ; special flag for bios event

TIMERINTERRUPT	equ	8	; interrupt number for timer counter


;	The following defines the maximum number of simultaneous events which
;	can be queued.  This value covers event slots 0 to 15.  Note that this
;	is 4 bits of data, which is relied upon in the code.
;
;	The two constants defined after are used to increment and filter the
;	mask added to the event slot IDs to create an event handle to return.
;	They illustrate the dependence upon the MAXEVENTS constant.

MAXEVENTS	equ	16

MASKINCREMENT	equ	0010h
MASKFILTER	equ	000fh

;	The following flags are used during the process of killing an event.
;
;	The first flag indicates that an event slot is being checked by the
;	kill event function, and that the EVENT_DESTROYED flag should be set
;	if the pevent is killed during interrupt time before the original
;	function completes its check.
;
;	The second flag indicates that an event is currently being killed, and
;	should not be allowed to execute.  This is set in the kill timer
;	function, and either cleared, or replaced with the EVENT_DESTROYED
;	flag when complete.
;
;	The third flag can be set either in the interrupt handler for oneshot
;	events, or in the kill timer function.  This is only set if the timer
;	was currently being checked when an interrupt occurred, and the event
;	was killed by the interrupt.  This flag disallows any new event to be
;	created in the event slot until the flag is cleared by the original
;	kill event function exiting.

EVENT_CHECKING		equ	1
EVENT_DESTROYING	equ	2
EVENT_DESTROYED		equ	4

EventStruct STRUC

evTime          dd  ?    ; actual time when the event will go off (in ticks)

evDelay         dd  ?    ; event delay time (in ticks)

evCallback      dd  ?    ; call back function

evUser          dd  ?    ; parameter to call-back function

evResolution    dw  ?    ; event resolution (in Ms)

evID            dw  ?    ; timer event id

evFlags         dw  ?    ; bits 1,0 = flags (one-shot/periodic)

evCreate	db  ?	 ; Creation flag

evDestroy	db  ?	 ; Destroying flag

EventStruct ENDS

    errnz <(SIZE EventStruct) and 1>

    SizeEvent equ <(SIZE EventStruct)>

;	Macro to cause a delay in between I/O accesses to the same device.

IO_Delay	MACRO
	jmp	$+2
ENDM

; this macro makes sure interrupts are disabled in debug driver
AssertCLI   MACRO
ifdef DEBUG
    push    ax
    pushf
    pop     ax
    test    ah,2
    jz	    @f
    int     3
@@: pop     ax
endif
ENDM

; this macro makes sure interrupts are enabled in debug driver
AssertSLI   MACRO
ifdef DEBUG
    push    ax
    pushf
    pop     ax
    test    ah,2
    jnz     @f
    int     3
@@: pop     ax
endif
ENDM

DefineInfo  MACRO
ifdef DEBUG
externNP    savedebuginfo
endif
ENDM

SaveInfo    MACRO   value
ifdef DEBUG
ifdef savedebuginfo
    push    ax
    mov     ax,value
    call    savedebuginfo
    pop     ax
else
    safd
endif
endif
ENDM

; The DOS Extender used for Standard mode Windows remaps the master 8259 from
; Int vectors 8h-Fh to 50h-57h.  In order to speed up com port interrupt
; response as much as possible, this driver hooks real mode interrupts
; when running in Standard mode.  It currently uses the following adjustment
; value to hook the real hardware int vector.  When time permits, this
; HARDCODED equate should be changed to be adjustible at run time.

DOSX_IRQ        equ     (50h - 8h)      ; Adjustment for DOSX remapping the
					; master 8259 from 8h to 50h
;	WinFlags[0] constants...remove when included in windows.inc

WF_PMODE	equ	01h
WF_CPU286	equ	02h
WF_CPU386	equ	04h
WF_CPU486	equ	08h
WF_WIN286	equ	10h		; WF_STANDARD
WF_WIN386	equ	20h		; WF_ENHANCED
WF_CPU086	equ	40h
WF_CPU186	equ	80h

;	Interrupt 31h service call equates

Get_RM_IntVector    equ     <(Int31_Int_Serv SHL 8 ) OR Int_Get_Real_Vec>
Set_RM_IntVector    equ     <(Int31_Int_Serv SHL 8 ) OR Int_Set_Real_Vec>

GetSystemConfig		equ	0c0h

;---------------------------------Macro---------------------------------;
;
; EnterCrit
;
;   saves the current state of the interrupt flag on the stack then
;   disables interrupts.
;
; Registers Destroyed:
;       BX, FLAGS
;
;------------------------------------------------------------------------;

EnterCrit macro
    local   no_cli
    pushf
    pushf
    pop     cx
    test    ch,2            ; if interrupts are already off, dont blow
    jz      no_cli          ; ... ~300 clocks doing the cli
    cli
no_cli:
endm

;---------------------------------Macro---------------------------------;
;
; LeaveCrit
;
;   restore the interrupt state saved by EnterCrit
;
; Registers Destroyed:
;       CX, FLAGS
;
;------------------------------------------------------------------------;

LeaveCrit macro reg
    local   no_sti
    pop     cx
    test    ch, 2
    jz      no_sti
    sti
no_sti:
endm

;------------------------------------------------------------------------;
;------------------------------------------------------------------------;

externFP    OutputDebugStr

DOUT macro text
    local   string_buffer

ifdef DEBUG

_DATA segment
string_buffer label byte
    db      "&text&",13,10,0
_DATA ends

    push    DataBASE
    push    DataOFFSET string_buffer
    call    OutputDebugStr
endif
    endm

ifdef   NEC_98
; Module Name: Timer interface procedures
;
; Created: 03-08-90 NEC Y.Ueno

TIMODESET       EQU     77H
TICNTSET        EQU     71H
TIMERMASK       EQU     01H

setmask macro   code
        cli                             ; mask timer int
        in      al,02h
        delay   8259,I-O
        or      al,code
        out     02h,al
        jmp     $+2
        sti
        endm

unmask macro    code
        cli                             ; mask timer int
        in      al,02h
        delay   8259,I-O
        and     al,not code
        out     02h,al
        jmp     $+2
        sti
        endm


;       DELAY MACRO FOR 80386
; This macro is defined in SYSMAC.INC(V23 ROM BIOS)             <880203 ver2.1
;
DELAY   MACRO   DEV,ACT,MOD

        IFIDN   <DEV>,<8237>
                IFIDN   <ACT>,<O-O>
        JMP     SHORT   $+2
                ENDIF
                IFIDN   <ACT>,<O-I>
        JMP     SHORT   $+2
                ENDIF
                IFIDN   <ACT>,<>
        JMP     SHORT   $+2
                ENDIF
        ENDIF

        IFIDN   <DEV>,<8253>
                IFIDN   <ACT>,<O-O>
        REPT    2
        JMP     SHORT   $+2
        ENDM
                ENDIF
                IFIDN   <ACT>,<I-I>
        JMP     SHORT   $+2
                ENDIF
                IFIDN   <ACT>,<O-I>
        REPT    2
        JMP     SHORT   $+2
        ENDM
                ENDIF
                IFIDN   <ACT>,<I-O>
        JMP     SHORT   $+2
                ENDIF
                IFIDN   <ACT>,<>
        REPT    2
        JMP     SHORT   $+2
        ENDM
                ENDIF
        ENDIF

        IFIDN   <DEV>,<8255>
                IFIDN   <ACT>,<O-O>
        REPT    2
        JMP     SHORT   $+2
        ENDM
                ENDIF
                IFIDN   <ACT>,<I-I>
        JMP     SHORT   $+2
                ENDIF
                IFIDN   <ACT>,<O-I>
        REPT    2
        JMP     SHORT   $+2
        ENDM
                ENDIF
                IFIDN   <ACT>,<I-O>
        JMP     SHORT   $+2
                ENDIF
                IFIDN   <ACT>,<>
        REPT    2
        JMP     SHORT   $+2
        ENDM
                ENDIF
        ENDIF

        IFIDN   <DEV>,<8259>
                IFIDN   <ACT>,<O-O>
        JMP     SHORT   $+2
                ENDIF
                IFIDN   <ACT>,<I-I>
                ENDIF
                IFIDN   <ACT>,<O-I>
        JMP     SHORT   $+2
                ENDIF
                IFIDN   <ACT>,<I-O>
                ENDIF
                IFIDN   <ACT>,<>
        JMP     SHORT   $+2
                ENDIF
        ENDIF

        IFIDN   <DEV>,<8251>
                IFIDN   <ACT>,<O-O>
                        IFIDN   <MOD>,<INIT>
        REPT    4
        JMP     SHORT   $+2
        ENDM
                        ENDIF
                        IFIDN   <MOD>,<ASYNC>
        REPT    5
        JMP     SHORT   $+2
        ENDM
                        ENDIF
                        IFIDN   <MOD>,<SYNC>
        REPT    10
        JMP     SHORT   $+2
        ENDM
                        ENDIF
                ENDIF
        ENDIF

        IFIDN   <DEV>,<765>
        ENDIF

        IFIDN   <DEV>,<7220>
                IFIDN   <ACT>,<O-O>
                        IFIDN   <MOD>,<GRAPH>
        REPT    4
        JMP     SHORT   $+2
        ENDM
                        ENDIF
                        IFIDN   <MOD>,<TEXT>
        REPT    2
        JMP     SHORT   $+2
        ENDM
                        ENDIF
                ENDIF
                IFIDN   <ACT>,<I-I>
                        IFIDN   <MOD>,<GRAPH>
        REPT    3
        JMP     SHORT   $+2
        ENDM
                        ENDIF
                        IFIDN   <MOD>,<TEXT>
        JMP     SHORT   $+2
                        ENDIF
                ENDIF
                IFIDN   <ACT>,<O-I>
                        IFIDN   <MOD>,<GRAPH>
        REPT    4
        JMP     SHORT   $+2
        ENDM
                        ENDIF
                        IFIDN   <MOD>,<TEXT>
        REPT    2
        JMP     SHORT   $+2
        ENDM
                        ENDIF
                ENDIF
                IFIDN   <ACT>,<I-O>
                        IFIDN   <MOD>,<GRAPH>
        REPT    3
        JMP     SHORT   $+2
        ENDM
                        ENDIF
                        IFIDN   <MOD>,<TEXT>
        JMP     SHORT   $+2
                        ENDIF
                ENDIF
        ENDIF

        IFIDN   <DEV>,<7201>
                IFIDN   <ACT>,<O-O>
        JMP     SHORT   $+2
                ENDIF
                IFIDN   <ACT>,<O-I>
        JMP     SHORT   $+2
                ENDIF
        ENDIF

        IFIDN   <DEV>,<7210>
                IFIDN   <ACT>,<O-O>
        JMP     SHORT   $+2
                ENDIF
                IFIDN   <ACT>,<O-I>
        JMP     SHORT   $+2
                ENDIF
        ENDIF

        IFIDN   <DEV>,<4990>
                REPT    3
                JMP     SHORT   $+2
                ENDM
        ENDIF

        ENDM
endif   ; NEC_98
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\toolhelp\class1.c ===
/*************************************************************************
 *  CLASS1.C
 *
 *      Routines used to enumerate window classes
 *
 *************************************************************************/

#include "toolpriv.h"
#include <testing.h>

/* ----- Types ----- */

/* The following was stolen from the 3.1 USER but is the same as 3.0.
 *  Note that the only fielda we use (for now) are the atomClassName
 *  and the pclsNext fields.
 *  Oops.  We're going to use the hInstance field also.
 */
typedef struct tagCLS
{
    struct tagCLS *pclsNext;
    unsigned clsMagic;
    unsigned atomClassName;
    char *pdce;                 /* DCE * to DC associated with class */
    int cWndReferenceCount;     /* Windows registered with this class */
    unsigned style;
    long (far *lpfnWndProc)();
    int cbclsExtra;
    int cbwndExtra;
    HANDLE hInstance;
    HANDLE hIcon;
    HANDLE hCursor;
    HANDLE hbrBackground;
    char far *lpszMenuName;
    char far *lpszClassName;
} CLS;
typedef CLS FAR *LPCLS;

/* ----- Functions ----- */

/*  ClassFirst
 *      Returns information about the first task in the task chain.
 */

BOOL TOOLHELPAPI ClassFirst(
    CLASSENTRY FAR *lpClass)
{
    WORD wClassHead;

    /* Check for errors */
    if (!wLibInstalled || !lpClass || lpClass->dwSize != sizeof (CLASSENTRY))
        return FALSE;

    /* If we're in Win3.1, call the special entry point to get the head */
    if (!(wTHFlags & TH_WIN30))
        wClassHead = (WORD)(*lpfnUserSeeUserDo)(SD_GETCLASSHEADPTR, 0, 0L);

    /* In 3.0 (and 3.0a) we're forced to use a fixed offset.  Unfortunately,
     *  this offset is different in debug and nondebug versions.
     */
    else
    {
        if (GetSystemMetrics(SM_DEBUG))
            wClassHead = 0x1cc;
        else
            wClassHead = 0x1b8;
        wClassHead = *(WORD FAR *)MAKEFARPTR(hUserHeap, wClassHead);
    }

    /* Now get the stuff */
    return ClassInfo(lpClass, wClassHead);
}


/*  ClassNext
 *      Returns information about the next task in the task chain.
 */

BOOL TOOLHELPAPI ClassNext(
    CLASSENTRY FAR *lpClass)
{
    /* Check for errors */
    if (!wLibInstalled || !lpClass || !lpClass->wNext ||
        lpClass->dwSize != sizeof (CLASSENTRY))
        return FALSE;

    return ClassInfo(lpClass, lpClass->wNext);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\toolhelp\class2.asm ===
;**************************************************************************
;*  CLASS2.ASM
;*
;*      Assembly support for the class enumeration routines.
;*
;**************************************************************************

        INCLUDE TOOLPRIV.INC

PMODE32 = 0
PMODE   = 0
SWAPPRO = 0
        INCLUDE TDB.INC

;** Class structure
CLS STRUC
cls_pclsNext    DW      ?
cls_clsMagic    DW      ?
cls_atom        DW      ?
cls_pdce        DW      ?
cls_RefCount    DW      ?
cls_style       DW      ?
cls_lpfnWndProc DD      ?
cls_cbclsExtra  DW      ?
cls_cbwndExtra  DW      ?
cls_hInstance   DW      ?
cls_hIcon       DW      ?
cls_hCursor     DW      ?
cls_hbrBackgr   DW      ?
cls_lpszMnName  DW      ?
cls_lpszClsName DW      ?
CLS ENDS

;** External functions
externNP HelperVerifySeg
externFP GetAtomName

;** Functions

sBegin  CODE
        assumes CS,CODE

;  ClassInfo
;
;       Returns information about the class with the given block handle

cProc   ClassInfo, <PUBLIC,NEAR>, <si,di,ds>
        parmD   lpClass
        parmW   wOffset
cBegin
        ;** Start by verifying that we can read the segment here
        mov     ax,hUserHeap            ;Get the selector
        mov     bx,wOffset              ;  and the desired offset
        cCall   HelperVerifySeg, <ax,bx>
        or      ax,ax                   ;FALSE return?
        jnz     CI_SelOk                ;We're OK
        xor     ax,ax                   ;Return FALSE
        jmp     CI_End
CI_SelOk:

        ;** Point to the CLS structure with DS:SI.  Note that using DS to
        ;**     point to USER's DS is useful to get USER's local atoms
        mov     ax,hUserHeap            ;User's heap is User's DGROUP
        mov     ds,ax
        mov     si,wOffset              ;Get a pointer to the CLS structure

        ;** Copy the hInstance
        les     di,lpClass              ;Get the structure
        mov     ax,[si].cls_hInstance   ;Get the hInst of the class owner
        mov     es:[di].ce_hInst,ax     ;Save in the CLASSENTRY struct  

        ;** Get the string from the atom and copy the next pointer
        mov     ax,[si].cls_atom        ;Get the desired atom number
        lea     bx,[di].ce_szClassName  ;Get the offset to copy string to
        push    es                      ;Save ES (GetAtomName may trash)
        mov     cx,MAX_CLASSNAME        ;Get max classname length
        cCall   GetAtomName, <ax,es,bx,cx> ;Copy the atom string
        pop     es
        or      ax,ax                   ;OK?
        jnz     CI_20                   ;Yes
        mov     es:[di].ce_szClassName,0 ;No.  Clear the string
CI_20:  mov     ax,[si].cls_pclsNext    ;Get the next pointer
        mov     es:[di].ce_wNext,ax     ;Save it

        ;** Return TRUE on success
        mov     ax,TRUE
CI_End:
cEnd

sEnd

        END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\toolhelp\global.c ===
/**************************************************************************
 *  GLOBAL.C
 *
 *      Routines used to walk the global heap.
 *
 **************************************************************************/

#include "toolpriv.h"
#include <newexe.h>
#include <string.h>

/*  GlobalInfo
 *      Reports information about the state of the global heap,
 *      specifically, the number of elements that will be returned by
 *      a global heap walk.
 */

BOOL TOOLHELPAPI GlobalInfo(
    GLOBALINFO FAR *lpGlobalInfo)
{
    /* Check the structure size and verify proper installation */
    if (!wLibInstalled || lpGlobalInfo->dwSize != sizeof (GLOBALINFO))
        return FALSE;

    /* Get the item counts */
    if (wTHFlags & TH_KERNEL_386)
    {
        lpGlobalInfo->wcItems = Walk386Count(GLOBAL_ALL);
        lpGlobalInfo->wcItemsFree = Walk386Count(GLOBAL_FREE);
        lpGlobalInfo->wcItemsLRU = Walk386Count(GLOBAL_LRU);
    }
    else
    {
        lpGlobalInfo->wcItems = Walk286Count(GLOBAL_ALL);
        lpGlobalInfo->wcItemsFree = Walk286Count(GLOBAL_FREE);
        lpGlobalInfo->wcItemsLRU = Walk286Count(GLOBAL_LRU);
    }

    return TRUE;
}

/*  GlobalFirst
 *      Finds the first element in the global heap.  This is modified by
 *      wFlags which modifies which list (GLOBAL_ALL, GLOBAL_FREE,
 *      GLOBAL_LRU) should be walked
 */

BOOL TOOLHELPAPI GlobalFirst(
    GLOBALENTRY FAR *lpGlobal,
    WORD wFlags)
{
    DWORD dwFirst;

    /* Check the structure size and verify proper installation */
    if (!wLibInstalled || !lpGlobal ||
        lpGlobal->dwSize != sizeof (GLOBALENTRY))
        return FALSE;

    /* Call the appropriate low-level routine to find the first block */
    if (wTHFlags & TH_KERNEL_386)
    {
        /* Get the first item.  Return false if no items in this list */
        if (!(dwFirst = Walk386First(wFlags)))
            return FALSE;

        /* Return information about this first item */
        Walk386(dwFirst, lpGlobal, wFlags);
    }
    else
    {
        /* Get the first item.  Return false if no items in this list */
        if (!(dwFirst = Walk286First(wFlags)))
            return FALSE;

        /* Return information about this first item */
        Walk286(dwFirst, lpGlobal, wFlags);
    }

    /* Guess at the type of the object */
    HelperGlobalType(lpGlobal);

    return TRUE;
}


/*  GlobalNext
 *      Returns the next item in the chain pointed to by lpGlobal and
 *      in the list indicated by wFlags (same choices as for GlobalFirst().
 */

BOOL TOOLHELPAPI GlobalNext(
    GLOBALENTRY FAR *lpGlobal,
    WORD wFlags)
{
    DWORD dwNext;

    /* Check the structure size and verify proper installation */
    if (!wLibInstalled || !lpGlobal ||
        lpGlobal->dwSize != sizeof (GLOBALENTRY))
        return FALSE;

    /* Check to see if we're at the end of the list */
    dwNext = wFlags & 3 ? lpGlobal->dwNextAlt : lpGlobal->dwNext;
    if (!dwNext)
        return FALSE;

    /* If we're using the 386 kernel, call the 386 heap walk routine with
     *  a pointer to the appropriate heap item
     *  (Note that this depends on GLOBAL_ALL being zero)
     */
    if (wTHFlags & TH_KERNEL_386)
        Walk386(dwNext, lpGlobal, wFlags);
    else
        Walk286(dwNext, lpGlobal, wFlags);

    /* Guess at the type of the object */
    HelperGlobalType(lpGlobal);

    return TRUE;
}


/*  GlobalEntryHandle
 *      Used to find information about a global heap entry.  Information
 *      about this entry is returned in the structure.
 */

BOOL TOOLHELPAPI GlobalEntryHandle(
    GLOBALENTRY FAR *lpGlobal,
    HANDLE hItem)
{
    DWORD dwBlock;

    /* Check the structure size and verify proper installation */
    if (!wLibInstalled || !lpGlobal ||
        lpGlobal->dwSize != sizeof (GLOBALENTRY))
        return FALSE;

    /* Make sure this is a valid block */
    if (wTHFlags & TH_KERNEL_386)
    {
        if (!(dwBlock = Walk386Handle(hItem)))
            return FALSE;
    }
    else
    {
        if (!(dwBlock = Walk286Handle(hItem)))
            return FALSE;
    }
    
    /* Return information about this item */
    if (wTHFlags & TH_KERNEL_386)
        Walk386(dwBlock, lpGlobal, GLOBAL_ALL);
    else
        Walk286(dwBlock, lpGlobal, GLOBAL_ALL);

    /* Guess at the type of the object */
    HelperGlobalType(lpGlobal);

    return TRUE;
}


/*  GlobalEntryModule
 *      Returns global information about the block with the given module
 *      handle and segment number.
 */

BOOL TOOLHELPAPI GlobalEntryModule(
    GLOBALENTRY FAR *lpGlobal,
    HANDLE hModule,
    WORD wSeg)
{
    struct new_exe FAR *lpNewExe;
    struct new_seg1 FAR *lpSeg;
    DWORD dwBlock;

    /* Check the structure size and verify proper installation */
    if (!wLibInstalled || !lpGlobal ||
        lpGlobal->dwSize != sizeof (GLOBALENTRY))
        return FALSE;

    /* Grunge in the module database to find the proper selector.  Start
     *  by first verifying the module database pointer
     */
    if (!HelperVerifySeg(hModule, sizeof (struct new_exe)))
        return FALSE;

    /* Get a pointer to the module database */
    lpNewExe = MAKEFARPTR(hModule, 0);

    /* Make sure this is a module database */
    if (lpNewExe->ne_magic != NEMAGIC)
        return FALSE;

    /* See if the number requested is past the end of the segment table.
     *  Note that the first segment is segment 1.
     */
    --wSeg;
    if (lpNewExe->ne_cseg <= wSeg)
        return FALSE;

    /* Get a pointer to the segment table */
    lpSeg = MAKEFARPTR(hModule, lpNewExe->ne_segtab);

    /* Jump to the right spot in the segment table */
    lpSeg += wSeg;

    /* Make sure this is a valid block and get its arena pointer */
    if (wTHFlags & TH_KERNEL_386)
    {
        if (!(dwBlock = Walk386Handle(lpSeg->ns_handle)))
            return FALSE;
    }
    else
    {
        if (!(dwBlock = Walk286Handle(lpSeg->ns_handle)))
            return FALSE;
    }

    /* Return information about this item */
    if (wTHFlags & TH_KERNEL_386)
        Walk386(dwBlock, lpGlobal, GLOBAL_ALL);
    else
        Walk286(dwBlock, lpGlobal, GLOBAL_ALL);

    /* Guess at the type of the object */
    HelperGlobalType(lpGlobal);

    /* If we've gotten to here, it must be OK */
    return TRUE;
}


/*  GlobalHandleToSel
 *      Provides a generic method of converting a handle to a selector.
 *      This works across Windows versions as well as working when the
 *      value is already a selector.
 */

WORD TOOLHELPAPI GlobalHandleToSel(
    HANDLE hMem)
{
    return HelperHandleToSel(hMem);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\toolhelp\int1.c ===
/**************************************************************************
 *  INT1.C
 *
 *      Routines used to implement the interrupt trapping API in
 *      TOOLHELP.DLL
 *
 **************************************************************************/

#include <string.h>
#include "toolpriv.h"

/* ----- Global variables ----- */
    WORD wIntInstalled;
    INTERRUPT NEAR *npIntHead;

/*  InterruptRegister
 *      Registers an interrupt callback.
 */

BOOL TOOLHELPAPI InterruptRegister(
    HANDLE hTask,
    FARPROC lpfnCallback)
{
    INTERRUPT *pInt;
    INTERRUPT *pTemp;

    /* Make sure TOOLHELP.DLL is installed */
    if (!wLibInstalled)
        return FALSE;

    /* If the interrupt hook has not yet been installed, install it */
    if (!wIntInstalled)
    {
        /* Make sure we can hook! */
        if (!InterruptInit())
            return FALSE;
        wIntInstalled = TRUE;
    }

    /* NULL hTask means current task */
    if (!hTask)
        hTask = GetCurrentTask();

    /* Register a death signal handler for this task (does nothing if one
     *  is already installed.
     */
    SignalRegister(hTask);

    /* Check to see if this task is already registered */
    for (pInt = npIntHead ; pInt ; pInt = pInt->pNext)
        if (pInt->hTask == hTask)
            return FALSE;

    /* Allocate a new INTERRUPT structure */
    pInt = (INTERRUPT *)LocalAlloc(LMEM_FIXED, sizeof (INTERRUPT));
    if (!pInt)
        return FALSE;

    /* Fill in the useful fields */
    pInt->hTask = hTask;
    pInt->lpfn = (LPFNCALLBACK) lpfnCallback;

    /* If this is the only handler, just insert it */
    if (!npIntHead)
    {
        pInt->pNext = npIntHead;
        npIntHead = pInt;
    }

    /* Otherwise, insert at the end of the list */
    else
    {
        for (pTemp = npIntHead ; pTemp->pNext ; pTemp = pTemp->pNext)
            ;
        pInt->pNext = pTemp->pNext;
        pTemp->pNext = pInt;
    }

    return TRUE;
}


/*  InterruptUnRegister
 *      Called by an app whose callback is no longer to be used.
 *      NULL hTask uses current task.
 */

BOOL TOOLHELPAPI InterruptUnRegister(
    HANDLE hTask)
{
    INTERRUPT *pInt;
    INTERRUPT *pBefore;

    /* Make sure we have interrupt installed and that TOOLHELP is OK */
    if (!wLibInstalled || !wIntInstalled)
        return FALSE;

    /* NULL hTask means current task */
    if (!hTask)
        hTask = GetCurrentTask();

    /* First try to find the task */
    pBefore = NULL;
    for (pInt = npIntHead ; pInt ; pInt = pInt->pNext)
        if (pInt->hTask == hTask)
            break;
        else
            pBefore = pInt;
    if (!pInt)
        return FALSE;

    /* Unhook the death signal proc only if there is no interrupt handler */
    if (!NotifyIsHooked(hTask))
        SignalUnRegister(hTask);

    /* Remove it from the list */
    if (!pBefore)
        npIntHead = pInt->pNext;
    else
        pBefore->pNext = pInt->pNext;

    /* Free the structure */
    LocalFree((HANDLE)pInt);

    /* If there are no more handlers, unhook the callback */
    if (!npIntHead)
    {
        InterruptUnInit();
        wIntInstalled = FALSE;
    }

    return TRUE;
}

/* ----- Helper functions ----- */

/*  InterruptIsHooked
 *      Returns TRUE iff the parameter task already has a interrupt hook.
 */

BOOL PASCAL InterruptIsHooked(
    HANDLE hTask)
{
    INTERRUPT *pInt;

    /* Loop thorugh all interrupts */
    for (pInt = npIntHead ; pInt ; pInt = pInt->pNext)
        if (pInt->hTask == hTask)
            break;

    /* Return found/not found */
    return (BOOL)pInt;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\toolhelp\int2.asm ===
PAGE 60,150
;***************************************************************************
;*  INT2.ASM
;*
;*      Assembly code support routines used for the TOOLHELP.DLL interrupt
;*      trapping API
;*
;***************************************************************************

        INCLUDE TOOLPRIV.INC
        INCLUDE WINDOWS.INC
        include vint.inc
.286p

;** Symbols
I_EXCEPTION             EQU     0
I_INTERRUPT             EQU     1
MAX_INTERRUPT           EQU     7
GIVE_WDEB386            EQU     8000h
BAD_STACK_FLAG          EQU     8000h
MIN_STACK_ALLOWED       EQU     128

;** Local types

INT_INFO STRUC
ii_wNumber      DW      ?               ;INT nn
ii_wType        DW      ?               ;I_EXCEPTION or I_INTERRUPT
ii_dwChain      DD      ?
ii_wHandler     DW      ?               ;Note that this is CS relative
INT_INFO ENDS

;** Data
sBegin  DATA

IntInfo         LABEL   BYTE
        public IntInfo
UD_Info         DW      6               ;Undefined opcode
                DW      I_EXCEPTION     ;This should be DPMI-hooked
                DD      0               ;Chain address (will be initialized)
                DW      OFFSET _TEXT:UD_Handler
Div0_Info       DW      0               ;Divide by zero
                DW      I_EXCEPTION     ;Hook with DPMI
                DW      OFFSET _TEXT:Div0_Handler
                DW      0
                DW      OFFSET _TEXT:Div0_Handler
Int1_Info       DW      1               ;Single step + debug register
                DW      I_INTERRUPT     ;Hook with DOS
                DD      0               ;Chain address
                DW      OFFSET _TEXT:Int1_Handler
Int3_Info       DW      3               ;Software debug int
                DW      I_INTERRUPT     ;Hook with DOS
                DD      0               ;Chain address
                DW      OFFSET _TEXT:Int3_Handler
GP_Info         DW      13              ;GP Fault
                DW      I_EXCEPTION     ;This should be DPMI-hooked
                ;** This entry is a special case entry for the Win30 std mode
                ;*      handler.  This is a separate entry point into the
                ;**     interrupt handler routine
                DW      OFFSET _TEXT:GP_StdModeHandler
                DW      0
                DW      OFFSET _TEXT:GP_Handler
SF_Info         DW      12              ;Stack fault
                DW      I_EXCEPTION     ;This should be DPMI-hooked
                ;** This entry is a special case entry for the Win30 std mode
                ;*      handler.  This is a separate entry point into the
                ;**     interrupt handler routine
                DW      OFFSET _TEXT:SF_StdModeHandler
                DW      0
                DW      OFFSET _TEXT:SF_Handler
PF_Info         DW      14              ;Page fault
                DW      I_EXCEPTION     ;This should be DPMI-hooked
                ;** This entry is a special case entry for the Win30 std mode
                ;*      handler.  This is a separate entry point into the
                ;**     interrupt handler routine
                DW      OFFSET _TEXT:PF_StdModeHandler
                DW      0
                DW      OFFSET _TEXT:PF_Handler
CASRq_Info      DW      256             ;CtlAltSysRq (fake interrupt)
                DW      I_INTERRUPT     ;Hook with DOS
                DD      0               ;Chain address
                DW      OFFSET _TEXT:CASRq_Handler

                ;** The following data is used to see if GDI wants the
                ;**     Div0 we have trapped
lpGDIFlag       DD      0
hGDI            DW      0
szGDI           DB      'GDI', 0
        public lpGDIFlag, hGDI

                ;** Points to a KERNEL routine to see if it wants the
                ;**     GP fault first
lpfnPV          DD      0               ;Call to see if PV GP fault
        public lpfnPV

                ;** Globals used for DPMI emulation
lpOldHandler    DD      0               ;Previous DPMI exception handler
lpChainCSIP     DD      0               ;Next exception handler on chain
wException      DW      0
        public lpOldHandler, lpChainCSIP

externW wCASRqFlag                      ;Set when an CASRq INT3 has been set
externD dwCASRqCSIP                     ;Holds the CS:IP of the CASRq INT3
sEnd

;** Imports
externNP TerminateApp
externNP HelperHandleToSel
externNP HelperVerifySeg
externFP AllocCStoDSAlias
externFP FreeSelector
externFP GetModuleHandle
externFP GetProcAddress
externFP GlobalEntryHandle
externFP _wsprintf
externFP OutputDebugString
externA __WinFlags

;** Functions

sBegin  CODE
        assumes CS,CODE
        assumes DS,DATA

;** Interrupt trapping API

;  InterruptInit
;       Hooks all necessary interrupts and exceptions to allow an API
;       for app-level interrupt hooks.

cProc   InterruptInit, <NEAR,PUBLIC>, <si,di>
cBegin
        ;** Loop through all possible handlers
        mov     cx,MAX_INTERRUPT        ;Number of ints to hook
        lea     si,IntInfo              ;Get the address of the array
DII_HandlerLoop:
        push    cx                      ;Save loop counter
        cmp     [si].ii_wNumber,256     ;Fake exception?
        jae     DII_Continue            ;Yes, don't hook anything!
        cmp     [si].ii_wType,I_EXCEPTION ;Exception?
        jnz     DII_Interrupt           ;Nope, hook as interrupt
        
        ;** Do a special case for 3.0 Std Mode 
        test    wTHFlags,TH_WIN30STDMODE ;Are we in Win30 std mode?
        jz      DII_NotStdMode          ;No.
        mov     ax,WORD PTR [si].ii_dwChain ;Get the secondary handler
        mov     [si].ii_wHandler,ax     ;Make sure we use it instead!
DII_NotStdMode:

        ;** Hook as an exception (DPMI)
        mov     ax,0202h                ;Get exception handler - DPMI
        mov     bl,BYTE PTR [si].ii_wNumber ;Interrupt number
        int     31h                     ;Call DPMI
        mov     WORD PTR [si].ii_dwChain,dx ;Save the old offset
        mov     WORD PTR [si].ii_dwChain + 2,cx ;Save the old selector
        mov     ax,0203h                ;Set exception handler - DPMI
        mov     bl,BYTE PTR [si].ii_wNumber ;Interrupt number
        mov     dx,[si].ii_wHandler     ;Address of exception handler
        mov     cx,cs                   ;Selector value of handler
        int     31h                     ;Call DPMI
        jmp     SHORT DII_Continue

        ;** Hook as an interrupt (DOS)
DII_Interrupt:
        mov     ah,35h                  ;Get interrrupt handler - DOS
        mov     al,BYTE PTR [si].ii_wNumber ;Interrupt number
        int     21h                     ;Call DOS
        mov     WORD PTR [si].ii_dwChain,bx ;Save the old offset
        mov     WORD PTR [si].ii_dwChain + 2,es ;Save the old selector
        mov     ah,25h                  ;Set interrupt handler - DOS
        mov     al,BYTE PTR [si].ii_wNumber ;Interrupt number
        mov     dx,[si].ii_wHandler     ;Address of exception handler
        push    ds                      ;Save static DS for later
        push    cs                      ;DS = CS
        pop     ds
        int     21h                     ;Call DOS
        pop     ds                      ;Get segment back

        ;** Prepare for next in table
DII_Continue:
        add     si,SIZE INT_INFO        ;Bump to next entry
        pop     cx                      ;Get loop counter back
        loop    DII_HandlerLoop         ;Loop back

        ;** Prepare the linked list
        mov     npIntHead,0             ;Put a NULL in the list head

        ;** Get information so we can check the GDI flag
        lea     ax,szGDI                ;Get the string
        cCall   GetModuleHandle, <ds,ax> ;Get GDI's module handle
        cCall   HelperHandleToSel, <ax> ;Convert the owner to a selector
        mov     hGDI,ax                 ;Save it for later
        cCall   GetProcAddress, <ax,0,355> ;The flag is ordinal 355
        mov     WORD PTR lpGDIFlag[0],ax ;Save it for later
        mov     WORD PTR lpGDIFlag[2],dx

DII_End:
        ;** Return TRUE
        mov     ax,1
cEnd


;  InterruptUnInit
;       Unhooks all interrupts and exceptions hooked by DebugInterruptUnInit.

cProc   InterruptUnInit, <NEAR,PUBLIC>, <si,di>
cBegin

        ;** Loop through all possible handlers
        mov     cx,MAX_INTERRUPT        ;Number of ints to hook
        lea     si,IntInfo              ;Get the address of the array
DIU_HandlerLoop:
        push    cx                      ;Save loop counter
        cmp     [si].ii_wNumber,256     ;Fake exception?
        jae     DIU_Continue            ;Yes, don't unhook anything!
        cmp     [si].ii_wType,I_EXCEPTION ;Exception?
        jnz     DIU_Interrupt           ;Nope, hook as interrupt

        ;** Unhook exception (DPMI)
        mov     ax,0203h                ;Set exception handler - DPMI
        mov     bl,BYTE PTR [si].ii_wNumber ;Interrupt number
        mov     dx,WORD PTR [si].ii_dwChain ;Put back the old offset
        mov     cx,WORD PTR [si].ii_dwChain + 2 ;Put back the old selector
        int     31h                     ;Call DPMI
        jmp     SHORT DIU_Continue

        ;** Unhook interrupt (DOS)
DIU_Interrupt:
        mov     ah,35h                  ;Get interrrupt handler - DOS
        mov     al,BYTE PTR [si].ii_wNumber ;Interrupt number
        int     21h                     ;Call DOS
        mov     ah,25h                  ;Set interrupt handler - DOS
        mov     al,BYTE PTR [si].ii_wNumber ;Interrupt number
        mov     dx,WORD PTR [si].ii_dwChain ;Put back the old offset
        push    ds
        mov     ds,WORD PTR [si].ii_dwChain + 2 ;Put back the old selector
        int     21h                     ;Call DOS
        pop     ds

        ;** Prepare for next in table
DIU_Continue:
        add     si,SIZE INT_INFO        ;Bump to next entry
        pop     cx                      ;Get loop counter back
        loop    DIU_HandlerLoop         ;Loop back

        ;** Prepare the linked list
        mov     npIntHead,0             ;Put a NULL in the list head

DIU_End:

cEnd

InterruptEntry  MACRO  Name, wBytes
        labelFP Name                    ;;Start at this address
        PUBLIC  Name
        sub     sp,wBytes               ;;Leave room on stack for return val
        push    bx                      ;;Save for the info pointer
ENDM

InterruptJump   MACRO pInfo
        mov     bx,OFFSET pInfo         ;;Point to interrupt info
        jmp     DIH_Main
ENDM

;  InterruptHandler
;       This routine is used to handle interrupts as they come in.  This
;       routine has multiple entry points; a seperate one for each int/
;       exception trapped.   Because interrupts and exceptions have
;       different stack frames, they are handled by two different code
;       sections.

cProc   InterruptHandler, <FAR,PUBLIC>
cBegin  NOGEN

        ;** All interrupt entry points here

        InterruptEntry GP_Handler, 14   ;Normal GP fault
        InterruptJump GP_Info
        InterruptEntry GP_StdModeHandler, 12 ;3.0 Std mode GP fault
        InterruptJump GP_Info
        InterruptEntry SF_Handler, 14   ;Normal Stack Fault
        InterruptJump SF_Info
        InterruptEntry SF_StdModeHandler, 12 ;3.0 Std mode Stack Fault
        InterruptJump SF_Info
        InterruptEntry PF_Handler, 14   ;Page fault
        InterruptJump PF_Info
        InterruptEntry PF_StdModeHandler, 10 ;3.0 Std mode Page fault
        InterruptJump PF_Info
        InterruptEntry UD_Handler, 14   ;Undefined opcode
        InterruptJump UD_Info
        InterruptEntry Int1_Handler, 14 ;Int 1
        InterruptJump Int1_Info
        InterruptEntry Int3_Handler, 14 ;Int 3
        InterruptJump Int3_Info
        InterruptEntry CASRq_Handler, 14 ;Ctrl-Alt-SysRq (not really an int)
        InterruptJump CASRq_Info

        ;** The divide by zero case has to include checking to make sure
        ;**     that this isn't GDI's divide by zero.

        InterruptEntry Div0_Handler, 14

        ;** Check to see if GDI wants this Div0
        push    ds                      ;Save some registers
        push    es
        mov     bx,_DATA                ;Point to our data
        mov     ds,bx                   ;  with DS
        mov     bx,WORD PTR lpGDIFlag[0];Get the low word
        push    bx
        or      bx,WORD PTR lpGDIFlag[2];Do we have a flag to look at?
        pop     bx
        jz      DIH_NoFlag              ;No.  Do this the hard way

        ;** Since we have a pointer to GDI's flag to look at, use it
        mov     es,WORD PTR lpGDIFlag[2];Get the seg value
        cmp     WORD PTR es:[bx],0      ;The flag is nonzero if GDI wants it
        je      DIH_NormalDiv0          ;GDI doesn't want it

        ;** GDI wants the Div0 so chain to it
DIH_ChainToGDI:
        pop     es                      ;Restore registers
        pop     ds                      ;  (Doesn't trash flags)
        push    bp                      ;Make the same stack frame for compat
        mov     bp,sp
        pusha                           ;Save all registers
        push    ds
        push    es
        mov     ax,_DATA                ;Get the data segment
        mov     ds,ax                   ;Point with DS
        mov     bx,OFFSET Div0_Info     ;This fault's info
        jmp     DIH_DPMIChainOn         ;Chain on (ignore the int)

DIH_NormalDiv0:
        pop     es                      ;Restore registers
        pop     ds
        InterruptJump Div0_Info

        ;** We didn't get a GDI flag (only present in 3.1) so instead, we
        ;*      check the owner of the CS where the fault occurred.  If
        ;**     the owner is GDI, we ignore the Div0.
DIH_NoFlag:
        push    bp                      ;Make a stack frame
        mov     bp,sp
        sub     sp,SIZE GLOBALENTRY     ;Make room for a structure
Global  EQU     [bp - SIZE GLOBALENTRY] ;Point to our structure
        pusha                           ;Save all registers
        mov     WORD PTR Global.ge_dwSize[0],SIZE GLOBALENTRY ;Size of struct
        mov     WORD PTR Global.ge_dwSize[2],0
        lea     bx,Global               ;Point to the structure
        test    wTHFlags,TH_WIN30STDMODE ;3.0 std mode?
        jnz     DIH_Div0_StdMode        ;Yes
        mov     ax,[bp + 1ah + 4]       ;Get the CS value (4 is extra BP,BX
        jmp     SHORT @F                ;  pushed by InterruptEntry macro)
DIH_Div0_StdMode:
        mov     ax,[bp + 14h + 4]       ;Get the CS value
@@:     cCall   GlobalEntryHandle, <ss,bx,ax> ;Get info about the CS
        or      ax,ax                   ;Did the call succeed?
        jne     @F                      ;Yes, go on
        popa                            ;No, clear stack frame and do normal
        mov     sp,bp
        pop     bp
        jmp     DIH_NormalDiv0          ;Jump to normal processing
@@:     mov     ax,Global.ge_hOwner     ;Get the owner
        cCall   HelperHandleToSel, <ax> ;Make it a selector
        cmp     hGDI,ax                 ;Is this owned by GDI?
        popa                            ;Restore the registers
        mov     sp,bp                   ;Clear stack frame
        pop     bp
        je      DIH_ChainToGDI          ;Yes, so give the interrupt to it
        jmp     DIH_NormalDiv0          ;No, do normal stuff

        ;** We now have to first find the item on the block to see if we
        ;**     want to handle the interrupt.
PubLabel CommonInterruptEntry
DIH_Main:
        push    bp                      ;Make a stack frame
        mov     bp,sp
        pusha                           ;Save all registers
        push    ds
        push    es

        ;** We check first to see if this was a GP fault received from the
        ;*      parameter validation code.  If it was, we just chain on
        ;*      just as if we don't find any handlers.
        ;**
        mov     ax,_DATA                ;Get our data segment
        mov     ds,ax
        FSTI                             ;Must have interrupts on
        cmp     bx,OFFSET GP_Info       ;GP Fault?
        jnz     DIH_NotPVGPFault        ;No.
        mov     cx,WORD PTR lpfnPV[0]   ;Get the low word
        or      cx,WORD PTR lpfnPV[2]   ;Param Validation stuff present?
        jz      DIH_NotPVGPFault        ;No, skip this

        ;** Check to see if the parameter validation code wants the fault
        push    ds
        push    bx
        push    [bp + 1Ah]              ;Push faulting CS:IP
        push    [bp + 18h]
        call    [lpfnPV]                ;Call it
        pop     bx
        pop     ds
        or      ax,ax                   ;Non-zero means this was PV fault
        je      DIH_NotPVGPFault        ;Not a PV GP fault

        ;** It is a parameter validation fault so ignore it
        jmp     DIH_DPMIChainOn         ;Chain the fault on--we don't want it

        ;** We check here to see if the INT3 we received is from the CASRq
        ;*      handler.  If it was, we have to replace the INT3 with the
        ;*      previous byte and tell the user this was actually a CASRq
        ;**     event (not an INT3).
PubLabel DIH_NotPVGPFault
        cmp     bx,OFFSET Int3_Info     ;INT3?
        jnz     DIH_NotCASRq            ;Nope, ignore all this
        cmp     wCASRqFlag,0            ;Was this because of CASRq?
        je      DIH_NotCASRq            ;No.
        mov     ax,[bp + 12h]           ;INT3 is an IRET frame.  Get bkpt IP
        dec     ax                      ;Breaks AFTER instruction
        cmp     WORD PTR dwCASRqCSIP[0],ax ;Is this the right CASRq address?
        jne     DIH_NotCASRq            ;Nope
        mov     dx,[bp + 14h]           ;Get the breakpoint CS
        cmp     WORD PTR dwCASRqCSIP[2],dx ;Is this correct?
        jne     DIH_NotCASRq            ;Nope
        push    ax                      ;Save the IP value
        cCall   AllocCStoDSAlias, <dx>  ;Get a data alias to the CS
        mov     es,ax                   ;Point with ES
        pop     si                      ;Restore the IP value
        mov     [bp + 12h],si           ;Back to instr where INT3 was
        mov     al,BYTE PTR wCASRqFlag  ;Get the saved byte
        mov     es:[si],al              ;Put it back in the code
        mov     wCASRqFlag,0            ;Clear the flag
        cCall   FreeSelector, <es>      ;Get rid of the alias
        mov     bx,OFFSET CASRq_Info    ;Point to the CASRq information

        ;** See if we have at least one handler.  We should always have one.
PubLabel DIH_NotCASRq
        mov     si,npIntHead            ;Get the list start
        or      si,si                   ;Are there any routines hooked?
        jnz     DIH_Found               ;There should ALWAYS be at least one
                                        ;  routine hooked (otherwise, the
                                        ;  interrupt hooks should have
                                        ;  already been removed)

        ;** Return the stack to its prior state and chain on.
        ;*      We only get here in an erroneous state.  We keep the code in
        ;*      to avoid GP faulting if things get wierd.
        ;*      The stack looks like this:
        ;*              ------------
        ;*              |    ES    |
        ;*              |    DS    |
        ;*              |   PUSHA  |
        ;*         BP-->|  Old BP  |  [BP + 00h]
        ;*              |    BX    |  [BP + 02h]
        ;*              |  Empty   |  [BP + 04h]
        ;*              |  Empty   |  [BP + 06h]
        ;*              |  Empty   |  [BP + 08h]
        ;*              |  Empty   |  [BP + 0Ah]
        ;*              |  Empty   |  [BP + 0Ch]
        ;*              |Our Ret IP|  [BP + 0Eh]
        ;*              |Our Ret CS|  [BP + 10h]
        ;*              |Original  |
        ;*              |  Frame   |
        ;*              |   ....   |
        ;*              ------------
        ;**
PubLabel DIH_DPMIChainOn
        mov     ax,WORD PTR [bx].ii_dwChain ;Get the LOWORD
        mov     [bp + 0eh],ax           ;Put into the frame we created
        mov     ax,WORD PTR [bx].ii_dwChain + 2 ;Get the HIWORD
        mov     [bp + 10h],ax           ;Put into the frame
        pop     es                      ;Clear the stack
        pop     ds
        popa
        pop     bp
        pop     bx
        add     sp,10                   ;Clear extra space
        retf                            ;This uses our own "return" frame
                                        ;  to chain on

        ;** Since we found the entry, we have to call the user callback.
        ;*      Because we must be reentrant at this state, we have to make
        ;*      sure that we're safe.  To do so, we must do different
        ;**     actions for DPMI and for DOS frames.
PubLabel DIH_Found
        cmp     [bx].ii_wType,I_EXCEPTION ;DPMI Exception frame?
        je      @F
        jmp     DIH_SkipDPMI            ;No.  Skip DPMI processing
@@:

        ;** If we are in Win3.0 Std Mode, the DPMI frame was broken.  It
        ;*      simply left the normal IRET frame on the stack *AND* the
        ;**     error code.
        test    wTHFlags,TH_Win30StdMode ;3.0 Std mode?
        jz      @F
        jmp     DIH_SkipDPMI            ;Yes
@@:

        ;** Tell DPMI that the exception is over.  Before we do this,
        ;*      however, save information we'll need later on the user stack.
        ;*      The stack currently looks like this:
        ;*              ------------
        ;*              |    ES    |
        ;*              |    DS    |
        ;*              |   PUSHA  |
        ;*         BP-->|  Old BP  |  [BP + 00h]
        ;*              |    BX    |  [BP + 02h]
        ;*              |  Empty   |  [BP + 04h]
        ;*              |  Empty   |  [BP + 06h]
        ;*              |  Empty   |  [BP + 08h]
        ;*              |  Empty   |  [BP + 0Ah]
        ;*              |  Empty   |  [BP + 0Ch]
        ;*              |  Empty   |  [BP + 0Eh]
        ;*              |  Empty   |  [BP + 10h]
        ;*              |  Ret IP  |  [BP + 12h]    <-
        ;*              |  Ret CS  |  [BP + 14h]      |
        ;*              |Error Code|  [BP + 16h]      | Pushed by DPMI
        ;*              |    IP    |  [BP + 18h]      |
        ;*              |    CS    |  [BP + 1Ah]      | (Locked stack)
        ;*              |   Flags  |  [BP + 1Ch]      |
        ;*              |    SP    |  [BP + 1Eh]      |
        ;*              |    SS    |  [BP + 20h]    <-
        ;*              ------------
        ;*
        ;*      Before returning to DPMI, however, we want to create a
        ;*      stack frame on the user's stack that we will be returning
        ;*      to so we can preserve information in a reentrant fashion.
        ;*      The user's stack will appear like this:
        ;*              ------------
        ;*       BP---->|  Old BP  |  [BP + 00h]
        ;*              |    BX    |  [BP + 02h]
        ;*              |Our Ret IP|  [BP + 04h]
        ;*              |Our Ret CS|  [BP + 06h]
        ;*              |  Ret IP  |  [BP + 08h]
        ;*              |  Ret CS  |  [BP + 0Ah]
        ;*              |    AX    |  [BP + 0Ch]
        ;*              |Exception#|  [BP + 0Eh]
        ;*              |  Handle  |  [BP + 10h]
        ;*              |    IP    |  [BP + 12h]
        ;*              |    CS    |  [BP + 14h]
        ;*              |   Flags  |  [BP + 16h]
        ;*              ------------
        ;**

PubLabel DIH_Exception

        ;** Check to see if we're already on the faulting stack.  If we are,
        ;**     we want to shift everything up on this stack so that we
        ;**     have room for the TOOLHELP user frame
        mov     ax,ss                   ;Get the current SS
	cmp	ax,WORD PTR ss:[bp + 20h] ;Is it the same as the user frame?
	jne	DIH_EnoughRoomOnStack    ;No, ignore all of this

        ;** Move everything up by copy everything that's on stack now to
        ;**     above where SP starts at.  This actually uses too much
        ;**     stack, but it's safe and easy.
	push	bp                      ;We use BP to do copy
	lea	bp,[bp + 20h]           ;Point to lowest WORD to copy
	mov	ax,sp                   ;Point to position to copy to
	dec	ax
	dec	ax
DIH_CopyLoop:
	push	WORD PTR [bp]           ;Copy a WORD
	dec	bp                      ;Point to next WORD to copy
	dec	bp
	cmp	bp,ax                   ;Done yet?
	jne	DIH_CopyLoop            ;No
	pop	bp                      ;Yes, compute new BP value
	sub	bp,56                   ;Point BP to right place

        ;** Put stuff on DPMI's stack
PubLabel DIH_EnoughRoomOnStack
        mov     di,[bp + 1Eh]           ;Get the old SP value
        mov     cx,[bp + 20h]           ;  and the SS value
        cmp     di,MIN_STACK_ALLOWED    ;Are we going to stack fault?
        jb      DIH_BadStack            ;Yes, so swich
        mov     ax,__WinFlags           ;Make sure we have a 386 or higher
        test    ax,WF_CPU286
        jnz     DIH_SkipBigCheck        ;No need to check big bit
.386p
        push    eax                     ;Make sure we don't trash EAX
        lar     eax,ecx                 ;Get the access rights DWORD
        test    eax,00400000h           ;Check the BIG bit
        pop     eax
        jnz     DIH_BadStack            ;Don't use this stack if BIG
.286p
DIH_SkipBigCheck:
        mov     ax,di                   ;Get the stack pointer
        add     ax,2                    ;Point just beyond
        cCall   HelperVerifySeg, <cx,ax> ;Is this seg OK?
        or      ax,ax                   ;Check for success
        jz      DIH_BadStack            ;Stack is bogus, don't change to it

PubLabel DIH_StackOK
        sub     di,20                   ;Reserve space for the user frame
        mov     ds,cx                   ;Get stack value in DS
        mov     dx,[bp + 1Ah]           ;Get the old CS value
        mov     cx,[bp + 18h]           ;Get the old IP value
        mov     ax,[bp + 1Ch]           ;Get the old flags
        mov     [bp + 1Eh],di           ;Save as new SP value
        sub     di,4                    ;Make DI equal to what BP will be
        mov     [bp + 1Ah],cs           ;Prepare to IRET to ourself
        mov     [bp + 18h],OFFSET _TEXT:DIH_DPMIRestart

        ;** Save some things on the user's stack before returning
        mov     [di + 16h],ax           ;Save the flags
        mov     [di + 14h],dx           ;Save the old CS value
        mov     [di + 12h],cx           ;Save the old IP value
        mov     [di + 0Eh],bx           ;INT_INFO pointer to new stack
        mov     [di + 10h],si           ;Handle to new stack

        ;** Clear the Trace and Ints Enabled flags
        and     [bp + 1Ch],NOT 0100h    ;Clear TF.  We don't want to trace here
        pop     es                      ;Clear the DPMI stack
        pop     ds
        popa
        pop     bp
        pop     bx
        add     sp,14                   ;Clear extra allocated space
        retf

        ;** The user stack is bad, so we want to stay on the fault handler
        ;**     stack.  In order to do this, we have to build a frame for
        ;**     the callback directly on the fault handler stack.
        ;**     We build the frame here and jump to it.
        ;**              ------------
        ;**              |    ES    |
        ;**              |    DS    |
        ;**              |   PUSHA  |
        ;**         BP-->|  Old BP  |  [BP + 00h]
        ;**              |    BX    |  [BP + 02h]
        ;**              |  Empty   |  [BP + 04h]
        ;**              |Our Ret IP|  [BP + 06h]   ; Client callback addr
        ;**              |Our Ret CS|  [BP + 08h]
        ;**              |  Ret IP  |  [BP + 0Ah]   ; TOOLHELP restart addr
        ;**              |  Ret CS  |  [BP + 0Ch]
        ;**              |    AX    |  [BP + 0Eh]   ; Saved AX for MPI
        ;**              |Exception#|  [BP + 10h]   ; Exception number
        ;**              |  Handle  |  [BP + 12h]   ; TOOLHELP handle
        ;**              |    IP    |  [BP + 14h]   ; IRET frame of fault
        ;**              |    CS    |  [BP + 16h]
        ;**              |  Flags   |  [BP + 18h]
        ;**              |    SP    |  [BP + 1Ah]   ; Faulting SS:SP
        ;**              |    SS    |  [BP + 1Ch]
        ;**              |  Ret IP  |  [BP + 1Eh]   ; DPMI return address
        ;**              |  Ret CS  |  [BP + 20h]
        ;**              ------------
PubLabel DIH_BadStack
        mov     dx,[bp + 12h]           ;DPMI return CS:IP
        mov     cx,[bp + 14h]           ;  stored in CX:DX
        mov     ax,[bp + 18h]           ;Faulting IP
        mov     [bp + 14h],ax
        mov     ax,[bp + 1Ah]           ;Faulting CS
        mov     [bp + 16h],ax
        mov     ax,[bp + 1Ch]           ;Flags
        mov     [bp + 18h],ax
        mov     ax,[bp + 1Eh]           ;Faulting SP
        mov     [bp + 1Ah],ax
        mov     ax,[bp + 20h]           ;Faulting SS
        mov     [bp + 1Ch],ax
        mov     [bp + 1Eh],dx           ;DPMI ret IP
        mov     [bp + 20h],cx           ;DPMI ret CS
        mov     [bp + 12h],si           ;Point to INTERRUPT struct
        mov     ax,[bx].ii_wNumber      ;Get the interrupt number
        or      ax,BAD_STACK_FLAG       ;Flag the client that stack is bad
        mov     [bp + 10h],ax
        mov     ax,[bp - 02h]           ;Get the AX value from the PUSHA frame
        mov     [bp + 0Eh],ax
        mov     [bp + 0Ch],cs           ;Point to callback return address
        mov     [bp + 0Ah],OFFSET _TEXT:DIH_CallbackRestart
        mov     ax,WORD PTR [si].i_lpfn ;Point to the user callback OFFSET
        mov     [bp + 06h],ax
        mov     ax,WORD PTR [si].i_lpfn + 2 ;Point to callback segment
        mov     [bp + 08h],ax
        pop     es                      ;Clear the stack
        pop     ds
        popa
        pop     bp
        pop     bx
        add     sp,2
        retf                            ;Jump to the user callback

        ;** At this point, DPMI IRETs back to us instead of to the faulting
        ;**      app.  We have to now create a stack frame identical to the
        ;**      frame used by interrupt-style hooks.  Note that we have
        ;**      already allocated the frame space (but not initialized it)
        ;**      before returning to DPMI.
        ;**      It will look like this:
        ;**              ------------
        ;**              |    ES    |  [BP - 14h]
        ;**              |    DS    |  [BP - 12h]
        ;**              |    DI    |  [BP - 10h]
        ;**              |    SI    |  [BP - 0Eh]
        ;**              |    BP    |  [BP - 0Ch]
        ;**              |    SP    |  [BP - 0Ah]
        ;**              |    BX    |  [BP - 08h]
        ;**              |    DX    |  [BP - 06h]
        ;**              |    CX    |  [BP - 04h]
        ;**              |    AX    |  [BP - 02h]
        ;**       BP---->|  Old BP  |  [BP + 00h]
        ;**              |    BX    |  [BP + 02h]
        ;**              |Our Ret IP|  [BP + 04h]
        ;**              |Our Ret CS|  [BP + 06h]
        ;**              |  Ret IP  |  [BP + 08h]
        ;**              |  Ret CS  |  [BP + 0Ah]
        ;**              |    AX    |  [BP + 0Ch]
        ;**              |Exception#|  [BP + 0Eh]
        ;**              |  Handle  |  [BP + 10h]
        ;**              |    IP    |  [BP + 12h]
        ;**              |    CS    |  [BP + 14h]
        ;**              |   Flags  |  [BP + 16h]
        ;**              ------------
        ;**
PubLabel DIH_DPMIRestart
        push    bx                      ;Save this register we're using
        push    bp                      ;Make a stack frame
        mov     bp,sp
        pusha                           ;Save all the registers
        push    ds
        push    es
        mov     bx,[bp + 0Eh]           ;Get the INT_INFO pointer back
        mov     si,[bp + 10h]           ;Get the INTERRUPT structure back
        mov     ax,_DATA                ;Get our data segment
        mov     ds,ax

        ;** We can now proceed with joint processing as we've matched the
        ;**     DOS interrupt frame
PubLabel DIH_SkipDPMI

        ;** Build our return frame and jump to the user callback
        mov     [bp + 10h],si           ;Point to INTERRUPT struct
        mov     ax,[bx].ii_wNumber      ;Get the interrupt number
        mov     [bp + 0Eh],ax           ;Put on frame
        mov     ax,[bp - 02h]           ;Get the AX value from the PUSHA frame
        mov     [bp + 0Ch],ax           ;Put on frame
        mov     [bp + 0Ah],cs           ;Point to callback return address
        mov     [bp + 08h],OFFSET _TEXT:DIH_CallbackRestart
        mov     ax,WORD PTR [si].i_lpfn ;Point to the user callback OFFSET
        mov     [bp + 04h],ax
        mov     ax,WORD PTR [si].i_lpfn + 2 ;Point to callback segment
        mov     [bp + 06h],ax
        pop     es                      ;Clear the stack
        pop     ds
        popa
        pop     bp
        pop     bx
        retf                            ;Jump to the user callback

        ;** When the callback returns, we have to know how to call the
        ;*      next matching callback or to chain on the interrupt list.
        ;*      We have to do a raft of special stuff if this was an
        ;*      exception so that the chained on handlers think it was
        ;**     DPMI that called them.
PubLabel DIH_CallbackRestart
        sub     sp,8                    ;Leave room for ret addresses
        push    bx                      ;For compat. with the above code
        push    bp                      ;Make the same stack frame
        mov     bp,sp
        pusha
        push    ds
        push    es

        ;** Get the next matching item on the list
        mov     ax,_DATA                ;Get our data segment
        mov     ds,ax
        mov     ax,[bp + 0Ch]           ;Get the saved AX value
        mov     [bp - 02h],ax           ;Put in PUSHA frame
        mov     si,[bp + 10h]           ;Get the last handle used
        or      si,si                   ;If NULL, app has messed with it
        jz      DIH_NukeIt              ;Nuke the app--it did a no-no
        mov     si,[si].i_pNext         ;Get the next item in the list
        or      si,si                   ;End of the line?
        jz      DIH_NextNotFound        ;Yes, chain on
        mov     ax,[bp + 0Eh]           ;Get the exception number
        cCall   InterruptInfo           ;Get the INT_INFO structure
        or      ax,ax                   ;If NULL return, user messed with #
        jz      DIH_NukeIt              ;  so nuke it
        mov     bx,ax                   ;Point with BX
        jmp     DIH_SkipDPMI            ;Process this one

        ;** If we don't find a match, we pass on to previous handler
PubLabel DIH_NextNotFound
        mov     ax,[bp + 0Eh]           ;Get the exception number
        and     ax,7fffh                ;Clear the new stack bit
        cCall   InterruptInfo           ;Find the INT_INFO structure
        or      ax,ax                   ;If the user messed with it,
        jz      DIH_NukeIt              ;  nuke the app.
        mov     si,ax                   ;Get the pointer in AX
        test    wTHFlags,TH_Win30StdMode ;3.0 Std mode?
        jnz     DIH_30StdChainOn        ;Always do normal chain on in 3.0sm
        cmp     [si].ii_wType,I_INTERRUPT ;Was this an interrupt?
        je      DIH_ChainOn             ;Yes, do normal chain on
        jmp     DIH_EmulateDPMI         ;No, do the DPMI chain on

PubLabel DIH_NukeIt
        push    [bp + 16h]              ;Copy the IRET frame for KERNEL
        push    [bp + 14h]
        push    [bp + 12h]

        push    0                       ;Nuke current task
        push    UAE_BOX OR GIVE_WDEB386 ;UAE box + give to wdeb
        push    cs                      ;Simulate a far jump
        call    NEAR PTR TerminateApp   ;Nuke the app

        ;** We only get here if WDEB386 is installed.  We tell it to set
        ;*      a breakpoint, then restart the app, in effect giving
        ;*      control to WDEB386.  Unfortunately, at this point, all
        ;**     fault handlers for this task have been removed
        add     sp,6                    ;Clear fake IRET frame
        mov     cx,[bp + 14h]           ;Faulting CS
        mov     bx,[bp + 12h]           ;Faulting IP
        mov     ax, 40h                 ;16 bit forced go command
        int     41h                     ;Call debugger
        pop     es                      ;Restore registers and clear stack
        pop     ds
        popa
        pop     bp
        pop     bx
        add     sp,14                   ;Clear extra words
                                        ;  all that remains is IRET frame
        iret                            ;WDEB386 will get control

PubLabel DIH_NukeApp
        push    0                       ;Nuke current task
        push    UAE_BOX                 ;Draw the UAE box
        push    cs                      ;Simulate a far jump
        call    NEAR PTR TerminateApp   ;Nuke the app
        int     1                       ;Should never return
        jmp     SHORT DIH_ChainOn

        ;** In 3.0 standard mode we have to put an error code on the stack
        ;**     if it's a GP fault or.  If not, we just chain on normally
PubLabel DIH_30StdChainOn
        cmp     si,OFFSET GP_Info       ;Is this a GP fault?
        jne     DIH_ChainOn             ;No, handle normally
        mov     ax,WORD PTR [si].ii_dwChain ;Get the LOWORD
        mov     dx,WORD PTR [si].ii_dwChain + 2 ;Get HIWORD
        mov     bx,ax                   ;Save the LOWORD
        or      ax,dx                   ;Is there a chain on address?
        jz      DIH_NoChainAddr         ;No, just restart the instruction
        mov     [bp + 0Ch],bx           ;Put on stack so we can retf to it
        mov     [bp + 0Eh],dx
        mov     WORD PTR [bp + 10h],0   ;Zero the error code
        pop     es                      ;Restore registers and clear stack
        pop     ds
        popa
        pop     bp
        pop     bx
        add     sp,8                    ;Clear extra words
        retf

PubLabel DIH_ChainOn
        mov     ax,WORD PTR [si].ii_dwChain ;Get the LOWORD
        mov     dx,WORD PTR [si].ii_dwChain + 2 ;Get HIWORD
        mov     bx,ax                   ;Save the LOWORD
        or      ax,dx                   ;Is there a chain on address?
        jz      DIH_NoChainAddr         ;No, just restart the instruction
        mov     [bp + 0Eh],bx           ;Put on stack so we can retf to it
        mov     [bp + 10h],dx
        pop     es                      ;Restore registers and clear stack
        pop     ds
        popa
        pop     bp
        pop     bx
        add     sp,10                   ;Clear extra words
        retf

        ;** No chain on address was recorded so just restart the instruction
PubLabel DIH_NoChainAddr
        pop     es
        pop     ds
        popa
        pop     bp
        pop     bx
        add     sp,14                   ;Clear all extra words
        iret                            ;  and restart instruction

        ;** Chain on a DPMI-style exception:
        ;**
        ;** The goal here is to make a fault frame that appears that DPMI
        ;**     has passed the next exception handler the interrupt.  We
        ;**     have only two important cases here:
        ;**             1) We have already told DPMI the int was finished.
        ;**             2) We have not told DPMI the int was finished and
        ;**                     have not switched off the fault handler stack
        ;**     We handle the cases differently:
        ;**     -If we have already told DPMI that the fault was handled,
        ;**      we have to make a new fault so that the next handler can see
        ;**      the frame.  This can be best accomplished by restarting the
        ;**      faulting instruction.  This will cause the same fault to
        ;**      happen and will make the same frame.
        ;**     -In the case of us still being on the fh stack, we have to
        ;**      rebuild the frame and chain on.
        ;**     The stack we're given looks like this:
        ;**              ------------
        ;**              |    ES    |  [BP - 14h]
        ;**              |    DS    |  [BP - 12h]
        ;**              |    DI    |  [BP - 10h]
        ;**              |    SI    |  [BP - 0Eh]
        ;**              |    BP    |  [BP - 0Ch]
        ;**              |    SP    |  [BP - 0Ah]
        ;**              |    BX    |  [BP - 08h]
        ;**              |    DX    |  [BP - 06h]
        ;**              |    CX    |  [BP - 04h]
        ;**              |    AX    |  [BP - 02h]
        ;**       BP---->|  Old BP  |  [BP + 00h]
        ;**              |    BX    |  [BP + 02h]
        ;**              |Our Ret IP|  [BP + 04h]
        ;**              |Our Ret CS|  [BP + 06h]
        ;**              |  Ret IP  |  [BP + 08h]
        ;**              |  Ret CS  |  [BP + 0Ah]
        ;**              |    AX    |  [BP + 0Ch]
        ;**              |Exception#|  [BP + 0Eh]
        ;**              |  Handle  |  [BP + 10h]
        ;**              |    IP    |  [BP + 12h]
        ;**              |    CS    |  [BP + 14h]
        ;**              |   Flags  |  [BP + 16h]
        ;**              |    SP    |  [BP + 18h]   ;Only here if on fh stack
        ;**              |    SS    |  [BP + 1Ah]
        ;**              |  Ret IP  |  [BP + 1Ch]   ;DPMI return address
        ;**              |  Ret CS  |  [BP + 1Eh]
        ;**              ------------
PubLabel DIH_EmulateDPMI
        mov     ax,[bp + 0Eh]           ;Get the exception number
        test    ax,BAD_STACK_FLAG       ;Still on fh stack?
        jnz     DIH_RebuildDPMIFrame    ;Yes, rebuild the frame

        ;** Rehook the exception so we're sure to get it first
        push    si                      ;Preserve handle
        mov     bx,ax                   ;Fault number in bx
        mov     wException,bx           ;Save as a static also
        mov     ax,0202h                ;Get exception handler - DPMI
        int     31h                     ;Call DPMI
        mov     WORD PTR lpOldHandler[0],dx ;Save the old exception handler
        mov     WORD PTR lpOldHandler[2],cx
        mov     ax,0203h                ;Set exception handler - DPMI
        mov     dx,OFFSET DIH_EmDPMIRestart
        mov     cx,cs                   ;Selector value of handler
        int     31h                     ;Call DPMI
        pop     si

        ;** Save the address of the next exception handler
        mov     ax,WORD PTR [si].ii_dwChain[0] ;Address to chain fault to
        mov     WORD PTR lpChainCSIP[0],ax
        mov     ax,WORD PTR [si].ii_dwChain[2]
        mov     WORD PTR lpChainCSIP[2],ax

        ;** Restart the instruction.  This will fault and jump to our
        ;**     newly-established handler at DIH_EmDPMIRestart
        pop     es
        pop     ds
        popa
        pop     bp
        pop     bx
        add     sp,14                   ;Clear all extra words
        iret                            ;  and restart instruction

        ;** Now we're on the fault handler stack with a DPMI frame.  Throw
        ;**     it to the next handler on the chain
PubLabel DIH_EmDPMIRestart
        sub     sp,4                    ;Enough room for a RETF frame
        push    bp
        mov     bp,sp
        pusha
        push    ds
        push    es
        mov     ax,_DATA                ;Point to TOOLHELP's DS
        mov     ds,ax

        ;** Restore the exception handler
        mov     ax,0203h                ;Set exception handler - DPMI
        mov     bx,wException           ;Get exception number
        mov     dx,WORD PTR lpOldHandler[0] ;Get the exception handler address
        mov     cx,WORD PTR lpOldHandler[2]
        int     31h                     ;Call DPMI

        ;** Put the chain address on the stack so we can return to it
        mov     ax,WORD PTR lpChainCSIP[0] ;Get chain address
        mov     [bp + 02h],ax
        mov     ax,WORD PTR lpChainCSIP[2]
        mov     [bp + 04h],ax

        ;** Restore registers and jump to the handler
        pop     es
        pop     ds
        popa
        pop     bp
        retf

        ;** Since we are already on the fault handler stack, there is no
        ;**     need to fault again.  All we have to do here is recreate the
        ;**     DPMI fault stack as if the fault had just occurred.  It would
        ;**     be nice to clear the exception and then make it fault again,
        ;**     but since we only get here in potentially stack-faulting
        ;**     conditions, we cannot do this.  We just build a reasonable
        ;**     facsimile of the frame and chain on.  This frame should
        ;**     look as follows when we're done:
        ;**              ------------
        ;**              |    ES    |  [BP - 14h]
        ;**              |    DS    |  [BP - 12h]
        ;**              |    DI    |  [BP - 10h]
        ;**              |    SI    |  [BP - 0Eh]
        ;**              |    BP    |  [BP - 0Ch]
        ;**              |    SP    |  [BP - 0Ah]
        ;**              |    BX    |  [BP - 08h]
        ;**              |    DX    |  [BP - 06h]
        ;**              |    CX    |  [BP - 04h]
        ;**              |    AX    |  [BP - 02h]
        ;**       BP---->|  Old BP  |  [BP + 00h]
        ;**              |    BX    |  [BP + 02h]
        ;**              |   Empty  |  [BP + 04h]
        ;**              |   Empty  |  [BP + 06h]
        ;**              |   Empty  |  [BP + 08h]
        ;**              |   Empty  |  [BP + 0Ah]
        ;**              | Chain IP |  [BP + 0Ch]
        ;**              | Chain CS |  [BP + 0Eh]
        ;**              |  Ret IP  |  [BP + 10h]
        ;**              |  Ret CS  |  [BP + 12h]
        ;**              |Error Code|  [BP + 14h]   ;Always return zero
        ;**              |    IP    |  [BP + 16h]
        ;**              |    CS    |  [BP + 18h]   ;Only here if on fh stack
        ;**              |   Flags  |  [BP + 1Ah]
        ;**              |    SP    |  [BP + 1Ch]   ;DPMI return address
        ;**              |    SS    |  [BP + 1Eh]
        ;**              ------------

PubLabel DIH_RebuildDPMIFrame
        mov     dx,[bp + 1Ch]           ;DPMI return CS:IP
        mov     cx,[bp + 1Eh]           ;  stored in CX:DX
        mov     ax,[bp + 1Ah]           ;Faulting SS
        mov     [bp + 1Eh],ax
        mov     ax,[bp + 18h]           ;Faulting SP
        mov     [bp + 1Ch],ax
        mov     ax,[bp + 16h]           ;Flags
        mov     [bp + 1Ah],ax
        mov     ax,[bp + 14h]           ;Faulting CS
        mov     [bp + 18h],ax
        mov     ax,[bp + 12h]           ;Faulting IP
        mov     [bp + 16h],ax
        xor     ax,ax                   ;Error code
        mov     [bp + 14h],ax
        mov     [bp + 12h],cx           ;DPMI ret CS
        mov     [bp + 10h],dx           ;DPMI ret IP
        mov     ax,WORD PTR [si].ii_dwChain[2] ;Address to chain fault to
        mov     [bp + 0Eh],ax
        mov     ax,WORD PTR [si].ii_dwChain[0]
        mov     [bp + 0Ch],ax
        pop     es
        pop     ds
        popa
        pop     bp
        pop     bx
        add     sp,8                    ;Clear all extra words
        retf

cEnd    NOGEN


;** Helper functions

;  InterruptInfo
;       Gets a pointer to the INT_INFO structure given the interrupt
;       number.  Accepts the int number in AX and returns the pointer in AX.
;       Preserves all other registers

cProc   InterruptInfo, <NEAR,PUBLIC>, <si,cx>
cBegin
        ;** Loop through all possible handlers
        mov     cx,MAX_INTERRUPT + 1    ;Number of ints to hook
        lea     si,IntInfo              ;Get the address of the array

        ;** Is this a match?
II_HandlerLoop:
        cmp     [si].ii_wNumber,ax      ;Match?
        jz      II_End                  ;Yes, return the pointer

        ;** Prepare for next in table
II_Continue:
        add     si,SIZE INT_INFO        ;Bump to next entry
        loop    II_HandlerLoop          ;Loop back
        xor     si,si                   ;Return NULL for not found

II_End:
        mov     ax,si                   ;Get return value
cEnd

sEnd

        END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\toolhelp\dllentry.asm ===
PAGE,132
;***************************************************************************
;*
;*   DLLENTRY.ASM
;*
;*      TOOLHELP.DLL Entry code
;*
;*      This module generates a code segment called INIT_TEXT.
;*      It initializes the local heap if one exists and then calls
;*      the C routine LibMain() which should have the form:
;*      BOOL FAR PASCAL LibMain(HANDLE hInstance,
;*                              WORD   wDataSeg,
;*                              WORD   cbHeap,
;*                              LPSTR  lpszCmdLine);
;*        
;*      The result of the call to LibMain is returned to Windows.
;*      The C routine should return TRUE if it completes initialization
;*      successfully, FALSE if some error occurs.
;*
;**************************************************************************

        INCLUDE TOOLPRIV.INC

extrn LocalInit:FAR
extrn GlobalUnwire:FAR

sBegin  CODE
        assumes CS,CODE

externNP ToolHelpLibMain
externNP HelperReleaseSelector
externNP NotifyUnInit
externNP InterruptUnInit

?PLM=0
externA  <_acrtused>             ;Ensures that Win DLL startup code is linked
?PLM=1


;  LibEntry
;
;       KERNEL calls this when the TOOLHELP is loaded the first time

cProc   LibEntry, <PUBLIC,FAR>
cBegin
        push    di               ;Handle of the module instance
        push    ds               ;Library data segment
        push    cx               ;Heap size
        push    es               ;Command line segment
        push    si               ;Command line offset

        ;** If we have some heap then initialize it
        jcxz    callc            ;Jump if no heap specified

        ;** Call the Windows function LocalInit() to set up the heap
        ;**     LocalInit((LPSTR)start, WORD cbHeap);
        xor     ax,ax
        cCall   LocalInit <ds, ax, cx>
        or      ax,ax            ;Did it do it ok ?
        jz      error            ;Quit if it failed

        ;** Invoke our initialization routine
callc:
        call    ToolHelpLibMain  ;Invoke the 'C' routine (result in AX)
        jmp     SHORT exit

error:
        pop     si               ;Clean up stack on a LocalInit error
        pop     es               
        pop     cx               
        pop     ds
        pop     di
exit:

cEnd

;  WEP
;      Windows Exit Procedure

cProc   WEP, <FAR,PUBLIC>, <si,di,ds>
        parmW   wState
cBegin
        ;** Make sure our DS is safe
        mov     ax,_DATA        ;Get the DS value
        lar     cx,ax           ;Is it OK?
        jz      @F
        jmp     SHORT WEP_Bad   ;No
@@:     and     cx,8a00h        ;Clear all but P, Code/Data, R/W bits
        cmp     cx,8200h        ;Is it P, R/W, Code/Data?
        jne     WEP_Bad         ;No
        mov     ax,_DATA        ;Get our DS now
        mov     ds,ax

        ;** Uninstall the Register PTrace notifications if necessary
        cmp     wNotifyInstalled,0
        jz      @F
        cCall   NotifyUnInit
@@:
        ;** Release fault handlers
        cmp     wIntInstalled,0
        jz      @F
        cCall   InterruptUnInit
@@:
        ;** Release our roving selector
        test    wTHFlags, TH_WIN30STDMODE
        jz      @F
        cCall   HelperReleaseSelector, <wSel>
@@:

WEP_Bad:
        mov     ax,1
cEnd

sEnd

        END LibEntry
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\toolhelp\helper.asm ===
;**************************************************************************
;*  HELPER.ASM
;*
;*      Assembly routines used by more than one module
;*
;**************************************************************************

        INCLUDE TOOLPRIV.INC
        INCLUDE WINDOWS.INC
PMODE32 = 0
PMODE   = 1
SWAPPRO = 0
        INCLUDE WINKERN.INC
        INCLUDE NEWEXE.INC
        INCLUDE TDB.INC

;** External functions
externNP Walk386VerifyLocHeap
externNP Walk286VerifyLocHeap
externFP GetCurrentTask
externFP InterruptUnRegister
externFP NotifyUnRegister
externNP SignalUnRegister
externFP TaskFirst
externFP TaskNext

;** Functions

sBegin  CODE
        assumes CS,CODE

.286p

;  HelperVerifySeg
;
;       Verifies that a selector is valid and that the segment it points
;       to is safe for reading out to wcb bytes offset
;       Returns 0 if too short or the length of the segment.
;       Preserves all used registers except the return value, AX

cProc   HelperVerifySeg, <PUBLIC,NEAR>, <dx>
        parmW   wSeg
        parmW   wcb
cBegin
        ;** Verify that this is a valid selector and that it is long enough
        cCall   HelperSegLen, <wSeg>    ;Check the segment
        or      dx,dx                   ;>64K?  If so, always return OK
        jnz     HVS_End
        cmp     ax,wcb                  ;Long enough?
        ja      HVS_End                 ;Yes, return the length
HVS_Bad:
        xor     ax,ax                   ;No.  Return FALSE
HVS_End:
cEnd


;  HelperHandleToSel
;       Converts a handle to a selector.  This routine knows how to
;       handle 3.0 and 3.1 differences as well as 286 & 386 differences.

cProc   HelperHandleToSel, <NEAR,PUBLIC>, <ds>
        parmW   h                       ;Handle
cBegin
        mov     ax,_DATA                ;Get the data segment
        mov     ds,ax                   ;Point with DS
        mov     ax,h                    ;Get the handle
        test    wTHFlags,TH_WIN30       ;Win3.0?
        jz      HTS_Win31               ;No
        test    ax,1                    ;Check the low bit
        jnz     HTS_End                 ;It's already a selector
        dec     ax                      ;Decrement for proper selector
        jmp     SHORT HTS_End           ;Out of here

HTS_Win31:
        or      ax,1                    ;Set the bit

HTS_End:

cEnd


;  HelperVerifyLocHeap
;
;       Uses the processor-specific local heap verify routine to check the
;       validity of a local heap.
;
;       Call:
;               AX = Block handle or selector
;               DS must point to TOOLHELP's DGROUP
;       Return:
;               Carry flag set iff NOT a local heap segment
;
;       Destroys all registers except AX, ESI, EDI, DS, and ES

HelperVerifyLocHeap PROC Near
        PUBLIC  HelperVerifyLocHeap

        test    wTHFlags,TH_KERNEL_386  ;Are we using KRNL386?
        jz      HVL_286                 ;No
        jmp     Walk386VerifyLocHeap    ;Jump to the 386 routine

HVL_286:
        jmp     Walk286VerifyLocHeap    ;Jump to the 286 routine

HVL_End:
        ret

HelperVerifyLocHeap ENDP


;  HelperGlobalType
;
;       Given data about a block, gropes around trying to decipher the
;       block type.  Parameters are passed and returned in the GLOBALENTRY
;       structure.

cProc   HelperGlobalType, <PUBLIC,NEAR>, <si,di,ds>
        parmD   lpGlobal
        localV  Task,<SIZE TASKENTRY>
cBegin
        lds     si,lpGlobal             ;Get the pointer
        mov     [si].ge_wData,0         ;Clear the wData field
                                        ;  Zero's not a valid seg # or type #

        ;** Check for internal block types
        mov     bx,[si].ge_hOwner       ;Get the owner handle
        mov     ax,GT_SENTINEL          ;Just in case...
        cmp     bx,GA_SENTINAL          ;Is this a sentinel?
        jz      HGT_JmpEnd              ;Yes, get out
        mov     ax,GT_BURGERMASTER      ;Just in case...
        cmp     bx,GT_BURGERMASTER      ;Burgermaster?
        jz      HGT_JmpEnd              ;Yes, get out
        cmp     bx,-7                   ;Lowest number reserved
        jb      HGT_0                   ;Not an internal block
        mov     ax,GT_INTERNAL          ;Internal KERNEL block type
HGT_JmpEnd:
        jmp     HGT_End                 ;Get out
HGT_0:

        ;** Check for a free block
        or      bx,bx                   ;Check for 0:  Free block
        jnz     HGT_2                   ;Not zero
        mov     ax,GT_FREE              ;Free blocks have zero owner
        jmp     HGT_End                 ;Unknown type
HGT_2:

        ;** Check for DGROUP and other data segments
        mov     ax,[si].ge_wFlags       ;Get the block flags
        test    ax,GAH_DGROUP           ;Is this a DGROUP segment
        jnz     @F
        jmp     HGT_10                  ;Didn't find it so continue
@@:

        ;** Save the segment number of the segment
        mov     ax,[si].ge_hOwner       ;Get the module database
        push    ax                      ;Save for later
        mov     bx,[si].ge_hBlock       ;Get the handle
        cCall   HelperGetSegNumber      ;Get the segment number
        mov     [si].ge_wData,ax        ;Save the segment number
        pop     bx                      ;Get hExe back in BX

        ;** Try two methods:  First, see if it is the hInst of the FIRST
        ;**     instance of its module
        lsl     cx, bx                  ;Is this segment OK?
        jnz     HGT_5                   ;No, punt and call it unknown data
        cmp     cx, ne_pautodata        ;Long enough?
        jbe     HGT_5                   ;No, get out
        mov     es,bx                   ;Point with ES
        cmp     es:[ne_magic],NEMAGIC   ;Make sure we have a module database
        jnz     HGT_5                   ;It isn't so get out
        mov     bx,es:[ne_pautodata]    ;Point to the segment table entry
        or      bx,bx                   ;Is there a DGROUP segment?
        jz      HGT_5                   ;No, flag as unknown data
        mov     ax,es:[bx].ns_handle    ;Get the handle from the table
        cmp     ax,[si].ge_hBlock       ;Does the DGROUP handle point here?
        jnz     HGT_3                   ;No, might be multiple instance
        mov     ax,GT_DGROUP            ;Matches, must be DGROUP
        jmp     HGT_End                 ;Get out
HGT_3:
        ;** It's not the first instance of this module.
        ;**     All multiple instance things will be on the task list
        ;**     so try to find it there.
        mov     bx,[si].ge_hBlock       ;Get the handle
        cCall   HelperHandleToSel,<bx>  ;Get the selector for this
        mov     di,ax                   ;Save in DI
        mov     ax,SIZE TASKENTRY       ;Get the struct size
        mov     WORD PTR Task.te_dwSize[0],ax ;Put in struct
        mov     WORD PTR Task.te_dwSize[2],0 ;Clear high word
        lea     ax,Task                 ;Get the structure
        cCall   TaskFirst, <ss,ax>      ;Get the first task's info
        or      ax,ax                   ;No tasks?
        jz      HGT_5                   ;Just call it data (not DGROUP)
HGT_TaskLoop:
        mov     ax,Task.te_hInst        ;Get this task's hInst
        cCall   HelperHandleToSel, <ax> ;Convert to selector
        cmp     ax,di                   ;Is this a match?
        je      HGT_TaskFound           ;Yes, do it
        lea     ax,Task                 ;Point to the struct
        cCall   TaskNext, <ss,ax>       ;Get the next one
        or      ax,ax                   ;End of the line?
        jnz     HGT_TaskLoop            ;Nope, do the next one
HGT_5:  mov     ax,GT_DATA              ;Unknown data segment
        jmp     HGT_End                 ;Get out
HGT_TaskFound:
        mov     ax,GT_DGROUP            ;Matches, must be DGROUP
        jmp     HGT_End                 ;Get out
HGT_10:

        ;** Check for a task database
        mov     ax,[si].ge_hBlock       ;Get the segment
        mov     bx,TDBSize              ;Get the limit to verify
        push    ax                      ;Save the segment
        cCall   HelperVerifySeg <ax,bx> ;Make sure we can check signature
        pop     bx                      ;Retrieve the segment value
        or      ax,ax                   ;Zero return means bad
        jz      HGT_20                  ;Not a task database
        mov     es,bx                   ;Point to the segment
        cmp     es:[TDB_sig],TDB_SIGNATURE ;Is this really a TDB?
        jnz     HGT_20                  ;Nope, go on
        mov     ax,GT_TASK              ;Set the task flag
        jmp     HGT_End                 ;Get out
HGT_20:

        ;** Now check for Module database
        mov     ax,[si].ge_hOwner       ;Get the owner handle
        cCall   HelperHandleToSel, <ax> ;Convert to selector for compare
        mov     cx,ax                   ;Save in CX
        mov     ax,[si].ge_hBlock       ;Does this block own itself?
        cCall   HelperHandleToSel, <ax> ;Convert to selector for compare
        cmp     ax,cx                   ;Do the pointers match?
        jnz     HGT_24                  ;No, so it's not a module database
        mov     ax,GT_MODULE            ;Set type
        jmp     HGT_End                 ;Get out
HGT_24:

        ;** Check for a code segment.  If found, return segment number
        mov     ax,[si].ge_hOwner       ;Get the module database
        push    ax                      ;Save the selector
        cCall   HelperVerifySeg <ax,2>  ;Make sure this is OK to put in ES
        pop     bx                      ;Retrieve in BX
        or      ax,ax                   ;Zero means bad
        jnz     @F
        jmp     SHORT HGT_Unknown
@@:     mov     es,bx                   ;Point with ES
        xor     dx,dx                   ;Use DX to count segments
        cmp     es:[ne_magic],NEMAGIC   ;Make sure we have a module database
        jz      HGT_25                  ;Looks good
        jmp     SHORT HGT_40            ;Not code or resource, try next
HGT_25: mov     cx,es:[ne_cseg]         ;Get max number of segments
        jcxz    HGT_30                  ;No segments
        mov     di,es:[ne_segtab]       ;Point to the segment table
        mov     bx,[si].ge_hBlock       ;Get the block we're looking for
HGT_SegLoop:
        inc     dx                      ;Bump the segment number
        cmp     bx,es:[di].ns_handle    ;Is this the correct segment entry?
        jz      HGT_27                  ;Yes, get out
        add     di,SIZE new_seg1        ;Bump to next entry
        loop    HGT_SegLoop             ;Loop back to check next entry
        jmp     SHORT HGT_30            ;Now check resources
HGT_27:
        mov     [si].ge_wData,dx        ;Save the segment count
        mov     ax,GT_CODE              ;Flag that it's a code segment
        jmp     SHORT HGT_End           ;Get out

        ;** Check to see if it's a resource.  If so, return resource type #
HGT_30: mov     di,es:[ne_rsrctab]      ;Point to the resource table
        cmp     di,es:[ne_restab]       ;If both point to same place, no rsrc
        jz      HGT_40                  ;No resource table -- unknown type
        add     di,2                    ;Skip past alignment count
HGT_TypeLoop:
        mov     dx,es:[di].rt_id        ;DX holds current type number
        or      dx,dx                   ;Zero type means end of res table
        jz      HGT_40                  ;Not found so get out!
        mov     cx,es:[di].rt_nres      ;Get the number of resources
        add     di,SIZE RSRC_TYPEINFO   ;Bump past the structure
HGT_ResLoop:
        cmp     bx,es:[di].rn_handle    ;Is it this resource?
        jz      HGT_FoundRes            ;Yep.  This is the one
        add     di,SIZE RSRC_NAMEINFO   ;Bump past this structure
        loop    HGT_ResLoop             ;Loop for next resource structure
        jmp     HGT_TypeLoop            ;Try the next type

        ;** Found the resource, now compute the resource type
HGT_FoundRes:
        test    dx,RSORDID              ;If this bit set, must be ordinal type
        jnz     HGT_32                  ;Yep.  Ordinal
        mov     dx,GD_USERDEFINED       ;Named resources are all user-def
HGT_32: and     dx,NOT RSORDID          ;Clear the flag bit
        cmp     dx,GD_MAX_RESOURCE      ;If the type is too big, it's user-def
        jbe     HGT_34                  ;Standard type
        mov     dx,GD_USERDEFINED       ;User-defined resource type
HGT_34: mov     [si].ge_wData,dx        ;Save the type
        mov     ax,GT_RESOURCE          ;Return that it's a resource
        jmp     SHORT HGT_End           ;Get out

HGT_40:
HGT_Unknown:
        mov     ax,GT_UNKNOWN           ;Unknown type
HGT_End:
        mov     [si].ge_wType,ax        ;Save the type and exit
cEnd


;  HelperGrabSelector
;
;       Allocates a selector from DPMI.

cProc   HelperGrabSelector, <NEAR,PUBLIC>
cBegin
        xor     ax,ax                   ;DPMI Function 0, allocate LDT sels
        mov     cx,1                    ;Just 1 sel
        int     31h                     ;Call DPMI.  Selector in AX
cEnd


;  HelperReleaseSelector
;
;       Frees a selector to DPMI

cProc   HelperReleaseSelector, <NEAR,PUBLIC>
        parmW   wSelector
cBegin
        mov     ax,1                    ;DPMI function 1, free LDT sels
        mov     bx,wSelector            ;Get the sel
        int     31h                     ;Free it
cEnd

;  HelperSetSignalProc
;       Puts a signal proc in a task's TDB so that it gets called in place
;       of USER's proc.  Returns the old USER proc.

cProc   HelperSetSignalProc, <NEAR,PUBLIC>, <si,di>
        parmW   hTask,
        parmD   lpfn
cBegin
        ;** Point to the TDB
        mov     es,hTask                ;Point with ES

        ;** Swap the new with the old and return the old one
        mov     ax,WORD PTR lpfn        ;Get the new signal proc
        xchg    ax,WORD PTR es:[TDB_USignalProc] ;Switch with the old one
        mov     dx,WORD PTR lpfn + 2    ;Get HIWORD
        xchg    dx,WORD PTR es:[TDB_USignalProc + 2] ;Switch with old one
cEnd


;  HelperSignalProc
;       Cleans up when a TOOLHELP-using app is terminated.  This proc
;       MUST chain on to USER's signal proc.  Note that action is only taken
;       on the death signal (BX = 0666h)

cProc   HelperSignalProc, <FAR,PUBLIC>
cBegin  NOGEN
        
        ;** Save all registers
        sub     sp,4
        push    bp
        mov     bp,sp                   ;Make a stack frame
        pusha
        push    ds
        push    es

        ;** Get a pointer to the correct SIGNAL structure
        mov     ax,_DATA                ;Get the TOOLHELP.DLL DS
        mov     ds,ax                   ;Point with DS
        cCall   GetCurrentTask          ;Get the current task in AX
        mov     di,ax                   ;Save task in DI
        mov     si,npSignalHead         ;Get the first struct
HSP_SigLoop:
        or      si,si                   ;End of the list?
        jz      HSP_Return              ;Yes -- This is bad!!
        cmp     di,[si].si_hTask        ;Task match?
        je      HSP_FoundIt             ;Yes
        mov     si,[si].si_pNext        ;Get the next one
        jmp     HSP_SigLoop             ;Loop around
        
        ;** Compute the fake return address (old signal proc)
HSP_FoundIt:
        mov     ax,WORD PTR [si].si_lpfnOld ;Get LOWORD of old proc
        mov     [bp + 2],ax             ;Put on stack frame
        mov     dx,WORD PTR [si].si_lpfnOld + 2 ;Get HIWORD of old proc
        mov     [bp + 4],dx             ;Put on stack frame

        ;** See if we have the death signal.  If not, don't do anything
        ;**     but just chain on.  20h is the signal for task exit
        cmp     bx, 20h                 ;Is this the death signal?
        jne     HSP_Done                ;No.  Don't cleanup

        ;** Since we have a death signal, use it to clean up everything
        push    ax                      ;Save the return address
        push    dx
        cCall   InterruptUnRegister, <di> ;Unregister any interrupt callbacks
        cCall   NotifyUnRegister, <di>  ;Unregister any notification callbacks
        cCall   SignalUnRegister, <di>  ;Unregister any signal callbacks

        ;** If we have fooled with the LRU lock (we only do this on 286
        ;**     machines), we must force it unlocked.
        cmp     wLRUCount, 0            ;Is it set?
        je      HSP_NoLRUFoolingAround  ;No, don't mess with this
        mov     es, hMaster             ;Point to GlobalInfo struct
        mov     ax, es:[gi_lrulock]     ;Get current lock count
        sub     ax, wLRUCount           ;Get rid of the amount we messed it up
        jns     @F                      ;Result is OK--no underflow
        xor     ax, ax                  ;We don't like negative, so zero it
@@:     mov     es:[gi_lrulock], ax     ;Save the result
        mov     wLRUCount, 0            ;No more LRU count
HSP_NoLRUFoolingAround:
        pop     dx
        pop     ax

        ;** Make sure we have a proc to chain to
HSP_Done:
        or      ax,dx                   ;NULL pointer?
        jz      HSP_Return              ;Yes, don't chain to this one

HSP_ChainOn:
        pop     es
        pop     ds
        popa
        pop     bp
        retf                            ;Jump to next signal proc

HSP_Return:
        pop     es
        pop     ds
        popa
        pop     bp
        add     sp,4                    ;Clear fake return address
        retf    10                      ;Return to signal caller

cEnd    NOGEN


;  HelperSegLen
;       Gets the length of a segment, regardless whether it is a 286 or
;       386 segment.
;       Returns the DWORD length of the segment or zero on error.
;       Doesn't trash registers except DX:AX

cProc   HelperSegLen, <NEAR,PUBLIC>, <si,di,cx>
        parmW   wSeg
cBegin
        ;** Make sure the segment is present
        mov     cx,wSeg                 ;Get the selector
        lar     ax,cx                   ;Get the access rights
        jnz     HSL_Bad                 ;If LAR fails, this is bad
        test    ax,8000h                ;Is this segment present?
        jz      HSL_Bad                 ;No, call it bad
        
        ;** Do different stuff on 286 and 386/486
        mov     ax,__WinFlags           ;Get the flags
        test    ax,WF_CPU286            ;286?
        jnz     HSL_Do286               ;Yes, do 16 bit stuff

        ;** Get the 32 bit length
.386p
        lsl     eax,ecx                 ;Get the limit
        jnz     SHORT HSL_Bad           ;We have an error
        mov     edx,eax                 ;Get HIWORD in DX
        shr     edx,16
        jmp     SHORT HSL_End           ;Done
.286p

        ;** Get the 16 bit length
HSL_Do286:
        xor     dx,dx                   ;286 never has >64K segs
        lsl     ax,cx                   ;Get the limit
        jnz     HSL_Bad                 ;Bad if LSL fails
        jmp     SHORT HSL_End           ;Done

HSL_Bad:
        xor     ax,ax                   ;Zero return value
        xor     dx,dx

HSL_End:

cEnd

;  HelperGetSegNumber
;
;       Returns the segment number corresponding to a selector given the
;       hExe.
;
;       Caller:  AX=hExe, BX=Handle
;       Exit:  AX=Seg Number or 0

cProc   HelperGetSegNumber, <NEAR,PUBLIC>, <di>
cBegin
        lsl     cx, ax                  ;Is the segment OK to load?
        jnz     HGSN_Error              ;No, don't do it
        cmp     cx, ne_segtab           ;Long enough?
        jbe     HGSN_Error              ;No
        mov     es,ax                   ;Point with ES
        xor     dx,dx                   ;Use DX to count segments
        cmp     es:[ne_magic],NEMAGIC   ;Make sure we have an hExe
        jnz     HGSN_Error              ;Nope, get out
        mov     cx,es:[ne_cseg]         ;Get max number of segments
        jcxz    HGSN_Error              ;No segments
        mov     di,es:[ne_segtab]       ;Point to the segment table
HGSN_SegLoop:
        inc     dx                      ;Bump the segment number
        cmp     bx,es:[di].ns_handle    ;Is this the correct segment entry?
        je      HGSN_FoundIt            ;Yes, get out
        add     di,SIZE new_seg1        ;Bump to next entry
        loop    HGSN_SegLoop            ;Loop back to check next entry
        jmp     SHORT HGSN_Error        ;Not found

HGSN_FoundIt:
        mov     ax,dx                   ;Get segment number
        jmp     SHORT HGSN_End

HGSN_Error:
        xor     ax,ax                   ;Error return
        
HGSN_End:
cEnd

;** Internal helper functions

;  HelperPDBtoTDB
;
;       Takes a PDB handle and finds the task handle associated with it.
;       Caller:  AX = PDB Handle
;       Return:  AX = TDB handle or zero if no TDB exists for it

cProc   HelperPDBtoTDB, <NEAR,PUBLIC>
cBegin
        ;** Point to the first TDB
        mov     dx,_DATA                ;Get the library static segment
        mov     es,dx                   ;Point with ES
        mov     bx,es:[npwTDBHead]      ;Get pointer to first TDB
        mov     dx,es:[segKernel]       ;Get the KERNEL data segment
        mov     es,dx                   ;Point with ES
        mov     dx,es:[bx]              ;Get the first TDB

        ;** Check this TDB's PDB to see if it matches
PT_Loop:
        mov     es,dx                   ;Get the TDB segment
        cmp     ax,es:[TDB_PDB]         ;Compare PDB pointers
        jz      PT_Found                ;This is it
        mov     dx,es:[TDB_next]        ;Get the next TDB
        or      dx,dx                   ;End of the line?
        jnz     PT_Loop                 ;Nope, loop back
        xor     ax,ax                   ;Return NULL'
        jmp     SHORT PT_End            ;Outta here

PT_Found:
        mov     ax,es                   ;Save the found value
PT_End:

cEnd

sEnd

        END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\toolhelp\krnlpeek.asm ===
;***************************************************************************
;*  KRNLPEEK.ASM
;*
;*      Assembly code used to peer into the heart of KERNEL and return
;*      information in global variables.
;*
;***************************************************************************

        INCLUDE TOOLPRIV.INC            ;Include the TOOLHELP values
PMODE32 = 0                             ;This should work either way
PMODE   = 0
        INCLUDE WINKERN.INC
        INCLUDE WINDOWS.INC

;** Functions
externFP GlobalMasterHandle
externFP GlobalLock
externFP GetVersion
externFP GetProcAddress
externFP GetModuleHandle
externNP HelperHandleToSel

sBegin	DATA
externB	_szKernel
sEnd	DATA
;** Functions

sBegin  CODE
        assumes CS,CODE

;  void KernelType(void)
;
;       Returns information from KERNEL in global variables

cProc   KernelType, <PUBLIC>, <si,di>
cBegin
        mov     wTHFlags,0              ;Zero flags indicates error

.286
        ;** Call the undocumented function GlobalMasterHandle to get
        ;*      a pointer to the global HeapInfo structure.
        ;**     This is the means we can use to detect the kernel types.

        cCall   GlobalMasterHandle
        cCall   HelperHandleToSel, <dx> ;Convert it to a selector
        mov     hMaster,ax              ;Save the handle
        mov     wTHFlags,TH_KERNEL_386

KT_BothPModes:

        ;** Now get pmode KERNEL information
;        cCall   GetVersion              ;Which Windows version are we on
        mov     bx,SEG GlobalLock       ;KERNEL code segment selector
;	 cmp     ax,0004h                ;Win 4.0?
;        je      KT_Win31
;        mov     wTHFlags,0              ;Zero wTHFlags indicates error
;        jmp     SHORT KT_End            ;Unknown Windows version
KT_Win31:
	mov	ax,seg _DATA
	mov	dx,offset _DATA:_szKernel
	cCall	GetModuleHandle,<ax,dx>
	cCall	GetProcAddress,<ax,0,332>	; DX:AX -> hGlobalHeap
        mov     segKernel,dx            ;Save for later
        mov     es,dx                   ;Point with ES
	add	ax,4
	mov	npwExeHead,ax
	add	ax,10
	mov	npwTDBHead,ax
	add	ax,2
	mov	npwTDBCur,ax
	add	ax,6
	mov	npwSelTableLen,ax
	add	ax,2
	mov	npdwSelTableStart,ax
.8086
KT_End:

cEnd

sEnd
        END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\toolhelp\sources.inc ===
TARGETNAME=
TARGETTYPE=NOTARGET
TARGETPATH=
SOURCES=

NTTARGETFILE1=buildall

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\toolhelp\local.c ===
/**************************************************************************
 *  LOCAL.C
 *
 *      Routines used to walk local heaps
 *
 **************************************************************************/

#include "toolpriv.h"

/* ----- Function prototypes ----- */

    NOEXPORT void NEAR PASCAL ComputeType(
        LOCALENTRY FAR *lpLocal);

/*  LocalInfo
 *      Reports information about the state of the indicated heap
 */

BOOL TOOLHELPAPI LocalInfo(
    LOCALINFO FAR *lpLocalInfo,
    HANDLE hHeap)
{
    /* Check the version number and verify proper installation */
    if (!wLibInstalled || !lpLocalInfo ||
        lpLocalInfo->dwSize != sizeof (LOCALINFO))
        return FALSE;

    /* Get the item counts */
    if (wTHFlags & TH_KERNEL_386)
        lpLocalInfo->wcItems = WalkLoc386Count(hHeap);
    else
        lpLocalInfo->wcItems = WalkLoc286Count(hHeap);

    return TRUE;
}

/*  LocalFirst
 *      Finds the first block on a local heap.
 */

BOOL TOOLHELPAPI LocalFirst(
    LOCALENTRY FAR *lpLocal,
    HANDLE hHeap)
{
    WORD wFirst;

    /* Check the version number and verify proper installation */
    if (!wLibInstalled || !lpLocal || lpLocal->dwSize != sizeof (LOCALENTRY))
        return FALSE;

    /* Convert the heap variable to a selector */
    hHeap = HelperHandleToSel(hHeap);

    /* Get the first item from the heap */
    if (wTHFlags & TH_KERNEL_386)
    {
        if (!(wFirst = WalkLoc386First(hHeap)))
            return FALSE;
    }
    else
    {
        if (!(wFirst = WalkLoc286First(hHeap)))
            return FALSE;
    }

    
    /* Fill in other miscellaneous stuff */
    lpLocal->hHeap = hHeap;

    /* Get information about this item */
    if (wTHFlags & TH_KERNEL_386)
        WalkLoc386(wFirst, lpLocal, hHeap);
    else
        WalkLoc286(wFirst, lpLocal, hHeap);

    /* Guess at the type of the object */
    ComputeType(lpLocal);

    return TRUE;
}


/*  LocalNext
 *      Continues a local heap walk by getting information about the
 *      next item.
 */

BOOL TOOLHELPAPI LocalNext(
    LOCALENTRY FAR *lpLocal)
{
    /* Check the version number and verify proper installation */
    if (!wLibInstalled || !lpLocal || lpLocal->dwSize != sizeof (LOCALENTRY))
        return FALSE;

    if (wTHFlags & TH_KERNEL_386)
        WalkLoc386(lpLocal->wNext, lpLocal, lpLocal->hHeap);
    else
        WalkLoc286(lpLocal->wNext, lpLocal, lpLocal->hHeap);

    /* See if this item is the last one.  If so, return done because this
     *  last item is NOT useful.
     */
    if (!lpLocal->wNext)
        return FALSE;

    /* Guess at the type of the object */
    ComputeType(lpLocal);

    return TRUE;
}


/*  ComputeType
 *      Computes the object type of an object
 */

NOEXPORT void NEAR PASCAL ComputeType(
    LOCALENTRY FAR *lpLocal)
{
    /* Decode the free/fixed/moveable bits */
    if (lpLocal->wFlags & 2)
        lpLocal->wFlags = LF_MOVEABLE;
    else if (lpLocal->wFlags & 1)
        lpLocal->wFlags = LF_FIXED;
    else
    {
        /* Free blocks never have a unique type so return */
        lpLocal->wFlags = LF_FREE;
        lpLocal->wType = LT_FREE;
        lpLocal->hHandle = NULL;
        return;
    }

    /* Decode the heap type if possible */
    UserGdiType(lpLocal);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\toolhelp\module.c ===
/*************************************************************************
 *  MODULE.C
 *
 *      Routines to enumerate the various module headers on  the module
 *      chain.
 *
 *************************************************************************/

#include "toolpriv.h"
#include <newexe.h>
#include <string.h>

/* ----- Function prototypes ----- */

    NOEXPORT BOOL PASCAL ModuleGetInfo(
        WORD wModule,
        MODULEENTRY FAR *lpModule);

/*  ModuleFirst
 *      Finds the first module in the module list and returns information
 *      about this module.
 */

BOOL TOOLHELPAPI ModuleFirst(
    MODULEENTRY FAR *lpModule)
{
    WORD FAR *lpwExeHead;

    /* Check the version number and verify proper installation */
    if (!wLibInstalled || !lpModule ||
        lpModule->dwSize != sizeof (MODULEENTRY))
        return FALSE;

    /* Get a pointer to the module head */
    lpwExeHead = MAKEFARPTR(segKernel, npwExeHead);

    /* Use this pointer to get information about this module */
    return ModuleGetInfo(*lpwExeHead, lpModule);
}


/*  ModuleNext
 *      Finds the next module in the module list.
 */

BOOL TOOLHELPAPI ModuleNext(
    MODULEENTRY FAR *lpModule)
{
    /* Check the version number and verify proper installation */
    if (!wLibInstalled || !lpModule ||
        lpModule->dwSize != sizeof (MODULEENTRY))
        return FALSE;

    /* Use the next handle to get information about this module */
    return ModuleGetInfo(lpModule->wNext, lpModule);
}


/*  ModuleFindName
 *      Finds a module with the given module name and returns information
 *      about it.
 */

HANDLE TOOLHELPAPI ModuleFindName(
    MODULEENTRY FAR *lpModule,
    LPCSTR lpstrName)
{
    /* Check the version number and verify proper installation */
    if (!wLibInstalled || !lpModule || !lpstrName ||
        lpModule->dwSize != sizeof (MODULEENTRY))
        return NULL;

    /* Loop through module chain until we find the name (or maybe we don't) */
    if (ModuleFirst(lpModule))
        do
        {
            /* Is this the name?  If so, we have the info, so return */
            if (!lstrcmp(lpstrName, lpModule->szModule))
                return lpModule->hModule;
        }
        while (ModuleNext(lpModule));

    /* If we get here, we didn't find it or there was an error */
    return NULL;
}


/*  ModuleFindHandle
 *      Returns information about a module with the given handle.
 */

HANDLE TOOLHELPAPI ModuleFindHandle(
    MODULEENTRY FAR *lpModule,
    HANDLE hModule)
{
    /* Check the version number and verify proper installation */
    if (!wLibInstalled || !lpModule || !hModule ||
        lpModule->dwSize != sizeof (MODULEENTRY))
        return NULL;
    
    /* Use the helper function to find out about this module */
    if (!ModuleGetInfo(hModule, lpModule))
        return NULL;

    return lpModule->hModule;
}


/* ----- Helper functions ----- */

NOEXPORT BOOL PASCAL ModuleGetInfo(
    WORD wModule,
    MODULEENTRY FAR *lpModule)
{
    struct new_exe FAR *lpNewExe;
    BYTE FAR *lpb;

    /* Verify the segment so we don't GP fault */
    if (!HelperVerifySeg(wModule, 2))
        return FALSE;

    /* Get a pointer to the module database */
    lpNewExe = MAKEFARPTR(wModule, 0);

    /* Make sure this is a module database */
    if (lpNewExe->ne_magic != NEMAGIC)
        return FALSE;

    /* Get the module name (it's the first name in the resident names
     * table
     */
    lpb = ((BYTE FAR *)lpNewExe) + lpNewExe->ne_restab;
    _fstrncpy(lpModule->szModule, lpb + 1, *lpb);
    lpModule->szModule[*lpb] = '\0';

    /* Get the EXE file path.  A pointer is stored in the same place as
     *  the high word of the CRC was in the EXE file. (6th word in new_exe)
     *  This pointer points to the length of a PASCAL string whose first
     *  eight characters are meaningless to us.
     */
    lpb = MAKEFARPTR(wModule, *(((WORD FAR *)lpNewExe) + 5));
    _fstrncpy(lpModule->szExePath, lpb + 8, *lpb - 8);
    lpModule->szExePath[*lpb - 8] = '\0';

    /* Get other information from the EXE Header
     * The usage count is stored in the second word of the EXE header
     * The handle of the next module in the chain is stored in the
     *  ne_cbenttab structure member.
     */
    lpModule->hModule = wModule;
    lpModule->wcUsage = *(((WORD FAR *)lpNewExe) + 1);
    lpModule->wNext = lpNewExe->ne_cbenttab;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\toolhelp\notify2.asm ===
PAGE 60,150
;***************************************************************************
;*  NOTIFY2.ASM
;*
;*      Assembly code support routines used for the TOOLHELP.DLL
;*      notification API
;*
;***************************************************************************

        INCLUDE TOOLPRIV.INC
.286p

;** Data
sBegin  DATA

globalW wCASRqFlag,0                    ;Set when an CASRq INT3 has been set
globalD dwCASRqCSIP,0                   ;Holds the CS:IP of the CASRq INT3
globalD lpfnOldProc,0                   ;Old hook from new PTrace hook
szWinDebug      DB      'WINDEBUG', 0

;** WARNING!!
;**     This structure is set to the size of the largest notification
;**     structure.  This is currently NFYLOADSEG which is 16 bytes long.
;**     If a structure is added that is longer than this or if any other
;**     structure is added, this space must be increased to match!!
ReturnStruct    DB      16 DUP (?)

sEnd

;** Imports
externFP GetModuleHandle
externFP RegisterPTrace
externFP OutputDebugString
externFP AllocCStoDSAlias
externFP FreeSelector
externNP HelperHandleToSel

sBegin  CODE
        assumes CS,CODE
        assumes DS,DATA

;  NotifyInit
;       Called when the first app registers a notification handler.
;       Hooks the Register PTrace notification.
;       Returns FALSE if we couldn't initialize, TRUE otherwise

cProc   NotifyInit, <NEAR,PUBLIC>, <si,di,ds>
cBegin
        ;** In the Windows 3.1 KERNEL, there is a special hook just for
        ;*      TOOLHELP that lets us get PTrace stuff and still coexist
        ;*      with old-fashioned debuggers.  We can check to see if the
        ;*      hook exists by simply checking the TOOLHELP flags
        ;**
        test    wTHFlags,TH_GOODPTRACEHOOK ;Good hook around?
        jz      DNI_UseRegPTrace        ;Nope, use the old one
        lea     si,NotifyHandler        ;Point to the routine
        push    cs                      ;Parameter is lpfn to callback
        push    si
        call    lpfnNotifyHook          ;Hook it
        mov     WORD PTR lpfnOldProc[0],ax ;Save old proc
        mov     WORD PTR lpfnOldProc[2],dx
        jmp     SHORT DNI_10            ;We're in

        ;** Since there's no way we can see if someone else has Register
        ;*      PTrace, we just connect and hope for the best!
        ;**     We do check, however, to see if WINDEBUG.DLL is installed.
DNI_UseRegPTrace:
        lea     si,szWinDebug           ;Get the name of the module
        cCall   GetModuleHandle, <ds,si> ;Is WINDEBUG present?
        or      ax,ax                   ;Check the handle
        jnz     DNI_Fail                ;It's here so fail
        or      wTHFlags,TH_GOTOLDPTRACE ;Flag that we made the hook
        lea     si,NotifyHandler        ;Point to our routine
        cCall   RegisterPTrace, <cs,si> ;Tell KERNEL to use it

        ;** Connect to the FatalExit hook.  We currently ignore
        ;**     the return value, thus unhooking anyone else
DNI_10: cmp     WORD PTR lpfnFatalExitHook + 2,0 ;Can we hook it?
        jz      DNI_20                  ;Can't do it
        push    cs                      ;Get the CS:IP of RIP handler
        push    OFFSET NotifyRIPHandler
        call    DWORD PTR lpfnFatalExitHook ;Tell KERNEL to insert the hook
DNI_20:

        ;** Return OK
        mov     ax,TRUE                 ;Return TRUE
        jmp     SHORT DNI_End           ;Get out

DNI_Fail:
        xor     ax,ax                   ;FALSE

DNI_End:
cEnd


;  NotifyUnInit
;       Called when the no more apps have hooked notification handlers
;       so the hook to the Register PTrace notification is no longer needed.

cProc   NotifyUnInit, <NEAR,PUBLIC>, <si,di,ds>
cBegin
        ;** Did we have a new hook to undo?
        test    wTHFlags,TH_GOODPTRACEHOOK ;Do we have a new hook?
        jz      DNU_TryOldPTrace        ;No
        push    WORD PTR lpfnOldProc[0] ;Get the old proc
        push    WORD PTR lpfnOldProc[2]
        call    lpfnNotifyHook          ;Unhook ourself
        jmp     SHORT DNU_NoOldPTrace

        ;** Unhook the old-style hook if necessary
DNU_TryOldPTrace:
        test    wTHFlags,TH_GOTOLDPTRACE ;Did we have a hook?
        jz      DNU_NoOldPTrace         ;No
        push    0
        push    0
        call    RegisterPTrace          ;Call KERNEL's routine to unhook
DNU_NoOldPTrace:

        ;** Unhook alternate hooks
        cmp     WORD PTR lpfnFatalExitHook + 2,0 ;Can we unhook it?
        jz      DNU_NoRIP               ;Can't do it
        xor     ax,ax                   ;Remove any other hooks
        push    ax                      ;NULL procedure
        push    ax
        call    DWORD PTR lpfnFatalExitHook
DNU_NoRIP:

cEnd


;  NotifyHandler
;       This routine is called directly by PTrace and is used to
;       dispatch the notifications to all registered callbacks.

cProc   NotifyHandler, <FAR,PUBLIC>
cBegin  NOGEN

        ;** Push a register frame
        ;*      When done, it should look like this:
        ;*              ------------
        ;*              |    ES    |  [BP - 14h]
        ;*              |    DS    |  [BP - 12h]
        ;*              |    DI    |  [BP - 10h]
        ;*              |    SI    |  [BP - 0Eh]
        ;*              |    BP    |  [BP - 0Ch]
        ;*              |    SP    |  [BP - 0Ah]
        ;*              |    BX    |  [BP - 08h]
        ;*              |    DX    |  [BP - 06h]
        ;*              |    CX    |  [BP - 04h]
        ;*              |    AX    |  [BP - 02h]
        ;*         BP-->|  Old BP  |  [BP - 00h]
        ;*              |    IP    |  [BP + 02h]
        ;*              |    CS    |  [BP + 04h]
        ;*              ------------
        ;**
        push    bp                      ;Make a stack frame
        mov     bp,sp
        pusha                           ;Save all registers
        push    ds                      ;Save segment registers, too
        push    es

        ;** Get the data segment
        mov     bx,_DATA                ;Get TOOLHELP data segment
        mov     ds,bx

        ;** If in 3.0 std mode and we get this wild notification 69h,
        ;**     translate it to a inchar notification as this is what it
        ;**     is supposed to be.
        cmp     ax,69h                  ;Bogus notification?
        jne     NH_NoBogusNotify        ;No, don't do this
        test    wTHFlags,TH_WIN30STDMODE ;3.0 standard mode?
        jz      NH_NoBogusNotify        ;No, might be valid in the future...
        mov     ax,NI_INCHAR            ;Put in real notify value
NH_NoBogusNotify:

        ;** Special case notifications:
        ;*      Notification 63h means that CtlAltSysRq was pressed.  For
        ;*      this, we want to handle as an interrupt, not a notification.
        ;*      To do this, we set a breakpoint and set a flag so that the
        ;**     INT3 handler knows what to do with it
        cmp     ax,63h                  ;CtlAltSysRq?
        jne     NH_NoCASRq              ;No.
        mov     ax,[bp + 04h]           ;Since we can't use IRET CS:IP, get
        mov     si,[bp + 02h]           ;  a safe address in KERNEL
        mov     WORD PTR dwCASRqCSIP[2],ax ;Save the CS:IP value
        cCall   AllocCStoDSAlias, <ax>  ;Get a data alias to the CS
        or      ax,ax                   ;Error?
        jnz     @F
        jmp     SHORT DNH_End           ;Yes, get out
@@:     verw    ax                      ;OK to write to?
        jnz     DNH_NoWrite             ;Yes, so do it
DNH_IRETCSOK:
        mov     es,ax                   ;Point with ES
        mov     WORD PTR dwCASRqCSIP[0],si
        mov     al,es:[si]              ;Get the character there
        mov     ah,1                    ;Make sure there's something in AH
        mov     wCASRqFlag,ax           ;Save the thing for the INT3 handler
        mov     BYTE PTR es:[si],0cch   ;Poke the INT3 in there
        mov     ax,es                   ;Get the selector back
DNH_NoWrite:
        cCall   FreeSelector, <ax>      ;Get rid of the alias
        jmp     SHORT DNH_End           ;Get out.  This will INT3 soon

NH_NoCASRq:                             ;  Does not return

        ;** Notifications to ignore here:
        ;**     Notification 60h is bogus and should be ignored
        cmp     ax,60h                  ;PostLoad notification?
        jz      DNH_End                 ;Yes, don't report

        ;** Decode the notification
        cCall   DecodeNotification      ;Returns dwData in CX:DX, AX is wID
                                        ;  BX is NOTIFYSTRUCT match flags
        ;** This is an entry point for notifications from sources other than
        ;**     PTrace
DNH_Decoded:

        ;** Loop through callbacks
        mov     di,npNotifyHead         ;Point to the start of the list
        xor     si,si                   ;FALSE return value is default
DNH_Loop:
        push    ax
        mov     ax,ds:[di].ns_pNext     ;Save the next pointer in a global
        mov     npNotifyNext,ax         ;  so we can chain in NotifyUnregister
        pop     ax

        or      di,di                   ;End of list?
        jz      DNH_Done                ;Yep.  Get out

        ;** If the flags for this notification are zero, we always send it
        or      bx,bx                   ;Check the matching flags
        jz      DNH_DoIt                ;Do notification

        ;** See if the flags match
        test    bx,ds:[di].ns_wFlags    ;Check against the NOTIFYSTRUCT flags
        jz      DNH_Continue            ;If zero, no match, don't do it

        ;** Call the user callback
DNH_DoIt:
        push    ax                      ;Save everything we need
        push    bx
        push    cx
        push    dx

        push    ax                      ;wID
        push    cx                      ;High word of dwData
        push    dx                      ;Low word
        call    DWORD PTR ds:[di].ns_lpfn ;Call the callback (PASCAL style)
        mov     si,ax                   ;Get return value in SI

        pop     dx                      ;Restore everything
        pop     cx
        pop     bx
        pop     ax

        ;** If the return value is nonzero, we don't want to give this to
        ;**     any more callbacks
        or      si,si                   ;TRUE return value?
        jnz     DNH_Done                ;Yes, get out

        ;** Get the next callback
DNH_Continue:
        mov     di,npNotifyNext         ;Get next pointer
        jmp     DNH_Loop                ;  and loop back

        ;** End of callback loop.
DNH_Done:

        ;**  If this was an InChar message but everyone ignored it, force
        ;**     the return to be an 'i' for 'ignore' on RIPs.  This i
        ;**     only necessary in 3.0 because the 3.1 KERNEL treats 0
        ;**     returns just like 'i'
        cmp     ax,NFY_INCHAR           ;Is this an InChar notification?
        jne     DNH_Default             ;No, so ignore
        test    wTHFlags,TH_WIN30       ;In 3.0?
        jz      DNH_Default             ;No, don't do this
        and     si,0ffh                 ;Ignore all but low byte
        or      si,si                   ;Non-zero?
        jnz     DNH_Default             ;Yes, return it as the character
        mov     si,'i'                  ;Instead of zero, return 'i'gnore.
DNH_Default:
        mov     [bp - 02h],si           ;Return the return code in AX

        ;** Clear off the stack and exit
DNH_End:
        mov     npNotifyNext,0          ;No current next pointer
        
        pop     es                      ;Restore all registers
        pop     ds
        popa
        pop     bp
        retf                            ;Just return

cEnd    NOGEN


;  NotifyRIPHandler
;       Gets called by KERNEL when a RIP occurs.  If it returns TRUE,
;       KERNEL will act like the RIP was ignored.  Otherwise, the RIP
;       procedes normally.
;       This routine does not need to worry about saving non-C regs

cProc   NotifyRIPHandler, <FAR,PUBLIC>
;       parmW   wExitCode
cBegin  nogen

        ;** Clear PASCAL-style parameters
        push    bp                      ;Make a stack frame
        mov     bp,sp
        mov     bx,[bp + 6]             ;Get the BP value
        mov     dx,[bp + 8]             ;Get the Exit code
        mov     [bp - 2],ax             ;Save it out of the way for now
        mov     ax,[bp + 4]             ;Get the RETF CS value
        mov     [bp + 8],ax             ;Shift down to clear parameters
        mov     ax,[bp + 2]             ;Get the RETF IP value
        mov     [bp + 6],ax             ;Shift down to clear parameters
        mov     ax,[bp + 0]             ;Get the old BP value
        mov     [bp + 4],ax             ;Shift down
        add     bp,4                    ;Move BP down on the stack
        mov     sp,bp                   ;Point SP there too
        pusha                           ;Save matching register frame
        push    ds
        push    es

        ;** Get the data segment
        mov     ax,_DATA                ;Get TOOLHELP data segment
        mov     ds,ax


        ;** Prepare to jump into the notification handler.
        ;**     The trick here is that if a notification callback returns
        ;**     non-zero, the RIP has been handled.  Otherwise, it has not.
        ;**     DX holds the exit code here, BX has the old BP value
        lea     si,ReturnStruct         ;Get a pointer to the return struct
        mov     WORD PTR [si].nrp_dwSize[0],SIZE NFYRIP
        mov     WORD PTR [si].nrp_dwSize[2],0
        mov     ax,ss:[bx + 4]          ;Get old CS value from stack
        mov     [si].nrp_wCS,ax         ;  (BX is BP from FatalExit stack)
        mov     ax,ss:[bx + 2]          ;Get old IP value
        mov     [si].nrp_wIP,ax
        mov     [si].nrp_wSS,ss         ;Save SS:BP for stack trace
        mov     [si].nrp_wBP,bx
        mov     [si].nrp_wExitCode,dx
        mov     cx,ds                   ;Point to structure
        mov     dx,si
        mov     bx,NF_RIP               ;Get the NOTIFYINFO match flags
        mov     ax,NFY_RIP              ;TOOLHELP ID

        ;** Jump to the real handler
        jmp     DNH_Decoded             ;Jump to alternate entry point

cEnd    nogen

;** Helper routines

;  DecodeNotification
;       Decodes a notification by pointing to a static structure and filling
;       this structure with notification-specific information.
;       The PTrace notification ID is in AX.
;       Returns the ToolHelp ID in AX
;       and the dwData value is in CX:DX.

cProc   DecodeNotification, <NEAR,PUBLIC>
cBegin
        ;** Point dwData to the structure just in case
        mov     cx,ds                   ;Get the segment value
        lea     dx,ReturnStruct         ;Get a pointer to the return struct
        xor     bx,bx                   ;Most notifications always match

        ;**  The stack frame looks like this:
        ;*              ------------
        ;*              |    ES    |  [BP - 14h]
        ;*              |    DS    |  [BP - 12h]
        ;*              |    DI    |  [BP - 10h]
        ;*              |    SI    |  [BP - 0Eh]
        ;*              |    BP    |  [BP - 0Ch]
        ;*              |    SP    |  [BP - 0Ah]
        ;*              |    BX    |  [BP - 08h]
        ;*              |    DX    |  [BP - 06h]
        ;*              |    CX    |  [BP - 04h]
        ;*              |    AX    |  [BP - 02h]
        ;*         BP-->|  Old BP  |  [BP - 00h]
        ;*              ------------
        ;**
FrameES         EQU     [BP - 14h]
FrameDS         EQU     [BP - 12h]
FrameDI         EQU     [BP - 10h]
FrameSI         EQU     [BP - 0Eh]
FrameBP         EQU     [BP - 0Ch]
FrameSP         EQU     [BP - 0Ah]
FrameBX         EQU     [BP - 08h]
FrameDX         EQU     [BP - 06h]
FrameCX         EQU     [BP - 04h]
FrameAX         EQU     [BP - 02h]

        ;** Check for LoadSeg
        cmp     ax,NI_LOADSEG           ;LoadSeg?
        jnz     DN_10                   ;No

        ;** LoadSeg:
        ;*      CX is selector
        ;*      BX is segment number
        ;*      SI is type:  Low bit set for data segment, clear for code
        ;*      DX is instance count only for data segments
        ;**     ES:DI module name
        mov     si,dx                   ;Point to NFYLOADSEG struct
        mov     ax,SIZE NFYLOADSEG      ;Get the structure size
        mov     WORD PTR [si].nls_dwSize,ax ;Save the LOWORD of the size
        mov     WORD PTR [si].nls_dwSize + 2,0 ;HIWORD is zero
        mov     ax,FrameCX              ;Get selector
        mov     [si].nls_wSelector,ax   ;Save in structure
        mov     ax,FrameBX              ;Get segment number
        inc     ax                      ;Segment number is 1-based
        mov     [si].nls_wSegNum,ax     ;Save in structure
        mov     ax,FrameSI              ;Get the segment type
        mov     [si].nls_wType,ax       ;Put in structure
        mov     ax,FrameDX              ;Get instance count
        mov     [si].nls_wcInstance,ax  ;Put in structure
        mov     ax,FrameDI              ;Get offset of module name str
        mov     WORD PTR [si].nls_lpstrModuleName,ax ;Save it
        mov     ax,FrameES              ;Get segment of module name str
        mov     WORD PTR [si].nls_lpstrModuleName + 2,ax ;Save it
        mov     ax,NFY_LOADSEG          ;Get the TOOLHELP ID
        jmp     DN_End

        ;** Check for FreeSeg
DN_10:  cmp     ax,NI_FREESEG           ;FreeSeg?
        jnz     DN_15                   ;No

        ;** FreeSeg:
        ;**     BX is selector
        xor     cx,cx                   ;Clear high word
        mov     dx,FrameBX              ;Get the selector
        test    wTHFlags,TH_WIN30STDMODE ;3.0 standard mode?
        jz      DN_FS_GotSelValue       ;No, what we have is correct
        mov     si,FrameSP              ;Point to old stack frame
        mov     dx, ss:[si + 6]         ;Selector is 6 bytes down
        lsl     ax, dx
        jz      DN_FS_CheckLen          ;Selector is OK
        mov     dx, FrameBX             ;Revert to BX value
        jmp     SHORT DN_FS_GotSelValue
DN_FS_CheckLen:
        cmp     ax, 15                  ;If the segment is 15 bytes long,
        jne     DN_FS_GotSelValue       ;  this is a bogus selector and is
                                        ;  really an arena header.
        push    es
        mov     es, dx                  ;Get handle
        cCall   HelperHandleToSel, <es:[0ah]> ;Convert to selector
        mov     dx, ax                  ;Get handle out of arena header
        pop     es
DN_FS_GotSelValue:
        mov     ax,NFY_FREESEG          ;Get the TOOLHELP ID
        jmp     DN_End

        ;** Check for StartDLL
DN_15:  cmp     ax,NI_LOADDLL
        jnz     DN_20

        ;** StartDLL:
        ;**     CX is CS
        ;**     BX is IP
        ;**     SI is Module handle
        mov	si,dx			;Point with SI
        mov	ax,SIZE NFYSTARTDLL	;Get the size
        mov	WORD PTR [si].nsd_dwSize,ax ;Save the LOWORD of the size
        mov	WORD PTR [si].nsd_dwSize + 2,0 ;HIWORD is always zero
        mov	ax,FrameSI		;Get the hInstance
        mov	[si].nsd_hModule,ax	;Save in structure
        mov	ax,FrameCX		;Get the starting CS
        mov	[si].nsd_wCS,ax		;Save in structure
        mov	ax,FrameBX		;Get the starting IP
        mov	[si].nsd_wIP,ax		;Save in structure
        mov     ax,NFY_STARTDLL
        jmp     DN_End

        ;** Check for StartTask
DN_20:  cmp     ax,NI_STARTTASK         ;StartTask?
        jnz     DN_30                   ;No

        ;** StartTask:
        ;*      CX is CS
        ;**     BX is IP
        mov     cx,FrameCX
        mov     dx,FrameBX
        mov     ax,NFY_STARTTASK
        jmp     DN_End

        ;** Check for ExitCall
DN_30:  cmp     ax,NI_EXITCALL          ;ExitCall
        jnz     DN_40                   ;No

        ;** ExitCall:
        ;*      Exit code is on stack somewhere if we don't have the new
        ;**     notification handler.  If we do, it's in BL.
        xor     cx,cx                   ;Clear all but low byte
        xor     dh,dh
        test    wTHFlags,TH_GOODPTRACEHOOK ;Do we have the good hook?
        jz      DN_DoOldHook            ;Nope, grope on the stack
        mov     dl,BYTE PTR FrameBX     ;Get the exit code
        mov     ax,NFY_EXITTASK         ;Get the TOOLHELP ID
        jmp     DN_End
DN_DoOldHook:
        mov     si,FrameSP              ;Point to old stack frame
        mov     dl,ss:[si + 6]          ;Exit code is 6 bytes down on stack
        mov     ax,NFY_EXITTASK         ;Get the TOOLHELP ID
        jmp     DN_End

        ;** Check for DelModule
DN_40:  cmp     ax,NI_DELMODULE         ;DelModule?
        jnz     DN_60                   ;No

        ;** DelModule:
        ;**     ES is module handle
        xor     cx,cx                   ;Clear HIWORD
        mov     dx,FrameES              ;Get the module handle
        mov     ax,NFY_DELMODULE        ;Get the TOOLHELP ID
        jmp     DN_End

        ;** Check for TaskSwitchIn
DN_60:  cmp     ax,NI_TASKIN            ;TaskSwitchIn?
        jnz     DN_70                   ;No

        ;** TaskSwitchIn:
        ;**     No data.  Callback should do GetCurrentTask()
        xor     cx,cx                   ;Clear data
        xor     dx,dx
        mov     ax,NFY_TASKIN           ;Get the TOOLHELP ID
        mov     bx,NF_TASKSWITCH        ;Get the NOTIFYSTRUCT match flag
        jmp     DN_End

        ;** Check for TaskSwitchOut
DN_70:  cmp     ax,NI_TASKOUT           ;TaskSwitchOut?
        jnz     DN_90                   ;No

        ;** TaskSwitchOut:
        ;**     No data
        xor     cx,cx                   ;Clear data
        xor     dx,dx
        mov     ax,NFY_TASKOUT          ;Get the TOOLHELP ID
        mov     bx,NF_TASKSWITCH        ;Get the NOTIFYSTRUCT match flag
        jmp     DN_End

        ;** Check for OutStr
DN_90:  cmp     ax,NI_OUTSTR            ;OutStr?
        jnz     DN_100                  ;No

        ;** OutStr:
        ;**     ES:SI points to string to display in 3.1
        ;**     DS:SI in 3.0
        test    wTHFlags,TH_WIN30       ;3.0?
        jz      DN_OS_Win31             ;Nope
        mov     cx,FrameDS              ;Get the segment value
        jmp     SHORT @F
DN_OS_Win31:
        mov     cx,FrameES              ;Get the segment value
@@:     mov     dx,FrameSI              ;  and the offset
        mov     ax,NFY_OUTSTR           ;Get the TOOLHELP ID
        jmp     DN_End

        ;** Check for InChar
DN_100: cmp     ax,NI_INCHAR            ;InChar?
        jnz     DN_105                  ;No

        ;** InChar:
        ;**     No data passed (it wants data back in AL)
        xor     cx,cx                   ;Clear dwData
        xor     dx,dx
        mov     ax,NFY_INCHAR           ;Get the TOOLHELP ID
        jmp     SHORT DN_End

        ;** NOTE:  The following notifications are defined as "NEW" and
        ;**     are NOT sent through the normal PTrace interface so as to
        ;**     not break CodeSpew.  It stack faults when
        ;**     it is sent a notification it doesn't understand.  So,
        ;**     here we don't bother decoding any of these unless we have
        ;**     the new (Win 3.1) style hook
DN_105: test    wTHFlags,TH_GOODPTRACEHOOK ;Do we have the advanced hook?
        jnz     DN_110                  ;Yes
        jmp     SHORT DN_End

        ;** Check for the parameter validation notifications
DN_110: cmp     ax,NI_LOGERROR          ;SDM_LOGERROR?
        jne     DN_120                  ;No

        ;** SDM_LOGERROR:
        ;*      CX is Error code
        ;**     DX:BX is lpInfo
        mov     si,dx                   ;Point with SI
        mov     ax,SIZE NFYLOGERROR     ;Get the size
        mov     WORD PTR [si].nle_dwSize[0],ax ;Save the LOWORD of the size
        mov     WORD PTR [si].nle_dwSize[2],0 ;HIWORD is always zero
        mov     ax,FrameCX              ;Get the error code
        mov     [si].nle_wErrCode,ax    ;Save in structure
        mov     ax,FrameDX              ;Get the lpInfo
        mov     WORD PTR [si].nle_lpInfo[2],ax ;Save in structure
        mov     ax,FrameBX
        mov     WORD PTR [si].nle_lpInfo[0],ax ;Save in structure
        mov     ax,NFY_LOGERROR         ;Get the TOOLHELP ID
        jmp     SHORT DN_End

DN_120: cmp     ax,NI_LOGPARAMERROR     ;SDM_LOGPARAMERROR?
        jne     DN_Unknown              ;No

        ;** SDM_LOGPARAMERROR:
        ;**     ES:BX points to a structure:
        ;**             WORD wErr
        ;**             FARPROC lpfn
        ;**             VOID FAR* lpBadParam
        mov     si,dx                   ;Point with SI
        mov     ax,SIZE NFYLOGPARAMERROR ;Struct size
        mov     WORD PTR [si].nlp_dwSize[0],ax ;Save the LOWORD of the size
        mov     WORD PTR [si].nlp_dwSize[2],0 ;HIWORD is always zero
        mov     es,FrameES              ;Point to the structure
        mov     bx,FrameBX
        mov     ax,es:[bx]              ;Get wErr
        mov     [si].nlp_wErrCode,ax    ;Save in structure
        mov     ax,es:[bx + 2]          ;Get lpfn[0]
        mov     WORD PTR [si].nlp_lpfnErrorAddr[0],ax
        mov     ax,es:[bx + 4]          ;Get lpfn[2]
        mov     WORD PTR [si].nlp_lpfnErrorAddr[2],ax
        mov     ax,es:[bx + 6]          ;Get lpBadParam[0]
        mov     WORD PTR [si].nlp_lpBadParam[0],ax
        mov     ax,es:[bx + 8]          ;Get lpBadParam[2]
        mov     WORD PTR [si].nlp_lpBadParam[2],ax
        mov     ax,NFY_LOGPARAMERROR    ;Get the TOOLHELP ID
        xor     bx,bx                   ;Always match
        jmp     SHORT DN_End

        ;** Must be unknown, return TOOLHELP ID NFY_UNKNOWN with KERNEL value
        ;**     in LOWORD(wData)
DN_Unknown:
        mov     dx,ax                   ;Get the notification value
        mov     ax,NFY_UNKNOWN          ;Unknown KERNEL notification
        xor     cx,cx                   ;Clear high WORD

DN_End:

cEnd

sEnd
        END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\toolhelp\notify1.c ===
/**************************************************************************
 *  NOTIFY1.C
 *
 *      Routines used to implement the Debugger Notification API in
 *      TOOLHELP.DLL
 *
 **************************************************************************/

#include <string.h>
#include "toolpriv.h"

/* ----- Global variables ----- */
    WORD wNotifyInstalled;
    NOTIFYSTRUCT NEAR *npNotifyHead;
    NOTIFYSTRUCT NEAR *npNotifyNext;

/*  NotifyRegister
 *      Registers a debugger notification callback.  This callback will
 *      be called whenever KERNEL has a notification to be sent.
 *      The format of the call to the callback function is documented
 *      elsewhere.
 */

BOOL TOOLHELPAPI NotifyRegister(
    HANDLE hTask,
    LPFNNOTIFYCALLBACK lpfn,
    WORD wFlags)
{
    NOTIFYSTRUCT *pInfo;
    NOTIFYSTRUCT *pTemp;

    /* Make sure TOOLHELP.DLL is installed */
    if (!wLibInstalled)
        return FALSE;

    /* If the notification hook has not yet been installed, install it */
    if (!wNotifyInstalled)
    {
        /* Make sure we can get a hook! */
        if (!NotifyInit())
            return FALSE;
        wNotifyInstalled = TRUE;
    }

    /* NULL hTask means current task */
    if (!hTask)
        hTask = GetCurrentTask();

    /* Register a death signal handler for this task (does nothing if one
     *  is already installed.
     */
    SignalRegister(hTask);

    /* Check to see if this task is already registered */
    for (pInfo = npNotifyHead ; pInfo ; pInfo = pInfo->pNext)
        if (pInfo->hTask == hTask)
            return FALSE;

    /* Allocate a new NOTIFYSTRUCT structure */
    pInfo = (NOTIFYSTRUCT *)LocalAlloc(LMEM_FIXED, sizeof (NOTIFYSTRUCT));
    if (!pInfo)
        return FALSE;

    /* Fill in the useful fields */
    pInfo->hTask = hTask;
    pInfo->wFlags = wFlags;
    pInfo->lpfn = lpfn;

    /* If this is the only handler, just insert it */
    if (!npNotifyHead)
    {
        pInfo->pNext = npNotifyHead;
        npNotifyHead = pInfo;
    }

    /* Otherwise, insert at the end of the list */
    else
    {
        for (pTemp = npNotifyHead ; pTemp->pNext ; pTemp = pTemp->pNext)
            ;
        pInfo->pNext = pTemp->pNext;
        pTemp->pNext = pInfo;
    }

    return TRUE;
}


/*  NotifyUnRegister
 *      Called by an app whose callback is no longer to be used.
 *      NULL hTask uses current task.
 */

BOOL TOOLHELPAPI NotifyUnRegister(
    HANDLE hTask)
{
    NOTIFYSTRUCT *pNotify;
    NOTIFYSTRUCT *pBefore;

    /* Make sure we have notifications installed and that TOOLHELP is OK */
    if (!wLibInstalled || !wNotifyInstalled)
        return FALSE;

    /* NULL hTask means current task */
    if (!hTask)
        hTask = GetCurrentTask();

    /* First try to find the task */
    pBefore = NULL;
    for (pNotify = npNotifyHead ; pNotify ; pNotify = pNotify->pNext)
        if (pNotify->hTask == hTask)
            break;
        else
            pBefore = pNotify;
    if (!pNotify)
        return FALSE;

    /* Unhook the death signal proc only if there is no interrupt handler */
    if (!InterruptIsHooked(hTask))
        SignalUnRegister(hTask);

    /* Check to see if the notification handler is about to use this entry.
     *  If it is, we point it to the next one, if any.
     */
    if (npNotifyNext == pNotify)
        npNotifyNext = pNotify->pNext;

    /* Remove it from the list */
    if (!pBefore)
        npNotifyHead = pNotify->pNext;
    else
        pBefore->pNext = pNotify->pNext;

    /* Free the structure */
    LocalFree((HANDLE)pNotify);

    /* If there are no more handlers, unhook the callback */
    if (!npNotifyHead)
    {
        NotifyUnInit();
        wNotifyInstalled = FALSE;
    }

    return TRUE;
}

/* ----- Helper functions ----- */

/*  NotifyIsHooked
 *      Returns TRUE iff the parameter task already has a notification hook.
 */

BOOL PASCAL NotifyIsHooked(
    HANDLE hTask)
{
    NOTIFYSTRUCT *pNotify;

    /* Loop thorugh all notifications */
    for (pNotify = npNotifyHead ; pNotify ; pNotify = pNotify->pNext)
        if (pNotify->hTask == hTask)
            break;

    /* Return found/not found */
    return (BOOL)pNotify;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\toolhelp\memman.asm ===
;**************************************************************************
;*  MEMMAN.ASM
;*
;*      Returns information about the VMM.
;*
;**************************************************************************

        INCLUDE TOOLPRIV.INC


sBegin  CODE
        assumes CS,CODE

;  MemManInfo
;
;       Returns information through DPMI about the VMM

cProc   MemManInfo, <PUBLIC,FAR>, <si,di,ds>
        parmD   lpMemMan
        localV  DPMIBuffer,30h          ;30h byte buffer for DPMI info
cBegin
        mov     ax,_DATA                ;Get our data segment
        mov     ds,ax

        ;** Fill the buffer with -1 so if the call messes up like
        ;**     in 3.0 std mode we get the correct results
        push    ss                      ;Point to the local variable block
        pop     es
        lea     di,DPMIBuffer           ;Get offset of buffer
        mov     cx,30h                  ;Max len of DPMI buffer
        mov     al,0ffh                 ;-1
        rep     stosb                   ;Fill buffer

        ;** Prepare to build public structure
        mov     ax,0500h                ;DPMI -- Get Free Memory Info
        lea     di,DPMIBuffer           ;Get offset of buffer
        int     31h                     ;Call DPMI
        jnc     MMI_10                  ;Success
        xor     ax,ax                   ;Return FALSE
        jmp     MMI_End                 ;Get out because of DPMI error
MMI_10: lds     si,lpMemMan             ;Point to the MEMMANINFO structure

        ;** Fill MEMMANINFO structure
        mov     ax,es:[di+0]            ;Loword of largest free block
        mov     WORD PTR [si].vmm_dwLargestFreeBlock,ax
        mov     ax,es:[di+2]            ;High word
        mov     WORD PTR [si].vmm_dwLargestFreeBlock + 2,ax
        mov     ax,es:[di+4]            ;Loword of largest unlockable block
        mov     WORD PTR [si].vmm_dwMaxPagesAvailable,ax
        mov     ax,es:[di+6]            ;Hiword
        mov     WORD PTR [si].vmm_dwMaxPagesAvailable + 2,ax
        mov     ax,es:[di+8]            ;Loword of largest lockable page
        mov     WORD PTR [si].vmm_dwMaxPagesLockable,ax
        mov     ax,es:[di+0ah]          ;Hiword
        mov     WORD PTR [si].vmm_dwMaxPagesLockable + 2,ax
        mov     ax,es:[di+0ch]          ;Loword of linear address space
        mov     WORD PTR [si].vmm_dwTotalLinearSpace,ax
        mov     ax,es:[di+0eh]          ;Hiword
        mov     WORD PTR [si].vmm_dwTotalLinearSpace + 2,ax
        mov     ax,es:[di+10h]          ;Loword of number of unlocked pages
        mov     WORD PTR [si].vmm_dwTotalUnlockedPages,ax
        mov     ax,es:[di+12h]          ;Hiword
        mov     WORD PTR [si].vmm_dwTotalUnlockedPages + 2,ax
        mov     ax,es:[di+14h]          ;Loword of number of free pages
        mov     WORD PTR [si].vmm_dwFreePages,ax
        mov     ax,es:[di+16h]          ;Hiword
        mov     WORD PTR [si].vmm_dwFreePages + 2,ax
        mov     ax,es:[di+18h]          ;Loword of total physical pages
        mov     WORD PTR [si].vmm_dwTotalPages,ax
        mov     ax,es:[di+1ah]          ;Hiword
        mov     WORD PTR [si].vmm_dwTotalPages + 2,ax
        mov     ax,es:[di+1ch]          ;Loword of free lin addr space (pages)
        mov     WORD PTR [si].vmm_dwFreeLinearSpace,ax
        mov     ax,es:[di+1eh]          ;Hiword
        mov     WORD PTR [si].vmm_dwFreeLinearSpace + 2,ax
        mov     ax,es:[di+20h]          ;Loword of size of paging file (pages)
        mov     WORD PTR [si].vmm_dwSwapFilePages,ax
        mov     ax,es:[di+22h]          ;Hiword
        mov     WORD PTR [si].vmm_dwSwapFilePages + 2,ax
        mov     [si].vmm_wPageSize,4096 ;Safe to hard code this for 386/486
        mov     ax,TRUE                 ;Return TRUE

MMI_End:
        
cEnd

sEnd
        END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\toolhelp\string.h ===
/***
*string.h - declarations for string manipulation functions
*
*	Copyright (c) 1985-1990, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*	This file contains the function declarations for the string
*	manipulation functions.
*	[ANSI/System V]
*
****/

#if defined(_DLL) && !defined(_MT)
#error Cannot define _DLL without _MT
#endif

#ifdef _MT
#define _FAR_ _far
#else
#define _FAR_
#endif

#ifndef _SIZE_T_DEFINED
typedef unsigned int size_t;
#define _SIZE_T_DEFINED
#endif

/* function prototypes */

void _FAR_ * _FAR_ _cdecl memccpy(void _FAR_ *, const void _FAR_ *,
	int, unsigned int);
void _FAR_ * _FAR_ _cdecl memchr(const void _FAR_ *, int, size_t);
int _FAR_ _cdecl memcmp(const void _FAR_ *, const void _FAR_ *,
	size_t);
int _FAR_ _cdecl memicmp(const void _FAR_ *, const void _FAR_ *,
	unsigned int);
void _FAR_ * _FAR_ _cdecl memcpy(void _FAR_ *, const void _FAR_ *,
	size_t);
void _FAR_ * _FAR_ _cdecl memmove(void _FAR_ *, const void _FAR_ *,
	size_t);
void _FAR_ * _FAR_ _cdecl memset(void _FAR_ *, int, size_t);
void _FAR_ _cdecl movedata(unsigned int, unsigned int, unsigned int,
	unsigned int, unsigned int);
char _FAR_ * _FAR_ _cdecl strcat(char _FAR_ *, const char _FAR_ *);
char _FAR_ * _FAR_ _cdecl strchr(const char _FAR_ *, int);
int _FAR_ _cdecl strcmp(const char _FAR_ *, const char _FAR_ *);
int _FAR_ _cdecl strcmpi(const char _FAR_ *, const char _FAR_ *);
int _FAR_ _cdecl strcoll(const char _FAR_ *, const char _FAR_ *);
int _FAR_ _cdecl stricmp(const char _FAR_ *, const char _FAR_ *);
char _FAR_ * _FAR_ _cdecl strcpy(char _FAR_ *, const char _FAR_ *);
size_t _FAR_ _cdecl strcspn(const char _FAR_ *, const char _FAR_ *);
char _FAR_ * _FAR_ _cdecl strdup(const char _FAR_ *);
char _FAR_ * _FAR_ _cdecl _strerror(const char _FAR_ *);
char _FAR_ * _FAR_ _cdecl strerror(int);
size_t _FAR_ _cdecl strlen(const char _FAR_ *);
char _FAR_ * _FAR_ _cdecl strlwr(char _FAR_ *);
char _FAR_ * _FAR_ _cdecl strncat(char _FAR_ *, const char _FAR_ *,
	size_t);
int _FAR_ _cdecl strncmp(const char _FAR_ *, const char _FAR_ *,
	size_t);
int _FAR_ _cdecl strnicmp(const char _FAR_ *, const char _FAR_ *,
	size_t);
char _FAR_ * _FAR_ _cdecl strncpy(char _FAR_ *, const char _FAR_ *,
	size_t);
char _FAR_ * _FAR_ _cdecl strnset(char _FAR_ *, int, size_t);
char _FAR_ * _FAR_ _cdecl strpbrk(const char _FAR_ *,
	const char _FAR_ *);
char _FAR_ * _FAR_ _cdecl strrchr(const char _FAR_ *, int);
char _FAR_ * _FAR_ _cdecl strrev(char _FAR_ *);
char _FAR_ * _FAR_ _cdecl strset(char _FAR_ *, int);
size_t _FAR_ _cdecl strspn(const char _FAR_ *, const char _FAR_ *);
char _FAR_ * _FAR_ _cdecl strstr(const char _FAR_ *,
	const char _FAR_ *);
char _FAR_ * _FAR_ _cdecl strtok(char _FAR_ *, const char _FAR_ *);
char _FAR_ * _FAR_ _cdecl strupr(char _FAR_ *);
size_t _FAR_ _cdecl strxfrm (char _FAR_ *, const char _FAR_ *,
	size_t);

/* model independent function prototypes */

void _far * _far _cdecl _fmemccpy(void _far *, const void _far *,
	int, unsigned int);
void _far * _far _cdecl _fmemchr(const void _far *, int, size_t);
int _far _cdecl _fmemcmp(const void _far *, const void _far *,
	size_t);
void _far * _far _cdecl _fmemcpy(void _far *, const void _far *,
	size_t);
int _far _cdecl _fmemicmp(const void _far *, const void _far *,
	unsigned int);
void _far * _far _cdecl _fmemmove(void _far *, const void _far *,
	size_t);
void _far * _far _cdecl _fmemset(void _far *, int, size_t);
char _far * _far _cdecl _fstrcat(char _far *, const char _far *);
char _far * _far _cdecl _fstrchr(const char _far *, int);
int _far _cdecl _fstrcmp(const char _far *, const char _far *);
int _far _cdecl _fstricmp(const char _far *, const char _far *);
char _far * _far _cdecl _fstrcpy(char _far *, const char _far *);
size_t _far _cdecl _fstrcspn(const char _far *, const char _far *);
char _far * _far _cdecl _fstrdup(const char _far *);
char _near * _far _cdecl _nstrdup(const char _far *);
size_t _far _cdecl _fstrlen(const char _far *);
char _far * _far _cdecl _fstrlwr(char _far *);
char _far * _far _cdecl _fstrncat(char _far *, const char _far *,
	size_t);
int _far _cdecl _fstrncmp(const char _far *, const char _far *,
	size_t);
int _far _cdecl _fstrnicmp(const char _far *, const char _far *,
	size_t);
char _far * _far _cdecl _fstrncpy(char _far *, const char _far *,
	size_t);
char _far * _far _cdecl _fstrnset(char _far *, int, size_t);
char _far * _far _cdecl _fstrpbrk(const char _far *,
	const char _far *);
char _far * _far _cdecl _fstrrchr(const char _far *, int);
char _far * _far _cdecl _fstrrev(char _far *);
char _far * _far _cdecl _fstrset(char _far *, int);
size_t _far _cdecl _fstrspn(const char _far *, const char _far *);
char _far * _far _cdecl _fstrstr(const char _far *,
	const char _far *);
char _far * _far _cdecl _fstrtok(char _far *, const char _far *);
char _far * _far _cdecl _fstrupr(char _far *);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\toolhelp\memory.asm ===
PAGE 60,150
;***************************************************************************
;*  MEMORY.ASM
;*
;*      Routines used to handle the read/write random memory API
;*
;***************************************************************************

        INCLUDE TOOLPRIV.INC
        INCLUDE WINDOWS.INC

;** Symbols
SI_CRITICAL     EQU     1
DI_CRITICAL     EQU     2

;** Imports
externA __AHINCR
externFP GlobalEntryHandle
externNP HelperHandleToSel

sBegin  CODE
        assumes CS,CODE
        assumes DS,DATA

;  MemoryRead
;       Uses the passed in selector and offset to read memory into a user-
;       specified buffer.  This works for >64K segments and, if code, may
;       have been discarded.
;
;       This function is normally used for heap selectors.  However, if
;       a non-global heap selector is used, it must be less than 64K on
;       a 286.
;
;       Prototype:
;               DWORD MemoryRead(
;                       WORD wSel,      /* Selector to read from */
;                       DWORD dwOffset, /* Offset to read at */
;                       LPSTR lpBuffer, /* Buffer to put data into */
;                       DWORD dwcb)     /* Number of characters to read */
;       Returns number of characters read (ends at segment limit)

cProc   MemoryRead, <FAR,PUBLIC>, <si,di,ds>
        parmW   wSelector
        parmD   dwOffset
        parmD   lpBuffer
        parmD   dwcb
        localD  dwcbCopied
        localV  Global,<SIZE GLOBALENTRY>
cBegin
        ;** Make sure the segment is present.  We only will fault the
        ;**     segment in if it is a code segment
        cCall   HelperHandleToSel, <wSelector> ;Convert to sel from handle
        mov     wSelector, ax           ;Save it so we have a good sel
        mov     cx, ax
        push    WORD PTR lpBuffer[2]    ;Convert handle to selector
        cCall   HelperHandleToSel
        mov     WORD PTR lpBuffer[2], ax ;Save converted handle
        lar     ax,cx                   ;Get the access rights
        jnz     MR_ShortBad             ;Failed.  It's bad
        test    ax,8000h                ;Is it present?
        jnz     MR_Present              ;Yes
        test    ax,0800h                ;This bit set for code segments
        jnz     MR_FaultIn              ;Code segment, fault it in
MR_ShortBad:
        jmp     MR_Bad                  ;Return error
MR_FaultIn:
        mov     es,wSelector            ;Get the selector in ES.
        mov     al,es:[0]               ;Must be at least one byte long
MR_Present:
        
        ;** Check this block's length.  We use the global heap functions
        ;*      to do this because they check in the arena for the length.
        ;*      This is the only way to get lengths of 286 heap blocks
        ;**     beyond 64K.
        mov     ax,SIZE GLOBALENTRY     ;Get the size of the structure
        mov     WORD PTR Global.ge_dwSize[0],ax ;Save in the structure
        mov     WORD PTR Global.ge_dwSize[2],0 ;Clear the HIWORD
        lea     ax,Global               ;Point to the structure
        cCall   GlobalEntryHandle, <ss,ax,wSelector>
        or      ax,ax                   ;Was this a valid selector?
        jnz     MR_HeapSel              ;Yes, this is a heap selector

        ;** If this wasn't a heap selector, we get the length with an LSL.
        ;**     When used like this, 64K is the max on a 286
MR_NonHeap:
        mov     bx,wSelector            ;Get the selector
        mov     ax,__WinFlags           ;Get the flags
        test    ax,WF_CPU286            ;286?
        jz      MR_32BitSize            ;No, do 32 bit size stuff
        lsl     dx,bx                   ;Get length in DX
        mov     WORD PTR Global.ge_dwBlockSize[0],dx ;Put in GLOBALENTRY struct
        mov     WORD PTR Global.ge_dwBlockSize[2],0
        jmp     SHORT MR_HeapSel
MR_32BitSize:
.386p
        lsl     edx,ebx
        mov     Global.ge_dwBlockSize,edx ;Put in GLOBALENTRY struct for later
.286p

MR_HeapSel:
        mov     dx,WORD PTR dwOffset[2] ;Get the HIWORD of segment offset
        cmp     dx,WORD PTR Global.ge_dwBlockSize[2] ;Check HIWORD of size
        jb      MR_OK                   ;Offset should be OK
        je      @F                      ;Equal.  Must check LOWORD
        jmp     MR_Bad                  ;Offset is not inside segment
@@:     mov     ax,WORD PTR dwOffset[0] ;Get the LOWORD of segment offset
        cmp     ax,WORD PTR Global.ge_dwBlockSize[0] ;Check LOWORD of size
        jb      MR_OK                   ;It's inside segment
        jmp     MR_Bad                  ;Not inside segment
MR_OK:

        ;** Do different stuff on 286 and 386/486
        mov     ax,__WinFlags           ;Get the flags
        test    ax,WF_CPU286            ;286?
        jnz     MR_Do16Bit              ;Yes, do 16 bit stuff

        ;** Do this the 386 way (easy)
.386p
        mov     ax,wSelector            ;Point with DS
        mov     ds,ax                   ;  (keep copy in AX)
        mov     esi,dwOffset            ;Point into the big segment
        mov     ecx,dwcb                ;Get the copy length
        lsl     edx,eax                 ;Get the segment limit
        sub     edx,esi                 ;Get distance from offset to limit
        inc     edx                     ;Make this the real length
        cmp     ecx,edx                 ;Are we within the limit?
        jbe     SHORT MR_LimitOK        ;Yes
        mov     ecx,edx                 ;No, so make this the copy amount
MR_LimitOK:
        mov     edx,ecx                 ;Get the # of bytes to read for ret
        xor     edi,edi                 ;Clear the high word
        les     di,lpBuffer             ;Point to the dest. buffer
        mov     ax,cx                   ;Save the low bits of ECX
        shr     ecx,2                   ;Prepare for DWORD move
        jecxz   @F                      ;No zero-length DWORD moves!
        rep     movs  DWORD PTR [edi],DWORD PTR [esi]
        db      67h                     ;Handles 386 bug
        db      90h
@@:     mov     cx,ax                   ;Get a copy
        jecxz   @F                      ;Don't do zero!
        and     cx,03                   ;Do the remaining 3,2, or 1
        rep     movs BYTE PTR [edi], BYTE PTR [esi]
        db      67h                     ;Handles 386 bug
        db      90h
@@:     mov     ax,dx                   ;Bytes copied returned in DX:AX
        shr     edx,16
        jmp     MR_End                  ;Get out
.286p

        ;** Do this the 286 way (hard)
MR_Do16Bit:
        
        ;** Compute the actual copy length
        mov     ax,WORD PTR Global.ge_dwBlockSize[0] ;Get the segment size
        mov     dx,WORD PTR Global.ge_dwBlockSize[2]
        sub     ax,WORD PTR dwOffset[0] ;Get distance from offset to limit
        sbb     dx,WORD PTR dwOffset[2]
        cmp     dx,WORD PTR dwcb[2]     ;Off end of heap block?
        ja      MR_LimOk                ;No, just do it
        jb      MR_Truncate             ;Yes, must truncate our length
        cmp     ax,WORD PTR dwcb[0]     ;Are we off the end?
        jae     MR_LimOk                ;No, just do it
MR_Truncate:
        mov     WORD PTR dwcb[0],ax     ;Force this to be the new length
        mov     WORD PTR dwcb[2],dx
MR_LimOk:

        ;** Save the number of bytes to be copied for the return value
        mov     ax,WORD PTR dwcb[0]     ;Get the LOWORD
        mov     WORD PTR dwcbCopied[0],ax ;Save it
        mov     ax,WORD PTR dwcb[2]     ;Get the HIWORD
        mov     WORD PTR dwcbCopied[2],ax ;Save it

        ;** Position the initial copying selectors
        mov     al,BYTE PTR dwOffset[2] ;Grab the HIWORD (286 is only 24 bits)
        mov     ah,__AHINCR             ;Get the selector inc value
        mul     ah                      ;Multiply to get sel offset
        add     ax,wSelector            ;AX = sel in sel array
        mov     ds,ax                   ;Point to this with DS
        mov     si,WORD PTR dwOffset[0] ;Get the current pointers
        les     di,lpBuffer

        ;** This is the main copying loop
MR_CopyLoop:
        
        ;** Compute the size of this block copy.  This is done by finding the
        ;*      smaller of the following quantities:
        ;*      - Distance to end of source segment
        ;*      - Distance to end of dest. segment
        ;**     - Distance to end of copy
        xor     bx,bx                   ;Flags start at zero
        xor     cx,cx                   ;Get the highest segment value (64K)
        cmp     di,si                   ;The bigger of the two will win
        je      MR_Equal                ;They're the same
        ja      MR_DIBigger             ;DI is bigger
        sub     cx,si                   ;SI bigger, compute dist to end
        or      bx,SI_CRITICAL          ;Flag set for SI-critical
        jmp     SHORT MR_CheckEndCopy   ;Go on
MR_Equal:
        sub     cx,di                   ;Use DI (SI and DI are the same)
        or      bx,SI_CRITICAL OR DI_CRITICAL ;Both will come true
        jmp     SHORT MR_CheckEndCopy   ;Go on
MR_DIBigger:
        sub     cx,di                   ;SI is bigger
        or      bx,DI_CRITICAL          ;Flag clear for DI-critical
MR_CheckEndCopy:
        cmp     WORD PTR dwcb[2],0      ;Check for less than 64K left
        ja      MR_DoCopy               ;Nope.  More than 64K left
        jcxz    MR_GetSize              ;CX = 0 is full 64K segment
        cmp     WORD PTR dwcb[0],cx     ;Less than in either segment left?
        ja      MR_DoCopy               ;No.  Do it
MR_GetSize:
        mov     cx,WORD PTR dwcb[0]     ;Get in CX
MR_DoCopy:

        ;** Do this block of 64K or less.
        mov     dx,cx                   ;Save the number of bytes we did
        jcxz    @F                      ;Do 64K
        shr     cx,1                    ;Do WORDS
        jmp     SHORT MR_10             ;Skip over
@@:     mov     cx,8000h                ;32K WORDS
MR_10:  jcxz    @F                      ;No zero length WORD moves!
        rep     movsw                   ;Do the copy
@@:     mov     cx,dx                   ;Get any remaining bits
        and     cx,1                    ;Any more to do?
        jcxz    @F                      ;No, don't do it
        movsb                           ;Do the odd byte if necessary
@@:     mov     cx,dx                   ;Get back in CX

        ;** Bump the loop pointers
        jcxz    MR_BigCount             ;We did 64K
        sub     WORD PTR dwcb[0],cx     ;Subtract the bytes done
        sbb     WORD PTR dwcb[2],0      ;  and don't forget the HIWORD
        jmp     SHORT MR_20             ;Continue
MR_BigCount:
        sub     WORD PTR dwcb[2],1      ;Subtract 64K
MR_20:  mov     ax,WORD PTR dwcb[0]     ;We're done if the count of bytes
        or      ax,WORD PTR dwcb[2]     ;  is zero
        jnz     @F                      ;Not zero, go on
        mov     dx,WORD PTR dwcbCopied[2] ;Get the return count
        mov     ax,WORD PTR dwcbCopied[0]
        jmp     SHORT MR_End            ;Get out
@@:     test    bx,SI_CRITICAL          ;Does SI need incrementing?
        jz      MR_TestDI               ;No, try DI
        mov     ax,ds                   ;Get the segment value
        add     ax,__AHINCR             ;Bump to next selector
        mov     ds,ax                   ;Point with DS still
        xor     si,si                   ;Point to start of this segment
MR_TestDI:
        test    bx,DI_CRITICAL          ;Does SI need incrementing?
        jz      MR_Continue             ;No, try DI
        mov     ax,es                   ;Get the segment value
        add     ax,__AHINCR             ;Bump to next selector
        mov     es,ax                   ;Point with DS still
        xor     di,di                   ;Point to start of this segment
MR_Continue:
        jmp     MR_CopyLoop             ;Do it again

MR_Bad:
        xor     ax,ax                   ;Return DWORD 0
        cwd

MR_End:

cEnd


;  MemoryWrite
;       Uses the passed in selector and offset to write memory from a user-
;       specified buffer.  This works for >64K segments and, if code, may
;       have been discarded.  The selector may be a selector or a handle
;       but MUST be on the global heap (no aliases or selector array
;       members).  If worried about low memory conditions, lpBuffer should
;       be in a (temporarily) fixed segment.
;
;       Prototype:
;               DWORD MemoryWrite(
;                       WORD wSel,      /* Selector to read from */
;                       DWORD dwOffset, /* Offset to read at */
;                       LPSTR lpBuffer, /* Buffer to put data into */
;                       DWORD dwcb)     /* Number of characters to read */
;       Returns number of characters read (ends at segment limit)

cProc   MemoryWrite, <FAR,PUBLIC>, <si,di,ds>
        parmW   wSelector
        parmD   dwOffset
        parmD   lpBuffer
        parmD   dwcb
        localW  wSelFlag
        localD  dwcbCopied
        localV  DPMISelBuf,8
        localV  Global,<SIZE GLOBALENTRY>
cBegin
        ;** Make sure the segment is present.  We only will fault the
        ;**     segment in if it is a code segment
        cCall   HelperHandleToSel, <wSelector> ;Convert to sel from handle
        mov     wSelector, ax           ;Save it
        mov     cx,ax                   ;Get the selector
        push    WORD PTR lpBuffer[2]    ;Convert handle to selector
        cCall   HelperHandleToSel
        mov     WORD PTR lpBuffer[2], ax ;Save converted handle
        mov     wSelFlag,0              ;Clear the flag
        lar     ax,cx                   ;Get the access rights
        jnz     MW_ShortBad             ;Failed
        test    ax,8000h                ;Is it present?
        jnz     MW_Present              ;Yes
        test    ax,0800h                ;This bit set for code segments
        jnz     MW_FaultIn              ;Code segment, fault it in
MW_ShortBad:
        jmp     MW_Bad                  ;Return error
MW_FaultIn:
        mov     es,wSelector            ;Get the selector in ES.
        mov     al,es:[0]               ;Must be at least one byte long
MW_Present:
        
        ;** Check this block's length.  We use the global heap functions
        ;*      to do this because they check in the arena for the length.
        ;*      This is the only way to get lengths of 286 heap blocks
        ;**     beyond 64K.
        mov     ax,SIZE GLOBALENTRY     ;Get the size of the structure
        mov     WORD PTR Global.ge_dwSize[0],ax ;Save in the structure
        mov     WORD PTR Global.ge_dwSize[2],0 ;Clear the HIWORD
        lea     ax,Global               ;Point to the structure
        cCall   GlobalEntryHandle, <ss,ax,wSelector>
        or      ax,ax                   ;Was this a valid selector?
        jnz     MW_HeapSel              ;Yes, this is a heap selector

        ;** If this wasn't a heap selector, we get the length with an LSL.
        ;**     When used like this, 64K is the max on a 286
MW_NonHeap:
        mov     bx,wSelector            ;Get the selector
        mov     ax,__WinFlags           ;Get the flags
        test    ax,WF_CPU286            ;286?
        jz      MW_32BitSize            ;No, do 32 bit size stuff
        lsl     dx,bx                   ;Get length in DX
        mov     WORD PTR Global.ge_dwBlockSize[0],dx ;Put in GLOBALENTRY struct
        mov     WORD PTR Global.ge_dwBlockSize[2],0
        jmp     SHORT MW_HeapSel
MW_32BitSize:
.386p
        lsl     edx,ebx
        mov     Global.ge_dwBlockSize,edx ;Put in GLOBALENTRY struct for later
.286p

MW_HeapSel:
        mov     dx,WORD PTR dwOffset[2] ;Get the HIWORD of segment offset
        cmp     dx,WORD PTR Global.ge_dwBlockSize[2] ;Check HIWORD of size
        jb      MW_OK                   ;Offset should be OK
        je      @F                      ;Equal.  Must check LOWORD
        jmp     MW_Bad                  ;Offset is not inside segment
@@:     mov     ax,WORD PTR dwOffset[0] ;Get the LOWORD of segment offset
        cmp     ax,WORD PTR Global.ge_dwBlockSize[0] ;Check LOWORD of size
        jb      MW_OK                   ;It's inside segment
        jmp     MW_Bad                  ;Not inside segment
MW_OK:
        ;** Do different stuff on 286 and 386/486
        mov     ax,__WinFlags           ;Get the flags
        test    ax,WF_CPU286            ;286?
        jnz     MW_Do16Bit              ;Yes, do 16 bit stuff

        ;** Do this the 386 way (easy)
.386p
        ;** Get an alias selector if necessary
        mov     ax,wSelector            ;Get the source selector
        push    ss                      ;Get ES = SS
        pop     es
        lea     di,DPMISelBuf           ;Point to our descriptor buffer
        cCall   MakeAlias               ;Make the alias selector
        jnc     SHORT @F                ;No error
        jmp     MW_Bad                  ;Must be error
@@:     mov     wSelFlag,bx             ;Set the selector flag
        mov     wSelector,ax            ;Save the new selector

        ;** Do the copying
        mov     ax,wSelector            ;Point with DS
        mov     es,ax                   ;  (keep copy in AX)
        mov     edi,dwOffset            ;Point into the big segment
        mov     ecx,dwcb                ;Get the copy length
        lsl     edx,eax                 ;Get the segment limit
        sub     edx,edi                 ;Get distance from offset to limit
        inc     edx                     ;Make this the real length
        cmp     ecx,edx                 ;Are we within the limit?
        jbe     SHORT MW_LimitOK        ;Yes
        mov     ecx,edx                 ;No, so make this the copy amount
MW_LimitOK:
        xor     esi,esi                 ;Clear the high word
        lds     si,lpBuffer             ;Point to the dest. buffer
        mov     eax,ecx                 ;Save ECX
        shr     ecx,2                   ;Prepare for DWORD move
        jecxz   @F                      ;No zero-length DWORD moves!
        rep     movs  DWORD PTR [edi],DWORD PTR [esi]
        db      67h                     ;Handles 386 bug
        db      90h
@@:     mov     ecx,eax                 ;Get a copy
        jecxz   @F                      ;Don't do zero!
        and     ecx,03                  ;Do the remaining 3,2, or 1
        rep     movs BYTE PTR [edi], BYTE PTR [esi]
        db      67h                     ;Handles 386 bug
        db      90h
@@:     mov     edx,eax                 ;Bytes copied returned in DX:AX
        shr     edx,16

        ;** Free alias if necessary
        push    ax                      ;Save return value
        push    dx
        cmp     wSelFlag,0              ;Selector flag set?
        je      SHORT @F                ;Nope
        mov     ax,1                    ;DPMI function - Free Selector
        mov     bx,wSelector            ;Selector to free
        int     31h                     ;Call DPMI
@@:     pop     dx
        pop     ax
        jmp     MW_End                  ;Get out
.286p

        ;** Do this the 286 way (hard)
MW_Do16Bit:
        
        ;** Compute the actual copy length
        mov     ax,WORD PTR Global.ge_dwBlockSize[0] ;Get the segment size
        mov     dx,WORD PTR Global.ge_dwBlockSize[2]
        sub     ax,WORD PTR dwOffset[0] ;Get distance from offset to limit
        sbb     dx,WORD PTR dwOffset[2]
        cmp     dx,WORD PTR dwcb[2]     ;Off end of heap block?
        ja      MW_LimOk                ;No, just do it
        jb      MW_Truncate             ;Yes, must truncate our length
        cmp     ax,WORD PTR dwcb[0]     ;Are we off the end?
        jae     MW_LimOk                ;No, just do it
MW_Truncate:
        mov     WORD PTR dwcb[0],ax     ;Force this to be the new length
        mov     WORD PTR dwcb[2],dx
MW_LimOk:

        ;** Save the number of bytes to be copied for the return value
        mov     ax,WORD PTR dwcb[0]     ;Get the LOWORD
        mov     WORD PTR dwcbCopied[0],ax ;Save it
        mov     ax,WORD PTR dwcb[2]     ;Get the HIWORD
        mov     WORD PTR dwcbCopied[2],ax ;Save it

        ;** Position the initial copying selectors
        mov     al,BYTE PTR dwOffset[2] ;Grab the HIWORD (286 is only 24 bits)
        mov     ah,__AHINCR             ;Get the selector inc value
        mul     ah                      ;Multiply to get sel offset
        add     ax,wSelector            ;AX = sel in sel array
        mov     es,ax                   ;Point to this with DS
        mov     di,WORD PTR dwOffset[0] ;Get the current pointers
        lds     si,lpBuffer

        ;** This is the main copying loop
MW_CopyLoop:

        ;** Get an alias selector if necessary
        push    si                      ;Save regs
        push    di
        mov     ax,es                   ;Get the source selector
        push    ss                      ;Get ES = SS
        pop     es
        lea     di,DPMISelBuf           ;Point to our descriptor buffer
        cCall   MakeAlias               ;Make the alias selector
        pop     di                      ;Restore regs
        pop     si
        jnc     @F                      ;No error
        jmp     MW_Bad                  ;Must be error
@@:     mov     wSelFlag,bx             ;Set the selector flag
        mov     es,ax                   ;Save the new selector
        
        ;** Compute the size of this block copy.  This is done by finding the
        ;*      smaller of the following quantities:
        ;*      - Distance to end of source segment
        ;*      - Distance to end of dest. segment
        ;**     - Distance to end of copy
        xor     bx,bx                   ;Flags start at zero
        xor     cx,cx                   ;Get the highest segment value (64K)
        cmp     di,si                   ;The bigger of the two will win
        je      MW_Equal                ;They're the same
        ja      MW_DIBigger             ;DI is bigger
        sub     cx,si                   ;SI bigger, compute dist to end
        or      bx,SI_CRITICAL          ;Flag set for SI-critical
        jmp     SHORT MW_CheckEndCopy   ;Go on
MW_Equal:
        sub     cx,di                   ;Use DI (SI and DI are the same)
        or      bx,SI_CRITICAL OR DI_CRITICAL ;Both will come true
        jmp     SHORT MW_CheckEndCopy   ;Go on
MW_DIBigger:
        sub     cx,di                   ;SI is bigger
        or      bx,DI_CRITICAL          ;Flag clear for DI-critical
MW_CheckEndCopy:
        cmp     WORD PTR dwcb[2],0      ;Check for less than 64K left
        ja      MW_DoCopy               ;Nope.  More than 64K left
        jcxz    MW_GetSize              ;CX = 0 is full 64K segment
        cmp     WORD PTR dwcb[0],cx     ;Less than in either segment left?
        ja      MW_DoCopy               ;No.  Do it
MW_GetSize:
        mov     cx,WORD PTR dwcb[0]     ;Get in CX
MW_DoCopy:

        ;** Do this block of 64K or less.
        mov     dx,cx                   ;Save the number of bytes we did
        jcxz    @F                      ;Do 64K
        shr     cx,1                    ;Do WORDS
        jmp     SHORT MW_10             ;Skip over
@@:     mov     cx,8000h                ;32K WORDS
MW_10:  jcxz    @F                      ;No zero-length WORD moves
        rep     movsw                   ;Do the copy
@@:     mov     cx,dx                   ;Get any remaining bits
        and     cx,1                    ;Any more to do?
        jcxz    @F                      ;No, don't do it
        movsb                           ;Do the odd byte if necessary
@@:     mov     cx,dx                   ;Get back in CX

        ;** Bump the loop pointers
        jcxz    MW_BigCount             ;We did 64K
        sub     WORD PTR dwcb[0],cx     ;Subtract the bytes done
        sbb     WORD PTR dwcb[2],0      ;  and don't forget the HIWORD
        jmp     SHORT MW_20             ;Continue
MW_BigCount:
        sub     WORD PTR dwcb[2],1      ;Subtract 64K
MW_20:  mov     ax,WORD PTR dwcb[0]     ;We're done if the count of bytes
        or      ax,WORD PTR dwcb[2]     ;  is zero
        jnz     @F                      ;Not zero, go on
        mov     dx,WORD PTR dwcbCopied[2] ;Get the return count
        mov     ax,WORD PTR dwcbCopied[0]
        jmp     SHORT MW_End            ;Get out
@@:     test    bx,SI_CRITICAL          ;Does SI need incrementing?
        jz      MW_TestDI               ;No, try DI
        mov     ax,ds                   ;Get the segment value
        add     ax,__AHINCR             ;Bump to next selector
        mov     ds,ax                   ;Point with DS still
        xor     si,si                   ;Point to start of this segment
MW_TestDI:
        test    bx,DI_CRITICAL          ;Does SI need incrementing?
        jz      MW_Continue             ;No, try DI
        mov     ax,es                   ;Get the segment value
        add     ax,__AHINCR             ;Bump to next selector
        mov     es,ax                   ;Point with DS still
        xor     di,di                   ;Point to start of this segment
MW_Continue:

        ;** Free alias if necessary
        cmp     wSelFlag,0              ;Selector flag set?
        je      @F                      ;Nope
        mov     ax,1                    ;DPMI function - Free Selector
        mov     bx,wSelector            ;Selector to free
        int     31h                     ;Call DPMI
@@:     jmp     MW_CopyLoop             ;Do it again

MW_Bad:
        xor     ax,ax                   ;Return DWORD 0
        cwd

MW_End:

cEnd


;** Helper functions

;  MakeAlias
;       Makes an alias selector for the selector in AX.  The new selector
;       is returned in AX.  Carry is set on exit if error.
;       Returns nonzero in BX if an alias was made, zero if not
;       ES:DI points to an 8-byte descriptor buffer

cProc   MakeAlias, <NEAR, PUBLIC>, <si,di>
cBegin

        ;** If this is not a read/write selector, we must create an alias.
        ;*      In order to be able to free up the selector, we set a flag
        ;**     so we know to free it.
        xor     si,si                   ;No alias made, just in case
        lar     cx,ax                   ;Get its access rights
        jnz     MA_Bad                  ;Failed
        test    cx,800h                 ;Is this a code segment?
        jnz     MA_MakeAlias            ;Yes.  Always make an alias
        test    cx,200h                 ;Is it read/write?
        jnz     MA_End                  ;Yes, no need for alias
MA_MakeAlias:
        mov     bx,ax                   ;Get the selector
        mov     ax,0bh                  ;DPMI function - Get Descriptor
                                        ;ES:DI already point to buffer
        int     31h                     ;Call DPMI
        jc      MA_Bad                  ;Error
        xor     ax,ax                   ;DPMI Function - Alloc selector
        mov     cx,1                    ;Alloc 1 selector
        int     31h                     ;Call DPMI
        jc      MA_Bad                  ;Error
        mov     si,1                    ;Set flag to say alias made
        and     BYTE PTR DPMISelBuf[5],0f0h ;Mask out unwanted bits
        or      BYTE PTR DPMISelBuf[5],2 ;Make it a R/W Data segment
        mov     bx,ax                   ;Selector in BX
        mov     ax,0ch                  ;DPMI function - Set Descriptor
        int     31h                     ;Call DPMI
        jc      MA_Bad                  ;Error
        mov     ax,bx                   ;Get the new selector in AX
        jmp     SHORT MA_End            ;Get out

MA_Bad:
        stc                             ;Error

MA_End:
        mov     bx,si                   ;Get flag in BX
cEnd


sEnd

        END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\toolhelp\signal.c ===
/**************************************************************************
 *  SIGNAL.C
 *
 *      Routines used to clean up on a forced KERNEL termination of a
 *      TOOLHELP using app.
 *
 **************************************************************************/

#include <string.h>
#include "toolpriv.h"

/* ----- Global variables ----- */
    WORD wSignalInstalled;
    SIGNAL NEAR *npSignalHead;

/*  SignalRegister
 *      Registers a default signal proc to a task.  This signal proc is
 *      called when the task is about to be terminated and is called before
 *      the USER signal proc is called.  The registered callback is
 *      called HelperSignalProc() [HELPER.ASM] and chains to the USER signal
 *      proc (if any) instead of returning.
 */

BOOL PASCAL SignalRegister(
    HANDLE hTask)
{
    SIGNAL *pSig;
    SIGNAL *pTemp;

    /* NULL hTask means current task */
    if (!hTask)
        hTask = GetCurrentTask();

    /* Check to see if this task is already registered */
    for (pSig = npSignalHead ; pSig ; pSig = pSig->pNext)
        if (pSig->hTask == hTask)
            return FALSE;

    /* Allocate a new SIGNAL structure */
    pSig = (SIGNAL *)LocalAlloc(LMEM_FIXED, sizeof (SIGNAL));
    if (!pSig)
        return FALSE;

    /* Fill in the useful fields */
    pSig->hTask = hTask;
    pSig->lpfn = (LPFNCALLBACK)HelperSignalProc;
    pSig->lpfnOld = (LPFNCALLBACK)
        HelperSetSignalProc(hTask, (DWORD)HelperSignalProc);

    /* If this is the only handler, just insert it */
    if (!npSignalHead)
    {
        pSig->pNext = npSignalHead;
        npSignalHead = pSig;
    }

    /* Otherwise, insert at the end of the list */
    else
    {
        for (pTemp = npSignalHead ; pTemp->pNext ; pTemp = pTemp->pNext)
            ;
        pSig->pNext = pTemp->pNext;
        pTemp->pNext = pSig;
    }

    return TRUE;
}


/*  SignalUnRegister
 *      Called by an app whose callback is no longer to be used.
 *      NULL hTask uses current task.
 */

BOOL PASCAL SignalUnRegister(
    HANDLE hTask)
{
    SIGNAL *pSig;
    SIGNAL *pBefore;

    /* NULL hTask means current task */
    if (!hTask)
        hTask = GetCurrentTask();

    /* First try to find the task */
    pBefore = NULL;
    for (pSig = npSignalHead ; pSig ; pSig = pSig->pNext)
        if (pSig->hTask == hTask)
            break;
        else
            pBefore = pSig;
    if (!pSig)
        return FALSE;

    /* Remove it from the list */
    if (!pBefore)
        npSignalHead = pSig->pNext;
    else
        pBefore->pNext = pSig->pNext;

    /* Replace the old signal proc */
    HelperSetSignalProc(hTask, (DWORD)pSig->lpfnOld);

    /* Free the structure */
    LocalFree((HANDLE)pSig);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\toolhelp\stack1.c ===
/***************************************************************************
 *  STACK1.C
 *
 *      Code to support stack tracing on task stacks.
 *
 ***************************************************************************/

#include "toolpriv.h"
#include <newexe.h>
#include <string.h>

/* ----- Function prototypes ----- */

    NOEXPORT void StackTraceInfo(
        STACKTRACEENTRY FAR *lpStack);

/* ----- Functions ----- */

/*  StackTraceFirst
 *      Starts a task stack trace by returning information about the
 *      first frame on the task's stack.
 */

BOOL TOOLHELPAPI StackTraceFirst(
    STACKTRACEENTRY FAR *lpStackTrace,
    HANDLE hTDB)
{
    /* Check the version number and verify proper installation */
    if (!wLibInstalled || !lpStackTrace ||
        lpStackTrace->dwSize != sizeof (STACKTRACEENTRY))
        return FALSE;

    /* Get the first value */
    if (!(StackFrameFirst(lpStackTrace, hTDB)))
        return FALSE;

    /* Get module and segment number information */
    StackTraceInfo(lpStackTrace);

    return TRUE;
}


/*  StackTraceCSIPFirst
 *      Traces the stack of an arbitrary CS:IP.  All parameters must be
 *      given, and once started, the StackTraceNext function can be used
 *      to trace the remainder of the stack
 */

BOOL TOOLHELPAPI StackTraceCSIPFirst(
    STACKTRACEENTRY FAR *lpStack,
    WORD wSS,
    WORD wCS,
    WORD wIP,
    WORD wBP)
{
    /* Check the version number and verify proper installation */
    if (!wLibInstalled || !lpStack ||
        lpStack->dwSize != sizeof (STACKTRACEENTRY))
        return FALSE;

    /* Get the user information */
    lpStack->wSS = wSS;
    lpStack->wCS = wCS;
    lpStack->wIP = wIP;
    lpStack->wBP = wBP;

    /* Get module and segment number information */
    StackTraceInfo(lpStack);

    /* Set the hTask to the current task as we are in the current task
     *  context.  The CS may not be owned by this task, but at least
     *  we put a reasonable value in there.
     */
    lpStack->hTask = GetCurrentTask();

    return TRUE;
}


/*  StackTraceNext
 *      Continues a stack trace by returning information about the next
 *      frame on the task's stack.
 *      structure.
 */

BOOL TOOLHELPAPI StackTraceNext(
    STACKTRACEENTRY FAR *lpStackTrace)
{
    /* Check the version number and verify proper installation */
    if (!wLibInstalled || !lpStackTrace ||
        lpStackTrace->dwSize != sizeof (STACKTRACEENTRY))
        return FALSE;

    /* Get information about this frame */
    if (!StackFrameNext(lpStackTrace))
        return FALSE;

    /* Get module and segment number information */
    StackTraceInfo(lpStackTrace);

    return TRUE;
}

/* ----- Helper functions ----- */

/*  StackTraceInfo
 *      Gets module and segment number info about the given entry
 */

NOEXPORT void StackTraceInfo(
    STACKTRACEENTRY FAR *lpStack)
{
    GLOBALENTRY GlobalEntry;
    struct new_exe FAR *lpNewExe;
    struct new_seg1 FAR *lpSeg;
    WORD i;

    /* If we have a NULL CS, this is a NEAR frame.  Just return because we
     *  assume the user hasn't trashed the structure.  The module and seg
     *  info will be the same as the last time
     */
    if (!lpStack->wCS)
        return;

    /* Get information about the code segment block */
    GlobalEntry.dwSize = sizeof (GLOBALENTRY);
    if (!GlobalEntryHandle(&GlobalEntry, lpStack->wCS))
        return;

    /* The owner of all code segments is the hModule */
    lpStack->hModule = GlobalEntry.hOwner;

    /* To find the segment number, we look in the EXE header and count the
     *  listed segments till we find this one
     */

    /* Get a pointer to the EXE Header module */
    lpNewExe = MAKEFARPTR(HelperHandleToSel(lpStack->hModule), 0);

    /* Make sure this is a EXE Header segment */
    if (lpNewExe->ne_magic != NEMAGIC)
        return;

    /* Get the list of segments and go for it */
    lpSeg = MAKEFARPTR(HIWORD((DWORD)lpNewExe), lpNewExe->ne_segtab);
    for (i = 0 ; i < lpNewExe->ne_cseg ; ++i, ++lpSeg)
        if (HelperHandleToSel(lpSeg->ns_handle) == lpStack->wCS)
            break;
    if (i == lpNewExe->ne_cseg)
        return;

    /* Save the segment number (seg numbers start at one) */
    lpStack->wSegment = i + 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\toolhelp\ththunks.asm ===
TITLE   THTHUNKS.ASM
    PAGE    ,132
;
; WOW v1.0
;
; Copyright (c) 1991-1992, Microsoft Corporation
;
; THTHUNKS.ASM
; Thunks in 16-bit space to route Windows API calls to WOW32
;
; History:
;
;   09-Nov-1992 Dave Hart (davehart)
;   Adapted from mvdm\wow16\kernel31\kthunks.asm for ToolHelp
;
;   02-Apr-1991 Matt Felton (mattfe)
;   Created.
;

ifndef WINDEBUG
    KDEBUG = 0
    WDEBUG = 0
else
    KDEBUG = 1
    WDEBUG = 1
endif


    .286p

    .xlist
    include cmacros.inc
    include wow.inc
    include wowth.inc
    .list

externFP WOW16Call

sBegin  CODE
assumes CS,CODE
assumes DS,NOTHING
assumes ES,NOTHING

; Kernel API thunks

    ToolHelpThunk ClassFirst
    ToolHelpThunk ClassNext


sEnd    CODE

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\toolhelp\terminat.asm ===
PAGE 60,150
;***************************************************************************
;*  TERMINAT.ASM
;*
;*      Assembly code routine used for the TOOLHELP.DLL app terminate
;*      routine.
;*
;***************************************************************************

        INCLUDE TOOLPRIV.INC
        INCLUDE TDB.INC

;** Symbols
I_EXCEPTION     EQU     0
I_INTERRUPT     EQU     1
MAX_INTERRUPT   EQU     5
GIVE_WDEB386    EQU     8000h
Q_HACK_30       EQU     54h

.286p

;** Data

sBegin  DATA

wTermFlags      DW      ?               ;Save terminate flags across Yield

sEnd

;** Imported values
externFP InterruptUnRegister
externFP NotifyUnRegister
externFP GetCurrentTask
externFP FatalAppExit
externFP TaskSetCSIP
externFP DirectedYield
externFP TaskSwitch

sBegin  CODE
        assumes CS,CODE
        assumes DS,DATA

;  TerminateApp
;       Terminates the task in one of two ways:  TERMINATE_NORMAL or
;       TERMINATE_USER_DISPLAY.  TERMINATE_NORMAL calls KERNEL to display
;       the UAE box and terminates the app.  TERMINATE_USER_DISPLAY also
;       terminates the app but assumes the user has displayed some warning.
;       If the task passed in is not the current task, this function does
;       the DirectedYield() to switch to the correct task before terminating
;       it.
;       This function does not return when terminating the current task
;       except when WDEB386 is installed and the (undocumented) GIVE_WDEB386
;       flag is set.
;       Caller:         TerminateApp(
;                               HANDLE hTask,  (If NULL, does current task)
;                               WORD wFlags)

cProc   TerminateApp, <FAR,PUBLIC>, <si,di,ds>
        parmW   hTask
        parmW   wFlags
cBegin
        mov     ax, _DATA               ;Get our DS
        mov     ds, ax

        ;** Save the flags in the DS so we can get after DYield
        mov     ax,wFlags               ;Get the parameter flags
        mov     wTermFlags,ax           ;Save them

        ;** Get the task value
        cCall   GetCurrentTask          ;Get the task
        mov     si,hTask                ;Get the hTask value
        or      si,si                   ;Zero?
        jnz     TA_10                   ;No
        mov     es,ax                   ;Point ES at current task
        jmp     SHORT TA_NukeCurrent    ;In this case we always nuke current
TA_10:
        ;** If this is the current task, just nuke it and don't return
        cmp     ax,si                   ;Current?
        mov     es,si                   ;Point ES at task
        je      TA_NukeCurrent          ;Yes, nuke it directly

        ;** Switch to the new task and prepare to nuke it
        lea     ax,TA_NewTask           ;Get address of new task entry
        cCall   TaskSwitch, <si,cs,ax>  ;Switch to this task
        jmp     SHORT TA_End            ;Get out

        ;** We're in the new task now
TA_NewTask:
        mov     ax,_DATA                ;Get the TOOLHELP DS
        mov     ds,ax
        mov     es,segKernel            ;Get the KERNEL segment
        mov     bx,npwTDBCur            ;Get the current task pointer
        mov     es,es:[bx]              ;Get the TDB pointer in ES

        ;** HACK ALERT!!!! In order to get USER to allow us to terminate
        ;*      this app, we are manually nuking the semaphore.  This is
        ;*      at a fixed offsets in the Q structure and only needs to
        ;**     be done in 3.0
        test    wTHFlags,TH_WIN30       ;In 3.0?
        jz      TA_NukeCurrent          ;No, don't do this ugly hack
        push    es                      ;Save ES while we play with the queue
        mov     es,es:[TDB_Queue]       ;ES points to queue now
        mov     bx,Q_HACK_30            ;Get 3.0 offset
        mov     WORD PTR es:[bx],0      ;Clear the semaphore count
        mov     WORD PTR es:[bx + 2],0  ;  and the semaphore value to wait for
        pop     es                      ;ES points to TDB again

TA_NukeCurrent:
        ;** Check the flag values.  If NO_UAE_BOX, tell KERNEL
        ;**     not to display the normal UAE box.
        test    wTermFlags,NO_UAE_BOX   ;Display the box?
        jz      TA_20                   ;Yes, so skip this stuff
        or      es:[TDB_ErrMode],02     ;Set the no display box flag
TA_20:
        ;** Terminate the app using KERNEL
        cCall   FatalAppExit, <0,0,0>   ;Do it

        ;** If we're flagged that this is an internal terminate, we just want
        ;*      to return if WDEB is installed so that we can pass the
        ;**     fault on.  To do this, we must return here to the caller.
        test    wFlags,GIVE_WDEB386     ;Internal entry?
        jnz     TA_End                  ;Yes, don't nuke app

        ;** If KERNEL doesn't nuke the app (does this if WDEB386
        ;**     is installed), nuke it ourselves (no UAE box)
        mov     es,segKernel            ;Get the KERNEL segment
        mov     bx,npwTDBCur            ;Get the current task pointer
        mov     es,es:[bx]              ;  in ES
        cmp     WORD PTR es:[TDB_USignalProc] + 2,0 ;USER signal proc?
        jz      @F                      ;No
        mov     bx,0666h                ;Death knell
        mov     di, -1
        cCall   es:[TDB_USignalProc],<es,bx,di,es:[TDB_Module],es:[TDB_Queue]>
@@:     mov     ax,4CFFH                ;Nuke the app
        int     21h                     ;We don't return here

TA_End:

cEnd

sEnd

        END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\toolhelp\stack2.asm ===
;**************************************************************************
;*  STACK2.ASM
;*
;*      Assembly support code for stack tracing.
;*
;**************************************************************************

        INCLUDE TOOLPRIV.INC
        INCLUDE TDB.INC

;** External functions

externNP HelperVerifySeg
externNP HelperHandleToSel

;** Functions

sBegin  CODE
        assumes CS,CODE

;  StackFrameFirst
;       Returns information about the first stack frame and checks it
;       for validity as much as possible.  The first stack frame is found
;       by getting the information from the TDB.  If this task is active,
;       or if the task was changed in an unusual way, this information
;       may be incorrect. If it is, the user must set up the first
;       CS, IP, and BP, and BPNext in the user structure, log it as the
;       first stack trace and call StackTraceNext directly.

cProc   StackFrameFirst, <NEAR,PUBLIC>, <si,di,ds>
        parmD   lpStack
        parmW   hTDB
cBegin
        ;** Verify that we have a good TDB first
        ;** Start by verifying the selector
        mov     ax,hTDB                 ;Get the selector
        cCall   HelperHandleToSel, <ax> ;Convert it to a selector
        push    ax                      ;Save it
        mov     bx,TDBSize
        cCall   HelperVerifySeg, <ax,bx>
        pop     bx                      ;Get selector back
        or      ax,ax                   ;FALSE return?
        jnz     SHORT SF_SelOk          ;Selector's OK
        xor     ax,ax                   ;Return FALSE
        jmp     SHORT SF_End
SF_SelOk:

        ;** Verify that the TDB signature matches
        mov     ds,bx                   ;Point with DS
        cmp     ds:[TDB_sig],TDB_SIGNATURE ;Is this really a TDB?
        jz      SF_SigOk                ;Must be
        xor     ax,ax                   ;Return FALSE
        jmp     SHORT SF_End
SF_SigOk:

        ;** Get the BP value from the task stack and store in structure
        les     di,lpStack              ;Get a pointer to the user struct
        mov     ax,ds:[TDB_taskSS]      ;Get the SS value
        mov     bx,ds:[TDB_taskSP]      ;Get the max segment offset we need
        add     bx,Task_CS + 2
        cCall   HelperVerifySeg, <ax,bx> ;Make sure we can read all this
        or      ax,ax                   ;Error?
        jz      SF_End                  ;Yes, can't do walk
        lds     bx,DWORD PTR ds:[TDB_taskSP] ;Get the SS:SP value
        mov     si,ds:[bx].Task_BP      ;Get the BP value from the stack
        and     si,NOT 1                ;Clear the FAR frame bit, if any
        mov     es:[di].st_wBP,si       ;Store the BP value
        mov     ax,ds:[bx].Task_IP      ;Store initial IP
        mov     es:[di].st_wIP,ax
        mov     ax,ds:[bx].Task_CS      ;Store the initial CS
        mov     es:[di].st_wCS,ax

        ;** Return as much info as possible about this first frame
        mov     ax,hTDB                 ;Get the TDB handle
        mov     es:[di].st_hTask,ax     ;Save in structure
        mov     es:[di].st_wSS,ds       ;Save the SS value
        mov     es:[di].st_wFlags,FRAME_FAR ;Force a FAR frame this time

        ;** Try to verify this stuff
        xor     ax,ax                   ;In case we need to exit
        or      si,si                   ;End of the line?
        jz      SF_End                  ;Nope
        cmp     si,ds:[0ah]             ;Compare against stack top
        jb      SF_End                  ;Fine with top
        cmp     si,ds:[0eh]             ;Check against stack bottom
        jae     SF_End                  ;OK with bottom too
        mov     ax,1                    ;Return TRUE

SF_End:
cEnd


;  StackFrameNext
;       Returns information in a public structure about the stack frame
;       pointed to by the BP value passed in.  Returns TRUE if the
;       information seems valid, or FALSE if information could not be
;       returned.

cProc   StackFrameNext, <NEAR,PUBLIC>, <si,di,ds>
        parmD   lpStack
cBegin
        ;** Get pointers to the frame
        les     di,lpStack              ;Get a pointer to the structure
        mov     ax,es:[di].st_wSS       ;Get the stack segment
        mov     ds,ax                   ;Point with DS

        ;** Get the next stack frame
        mov     si,es:[di].st_wBP       ;Get the current BP value
        lea     ax,[si + 6]             ;Get the max stack probe
        cmp     ax,si                   ;No stack wraparound allowed
        jb      SN_End                  ;If below, we have wrapped
        cCall   HelperVerifySeg, <ds,ax> ;Make sure the stack is OK
        or      ax,ax                   ;OK?
        jnz     @F                      ;Yes.
        jmp     SHORT SN_End            ;Return FALSE
@@:     mov     dx,ds:[si+4]            ;DX:CX is the return address
        mov     cx,ds:[si+2]
        mov     bx,ds:[si]              ;Get next BP value

        ;** Zero BP is end of chain
        xor     ax,ax                   ;In case we need to exit
        or      bx,bx                   ;End of the line?
        jz      SN_End                  ;Nope

        ;** If the new BP is higher on the stack than the old, it's invalid
        cmp     bx,si                   ;New BP <= Old BP?
        jbe     SN_End                  ;OK.

        ;** Make sure we're still on the stack (variables from KDATA.ASM)
        cmp     bx,ds:[0ah]             ;Compare against stack top
        jb      SN_End                  ;Fine with top
        cmp     bx,ds:[0eh]             ;Check against stack bottom
        jae     SN_End                  ;OK with bottom too

        ;** Return what we can about the frame
        mov     es:[di].st_wSS,ds       ;Save the SS value
        mov     es:[di].st_wBP,si       ;  and the BP value
        test    bx,1                    ;Far or near frame?
        jnz     SN_FarFrame             ;For sure far if BP is odd

        ;** Even when BP is not odd, we may have a far frame
        mov     ax,cs                   ;Get our RPL bits
        and     al,3                    ;Mask RPL bits
        mov     ah,dl                   ;Get frame's RPL bits
        and     ah,3                    ;Mask RPL bits
        cmp     al,ah                   ;If CS is a handle, they won't match
        jne     SN_NearFrame            ;Bits don't match
        lar     ax,dx                   ;Get the access bits
        test    ax,800h                 ;Is this a code segment?
        jz      SN_NearFrame            ;No.  MUST be near frame
        lsl     ax,dx                   ;Get the limit
        cmp     ax,cx                   ;Inside limit?
        jbe     SN_NearFrame            ;No.  MUST be near

        ;** Otherwise, probably is a far frame.  It may not be, of course,
        ;**     because this may be a code seg parameter
SN_FarFrame:
        mov     es:[di].st_wIP,cx       ;Save the offset
        mov     es:[di].st_wCS,dx       ;  and selector value
        mov     ax,FRAME_FAR            ;Tell the user what we did
        and     bx,NOT 1                ;Clear the far frame bit
        jmp     SHORT SN_20             ;Skip near section

        ;** Must be a near frame
SN_NearFrame:
        mov     es:[di].st_wIP,cx       ;Save the offset
                                        ;Leave the old CS value in
        mov     ax,FRAME_NEAR           ;Tell the user what we did
SN_20:  mov     es:[di].st_wFlags,ax    ;Save in the structure
        mov     es:[di].st_wBP,bx       ;Save BP in the structure
        mov     ax,1                    ;Return TRUE

SN_End:
cEnd

sEnd

        END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\toolhelp\task2.asm ===
;**************************************************************************
;*  TASK2.ASM
;*
;*      Assembly support for the task enumeration routines.
;*
;**************************************************************************

        INCLUDE TOOLPRIV.INC

PMODE32 = 0
PMODE   = 0
SWAPPRO = 0
        INCLUDE TDB.INC
ifdef WOW
        INCLUDE WOW.INC
endif

;** Data

sBegin  DATA

lpfnRetAddr     DD      0               ;Return address after stack switch

sEnd

;** External functions
externNP HelperHandleToSel
externNP HelperVerifySeg
externFP GetCurrentTask
externFP DirectedYield
ifdef WOW
externFP PostAppMessage
endif

;** Functions

.286p

sBegin  CODE
        assumes CS,CODE
        assumes DS,DATA


;  TaskSetCSIP
;       Allows the user to set the CS:IP of a sleeping task so that it will
;       begin execution at this address when the task is yielded to.
;       Returns the old address.

cProc   TaskSetCSIP, <PUBLIC,FAR>, <si>
        parmW   hTask
        parmW   wCS
        parmW   wIP
cBegin
        assumes DS,nothing
        assumes ES,nothing

        ;** If this is the current task, do nothing:  we only work on
        ;**     sleeping tasks
        cCall   GetCurrentTask          ;Gets current task in AX
        mov     bx,hTask                ;Get desired task
        cmp     ax,bx                   ;Same?
        jne     @F                      ;No, it's OK
        xor     ax,ax                   ;Return a DWORD zero
        cwd
        jmp     SHORT TC_End
@@:

        ;** Get the TDB SS:SP
        mov     es,bx                   ;Point to TDB with ES
        les     si,DWORD PTR es:[TDB_TaskSP] ;Get a pointer to the task stack
ifdef WOW
        ;
        ; ES:SI now points to the place where we had the TDB's SS:SP pointing
        ; This spot in wow is actually the SS:BP frame of the WOW16CALL
        ; function.  The definitions for this frame come from WOW.INC (WOW.H).
        ; The addition of this strange value adjusts the SS:SP pointer back
        ; onto the stack, undoing a previous adjustment in TASKING.ASM
        add     si,(vf_vpCSIP-vf_wThunkCSIP)
endif
        ;** Change the CS:IP
        mov     ax,wIP                  ;Get the new IP value
        xchg    ax,es:[si].Task_IP      ;Swap with the old one
        mov     dx,wCS                  ;Get the new CS value
        xchg    dx,es:[si].Task_CS      ;Swap with the old one

TC_End:
cEnd


;  TaskGetCSIP
;       Gets the next CS:IP that this task will run at.

cProc   TaskGetCSIP, <PUBLIC,FAR>, <si>
        parmW   hTask
cBegin
        assumes DS,nothing
        assumes ES,nothing

        ;** If this is the current task, do nothing:  we only work on
        ;**     sleeping tasks
        cCall   GetCurrentTask          ;Gets current task in AX
        mov     bx,hTask                ;Get desired task
        cmp     ax,bx                   ;Same?
        jne     @F                      ;No, it's OK
        xor     ax,ax                   ;Return a DWORD zero
        cwd
        jmp     SHORT TG_End
@@:

        ;** Get the TDB SS:SP
        mov     es,bx                   ;Point to TDB with ES
        les     si,DWORD PTR es:[TDB_TaskSP] ;Get a pointer to the task stack

ifdef WOW
        ;
        ; ES:SI now points to the place where we had the TDB's SS:SP pointing
        ; This spot in wow is actually the SS:BP frame of the WOW16CALL
        ; function.  The definitions for this frame come from WOW.INC (WOW.H).
        ; The addition of this strange value adjusts the SS:SP pointer back
        ; onto the stack, undoing a previous adjustment in TASKING.ASM
        add     si,(vf_vpCSIP-vf_wThunkCSIP)
endif
        ;** Change the CS:IP
        mov     ax,es:[si].Task_IP      ;Get the CS:IP to return
        mov     dx,es:[si].Task_CS

TG_End:
cEnd


;  TaskSwitch
;       Switches to the indicated task from the current one.
;       Returns FALSE if it couldn't task switch.
;       Jumps to the address given by lpJmpAddr

cProc   TaskSwitch, <PUBLIC,FAR>, <si,di>
        parmW   hTask
        parmD   lpJmpAddr
cBegin
        push    ds
        mov     ax, _DATA               ;Make sure to set DS
        mov     ds, ax
        assumes ds,DATA

        ;** Check to make sure TOOLHELP is installed
        cmp     wLibInstalled,0         ;Library installed?
        pop     ds
        assumes ds,nothing
        jnz     @F                      ;Yes
        xor     ax,ax                   ;Return FALSE
        jmp     TS_End                  ;No.  Fail the API
@@:

        ;** Get the task handle
        cCall   GetCurrentTask          ;Get the current task
        cmp     ax,hTask                ;Switch to current task?
        jne     @F                      ;No, it's OK
        xor     ax,ax                   ;Yes, we can't do that so return FALSE

ifdef WOW
        jmp     TS_End
else
        jmp     SHORT TS_End
endif

@@:     cCall   HelperVerifySeg, <hTask,TDB_sig+1> ;Verify the segment
        or      ax,ax                   ;Segment OK?
        jz      TS_End                  ;Nope.  Get out
        mov     es,hTask                ;Get the TDB
        xor     ax,ax                   ;Get a zero just in case
        cmp     es:[TDB_sig], TDB_SIGNATURE ;Signature match?
        jne     TS_End                  ;Return FALSE

        ;** Poke in the address to jump to
        mov     si,es                   ;Save the hTask
        lea     ax,TS_FromYield         ;Point to new task address
        cCall   TaskSetCSIP, <si,cs,ax> ;Set the new address
        mov     es,si                   ;Get hTask back

        ;** Save the jump address from the stack so we can jump to it later
        push    ds
        mov     ax,_DATA                ;Point to our data segment
        mov     ds,ax
        assumes ds,DATA
        mov     ax,WORD PTR lpJmpAddr[0];Get the low word of the ret address
        mov     WORD PTR lpfnRetAddr[0],ax
        mov     ax,WORD PTR lpJmpAddr[2];Get the selector value
        mov     WORD PTR lpfnRetAddr[2],ax
        pop     ds

ifdef WOW
        ;** Force a task switch by posting a message. This is because the
        ;** event count is not used under WOW.
        cCall   PostAppMessage,<es, 0, 0, 0, 0>
else
        ;** Force a task switch by tampering with the event count
        inc     es:[TDB_nEvents]        ;Force at least one event so we
                                        ;  will switch to this task next
endif   ;WOW

        ;** Switch to the new task.  DirectedYield() returns only when this
        ;**     task is next scheduled
        cCall   DirectedYield, <si>     ;Switch to the new task
        mov     ax,1                    ;Return TRUE
        jmp     SHORT TS_End            ;Get out

        ;** Restore from the directed yield
TS_FromYield:

        ;** Make a stack frame to work on.  We can't trash any regs
        PUBLIC TS_FromYield
        sub     sp,4                    ;Save room for a far ret frame
        push    bp                      ;Make a stack frame
        mov     bp,sp
        pusha                           ;Save everything
        push    ds
        push    es

        ;** Get our jump address from our DS and put in far ret frame
        mov     ax,_DATA                ;Get the TOOLHELP DS
        mov     ds,ax
        mov     ax,WORD PTR lpfnRetAddr[0] ;Get the offset
        mov     [bp + 2],ax             ;Put it on the stack
        mov     ax,WORD PTR lpfnRetAddr[2] ;Get the selector
        mov     [bp + 4],ax             ;Put on the stack

        ;** Restore the event count
        mov     es,segKernel            ;Get the KERNEL segment
        mov     bx,npwTDBCur            ;Get the current task pointer
        mov     es,es:[bx]              ;Get the TDB pointer in ES
ifndef WOW
        dec     es:[TDB_nEvents]        ;Clear the dummy event we put in
endif

        ;** Clear the stack and 'return' to the new address
        pop     es
        pop     ds
        popa
        pop     bp
        retf

TS_End:
cEnd


;  TaskInfo
;
;       Returns information about the task with the given block handle

cProc   TaskInfo, <PUBLIC,NEAR>, <si,di,ds>
        parmD   lpTask
        parmW   wTask
cBegin
        ;** Start by verifying the selector
        mov     ax,wTask                ;Get the selector
        cCall   HelperHandleToSel, <ax> ;Convert it to a selector
        push    ax                      ;Save it
        mov     bx,TDBSize
        cCall   HelperVerifySeg, <ax,bx>
        pop     bx                      ;Get selector back
        or      ax,ax                   ;FALSE return?
        jnz     TI_SelOk                ;Selector's OK
        xor     ax,ax                   ;Return FALSE
        jmp     TI_End
TI_SelOk:

        ;** Verify that the TDB signature matches
        mov     ds,bx                   ;Point with DS
        cmp     ds:[TDB_sig],TDB_SIGNATURE ;Is this really a TDB?
        jz      TI_SigOk                ;Must be
        xor     ax,ax                   ;Return FALSE
        jmp     SHORT TI_End
TI_SigOk:

        ;** Now, get information from the TDB
        les     di,lpTask               ;Point to destination buffer
        mov     ax,ds:[TDB_next]        ;Get the next TDB handle
        mov     es:[di].te_hNext,ax     ;Save in public structure
        mov     ax,wTask                ;Get this task's handle
        mov     es:[di].te_hTask,ax     ;Save in buffer
        mov     ax,ds:[TDB_Parent]      ;Get this task's parent
        mov     es:[di].te_hTaskParent,ax ;Save
        mov     ax,ds:[TDB_taskSS]      ;Get the SS
        mov     es:[di].te_wSS,ax
        mov     ax,ds:[TDB_taskSP]      ;Get the SP
        mov     es:[di].te_wSP,ax
        mov     ax,ds:[TDB_nEvents]     ;Event counter
        mov     es:[di].te_wcEvents,ax
        mov     ax,ds:[TDB_Queue]       ;Queue pointer
        mov     es:[di].te_hQueue,ax
        mov     ax,ds:[TDB_PDB]         ;Offset of DOS PSP
        mov     es:[di].te_wPSPOffset,ax
        mov     ax,ds:[TDB_Module]      ;Instance handle (DS) of task
        mov     es:[di].te_hInst,ax
        mov     ax,ds:[TDB_pModule]     ;Module database handle
        mov     es:[di].te_hModule,ax
        mov     cx,8                    ;Copy module name
        push    di                      ;Save structure pointer
        mov     si,TDB_ModName          ;Point to the string
        add     di,te_szModule          ;  and to the string dest
        cld
        repnz   movsb                   ;Copy the string
        mov     BYTE PTR es:[di],0      ;Zero terminate it
        pop     di                      ;Get structure pointer back

        ;** Get information from the stack segment.  Vars from KDATA.ASM
        mov     ax,es:[di].te_wSS       ;Get the SS value
        verr    ax                      ;OK to read here?
        jnz     TI_SkipThis             ;No, so don't do it
        mov     ds,ax                   ;Point with DS
        mov     ax,ds:[0ah]             ;Lowest value of SP allowed
        mov     es:[di].te_wStackTop,ax ;Save in structure
        mov     ax,ds:[0ch]             ;Get stack minimum value so far
        mov     es:[di].te_wStackMinimum,ax ;Save in structure
        mov     ax,ds:[0eh]             ;Largest value of SP allowed
        mov     es:[di].te_wStackBottom,ax ;Save in structure

        ;** Return TRUE on success
TI_SkipThis:
        mov     ax,1                    ;Return TRUE code
TI_End:
cEnd

sEnd

        END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\toolhelp\task1.c ===
/*************************************************************************
 *  TASK1.C
 *
 *      Routines used to enumerate all tasks.
 *
 *************************************************************************/

#include <string.h>
#include "toolpriv.h"

/* ----- Functions ----- */

/*  TaskFirst
 *      Returns information about the first task in the task chain.
 */

BOOL TOOLHELPAPI TaskFirst(
    TASKENTRY FAR *lpTask)
{
    /* Check for errors */
    if (!wLibInstalled || !lpTask || lpTask->dwSize != sizeof (TASKENTRY))
        return FALSE;

    /* Pass a pointer to the first block to the assembly routine */
    return TaskInfo(lpTask, *(WORD FAR *)MAKEFARPTR(segKernel, npwTDBHead));
}


/*  TaskNext
 *      Returns information about the next task in the task chain.
 */

BOOL TOOLHELPAPI TaskNext(
    TASKENTRY FAR *lpTask)
{
    /* Check for errors */
    if (!wLibInstalled || !lpTask || !lpTask->hNext ||
        lpTask->dwSize != sizeof (TASKENTRY))
        return FALSE;

    /* Pass a pointer to the next block to the assembly routine */
    return TaskInfo(lpTask, lpTask->hNext);
}


/*  TaskFindHandle
 *      Returns information about the task with the given task handle.
 */

BOOL TOOLHELPAPI TaskFindHandle(
    TASKENTRY FAR *lpTask,
    HANDLE hTask)
{
    /* Check for errors */
    if (!wLibInstalled || !lpTask || lpTask->dwSize != sizeof (TASKENTRY))
        return FALSE;

#ifdef WOW
    if ( (hTask & 0x4) == 0 && hTask <= 0xffe0 && hTask != 0 ) {
        //
        // If they are getting a task handle for an htask alias, then
        // just fill in the hinst method and return.
        //
        // Special hack for OLE 2.0's BusyDialog.
        //
        lpTask->hInst = hTask;
        return( TRUE );
    }
#endif

    /* Pass a pointer to the first block to the assembly routine */
    return TaskInfo(lpTask, hTask);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\toolhelp\toolhelp.h ===
/*****************************************************************************\
*                                                                             *
* toolhelp.h -  toolhelp.dll functions, types, and definitions                *
*                                                                             *
*               Version 1.0                                                   *
*                                                                             *
*               NOTE: windows.h must be #included first                       *
*                                                                             *
*               Copyright (c) 1992, Microsoft Corp.  All rights reserved.     *
*                                                                             *
\*****************************************************************************/

#ifndef _INC_TOOLHELP
#define _INC_TOOLHELP

#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif	/* __cplusplus */

#ifndef _INC_WINDOWS    /* If included with 3.0 headers... */
#define LPCSTR      LPSTR
#define WINAPI      FAR PASCAL
#define CALLBACK    FAR PASCAL
#define UINT        WORD
#define HMODULE     HANDLE
#define HINSTANCE   HANDLE
#define HLOCAL      HANDLE
#define HGLOBAL     HANDLE
#define HTASK       HANDLE
#endif  /* _INC_WINDOWS */

/****** General symbols ******************************************************/
#define MAX_DATA        11
#define MAX_PATH        255
#define MAX_MODULE_NAME 8 + 1
#define MAX_CLASSNAME   255

/****** Global heap walking ***************************************************/
typedef struct tagGLOBALINFO
{
    DWORD dwSize;
    WORD wcItems;
    WORD wcItemsFree;
    WORD wcItemsLRU;
} GLOBALINFO;

typedef struct tagGLOBALENTRY
{
    DWORD dwSize;
    DWORD dwAddress;
    DWORD dwBlockSize;
    HGLOBAL hBlock;
    WORD wcLock;
    WORD wcPageLock;
    WORD wFlags;
    BOOL wHeapPresent;
    HGLOBAL hOwner;
    WORD wType;
    WORD wData;
    DWORD dwNext;
    DWORD dwNextAlt;
} GLOBALENTRY;

/* GlobalFirst()/GlobalNext() flags */
#define GLOBAL_ALL      0
#define GLOBAL_LRU      1
#define GLOBAL_FREE     2

/* GLOBALENTRY.wType entries */
#define GT_UNKNOWN      0
#define GT_DGROUP       1
#define GT_DATA         2
#define GT_CODE         3
#define GT_TASK         4
#define GT_RESOURCE     5
#define GT_MODULE       6
#define GT_FREE         7
#define GT_INTERNAL     8
#define GT_SENTINEL     9
#define GT_BURGERMASTER 10

/* If GLOBALENTRY.wType==GT_RESOURCE, the following is GLOBALENTRY.wData: */
#define GD_USERDEFINED      0
#define GD_CURSORCOMPONENT  1
#define GD_BITMAP           2
#define GD_ICONCOMPONENT    3
#define GD_MENU             4
#define GD_DIALOG           5
#define GD_STRING           6
#define GD_FONTDIR          7
#define GD_FONT             8
#define GD_ACCELERATORS     9
#define GD_RCDATA           10
#define GD_ERRTABLE         11
#define GD_CURSOR           12
#define GD_ICON             14
#define GD_NAMETABLE        15
#define GD_MAX_RESOURCE     15

/* GLOBALENTRY.wFlags */
#define GF_PDB_OWNER        0x0100      /* Low byte is KERNEL flags */

BOOL    WINAPI GlobalInfo(GLOBALINFO FAR* lpGlobalInfo);
BOOL    WINAPI GlobalFirst(GLOBALENTRY FAR* lpGlobal, WORD wFlags);
BOOL    WINAPI GlobalNext(GLOBALENTRY FAR* lpGlobal, WORD wFlags);
BOOL    WINAPI GlobalEntryHandle(GLOBALENTRY FAR* lpGlobal, HGLOBAL hItem);
BOOL    WINAPI GlobalEntryModule(GLOBALENTRY FAR* lpGlobal, HMODULE hModule, WORD wSeg);
WORD    WINAPI GlobalHandleToSel(HGLOBAL hMem);

/****** Local heap walking ***************************************************/

typedef struct tagLOCALINFO
{
    DWORD dwSize;
    WORD wcItems;
} LOCALINFO;

typedef struct tagLOCALENTRY
{
    DWORD dwSize;
    HLOCAL hHandle;
    WORD wAddress;
    WORD wSize;
    WORD wFlags;
    WORD wcLock;
    WORD wType;
    WORD hHeap;
    WORD wHeapType;
    WORD wNext;
} LOCALENTRY;

/* LOCALENTRY.wHeapType flags */
#define NORMAL_HEAP     0
#define USER_HEAP       1
#define GDI_HEAP        2

/* LOCALENTRY.wFlags */
#define LF_FIXED        1
#define LF_FREE         2
#define LF_MOVEABLE     4

/* LOCALENTRY.wType */
#define LT_NORMAL                   0
#define LT_FREE                     0xff
#define LT_GDI_PEN                  1   /* LT_GDI_* is for GDI's heap */
#define LT_GDI_BRUSH                2
#define LT_GDI_FONT                 3
#define LT_GDI_PALETTE              4
#define LT_GDI_BITMAP               5
#define LT_GDI_RGN                  6
#define LT_GDI_DC                   7
#define LT_GDI_DISABLED_DC          8
#define LT_GDI_METADC               9
#define LT_GDI_METAFILE             10
#define LT_GDI_MAX                  LT_GDI_METAFILE
#define LT_USER_CLASS               1   /* LT_USER_* is for USER's heap */
#define LT_USER_WND                 2
#define LT_USER_STRING              3
#define LT_USER_MENU                4
#define LT_USER_CLIP                5
#define LT_USER_CBOX                6
#define LT_USER_PALETTE             7
#define LT_USER_ED                  8
#define LT_USER_BWL                 9
#define LT_USER_OWNERDRAW           10
#define LT_USER_SPB                 11
#define LT_USER_CHECKPOINT          12
#define LT_USER_DCE                 13
#define LT_USER_MWP                 14
#define LT_USER_PROP                15
#define LT_USER_LBIV                16
#define LT_USER_MISC                17
#define LT_USER_ATOMS               18
#define LT_USER_LOCKINPUTSTATE      19
#define LT_USER_HOOKLIST            20
#define LT_USER_USERSEEUSERDOALLOC  21
#define LT_USER_HOTKEYLIST          22
#define LT_USER_POPUPMENU           23
#define LT_USER_HANDLETABLE         32
#define LT_USER_MAX                 LT_USER_HANDLETABLE

BOOL    WINAPI LocalInfo(LOCALINFO FAR* lpLocal, HGLOBAL hHeap);
BOOL    WINAPI LocalFirst(LOCALENTRY FAR* lpLocal, HGLOBAL hHeap);
BOOL    WINAPI LocalNext(LOCALENTRY FAR* lpLocal);

/****** Stack Tracing ********************************************************/

typedef struct tagSTACKTRACEENTRY
{
    DWORD dwSize;
    HTASK hTask;
    WORD wSS;
    WORD wBP;
    WORD wCS;
    WORD wIP;
    HMODULE hModule;
    WORD wSegment;
    WORD wFlags;
} STACKTRACEENTRY;

/* STACKTRACEENTRY.wFlags values */
#define FRAME_FAR       0
#define FRAME_NEAR      1

BOOL    WINAPI StackTraceFirst(STACKTRACEENTRY FAR* lpStackTrace, HTASK hTask);
BOOL    WINAPI StackTraceCSIPFirst(STACKTRACEENTRY FAR* lpStackTrace,
            WORD wSS, WORD wCS, WORD wIP, WORD wBP);
BOOL    WINAPI StackTraceNext(STACKTRACEENTRY FAR* lpStackTrace);

/****** Module list walking **************************************************/

typedef struct tagMODULEENTRY
{
    DWORD dwSize;
    char szModule[MAX_MODULE_NAME + 1];
    HMODULE hModule;
    WORD wcUsage;
    char szExePath[MAX_PATH + 1];
    WORD wNext;
} MODULEENTRY;

BOOL    WINAPI ModuleFirst(MODULEENTRY FAR* lpModule);
BOOL    WINAPI ModuleNext(MODULEENTRY FAR* lpModule);
HMODULE WINAPI ModuleFindName(MODULEENTRY FAR* lpModule, LPCSTR lpstrName);
HMODULE WINAPI ModuleFindHandle(MODULEENTRY FAR* lpModule, HMODULE hModule);

/****** Task list walking *****************************************************/

typedef struct tagTASKENTRY
{
    DWORD dwSize;
    HTASK hTask;
    HTASK hTaskParent;
    HINSTANCE hInst;
    HMODULE hModule;
    WORD wSS;
    WORD wSP;
    WORD wStackTop;
    WORD wStackMinimum;
    WORD wStackBottom;
    WORD wcEvents;
    HGLOBAL hQueue;
    char szModule[MAX_MODULE_NAME + 1];
    WORD wPSPOffset;
    HANDLE hNext;
} TASKENTRY;

BOOL    WINAPI TaskFirst(TASKENTRY FAR* lpTask);
BOOL    WINAPI TaskNext(TASKENTRY FAR* lpTask);
BOOL    WINAPI TaskFindHandle(TASKENTRY FAR* lpTask, HTASK hTask);
DWORD   WINAPI TaskSetCSIP(HTASK hTask, WORD wCS, WORD wIP);
DWORD   WINAPI TaskGetCSIP(HTASK hTask);
BOOL    WINAPI TaskSwitch(HTASK hTask, DWORD dwNewCSIP);

/****** Window Class enumeration **********************************************/

typedef struct tagCLASSENTRY
{
    DWORD dwSize;
    HMODULE hInst;              /* This is really an hModule */
    char szClassName[MAX_CLASSNAME + 1];
    WORD wNext;
} CLASSENTRY;

BOOL    WINAPI ClassFirst(CLASSENTRY FAR* lpClass);
BOOL    WINAPI ClassNext(CLASSENTRY FAR* lpClass);

/****** Information functions *************************************************/

typedef struct tagMEMMANINFO
{
    DWORD dwSize;
    DWORD dwLargestFreeBlock;
    DWORD dwMaxPagesAvailable;
    DWORD dwMaxPagesLockable;
    DWORD dwTotalLinearSpace;
    DWORD dwTotalUnlockedPages;
    DWORD dwFreePages;
    DWORD dwTotalPages;
    DWORD dwFreeLinearSpace;
    DWORD dwSwapFilePages;
    WORD wPageSize;
} MEMMANINFO;

BOOL    WINAPI MemManInfo(MEMMANINFO FAR* lpEnhMode);

typedef struct tagSYSHEAPINFO
{
    DWORD dwSize;
    WORD wUserFreePercent;
    WORD wGDIFreePercent;
    HGLOBAL hUserSegment;
    HGLOBAL hGDISegment;
} SYSHEAPINFO;

BOOL    WINAPI SystemHeapInfo(SYSHEAPINFO FAR* lpSysHeap);

/****** Interrupt Handling ****************************************************/

/* Hooked interrupts */
#define INT_DIV0            0
#define INT_1               1
#define INT_3               3
#define INT_UDINSTR         6
#define INT_STKFAULT        12
#define INT_GPFAULT         13
#define INT_BADPAGEFAULT    14
#define INT_CTLALTSYSRQ     256

/* TOOLHELP Interrupt callbacks registered with InterruptRegister should
 *  always be written in assembly language.  The stack frame is not 
 *  compatible with high level language conventions.
 *
 *  This stack frame looks as follows to the callback.  All registers
 *  should be preserved across this callback to allow restarting fault.
 *               ------------
 *               |   Flags  |  [SP + 0Eh]
 *               |    CS    |  [SP + 0Ch]
 *               |    IP    |  [SP + 0Ah]
 *               |  Handle  |  [SP + 08h]
 *               |Exception#|  [SP + 06h]
 *               |    AX    |  [SP + 04h]  AX Saved to allow MakeProcInstance
 *               |  Ret CS  |  [SP + 02h]
 *       SP--->  |  Ret IP  |  [SP + 00h]
 *               ------------
 */
BOOL    WINAPI InterruptRegister(HTASK hTask, FARPROC lpfnIntCallback);
BOOL    WINAPI InterruptUnRegister(HTASK hTask);

/*  Notifications:
 *      When a notification callback is called, two parameters are passed
 *      in:  a WORD, wID, and another DWORD, dwData.  wID is one of
 *      the values NFY_* below.  Callback routines should ignore unrecog-
 *      nized values to preserve future compatibility.  Callback routines
 *      are also passed a dwData value.  This may contain data or may be
 *      a FAR pointer to a structure, or may not be used depending on
 *      which notification is being received.
 *
 *      In all cases, if the return value of the callback is TRUE, the
 *      notification will NOT be passed on to other callbacks.  It has
 *      been handled.  This should be used sparingly and only with certain
 *      notifications.  Callbacks almost always return FALSE.
 */

/* NFY_UNKNOWN:  An unknown notification has been returned from KERNEL.  Apps
 *  should ignore these.
 */
#define NFY_UNKNOWN         0

/* NFY_LOADSEG:  dwData points to a NFYLOADSEG structure */
#define NFY_LOADSEG         1
typedef struct tagNFYLOADSEG
{
    DWORD dwSize;
    WORD wSelector;
    WORD wSegNum;
    WORD wType;             /* Low bit set if data seg, clear if code seg */
    WORD wcInstance;        /* Instance count ONLY VALID FOR DATA SEG */
    LPCSTR lpstrModuleName;
} NFYLOADSEG;

/* NFY_FREESEG:  LOWORD(dwData) is the selector of the segment being freed */
#define NFY_FREESEG         2

/* NFY_STARTDLL:  dwData points to a NFYLOADSEG structure */
#define NFY_STARTDLL        3
typedef struct tagNFYSTARTDLL
{
    DWORD dwSize;
    HMODULE hModule;
    WORD wCS;
    WORD wIP;
} NFYSTARTDLL;

/* NFY_STARTTASK:  dwData is the CS:IP of the start address of the task */
#define NFY_STARTTASK       4

/* NFY_EXITTASK:  The low byte of dwData contains the program exit code */
#define NFY_EXITTASK        5

/* NFY_DELMODULE:  LOWORD(dwData) is the handle of the module to be freed */
#define NFY_DELMODULE       6

/* NFY_RIP:  dwData points to a NFYRIP structure */
#define NFY_RIP             7
typedef struct tagNFYRIP
{
    DWORD dwSize;
    WORD wIP;
    WORD wCS;
    WORD wSS;
    WORD wBP;
    WORD wExitCode;
} NFYRIP;

/* NFY_TASKIN:  No data.  Callback should do GetCurrentTask() */
#define NFY_TASKIN          8

/* NFY_TASKOUT:  No data.  Callback should do GetCurrentTask() */
#define NFY_TASKOUT         9

/* NFY_INCHAR:  Return value from callback is used.  If NULL, mapped to 'i' */
#define NFY_INCHAR          10

/* NFY_OUTSTR:  dwData points to the string to be displayed */
#define NFY_OUTSTR          11

/* NFY_LOGERROR:  dwData points to a NFYLOGERROR struct */
#define NFY_LOGERROR        12
typedef struct tagNFYLOGERROR
{
    DWORD dwSize;
    UINT wErrCode;
    void FAR* lpInfo;       /* Error code-dependent */
} NFYLOGERROR;

/* NFY_LOGPARAMERROR:  dwData points to a NFYLOGPARAMERROR struct */
#define NFY_LOGPARAMERROR   13
typedef struct tagNFYLOGPARAMERROR
{
    DWORD dwSize;
    UINT wErrCode;
    FARPROC lpfnErrorAddr;
    void FAR* FAR* lpBadParam;
} NFYLOGPARAMERROR;

/* NotifyRegister() flags */
#define NF_NORMAL       0
#define NF_TASKSWITCH   1
#define NF_RIP          2

typedef BOOL (CALLBACK* LPFNNOTIFYCALLBACK)(WORD wID, DWORD dwData);

BOOL    WINAPI NotifyRegister(HTASK hTask, LPFNNOTIFYCALLBACK lpfn, WORD wFlags);
BOOL    WINAPI NotifyUnRegister(HTASK hTask);

/****** Miscellaneous *********************************************************/

void    WINAPI TerminateApp(HTASK hTask, WORD wFlags);

/* TerminateApp() flag values */
#define UAE_BOX     0
#define NO_UAE_BOX  1

DWORD   WINAPI MemoryRead(WORD wSel, DWORD dwOffset, void FAR* lpBuffer, DWORD dwcb);
DWORD   WINAPI MemoryWrite(WORD wSel, DWORD dwOffset, void FAR* lpBuffer, DWORD dwcb);

typedef struct tagTIMERINFO
{
    DWORD dwSize;
    DWORD dwmsSinceStart;
    DWORD dwmsThisVM;
} TIMERINFO;

BOOL    WINAPI TimerCount(TIMERINFO FAR* lpTimer);

#ifdef __cplusplus
}
#endif	/* __cplusplus */

#ifndef RC_INVOKED
#pragma pack()          /* Revert to default packing */
#endif

#endif /* !_INC_TOOLHELP */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\toolhelp\timer.asm ===
PAGE 60,150
;***************************************************************************
;*  TIMER.ASM
;*
;*      Routines used to give a cleaner interface to the VTD.
;*      This interface also works on a 286 by calling GetTickCount() in
;*      this case.
;*
;***************************************************************************

        INCLUDE TOOLPRIV.INC
        INCLUDE WINDOWS.INC

;** Symbols
SI_CRITICAL     EQU     1
DI_CRITICAL     EQU     2

;** Imports
externA __WinFlags
externFP GetTickCount

sBegin  DATA

dwLastTimeReturned      dd      0
wLastCountDown          dw      0


sEnd

sBegin  CODE
        assumes CS,CODE
        assumes DS,DATA

;  TimerCount
;       Returns the count from either the virtual timer device or from the
;       Windows function GetTickCount() depending on the processor.
;       Prototype:
;               BOOL FAR PASCAL TimerCount(
;                       TIMERINFO FAR *lpTimer)
;

cProc   TimerCount, <FAR,PUBLIC>, <si,di,ds>
        parmD   lpTimer
        localD  dwJumpAddr
cBegin
        mov     ax, _DATA               ;Get our data segment
        mov     es, ax

        ;** Point to the structure
        lds     si,lpTimer              ;Point to the structure

        ;** Make sure the size is correct
        xor     ax,ax                   ;FALSE
        cmp     WORD PTR [si].ti_dwSize[2],0 ;High word must be zero
        je      @F
        jmp     TC_End
@@:     cmp     WORD PTR [si].ti_dwSize[0],SIZE TIMERINFO ;Low word must match
        je      @F
        jmp     TC_End
@@:

ifndef WOW
        ;** If we are in standard mode, always use Windows entry point
        mov     ax,__WinFlags           ;Get the flags
        test    ax,WF_STANDARD          ;Standard mode?
        jnz     TC_TryMMSys             ;Yes, don't even try VTD
.386p
        ;** Try to get the VTD entry point
        mov     ax,1684h                ;Get device entry point
        mov     bx,5                    ;VTD device number
        int     2fh                     ;Win386 entry point
        mov     ax,es                   ;Did we get a value?
        or      ax,di                   ;  (zero means no device)
        jz      SHORT TC_UseWinAPI      ;No VTD--use Win API

        ;** Get the VTD values
        mov     WORD PTR dwJumpAddr[0],di ;Save the address
        mov     WORD PTR dwJumpAddr[2],es ;Save the address
        mov     ax,0101h                ;VTD:  ms since start of Win386
        call    DWORD PTR dwJumpAddr    ;Call the VTD
        jc      SHORT TC_UseWinAPI      ;Carry set means error
        mov     [si].ti_dwmsSinceStart,eax ;Save in structure
        mov     ax,0102h                ;VTD:  ms in this VM
        call    DWORD PTR dwJumpAddr    ;Call the VTD
        jc      SHORT TC_UseWinAPI      ;Carry set means VTD error
        mov     [si].ti_dwmsThisVM,eax  ;Save value in structure
        jmp     TC_ReturnOK             ;We're done
.286p

        ;** See if mmsystem timer is installed
TC_TryMMSys:
        cmp     WORD PTR es:[lpfntimeGetTime][2], 0 ;Installed?
        je      TC_UseWinAPI            ;No, do this the hard way
        call    DWORD PTR es:lpfntimeGetTime

        ;** Fill the structure with this information
        mov     WORD PTR [si].ti_dwmsSinceStart[0],ax
        mov     WORD PTR [si].ti_dwmsSinceStart[2],dx
        mov     WORD PTR [si].ti_dwmsThisVM[0],ax
        mov     WORD PTR [si].ti_dwmsThisVM[2],dx
        jmp     TC_ReturnOK
endif   ; ndef WOW

        ;** Use the Windows API
TC_UseWinAPI:
        cCall   GetTickCount            ;Call the Windows API
        mov     WORD PTR [si].ti_dwmsSinceStart[0],ax ;Save the value for now
        mov     WORD PTR [si].ti_dwmsSinceStart[2],dx

        ;** Read the countdown timer.  Note that the timer starts at 54 * 1193
        ;**     and counts down to zero.  Each count is 1193 ms.
ifdef   NEC_98
;       timer i/o access change
        push    ds
        mov     ax,40h                  ;       40:101                  ;921006
        mov     ds,ax
        test    byte ptr ds:[101h],80h  ; system clock check            ;921006
        pop     ds
        mov     cx,2457                 ; 2.5MHz
        jz      @f
        mov     cx,1996                 ; 2MHz
@@:
        push    cx
        xor     al,al                   ;Prepare to read tick count
        out     77h,al                  ;Send to timer                  ;921006
        in      al,dx                   ;Get the low byte
        mov     ah,al                   ;Save in AH
        in      al,dx                   ;Get the high byte
        xchg    ah,al
        pop     cx
        mov     dx,0ffffh               ;Get total countdown amount
        sub     dx,ax                   ;Get number of counts expired
        mov     ax,dx                   ;Get the number in AX for div
        xor     dx,dx                   ;Zero the high word
else    ; NEC_98
        xor     al,al                   ;Prepare to read tick count
        out     43h,al                  ;Send to timer
        in      al,40h                  ;Get the low byte
        mov     ah,al                   ;Save in AH
        in      al,40h                  ;Get the high byte
        xchg    ah,al
        mov     dx,0ffffh               ;Get total countdown amount
        sub     dx,ax                   ;Get number of counts expired
        mov     ax,dx                   ;Get the number in AX for div
        xor     dx,dx                   ;Zero the high word
        mov     cx,1193                 ;Divide to get ms
endif   ; NEC_98
        div     cx                      ;Divide it
        mov     cx, ax                  ;cx == saved Curr count

        ;** Now fill the structure.  Note that the 'ThisVM' entry is the
        ;**     same as the 'SinceStart' entry in standard mode.
        xor     dx, dx
        add     ax, WORD PTR [si].ti_dwmsSinceStart[0] ;Add this count in
        adc     dx, WORD PTR [si].ti_dwmsSinceStart[2]

        ;** Check to make sure we didn't mess up.  If we did (if the timer
        ;**     was reset right in the middle of us reading it).  If we
        ;**     messed up, do it again until we get it right.
        mov     bx, _DATA               ;Get our data segment
        mov     es, bx
        cmp     dx, WORD PTR es:dwLastTimeReturned[2]
        jne     TC_TimeOK
        cmp     ax, WORD PTR es:dwLastTimeReturned[0]
        jae     TC_TimeOK

        ; New time is less than the old time so estimate the curr time
        ; using LastTimeReturned as the base
        mov     ax, WORD PTR es:dwLastTimeReturned[0]
        mov     dx, WORD PTR es:dwLastTimeReturned[2]

        xor     bx, bx                            ;check for wrap
        cmp     cx, word ptr es:wLastCountDown
        jae     TC_NoWrap                         ;if wrap
        add     ax, cx                            ;   += curr count
        adc     dx, 0
        jmp     short TC_TimeOK

TC_NoWrap:                                        ;else no wrap
        mov     bx, cx                            ;  += Curr - LastCountDown
        sub     bx, word ptr es:wLastCountDown
        add     ax, bx
        adc     dx, 0

TC_TimeOK:
        mov     word ptr es:wLastCountDown, cx
        mov     WORD PTR es:dwLastTimeReturned[0], ax
        mov     WORD PTR es:dwLastTimeReturned[2], dx
        mov     WORD PTR [si].ti_dwmsSinceStart[0], ax ;Save good count
        mov     WORD PTR [si].ti_dwmsSinceStart[2], dx
        mov     WORD PTR [si].ti_dwmsThisVM[0],ax ;Save in structure
        mov     WORD PTR [si].ti_dwmsThisVM[2],dx ;Save in structure

TC_ReturnOK:
        mov     ax,1                    ;Return TRUE

TC_End:



cEnd

sEnd

END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\toolhelp\toolhelp.c ===
/**************************************************************************
 *  TOOLHELP.C
 *
 *      Contains the initalization and deinitialization code for the
 *      TOOLHELP DLL.
 *
 **************************************************************************/

#include "toolpriv.h"
#undef VERSION
#include <mmsystem.h>

/* ----- Global variables ----- */
    WORD segKernel;
    WORD wLibInstalled;
    WORD wTHFlags;
    HANDLE hMaster;
    HANDLE hGDIHeap;
    HANDLE hUserHeap;
    WORD NEAR *npwExeHead;
    WORD NEAR *npwTDBHead;
    WORD NEAR *npwTDBCur;
    DWORD NEAR *npdwSelTableStart;
    WORD NEAR *npwSelTableLen;
    FARPROC lpfnGetUserLocalObjType;
    FARPROC lpfnFatalExitHook;
    FARPROC lpfnNotifyHook;
    LPFNUSUD lpfnUserSeeUserDo;
    FARPROC lpfnGetFreeSystemResources;
    FARPROC lpfntimeGetTime;
    WORD wSel;
    WORD wLRUCount;
    char szKernel[] = "KERNEL";

/* ----- Import values ----- */
#define FATALEXITHOOK           MAKEINTRESOURCE(318)
#define GETUSERLOCALOBJTYPE     MAKEINTRESOURCE(480)
#define USERSEEUSERDO           MAKEINTRESOURCE(216)
#define HASGPHANDLER            MAKEINTRESOURCE(338)
#define TOOLHELPHOOK            MAKEINTRESOURCE(341)
#define GETFREESYSTEMRESOURCES  MAKEINTRESOURCE(284)


/*  ToolHelpLibMain
 *      Called by DLL startup code.
 *      Initializes TOOLHELP.DLL.
 */

int PASCAL ToolHelpLibMain(
    HANDLE hInstance,
    WORD wDataSeg,
    WORD wcbHeapSize,
    LPSTR lpszCmdLine)
{
    HANDLE hKernel;
    HANDLE hUser;
    HANDLE hMMSys;

    /* Unless we say otherwise, the library is installed OK */
    wLibInstalled = TRUE;

    /* Do the KERNEL type-checking.  Puts the results in global variables */
    KernelType();

    /* If the KERNEL check failed (not in PMODE) return that the library did
     *  not correctly install but allow the load anyway.
     */
    if (!wTHFlags)
    {
        wLibInstalled = FALSE;

        /* Return success anyway, just fails all API calls */
        return 1;
    }

    /* Grab a selector.  This is only necessary in Win30StdMode */
    if (wTHFlags & TH_WIN30STDMODE)
        wSel = HelperGrabSelector();

    /* Get the User and GDI heap handles if possible */
    hKernel = GetModuleHandle((LPSTR)szKernel);
    hUser = GetModuleHandle("USER");
    hUserHeap = UserGdiDGROUP(hUser);
    hGDIHeap = UserGdiDGROUP(GetModuleHandle("GDI"));

    /* Get all the functions we may need.  These functions only exist in
     *  the 3.1 USER and KERNEL.
     */
    if (!(wTHFlags & TH_WIN30))
    {
        /* FatalExit hook */
        lpfnFatalExitHook = GetProcAddress(hKernel, FATALEXITHOOK);

        /* Internal USER routine to get head of class list */
        lpfnUserSeeUserDo = (LPFNUSUD)(FARPROC)
            GetProcAddress(hUser, USERSEEUSERDO);

        /* Identifies objects on USER's local heap */
        lpfnGetUserLocalObjType = GetProcAddress(hUser, GETUSERLOCALOBJTYPE);

        /* Identifies parameter validation GP faults */
        lpfnPV = GetProcAddress(hKernel, HASGPHANDLER);

        /* See if the new TOOLHELP KERNEL hook is around */
        lpfnNotifyHook = (FARPROC) GetProcAddress(hKernel, TOOLHELPHOOK);
        if (lpfnNotifyHook)
            wTHFlags |= TH_GOODPTRACEHOOK;

        /* Get the USER system resources function */
        lpfnGetFreeSystemResources = (FARPROC)
            GetProcAddress(hUser, GETFREESYSTEMRESOURCES);
    }

    /* Make sure we don't ever call these in 3.0 */
    else
    {
        lpfnFatalExitHook = NULL;
        lpfnUserSeeUserDo = NULL;
        lpfnGetUserLocalObjType = NULL;
        lpfnPV = NULL;
    }

    /* Try to get the multimedia system timer function address */
    hMMSys = GetModuleHandle("MMSYSTEM");
    if (hMMSys)
    {
        TIMECAPS tc;
        UINT (WINAPI* lpfntimeGetDevCaps)(
            TIMECAPS FAR* lpTimeCaps,
            UINT wSize);

        /* Call the timer API to see if the timer's really installed,
         *  and if it is, get the address of the get time function
         */
        lpfntimeGetDevCaps = (UINT(WINAPI *)(TIMECAPS FAR *, UINT))
            GetProcAddress(hMMSys, MAKEINTRESOURCE(604));
        if ((*lpfntimeGetDevCaps)(&tc, sizeof (tc)) == TIMERR_NOERROR)
            lpfntimeGetTime =
                GetProcAddress(hMMSys, MAKEINTRESOURCE(607));
    }

    /* Return success */
    return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\toolhelp\toolpriv.inc ===
;**************************************************************************
;*  TOOLPRIV.INC
;*
;*      Private assembly-language include file for modules assembled as a
;*      part of TOOLHELP.DLL.
;*
;**************************************************************************

;** CMACROS.INC variables for correct assembly
DOS5 = 1
PMODE = 1
?WIN = 0
?PLM = 1

.286p

        INCLUDE CMACROS.INC
        INCLUDE TOOLHELP.INC

externA __WinFlags

;** TOOLHELP global variables
?PLM = 0
externW segKernel
externW wLibInstalled
externW hMaster
externW wTHFlags
externW npwExeHead
externW npwTDBHead
externW npwTDBCur
externW hUserHeap
externW hGDIHeap
externW npdwSelTableStart
externW npwSelTableLen
externW wNotifyInstalled
externW npNotifyHead
externW wIntInstalled
externW npIntHead
externD lpfnGetUserLocalObjType
externD lpfnFatalExitHook
externD lpfnUserSeeUserDo
externD lpfnNotifyHook
externD lpfnGetFreeSystemResources
externD lpfntimeGetTime;
externW wSel
externW wSignalInstalled
externW npSignalHead
externW npNotifyNext
externW wLRUCount
?PLM = 1

;** Symbols
TRUE    =       1
FALSE   =       0

KERNEL_286      EQU     1
KERNEL_386      EQU     2

FAULT_ACTIVE    EQU     2

NUM_EXCEP       EQU     3

;** wTHFlag values
TH_KERNEL_286   EQU     1
TH_KERNEL_386   EQU     2
TH_WIN30        EQU     4
TH_WIN30STDMODE EQU     8       ;THWIN30STDMODE set if TH_WIN30 & Std mode
TH_GOODPTRACEHOOK EQU   16
TH_GOTOLDPTRACE EQU     32

;** Notification values
NI_INCHAR       EQU     01h
NI_OUTSTR       EQU     12h
NI_LOADSEG      EQU     50h
NI_FREESEG      EQU     52h
NI_STARTTASK    EQU     59h
NI_EXITCALL     EQU     62h
NI_LOADDLL      EQU     64h
NI_DELMODULE    EQU     65h
NI_TASKOUT      EQU     0dh
NI_TASKIN       EQU     0eh
NI_CTLALTSYSRQ  EQU     63h
NI_LOGERROR     EQU     66h
NI_LOGPARAMERROR EQU    67h

;** Structures

NOTIFYSTRUCT STRUC
ns_pNext                DW      ?
ns_hTask                DW      ?
ns_lpfn                 DD      ?
ns_wFlags               DW      ?
NOTIFYSTRUCT ENDS

INTERRUPT STRUC
i_pNext                 DW      ?
i_hTask                 DW      ?
i_lpfn                  DD      ?
INTERRUPT ENDS

SIGNAL STRUC
si_pNext                DW      ?
si_hTask                DW      ?
si_lpfn                 DD      ?
si_lpfnOld              DD      ?
SIGNAL ENDS

;** Macros
PubLabel MACRO PLabel
        labelNP PLabel
        PUBLIC PLabel
ENDM
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\toolhelp\toolpriv.h ===
/**************************************************************************
 *  TOOLPRIV.H
 *
 *      Private header file for routines in the tool helper library
 *
 **************************************************************************/

#ifndef TOOLPRIV_H
#define TOOLPRIV_H

#define BUILDDLL

#include <windows.h>
#include "toolhelp.h"

/* ----- Symbols ----- */
#define VERSION     1
#ifndef NOEXPORT
#define NOEXPORT static
#endif
#define TOOLHELPAPI     WINAPI

#define FAULT_ACTIVE    2
#define NUM_EXCEPTIONS  3

/* wTHFlag values */
#define TH_KERNEL_286       1
#define TH_KERNEL_386       2
#define TH_WIN30            4
#define TH_WIN30STDMODE     8   /* THWIN30STDMODE set if TH_WIN30 & Std mode */
#define TH_GOODPTRACEHOOK   16
#define TH_GOTOLDPTRACE     32

/* ----- Code macros ----- */
#define MAKEFARPTR(s, o) ((void FAR *)(((WORD)(o)) | \
    (((DWORD)(WORD)(s)) << 16)))

/* ----- Types ----- */

typedef struct tagNOTIFYSTRUCT
{
    struct tagNOTIFYSTRUCT *pNext;
    HANDLE hTask;
    LPFNNOTIFYCALLBACK lpfn;
    WORD wFlags;
} NOTIFYSTRUCT;

typedef void (FAR PASCAL *LPFNCALLBACK)(void);

typedef struct tagINTERRUPT
{
    struct tagINTERRUPT *pNext;
    HANDLE hTask;
    LPFNCALLBACK lpfn;
} INTERRUPT;

typedef struct tagSIGNAL
{
    struct tagSIGNAL *pNext;
    HANDLE hTask;
    LPFNCALLBACK lpfn;
    LPFNCALLBACK lpfnOld;
} SIGNAL;

typedef LONG (FAR PASCAL *LPFNUSUD)(
    WORD wID,
    WORD wParam,
    LONG lParam);

/* ----- TOOLHELP global variables ----- */
    extern WORD segKernel;
    extern WORD wLibInstalled;
    extern HANDLE hMaster;
    extern WORD wTHFlags;
    extern HANDLE hUserHeap;
    extern HANDLE hGDIHeap;
    extern WORD NEAR *npwExeHead;
    extern WORD NEAR *npwTDBHead;
    extern WORD NEAR *npwTDBCur;
    extern DWORD NEAR *npdwSelTableStart;
    extern WORD NEAR *npwSelTableLen;
    extern WORD wNotifyInstalled;
    extern NOTIFYSTRUCT NEAR *npNotifyHead;
    extern WORD wIntInstalled;
    extern INTERRUPT NEAR *npIntHead;
    extern FARPROC lpfnGetUserLocalObjType;
    extern FARPROC lpfnFatalExitHook;
    extern FARPROC PASCAL lpfnPV;
    extern FARPROC lpfnNotifyHook;
    extern FARPROC lpfnGetFreeSystemResources;
    extern FARPROC lpfntimeGetTime;
    extern LPFNUSUD lpfnUserSeeUserDo;
    extern WORD wSignalInstalled;
    extern SIGNAL NEAR *npSignalHead;
    extern NOTIFYSTRUCT NEAR* npNotifyNext;
    extern WORD wLRUCount;

/* ----- Private function prototypes ----- */

    void PASCAL KernelType(void);

    DWORD PASCAL Walk386First(
        WORD wFlags);

    WORD PASCAL Walk386Count(
        WORD wFlags);

    void PASCAL Walk386(
        DWORD dwBlock,
        GLOBALENTRY FAR *lpGlobal,
        WORD wFlags);

    DWORD PASCAL Walk386Handle(
        HANDLE hBlock);

    WORD PASCAL WalkLoc386Count(
        HANDLE hHeap);

    HANDLE PASCAL WalkLoc386First(
        HANDLE hHeap);

    void PASCAL WalkLoc386(
        WORD wBlock,
        LOCALENTRY FAR *lpLocal,
        HANDLE hHeap);

    DWORD PASCAL Walk286First(
        WORD wFlags);

    WORD PASCAL Walk286Count(
        WORD wFlags);

    void PASCAL Walk286(
        DWORD dwBlock,
        GLOBALENTRY FAR *lpGlobal,
        WORD wFlags);

    DWORD PASCAL Walk286Handle(
        HANDLE hBlock);

    WORD PASCAL WalkLoc286Count(
        HANDLE hHeap);

    HANDLE PASCAL WalkLoc286First(
        HANDLE hHeap);

    void PASCAL WalkLoc286(
        WORD wBlock,
        LOCALENTRY FAR *lpLocal,
        HANDLE hHeap);

    BOOL PASCAL TaskInfo(
        TASKENTRY FAR *lpTask,
        WORD wBlock);

    WORD PASCAL StackFrameFirst(
        STACKTRACEENTRY FAR *lpStack,
        HANDLE hTDB);

    BOOL PASCAL StackFrameNext(
        STACKTRACEENTRY FAR *lpStack);

    HANDLE PASCAL UserGdiDGROUP(
        HANDLE hModule);

    DWORD PASCAL UserGdiSpace(
        HANDLE hData);

    WORD PASCAL HelperVerifySeg(
        WORD wSeg,
        WORD wcb);

    WORD PASCAL HelperHandleToSel(
        HANDLE h);

    void PASCAL HelperGlobalType(
        GLOBALENTRY FAR *lpGlobal);

    WORD PASCAL HelperGrabSelector(void);

    void PASCAL HelperReleaseSelector(
        WORD wSelector);

    void PASCAL UserGdiType(
        LOCALENTRY FAR *lpLocal);

    BOOL PASCAL NotifyInit(void);

    void PASCAL NotifyUnInit(void);
        
    BOOL PASCAL NotifyIsHooked(
        HANDLE hTask);

    BOOL PASCAL InterruptInit(void);

    void PASCAL InterruptUnInit(void);

    BOOL PASCAL InterruptIsHooked(
        HANDLE hTask);

    BOOL PASCAL SignalRegister(
        HANDLE hTask);

    BOOL PASCAL SignalUnRegister(
        HANDLE hTask);

    void FAR PASCAL HelperSignalProc(void);

    DWORD PASCAL HelperSetSignalProc(
        HANDLE hTask,
        DWORD lpfn);

    BOOL PASCAL ClassInfo(
        CLASSENTRY FAR *lpClass,
        WORD wOffset);

    DWORD PASCAL HelperSegLen(
        WORD wSeg);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\toolhelp\usergdi1.c ===
/**************************************************************************
 *  USERGDI1.C
 *
 *      Returns information about USER.EXE and GDI.EXE
 *
 **************************************************************************/

#include "toolpriv.h"

/*  SystemHeapInfo
 *      Returns information about USER's and GDI's heaps
 */

BOOL TOOLHELPAPI SystemHeapInfo(
    SYSHEAPINFO FAR* lpSysHeap)
{
    MODULEENTRY ModuleEntry;
#ifndef WOW
    DWORD dw;
    WORD wFreeK;
    WORD wMaxHeapK;
#endif

    /* Check the structure version number and pointer */
    if (!wLibInstalled || !lpSysHeap ||
        lpSysHeap->dwSize != sizeof (SYSHEAPINFO))
        return FALSE;

    /* Find the user data segment */
    ModuleEntry.dwSize = sizeof (MODULEENTRY);
    lpSysHeap->hUserSegment =
        UserGdiDGROUP(ModuleFindName(&ModuleEntry, "USER"));
    lpSysHeap->hGDISegment =
        UserGdiDGROUP(ModuleFindName(&ModuleEntry, "GDI"));

#ifndef WOW
    /* We get the information about the heap percentages differently in
     *  3.0 and 3.1
     */
    if ((wTHFlags & TH_WIN30) || !lpfnGetFreeSystemResources)
    {
        /* Get the space information about USER's heap */
        dw = UserGdiSpace(lpSysHeap->hUserSegment);
        wFreeK = LOWORD(dw) / 1024;
        wMaxHeapK = HIWORD(dw) / 1024;
        if (wMaxHeapK)
            lpSysHeap->wUserFreePercent = wFreeK * 100 / wMaxHeapK;
        else
            lpSysHeap->wUserFreePercent = 0;

        /* Get the space information about GDI's heap */
        dw = UserGdiSpace(lpSysHeap->hGDISegment);
        wFreeK = LOWORD(dw) / 1024;
        wMaxHeapK = HIWORD(dw) / 1024;
        if (wMaxHeapK)
            lpSysHeap->wGDIFreePercent = wFreeK * 100 / wMaxHeapK;
        else
            lpSysHeap->wGDIFreePercent = 0;
    }

    /* Get the information from USER in 3.1 */
    else
    {
        lpSysHeap->wUserFreePercent =
            (*(WORD (FAR PASCAL *)(WORD))lpfnGetFreeSystemResources)(2);
        lpSysHeap->wGDIFreePercent =
            (*(WORD (FAR PASCAL *)(WORD))lpfnGetFreeSystemResources)(1);
    }
#else

    lpSysHeap->wUserFreePercent = GetFreeSystemResources(GFSR_USERRESOURCES);
    lpSysHeap->wGDIFreePercent = GetFreeSystemResources(GFSR_GDIRESOURCES);

#endif

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\toolhelp\usa\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH)
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\toolhelp\toolhelp.inc ===
;**************************************************************************
;*  TOOLHELP.INC
;*
;*      Assembly-language public include file for TOOLHELP.DLL
;*
;**************************************************************************

;** General symbol values
MAX_DATA        EQU     11
MAX_PATH        EQU     255
MAX_MODULE_NAME EQU     8 + 1           ;Leave room for the zero and padding
MAX_CLASSNAME   EQU     255

; ----- Global heap walking -----

GLOBALENTRY STRUC
ge_dwSize       DD      ?               ;Structure version
ge_dwAddress    DD      ?               ;This block's address
ge_dwBlockSize  DD      ?               ;This block's size
ge_hBlock       DW      ?               ;This block's handle
ge_wcLock       DW      ?               ;Lock count
ge_wcPageLock   DW      ?               ;Page lock count
ge_wFlags       DW      ?               ;Block flags
ge_wHeapPresent DW      ?               ;Size of available local heap
ge_hOwner       DW      ?               ;Owner handle
ge_wType        DW      ?               ;Block type
ge_wData        DW      ?               ;Type-specific data
ge_dwNext       DD      ?               ;Pointer to next block
ge_dwNextAlt    DD      ?               ;Next free/LRU block in chain
GLOBALENTRY ENDS

; ** GlobalFirst()/GlobalNext() flags
GLOBAL_ALL      EQU     0
GLOBAL_LRU      EQU     1
GLOBAL_FREE     EQU     2

; ** GLOBALENTRY.ge_wType entries
GT_UNKNOWN      EQU     0
GT_DGROUP       EQU     1
GT_DATA         EQU     2
GT_CODE         EQU     3
GT_TASK         EQU     4
GT_RESOURCE     EQU     5
GT_MODULE       EQU     6
GT_FREE         EQU     7
GT_INTERNAL     EQU     8
GT_SENTINEL     EQU     9
GT_BURGERMASTER EQU     10

; ** if GLOBALENTRY.wType==GT_RESOURCE, the following is GLOBALENTRY.wData:
GD_USERDEFINED          EQU     0
GD_CURSORCOMPONENT      EQU     1
GD_BITMAP               EQU     2
GD_ICONCOMPONENT        EQU     3
GD_MENU                 EQU     4
GD_DIALOG               EQU     5
GD_STRING               EQU     6
GD_FONTDIR              EQU     7
GD_FONT                 EQU     8
GD_ACCELERATORS         EQU     9
GD_RCDATA               EQU     10
GD_ERRTABLE             EQU     11
GD_CURSOR               EQU     12
GD_ICON                 EQU     14
GD_NAMETABLE            EQU     15
GD_MAX_RESOURCE         EQU     15

;** GLOBALENTRY.wFlags
GF_PDB_OWNER    EQU     100h            ;Low byte is KERNEL flags

; ----- Local heap walking -----

LOCALENTRY STRUC
le_dwSize       DD      ?
le_hHandle      DW      ?
le_wAddress     DW      ?
le_wSize        DW      ?
le_wFlags       DW      ?
le_wcLock       DW      ?
le_wType        DW      ?
le_hHeap        DW      ?
le_wHeapType    DW      ?
le_wNext        DW      ?
LOCALENTRY ENDS

; ** LOCALENTRY.wHeapType flags
NORMAL_HEAP     EQU     0
USER_HEAP       EQU     1
GDI_HEAP        EQU     2

;** LOCALENTRY.wFlags
LF_FIXED                EQU     1
LF_FREE                 EQU     2
LF_MOVEABLE             EQU     4

;** LOCALENTRY.wType
LT_NORMAL               EQU     0
LT_GDI_PEN              EQU     1
LT_GDI_BRUSH            EQU     2
LT_GDI_FONT             EQU     3
LT_GDI_PALETTE          EQU     4
LT_GDI_BITMAP           EQU     5
LT_GDI_RGN              EQU     6
LT_GDI_DC               EQU     7
LT_GDI_DISABLED_DC      EQU     8
LT_GDI_METADC           EQU     9
LT_GDI_METAFILE         EQU     10
LT_GDI_MAX              EQU     LT_GDI_METAFILE
LT_FREE                 EQU     0ffh

; ----- Stack tracing -----

STACKTRACEENTRY STRUC
st_dwSize       DD      ?
st_hTask        DW      ?
st_wSS          DW      ?
st_wBP          DW      ?
st_wCS          DW      ?
st_wIP          DW      ?
st_hModule      DW      ?
st_wSegment     DW      ?
st_wFlags       DW      ?
STACKTRACEENTRY ENDS

;** STACKTRACEENTRY.wFlags values
FRAME_FAR       EQU     0
FRAME_NEAR      EQU     1

; ----- Module list walking -----

MODULEENTRY STRUC
me_dwSize       DD      ?
me_szModule     DB      MAX_MODULE_NAME + 1 DUP(?)
me_hModule      DW      ?
me_wcUsage      DW      ?
me_szExePath    DB      MAX_PATH + 1 + 1 DUP(?)
me_wNext        DW      ?
MODULEENTRY ENDS

; ----- Task list walking -----

TASKENTRY STRUC
te_dwSize               DD      ?
te_hTask                DW      ?
te_hTaskParent          DW      ?
te_hInst                DW      ?
te_hModule              DW      ?
te_wSS                  DW      ?
te_wSP                  DW      ?
te_wStackTop            DW      ?
te_wStackMinimum        DW      ?
te_wStackBottom         DW      ?
te_wcEvents             DW      ?
te_hQueue               DW      ?
te_szModule             DB      MAX_MODULE_NAME + 1 DUP(?)
te_wPSPOffset           DW      ?
te_hNext                DW      ?
TASKENTRY ENDS

;** TaskSwitch() return values
TS_ERROR    EQU         0
TS_NEW      EQU         1
TS_OLD      EQU         2

; ----- Window Class enumeration -----

CLASSENTRY STRUC
ce_dwSize               DD      ?
ce_hInst                DW      ?
ce_szClassName          DB      MAX_CLASSNAME + 1 DUP(?)
ce_wNext                DW      ?
CLASSENTRY ENDS

; ----- Information functions -----

VMEMMANINFO STRUC
vmm_dwSize              DD      ?
vmm_dwLargestFreeBlock  DD      ?
vmm_dwMaxPagesAvailable DD      ?
vmm_dwMaxPagesLockable  DD      ?
vmm_dwTotalLinearSpace  DD      ?
vmm_dwTotalUnlockedPages DD     ?
vmm_dwFreePages         DD      ?
vmm_dwTotalPages        DD      ?
vmm_dwFreeLinearSpace   DD      ?
vmm_dwSwapFilePages     DD      ?
vmm_wPageSize           DW      ?
VMEMMANINFO ENDS

SYSHEAPINFO STRUC
si_dwSize               DD      ?
si_wUserFreePercent     DW      ?
si_wGDIFreePercent      DW      ?
si_hUserSegment         DW      ?
si_hGDISegment          DW      ?
SYSHEAPINFO ENDS

; ----- Notifications -----

;* NFY_UNKNOWN:  An unknown notification has been returned from KERNEL.  Apps
;*      should ignore these.
;*
NFY_UNKNOWN     EQU     0

;** NFY_LOADSEG:  dwData points to a NFYLOADSEG structure
NFY_LOADSEG     EQU     1
NFYLOADSEG STRUC
nls_dwSize              DD      ?
nls_wSelector           DW      ?
nls_wSegNum             DW      ?
nls_wType               DW      ?       ;Low bit set for DATA, clear for CODE
nls_wcInstance          DW      ?       ;Instance count ONLY VALID FOR DATA!
nls_lpstrModuleName     DD      ?
NFYLOADSEG ENDS

;** NFY_FREESEG:  LOWORD(dwData) is the selector of the segment being freed
NFY_FREESEG     EQU     2

;** NFY_STARTDLL:  dwData points to a NFYSTARTDLL structure
NFY_STARTDLL    EQU     3
NFYSTARTDLL STRUC
nsd_dwSize              DD      ?
nsd_hModule             DW      ?
nsd_wCS                 DW      ?
nsd_wIP                 DW      ?
NFYSTARTDLL ENDS

;** NFY_STARTTASK:  dwData is the CS:IP of the task start address
NFY_STARTTASK   EQU     4

;** NFY_EXITTASK:  The low byte of dwData contains the program exit code
NFY_EXITTASK    EQU     5

;** NFY_DELMODULE:  LOWORD(dwData) is the handle of the module to be freed
NFY_DELMODULE   EQU     6

;** NFY_RIP:  LOWORD(dwData) is the fatal exit code
;** NFY_RIP:  dwData points to a NFYRIP structure
NFY_RIP         EQU     7
NFYRIP STRUC
nrp_dwSize      DD      ?
nrp_wIP         DW      ?
nrp_wCS         DW      ?
nrp_wSS         DW      ?
nrp_wBP         DW      ?
nrp_wExitCode   DW      ?
NFYRIP ENDS

;** NFY_TASKIN:  No data.  Callback should do GetCurrentTask()
NFY_TASKIN      EQU     8

;** NFY_TASKOUT:  No data.  Callback should do GetCurrentTask()
NFY_TASKOUT     EQU     9

;** NFY_INCHAR:  Return value of callback is used.  If FALSE, mapped to 'i'
NFY_INCHAR      EQU     10

;** NFY_OUTSTR:  dwData points to the string to be displayed
NFY_OUTSTR      EQU     11

;** NFY_LOGERROR:  dwData points to a NFYLOGERROR struct
NFY_LOGERROR    EQU     12
NFYLOGERROR STRUC
nle_dwSize      DD      ?
nle_wErrCode    DW      ?
nle_lpInfo      DD      ?       ;Error-code dependent
NFYLOGERROR ENDS

;** NFY_LOGPARAMERROR:  dwData points to a NFYLOGPARAMERROR struct
NFY_LOGPARAMERROR EQU   13
NFYLOGPARAMERROR STRUC
nlp_dwSize              DD      ?
nlp_wErrCode            DW      ?
nlp_lpfnErrorAddr       DD      ?
nlp_lpBadParam          DD      ?
NFYLOGPARAMERROR ENDS

;** NotifyRegister() flags
NF_NORMAL       EQU     0
NF_TASKSWITCH   EQU     1
NF_RIP          EQU     2

;** TerminateApp() flag values
UAE_BOX         EQU     0
NO_UAE_BOX      EQU     1

TIMERINFO STRUC
ti_dwSize               DD      ?
ti_dwmsSinceStart       DD      ?
ti_dwmsThisVM           DD      ?
TIMERINFO ENDS
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\toolhelp\usergdi2.asm ===
;***************************************************************************
;*  USERGDI2.ASM
;*
;*      Assembly routines used in computing heap space remaining for
;*      USER, GDI, and any other heaps.
;*
;***************************************************************************

        INCLUDE TOOLPRIV.INC
SWAPPRO = 0
PMODE32 = 0
PMODE   = 1
        INCLUDE WINKERN.INC
        INCLUDE NEWEXE.INC

;** This slimy thing is from GDIOBJ.INC and is subtracted from the
;**     object type nunbers only in 3.1
LT_GDI_BASE     EQU     ('G' or ('O' * 256)) - 1

;** External functions

externNP HelperVerifyLocHeap
externNP HelperHandleToSel

;** Functions

sBegin  CODE
        assumes CS,CODE
        assumes DS,DATA

.286p

;  UserGdiDGROUP
;       Returns a handle to the DGROUP segment for a given module
;
;       HANDLE UserGdiDGROUP(
;               HANDLE hModule)

cProc   UserGdiDGROUP, <PUBLIC,NEAR>, <di,si>
        parmW   hModule
cBegin
        mov     ax,hModule              ;Get the handle
        cCall   HelperHandleToSel, <ax> ;Convert to a selector
        mov     es,ax                   ;Point with ES for this
        xor     ax,ax                   ;Prepare to return NULL
        cmp     es:[ne_magic],NEMAGIC   ;Make sure we have a module database
        jnz     UGD_End                 ;It isn't so get out
        mov     bx,es:[ne_pautodata]    ;Point to the segment table entry
        mov     ax,es:[bx].ns_handle    ;Get the handle from the table
        cCall   HelperHandleToSel, <ax> ;Convert to a selector for return
UGD_End:
cEnd


;  UserGdiSpace
;       This function was stolen from KERNEL where it is used to compute
;       the space remaining in the USER and GDI heaps.  It actually works
;       on any local heap.
;
;       DWORD UserGdiSpace(
;               HANDLE hData)
;       HIWORD of return is maximum size of heap (64K less statics, etc.)
;       LOWORD of return is space remaining on heap

cProc   UserGdiSpace, <PUBLIC,NEAR>, <di,si,ds>
        parmW   hData
cBegin
        ;** Count the free space in this heap.  First:  Is this heap valid?
        mov     ax,hData                ;Get the heap selector
        cCall   HelperVerifyLocHeap     ;Call the verify routine
        mov     ax,0                    ;In case we jump -- set error
        mov     dx,0                    ;  Use MOV to not mess up carry
        jc      UGS_Exit                ;No valid local heap!!

        ;** Loop through all local blocks, adding free space
        cCall   HelperHandleToSel, <hData> ;Convert to selector
        mov     ds,ax                   ;Point to the segment
        mov     di,ds:[6]               ;Get pHeapInfo
        mov     di,[di].hi_first        ;First arena header
        mov     di,[di].la_free_next    ;First free block
UGS_Loop:
        add     ax,[di].la_size         ;Add in size of this block
        sub     ax,SIZE LocalArenaFree  ;Less block overhead
        mov     si,[di].la_free_next    ;Get next free block
        or      si,si                   ;NULL?
        jz      UGS_Break               ;Yes, say we're done
        cmp     si,di                   ;Last block? (points to self)
        mov     di,si                   ;Save for next time around
        jnz     UGS_Loop                ;Not last block so loop some more
UGS_Break:

        ;** We have the size of the local heap
        mov     si,ax                   ;Save the size
        mov     cx,ds                   ;Get the selector in a non-segreg
        lsl     ax,cx                   ;Get the size of the segment
        neg     ax                      ;64K - segment size
        add     ax,si                   ;Add in the free holes in the heap
        mov     dx,-1                   ;Compute the max size of heap
        sub     dx,ds:[6]               ;  which is 64K less statics

UGS_Exit:

cEnd


;  UserGdiType
;
;       Tries to compute the type of local heap block if possible
;       Prototype:
;
;       void PASCAL UserGdiType(
;               LOCALENTRY FAR *lpLocal)

cProc   UserGdiType, <PUBLIC,NEAR>, <si,di>
        parmD   lpLocal
cBegin
        ;** Get info from our static variables
        mov     ax,_DATA                ;Get the variables first
        mov     ds,ax                   ;Point to our DS
        mov     bx,hUserHeap            ;BX=User's heap block
        mov     cx,hGDIHeap             ;CX=GDI's heap block

        ;** See if we can do anything with this heap
        les     si,lpLocal              ;Get a pointer to the structure
        mov     es:[si].le_wType,LT_NORMAL ;In case we don't find anything
        mov     ax,es:[si].le_hHeap     ;Get the heap pointer
        cmp     ax,bx                   ;User's heap?
        jnz     UGT_10                  ;Nope, try next
        cCall   GetUserType             ;Call routine to get user type
        jmp     SHORT UGT_End           ;Get out

UGT_10: cmp     ax,cx                   ;GDI's heap?
        jnz     UGT_End                 ;Nope, can't do anything with it
        cCall   GetGDIType              ;Call routine to get GDI type

UGT_End:

cEnd


;** Internal helper functions

;  GetUserType
;
;       Uses the tags in debug USER.EXE to give information on what type
;       block is pointed to by the current LOCALENTRY structure.
;       Caller:  ES:SI points to the parameter LOCALENTRY structure
;       Return:  LOCALENTRY structure is correctly updated

cProc   GetUserType, <NEAR>
cBegin
        ;** Make sure we have a function to call
        cmp     WORD PTR lpfnGetUserLocalObjType + 2,0 ;Selector zero?
        je      GUT_End                 ;Yes

        ;** Call USER to get the type
        push    es                      ;Save ES
        mov     bx,es:[si].le_wAddress  ;Get the block address
        sub     bx, la_fixedsize        ;The USER call needs the arena header
        test    es:[si].le_wFlags, LF_MOVEABLE ;Moveable block?
        jz      @F                      ;No
        sub     bx, (SIZE LocalArena) - la_fixedsize ;Moveable arena bigger
@@:     push    bx                      ;Parameter arena handle
        call    DWORD PTR lpfnGetUserLocalObjType ;Call the function
        pop     es
        xor     ah,ah                   ;Clear the upper byte
        mov     es:[si].le_wType,ax     ;Save the type
GUT_End:
cEnd


;  GetGDIType
;
;       Uses the tags in debug GDI.EXE to give information on what type
;       block is pointed to by the current LOCALENTRY structure.
;       Caller:  ES:SI points to the parameter LOCALENTRY structure
;       Return:  LOCALENTRY structure is correctly updated

cProc   GetGDIType, <NEAR>, <ds>
cBegin
        ;** All fixed blocks are unknown to us
        test    es:[si].le_wFlags,LF_FIXED ;Is it fixed?
        jz      GGT_10                  ;Nope
        jmp     SHORT GGT_End           ;Yes, get out
GGT_10:

        ;** Prepare to find the type
        cCall   HelperHandleToSel,es:[si].le_hHeap ;Get the selector value
        mov     cx,wTHFlags             ;Save for when we trash DS
        mov     ds,ax                   ;Get the heap pointer
        mov     di,es:[si].le_wAddress  ;Get the block pointer

        ;** Get the type word
        mov     ax,[di+2]               ;Get the type word from the heap
        and     ax,05fffh               ;Mask out the stock object flag
        test    cx,TH_WIN30             ;In 3.0?
        jnz     CGT_Win30               ;Yes
        sub     ax,LT_GDI_BASE          ;No, subtract type tag base
CGT_Win30:
        cmp     ax,LT_GDI_MAX           ;Recognizable type code?
        ja      GGT_End                 ;No, get out
        mov     es:[si].le_wType,ax     ;Save in the structure

GGT_End:
cEnd

sEnd
        END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\toolhelp\walk286.asm ===
;**************************************************************************
;*  walk286.ASM
;*
;*      Assembly support code for the KRNL286 global heap routines
;*      for TOOLHELP.DLL
;*
;**************************************************************************

        INCLUDE TOOLPRIV.INC

PMODE32 = 0
PMODE   = 1
SWAPPRO = 0
        INCLUDE WINKERN.INC

;** External functions
externNP HelperVerifySeg
externNP HelperHandleToSel
externNP HelperPDBtoTDB
externNP HelperSegLen

;** Functions

sBegin  CODE
        assumes CS,CODE

;  Walk286Count
;
;       Returns the number of blocks in the given list

cProc   Walk286Count, <PUBLIC,NEAR>, <di>
        parmW   wFlags
cBegin
        mov     es,hMaster              ;Segment of master block
        mov     ax,wFlags               ;Get the flag value
        shr     ax,1                    ;Check for GLOBAL_LRU
        jc      W2C_LRU                 ;Bit set, must be LRU
        shr     ax,1                    ;Check for GLOBAL_FREE
        jc      W2C_Free                ;Must be free
                                        ;Must be GLOBAL_ALL

        ;** Get total object count
        mov     ax,es:[hi_count]        ;Get heap count
        inc     ax                      ;Bump to include first sentinel
        jmp     SHORT W2C_End           ;Get out

        ;** Get LRU object count
W2C_LRU:
        mov     ax,es:[gi_lrucount]     ;Get the LRU count
        jmp     SHORT W2C_End           ;Get out

        ;** Get Free list object count
W2C_Free:
        mov     ax,es:[gi_free_count]   ;Get free count
        jmp     SHORT W2C_End           ;Get out

        ;** Return the result in AX
W2C_End:
        
cEnd

;  Walk286First
;
;       Returns a handle to the first block in the 286 global heap.

cProc   Walk286First, <PUBLIC,NEAR>, <di>
        parmW   wFlags
cBegin
        mov     es,hMaster              ;Segment of master block
        mov     ax,wFlags               ;Get the flag value
        shr     ax,1                    ;Check for GLOBAL_LRU
        jc      W2F_LRU                 ;Bit set, must be LRU
        shr     ax,1                    ;Check for GLOBAL_FREE
        jc      W2F_Free                ;Must be free
                                        ;Must be GLOBAL_ALL

        ;** Get first object in complete heap (wFlags == GLOBAL_ALL)
        mov     ax,es:[hi_first]        ;Get handle of first arena header
        jmp     SHORT W2F_End           ;Get out

        ;** Get first object in LRU list
W2F_LRU:
        mov     ax,es:[gi_lrucount]     ;Get the number of objects
        or      ax,ax                   ;Are there any objects?
        je      W2F_End                 ;No, return NULL
        inc     es:[gi_lrulock]         ;No LRU sweeping for awhile
        inc     wLRUCount               ;Keep a count of this
        mov     ax,es:[gi_lruchain]     ;Get a pointer to the first item
        jmp     SHORT W2F_End           ;Done

        ;** Get first object in Free list
W2F_Free:
        mov     ax,es:[gi_free_count]   ;Get the number of objects
        or      ax,ax                   ;Are there any objects?
        jz      W2F_End                 ;No, return NULL
        mov     es,es:[hi_first]        ;Get the first object
        mov     ax,es:[ga_freenext]     ;Skip to the first free block
                                        ;Fall through to the return

        ;** Return the result in AX (return DX = NULL)
W2F_End:
        xor     dx,dx                   ;Clear high word
cEnd


;  Walk286
;
;       Takes a pointer to a block and returns a GLOBALENTRY structure
;       full of information about the block.  If the block  pointer is
;       NULL, looks at the first block.  The last field in the GLOBALENTRY
;       structure is used to chain to the next block and is thus used to walk
;       the heap.

cProc   Walk286, <PUBLIC,NEAR>, <di,si,ds>
        parmD   dwBlock
        parmD   lpGlobal
        parmW   wFlags
cBegin
        ;** Set up to build public structure
        mov     es,WORD PTR dwBlock     ;Point to this block
        lds     si,lpGlobal             ;Point to the GLOBALENTRY structure

        ;** Fill public structure
        mov     ax,es:[ga_handle]       ;Get the handle of the block
        mov     [si].ge_hBlock,ax       ;Put in public structure
        mov     ax,es:[ga_size]         ;Get the size of the block (LOWORD)
        mov     dx,ax                   ;Clear high word
        shl     ax,4                    ;Left shift DX:AX by 4
        shr     dx,16-4
        mov     WORD PTR [si].ge_dwBlockSize,ax ;Put in public structure
        mov     WORD PTR [si].ge_dwBlockSize + 2,dx ;Put in public structure
        mov     ax,es:[ga_owner]        ;Owning task of block
        mov     [si].ge_hOwner,ax       ;Put in public structure
        xor     ah,ah                   ;No upper BYTE
        mov     al,es:[ga_count]        ;Lock count (moveable segments)
        mov     [si].ge_wcLock,ax       ;Put in public structure
        mov     WORD PTR [si].ge_wcPageLock,0 ;Zero the page lock count
        mov     al,es:[ga_flags]        ;BYTE of flags
        xor     ah,ah                   ;No upper BYTE
        mov     [si].ge_wFlags,ax       ;Put in public structure
        mov     ax,es:[ga_next]         ;Put next pointer in structure
        mov     WORD PTR [si].ge_dwNext,ax
        mov     WORD PTR [si].ge_dwNext + 2,0

        ;** Use DPMI to compute linear address of selector
        mov     ax,6                    ;Get Segment Base Address
        mov     bx,es                   ;Get the segment value
        int     31h                     ;Call DPMI
        mov     WORD PTR [si].ge_dwAddress,dx ;Save linear address
        mov     WORD PTR [si].ge_dwAddress + 2,cx

        ;** If this is a data segment, get local heap information
        mov     ax,[si].ge_hBlock       ;Get the handle
        cCall   Walk286VerifyLocHeap
        mov     [si].ge_wHeapPresent,TRUE ;Flag that there's a heap
        jnc     W2_10                   ;There really is no heap
        mov     [si].ge_wHeapPresent,FALSE ;Flag that there's no heap
W2_10:

        ;** If the owner is a PDB, translate this to the TDB
        mov     bx,[si].ge_hOwner       ;Get the owner
        cCall   HelperHandleToSel, <bx> ;Translate to selector
        mov     bx,ax                   ;Get the selector in BX
        cCall   HelperVerifySeg, <ax,2> ;Must be two bytes long
        or      ax,ax                   ;Is it?
        jz      W2_15                   ;No.
        push    es                      ;Save ES for later
        mov     es,bx                   ;Point to possible PDB block
        cmp     es:[0],20CDh            ;Int 20h is first word of PDB
        jnz     W2_12                   ;Nope, don't mess with this
        mov     ax,bx                   ;Pass parameter in AX
        cCall   HelperPDBtoTDB          ;Get the corresponding TDB
        or      ax,ax                   ;Was one found?
        jz      W2_11                   ;No.
        mov     [si].ge_hOwner,ax       ;Make the owner the TDB instead
W2_11:  or      [si].ge_wFlags,GF_PDB_OWNER ;Flag that a PDB owned block
W2_12:  pop     es                      ;Restore ES
W2_15:

        ;** Check for this being the last item in both lists
        mov     ax,es                   ;Get the current pointer
        cmp     ax,es:[ga_next]         ;See if we're at the end
        jne     W2_20                   ;No
        mov     WORD PTR [si].ge_dwNext,0 ;NULL the next pointer
        mov     WORD PTR [si].ge_dwNext + 2,0
W2_20:  mov     ax,es                   ;Get current pointer
        mov     cx,wFlags               ;Get the flags back
        cCall   NextLRU286              ;Get next LRU list pointer or 0
        mov     WORD PTR [si].ge_dwNextAlt,ax
        mov     WORD PTR [si].ge_dwNextAlt + 2,0

W2_End:
cEnd


;  Walk286Handle
;
;       Finds an arena pointer given a block handle

cProc   Walk286Handle, <PUBLIC,NEAR>, <di,si,ds>
        parmW   hBlock
cBegin
        mov     ax,hBlock               ;Get the block handle
        cCall   HelperHandleToSel, <ax> ;Convert to selector
        cCall   SelToArena286           ;Get the arena pointer
        jnc     W2H_10                  ;Must be OK
        xor     ax,ax                   ;Return a 0L
        xor     dx,dx
        jmp     SHORT W2H_End           ;Error in conversion, get out
W2H_10: mov     ax,bx                   ;Get the low word
        xor     dx,dx                   ;No high word
W2H_End:
cEnd


;  WalkLoc286Count
;
;       Returns the number of blocks in the given local heap

cProc   WalkLoc286Count, <PUBLIC,NEAR>, <di>
        parmW   hHeap
cBegin
        ;** Verify that it has a local heap
        mov     ax, hHeap               ;Get the block
        cCall   Walk286VerifyLocHeap    ;Verify it
        jnc     LC_10                   ;It's OK
        xor     ax,ax                   ;No heap
        jmp     SHORT LC_End            ;Get out
LC_10:

        ;** Point to the block
        mov     ax,hHeap                ;Get the heap block
        cCall   HelperHandleToSel, <ax> ;Convert it to a selector
        mov     es,ax                   ;Use ES to point to it
        mov     bx,es:[6]               ;Get a pointer to the HeapInfo struct

        ;** Get the number of blocks
        mov     ax,es:[bx].hi_count     ;Get the count
LC_End:
cEnd


;  WalkLoc286First
;
;       Returns a handle to the first block in the 286 global heap.

cProc   WalkLoc286First, <PUBLIC,NEAR>, <di>
        parmW   hHeap
cBegin
        ;** Verify that the given global block has a local heap
        mov     ax, hHeap               ;Get the block
        cCall   Walk286VerifyLocHeap    ;Verify it
        jnc     LF_10                   ;It's OK
        xor     ax,ax                   ;No heap
        jmp     SHORT LF_End            ;Get out
LF_10:

        ;** Point to the global block
        mov     ax,hHeap                ;Get the heap block
        cCall   HelperHandleToSel, <ax> ;Convert it to a selector
        mov     es,ax                   ;Use ES to point to it
        mov     bx,es:[6]               ;Get a pointer to the HeapInfo struct

        ;** Get the first block and return it
        mov     ax,WORD PTR es:[bx].hi_first ;Get the first block
LF_End:
cEnd


;  WalkLoc286
;
;       Takes a pointer to a block and returns a GLOBALENTRY structure
;       full of information about the block.  If the block  pointer is
;       NULL, looks at the first block.  The last field in the GLOBALENTRY
;       structure is used to chain to the next block and is thus used to walk
;       the heap.

cProc   WalkLoc286, <PUBLIC,NEAR>, <di,si,ds>
        parmW   wBlock
        parmD   lpLocal
        parmW   hHeap
cBegin
        ;** Verify that it has a local heap
        mov     ax, hHeap               ;Get the block
        cCall   Walk286VerifyLocHeap    ;Verify it
        jnc     LW_10                   ;It's OK
        jmp     LW_End                 ;Get out
LW_10:

        ;** Get variables from the TOOLHELP DGROUP
        mov     ax,_DATA                ;Get the variables first
        mov     ds,ax                   ;Point to our DS
        mov     bx,hUserHeap            ;BX=User's heap block
        mov     cx,hGDIHeap             ;CX=GDI's heap block

        ;** Point to the heap
        mov     ax,hHeap                ;Get the heap block
        cCall   HelperHandleToSel, <ax> ;Convert it to a selector
        mov     es,ax                   ;Use ES to point to it
        lds     di,lpLocal              ;Point to the LOCALENTRY structure
        mov     [di].le_wHeapType,NORMAL_HEAP ;In case we don't match below...
        cmp     bx,hHeap                ;User's heap?
        jnz     LW_3                    ;No
        mov     [di].le_wHeapType,USER_HEAP ;Yes
        jmp     SHORT LW_5              ;Skip on
LW_3:   cmp     cx,hHeap                ;GDI's heap?
        jnz     LW_5                    ;No
        mov     [di].le_wHeapType,GDI_HEAP ;Yes
LW_5:
        mov     si,wBlock               ;Get the address of the block

        ;** Get information about the given block
        mov     bx,es:[si].la_handle    ;Get the handle
        mov     [di].le_hHandle,bx      ;Save in the public structure
        mov     ax,si                   ;Get block address
        add     ax,la_fixedsize         ;Skip fixed size local arena
        mov     [di].le_wAddress,ax     ;Save the block address
        mov     ax,es:[si].la_next      ;Get the address of the next block
        mov     [di].le_wNext,ax        ;Save the next pointer
        sub     ax,si                   ;Compute the size
        sub     ax,SIZE LocalArena      ;Don't count arena size
        mov     [di].le_wSize,ax        ;Save in public structure
        mov     ax,es:[si].la_prev      ;Get the flags
        and     ax,3                    ;Mask out all but flags
        mov     [di].le_wFlags,ax       ;Save in structure

        ;** Moveable arenas are bigger and have a lock count to get
        test    al,LA_MOVEABLE          ;Block has a handle iff it's moveable
        jz      SHORT LW_NoHandle       ;No handle info
        sub     [di].le_wSize, (SIZE LocalArena) - la_fixedsize
        add     [di].le_wAddress, (SIZE LocalArena) - la_fixedsize
        xor     ah,ah                   ;Clear upper word
        mov     al,es:[bx].lhe_count    ;Get lock count
        mov     [di].le_wcLock,ax       ;Save it
        jmp     SHORT LW_20             ;Skip no handle info
LW_NoHandle:
        mov     ax, [di].le_wAddress    ;Handle of fixed block is real offset
        mov     [di].le_hHandle, ax
        mov     [di].le_wcLock,0
LW_20:
        ;** See if it's the end
        cmp     [di].le_wNext,si        ;Loop pointer?
        jnz     LW_End                  ;Nope
        mov     [di].le_wNext,0         ;Set a zero pointer
LW_End:
cEnd


;  Walk286VerifyLocHeap
;
;       Verifies that the given global block points to a data segment
;       with a local heap.
;
;       Call:
;               AX = Block handle or selector
;       Return:
;               Carry flag set iff NOT a local heap segment
;
;       Destroys all registers except AX, ESI, EDI, DS, and ES

cProc   Walk286VerifyLocHeap, <PUBLIC,NEAR>, <es,si,di>
cBegin
        ;** Convert to a handle
        cCall   HelperHandleToSel, <ax>

        ;** Verify the selector
        push    ax                      ;Save the parameter
        mov     bx,SIZE LocalInfo       ;Get the size
        cCall   HelperVerifySeg, <ax,bx> ;Check the selector
        or      ax,ax                   ;Is it valid?
        pop     ax                      ;Restore parameter
        jnz     VLH_SelOK               ;Yes.
        stc                             ;Set error flag 
        jmp     SHORT VLH_End           ;Get out
VLH_SelOK:

        ;** Check data segment to see if it has a local heap
        mov     es,ax                   ;Point to the local block with ES
        cCall   HelperSegLen, <ax>      ;Get the length of the heap
        or      ax,ax                   ;Check for error
        jz      VLH_NoHeap              ;Get out on error
        mov     cx,ax                   ;Use CX for comparisons
        cmp     cx,8                    ;At least 8 bytes long?
        ja      VLH_10                  ;Yes
        stc                             ;No -- set error flag and get out
        jmp     SHORT VLH_End
VLH_10: mov     bx,es:[6]               ;Get offset to HeapInfo struct
        or      bx,bx                   ;If NULL, no local heap
        jz      VLH_NoHeap              ;Get out
        sub     cx,bx                   ;See if HeapInfo is beyond segment
        jbe     VLH_NoHeap
        sub     cx,li_sig + 2           ;Compare against last structure mem
        jbe     VLH_NoHeap
        cmp     es:[bx].li_sig,LOCALHEAP_SIG ;Make sure the signature matches
        jne     VLH_NoHeap              ;Doesn't match
        clc                             ;Must be a heap!
        jmp     SHORT VLH_End

VLH_NoHeap:
        stc                             ;Set error flag

VLH_End:
cEnd


;** Private helper functions

;  SelToArena286
;
;       Finds the arena entry for the given selector or handle.
;       The arena entry is stored 16 bytes before the block in linear
;       address space.
;
;       Caller:         AX = Selector
;       Returns:        BX = Arena entry
;       Trashes everything except segment registers and AX
;       Carry set on error

cProc   SelToArena286, <NEAR>, <es,ds,ax>
cBegin
        ;** Convert to a handle
        cCall   HelperHandleToSel, <ax>

        ;** Verify selector
        push    ax                      ;Save the parameter
        cCall   HelperVerifySeg, <ax,1> ;Check the selector
        or      ax,ax                   ;Is it valid?
        pop     ax                      ;Restore parameter
        jnz     STA_SelOK               ;Must be
        stc                             ;Nope.  Set error flag and exit
        jmp     SHORT STA_End
STA_SelOK:
        ;** If this is Win30StdMode, we're in the old KRNL286 which used
        ;*      an arcane method of finding the arena.  If that's the case
        ;**     here, handle it seperately.
        mov     bx,_DATA                ;Get the static data segment
        mov     ds,bx
        test    wTHFlags,TH_WIN30STDMODE ;3.0 Std Mode?
        jnz     STA_OldKRNL286          ;Yes
        mov     bx,segKernel            ;Get the KERNEL variable segment
        mov     es,bx
        mov     bx,npwSelTableLen       ;Get the pointer
        mov     dx,es:[bx]              ;Get the selector table length
        mov     bx,npdwSelTableStart    ;Get the start of the sel table
        mov     bx,es:[bx]              ;Get the linear offset (32 bits)
        mov     es,hMaster              ;Point to the arena table
        and     al,not 7                ;Clear the RPL bits for table lookup
        shr     ax,2                    ;Convert to WORD offset
        cmp     ax,dx                   ;Check to see if off the end of table
        jb      STA_InTable             ;It's in the table
        stc                             ;Set error flag--not in table
        jmp     SHORT STA_End           ;Get out
STA_InTable:
        add     bx,ax                   ;Add the selector offset
        mov     bx,es:[bx]              ;Do the sel table indirection
        clc                             ;BX now points to arena segment
        jmp     SHORT STA_End           ;Skip the old stuff

STA_OldKRNL286:
        mov     bx,ax                   ;Selector in BX
        mov     ax,6                    ;DPMI function 6, Get Seg Base Addr
        int     31h                     ;Call DPMI
        sub     dx,10h                  ;Move back 16 bytes
        sbb     cx,0                    ;  (this is a linear address)
        mov     ax,7                    ;DPMI function 7, Set Seg Base Addr
        mov     bx,wSel                 ;Use our roving selector
        int     31h                     ;Call DPMI
        mov     ax,8                    ;DPMI function 8, Set Seg Limit
        xor     cx,cx                   ;No upper byte
        mov     dx,16                   ;Just 16 bytes
        int     31h                     ;Call DPMI
        mov     ax,9                    ;DPMI function 9, Set Access Rights
        mov     cl,0b2h                 ;Desired rights byte
        int     31h                     ;Call DPMI
                                        ;Return arena segment pointer in BX
STA_End:
cEnd


;  NextLRU286
;
;       Checks the given arena table pointer to see if it is the last
;       arena entry on the list.
;       Uses a grungy method that is necessitated because of the
;       unterminated linked lists we're dealing with here.  The count
;       stored is the only reliable method for finding the end.  So, to
;       provide random access to blocks in the heap, the heap is searched
;       from top to bottom to find the block and see if it is the last
;       one.  If it is or if it is not on the given list, returns a 0
;       pointer to the next item.
;
;       If this search is for the entire global heap, we do not get the
;       LRU link, but return NULL in AX.  This speeds this up alot!
;
;       Caller:         AX = Arena table pointer
;                       CX = GLOBAL_ALL, GLOBAL_FREE, or GLOBAL_LRU
;       Return:         AX = Next arena table pointer or 0 if no more
;       Trashes all registers except segment registers and SI,DI

cProc   NextLRU286, <NEAR,PUBLIC>, <es,ds,si,di>
cBegin
        ;** Decode the flags
        mov     bx,_DATA                ;Get the static data segment
        mov     ds,bx                   ;Point with DS
        mov     es,hMaster              ;Segment of master block
        cmp     cx,GLOBAL_ALL           ;Don't do this on full heap search
        jne     @F
        jmp     SHORT NL_BadList        ;Just return NULL for this one
@@:     cmp     cx,GLOBAL_FREE          ;Check free list?
        je      NL_Free                 ;Yes

        ;** Loop through LRU list until we find this item
NL_LRU:
        mov     si,ax                   ;Save the selector in AX
        mov     cx,es:[gi_lrucount]     ;Get the number of objects
        jcxz    NL_Bad                  ;No object so return end
        dec     cx                      ;We don't want to find the last one
        jcxz    NL_Bad                  ;1 object so return end
        mov     ds,es:[gi_lruchain]     ;Get a pointer to the first item
NL_LRULoop:
        mov     ax,ds                   ;Get in AX so we can compare
        cmp     si,ax                   ;Match yet?
        je      NL_ReturnNext           ;Found it, return next item
        mov     ds,ds:[ga_lrunext]      ;Not found yet, get the next one
        loop    NL_LRULoop              ;Loop through all items

        ;** Unlock the LRU sweeping
NL_Bad: dec     es:[gi_lrulock]         ;OK to LRU sweep now
        mov     ax, _DATA               ;Point to TH Data seg
        mov     ds, ax
        dec     wLRUCount               ;Keep a count of this
        jmp     SHORT NL_BadList        ;Not here either.  Get out

        ;** Loop through free list until we find this item
NL_Free:
        mov     si,ax                   ;Save the selector in SI
        mov     cx,es:[gi_free_count]   ;Get the number of objects
        jcxz    NL_BadList              ;0 objects so return end
        dec     cx                      ;We don't want to find the last one
        jcxz    NL_BadList              ;1 object so return end
        mov     ds,es:[hi_first]        ;Get a pointer to the first item
NL_FreeLoop:
        mov     ds,ds:[ga_lrunext]      ;Not found yet, get the next one
        mov     ax,ds                   ;Get the pointer so we can compare it
        cmp     ax,si                   ;Is this the one?
        je      NL_ReturnNext           ;Yes, return it
        loop    NL_FreeLoop             ;Loop through all items
        jmp     SHORT NL_BadList        ;Not here either.  Get out

NL_ReturnNext:
        mov     ax,ds:[ga_lrunext]      ;Return the next one
        jmp     SHORT NL_End            ;Get out

NL_BadList:
        xor     ax,ax                   ;Return zero for error

NL_End:
cEnd

sEnd
        END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\user\drvr.c ===
/* Installable drivers for windows. Often used stuff.
  */
#include "user.h"

LRESULT FAR InternalBroadcastDriverMessage(HDRVR  hDriverStart,
                                           WORD   message,
                                           LPARAM lParam1,
					   LPARAM lParam2,
                                           LONG   flags)
/* effects: Allows for sending messages to the drivers. Supports sending
 * messages to one instance of every driver, supports running through the list
 * in reverse order, and supports sending a message to a particular driver id.
 *
 * If flags & IBDM_SENDMESSAGE then only send message to
 * hDriverStart and ignore other flags. Fail if not
 * 0<hDriverStart<=cInstalledDrivers.
 *
 * If flags & IBDM_FIRSTINSTANCEONLY then send message to one instance of
 * each driver between hDriverStart and cInstalledDrivers.
 *
 * If flags  & IBDM_REVERSE then send message to drivers in reverse
 * order from hDriverStart to 1. If hDriverStart is 0 then send
 * messages to drivers from cInstalledDrivers to 1
 */
{
  LPDRIVERTABLE lpdt;
  LRESULT	result=0;
  int           id;
  int           idEnd;

  if (!hInstalledDriverList || (int)hDriverStart > cInstalledDrivers)
      return(FALSE);

  if (idFirstDriver == -1)
      /* No drivers in the list
       */
      return(FALSE);

  lpdt = (LPDRIVERTABLE)MAKELP(hInstalledDriverList,0);


  if (flags & IBDM_SENDMESSAGE)
    {
      if (!hDriverStart)
          return(FALSE);
      idEnd = lpdt[(int)hDriverStart-1].idNextDriver;
      flags &= ~(IBDM_REVERSE | IBDM_FIRSTINSTANCEONLY);
    }
  else
    {
      if (flags & IBDM_REVERSE)
        {
          if (!hDriverStart)
	      hDriverStart = (HDRVR)(idLastDriver+1);
          idEnd = lpdt[idFirstDriver].idPrevDriver;
        }
      else
        {
          if (!hDriverStart)
              hDriverStart = (HDRVR)(idFirstDriver+1);
	  idEnd = lpdt[idLastDriver].idNextDriver;
        }
    }

  /* Ids are -1 into the global driver list. */
  ((int)hDriverStart)--;

  for (id = (int)hDriverStart; id != idEnd; id = (flags & IBDM_REVERSE ? lpdt[id].idPrevDriver : lpdt[id].idNextDriver))
    {
       if (lpdt[id].hModule)
         {
           if ((flags & IBDM_FIRSTINSTANCEONLY) &&
               !lpdt[id].fFirstEntry)
               continue;

           result =
           (*lpdt[id].lpDriverEntryPoint)(lpdt[id].dwDriverIdentifier,
					  (HDRVR)(id+1),
                                          message,
                                          lParam1,
                                          lParam2);

           /* If this isn't a IBDM_SENDMESSAGE, we want to update our end
	    * points in case the driver callback added or removed some drivers
	    */
           if (flags & IBDM_REVERSE)
             {
               idEnd = lpdt[idFirstDriver].idPrevDriver;
             }
           else if (!(flags & IBDM_SENDMESSAGE))
             {
   	       idEnd = lpdt[idLastDriver].idNextDriver;
             }
           else
             {
               /* This is a IBDM_SENDMESSAGE. We need to break out of the for
		* loop here otherwise we run into problems if a new driver was
		* installed in the list during the callback and idEnd got
		* updated or something...
		*/
               break;
             }
         }
    }

  return(result);
}


LRESULT API ISendDriverMessage(HDRVR  hDriverID,
			       UINT   message,
			       LPARAM lParam1,
			       LPARAM lParam2)
{
  return(InternalBroadcastDriverMessage(hDriverID,
                                        message,
                                        lParam1,
                                        lParam2,
                                        IBDM_SENDMESSAGE));
}




BOOL API IGetDriverInfo(HDRVR hDriver, LPDRIVERINFOSTRUCT lpDriverInfoStruct)
{
  LPDRIVERTABLE lpdt;
  BOOL          ret = FALSE;

  if (!lpDriverInfoStruct ||
      lpDriverInfoStruct->length != sizeof(DRIVERINFOSTRUCT))
    {
      /* Error in struct size
       */
      DebugErr(DBF_ERROR, "Invalid size for DRIVERINFOSTRUCT");
      return(ret);
    }

#ifdef DEBUG
    DebugFillStruct(lpDriverInfoStruct, sizeof(DRIVERINFOSTRUCT));
    lpDriverInfoStruct->length = sizeof(DRIVERINFOSTRUCT);
#endif

  if (!hInstalledDriverList || (int)hDriver <= 0 || (int)hDriver > cInstalledDrivers)
      return(ret);

  lpdt = (LPDRIVERTABLE)MAKELP(hInstalledDriverList, 0);

  if (lpdt[(int)hDriver-1].hModule)
    {
      lpDriverInfoStruct->hDriver = hDriver;
      lpDriverInfoStruct->hModule = lpdt[(int)hDriver-1].hModule;
      lstrcpy(lpDriverInfoStruct->szAliasName, lpdt[(int)hDriver-1].szAliasName);

      ret = TRUE;
    }


  return(ret);
}



HDRVR API IGetNextDriver(HDRVR hStart, DWORD dwFlags)
{
  int           iStart;
  int           iEnd;
  int           id;
  HDRVR 	h;
  LPDRIVERTABLE lpdt;

  if (!hInstalledDriverList || !cInstalledDrivers || idFirstDriver == -1)
      return(0);

  lpdt = (LPDRIVERTABLE)MAKELP(hInstalledDriverList,0);

  if (dwFlags & GND_REVERSE)
    {
      if (!hStart)
          iStart = idLastDriver;
      else
        {
          iStart = (int)hStart-1;

	  if (iStart == idFirstDriver)
	      /* If we are at the first driver, nothing left to do
	       */
	      return((HDRVR)0);

	  iStart = lpdt[iStart].idPrevDriver;
        }

      iEnd = lpdt[idFirstDriver].idPrevDriver;

    }
  else
    {
      if (!hStart)
          iStart = idFirstDriver;
      else
        {
	  iStart = (int)hStart-1;

          if (iStart == idLastDriver)
              /* If we are at the last driver, nothing left to do.
	       */
              return((HDRVR)0);

          iStart = lpdt[iStart].idNextDriver;
        }

      iEnd = lpdt[idLastDriver].idNextDriver;

    }

  if (!lpdt[iStart].hModule)
    {
      /* Bogus driver handle passed in
       */
      DebugErr(DBF_ERROR, "GetNextDriver: Invalid starting driver handle");
      return(0);
    }

  h = NULL;

  for (id = iStart; id != iEnd; id = (dwFlags & GND_REVERSE ? lpdt[id].idPrevDriver : lpdt[id].idNextDriver))
    {
       if (lpdt[id].hModule)
         {
           if ((dwFlags & GND_FIRSTINSTANCEONLY) &&
               !lpdt[id].fFirstEntry)
               continue;

	   h = (HDRVR)(id+1);
           break;
         }
    }

  return(h);
}


LRESULT API IDefDriverProc(dwDriverIdentifier, driverID, message, lParam1, lParam2)
DWORD  dwDriverIdentifier;
HDRVR  driverID;
UINT   message;
LPARAM lParam1;
LPARAM lParam2;
{

  switch (message)
   {
      case DRV_INSTALL:
         return((LRESULT)(DWORD)DRVCNF_OK);
         break;

      case DRV_LOAD:
      case DRV_ENABLE:
      case DRV_DISABLE:
      case DRV_FREE:
	 return((LRESULT)(DWORD)TRUE);
         break;
   }

  return(0L);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\user\fastres.c ===
/*++
 *
 *  WOW v1.0
 *
 *  Copyright (c) 1991, Microsoft Corporation
 *
 *  FASTRES.C
 *  WOW16 user resource services
 *
 *  History:
 *
 *  Created 12-Jan-1993 by Chandan Chuahan (ChandanC)
 *
 *  This file provides the Win 3.1 routines for loading BITMAP, MENU, ICON,
 *  CURSOR, and DIALOG resources. These routines load the resources from the
 *  App EXE and then pass the pointers to the corresponding 32 bit WOW
 *  thunks. Thus saving the call backs from USER client to find, load, lock,
 *  size, unlock, and free the resources.
 *
--*/

#include "user.h"

HBITMAP FAR PASCAL WOWLoadBitmap (HINSTANCE hInst, LPCSTR lpszBitmap, LPBYTE lpByte, DWORD ResSize);
HMENU   FAR PASCAL WOWLoadMenu (HINSTANCE hInst, LPCSTR lpszMenuName, LPBYTE lpByte, DWORD ResSize, WORD WinVer);
HCURSOR FAR PASCAL WOWLoadCursorIcon (HINSTANCE hInst, LPCSTR lpszCursor, LPBYTE lpByte, DWORD ResSize, HGLOBAL hGbl, WORD WinVer, WORD wRttype);

//
// fDialogApi is TRUE for DialogBox* apis
// fDialogApi is FALSE for CreateDialog* apis
//

HWND    FAR PASCAL WOWDialogBoxParam (HINSTANCE hInst, LPBYTE lpByte,
                         HWND hwndOwner, DLGPROC dlgprc,  LPARAM lParamInit,
                         DWORD ResSize, WORD fDialogApi);

DWORD   FAR PASCAL NotifyWOW (WORD Id, LPBYTE pData);
#define LR_DEFAULTSIZE      0x0040  // from \nt\public\sdk\inc\winuser.h
int     FAR PASCAL LookupIconIdFromDirectoryEx(LPBYTE lpByte, BOOL fIcon,
                                               int cxDesired, int cyDesired,
                                               WORD wFlags);
HANDLE  FAR PASCAL WOWSetClipboardData (UINT, HANDLE);

typedef struct _ICONCUR16 { /* iconcur */
    WORD   hInst;
    DWORD  lpStr;
} ICONCUR16;

/* These must match counterparts in mvdm\inc\wowusr.h */
#define NW_LOADICON         1 // Internal
#define NW_LOADCURSOR       2 // Internal

HINSTANCE CheckDispHandle (HINSTANCE hInst)
{
    HMODULE hIns;

    if (hInst) {
        hIns = GetModuleHandle ("DISPLAY");
        return ((hInst == (HINSTANCE) hIns) ? 0:hInst);
    }
    else {
        return (0);
    }
}


HBITMAP API ILoadBitmap (HINSTANCE hInst, LPCSTR lpszBitmap)
{
    HRSRC hRsrc = 0;
    HGLOBAL hGbl = 0;
    DWORD ResSize = 0;
    LPBYTE lpByte = (LPBYTE) NULL;
    HBITMAP ul = (HBITMAP)0;

    if (hInst = CheckDispHandle (hInst)) {

        hRsrc = FindResource (hInst, lpszBitmap, RT_BITMAP);
        if (!hRsrc) {
            goto lbm_exit;
        }
        ResSize = SizeofResource (hInst, hRsrc);
        if (!ResSize) {
            goto lbm_exit;
        }

        hGbl = LoadResource (hInst, hRsrc);
        if (!hGbl) {
            goto lbm_exit;
        }

        lpByte = LockResource (hGbl);
        if (!lpByte) {
            goto lbm_exit;
        }
    }

    ul = (HBITMAP) WOWLoadBitmap (hInst, lpszBitmap, lpByte, ResSize);


lbm_exit:
    if (lpByte) {
        GlobalUnlock (hGbl);
    }
    if (hGbl) {
        FreeResource(hGbl);
    }

    return (ul);
}




HMENU API ILoadMenu (HINSTANCE hInst, LPCSTR lpszMenuName)
{
    HRSRC hRsrc;
    HGLOBAL hGbl;
    DWORD ResSize = 0;
    LPBYTE lpByte = (LPBYTE) NULL;
    HMENU  ul;
    WORD WinVer;

    if (hRsrc = FindResource (hInst, lpszMenuName, RT_MENU)) {
        if (ResSize = SizeofResource (hInst, hRsrc))
            if (hGbl = LoadResource (hInst, hRsrc))
                if (lpByte = LockResource (hGbl))
                    WinVer = GetExpWinVer (hInst);
    }

    if (!lpByte) {
        return (NULL);
    }

    ul = (HMENU) WOWLoadMenu (hInst, lpszMenuName, lpByte, ResSize, WinVer);

    if (hInst) {
        GlobalUnlock (hGbl);
    }

    return (ul);
}


HICON API ILoadIcon (HINSTANCE hInst, LPCSTR lpszIcon)
{
    HRSRC hRsrc;
    HGLOBAL hGbl;
    DWORD ResSize = 0;
    LPBYTE lpByte = (LPBYTE) NULL;
    HICON  ul;
    DWORD IconId;
    WORD WinVer;

    ICONCUR16 IconCur;

    WinVer = GetExpWinVer (hInst);

    if (!(hInst = CheckDispHandle (hInst))) {
        ul = WOWLoadCursorIcon (hInst, lpszIcon, lpByte, ResSize, NULL, WinVer, (WORD)RT_ICON);
    }
    else {
        IconCur.hInst = (WORD) hInst;
        IconCur.lpStr = (DWORD) lpszIcon;

        if (!(ul = (HICON) NotifyWOW (NW_LOADICON, (LPBYTE) &IconCur))) {
            if (WinVer >= VER30) {
                if (hRsrc = FindResource (hInst, lpszIcon, RT_GROUP_ICON)) {
                    if (ResSize = SizeofResource (hInst, hRsrc))
                        if (hGbl = LoadResource (hInst, hRsrc))
                            lpByte = LockResource (hGbl);
                }
                if (!lpByte) {
                    return (NULL);
                }

                IconId = LookupIconIdFromDirectoryEx(lpByte, TRUE, 0, 0, LR_DEFAULTSIZE);

                GlobalUnlock (hGbl);
            }
            else {
                IconId = (DWORD)lpszIcon;
            }

            if (hRsrc = FindResource (hInst, (LPCSTR) IconId, RT_ICON)) {
                if (ResSize = SizeofResource (hInst, hRsrc))
                    if (hGbl = LoadResource (hInst, hRsrc))
                        lpByte = LockResource (hGbl);
                }
            if (!lpByte) {
                return (NULL);
            }

            ul = WOWLoadCursorIcon (hInst, lpszIcon, lpByte, ResSize, hGbl, WinVer, (WORD)RT_ICON);

            GlobalUnlock (hGbl);
        }
    }

    return (ul);
}


HCURSOR API ILoadCursor (HINSTANCE hInst, LPCSTR lpszCursor)
{
    HRSRC hRsrc;
    HGLOBAL hGbl;
    DWORD ResSize = 0;
    LPBYTE lpByte = (LPBYTE) NULL;
    HCURSOR ul;
    DWORD CursorId;
    WORD WinVer;

    ICONCUR16 IconCur;

    WinVer = GetExpWinVer (hInst);

    if (!(hInst = CheckDispHandle (hInst))) {
        ul = WOWLoadCursorIcon (hInst, lpszCursor, lpByte, ResSize, NULL, WinVer, (WORD)RT_CURSOR);
    }
    else {
        IconCur.hInst = (WORD) hInst;
        IconCur.lpStr = (DWORD) lpszCursor;

        if (!(ul = (HICON) NotifyWOW (NW_LOADCURSOR, (LPBYTE) &IconCur))) {
            if (WinVer >= VER30) {
                if (hRsrc = FindResource (hInst, lpszCursor, RT_GROUP_CURSOR)) {
                    if (ResSize = SizeofResource (hInst, hRsrc))
                        if (hGbl = LoadResource (hInst, hRsrc))
                            lpByte = LockResource (hGbl);
                }
                if (!lpByte) {
                    return (NULL);
                }

                CursorId = LookupIconIdFromDirectoryEx((LPBYTE)lpByte, FALSE, 0, 0, LR_DEFAULTSIZE);

                GlobalUnlock (hGbl);
            }
            else {
                CursorId = (DWORD)lpszCursor;
            }

            if (hRsrc = FindResource (hInst, (LPCSTR) CursorId, RT_CURSOR)) {
                if (ResSize = SizeofResource (hInst, hRsrc))
                    if (hGbl = LoadResource (hInst, hRsrc))
                        if (lpByte = LockResource (hGbl))
                            WinVer = GetExpWinVer (hInst);
            }
            if (!lpByte) {
                return (NULL);
            }

            ul = WOWLoadCursorIcon (hInst, lpszCursor, lpByte, ResSize, hGbl, WinVer, (WORD)RT_CURSOR);

            GlobalUnlock (hGbl);
        }
    }

    return (ul);
}



HWND API ICreateDialogParam (HINSTANCE hInst, LPCSTR lpszDlgTemp, HWND hwndOwner, DLGPROC dlgprc, LPARAM lParamInit)
{
    HRSRC hRsrc;
    HGLOBAL hGbl;
    DWORD ResSize = 0;
    LPBYTE lpByte = (LPBYTE) NULL;
    HWND  ul;

    if (hRsrc = FindResource (hInst, lpszDlgTemp, RT_DIALOG)) {
        if (ResSize = SizeofResource (hInst, hRsrc))
            if (hGbl = LoadResource (hInst, hRsrc))
                lpByte = LockResource (hGbl);
    }

    if (!lpByte) {
        return (NULL);
    }

    ul = (HWND) WOWDialogBoxParam (hInst, lpByte, hwndOwner,
                                           dlgprc, lParamInit, ResSize, FALSE);

    if (hInst) {
        GlobalUnlock (hGbl);
    }

    return (ul);
}

HWND API ICreateDialog (HINSTANCE hInst, LPCSTR lpszDlgTemp, HWND hwndOwner, DLGPROC dlgprc)
{
    return (ICreateDialogParam (hInst, lpszDlgTemp, hwndOwner, dlgprc, 0L));
}


HWND API ICreateDialogIndirectParam (HINSTANCE hInst, LPCSTR lpszDlgTemp, HWND hwndOwner, DLGPROC dlgprc, LPARAM lParamInit)
{
    return  WOWDialogBoxParam (hInst, (LPBYTE)lpszDlgTemp, hwndOwner,
                                            dlgprc, lParamInit, 0, FALSE);
}

HWND API ICreateDialogIndirect (HINSTANCE hInst, LPCSTR lpszDlgTemp, HWND hwndOwner, DLGPROC dlgprc)
{
    return  WOWDialogBoxParam (hInst, (LPBYTE)lpszDlgTemp, hwndOwner,
                                            dlgprc, 0, 0, FALSE);
}

int API IDialogBoxParam (HINSTANCE hInst, LPCSTR lpszDlgTemp, HWND hwndOwner, DLGPROC dlgprc, LPARAM lParamInit)
{
    HRSRC hRsrc;
    HGLOBAL hGbl;
    DWORD ResSize = 0;
    LPBYTE lpByte = (LPBYTE) NULL;
    int   ul;

    if (hRsrc = FindResource (hInst, lpszDlgTemp, RT_DIALOG)) {
        if (ResSize = SizeofResource (hInst, hRsrc))
            if (hGbl = LoadResource (hInst, hRsrc))
                lpByte = LockResource (hGbl);
    }

    if (!lpByte) {
        return (-1);
    }

    ul = (int)WOWDialogBoxParam (hInst, lpByte, hwndOwner, dlgprc,
                                                  lParamInit, ResSize, TRUE);

    if (hInst) {
        GlobalUnlock (hGbl);
    }

    return (ul);
}


int API IDialogBox (HINSTANCE hInst, LPCSTR lpszDlgTemp, HWND hwndOwner, DLGPROC dlgprc)
{
    return (IDialogBoxParam (hInst, lpszDlgTemp, hwndOwner, dlgprc, 0L));
}


int API IDialogBoxIndirectParam (HINSTANCE hInst, HGLOBAL hGbl, HWND hwndOwner, DLGPROC dlgprc, LPARAM lParamInit)
{
    DWORD ResSize;
    LPBYTE lpByte;
    int    ul;

    if (lpByte = LockResource (hGbl)) {
        ResSize = GlobalSize(hGbl);
        ul = (int)WOWDialogBoxParam (hInst, lpByte, hwndOwner, dlgprc,
                                                   lParamInit, ResSize, TRUE);
        GlobalUnlock (hGbl);
    }
    else {
        ul = -1;
    }

    return (ul);
}


int API IDialogBoxIndirect(HINSTANCE hInst, HGLOBAL hGbl, HWND hwndOwner, DLGPROC dlgprc)
{
    return IDialogBoxIndirectParam (hInst, hGbl, hwndOwner, dlgprc, 0);
}

HANDLE  API SetClipboardData (UINT cbformat, HANDLE hMem)
{
    HANDLE ul;
    LPMETAFILEPICT  lpMf;

    switch (cbformat) {

        case CF_DSPMETAFILEPICT:
        case CF_METAFILEPICT:
            if (hMem) {
                lpMf = (LPMETAFILEPICT) GlobalLock(hMem);
                if (lpMf) {

                    /* If the handle is bad make hMF = NULL. This is needed
                     * for Micrograpfx. They don't check for failure when rendering
                     * data
                     */

                    if (!(GlobalReAlloc (lpMf->hMF, 0L, GMEM_MODIFY | GMEM_SHARE))) {
                        lpMf->hMF = NULL;
                    }
                }
                GlobalUnlock(hMem);
            }


            // It is intentional to let it thru to the "case statements".
            // ChandanC 5/11/92.


/*
*        These are the defaults.
*
*        case CF_DIB:
*        case CF_TEXT:
*        case CF_DSPTEXT:
*        case CF_SYLK:
*        case CF_DIF:
*        case CF_TIFF:
*        case CF_OEMTEXT:
*        case CF_PENDATA:
*        case CF_RIFF:
*        case CF_WAVE:
*        case CF_OWNERDISPLAY:
*/

        default:
            if (hMem) {
                hMem = GlobalReAlloc (hMem, 0L, GMEM_MODIFY | GMEM_DDESHARE);
            }
            break;

        case CF_DSPBITMAP:
        case CF_BITMAP:
        case CF_PALETTE:
            break;

    }

    ul = WOWSetClipboardData (cbformat, hMem);
    return (ul);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\user\fmtmsg.c ===
//
// Windows NT WOW v5
//
// fmtmsg.c -- 16-bit FormatMessage API, lifted from Win95
//             \win\core\user\wn32rare.c by Dave Hart
//
//

#include "user.h"

typedef DWORD ULONG;

// from win95 user.h
#define CODESEG     _based(_segname("_CODE"))
#define TESTFAR(p)  SELECTOROF(p)

// from win95 dev\inc16\windows.h
#define FORMAT_MESSAGE_ALLOCATE_BUFFER  0x00000100      /* ;Internal NT */
#define FORMAT_MESSAGE_IGNORE_INSERTS   0x00000200      /* ;Internal NT */
#define FORMAT_MESSAGE_FROM_STRING      0x00000400      /* ;Internal NT */
#define FORMAT_MESSAGE_FROM_HMODULE     0x00000800      /* ;Internal NT */
#define FORMAT_MESSAGE_FROM_SYSTEM      0x00001000      /* ;Internal NT */
//#define FORMAT_MESSAGE_ARGUMENT_ARRAY   0x00002000      /* ;Internal */
#define FORMAT_MESSAGE_MAX_WIDTH_MASK   0x000000FF      /* ;Internal NT */
#define FORMAT_MESSAGE_VALID            0x00003FFF      /* ;Internal */


char CODESEG szStringFormat[] = "%s";
char CODESEG szStringFormat2[] = "%%%lu";
char CODESEG szStringFormat3[] = "%%%lu!%s!";


#if 0
// ----------------------------------------------------------------------------
//
//  GetSystemInstance()
//
//  _loadds function to return hInstanceWin.  Needed cuz FormatMessage can
//  LocalAlloc a buffer for an app.  We GlobalAlloc() a temp buffer to do the
//  actual work in.  Both local & global memory go away when the context that
//  created it terminates.
//
// ----------------------------------------------------------------------------
HINSTANCE NEAR _loadds FMGetSystemInstance(void)
{
    return(hInstanceWin);
}
#endif


#undef LocalAlloc
#undef LocalFree
extern HLOCAL WINAPI LocalAlloc(UINT, UINT);
extern HLOCAL WINAPI LocalFree(HLOCAL);

// ----------------------------------------------------------------------------
//
//  FormatMessage()
//
//  16-bit version of FormatMessage32().
//
//  Note that this API is NOT _loadds.  We might need to LocalAlloc() a buffer
//  for the result.  Therefore, we can't just use random static string vars.
//  They _must_ be CODESEG.
//
// ----------------------------------------------------------------------------
UINT _far _pascal FormatMessage(DWORD dwFlags, LPVOID lpSource, UINT idMessage,
    UINT idLanguage, LPSTR lpResult, UINT cbResultMax, DWORD FAR * rglArgs)
{
    LPSTR       lpBuffer;
    HINSTANCE   hInstance;
    UINT        Column;
    UINT        MaximumWidth;
    DWORD       rgInserts[100];
    WORD        MaxInsert, CurInsert;
    UINT        cbNeeded, cbResult;
    char        szMessage[256];
    LPSTR       MessageFormat;
    UINT        cbMessage;
    UINT        PrintParameterCount;
    DWORD       PrintParameter1;
    DWORD       PrintParameter2;
    char        PrintFormatString[32];
    LPSTR       s, s1, s1base;
    LPSTR       lpAlloc;
    LPSTR       lpDst, lpDstBeg;

    //
    // Force idLanguage to be 0 for 16-bit apps, for now...
    //
    if (idLanguage)
    {
        DebugErr(DBF_ERROR, "FormatMessage: language id must be 0");
        return(0);
    }

    //
    // Prevent NULL lpResult
    //
    if (!TESTFAR(lpResult))
    {
        DebugErr(DBF_ERROR, "FormatMessage: NULL result buffer");
        return(0);
    }

    //
    // Prevent caller from using non-defined flags...
    //
    if (dwFlags & ~FORMAT_MESSAGE_VALID)
    {
        DebugErr(DBF_ERROR, "FormatMessage: invalid flags");
        return(0);
    }

    //
    // Get temporary buffer.
    //
    if (dwFlags & FORMAT_MESSAGE_ALLOCATE_BUFFER)
        cbResultMax = 0x7FFE;

    lpBuffer = MAKELP(GlobalAlloc(GHND, (DWORD)cbResultMax+1), 0);
    if (!SELECTOROF(lpBuffer))
    {
        DebugErr(DBF_ERROR, "FormatMessage:  Couldn't allocate enough memory");
        return(0);
    }

    lpAlloc = NULL;
    cbResult = 0;

    MaximumWidth = LOWORD(dwFlags & FORMAT_MESSAGE_MAX_WIDTH_MASK);

    //
    // Get message string
    //
    if (dwFlags & FORMAT_MESSAGE_FROM_STRING)
    {
        if (!TESTFAR(lpSource))
        {
            DebugErr(DBF_ERROR, "FormatMessage:  NULL format string");
            goto FailureExit;
        }

        MessageFormat = lpSource;
        cbMessage = lstrlen(MessageFormat);
    }
    else
    {
        if (dwFlags & FORMAT_MESSAGE_FROM_HMODULE)
        {
            hInstance = (HINSTANCE)OFFSETOF(lpSource);
            if (!hInstance)
            {
                DebugErr(DBF_ERROR, "FormatMessage:  NULL hInstance not allowed for 16 bits");
                goto FailureExit;
            }
        }
        else if (dwFlags & FORMAT_MESSAGE_FROM_SYSTEM)
#if 0
            // This doesn't work on WOW and it's not worth
            // fixing because our user.exe doesn't have any
            // FormatMessage text as string resources.
            hInstance = FMGetSystemInstance();
#else
        {
            DebugErr(DBF_ERROR, "FormatMessage:  FORMAT_MESSAGE_FROM_SYSTEM");
            goto FailureExit;
        }
#endif
        else
        {
            DebugErr(DBF_ERROR, "FormatMessage:  Invalid source");
            goto FailureExit;
        }

        //
        // Load the string
        //
        cbMessage = LoadString(hInstance, idMessage, szMessage,
            sizeof(szMessage)-1);

        if (!cbMessage)
        {
            DebugErr(DBF_ERROR, "FormatMessage:  Couldn't load source string");
            goto FailureExit;
        }

        MessageFormat = (LPSTR)szMessage;
    }

    lpDst = lpBuffer;
    MaxInsert = 0;
    Column = 0;
    s = MessageFormat;

    while (*s)
    {
        if (*s == '%')
        {
            s++;

            lpDstBeg = lpDst;
            if (*s >= '1' && *s <= '9')
            {
                CurInsert = *s++ - '0';
                if (*s >= '0' && *s <= '9')
                {
                    CurInsert = (CurInsert * 10) + (*s++ - '0');
                }
                CurInsert--;

                PrintParameterCount = 0;
                if (*s == '!')
                {
                    s1 = s1base = PrintFormatString;
                    *s1++ = '%';
                    s++;
                    while (*s != '!')
                    {
                        if (*s != '\0')
                        {
                            if (s1 >= (s1base + sizeof(PrintFormatString) - 1))
                            {
                                goto ParamError;
                            }

                            if (*s == '*')
                            {
                                if (PrintParameterCount++ > 1)
                                {
                                    goto ParamError;
                                }
                            }

                            *s1++ = *s++;
                        }
                        else
                        {
ParamError: 
                            DebugErr(DBF_ERROR, "FormatMessage:  Invalid format string");
                            goto FailureExit;
                        }
                    }

                    s++;
                    *s1 = '\0';
                }
                else
                {
                    lstrcpy(PrintFormatString, szStringFormat);
                    s1 = PrintFormatString + lstrlen(PrintFormatString);
                }

                if (!(dwFlags & FORMAT_MESSAGE_IGNORE_INSERTS) && TESTFAR(rglArgs))
                {
                    while (CurInsert >= MaxInsert)
                    {
                        rgInserts[MaxInsert++] = *(rglArgs++);
                    }

                    s1 = (LPSTR)rgInserts[CurInsert];
                    PrintParameter1 = 0;
                    PrintParameter2 = 0;
                    if (PrintParameterCount > 0)
                    {
                        PrintParameter1 = rgInserts[MaxInsert++] = *(rglArgs++);
                        if (PrintParameterCount > 1)
                        {
                            PrintParameter2 = rgInserts[MaxInsert++] = *(rglArgs++);
                        }
                    }

                    lpDst += wsprintf(lpDst, PrintFormatString, s1,
                        PrintParameter1, PrintParameter2);
                }
                else if (!lstrcmp(PrintFormatString, szStringFormat))
                {
                    lpDst += wsprintf(lpDst, szStringFormat2, CurInsert+1);
                }
                else
                {
                    lpDst += wsprintf(lpDst, szStringFormat3, CurInsert+1,
                        (LPSTR)&PrintFormatString[1]);
                }
            }
            else if (*s == '0')
                break;
            else if (!*s)
                goto FailureExit;
            else if (*s == '!')
            {
                *lpDst++ = '!';
                s++;
            }
            else if (*s == 't')
            {
                *lpDst++ = '\t';
                s++;
                if (Column % 8)
                {
                    Column = (Column + 7) & ~7;
                }
                else
                {
                    Column += 8;
                }
            }
            else if (*s == 'b')
            {
                *lpDst++ = ' ';
                s++;
            }
            else if (*s == 'r')
            {
                *lpDst++ = '\r';
                s++;
                lpDstBeg = NULL;
            }
            else if (*s == '\n')
            {
                *lpDst++ = '\r';
                *lpDst++ = '\n';
                s++;
                lpDstBeg = NULL;
            }
            else
            {
                if (dwFlags & FORMAT_MESSAGE_IGNORE_INSERTS)
                {
                    *lpDst++ = '%';
                }

                *lpDst++ = *s++;
            }

            if (!TESTFAR(lpDstBeg))
            {
                Column = 0;
            }
            else
            {
                Column += lpDst - lpDstBeg;
            }
        }
        else
        {
            char c;

            c = *s++;
            if (c == '\r')
            {
                if (*s == '\n')
                {
                    s++;
                }

                if (MaximumWidth)
                {
                    c = ' ';
                }
                else
                {
                    c = '\n';
                }
            }

            if (c == '\n' || (c == ' ' && MaximumWidth &&
                MaximumWidth != FORMAT_MESSAGE_MAX_WIDTH_MASK &&
                Column >= MaximumWidth))
            {

                *lpDst++ = '\r';
                *lpDst++ = '\n';
                Column = 0;
            }
            else
            {
                *lpDst++ = c;
                Column++;
            }
        }
    }

    *lpDst++ = 0;
    cbNeeded = lpDst - lpBuffer;

    if (dwFlags & FORMAT_MESSAGE_ALLOCATE_BUFFER)
    {
        PSTR pstr;

        *(PSTR FAR *)lpResult = NULL;

        pstr = (PSTR)LocalAlloc(LPTR, cbNeeded);

        if (!pstr)
        {
            DebugErr(DBF_ERROR, "FormatMessge:  couldn't LocalAlloc memory for result");
            goto FailureExit;
        }

        lpDst = lpAlloc = (LPSTR)pstr;
    }
    else if (cbNeeded > cbResultMax)
    {
        DebugErr(DBF_ERROR, "FormatMessage:  passed in buffer is too small for result");
        goto FailureExit;
    }
    else
    {
        lpDst = lpResult;
    }

    lstrcpyn(lpDst, lpBuffer, cbNeeded);

    cbResult = --cbNeeded;

FailureExit:
    if (TESTFAR(lpAlloc))
    {
        if (cbResult)
        {
            *(PSTR FAR *)lpResult = (PSTR)OFFSETOF(lpAlloc);
        }
        else
        {
            LocalFree((HANDLE)OFFSETOF(lpAlloc));
        }
    }

    if (TESTFAR(lpBuffer))
        GlobalFree((HANDLE)SELECTOROF(lpBuffer));

    return(cbResult);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\user\debug.c ===
/*++
 *
 *  WOW v3.5
 *
 *  Copyright (c) 1980-1994, Microsoft Corporation
 *
 *  DEBUG.C
 *  USER16 debug support
 *
 *  History:
 *
 *  Created 18-Aug-94 by Dave Hart (davehart)
 *  Copied from WIN31 and edited (as little as possible) for WOW16.
 *  At this time, all we want is GetSystemDebugState.
--*/

/* Debug api support */
#include "user.h"
#ifndef WOW
#include "menu.h"

typedef struct tagMSGR
  {
    LPARAM	lParam;
    WPARAM	wParam;
    WORD	message;
    HWND	hwnd;
  } MSGR;
typedef MSGR FAR *LPMSGR;


/* A debug hook gets called by Windows just before calling any other type of
 * hook. Let us call the hook which is about to be called as "App hook"; Debug
 * hook is provided with all the details of the App hook so that it can decide
 * whether to prevent Windows from calling the App hook or not; If the debug
 * hook wants Windows to skip the call to the App hook, it must return TRUE;
 * Otherwise, it must call the DefHookProc.  
 */

/*  Debug Hooks recieve three params just like anyother type of hook:

   iCode  =  Hook Code (must be HC_ACTION in the current implementaion).
   wParam =  hook type of the App hook, which is about to be called by 
             Windows.
   lParam =  a FAR pointer to DEBUGHOOKSTRUCT structure which contains all
	       the details about the App hook;
 */


/* Our helper call which returns a pointer to the senders message queue. 
 */
LPMSGR FAR PASCAL QuerySendMessageReversed(void);



BOOL API QuerySendMessage(HANDLE h1, HANDLE h2, HANDLE h3, LPMSG lpmsg)
{
  LPMSGR lpmsgr;

  if (h1 || h2 || h3)
      return(FALSE);

  if (!InSendMessage())
      return(FALSE);

  /* Get the inter task sendmessage we are servicing out of the apps queue. 
   */
  lpmsgr = QuerySendMessageReversed();

  lpmsg->hwnd    = lpmsgr->hwnd;
  lpmsg->message = lpmsgr->message;
  lpmsg->wParam  = lpmsgr->wParam;
  lpmsg->lParam  = lpmsgr->lParam;

  return(TRUE);
}

typedef struct
{
  BOOL       fOldHardwareInputState;
  BOOL       fMessageBox;
  BOOL       fDialog;

  BOOL       fMenu;
  BOOL       fInsideMenuLoop;
  PPOPUPMENU pGlobalPopupMenu;

  RECT       rcClipCursor;

  HWND       hwndFocus;
  HWND       hwndActive;
  HWND       hwndSysModal;
  HWND       hwndCapture;
} SAVESTATESTRUCT;
typedef SAVESTATESTRUCT NEAR *PSAVESTATESTRUCT;
typedef SAVESTATESTRUCT FAR  *LPSAVESTATESTRUCT;

static PSAVESTATESTRUCT pLockInputSaveState=NULL;

BOOL API LockInput(HANDLE h1, HWND hwndInput, BOOL fLock)
{
  if (h1)
      return(FALSE);

  if (fLock)
    {
      if (pLockInputSaveState)
        {
          /* Save state struct currently in use. 
	   */
          DebugErr(DBF_ERROR, "LockInput() called when already locked");
          return(NULL);
        }

      if (!hwndInput || hwndInput != GetTopLevelWindow(hwndInput))
          return(FALSE);

      pLockInputSaveState=(PSAVESTATESTRUCT)UserLocalAlloc(ST_LOCKINPUTSTATE,
                                            LPTR, 
                                            sizeof(SAVESTATESTRUCT));

      if (!pLockInputSaveState)
          /* No memory, can't lock. 
	   */
          return(FALSE);

      if (hwndInput)
          ChangeToCurrentTask(hwndInput, hwndDesktop);

      LockMyTask(TRUE);

      /* Set global which tells us a task is locked. Needs to be set after
       * calling LockMyTask...
       */
      hTaskLockInput = GetCurrentTask();

      /* For DBCS, save are we in a dlg box global. */
      pLockInputSaveState->fDialog     = fDialog;

      /* Save menu state and clear it so that the debugger can bring up menus
       * if needed.  
       */
      pLockInputSaveState->fMenu           = fMenu;
      pLockInputSaveState->fInsideMenuLoop = fInsideMenuLoop;
      fMenu = FALSE;
      fInsideMenuLoop = FALSE;

      pLockInputSaveState->pGlobalPopupMenu = pGlobalPopupMenu;
      pGlobalPopupMenu = NULL;

      /* Change focus etc without sending messages... 
       */
      pLockInputSaveState->hwndFocus   = hwndFocus;
      pLockInputSaveState->hwndActive  = hwndActive;
      hwndFocus  = hwndInput;
      hwndActive = hwndInput;
      
      /* Save capture and set it to null */
      pLockInputSaveState->hwndCapture = hwndCapture;
      SetCapture(NULL);

      /* Save sysmodal window */
      pLockInputSaveState->hwndSysModal= hwndSysModal;
      pLockInputSaveState->fMessageBox = fMessageBox;
      SetSysModalWindow(hwndInput);

      /* Save clipcursor rect */
      CopyRect(&pLockInputSaveState->rcClipCursor, &rcCursorClip);
      ClipCursor(NULL);

      /* Enable hardware input so that we can get mouse/keyboard messages. 
       */
      pLockInputSaveState->fOldHardwareInputState=EnableHardwareInput(TRUE);

    }
  else
    {
      if (!pLockInputSaveState)
        {
          /* Save state struct not in use, nothing to restore. 
	   */
          DebugErr(DBF_ERROR, "LockInput called with input already unlocked");
          return(NULL);
        }


      /* For DBCS, save are we in a dlg box global. */
      fDialog = pLockInputSaveState->fDialog;

      /* Restore clipcursor rect */
      ClipCursor(&pLockInputSaveState->rcClipCursor);

      /* Set active and focus windows manually so we avoid sending messages to
       * the applications. 
       */
      hwndFocus = pLockInputSaveState->hwndFocus;
      hwndActive= pLockInputSaveState->hwndActive;

      SetSysModalWindow(pLockInputSaveState->hwndSysModal);
      fMessageBox = pLockInputSaveState->fMessageBox;

      pGlobalPopupMenu = pLockInputSaveState->pGlobalPopupMenu;
      fMenu            = pLockInputSaveState->fMenu;
      fInsideMenuLoop  = pLockInputSaveState->fInsideMenuLoop;

      SetCapture(pLockInputSaveState->hwndCapture);
      EnableHardwareInput(pLockInputSaveState->fOldHardwareInputState);

      /* Unset global which tells us a task is locked. Has to be unset before
       * we call LockMyTask...  
       */
      hTaskLockInput = NULL;
      LockMyTask(FALSE);

      LocalFree((HANDLE)pLockInputSaveState);
      pLockInputSaveState = NULL;
    }

  return(TRUE);
}
#endif // !WOW

LONG API GetSystemDebugState(void)
{
  LONG   returnval = 0;
  HANDLE hTask;

  hTask = GetCurrentTask();
  if (!GetTaskQueue(hTask))
      returnval = returnval | SDS_NOTASKQUEUE;

#ifndef WOW
  if (fMenu)
      returnval = returnval | SDS_MENU;

  if (fDialog)
      returnval = returnval | SDS_DIALOG;

  if (fTaskIsLocked)
      returnval = returnval | SDS_TASKLOCKED;

  if (hwndSysModal)
      returnval = returnval | SDS_SYSMODAL;
#endif // !WOW

  return(returnval);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\toolhelp\walk386.asm ===
;**************************************************************************
;*  walk386.ASM
;*
;*      Assembly support code for the KERNEL386 global heap routines
;*      for TOOLHELP.DLL
;*
;**************************************************************************

        INCLUDE TOOLPRIV.INC

PMODE32 = 1
PMODE   = 0
SWAPPRO = 0
        INCLUDE WINKERN.INC

;** External functions
externNP HelperVerifySeg
externNP HelperHandleToSel
externNP HelperPDBtoTDB
externNP HelperSegLen

;** Functions

sBegin  CODE
        assumes CS,CODE
.386p

;  Walk386Count
;
;       Returns the number of blocks in the given list

cProc   Walk386Count, <PUBLIC,NEAR>, <di>
        parmW   wFlags
cBegin
        mov     es,hMaster              ;Segment of master block
        mov     ax,wFlags               ;Get the flag value
        shr     ax,1                    ;Check for GLOBAL_LRU
        jc      SHORT W3C_LRU           ;Bit set, must be LRU
        shr     ax,1                    ;Check for GLOBAL_FREE
        jc      SHORT W3C_Free          ;Must be free
                                        ;Must be GLOBAL_ALL

        ;** Get total object count
        mov     ax,es:[hi_count]        ;Get heap count
        inc     ax                      ;Bump to include first sentinel
        jmp     SHORT W3C_End           ;Get out

        ;** Get LRU object count
W3C_LRU:
        mov     ax,es:[gi_lrucount]     ;Get the LRU count
        jmp     SHORT W3C_End           ;Get out

        ;** Get Free list object count
W3C_Free:
        mov     ax,es:[gi_free_count]   ;Get free count
        jmp     SHORT W3C_End           ;Get out

        ;** Return the result in AX
W3C_End:
        
cEnd

;  Walk386First
;
;       Returns a handle to the first block in the 386 global heap.

cProc   Walk386First, <PUBLIC,NEAR>, <di>
        parmW   wFlags
cBegin
        mov     es,hMaster              ;Segment of master block
        mov     ax,wFlags               ;Get the flag value
        shr     ax,1                    ;Check for GLOBAL_LRU
        jc      SHORT W3F_LRU           ;Bit set, must be LRU
        shr     ax,1                    ;Check for GLOBAL_FREE
        jc      SHORT W3F_Free          ;Must be free
                                        ;Must be GLOBAL_ALL

        ;** Get first object in complete heap (wFlags == GLOBAL_ALL)
        mov     edi,es:[phi_first]      ;Get offset of first arena header
        jmp     SHORT W3F_End           ;Get out

        ;** Get first object in LRU list
W3F_LRU:
        xor     edi,edi                 ;Zero upper word
        mov     di,es:[gi_lrucount]     ;Get the number of objects
        or      di,di                   ;Are there any objects?
        jz      SHORT W3F_End           ;No, return NULL
        mov     edi,es:[gi_lruchain]    ;Get a pointer to the first item
        jmp     SHORT W3F_End           ;Done

        ;** Get first object in Free list
W3F_Free:
        xor     edi,edi                 ;Zero upper word
        mov     di,es:[gi_free_count]   ;Get the number of objects
        or      di,di                   ;Are there any objects?
        jz      SHORT W3F_End           ;No, return NULL
        mov     edi,es:[phi_first]      ;Get the first object
        mov     edi,es:[edi].pga_freenext ;Skip to the first free block
                                        ;Fall through to the return

        ;** Save the result in DX:AX for the return
W3F_End:
        mov     ax,di                   ;Get the low word
        shr     edi,16                  ;Get the high word out
        mov     dx,di                   ;Get the high word
cEnd


;  Walk386
;
;       Takes a pointer to a block and returns a GLOBALENTRY structure
;       full of information about the block.  If the block  pointer is
;       NULL, looks at the first block.  The last field in the GLOBALENTRY
;       structure is used to chain to the next block and is thus used to walk
;       the heap.

cProc   Walk386, <PUBLIC,NEAR>, <di,si,ds>
        parmD   dwBlock
        parmD   lpGlobal
        parmW   wFlags
cBegin
        ;** Set up to build public structure
        mov     es,hMaster              ;Get the correct segment
        mov     edi,dwBlock             ;Point to this block
        lds     si,lpGlobal             ;Point to the GLOBALENTRY structure

        ;** Fill public structure
        mov     ax,es:[edi].pga_handle  ;Get the handle of the block
        mov     [si].ge_hBlock,ax       ;Put in public structure
        mov     eax,es:[edi].pga_address ;Get linear address of block
        mov     [si].ge_dwAddress,eax   ;Put in public structure
        mov     eax,es:[edi].pga_size   ;Get the size of the block
        mov     [si].ge_dwBlockSize,eax ;Put in public structure
        mov     ax,es:[edi].pga_owner   ;Owning task of block
        mov     [si].ge_hOwner,ax       ;Put in public structure
        xor     ah,ah
        mov     al,es:[edi].pga_count   ;Lock count (moveable segments)
        mov     [si].ge_wcLock,ax       ;Put in public structure
        mov     al,es:[edi].pga_pglock  ;Page lock count
        mov     [si].ge_wcPageLock,ax   ;Save in structure
        mov     al,es:[edi].pga_flags   ;Word of flags
        xor     ah,ah
        mov     [si].ge_wFlags,ax       ;Put in public structure
        mov     eax,es:[edi].pga_next   ;Put next pointer in structure
        mov     [si].ge_dwNext,eax

        ;** If this is a data segment, get local heap information
        mov     ax,[si].ge_hBlock       ;Get the handle
        cCall   Walk386VerifyLocHeap
        mov     [si].ge_wHeapPresent,TRUE ;Flag that there's a heap
        jnc     SHORT W3_10             ;There really is no heap
        mov     [si].ge_wHeapPresent,FALSE ;Flag that there's no heap
W3_10:

        ;** If the owner is a PDB, translate this to the TDB
        mov     bx,[si].ge_hOwner       ;Get the owner
        cCall   HelperHandleToSel, <bx> ;Translate to selector
        mov     bx,ax                   ;Get the selector in BX
        cCall   HelperVerifySeg, <ax,2> ;Must be two bytes long
        or      ax,ax                   ;Is it?
        jz      SHORT W3_15             ;No.
        push    es                      ;Save ES for later
        mov     es,bx                   ;Point to possible PDB block
        cmp     es:[0],20CDh            ;Int 20h is first word of PDB
        jnz     SHORT W3_12             ;Nope, don't mess with this
        mov     ax,bx                   ;Pass parameter in AX
        cCall   HelperPDBtoTDB          ;Get the corresponding TDB
        or      ax,ax                   ;Was one found?
        jz      SHORT W3_11             ;No.
        mov     [si].ge_hOwner,ax       ;Make the owner the TDB instead
W3_11:  or      [si].ge_wFlags,GF_PDB_OWNER ;Flag that a PDB owned block
W3_12:  pop     es                      ;Restore ES
W3_15:

        ;** Check for this being the last item in both lists
        cmp     edi,es:[edi].pga_next   ;See if we're at the end
        jnz     SHORT W3_20             ;No
        mov     [si].ge_dwNext,0        ;NULL the next pointer
W3_20:  mov     eax,edi                 ;Get current pointer
        mov     cx,wFlags               ;Get the flags back
        cCall   NextLRU386              ;Get next LRU list pointer or 0
        mov     [si].ge_dwNextAlt,eax   ;Save it

W3_End:
cEnd


;  Walk386Handle
;
;       Finds an arena pointer given a block handle

cProc   Walk386Handle, <PUBLIC,NEAR>, <di,si,ds>
        parmW   hBlock
cBegin
        mov     ax,hBlock               ;Get the block handle
        cCall   HelperHandleToSel, <ax> ;Convert to selector
        cCall   SelToArena386           ;Get the arena pointer
        jnc     SHORT W3H_10            ;Must be OK
        xor     ax,ax                   ;Return a 0L
        xor     dx,dx
        jmp     SHORT W3H_End           ;Error in conversion, get out
W3H_10: mov     ax,bx                   ;Get the low word
        shr     ebx,16                  ;Get the high word in DX
        mov     dx,bx
W3H_End:
cEnd


;  WalkLoc386Count
;
;       Returns the number of blocks in the given local heap

cProc   WalkLoc386Count, <PUBLIC,NEAR>, <di>
        parmW   hHeap
cBegin
        ;** Verify that it has a local heap
        mov     ax, hHeap               ;Get the block
        cCall   Walk386VerifyLocHeap    ;Verify it
        jnc     SHORT LC_10             ;It's OK
        xor     ax,ax                   ;No heap
        jmp     SHORT LC_End            ;Get out
LC_10:

        ;** Point to the block
        mov     ax,hHeap                ;Get the heap block
        cCall   HelperHandleToSel, <ax> ;Convert it to a selector
        mov     es,ax                   ;Use ES to point to it
        mov     bx,es:[6]               ;Get a pointer to the HeapInfo struct

        ;** Get the number of blocks
        mov     ax,es:[bx].hi_count     ;Get the count
LC_End:
cEnd


;  WalkLoc386First
;
;       Returns a handle to the first block in the 386 global heap.

cProc   WalkLoc386First, <PUBLIC,NEAR>, <di>
        parmW   hHeap
cBegin
        ;** Verify that the given global block has a local heap
        mov     ax, hHeap               ;Get the block
        cCall   Walk386VerifyLocHeap    ;Verify it
        jnc     SHORT LF_10             ;It's OK
        xor     ax,ax                   ;No heap
        jmp     SHORT LF_End            ;Get out
LF_10:

        ;** Point to the global block
        mov     ax,hHeap                ;Get the heap block
        cCall   HelperHandleToSel, <ax> ;Convert it to a selector
        mov     es,ax                   ;Use ES to point to it
        mov     bx,es:[6]               ;Get a pointer to the HeapInfo struct

        ;** Get the first block and return it
        mov     ax,WORD PTR es:[bx].hi_first ;Get the first block
LF_End:
cEnd


;  WalkLoc386
;
;       Takes a pointer to a block and returns a GLOBALENTRY structure
;       full of information about the block.  If the block  pointer is
;       NULL, looks at the first block.  The last field in the GLOBALENTRY
;       structure is used to chain to the next block and is thus used to walk
;       the heap.

cProc   WalkLoc386, <PUBLIC,NEAR>, <di,si,ds>
        parmW   wBlock
        parmD   lpLocal
        parmW   hHeap
cBegin
        ;** Verify that it has a local heap
        mov     ax, hHeap               ;Get the block
        cCall   Walk386VerifyLocHeap    ;Verify it
        jnc     SHORT LW_10             ;It's OK
        jmp     LW_End                  ;Get out
LW_10:

        ;** Get variables from the TOOLHELP DGROUP
        mov     ax,_DATA                ;Get the variables first
        mov     ds,ax                   ;Point to our DS
        mov     bx,hUserHeap            ;BX=User's heap block
        mov     cx,hGDIHeap             ;CX=GDI's heap block

        ;** Point to the heap
        mov     ax,hHeap                ;Get the heap block
        cCall   HelperHandleToSel, <ax> ;Convert it to a selector
        mov     es,ax                   ;Use ES to point to it
        lds     di,lpLocal              ;Point to the LOCALENTRY structure
        mov     [di].le_wHeapType,NORMAL_HEAP ;In case we don't match below...
        cmp     bx,hHeap                ;User's heap?
        jnz     SHORT W3_3              ;No
        mov     [di].le_wHeapType,USER_HEAP ;Yes
        jmp     SHORT W3_5              ;Skip on
W3_3:   cmp     cx,hHeap                ;GDI's heap?
        jnz     SHORT W3_5              ;No
        mov     [di].le_wHeapType,GDI_HEAP ;Yes
W3_5:
        mov     si,wBlock               ;Get the address of the block

        ;** Get information about the given block
        mov     bx,es:[si].la_handle    ;Get the handle
        mov     [di].le_hHandle,bx      ;Save in the public structure
        mov     ax,si                   ;Get block address
        add     ax,la_fixedsize         ;Skip fixed size local arena
        mov     [di].le_wAddress,ax     ;Save the block address
        mov     ax,es:[si].la_next      ;Get the address of the next block
        mov     [di].le_wNext,ax        ;Save the next pointer
        sub     ax,si                   ;Compute the size
        sub     ax,la_fixedsize         ;Size of fixed arena
        mov     [di].le_wSize,ax        ;Save in public structure
        mov     ax,es:[si].la_prev      ;Get the flags
        and     ax,3                    ;Mask out all but flags
        mov     [di].le_wFlags,ax       ;Save in structure

        ;** Moveable arenas are bigger and have a lock count to get
        test    al,LA_MOVEABLE          ;Block has a handle iff it's moveable
        jz      SHORT LW_NoHandle       ;No handle info
        sub     [di].le_wSize, (SIZE LocalArena) - la_fixedsize
        add     [di].le_wAddress, (SIZE LocalArena) - la_fixedsize
        xor     ah,ah                   ;Clear upper word
        mov     al,es:[bx].lhe_count    ;Get lock count
        mov     [di].le_wcLock,ax       ;Save it
        jmp     SHORT LW_20             ;Skip no handle info
LW_NoHandle:
        mov     ax, [di].le_wAddress    ;Handle of fixed block is real offset
        mov     [di].le_hHandle, ax
        mov     [di].le_wcLock,0        ;No lock count either
LW_20:
        ;** See if it's the end
        cmp     [di].le_wNext,0         ;Check for NULL pointer just in case
        jz      SHORT LW_End            ;It is so get out
        cmp     [di].le_wNext,si        ;Loop pointer?
        jnz     SHORT LW_End            ;Nope
        mov     [di].le_wNext,0         ;Set a zero pointer
LW_End:
cEnd


;  Walk386VerifyLocHeap
;
;       Verifies that the given global block points to a data segment
;       with a local heap.
;
;       Call:
;               AX = Block handle or selector
;       Return:
;               Carry flag set iff NOT a local heap segment
;
;       Destroys all registers except AX, ESI, EDI, DS, and ES

cProc   Walk386VerifyLocHeap, <PUBLIC,NEAR>, <es>
cBegin
        push    esi                     ;Save certain registers
        push    edi

        ;** Convert to a selector
        cCall   HelperHandleToSel, <ax>

        ;** Verify that the selector is long enough
        push    ax                      ;Save parameter
        mov     bx,SIZE LocalInfo
        cCall   HelperVerifySeg, <ax,bx> ;Check the selector
        or      ax,ax                   ;Is it valid?
        pop     ax                      ;Restore parameter
        jnz     SHORT VLH_SelOK         ;Yes
        stc                             ;Set error flag 
        jmp     SHORT VLH_End           ;Get out
VLH_SelOK:

        ;** Check data segment to see if it has a local heap
        mov     es,ax                   ;Point to the local block with ES
        cCall   HelperSegLen, <ax>      ;Get the length of the heap
        movzx   ecx,dx                  ;ECX gets the length
        shl     ecx,16                  ;Put high word in high word of EAX
        mov     cx,ax                   ;Get the low word
        cmp     ecx,8                   ;At least 8 bytes long?
        ja      SHORT VLH_10            ;Yes
        stc                             ;No -- set error flag and get out
        jmp     SHORT VLH_End
VLH_10: xor     ebx,ebx                 ;Clear high word
        mov     bx,es:[6]               ;Get offset to HeapInfo struct
        or      bx,bx                   ;If NULL, no local heap
        jz      SHORT VLH_NoHeap        ;Get out
        sub     ecx,ebx                 ;See if HeapInfo is beyond segment
        jbe     SHORT VLH_NoHeap
  sub     ecx,li_sig + 2          ;Compare against last structure mem
        jbe     SHORT VLH_NoHeap
  cmp     es:[bx].li_sig,LOCALHEAP_SIG ;Make sure the signature matches
        jne     SHORT VLH_NoHeap        ;Doesn't match
        clc                             ;Must be a heap!
        jmp     SHORT VLH_End

VLH_NoHeap:
        stc                             ;Set error flag

VLH_End:
        pop     edi
        pop     esi
cEnd


;** Private helper functions

;  SelToArena386
;
;       Finds the arena entry for the given selector or handle.
;       Uses the selector table which is located just after the arena table.
;       Since this is a large segment, use 32 bit offsets into it.
;       The selector-to-arena mapping table is simply an array of arena
;       offsets indexed by the (selector number >> 3) * 4 [DWORD offsets].
;
;       Caller:         AX = Selector
;       Returns:        DX:EBX = Arena entry
;       Trashes everything except segment registers and AX
;       Carry set on error

cProc   SelToArena386, <NEAR,PUBLIC>, <es,ds,ax>
cBegin
        ;** Convert to a selector
        cCall   HelperHandleToSel, <ax>

        ;** Verify selector
        push    ax                      ;Save parameter
        cCall   HelperVerifySeg, <ax,1> ;Check the selector
        or      ax,ax                   ;Is it valid?
        pop     ax                      ;Restore parameter
        jnz     SHORT STA_SelOK         ;Must be
        stc                             ;Nope.  Set error flag and exit
        jmp     SHORT STA_End
STA_SelOK:
        mov     bx,_DATA                ;Get the static data segment
        mov     ds,bx
        mov     bx,segKernel            ;Get the KERNEL variable segment
        mov     es,bx
        mov     bx,npwSelTableLen       ;Get the pointer
        mov     dx,es:[bx]              ;Get the selector table length
        mov     bx,npdwSelTableStart    ;Get the start of the sel table
        mov     ebx,es:[bx]             ;Get the linear offset (32 bits)
        mov     es,hMaster              ;Point to the arena table
        and     al,not 7                ;Clear the RPL bits for table lookup
        shr     ax,1                    ;Convert to DWORD offset
        cmp     ax,dx                   ;Check to see if off the end of table
        jb      SHORT STA_InTable       ;It's in the table
        stc                             ;Set error flag--not in table
        jmp     SHORT STA_End           ;Get out
STA_InTable:
        movzx   eax,ax                  ;Convert the offset to 32 bits
        add     ebx,eax                 ;Add the selector offset
        mov     ebx,es:[ebx]            ;Do the sel table indirection
        mov     dx,hMaster              ;DX points to the arena segment
        clc                             ;No error; return OK
STA_End:
cEnd


;  NextLRU386
;
;       Checks the given arena table pointer to see if it is the last
;       arena entry on the list.
;       Uses a grungy method that is necessitated because of the
;       unterminated linked lists we're dealing with here.  The count
;       stored is the only reliable method for finding the end.  So, to
;       provide random access to blocks in the heap, the heap is searched
;       from top to bottom to find the block and see if it is the last
;       one.  If it is or if it is not on the given list, returns a 0
;       pointer to the next item.
;
;       If this search is for the entire global heap, we do not get the
;       LRU link, but return NULL in EAX.  This speeds this up alot!
;
;       Caller:         EAX = Arena table pointer
;                       CX = GLOBAL_ALL, GLOBAL_FREE, or GLOBAL_LRU
;       Return:         EAX = Next arena table pointer or 0 if no more
;       Trashes all registers except segment registers and ESI,EDI

cProc   NextLRU386, <NEAR,PUBLIC>, <es,ds>
cBegin
        push    esi
        push    edi

        mov     bx,_DATA                ;Get the static data segment
        mov     ds,bx                   ;Point with DS
        mov     es,hMaster              ;Segment of master block
        cmp     cx,GLOBAL_ALL           ;If doing entire heap, don't do this!
        je      SHORT NL_BadList        ;Must not be entire heap
        shr     cx,1                    ;Check for GLOBAL_LRU
        jc      SHORT NL_LRU            ;Bit set, must be LRU
        shr     cx,1                    ;Check for GLOBAL_FREE
        jc      SHORT NL_Free           ;Must be free
                                        ;Must be GLOBAL_ALL

        ;** Decide which list the block is in then hand off
        cmp     es:[eax].pga_owner,0    ;If the owner is zero, it's free
        jz      SHORT NL_Free           ;Handle this as if on free list
                                        ;Otherwise, might be on LRU list

        ;** Loop through LRU list until we find this item
NL_LRU:
        mov     cx,es:[gi_lrucount]     ;Get the number of objects
        jcxz    NL_Bad                  ;No object so return end
        dec     cx                      ;We don't want to find the last one
        jcxz    NL_Bad                  ;1 object so return end
        mov     edi,es:[gi_lruchain]    ;Get a pointer to the first item
NL_LRULoop:
        cmp     edi,eax                 ;Match yet?
        jz      SHORT NL_ReturnNext     ;Found it, return next item
        mov     edi,es:[edi].pga_lrunext ;Not found yet, get the next one
        loop    NL_LRULoop              ;Loop through all items
NL_Bad: jmp     SHORT NL_BadList        ;Not here either.  Get out

        ;** Loop through free list until we find this item
NL_Free:
        mov     cx,es:[gi_free_count]   ;Get the number of objects
        jcxz    NL_BadList              ;1 object so return end
        mov     edi,es:[phi_first]      ;Get a pointer to the first item
NL_FreeLoop:
        mov     edi,es:[edi].pga_lrunext ;Not found yet, get the next one
        cmp     edi,eax                 ;Match yet?
        jz      SHORT NL_ReturnNext     ;Found it, return next item
        loop    NL_FreeLoop             ;Loop through all items
        jmp     SHORT NL_BadList        ;Not here either.  Get out

NL_ReturnNext:
        mov     eax,es:[edi].pga_lrunext ;Return the next one
        jmp     SHORT NL_End            ;Get out

NL_BadList:
        xor     eax,eax                 ;Return zero for error

NL_End:
        pop     edi
        pop     esi
cEnd

sEnd
        END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\user\drvrrare.c ===
/* Installable drivers for windows.  Less common code.
 */
#include "user.h"

/*--------------------------------------------------------------------------*\
**
**  NewSignalProc() -
**
\*--------------------------------------------------------------------------*/
#define SG_EXIT     0x0020
#define SG_LOAD_DLL 0x0040
#define SG_EXIT_DLL 0x0080
#define SG_GP_FAULT 0x0666

BOOL
CALLBACK NewSignalProc(
    HTASK hTask,
    WORD message,
    WPARAM wParam,
    LPARAM lParam
    )
{
    BOOL fRet;

    // Notify installable drivers this app is going away.
    if ( message == SG_EXIT || message == SG_GP_FAULT ) {
        InternalBroadcastDriverMessage( NULL, DRV_EXITAPPLICATION,
                                       (message == SG_GP_FAULT
                                                    ? DRVEA_ABNORMALEXIT
                                                    : DRVEA_NORMALEXIT),
                                       0L, IBDM_FIRSTINSTANCEONLY );
    }

    //
    // Pass notification on to WOW32 (which passes on to USER32)
    //

    fRet = SignalProc( hTask, message, wParam, lParam );

    //
    // After letting WOW32 and User32 cleanup, destroy the shadow
    // message queue created by InitApp.
    //

    if ( message == SG_EXIT || message == SG_GP_FAULT ) {
        DeleteQueue();
    }

    return fRet;
}

HINSTANCE LoadAliasedLibrary(LPCSTR szLibFileName,
                             LPCSTR szSection,
                             LPCSTR szIniFile,
                             LPSTR  lpstrTail,
                             WORD   cbTail)
{
  char          sz[128];
  LPSTR         pch;
  HINSTANCE     h;
  WORD          errMode;

  if (!szLibFileName || !*szLibFileName)
      return((HINSTANCE)2); /* File not found */

  /* read the filename and additional info. into sz
   */
  GetPrivateProfileString(szSection,          // ini section
                          szLibFileName,      // key name
                          szLibFileName,      // default if no match
                          sz,                 // return buffer
                          sizeof(sz),         // return buffer size
                          szIniFile);         // ini. file

  sz[sizeof(sz)-1] = 0;

  /* strip off the additional info. Remember, DS!=SS so we need to get a lpstr
   * to our stack allocated sz.
   */
  pch = (LPSTR)sz;
  while (*pch)
    {
      if (*pch == ' ')
        {
          *pch++ = '\0';
          break;
        }
      pch++;
    }

  // pch pts to ch after first space or null ch

  /* copy additional info. to lpstrTail
   */

  if (lpstrTail && cbTail)
    {
      while (cbTail-- && (*lpstrTail++ = *pch++))
          ;
      *(lpstrTail-1) = 0;
    }

  errMode = SetErrorMode(0x8001);

  h = LoadLibrary(sz);

  SetErrorMode(errMode);

  return (h);
}



int GetDrvrUsage(HMODULE hModule)
/* effects: Runs through the driver list and figures out how many instances of
 * this driver module handle we have.  We use this instead of GetModuleUsage
 * so that we can have drivers loaded as normal DLLs and as installable
 * drivers.
 */
{
  LPDRIVERTABLE lpdt;
  int           index;
  int           count;

  if (!hInstalledDriverList || !cInstalledDrivers || !hModule)
      return(0);

  count = 0;

  lpdt = (LPDRIVERTABLE)MAKELP(hInstalledDriverList,0);

  for (index=0;index<cInstalledDrivers;index++)
    {
       if (lpdt->hModule==hModule)
           count++;

       lpdt++;
    }


  return(count);
}


BOOL PASCAL CheckValidDriverProc(LPDRIVERTABLE lpdt, HDRVR hdrv)
/* effects: Some vendors shipped multimedia style installable drivers with
 * bogus entry procs. This test checks for these bogus drivers and refuses to
 * install them.
 */
{
  WORD  currentSP;
  WORD  saveSP;

  _asm mov saveSP, sp
  (void)(lpdt->lpDriverEntryPoint)(0, hdrv, 0, 0L, 0L);
  _asm mov currentSP, sp
  _asm mov sp, saveSP

  if (saveSP != currentSP)
      DebugErr(DBF_ERROR, "Invalid driver entry proc address");

  return (saveSP == currentSP);
}

LRESULT FAR InternalLoadDriver(LPCSTR szDriverName,
                               LPCSTR szSectionName,
                               LPCSTR lpstrTail,
                               WORD   cbTail,
                               BOOL   fSendEnable)
{
  int           index;
  int           i;
  LPDRIVERTABLE lpdt;
  LPDRIVERTABLE lpdtBegin;
  LRESULT       result;
  HGLOBAL       h;
  HINSTANCE     hInstance;
  char          szDrivers[20];
  char          szSystemIni[20];

  /* Drivers receive the following messages: if the driver was loaded,
   * DRV_LOAD.  If DRV_LOAD returns non-zero and fSendEnable, DRV_ENABLE.
   */

  if (!hInstalledDriverList)
      h = GlobalAlloc(GHND|GMEM_SHARE, (DWORD)((WORD)sizeof(DRIVERTABLE)));
  else
      /* Alloc space for the next driver we will install. We may not really
       * install the driver in the last slot but rather in an intermediate
       * slot which was freed.
       */
      h = GlobalReAlloc(hInstalledDriverList,
                     (DWORD)((WORD)sizeof(DRIVERTABLE)*(cInstalledDrivers+1)),
                     GHND|GMEM_SHARE);

  if (!h)
      return(0L);

  cInstalledDrivers++;
  hInstalledDriverList = h;

  if (!szSectionName)
      LoadString(hInstanceWin, STR_DRIVERS, szDrivers, sizeof(szDrivers));
  LoadString(hInstanceWin, STR_SYSTEMINI, szSystemIni, sizeof(szSystemIni));

  lpdtBegin = lpdt = (LPDRIVERTABLE)MAKELP(hInstalledDriverList, NULL);

  /* Find an empty driver entry */
  for (i = 0; i < cInstalledDrivers; i++)
    {
      if (lpdt->hModule == NULL)
        {
          index = i;
          break;
        }

      lpdt++;
    }

  if (index + 1 < cInstalledDrivers)
      /* The driver went into an unused slot in the middle somewhere so
       * decrement cInstalledDrivers count.
       */
      cInstalledDrivers--;

  /* Temporarly use an hModule to 1 to reserve this entry in case the driver
   * loads another driver in its LibMain.
   */
  lpdt->hModule = (HMODULE)1;

  hInstance = LoadAliasedLibrary((LPSTR)szDriverName,
                         (LPSTR)(szSectionName ? szSectionName : szDrivers),
                         szSystemIni,
                         (LPSTR)lpstrTail,
                         cbTail);
  if (hInstance < HINSTANCE_ERROR)
    {
      lpdt->hModule = NULL;

      /* Load failed with an error. Return error code in highword.
       */
      return(MAKELRESULT(0, hInstance));
    }

  (FARPROC)lpdt->lpDriverEntryPoint = GetProcAddress(hInstance, "DriverProc");

  if (!lpdt->lpDriverEntryPoint)
    {
      FreeLibrary(hInstance);
      lpdt->hModule = 0;
      result = 0L;
      goto LoadCleanUp;
    }

  lpdt->hModule = hInstance;

  /* Save either the alias or filename of this driver. (depends on what the
   * app passed to us to load it)
   */
  lstrcpy(lpdt->szAliasName, szDriverName);

  if (GetDrvrUsage(hInstance) == 1)
    {
      /* If this is the first instance, send the drv_load message. Don't use
       * SendDriverMessage because we haven't initialized the linked list yet
       */
      if (!CheckValidDriverProc(lpdt, (HDRVR)(index+1)) ||
          !(lpdt->lpDriverEntryPoint)(lpdt->dwDriverIdentifier,
                                      (HDRVR)(index+1),
                                      DRV_LOAD,
                                      0L, 0L))
        {
          /* Driver failed load call.
           */
          lpdt->lpDriverEntryPoint = NULL;
          lpdt->hModule = NULL;
          FreeLibrary(hInstance);
          result = 0L;
          goto LoadCleanUp;
        }

      lpdt->fFirstEntry = 1;
    }

  /* Put driver in the load order linked list
   */
  if (idFirstDriver == -1)
    {
      /* Initialize everything when first driver is loaded.
       */
      idFirstDriver      = index;
      idLastDriver       = index;
      lpdt->idNextDriver = -1;
      lpdt->idPrevDriver = -1;
    }
  else
    {
      /* Insert this driver at the end of the load chain.
       */
      lpdtBegin[idLastDriver].idNextDriver = index;
      lpdt->idPrevDriver = idLastDriver;
      lpdt->idNextDriver = -1;
      idLastDriver = index;
    }

  if (fSendEnable && lpdt->fFirstEntry)
      SendDriverMessage((HDRVR)(index+1), DRV_ENABLE, 0L, 0L);

  result = MAKELRESULT(index+1, hInstance);

LoadCleanUp:
  return(result);
}



WORD FAR InternalFreeDriver(HDRVR hDriver, BOOL fSendDisable)
{
  LPDRIVERTABLE lpdt;
  WORD          w;
  int           id;

  /*  The driver will receive the following message sequence:
   *
   *      if usage count of driver is 1
   *          DRV_DISABLE (normally)
   *          DRV_FREE
   */

  if ((int)hDriver > cInstalledDrivers || !hDriver)
      return(0);

  lpdt = (LPDRIVERTABLE)MAKELP(hInstalledDriverList,0);

  if (!lpdt[(int)hDriver-1].hModule)
      return(0);

  /* If the driver usage count is 1, then send free and disable messages.
   */

  /* Clear dwDriverIdentifier so that the sendmessage for DRV_OPEN and
   * DRV_ENABLE have dwDriverIdentifier = 0 if an entry gets reused and so
   * that the DRV_DISABLE and DRV_FREE messages below also get
   * dwDriverIdentifier = 0.
   */

  lpdt[(int)hDriver-1].dwDriverIdentifier = 0;

  w = GetDrvrUsage(lpdt[(int)hDriver-1].hModule);
  if (w == 1)
    {
      if (fSendDisable)
          SendDriverMessage(hDriver, DRV_DISABLE, 0L, 0L);
      SendDriverMessage(hDriver, DRV_FREE, 0L, 0L);
    }
  FreeLibrary(lpdt[(int)hDriver-1].hModule);

  // Clear the rest of the table entry

  lpdt[(int)hDriver-1].hModule = 0;            // this indicates free entry
  lpdt[(int)hDriver-1].fFirstEntry = 0;        // this is also just to be tidy
  lpdt[(int)hDriver-1].lpDriverEntryPoint = 0; // this is