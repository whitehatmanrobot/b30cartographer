SPACEW,
    EmfRecordTypeMax                     = 122,
    EmfRecordTypeMin                     = 1,

    // That is the END of the GDI EMF records.

    // Now we start the list of EMF+ records.  We leave quite
    // a bit of room here for the addition of any new GDI
    // records that may be added later.

    EmfPlusRecordTypeInvalid = GDIP_EMFPLUS_RECORD_BASE,
    EmfPlusRecordTypeHeader,
    EmfPlusRecordTypeEndOfFile,

    EmfPlusRecordTypeComment,

    EmfPlusRecordTypeGetDC,

    EmfPlusRecordTypeMultiFormatStart,
    EmfPlusRecordTypeMultiFormatSection,
    EmfPlusRecordTypeMultiFormatEnd,

    // For all persistent objects
    
    EmfPlusRecordTypeObject,

    // Drawing Records
    
    EmfPlusRecordTypeClear,
    EmfPlusRecordTypeFillRects,
    EmfPlusRecordTypeDrawRects,
    EmfPlusRecordTypeFillPolygon,
    EmfPlusRecordTypeDrawLines,
    EmfPlusRecordTypeFillEllipse,
    EmfPlusRecordTypeDrawEllipse,
    EmfPlusRecordTypeFillPie,
    EmfPlusRecordTypeDrawPie,
    EmfPlusRecordTypeDrawArc,
    EmfPlusRecordTypeFillRegion,
    EmfPlusRecordTypeFillPath,
    EmfPlusRecordTypeDrawPath,
    EmfPlusRecordTypeFillClosedCurve,
    EmfPlusRecordTypeDrawClosedCurve,
    EmfPlusRecordTypeDrawCurve,
    EmfPlusRecordTypeDrawBeziers,
    EmfPlusRecordTypeDrawImage,
    EmfPlusRecordTypeDrawImagePoints,
    EmfPlusRecordTypeDrawString,

    // Graphics State Records
    
    EmfPlusRecordTypeSetRenderingOrigin,
    EmfPlusRecordTypeSetAntiAliasMode,
    EmfPlusRecordTypeSetTextRenderingHint,
    EmfPlusRecordTypeSetTextContrast,
    EmfPlusRecordTypeSetInterpolationMode,
    EmfPlusRecordTypeSetPixelOffsetMode,
    EmfPlusRecordTypeSetCompositingMode,
    EmfPlusRecordTypeSetCompositingQuality,
    EmfPlusRecordTypeSave,
    EmfPlusRecordTypeRestore,
    EmfPlusRecordTypeBeginContainer,
    EmfPlusRecordTypeBeginContainerNoParams,
    EmfPlusRecordTypeEndContainer,
    EmfPlusRecordTypeSetWorldTransform,
    EmfPlusRecordTypeResetWorldTransform,
    EmfPlusRecordTypeMultiplyWorldTransform,
    EmfPlusRecordTypeTranslateWorldTransform,
    EmfPlusRecordTypeScaleWorldTransform,
    EmfPlusRecordTypeRotateWorldTransform,
    EmfPlusRecordTypeSetPageTransform,
    EmfPlusRecordTypeResetClip,
    EmfPlusRecordTypeSetClipRect,
    EmfPlusRecordTypeSetClipPath,
    EmfPlusRecordTypeSetClipRegion,
    EmfPlusRecordTypeOffsetClip,

    EmfPlusRecordTypeDrawDriverString,

    EmfPlusRecordTotal,

    EmfPlusRecordTypeMax = EmfPlusRecordTotal-1,
    EmfPlusRecordTypeMin = EmfPlusRecordTypeHeader,
};

//---------------------------------------------------------------------------
// StringFormatFlags
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// String format flags
//
//  DirectionRightToLeft          - For horizontal text, the reading order is
//                                  right to left. This value is called
//                                  the base embedding level by the Unicode
//                                  bidirectional engine.
//                                  For vertical text, columns are read from
//                                  right to left.
//                                  By default, horizontal or vertical text is
//                                  read from left to right.
//
//  DirectionVertical             - Individual lines of text are vertical. In
//                                  each line, characters progress from top to
//                                  bottom.
//                                  By default, lines of text are horizontal,
//                                  each new line below the previous line.
//
//  NoFitBlackBox                 - Allows parts of glyphs to overhang the
//                                  bounding rectangle.
//                                  By default glyphs are first aligned
//                                  inside the margines, then any glyphs which
//                                  still overhang the bounding box are
//                                  repositioned to avoid any overhang.
//                                  For example when an italic
//                                  lower case letter f in a font such as
//                                  Garamond is aligned at the far left of a
//                                  rectangle, the lower part of the f will
//                                  reach slightly further left than the left
//                                  edge of the rectangle. Setting this flag
//                                  will ensure the character aligns visually
//                                  with the lines above and below, but may
//                                  cause some pixels outside the formatting
//                                  rectangle to be clipped or painted.
//
//  DisplayFormatControl          - Causes control characters such as the
//                                  left-to-right mark to be shown in the
//                                  output with a representative glyph.
//
//  NoFontFallback                - Disables fallback to alternate fonts for
//                                  characters not supported in the requested
//                                  font. Any missing characters will be
//                                  be displayed with the fonts missing glyph,
//                                  usually an open square.
//
//  NoWrap                        - Disables wrapping of text between lines
//                                  when formatting within a rectangle.
//                                  NoWrap is implied when a point is passed
//                                  instead of a rectangle, or when the
//                                  specified rectangle has a zero line length.
//
//  NoClip                        - By default text is clipped to the
//                                  formatting rectangle. Setting NoClip
//                                  allows overhanging pixels to affect the
//                                  device outside the formatting rectangle.
//                                  Pixels at the end of the line may be
//                                  affected if the glyphs overhang their
//                                  cells, and either the NoFitBlackBox flag
//                                  has been set, or the glyph extends to far
//                                  to be fitted.
//                                  Pixels above/before the first line or
//                                  below/after the last line may be affected
//                                  if the glyphs extend beyond their cell
//                                  ascent / descent. This can occur rarely
//                                  with unusual diacritic mark combinations.

//---------------------------------------------------------------------------

enum StringFormatFlags
{
    StringFormatFlagsDirectionRightToLeft        = 0x00000001,
    StringFormatFlagsDirectionVertical           = 0x00000002,
    StringFormatFlagsNoFitBlackBox               = 0x00000004,
    StringFormatFlagsDisplayFormatControl        = 0x00000020,
    StringFormatFlagsNoFontFallback              = 0x00000400,
    StringFormatFlagsMeasureTrailingSpaces       = 0x00000800,
    StringFormatFlagsNoWrap                      = 0x00001000,
    StringFormatFlagsLineLimit                   = 0x00002000,

    StringFormatFlagsNoClip                      = 0x00004000
};

//---------------------------------------------------------------------------
// StringTrimming
//---------------------------------------------------------------------------

enum StringTrimming {
    StringTrimmingNone              = 0,
    StringTrimmingCharacter         = 1,
    StringTrimmingWord              = 2,
    StringTrimmingEllipsisCharacter = 3,
    StringTrimmingEllipsisWord      = 4,
    StringTrimmingEllipsisPath      = 5
};

//---------------------------------------------------------------------------
// National language digit substitution
//---------------------------------------------------------------------------

enum StringDigitSubstitute
{
    StringDigitSubstituteUser        = 0,  // As NLS setting
    StringDigitSubstituteNone        = 1,
    StringDigitSubstituteNational    = 2,
    StringDigitSubstituteTraditional = 3
};

//---------------------------------------------------------------------------
// Hotkey prefix interpretation
//---------------------------------------------------------------------------

enum HotkeyPrefix
{
    HotkeyPrefixNone        = 0,
    HotkeyPrefixShow        = 1,
    HotkeyPrefixHide        = 2
};

//---------------------------------------------------------------------------
// String alignment flags
//---------------------------------------------------------------------------

enum StringAlignment
{
    // Left edge for left-to-right text,
    // right for right-to-left text,
    // and top for vertical
    StringAlignmentNear   = 0,
    StringAlignmentCenter = 1,
    StringAlignmentFar    = 2
};

//---------------------------------------------------------------------------
// DriverStringOptions
//---------------------------------------------------------------------------

enum DriverStringOptions
{
    DriverStringOptionsCmapLookup             = 1,
    DriverStringOptionsVertical               = 2,
    DriverStringOptionsRealizedAdvance        = 4,
    DriverStringOptionsLimitSubpixel          = 8
};

//---------------------------------------------------------------------------
// Flush Intention flags
//---------------------------------------------------------------------------

enum FlushIntention
{
    FlushIntentionFlush = 0,        // Flush all batched rendering operations
    FlushIntentionSync = 1          // Flush all batched rendering operations
                                    // and wait for them to complete
};

//---------------------------------------------------------------------------
// Image encoder parameter related types
//---------------------------------------------------------------------------

enum EncoderParameterValueType
{
    EncoderParameterValueTypeByte           = 1,    // 8-bit unsigned int
    EncoderParameterValueTypeASCII          = 2,    // 8-bit byte containing one 7-bit ASCII
                                                    // code. NULL terminated.
    EncoderParameterValueTypeShort          = 3,    // 16-bit unsigned int
    EncoderParameterValueTypeLong           = 4,    // 32-bit unsigned int
    EncoderParameterValueTypeRational       = 5,    // Two Longs. The first Long is the
                                                    // numerator, the second Long expresses the
                                                    // denomintor.
    EncoderParameterValueTypeLongRange      = 6,    // Two longs which specify a range of
                                                    // integer values. The first Long specifies
                                                    // the lower end and the second one
                                                    // specifies the higher end. All values
                                                    // are inclusive at both ends
    EncoderParameterValueTypeUndefined      = 7,    // 8-bit byte that can take any value
                                                    // depending on field definition
    EncoderParameterValueTypeRationalRange  = 8     // Two Rationals. The first Rational
                                                    // specifies the lower end and the second
                                                    // specifies the higher end. All values
                                                    // are inclusive at both ends
};

//---------------------------------------------------------------------------
// Image encoder value types
//---------------------------------------------------------------------------

enum EncoderValue
{
    EncoderValueColorTypeCMYK,
    EncoderValueColorTypeYCCK,
    EncoderValueCompressionLZW,
    EncoderValueCompressionCCITT3,
    EncoderValueCompressionCCITT4,
    EncoderValueCompressionRle,
    EncoderValueCompressionNone,
    EncoderValueScanMethodInterlaced,
    EncoderValueScanMethodNonInterlaced,
    EncoderValueVersionGif87,
    EncoderValueVersionGif89,
    EncoderValueRenderProgressive,
    EncoderValueRenderNonProgressive,
    EncoderValueTransformRotate90,
    EncoderValueTransformRotate180,
    EncoderValueTransformRotate270,
    EncoderValueTransformFlipHorizontal,
    EncoderValueTransformFlipVertical,
    EncoderValueMultiFrame,
    EncoderValueLastFrame,
    EncoderValueFlush,
    EncoderValueFrameDimensionTime,
    EncoderValueFrameDimensionResolution,
    EncoderValueFrameDimensionPage
};

//---------------------------------------------------------------------------
// Conversion of Emf To WMF Bits flags
//---------------------------------------------------------------------------

enum EmfToWmfBitsFlags
{
    EmfToWmfBitsFlagsDefault          = 0x00000000,
    EmfToWmfBitsFlagsEmbedEmf         = 0x00000001,
    EmfToWmfBitsFlagsIncludePlaceable = 0x00000002,
    EmfToWmfBitsFlagsNoXORClip        = 0x00000004
};

//---------------------------------------------------------------------------
// Test Control flags
//---------------------------------------------------------------------------

enum GpTestControlEnum
{
    TestControlForceBilinear = 0,
    TestControlNoICM = 1,
    TestControlGetBuildNumber = 2
};



#endif // !_GDIPLUSENUMS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\sdkinc\gdiplusfontcollection.h ===
/**************************************************************************\
*
* Copyright (c) 2000, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
* 
*   GdiplusFontCollection.h
*
* Abstract:
*
*   Font collections (Installed and Private)
*
\**************************************************************************/

#ifndef _GDIPLUSFONTCOLL_H
#define _GDIPLUSFONTCOLL_H

inline
FontCollection::FontCollection()
{
    nativeFontCollection = NULL;
}

inline
FontCollection::~FontCollection()
{
}

inline INT
FontCollection::GetFamilyCount() const
{
    INT numFound = 0;

    lastResult = DllExports::GdipGetFontCollectionFamilyCount(
                             nativeFontCollection, &numFound);



    return numFound;
}

inline Status
FontCollection::GetFamilies(
    IN INT           numSought,
    OUT FontFamily * gpfamilies,
    OUT INT *        numFound
) const
{
    if (numSought <= 0 || gpfamilies == NULL || numFound == NULL)
    {
        return SetStatus(InvalidParameter);
    }
    *numFound = 0;
    GpFontFamily **nativeFamilyList = new GpFontFamily*[numSought];

    if (nativeFamilyList == NULL)
    {
        return SetStatus(OutOfMemory);
    }

    Status status = SetStatus(DllExports::GdipGetFontCollectionFamilyList(
        nativeFontCollection,
        numSought,
        nativeFamilyList,
        numFound
    ));
    if (status == Ok)
    {
        for (INT i = 0; i < *numFound; i++)
        {
            DllExports::GdipCloneFontFamily(nativeFamilyList[i],
                                            &gpfamilies[i].nativeFamily);
        }
    }

    delete [] nativeFamilyList;

    return status;
}

inline Status FontCollection::GetLastStatus () const
{
    return lastResult;
}

inline Status
FontCollection::SetStatus(IN Status status) const
{
    lastResult = status;
    return lastResult;
}

inline
InstalledFontCollection::InstalledFontCollection()
{
    nativeFontCollection = NULL;
    lastResult = DllExports::GdipNewInstalledFontCollection(&nativeFontCollection);
}

inline
InstalledFontCollection::~InstalledFontCollection()
{
}

inline
PrivateFontCollection::PrivateFontCollection()
{
    nativeFontCollection = NULL;
    lastResult = DllExports::GdipNewPrivateFontCollection(&nativeFontCollection);
}

inline
PrivateFontCollection::~PrivateFontCollection()
{
    DllExports::GdipDeletePrivateFontCollection(&nativeFontCollection);
}

inline Status
PrivateFontCollection::AddFontFile(IN const WCHAR* filename)
{
    return SetStatus(DllExports::GdipPrivateAddFontFile(nativeFontCollection, filename));
}

inline Status
PrivateFontCollection::AddMemoryFont(IN const void* memory,
                                     IN INT length)
{
    return SetStatus(DllExports::GdipPrivateAddMemoryFont(
        nativeFontCollection,
        memory,
        length));
}

#endif // _GDIPLUSFONTCOLL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\sdkinc\gdiplusimagecodec.h ===
/**************************************************************************\
*
* Copyright (c) 2000-2001, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   GdiplusImageCodec.h
*
* Abstract:
*
*   GDI+ Codec Image APIs
*
\**************************************************************************/

#ifndef _GDIPLUSIMAGECODEC_H
#define _GDIPLUSIMAGECODEC_H

//--------------------------------------------------------------------------
// Codec Management APIs
//--------------------------------------------------------------------------

inline Status 
GetImageDecodersSize(
    OUT UINT *numDecoders,
    OUT UINT *size)
{
    return DllExports::GdipGetImageDecodersSize(numDecoders, size);
}


inline Status 
GetImageDecoders(
    IN UINT numDecoders,
    IN UINT size,
    OUT ImageCodecInfo *decoders)
{
    return DllExports::GdipGetImageDecoders(numDecoders, size, decoders);
}


inline Status 
GetImageEncodersSize(
    OUT UINT *numEncoders, 
    OUT UINT *size)
{
    return DllExports::GdipGetImageEncodersSize(numEncoders, size);
}


inline Status 
GetImageEncoders(
    IN UINT numEncoders,
    IN UINT size,
    OUT ImageCodecInfo *encoders)
{
    return DllExports::GdipGetImageEncoders(numEncoders, size, encoders);
}

#endif  // _GDIPLUSIMAGECODEC_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\sdkinc\gdiplusgpstubs.h ===
/**************************************************************************\
*
* Copyright (c) 1998-2001, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   GdiplusGpStubs.h
*
* Abstract:
*
*   Private GDI+ header file.
*
\**************************************************************************/

#ifndef _GDIPLUSGPSTUBS_H
#define _GDIPLUSGPSTUBS_H

//---------------------------------------------------------------------------
// GDI+ classes for forward reference
//---------------------------------------------------------------------------

class Graphics;
class Pen;
class Brush;
class Matrix;
class Bitmap;
class Metafile;
class GraphicsPath;
class PathIterator;
class Region;
class Image;
class TextureBrush;
class HatchBrush;
class SolidBrush;
class LinearGradientBrush;
class PathGradientBrush;
class Font;
class FontFamily;
class FontCollection;
class InstalledFontCollection;
class PrivateFontCollection;
class ImageAttributes;
class CachedBitmap;

//---------------------------------------------------------------------------
// Private GDI+ classes for internal type checking
//---------------------------------------------------------------------------
class GpGraphics {};

class GpBrush {};
class GpTexture : public GpBrush {};
class GpSolidFill : public GpBrush {};
class GpLineGradient : public GpBrush {};
class GpPathGradient : public GpBrush {};
class GpHatch : public GpBrush {};

class GpPen {};
class GpCustomLineCap {};
class GpAdjustableArrowCap : public GpCustomLineCap {};

class GpImage {};
class GpBitmap : public GpImage {};
class GpMetafile : public GpImage {};
class GpImageAttributes {};

class GpPath {};
class GpRegion {};
class GpPathIterator {};

class GpFontFamily {};
class GpFont {};
class GpStringFormat {};
class GpFontCollection {};
class GpInstalledFontCollection : public GpFontCollection {};
class GpPrivateFontCollection : public GpFontCollection {};

class GpCachedBitmap;

typedef Status GpStatus;
typedef FillMode GpFillMode;
typedef WrapMode GpWrapMode;
typedef Unit GpUnit;
typedef CoordinateSpace GpCoordinateSpace;
typedef PointF GpPointF;
typedef Point GpPoint;
typedef RectF GpRectF;
typedef Rect GpRect;
typedef SizeF GpSizeF;
typedef HatchStyle GpHatchStyle;
typedef DashStyle GpDashStyle;
typedef LineCap GpLineCap;
typedef DashCap GpDashCap;


typedef PenAlignment GpPenAlignment;

typedef LineJoin GpLineJoin;
typedef PenType GpPenType;

typedef Matrix GpMatrix;
typedef BrushType GpBrushType;
typedef MatrixOrder GpMatrixOrder;
typedef FlushIntention GpFlushIntention;
typedef PathData GpPathData;

#endif  // !_GDIPLUSGPSTUBS.HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\sdkinc\gdiplusfontfamily.h ===
/**************************************************************************\
*
* Copyright (c) 1998-2001, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   GdiplusFontFamily.h
*
* Abstract:
*
*   GDI+ Font Family class
*
\**************************************************************************/

#ifndef _GDIPLUS_FONT_FAMILY_H
#define _GDIPLUS_FONT_FAMILY_H

inline 
FontFamily::FontFamily() :
    nativeFamily (NULL),
    lastResult    (Ok)
{
}

inline 
FontFamily::FontFamily(
    IN const WCHAR*          name,
    IN const FontCollection* fontCollection
)
{
    nativeFamily = NULL;
    lastResult = DllExports::GdipCreateFontFamilyFromName(
        name,
        fontCollection ? fontCollection->nativeFontCollection : NULL,
        &nativeFamily
    );
}

inline
FontFamily::FontFamily(
    IN GpFontFamily *nativeOrig,
    IN Status status
)
{
    lastResult    = status;
    nativeFamily = nativeOrig;
}

inline const FontFamily *
FontFamily::GenericSansSerif() 
{
    if (GenericSansSerifFontFamily != NULL)
    {
        return GenericSansSerifFontFamily;
    }

    GenericSansSerifFontFamily =
        (FontFamily*) GenericSansSerifFontFamilyBuffer;

    GenericSansSerifFontFamily->lastResult =
        DllExports::GdipGetGenericFontFamilySansSerif(
            &(GenericSansSerifFontFamily->nativeFamily)
        );

    return GenericSansSerifFontFamily;
}

inline const FontFamily *
FontFamily::GenericSerif() 
{
    if (GenericSerifFontFamily != NULL)
    {
        return GenericSerifFontFamily;
    }

    GenericSerifFontFamily =
        (FontFamily*) GenericSerifFontFamilyBuffer;

    GenericSerifFontFamily->lastResult =
        DllExports::GdipGetGenericFontFamilySerif(
            &(GenericSerifFontFamily->nativeFamily)
        );

    return GenericSerifFontFamily;
}

inline const FontFamily *
FontFamily::GenericMonospace()
{
    if (GenericMonospaceFontFamily != NULL)
    {
        return GenericMonospaceFontFamily;
    }

    GenericMonospaceFontFamily =
        (FontFamily*) GenericMonospaceFontFamilyBuffer;

    GenericMonospaceFontFamily->lastResult =
        DllExports::GdipGetGenericFontFamilyMonospace(
            &(GenericMonospaceFontFamily->nativeFamily)
        );

    return GenericMonospaceFontFamily;
}

inline FontFamily::~FontFamily()
{
    DllExports::GdipDeleteFontFamily (nativeFamily);
}

inline FontFamily *
FontFamily::Clone() const
{
    GpFontFamily * clonedFamily = NULL;

    SetStatus(DllExports::GdipCloneFontFamily (nativeFamily, &clonedFamily));

    return new FontFamily(clonedFamily, lastResult);
}

inline Status 
FontFamily::GetFamilyName(
    IN WCHAR name[LF_FACESIZE],
    IN LANGID language
) const
{
    return SetStatus(DllExports::GdipGetFamilyName(nativeFamily, 
                                                   name, 
                                                   language));
}

inline BOOL 
FontFamily::IsStyleAvailable(IN INT style) const
{
    BOOL    StyleAvailable;
    Status  status;

    status = SetStatus(DllExports::GdipIsStyleAvailable(nativeFamily, style, &StyleAvailable));

    if (status != Ok)
        StyleAvailable = FALSE;

    return StyleAvailable;
}


inline UINT16 
FontFamily::GetEmHeight(IN INT style) const
{
    UINT16  EmHeight;

    SetStatus(DllExports::GdipGetEmHeight(nativeFamily, style, &EmHeight));

    return EmHeight;
}

inline UINT16 
FontFamily::GetCellAscent(IN INT style) const
{
    UINT16  CellAscent;

    SetStatus(DllExports::GdipGetCellAscent(nativeFamily, style, &CellAscent));

    return CellAscent;
}

inline UINT16 
FontFamily::GetCellDescent(IN INT style) const
{
    UINT16  CellDescent;

    SetStatus(DllExports::GdipGetCellDescent(nativeFamily, style, &CellDescent));

    return CellDescent;
}


inline UINT16 
FontFamily::GetLineSpacing(IN INT style) const
{
    UINT16  LineSpacing;

    SetStatus(DllExports::GdipGetLineSpacing(nativeFamily, style, &LineSpacing));

    return LineSpacing;

}

inline Status 
FontFamily::GetLastStatus() const
{
    Status lastStatus = lastResult;
    lastResult = Ok;

    return lastStatus;
}

inline Status
FontFamily::SetStatus(Status status) const 
{
    if (status != Ok)
        return (lastResult = status);
    else
        return status;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\sdkinc\gdiplusgraphics.h ===
/**************************************************************************\
*
* Copyright (c) 1998-2001, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   GdiplusGraphics.h
*
* Abstract:
*
*   GDI+ Graphics Object
*
\**************************************************************************/

#ifndef _GDIPLUSGRAPHICS_H
#define _GDIPLUSGRAPHICS_H

class Graphics : public GdiplusBase
{
public:
    friend class Region;
    friend class GraphicsPath;
    friend class Image;
    friend class Bitmap;
    friend class Metafile;
    friend class Font;
    friend class FontFamily;
    friend class FontCollection;
    friend class CachedBitmap;

    static Graphics* FromHDC(IN HDC hdc)
    {
        return new Graphics(hdc);
    }

    static Graphics* FromHDC(IN HDC hdc,
                             IN HANDLE hdevice)
    {
        return new Graphics(hdc, hdevice);
    }

    static Graphics* FromHWND(IN HWND hwnd,
                              IN BOOL icm = FALSE)
    {
        return new Graphics(hwnd, icm);
    }

    static Graphics* FromImage(IN Image *image)
    {
        return new Graphics(image);
    }

    Graphics(IN HDC hdc)
    {
        GpGraphics *graphics = NULL;

        lastResult = DllExports::GdipCreateFromHDC(hdc, &graphics);

        SetNativeGraphics(graphics);
    }

    Graphics(IN HDC hdc,
             IN HANDLE hdevice)
    {
        GpGraphics *graphics = NULL;

        lastResult = DllExports::GdipCreateFromHDC2(hdc, hdevice, &graphics);

        SetNativeGraphics(graphics);
    }

    Graphics(IN HWND hwnd,
             IN BOOL icm = FALSE)
    {
        GpGraphics *graphics = NULL;

        if (icm)
        {
            lastResult = DllExports::GdipCreateFromHWNDICM(hwnd, &graphics);
        }
        else
        {
            lastResult = DllExports::GdipCreateFromHWND(hwnd, &graphics);
        }

        SetNativeGraphics(graphics);
    }

    Graphics(IN Image* image)
    {
        GpGraphics *graphics = NULL;

        if (image != NULL)
        {
            lastResult = DllExports::GdipGetImageGraphicsContext(
                                                                image->nativeImage, &graphics);
        }
        SetNativeGraphics(graphics);
    }

    ~Graphics()
    {
        DllExports::GdipDeleteGraphics(nativeGraphics);
    }

    VOID Flush(IN FlushIntention intention = FlushIntentionFlush)
    {
        DllExports::GdipFlush(nativeGraphics, intention);
    }

    //------------------------------------------------------------------------
    // GDI Interop methods
    //------------------------------------------------------------------------

    // Locks the graphics until ReleaseDC is called

    HDC GetHDC()
    {
        HDC     hdc = NULL;

        SetStatus(DllExports::GdipGetDC(nativeGraphics, &hdc));

        return hdc;
    }

    VOID ReleaseHDC(IN HDC hdc)
    {
        SetStatus(DllExports::GdipReleaseDC(nativeGraphics, hdc));
    }

    //------------------------------------------------------------------------
    // Rendering modes
    //------------------------------------------------------------------------

    Status SetRenderingOrigin(IN INT x, IN INT y)
    {
        return SetStatus(
            DllExports::GdipSetRenderingOrigin(
                nativeGraphics, x, y
            )
        );
    }

    Status GetRenderingOrigin(OUT INT *x, OUT INT *y) const
    {
        return SetStatus(
            DllExports::GdipGetRenderingOrigin(
                nativeGraphics, x, y
            )
        );
    }

    Status SetCompositingMode(IN CompositingMode compositingMode)
    {
        return SetStatus(DllExports::GdipSetCompositingMode(nativeGraphics,
                                                            compositingMode));
    }

    CompositingMode GetCompositingMode() const
    {
        CompositingMode mode;

        SetStatus(DllExports::GdipGetCompositingMode(nativeGraphics,
                                                     &mode));

        return mode;
    }

    Status SetCompositingQuality(IN CompositingQuality compositingQuality)
    {
        return SetStatus(DllExports::GdipSetCompositingQuality(
            nativeGraphics,
            compositingQuality));
    }

    CompositingQuality GetCompositingQuality() const
    {
        CompositingQuality quality;

        SetStatus(DllExports::GdipGetCompositingQuality(
            nativeGraphics,
            &quality));

        return quality;
    }

    Status SetTextRenderingHint(IN TextRenderingHint newMode)
    {
        return SetStatus(DllExports::GdipSetTextRenderingHint(nativeGraphics,
                                                          newMode));
    }

    TextRenderingHint GetTextRenderingHint() const
    {
        TextRenderingHint hint;

        SetStatus(DllExports::GdipGetTextRenderingHint(nativeGraphics,
                                                   &hint));

        return hint;
    }

    Status SetTextContrast(IN UINT contrast)
    {
        return SetStatus(DllExports::GdipSetTextContrast(nativeGraphics,
                                                          contrast));
    }

    UINT GetTextContrast() const
    {
        UINT contrast;

        SetStatus(DllExports::GdipGetTextContrast(nativeGraphics,
                                                    &contrast));

        return contrast;
    }

    InterpolationMode GetInterpolationMode() const
    {
        InterpolationMode mode = InterpolationModeInvalid;

        SetStatus(DllExports::GdipGetInterpolationMode(nativeGraphics,
                                                           &mode));

        return mode;
    }

    Status SetInterpolationMode(IN InterpolationMode interpolationMode)
    {
        return SetStatus(DllExports::GdipSetInterpolationMode(nativeGraphics,
                                                           interpolationMode));
    }

    SmoothingMode GetSmoothingMode() const
    {
        SmoothingMode smoothingMode = SmoothingModeInvalid;

        SetStatus(DllExports::GdipGetSmoothingMode(nativeGraphics,
                                                   &smoothingMode));

        return smoothingMode;
    }

    Status SetSmoothingMode(IN SmoothingMode smoothingMode)
    {
        return SetStatus(DllExports::GdipSetSmoothingMode(nativeGraphics,
                                                          smoothingMode));
    }

    PixelOffsetMode GetPixelOffsetMode() const
    {
        PixelOffsetMode pixelOffsetMode = PixelOffsetModeInvalid;

        SetStatus(DllExports::GdipGetPixelOffsetMode(nativeGraphics,
                                                     &pixelOffsetMode));

        return pixelOffsetMode;
    }

    Status SetPixelOffsetMode(IN PixelOffsetMode pixelOffsetMode)
    {
        return SetStatus(DllExports::GdipSetPixelOffsetMode(nativeGraphics,
                                                            pixelOffsetMode));
    }

    //------------------------------------------------------------------------
    // Manipulate current world transform
    //------------------------------------------------------------------------

    Status SetTransform(IN const Matrix* matrix)
    {
        return SetStatus(DllExports::GdipSetWorldTransform(nativeGraphics,
                                                        matrix->nativeMatrix));
    }
    Status ResetTransform()
    {
        return SetStatus(DllExports::GdipResetWorldTransform(nativeGraphics));
    }

    Status MultiplyTransform(IN const Matrix* matrix,
                             IN MatrixOrder order = MatrixOrderPrepend)
    {
        return SetStatus(DllExports::GdipMultiplyWorldTransform(nativeGraphics,
                                                                matrix->nativeMatrix,
                                                                order));
    }

    Status TranslateTransform(IN REAL dx,
                              IN REAL dy,
                              IN MatrixOrder order = MatrixOrderPrepend)
    {
        return SetStatus(DllExports::GdipTranslateWorldTransform(nativeGraphics,
                                                               dx, dy, order));
    }

    Status ScaleTransform(IN REAL sx,
                          IN REAL sy,
                          IN MatrixOrder order = MatrixOrderPrepend)
    {
        return SetStatus(DllExports::GdipScaleWorldTransform(nativeGraphics,
                                                             sx, sy, order));
    }

    Status RotateTransform(IN REAL angle,
                           IN MatrixOrder order = MatrixOrderPrepend)
    {
        return SetStatus(DllExports::GdipRotateWorldTransform(nativeGraphics,
                                                              angle, order));
    }

    Status GetTransform(OUT Matrix* matrix) const
    {
        return SetStatus(DllExports::GdipGetWorldTransform(nativeGraphics,
                                                           matrix->nativeMatrix));
    }

    Status SetPageUnit(IN Unit unit)
    {
        return SetStatus(DllExports::GdipSetPageUnit(nativeGraphics,
                                                     unit));
    }

    Status SetPageScale(IN REAL scale)
    {
        return SetStatus(DllExports::GdipSetPageScale(nativeGraphics,
                                                      scale));
    }

    Unit GetPageUnit() const
    {
        Unit unit;

        SetStatus(DllExports::GdipGetPageUnit(nativeGraphics, &unit));

        return unit;
    }

    REAL GetPageScale() const
    {
        REAL scale;

        SetStatus(DllExports::GdipGetPageScale(nativeGraphics, &scale));

        return scale;
    }

    REAL GetDpiX() const
    {
        REAL dpi;

        SetStatus(DllExports::GdipGetDpiX(nativeGraphics, &dpi));

        return dpi;
    }

    REAL GetDpiY() const
    {
        REAL dpi;

        SetStatus(DllExports::GdipGetDpiY(nativeGraphics, &dpi));

        return dpi;
    }

    Status TransformPoints(IN CoordinateSpace destSpace,
                           IN CoordinateSpace srcSpace,
                           IN OUT PointF* pts,
                           IN INT count) const
    {
        return SetStatus(DllExports::GdipTransformPoints(nativeGraphics,
                                                         destSpace,
                                                         srcSpace,
                                                         pts,
                                                         count));
    }

    Status TransformPoints(IN CoordinateSpace destSpace,
                           IN CoordinateSpace srcSpace,
                           IN OUT Point* pts,
                           IN INT count) const
    {

        return SetStatus(DllExports::GdipTransformPointsI(nativeGraphics,
                                                          destSpace,
                                                          srcSpace,
                                                          pts,
                                                          count));
    }

    //------------------------------------------------------------------------
    // GetNearestColor (for <= 8bpp surfaces).  Note: Alpha is ignored.
    //------------------------------------------------------------------------
    
    Status GetNearestColor(IN OUT Color* color) const
    {
        if (color == NULL)
        {
            return SetStatus(InvalidParameter);
        }

        ARGB argb = color->GetValue();

        Status status = SetStatus(DllExports::GdipGetNearestColor(nativeGraphics, &argb));

        color->SetValue(argb);

        return status;
    }

    Status DrawLine(IN const Pen* pen,
                    IN REAL x1,
                    IN REAL y1,
                    IN REAL x2,
                    IN REAL y2)
    {
        return SetStatus(DllExports::GdipDrawLine(nativeGraphics,
                                                  pen->nativePen, x1, y1, x2,
                                                  y2));
    }

    Status DrawLine(IN const Pen* pen,
                    IN const PointF& pt1,
                    IN const PointF& pt2)
    {
        return DrawLine(pen, pt1.X, pt1.Y, pt2.X, pt2.Y);
    }

    Status DrawLines(IN const Pen* pen,
                     IN const PointF* points,
                     IN INT count)
    {
        return SetStatus(DllExports::GdipDrawLines(nativeGraphics,
                                                   pen->nativePen,
                                                   points, count));
    }

    Status DrawLine(IN const Pen* pen,
                    IN INT x1,
                    IN INT y1,
                    IN INT x2,
                    IN INT y2)
    {
        return SetStatus(DllExports::GdipDrawLineI(nativeGraphics,
                                                   pen->nativePen,
                                                   x1,
                                                   y1,
                                                   x2,
                                                   y2));
    }

    Status DrawLine(IN const Pen* pen,
                    IN const Point& pt1,
                    IN const Point& pt2)
    {
        return DrawLine(pen,
                        pt1.X,
                        pt1.Y,
                        pt2.X,
                        pt2.Y);
    }

    Status DrawLines(IN const Pen* pen,
                     IN const Point* points,
                     IN INT count)
    {
        return SetStatus(DllExports::GdipDrawLinesI(nativeGraphics,
                                                    pen->nativePen,
                                                    points,
                                                    count));
    }

    Status DrawArc(IN const Pen* pen,
                   IN REAL x,
                   IN REAL y,
                   IN REAL width,
                   IN REAL height,
                   IN REAL startAngle,
                   IN REAL sweepAngle)
    {
        return SetStatus(DllExports::GdipDrawArc(nativeGraphics,
                                                 pen->nativePen,
                                                 x,
                                                 y,
                                                 width,
                                                 height,
                                                 startAngle,
                                                 sweepAngle));
    }

    Status DrawArc(IN const Pen* pen,
                   IN const RectF& rect,
                   IN REAL startAngle,
                   IN REAL sweepAngle)
    {
        return DrawArc(pen, rect.X, rect.Y, rect.Width, rect.Height,
                       startAngle, sweepAngle);
    }

    Status DrawArc(IN const Pen* pen,
                   IN INT x,
                   IN INT y,
                   IN INT width,
                   IN INT height,
                   IN REAL startAngle,
                   IN REAL sweepAngle)
    {
        return SetStatus(DllExports::GdipDrawArcI(nativeGraphics,
                                                  pen->nativePen,
                                                  x,
                                                  y,
                                                  width,
                                                  height,
                                                  startAngle,
                                                  sweepAngle));
    }


    Status DrawArc(IN const Pen* pen,
                   IN const Rect& rect,
                   IN REAL startAngle,
                   IN REAL sweepAngle)
    {
        return DrawArc(pen,
                       rect.X,
                       rect.Y,
                       rect.Width,
                       rect.Height,
                       startAngle,
                       sweepAngle);
    }

    Status DrawBezier(IN const Pen* pen,
                      IN REAL x1,
                      IN REAL y1,
                      IN REAL x2,
                      IN REAL y2,
                      IN REAL x3,
                      IN REAL y3,
                      IN REAL x4,
                      IN REAL y4)
    {
        return SetStatus(DllExports::GdipDrawBezier(nativeGraphics,
                                                    pen->nativePen, x1, y1,
                                                    x2, y2, x3, y3, x4, y4));
    }

    Status DrawBezier(IN const Pen* pen,
                      IN const PointF& pt1,
                      IN const PointF& pt2,
                      IN const PointF& pt3,
                      IN const PointF& pt4)
    {
        return DrawBezier(pen,
                          pt1.X,
                          pt1.Y,
                          pt2.X,
                          pt2.Y,
                          pt3.X,
                          pt3.Y,
                          pt4.X,
                          pt4.Y);
    }

    Status DrawBeziers(IN const Pen* pen,
                       IN const PointF* points,
                       IN INT count)
    {
        return SetStatus(DllExports::GdipDrawBeziers(nativeGraphics,
                                                     pen->nativePen,
                                                     points,
                                                     count));
    }

    Status DrawBezier(IN const Pen* pen,
                      IN INT x1,
                      IN INT y1,
                      IN INT x2,
                      IN INT y2,
                      IN INT x3,
                      IN INT y3,
                      IN INT x4,
                      IN INT y4)
    {
        return SetStatus(DllExports::GdipDrawBezierI(nativeGraphics,
                                                     pen->nativePen,
                                                     x1,
                                                     y1,
                                                     x2,
                                                     y2,
                                                     x3,
                                                     y3,
                                                     x4,
                                                     y4));
    }

    Status DrawBezier(IN const Pen* pen,
                      IN const Point& pt1,
                      IN const Point& pt2,
                      IN const Point& pt3,
                      IN const Point& pt4)
    {
        return DrawBezier(pen,
                          pt1.X,
                          pt1.Y,
                          pt2.X,
                          pt2.Y,
                          pt3.X,
                          pt3.Y,
                          pt4.X,
                          pt4.Y);
    }

    Status DrawBeziers(IN const Pen* pen,
                       IN const Point* points,
                       IN INT count)
    {
        return SetStatus(DllExports::GdipDrawBeziersI(nativeGraphics,
                                                      pen->nativePen,
                                                      points,
                                                      count));
    }

    Status DrawRectangle(IN const Pen* pen,
                         IN const RectF& rect)
    {
        return DrawRectangle(pen, rect.X, rect.Y, rect.Width, rect.Height);
    }

    Status DrawRectangle(IN const Pen* pen,
                         IN REAL x,
                         IN REAL y,
                         IN REAL width,
                         IN REAL height)
    {
        return SetStatus(DllExports::GdipDrawRectangle(nativeGraphics,
                                                       pen->nativePen, x, y,
                                                       width, height));
    }

    Status DrawRectangles(IN const Pen* pen,
                          IN const RectF* rects,
                          IN INT count)
    {
        return SetStatus(DllExports::GdipDrawRectangles(nativeGraphics,
                                                        pen->nativePen,
                                                        rects, count));
    }

    Status DrawRectangle(IN const Pen* pen,
                         IN const Rect& rect)
    {
        return DrawRectangle(pen,
                             rect.X,
                             rect.Y,
                             rect.Width,
                             rect.Height);
    }

    Status DrawRectangle(IN const Pen* pen,
                         IN INT x,
                         IN INT y,
                         IN INT width,
                         IN INT height)
    {
        return SetStatus(DllExports::GdipDrawRectangleI(nativeGraphics,
                                                        pen->nativePen,
                                                        x,
                                                        y,
                                                        width,
                                                        height));
    }

    Status DrawRectangles(IN const Pen* pen,
                          IN const Rect* rects,
                          IN INT count)
    {
        return SetStatus(DllExports::GdipDrawRectanglesI(nativeGraphics,
                                                         pen->nativePen,
                                                         rects,
                                                         count));
    }

    Status DrawEllipse(IN const Pen* pen,
                       IN const RectF& rect)
    {
        return DrawEllipse(pen, rect.X, rect.Y, rect.Width, rect.Height);
    }

    Status DrawEllipse(IN const Pen* pen,
                       IN REAL x,
                       IN REAL y,
                       IN REAL width,
                       IN REAL height)
    {
        return SetStatus(DllExports::GdipDrawEllipse(nativeGraphics,
                                                     pen->nativePen,
                                                     x,
                                                     y,
                                                     width,
                                                     height));
    }

    Status DrawEllipse(IN const Pen* pen,
                       IN const Rect& rect)
    {
        return DrawEllipse(pen,
                           rect.X,
                           rect.Y,
                           rect.Width,
                           rect.Height);
    }

    Status DrawEllipse(IN const Pen* pen,
                       IN INT x,
                       IN INT y,
                       IN INT width,
                       IN INT height)
    {
        return SetStatus(DllExports::GdipDrawEllipseI(nativeGraphics,
                                                      pen->nativePen,
                                                      x,
                                                      y,
                                                      width,
                                                      height));
    }

    Status DrawPie(IN const Pen* pen,
                   IN const RectF& rect,
                   IN REAL startAngle,
                   IN REAL sweepAngle)
    {
        return DrawPie(pen,
                       rect.X,
                       rect.Y,
                       rect.Width,
                       rect.Height,
                       startAngle,
                       sweepAngle);
    }

    Status DrawPie(IN const Pen* pen,
                   IN REAL x,
                   IN REAL y,
                   IN REAL width,
                   IN REAL height,
                   IN REAL startAngle,
                   IN REAL sweepAngle)
    {
        return SetStatus(DllExports::GdipDrawPie(nativeGraphics,
                                                 pen->nativePen,
                                                 x,
                                                 y,
                                                 width,
                                                 height,
                                                 startAngle,
                                                 sweepAngle));
    }

    Status DrawPie(IN const Pen* pen,
                   IN const Rect& rect,
                   IN REAL startAngle,
                   IN REAL sweepAngle)
    {
        return DrawPie(pen,
                       rect.X,
                       rect.Y,
                       rect.Width,
                       rect.Height,
                       startAngle,
                       sweepAngle);
    }

    Status DrawPie(IN const Pen* pen,
                   IN INT x,
                   IN INT y,
                   IN INT width,
                   IN INT height,
                   IN REAL startAngle,
                   IN REAL sweepAngle)
    {
        return SetStatus(DllExports::GdipDrawPieI(nativeGraphics,
                                                  pen->nativePen,
                                                  x,
                                                  y,
                                                  width,
                                                  height,
                                                  startAngle,
                                                  sweepAngle));
    }

    Status DrawPolygon(IN const Pen* pen,
                       IN const PointF* points,
                       IN INT count)
    {
        return SetStatus(DllExports::GdipDrawPolygon(nativeGraphics,
                                                     pen->nativePen,
                                                     points,
                                                     count));
    }

    Status DrawPolygon(IN const Pen* pen,
                       IN const Point* points,
                       IN INT count)
    {
        return SetStatus(DllExports::GdipDrawPolygonI(nativeGraphics,
                                                      pen->nativePen,
                                                      points,
                                                      count));
    }

    Status DrawPath(IN const Pen* pen,
                    IN const GraphicsPath* path)
    {
        return SetStatus(DllExports::GdipDrawPath(nativeGraphics,
                                                  pen ? pen->nativePen : NULL,
                                                  path ? path->nativePath : NULL));
    }

    Status DrawCurve(IN const Pen* pen,
                     IN const PointF* points,
                     IN INT count)
    {
        return SetStatus(DllExports::GdipDrawCurve(nativeGraphics,
                                                   pen->nativePen, points,
                                                   count));
    }

    Status DrawCurve(IN const Pen* pen,
                     IN const PointF* points,
                     IN INT count,
                     IN REAL tension)
    {
        return SetStatus(DllExports::GdipDrawCurve2(nativeGraphics,
                                                    pen->nativePen, points,
                                                    count, tension));
    }

    Status DrawCurve(IN const Pen* pen,
                     IN const PointF* points,
                     IN INT count,
                     IN INT offset,
                     IN INT numberOfSegments,
                     IN REAL tension = 0.5f)
    {
        return SetStatus(DllExports::GdipDrawCurve3(nativeGraphics,
                                                    pen->nativePen, points,
                                                    count, offset,
                                                    numberOfSegments, tension));
    }

    Status DrawCurve(IN const Pen* pen,
                     IN const Point* points,
                     IN INT count)
    {
        return SetStatus(DllExports::GdipDrawCurveI(nativeGraphics,
                                                    pen->nativePen,
                                                    points,
                                                    count));
    }

    Status DrawCurve(IN const Pen* pen,
                     IN const Point* points,
                     IN INT count,
                     IN REAL tension)
    {
        return SetStatus(DllExports::GdipDrawCurve2I(nativeGraphics,
                                                     pen->nativePen,
                                                     points,
                                                     count,
                                                     tension));
    }

    Status DrawCurve(IN const Pen* pen,
                     IN const Point* points,
                     IN INT count,
                     IN INT offset,
                     IN INT numberOfSegments,
                     IN REAL tension = 0.5f)
    {
        return SetStatus(DllExports::GdipDrawCurve3I(nativeGraphics,
                                                     pen->nativePen,
                                                     points,
                                                     count,
                                                     offset,
                                                     numberOfSegments,
                                                     tension));
    }

    Status DrawClosedCurve(IN const Pen* pen,
                           IN const PointF* points,
                           IN INT count)
    {
        return SetStatus(DllExports::GdipDrawClosedCurve(nativeGraphics,
                                                         pen->nativePen,
                                                         points, count));
    }

    Status DrawClosedCurve(IN const Pen *pen,
                           IN const PointF* points,
                           IN INT count,
                           IN REAL tension)
    {
        return SetStatus(DllExports::GdipDrawClosedCurve2(nativeGraphics,
                                                          pen->nativePen,
                                                          points, count,
                                                          tension));
    }

    Status DrawClosedCurve(IN const Pen* pen,
                           IN const Point* points,
                           IN INT count)
    {
        return SetStatus(DllExports::GdipDrawClosedCurveI(nativeGraphics,
                                                          pen->nativePen,
                                                          points,
                                                          count));
    }

    Status DrawClosedCurve(IN const Pen *pen,
                           IN const Point* points,
                           IN INT count,
                           IN REAL tension)
    {
        return SetStatus(DllExports::GdipDrawClosedCurve2I(nativeGraphics,
                                                           pen->nativePen,
                                                           points,
                                                           count,
                                                           tension));
    }

    Status Clear(IN const Color &color)
    {
        return SetStatus(DllExports::GdipGraphicsClear(
            nativeGraphics,
            color.GetValue()));
    }

    Status FillRectangle(IN const Brush* brush,
                         IN const RectF& rect)
    {
        return FillRectangle(brush, rect.X, rect.Y, rect.Width, rect.Height);
    }

    Status FillRectangle(IN const Brush* brush,
                         IN REAL x,
                         IN REAL y,
                         IN REAL width,
                         IN REAL height)
    {
        return SetStatus(DllExports::GdipFillRectangle(nativeGraphics,
                                                       brush->nativeBrush, x, y,
                                                       width, height));
    }

    Status FillRectangles(IN const Brush* brush,
                          IN const RectF* rects,
                          IN INT count)
    {
        return SetStatus(DllExports::GdipFillRectangles(nativeGraphics,
                                                        brush->nativeBrush,
                                                        rects, count));
    }

    Status FillRectangle(IN const Brush* brush,
                         IN const Rect& rect)
    {
        return FillRectangle(brush,
                             rect.X,
                             rect.Y,
                             rect.Width,
                             rect.Height);
    }

    Status FillRectangle(IN const Brush* brush,
                         IN INT x,
                         IN INT y,
                         IN INT width,
                         IN INT height)
    {
        return SetStatus(DllExports::GdipFillRectangleI(nativeGraphics,
                                                        brush->nativeBrush,
                                                        x,
                                                        y,
                                                        width,
                                                        height));
    }

    Status FillRectangles(IN const Brush* brush,
                          IN const Rect* rects,
                          IN INT count)
    {
        return SetStatus(DllExports::GdipFillRectanglesI(nativeGraphics,
                                                         brush->nativeBrush,
                                                         rects,
                                                         count));
    }

    Status FillPolygon(IN const Brush* brush,
                       IN const PointF* points,
                       IN INT count)
    {
        return FillPolygon(brush, points, count, FillModeAlternate);
    }

    Status FillPolygon(IN const Brush* brush,
                       IN const PointF* points,
                       IN INT count,
                       IN FillMode fillMode)
    {
        return SetStatus(DllExports::GdipFillPolygon(nativeGraphics,
                                                     brush->nativeBrush,
                                                     points, count, fillMode));
    }

    Status FillPolygon(IN const Brush* brush,
                       IN const Point* points,
                       IN INT count)
    {
        return FillPolygon(brush, points, count, FillModeAlternate);
    }

    Status FillPolygon(IN const Brush* brush,
                       IN const Point* points,
                       IN INT count,
                       IN FillMode fillMode)
    {
        return SetStatus(DllExports::GdipFillPolygonI(nativeGraphics,
                                                      brush->nativeBrush,
                                                      points, count,
                                                      fillMode));
    }

    Status FillEllipse(IN const Brush* brush,
                       IN const RectF& rect)
    {
        return FillEllipse(brush, rect.X, rect.Y, rect.Width, rect.Height);
    }

    Status FillEllipse(IN const Brush* brush,
                       IN REAL x,
                       IN REAL y,
                       IN REAL width,
                       IN REAL height)
    {
        return SetStatus(DllExports::GdipFillEllipse(nativeGraphics,
                                                     brush->nativeBrush, x, y,
                                                     width, height));
    }

    Status FillEllipse(IN const Brush* brush,
                       IN const Rect& rect)
    {
        return FillEllipse(brush, rect.X, rect.Y, rect.Width, rect.Height);
    }

    Status FillEllipse(IN const Brush* brush,
                       IN INT x,
                       IN INT y,
                       IN INT width,
                       IN INT height)
    {
        return SetStatus(DllExports::GdipFillEllipseI(nativeGraphics,
                                                      brush->nativeBrush,
                                                      x,
                                                      y,
                                                      width,
                                                      height));
    }

    Status FillPie(IN const Brush* brush,
                   IN const RectF& rect,
                   IN REAL startAngle,
                   IN REAL sweepAngle)
    {
        return FillPie(brush, rect.X, rect.Y, rect.Width, rect.Height,
                       startAngle, sweepAngle);
    }

    Status FillPie(IN const Brush* brush,
                   IN REAL x,
                   IN REAL y,
                   IN REAL width,
                   IN REAL height,
                   IN REAL startAngle,
                   IN REAL sweepAngle)
    {
        return SetStatus(DllExports::GdipFillPie(nativeGraphics,
                                                 brush->nativeBrush, x, y,
                                                 width, height, startAngle,
                                                 sweepAngle));
    }

    Status FillPie(IN const Brush* brush,
                   IN const Rect& rect,
                   IN REAL startAngle,
                   IN REAL sweepAngle)
    {
        return FillPie(brush, rect.X, rect.Y, rect.Width, rect.Height,
                       startAngle, sweepAngle);
    }

    Status FillPie(IN const Brush* brush,
                   IN INT x,
                   IN INT y,
                   IN INT width,
                   IN INT height,
                   IN REAL startAngle,
                   IN REAL sweepAngle)
    {
        return SetStatus(DllExports::GdipFillPieI(nativeGraphics,
                                                  brush->nativeBrush,
                                                  x,
                                                  y,
                                                  width,
                                                  height,
                                                  startAngle,
                                                  sweepAngle));
    }

    Status FillPath(IN const Brush* brush,
                    IN const GraphicsPath* path)
    {
        return SetStatus(DllExports::GdipFillPath(nativeGraphics,
                                                  brush->nativeBrush,
                                                  path->nativePath));
    }

    Status FillClosedCurve(IN const Brush* brush,
                           IN const PointF* points,
                           IN INT count)
    {
        return SetStatus(DllExports::GdipFillClosedCurve(nativeGraphics,
                                                         brush->nativeBrush,
                                                         points, count));

    }

    Status FillClosedCurve(IN const Brush* brush,
                           IN const PointF* points,
                           IN INT count,
                           IN FillMode fillMode,
                           IN REAL tension = 0.5f)
    {
        return SetStatus(DllExports::GdipFillClosedCurve2(nativeGraphics,
                                                          brush->nativeBrush,
                                                          points, count,
                                                          tension, fillMode));
    }

    Status FillClosedCurve(IN const Brush* brush,
                           IN const Point* points,
                           IN INT count)
    {
        return SetStatus(DllExports::GdipFillClosedCurveI(nativeGraphics,
                                                          brush->nativeBrush,
                                                          points,
                                                          count));
    }

    Status FillClosedCurve(IN const Brush* brush,
                           IN const Point* points,
                           IN INT count,
                           IN FillMode fillMode,
                           IN REAL tension = 0.5f)
    {
        return SetStatus(DllExports::GdipFillClosedCurve2I(nativeGraphics,
                                                           brush->nativeBrush,
                                                           points, count,
                                                           tension, fillMode));
    }

    Status FillRegion(IN const Brush* brush,
                      IN const Region* region)
    {
        return SetStatus(DllExports::GdipFillRegion(nativeGraphics,
                                                    brush->nativeBrush,
                                                    region->nativeRegion));
    }

    Status
    DrawString(
        IN const WCHAR        *string,
        IN INT                 length,
        IN const Font         *font,
        IN const RectF        &layoutRect,
        IN const StringFormat *stringFormat,
        IN const Brush        *brush
    )
    {
        return SetStatus(DllExports::GdipDrawString(
            nativeGraphics,
            string,
            length,
            font ? font->nativeFont : NULL,
            &layoutRect,
            stringFormat ? stringFormat->nativeFormat : NULL,
            brush ? brush->nativeBrush : NULL
        ));
    }

    Status
    DrawString(
        const WCHAR        *string,
        INT                 length,
        const Font         *font,
        const PointF       &origin,
        const Brush        *brush
    )
    {
        RectF rect(origin.X, origin.Y, 0.0f, 0.0f);

        return SetStatus(DllExports::GdipDrawString(
            nativeGraphics,
            string,
            length,
            font ? font->nativeFont : NULL,
            &rect,
            NULL,
            brush ? brush->nativeBrush : NULL
        ));
    }

    Status
    DrawString(
        const WCHAR        *string,
        INT                 length,
        const Font         *font,
        const PointF       &origin,
        const StringFormat *stringFormat,
        const Brush        *brush
    )
    {
        RectF rect(origin.X, origin.Y, 0.0f, 0.0f);

        return SetStatus(DllExports::GdipDrawString(
            nativeGraphics,
            string,
            length,
            font ? font->nativeFont : NULL,
            &rect,
            stringFormat ? stringFormat->nativeFormat : NULL,
            brush ? brush->nativeBrush : NULL
        ));
    }

    Status
    MeasureString(
        IN const WCHAR        *string,
        IN INT                 length,
        IN const Font         *font,
        IN const RectF        &layoutRect,
        IN const StringFormat *stringFormat,
        OUT RectF             *boundingBox,
        OUT INT               *codepointsFitted = 0,
        OUT INT               *linesFilled      = 0
    ) const
    {
        return SetStatus(DllExports::GdipMeasureString(
            nativeGraphics,
            string,
            length,
            font ? font->nativeFont : NULL,
            &layoutRect,
            stringFormat ? stringFormat->nativeFormat : NULL,
            boundingBox,
            codepointsFitted,
            linesFilled
        ));
    }

    Status
    MeasureString(
        IN const WCHAR        *string,
        IN INT                 length,
        IN const Font         *font,
        IN const SizeF        &layoutRectSize,
        IN const StringFormat *stringFormat,
        OUT SizeF             *size,
        OUT INT               *codepointsFitted = 0,
        OUT INT               *linesFilled      = 0
    ) const
    {
        RectF   layoutRect(0, 0, layoutRectSize.Width, layoutRectSize.Height);
        RectF   boundingBox;
        Status  status;

        if (size == NULL)
        {
            return SetStatus(InvalidParameter);
        }

        status = SetStatus(DllExports::GdipMeasureString(
            nativeGraphics,
            string,
            length,
            font ? font->nativeFont : NULL,
            &layoutRect,
            stringFormat ? stringFormat->nativeFormat : NULL,
            size ? &boundingBox : NULL,
            codepointsFitted,
            linesFilled
        ));

        if (size && status == Ok)
        {
            size->Width  = boundingBox.Width;
            size->Height = boundingBox.Height;
        }

        return status;
    }

    Status
    MeasureString(
        IN const WCHAR        *string,
        IN INT                 length,
        IN const Font         *font,
        IN const PointF       &origin,
        IN const StringFormat *stringFormat,
        OUT RectF             *boundingBox
    ) const
    {
        RectF rect(origin.X, origin.Y, 0.0f, 0.0f);

        return SetStatus(DllExports::GdipMeasureString(
            nativeGraphics,
            string,
            length,
            font ? font->nativeFont : NULL,
            &rect,
            stringFormat ? stringFormat->nativeFormat : NULL,
            boundingBox,
            NULL,
            NULL
        ));
    }

    Status
    MeasureString(
        IN const WCHAR  *string,
        IN INT           length,
        IN const Font   *font,
        IN const RectF  &layoutRect,
        OUT RectF       *boundingBox
    ) const
    {
        return SetStatus(DllExports::GdipMeasureString(
            nativeGraphics,
            string,
            length,
            font ? font->nativeFont : NULL,
            &layoutRect,
            NULL,
            boundingBox,
            NULL,
            NULL
        ));
    }

    Status
    MeasureString(
        IN const WCHAR  *string,
        IN INT           length,
        IN const Font   *font,
        IN const PointF &origin,
        OUT RectF       *boundingBox
    ) const
    {
        RectF rect(origin.X, origin.Y, 0.0f, 0.0f);

        return SetStatus(DllExports::GdipMeasureString(
            nativeGraphics,
            string,
            length,
            font ? font->nativeFont : NULL,
            &rect,
            NULL,
            boundingBox,
            NULL,
            NULL
        ));
    }


    Status
    MeasureCharacterRanges(
        IN const WCHAR        *string,
        IN INT                 length,
        IN const Font         *font,
        IN const RectF        &layoutRect,
        IN const StringFormat *stringFormat,
        IN INT                 regionCount,
        OUT Region            *regions
    ) const
    {
        if (!regions || regionCount <= 0)
        {
            return InvalidParameter;
        }

        GpRegion **nativeRegions = new GpRegion* [regionCount];

        if (!nativeRegions)
        {
            return OutOfMemory;
        }

        for (INT i = 0; i < regionCount; i++)
        {
            nativeRegions[i] = regions[i].nativeRegion;
        }

        Status status = SetStatus(DllExports::GdipMeasureCharacterRanges(
            nativeGraphics,
            string,
            length,
            font ? font->nativeFont : NULL,
            layoutRect,
            stringFormat ? stringFormat->nativeFormat : NULL,
            regionCount,
            nativeRegions
        ));

        delete [] nativeRegions;

        return status;
    }

    Status DrawDriverString(
        IN const UINT16  *text,
        IN INT            length,
        IN const Font    *font,
        IN const Brush   *brush,
        IN const PointF  *positions,
        IN INT            flags,
        IN const Matrix        *matrix
    )
    {
        return SetStatus(DllExports::GdipDrawDriverString(
            nativeGraphics,
            text,
            length,
            font ? font->nativeFont : NULL,
            brush ? brush->nativeBrush : NULL,
            positions,
            flags,
            matrix ? matrix->nativeMatrix : NULL
        ));
    }

    Status MeasureDriverString(
        IN const UINT16  *text,
        IN INT            length,
        IN const Font    *font,
        IN const PointF  *positions,
        IN INT            flags,
        IN const Matrix        *matrix,
        OUT RectF        *boundingBox
    ) const
    {
        return SetStatus(DllExports::GdipMeasureDriverString(
            nativeGraphics,
            text,
            length,
            font ? font->nativeFont : NULL,
            positions,
            flags,
            matrix ? matrix->nativeMatrix : NULL,
            boundingBox
        ));
    }

    // Draw a cached bitmap on this graphics destination offset by
    // x, y. Note this will fail with WrongState if the CachedBitmap
    // native format differs from this Graphics.

    Status DrawCachedBitmap(IN CachedBitmap *cb,
                            IN INT x,
                            IN INT y)
    {
        return SetStatus(DllExports::GdipDrawCachedBitmap(
            nativeGraphics,
            cb->nativeCachedBitmap,
            x, y
        ));
    }

    Status DrawImage(IN Image* image,
                     IN const PointF& point)
    {
        return DrawImage(image, point.X, point.Y);
    }

    Status DrawImage(IN Image* image,
                     IN REAL x,
                     IN REAL y)
    {
        return SetStatus(DllExports::GdipDrawImage(nativeGraphics,
                                                   image ? image->nativeImage
                                                         : NULL,
                                                   x,
                                                   y));
    }

    Status DrawImage(IN Image* image, 
                     IN const RectF& rect)
    {
        return DrawImage(image, rect.X, rect.Y, rect.Width, rect.Height);
    }

    Status DrawImage(IN Image* image,
                     IN REAL x,
                     IN REAL y,
                     IN REAL width,
                     IN REAL height)
    {
        return SetStatus(DllExports::GdipDrawImageRect(nativeGraphics,
                                                       image ? image->nativeImage
                                                             : NULL,
                                                       x,
                                                       y,
                                                       width,
                                                       height));
    }

    Status DrawImage(IN Image* image,
                     IN const Point& point)
    {
        return DrawImage(image, point.X, point.Y);
    }

    Status DrawImage(IN Image* image,
                     IN INT x,
                     IN INT y)
    {
        return SetStatus(DllExports::GdipDrawImageI(nativeGraphics,
                                                    image ? image->nativeImage
                                                          : NULL,
                                                    x,
                                                    y));
    }

    Status DrawImage(IN Image* image,
                     IN const Rect& rect)
    {
        return DrawImage(image,
                         rect.X,
                         rect.Y,
                         rect.Width,
                         rect.Height);
    }

    Status DrawImage(IN Image* image,
                     IN INT x,
                     IN INT y,
                     IN INT width,
                     IN INT height) {
        return SetStatus(DllExports::GdipDrawImageRectI(nativeGraphics,
                                                        image ? image->nativeImage
                                                              : NULL,
                                                        x,
                                                        y,
                                                        width,
                                                        height));
    }

    
    // Affine Draw Image
    // destPoints.length = 3: rect => parallelogram
    //     destPoints[0] <=> top-left corner of the source rectangle
    //     destPoints[1] <=> top-right corner
    //     destPoints[2] <=> bottom-left corner
    // destPoints.length = 4: rect => quad
    //     destPoints[3] <=> bottom-right corner
    
    Status DrawImage(IN Image* image,
                     IN const PointF* destPoints,
                     IN INT count)
    {
        if (count != 3 && count != 4)
            return SetStatus(InvalidParameter);

        return SetStatus(DllExports::GdipDrawImagePoints(nativeGraphics,
                                                         image ? image->nativeImage
                                                               : NULL,
                                                         destPoints, count));
    }

    Status DrawImage(IN Image* image,
                     IN const Point* destPoints,
                     IN INT count)
    {
        if (count != 3 && count != 4)
            return SetStatus(InvalidParameter);

        return SetStatus(DllExports::GdipDrawImagePointsI(nativeGraphics,
                                                          image ? image->nativeImage
                                                                : NULL,
                                                          destPoints,
                                                          count));
    }

    Status DrawImage(IN Image* image,
                     IN REAL x,
                     IN REAL y,
                     IN REAL srcx,
                     IN REAL srcy,
                     IN REAL srcwidth,
                     IN REAL srcheight,
                     IN Unit srcUnit)
    {
        return SetStatus(DllExports::GdipDrawImagePointRect(nativeGraphics,
                                                            image ? image->nativeImage
                                                                  : NULL,
                                                            x, y,
                                                            srcx, srcy,
                                                            srcwidth, srcheight, srcUnit));
    }

    Status DrawImage(IN Image* image,
                     IN const RectF& destRect,
                     IN REAL srcx,
                     IN REAL srcy,
                     IN REAL srcwidth,
                     IN REAL srcheight,
                     IN Unit srcUnit,
                     IN const ImageAttributes* imageAttributes = NULL,
                     IN DrawImageAbort callback = NULL,
                     IN VOID* callbackData = NULL)
    {
        return SetStatus(DllExports::GdipDrawImageRectRect(nativeGraphics,
                                                           image ? image->nativeImage
                                                                 : NULL,
                                                           destRect.X,
                                                           destRect.Y,
                                                           destRect.Width,
                                                           destRect.Height,
                                                           srcx, srcy,
                                                           srcwidth, srcheight,
                                                           srcUnit,
                                                           imageAttributes
                                                            ? imageAttributes->nativeImageAttr
                                                            : NULL,
                                                           callback,
                                                           callbackData));
    }

    Status DrawImage(IN Image* image,
                     IN const PointF* destPoints,
                     IN INT count,
                     IN REAL srcx,
                     IN REAL srcy,
                     IN REAL srcwidth,
                     IN REAL srcheight,
                     IN Unit srcUnit,
                     IN const ImageAttributes* imageAttributes = NULL,
                     IN DrawImageAbort callback = NULL,
                     IN VOID* callbackData = NULL)
    {
        return SetStatus(DllExports::GdipDrawImagePointsRect(nativeGraphics,
                                                             image ? image->nativeImage
                                                                   : NULL,
                                                             destPoints, count,
                                                             srcx, srcy,
                                                             srcwidth,
                                                             srcheight,
                                                             srcUnit,
                                                             imageAttributes
                                                              ? imageAttributes->nativeImageAttr
                                                              : NULL,
                                                             callback,
                                                             callbackData));
    }

    Status DrawImage(IN Image* image,
                     IN INT x,
                     IN INT y,
                     IN INT srcx,
                     IN INT srcy,
                     IN INT srcwidth,
                     IN INT srcheight,
                     IN Unit srcUnit)
    {
        return SetStatus(DllExports::GdipDrawImagePointRectI(nativeGraphics,
                                                             image ? image->nativeImage
                                                                   : NULL,
                                                             x,
                                                             y,
                                                             srcx,
                                                             srcy,
                                                             srcwidth,
                                                             srcheight,
                                                             srcUnit));
    }

    Status DrawImage(IN Image* image,
                     IN const Rect& destRect,
                     IN INT srcx,
                     IN INT srcy,
                     IN INT srcwidth,
                     IN INT srcheight,
                     IN Unit srcUnit,
                     IN const ImageAttributes* imageAttributes = NULL,
                     IN DrawImageAbort callback = NULL,
                     IN VOID* callbackData = NULL)
    {
        return SetStatus(DllExports::GdipDrawImageRectRectI(nativeGraphics,
                                                            image ? image->nativeImage
                                                                  : NULL,
                                                            destRect.X,
                                                            destRect.Y,
                                                            destRect.Width,
                                                            destRect.Height,
                                                            srcx,
                                                            srcy,
                                                            srcwidth,
                                                            srcheight,
                                                            srcUnit,
                                                            imageAttributes
                                                            ? imageAttributes->nativeImageAttr
                                                            : NULL,
                                                            callback,
                                                            callbackData));
    }

    Status DrawImage(IN Image* image,
                     IN const Point* destPoints,
                     IN INT count,
                     IN INT srcx,
                     IN INT srcy,
                     IN INT srcwidth,
                     IN INT srcheight,
                     IN Unit srcUnit,
                     IN const ImageAttributes* imageAttributes = NULL,
                     IN DrawImageAbort callback = NULL,
                     IN VOID* callbackData = NULL)
    {
        return SetStatus(DllExports::GdipDrawImagePointsRectI(nativeGraphics,
                                                              image ? image->nativeImage
                                                                    : NULL,
                                                              destPoints,
                                                              count,
                                                              srcx,
                                                              srcy,
                                                              srcwidth,
                                                              srcheight,
                                                              srcUnit,
                                                              imageAttributes
                                                               ? imageAttributes->nativeImageAttr
                                                               : NULL,
                                                              callback,
                                                              callbackData));
    }

    // The following methods are for playing an EMF+ to a graphics
    // via the enumeration interface.  Each record of the EMF+ is
    // sent to the callback (along with the callbackData).  Then
    // the callback can invoke the Metafile::PlayRecord method
    // to play the particular record.

    Status
    EnumerateMetafile(
        IN const Metafile *        metafile,
        IN const PointF &          destPoint,
        IN EnumerateMetafileProc   callback,
        IN VOID *                  callbackData    = NULL,
        IN const ImageAttributes *       imageAttributes = NULL
        )
    {
        return SetStatus(DllExports::GdipEnumerateMetafileDestPoint(
                    nativeGraphics,
                    (const GpMetafile *)(metafile ? metafile->nativeImage:NULL),
                    destPoint,
                    callback,
                    callbackData,
                    imageAttributes ? imageAttributes->nativeImageAttr : NULL));
    }

    Status
    EnumerateMetafile(
        IN const Metafile *        metafile,
        IN const Point &           destPoint,
        IN EnumerateMetafileProc   callback,
        IN VOID *                  callbackData    = NULL,
        IN const ImageAttributes *       imageAttributes = NULL
        )
    {
        return SetStatus(DllExports::GdipEnumerateMetafileDestPointI(
                    nativeGraphics,
                    (const GpMetafile *)(metafile ? metafile->nativeImage:NULL),
                    destPoint,
                    callback,
                    callbackData,
                    imageAttributes ? imageAttributes->nativeImageAttr : NULL));
    }

    Status
    EnumerateMetafile(
        IN const Metafile *        metafile,
        IN const RectF &           destRect,
        IN EnumerateMetafileProc   callback,
        IN VOID *                  callbackData    = NULL,
        IN const ImageAttributes *       imageAttributes = NULL
        )
    {
        return SetStatus(DllExports::GdipEnumerateMetafileDestRect(
                    nativeGraphics,
                    (const GpMetafile *)(metafile ? metafile->nativeImage:NULL),
                    destRect,
                    callback,
                    callbackData,
                    imageAttributes ? imageAttributes->nativeImageAttr : NULL));
    }

    Status
    EnumerateMetafile(
        IN const Metafile *        metafile,
        IN const Rect &            destRect,
        IN EnumerateMetafileProc   callback,
        IN VOID *                  callbackData    = NULL,
        IN const ImageAttributes *       imageAttributes = NULL
        )
    {
        return SetStatus(DllExports::GdipEnumerateMetafileDestRectI(
                    nativeGraphics,
                    (const GpMetafile *)(metafile ? metafile->nativeImage:NULL),
                    destRect,
                    callback,
                    callbackData,
                    imageAttributes ? imageAttributes->nativeImageAttr : NULL));
    }

    Status
    EnumerateMetafile(
        IN const Metafile *        metafile,
        IN const PointF *          destPoints,
        IN INT                     count,
        IN EnumerateMetafileProc   callback,
        IN VOID *                  callbackData    = NULL,
        IN const ImageAttributes *       imageAttributes = NULL
        )
    {
        return SetStatus(DllExports::GdipEnumerateMetafileDestPoints(
                    nativeGraphics,
                    (const GpMetafile *)(metafile ? metafile->nativeImage:NULL),
                    destPoints,
                    count,
                    callback,
                    callbackData,
                    imageAttributes ? imageAttributes->nativeImageAttr : NULL));
    }

    Status
    EnumerateMetafile(
        IN const Metafile *        metafile,
        IN const Point *           destPoints,
        IN INT                     count,
        IN EnumerateMetafileProc   callback,
        IN VOID *                  callbackData    = NULL,
        IN const ImageAttributes *       imageAttributes = NULL
        )
    {
        return SetStatus(DllExports::GdipEnumerateMetafileDestPointsI(
                    nativeGraphics,
                    (const GpMetafile *)(metafile ? metafile->nativeImage:NULL),
                    destPoints,
                    count,
                    callback,
                    callbackData,
                    imageAttributes ? imageAttributes->nativeImageAttr : NULL));
    }

    Status
    EnumerateMetafile(
        IN const Metafile *        metafile,
        IN const PointF &          destPoint,
        IN const RectF &           srcRect,
        IN Unit                    srcUnit,
        IN EnumerateMetafileProc   callback,
        IN VOID *                  callbackData    = NULL,
        IN const ImageAttributes *       imageAttributes = NULL
        )
    {
        return SetStatus(DllExports::GdipEnumerateMetafileSrcRectDestPoint(
                    nativeGraphics,
                    (const GpMetafile *)(metafile ? metafile->nativeImage:NULL),
                    destPoint,
                    srcRect,
                    srcUnit,
                    callback,
                    callbackData,
                    imageAttributes ? imageAttributes->nativeImageAttr : NULL));
    }

    Status
    EnumerateMetafile(
        IN const Metafile *        metafile,
        IN const Point &           destPoint,
        IN const Rect &            srcRect,
        IN Unit                    srcUnit,
        IN EnumerateMetafileProc   callback,
        IN VOID *                  callbackData    = NULL,
        IN const ImageAttributes *       imageAttributes = NULL
        )
    {
        return SetStatus(DllExports::GdipEnumerateMetafileSrcRectDestPointI(
                    nativeGraphics,
                    (const GpMetafile *)(metafile ? metafile->nativeImage:NULL),
                    destPoint,
                    srcRect,
                    srcUnit,
                    callback,
                    callbackData,
                    imageAttributes ? imageAttributes->nativeImageAttr : NULL));
    }

    Status
    EnumerateMetafile(
        IN const Metafile *        metafile,
        IN const RectF &           destRect,
        IN const RectF &           srcRect,
        IN Unit                    srcUnit,
        IN EnumerateMetafileProc   callback,
        IN VOID *                  callbackData    = NULL,
        IN const ImageAttributes *       imageAttributes = NULL
        )
    {
        return SetStatus(DllExports::GdipEnumerateMetafileSrcRectDestRect(
                    nativeGraphics,
                    (const GpMetafile *)(metafile ? metafile->nativeImage:NULL),
                    destRect,
                    srcRect,
                    srcUnit,
                    callback,
                    callbackData,
                    imageAttributes ? imageAttributes->nativeImageAttr : NULL));
    }

    Status
    EnumerateMetafile(
        IN const Metafile *        metafile,
        IN const Rect &            destRect,
        IN const Rect &            srcRect,
        IN Unit                    srcUnit,
        IN EnumerateMetafileProc   callback,
        IN VOID *                  callbackData    = NULL,
        IN const ImageAttributes *       imageAttributes = NULL
        )
    {
        return SetStatus(DllExports::GdipEnumerateMetafileSrcRectDestRectI(
                    nativeGraphics,
                    (const GpMetafile *)(metafile ? metafile->nativeImage:NULL),
                    destRect,
                    srcRect,
                    srcUnit,
                    callback,
                    callbackData,
                    imageAttributes ? imageAttributes->nativeImageAttr : NULL));
    }

    Status
    EnumerateMetafile(
        IN const Metafile *        metafile,
        IN const PointF *          destPoints,
        IN INT                     count,
        IN const RectF &           srcRect,
        IN Unit                    srcUnit,
        IN EnumerateMetafileProc   callback,
        IN VOID *                  callbackData    = NULL,
        IN const ImageAttributes *       imageAttributes = NULL
        )
    {
        return SetStatus(DllExports::GdipEnumerateMetafileSrcRectDestPoints(
                    nativeGraphics,
                    (const GpMetafile *)(metafile ? metafile->nativeImage:NULL),
                    destPoints,
                    count,
                    srcRect,
                    srcUnit,
                    callback,
                    callbackData,
                    imageAttributes ? imageAttributes->nativeImageAttr : NULL));
    }

    Status
    EnumerateMetafile(
        IN const Metafile *        metafile,
        IN const Point *           destPoints,
        IN INT                     count,
        IN const Rect &            srcRect,
        IN Unit                    srcUnit,
        IN EnumerateMetafileProc   callback,
        IN VOID *                  callbackData    = NULL,
        IN const ImageAttributes *       imageAttributes = NULL
        )
    {
        return SetStatus(DllExports::GdipEnumerateMetafileSrcRectDestPointsI(
                    nativeGraphics,
                    (const GpMetafile *)(metafile ? metafile->nativeImage:NULL),
                    destPoints,
                    count,
                    srcRect,
                    srcUnit,
                    callback,
                    callbackData,
                    imageAttributes ? imageAttributes->nativeImageAttr : NULL));
    }
    
    Status SetClip(IN const Graphics* g,
                   IN CombineMode combineMode = CombineModeReplace)
    {
        return SetStatus(DllExports::GdipSetClipGraphics(nativeGraphics,
                                                         g->nativeGraphics,
                                                         combineMode));
    }

    Status SetClip(IN const RectF& rect,
                   IN CombineMode combineMode = CombineModeReplace)
    {
        return SetStatus(DllExports::GdipSetClipRect(nativeGraphics,
                                                     rect.X, rect.Y,
                                                     rect.Width, rect.Height,
                                                     combineMode));
    }

    Status SetClip(IN const Rect& rect,
                   IN CombineMode combineMode = CombineModeReplace)
    {
        return SetStatus(DllExports::GdipSetClipRectI(nativeGraphics,
                                                      rect.X, rect.Y,
                                                      rect.Width, rect.Height,
                                                      combineMode));
    }

    Status SetClip(IN const GraphicsPath* path,
                   IN CombineMode combineMode = CombineModeReplace)
    {
        return SetStatus(DllExports::GdipSetClipPath(nativeGraphics,
                                                     path->nativePath,
                                                     combineMode));
    }

    Status SetClip(IN const Region* region,
                   IN CombineMode combineMode = CombineModeReplace)
    {
        return SetStatus(DllExports::GdipSetClipRegion(nativeGraphics,
                                                       region->nativeRegion,
                                                       combineMode));
    }

    // This is different than the other SetClip methods because it assumes
    // that the HRGN is already in device units, so it doesn't transform
    // the coordinates in the HRGN.
    
    Status SetClip(IN HRGN hRgn,
                   IN CombineMode combineMode = CombineModeReplace)
    {
        return SetStatus(DllExports::GdipSetClipHrgn(nativeGraphics, hRgn,
                                                     combineMode));
    }

    Status IntersectClip(IN const RectF& rect)
    {
        return SetStatus(DllExports::GdipSetClipRect(nativeGraphics,
                                                     rect.X, rect.Y,
                                                     rect.Width, rect.Height,
                                                     CombineModeIntersect));
    }

    Status IntersectClip(IN const Rect& rect)
    {
        return SetStatus(DllExports::GdipSetClipRectI(nativeGraphics,
                                                      rect.X, rect.Y,
                                                      rect.Width, rect.Height,
                                                      CombineModeIntersect));
    }

    Status IntersectClip(IN const Region* region)
    {
        return SetStatus(DllExports::GdipSetClipRegion(nativeGraphics,
                                                       region->nativeRegion,
                                                       CombineModeIntersect));
    }

    Status ExcludeClip(IN const RectF& rect)
    {
        return SetStatus(DllExports::GdipSetClipRect(nativeGraphics,
                                                     rect.X, rect.Y,
                                                     rect.Width, rect.Height,
                                                     CombineModeExclude));
    }

    Status ExcludeClip(IN const Rect& rect)
    {
        return SetStatus(DllExports::GdipSetClipRectI(nativeGraphics,
                                                      rect.X, rect.Y,
                                                      rect.Width, rect.Height,
                                                      CombineModeExclude));
    }

    Status ExcludeClip(IN const Region* region)
    {
        return SetStatus(DllExports::GdipSetClipRegion(nativeGraphics,
                                                       region->nativeRegion,
                                                       CombineModeExclude));
    }

    Status ResetClip()
    {
        return SetStatus(DllExports::GdipResetClip(nativeGraphics));
    }

    Status TranslateClip(IN REAL dx,
                         IN REAL dy)
    {
        return SetStatus(DllExports::GdipTranslateClip(nativeGraphics, dx, dy));
    }

    Status TranslateClip(IN INT dx,
                         IN INT dy)
    {
        return SetStatus(DllExports::GdipTranslateClipI(nativeGraphics,
                                                        dx, dy));
    }

    Status GetClip(OUT Region* region) const
    {
        return SetStatus(DllExports::GdipGetClip(nativeGraphics,
                                                 region->nativeRegion));
    }

    Status GetClipBounds(OUT RectF* rect) const
    {
        return SetStatus(DllExports::GdipGetClipBounds(nativeGraphics, rect));
    }

    Status GetClipBounds(OUT Rect* rect) const
    {
        return SetStatus(DllExports::GdipGetClipBoundsI(nativeGraphics, rect));
    }

    BOOL IsClipEmpty() const
    {
        BOOL booln = FALSE;

        SetStatus(DllExports::GdipIsClipEmpty(nativeGraphics, &booln));

        return booln;
    }

    Status GetVisibleClipBounds(OUT RectF *rect) const
    {

        return SetStatus(DllExports::GdipGetVisibleClipBounds(nativeGraphics,
                                                              rect));
    }

    Status GetVisibleClipBounds(OUT Rect *rect) const
    {
       return SetStatus(DllExports::GdipGetVisibleClipBoundsI(nativeGraphics,
                                                              rect));
    }

    BOOL IsVisibleClipEmpty() const
    {
        BOOL booln = FALSE;

        SetStatus(DllExports::GdipIsVisibleClipEmpty(nativeGraphics, &booln));

        return booln;
    }

    BOOL IsVisible(IN INT x,
                   IN INT y) const
    {
        return IsVisible(Point(x,y));
    }

    BOOL IsVisible(IN const Point& point) const
    {
        BOOL booln = FALSE;

        SetStatus(DllExports::GdipIsVisiblePointI(nativeGraphics,
                                                  point.X,
                                                  point.Y,
                                                  &booln));

        return booln;
    }

    BOOL IsVisible(IN INT x,
                   IN INT y,
                   IN INT width,
                   IN INT height) const
    {
        return IsVisible(Rect(x, y, width, height));
    }

    BOOL IsVisible(IN const Rect& rect) const
    {

        BOOL booln = TRUE;

        SetStatus(DllExports::GdipIsVisibleRectI(nativeGraphics,
                                                 rect.X,
                                                 rect.Y,
                                                 rect.Width,
                                                 rect.Height,
                                                 &booln));
        return booln;
    }

    BOOL IsVisible(IN REAL x,
                   IN REAL y) const
    {
        return IsVisible(PointF(x, y));
    }

    BOOL IsVisible(IN const PointF& point) const
    {
        BOOL booln = FALSE;

        SetStatus(DllExports::GdipIsVisiblePoint(nativeGraphics,
                                                 point.X,
                                                 point.Y,
                                                 &booln));

        return booln;
    }

    BOOL IsVisible(IN REAL x,
                   IN REAL y,
                   IN REAL width,
                   IN REAL height) const
    {
        return IsVisible(RectF(x, y, width, height));
    }

    BOOL IsVisible(IN const RectF& rect) const
    {
        BOOL booln = TRUE;

        SetStatus(DllExports::GdipIsVisibleRect(nativeGraphics,
                                                rect.X,
                                                rect.Y,
                                                rect.Width,
                                                rect.Height,
                                                &booln));
        return booln;
    }

    GraphicsState Save() const
    {
        GraphicsState gstate;

        SetStatus(DllExports::GdipSaveGraphics(nativeGraphics, &gstate));

        return gstate;
    }

    Status Restore(IN GraphicsState gstate)
    {
        return SetStatus(DllExports::GdipRestoreGraphics(nativeGraphics,
                                                         gstate));
    }

    GraphicsContainer BeginContainer(IN const RectF &dstrect,
                                     IN const RectF &srcrect,
                                     IN Unit         unit)
    {
        GraphicsContainer state;

        SetStatus(DllExports::GdipBeginContainer(nativeGraphics, &dstrect,
                                                 &srcrect, unit, &state));

        return state;
    }

    GraphicsContainer BeginContainer(IN const Rect    &dstrect,
                                     IN const Rect    &srcrect,
                                     IN Unit           unit)
    {
        GraphicsContainer state;

        SetStatus(DllExports::GdipBeginContainerI(nativeGraphics, &dstrect,
                                                  &srcrect, unit, &state));

        return state;
    }

    GraphicsContainer BeginContainer()
    {
        GraphicsContainer state;

        SetStatus(DllExports::GdipBeginContainer2(nativeGraphics, &state));

        return state;
    }

    Status EndContainer(IN GraphicsContainer state)
    {
        return SetStatus(DllExports::GdipEndContainer(nativeGraphics, state));
    }

    // Only valid when recording metafiles.

    Status AddMetafileComment(IN const BYTE * data,
                              IN UINT sizeData)
    {
        return SetStatus(DllExports::GdipComment(nativeGraphics, sizeData, data));
    }

    static HPALETTE GetHalftonePalette()
    {
        return DllExports::GdipCreateHalftonePalette();
    }

    Status GetLastStatus() const
    {
        Status lastStatus = lastResult;
        lastResult = Ok;

        return lastStatus;
    }

private:
    Graphics(const Graphics &);
    Graphics& operator=(const Graphics &);

protected:
    Graphics(GpGraphics* graphics)
    {
        lastResult = Ok;
        SetNativeGraphics(graphics);
    }

    VOID SetNativeGraphics(GpGraphics *graphics)
    {
        this->nativeGraphics = graphics;
    }

    Status SetStatus(Status status) const
    {
        if (status != Ok)
            return (lastResult = status);
        else
            return status;
    }

    GpGraphics* GetNativeGraphics() const
    {
        return this->nativeGraphics;
    }

    GpPen* GetNativePen(const Pen* pen)
    {
        return pen->nativePen;
    }

protected:
    GpGraphics* nativeGraphics;
    mutable Status lastResult;

};

//----------------------------------------------------------------------------
// Implementation of GraphicsPath methods that use Graphics
//----------------------------------------------------------------------------

// The GetBounds rectangle may not be the tightest bounds.

inline Status
GraphicsPath::GetBounds(
    OUT RectF* bounds,
    IN const Matrix* matrix,
    IN const Pen* pen) const
{
    GpMatrix* nativeMatrix = NULL;
    GpPen* nativePen = NULL;

    if (matrix)
        nativeMatrix = matrix->nativeMatrix;

    if (pen)
        nativePen = pen->nativePen;

    return SetStatus(DllExports::GdipGetPathWorldBounds(nativePath, bounds,
                                                   nativeMatrix, nativePen));
}

inline Status
GraphicsPath::GetBounds(
    OUT Rect* bounds,
    IN const Matrix* matrix,
    IN const Pen* pen
) const
{
    GpMatrix* nativeMatrix = NULL;
    GpPen* nativePen = NULL;

    if (matrix)
        nativeMatrix = matrix->nativeMatrix;

    if (pen)
        nativePen = pen->nativePen;

    return SetStatus(DllExports::GdipGetPathWorldBoundsI(nativePath, bounds,
                                                    nativeMatrix, nativePen));
}

inline BOOL
GraphicsPath::IsVisible(
    IN REAL x,
    IN REAL y,
    IN const Graphics* g) const
{
   BOOL booln = FALSE;

   GpGraphics* nativeGraphics = NULL;

   if (g)
       nativeGraphics = g->nativeGraphics;

   SetStatus(DllExports::GdipIsVisiblePathPoint(nativePath,
                                                x, y, nativeGraphics,
                                                &booln));
   return booln;
}

inline BOOL
GraphicsPath::IsVisible(
    IN INT x,
    IN INT y,
    IN const Graphics* g) const
{
   BOOL booln = FALSE;

   GpGraphics* nativeGraphics = NULL;

   if (g)
       nativeGraphics = g->nativeGraphics;

   SetStatus(DllExports::GdipIsVisiblePathPointI(nativePath,
                                                 x, y, nativeGraphics,
                                                 &booln));
   return booln;
}

inline BOOL
GraphicsPath::IsOutlineVisible(
    IN REAL x,
    IN REAL y,
    IN const Pen* pen,
    IN const Graphics* g) const
{
    BOOL booln = FALSE;

    GpGraphics* nativeGraphics = NULL;
    GpPen* nativePen = NULL;

    if(g)
        nativeGraphics = g->nativeGraphics;
    if(pen)
        nativePen = pen->nativePen;

    SetStatus(DllExports::GdipIsOutlineVisiblePathPoint(nativePath,
                                                        x, y, nativePen, nativeGraphics,
                                                        &booln));
    return booln;
}

inline BOOL
GraphicsPath::IsOutlineVisible(
    IN INT x,
    IN INT y,
    IN const Pen* pen,
    IN const Graphics* g) const
{
    BOOL booln = FALSE;

    GpGraphics* nativeGraphics = NULL;
    GpPen* nativePen = NULL;

    if(g)
        nativeGraphics = g->nativeGraphics;
    if(pen)
        nativePen = pen->nativePen;

    SetStatus(DllExports::GdipIsOutlineVisiblePathPointI(nativePath,
                                                         x, y, nativePen, nativeGraphics,
                                                         &booln));
    return booln;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\sdkinc\gdiplusimageattributes.h ===
/**************************************************************************\
*
* Copyright (c) 1998-2001, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   Image Attributes
*
* Abstract:
*
*   GDI+ Image Attributes used with Graphics.DrawImage
*
* There are 5 possible sets of color adjustments:
*          ColorAdjustDefault,
*          ColorAdjustBitmap,
*          ColorAdjustBrush,
*          ColorAdjustPen,
*          ColorAdjustText,
*
* Bitmaps, Brushes, Pens, and Text will all use any color adjustments
* that have been set into the default ImageAttributes until their own
* color adjustments have been set.  So as soon as any "Set" method is
* called for Bitmaps, Brushes, Pens, or Text, then they start from
* scratch with only the color adjustments that have been set for them.
* Calling Reset removes any individual color adjustments for a type
* and makes it revert back to using all the default color adjustments
* (if any).  The SetToIdentity method is a way to force a type to
* have no color adjustments at all, regardless of what previous adjustments
* have been set for the defaults or for that type.
*
\********************************************************************F******/

#ifndef _GDIPLUSIMAGEATTRIBUTES_H
#define _GDIPLUSIMAGEATTRIBUTES_H

class GpImageAttributes;

class ImageAttributes : public GdiplusBase
{
    friend class Graphics;
    friend class TextureBrush;

public:

    ImageAttributes()
    {
        nativeImageAttr = NULL;
        lastResult = DllExports::GdipCreateImageAttributes(&nativeImageAttr);
    }

    ~ImageAttributes()
    {
        DllExports::GdipDisposeImageAttributes(nativeImageAttr);
    }

    ImageAttributes* Clone() const
    {
        GpImageAttributes* clone;

        SetStatus(DllExports::GdipCloneImageAttributes(
                                            nativeImageAttr,
                                            &clone));

        return new ImageAttributes(clone, lastResult);
    }

    Status
    SetToIdentity(
        IN ColorAdjustType type = ColorAdjustTypeDefault
        )
    {
        return SetStatus(DllExports::GdipSetImageAttributesToIdentity(
                                            nativeImageAttr,
                                            type));
    }

    Status
    Reset(
        IN ColorAdjustType type = ColorAdjustTypeDefault
        )
    {
        return SetStatus(DllExports::GdipResetImageAttributes(
                                            nativeImageAttr,
                                            type));
    }

    Status
    SetColorMatrix(
        IN const ColorMatrix *colorMatrix,
        IN ColorMatrixFlags mode = ColorMatrixFlagsDefault,
        IN ColorAdjustType type = ColorAdjustTypeDefault
        )
    {
        return SetStatus(DllExports::GdipSetImageAttributesColorMatrix(
                                            nativeImageAttr,
                                            type,
                                            TRUE,
                                            colorMatrix,
                                            NULL,
                                            mode));
    }

    Status ClearColorMatrix(
        IN ColorAdjustType type = ColorAdjustTypeDefault
        )
    {
        return SetStatus(DllExports::GdipSetImageAttributesColorMatrix(
                                            nativeImageAttr,
                                            type,
                                            FALSE,
                                            NULL,
                                            NULL,
                                            ColorMatrixFlagsDefault));
    }

    Status
    SetColorMatrices(
        IN const ColorMatrix *colorMatrix,
        IN const ColorMatrix *grayMatrix,
        IN ColorMatrixFlags mode = ColorMatrixFlagsDefault,
        IN ColorAdjustType type = ColorAdjustTypeDefault
        )
    {
        return SetStatus(DllExports::GdipSetImageAttributesColorMatrix(
                                            nativeImageAttr,
                                            type,
                                            TRUE,
                                            colorMatrix,
                                            grayMatrix,
                                            mode));
    }

    Status ClearColorMatrices(
        IN ColorAdjustType type = ColorAdjustTypeDefault
        )
    {
        return SetStatus(DllExports::GdipSetImageAttributesColorMatrix(
                                            nativeImageAttr,
                                            type,
                                            FALSE,
                                            NULL,
                                            NULL,
                                            ColorMatrixFlagsDefault));
    }

    Status SetThreshold(
        IN REAL threshold,
        IN ColorAdjustType type = ColorAdjustTypeDefault
        )
    {
        return SetStatus(DllExports::GdipSetImageAttributesThreshold(
                                            nativeImageAttr,
                                            type,
                                            TRUE,
                                            threshold));
    }

    Status ClearThreshold(
        IN ColorAdjustType type = ColorAdjustTypeDefault
        )
    {
        return SetStatus(DllExports::GdipSetImageAttributesThreshold(
                                            nativeImageAttr,
                                            type,
                                            FALSE,
                                            0.0));
    }

    Status SetGamma(
        IN REAL gamma,
        IN ColorAdjustType type = ColorAdjustTypeDefault
        )
    {
        return SetStatus(DllExports::GdipSetImageAttributesGamma(
                                            nativeImageAttr,
                                            type,
                                            TRUE,
                                            gamma));
    }

    Status ClearGamma(
        IN ColorAdjustType type = ColorAdjustTypeDefault
        )
    {
        return SetStatus(DllExports::GdipSetImageAttributesGamma(
                                            nativeImageAttr,
                                            type,
                                            FALSE,
                                            0.0));
    }

    Status SetNoOp(
        IN ColorAdjustType type = ColorAdjustTypeDefault
        )
    {
        return SetStatus(DllExports::GdipSetImageAttributesNoOp(
                                            nativeImageAttr,
                                            type,
                                            TRUE));
    }

    Status ClearNoOp(
        IN ColorAdjustType type = ColorAdjustTypeDefault
        )
    {
        return SetStatus(DllExports::GdipSetImageAttributesNoOp(
                                            nativeImageAttr,
                                            type,
                                            FALSE));
    }

    Status SetColorKey(
        IN const Color& colorLow, 
        IN const Color& colorHigh,
        IN ColorAdjustType type = ColorAdjustTypeDefault
        )
    {
        return SetStatus(DllExports::GdipSetImageAttributesColorKeys(
                                            nativeImageAttr,
                                            type,
                                            TRUE,
                                            colorLow.GetValue(),
                                            colorHigh.GetValue()));
    }

    Status ClearColorKey(
        IN ColorAdjustType type = ColorAdjustTypeDefault
        )
    {
        return SetStatus(DllExports::GdipSetImageAttributesColorKeys(
                                            nativeImageAttr,
                                            type,
                                            FALSE,
                                            NULL,
                                            NULL));
    }

    Status SetOutputChannel(
        IN ColorChannelFlags channelFlags,
        IN ColorAdjustType type = ColorAdjustTypeDefault
        )
    {
        return SetStatus(DllExports::GdipSetImageAttributesOutputChannel(
                                            nativeImageAttr,
                                            type,
                                            TRUE,
                                            channelFlags));
    }
    
    Status ClearOutputChannel(
        IN ColorAdjustType type = ColorAdjustTypeDefault
        )
    {
        return SetStatus(DllExports::GdipSetImageAttributesOutputChannel(
                                            nativeImageAttr,
                                            type,
                                            FALSE,
                                            ColorChannelFlagsLast));
    }

    Status SetOutputChannelColorProfile(
        IN const WCHAR *colorProfileFilename,
        IN ColorAdjustType type = ColorAdjustTypeDefault
        )
    {
        return SetStatus(DllExports::GdipSetImageAttributesOutputChannelColorProfile(
                                            nativeImageAttr,
                                            type,
                                            TRUE,
                                            colorProfileFilename));
    }
    
    Status ClearOutputChannelColorProfile(
        IN ColorAdjustType type = ColorAdjustTypeDefault
        )
    {
        return SetStatus(DllExports::GdipSetImageAttributesOutputChannelColorProfile(
                                            nativeImageAttr,
                                            type,
                                            FALSE,
                                            NULL));
    }
    
    Status SetRemapTable(
        IN UINT mapSize, 
        IN const ColorMap *map,
        IN ColorAdjustType type = ColorAdjustTypeDefault
        )
    {
        return SetStatus(DllExports::GdipSetImageAttributesRemapTable(
                                            nativeImageAttr,
                                            type,
                                            TRUE,
                                            mapSize,
                                            map));
    }

    Status ClearRemapTable(
        IN ColorAdjustType type = ColorAdjustTypeDefault
        )
    {
        return SetStatus(DllExports::GdipSetImageAttributesRemapTable(
                                            nativeImageAttr,
                                            type,
                                            FALSE,
                                            0,
                                            NULL));
    }

    Status SetBrushRemapTable(IN UINT mapSize, 
                              IN const ColorMap *map)
    {
        return this->SetRemapTable(mapSize, map, ColorAdjustTypeBrush);
    }

    Status ClearBrushRemapTable()
    {
        return this->ClearRemapTable(ColorAdjustTypeBrush);
    }

    Status SetWrapMode(IN WrapMode wrap, 
                       IN const Color& color = Color(), 
                       IN BOOL clamp = FALSE) 
    {
        ARGB argb = color.GetValue();

        return SetStatus(DllExports::GdipSetImageAttributesWrapMode(
                           nativeImageAttr, wrap, argb, clamp));
    }

    // The flags of the palette are ignored.

    Status GetAdjustedPalette(IN OUT ColorPalette* colorPalette,
                              IN ColorAdjustType colorAdjustType) const 
    {
        return SetStatus(DllExports::GdipGetImageAttributesAdjustedPalette(
                           nativeImageAttr, colorPalette, colorAdjustType));
    }

    Status GetLastStatus() const
    {
        Status lastStatus = lastResult;
        lastResult = Ok;
    
        return lastStatus;
    }
    
private:
    ImageAttributes(const ImageAttributes &);
    ImageAttributes& operator=(const ImageAttributes &);

protected:
    ImageAttributes(GpImageAttributes* imageAttr, Status status)
    {
        SetNativeImageAttr(imageAttr);
        lastResult = status;
    }

    VOID SetNativeImageAttr(GpImageAttributes* nativeImageAttr)
    {
        this->nativeImageAttr = nativeImageAttr;
    }
    
    Status SetStatus(Status status) const
    {
        if (status != Ok)
            return (lastResult = status);
        else 
            return status;
    }

protected:
    GpImageAttributes* nativeImageAttr;
    mutable Status lastResult;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\sdkinc\gdiplusinit.h ===
/**************************************************************************
*
* Copyright (c) 2000-2001 Microsoft Corporation
*
* Module Name:
*
*   Gdiplus initialization
*
* Abstract:
*
*   GDI+ Startup and Shutdown APIs
*
**************************************************************************/

#ifndef _GDIPLUSINIT_H
#define _GDIPLUSINIT_H

enum DebugEventLevel
{
    DebugEventLevelFatal,
    DebugEventLevelWarning
};

// Callback function that GDI+ can call, on debug builds, for assertions
// and warnings.

typedef VOID (WINAPI *DebugEventProc)(DebugEventLevel level, CHAR *message);

// Notification functions which the user must call appropriately if
// "SuppressBackgroundThread" (below) is set.

typedef Status (WINAPI *NotificationHookProc)(OUT ULONG_PTR *token);
typedef VOID (WINAPI *NotificationUnhookProc)(ULONG_PTR token);

// Input structure for GdiplusStartup()

struct GdiplusStartupInput
{
    UINT32 GdiplusVersion;             // Must be 1
    DebugEventProc DebugEventCallback; // Ignored on free builds
    BOOL SuppressBackgroundThread;     // FALSE unless you're prepared to call 
                                       // the hook/unhook functions properly
    BOOL SuppressExternalCodecs;       // FALSE unless you want GDI+ only to use
                                       // its internal image codecs.
    
    GdiplusStartupInput(
        DebugEventProc debugEventCallback = NULL,
        BOOL suppressBackgroundThread = FALSE,
        BOOL suppressExternalCodecs = FALSE)
    {
        GdiplusVersion = 1;
        DebugEventCallback = debugEventCallback;
        SuppressBackgroundThread = suppressBackgroundThread;
        SuppressExternalCodecs = suppressExternalCodecs;
    }
};

// Output structure for GdiplusStartup()

struct GdiplusStartupOutput
{
    // The following 2 fields are NULL if SuppressBackgroundThread is FALSE.
    // Otherwise, they are functions which must be called appropriately to
    // replace the background thread.
    //
    // These should be called on the application's main message loop - i.e.
    // a message loop which is active for the lifetime of GDI+.
    // "NotificationHook" should be called before starting the loop,
    // and "NotificationUnhook" should be called after the loop ends.
    
    NotificationHookProc NotificationHook;
    NotificationUnhookProc NotificationUnhook;
};

// GDI+ initialization. Must not be called from DllMain - can cause deadlock.
//
// Must be called before GDI+ API's or constructors are used.
//
// token  - may not be NULL - accepts a token to be passed in the corresponding
//          GdiplusShutdown call.
// input  - may not be NULL
// output - may be NULL only if input->SuppressBackgroundThread is FALSE.

extern "C" Status WINAPI GdiplusStartup(
    OUT ULONG_PTR *token,
    const GdiplusStartupInput *input,
    OUT GdiplusStartupOutput *output);

// GDI+ termination. Must be called before GDI+ is unloaded. 
// Must not be called from DllMain - can cause deadlock.
//
// GDI+ API's may not be called after GdiplusShutdown. Pay careful attention
// to GDI+ object destructors.

extern "C" VOID WINAPI GdiplusShutdown(ULONG_PTR token);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\sdkinc\gdipluslinecaps.h ===
/**************************************************************************\
* 
* Copyright (c) 2000-2001, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
* 
*    GdiplusLineCaps.h
*
* Abstract:
*
*   GDI+ CustomLineCap APIs
*
\**************************************************************************/

#ifndef _GDIPLUSLINECAPS_H
#define _GDIPLUSLINECAPS_H

inline 
CustomLineCap::CustomLineCap(
    IN const GraphicsPath* fillPath,
    IN const GraphicsPath* strokePath,
    IN LineCap baseCap,
    IN REAL baseInset
    )
{
    nativeCap = NULL;
    GpPath* nativeFillPath = NULL;
    GpPath* nativeStrokePath = NULL;

    if(fillPath)
        nativeFillPath = fillPath->nativePath;
    if(strokePath)
        nativeStrokePath = strokePath->nativePath;

    lastResult = DllExports::GdipCreateCustomLineCap(
                    nativeFillPath, nativeStrokePath,
                    baseCap, baseInset, &nativeCap);
}

inline 
CustomLineCap::CustomLineCap()
{
    nativeCap = NULL;
    lastResult = Ok;
}

inline 
CustomLineCap::~CustomLineCap()
{
    DllExports::GdipDeleteCustomLineCap(nativeCap);
}

inline Status 
CustomLineCap::SetStrokeCaps(
    IN LineCap startCap, 
    IN LineCap endCap)
{
    return SetStatus(DllExports::GdipSetCustomLineCapStrokeCaps(nativeCap,
                startCap, endCap));
}

inline Status 
CustomLineCap::GetStrokeCaps(
    OUT LineCap* startCap, 
    OUT LineCap* endCap) const
{
    return SetStatus(DllExports::GdipGetCustomLineCapStrokeCaps(nativeCap,
                 startCap, endCap));
}

inline Status 
CustomLineCap::SetStrokeJoin(
    IN LineJoin lineJoin)
{
    return SetStatus(DllExports::GdipSetCustomLineCapStrokeJoin(nativeCap, 
                                                                lineJoin));
}

inline LineJoin 
CustomLineCap::GetStrokeJoin() const
{
    LineJoin lineJoin;

    SetStatus(DllExports::GdipGetCustomLineCapStrokeJoin(nativeCap, 
                                                         &lineJoin));

    return lineJoin;
}

inline Status 
CustomLineCap::SetBaseCap(IN LineCap baseCap)
{
    return SetStatus(DllExports::GdipSetCustomLineCapBaseCap(nativeCap, 
                                                             baseCap));
}

inline LineCap 
CustomLineCap::GetBaseCap() const
{
    LineCap baseCap;
    SetStatus(DllExports::GdipGetCustomLineCapBaseCap(nativeCap, &baseCap));

    return baseCap;
}

inline Status 
CustomLineCap::SetBaseInset(IN REAL inset)
{
    return SetStatus(DllExports::GdipSetCustomLineCapBaseInset(nativeCap, 
                                                               inset));
}

inline REAL 
CustomLineCap::GetBaseInset() const
{
    REAL inset;
    SetStatus(DllExports::GdipGetCustomLineCapBaseInset(nativeCap, &inset));

    return inset;
}


inline Status 
CustomLineCap::SetWidthScale(IN REAL widthScale)
{
    return SetStatus(DllExports::GdipSetCustomLineCapWidthScale(nativeCap, 
                                                                widthScale));
}

inline REAL 
CustomLineCap::GetWidthScale() const
{
    REAL widthScale;
    SetStatus(DllExports::GdipGetCustomLineCapWidthScale(nativeCap, 
                                                         &widthScale));

    return widthScale;
}

inline CustomLineCap* 
CustomLineCap::Clone() const
{
    GpCustomLineCap *newNativeLineCap = NULL;
    
    SetStatus(DllExports::GdipCloneCustomLineCap(nativeCap, 
                                                 &newNativeLineCap));

    if (lastResult == Ok) 
    {
        CustomLineCap *newLineCap = new CustomLineCap(newNativeLineCap, 
                                                      lastResult);
        if (newLineCap == NULL) 
        {
            SetStatus(DllExports::GdipDeleteCustomLineCap(newNativeLineCap));
        }

        return newLineCap;
    }

    return NULL;
}

inline Status 
CustomLineCap::GetLastStatus() const 
{
    Status lastStatus = lastResult;
    lastResult = Ok;    
    return (lastStatus);
}

class AdjustableArrowCap : public CustomLineCap
{
public:

    AdjustableArrowCap(
        IN REAL height,
        IN REAL width,
        IN BOOL isFilled = TRUE
        )
    {
        GpAdjustableArrowCap* cap = NULL;

        lastResult = DllExports::GdipCreateAdjustableArrowCap(
                        height, width, isFilled, &cap);
        SetNativeCap(cap);
    }

    Status SetHeight(IN REAL height)
    {
        GpAdjustableArrowCap* cap = (GpAdjustableArrowCap*) nativeCap;
        return SetStatus(DllExports::GdipSetAdjustableArrowCapHeight(
                            cap, height));
    }

    REAL GetHeight() const
    {
        GpAdjustableArrowCap* cap = (GpAdjustableArrowCap*) nativeCap;
        REAL height;
        SetStatus(DllExports::GdipGetAdjustableArrowCapHeight(
                            cap, &height));

        return height;
    }

    Status SetWidth(IN REAL width)
    {
        GpAdjustableArrowCap* cap = (GpAdjustableArrowCap*) nativeCap;
        return SetStatus(DllExports::GdipSetAdjustableArrowCapWidth(
                            cap, width));
    }

    REAL GetWidth() const
    {
        GpAdjustableArrowCap* cap = (GpAdjustableArrowCap*) nativeCap;
        REAL width;
        SetStatus(DllExports::GdipGetAdjustableArrowCapWidth(
                            cap, &width));

        return width;
    }

    Status SetMiddleInset(IN REAL middleInset)
    {
        GpAdjustableArrowCap* cap = (GpAdjustableArrowCap*) nativeCap;
        return SetStatus(DllExports::GdipSetAdjustableArrowCapMiddleInset(
                            cap, middleInset));
    }

    REAL GetMiddleInset() const
    {
        GpAdjustableArrowCap* cap = (GpAdjustableArrowCap*) nativeCap;
        REAL middleInset;
        SetStatus(DllExports::GdipGetAdjustableArrowCapMiddleInset(
                            cap, &middleInset));

        return middleInset;
    }

    Status SetFillState(IN BOOL isFilled)
    {
        GpAdjustableArrowCap* cap = (GpAdjustableArrowCap*) nativeCap;
        return SetStatus(DllExports::GdipSetAdjustableArrowCapFillState(
                            cap, isFilled));
    }

    BOOL IsFilled() const
    {
        GpAdjustableArrowCap* cap = (GpAdjustableArrowCap*) nativeCap;
        BOOL isFilled;
        SetStatus(DllExports::GdipGetAdjustableArrowCapFillState(
                            cap, &isFilled));

        return isFilled;
    }

private:
    AdjustableArrowCap(const AdjustableArrowCap &);
    AdjustableArrowCap& operator=(const AdjustableArrowCap &);
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\sdkinc\gdiplusimaging.h ===
/**************************************************************************\
* 
* Copyright (c) 1999-2000  Microsoft Corporation
*
* Module Name:
*
*   GdiplusImaging.h
*
* Abstract:
*
*   GDI+ Imaging GUIDs
*
\**************************************************************************/

#ifndef _GDIPLUSIMAGING_H
#define _GDIPLUSIMAGING_H

//---------------------------------------------------------------------------
// Image file format identifiers
//---------------------------------------------------------------------------

DEFINE_GUID(ImageFormatUndefined, 0xb96b3ca9,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(ImageFormatMemoryBMP, 0xb96b3caa,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(ImageFormatBMP, 0xb96b3cab,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(ImageFormatEMF, 0xb96b3cac,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(ImageFormatWMF, 0xb96b3cad,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(ImageFormatJPEG, 0xb96b3cae,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(ImageFormatPNG, 0xb96b3caf,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(ImageFormatGIF, 0xb96b3cb0,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(ImageFormatTIFF, 0xb96b3cb1,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(ImageFormatEXIF, 0xb96b3cb2,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(ImageFormatIcon, 0xb96b3cb5,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);

//---------------------------------------------------------------------------
// Predefined multi-frame dimension IDs
//---------------------------------------------------------------------------

DEFINE_GUID(FrameDimensionTime, 0x6aedbd6d,0x3fb5,0x418a,0x83,0xa6,0x7f,0x45,0x22,0x9d,0xc8,0x72);
DEFINE_GUID(FrameDimensionResolution, 0x84236f7b,0x3bd3,0x428f,0x8d,0xab,0x4e,0xa1,0x43,0x9c,0xa3,0x15);
DEFINE_GUID(FrameDimensionPage, 0x7462dc86,0x6180,0x4c7e,0x8e,0x3f,0xee,0x73,0x33,0xa7,0xa4,0x83);

//---------------------------------------------------------------------------
// Property sets
//---------------------------------------------------------------------------

DEFINE_GUID(FormatIDImageInformation, 0xe5836cbe,0x5eef,0x4f1d,0xac,0xde,0xae,0x4c,0x43,0xb6,0x08,0xce);
DEFINE_GUID(FormatIDJpegAppHeaders, 0x1c4afdcd,0x6177,0x43cf,0xab,0xc7,0x5f,0x51,0xaf,0x39,0xee,0x85);

//---------------------------------------------------------------------------
// Encoder parameter sets
//---------------------------------------------------------------------------

DEFINE_GUID(EncoderCompression, 0xe09d739d,0xccd4,0x44ee,0x8e,0xba,0x3f,0xbf,0x8b,0xe4,0xfc,0x58);
DEFINE_GUID(EncoderColorDepth, 0x66087055,0xad66,0x4c7c,0x9a,0x18,0x38,0xa2,0x31,0x0b,0x83,0x37);
DEFINE_GUID(EncoderScanMethod, 0x3a4e2661,0x3109,0x4e56,0x85,0x36,0x42,0xc1,0x56,0xe7,0xdc,0xfa);
DEFINE_GUID(EncoderVersion, 0x24d18c76,0x814a,0x41a4,0xbf,0x53,0x1c,0x21,0x9c,0xcc,0xf7,0x97);
DEFINE_GUID(EncoderRenderMethod, 0x6d42c53a,0x229a,0x4825,0x8b,0xb7,0x5c,0x99,0xe2,0xb9,0xa8,0xb8);
DEFINE_GUID(EncoderQuality, 0x1d5be4b5,0xfa4a,0x452d,0x9c,0xdd,0x5d,0xb3,0x51,0x05,0xe7,0xeb);
DEFINE_GUID(EncoderTransformation,0x8d0eb2d1,0xa58e,0x4ea8,0xaa,0x14,0x10,0x80,0x74,0xb7,0xb6,0xf9);
DEFINE_GUID(EncoderLuminanceTable,0xedb33bce,0x0266,0x4a77,0xb9,0x04,0x27,0x21,0x60,0x99,0xe7,0x17);
DEFINE_GUID(EncoderChrominanceTable,0xf2e455dc,0x09b3,0x4316,0x82,0x60,0x67,0x6a,0xda,0x32,0x48,0x1c);
DEFINE_GUID(EncoderSaveFlag,0x292266fc,0xac40,0x47bf,0x8c, 0xfc, 0xa8, 0x5b, 0x89, 0xa6, 0x55, 0xde);

DEFINE_GUID(CodecIImageBytes,0x025d1823,0x6c7d,0x447b,0xbb, 0xdb, 0xa3, 0xcb, 0xc3, 0xdf, 0xa2, 0xfc);

MIDL_INTERFACE("025D1823-6C7D-447B-BBDB-A3CBC3DFA2FC")
IImageBytes : public IUnknown
{
public:
    // Return total number of bytes in the IStream

    STDMETHOD(CountBytes)(
        OUT UINT *pcb
        ) = 0;
    
    // Locks "cb" bytes, starting from "ulOffset" in the stream, and returns the
    // pointer to the beginning of the locked memory chunk in "ppvBytes"

    STDMETHOD(LockBytes)(
        IN UINT cb,
        IN ULONG ulOffset,
        OUT const VOID ** ppvBytes
        ) = 0;

    // Unlocks "cb" bytes, pointed by "pvBytes", starting from "ulOffset" in the
    // stream

    STDMETHOD(UnlockBytes)(
        IN const VOID *pvBytes,
        IN UINT cb,
        IN ULONG ulOffset
        ) = 0;
};

//--------------------------------------------------------------------------
// ImageCodecInfo structure
//--------------------------------------------------------------------------

class ImageCodecInfo
{
public:          
    CLSID Clsid;
    GUID  FormatID;
    const WCHAR* CodecName;
    const WCHAR* DllName;
    const WCHAR* FormatDescription;
    const WCHAR* FilenameExtension;
    const WCHAR* MimeType;
    DWORD Flags;
    DWORD Version;
    DWORD SigCount;
    DWORD SigSize;
    const BYTE* SigPattern;
    const BYTE* SigMask;
};

//--------------------------------------------------------------------------
// Information flags about image codecs
//--------------------------------------------------------------------------

enum ImageCodecFlags
{
    ImageCodecFlagsEncoder            = 0x00000001,
    ImageCodecFlagsDecoder            = 0x00000002,
    ImageCodecFlagsSupportBitmap      = 0x00000004,
    ImageCodecFlagsSupportVector      = 0x00000008,
    ImageCodecFlagsSeekableEncode     = 0x00000010,
    ImageCodecFlagsBlockingDecode     = 0x00000020,

    ImageCodecFlagsBuiltin            = 0x00010000,
    ImageCodecFlagsSystem             = 0x00020000,
    ImageCodecFlagsUser               = 0x00040000
};

//---------------------------------------------------------------------------
// Access modes used when calling Image::LockBits
//---------------------------------------------------------------------------

enum ImageLockMode
{
    ImageLockModeRead        = 0x0001,
    ImageLockModeWrite       = 0x0002,
    ImageLockModeUserInputBuf= 0x0004
};

//---------------------------------------------------------------------------
// Information about image pixel data
//---------------------------------------------------------------------------

class BitmapData
{
public:
    UINT Width;
    UINT Height;
    INT Stride;
    PixelFormat PixelFormat;
    VOID* Scan0;
    UINT_PTR Reserved;
};

//---------------------------------------------------------------------------
// Image flags
//---------------------------------------------------------------------------

enum ImageFlags
{
    ImageFlagsNone                = 0,

    // Low-word: shared with SINKFLAG_x

    ImageFlagsScalable            = 0x0001,
    ImageFlagsHasAlpha            = 0x0002,
    ImageFlagsHasTranslucent      = 0x0004,
    ImageFlagsPartiallyScalable   = 0x0008,

    // Low-word: color space definition

    ImageFlagsColorSpaceRGB       = 0x0010,
    ImageFlagsColorSpaceCMYK      = 0x0020,
    ImageFlagsColorSpaceGRAY      = 0x0040,
    ImageFlagsColorSpaceYCBCR     = 0x0080,
    ImageFlagsColorSpaceYCCK      = 0x0100,
 
    // Low-word: image size info

    ImageFlagsHasRealDPI          = 0x1000,
    ImageFlagsHasRealPixelSize    = 0x2000,

    // High-word

    ImageFlagsReadOnly            = 0x00010000,
    ImageFlagsCaching             = 0x00020000
};

enum RotateFlipType
{
    RotateNoneFlipNone = 0,
    Rotate90FlipNone   = 1,
    Rotate180FlipNone  = 2,
    Rotate270FlipNone  = 3,

    RotateNoneFlipX    = 4,
    Rotate90FlipX      = 5,
    Rotate180FlipX     = 6,
    Rotate270FlipX     = 7,

    RotateNoneFlipY    = Rotate180FlipX,
    Rotate90FlipY      = Rotate270FlipX,
    Rotate180FlipY     = RotateNoneFlipX,
    Rotate270FlipY     = Rotate90FlipX,

    RotateNoneFlipXY   = Rotate180FlipNone,
    Rotate90FlipXY     = Rotate270FlipNone,
    Rotate180FlipXY    = RotateNoneFlipNone,
    Rotate270FlipXY    = Rotate90FlipNone
};

//---------------------------------------------------------------------------
// Encoder Parameter structure
//---------------------------------------------------------------------------
class EncoderParameter
{
public:
    GUID    Guid;               // GUID of the parameter
    ULONG   NumberOfValues;     // Number of the parameter values
    ULONG   Type;               // Value type, like ValueTypeLONG  etc.
    VOID*   Value;              // A pointer to the parameter values
};

//---------------------------------------------------------------------------
// Encoder Parameters structure
//---------------------------------------------------------------------------
class EncoderParameters
{
public:
    UINT Count;                      // Number of parameters in this structure
    EncoderParameter Parameter[1];   // Parameter values
};

//---------------------------------------------------------------------------
// Property Item
//---------------------------------------------------------------------------
class PropertyItem
{
public:
    PROPID  id;                 // ID of this property
    ULONG   length;             // Length of the property value, in bytes
    WORD    type;               // Type of the value, as one of TAG_TYPE_XXX
                                // defined above
    VOID*   value;              // property value
};

//---------------------------------------------------------------------------
// Image property types 
//---------------------------------------------------------------------------
#define PropertyTagTypeByte        1
#define PropertyTagTypeASCII       2
#define PropertyTagTypeShort       3
#define PropertyTagTypeLong        4
#define PropertyTagTypeRational    5
#define PropertyTagTypeUndefined   7
#define PropertyTagTypeSLONG       9
#define PropertyTagTypeSRational  10

//---------------------------------------------------------------------------
// Image property ID tags
//---------------------------------------------------------------------------

#define PropertyTagExifIFD             0x8769
#define PropertyTagGpsIFD              0x8825

#define PropertyTagNewSubfileType      0x00FE
#define PropertyTagSubfileType         0x00FF
#define PropertyTagImageWidth          0x0100
#define PropertyTagImageHeight         0x0101
#define PropertyTagBitsPerSample       0x0102
#define PropertyTagCompression         0x0103
#define PropertyTagPhotometricInterp   0x0106
#define PropertyTagThreshHolding       0x0107
#define PropertyTagCellWidth           0x0108
#define PropertyTagCellHeight          0x0109
#define PropertyTagFillOrder           0x010A
#define PropertyTagDocumentName        0x010D
#define PropertyTagImageDescription    0x010E
#define PropertyTagEquipMake           0x010F
#define PropertyTagEquipModel          0x0110
#define PropertyTagStripOffsets        0x0111
#define PropertyTagOrientation         0x0112
#define PropertyTagSamplesPerPixel     0x0115
#define PropertyTagRowsPerStrip        0x0116
#define PropertyTagStripBytesCount     0x0117
#define PropertyTagMinSampleValue      0x0118
#define PropertyTagMaxSampleValue      0x0119
#define PropertyTagXResolution         0x011A   // Image resolution in width direction
#define PropertyTagYResolution         0x011B   // Image resolution in height direction
#define PropertyTagPlanarConfig        0x011C   // Image data arrangement
#define PropertyTagPageName            0x011D
#define PropertyTagXPosition           0x011E
#define PropertyTagYPosition           0x011F
#define PropertyTagFreeOffset          0x0120
#define PropertyTagFreeByteCounts      0x0121
#define PropertyTagGrayResponseUnit    0x0122
#define PropertyTagGrayResponseCurve   0x0123
#define PropertyTagT4Option            0x0124
#define PropertyTagT6Option            0x0125
#define PropertyTagResolutionUnit      0x0128   // Unit of X and Y resolution
#define PropertyTagPageNumber          0x0129
#define PropertyTagTransferFuncition   0x012D
#define PropertyTagSoftwareUsed        0x0131
#define PropertyTagDateTime            0x0132
#define PropertyTagArtist              0x013B
#define PropertyTagHostComputer        0x013C
#define PropertyTagPredictor           0x013D
#define PropertyTagWhitePoint          0x013E
#define PropertyTagPrimaryChromaticities 0x013F
#define PropertyTagColorMap            0x0140
#define PropertyTagHalftoneHints       0x0141
#define PropertyTagTileWidth           0x0142
#define PropertyTagTileLength          0x0143
#define PropertyTagTileOffset          0x0144
#define PropertyTagTileByteCounts      0x0145
#define PropertyTagInkSet              0x014C
#define PropertyTagInkNames            0x014D
#define PropertyTagNumberOfInks        0x014E
#define PropertyTagDotRange            0x0150
#define PropertyTagTargetPrinter       0x0151
#define PropertyTagExtraSamples        0x0152
#define PropertyTagSampleFormat        0x0153
#define PropertyTagSMinSampleValue     0x0154
#define PropertyTagSMaxSampleValue     0x0155
#define PropertyTagTransferRange       0x0156

#define PropertyTagJPEGProc            0x0200
#define PropertyTagJPEGInterFormat     0x0201
#define PropertyTagJPEGInterLength     0x0202
#define PropertyTagJPEGRestartInterval 0x0203
#define PropertyTagJPEGLosslessPredictors  0x0205
#define PropertyTagJPEGPointTransforms     0x0206
#define PropertyTagJPEGQTables         0x0207
#define PropertyTagJPEGDCTables        0x0208
#define PropertyTagJPEGACTables        0x0209

#define PropertyTagYCbCrCoefficients   0x0211
#define PropertyTagYCbCrSubsampling    0x0212
#define PropertyTagYCbCrPositioning    0x0213
#define PropertyTagREFBlackWhite       0x0214

#define PropertyTagICCProfile          0x8773   // This TAG is defined by ICC
                                                // for embedded ICC in TIFF
#define PropertyTagGamma               0x0301
#define PropertyTagICCProfileDescriptor 0x0302
#define PropertyTagSRGBRenderingIntent 0x0303

#define PropertyTagImageTitle          0x0320
#define PropertyTagCopyright           0x8298

// Extra TAGs (Like Adobe Image Information tags etc.)

#define PropertyTagResolutionXUnit           0x5001
#define PropertyTagResolutionYUnit           0x5002
#define PropertyTagResolutionXLengthUnit     0x5003
#define PropertyTagResolutionYLengthUnit     0x5004
#define PropertyTagPrintFlags                0x5005
#define PropertyTagPrintFlagsVersion         0x5006
#define PropertyTagPrintFlagsCrop            0x5007
#define PropertyTagPrintFlagsBleedWidth      0x5008
#define PropertyTagPrintFlagsBleedWidthScale 0x5009
#define PropertyTagHalftoneLPI               0x500A
#define PropertyTagHalftoneLPIUnit           0x500B
#define PropertyTagHalftoneDegree            0x500C
#define PropertyTagHalftoneShape             0x500D
#define PropertyTagHalftoneMisc              0x500E
#define PropertyTagHalftoneScreen            0x500F
#define PropertyTagJPEGQuality               0x5010
#define PropertyTagGridSize                  0x5011
#define PropertyTagThumbnailFormat           0x5012  // 1 = JPEG, 0 = RAW RGB
#define PropertyTagThumbnailWidth            0x5013
#define PropertyTagThumbnailHeight           0x5014
#define PropertyTagThumbnailColorDepth       0x5015
#define PropertyTagThumbnailPlanes           0x5016
#define PropertyTagThumbnailRawBytes         0x5017
#define PropertyTagThumbnailSize             0x5018
#define PropertyTagThumbnailCompressedSize   0x5019
#define PropertyTagColorTransferFunction     0x501A
#define PropertyTagThumbnailData             0x501B// RAW thumbnail bits in
                                                   // JPEG format or RGB format
                                                   // depends on
                                                   // PropertyTagThumbnailFormat

// Thumbnail related TAGs
                                                
#define PropertyTagThumbnailImageWidth       0x5020  // Thumbnail width
#define PropertyTagThumbnailImageHeight      0x5021  // Thumbnail height
#define PropertyTagThumbnailBitsPerSample    0x5022  // Number of bits per
                                                     // component
#define PropertyTagThumbnailCompression      0x5023  // Compression Scheme
#define PropertyTagThumbnailPhotometricInterp 0x5024 // Pixel composition
#define PropertyTagThumbnailImageDescription 0x5025  // Image Tile
#define PropertyTagThumbnailEquipMake        0x5026  // Manufacturer of Image
                                                     // Input equipment
#define PropertyTagThumbnailEquipModel       0x5027  // Model of Image input
                                                     // equipment
#define PropertyTagThumbnailStripOffsets     0x5028  // Image data location
#define PropertyTagThumbnailOrientation      0x5029  // Orientation of image
#define PropertyTagThumbnailSamplesPerPixel  0x502A  // Number of components
#define PropertyTagThumbnailRowsPerStrip     0x502B  // Number of rows per strip
#define PropertyTagThumbnailStripBytesCount  0x502C  // Bytes per compressed
                                                     // strip
#define PropertyTagThumbnailResolutionX      0x502D  // Resolution in width
                                                     // direction
#define PropertyTagThumbnailResolutionY      0x502E  // Resolution in height
                                                     // direction
#define PropertyTagThumbnailPlanarConfig     0x502F  // Image data arrangement
#define PropertyTagThumbnailResolutionUnit   0x5030  // Unit of X and Y
                                                     // Resolution
#define PropertyTagThumbnailTransferFunction 0x5031  // Transfer function
#define PropertyTagThumbnailSoftwareUsed     0x5032  // Software used
#define PropertyTagThumbnailDateTime         0x5033  // File change date and
                                                     // time
#define PropertyTagThumbnailArtist           0x5034  // Person who created the
                                                     // image
#define PropertyTagThumbnailWhitePoint       0x5035  // White point chromaticity
#define PropertyTagThumbnailPrimaryChromaticities 0x5036 
                                                     // Chromaticities of
                                                     // primaries
#define PropertyTagThumbnailYCbCrCoefficients 0x5037 // Color space transforma-
                                                     // tion coefficients
#define PropertyTagThumbnailYCbCrSubsampling 0x5038  // Subsampling ratio of Y
                                                     // to C
#define PropertyTagThumbnailYCbCrPositioning 0x5039  // Y and C position
#define PropertyTagThumbnailRefBlackWhite    0x503A  // Pair of black and white
                                                     // reference values
#define PropertyTagThumbnailCopyRight        0x503B  // CopyRight holder

#define PropertyTagLuminanceTable            0x5090
#define PropertyTagChrominanceTable          0x5091

#define PropertyTagFrameDelay                0x5100
#define PropertyTagLoopCount                 0x5101

#define PropertyTagPixelUnit         0x5110  // Unit specifier for pixel/unit
#define PropertyTagPixelPerUnitX     0x5111  // Pixels per unit in X
#define PropertyTagPixelPerUnitY     0x5112  // Pixels per unit in Y
#define PropertyTagPaletteHistogram  0x5113  // Palette histogram

// EXIF specific tag

#define PropertyTagExifExposureTime  0x829A
#define PropertyTagExifFNumber       0x829D

#define PropertyTagExifExposureProg  0x8822
#define PropertyTagExifSpectralSense 0x8824
#define PropertyTagExifISOSpeed      0x8827
#define PropertyTagExifOECF          0x8828

#define PropertyTagExifVer            0x9000
#define PropertyTagExifDTOrig         0x9003 // Date & time of original
#define PropertyTagExifDTDigitized    0x9004 // Date & time of digital data generation

#define PropertyTagExifCompConfig     0x9101
#define PropertyTagExifCompBPP        0x9102

#define PropertyTagExifShutterSpeed   0x9201
#define PropertyTagExifAperture       0x9202
#define PropertyTagExifBrightness     0x9203
#define PropertyTagExifExposureBias   0x9204
#define PropertyTagExifMaxAperture    0x9205
#define PropertyTagExifSubjectDist    0x9206
#define PropertyTagExifMeteringMode   0x9207
#define PropertyTagExifLightSource    0x9208
#define PropertyTagExifFlash          0x9209
#define PropertyTagExifFocalLength    0x920A
#define PropertyTagExifMakerNote      0x927C
#define PropertyTagExifUserComment    0x9286
#define PropertyTagExifDTSubsec       0x9290  // Date & Time subseconds
#define PropertyTagExifDTOrigSS       0x9291  // Date & Time original subseconds
#define PropertyTagExifDTDigSS        0x9292  // Date & TIme digitized subseconds

#define PropertyTagExifFPXVer         0xA000
#define PropertyTagExifColorSpace     0xA001
#define PropertyTagExifPixXDim        0xA002
#define PropertyTagExifPixYDim        0xA003
#define PropertyTagExifRelatedWav     0xA004  // related sound file
#define PropertyTagExifInterop        0xA005
#define PropertyTagExifFlashEnergy    0xA20B
#define PropertyTagExifSpatialFR      0xA20C  // Spatial Frequency Response
#define PropertyTagExifFocalXRes      0xA20E  // Focal Plane X Resolution
#define PropertyTagExifFocalYRes      0xA20F  // Focal Plane Y Resolution
#define PropertyTagExifFocalResUnit   0xA210  // Focal Plane Resolution Unit
#define PropertyTagExifSubjectLoc     0xA214
#define PropertyTagExifExposureIndex  0xA215
#define PropertyTagExifSensingMethod  0xA217
#define PropertyTagExifFileSource     0xA300
#define PropertyTagExifSceneType      0xA301
#define PropertyTagExifCfaPattern     0xA302

#define PropertyTagGpsVer             0x0000
#define PropertyTagGpsLatitudeRef     0x0001
#define PropertyTagGpsLatitude        0x0002
#define PropertyTagGpsLongitudeRef    0x0003
#define PropertyTagGpsLongitude       0x0004
#define PropertyTagGpsAltitudeRef     0x0005
#define PropertyTagGpsAltitude        0x0006
#define PropertyTagGpsGpsTime         0x0007
#define PropertyTagGpsGpsSatellites   0x0008
#define PropertyTagGpsGpsStatus       0x0009
#define PropertyTagGpsGpsMeasureMode  0x00A
#define PropertyTagGpsGpsDop          0x000B  // Measurement precision
#define PropertyTagGpsSpeedRef        0x000C
#define PropertyTagGpsSpeed           0x000D
#define PropertyTagGpsTrackRef        0x000E
#define PropertyTagGpsTrack           0x000F
#define PropertyTagGpsImgDirRef       0x0010
#define PropertyTagGpsImgDir          0x0011
#define PropertyTagGpsMapDatum        0x0012
#define PropertyTagGpsDestLatRef      0x0013
#define PropertyTagGpsDestLat         0x0014
#define PropertyTagGpsDestLongRef     0x0015
#define PropertyTagGpsDestLong        0x0016
#define PropertyTagGpsDestBearRef     0x0017
#define PropertyTagGpsDestBear        0x0018
#define PropertyTagGpsDestDistRef     0x0019
#define PropertyTagGpsDestDist        0x001A

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\sdkinc\gdiplusmem.h ===
/**************************************************************************\
*
* Copyright (c) 1998-2001, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   GdiplusMem.h
*
* Abstract:
*
*   GDI+ Private Memory Management APIs
*
\**************************************************************************/

#ifndef _GDIPLUSMEM_H
#define _GDIPLUSMEM_H

#ifdef __cplusplus
extern "C" {
#endif

#define WINGDIPAPI __stdcall

//----------------------------------------------------------------------------
// Memory Allocation APIs
//----------------------------------------------------------------------------

void* WINGDIPAPI
GdipAlloc(size_t size);

void WINGDIPAPI
GdipFree(void* ptr);

#ifdef __cplusplus
}
#endif

#endif // !_GDIPLUSMEM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\sdkinc\gdiplusheaders.h ===
/**************************************************************************\
*
* Copyright (c) 1998-2001, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   GdiplusHeaders.h
*
* Abstract:
*
*   GDI+ Region, Font, Image, CustomLineCap class definitions.
*
*
* Class definition and inline class implementation are separated into
* different files to avoid circular dependencies.
*
\**************************************************************************/

#ifndef _GDIPLUSHEADERS_H
#define _GDIPLUSHEADERS_H

class Region : public GdiplusBase
{
public:
    friend class Graphics;

    Region();
    Region(IN const RectF& rect);
    Region(IN const Rect& rect);
    Region(IN const GraphicsPath* path);
    Region(IN const BYTE* regionData, IN INT size);
    Region(IN HRGN hRgn);
    static Region* FromHRGN(IN HRGN hRgn);

    ~Region();
    Region* Clone() const;

    Status MakeInfinite();
    Status MakeEmpty();

    UINT GetDataSize() const;

    // buffer     - where to put the data
    // bufferSize - how big the buffer is (should be at least as big as GetDataSize())
    // sizeFilled - if not NULL, this is an OUT param that says how many bytes
    //              of data were written to the buffer.

    Status GetData(OUT BYTE* buffer,
                   IN UINT bufferSize,
                   OUT UINT* sizeFilled = NULL) const;

    Status Intersect(IN const Rect& rect);
    Status Intersect(IN const RectF& rect);
    Status Intersect(IN const GraphicsPath* path);
    Status Intersect(IN const Region* region);
    Status Union(IN const Rect& rect);
    Status Union(IN const RectF& rect);
    Status Union(IN const GraphicsPath* path);
    Status Union(IN const Region* region);
    Status Xor(IN const Rect& rect);
    Status Xor(IN const RectF& rect);
    Status Xor(IN const GraphicsPath* path);
    Status Xor(IN const Region* region);
    Status Exclude(IN const Rect& rect);
    Status Exclude(IN const RectF& rect);
    Status Exclude(IN const GraphicsPath* path);
    Status Exclude(IN const Region* region);
    Status Complement(IN const Rect& rect);
    Status Complement(IN const RectF& rect);
    Status Complement(IN const GraphicsPath* path);
    Status Complement(IN const Region* region);
    Status Translate(IN REAL dx,
                     IN REAL dy);
    Status Translate(IN INT dx,
                     IN INT dy);
    Status Transform(IN const Matrix* matrix);

    Status GetBounds(OUT Rect* rect,
                     IN const Graphics* g) const;

    Status GetBounds(OUT RectF* rect,
                     IN const Graphics* g) const;

    HRGN   GetHRGN  (IN const Graphics * g) const;

    BOOL IsEmpty(IN const Graphics *g) const;
    BOOL IsInfinite(IN const Graphics *g) const;

    BOOL IsVisible(IN INT x,
                   IN INT y,
                   IN const Graphics* g = NULL) const
    {
        return IsVisible(Point(x, y), g);
    }

    BOOL IsVisible(IN const Point& point,
                   IN const Graphics* g = NULL) const;

    BOOL IsVisible(IN REAL x,
                   IN REAL y,
                   IN const Graphics* g = NULL) const
    {
        return IsVisible(PointF(x, y), g);
    }

    BOOL IsVisible(IN const PointF& point,
                   IN const Graphics* g = NULL) const;

    BOOL IsVisible(IN INT x,
                   IN INT y,
                   IN INT width,
                   IN INT height,
                   IN const Graphics* g) const
    {
        return IsVisible(Rect(x, y, width, height), g);
    }

    BOOL IsVisible(IN const Rect& rect,
                   IN const Graphics* g = NULL) const;

    BOOL IsVisible(IN REAL x,
                   IN REAL y,
                   IN REAL width,
                   IN REAL height,
                   IN const Graphics* g = NULL) const
    {
        return IsVisible(RectF(x, y, width, height), g);
    }

    BOOL IsVisible(IN const RectF& rect,
                   IN const Graphics* g = NULL) const;

    BOOL Equals(IN const Region* region,
                IN const Graphics* g) const;

    UINT GetRegionScansCount(IN const Matrix* matrix) const;
    Status GetRegionScans(IN const Matrix* matrix,
                          OUT RectF* rects,
                          OUT INT* count) const;
    Status GetRegionScans(IN const Matrix* matrix,
                          OUT Rect*  rects,
                          OUT INT* count) const;
    Status GetLastStatus() const;

protected:

private:
    Region(const Region &region);
    Region& operator=(const Region &region);
protected:

    Status SetStatus(Status status) const
    {
        if (status != Ok)
            return (lastResult = status);
        else
            return status;
    }

    Region(GpRegion* nativeRegion);

    VOID SetNativeRegion(GpRegion* nativeRegion);

protected:
    GpRegion* nativeRegion;
    mutable Status lastResult;
};


//--------------------------------------------------------------------------
// FontFamily
//--------------------------------------------------------------------------

class FontFamily : public GdiplusBase
{
public:
    friend class Font;
    friend class Graphics;
    friend class GraphicsPath;
    friend class FontCollection;

    FontFamily();

    FontFamily(
        IN const WCHAR          *name,
        IN const FontCollection *fontCollection = NULL
    );

    ~FontFamily();

    static const FontFamily *GenericSansSerif();
    static const FontFamily *GenericSerif();
    static const FontFamily *GenericMonospace();

    Status GetFamilyName(
        OUT WCHAR        name[LF_FACESIZE],
        IN LANGID        language = 0
    ) const;

    FontFamily * Clone() const;

    BOOL    IsAvailable() const
    {
        return (nativeFamily != NULL);
    };

    BOOL    IsStyleAvailable(IN INT style) const;

    UINT16  GetEmHeight     (IN INT style) const;
    UINT16  GetCellAscent   (IN INT style) const;
    UINT16  GetCellDescent  (IN INT style) const;
    UINT16  GetLineSpacing  (IN INT style) const;
    
    Status GetLastStatus() const;

private:
    FontFamily(const FontFamily &);
    FontFamily& operator=(const FontFamily &);

protected:
    Status SetStatus(Status status) const;

    FontFamily(GpFontFamily * nativeFamily, Status status);

protected:

    GpFontFamily    *nativeFamily;
    mutable Status   lastResult;
};

static FontFamily *GenericSansSerifFontFamily = NULL;
static FontFamily *GenericSerifFontFamily     = NULL;
static FontFamily *GenericMonospaceFontFamily = NULL;

static BYTE GenericSansSerifFontFamilyBuffer[sizeof(FontFamily)] = {0};
static BYTE GenericSerifFontFamilyBuffer    [sizeof(FontFamily)] = {0};
static BYTE GenericMonospaceFontFamilyBuffer[sizeof(FontFamily)] = {0};


//--------------------------------------------------------------------------
// Font
//--------------------------------------------------------------------------

class Font : public GdiplusBase
{
public:
    friend class Graphics;

    Font(IN HDC hdc);
    Font(IN HDC hdc,
         IN const LOGFONTA* logfont);
    Font(IN HDC hdc,
         IN const LOGFONTW* logfont);
    Font(IN HDC hdc,
         IN const HFONT hfont);
    Font(
        IN const FontFamily * family,
        IN REAL         emSize,
        IN INT          style   = FontStyleRegular,
        IN Unit         unit    = UnitPoint
    );

    Font(
        IN const WCHAR *           familyName,
        IN REAL                    emSize,
        IN INT                     style   = FontStyleRegular,
        IN Unit                    unit    = UnitPoint,
        IN const FontCollection *  fontCollection = NULL
    );

    Status GetLogFontA(IN const Graphics* g,
                       OUT  LOGFONTA * logfontA) const;
    Status GetLogFontW(IN const Graphics* g,
                       OUT LOGFONTW * logfontW) const;

    Font* Clone() const;
    ~Font();
    BOOL        IsAvailable()   const;
    INT         GetStyle()      const;
    REAL        GetSize()       const;
    Unit        GetUnit()       const;
    Status      GetLastStatus() const;
    REAL        GetHeight(IN const Graphics *graphics) const;
    REAL        GetHeight(IN REAL dpi) const;

    Status GetFamily(OUT FontFamily *family) const;

private:
    Font(const Font &);
    Font& operator=(const Font &);

protected:
    Font(GpFont* font, Status status);
    VOID SetNativeFont(GpFont *Font);
    Status SetStatus(Status status) const;

protected:

    GpFont* nativeFont;
    mutable Status lastResult;
};

//--------------------------------------------------------------------------
// Font Collection
//--------------------------------------------------------------------------

class FontCollection : public GdiplusBase
{
public:
    friend class FontFamily;

    FontCollection();
    virtual ~FontCollection();

    INT GetFamilyCount() const;

    Status GetFamilies(
        IN INT           numSought,
        OUT FontFamily * gpfamilies,
        OUT INT        * numFound
    ) const;

    Status GetLastStatus() const;

private:
    FontCollection(const FontCollection &);
    FontCollection& operator=(const FontCollection &);

protected:
    Status SetStatus(Status status) const ;

    GpFontCollection *nativeFontCollection;
    mutable Status    lastResult;
};


class InstalledFontCollection : public FontCollection
{
public:
    InstalledFontCollection();
    ~InstalledFontCollection();

private:
    InstalledFontCollection(const InstalledFontCollection &);
    InstalledFontCollection& operator=(const InstalledFontCollection &);

protected:
    Status SetStatus(Status status) const ;
};


class PrivateFontCollection : public FontCollection
{
public:
    PrivateFontCollection();
    ~PrivateFontCollection();

    Status AddFontFile(IN const WCHAR* filename);
    Status AddMemoryFont(IN const VOID* memory,
                         IN INT length);

private:
    PrivateFontCollection(const PrivateFontCollection &);
    PrivateFontCollection& operator=(const PrivateFontCollection &);
};


//--------------------------------------------------------------------------
// Abstract base class for Image and Metafile
//--------------------------------------------------------------------------

class Image : public GdiplusBase
{
public:
    friend class Brush;
    friend class TextureBrush;
    friend class Graphics;

    Image(
        IN const WCHAR* filename,
        IN BOOL useEmbeddedColorManagement = FALSE
    );

    Image(
        IN IStream* stream,
        IN BOOL useEmbeddedColorManagement = FALSE
    );

    static Image* FromFile(
        IN const WCHAR* filename,
        IN BOOL useEmbeddedColorManagement = FALSE
    );

    static Image* FromStream(
        IN IStream* stream,
        IN BOOL useEmbeddedColorManagement = FALSE
    );

    virtual ~Image();
    virtual Image* Clone();

    Status Save(IN const WCHAR* filename,
                IN const CLSID* clsidEncoder,
                IN const EncoderParameters *encoderParams = NULL);
    Status Save(IN IStream* stream,
                IN const CLSID* clsidEncoder,
                IN const EncoderParameters *encoderParams = NULL);
    Status SaveAdd(IN const EncoderParameters* encoderParams);
    Status SaveAdd(IN Image* newImage,
                   IN const EncoderParameters* encoderParams);

    ImageType GetType() const;
    Status GetPhysicalDimension(OUT SizeF* size);
    Status GetBounds(OUT RectF* srcRect,
                     OUT Unit* srcUnit);

    UINT GetWidth();
    UINT GetHeight();
    REAL GetHorizontalResolution();
    REAL GetVerticalResolution();
    UINT GetFlags();
    Status GetRawFormat(OUT GUID *format);
    PixelFormat GetPixelFormat();

    INT GetPaletteSize();
    Status GetPalette(OUT ColorPalette* palette,
                      IN INT size);
    Status SetPalette(IN const ColorPalette* palette);

    Image* GetThumbnailImage(IN UINT thumbWidth,
                             IN UINT thumbHeight,
                             IN GetThumbnailImageAbort callback = NULL,
                             IN VOID* callbackData = NULL);
    UINT GetFrameDimensionsCount();
    Status GetFrameDimensionsList(OUT GUID* dimensionIDs,
                                  IN UINT count);
    UINT GetFrameCount(IN const GUID* dimensionID);
    Status SelectActiveFrame(IN const GUID* dimensionID,
                             IN UINT frameIndex);
    Status RotateFlip(IN RotateFlipType rotateFlipType);
    UINT GetPropertyCount();
    Status GetPropertyIdList(IN UINT numOfProperty,
                             OUT PROPID* list);
    UINT GetPropertyItemSize(IN PROPID propId);
    Status GetPropertyItem(IN PROPID propId,
                           IN UINT propSize,
                           OUT PropertyItem* buffer);
    Status GetPropertySize(OUT UINT* totalBufferSize,
                           OUT UINT* numProperties);
    Status GetAllPropertyItems(IN UINT totalBufferSize,
                               IN UINT numProperties,
                               OUT PropertyItem* allItems);
    Status RemovePropertyItem(IN PROPID propId);
    Status SetPropertyItem(IN const PropertyItem* item);

    UINT  GetEncoderParameterListSize(IN const CLSID* clsidEncoder);
    Status GetEncoderParameterList(IN const CLSID* clsidEncoder,
                                   IN UINT size,
                                   OUT EncoderParameters* buffer);

    Status GetLastStatus() const;

protected:

    Image() {}

    Image(GpImage *nativeImage, Status status);

    VOID SetNativeImage(GpImage* nativeImage);

    Status SetStatus(Status status) const
    {
        if (status != Ok)
            return (lastResult = status);
        else
            return status;
    }

    GpImage* nativeImage;
    mutable Status lastResult;
    mutable Status loadStatus;

private:
    Image(IN const Image& C);
    Image& operator=(IN const Image& C);
};

class Bitmap : public Image
{
public:
    friend class Image;
    friend class CachedBitmap;

    Bitmap(
        IN const WCHAR *filename,
        IN BOOL useEmbeddedColorManagement = FALSE
    );

    Bitmap(
        IN IStream *stream,
        IN BOOL useEmbeddedColorManagement = FALSE
    );

    static Bitmap* FromFile(
        IN const WCHAR *filename,
        IN BOOL useEmbeddedColorManagement = FALSE
    );

    static Bitmap* FromStream(
        IN IStream *stream,
        IN BOOL useEmbeddedColorManagement = FALSE
    );

    Bitmap(IN INT width,
           IN INT height,
           IN INT stride, PixelFormat format,
           IN BYTE* scan0);
    Bitmap(IN INT width,
           IN INT height,
           IN PixelFormat format = PixelFormat32bppARGB);
    Bitmap(IN INT width,
           IN INT height,
           IN  Graphics* target);

    Bitmap* Clone(IN const Rect& rect,
                  IN PixelFormat format);
    Bitmap* Clone(IN INT x,
                  IN INT y,
                  IN INT width,
                  IN INT height,
                  IN PixelFormat format);
    Bitmap* Clone(IN const RectF& rect,
                  IN PixelFormat format);
    Bitmap* Clone(IN REAL x,
                  IN REAL y,
                  IN REAL width,
                  IN REAL height,
                  IN PixelFormat format);

    Status LockBits(IN const Rect* rect,
                    IN UINT flags,
                    IN PixelFormat format,
                    OUT BitmapData* lockedBitmapData);
    Status UnlockBits(IN BitmapData* lockedBitmapData);
    Status GetPixel(IN INT x,
                    IN INT y,
                    OUT Color *color);
    Status SetPixel(IN INT x,
                    IN INT y,
                    IN const Color &color);
    Status SetResolution(IN REAL xdpi,
                         IN REAL ydpi);

    Bitmap(IN IDirectDrawSurface7* surface);
    Bitmap(IN const BITMAPINFO* gdiBitmapInfo,
           IN VOID* gdiBitmapData);
    Bitmap(IN HBITMAP hbm,
           IN HPALETTE hpal);
    Bitmap(IN HICON hicon);
    Bitmap(IN HINSTANCE hInstance,
           IN const WCHAR * bitmapName);
    static Bitmap* FromDirectDrawSurface7(IN IDirectDrawSurface7* surface);
    static Bitmap* FromBITMAPINFO(IN const BITMAPINFO* gdiBitmapInfo,
                                  IN VOID* gdiBitmapData);
    static Bitmap* FromHBITMAP(IN HBITMAP hbm,
                               IN HPALETTE hpal);
    static Bitmap* FromHICON(IN HICON hicon);
    static Bitmap* FromResource(IN HINSTANCE hInstance,
                                IN const WCHAR * bitmapName);

    Status GetHBITMAP(IN const Color& colorBackground,
                      OUT HBITMAP *hbmReturn);
    Status GetHICON(HICON *hicon);

private:
    Bitmap(const Bitmap &);
    Bitmap& operator=(const Bitmap &);

protected:
    Bitmap(GpBitmap *nativeBitmap);
};

class CustomLineCap : public GdiplusBase
{
public:
    friend class Pen;

    CustomLineCap(
        IN const GraphicsPath* fillPath,
        IN const GraphicsPath* strokePath,
        IN LineCap baseCap = LineCapFlat,
        IN REAL baseInset = 0
        );
    virtual ~CustomLineCap();

    CustomLineCap* Clone() const;

    // This changes both the start and end cap.

    Status SetStrokeCap(IN LineCap strokeCap)
    {
        return SetStrokeCaps(strokeCap, strokeCap);
    }

    Status SetStrokeCaps(IN LineCap startCap,
                         IN LineCap endCap);
    Status GetStrokeCaps(OUT LineCap* startCap,
                         OUT LineCap* endCap) const;
    Status SetStrokeJoin(IN LineJoin lineJoin);
    LineJoin GetStrokeJoin() const;
    Status SetBaseCap(IN LineCap baseCap);
    LineCap GetBaseCap() const;
    Status SetBaseInset(IN REAL inset);
    REAL GetBaseInset() const;
    Status SetWidthScale(IN REAL widthScale);
    REAL GetWidthScale() const;
    Status GetLastStatus() const;

protected:
    CustomLineCap();

private:
    CustomLineCap(const CustomLineCap &);
    CustomLineCap& operator=(const CustomLineCap &);

protected:
    CustomLineCap(GpCustomLineCap* nativeCap, Status status)
    {
        lastResult = status;
        SetNativeCap(nativeCap);
    }

    VOID SetNativeCap(GpCustomLineCap* nativeCap)
    {
        this->nativeCap = nativeCap;
    }

    Status SetStatus(Status status) const
    {
        if (status != Ok)
            return (lastResult = status);
        else
            return status;
    }

protected:
    GpCustomLineCap* nativeCap;
    mutable Status lastResult;
};

class CachedBitmap : public GdiplusBase
{
    friend Graphics;

public:
    CachedBitmap(IN Bitmap *bitmap,
                 IN Graphics *graphics);
    virtual ~CachedBitmap();

    Status GetLastStatus() const;

private:
    CachedBitmap(const CachedBitmap &);
    CachedBitmap& operator=(const CachedBitmap &);

protected:
    GpCachedBitmap *nativeCachedBitmap;
    mutable Status lastResult;
};

#endif  // !_GDIPLUSHEADERS.HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\sdkinc\gdiplusmetafile.h ===
/**************************************************************************\
*
* Copyright (c) 1998-2001, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   GdiplusMetafile.h
*
* Abstract:
*
*   GDI+ Metafile class
*
\**************************************************************************/

#ifndef _GDIPLUSMETAFILE_H
#define _GDIPLUSMETAFILE_H

class Metafile : public Image
{
public:
    friend class Image;

    // Playback a metafile from a HMETAFILE
    // If deleteWmf is TRUE, then when the metafile is deleted,
    // the hWmf will also be deleted.  Otherwise, it won't be.
    
    Metafile(IN HMETAFILE                      hWmf,
             IN const WmfPlaceableFileHeader * wmfPlaceableFileHeader,
             IN BOOL                           deleteWmf = FALSE)
    {
        GpMetafile *    metafile = NULL;

        lastResult = DllExports::GdipCreateMetafileFromWmf(hWmf, deleteWmf, 
                                                           wmfPlaceableFileHeader, 
                                                           &metafile);

        SetNativeImage(metafile);
    }

    // Playback a metafile from a HENHMETAFILE
    // If deleteEmf is TRUE, then when the metafile is deleted,
    // the hEmf will also be deleted.  Otherwise, it won't be.
    
    Metafile(IN HENHMETAFILE hEmf,
             IN BOOL deleteEmf = FALSE)
    {
        GpMetafile *    metafile = NULL;

        lastResult = DllExports::GdipCreateMetafileFromEmf(hEmf, deleteEmf, 
                                                           &metafile);

        SetNativeImage(metafile);
    }

    Metafile(IN const WCHAR* filename)
    {
        GpMetafile *    metafile = NULL;

        lastResult = DllExports::GdipCreateMetafileFromFile(filename, 
                                                            &metafile);

        SetNativeImage(metafile);
    }

    // Playback a WMF metafile from a file.

    Metafile(IN const WCHAR*                   filename,
             IN const WmfPlaceableFileHeader * wmfPlaceableFileHeader
            )
    {
        GpMetafile *    metafile = NULL;

        lastResult = DllExports::GdipCreateMetafileFromWmfFile(filename, 
                                                               wmfPlaceableFileHeader, 
                                                               &metafile);

        SetNativeImage(metafile);
    }

    Metafile(IN IStream* stream)
    {
        GpMetafile *    metafile = NULL;

        lastResult = DllExports::GdipCreateMetafileFromStream(stream, 
                                                              &metafile);

        SetNativeImage(metafile);
    }

    // Record a metafile to memory.

    Metafile(
        IN HDC                 referenceHdc,
        IN EmfType             type        = EmfTypeEmfPlusDual,
        IN const WCHAR *       description = NULL
        )
    {
        GpMetafile *    metafile = NULL;

        lastResult = DllExports::GdipRecordMetafile(
                        referenceHdc, type, NULL, MetafileFrameUnitGdi,
                        description, &metafile);

        SetNativeImage(metafile);
    }

    // Record a metafile to memory.

    Metafile(
        IN HDC                 referenceHdc,
        IN const RectF &       frameRect,
        IN MetafileFrameUnit   frameUnit   = MetafileFrameUnitGdi,
        IN EmfType             type        = EmfTypeEmfPlusDual,
        IN const WCHAR *       description = NULL
        )
    {
        GpMetafile *    metafile = NULL;

        lastResult = DllExports::GdipRecordMetafile(
                        referenceHdc, type, &frameRect, frameUnit,
                        description, &metafile);

        SetNativeImage(metafile);
    }

    // Record a metafile to memory.

    Metafile(
        IN HDC                 referenceHdc,
        IN const Rect &        frameRect,
        IN MetafileFrameUnit   frameUnit   = MetafileFrameUnitGdi,
        IN EmfType             type        = EmfTypeEmfPlusDual,
        IN const WCHAR *       description = NULL
        )
    {
        GpMetafile *    metafile = NULL;

        lastResult = DllExports::GdipRecordMetafileI(
                        referenceHdc, type, &frameRect, frameUnit,
                        description, &metafile);

        SetNativeImage(metafile);
    }

    Metafile(
        IN const WCHAR*        fileName,
        IN HDC                 referenceHdc,
        IN EmfType             type        = EmfTypeEmfPlusDual,
        IN const WCHAR *       description = NULL
        )
    {
        GpMetafile *    metafile = NULL;

        lastResult = DllExports::GdipRecordMetafileFileName(fileName,
                        referenceHdc, type, NULL, MetafileFrameUnitGdi,
                        description, &metafile);

        SetNativeImage(metafile);
    }

    Metafile(
        IN const WCHAR*        fileName,
        IN HDC                 referenceHdc,
        IN const RectF &       frameRect,
        IN MetafileFrameUnit   frameUnit   = MetafileFrameUnitGdi,
        IN EmfType             type        = EmfTypeEmfPlusDual,
        IN const WCHAR *       description = NULL
        )
    {
        GpMetafile *    metafile = NULL;

        lastResult = DllExports::GdipRecordMetafileFileName(fileName,
                        referenceHdc, type, &frameRect, frameUnit,
                        description, &metafile);

        SetNativeImage(metafile);
    }

    Metafile(
        IN const WCHAR*        fileName,
        IN HDC                 referenceHdc,
        IN const Rect &        frameRect,
        IN MetafileFrameUnit   frameUnit   = MetafileFrameUnitGdi,
        IN EmfType             type        = EmfTypeEmfPlusDual,
        IN const WCHAR *       description = NULL
        )
    {
        GpMetafile *    metafile = NULL;

        lastResult = DllExports::GdipRecordMetafileFileNameI(fileName,
                        referenceHdc, type, &frameRect, frameUnit,
                        description, &metafile);

        SetNativeImage(metafile);
    }

    Metafile(
        IN IStream *           stream,
        IN HDC                 referenceHdc,
        IN EmfType             type        = EmfTypeEmfPlusDual,
        IN const WCHAR *       description = NULL
        )
    {
        GpMetafile *    metafile = NULL;

        lastResult = DllExports::GdipRecordMetafileStream(stream,
                        referenceHdc, type, NULL, MetafileFrameUnitGdi,
                        description, &metafile);

        SetNativeImage(metafile);
    }

    Metafile(
        IN IStream *           stream,
        IN HDC                 referenceHdc,
        IN const RectF &       frameRect,
        IN MetafileFrameUnit   frameUnit   = MetafileFrameUnitGdi,
        IN EmfType             type        = EmfTypeEmfPlusDual,
        IN const WCHAR *       description = NULL
        )
    {
        GpMetafile *    metafile = NULL;

        lastResult = DllExports::GdipRecordMetafileStream(stream,
                        referenceHdc, type, &frameRect, frameUnit,
                        description, &metafile);

        SetNativeImage(metafile);
    }

    Metafile(
        IN IStream *           stream,
        IN HDC                 referenceHdc,
        IN const Rect &        frameRect,
        IN MetafileFrameUnit   frameUnit   = MetafileFrameUnitGdi,
        IN EmfType             type        = EmfTypeEmfPlusDual,
        IN const WCHAR *       description = NULL
        )
    {
        GpMetafile *    metafile = NULL;

        lastResult = DllExports::GdipRecordMetafileStreamI(stream,
                        referenceHdc, type, &frameRect, frameUnit,
                        description, &metafile);

        SetNativeImage(metafile);
    }

    static Status GetMetafileHeader(
        IN HMETAFILE                       hWmf,
        IN const WmfPlaceableFileHeader *  wmfPlaceableFileHeader,
        OUT MetafileHeader *               header
        )
    {
        return DllExports::GdipGetMetafileHeaderFromWmf(hWmf,
                                                        wmfPlaceableFileHeader, 
                                                        header);
    }

    static Status GetMetafileHeader(
        IN HENHMETAFILE        hEmf,
        OUT MetafileHeader *   header
        )
    {
        return DllExports::GdipGetMetafileHeaderFromEmf(hEmf, header);
    }

    static Status GetMetafileHeader(
        IN const WCHAR*        filename,
        OUT MetafileHeader *   header
        )
    {
        return DllExports::GdipGetMetafileHeaderFromFile(filename, header);
    }

    static Status GetMetafileHeader(
        IN IStream *           stream,
        OUT MetafileHeader *   header
        )
    {
        return DllExports::GdipGetMetafileHeaderFromStream(stream, header);
    }

    Status GetMetafileHeader(
        OUT MetafileHeader *    header
        ) const
    {
        return SetStatus(DllExports::GdipGetMetafileHeaderFromMetafile(
                                              (GpMetafile *)nativeImage,
                                              header));
    }

    // Once this method is called, the Metafile object is in an invalid state
    // and can no longer be used.  It is the responsiblity of the caller to
    // invoke DeleteEnhMetaFile to delete this hEmf.

    HENHMETAFILE GetHENHMETAFILE()
    {
        HENHMETAFILE hEmf;

        SetStatus(DllExports::GdipGetHemfFromMetafile(
                                  (GpMetafile *)nativeImage, 
                                  &hEmf));

        return hEmf;
    }

    // Used in conjuction with Graphics::EnumerateMetafile to play an EMF+
    // The data must be DWORD aligned if it's an EMF or EMF+.  It must be
    // WORD aligned if it's a WMF.
    
    Status PlayRecord(
        IN EmfPlusRecordType   recordType,
        IN UINT                flags,
        IN UINT                dataSize,
        IN const BYTE *        data
        ) const
    {
        return SetStatus(DllExports::GdipPlayMetafileRecord(
                                (GpMetafile *)nativeImage,
                                recordType,
                                flags,
                                dataSize,
                                data));
    }

    // If you're using a printer HDC for the metafile, but you want the
    // metafile rasterized at screen resolution, then use this API to set
    // the rasterization dpi of the metafile to the screen resolution,
    // e.g. 96 dpi or 120 dpi.
    
    Status SetDownLevelRasterizationLimit(
        IN UINT     metafileRasterizationLimitDpi
        )
    {
        return SetStatus(DllExports::
                         GdipSetMetafileDownLevelRasterizationLimit(
                                (GpMetafile *)nativeImage,
                                metafileRasterizationLimitDpi));
    }

    UINT GetDownLevelRasterizationLimit() const
    {
        UINT    metafileRasterizationLimitDpi = 0;

        SetStatus(DllExports::GdipGetMetafileDownLevelRasterizationLimit(
                                (GpMetafile *)nativeImage,
                                &metafileRasterizationLimitDpi));

        return metafileRasterizationLimitDpi;
    }

    static UINT Metafile::EmfToWmfBits(
        IN HENHMETAFILE       hemf,
        IN UINT               cbData16,
        OUT LPBYTE            pData16,
        IN INT                iMapMode = MM_ANISOTROPIC,
        IN INT                eFlags = EmfToWmfBitsFlagsDefault
    )
    {
        return DllExports::GdipEmfToWmfBits(
            hemf,
            cbData16,
            pData16,
            iMapMode,
            eFlags);
    }

protected:
    Metafile()
    {
        SetNativeImage(NULL);
        lastResult = Ok;
    }

private:
    Metafile(const Metafile &);
    Metafile& operator=(const Metafile &);
};

#endif // !_METAFILE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\sdkinc\gdiplusmatrix.h ===
/**************************************************************************\
* 
* Copyright (c) 1998-2001, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   GdiplusMatrix.h
*
* Abstract:
*
*   GDI+ Matrix class
*
\**************************************************************************/

class Matrix : public GdiplusBase
{
public:
    friend class Graphics;
    friend class GraphicsPath;
    friend class TextureBrush;
    friend class LinearGradientBrush;
    friend class PathGradientBrush;
    friend class Pen;
    friend class Region;
    
    // Default constructor is set to identity matrix.

    Matrix()
    {
        GpMatrix *matrix = NULL;

        lastResult = DllExports::GdipCreateMatrix(&matrix);
    
        SetNativeMatrix(matrix);
    }

    Matrix(IN REAL m11, 
           IN REAL m12,
           IN REAL m21, 
           IN REAL m22,
           IN REAL dx, 
           IN REAL dy)
    {
        GpMatrix *matrix = NULL;

        lastResult = DllExports::GdipCreateMatrix2(m11, m12, m21, m22, 
                                                      dx, dy, &matrix);
    
        SetNativeMatrix(matrix);
    }
    
    Matrix(IN const RectF& rect, 
           IN const PointF* dstplg)
    {
        GpMatrix *matrix = NULL;

        lastResult = DllExports::GdipCreateMatrix3(&rect, 
                                                   dstplg,
                                                   &matrix);

        SetNativeMatrix(matrix);
    }

    Matrix(IN const Rect& rect, 
           IN const Point* dstplg)
    {
        GpMatrix *matrix = NULL;

        lastResult = DllExports::GdipCreateMatrix3I(&rect, 
                                                    dstplg,
                                                    &matrix);

        SetNativeMatrix(matrix);
    }

    ~Matrix()
    {
        DllExports::GdipDeleteMatrix(nativeMatrix);
    }

    Matrix *Clone() const
    {
        GpMatrix *cloneMatrix = NULL;

        SetStatus(DllExports::GdipCloneMatrix(nativeMatrix,
                                                  &cloneMatrix));

        if (lastResult != Ok)
            return NULL;

        return new Matrix(cloneMatrix);
    }

    Status GetElements(OUT REAL *m) const 
    {
        return SetStatus(DllExports::GdipGetMatrixElements(nativeMatrix, m));
    }
    
    Status SetElements(IN REAL m11, 
                       IN REAL m12, 
                       IN REAL m21, 
                       IN REAL m22, 
                       IN REAL dx, 
                       IN REAL dy)
    {
        return SetStatus(DllExports::GdipSetMatrixElements(nativeMatrix,
                            m11, m12, m21, m22, dx, dy));
    }

    REAL OffsetX() const
    {
        REAL elements[6];

        if (GetElements(&elements[0]) == Ok)
            return elements[4];
        else 
            return 0.0f;
    }

    REAL OffsetY() const
    {
       REAL elements[6];

       if (GetElements(&elements[0]) == Ok)
           return elements[5];
       else 
           return 0.0f;
    }

    Status Reset()
    {
        // set identity matrix elements 
        return SetStatus(DllExports::GdipSetMatrixElements(nativeMatrix,
                                             1.0, 0.0, 0.0, 1.0, 0.0, 0.0));
    }

    Status Multiply(IN const Matrix *matrix, 
                    IN MatrixOrder order = MatrixOrderPrepend)
    {
        return SetStatus(DllExports::GdipMultiplyMatrix(nativeMatrix, 
                                          matrix->nativeMatrix,
                                          order));
    }

    Status Translate(IN REAL offsetX, 
                     IN REAL offsetY, 
                     IN MatrixOrder order = MatrixOrderPrepend)
    {
        return SetStatus(DllExports::GdipTranslateMatrix(nativeMatrix, offsetX,
                                                         offsetY, order));
    }

    Status Scale(IN REAL scaleX, 
                 IN REAL scaleY, 
                 IN MatrixOrder order = MatrixOrderPrepend)
    {
        return SetStatus(DllExports::GdipScaleMatrix(nativeMatrix, scaleX, 
                                                     scaleY, order));
    }

    Status Rotate(IN REAL angle, 
                  IN MatrixOrder order = MatrixOrderPrepend)
    {
        return SetStatus(DllExports::GdipRotateMatrix(nativeMatrix, angle, 
                                                      order));
    }
    
    Status RotateAt(IN REAL angle, 
                    IN const PointF& center, 
                    IN MatrixOrder order = MatrixOrderPrepend)
    {
        if(order == MatrixOrderPrepend)
        {
            SetStatus(DllExports::GdipTranslateMatrix(nativeMatrix, center.X,
                                                      center.Y, order));
            SetStatus(DllExports::GdipRotateMatrix(nativeMatrix, angle, 
                                                   order));
            return SetStatus(DllExports::GdipTranslateMatrix(nativeMatrix,
                                                             -center.X, 
                                                             -center.Y, 
                                                             order));
        }
        else
        {
            SetStatus(DllExports::GdipTranslateMatrix(nativeMatrix, 
                                                      - center.X, 
                                                      - center.Y, 
                                                      order));
            SetStatus(DllExports::GdipRotateMatrix(nativeMatrix, angle, 
                                                   order));
            return SetStatus(DllExports::GdipTranslateMatrix(nativeMatrix, 
                                                             center.X, 
                                                             center.Y, 
                                                             order));
        }
    }

    Status Shear(IN REAL shearX, 
                 IN REAL shearY,
                 IN MatrixOrder order = MatrixOrderPrepend)
    {
        return SetStatus(DllExports::GdipShearMatrix(nativeMatrix, shearX, 
                                                     shearY, order));
    }

    Status Invert()
    {
        return SetStatus(DllExports::GdipInvertMatrix(nativeMatrix));
    }

    // float version
    Status TransformPoints(IN OUT PointF* pts, 
                           IN INT count = 1) const
    {
        return SetStatus(DllExports::GdipTransformMatrixPoints(nativeMatrix, 
                                                               pts, count));
    }
    
    Status TransformPoints(IN OUT Point* pts, 
                           IN INT count = 1) const
    {
        return SetStatus(DllExports::GdipTransformMatrixPointsI(nativeMatrix, 
                                                                pts, 
                                                                count));
    }

    Status TransformVectors(IN OUT PointF* pts, 
                            IN INT count = 1) const
    { 
        return SetStatus(DllExports::GdipVectorTransformMatrixPoints(
                                        nativeMatrix, pts, count));
    }

    Status TransformVectors(IN OUT Point* pts, 
                            IN INT count = 1) const
    { 
       return SetStatus(DllExports::GdipVectorTransformMatrixPointsI(
                                        nativeMatrix, 
                                        pts, 
                                        count));
    }
    
    BOOL IsInvertible() const
    {
        BOOL result = FALSE;

        SetStatus(DllExports::GdipIsMatrixInvertible(nativeMatrix, &result));
    
        return result;
    }

    BOOL IsIdentity() const
    {
       BOOL result = FALSE;

       SetStatus(DllExports::GdipIsMatrixIdentity(nativeMatrix, &result));
    
       return result;
    }

    BOOL Equals(IN const Matrix *matrix) const
    {
       BOOL result = FALSE;

       SetStatus(DllExports::GdipIsMatrixEqual(nativeMatrix,
                                               matrix->nativeMatrix, 
                                               &result));
   
       return result;
    }
    
    Status GetLastStatus() const
    {
        Status lastStatus = lastResult;
        lastResult = Ok;
 
        return lastStatus;
    }

private:
    Matrix(const Matrix &);
    Matrix& operator=(const Matrix &);

protected:
    Matrix(GpMatrix *nativeMatrix)
    {
        lastResult = Ok;
        SetNativeMatrix(nativeMatrix);
    }
    
    VOID SetNativeMatrix(GpMatrix *nativeMatrix)
    {
        this->nativeMatrix = nativeMatrix;
    }

    Status SetStatus(Status status) const
    {
        if (status != Ok)
            return (lastResult = status);
        else
            return status;
    }

protected:
    GpMatrix *nativeMatrix;
    mutable Status lastResult;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\gpinit.cpp ===
/**************************************************************************
*
* Copyright (c) 2000 Microsoft Corporation
*
* Module Name:
*
*   Helper for GDI+ initialization
*
* Abstract:
*
*   This code initializes GDI+ (with default parameters).
*   The code is probably specific to our compiler, because it uses #pragma to
*   get our code to be initialized before the app's other global objects.
*   The ordering is important when apps make global GDI+ objects.
*
* Notes:
*
*   An app should check gGdiplusInitHelper.IsValid() in its main function,
*   and abort if it returns FALSE.
*
* Created:
*
*   09/18/2000 agodfrey
*      Created it.
*
**************************************************************************/

#include <objbase.h>
#include "gdiplus.h"
#include "gpinit.h"

GdiplusInitHelper::GdiplusInitHelper() : gpToken(0), Valid(FALSE)
{
    Gdiplus::GdiplusStartupInput sti;
    if (Gdiplus::GdiplusStartup(&gpToken, &sti, NULL) == Gdiplus::Ok)
    {
        Valid = TRUE;
    }
}
    
GdiplusInitHelper::~GdiplusInitHelper()
{
    if (Valid)
    {
        Gdiplus::GdiplusShutdown(gpToken);
    }
}

// Disable the stupid warning that says we have a "lib" code segment.
#pragma warning( push )
#pragma warning( disable : 4073 )

// Make a separate code segment, and mark it as a "library initialization"
// segment
#pragma code_seg( "GpInit" )
#pragma init_seg( lib )

// Declare the global in this code segment, so that it is initialized before/
// destroyed after the app's globals.

GdiplusInitHelper gGdiplusInitHelper;

// Reset the code segment to "whatever it was when compilation began".

#pragma code_seg()

#pragma warning( pop )
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\sdkinc\gdiplusmetaheader.h ===
/**************************************************************************\
*
* Copyright (c) 1998-2001, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   Metafile headers
*
* Abstract:
*
*   GDI+ Metafile Related Structures
*
\**************************************************************************/

#ifndef _GDIPLUSMETAHEADER_H
#define _GDIPLUSMETAHEADER_H

typedef struct
{
    DWORD   iType;              // Record type EMR_HEADER
    DWORD   nSize;              // Record size in bytes.  This may be greater
                                // than the sizeof(ENHMETAHEADER).
    RECTL   rclBounds;          // Inclusive-inclusive bounds in device units
    RECTL   rclFrame;           // Inclusive-inclusive Picture Frame .01mm unit
    DWORD   dSignature;         // Signature.  Must be ENHMETA_SIGNATURE.
    DWORD   nVersion;           // Version number
    DWORD   nBytes;             // Size of the metafile in bytes
    DWORD   nRecords;           // Number of records in the metafile
    WORD    nHandles;           // Number of handles in the handle table
                                // Handle index zero is reserved.
    WORD    sReserved;          // Reserved.  Must be zero.
    DWORD   nDescription;       // Number of chars in the unicode desc string
                                // This is 0 if there is no description string
    DWORD   offDescription;     // Offset to the metafile description record.
                                // This is 0 if there is no description string
    DWORD   nPalEntries;        // Number of entries in the metafile palette.
    SIZEL   szlDevice;          // Size of the reference device in pels
    SIZEL   szlMillimeters;     // Size of the reference device in millimeters
} ENHMETAHEADER3;

// Placeable WMFs

// Placeable Metafiles were created as a non-standard way of specifying how 
// a metafile is mapped and scaled on an output device.
// Placeable metafiles are quite wide-spread, but not directly supported by
// the Windows API. To playback a placeable metafile using the Windows API,
// you will first need to strip the placeable metafile header from the file.
// This is typically performed by copying the metafile to a temporary file
// starting at file offset 22 (0x16). The contents of the temporary file may
// then be used as input to the Windows GetMetaFile(), PlayMetaFile(),
// CopyMetaFile(), etc. GDI functions.

// Each placeable metafile begins with a 22-byte header,
//  followed by a standard metafile:

#include <pshpack2.h>   // set structure packing to 2

typedef struct
{
    INT16           Left;
    INT16           Top;
    INT16           Right;
    INT16           Bottom;
} PWMFRect16;

typedef struct
{
    UINT32          Key;            // GDIP_WMF_PLACEABLEKEY
    INT16           Hmf;            // Metafile HANDLE number (always 0)
    PWMFRect16      BoundingBox;    // Coordinates in metafile units
    INT16           Inch;           // Number of metafile units per inch
    UINT32          Reserved;       // Reserved (always 0)
    INT16           Checksum;       // Checksum value for previous 10 WORDs
} WmfPlaceableFileHeader;

#include <poppack.h>

// Key contains a special identification value that indicates the presence
// of a placeable metafile header and is always 0x9AC6CDD7.

// Handle is used to stored the handle of the metafile in memory. When written
// to disk, this field is not used and will always contains the value 0.

// Left, Top, Right, and Bottom contain the coordinates of the upper-left
// and lower-right corners of the image on the output device. These are
// measured in twips.

// A twip (meaning "twentieth of a point") is the logical unit of measurement
// used in Windows Metafiles. A twip is equal to 1/1440 of an inch. Thus 720
// twips equal 1/2 inch, while 32,768 twips is 22.75 inches.

// Inch contains the number of twips per inch used to represent the image.
// Normally, there are 1440 twips per inch; however, this number may be
// changed to scale the image. A value of 720 indicates that the image is
// double its normal size, or scaled to a factor of 2:1. A value of 360
// indicates a scale of 4:1, while a value of 2880 indicates that the image
// is scaled down in size by a factor of two. A value of 1440 indicates
// a 1:1 scale ratio.

// Reserved is not used and is always set to 0.

// Checksum contains a checksum value for the previous 10 WORDs in the header.
// This value can be used in an attempt to detect if the metafile has become
// corrupted. The checksum is calculated by XORing each WORD value to an
// initial value of 0.

// If the metafile was recorded with a reference Hdc that was a display.

#define GDIP_EMFPLUSFLAGS_DISPLAY       0x00000001

class MetafileHeader
{
public:
    MetafileType        Type;
    UINT                Size;               // Size of the metafile (in bytes)
    UINT                Version;            // EMF+, EMF, or WMF version
    UINT                EmfPlusFlags;
    REAL                DpiX;
    REAL                DpiY;
    INT                 X;                  // Bounds in device units
    INT                 Y;
    INT                 Width;
    INT                 Height;
    union
    {
        METAHEADER      WmfHeader;
        ENHMETAHEADER3  EmfHeader;
    };
    INT                 EmfPlusHeaderSize;  // size of the EMF+ header in file
    INT                 LogicalDpiX;        // Logical Dpi of reference Hdc
    INT                 LogicalDpiY;        // usually valid only for EMF+

public:
    MetafileType GetType() const { return Type; }

    UINT GetMetafileSize() const { return Size; }

    // If IsEmfPlus, this is the EMF+ version; else it is the WMF or EMF ver
    
    UINT GetVersion() const { return Version; }

    // Get the EMF+ flags associated with the metafile
    
    UINT GetEmfPlusFlags() const { return EmfPlusFlags; }

    REAL GetDpiX() const { return DpiX; }

    REAL GetDpiY() const { return DpiY; }

    VOID GetBounds (OUT Rect *rect) const
    {
        rect->X = X;
        rect->Y = Y;
        rect->Width = Width;
        rect->Height = Height;
    }
    
    // Is it any type of WMF (standard or Placeable Metafile)?
    
    BOOL IsWmf() const
    {
       return ((Type == MetafileTypeWmf) || (Type == MetafileTypeWmfPlaceable));
    }

    // Is this an Placeable Metafile?

    BOOL IsWmfPlaceable() const { return (Type == MetafileTypeWmfPlaceable); }

    // Is this an EMF (not an EMF+)?
    
    BOOL IsEmf() const { return (Type == MetafileTypeEmf); }

    // Is this an EMF or EMF+ file?
    
    BOOL IsEmfOrEmfPlus() const { return (Type >= MetafileTypeEmf); }

    // Is this an EMF+ file?
    
    BOOL IsEmfPlus() const { return (Type >= MetafileTypeEmfPlusOnly); }

    // Is this an EMF+ dual (has dual, down-level records) file?
    
    BOOL IsEmfPlusDual() const { return (Type == MetafileTypeEmfPlusDual); }

    // Is this an EMF+ only (no dual records) file?
    
    BOOL IsEmfPlusOnly() const { return (Type == MetafileTypeEmfPlusOnly); }

    // If it's an EMF+ file, was it recorded against a display Hdc?
    
    BOOL IsDisplay() const
    {
        return (IsEmfPlus() &&
                ((EmfPlusFlags & GDIP_EMFPLUSFLAGS_DISPLAY) != 0));
    }

    // Get the WMF header of the metafile (if it is a WMF)
    
    const METAHEADER * GetWmfHeader() const
    {
        if (IsWmf())
        {
            return &WmfHeader;
        }
        return NULL;
    }

    // Get the EMF header of the metafile (if it is an EMF)
    
    const ENHMETAHEADER3 * GetEmfHeader() const
    {
        if (IsEmfOrEmfPlus())
        {
            return &EmfHeader;
        }
        return NULL;
    }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\sdkinc\gdipluspath.h ===
/**************************************************************************\
*
* Copyright (c) 1998-2001, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   GdiplusPath.h
*
* Abstract:
*
*   GDI+ Graphics Path class
*
\**************************************************************************/

#ifndef _GDIPLUSPATH_H
#define _GDIPLUSPATH_H

class GraphicsPath : public GdiplusBase
{
public:
    friend class Graphics;
    friend class Region;
    friend class PathGradientBrush;
    friend class GraphicsPathIterator;
    friend class CustomLineCap;

    GraphicsPath(IN FillMode fillMode = FillModeAlternate)
    {
        nativePath = NULL;
        lastResult = DllExports::GdipCreatePath(fillMode, &nativePath);
    }

    GraphicsPath(IN const PointF* points,
                 IN const BYTE* types,
                 IN INT count,
                 IN FillMode fillMode = FillModeAlternate)
    {
        nativePath = NULL;
        lastResult = DllExports::GdipCreatePath2(points,
                                                 types,
                                                 count,
                                                 fillMode,
                                                 &nativePath);
    }

    GraphicsPath(IN const Point* points,
                 IN const BYTE* types,
                 IN INT count,
                 IN FillMode fillMode = FillModeAlternate)
    {
        nativePath = NULL;
        lastResult = DllExports::GdipCreatePath2I(points,
                                                  types,
                                                  count,
                                                  fillMode,
                                                  &nativePath);
    }

    ~GraphicsPath()
    {
        DllExports::GdipDeletePath(nativePath);
    }

    GraphicsPath* Clone() const
    {
        GpPath *clonepath = NULL;

        SetStatus(DllExports::GdipClonePath(nativePath, &clonepath));

        return new GraphicsPath(clonepath);
    }

    // Reset the path object to empty (and fill mode to FillModeAlternate)

    Status Reset()
    {
        return SetStatus(DllExports::GdipResetPath(nativePath));
    }

    FillMode GetFillMode() const
    {
        FillMode fillmode = FillModeAlternate;

        SetStatus(DllExports::GdipGetPathFillMode(nativePath, &fillmode));

        return fillmode;
    }

    Status SetFillMode(IN FillMode fillmode)
    {
        return SetStatus(DllExports::GdipSetPathFillMode(nativePath, 
                                                         fillmode));
    }

    Status GetPathData(OUT PathData* pathData) const
    {
        if (pathData == NULL) 
        {
            return SetStatus(InvalidParameter);
        }
        
        INT count = GetPointCount();
        
        if ((count <= 0) || (pathData->Count>0 && pathData->Count<count))
        {
            pathData->Count = 0;
            if (pathData->Points)
            {
                delete pathData->Points;
                pathData->Points = NULL;
            }

            if (pathData->Types) 
            {
                delete pathData->Types;
                pathData->Types = NULL;
            }

            if (count <= 0)
            {
                return lastResult;
            }
        }

        if (pathData->Count == 0) 
        {
            pathData->Points = new PointF[count];
            if (pathData->Points == NULL) 
            {
                return SetStatus(OutOfMemory);
            
            }
            pathData->Types = new byte[count];
            if (pathData->Types == NULL) 
            {
                delete pathData->Points;
                pathData->Points = NULL;

                return SetStatus(OutOfMemory);
            }
            pathData->Count = count;
        }

        return SetStatus(DllExports::GdipGetPathData(nativePath, pathData));
    }

    Status StartFigure()
    {
        return SetStatus(DllExports::GdipStartPathFigure(nativePath));
    }

    Status CloseFigure()
    {
        return SetStatus(DllExports::GdipClosePathFigure(nativePath));
    }

    Status CloseAllFigures()
    {
        return SetStatus(DllExports::GdipClosePathFigures(nativePath));
    }

    Status SetMarker()
    {
        return SetStatus(DllExports::GdipSetPathMarker(nativePath));
    }

    Status ClearMarkers()
    {
        return SetStatus(DllExports::GdipClearPathMarkers(nativePath));
    }

    Status Reverse()
    {
        return SetStatus(DllExports::GdipReversePath(nativePath));
    }

    Status GetLastPoint(OUT PointF* lastPoint) const
    {
        return SetStatus(DllExports::GdipGetPathLastPoint(nativePath, 
                                                          lastPoint));
    }

    Status AddLine(IN const PointF& pt1, 
                   IN const PointF& pt2)
    {
        return AddLine(pt1.X, pt1.Y, pt2.X, pt2.Y);
    }

    Status AddLine(IN REAL x1,
                   IN REAL y1, 
                   IN REAL x2, 
                   IN REAL y2)
    {
        return SetStatus(DllExports::GdipAddPathLine(nativePath, x1, y1, 
                                                     x2, y2));
    }

    Status AddLines(IN const PointF* points, 
                    IN INT count)
    {
        return SetStatus(DllExports::GdipAddPathLine2(nativePath, points, 
                                                      count));
    }

    Status AddLine(IN const Point& pt1, 
                   IN const Point& pt2)
    {
        return AddLine(pt1.X,
                       pt1.Y,
                       pt2.X,
                       pt2.Y);
    }

    Status AddLine(IN INT x1, 
                   IN INT y1, 
                   IN INT x2, 
                   IN INT y2)
    {
        return SetStatus(DllExports::GdipAddPathLineI(nativePath,
                                                     x1,
                                                     y1,
                                                     x2,
                                                     y2));
    }

    Status AddLines(IN const Point* points, 
                    IN INT count)
    {
        return SetStatus(DllExports::GdipAddPathLine2I(nativePath,
                                                       points,
                                                       count));
    }

    Status AddArc(IN const RectF& rect, 
                  IN REAL startAngle, 
                  IN REAL sweepAngle)
    {
        return AddArc(rect.X, rect.Y, rect.Width, rect.Height,
                      startAngle, sweepAngle);
    }

    Status AddArc(IN REAL x, 
                  IN REAL y, 
                  IN REAL width, 
                  IN REAL height,
                  IN REAL startAngle, 
                  IN REAL sweepAngle)
    {
        return SetStatus(DllExports::GdipAddPathArc(nativePath, x, y, width, 
                                                    height, startAngle, 
                                                    sweepAngle));
    }

    Status AddArc(IN const Rect& rect, 
                  IN REAL startAngle, 
                  IN REAL sweepAngle)
    {
        return AddArc(rect.X, rect.Y, rect.Width, rect.Height,
                      startAngle, sweepAngle);
    }

    Status AddArc(IN INT x, 
                  IN INT y, 
                  IN INT width, 
                  IN INT height,
                  IN REAL startAngle, 
                  IN REAL sweepAngle)
    {
        return SetStatus(DllExports::GdipAddPathArcI(nativePath,
                                                    x,
                                                    y,
                                                    width,
                                                    height,
                                                    startAngle,
                                                    sweepAngle));
    }

    Status AddBezier(IN const PointF& pt1, 
                     IN const PointF& pt2,
                     IN const PointF& pt3, 
                     IN const PointF& pt4)
    {
        return AddBezier(pt1.X, pt1.Y, pt2.X, pt2.Y, pt3.X, pt3.Y, pt4.X,
                         pt4.Y);
    }

    Status AddBezier(IN REAL x1, 
                     IN REAL y1, 
                     IN REAL x2, 
                     IN REAL y2,
                     IN REAL x3, 
                     IN REAL y3, 
                     IN REAL x4, 
                     IN REAL y4)
    {
        return SetStatus(DllExports::GdipAddPathBezier(nativePath, x1, y1, x2, 
                                                       y2, x3, y3, x4, y4));
    }

    Status AddBeziers(IN const PointF* points, 
                      IN INT count)
    {
        return SetStatus(DllExports::GdipAddPathBeziers(nativePath, points, 
                                                        count));
    }

    Status AddBezier(IN const Point& pt1, 
                     IN const Point& pt2,
                     IN const Point& pt3, 
                     IN const Point& pt4)
    {
       return AddBezier(pt1.X, pt1.Y, pt2.X, pt2.Y, pt3.X, pt3.Y, pt4.X,
                        pt4.Y);
    }

    Status AddBezier(IN INT x1, 
                     IN INT y1, 
                     IN INT x2, 
                     IN INT y2,
                     IN INT x3,
                     IN INT y3, 
                     IN INT x4, 
                     IN INT y4)
    {
       return SetStatus(DllExports::GdipAddPathBezierI(nativePath,
                                                      x1,
                                                      y1,
                                                      x2,
                                                      y2,
                                                      x3,
                                                      y3,
                                                      x4,
                                                      y4));
    }

    Status AddBeziers(IN const Point* points,
                      IN INT count)
    {
       return SetStatus(DllExports::GdipAddPathBeziersI(nativePath,
                                                        points,
                                                        count));
    }

    Status AddCurve(IN const PointF* points, 
                    IN INT count)
    {
        return SetStatus(DllExports::GdipAddPathCurve(nativePath,
                                                      points,
                                                      count));
    }

    Status AddCurve(IN const PointF* points, 
                    IN INT count,
                    IN REAL tension)
    {
        return SetStatus(DllExports::GdipAddPathCurve2(nativePath,
                                                       points,
                                                       count,
                                                       tension));
    }

    Status AddCurve(IN const PointF* points, 
                    IN INT count, 
                    IN INT offset,
                    IN INT numberOfSegments, 
                    IN REAL tension)
    {
        return SetStatus(DllExports::GdipAddPathCurve3(nativePath,
                                                       points,
                                                       count,
                                                       offset,
                                                       numberOfSegments,
                                                       tension));
    }

    Status AddCurve(IN const Point* points, 
                    IN INT count)
    {
       return SetStatus(DllExports::GdipAddPathCurveI(nativePath,
                                                     points,
                                                     count));
    }

    Status AddCurve(IN const Point* points, 
                    IN INT count, 
                    IN REAL tension)
    {
       return SetStatus(DllExports::GdipAddPathCurve2I(nativePath,
                                                      points,
                                                      count,
                                                      tension));
    }

    Status AddCurve(IN const Point* points, 
                    IN INT count, 
                    IN INT offset,
                    IN INT numberOfSegments, 
                    IN REAL tension)
    {
       return SetStatus(DllExports::GdipAddPathCurve3I(nativePath,
                                                      points,
                                                      count,
                                                      offset,
                                                      numberOfSegments,
                                                      tension));
    }

    Status AddClosedCurve(IN const PointF* points, 
                          IN INT count)
    {
        return SetStatus(DllExports::GdipAddPathClosedCurve(nativePath,
                                                            points,
                                                            count));
    }

    Status AddClosedCurve(IN const PointF* points, 
                          IN INT count, 
                          IN REAL tension)
    {
        return SetStatus(DllExports::GdipAddPathClosedCurve2(nativePath,
                                                             points,
                                                             count,
                                                             tension));
    }

    Status AddClosedCurve(IN const Point* points, 
                          IN INT count)
    {
       return SetStatus(DllExports::GdipAddPathClosedCurveI(nativePath,
                                                            points,
                                                            count));
    }


    Status AddClosedCurve(IN const Point* points, 
                          IN INT count,
                          IN REAL tension)
    {
       return SetStatus(DllExports::GdipAddPathClosedCurve2I(nativePath,
                                                             points,
                                                             count,
                                                             tension));
    }

    Status AddRectangle(IN const RectF& rect)
    {
        return SetStatus(DllExports::GdipAddPathRectangle(nativePath,
                                                          rect.X,
                                                          rect.Y,
                                                          rect.Width,
                                                          rect.Height));
    }

    Status AddRectangles(IN const RectF* rects, 
                         IN INT count)
    {
        return SetStatus(DllExports::GdipAddPathRectangles(nativePath,
                                                           rects,
                                                           count));
    }

    Status AddRectangle(IN const Rect& rect)
    {
        return SetStatus(DllExports::GdipAddPathRectangleI(nativePath,
                                                          rect.X,
                                                          rect.Y,
                                                          rect.Width,
                                                          rect.Height));
    }

    Status AddRectangles(IN const Rect* rects, INT count)
    {
        return SetStatus(DllExports::GdipAddPathRectanglesI(nativePath,
                                                           rects,
                                                           count));
    }

    Status AddEllipse(IN const RectF& rect)
    {
        return AddEllipse(rect.X, rect.Y, rect.Width, rect.Height);
    }

    Status AddEllipse(IN REAL x, 
                      IN REAL y, 
                      IN REAL width, 
                      IN REAL height)
    {
        return SetStatus(DllExports::GdipAddPathEllipse(nativePath,
                                                        x,
                                                        y,
                                                        width,
                                                        height));
    }

    Status AddEllipse(IN const Rect& rect)
    {
        return AddEllipse(rect.X, rect.Y, rect.Width, rect.Height);
    }

    Status AddEllipse(IN INT x, 
                      IN INT y, 
                      IN INT width, 
                      IN INT height)
    {
        return SetStatus(DllExports::GdipAddPathEllipseI(nativePath,
                                                        x,
                                                        y,
                                                        width,
                                                        height));
    }

    Status AddPie(IN const RectF& rect, 
                  IN REAL startAngle, 
                  IN REAL sweepAngle)
    {
        return AddPie(rect.X, rect.Y, rect.Width, rect.Height, startAngle,
                      sweepAngle);
    }

    Status AddPie(IN REAL x, 
                  IN REAL y, 
                  IN REAL width, 
                  IN REAL height, 
                  IN REAL startAngle,
                  IN REAL sweepAngle)
    {
        return SetStatus(DllExports::GdipAddPathPie(nativePath, x, y, width,
                                                    height, startAngle, 
                                                    sweepAngle));
    }

    Status AddPie(IN const Rect& rect, 
                  IN REAL startAngle, 
                  IN REAL sweepAngle)
    {
        return AddPie(rect.X,
                      rect.Y,
                      rect.Width,
                      rect.Height,
                      startAngle,
                      sweepAngle);
    }

    Status AddPie(IN INT x, 
                  IN INT y, 
                  IN INT width, 
                  IN INT height, 
                  IN REAL startAngle,
                  IN REAL sweepAngle)
    {
        return SetStatus(DllExports::GdipAddPathPieI(nativePath,
                                                    x,
                                                    y,
                                                    width,
                                                    height,
                                                    startAngle,
                                                    sweepAngle));
    }

    Status AddPolygon(IN const PointF* points, 
                      IN INT count)
    {
        return SetStatus(DllExports::GdipAddPathPolygon(nativePath, points, 
                                                        count));
    }

    Status AddPolygon(IN const Point* points, 
                      IN INT count)
    {
       return SetStatus(DllExports::GdipAddPathPolygonI(nativePath, points, 
                                                        count));
    }

    Status AddPath(IN const GraphicsPath* addingPath, 
                   IN BOOL connect)
    {
        GpPath* nativePath2 = NULL;
        if(addingPath)
            nativePath2 = addingPath->nativePath;

        return SetStatus(DllExports::GdipAddPathPath(nativePath, nativePath2, 
                                                     connect));
    }

    Status AddString(
        IN const WCHAR         *string,
        IN INT                  length,
        IN const FontFamily    *family,
        IN INT                  style,
        IN REAL                 emSize,  // World units
        IN const PointF        &origin,
        IN const StringFormat  *format
    )
    {
        RectF rect(origin.X, origin.Y, 0.0f, 0.0f);

        return SetStatus(DllExports::GdipAddPathString(
            nativePath,
            string,
            length,
            family ? family->nativeFamily : NULL,
            style,
            emSize,
            &rect,
            format ? format->nativeFormat : NULL
        ));
    }

    Status AddString(
        IN const WCHAR         *string,
        IN INT                  length,
        IN const FontFamily    *family,
        IN INT                  style,
        IN REAL                 emSize,  // World units
        IN const RectF         &layoutRect,
        IN const StringFormat  *format
    )
    {
        return SetStatus(DllExports::GdipAddPathString(
            nativePath,
            string,
            length,
            family ? family->nativeFamily : NULL,
            style,
            emSize,
            &layoutRect,
            format ? format->nativeFormat : NULL
        ));
    }

    Status AddString(
        IN const WCHAR         *string,
        IN INT                  length,
        IN const FontFamily    *family,
        IN INT                  style,
        IN REAL                 emSize,  // World units
        IN const Point         &origin,
        IN const StringFormat  *format
    )
    {
        Rect rect(origin.X, origin.Y, 0, 0);

        return SetStatus(DllExports::GdipAddPathStringI(
            nativePath,
            string,
            length,
            family ? family->nativeFamily : NULL,
            style,
            emSize,
            &rect,
            format ? format->nativeFormat : NULL
        ));
    }

    Status AddString(
        IN const WCHAR         *string,
        IN INT                  length,
        IN const FontFamily    *family,
        IN INT                  style,
        IN REAL                 emSize,  // World units
        IN const Rect          &layoutRect,
        IN const StringFormat  *format
    )
    {
        return SetStatus(DllExports::GdipAddPathStringI(
            nativePath,
            string,
            length,
            family ? family->nativeFamily : NULL,
            style,
            emSize,
            &layoutRect,
            format ? format->nativeFormat : NULL
        ));
    }
    
    Status Transform(IN const Matrix* matrix)
    {
        if(matrix)
            return SetStatus(DllExports::GdipTransformPath(nativePath, 
                                                      matrix->nativeMatrix));
        else
            return Ok;
    }

    // This is not always the tightest bounds.

    Status GetBounds(OUT RectF* bounds, 
                     IN const Matrix* matrix = NULL, 
                     IN const Pen* pen = NULL) const;

    Status GetBounds(OUT Rect* bounds,
                     IN const Matrix* matrix = NULL, 
                     IN const Pen* pen = NULL) const;

    // Once flattened, the resultant path is made of line segments and
    // the original path information is lost.  When matrix is NULL the
    // identity matrix is assumed.
        
    Status Flatten(IN const Matrix* matrix = NULL, 
                   IN REAL flatness = FlatnessDefault)
    {
        GpMatrix* nativeMatrix = NULL;
        if(matrix)
        {
            nativeMatrix = matrix->nativeMatrix;
        }

        return SetStatus(DllExports::GdipFlattenPath(
            nativePath, 
            nativeMatrix, 
            flatness
        ));
    }

    Status Widen(
        IN const Pen* pen, 
        IN const Matrix* matrix = NULL,
        IN REAL flatness = FlatnessDefault
    )
    {
        GpMatrix* nativeMatrix = NULL;
        if(matrix)
            nativeMatrix = matrix->nativeMatrix;

        return SetStatus(DllExports::GdipWidenPath(
            nativePath, 
            pen->nativePen,
            nativeMatrix, 
            flatness
        ));
    }

    Status Outline(
        IN const Matrix *matrix = NULL,
        IN REAL flatness = FlatnessDefault
    )
    {
        GpMatrix* nativeMatrix = NULL;
        if(matrix)
        {
            nativeMatrix = matrix->nativeMatrix;
        }

        return SetStatus(DllExports::GdipWindingModeOutline(
            nativePath, nativeMatrix, flatness
        ));
    }
    
    // Once this is called, the resultant path is made of line segments and
    // the original path information is lost.  When matrix is NULL, the 
    // identity matrix is assumed.
    
    Status Warp(IN const PointF* destPoints, 
                IN INT count,
                IN const RectF& srcRect, 
                IN const Matrix* matrix = NULL,
                IN WarpMode warpMode = WarpModePerspective,
                IN REAL flatness = FlatnessDefault)
    {
        GpMatrix* nativeMatrix = NULL;
        if(matrix)
            nativeMatrix = matrix->nativeMatrix;

        return SetStatus(DllExports::GdipWarpPath(
                                        nativePath,
                                        nativeMatrix,
                                        destPoints,
                                        count,
                                        srcRect.X,
                                        srcRect.Y,
                                        srcRect.Width,
                                        srcRect.Height,
                                        warpMode,
                                        flatness));
    }

    INT GetPointCount() const
    {
        INT count = 0;

        SetStatus(DllExports::GdipGetPointCount(nativePath, &count));

        return count;
    }

    Status GetPathTypes(OUT BYTE* types, 
                        IN INT count) const
    {
        return SetStatus(DllExports::GdipGetPathTypes(nativePath, types,
                                                      count));
    }

    Status GetPathPoints(OUT PointF* points, 
                         IN INT count) const
    {
        return SetStatus(DllExports::GdipGetPathPoints(nativePath, points, 
                                                       count));
    }

    Status GetPathPoints(OUT Point* points, 
                         IN INT count) const
    {
        return SetStatus(DllExports::GdipGetPathPointsI(nativePath, points, 
                                                        count));
    }

    Status GetLastStatus() const
    {
        Status lastStatus = lastResult;
        lastResult = Ok;

        return lastStatus;
    }

    BOOL IsVisible(IN const PointF& point, 
                   IN const Graphics* g = NULL) const
    {
        return IsVisible(point.X, point.Y, g);
    }
    
    BOOL IsVisible(IN REAL x, 
                   IN REAL y, 
                   IN const Graphics* g = NULL) const;

    BOOL IsVisible(IN const Point& point,
                   IN const Graphics* g = NULL) const
    {
        return IsVisible(point.X, point.Y, g);
    }

    BOOL IsVisible(IN INT x, 
                   IN INT y, 
                   IN const Graphics* g = NULL) const;
    
    BOOL IsOutlineVisible(IN const PointF& point,
                          IN const Pen* pen, 
                          IN const Graphics* g = NULL) const
    {
        return IsOutlineVisible(point.X, point.Y, pen, g);
    }

    BOOL IsOutlineVisible(IN REAL x, 
                          IN REAL y, 
                          IN const Pen* pen, 
                          IN const Graphics* g = NULL) const;

    BOOL IsOutlineVisible(IN const Point& point,
                          IN const Pen* pen, 
                          IN const Graphics* g = NULL) const
    {
        return IsOutlineVisible(point.X, point.Y, pen, g);
    }
    
    BOOL IsOutlineVisible(IN INT x, 
                          IN INT y, 
                          IN const Pen* pen, 
                          IN const Graphics* g = NULL) const;

protected:

    GraphicsPath(const GraphicsPath& path)
    {
        GpPath *clonepath = NULL;
        SetStatus(DllExports::GdipClonePath(path.nativePath, &clonepath));
        SetNativePath(clonepath);
    }

private:
    GraphicsPath& operator=(const GraphicsPath &);

protected:
    GraphicsPath(GpPath* nativePath)
    {
        lastResult = Ok;
        SetNativePath(nativePath);
    }

    VOID SetNativePath(GpPath *nativePath)
    {
        this->nativePath = nativePath;
    }

    Status SetStatus(Status status) const
    {
        if (status != Ok)
            return (lastResult = status);
        else
            return status;
    }

protected:
    GpPath* nativePath;
    mutable Status lastResult;
};


//--------------------------------------------------------------------------
// GraphisPathIterator class
//--------------------------------------------------------------------------

class GraphicsPathIterator : public GdiplusBase
{
public:

    GraphicsPathIterator(IN const GraphicsPath* path)
    {
        GpPath* nativePath = NULL;
        if(path)
            nativePath = path->nativePath;

        GpPathIterator *iter = NULL;
        lastResult = DllExports::GdipCreatePathIter(&iter, nativePath);
        SetNativeIterator(iter);
    }

    ~GraphicsPathIterator()
    {
        DllExports::GdipDeletePathIter(nativeIterator);
    }


    INT NextSubpath(OUT INT* startIndex,
                    OUT INT* endIndex,
                    OUT BOOL* isClosed)
    {
        INT resultCount;

        SetStatus(DllExports::GdipPathIterNextSubpath(nativeIterator,
            &resultCount, startIndex, endIndex, isClosed));

        return resultCount;
    }


    INT NextSubpath(OUT const GraphicsPath* path, 
                    OUT BOOL* isClosed)
    {
        GpPath* nativePath = NULL;

        INT resultCount;

        if(path)
            nativePath= path->nativePath;

        SetStatus(DllExports::GdipPathIterNextSubpathPath(nativeIterator,
            &resultCount, nativePath, isClosed));

        return resultCount;
    }

    INT NextPathType(OUT BYTE* pathType, 
                     OUT INT* startIndex, 
                     OUT INT* endIndex)
    {
        INT resultCount;

        SetStatus(DllExports::GdipPathIterNextPathType(nativeIterator,
            &resultCount, pathType, startIndex, endIndex));

        return resultCount;
    }

    INT NextMarker(OUT INT* startIndex, 
                   OUT INT* endIndex)
    {
        INT resultCount;

        SetStatus(DllExports::GdipPathIterNextMarker(nativeIterator,
            &resultCount, startIndex, endIndex));

        return resultCount;
    }


    INT NextMarker(OUT const GraphicsPath* path)
    {
        GpPath* nativePath = NULL;

        INT resultCount;

        if(path)
            nativePath= path->nativePath;

        SetStatus(DllExports::GdipPathIterNextMarkerPath(nativeIterator,
            &resultCount, nativePath));

        return resultCount;
    }

    INT GetCount() const
    {
        INT resultCount;

        SetStatus(DllExports::GdipPathIterGetCount(nativeIterator, 
                                                   &resultCount));

        return resultCount;
    }

    INT GetSubpathCount() const
    {
        INT resultCount;

        SetStatus(DllExports::GdipPathIterGetSubpathCount(nativeIterator, 
                                                          &resultCount));

        return resultCount;
    }

    BOOL HasCurve() const
    {
        BOOL hasCurve;

        SetStatus(DllExports::GdipPathIterHasCurve(nativeIterator, &hasCurve));

        return hasCurve;
    }

    VOID Rewind()
    {
        SetStatus(DllExports::GdipPathIterRewind(nativeIterator));
    }

    INT Enumerate(OUT PointF *points,
                  OUT BYTE *types, 
                  IN INT count)
    {
        INT resultCount;

        SetStatus(DllExports::GdipPathIterEnumerate(nativeIterator,
            &resultCount, points, types, count));

        return resultCount;
    }

    INT CopyData(OUT PointF* points, 
                 OUT BYTE* types,
                 IN INT startIndex, 
                 IN INT endIndex)
    {
        INT resultCount;

        SetStatus(DllExports::GdipPathIterCopyData(nativeIterator,
            &resultCount, points, types, startIndex, endIndex));

        return resultCount;
    }

    Status GetLastStatus() const
    {
        Status lastStatus = lastResult;
        lastResult = Ok;

        return lastStatus;
    }

private:
    GraphicsPathIterator(const GraphicsPathIterator &);
    GraphicsPathIterator& operator=(const GraphicsPathIterator &);

protected:
    VOID SetNativeIterator(GpPathIterator *nativeIterator)
    {
        this->nativeIterator = nativeIterator;
    }

    Status SetStatus(Status status) const
    {
        if (status != Ok)
            return (lastResult = status);
        else
            return status;
    }

protected:
    GpPathIterator* nativeIterator;
    mutable Status lastResult;
};


//--------------------------------------------------------------------------
// Path Gradient Brush
//--------------------------------------------------------------------------

class PathGradientBrush : public Brush
{
public:
    friend class Pen;

    PathGradientBrush(
        IN const PointF* points,
        IN INT count,
        IN WrapMode wrapMode = WrapModeClamp)
    {
        GpPathGradient *brush = NULL;

        lastResult = DllExports::GdipCreatePathGradient(
                                        points, count,
                                        wrapMode, &brush);
        SetNativeBrush(brush);
    }

    PathGradientBrush(
        IN const Point* points,
        IN INT count,
        IN WrapMode wrapMode = WrapModeClamp)
    {
        GpPathGradient *brush = NULL;

        lastResult = DllExports::GdipCreatePathGradientI(
                                        points, count,
                                        wrapMode, &brush);

        SetNativeBrush(brush);
    }

    PathGradientBrush(
        IN const GraphicsPath* path
        )
    {
        GpPathGradient *brush = NULL;

        lastResult = DllExports::GdipCreatePathGradientFromPath(
                                        path->nativePath, &brush);
        SetNativeBrush(brush);
    }

    Status GetCenterColor(OUT Color* color) const
    {
        ARGB argb;
        
        if (color == NULL) 
        {
            return SetStatus(InvalidParameter);
        }

        SetStatus(DllExports::GdipGetPathGradientCenterColor(
                       (GpPathGradient*) nativeBrush, &argb));

        color->SetValue(argb);

        return lastResult;
    }

    Status SetCenterColor(IN const Color& color)
    {
        SetStatus(DllExports::GdipSetPathGradientCenterColor(
                       (GpPathGradient*) nativeBrush,
                       color.GetValue()));

        return lastResult;
    }

    INT GetPointCount() const
    {
        INT count;

        SetStatus(DllExports::GdipGetPathGradientPointCount(
                       (GpPathGradient*) nativeBrush, &count));

        return count;
    }

    INT GetSurroundColorCount() const
    {
        INT count;

        SetStatus(DllExports::GdipGetPathGradientSurroundColorCount(
                       (GpPathGradient*) nativeBrush, &count));

        return count;
    }

    Status GetSurroundColors(OUT Color* colors, 
                             IN OUT INT* count) const
    {
        if(colors == NULL || count == NULL)
        {
            return SetStatus(InvalidParameter);
        }

        INT count1;
        
        SetStatus(DllExports::GdipGetPathGradientSurroundColorCount(
                        (GpPathGradient*) nativeBrush, &count1));

        if(lastResult != Ok)
            return lastResult;

        if((*count < count1) || (count1 <= 0))
            return SetStatus(InsufficientBuffer);

        ARGB* argbs = (ARGB*) new ARGB[count1];
        if(argbs == NULL)
            return SetStatus(OutOfMemory);

        SetStatus(DllExports::GdipGetPathGradientSurroundColorsWithCount(
                    (GpPathGradient*)nativeBrush, argbs, &count1));

        if(lastResult == Ok)
        {
            for(INT i = 0; i < count1; i++)
            {
                colors[i].SetValue(argbs[i]);
            }        
            *count = count1;
        }

        delete [] argbs;
        return lastResult;
    }

    Status SetSurroundColors(IN const Color* colors, 
                             IN OUT INT* count)
    {
        if(colors == NULL || count == NULL)
        {
            return SetStatus(InvalidParameter);
        }

        INT count1 = GetPointCount();

        if((*count > count1) || (count1 <= 0))
            return SetStatus(InvalidParameter);

        count1 = *count;

        ARGB* argbs = (ARGB*) new ARGB[count1];
        if(argbs == NULL)
            return SetStatus(OutOfMemory);

        for(INT i = 0; i < count1; i++)
        {
            argbs[i] = colors[i].GetValue();
        }

        SetStatus(DllExports::GdipSetPathGradientSurroundColorsWithCount(
                    (GpPathGradient*)nativeBrush, argbs, &count1));

        if(lastResult == Ok)
            *count = count1;

        delete [] argbs;

        return lastResult;
    }

    Status GetGraphicsPath(OUT GraphicsPath* path) const
    {
        if(path == NULL)
            return SetStatus(InvalidParameter);

        return SetStatus(DllExports::GdipGetPathGradientPath(
                    (GpPathGradient*)nativeBrush, path->nativePath));
    }

    Status SetGraphicsPath(IN const GraphicsPath* path)
    {
        if(path == NULL)
            return SetStatus(InvalidParameter);

        return SetStatus(DllExports::GdipSetPathGradientPath(
                    (GpPathGradient*)nativeBrush, path->nativePath));
    }

    Status GetCenterPoint(OUT PointF* point) const
    {
        return SetStatus(DllExports::GdipGetPathGradientCenterPoint(
                                (GpPathGradient*)nativeBrush,
                                point));
    }

    Status GetCenterPoint(OUT Point* point) const
    {
        return SetStatus(DllExports::GdipGetPathGradientCenterPointI(
                                (GpPathGradient*)nativeBrush,
                                point));
    }

    Status SetCenterPoint(IN const PointF& point)
    {
        return SetStatus(DllExports::GdipSetPathGradientCenterPoint(
                                (GpPathGradient*)nativeBrush,
                                &point));
    }

    Status SetCenterPoint(IN const Point& point)
    {
        return SetStatus(DllExports::GdipSetPathGradientCenterPointI(
                                (GpPathGradient*)nativeBrush,
                                &point));
    }

    Status GetRectangle(OUT RectF* rect) const
    {
        return SetStatus(DllExports::GdipGetPathGradientRect(
                            (GpPathGradient*)nativeBrush, rect));
    }

    Status GetRectangle(OUT Rect* rect) const
    {
        return SetStatus(DllExports::GdipGetPathGradientRectI(
                            (GpPathGradient*)nativeBrush, rect));
    }

    Status SetGammaCorrection(IN BOOL useGammaCorrection)
    {
        return SetStatus(DllExports::GdipSetPathGradientGammaCorrection(
            (GpPathGradient*)nativeBrush, useGammaCorrection));
    }

    BOOL GetGammaCorrection() const
    {
        BOOL useGammaCorrection;

        SetStatus(DllExports::GdipGetPathGradientGammaCorrection(
            (GpPathGradient*)nativeBrush, &useGammaCorrection));

        return useGammaCorrection;
    }

    INT GetBlendCount() const
    {
       INT count = 0;

       SetStatus(DllExports::GdipGetPathGradientBlendCount(
                           (GpPathGradient*) nativeBrush, &count));

       return count;
    }

    Status GetBlend(OUT REAL* blendFactors,
                    OUT REAL* blendPositions,
                    IN INT count) const
    {
        return SetStatus(DllExports::GdipGetPathGradientBlend(
                            (GpPathGradient*)nativeBrush,
                            blendFactors, blendPositions, count));
    }

    Status SetBlend(IN const REAL* blendFactors, 
                    IN const REAL* blendPositions, 
                    IN INT count)
    {
        return SetStatus(DllExports::GdipSetPathGradientBlend(
                            (GpPathGradient*)nativeBrush,
                            blendFactors, blendPositions, count));
    }

    INT GetInterpolationColorCount() const
    {
       INT count = 0;

       SetStatus(DllExports::GdipGetPathGradientPresetBlendCount(
                        (GpPathGradient*) nativeBrush, &count));

       return count;
    }

    Status SetInterpolationColors(IN const Color* presetColors,
                                  IN const REAL* blendPositions, 
                                  IN INT count)
    {
        if ((count <= 0) || !presetColors) 
        {
            return SetStatus(InvalidParameter);
        }

        ARGB* argbs = (ARGB*) new ARGB[count];
        if(argbs)
        {
            for(INT i = 0; i < count; i++)
            {
                argbs[i] = presetColors[i].GetValue();
            }

            Status status = SetStatus(DllExports::
                               GdipSetPathGradientPresetBlend(
                                    (GpPathGradient*) nativeBrush,
                                    argbs,
                                    blendPositions,
                                    count));
            delete[] argbs;
            return status;
        }
        else
        {
            return SetStatus(OutOfMemory);
        }
    }

    Status GetInterpolationColors(OUT Color* presetColors,
                                  OUT REAL* blendPositions, 
                                  IN INT count) const
    {
        if ((count <= 0) || !presetColors) 
        {
            return SetStatus(InvalidParameter);
        }

        ARGB* argbs = (ARGB*) new ARGB[count];
        
        if (!argbs)
        {
            return SetStatus(OutOfMemory);
        }

        GpStatus status = SetStatus(DllExports::GdipGetPathGradientPresetBlend(
                                (GpPathGradient*)nativeBrush,
                                argbs,
                                blendPositions,
                                count));
        
        for(INT i = 0; i < count; i++)
        {
            presetColors[i] = Color(argbs[i]);
        }
        delete [] argbs;
        
        return status;
    }

    Status SetBlendBellShape(IN REAL focus, 
                             IN REAL scale = 1.0)
    {
        return SetStatus(DllExports::GdipSetPathGradientSigmaBlend(
                            (GpPathGradient*)nativeBrush, focus, scale));
    }

    Status SetBlendTriangularShape(
        IN REAL focus,
        IN REAL scale = 1.0
    )
    {
        return SetStatus(DllExports::GdipSetPathGradientLinearBlend(
                            (GpPathGradient*)nativeBrush, focus, scale));
    }

    Status GetTransform(OUT Matrix *matrix) const
    {
        return SetStatus(DllExports::GdipGetPathGradientTransform(
                            (GpPathGradient*) nativeBrush, 
                            matrix->nativeMatrix));
    }

    Status SetTransform(IN const Matrix* matrix)
    {
        return SetStatus(DllExports::GdipSetPathGradientTransform(
                            (GpPathGradient*) nativeBrush, 
                            matrix->nativeMatrix));
    }

    Status ResetTransform()
    {
        return SetStatus(DllExports::GdipResetPathGradientTransform(
                            (GpPathGradient*)nativeBrush));
    }

    Status MultiplyTransform(IN const Matrix* matrix,
                             IN MatrixOrder order = MatrixOrderPrepend)
    {
        return SetStatus(DllExports::GdipMultiplyPathGradientTransform(
                            (GpPathGradient*)nativeBrush,
                            matrix->nativeMatrix,
                            order));
    }

    Status TranslateTransform(IN REAL dx, 
                              IN REAL dy,
                              IN MatrixOrder order = MatrixOrderPrepend)
    {
        return SetStatus(DllExports::GdipTranslatePathGradientTransform(
                            (GpPathGradient*)nativeBrush,
                            dx, dy, order));
    }

    Status ScaleTransform(IN REAL sx, 
                          IN REAL sy,
                          IN MatrixOrder order = MatrixOrderPrepend)
    {
        return SetStatus(DllExports::GdipScalePathGradientTransform(
                            (GpPathGradient*)nativeBrush,
                            sx, sy, order));
    }

    Status RotateTransform(IN REAL angle, 
                           IN MatrixOrder order = MatrixOrderPrepend)
    {
        return SetStatus(DllExports::GdipRotatePathGradientTransform(
                            (GpPathGradient*)nativeBrush,
                            angle, order));
    }

    Status GetFocusScales(OUT REAL* xScale, 
                          OUT REAL* yScale) const
    {
        return SetStatus(DllExports::GdipGetPathGradientFocusScales(
                            (GpPathGradient*) nativeBrush, xScale, yScale));
    }

    Status SetFocusScales(IN REAL xScale,
                          IN REAL yScale)
    {
        return SetStatus(DllExports::GdipSetPathGradientFocusScales(
                            (GpPathGradient*) nativeBrush, xScale, yScale));
    }

    WrapMode GetWrapMode() const
    {
        WrapMode wrapMode;

        SetStatus(DllExports::GdipGetPathGradientWrapMode(
                     (GpPathGradient*) nativeBrush, &wrapMode));

        return wrapMode;
    }

    Status SetWrapMode(IN WrapMode wrapMode)
    {
        return SetStatus(DllExports::GdipSetPathGradientWrapMode(
                            (GpPathGradient*) nativeBrush, wrapMode));
    }

private:
    PathGradientBrush(const PathGradientBrush &);
    PathGradientBrush& operator=(const PathGradientBrush &);

protected:

    PathGradientBrush()
    {
    }
};

#endif // !_GRAPHICSPATH_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\sdkinc\gdipluspixelformats.h ===
/**************************************************************************\
*
* Copyright (c) 1998-2001, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   Gdiplus Pixel Formats
*
* Abstract:
*
*   GDI+ Pixel Formats
*
\**************************************************************************/

#ifndef _GDIPLUSPIXELFORMATS_H
#define _GDIPLUSPIXELFORMATS_H

typedef DWORD ARGB;
typedef DWORDLONG ARGB64;

#define ALPHA_SHIFT 24
#define RED_SHIFT   16
#define GREEN_SHIFT 8
#define BLUE_SHIFT  0
#define ALPHA_MASK  ((ARGB) 0xff << ALPHA_SHIFT)

// In-memory pixel data formats:
// bits 0-7 = format index
// bits 8-15 = pixel size (in bits)
// bits 16-23 = flags
// bits 24-31 = reserved

typedef INT PixelFormat;

#define    PixelFormatIndexed      0x00010000 // Indexes into a palette
#define    PixelFormatGDI          0x00020000 // Is a GDI-supported format
#define    PixelFormatAlpha        0x00040000 // Has an alpha component
#define    PixelFormatPAlpha       0x00080000 // Pre-multiplied alpha
#define    PixelFormatExtended     0x00100000 // Extended color 16 bits/channel
#define    PixelFormatCanonical    0x00200000 

#define    PixelFormatUndefined       0
#define    PixelFormatDontCare        0

#define    PixelFormat1bppIndexed     (1 | ( 1 << 8) | PixelFormatIndexed | PixelFormatGDI)
#define    PixelFormat4bppIndexed     (2 | ( 4 << 8) | PixelFormatIndexed | PixelFormatGDI)
#define    PixelFormat8bppIndexed     (3 | ( 8 << 8) | PixelFormatIndexed | PixelFormatGDI)
#define    PixelFormat16bppGrayScale  (4 | (16 << 8) | PixelFormatExtended)
#define    PixelFormat16bppRGB555     (5 | (16 << 8) | PixelFormatGDI)
#define    PixelFormat16bppRGB565     (6 | (16 << 8) | PixelFormatGDI)
#define    PixelFormat16bppARGB1555   (7 | (16 << 8) | PixelFormatAlpha | PixelFormatGDI)
#define    PixelFormat24bppRGB        (8 | (24 << 8) | PixelFormatGDI)
#define    PixelFormat32bppRGB        (9 | (32 << 8) | PixelFormatGDI)
#define    PixelFormat32bppARGB       (10 | (32 << 8) | PixelFormatAlpha | PixelFormatGDI | PixelFormatCanonical)
#define    PixelFormat32bppPARGB      (11 | (32 << 8) | PixelFormatAlpha | PixelFormatPAlpha | PixelFormatGDI)
#define    PixelFormat48bppRGB        (12 | (48 << 8) | PixelFormatExtended)
#define    PixelFormat64bppARGB       (13 | (64 << 8) | PixelFormatAlpha  | PixelFormatCanonical | PixelFormatExtended)
#define    PixelFormat64bppPARGB      (14 | (64 << 8) | PixelFormatAlpha  | PixelFormatPAlpha | PixelFormatExtended)
#define    PixelFormatMax             15

inline UINT
GetPixelFormatSize(
                   PixelFormat pixfmt
    )
{
    return (pixfmt >> 8) & 0xff;
}

inline BOOL
IsIndexedPixelFormat(
                     PixelFormat pixfmt
    )
{
    return (pixfmt & PixelFormatIndexed) != 0;
}

inline BOOL
IsAlphaPixelFormat(
                     PixelFormat pixfmt
)
{
   return (pixfmt & PixelFormatAlpha) != 0;
}

inline BOOL
IsExtendedPixelFormat(
                     PixelFormat pixfmt
    )
{
   return (pixfmt & PixelFormatExtended) != 0;
}

//--------------------------------------------------------------------------
// Determine if the Pixel Format is Canonical format:
//   PixelFormat32bppARGB
//   PixelFormat32bppPARGB
//   PixelFormat64bppARGB
//   PixelFormat64bppPARGB
//--------------------------------------------------------------------------

inline BOOL
IsCanonicalPixelFormat(
                     PixelFormat pixfmt
    )
{
   return (pixfmt & PixelFormatCanonical) != 0;
}

enum PaletteFlags
{
    PaletteFlagsHasAlpha    = 0x0001,
    PaletteFlagsGrayScale   = 0x0002,
    PaletteFlagsHalftone    = 0x0004
};

struct ColorPalette
{
public:
    UINT Flags;             // Palette flags
    UINT Count;             // Number of color entries
    ARGB Entries[1];        // Palette color entries
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\sdkinc\gdipluspen.h ===
/**************************************************************************\
* 
* Copyright (c) 1998-2001, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   GdiplusPen.h
*
* Abstract:
*
*   GDI+ Pen class
*
\**************************************************************************/
#ifndef _GDIPLUSPEN_H
#define _GDIPLUSPEN_H

//--------------------------------------------------------------------------
// Pen class
//--------------------------------------------------------------------------

class Pen : public GdiplusBase
{
public:
    friend class GraphicsPath;
    friend class Graphics;

    Pen(IN const Color& color, 
        IN REAL width = 1.0f)
    {
        Unit unit = UnitWorld;
        nativePen = NULL;
        lastResult = DllExports::GdipCreatePen1(color.GetValue(),
                                    width, unit, &nativePen);
    }

    Pen(IN const Brush* brush, 
        IN REAL width = 1.0f)
    {
        Unit unit = UnitWorld;
        nativePen = NULL;
        lastResult = DllExports::GdipCreatePen2(brush->nativeBrush,
                                    width, unit, &nativePen);
    }

    ~Pen()
    {
        DllExports::GdipDeletePen(nativePen);
    }

    Pen* Clone() const
    {
        GpPen *clonePen = NULL;

        lastResult = DllExports::GdipClonePen(nativePen, &clonePen);
   
        return new Pen(clonePen, lastResult);
    }

    Status SetWidth(IN REAL width)
    {
        return SetStatus(DllExports::GdipSetPenWidth(nativePen, width));
    }

    REAL GetWidth() const
    {
        REAL width;

        SetStatus(DllExports::GdipGetPenWidth(nativePen, &width));
        
        return width;
    }
    
    // Set/get line caps: start, end, and dash

    // Line cap and join APIs by using LineCap and LineJoin enums.

    Status SetLineCap(IN LineCap startCap, 
                      IN LineCap endCap, 
                      IN DashCap dashCap)
    {
        return SetStatus(DllExports::GdipSetPenLineCap197819(nativePen, 
                                   startCap, endCap, dashCap));
    }

    Status SetStartCap(IN LineCap startCap)
    {
        return SetStatus(DllExports::GdipSetPenStartCap(nativePen, startCap));
    }

    Status SetEndCap(IN LineCap endCap)
    {
        return SetStatus(DllExports::GdipSetPenEndCap(nativePen, endCap));
    }

    Status SetDashCap(IN DashCap dashCap)
    {
        return SetStatus(DllExports::GdipSetPenDashCap197819(nativePen,
                                   dashCap));
    }

    LineCap GetStartCap() const
    {
        LineCap startCap;

        SetStatus(DllExports::GdipGetPenStartCap(nativePen, &startCap));
        
        return startCap;
    }

    LineCap GetEndCap() const
    {
        LineCap endCap;

        SetStatus(DllExports::GdipGetPenEndCap(nativePen, &endCap));

        return endCap;
    }

    DashCap GetDashCap() const
    {
        DashCap dashCap;

        SetStatus(DllExports::GdipGetPenDashCap197819(nativePen,
                            &dashCap));

        return dashCap;
    }

    Status SetLineJoin(IN LineJoin lineJoin)
    {
        return SetStatus(DllExports::GdipSetPenLineJoin(nativePen, lineJoin));
    }

    LineJoin GetLineJoin() const
    {
        LineJoin lineJoin;
        
        SetStatus(DllExports::GdipGetPenLineJoin(nativePen, &lineJoin));
        
        return lineJoin;
    }

    Status SetCustomStartCap(IN const CustomLineCap* customCap)
    {
        GpCustomLineCap* nativeCap = NULL;
        if(customCap)
            nativeCap = customCap->nativeCap;

        return SetStatus(DllExports::GdipSetPenCustomStartCap(nativePen, 
                                                              nativeCap));
    }

    Status GetCustomStartCap(OUT CustomLineCap* customCap) const
    {
        if(!customCap)
            return SetStatus(InvalidParameter);

        return SetStatus(DllExports::GdipGetPenCustomStartCap(nativePen, 
                                                    &(customCap->nativeCap)));
    }

    Status SetCustomEndCap(IN const CustomLineCap* customCap)
    {
        GpCustomLineCap* nativeCap = NULL;
        if(customCap)
            nativeCap = customCap->nativeCap;

        return SetStatus(DllExports::GdipSetPenCustomEndCap(nativePen, 
                                                            nativeCap));
    }

    Status GetCustomEndCap(OUT CustomLineCap* customCap) const
    {
        if(!customCap)
            return SetStatus(InvalidParameter);

        return SetStatus(DllExports::GdipGetPenCustomEndCap(nativePen, 
                                                    &(customCap->nativeCap)));
    }

    Status SetMiterLimit(IN REAL miterLimit)
    {
        return SetStatus(DllExports::GdipSetPenMiterLimit(nativePen, 
                                                    miterLimit));
    }

    REAL GetMiterLimit() const
    {
        REAL miterLimit;

        SetStatus(DllExports::GdipGetPenMiterLimit(nativePen, &miterLimit));

        return miterLimit;
    }

    Status SetAlignment(IN PenAlignment penAlignment)
    {
        return SetStatus(DllExports::GdipSetPenMode(nativePen, penAlignment));
    }

    PenAlignment GetAlignment() const
    {
        PenAlignment penAlignment;
        
        SetStatus(DllExports::GdipGetPenMode(nativePen, &penAlignment));
        
        return penAlignment;
    }
    
    Status SetTransform(IN const Matrix* matrix)
    {
        return SetStatus(DllExports::GdipSetPenTransform(nativePen, 
                                                       matrix->nativeMatrix));
    }

    Status GetTransform(OUT Matrix* matrix) const
    {
        return SetStatus(DllExports::GdipGetPenTransform(nativePen, 
                                                         matrix->nativeMatrix));
    }

    Status ResetTransform()
    {
        return SetStatus(DllExports::GdipResetPenTransform(nativePen));
    }

    Status MultiplyTransform(IN const Matrix* matrix,
                             IN MatrixOrder order = MatrixOrderPrepend)
    {
        return SetStatus(DllExports::GdipMultiplyPenTransform(nativePen,
                                                         matrix->nativeMatrix,
                                                         order));
    }

    Status TranslateTransform(IN REAL dx, 
                              IN REAL dy,
                              IN MatrixOrder order = MatrixOrderPrepend)
    {
        return SetStatus(DllExports::GdipTranslatePenTransform(nativePen,
                                                               dx, 
                                                               dy, 
                                                               order));
    }

    Status ScaleTransform(IN REAL sx, 
                          IN REAL sy,
                          IN MatrixOrder order = MatrixOrderPrepend)
    {
        return SetStatus(DllExports::GdipScalePenTransform(nativePen,
                                                           sx, 
                                                           sy, 
                                                           order));
    }

    Status RotateTransform(IN REAL angle, 
                           IN MatrixOrder order = MatrixOrderPrepend)
    {
        return SetStatus(DllExports::GdipRotatePenTransform(nativePen,
                                                            angle, 
                                                            order));
    }

    PenType GetPenType() const
    {
       PenType type;
       SetStatus(DllExports::GdipGetPenFillType(nativePen, &type));

       return type;
    }

    Status SetColor(IN const Color& color)
    {
        return SetStatus(DllExports::GdipSetPenColor(nativePen,
                                                     color.GetValue()));
    }

    Status SetBrush(IN const Brush* brush)
    {
        return SetStatus(DllExports::GdipSetPenBrushFill(nativePen, 
                                       brush->nativeBrush));
    }

    Status GetColor(OUT Color* color) const
    {
        if (color == NULL) 
        {
            return SetStatus(InvalidParameter);
        }
        
        PenType type = GetPenType();

        if (type != PenTypeSolidColor) 
        {
            return WrongState;
        }
        
        ARGB argb;
        
        SetStatus(DllExports::GdipGetPenColor(nativePen,
                                              &argb));
        if (lastResult == Ok)
        {
            color->SetValue(argb);
        }
        
        return lastResult;
    }

    Brush* GetBrush() const
    {
       PenType type = GetPenType();

       Brush* brush = NULL;

       switch(type)
       {
       case PenTypeSolidColor:
           brush = new SolidBrush();
           break;

       case PenTypeHatchFill:
           brush = new HatchBrush();
           break;

       case PenTypeTextureFill:
           brush = new TextureBrush();
           break;

       case PenTypePathGradient:
           brush = new Brush();
           break;

       case PenTypeLinearGradient:
           brush = new LinearGradientBrush();
           break;

       default:
           break;
       }

       if(brush)
       {
           GpBrush* nativeBrush;

           SetStatus(DllExports::GdipGetPenBrushFill(nativePen, 
                                                     &nativeBrush));
           brush->SetNativeBrush(nativeBrush);
       }

       return brush;
    }

    DashStyle GetDashStyle() const
    {
        DashStyle dashStyle;

        SetStatus(DllExports::GdipGetPenDashStyle(nativePen, &dashStyle));

        return dashStyle;
    }

    Status SetDashStyle(IN DashStyle dashStyle)
    {
        return SetStatus(DllExports::GdipSetPenDashStyle(nativePen, 
                                                         dashStyle));
    }

    REAL GetDashOffset() const
    {
        REAL dashOffset;

        SetStatus(DllExports::GdipGetPenDashOffset(nativePen, &dashOffset));

        return dashOffset;
    }

    Status SetDashOffset(IN REAL dashOffset)
    {
        return SetStatus(DllExports::GdipSetPenDashOffset(nativePen, 
                                                          dashOffset));
    }
    
    Status SetDashPattern(IN const REAL* dashArray, IN INT count)
    {
        return SetStatus(DllExports::GdipSetPenDashArray(nativePen,
                                                         dashArray, 
                                                         count));
    }
    
    INT GetDashPatternCount() const
    {
        INT count = 0;
        
        SetStatus(DllExports::GdipGetPenDashCount(nativePen, &count));
        
        return count;
    }

    Status GetDashPattern(OUT REAL* dashArray, 
                          IN INT count) const
    {
        if (dashArray == NULL || count <= 0)
            return SetStatus(InvalidParameter); 
        
        return SetStatus(DllExports::GdipGetPenDashArray(nativePen, 
                                                         dashArray, 
                                                         count));
    }

    Status SetCompoundArray(IN const REAL* compoundArray,
                            IN INT count)
    {
        return SetStatus(DllExports::GdipSetPenCompoundArray(nativePen, 
                                                             compoundArray,
                                                             count));
    }

    INT GetCompoundArrayCount() const
    {
        INT count = 0;
        
        SetStatus(DllExports::GdipGetPenCompoundCount(nativePen, &count));
        
        return count;
    }

    Status GetCompoundArray(OUT REAL* compoundArray, 
                            IN INT count) const
    {
        if (compoundArray == NULL || count <= 0)
            return SetStatus(InvalidParameter); 
        
        return SetStatus(DllExports::GdipGetPenCompoundArray(nativePen, 
                                                             compoundArray, 
                                                             count));
    }

    Status GetLastStatus() const
    {
        Status lastStatus = lastResult;
        lastResult = Ok;

        return lastStatus;
    }

private:
    Pen(const Pen &);
    Pen& operator=(const Pen &);

protected:
    Pen(GpPen* nativePen, Status status)
    {
        lastResult = status;
        SetNativePen(nativePen);
    }

    VOID SetNativePen(GpPen* nativePen)
    {
        this->nativePen = nativePen;
    }
    
    Status SetStatus(Status status) const
    {
        if (status != Ok)
            return (lastResult = status);
        else 
            return status;
    }

protected:
    GpPen* nativePen;
    mutable Status lastResult;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\gpinit.h ===
/**************************************************************************
*
* Copyright (c) 2000 Microsoft Corporation
*
* Module Name:
*
*   Helper for GDI+ initialization
*
* Notes:
*
*   An app should check gGdiplusInitHelper.IsValid() in its main function,
*   and abort if it returns FALSE.
*
* Created:
*
*   09/25/2000 agodfrey
*      Created it.
*
**************************************************************************/

#ifndef _GPINIT_H
#define _GPINIT_H

class GdiplusInitHelper
{
public:
    GdiplusInitHelper();
    ~GdiplusInitHelper();
    BOOL IsValid() { return Valid; }
    
private:    
    ULONG_PTR gpToken;
    BOOL Valid;
};

extern GdiplusInitHelper gGdiplusInitHelper;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\gpinit.inc ===
/**************************************************************************
*
* Copyright (c) 2000 Microsoft Corporation
*
* Module Name:
*
*   Helper for GDI+ initialization
*
* Abstract:
*
*   This code initializes GDI+ (with default parameters).
*   The code is specific to our compiler, because it uses #pragma to
*   get our code to be initialized before the app's other global objects
*   (important when apps make global GDI+ objects.)
*
* Notes:
*
*   A test app should include this in *just one* of its .cpp files.
*   It should check gGdiplusInitHelper.IsValid() in its main function,
*   and abort if it returns FALSE.
*
*   We use "#pragma code_seg()", which resets the code segment to "whatever
*   it was when compilation began" (MSDN). In other words, we stomp on whatever
*   the code segment might have been changed to before this file was included.
*   You don't need to worry about this unless you use "#pragma code_seg"
*   yourself, in the file which includes this one.
*
* Created:
*
*   09/18/2000 agodfrey
*      Created it.
*
**************************************************************************/

#include <objbase.h>
#include "gdiplus.h"

// Disable the stupid warning that says we have a "lib" code segment.
#pragma warning( push )
#pragma warning( disable : 4073 )

// Make a separate code segment, and mark it as a "library initialization"
// segment
#pragma code_seg( "GpInit" )
#pragma init_seg( lib )

class GdiplusInitHelper
{
public:
    GdiplusInitHelper() : gpToken(0), Valid(FALSE)
    {
        Gdiplus::GdiplusStartupInput sti;
        if (Gdiplus::GdiplusStartup(&gpToken, &sti, NULL) == Gdiplus::Ok)
        {
            Valid = TRUE;
        }
    }
    ~GdiplusInitHelper()
    {
        if (Valid)
        {
            Gdiplus::GdiplusShutdown(gpToken);
        }
    }
    BOOL IsValid() { return Valid; }
    
private:    
    ULONG_PTR gpToken;
    BOOL Valid;
};

// Declare the global in this code segment, so that it is initialized before/
// destroyed after the app's globals.

GdiplusInitHelper gGdiplusInitHelper;

// Reset the code segment to "whatever it was when compilation began".

#pragma code_seg()

#pragma warning( pop )
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\sdkinc\gdiplusstringformat.h ===
/**************************************************************************\
*
* Copyright (c) 1998-2001, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   GdiplusStringFormat.h
*
* Abstract:
*
*   GDI+ StringFormat class
*
\**************************************************************************/

#ifndef _GDIPLUSSTRINGFORMAT_H
#define _GDIPLUSSTRINGFORMAT_H

class StringFormat : public GdiplusBase
{
public:
    friend class Graphics;
    friend class GraphicsPath;


    StringFormat(
        IN INT     formatFlags = 0,
        IN LANGID  language = LANG_NEUTRAL
    )
    {
        nativeFormat = NULL;
        lastError = DllExports::GdipCreateStringFormat(
            formatFlags,
            language,
            &nativeFormat
        );
    }

    static const StringFormat *GenericDefault();
    static const StringFormat *GenericTypographic();

    StringFormat(
        IN const StringFormat *format
    )
    {
        nativeFormat = NULL;
        lastError = DllExports::GdipCloneStringFormat(
            format ? format->nativeFormat : NULL,
            &nativeFormat
        );
    }

    StringFormat *Clone() const
    {
        GpStringFormat *clonedStringFormat = NULL;

        lastError = DllExports::GdipCloneStringFormat(
            nativeFormat,
            &clonedStringFormat
        );

        if (lastError == Ok)
            return new StringFormat(clonedStringFormat, lastError);
        else
            return NULL;
    }

    ~StringFormat()
    {
        DllExports::GdipDeleteStringFormat(nativeFormat);
    }

    Status SetFormatFlags(IN INT flags)
    {
        return SetStatus(DllExports::GdipSetStringFormatFlags(
            nativeFormat,
            flags
        ));
    }

    INT GetFormatFlags() const
    {
        INT flags;
        SetStatus(DllExports::GdipGetStringFormatFlags(nativeFormat, &flags));
        return flags;
    }

    Status SetAlignment(IN StringAlignment align)
    {
        return SetStatus(DllExports::GdipSetStringFormatAlign(
            nativeFormat,
            align
        ));
    }

    StringAlignment GetAlignment() const
    {
        StringAlignment alignment;
        SetStatus(DllExports::GdipGetStringFormatAlign(
            nativeFormat,
            &alignment
        ));
        return alignment;
    }

    Status SetLineAlignment(IN StringAlignment align)
    {
        return SetStatus(DllExports::GdipSetStringFormatLineAlign(
            nativeFormat,
            align
        ));
    }

    StringAlignment GetLineAlignment() const
    {
        StringAlignment alignment;
        SetStatus(DllExports::GdipGetStringFormatLineAlign(
            nativeFormat,
            &alignment
        ));
        return alignment;
    }

    Status SetHotkeyPrefix(IN HotkeyPrefix hotkeyPrefix)
    {
        return SetStatus(DllExports::GdipSetStringFormatHotkeyPrefix(
            nativeFormat,
            (INT)hotkeyPrefix
        ));
    }

    HotkeyPrefix GetHotkeyPrefix() const
    {
        HotkeyPrefix hotkeyPrefix;
        SetStatus(DllExports::GdipGetStringFormatHotkeyPrefix(
            nativeFormat,
            (INT*)&hotkeyPrefix
        ));
        return hotkeyPrefix;
    }

    Status SetTabStops(
        IN REAL    firstTabOffset,
        IN INT     count,
        IN const REAL    *tabStops
    )
    {
        return SetStatus(DllExports::GdipSetStringFormatTabStops(
            nativeFormat,
            firstTabOffset,
            count,
            tabStops
        ));
    }

    INT GetTabStopCount() const
    {
        INT count;
        SetStatus(DllExports::GdipGetStringFormatTabStopCount(nativeFormat, &count));
        return count;
    }

    Status GetTabStops(
        IN INT     count,
        OUT REAL   *firstTabOffset,
        OUT REAL   *tabStops
    ) const
    {
        return SetStatus(DllExports::GdipGetStringFormatTabStops(
            nativeFormat,
            count,
            firstTabOffset,
            tabStops
        ));
    }

    Status SetDigitSubstitution(
        IN LANGID                language,
        IN StringDigitSubstitute substitute
    )
    {
        return SetStatus(DllExports::GdipSetStringFormatDigitSubstitution(
            nativeFormat,
            language,
            substitute
        ));
    }

    LANGID GetDigitSubstitutionLanguage(
    ) const
    {
        LANGID language;
        SetStatus(DllExports::GdipGetStringFormatDigitSubstitution(
            nativeFormat,
            &language,
            NULL
        ));
        return language;
    }

    StringDigitSubstitute GetDigitSubstitutionMethod(
    ) const
    {
        StringDigitSubstitute substitute;
        SetStatus(DllExports::GdipGetStringFormatDigitSubstitution(
            nativeFormat,
            NULL,
            &substitute
        ));
        return substitute;
    }

    Status SetTrimming(IN StringTrimming trimming)
    {
        return SetStatus(DllExports::GdipSetStringFormatTrimming(
            nativeFormat,
            trimming
        ));
    }

    StringTrimming StringFormat::GetTrimming() const
    {
        StringTrimming trimming;
        SetStatus(DllExports::GdipGetStringFormatTrimming(
            nativeFormat,
            &trimming
        ));
        return trimming;
    }

    Status SetMeasurableCharacterRanges(
        IN INT                  rangeCount,
        IN const CharacterRange *ranges
    )
    {
        return SetStatus(DllExports::GdipSetStringFormatMeasurableCharacterRanges(
            nativeFormat,
            rangeCount,
            ranges
        ));
    }

    INT GetMeasurableCharacterRangeCount()
    {
        INT count;
        SetStatus(DllExports::GdipGetStringFormatMeasurableCharacterRangeCount(
            nativeFormat,
            &count
        ));
        return count;
    }

    Status GetLastStatus() const
    {
        Status lastStatus = lastError;
        lastError = Ok;

        return lastStatus;
    }

protected:

    Status SetStatus(GpStatus newStatus) const
    {
        if (newStatus == Ok)
        {
            return Ok;
        }
        else
        {
            return lastError = newStatus;
        }
    }

    StringFormat(const StringFormat &source)
    {
        nativeFormat = NULL;
        lastError = DllExports::GdipCloneStringFormat(
            source.nativeFormat,
            &nativeFormat
        );
    }

    StringFormat& operator=(const StringFormat &source)
    {
        DllExports::GdipDeleteStringFormat(nativeFormat);
        lastError = DllExports::GdipCloneStringFormat(
            source.nativeFormat,
            &nativeFormat
        );
        return *this;
    }

    StringFormat(GpStringFormat * clonedStringFormat, Status status)
    {
        lastError = status;
        nativeFormat = clonedStringFormat;

    }

    GpStringFormat *nativeFormat;
    mutable Status  lastError;
};

static BYTE GenericTypographicStringFormatBuffer[sizeof(StringFormat)] = {0};
static BYTE GenericDefaultStringFormatBuffer[sizeof(StringFormat)] = {0};

inline const StringFormat *StringFormat::GenericDefault()
{
    StringFormat * genericDefaultStringFormat =
        (StringFormat*)GenericDefaultStringFormatBuffer;

    genericDefaultStringFormat->lastError =
        DllExports::GdipStringFormatGetGenericDefault(
            &(genericDefaultStringFormat->nativeFormat)
        );

    return genericDefaultStringFormat;
}

inline const StringFormat *StringFormat::GenericTypographic()
{
    StringFormat * genericTypographicStringFormat =
        (StringFormat*)GenericTypographicStringFormatBuffer;

    genericTypographicStringFormat->lastError =
        DllExports::GdipStringFormatGetGenericTypographic(
            &genericTypographicStringFormat->nativeFormat
        );

    return genericTypographicStringFormat;
}

#endif // !_GDIPLUSSTRINGFORMAT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\sdkinc\gdiplusregion.h ===
/**************************************************************************\
*
* Copyright (c) 1998-2001, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   GdiplusRegion.h
*
* Abstract:
*
*   GDI+ Region class implementation
*
\**************************************************************************/

#ifndef _GDIPLUSREGION_H
#define _GDIPLUSREGION_H

inline 
Region::Region()
{
    GpRegion *region = NULL;

    lastResult = DllExports::GdipCreateRegion(&region);

    SetNativeRegion(region);
}

inline 
Region::Region(IN const RectF& rect)
{
    GpRegion *region = NULL;

    lastResult = DllExports::GdipCreateRegionRect(&rect, &region);

    SetNativeRegion(region);
}

inline 
Region::Region(IN const Rect& rect)
{
    GpRegion *region = NULL;

    lastResult = DllExports::GdipCreateRegionRectI(&rect, &region);

    SetNativeRegion(region);
}

inline 
Region::Region(IN const GraphicsPath* path)
{
    GpRegion *region = NULL;

    lastResult = DllExports::GdipCreateRegionPath(path->nativePath, &region);

    SetNativeRegion(region);
}

inline 
Region::Region(IN const BYTE* regionData, IN INT size)
{
    GpRegion *region = NULL;

    lastResult = DllExports::GdipCreateRegionRgnData(regionData, size, 
                                                     &region);

    SetNativeRegion(region);
}

inline 
Region::Region(IN HRGN hRgn)
{
    GpRegion *region = NULL;

    lastResult = DllExports::GdipCreateRegionHrgn(hRgn, &region);

    SetNativeRegion(region);
}

inline 
Region* Region::FromHRGN(IN HRGN hRgn)
{
    GpRegion *region = NULL;

    if (DllExports::GdipCreateRegionHrgn(hRgn, &region) == Ok)
    {
        Region* newRegion = new Region(region);

        if (newRegion == NULL) 
        {
            DllExports::GdipDeleteRegion(region);
        }

        return newRegion;
    }
    else
        return NULL;
}

inline 
Region::~Region()
{
    DllExports::GdipDeleteRegion(nativeRegion);
}

inline Region* 
Region::Clone() const
{
    GpRegion *region = NULL;

    SetStatus(DllExports::GdipCloneRegion(nativeRegion, &region));

    return new Region(region);
}

inline Status 
Region::MakeInfinite()
{
    return SetStatus(DllExports::GdipSetInfinite(nativeRegion));
}

inline Status 
Region::MakeEmpty()
{
    return SetStatus(DllExports::GdipSetEmpty(nativeRegion));
}

inline Status 
Region::Intersect(IN const RectF& rect)
{
    return SetStatus(DllExports::GdipCombineRegionRect(nativeRegion, &rect, 
                                                       CombineModeIntersect));
}

inline Status 
Region::Intersect(IN const Rect& rect)
{
    return SetStatus(DllExports::GdipCombineRegionRectI(nativeRegion, &rect, 
                                                        CombineModeIntersect));
}

inline Status 
Region::Intersect(IN const GraphicsPath* path)
{
    return SetStatus(DllExports::GdipCombineRegionPath(nativeRegion, 
                                                       path->nativePath, 
                                                       CombineModeIntersect));
}

inline Status 
Region::Intersect(IN const Region* region)
{
    return SetStatus(DllExports::GdipCombineRegionRegion(nativeRegion, 
                                                         region->nativeRegion, 
                                                         CombineModeIntersect));
}

inline Status 
Region::Union(IN const RectF& rect)
{
    return SetStatus(DllExports::GdipCombineRegionRect(nativeRegion, &rect, 
                                                       CombineModeUnion));
}

inline Status 
Region::Union(IN const Rect& rect)
{
    return SetStatus(DllExports::GdipCombineRegionRectI(nativeRegion, &rect, 
                                                        CombineModeUnion));
}

inline Status 
Region::Union(IN const GraphicsPath* path)
{
    return SetStatus(DllExports::GdipCombineRegionPath(nativeRegion, 
                                                       path->nativePath, 
                                                       CombineModeUnion));
}

inline Status 
Region::Union(IN const Region* region)
{
    return SetStatus(DllExports::GdipCombineRegionRegion(nativeRegion, 
                                                         region->nativeRegion, 
                                                         CombineModeUnion));
}

inline Status 
Region::Xor(IN const RectF& rect)
{
    return SetStatus(DllExports::GdipCombineRegionRect(nativeRegion, &rect, 
                                                       CombineModeXor));
}

inline Status 
Region::Xor(IN const Rect& rect)
{
    return SetStatus(DllExports::GdipCombineRegionRectI(nativeRegion, &rect, 
                                                        CombineModeXor));
}

inline Status 
Region::Xor(IN const GraphicsPath* path)
{
    return SetStatus(DllExports::GdipCombineRegionPath(nativeRegion, 
                                                       path->nativePath, 
                                                       CombineModeXor));
}

inline Status 
Region::Xor(IN const Region* region)
{
    return SetStatus(DllExports::GdipCombineRegionRegion(nativeRegion, 
                                                         region->nativeRegion, 
                                                         CombineModeXor));
}

inline Status 
Region::Exclude(IN const RectF& rect)
{
    return SetStatus(DllExports::GdipCombineRegionRect(nativeRegion, &rect, 
                                                       CombineModeExclude));
}

inline Status 
Region::Exclude(IN const Rect& rect)
{
     return SetStatus(DllExports::GdipCombineRegionRectI(nativeRegion, &rect, 
                                                         CombineModeExclude));
}

inline Status 
Region::Exclude(IN const GraphicsPath* path)
{
    return SetStatus(DllExports::GdipCombineRegionPath(nativeRegion, 
                                                       path->nativePath, 
                                                       CombineModeExclude));
}

inline Status
Region::Exclude(IN const Region* region)
{
    return SetStatus(DllExports::GdipCombineRegionRegion(nativeRegion,
                                               region->nativeRegion, 
                                                         CombineModeExclude));
}

inline Status 
Region::Complement(IN const RectF& rect)
{
    return SetStatus(DllExports::GdipCombineRegionRect(nativeRegion, &rect, 
                                                       CombineModeComplement));
}

inline Status 
Region::Complement(IN const Rect& rect)
{
    return SetStatus(DllExports::GdipCombineRegionRectI(nativeRegion, &rect, 
                                                        CombineModeComplement));
}

inline Status 
Region::Complement(IN const GraphicsPath* path)
{
    return SetStatus(DllExports::GdipCombineRegionPath(nativeRegion,
                                                path->nativePath, 
                                                CombineModeComplement));
}

inline Status 
Region::Complement(IN const Region* region)
{
    return SetStatus(DllExports::GdipCombineRegionRegion(nativeRegion,
                                                  region->nativeRegion, 
                                                         CombineModeComplement));
}

inline Status 
Region::Translate(IN REAL dx, 
                  IN REAL dy)
{
    return SetStatus(DllExports::GdipTranslateRegion(nativeRegion, dx, dy));
}

inline Status 
Region::Translate(IN INT dx, 
                  IN INT dy)
{
    return SetStatus(DllExports::GdipTranslateRegionI(nativeRegion, dx, dy));
}

inline Status 
Region::Transform(IN const Matrix* matrix)
{
    return SetStatus(DllExports::GdipTransformRegion(nativeRegion, 
                                                     matrix->nativeMatrix));
}

inline Status 
Region::GetBounds(OUT RectF* rect,
                  IN const Graphics* g) const
{
    return SetStatus(DllExports::GdipGetRegionBounds(nativeRegion,
                                                g->nativeGraphics,
                                                rect));
}

inline Status 
Region::GetBounds(OUT Rect* rect,
                  IN const Graphics* g) const
{
    return SetStatus(DllExports::GdipGetRegionBoundsI(nativeRegion,
                                                g->nativeGraphics,
                                                rect));
}

inline HRGN
Region::GetHRGN(IN const Graphics* g) const
{
    HRGN hrgn;

    SetStatus(DllExports::GdipGetRegionHRgn(nativeRegion,
                                            g->nativeGraphics,
                                            &hrgn));

    return hrgn;
}

inline BOOL 
Region::IsEmpty(IN const Graphics *g) const
{
    BOOL booln = FALSE;
   
    SetStatus(DllExports::GdipIsEmptyRegion(nativeRegion,
                                            g->nativeGraphics,
                                            &booln));

    return booln;
}

inline BOOL 
Region::IsInfinite(IN const Graphics *g) const
{
    BOOL booln = FALSE;

    SetStatus(DllExports::GdipIsInfiniteRegion(nativeRegion,
                                                 g->nativeGraphics,
                                                 &booln));

    return booln;
}

inline BOOL 
Region::Equals(IN const Region* region, 
               IN const Graphics* g) const
{
    BOOL booln = FALSE;

    SetStatus(DllExports::GdipIsEqualRegion(nativeRegion,
                                              region->nativeRegion,
                                              g->nativeGraphics,
                                              &booln));
    return booln;
}

// Get the size of the buffer needed for the GetData method
inline UINT 
Region::GetDataSize() const
{
    UINT     bufferSize = 0;
    
    SetStatus(DllExports::GdipGetRegionDataSize(nativeRegion, &bufferSize));
    
    return bufferSize;
}

// buffer     - where to put the data
// bufferSize - how big the buffer is (should be at least as big as GetDataSize())
// sizeFilled - if not NULL, this is an OUT param that says how many bytes
//              of data were written to the buffer.
inline Status 
Region::GetData(OUT BYTE* buffer, 
                IN UINT bufferSize, 
                OUT UINT* sizeFilled) const
{
    return SetStatus(DllExports::GdipGetRegionData(nativeRegion, buffer, 
                                                   bufferSize, sizeFilled));
}

/**
 * Hit testing operations
 */
inline BOOL 
Region::IsVisible(IN const PointF& point, 
                  IN const Graphics* g) const
{
    BOOL booln = FALSE;

    SetStatus(DllExports::GdipIsVisibleRegionPoint(nativeRegion,
                                     point.X, point.Y, 
                                     (g == NULL) ? NULL : g->nativeGraphics,
                                     &booln));
    return booln;
}

inline BOOL 
Region::IsVisible(IN const RectF& rect, 
                  IN const Graphics* g) const
{
    BOOL booln = FALSE;

    SetStatus(DllExports::GdipIsVisibleRegionRect(nativeRegion, rect.X,
                                                    rect.Y, rect.Width,
                                                    rect.Height,
                                                    (g == NULL) ?
                                                      NULL : g->nativeGraphics,
                                                    &booln));
    return booln;
}

inline BOOL 
Region::IsVisible(IN const Point& point, 
                  IN const Graphics* g) const
{
    BOOL booln = FALSE;


    SetStatus(DllExports::GdipIsVisibleRegionPointI(nativeRegion,
                                                   point.X,
                                                   point.Y,
                                                   (g == NULL) 
                                                    ? NULL : g->nativeGraphics,
                                                   &booln));
    return booln;
}

inline BOOL 
Region::IsVisible(IN const Rect& rect, 
                  IN const Graphics* g) const
{
    BOOL booln = FALSE;

    SetStatus(DllExports::GdipIsVisibleRegionRectI(nativeRegion,
                                                  rect.X,
                                                  rect.Y,
                                                  rect.Width,
                                                  rect.Height,
                                                  (g == NULL) 
                                                    ? NULL : g->nativeGraphics,
                                                  &booln));
    return booln;
}

inline UINT 
Region::GetRegionScansCount(IN const Matrix* matrix) const
{
    UINT count = 0;

    SetStatus(DllExports::GdipGetRegionScansCount(nativeRegion,
                                                  &count,
                                                  matrix->nativeMatrix));
    return count;
}

// If rects is NULL, return the count of rects in the region.
// Otherwise, assume rects is big enough to hold all the region rects
// and fill them in and return the number of rects filled in.
// The rects are returned in the units specified by the matrix
// (which is typically a world-to-device transform).
// Note that the number of rects returned can vary, depending on the
// matrix that is used.

inline Status 
Region::GetRegionScans(
    IN const Matrix* matrix,
    OUT RectF* rects,
    IN OUT INT* count) const
{
    return SetStatus(DllExports::GdipGetRegionScans(nativeRegion,
                                          rects,
                                          count,
                                          matrix->nativeMatrix));
}

inline Status
Region::GetRegionScans(
    IN const Matrix* matrix,
    OUT Rect* rects,
    IN OUT INT* count) const
{
    return SetStatus(DllExports::GdipGetRegionScansI(nativeRegion,
                                          rects,
                                          count,
                                          matrix->nativeMatrix));
}

inline Region::Region(GpRegion* nativeRegion)
{
    SetNativeRegion(nativeRegion);
}

inline VOID Region::SetNativeRegion(GpRegion* nativeRegion)
{
    this->nativeRegion = nativeRegion;
}

inline Status Region::GetLastStatus() const
{
    Status lastStatus = lastResult;
    lastResult = Ok;

    return lastStatus;
}

#endif // !_GDIPLUSREGION_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\sdkinc\gdiplustypes.h ===
/**************************************************************************\
*
* Copyright (c) 1998-2001, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   GdiplusTypes.h
*
* Abstract:
*
*   GDI+ Types
*
\**************************************************************************/

#ifndef _GDIPLUSTYPES_H
#define _GDIPLUSTYPES_H

//--------------------------------------------------------------------------
// Callback functions
//--------------------------------------------------------------------------

extern "C" {
typedef BOOL (CALLBACK * ImageAbort)(VOID *);
typedef ImageAbort DrawImageAbort;
typedef ImageAbort GetThumbnailImageAbort;
}

// Callback for EnumerateMetafile methods.  The parameters are:

//      recordType      WMF, EMF, or EMF+ record type
//      flags           (always 0 for WMF/EMF records)
//      dataSize        size of the record data (in bytes), or 0 if no data
//      data            pointer to the record data, or NULL if no data
//      callbackData    pointer to callbackData, if any

// This method can then call Metafile::PlayRecord to play the
// record that was just enumerated.  If this method  returns
// FALSE, the enumeration process is aborted.  Otherwise, it continues.

extern "C" {
typedef BOOL (CALLBACK * EnumerateMetafileProc)(EmfPlusRecordType,UINT,UINT,const BYTE*,VOID*);
}

//--------------------------------------------------------------------------
// Primitive data types
//
// NOTE:
//  Types already defined in standard header files:
//      INT8
//      UINT8
//      INT16
//      UINT16
//      INT32
//      UINT32
//      INT64
//      UINT64
//
//  Avoid using the following types:
//      LONG - use INT
//      ULONG - use UINT
//      DWORD - use UINT32
//--------------------------------------------------------------------------

typedef float REAL;

#define REAL_MAX            FLT_MAX
#define REAL_MIN            FLT_MIN
#define REAL_TOLERANCE     (FLT_MIN * 100)
#define REAL_EPSILON        1.192092896e-07F        /* FLT_EPSILON */

//--------------------------------------------------------------------------
// Forward declarations of common classes
//--------------------------------------------------------------------------

class Size;
class SizeF;
class Point;
class PointF;
class Rect;
class RectF;
class CharacterRange;

//--------------------------------------------------------------------------
// Status return values from GDI+ methods
//--------------------------------------------------------------------------

enum Status
{
    Ok = 0,
    GenericError = 1,
    InvalidParameter = 2,
    OutOfMemory = 3,
    ObjectBusy = 4,
    InsufficientBuffer = 5,
    NotImplemented = 6,
    Win32Error = 7,
    WrongState = 8,
    Aborted = 9,
    FileNotFound = 10,
    ValueOverflow = 11,
    AccessDenied = 12,
    UnknownImageFormat = 13,
    FontFamilyNotFound = 14,
    FontStyleNotFound = 15,
    NotTrueTypeFont = 16,
    UnsupportedGdiplusVersion = 17,
    GdiplusNotInitialized = 18,
    PropertyNotFound = 19,
    PropertyNotSupported = 20
};

//--------------------------------------------------------------------------
// Represents a dimension in a 2D coordinate system (floating-point coordinates)
//--------------------------------------------------------------------------

class SizeF
{
public:
    SizeF()
    {
        Width = Height = 0.0f;
    }

    SizeF(IN const SizeF& size)
    {
        Width = size.Width;
        Height = size.Height;
    }

    SizeF(IN REAL width,
          IN REAL height)
    {
        Width = width;
        Height = height;
    }

    SizeF operator+(IN const SizeF& sz) const
    {
        return SizeF(Width + sz.Width,
                     Height + sz.Height);
    }

    SizeF operator-(IN const SizeF& sz) const
    {
        return SizeF(Width - sz.Width,
                     Height - sz.Height);
    }

    BOOL Equals(IN const SizeF& sz) const
    {
        return (Width == sz.Width) && (Height == sz.Height);
    }

    BOOL Empty() const
    {
        return (Width == 0.0f && Height == 0.0f);
    }

public:

    REAL Width;
    REAL Height;
};

//--------------------------------------------------------------------------
// Represents a dimension in a 2D coordinate system (integer coordinates)
//--------------------------------------------------------------------------

class Size
{
public:
    Size()
    {
        Width = Height = 0;
    }

    Size(IN const Size& size)
    {
        Width = size.Width;
        Height = size.Height;
    }

    Size(IN INT width,
         IN INT height)
    {
        Width = width;
        Height = height;
    }

    Size operator+(IN const Size& sz) const
    {
        return Size(Width + sz.Width,
                    Height + sz.Height);
    }

    Size operator-(IN const Size& sz) const
    {
        return Size(Width - sz.Width,
                    Height - sz.Height);
    }

    BOOL Equals(IN const Size& sz) const
    {
        return (Width == sz.Width) && (Height == sz.Height);
    }

    BOOL Empty() const
    {
        return (Width == 0 && Height == 0);
    }

public:

    INT Width;
    INT Height;
};

//--------------------------------------------------------------------------
// Represents a location in a 2D coordinate system (floating-point coordinates)
//--------------------------------------------------------------------------

class PointF
{
public:
   PointF()
   {
       X = Y = 0.0f;
   }

   PointF(IN const PointF &point)
   {
       X = point.X;
       Y = point.Y;
   }

   PointF(IN const SizeF &size)
   {
       X = size.Width;
       Y = size.Height;
   }

   PointF(IN REAL x,
          IN REAL y)
   {
       X = x;
       Y = y;
   }

   PointF operator+(IN const PointF& point) const
   {
       return PointF(X + point.X,
                     Y + point.Y);
   }

   PointF operator-(IN const PointF& point) const
   {
       return PointF(X - point.X,
                     Y - point.Y);
   }

   BOOL Equals(IN const PointF& point)
   {
       return (X == point.X) && (Y == point.Y);
   }

public:

    REAL X;
    REAL Y;
};

//--------------------------------------------------------------------------
// Represents a location in a 2D coordinate system (integer coordinates)
//--------------------------------------------------------------------------

class Point
{
public:
   Point()
   {
       X = Y = 0;
   }

   Point(IN const Point &point)
   {
       X = point.X;
       Y = point.Y;
   }

   Point(IN const Size &size)
   {
       X = size.Width;
       Y = size.Height;
   }

   Point(IN INT x,
         IN INT y)
   {
       X = x;
       Y = y;
   }

   Point operator+(IN const Point& point) const
   {
       return Point(X + point.X,
                    Y + point.Y);
   }

   Point operator-(IN const Point& point) const
   {
       return Point(X - point.X,
                    Y - point.Y);
   }

   BOOL Equals(IN const Point& point)
   {
       return (X == point.X) && (Y == point.Y);
   }

public:

    INT X;
    INT Y;
};

//--------------------------------------------------------------------------
// Represents a rectangle in a 2D coordinate system (floating-point coordinates)
//--------------------------------------------------------------------------

class RectF
{
public:

    RectF()
    {
        X = Y = Width = Height = 0.0f;
    }

    RectF(IN REAL x,
          IN REAL y,
          IN REAL width,
          IN REAL height)
    {
        X = x;
        Y = y;
        Width = width;
        Height = height;
    }

    RectF(IN const PointF& location,
          IN const SizeF& size)
    {
        X = location.X;
        Y = location.Y;
        Width = size.Width;
        Height = size.Height;
    }

    RectF* Clone() const
    {
        return new RectF(X, Y, Width, Height);
    }

    VOID GetLocation(OUT PointF* point) const
    {
        point->X = X;
        point->Y = Y;
    }

    VOID GetSize(OUT SizeF* size) const
    {
        size->Width = Width;
        size->Height = Height;
    }

    VOID GetBounds(OUT RectF* rect) const
    {
        rect->X = X;
        rect->Y = Y;
        rect->Width = Width;
        rect->Height = Height;
    }

    REAL GetLeft() const
    {
        return X;
    }

    REAL GetTop() const
    {
        return Y;
    }

    REAL GetRight() const
    {
        return X+Width;
    }

    REAL GetBottom() const
    {
        return Y+Height;
    }

    BOOL IsEmptyArea() const
    {
        return (Width <= REAL_EPSILON) || (Height <= REAL_EPSILON);
    }

    BOOL Equals(IN const RectF & rect) const
    {
        return X == rect.X &&
               Y == rect.Y &&
               Width == rect.Width &&
               Height == rect.Height;
    }

    BOOL Contains(IN REAL x,
                  IN REAL y) const
    {
        return x >= X && x < X+Width &&
               y >= Y && y < Y+Height;
    }

    BOOL Contains(IN const PointF& pt) const
    {
        return Contains(pt.X, pt.Y);
    }

    BOOL Contains(IN const RectF& rect) const
    {
        return (X <= rect.X) && (rect.GetRight() <= GetRight()) &&
               (Y <= rect.Y) && (rect.GetBottom() <= GetBottom());
    }

    VOID Inflate(IN REAL dx,
                 IN REAL dy)
    {
        X -= dx;
        Y -= dy;
        Width += 2*dx;
        Height += 2*dy;
    }

    VOID Inflate(IN const PointF& point)
    {
        Inflate(point.X, point.Y);
    }

    BOOL Intersect(IN const RectF& rect)
    {
        return Intersect(*this, *this, rect);
    }

    static BOOL Intersect(OUT RectF& c,
                          IN const RectF& a,
                          IN const RectF& b)
    {
        REAL right = min(a.GetRight(), b.GetRight());
        REAL bottom = min(a.GetBottom(), b.GetBottom());
        REAL left = max(a.GetLeft(), b.GetLeft());
        REAL top = max(a.GetTop(), b.GetTop());

        c.X = left;
        c.Y = top;
        c.Width = right - left;
        c.Height = bottom - top;
        return !c.IsEmptyArea();
    }

    BOOL IntersectsWith(IN const RectF& rect) const
    {
        return (GetLeft() < rect.GetRight() &&
                GetTop() < rect.GetBottom() &&
                GetRight() > rect.GetLeft() &&
                GetBottom() > rect.GetTop());
    }

    static BOOL Union(OUT RectF& c,
                      IN const RectF& a,
                      IN const RectF& b)
    {
        REAL right = max(a.GetRight(), b.GetRight());
        REAL bottom = max(a.GetBottom(), b.GetBottom());
        REAL left = min(a.GetLeft(), b.GetLeft());
        REAL top = min(a.GetTop(), b.GetTop());

        c.X = left;
        c.Y = top;
        c.Width = right - left;
        c.Height = bottom - top;
        return !c.IsEmptyArea();
    }

    VOID Offset(IN const PointF& point)
    {
        Offset(point.X, point.Y);
    }

    VOID Offset(IN REAL dx,
                IN REAL dy)
    {
        X += dx;
        Y += dy;
    }

public:

    REAL X;
    REAL Y;
    REAL Width;
    REAL Height;
};

//--------------------------------------------------------------------------
// Represents a rectangle in a 2D coordinate system (integer coordinates)
//--------------------------------------------------------------------------

class Rect
{
public:

    Rect()
    {
        X = Y = Width = Height = 0;
    }

    Rect(IN INT x,
         IN INT y,
         IN INT width,
         IN INT height)
    {
        X = x;
        Y = y;
        Width = width;
        Height = height;
    }

    Rect(IN const Point& location,
         IN const Size& size)
    {
        X = location.X;
        Y = location.Y;
        Width = size.Width;
        Height = size.Height;
    }

    Rect* Clone() const
    {
        return new Rect(X, Y, Width, Height);
    }

    VOID GetLocation(OUT Point* point) const
    {
        point->X = X;
        point->Y = Y;
    }

    VOID GetSize(OUT Size* size) const
    {
        size->Width = Width;
        size->Height = Height;
    }

    VOID GetBounds(OUT Rect* rect) const
    {
        rect->X = X;
        rect->Y = Y;
        rect->Width = Width;
        rect->Height = Height;
    }

    INT GetLeft() const
    {
        return X;
    }

    INT GetTop() const
    {
        return Y;
    }

    INT GetRight() const
    {
        return X+Width;
    }

    INT GetBottom() const
    {
        return Y+Height;
    }

    BOOL IsEmptyArea() const
    {
        return (Width <= 0) || (Height <= 0);
    }

    BOOL Equals(IN const Rect & rect) const
    {
        return X == rect.X &&
               Y == rect.Y &&
               Width == rect.Width &&
               Height == rect.Height;
    }

    BOOL Contains(IN INT x,
                  IN INT y) const
    {
        return x >= X && x < X+Width &&
               y >= Y && y < Y+Height;
    }

    BOOL Contains(IN const Point& pt) const
    {
        return Contains(pt.X, pt.Y);
    }

    BOOL Contains(IN Rect& rect) const
    {
        return (X <= rect.X) && (rect.GetRight() <= GetRight()) &&
               (Y <= rect.Y) && (rect.GetBottom() <= GetBottom());
    }

    VOID Inflate(IN INT dx,
                 IN INT dy)
    {
        X -= dx;
        Y -= dy;
        Width += 2*dx;
        Height += 2*dy;
    }

    VOID Inflate(IN const Point& point)
    {
        Inflate(point.X, point.Y);
    }

    BOOL Intersect(IN const Rect& rect)
    {
        return Intersect(*this, *this, rect);
    }

    static BOOL Intersect(OUT Rect& c,
                          IN const Rect& a,
                          IN const Rect& b)
    {
        INT right = min(a.GetRight(), b.GetRight());
        INT bottom = min(a.GetBottom(), b.GetBottom());
        INT left = max(a.GetLeft(), b.GetLeft());
        INT top = max(a.GetTop(), b.GetTop());

        c.X = left;
        c.Y = top;
        c.Width = right - left;
        c.Height = bottom - top;
        return !c.IsEmptyArea();
    }

    BOOL IntersectsWith(IN const Rect& rect) const
    {
        return (GetLeft() < rect.GetRight() &&
                GetTop() < rect.GetBottom() &&
                GetRight() > rect.GetLeft() &&
                GetBottom() > rect.GetTop());
    }

    static BOOL Union(OUT Rect& c,
                      IN const Rect& a,
                      IN const Rect& b)
    {
        INT right = max(a.GetRight(), b.GetRight());
        INT bottom = max(a.GetBottom(), b.GetBottom());
        INT left = min(a.GetLeft(), b.GetLeft());
        INT top = min(a.GetTop(), b.GetTop());

        c.X = left;
        c.Y = top;
        c.Width = right - left;
        c.Height = bottom - top;
        return !c.IsEmptyArea();
    }

    VOID Offset(IN const Point& point)
    {
        Offset(point.X, point.Y);
    }

    VOID Offset(IN INT dx,
                IN INT dy)
    {
        X += dx;
        Y += dy;
    }

public:

    INT X;
    INT Y;
    INT Width;
    INT Height;
};

class PathData
{
public:
    PathData()
    {
        Count = 0;
        Points = NULL;
        Types = NULL;
    }

    ~PathData()
    {
        if (Points != NULL)
        {
            delete Points;
        }

        if (Types != NULL)
        {
            delete Types;
        }
    }

private:
    PathData(const PathData &);
    PathData& operator=(const PathData &);

public:
    INT Count;
    PointF* Points;
    BYTE* Types;
};

class CharacterRange
{
public:
    CharacterRange(
        INT first,
        INT length
    ) :
        First   (first),
        Length  (length)
    {}

    CharacterRange() : First(0), Length(0)
    {}

    CharacterRange & operator = (const CharacterRange &rhs)
    {
        First  = rhs.First;
        Length = rhs.Length;
        return *this;
    }

    INT First;
    INT Length;
};

#endif // !_GDIPLUSTYPES_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\16bpp\wndstuff.h ===
/****************************** Module Header ******************************\
* Module Name: wndstuff.h
*
* Kent's Window Test.  To be used as a program template.
*
* Created: 09-May-91
* Author: KentD
*
* Copyright (c) 1991 Microsoft Corporation
\***************************************************************************/

#define DONTUSE(x) (x)

#define MM_NEW          0x8001
#define MM_EXIT         0x8002
#define MM_TEST         0x8003

#define IDB_BITMAPCMYKTEST  0x9001

VOID Test(HWND);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\16bpp\16bpp.cpp ===
/******************************Module*Header*******************************\
* Module Name: test.c
*
* Created: 09-Dec-1992 10:51:46          
* Author: Kirk Olynyk [kirko]
*
* Copyright (c) 1991 Microsoft Corporation
*
* Contains the test
*
\**************************************************************************/

#include <windows.h>
#include <objbase.h>
#include <math.h>             // sin & cos
#include <stdio.h>
#include "wndstuff.h"

#include <gdiplus.h>

using namespace Gdiplus;

enum SurfaceFormat {
    SurfaceFormatUnknown,
    SurfaceFormat565,
    SurfaceFormat555
};

/**************************************************************************\
* GetSurfaceFormat
* 
* Returns:
*   Returns the display mode, or
*   SurfaceFormatUnknown if unknown or on error.
*
*   Only recognizes 555 and 565.
*
\**************************************************************************/

SurfaceFormat
GetSurfaceFormat(
    HDC hdc
    )
{
    HBITMAP hbm;
    SurfaceFormat ret = SurfaceFormatUnknown;
    
    BYTE bmi_buf[sizeof(BITMAPINFO) + (sizeof(RGBQUAD) * 255)];
    BITMAPINFO *pbmi = (BITMAPINFO *) bmi_buf;
    
    memset(bmi_buf, 0, sizeof(bmi_buf));
    
    // Create a dummy bitmap from which we can query color format info
    // about the device surface.

    if ( (hbm = CreateCompatibleBitmap(hdc, 1, 1)) != NULL )
    {
        pbmi->bmiHeader.biSize = sizeof(BITMAPINFOHEADER);

        // Call first time to fill in BITMAPINFO header.

        GetDIBits(hdc, hbm, 0, 0, NULL, pbmi, DIB_RGB_COLORS);

        // First handle the 'simple' case of indexed formats.
        
        if (   (pbmi->bmiHeader.biBitCount == 16)
            && ( pbmi->bmiHeader.biCompression == BI_BITFIELDS ))
        {
            DWORD redMask = 0;
            DWORD greenMask = 0;
            DWORD blueMask = 0;
            
            // Call a second time to get the color masks.
            // It's a GetDIBits Win32 "feature".

            GetDIBits(
                hdc, 
                hbm, 
                0, 
                pbmi->bmiHeader.biHeight, 
                NULL, 
                pbmi,
                DIB_RGB_COLORS
            );
                      
            DWORD* masks = reinterpret_cast<DWORD*>(&pbmi->bmiColors[0]);

            redMask = masks[0];
            greenMask = masks[1];
            blueMask = masks[2];          
            
            if ((redMask   == 0x0000f800) &&
                (greenMask == 0x000007e0) &&
                (blueMask  == 0x0000001f) &&
                (pbmi->bmiHeader.biBitCount == 16))
            {
                ret = SurfaceFormat565;
            }
            if ((redMask   == 0x00007c00) &&
                (greenMask == 0x000003e0) &&
                (blueMask  == 0x0000001f) &&
                (pbmi->bmiHeader.biBitCount == 16))
            {
                ret = SurfaceFormat555;
            }
        }

        DeleteObject(hbm);
    }

    return ret;
}


static HBITMAP CreateMyDIB(HDC hdcin, PVOID *ppvBits) {
    // these combined give BITMAPINFO structure.
    struct {
        BITMAPINFOHEADER bmih;
        RGBQUAD rgbquad16[3];
    } bmi;

    bmi.bmih.biSize = sizeof(BITMAPINFOHEADER);
    bmi.bmih.biWidth = 8;
    bmi.bmih.biHeight = 8;
    bmi.bmih.biPlanes = 1;
    bmi.bmih.biBitCount = 16;
    bmi.bmih.biCompression = BI_BITFIELDS;
    bmi.bmih.biSizeImage = 0;
    bmi.bmih.biXPelsPerMeter = 0;
    bmi.bmih.biYPelsPerMeter = 0;
    bmi.bmih.biClrUsed = 0;             // only used for <= 16bpp
    bmi.bmih.biClrImportant = 0;

    RGBQUAD rgbQuad16[3] = { { 0, 0xf8, 0, 0 }, { 0xe0, 07, 0, 0 }, { 0x1f, 0, 0, 0 } };

    memcpy(bmi.rgbquad16, rgbQuad16, sizeof(rgbQuad16));
    
    HBITMAP hbitmap;
    
    hbitmap = CreateDIBSection(
        hdcin,
        (BITMAPINFO*)&bmi,
        DIB_RGB_COLORS,
        ppvBits,
        NULL,
        0);
        
    return hbitmap;
}

static int sysColorNum[4] = {
    COLOR_3DSHADOW,
    COLOR_3DFACE,
    COLOR_3DHIGHLIGHT,
    COLOR_DESKTOP
};

static void DumpBitmap(FILE *fp, WORD *pBits) {
    WORD * pBits2 = pBits;

    WORD col = *pBits2++;
    int count;
    for (count = 1;count < 64; count++) {
        if (col != *pBits2++) break;
    }
    if (count == 64) {
        fprintf(fp, "      Solid %04x\n\n", col);
    } else {
        int i,j;
        for (i=0;i<8;i++) {
            fprintf(fp, "      ");
            for (j=0;j<8;j++) {
                fprintf(fp, "%04x ", *pBits++);
            }
            fprintf(fp, "\n");
        }
        fprintf(fp, "\n");
    }
}

static void DumpColor(FILE *fp, Color &c) {
    fprintf(fp, "(%02x, %02x, %02x)", c.GetRed(), c.GetGreen(), c.GetBlue());
}

VOID
Test(
    HWND hwnd
    )
{
    HDC hdc = NULL;
    Graphics *g = NULL;
    HBITMAP hbm = NULL;
    HDC hdcOffscreen = NULL;
    HBITMAP bmOld = NULL;
    PVOID pvBits = NULL;
    FILE *fp = NULL;
    SurfaceFormat format = SurfaceFormatUnknown;
    
    Rect rect1(
        0, 
        40, 
        8,
        8
    );
    
    Rect rect2(
        0, 
        0, 
        8,
        8
    );
    
    hdc = GetDC(hwnd);
    g = new Graphics(hdc);
    
    {
        HDC h = g->GetHDC();
        format = GetSurfaceFormat(h);
    
        if (   (format == SurfaceFormat555)
            || (format == SurfaceFormat565)) {
            
            hbm = CreateMyDIB(h, &pvBits);
            hdcOffscreen = CreateCompatibleDC(h);
            bmOld = (HBITMAP) SelectObject(hdcOffscreen, hbm);
        } else {
            printf("Error: Display doesn't seem to be in 16bpp\n");
            g->ReleaseHDC(h);
            goto ErrorOut;
        }
        g->ReleaseHDC(h);
    }
    
    fp = fopen("output.txt", "w");
    fprintf(fp, 
        "The 16bpp mode on this machine is in %s format.\n\n"
        "This is test output for examining rendering to 16bpp (555/565) destinations,\n"
        "and comparing Win9x with NT output.\n"
        "Related bugs: #294433, #292492, #298264, #298283, #351610, #321960.\n"
        "We use 3*256 test colors; for each channel, one test color for each possible\n"
        "0-255 level.\n"
        "This output has 2 sections.\n\n"

        "--------------------------------------------------------------------------------\n"
        "SECTION 1: GetNearestColor\n"
        "Shows the result of calling GetNearestColor on that color. For section 2, we\n"
        "also remember which colors were the result of a GetNearestColor call.\n"
        "\n",
        (format == SurfaceFormat555) ? "555" : "565"
    );
    
    int num;
    
    const int numColors = 256 * 3;
    
    BYTE colors[numColors][3];
    BOOL isNearest[numColors];

    for (num=0; num < numColors; num++) {
        isNearest[num] = FALSE;
    }
    
    for (num=0; num < numColors; num++) {
        colors[num][0] = 0;
        colors[num][1] = 0;
        colors[num][2] = 0;
        
        int chnum = num / 256;
        
        colors[num][chnum] = (BYTE) (num % 256);
        
        Color color(colors[num][0], colors[num][1], colors[num][2]);
        Color color2(colors[num][0], colors[num][1], colors[num][2]);
        g->GetNearestColor(&color2);
        
        BYTE nc[3];
        nc[0] = color2.GetRed();
        nc[1] = color2.GetGreen();
        nc[2] = color2.GetBlue();
        
        int nearestIdx = nc[chnum] + 256*chnum;
        nc[chnum] = 0;
        if ((nc[0] != 0) ||
            (nc[1] != 0) ||
            (nc[2] != 0) ||
            (nearestIdx < 0) ||
            (nearestIdx >= numColors))
        {
            fprintf(fp, "UNEXPECTED: ");
        }
        else
        {
            isNearest[nearestIdx] = TRUE;
        }
        fprintf(fp, "GetNearestColor(");
        DumpColor(fp, color);
        fprintf(fp, ") == ");
        DumpColor(fp, color2);
        fprintf(fp, "\n");
    }

    fprintf(fp, 
        "\n--------------------------------------------------------------------------------\n"
        "SECTION 2: FillRect\n"
        "Shows the result of calling FillRectangle of an 8x8 rectangle using the input\n"
        "color. If all 64 pixels are the same, we say \"Solid xxxx\" with the resulting\n"
        "16-bit value. Otherwise, all 64 pixels are reported.\n"
        "\n"
        "* next to the color means that GetNearestColor can return this color.\n"
        "\n"
    );
    
    for (num=0; num < numColors; num++) {
        Color color(colors[num][0], colors[num][1], colors[num][2]);
        
        fprintf(fp, "%sColor: ", isNearest[num]?"* ":"  ");
        DumpColor(fp, color);
        fprintf(fp, "\n");
        
        SolidBrush solidBrush1(color);
        
        fprintf(fp, "    GDI+ FillRectangle to screen (uses GDI CreateSolidBrush & PatBlt):\n");
        
        {
            g->FillRectangle(&solidBrush1, rect1);
            HDC hdcGraphics = g->GetHDC();
            BitBlt(hdcOffscreen, 0, 0, rect1.Width, rect1.Height, hdcGraphics, rect1.X, rect1.Y, SRCCOPY);
            g->ReleaseHDC(hdcGraphics);
        }

        DumpBitmap(fp, (WORD *) pvBits);
        
        fprintf(fp, "    GDI+ FillRectangle to DIBSection (uses GDI+ dithering):\n");
        
        {
            Graphics g2(hdcOffscreen);
            g2.FillRectangle(&solidBrush1, rect2);
        }

        DumpBitmap(fp, (WORD *) pvBits);
    }
    
ErrorOut:
    if (fp) fclose(fp);
    
    if (bmOld) SelectObject(hdcOffscreen, bmOld);                  
    if (hdcOffscreen) DeleteDC(hdcOffscreen);
    if (hbm) DeleteObject(hbm);

    delete g;
        
    if (hdc) ReleaseDC(hwnd, hdc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\16bpp\wndstuff.cpp ===
/******************************Module*Header*******************************\
* Module Name: wndstuff.cpp
*
* This file contains the code to support a simple window that has
* a menu with a single item called "Test". When "Test" is selected
* vTest(HWND) is called.
*
* Created: 09-Dec-1992 10:44:31
* Author: Kirk Olynyk [kirko]
*
* Copyright (c) 1991 Microsoft Corporation
*
\**************************************************************************/

// for Win95 compile
#undef UNICODE
#undef _UNICODE

#include <windows.h>
#include <stdio.h>
#include <tchar.h>
#include <objbase.h>
#include <gdiplus.h>

#include "wndstuff.h"

#include "../gpinit.inc"

HINSTANCE ghInstance;
HWND ghwndMain;
HWND ghwndDebug;
HWND ghwndList;
HBRUSH ghbrWhite;

/***************************************************************************\
* lMainWindowProc(hwnd, message, wParam, lParam)
*
* Processes all messages for the main window.
*
* History:
*  04-07-91 -by- KentD
* Wrote it.
\***************************************************************************/

LONG_PTR
lMainWindowProc(
    HWND    hwnd,
    UINT    message,
    WPARAM  wParam,
    LPARAM  lParam
    )
{
    PAINTSTRUCT ps;

    switch (message)
    {
    case WM_CREATE:
/*        if (!InitializeEngine())
        {
            MessageBox(0, _T("Engine didn't initialize"), _T("Uh oh"), MB_OK);
        }
*/
        break;

    case WM_COMMAND:
        switch(LOWORD(wParam))
        {
        case MM_TEST:
            Test(hwnd);
            break;

        default:
            break;
        }
        break;

    case WM_DESTROY:
//        UninitializeEngine();

        DeleteObject(ghbrWhite);
        PostQuitMessage(0);
        return(DefWindowProc(hwnd, message, wParam, lParam));

    default:
        return(DefWindowProc(hwnd, message, wParam, lParam));
    }

    return(0);
}

/******************************Public*Routine******************************\
* DebugWndProc
*
* List box is maintained here.
*
\**************************************************************************/

LONG_PTR FAR PASCAL DebugWndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    RECT    rcl;
    HDC     hdc;
    LONG_PTR    lRet = 0;

// Process window message.

    switch (message)
    {
    case WM_SIZE:
        lRet = DefWindowProc(ghwndList, message, wParam, lParam);
        GetClientRect(ghwndMain, &rcl);
        MoveWindow(
            ghwndList,
            rcl.left, rcl.top,
            (rcl.right - rcl.left), (rcl.bottom - rcl.top),
            TRUE
            );
        UpdateWindow(ghwndList);
        break;

    case WM_DESTROY:
        PostQuitMessage(0);
        break;

    default:
        lRet = DefWindowProc(hwnd, message, wParam, lParam);
        break;
    }

    return lRet;
}

/******************************Public*Routine******************************\
* LBprintf
*
* ListBox printf implementation.
*
* History:
*  15-Dec-1994 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

void LBprintf(PCH msg, ...)
{
    if (ghwndList)
    {
        va_list ap;
        char buffer[256];

        va_start(ap, msg);

        vsprintf(buffer, msg, ap);

        SendMessage(ghwndList, LB_ADDSTRING, (WPARAM) 0, (LPARAM) buffer);
        SendMessage(ghwndList, WM_SETREDRAW, (WPARAM) TRUE, (LPARAM) 0);
        InvalidateRect(ghwndList, NULL, TRUE);
        UpdateWindow(ghwndList);

        va_end(ap);
    }
}

/******************************Public*Routine******************************\
* LBreset
*
* Reset ListBox state (clear).
*
* History:
*  15-Dec-1994 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

void LBreset()
{
    if (ghwndList)
        SendMessage(ghwndList, LB_RESETCONTENT, (WPARAM) FALSE, (LPARAM) 0);
}

/***************************************************************************\
* bInitApp()
*
* Initializes app.
*
* History:
*  04-07-91 -by- KentD
* Wrote it.
\***************************************************************************/

BOOL bInitApp(BOOL debug)
{
    WNDCLASS wc;

    ghbrWhite = CreateSolidBrush(RGB(0xFF,0xFF,0xFF));

    wc.style            = 0;
    wc.lpfnWndProc      = lMainWindowProc;
    wc.cbClsExtra       = 0;
    wc.cbWndExtra       = 0;
    wc.hInstance        = ghInstance;
    wc.hIcon            = LoadIcon(NULL, IDI_APPLICATION);
    wc.hCursor          = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground    = ghbrWhite;
    wc.lpszMenuName     = _T("MainMenu");
    wc.lpszClassName    = _T("TestClass");
    if (!RegisterClass(&wc))
    {
        return(FALSE);
    }
    ghwndMain =
      CreateWindowEx(
        0,
        _T("TestClass"),
        _T("Win32 Test"),
        WS_OVERLAPPED   |  
        WS_CAPTION      |  
        WS_BORDER       |  
        WS_THICKFRAME   |  
        WS_MAXIMIZEBOX  |  
        WS_MINIMIZEBOX  |  
        WS_CLIPCHILDREN |  
        WS_VISIBLE      |  
        WS_SYSMENU,
        80,
        70,
        500,
        500,
        NULL,
        NULL,
        ghInstance,
        NULL);

    if (ghwndMain == NULL)
    {
        return(FALSE);
    }

    if (debug)
    {
        RECT rcl;

        memset(&wc, 0, sizeof(wc));
        wc.style = 0;
        wc.lpfnWndProc = DebugWndProc;
        wc.cbClsExtra = 0;
        wc.cbWndExtra = 0;
        wc.hInstance = ghInstance;
        wc.hIcon = LoadIcon(NULL, IDI_APPLICATION);
        wc.hCursor = LoadCursor(NULL, IDC_ARROW);
        wc.hbrBackground = ghbrWhite;
        wc.lpszClassName = "DebugWClass";
        RegisterClass(&wc);

        ghwndDebug = CreateWindow(
            "DebugWClass",
            "Debug output",
            WS_OVERLAPPEDWINDOW|WS_MAXIMIZE,
            600,
            70,
            300,
            500,
            NULL,
            NULL,
            ghInstance,
            NULL
            );

        if (ghwndDebug)
        {
            ShowWindow(ghwndDebug, SW_NORMAL);
            UpdateWindow(ghwndDebug);

        // Create the list box to fill the main window.

            GetClientRect(ghwndDebug, &rcl);

            ghwndList = CreateWindow(
                "LISTBOX",
                "Debug output",
                WS_CHILD | WS_VISIBLE | WS_VSCROLL
                | WS_HSCROLL | LBS_NOINTEGRALHEIGHT,
                rcl.left, rcl.top,
                (rcl.right - rcl.left), (rcl.bottom - rcl.top),
                ghwndDebug,
                NULL,
                ghInstance,
                NULL
                );

            if (ghwndList)
            {
                SendMessage(
                    ghwndList,
                    WM_SETFONT,
                    (WPARAM) GetStockObject(ANSI_FIXED_FONT),
                    (LPARAM) FALSE
                    );

                LBreset();

                ShowWindow(ghwndList, SW_NORMAL);
                UpdateWindow(ghwndList);
            }
        }

    }

    SetFocus(ghwndMain);

    return(TRUE);
}

/***************************************************************************\
* main(argc, argv[])
*
* Sets up the message loop.
*
* History:
*  04-07-91 -by- KentD
* Wrote it.
\***************************************************************************/

_cdecl
main(
    INT   argc,
    PCHAR argv[])
{
    MSG    msg;
    HACCEL haccel;
    CHAR*  pSrc;
    CHAR*  pDst;

    if (!gGdiplusInitHelper.IsValid())
    {
        return 0;
    }
    
    BOOL wantDebugWindow = FALSE;

    CoInitialize(NULL);

    // Parse arguments

    for (argc--, argv++ ; argc && '-' == **argv ; argc--, argv++ )
    {
        switch ( *(++(*argv)) )
        {
        case 'd':
        case 'D':
            wantDebugWindow = TRUE;
            break;
        }
    }

    ghInstance = GetModuleHandle(NULL);

    if (!bInitApp(wantDebugWindow))
    {
        return(0);
    }

    haccel = LoadAccelerators(ghInstance, MAKEINTRESOURCE(1));
    while (GetMessage(&msg, NULL, 0, 0))
    {
        if (!TranslateAccelerator(msg.hwnd, haccel, &msg))
        {
             TranslateMessage(&msg);
             DispatchMessage(&msg);
        }
    }

    CoUninitialize();
    return(1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\anitest\anitest.cpp ===
//
// Simple test program for imaging library
//

#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <windows.h>
#include <objbase.h>
#include <urlmon.h>
#include <commdlg.h>

#include <imaging.h>
#include <initguid.h>
#include <imgguids.h>

CHAR* programName;          // program name
HINSTANCE appInstance;      // handle to the application instance
HWND hwndMain;              // handle to application's main window
IImagingFactory* imgfact;   // pointer to IImageingFactory object
IImage* curimage;           // pointer to IImage object
CHAR curFilename[MAX_PATH]; // current image filename
IImageDecoder *decoder;
IBitmapImage *bitmap;
ImageInfo imageinfo;
BOOL hastimedimension, loopingset, viewagain;
UINT numframes, lastsuccframe, currentframe, delay;
INT loopcount;


//
// Display an error message dialog
//

BOOL
CheckHRESULT(
    HRESULT hr,
    INT line
    )
{
    if (SUCCEEDED(hr))
        return TRUE;

    CHAR buf[1024];

    sprintf(buf, "Error on line %d: 0x%x\n", line, hr);
    MessageBoxA(hwndMain, buf, programName, MB_OK);

    return FALSE;
}

#define CHECKHR(hr) CheckHRESULT(hr, __LINE__)
#define LASTWIN32HRESULT HRESULT_FROM_WIN32(GetLastError())

#if DBG
#define VERBOSE(args) printf args
#else
#define VERBOSE(args)
#endif


//
// Helper class to convert ANSI strings to Unicode strings
//

inline BOOL
UnicodeToAnsiStr(
    const WCHAR* unicodeStr,
    CHAR* ansiStr,
    INT ansiSize
    )
{
    return WideCharToMultiByte(
                CP_ACP,
                0,
                unicodeStr,
                -1,
                ansiStr,
                ansiSize,
                NULL,
                NULL) > 0;
}

inline BOOL
AnsiToUnicodeStr(
    const CHAR* ansiStr,
    WCHAR* unicodeStr,
    INT unicodeSize
    )
{
    return MultiByteToWideChar(
                CP_ACP,
                0,
                ansiStr,
                -1,
                unicodeStr,
                unicodeSize) > 0;
}


class UnicodeStrFromAnsi
{
public:

    UnicodeStrFromAnsi(const CHAR* ansiStr)
    {
        if (ansiStr == NULL)
        {
            valid = TRUE;
            unicodeStr = NULL;
        }
        else
        {
            // NOTE: we only handle strings with length < MAX_PATH.

            valid = AnsiToUnicodeStr(ansiStr, buf, MAX_PATH);
            unicodeStr = valid ? buf : NULL;
        }
    }

    BOOL IsValid() const
    {
        return valid;
    }

    operator WCHAR*()
    {
        return unicodeStr;
    }

private:

    BOOL valid;
    WCHAR* unicodeStr;
    WCHAR buf[MAX_PATH];
};


//
// Convert current image to a bitmap image
//

IBitmapImage*
ConvertImageToBitmap(
    IImage* image,
    INT width = 0,
    INT height = 0,
    PixelFormatID pixfmt = PIXFMT_DONTCARE,
    InterpolationHint hint = INTERP_DEFAULT
    )
{
    if (!image)
        return NULL;

    HRESULT hr;
    IBitmapImage* bmp;

    hr = image->QueryInterface(IID_IBitmapImage, (VOID**) &bmp);

    if (SUCCEEDED(hr))
    {
        SIZE size;
        PixelFormatID fmt;

        // Current image is already a bitmap image and
        //  its dimension and pixel format are already as expected

        hr = bmp->GetSize(&size);
        if (!CHECKHR(hr))
            return NULL;

        hr = bmp->GetPixelFormatID(&fmt);
        if (!CHECKHR(hr))
            return NULL;

        if ((width == 0 || size.cx == width) &&
            (height == 0 || size.cy == height) &&
            (pixfmt == PIXFMT_DONTCARE || pixfmt == fmt))
        {
            return bmp;
        }

        bmp->Release();
    }

    // Convert the current image to a bitmap image

    if (width == 0 && height == 0)
    {
        ImageInfo imageInfo;
        hr = image->GetImageInfo(&imageInfo);

        // If the source image is scalable, then compute
        // the appropriate pixel dimension for the bitmap

        if (SUCCEEDED(hr) && (imageInfo.Flags & IMGFLAG_SCALABLE))
        {
            width = (INT) (96.0 * imageInfo.Width / imageInfo.Xdpi + 0.5);
            height = (INT) (96.0 * imageInfo.Height / imageInfo.Ydpi + 0.5);
        }
    }

    hr = imgfact->CreateBitmapFromImage(
                        image,
                        width, 
                        height, 
                        pixfmt,
                        hint,
                        &bmp);

    return SUCCEEDED(hr) ? bmp : NULL;
}


//
// Get pixel format strings
//

const CHAR*
GetPixelFormatStr(
    PixelFormatID pixfmt
    )
{
    switch (pixfmt)
    {
    case PIXFMT_8BPP_INDEXED:       return "8bpp indexed";
    case PIXFMT_16BPP_GRAYSCALE:    return "16bpp grayscale";
    case PIXFMT_16BPP_RGB555:       return "16bpp RGB 5-5-5";
    case PIXFMT_16BPP_RGB565:       return "16bpp RGB 5-6-5";
    case PIXFMT_16BPP_ARGB1555:     return "16bpp ARGB 1-5-5-5";
    case PIXFMT_24BPP_RGB:          return "24bpp RGB";
    case PIXFMT_32BPP_RGB:          return "32bpp RGB";
    case PIXFMT_32BPP_ARGB:         return "32bpp ARGB";
    case PIXFMT_32BPP_PARGB:        return "32bpp premultiplied ARGB";
    case PIXFMT_48BPP_RGB:          return "48bpp RGB";
    case PIXFMT_64BPP_ARGB:         return "64bpp ARGB";
    case PIXFMT_64BPP_PARGB:        return "64bpp premultiplied ARGB";
    case PIXFMT_UNDEFINED:
    default:                        return "Unknown";
    }
}

//
// Force a refresh of the image window
//

inline VOID RefreshImageDisplay()
{
    InvalidateRect(hwndMain, NULL, FALSE);

    // Update window title

    CHAR title[2*MAX_PATH];
    CHAR* p = title;

    strcpy(p, curFilename);

    SetWindowText(hwndMain, title);
}


//
// Decodes the specified frame and sets it up for drawing
//
HRESULT
DrawFrame(UINT frame)
{
    HRESULT hresult;

    if (hastimedimension)
    {
        if (numframes != -1 && frame > numframes)
        {
            return IMGERR_NOFRAME;
        }

        GUID guid = FRAMEDIM_TIME;
        hresult = decoder->SelectActiveFrame(&guid, frame);
        if (FAILED(hresult))
            return hresult;
        
        lastsuccframe = frame;
        
        IPropertySetStorage *propsetstorage;
        hresult = decoder->GetProperties(&propsetstorage);
        if (FAILED(hresult))
            propsetstorage = NULL;

        IPropertyStorage *propstorage;
        if (propsetstorage)
        {
            hresult = propsetstorage->Open(FMTID_ImageInformation, STGM_READ | 
                STGM_SHARE_EXCLUSIVE, &propstorage);
            if (FAILED(hresult))
                propstorage = NULL;
        }
        
        if (propstorage)
        {
            PROPSPEC propspec[2];
            PROPVARIANT propvariant[2];

            propspec[0].ulKind = PRSPEC_LPWSTR;
            propspec[0].lpwstr = L"Frame delay";
            propspec[1].ulKind = PRSPEC_LPWSTR;
            propspec[1].lpwstr = L"Loop count";

            hresult = propstorage->ReadMultiple(2, propspec, propvariant);
            propstorage->Release();
            if (SUCCEEDED(hresult))
            {
                if (propvariant[0].vt != VT_EMPTY)
                    delay = propvariant[0].uiVal;
                else
                    delay = 0;

                if (!loopingset)
                {
                    if (propvariant[1].vt != VT_EMPTY)
                    {
                        loopcount = propvariant[1].iVal;
                    }
                    else
                    {
                        loopcount = 0;
                    }
                    loopingset = TRUE;
                }
            }
            else
            {
                delay = 0;
            }
        }
    }
    IImageSink *sink;
    bitmap->QueryInterface(IID_IImageSink, (void**)&sink);

    hresult = decoder->BeginDecode(sink, NULL);
    sink->Release();
    if (FAILED(hresult))
        return hresult;

    hresult = decoder->Decode();
    if (FAILED(hresult))
        return hresult;

    hresult = decoder->EndDecode(S_OK);
    if (FAILED(hresult))
        return hresult;

    if (curimage)
    {
        curimage->Release();
        curimage = NULL;
    }

    bitmap->QueryInterface(IID_IImage, (void**)&curimage);

    return S_OK;
}


//
// Sets us the app for decompressing multiple frames
//

VOID
SetCurrentImage()
{
    HRESULT hresult;

    hresult = decoder->GetImageInfo(&imageinfo);
    if (FAILED(hresult))
        return;

    if (bitmap)
    {
        bitmap->Release();
        bitmap = NULL;
    }

    imgfact->CreateNewBitmap(imageinfo.Width, imageinfo.Height, PIXFMT_32BPP_ARGB, &bitmap);
    
    UINT count;
    GUID *dimensions;

    hastimedimension = FALSE;

    hresult = decoder->QueryFrameDimensions(&count, &dimensions);
    if (SUCCEEDED(hresult))
    {
        for (UINT i=0;i<count;i++)
        {
            if (dimensions[i] == FRAMEDIM_TIME)
            {
                hastimedimension = TRUE;
            }
        }
    } else if (hresult != E_NOTIMPL) {
        return;
    }

    DrawFrame(0);
    SetTimer(hwndMain, 0, delay*10, NULL);

    RefreshImageDisplay();
}


//
// Resize the window so it fits the image
//

#define MINWINWIDTH     200
#define MINWINHEIGHT    100
#define MAXWINWIDTH     1024
#define MAXWINHEIGHT    768

VOID
DoSizeWindowToFit(
    HWND hwnd,
    BOOL strict = FALSE
    )
{
    HRESULT hr;
    IBitmapImage* bmp;
    SIZE size;

    // Check if the current image is a bitmap image
    //  in that case, we'll get the pixel dimension

    hr = curimage->QueryInterface(IID_IBitmapImage, (VOID**) &bmp);

    if (SUCCEEDED(hr))
    {
        hr = bmp->GetSize(&size);
        bmp->Release();
    }

    // Otherwise, try to get device-independent image dimension

    if (FAILED(hr))
    {
        hr = curimage->GetPhysicalDimension(&size);
        if (FAILED(hr))
            return;

        size.cx = (INT) (size.cx * 96.0 / 2540.0 + 0.5);
        size.cy = (INT) (size.cy * 96.0 / 2540.0 + 0.5);
    }

    if (SUCCEEDED(hr))
    {
        // Figure out window border dimensions

        RECT r1, r2;
        INT w, h;

        w = size.cx;
        h = size.cy;

        if (!strict)
        {
            if (w < MINWINWIDTH)
                w = MINWINWIDTH;
            else if (w > MAXWINWIDTH)
                w = MAXWINWIDTH;

            if (h < MINWINHEIGHT)
                h = MINWINHEIGHT;
            else if (h > MAXWINHEIGHT)
                h = MAXWINHEIGHT;
        }

        GetWindowRect(hwnd, &r1);
        GetClientRect(hwnd, &r2);

        w += (r1.right - r1.left) - (r2.right - r2.left);
        h += (r1.bottom - r1.top) - (r2.bottom - r2.top);

        // Resize the window

        do
        {
            SetWindowPos(
                hwnd,
                NULL,
                0, 0,
                w, h,
                SWP_NOMOVE | SWP_NOZORDER);

            GetClientRect(hwnd, &r2);
            h += GetSystemMetrics(SM_CYMENU);
        }
        while (r2.bottom == 0);
    }
}


//
// Create an image object from a file
//

VOID
OpenImageFile(
    const CHAR* filename
    )
{
    HRESULT hr;
    IStream* stream;

    // Use URLMON.DLL to turn file into stream

    CHAR fullpath[MAX_PATH];
    CHAR* p;

    if (!GetFullPathName(filename, MAX_PATH, fullpath, &p))
        return;

    hr = URLOpenBlockingStreamA(NULL, fullpath, &stream, 0, NULL);

    if (!CHECKHR(hr))
        return;

    if (decoder)
    {
        decoder->TerminateDecoder();
        decoder->Release();
        decoder = NULL;
    }

    hr = imgfact->CreateImageDecoder(stream, DECODERINIT_NONE, &decoder);
    stream->Release();

    // Set the new image as the current image

    if (CHECKHR(hr))
    {
        SetCurrentImage();
        DoSizeWindowToFit(hwndMain);
    }
}


//
// Handle window repaint event
//

VOID
DoPaint(
    HWND hwnd
    )
{
    HDC hdc;
    PAINTSTRUCT ps;
    RECT rect;
    DWORD timer;
    HRESULT hr = E_FAIL;

    hdc = BeginPaint(hwnd, &ps);

    GetClientRect(hwnd, &rect);

    SetStretchBltMode(hdc, COLORONCOLOR);

    timer = GetTickCount();

    IBitmapImage* bmp;

    bmp = ConvertImageToBitmap(
                curimage,
                rect.right,
                rect.bottom,
                PIXFMT_32BPP_ARGB,
                INTERP_BICUBIC);

    if (!bmp)
        goto endPaint;

    //VERBOSE(("Stretch time: %dms, ", GetTickCount() - timer));

    IImage* image;

    hr = bmp->QueryInterface(IID_IImage, (VOID**) &image);
    bmp->Release();

    if (FAILED(hr))
        goto endPaint;
    
    //timer = GetTickCount();
    hr = image->Draw(hdc, &rect, NULL);
    //VERBOSE(("GDI time: %dms\n", GetTickCount() - timer));

    image->Release();

endPaint:

    if (FAILED(hr))
        FillRect(hdc, &rect, (HBRUSH) GetStockObject(BLACK_BRUSH));

    EndPaint(hwnd, &ps);
}


//
// Compose a file type filter string given an array of
// ImageCodecInfo structures
//

#define SizeofWSTR(s) (sizeof(WCHAR) * (wcslen(s) + 1))
#define SizeofSTR(s) (strlen(s) + 1)

CHAR*
MakeFilterFromCodecs(
    UINT count,
    const ImageCodecInfo* codecs,
    BOOL open
    )
{
    static const CHAR allFiles[] = "All Files\0*.*\0";

    // Figure out the total size of the filter string

    UINT index, size;

    for (index=size=0; index < count; index++)
    {
        size += SizeofWSTR(codecs[index].FormatDescription) +
                SizeofWSTR(codecs[index].FilenameExtension);
    }

    if (open)
        size += sizeof(allFiles);
    
    size += sizeof(CHAR);

    // Allocate memory

    CHAR *filter = (CHAR*) malloc(size);
    CHAR* p = filter;
    const WCHAR* ws;

    if (!filter)
        return NULL;

    for (index=0; index < count; index++)
    {
        ws = codecs[index].FormatDescription;
        size = SizeofWSTR(ws);

        if (UnicodeToAnsiStr(ws, p, size))
            p += SizeofSTR(p);
        else
            break;

        ws = codecs[index].FilenameExtension;
        size = SizeofWSTR(ws);

        if (UnicodeToAnsiStr(ws, p, size))
            p += SizeofSTR(p);
        else
            break;
    }

    if (index < count)
    {
        free(filter);
        return NULL;
    }

    if (open)
    {
        size = sizeof(allFiles);
        memcpy(p, allFiles, size);
        p += size;
    }

    *((CHAR*) p) = '\0';
    return filter;
}


//
// Open image file
//

VOID
DoOpen(
    HWND hwnd
    )
{
    OPENFILENAME ofn;
    CHAR filename[MAX_PATH];

    ZeroMemory(&ofn, sizeof(ofn));

    ofn.lStructSize = sizeof(ofn);
    ofn.hwndOwner = hwnd;
    ofn.hInstance = appInstance;
    ofn.lpstrFile = filename;
    ofn.nMaxFile = MAX_PATH;
    ofn.lpstrTitle = "Open Image File";
    ofn.lpstrInitialDir = ".";
    ofn.Flags = OFN_FILEMUSTEXIST;
    filename[0] = '\0';

    // Make up the file type filter string

    HRESULT hr;
    ImageCodecInfo* codecs;
    UINT count;

    hr = imgfact->GetInstalledDecoders(&count, &codecs);

    if (!CHECKHR(hr))
        return;

    CHAR* filter = MakeFilterFromCodecs(count, codecs, TRUE);

    if (codecs)
        CoTaskMemFree(codecs);

    if (!filter)
    {
        CHECKHR(LASTWIN32HRESULT);
        return;
    }

    ofn.lpstrFilter = filter;
    
    // Present the file/open dialog

    if (GetOpenFileName(&ofn))
        OpenImageFile(filename);

    free(filter);
}


//
//Figures out which frame to draw next and draws it.
//

void
NextFrame()
{
    BOOL tryagain = TRUE;
    while (tryagain)
    {
        tryagain = FALSE;
        HRESULT hresult = DrawFrame(currentframe);
        if (SUCCEEDED(hresult))
        {
            if (viewagain)
                currentframe++;
        }
        else if (hresult == IMGERR_NOFRAME)
        {
            if (currentframe > 0)
            {
                if (loopcount != 0)
                {
                    if (loopcount > 0)
                        loopcount--;
                    currentframe = 0;
                    tryagain = TRUE;
                }
                else
                {
                    currentframe--;
                    tryagain = TRUE;
                    viewagain = FALSE;
                }
            }
            else
            {
                printf("No frames are displayable.\n");
                exit(1);
            }
        }
    }
}

//
// Window callback procedure
//

LRESULT CALLBACK
MyWindowProc(
    HWND    hwnd,
    UINT    uMsg,
    WPARAM  wParam,
    LPARAM  lParam
    )
{
    switch (uMsg)
    {
    case WM_KEYDOWN:
        //For debugging
        //NextFrame();

        //RefreshImageDisplay();
        break;
    
    case WM_PAINT:
        DoPaint(hwnd);
        break;

    case WM_DESTROY:
        PostQuitMessage(0);
        break;

    case WM_TIMER:
        {
        KillTimer(hwndMain, 0);
        
        NextFrame();
        
        RefreshImageDisplay();

        if (viewagain)
            SetTimer(hwndMain, 0, delay*10, NULL);
        break;
        }
    default:
        return DefWindowProc(hwnd, uMsg, wParam, lParam);
    }

    return 0;
}


//
// Create main application window
//

#define MYWNDCLASSNAME "AniTest"

VOID
CreateMainWindow(
    VOID
    )
{
    //
    // Register window class
    //

    WNDCLASS wndClass =
    {
        CS_HREDRAW|CS_VREDRAW,
        MyWindowProc,
        0,
        0,
        appInstance,
        LoadIcon(NULL, IDI_APPLICATION),
        LoadCursor(NULL, IDC_ARROW),
        NULL,
        NULL,
        MYWNDCLASSNAME
    };

    RegisterClass(&wndClass);

    hwndMain = CreateWindow(
                    MYWNDCLASSNAME,
                    MYWNDCLASSNAME,
                    WS_OVERLAPPEDWINDOW,
                    CW_USEDEFAULT,
                    CW_USEDEFAULT,
                    CW_USEDEFAULT,
                    CW_USEDEFAULT,
                    NULL,
                    NULL,
                    appInstance,
                    NULL);

    if (!hwndMain)
    {
        CHECKHR(HRESULT_FROM_WIN32(GetLastError()));
        exit(-1);
    }
}


//
// Main program entrypoint
//

INT _cdecl
main(
    INT argc,
    CHAR **argv
    )
{
    programName = *argv++;
    argc--;
    appInstance = GetModuleHandle(NULL);
    CoInitialize(NULL);

    bitmap = NULL;
    decoder = NULL;    
    numframes = -1;
    lastsuccframe = -1;
    currentframe = 0;
    loopingset = FALSE;
    viewagain = TRUE;
    
    //
    // Create an IImagingFactory object
    //
    
    HRESULT hr;

    hr = CoCreateInstance(
            CLSID_ImagingFactory,
            NULL,
            CLSCTX_INPROC_SERVER,
            IID_IImagingFactory,
            (VOID**) &imgfact);

    if (!CHECKHR(hr))
        exit(-1);

    //
    // Create the main application window
    //

    CreateMainWindow();

    //
    // Create a test image
    //

    if (argc != 0)
        OpenImageFile(*argv);
    
    if (!curimage)
        exit(-1);

    DoSizeWindowToFit(hwndMain);
    ShowWindow(hwndMain, SW_SHOW);

    //
    // Main message loop
    //

    MSG msg;

    while (GetMessage(&msg, NULL, 0, 0))
    {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }

    imgfact->Release();

    CoUninitialize();
    return (INT)(msg.wParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\autotext\afxres.h ===
//
//      Copyright(c) 1996 - 1999. Microsoft Corporation.
//

// afxres.h

#include <windows.h>
#undef _WIN32
#ifdef IDC_STATIC
#undef IDC_STATIC
#endif
#define IDC_STATIC              (-1)     // all static controls
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\autotext\autotext.cpp ===
/////   autoText.cpp - gdiplus text test harness
//
//


#include "precomp.hpp"

#define GLOBALS_HERE 1
#include "global.h"

#include "../gpinit.inc"

///     ProcessCommandLine
//
//      -d  - Do display regression tests then exit
//      -p  - Do print regeression tests then exit
//
//      ProcessCommandLine returns FALSE if the program should not continue.


void SkipBlanks(const char **p)
{
    while (**p  &&  **p == ' ')
    {
        (*p)++;
    }
}

void SkipNonBlank(const char **p)
{
    while (**p  &&  **p != ' ')
    {
        (*p)++;
    }
}

void ProcessParameter(const char **p)
{
    if (    **p == '-'
        ||  **p == '/')
    {
        (*p)++;

        while (**p  &&  **p != ' ')
        {
            switch (**p)
            {
            case 'd':
                G.AutoDisplayRegress = TRUE;
                break;

            case 'p':
                G.AutoPrintRegress = TRUE;
                break;

            case 'h':
            default:
                G.Help = TRUE;
                break;
            }

            (*p)++;
        }

    }
    else
    {
        SkipNonBlank(p);
        G.Help = TRUE;
    }
}

BOOL ProcessCommandLine(const char *command)
{
    const char *p = command;

    SkipBlanks(&p);

    while (*p)
    {
        ProcessParameter(&p);
        SkipBlanks(&p);
    }

    if (G.Help)
    {
        MessageBoxA(
            NULL,
            "-d  - Regress display and exit\n\
-p  - Regress printing and exit\n\
-h  - Help",
            "autoText - text regression tests",
            MB_OK
        );

        return FALSE;
    }

    if (G.AutoDisplayRegress)
    {
        G.RunAllTests = TRUE;
    }
    return TRUE;
}





////    WinMain - Application entry point and dispatch loop
//
//


int APIENTRY WinMain(
    HINSTANCE   hInst,
    HINSTANCE   hPrevInstance,
    char       *pCmdLine,
    int         nCmdShow) {

    MSG         msg;
    HACCEL      hAccelTable;
    RECT        rc;
    RECT        rcMain;


    if (!gGdiplusInitHelper.IsValid())
    {
        return 0;
    }
   
   G.Instance = hInst;  // Global hInstance

   G.PSLevel2 = TRUE;

   G.ghPrinter = 0;
   
    if (!ProcessCommandLine(pCmdLine))
    {
        return 1;
    }


    GetInstalledFamilies();


    // Create main text window

    G.Window = CreateTextWindow();


    ShowWindow(G.Window, SW_SHOWNORMAL);
    UpdateWindow(G.Window);


    // Main message loop

    if (G.Unicode)
    {
        hAccelTable = LoadAcceleratorsW(G.Instance, APPNAMEW);

        while (GetMessageW(&msg, (HWND) NULL, 0, 0) > 0)
        {
            if (!TranslateAcceleratorA(G.Window, hAccelTable, &msg))
            {
                TranslateMessage(&msg);
                DispatchMessageA(&msg);
            }
        }
    }
    else
    {
        hAccelTable = LoadAcceleratorsA(G.Instance, APPNAMEA);

        while (GetMessageA(&msg, (HWND) NULL, 0, 0) > 0)
        {
            if (!TranslateAcceleratorA(G.Window, hAccelTable, &msg))
            {
                TranslateMessage(&msg);
                DispatchMessageA(&msg);
            }
        }
    }


    ReleaseInstalledFamilies();

    return (int)msg.wParam;


    UNREFERENCED_PARAMETER(hPrevInstance);
    UNREFERENCED_PARAMETER(pCmdLine);
    UNREFERENCED_PARAMETER(nCmdShow);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\autotext\brush.cpp ===
////    brush.cpp - brush type tests
//
//


#include "precomp.hpp"
#include "global.h"
#include "gdiplus.h"




/////   Brush tests
//
//      Test combinations of foreground background and rotation that
//      affect rendering codepaths.


INT BrushTest::GetPageCount()
{
    return 5;
}




void BrushTest::GetPageTitle(INT pageNumber, WCHAR *title)
{
    title[0] = 0;

    wcscat(title, L"AutoText brush test, page settings: ");

    switch (pageNumber)
    {
    case 0: wcscat(title, L"1bpp Grid fit.");                 break;
    case 1: wcscat(title, L"1bpp.");                          break;
    case 2: wcscat(title, L"Anti alias grid fit.");           break;
    case 3: wcscat(title, L"Anti alias.");                    break;
    case 4: wcscat(title, L"ClearType compatible grid fit."); break;
    }
}


///     DrawPage - draw one page of the test
//
//

void BrushTest::DrawPage(
    IN Graphics *graphics,
    IN INT       pageNumber,
    IN REAL      pageWidth,
    IN REAL      pageHeight
)
{
    PageLayout pageLayout(pageWidth, pageHeight, 10, 10);

    SolidBrush solidBlack (Color(0x00, 0x00, 0x00));
    SolidBrush solidDark  (Color(0x80, 0x80, 0x80));
    SolidBrush solidLight (Color(0xc0, 0xc0, 0xc0));
    SolidBrush solidWhite (Color(0xf0, 0xf0, 0xf0));
    SolidBrush lucentBlack(Color(0x80, 0x00, 0x00, 0x00));
    SolidBrush lucentDark (Color(0x80, 0x80, 0x80, 0x80));
    SolidBrush lucentLight(Color(0x80, 0xc0, 0xc0, 0xc0));
    SolidBrush lucentWhite(Color(0x80, 0xf0, 0xf0, 0xf0));

    Pen blackPen(&solidBlack, 1.0);

    Font titleFont(
        &FontFamily(L"Microsoft Sans Serif"),
        9,
        0,
        UnitPoint
    );


    // Set page rendering hint

    switch (pageNumber)
    {
    case 0: graphics->SetTextRenderingHint(TextRenderingHintSingleBitPerPixelGridFit); break;
    case 1: graphics->SetTextRenderingHint(TextRenderingHintSingleBitPerPixel);        break;
    case 2: graphics->SetTextRenderingHint(TextRenderingHintAntiAliasGridFit);         break;
    case 3: graphics->SetTextRenderingHint(TextRenderingHintAntiAlias);                break;
    case 4: graphics->SetTextRenderingHint(TextRenderingHintClearTypeGridFit);         break;
    }


    // Page title

    WCHAR title[200];
    RectF titleRect;
    StringFormat titleFormat(StringFormat::GenericDefault());
    titleFormat.SetAlignment(StringAlignmentCenter);
    titleFormat.SetLineAlignment(StringAlignmentCenter);

    pageLayout.GetFooterRect(&titleRect);

    Font pageTitleFont(L"Microsoft Sans Serif", 12, FontStyleBold);

    GetPageTitle(pageNumber, title);
    graphics->DrawString(
        title,
        -1,
        &pageTitleFont,
        titleRect,
        &titleFormat,
        &solidBlack
    );

    // Column titles

    for (INT column=0; column<10; column++)
    {
        // Row title

        title[0] = 0;
        switch (column)
        {
        case 0: wcscat(title, L"solid black foregrnd");  break;
        case 1: wcscat(title, L"solid dark foregrnd");   break;
        case 2: wcscat(title, L"solid light foregrnd");  break;
        case 3: wcscat(title, L"solid white foregrnd");  break;
        case 4: wcscat(title, L"solid grdnt foregrnd");  break;
        case 5: wcscat(title, L"lucent black foregrnd"); break;
        case 6: wcscat(title, L"lucent dark foregrnd");  break;
        case 7: wcscat(title, L"lucent light foregrnd"); break;
        case 8: wcscat(title, L"lucent white foregrnd"); break;
        case 9: wcscat(title, L"lucent grdnt foregrnd"); break;
        }

        pageLayout.GetColumnTitleRect(column, &titleRect);
        graphics->DrawString(
            title,
            -1,
            &titleFont,
            titleRect,
            &titleFormat,
            &solidBlack
        );
    }

    Font font(
        &FontFamily(L"Times New Roman"),
        9,
        0,
        UnitPoint
    );



    // The test rows

    for (INT row=0; row<10; row++)
    {
        Brush *background;

        switch (row)
        {
        // Solid brushes

        case 0: background = &solidBlack; break;
        case 1: background = &solidDark;  break;
        case 2: background = &solidLight; break;
        case 3: background = &solidWhite; break;

        // 50% alpha brushes

        case 5: background = &lucentBlack; break;
        case 6: background = &lucentDark;  break;
        case 7: background = &lucentLight; break;
        case 8: background = &lucentWhite; break;

        // Linear gradient brushes created separately for each item
        }


        // Row title

        title[0] = 0;
        switch (row)
        {
        case 0: wcscat(title, L"solid black backgrnd");  break;
        case 1: wcscat(title, L"solid dark backgrnd");   break;
        case 2: wcscat(title, L"solid light backgrnd");  break;
        case 3: wcscat(title, L"solid white backgrnd");  break;
        case 4: wcscat(title, L"solid grdnt backgrnd");  break;
        case 5: wcscat(title, L"lucent black backgrnd"); break;
        case 6: wcscat(title, L"lucent dark backgrnd");  break;
        case 7: wcscat(title, L"lucent light backgrnd"); break;
        case 8: wcscat(title, L"lucent white backgrnd"); break;
        case 9: wcscat(title, L"lucent grdnt backgrnd"); break;
        }

        pageLayout.GetRowTitleRect(row, &titleRect);
        graphics->DrawString(
            title,
            -1,
            &titleFont,
            titleRect,
            &titleFormat,
            &solidBlack
        );

        for (INT column=0; column<10; column++)
        {
            RectF itemRect;
            pageLayout.GetItemRect(column, row, &itemRect);

            switch (row)
            {
            // Linear gradient brushes

            case 4:
                background = new LinearGradientBrush(
                    itemRect,
                    Color(0x00, 0x00, 0x00),
                    Color(0xff, 0xff, 0xff),
                    LinearGradientModeVertical
                );
                break;

            case 9:
                background = new LinearGradientBrush(
                    itemRect,
                    Color(0x80, 0x00, 0x00, 0x00),
                    Color(0x80, 0xff, 0xff, 0xff),
                    LinearGradientModeVertical
                );
                break;
            }


            Brush *foreground;

            switch (column)
            {
            // Solid brushes

            case 0: foreground = &solidBlack; break;
            case 1: foreground = &solidDark;  break;
            case 2: foreground = &solidLight; break;
            case 3: foreground = &solidWhite; break;

            // 50% alpha brushes

            case 5: foreground = &lucentBlack; break;
            case 6: foreground = &lucentDark;  break;
            case 7: foreground = &lucentLight; break;
            case 8: foreground = &lucentWhite; break;

            // Linear gradient brushes

            case 4:
                foreground = new LinearGradientBrush(
                    itemRect,
                    Color(0x00, 0x00, 0x00),
                    Color(0xff, 0xff, 0xff),
                    LinearGradientModeHorizontal
                );
                break;

            case 9:
                foreground = new LinearGradientBrush(
                    itemRect,
                    Color(0x80, 0x00, 0x00, 0x00),
                    Color(0x80, 0xff, 0xff, 0xff),
                    LinearGradientModeHorizontal
                );
                break;
            }


            graphics->FillRectangle(background, itemRect);
            graphics->DrawRectangle(&blackPen, itemRect);

            graphics->DrawString(
                L"There was an Old Man of the Coast\n\
Who placidly sat on a post;\n\
But when it was cold,\n\
He relinquished his hold,\n\
And called for some hot buttered toast.\n",
                -1,
                &font,
                itemRect,
                NULL,
                foreground
            );

            switch (row)
            {
            case 4: case 9: delete background;
            }
            switch (column)
            {
            case 4: case 9: delete foreground;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\autotext\precomp.hpp ===
////    precomp.hxx
//


// Private StringFormatFlags

const int StringFormatFlagsPrivateNoGDI                = 0x80000000;
const int StringFormatFlagsPrivateAlwaysUseFullImager  = 0x40000000;




#include <windows.h>
#include <objbase.h>
#include <math.h>             // sin & cos

//
// Where is IStream included from?
//

#define IStream int

#include <gdiplus.h>

using namespace Gdiplus;

#include <stdlib.h>
#include <malloc.h>
#include <memory.h>
#include <string.h>

#include "resource.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\autotext\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by autoText.rc
//
#define IDM_EXIT                        40001
#define ID_FILE_PRINTALLTESTS           40002
#define ID_FIRST_FAMILY                 40003
#define ID_FIRST_BRUSH                  40004
#define ID_FILE_PRINT_CURRENT_TEST      40019
#define ID_NEXT_TEST                    40020
#define ID_PREV_TEST                    40021
#define ID_FIRST_FORMAT                 40022
#define ID_FILE_REGRESS                 40023
#define ID_FILE_PRINT_FIRST_PAGE        40024
#define ID_PS_LEVEL1                    40025
#define ID_PS_LEVEL2                    40026

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40027
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           10001
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\autotext\window.cpp ===
////    window.cpp
//
//      Maintains the text display panel



#include "precomp.hpp"
#include "global.h"
#include "winspool.h"
#include <Tchar.h>
#include "commdlg.h"


INT GetTotalPageCount()
{
    return   FamilyTest().GetPageCount()
           + FormatTest().GetPageCount()
           + BrushTest().GetPageCount();
}



void DrawTestPage(Graphics *graphics, INT page, REAL width, REAL height)
{
    if (page < FamilyTest().GetPageCount())
    {
        FamilyTest().DrawPage(
            graphics,
            page,
            width,
            height
        );
    }
    else
    {
        page -= FamilyTest().GetPageCount();

        if (page < BrushTest().GetPageCount())
        {
            BrushTest().DrawPage(
                graphics,
                page,
                width,
                height
            );
        }
        else
        {
            page -= BrushTest().GetPageCount();

            if (page < FormatTest().GetPageCount())
            {
                FormatTest().DrawPage(
                    graphics,
                    page,
                    width,
                    height
                );
            }
            else
            {
                page -= FormatTest().GetPageCount();
            }
        }
    }
}



////    Print tests
//
//


HDC StartPrintDoc(DWORD flags)
{
    PRINTDLG printDialog;

    memset(&printDialog, 0, sizeof(printDialog));

    printDialog.lStructSize = sizeof(printDialog);
    printDialog.Flags = flags | PD_RETURNDC | PD_NOPAGENUMS | PD_NOSELECTION ;

    if (PrintDlg(&printDialog))
    {
        HDC dc = printDialog.hDC;

        DEVMODE * dv;

        dv = (DEVMODE *) GlobalLock(printDialog.hDevMode);

        if (G.PSLevel2)
            OpenPrinter((LPSTR) &dv->dmDeviceName[0], &G.ghPrinter, NULL);
        
        if (dc != NULL)
        {
            DOCINFO documentInfo;
            documentInfo.cbSize       = sizeof(documentInfo);
            documentInfo.lpszDocName  = _T("autoText gdiPlus test");
            documentInfo.lpszOutput   = NULL;
            documentInfo.lpszDatatype = NULL;
            documentInfo.fwType       = 0;

            if (StartDoc(dc, &documentInfo))
            {
                return dc;
            }
            else
            {
                DeleteDC(dc);
            }
        }
    }

    return FALSE;
}


void PrintAllTests()
{
    HDC dc = StartPrintDoc(0);

    if (dc)
    {
        INT page      = 0;
        INT pageCount = GetTotalPageCount();

        while (page < pageCount)
        {
            if (StartPage(dc) > 0)
            {
                HANDLE h = 0;
                
                if (G.PSLevel2)
                    h = G.ghPrinter;

                Graphics graphics(dc, h);
                    
                graphics.SetPageUnit(UnitPixel);
                DrawTestPage(
                    &graphics,
                    page,
                    REAL(GetDeviceCaps(dc, HORZRES)),
                    REAL(GetDeviceCaps(dc, VERTRES))
                );
                EndPage(dc);
            }

            page++;
        }

        EndDoc(dc);
        DeleteDC(dc);

        if (G.PSLevel2)
        {
            ClosePrinter(G.ghPrinter);
            G.ghPrinter = 0;
        }
    }

    
}




void PrintTest(INT pageNumber)
{
    HDC dc = StartPrintDoc(0);

    if (dc)
    {
        if (StartPage(dc) > 0)
        {
            HANDLE h = 0;
                
            if (G.PSLevel2)
                h = G.ghPrinter;

            Graphics graphics(dc, h);
                
            graphics.SetPageUnit(UnitPixel);
            DrawTestPage(
                &graphics,
                pageNumber,
                REAL(GetDeviceCaps(dc, HORZRES)),
                REAL(GetDeviceCaps(dc, VERTRES))
            );
            EndPage(dc);
        }
        EndDoc(dc);
        DeleteDC(dc);

        if (G.PSLevel2)
        {
            ClosePrinter(G.ghPrinter);
            G.ghPrinter = 0;
        }
    }
}



void PrintFirstPages(DWORD flags)
{
    HDC dc = StartPrintDoc(flags);

    if (dc)
    {
        HANDLE h = 0;
                
        if (G.PSLevel2)
            h = G.ghPrinter;

        Graphics graphics(dc, h);
            
        graphics.SetPageUnit(UnitPixel);

        if (StartPage(dc) > 0)
        {
            DrawTestPage(
                &graphics,
                0,
                REAL(GetDeviceCaps(dc, HORZRES)),
                REAL(GetDeviceCaps(dc, VERTRES))
            );
            EndPage(dc);
        }

        if (StartPage(dc) > 0)
        {
            DrawTestPage(
                &graphics,
                FamilyTest().GetPageCount(),
                REAL(GetDeviceCaps(dc, HORZRES)),
                REAL(GetDeviceCaps(dc, VERTRES))
            );
            EndPage(dc);
        }

        if (StartPage(dc) > 0)
        {
            DrawTestPage(
                &graphics,
                  FamilyTest().GetPageCount()
                + FormatTest().GetPageCount(),
                REAL(GetDeviceCaps(dc, HORZRES)),
                REAL(GetDeviceCaps(dc, VERTRES))
            );
            EndPage(dc);
        }

        EndDoc(dc);
        DeleteDC(dc);

        if (G.PSLevel2)
        {
            ClosePrinter(G.ghPrinter);
            G.ghPrinter = 0;
        }
    }
}



////    Paint - redraw part or all of client area
//
//


void PaintWindow(HWND hWnd) {

    PAINTSTRUCT  ps;
    HDC          hdc;

    hdc = BeginPaint(hWnd, &ps);

    Graphics graphics(hdc);

    RectF clip(
        REAL(ps.rcPaint.left),
        REAL(ps.rcPaint.top),
        REAL(ps.rcPaint.right-ps.rcPaint.left),
        REAL(ps.rcPaint.bottom-ps.rcPaint.top)
    );

    if (ps.fErase)
    {
        graphics.FillRectangle(
            &SolidBrush(Color(0xff, 0xff, 0xff)),
            clip
        );
    }

    RECT rcWnd;
    GetClientRect(hWnd, &rcWnd);

    if (G.RunAllTests)
    {
        for (INT i=0; i<GetTotalPageCount(); i++)
        {
            G.TestPage = i;
            DrawTestPage(
                &graphics,
                G.TestPage,
                REAL(rcWnd.right - rcWnd.left),
                REAL(rcWnd.bottom - rcWnd.top)
            );

            graphics.FillRectangle(
                &SolidBrush(Color(0xff, 0xff, 0xff)),
                RectF(
                    REAL(rcWnd.left),
                    REAL(rcWnd.top),
                    REAL(rcWnd.right-ps.rcPaint.left),
                    REAL(rcWnd.bottom-ps.rcPaint.top)
                )
            );
        }
        G.RunAllTests = FALSE;
    }
    else
    {
        DrawTestPage(
            &graphics,
            G.TestPage,
            REAL(rcWnd.right - rcWnd.left),
            REAL(rcWnd.bottom - rcWnd.top)
        );
    }

    EndPaint(hWnd, &ps);



    if (G.AutoPrintRegress)
    {
        PrintFirstPages(PD_RETURNDEFAULT);
    }



    if (    G.AutoDisplayRegress
        ||  G.AutoPrintRegress)
    {
        SendMessage(hWnd, WM_CLOSE, 0, 0);
    }
}




////    TextWndProc - Main window message handler and dispatcher
//
//


LRESULT CALLBACK TextWndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam) {

    HDC hdc;

    switch (message) {

    case WM_ERASEBKGND:
        return 0;       // Leave Paint to erase the background


    case WM_PAINT:
        PaintWindow(hWnd);
        break;


    case WM_DESTROY:
        PostQuitMessage(0);
        return 0;


    case WM_COMMAND:
        //INT  command = LOWORD(wParam);
        //INT  notify  = HIWORD(wParam);
        //HWND item    = HWND(lParam);
        switch (LOWORD(wParam))
        {
        case ID_NEXT_TEST:
            G.TestPage++;
            if (G.TestPage >= GetTotalPageCount())
            {
                G.TestPage = 0;
            }
            InvalidateRect(hWnd, NULL, TRUE);
            break;

        case ID_PREV_TEST:
            G.TestPage--;
            if (G.TestPage < 0)
            {
                G.TestPage = GetTotalPageCount()-1;
            }
            InvalidateRect(hWnd, NULL, TRUE);
            break;

        case ID_PS_LEVEL1:
            G.PSLevel2 = FALSE;
            break;

        case ID_PS_LEVEL2:
            G.PSLevel2 = TRUE;
            break;
            
        case ID_FIRST_FAMILY:
            G.TestPage = 0;
            InvalidateRect(hWnd, NULL, TRUE);
            break;

        case ID_FIRST_BRUSH:
            G.TestPage = FamilyTest().GetPageCount();
            InvalidateRect(hWnd, NULL, TRUE);
            break;

        case ID_FIRST_FORMAT:
            G.TestPage = FamilyTest().GetPageCount() + BrushTest().GetPageCount();
            InvalidateRect(hWnd, NULL, TRUE);
            break;

        case ID_FILE_REGRESS:
            G.TestPage = 0;
            G.RunAllTests = TRUE;
            InvalidateRect(hWnd, NULL, TRUE);
            break;

        case ID_FILE_PRINT_CURRENT_TEST:
            PrintTest(G.TestPage);
            break;

        case ID_FILE_PRINT_FIRST_PAGE:
            PrintFirstPages(0);
            break;

        case ID_FILE_PRINTALLTESTS:
            PrintAllTests();
            break;

        case IDM_EXIT:
            SendMessage(hWnd, WM_CLOSE, 0, 0);
            break;
        }

        // Validate current test page number

        if (G.TestPage < 0)
        {
            G.TestPage = 0;
        }
        else
        {
            if (G.TestPage >= GetTotalPageCount())
            {
                G.TestPage = GetTotalPageCount()-1;
            }
        }
        return 0;


    default:
        if (G.Unicode) {
            return DefWindowProcW(hWnd, message, wParam, lParam);
        } else {
            return DefWindowProcA(hWnd, message, wParam, lParam);
        }
    }

    return 0;
}






////    CreateTextWindow - create window class and window
//
//      Attempts to use a Unicode window, if this fails uses an ANSI
//      window.
//
//      For example the Unicode window will succeed on Windows NT and
//      Windows CE, but fail on Windows 9x.


HWND CreateTextWindow() {

    WNDCLASSA  wcA;
    WNDCLASSW  wcW;
    HWND       hWnd;

    // Try registering as a Unicode window

    wcW.style         = CS_HREDRAW | CS_VREDRAW;
    wcW.lpfnWndProc   = TextWndProc;
    wcW.cbClsExtra    = 0;
    wcW.cbWndExtra    = 0;
    wcW.hInstance     = G.Instance;
    wcW.hIcon         = LoadIconW(G.Instance, APPNAMEW);
    wcW.hCursor       = LoadCursorW(NULL, (WCHAR*)IDC_ARROW);
    wcW.hbrBackground = (HBRUSH)(COLOR_WINDOW+1);
    wcW.lpszMenuName  = L"MAINMENU";
    wcW.lpszClassName = APPNAMEW;

    if (RegisterClassW(&wcW)) {

        // Use a Unicode window

        G.Unicode = TRUE;

        hWnd  = CreateWindowW(
            APPNAMEW, APPTITLEW,
            WS_OVERLAPPEDWINDOW,
            CW_USEDEFAULT, 0,
            CW_USEDEFAULT, 0,
            NULL, NULL,
            G.Instance,
            NULL);


        return hWnd;

    } else {

        // Must use an ANSI window.

        wcA.style         = CS_HREDRAW | CS_VREDRAW;
        wcA.lpfnWndProc   = TextWndProc;
        wcA.cbClsExtra    = 0;
        wcA.cbWndExtra    = 0;
        wcA.hInstance     = G.Instance;
        wcA.hIcon         = LoadIconA(G.Instance, APPNAMEA);
        wcA.hCursor       = LoadCursor(NULL, IDC_ARROW);
        wcA.hbrBackground = (HBRUSH)(COLOR_WINDOW+1);
        wcA.lpszMenuName  = "MAINMENU";
        wcA.lpszClassName = APPNAMEA;

        if (!RegisterClassA(&wcA)) {
            return NULL;
        }

        G.Unicode = FALSE;

        hWnd  = CreateWindowA(
            APPNAMEA, APPTITLEA,
            WS_OVERLAPPEDWINDOW,
            CW_USEDEFAULT, 0,
            CW_USEDEFAULT, 0,
            NULL, NULL,
            G.Instance,
            NULL);
    };


    return hWnd;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\autotext\family.cpp ===
////    family.cpp - String format tests
//
//


#include "precomp.hpp"
#include "global.h"
#include "gdiplus.h"




/////   Family tests
//
//      Test combinations of style with each family
//
//      2 rows for each family using all style combinations
//
//      6 families per page


void GetInstalledFamilies()
{
    InstalledFontCollection installedFonts;

    G.InstalledFamilyCount = installedFonts.GetFamilyCount();

    G.InstalledFamilies = new FontFamily[G.InstalledFamilyCount];
    installedFonts.GetFamilies(
        G.InstalledFamilyCount,
        G.InstalledFamilies,
        &G.InstalledFamilyCount
    );
}

void ReleaseInstalledFamilies()
{
    G.InstalledFamilyCount = 0;
    delete [] G.InstalledFamilies;
}


INT FamilyTest::GetPageCount()
{
    return (G.InstalledFamilyCount + 5) / 6;
}


void FamilyTest::GetPageTitle(INT pageNumber, WCHAR *title)
{
    title[0] = 0;
    wcscat(title, L"AutoText family test.");
}


Font *GetItemFont(INT page, INT row, INT column)
{
    INT familyIndex = page*6 + row/2;

    if (familyIndex < G.InstalledFamilyCount)
    {
        return new Font(
            G.InstalledFamilies + familyIndex,
            9,
            FontStyle(((row & 1) << 4) + column),
            UnitPoint
        );
    }
    else
    {
        return NULL;
    }
}




///     DrawPage - draw one page of the test
//
//

void FamilyTest::DrawPage(
    IN Graphics *graphics,
    IN INT       page,
    IN REAL      pageWidth,
    IN REAL      pageHeight
)
{
    PageLayout pageLayout(pageWidth, pageHeight, 8, 12);

    SolidBrush blackBrush(Color(0, 0, 0));
    Pen        blackPen(&blackBrush, 1.0);


    // Display title at bottom of page

    StringFormat titleFormat(StringFormat::GenericDefault());
    titleFormat.SetAlignment(StringAlignmentCenter);
    titleFormat.SetLineAlignment(StringAlignmentCenter);

    RectF titleRect;
    pageLayout.GetFooterRect(&titleRect);

    Font pageTitleFont(L"Microsoft Sans Serif", 12, FontStyleBold);

    WCHAR title[200];

    GetPageTitle(page, title);

    graphics->DrawString(
        title,
        -1,
        &pageTitleFont,
        titleRect,
        &titleFormat,
        &blackBrush
    );


    // Display row titles

    Font titleFont(
        &FontFamily(L"Microsoft Sans Serif"),
        9,
        0,
        UnitPoint
    );

    for (INT i=0; i<12; i++)
    {
        pageLayout.GetRowTitleRect(i, &titleRect);

        Font *rowFont = GetItemFont(page, i, 3);    // bold/italic available if any are!
        if (rowFont)
        {
            FontFamily rowFamily;
            rowFont->GetFamily(&rowFamily);
            delete rowFont;

            rowFamily.GetFamilyName(title);

            graphics->DrawString(
                title,
                -1,
                &titleFont,
                titleRect,
                &titleFormat,
                &blackBrush
            );
        }
    }


    // Display column titles


    for (INT i=0; i<8; i++)
    {
        pageLayout.GetColumnTitleRect(i, &titleRect);

        title[0] = 0;

        if (i==0)
        {
            wcscat(title, L"regular");
        }
        else
        {
            if (i & 1)
            {
                wcscat(title, L"bold ");
            }

            if (i & 2)
            {
                wcscat(title, L"italic ");
            }

            if (i & 4)
            {
                wcscat(title, L"underline ");
            }
        }

        graphics->DrawString(
            title,
            -1,
            &titleFont,
            titleRect,
            &titleFormat,
            &blackBrush
        );
    }


    // Prepare common string format for this page

    StringFormat stringFormat(StringFormat::GenericDefault());


    // The tests themselves

    for (INT row=0; row<12; row++)
    {
        for (INT column=0; column<8; column++)
        {
            Font *itemFont = GetItemFont(page, row, column);

            if (itemFont)
            {
                RectF itemRect;
                pageLayout.GetItemRect(column, row, &itemRect);
                graphics->DrawRectangle(&blackPen, itemRect);


                graphics->DrawString(
                    L"There was an Old Man of the Coast\n\
Who placidly sat on a post;\n\
But when it was cold,\n\
He relinquished his hold,\n\
And called for some hot buttered toast.\n",
                    -1,
                    itemFont,
                    itemRect,
                    &stringFormat,
                    &blackBrush
                );

                delete itemFont;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\autotext\format.cpp ===
////    format.cpp - String format tests
//
//


#include "precomp.hpp"
#include "global.h"
#include "gdiplus.h"




/////   Formatting tests
//
//      Test combinations of StringFormat that affect layout




INT FormatTest::GetPageCount()
{
    return 6;
}


void FormatTest::GetPageTitle(INT pageNumber, WCHAR *title)
{
    title[0] = 0;

    wcscat(title, L"AutoText format test. Page settings: ");

    if (pageNumber & 1)
    {
        wcscat(title, L"Right-to-Left, ");
    }
    else
    {
        wcscat(title, L"Left-To-Right, ");
    }

    switch (pageNumber / 2)
    {
    case 0:
        wcscat(title, L"near");
        break;

    case 1:
        wcscat(title, L"center");
        break;

    case 2:
        wcscat(title, L"far");
        break;

    }
}



///     DrawPage - draw one page of the test
//
//

void FormatTest::DrawPage(
    IN Graphics *graphics,
    IN INT       pageNumber,
    IN REAL      pageWidth,
    IN REAL      pageHeight
)
{
    PageLayout pageLayout(pageWidth, pageHeight, 8, 12);

    SolidBrush blackBrush(Color(0, 0, 0));
    Pen        blackPen(&blackBrush, 1.0);


    // Display title at bottom of page

    StringFormat titleFormat(StringFormat::GenericDefault());
    titleFormat.SetAlignment(StringAlignmentCenter);
    titleFormat.SetLineAlignment(StringAlignmentCenter);

    RectF titleRect;
    pageLayout.GetFooterRect(&titleRect);

    Font pageTitleFont(L"Microsoft Sans Serif", 12, FontStyleBold);

    WCHAR title[200];

    GetPageTitle(pageNumber, title);

    graphics->DrawString(
        title,
        -1,
        &pageTitleFont,
        titleRect,
        &titleFormat,
        &blackBrush
    );


    // Display row titles

    Font titleFont(
        &FontFamily(L"Microsoft Sans Serif"),
        9,
        0,
        UnitPoint
    );

    for (INT i=0; i<12; i++)
    {
        pageLayout.GetRowTitleRect(i, &titleRect);

        title[0] = 0;

        if (i < 6)
        {
            wcscat(title, L"horz,");
        }
        else
        {
            wcscat(title, L"vert,");
        }

        switch (i % 6)
        {
        case 0: wcscat(title, L"trim- none "); break;
        case 1: wcscat(title, L"trim- char "); break;
        case 2: wcscat(title, L"trim- word "); break;
        case 3: wcscat(title, L"trim- ch... "); break;
        case 4: wcscat(title, L"trim- wd... "); break;
        case 5: wcscat(title, L"trim- uri... "); break;
        }

        graphics->DrawString(
            title,
            -1,
            &titleFont,
            titleRect,
            &titleFormat,
            &blackBrush
        );
    }


    // Display column titles


    for (INT i=0; i<8; i++)
    {
        pageLayout.GetColumnTitleRect(i, &titleRect);

        title[0] = 0;

        if (i & 1)
        {
            wcscat(title, L"LineLimit, ");
        }
        else
        {
            wcscat(title, L"NoLineLimit, ");
        }

        if (i & 2)
        {
            wcscat(title, L"NoWrap, ");
        }
        else
        {
            wcscat(title, L"Wrap, ");
        }

        if (i & 4)
        {
            wcscat(title, L"NoClip");
        }
        else
        {
            wcscat(title, L"Clip");
        }

        graphics->DrawString(
            title,
            -1,
            &titleFont,
            titleRect,
            &titleFormat,
            &blackBrush
        );
    }


    // Prepare common string format for this page

    StringFormat stringFormat(StringFormat::GenericDefault());

    INT pageFormatFlags = 0;

    if (pageNumber & 1)
    {
        pageFormatFlags |= StringFormatFlagsDirectionRightToLeft;
    }

    switch (pageNumber / 2)
    {
    case 0:
        stringFormat.SetAlignment(StringAlignmentNear);
        break;

    case 1:
        stringFormat.SetAlignment(StringAlignmentCenter);
        break;

    case 2:
        stringFormat.SetAlignment(StringAlignmentFar);
        break;
    }

    Font font(
        &FontFamily(L"Times New Roman"),
        9,
        0,
        UnitPoint
    );


    // The tests themselves

    INT testNumber = 0;
    while (testNumber < 96)
    {
        INT formatFlags = pageFormatFlags;


        if (testNumber & 1)
        {
            formatFlags |= StringFormatFlagsLineLimit;
        }

        if (testNumber & 2)
        {
            formatFlags |= StringFormatFlagsNoWrap;
        }

        if (testNumber & 4)
        {
            formatFlags |= StringFormatFlagsNoClip;
        }

        switch ((testNumber/8) % 6)
        {
        case 0: stringFormat.SetTrimming(StringTrimmingNone);              break;
        case 1: stringFormat.SetTrimming(StringTrimmingCharacter);         break;
        case 2: stringFormat.SetTrimming(StringTrimmingWord);              break;
        case 3: stringFormat.SetTrimming(StringTrimmingEllipsisCharacter); break;
        case 4: stringFormat.SetTrimming(StringTrimmingEllipsisWord);      break;
        case 5: stringFormat.SetTrimming(StringTrimmingEllipsisPath);      break;
        }

        if (testNumber >= 48)
        {
            formatFlags |= StringFormatFlagsDirectionVertical;
        }

        stringFormat.SetFormatFlags(formatFlags);

        RectF itemRect;
        pageLayout.GetItemRect(testNumber%8, testNumber/8, &itemRect);
        graphics->DrawRectangle(&blackPen, itemRect);

        RectF itemGutterRect;
        pageLayout.GetItemGutterRect(testNumber%8, testNumber/8, &itemGutterRect);
        graphics->SetClip(itemGutterRect);

        graphics->DrawString(
            L"There was an Old Man of the Coast\n\
Who placidly sat on a post;\n\
But when it was cold,\n\
He relinquished his hold,\n\
And called for some hot buttered toast.\n",
            -1,
            &font,
            itemRect,
            &stringFormat,
            &blackBrush
        );

        graphics->ResetClip();

        testNumber++;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\autotext\global.h ===
////    GLOBAL.H - Global variables for CSSAMP
//
//





////    Constants
//
//


#define APPNAMEA   "autoText"
#define APPTITLEA  "autoText - GdipPlus Text support (Text+) regression test"
#define APPNAMEW   L"autoText"
#define APPTITLEW  L"autoText - GdipPlus Text support (Text+) regression test"






////    Global variables
//
//


struct GlobalVariables
{
    HINSTANCE    Instance;
    HWND         Window;
    BOOL         Unicode;
    INT          TestPage;    // Selected with test menu
    BOOL         RunAllTests; // When set, cycles through all test pages
    FontFamily  *InstalledFamilies;
    INT          InstalledFamilyCount;

    // Parameter flags
    BOOL         Help;
    BOOL         AutoDisplayRegress;
    BOOL         AutoPrintRegress;
    HANDLE       ghPrinter;
    BOOL         PSLevel2;
};

extern HANDLE ghPrinter;

#ifdef GLOBALS_HERE

    GlobalVariables G = {0};

#else

    extern GlobalVariables G;

#endif


void GetInstalledFamilies();
void ReleaseInstalledFamilies();


class TextTest
{
public:
    virtual INT GetPageCount() = 0;
    virtual void GetPageTitle(INT i, WCHAR *title) = 0;
    virtual void DrawPage(
        IN Graphics *graphics,
        IN INT       pageNumber,
        IN REAL      pageWidth,
        IN REAL      pageHeight
    ) = 0;
};



class FormatTest: public TextTest
{
public:
    virtual INT GetPageCount();
    virtual void GetPageTitle(INT i, WCHAR *title);
    virtual void DrawPage(
        IN Graphics *graphics,
        IN INT       pageNumber,
        IN REAL      pageWidth,
        IN REAL      pageHeight
    );
};


class BrushTest: public TextTest
{
public:
    virtual INT GetPageCount();
    virtual void GetPageTitle(INT i, WCHAR *title);
    virtual void DrawPage(
        IN Graphics *graphics,
        IN INT       pageNumber,
        IN REAL      pageWidth,
        IN REAL      pageHeight
    );
};


class FamilyTest: public TextTest
{
public:
    virtual INT GetPageCount();
    virtual void GetPageTitle(INT i, WCHAR *title);
    virtual void DrawPage(
        IN Graphics *graphics,
        IN INT       pageNumber,
        IN REAL      pageWidth,
        IN REAL      pageHeight
    );
};








HWND CreateTextWindow();
void DrawFormatPage(
    IN Graphics *graphics,
    IN INT       pageNumber,
    IN REAL      pageWidth,
    IN REAL      pageHeight
);





/////   PageLayout - All the page coordinate calculations in one place
//
//      The PageLayout constructor takes page dimensions and required
//      layout.
//
//      Pagelayout functions return item and title rectangles.


class PageLayout
{
public:
    PageLayout(
        IN  REAL  pageWidth,
        IN  REAL  pageHeight,
        IN  INT   columnCount = 8,
        IN  INT   rowCount    = 12,
        IN  REAL  pageMargin  = -1,
        IN  REAL  gutter      = -1,
        IN  REAL  columnTitle = -1,
        IN  REAL  rowTitle    = -1,
        IN  REAL  footer      = -1
    ) :
    PageWidth    (pageWidth),
    PageHeight   (pageHeight),
    ColumnCount  (columnCount),
    RowCount     (rowCount),
    PageMargin   (pageMargin),
    Gutter       (gutter),
    ColumnTitle  (columnTitle),
    RowTitle     (rowTitle),
    Footer       (footer)
    {
        if (pageMargin < 0)   PageMargin = REAL(PageWidth  / 32);
        if (gutter < 0)       Gutter     = REAL(PageWidth  / 128);
        if (columnTitle < 0)  ColumnTitle= REAL(PageHeight / 20);
        if (rowTitle < 0)     RowTitle   = REAL(PageWidth  / 20);
        if (footer < 0)       Footer     = REAL(PageHeight / 20);
    }


    void GetItemSize(SizeF *item)
    {
        item->Width  = ((PageWidth  - (RowTitle           + 2*PageMargin + ColumnCount*Gutter)) / ColumnCount);
        item->Height = ((PageHeight - (ColumnTitle+Footer + 2*PageMargin + RowCount*Gutter))    / RowCount);
    }

    void GetItemRect(
        IN  INT    column,
        IN  INT    row,
        OUT RectF *item
    )
    {
        SizeF itemSize;
        GetItemSize(&itemSize);

        item->X = PageMargin + RowTitle    + Gutter + column * (itemSize.Width + Gutter);
        item->Y = PageMargin + ColumnTitle + Gutter + row * (itemSize.Height + Gutter);
        item->Width  = itemSize.Width;
        item->Height = itemSize.Height;
    }

    void GetItemGutterRect(
        IN  INT    column,
        IN  INT    row,
        OUT RectF *gutterRect
    )
    {
        RectF item;
        GetItemRect(column, row, &item);

        gutterRect->X      = item.X      - Gutter;
        gutterRect->Y      = item.Y      - Gutter;
        gutterRect->Width  = item.Width  + 2*Gutter;
        gutterRect->Height = item.Height + 2*Gutter;
    }

    void GetColumnTitleRect(
        IN  INT    column,
        OUT RectF *title
    )
    {
        RectF item;
        GetItemRect(column, 0, &item);

        title->X      = item.X;
        title->Y      = PageMargin;
        title->Width  = item.Width;
        title->Height = ColumnTitle;
    }


    void GetRowTitleRect(
        IN  INT    row,
        OUT RectF *title
    )
    {
        RectF item;
        GetItemRect(0, row, &item);

        title->X      = PageMargin;
        title->Y      = item.Y;
        title->Width  = RowTitle;
        title->Height = item.Height;
    }


    void GetFooterRect(
        OUT RectF *footer
    )
    {
        footer->X      = PageMargin;
        footer->Y      = PageHeight - (PageMargin + Footer);
        footer->Width  = PageWidth - 2 * PageMargin;
        footer->Height = Footer;
    }


private:
    REAL PageWidth;
    REAL PageHeight;
    INT  ColumnCount;
    INT  RowCount;
    REAL PageMargin;
    REAL Gutter;
    REAL ColumnTitle;
    REAL RowTitle;
    REAL Footer;
    REAL ItemWidth;
    REAL ItemHeight;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\comtest\combase.cpp ===
#include "precomp.hpp"
#include "combase.hpp"


//
// Create a new registry key and set its default value
//

BOOL
SetRegKeyValue(
    HKEY parentKey,
    const WCHAR* keyname,
    const WCHAR* value,
    HKEY* retkey
    )
{
    HKEY hkey;

    // Create or open the specified registry key

    if (RegCreateKeyEx(parentKey,
                       keyname,
                       0,
                       NULL,
                       REG_OPTION_NON_VOLATILE,
                       KEY_ALL_ACCESS,
                       NULL,
                       &hkey,
                       NULL) != ERROR_SUCCESS)
    {
        return FALSE;
    }

    // Set the default value for the new key

    INT size = sizeof(WCHAR) * (wcslen(value)+1);

    if (RegSetValueEx(hkey,
                      NULL,
                      0,
                      REG_SZ,
                      (const BYTE*) value,
                      size) != ERROR_SUCCESS)
    {
        RegCloseKey(hkey);
        return FALSE;
    }

    // Check if the caller is interested in the handle to the new key

    if (retkey != NULL)
        *retkey = hkey;
    else
        RegCloseKey(hkey);

    return TRUE;
}


//
// Delete a registry key and everything below it.
//

BOOL
DeleteRegKey(
    HKEY parentKey,
    const WCHAR* keyname
    )
{
    HKEY hkey;

    // Open the specified registry key

    if (RegOpenKeyEx(parentKey,
                     keyname,
                     0,
                     KEY_ALL_ACCESS,
                     &hkey) != ERROR_SUCCESS)
    {
        return FALSE;
    }

    // Enumerate all subkeys

    WCHAR childname[256];
    DWORD childlen = 256;
    FILETIME filetime;
    
    while (RegEnumKeyEx(hkey,
                        0,
                        childname,
                        &childlen,
                        NULL,
                        NULL,
                        NULL,
                        &filetime) == ERROR_SUCCESS)
    {
        // Recursively delete subkeys

        if (!DeleteRegKey(hkey, childname))
        {
            RegCloseKey(hkey);
            return FALSE;
        }

        childlen = 256;
    }

    // Close the specified key and then delete it

    RegCloseKey(hkey);
    return RegDeleteKey(parentKey, keyname) == ERROR_SUCCESS;
}


//
// Register or unregister a component depending on the value
// of registerIt parameter:
//  TRUE = register it
//  FALSE = unregister it
//

HRESULT
RegisterComponent(
    const ComponentRegData& regdata,
    BOOL registerIt
    )
{
    static const WCHAR CLSID_KEYSTR[] = L"CLSID";
    static const WCHAR INPROCSERVER32_KEYSTR[] = L"InProcServer32";
    static const WCHAR PROGID_KEYSTR[] = L"ProgID";
    static const WCHAR PROGIDNOVER_KEYSTR[] = L"VersionIndependentProgID";
    static const WCHAR CURVER_KEYSTR[] = L"CurVer";

    // compose class ID string

    WCHAR clsidStr[64];
    StringFromGUID2(*regdata.clsid, clsidStr, 64);

    // open registry key HKEY_CLASSES_ROOT\CLSID

    BOOL success;
    HKEY clsidKey;

    if (RegOpenKeyEx(HKEY_CLASSES_ROOT,
                     CLSID_KEYSTR,
                     0,
                     KEY_ALL_ACCESS,
                     &clsidKey) != ERROR_SUCCESS)
    {
        return E_FAIL;
    }

    if (registerIt)
    {
        // Register the component

        HKEY hkey;
        WCHAR fullpath[MAX_PATH];

        // HKEY_CLASSES_ROOT
        //  <Version-independent ProgID> - component friendly name
        //      CLSID - current version class ID
        //      CurVer - current version ProgID

        if (!GetModuleFileName(globalInstanceHandle, fullpath, MAX_PATH) ||
            !SetRegKeyValue(HKEY_CLASSES_ROOT,
                            regdata.progIDNoVer,
                            regdata.compName,
                            &hkey))
        {
            success = FALSE;
            goto regcompExit;
        }

        success = SetRegKeyValue(hkey, CLSID_KEYSTR, clsidStr, NULL)
               && SetRegKeyValue(hkey, CURVER_KEYSTR, regdata.progID, NULL);

        RegCloseKey(hkey);

        if (!success)
            goto regcompExit;

        // HKEY_CLASSES_ROOT
        //  <ProgID> - friendly component name
        //      CLSID - class ID

        if (!SetRegKeyValue(HKEY_CLASSES_ROOT,
                            regdata.progID,
                            regdata.compName,
                            &hkey))
        {
            success = FALSE;
            goto regcompExit;
        }

        success = SetRegKeyValue(hkey, CLSID_KEYSTR, clsidStr, NULL);
        RegCloseKey(hkey);

        if (!success)
            goto regcompExit;

        // HKEY_CLASSES_ROOT
        //  CLSID
        //      <class ID> - friendly component name
        //          InProcServer32 - full pathname to component DLL
        //          ProgID - current version ProgID
        //          VersionIndependentProgID - ...

        if (!SetRegKeyValue(clsidKey, clsidStr, regdata.compName, &hkey))
        {
            success = FALSE;
            goto regcompExit;
        }
        
        success = SetRegKeyValue(hkey, INPROCSERVER32_KEYSTR, fullpath, NULL)
               && SetRegKeyValue(hkey, PROGID_KEYSTR, regdata.progID, NULL)
               && SetRegKeyValue(hkey, PROGIDNOVER_KEYSTR, regdata.progIDNoVer, NULL);

        RegCloseKey(hkey);
    }
    else
    {
        // Unregister the component

        success = DeleteRegKey(clsidKey, clsidStr)
               && DeleteRegKey(HKEY_CLASSES_ROOT, regdata.progIDNoVer)
               && DeleteRegKey(HKEY_CLASSES_ROOT, regdata.progID);
    }

regcompExit:

    RegCloseKey(clsidKey);
    return success ? S_OK : E_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\comtest\combase.hpp ===
#ifndef _COMBASE_HPP
#define _COMBASE_HPP


//
// Macros for incrementing or decrementing global component count
//

extern HINSTANCE globalInstanceHandle;
extern LONG globalComponentCount;

#define IncrementGlobalComponentCount() \
        InterlockedIncrement(&globalComponentCount)
    
#define DecrementGlobalComponentCount() \
        InterlockedDecrement(&globalComponentCount)


//
// Template for implementing IUnknown interface
//
// NOTES:
// 1. We can only handle objects that one interface other than IUnknown.
// 2. We do not support aggregation.
//

template <class I> class IUnknownBase : public I
{
public:

    // Constructor: notice that when an object is first
    // created, its reference count is set to 1.

    IUnknownBase<I>()
    {
        refCount = 1;
    }

    // Query interface: note that we can only handle
    // objects that one interface other than IUnknown.

    STDMETHOD(QueryInterface)(REFIID riid, VOID** ppv)
    {
        if (riid == IID_IUnknown)
            *ppv = static_cast<IUnknown*>(this);
        else if (riid == __uuidof(I))
            *ppv = static_cast<I*>(this);
        else
        {
            *ppv = NULL;
            return E_NOINTERFACE;
        }

        reinterpret_cast<IUnknown*>(*ppv)->AddRef();
        return S_OK;
    }

    // Increment reference count

    STDMETHOD_(ULONG, AddRef)(VOID)
    {
        return InterlockedIncrement(&refCount);
    }

    // Decrement reference count

    STDMETHOD_(ULONG, Release)(VOID)
    {
        ULONG count = InterlockedDecrement(&refCount);

        if (count == 0)
            delete this;

        return count;
    }

private:

    LONG refCount;
};


//
// Template for implementing IClassFactory interface
//

template <class T> class IFactoryBase
    : public IUnknownBase<IClassFactory>
{
public:

    // NOTE: We don't count class factory objects in globalComponentCount.
    // This means that the existence of a running class factory is not
    // guaranteed to keep a server loaded in memory.

    // Create a new instance of the component

    STDMETHOD(CreateInstance)(IUnknown* outer, REFIID riid, VOID** ppv)
    {
        // We don't support aggregation

        if (outer != NULL)
            return CLASS_E_NOAGGREGATION;

        // Instantiate a new object

        T* obj = new T;

        if (obj == NULL)
            return E_OUTOFMEMORY;

        // Get the requested interface

        HRESULT hr = obj->QueryInterface(riid, ppv);
        obj->Release();

        return hr;
    }

    // Lock/unlock the component server DLL

    STDMETHOD(LockServer)(BOOL lock)
    {
        if (lock)
        {
            IncrementGlobalComponentCount();
        }
        else
        {
            DecrementGlobalComponentCount();
        }

        return S_OK;
    }
};


//
// Helper function for registering and unregistering a component
//

struct ComponentRegData
{
    const CLSID* clsid;
    const WCHAR* compName;
    const WCHAR* progID;
    const WCHAR* progIDNoVer;
};

HRESULT
RegisterComponent(
    const ComponentRegData& regdata,
    BOOL registerIt
    );

#endif // !_COMBASE_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\comtest\comtest.cpp ===
#include "precomp.hpp"

#include "comtest.h"
#include "ComBase.hpp"
#include "HelloWorld.hpp"

#include <initguid.h>
#include "comtest_i.c"

HINSTANCE globalInstanceHandle = NULL;
LONG globalComponentCount = 0;


// 
// DLL entrypoint
//

extern "C" BOOL WINAPI
DllMain(
    HINSTANCE hInstance,
    DWORD dwReason,
    VOID* lpReserved
    )
{
    switch (dwReason)
    {
    case DLL_PROCESS_ATTACH:

        DisableThreadLibraryCalls(hInstance);
        globalInstanceHandle = hInstance;
        break;

    case DLL_PROCESS_DETACH:

        break;
    }

    return TRUE;
}


//
// Determine whether the DLL can be safely unloaded
//

STDAPI
DllCanUnloadNow()
{
    return (globalComponentCount == 0) ? S_OK : S_FALSE;
}


//
// Return a class factory object
//

STDAPI
DllGetClassObject(
    REFCLSID rclsid,
    REFIID riid,
    VOID** ppv
    )
{
    if (rclsid != CLSID_HelloWorld)
        return CLASS_E_CLASSNOTAVAILABLE;

    CHelloWorldFactory* factory = new CHelloWorldFactory();

    if (factory == NULL)
        return E_OUTOFMEMORY;

    HRESULT hr = factory->QueryInterface(riid, ppv);
    factory->Release();

    return hr;
}


//
// Register our component
//

static const ComponentRegData compRegData =
{
    &CLSID_HelloWorld,
    L"Skeleton COM Component",
    L"comtest.HelloWorld.1",
    L"comtest.HelloWorld"
};

STDAPI
DllRegisterServer()
{
    return RegisterComponent(compRegData, TRUE);
}


//
// Unregister our component
//

STDAPI
DllUnregisterServer()
{
    return RegisterComponent(compRegData, FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\comtest\precomp.hpp ===
#include <stdio.h>
#include <stdlib.h>
#include <windows.h>
#include <objbase.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\comtest\helloworld.hpp ===
#ifndef _HELLOWORLD_HPP
#define _HELLOWORLD_HPP

//
// Class that implements our component
//

class CHelloWorld : public IUnknownBase<IHelloWorld>
{
public:

    CHelloWorld()
    {
        IncrementGlobalComponentCount();
    }

    ~CHelloWorld()
    {
        DecrementGlobalComponentCount();
    }

    STDMETHOD(Print)(BSTR message)
    {
        printf("%S\n", message);
        return S_OK;
    }
};

//
// The class factory for our component
//

typedef IFactoryBase<CHelloWorld> CHelloWorldFactory;

#endif // !_HELLOWORLD_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\comtest\comtest.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 5.02.0221 */
/* at Thu Feb 04 17:08:08 1999
 */
/* Compiler settings for comtest.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32 (32b run), ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __comtest_h__
#define __comtest_h__

/* Forward Declarations */ 

#ifndef __IHelloWorld_FWD_DEFINED__
#define __IHelloWorld_FWD_DEFINED__
typedef interface IHelloWorld IHelloWorld;
#endif 	/* __IHelloWorld_FWD_DEFINED__ */


#ifndef __HelloWorld_FWD_DEFINED__
#define __HelloWorld_FWD_DEFINED__

#ifdef __cplusplus
typedef class HelloWorld HelloWorld;
#else
typedef struct HelloWorld HelloWorld;
#endif /* __cplusplus */

#endif 	/* __HelloWorld_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

#ifndef __IHelloWorld_INTERFACE_DEFINED__
#define __IHelloWorld_INTERFACE_DEFINED__

/* interface IHelloWorld */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IHelloWorld;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("FEE1509A-BC8F-11D2-9D5E-0000F81EF32E")
    IHelloWorld : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Print( 
            /* [in] */ BSTR message) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IHelloWorldVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IHelloWorld __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IHelloWorld __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IHelloWorld __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Print )( 
            IHelloWorld __RPC_FAR * This,
            /* [in] */ BSTR message);
        
        END_INTERFACE
    } IHelloWorldVtbl;

    interface IHelloWorld
    {
        CONST_VTBL struct IHelloWorldVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHelloWorld_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IHelloWorld_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IHelloWorld_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IHelloWorld_Print(This,message)	\
    (This)->lpVtbl -> Print(This,message)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IHelloWorld_Print_Proxy( 
    IHelloWorld __RPC_FAR * This,
    /* [in] */ BSTR message);


void __RPC_STUB IHelloWorld_Print_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IHelloWorld_INTERFACE_DEFINED__ */



#ifndef __COMTESTLib_LIBRARY_DEFINED__
#define __COMTESTLib_LIBRARY_DEFINED__

/* library COMTESTLib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_COMTESTLib;

EXTERN_C const CLSID CLSID_HelloWorld;

#ifdef __cplusplus

class DECLSPEC_UUID("0B7E1310-BC90-11D2-9D5E-0000F81EF32E")
HelloWorld;
#endif
#endif /* __COMTESTLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long __RPC_FAR *, unsigned long            , BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long __RPC_FAR *, BSTR __RPC_FAR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\comtest\comtest_i.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 5.02.0221 */
/* at Thu Feb 04 17:08:08 1999
 */
/* Compiler settings for comtest.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32 (32b run), ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AXP64)

#ifdef __cplusplus
extern "C"{
#endif 


#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

const IID IID_IHelloWorld = {0xFEE1509A,0xBC8F,0x11D2,{0x9D,0x5E,0x00,0x00,0xF8,0x1E,0xF3,0x2E}};


const IID LIBID_COMTESTLib = {0xECE5BCF2,0xBC8F,0x11D2,{0x9D,0x5E,0x00,0x00,0xF8,0x1E,0xF3,0x2E}};


const CLSID CLSID_HelloWorld = {0x0B7E1310,0xBC90,0x11D2,{0x9D,0x5E,0x00,0x00,0xF8,0x1E,0xF3,0x2E}};


#ifdef __cplusplus
}
#endif



#endif /* !defined(_M_IA64) && !defined(_M_AXP64)*/


#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 5.02.0221 */
/* at Thu Feb 04 17:08:09 1999
 */
/* Compiler settings for comtest.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win64 (32b run,appending), ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if defined(_M_IA64) || defined(_M_AXP64)

#ifdef __cplusplus
extern "C"{
#endif 


#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

const IID IID_IHelloWorld = {0xFEE1509A,0xBC8F,0x11D2,{0x9D,0x5E,0x00,0x00,0xF8,0x1E,0xF3,0x2E}};


const IID LIBID_COMTESTLib = {0xECE5BCF2,0xBC8F,0x11D2,{0x9D,0x5E,0x00,0x00,0xF8,0x1E,0xF3,0x2E}};


const CLSID CLSID_HelloWorld = {0x0B7E1310,0xBC90,0x11D2,{0x9D,0x5E,0x00,0x00,0xF8,0x1E,0xF3,0x2E}};


#ifdef __cplusplus
}
#endif



#endif /* defined(_M_IA64) || defined(_M_AXP64)*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\cycloid\cycloid.hpp ===
/**************************************************************************
*
* Copyright (c) 2000 Microsoft Corporation
*
* Module Name:
*
*   Main cycloid canvas paint procedure
*
* Created:
*
*   06/11/2000 asecchia
*      Created it.
*
**************************************************************************/

#pragma once

#include "precomp.hpp"

class HypoCycloid :public DrawingObject {
    INT a;
    INT b;
    
    public: 
    
    HypoCycloid(int a_, int b_) {
        a=a_;
        b=b_;
    }
    
    virtual void Draw(Graphics *g, int x, int y, int width, int height);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\cycloid\cycloid.cpp ===
/**************************************************************************
*
* Copyright (c) 2000 Microsoft Corporation
*
* Module Name:
*
*   Main cycloid canvas paint procedure
*
* Created:
*
*   06/11/2000 asecchia
*      Created it.
*
**************************************************************************/

#include "cycloid.hpp"
#include "wndstuff.h"

void HypoCycloid::Draw(Graphics *g, int x, int y, int width, int height)
{
    #define _2PI 2*3.141592653689
    
    // Compute the center point for the cycle.

    float fXo=static_cast<float>(width)/2.0f;
    float fYo=static_cast<float>(height)/2.0f;
    
    float ScaleX = fXo/( (a>b)?a:a+b );
    float ScaleY = fYo/( (a>b)?a:a+b );


    int cycle=b/gcf(a,b);    //number of times round the outer circle
    int Num = cycle*30;
    
    PointF *points = new PointF[Num];

    // Compute the points tracking the cycloid path.

    for(int i=0; i<Num; i++) 
    {
        float t = (float)(cycle*_2PI*i/Num);
        points[i].X = x+(float)(fXo+ScaleX*((a-b)*cos(t)+b*cos((a-b)*t/b)));
        points[i].Y = y+(float)(fYo+ScaleY*((a-b)*sin(t)-b*sin((a-b)*t/b)));
    }
    
    Color PenColor(0xffff0000);   
    Pen myPen(PenColor, 2.0f);    
    myPen.SetLineJoin(LineJoinBevel);
    g->DrawPolygon(&myPen, points, Num);

    #undef _2PI
}

VOID
PaintWindow(
    HDC hdc
    )
{
    // Clear the window
      
    HGDIOBJ hbrush = GetStockObject(WHITE_BRUSH);
    HGDIOBJ holdBrush = SelectObject(hdc, hbrush);
    PatBlt(hdc, -10000, -10000, 20000, 20000, PATCOPY);
    SelectObject(hdc, holdBrush);
    DeleteObject(hbrush);

  
    Graphics *g = new Graphics(hdc);
    
    g->SetCompositingQuality(CompositingQualityGammaCorrected);
    g->SetSmoothingMode(SmoothingModeAntiAlias);
    
    // Do some stuff

    HypoCycloid *h = new HypoCycloid(52, 16);
    h->Draw(g, 10, 10, 400, 100);
    delete h;
    
    delete g;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\cycloid\drawcycloid.hpp ===
/**************************************************************************
*
* Copyright (c) 2000 Microsoft Corporation
*
* Module Name:
*
*   Main cycloid computation and drawing routines
*
* Created:
*
*   06/11/2000 asecchia
*      Created it.
*
**************************************************************************/

#ifndef _DRAWCYCLOID_HPP
#define _DRAWCYCLOID_HPP

#include "precomp.hpp"

void DrawTestCycloid(Graphics *g, int a, int b, int width, int height);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\cycloid\drawcycloid.cpp ===
/**************************************************************************
*
* Copyright (c) 2000 Microsoft Corporation
*
* Module Name:
*
*   Cycloid Drawing.
*
* Abstract:
*
*   Routines for computing and drawing cycloids.
*
* Created:
*
*   06/11/2000 asecchia
*      Created it.
*
**************************************************************************/

#include "drawcycloid.hpp"

/**************************************************************************
*
* Function Description:
*
*   Test function to draw an example cycloid.
*
* Created:
*
*   06/11/2000 asecchia
*      Created it.
*
**************************************************************************/

void DrawTestCycloid(Graphics *g, int a, int b, int width, int height)
{
    #define _2PI 2*3.141592653689
    

    // Compute the center point for the cycle.

    float fXo=static_cast<float>(width)/2.0f;
    float fYo=static_cast<float>(height)/2.0f;
    
    float ScaleX = fXo/( (a>b)?a:a+b );
    float ScaleY = fYo/( (a>b)?a:a+b );


    int cycle=b/gcf(a,b);    //number of times round the outer circle
    int Num = cycle*30;
    
    PointF *points = new PointF[Num];

    // Compute the points tracking the cycloid path.

    for(int i=0; i<Num; i++) 
    {
        float t = (float)(cycle*_2PI*i/Num);
        points[i].X = 10+(float)(fXo+ScaleX*((a-b)*cos(t)+b*cos((a-b)*t/b)));
        points[i].Y = 10+(float)(fYo+ScaleY*((a-b)*sin(t)-b*sin((a-b)*t/b)));
    }
    
    Color PenColor(0xffff0000);   
    Pen myPen(PenColor, 2.0f);    
    myPen.SetLineJoin(LineJoinBevel);
    g->DrawPolygon(&myPen, points, Num);

    #undef _2PI
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\crop\crop.cxx ===
/**************************************************************************
*
* Copyright (c) 2000 Microsoft Corporation
*
* Program Name:
*
*   Crop
*
*   This is a sample application that loads an image and shrinks it down
*   to 128x96 using the HighQualityBicubic resampling filter. It crops the
*   image to preserve the aspect ratio.
*
*   This app is particularly useful for creating a set of thumbnail images
*   from a directory of pictures for use in a web page index.
*
*   This example will produce a directory (idx) containing 128x96 jpeg
*   thumbnails for all the jpeg files in the pictures directory:
*       cd pictures
*       md idx
*       for %i in (*.jpg) do crop %~nxi idx\%~nxi
*
* Usage (command line):
*
*   Crop input_filename output_filename
*
* Created:
*
*   06/25/2000 asecchia
*      Created it.
*   03/16/2001 minliu
*       add -w, -h, -? -s, -q switches support. New ValidateArguments() and
*       USAGE() function
*   05/10/2001 gillesk
*       added -a to crop the excess of the file and keep the w and h
*
**************************************************************************/

#include <stdio.h>
#include <windows.h>
#include <objbase.h>
#include <gdiplus.h>

#include "../gpinit.inc"

INT AsciiToUnicodeStr(
    const CHAR* ansiStr,
    WCHAR* unicodeStr,
    INT unicodeSize
)
{
    return( MultiByteToWideChar(
        CP_ACP,
        0,
        ansiStr,
        -1,
        unicodeStr,
        unicodeSize
    ) > 0 );
}

int round(float f) { return (int) (f+0.5); }

const int k_xsize = 128;    // default thumbnail size
const int k_ysize = 96;

int     g_xsize = k_xsize;
int     g_ysize = k_ysize;
float   g_scale = 1;
int     g_quality = 5;
int     g_compression = 70;
BOOL    g_HasSetScaleFactor = FALSE;
BOOL    g_KeepAspectRation = FALSE;
BOOL    g_GotFileNames = FALSE;
WCHAR   filename[1024];
WCHAR   outfilename[1024];

#define Fail() goto cleanup

void
USAGE()
{
    printf("******************************************************\n");
    printf("Usage: crop [-?] [-w width] [-h height] [-s factor] srcImg dstImg\n");
    printf("-w----Specify the thumbnail image width. Default is 128\n");
    printf("-h----Specify the thumbnail image height. Default is 96\n");
    printf("-s----Specify the scale factor\n");
    printf("-q----Specify the render quality [1-5] where 5(default) is the best\n");
    printf("-a----Keep the apsect ratio and crop the excess of the image\n");
    printf("-c----Set the compression factor [0-100] where 100 is least compressed\n");
    printf("-?----Print this usage message\n");
    printf("Note: If scale factor is specified, then width and height you specified are ignored\n\n\n");
    printf("Sample usage:\n");
    printf("    crop -w 200 -h 300 foo.jpg thumb.jpg\n");
    printf("    crop -s 0.5 foo.jpg thumb.jpg\n");
    printf("    crop foo.jpg thumb.jpg\n");
}// USAGE()

void
ValidateArguments(int   argc,
                  char* argv[])
{
    argc--;
    argv++; // Filter out program name

    while ( argc > 0 )
    {
        if ( strcmp(*argv, "-w") == 0 )
        {
            argc--;
            argv++;

            if ( argc == 0 )
            {
                // Not enough parameters

                USAGE();
                exit(1);
            }
            
            g_xsize = atoi(*argv++);
            argc--;
        }
        else if ( strcmp(*argv, "-h") == 0 )
        {
            argc--;
            argv++;

            if ( argc == 0 )
            {
                // Not enough parameters

                USAGE();
                exit(1);
            }
            
            g_ysize = atoi(*argv++);
            argc--;
        }
        else if ( strcmp(*argv, "-s") == 0 )
        {
            argc--;
            argv++;

            if ( argc == 0 )
            {
                // Not enough parameters

                USAGE();
                exit(1);
            }
            
            g_scale = (float)atof(*argv++);
            g_HasSetScaleFactor = TRUE;
            argc--;
        }
        else if ( strcmp(*argv, "-q") == 0 )
        {
            argc--;
            argv++;

            if ( argc == 0 )
            {
                // Not enough parameters

                USAGE();
                exit(1);
            }
            
            g_quality = atoi(*argv++);
            argc--;
        }
        else if ( strcmp(*argv, "-a") == 0 )
        {
            g_KeepAspectRation = TRUE;
            argc--;
            argv++;
        }
        else if ( strcmp(*argv, "-c") == 0 )
        {
            argc--;
            argv++;

            if ( argc == 0 )
            {
                // Not enough parameters

                USAGE();
                exit(1);
            }
            
            g_compression = atoi(*argv++);
            argc--;
        }
        else if ( strcmp(*argv, "-?") == 0 )
        {
            USAGE();
            exit(1);
        }
        else
        {
            // source and dest image name

            if ( argc < 2 )
            {
                // Not enough parameters

                USAGE();
                exit(1);
            }
            
            AsciiToUnicodeStr(*argv++, filename, 1024);
            argc--;
            AsciiToUnicodeStr(*argv++, outfilename, 1024);
            argc--;
            g_GotFileNames = TRUE;
        }
    }// while ( argc > 0 )

    if ( g_GotFileNames == FALSE )
    {
        // No input file name yet, bail out

        USAGE();
        exit(1);
    }
}// ValidateArguments()

void _cdecl
main(int argc,
     char **argv
     )
{
    if (!gGdiplusInitHelper.IsValid())
    {
        printf("error - GDI+ initialization failed\n");
        return;
    }

    // Parse input parameters

    ValidateArguments(argc, argv);

    using namespace Gdiplus;

    Status status = Ok;

    ImageCodecInfo* codecs = NULL;
    UINT count;
    UINT cbCodecs;

    // Open the source image
    
    Bitmap* dstBmp = NULL;
    Graphics *gdst = NULL;
    RectF srcRect;

    Bitmap *srcBmp = new Bitmap(filename, TRUE);
    if ( (srcBmp == NULL) || (srcBmp->GetLastStatus() != Ok) )
    {
        printf("Error opening image %s\n", filename);
        Fail();
    }

    // Ask the source image for it's size.

    int width = srcBmp->GetWidth();
    int height = srcBmp->GetHeight();

    srcRect = RectF(0.0f, 0.0f, (REAL)width, (REAL)height);

    printf("Input image is %d x %d\n", width, height);

    // Compute the optimal scale factor without changing the aspect ratio
    if ( g_HasSetScaleFactor == FALSE )
    {
        float scalex = (float)g_xsize / width;
        float scaley = (float)g_ysize / height;
        g_scale = min(scalex, scaley);
    }

    // If we want to keep the aspect ratio, then we need to crop the srcBmp

    UINT    dstWidth = (UINT)(width * g_scale + 0.5);
    UINT    dstHeight = (UINT)(height * g_scale + 0.5);

    if ( g_KeepAspectRation == TRUE )
    {
        float scalex = (float)g_xsize / width;
        float scaley = (float)g_ysize / height;
        g_scale = max(scalex, scaley);
        srcRect = RectF((REAL)width/2.0f, (REAL)height/2.0f, 0.0f, 0.0f);
        srcRect.Inflate(g_xsize/g_scale/2.0f, g_ysize/g_scale/2.0f);
        dstWidth = g_xsize;
        dstHeight = g_ysize;
    }
    

    // Create a destination image to draw onto
    
    dstBmp = new Bitmap(dstWidth, dstHeight, PixelFormat32bppPARGB);
    if ( (dstBmp == NULL) || (dstBmp->GetLastStatus() != Ok) )
    {
        printf("Error create temp Bitmap with size %d x %x\n", dstWidth,
               dstHeight);
        Fail();
    }
    
    gdst = new Graphics(dstBmp);
    if ( (gdst == NULL) || (gdst->GetLastStatus() != Ok) )
    {
        printf("Error create graphics\n");
        Fail();
    }
    
    // Make up a dest rect that we need image to draw to

    {
        RectF    dstRect(0.0f, 0.0f, (REAL)dstWidth, (REAL)dstHeight);

        // Set the resampling quality to the bicubic filter

        switch ( g_quality )
        {
        case 1:
            gdst->SetInterpolationMode(InterpolationModeBilinear);
            break;

        case 2:
            gdst->SetInterpolationMode(InterpolationModeNearestNeighbor);
            break;

        case 3:
            gdst->SetInterpolationMode(InterpolationModeBicubic);
            break;
        
        case 4:
            gdst->SetInterpolationMode(InterpolationModeHighQualityBilinear);
            break;

        case 5:
        default:
            gdst->SetInterpolationMode(InterpolationModeHighQualityBicubic);
            break;
        }

        // Set the compositing quality to copy source pixels rather than
        // alpha blending. This will preserve any alpha in the source image.

        gdst->SetCompositingMode(CompositingModeSourceCopy);

        // Draw the source image onto the destination with the correct scale
        // and quality settings.

        status = gdst->DrawImage(srcBmp, 
                                 dstRect, 
                                 srcRect.X,
                                 srcRect.Y,
                                 srcRect.Width,
                                 srcRect.Height,
                                 UnitPixel
                                 );

        if (status != Ok)
        {
            printf("Error drawing the image\n");
            Fail();
        }
    }

    // Now start finding a codec to output the image.

    cbCodecs = 0;
    GetImageEncodersSize(&count, &cbCodecs);

    // Allocate space for the codec list

    codecs = static_cast<ImageCodecInfo *>(malloc (cbCodecs));

    if (codecs == NULL)
    {
        printf("error: failed to allocate memory for codecs\n");
        Fail();
    }

    // Get the list of encoders

    status = GetImageEncoders(count, cbCodecs, codecs);

    if (status != Ok)
    {
        printf("Error: GetImageEncoders returned %d\n", status);
        Fail();
    }

    // Search the codec list for the JPEG codec.
    // Use the Mime Type field to specify the correct codec.

    for(UINT i=0; i<count; i++) {
        if(wcscmp(codecs[i].MimeType, L"image/jpeg")==0) {break;}
    }

    if(i>=count)
    {
        fprintf(stderr, "failed to find the codec\n");
        Fail();
    }

    // Output the image to disk.

    CLSID tempClsID;
    tempClsID = codecs[i].Clsid;
    EncoderParameters params;
    params.Count = 1;

    params.Parameter[0].Guid = EncoderCompression;
    params.Parameter[0].NumberOfValues = 1;
    params.Parameter[0].Type = EncoderParameterValueTypeLong;
    params.Parameter[0].Value = (void*) &g_compression;

    status = dstBmp->Save(
        outfilename,
        &tempClsID,
        &params
    );

    if (status != Ok)
    {
        fprintf(stderr, "SaveImage--Save() failed\n");
        Fail();
    }

    printf("Create new image at %d x %d\n", dstWidth, dstHeight);
    
    // We're golden - everything worked.

    printf("Done\n");


    // Clean up the objects we used.

    cleanup:

    free(codecs);
    delete gdst;
    delete dstBmp;
    delete srcBmp;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\cycloid\message.hpp ===
/**************************************************************************
*
* Copyright (c) 2000 Microsoft Corporation
*
* Module Name:
*
*   Messages
*
* Abstract:
*
*   Simple class that encapsulates the necessary information to propagate
*   a basic object message
*
* Created:
*
*   06/17/2000 asecchia
*      Created it.
*
**************************************************************************/

#ifndef _MESSAGE_HPP
#define _MESSAGE_HPP

#include "precomp.hpp"

class Message {
    public: 
    INT TheMessage;
    WPARAM WParam;
    LPARAM LParam;
    
    public:
    Message(INT msg, WPARAM w, LPARAM l) {
        TheMessage = msg;
        WParam = w;
        LParam = l;
    }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\cycloid\manipulator.hpp ===
/**************************************************************************
*
* Copyright (c) 2000 Microsoft Corporation
*
* Module Name:
*
*   Manipulator ancestor
*
* Abstract:
*
*   This is the root of the manipulator object heirarchy
*
*
* Created:
*
*   06/17/2000 asecchia
*      Created it.
*
**************************************************************************/

#ifndef _MANIPULATOR_HPP
#define _MANIPULATOR_HPP

#include "precomp.hpp"

class Manipulator {

    public:
    Manipulator() {}
    
    // Process this message
    virtual void DoMessage(Message &msg) = 0;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\cycloid\prime.hpp ===
/**************************************************************************
*
* Copyright (c) 2000 Microsoft Corporation
*
* Module Name:
*
*   prime.hpp
*
* Abstract:
*
*   Routines dealing with prime numbers and factorization.
*
* Created:
*
*   06/11/2000 asecchia
*      Created it.
*
**************************************************************************/

#ifndef _PRIME_HPP
#define _PRIME_HPP

#include "precomp.hpp"

// An array of the first 1000 prime numbers.

extern int PrimeNumbers[1000];

// Greatest Common Factor

int gcf(int a, int b);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\cycloid\precomp.hpp ===
/**************************************************************************
*
* Copyright (c) 2000 Microsoft Corporation
*
* Module Name:
*
*   Header files included in this program 
*
* Created:
*
*   06/11/2000 asecchia
*      Created it.
*
**************************************************************************/

#ifndef _PRECOMP_HPP
#define _PRECOMP_HPP

#include "global.h"
#include "prime.hpp"
#include "drawcycloid.hpp"
#include "message.hpp"
#include "object.hpp"
#include "manipulator.hpp"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\cycloid\wndstuff.h ===
/****************************** Module Header ******************************\
* Module Name: wndstuff.h
*
* Created: 23 December 1999
* Author: Adrian Secchia [asecchia]
*
* Copyright (c) 1999 Microsoft Corporation
\***************************************************************************/
#pragma once

#include <windows.h>
#include <winuser.h>
#include <commdlg.h>

#define DONTUSE(x) (x)

#define IDM_OPENFILE         40000
#define IDM_QUIT             40001

VOID PaintWindow(HDC hdc);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\cycloid\object.hpp ===
/**************************************************************************
*
* Copyright (c) 2000 Microsoft Corporation
*
* Module Name:
*
*   Object ancestor
*
* Abstract:
*
*   Ancestor class for all drawing objects
*
* Created:
*
*   06/17/2000 asecchia
*      Created it.
*
**************************************************************************/

#ifndef _OBJECT_HPP
#define _OBJECT_HPP

#include "precomp.hpp"

class DrawingObject {
    public:
    DrawingObject() {}
    
    // Tell the object to draw itself on this graphics, 
    // given a set of dimensions
    virtual void Draw(Graphics *g, int x, int y, int width, int height) = 0;
    
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\cycloid\prime.cpp ===
/**************************************************************************
*
* Copyright (c) 2000 Microsoft Corporation
*
* Module Name:
*
*   prime.cpp
*
* Abstract:
*
*   Routines dealing with prime numbers and factorization.
*
* Created:
*
*   06/11/2000 asecchia
*      Created it.
*
**************************************************************************/

#include "prime.hpp"

// An array of the first 1000 prime numbers.

int PrimeNumbers[1000] = {
      2,     3,     5,     7,    11,    13,    17,    19,    23,    29,
     31,    37,    41,    43,    47,    53,    59,    61,    67,    71,
     73,    79,    83,    89,    97,   101,   103,   107,   109,   113,
    127,   131,   137,   139,   149,   151,   157,   163,   167,   173,
    179,   181,   191,   193,   197,   199,   211,   223,   227,   229,
    233,   239,   241,   251,   257,   263,   269,   271,   277,   281,
    283,   293,   307,   311,   313,   317,   331,   337,   347,   349,
    353,   359,   367,   373,   379,   383,   389,   397,   401,   409,
    419,   421,   431,   433,   439,   443,   449,   457,   461,   463,
    467,   479,   487,   491,   499,   503,   509,   521,   523,   541,
    547,   557,   563,   569,   571,   577,   587,   593,   599,   601,
    607,   613,   617,   619,   631,   641,   643,   647,   653,   659,
    661,   673,   677,   683,   691,   701,   709,   719,   727,   733,
    739,   743,   751,   757,   761,   769,   773,   787,   797,   809,
    811,   821,   823,   827,   829,   839,   853,   857,   859,   863,
    877,   881,   883,   887,   907,   911,   919,   929,   937,   941,
    947,   953,   967,   971,   977,   983,   991,   997,  1009,  1013,
   1019,  1021,  1031,  1033,  1039,  1049,  1051,  1061,  1063,  1069,
   1087,  1091,  1093,  1097,  1103,  1109,  1117,  1123,  1129,  1151,
   1153,  1163,  1171,  1181,  1187,  1193,  1201,  1213,  1217,  1223,
   1229,  1231,  1237,  1249,  1259,  1277,  1279,  1283,  1289,  1291,
   1297,  1301,  1303,  1307,  1319,  1321,  1327,  1361,  1367,  1373,
   1381,  1399,  1409,  1423,  1427,  1429,  1433,  1439,  1447,  1451,
   1453,  1459,  1471,  1481,  1483,  1487,  1489,  1493,  1499,  1511,
   1523,  1531,  1543,  1549,  1553,  1559,  1567,  1571,  1579,  1583,
   1597,  1601,  1607,  1609,  1613,  1619,  1621,  1627,  1637,  1657,
   1663,  1667,  1669,  1693,  1697,  1699,  1709,  1721,  1723,  1733,
   1741,  1747,  1753,  1759,  1777,  1783,  1787,  1789,  1801,  1811,
   1823,  1831,  1847,  1861,  1867,  1871,  1873,  1877,  1879,  1889,
   1901,  1907,  1913,  1931,  1933,  1949,  1951,  1973,  1979,  1987,
   1993,  1997,  1999,  2003,  2011,  2017,  2027,  2029,  2039,  2053,
   2063,  2069,  2081,  2083,  2087,  2089,  2099,  2111,  2113,  2129,
   2131,  2137,  2141,  2143,  2153,  2161,  2179,  2203,  2207,  2213,
   2221,  2237,  2239,  2243,  2251,  2267,  2269,  2273,  2281,  2287,
   2293,  2297,  2309,  2311,  2333,  2339,  2341,  2347,  2351,  2357,
   2371,  2377,  2381,  2383,  2389,  2393,  2399,  2411,  2417,  2423,
   2437,  2441,  2447,  2459,  2467,  2473,  2477,  2503,  2521,  2531,
   2539,  2543,  2549,  2551,  2557,  2579,  2591,  2593,  2609,  2617,
   2621,  2633,  2647,  2657,  2659,  2663,  2671,  2677,  2683,  2687,
   2689,  2693,  2699,  2707,  2711,  2713,  2719,  2729,  2731,  2741,
   2749,  2753,  2767,  2777,  2789,  2791,  2797,  2801,  2803,  2819,
   2833,  2837,  2843,  2851,  2857,  2861,  2879,  2887,  2897,  2903,
   2909,  2917,  2927,  2939,  2953,  2957,  2963,  2969,  2971,  2999,
   3001,  3011,  3019,  3023,  3037,  3041,  3049,  3061,  3067,  3079,
   3083,  3089,  3109,  3119,  3121,  3137,  3163,  3167,  3169,  3181,
   3187,  3191,  3203,  3209,  3217,  3221,  3229,  3251,  3253,  3257,
   3259,  3271,  3299,  3301,  3307,  3313,  3319,  3323,  3329,  3331,
   3343,  3347,  3359,  3361,  3371,  3373,  3389,  3391,  3407,  3413,
   3433,  3449,  3457,  3461,  3463,  3467,  3469,  3491,  3499,  3511,
   3517,  3527,  3529,  3533,  3539,  3541,  3547,  3557,  3559,  3571,
   3581,  3583,  3593,  3607,  3613,  3617,  3623,  3631,  3637,  3643,
   3659,  3671,  3673,  3677,  3691,  3697,  3701,  3709,  3719,  3727,
   3733,  3739,  3761,  3767,  3769,  3779,  3793,  3797,  3803,  3821,
   3823,  3833,  3847,  3851,  3853,  3863,  3877,  3881,  3889,  3907,
   3911,  3917,  3919,  3923,  3929,  3931,  3943,  3947,  3967,  3989,
   4001,  4003,  4007,  4013,  4019,  4021,  4027,  4049,  4051,  4057,
   4073,  4079,  4091,  4093,  4099,  4111,  4127,  4129,  4133,  4139,
   4153,  4157,  4159,  4177,  4201,  4211,  4217,  4219,  4229,  4231,
   4241,  4243,  4253,  4259,  4261,  4271,  4273,  4283,  4289,  4297,
   4327,  4337,  4339,  4349,  4357,  4363,  4373,  4391,  4397,  4409,
   4421,  4423,  4441,  4447,  4451,  4457,  4463,  4481,  4483,  4493,
   4507,  4513,  4517,  4519,  4523,  4547,  4549,  4561,  4567,  4583,
   4591,  4597,  4603,  4621,  4637,  4639,  4643,  4649,  4651,  4657,
   4663,  4673,  4679,  4691,  4703,  4721,  4723,  4729,  4733,  4751,
   4759,  4783,  4787,  4789,  4793,  4799,  4801,  4813,  4817,  4831,
   4861,  4871,  4877,  4889,  4903,  4909,  4919,  4931,  4933,  4937,
   4943,  4951,  4957,  4967,  4969,  4973,  4987,  4993,  4999,  5003,
   5009,  5011,  5021,  5023,  5039,  5051,  5059,  5077,  5081,  5087,
   5099,  5101,  5107,  5113,  5119,  5147,  5153,  5167,  5171,  5179,
   5189,  5197,  5209,  5227,  5231,  5233,  5237,  5261,  5273,  5279,
   5281,  5297,  5303,  5309,  5323,  5333,  5347,  5351,  5381,  5387,
   5393,  5399,  5407,  5413,  5417,  5419,  5431,  5437,  5441,  5443,
   5449,  5471,  5477,  5479,  5483,  5501,  5503,  5507,  5519,  5521,
   5527,  5531,  5557,  5563,  5569,  5573,  5581,  5591,  5623,  5639,
   5641,  5647,  5651,  5653,  5657,  5659,  5669,  5683,  5689,  5693,
   5701,  5711,  5717,  5737,  5741,  5743,  5749,  5779,  5783,  5791,
   5801,  5807,  5813,  5821,  5827,  5839,  5843,  5849,  5851,  5857,
   5861,  5867,  5869,  5879,  5881,  5897,  5903,  5923,  5927,  5939,
   5953,  5981,  5987,  6007,  6011,  6029,  6037,  6043,  6047,  6053,
   6067,  6073,  6079,  6089,  6091,  6101,  6113,  6121,  6131,  6133,
   6143,  6151,  6163,  6173,  6197,  6199,  6203,  6211,  6217,  6221,
   6229,  6247,  6257,  6263,  6269,  6271,  6277,  6287,  6299,  6301,
   6311,  6317,  6323,  6329,  6337,  6343,  6353,  6359,  6361,  6367,
   6373,  6379,  6389,  6397,  6421,  6427,  6449,  6451,  6469,  6473,
   6481,  6491,  6521,  6529,  6547,  6551,  6553,  6563,  6569,  6571,
   6577,  6581,  6599,  6607,  6619,  6637,  6653,  6659,  6661,  6673,
   6679,  6689,  6691,  6701,  6703,  6709,  6719,  6733,  6737,  6761,
   6763,  6779,  6781,  6791,  6793,  6803,  6823,  6827,  6829,  6833,
   6841,  6857,  6863,  6869,  6871,  6883,  6899,  6907,  6911,  6917,
   6947,  6949,  6959,  6961,  6967,  6971,  6977,  6983,  6991,  6997,
   7001,  7013,  7019,  7027,  7039,  7043,  7057,  7069,  7079,  7103,
   7109,  7121,  7127,  7129,  7151,  7159,  7177,  7187,  7193,  7207,
   7211,  7213,  7219,  7229,  7237,  7243,  7247,  7253,  7283,  7297,
   7307,  7309,  7321,  7331,  7333,  7349,  7351,  7369,  7393,  7411,
   7417,  7433,  7451,  7457,  7459,  7477,  7481,  7487,  7489,  7499,
   7507,  7517,  7523,  7529,  7537,  7541,  7547,  7549,  7559,  7561,
   7573,  7577,  7583,  7589,  7591,  7603,  7607,  7621,  7639,  7643,
   7649,  7669,  7673,  7681,  7687,  7691,  7699,  7703,  7717,  7723,
   7727,  7741,  7753,  7757,  7759,  7789,  7793,  7817,  7823,  7829,
   7841,  7853,  7867,  7873,  7877,  7879,  7883,  7901,  7907,  7919
};



/**************************************************************************
*
* Function Description:
*
*   gcf(a,b) returns the greatest common factor of two integers.
*   Example: 24=2.2.2.3, 20=2.2.5, gcf(24,20)=4=2.2
*
* Arguments:
*
*   [IN] a, b  - the two numbers
*
*
* Return Value:
*
*   return value is the greatest common factor of a and b
*
*
* Created:
*
*   06/11/2000 asecchia
*      Created it.
*
**************************************************************************/

int gcf(int a, int b) {
  int gcftot=1;
  int minab = min(a,b);
  int limit = (int) sqrt((float)minab);
  int pf;

  int i=0;
  pf = PrimeNumbers[i];
  do {
    if( (a % pf == 0) &&                 //does this prime number divide into
        (b % pf == 0) ) {                //what we have left?
      a /= pf;                           //remove this common factor
      b /= pf;
      gcftot *= pf;                      //remember this common factor
    } else {
      pf = PrimeNumbers[++i];            //start on the next prime number
    }
  } while ((i<1000) && (pf<=limit));

  return gcftot;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\cycloid\wndstuff.cpp ===
/******************************Module*Header*******************************\
* Module Name: wndstuff.cpp
*
* Menu driven test environment.
*
* Created: 23 December 1999
* Author: Adrian Secchia [asecchia]
*
* Copyright (c) 1999 Microsoft Corporation
*
\**************************************************************************/

// for Win95 compile
#undef UNICODE
#undef _UNICODE

#include <windows.h>
#include <tchar.h>
#include <stdio.h>
#include <stdlib.h>

#include "wndstuff.h"

HINSTANCE ghInstance;
HWND ghwndMain;
HBRUSH ghbrWhite;

AnsiToUnicodeStr(
    const CHAR* ansiStr,
    WCHAR* unicodeStr,
    INT unicodeSize
    )
{
    return (
        MultiByteToWideChar(
            CP_ACP,
            0,
            ansiStr,
            -1,
            unicodeStr,
            unicodeSize
        ) > 0
    );
}


void OpenFileProc(HWND hwnd)
{

    char locFileName[MAX_PATH];
    OPENFILENAME    ofn;

    ZeroMemory(&ofn, sizeof(ofn));

    ofn.lStructSize = sizeof(ofn);
    ofn.hwndOwner = hwnd;
    ofn.hInstance = ghInstance;
    ofn.lpstrFile = locFileName;
    ofn.nMaxFile = MAX_PATH;
    ofn.lpstrTitle = "Open Image";
    ofn.lpstrInitialDir = ".";
    ofn.Flags = OFN_FILEMUSTEXIST;
    locFileName[0] = '\0';

    // Present the file/open dialog

    if(GetOpenFileName(&ofn)) 
    {
        //AnsiToUnicodeStr(locFileName, FileName, MAX_PATH);
    }
}



/***************************************************************************\
* lMainWindowProc(hwnd, message, wParam, lParam)
*
* Processes all messages for the main window.
\***************************************************************************/

LONG_PTR
lMainWindowProc(
    HWND    hwnd,
    UINT    message,
    WPARAM  wParam,
    LPARAM  lParam
    )
{
    PAINTSTRUCT ps;
    HDC hdc;

    switch (message)
    {
    
    case WM_CREATE:
        break;

    case WM_SIZE:
        InvalidateRect(hwnd, NULL, FALSE);
        break;

    case WM_PAINT:
        hdc = BeginPaint(hwnd, &ps);
        PaintWindow(hdc);
        ReleaseDC(hwnd, hdc);
        break;


    case WM_COMMAND:
        switch(LOWORD(wParam))
        {
        
        case IDM_OPENFILE:
            OpenFileProc(hwnd);
            InvalidateRect(hwnd, NULL, TRUE);        
        break;

        case IDM_QUIT:
            exit(0);
        break;
          
        default:
            // The user selected an unimplemented menu item.
            MessageBox(hwnd,
                _T("This is an unimplemented feature."), 
                _T(""),
                MB_OK
            );
        break;

        }
        break;

    case WM_DESTROY:
        DeleteObject(ghbrWhite);
        PostQuitMessage(0);
        return(DefWindowProc(hwnd, message, wParam, lParam));

    default:
        return(DefWindowProc(hwnd, message, wParam, lParam));
    }

    return(0);
}

/***************************************************************************\
* bInitApp()
*
* Initializes the app.
\***************************************************************************/

BOOL bInitApp(VOID)
{
    WNDCLASS wc;

    // not quite so white background brush.
    ghbrWhite = CreateSolidBrush(RGB(0xFF,0xFF,0xFF));

    wc.style            = 0;
    wc.lpfnWndProc      = lMainWindowProc;
    wc.cbClsExtra       = 0;
    wc.cbWndExtra       = 0;
    wc.hInstance        = ghInstance;
    wc.hIcon            = LoadIcon(NULL, IDI_APPLICATION);
    wc.hCursor          = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground    = ghbrWhite;
    wc.lpszMenuName     = _T("MainMenu");
    wc.lpszClassName    = _T("TestClass");

    if(!RegisterClass(&wc)) { return FALSE; }

    ghwndMain = CreateWindowEx(
        0,
        _T("TestClass"),
        _T("Win32 Test"),
        WS_OVERLAPPED   |  
        WS_CAPTION      |  
        WS_BORDER       |  
        WS_THICKFRAME   |  
        WS_MAXIMIZEBOX  |  
        WS_MINIMIZEBOX  |  
        WS_CLIPCHILDREN |  
        WS_VISIBLE      |  
        WS_SYSMENU,
        80,
        70,
        500,
        500,
        NULL,
        NULL,
        ghInstance,
        NULL
    );

    if (ghwndMain == NULL)
    {
        return(FALSE);
    }
    SetFocus(ghwndMain);
    return TRUE;
}

/***************************************************************************\
* main(argc, argv[])
*
* Sets up the message loop.
\***************************************************************************/

_cdecl
main(
    INT   argc,
    PCHAR argv[]
)
{
    MSG    msg;
    HACCEL haccel;
    CHAR*  pSrc;
    CHAR*  pDst;

    ghInstance = GetModuleHandle(NULL);
    if(!bInitApp()) { return 0; }

    while(GetMessage (&msg, NULL, 0, 0))
    {
      if((ghwndMain == 0) || !IsDialogMessage(ghwndMain, &msg)) {
        TranslateMessage(&msg) ;
        DispatchMessage(&msg) ;
      }
    }

    return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\dciperf\dciperf.c ===
/******************************Module*Header*******************************\
* Module Name: test.c
*
* Created: 09-Dec-1992 10:51:46
* Author: Kirk Olynyk [kirko]
*
* Copyright (c) 1991 Microsoft Corporation
*
* Contains the test
*
* Dependencies:
*
\**************************************************************************/

#include <windows.h>

#include <stdio.h>
#include <commdlg.h>

#include <dciman.h>
#include <ddraw.h>
#include <limits.h>

VOID _fastcall KniNt128Write(VOID*);
VOID _fastcall Kni128Read(VOID*);

LPDIRECTDRAW        lpDD;
LPDIRECTDRAWSURFACE lpSurface;
DDSURFACEDESC       ddsd;
BOOL                gbWarned;

#define BYTE_OPS 1
#define MMX 1

#define WRITE_ITERATIONS    10000
#define READ_ITERATIONS     1000
#define NUM_BYTES           (8 * 1024)
#define WRITE_MEGS          ((WRITE_ITERATIONS * NUM_BYTES) / 1000.f)
#define READ_MEGS           ((READ_ITERATIONS * NUM_BYTES) / 1000.f)

/******************************Public*Routine******************************\
* vTestRegular
*
* Test regular IA instructions
*
\**************************************************************************/

VOID vTestRegular(
    PVOID pvBits
    )
{
    DWORD   dwStart;
    ULONG   i;
    ULONG   j;
    ULONG   ul;
    volatile BYTE*   pj;
    volatile USHORT* pus;
    volatile ULONG*  pul;
    BYTE    uchars;
    USHORT  ushorts;
    ULONG   ulongs;
    DWORD   dwTimeWritesConsecutiveBytes = LONG_MIN;
    DWORD   dwTimeWritesConsecutiveWords = LONG_MIN;
    DWORD   dwTimeWritesConsecutiveDwords = LONG_MIN;
    DWORD   dwTimeReadsConsecutiveBytes = LONG_MIN;
    DWORD   dwTimeReadsConsecutiveWords = LONG_MIN;
    DWORD   dwTimeReadsConsecutiveDwords = LONG_MIN;
    DWORD   dwTimeReadWritesConsecutiveBytes = LONG_MIN;
    DWORD   dwTimeReadWritesConsecutiveWords = LONG_MIN;
    DWORD   dwTimeReadWritesConsecutiveDwords = LONG_MIN;
    DWORD   dwTimeReadWritesBatchedBytes = LONG_MIN;
    DWORD   dwTimeReadWritesBatchedWords = LONG_MIN;
    DWORD   dwTimeReadWritesBatchedDwords = LONG_MIN;
    DWORD   dwTimeWritesInplaceBytes = LONG_MIN;
    DWORD   dwTimeWritesInplaceWords = LONG_MIN;
    DWORD   dwTimeWritesInplaceDwords = LONG_MIN;
    DWORD   dwTimeReadsInplaceBytes = LONG_MIN;
    DWORD   dwTimeReadsInplaceWords = LONG_MIN;
    DWORD   dwTimeReadsInplaceDwords = LONG_MIN;
    DWORD   dwTimeWritesRandomBytes = LONG_MIN;
    DWORD   dwTimeWritesRandomWords = LONG_MIN;
    DWORD   dwTimeWritesRandomDwords = LONG_MIN;
    DWORD   dwTimeReadsRandomBytes = LONG_MIN;
    DWORD   dwTimeReadsRandomWords = LONG_MIN;
    DWORD   dwTimeReadsRandomDwords = LONG_MIN;
    DWORD   dwTimeWritesUnalignedWords = LONG_MIN;
    DWORD   dwTimeWritesUnalignedDwords = LONG_MIN;
    DWORD   dwTimeReadsUnalignedWords = LONG_MIN;
    DWORD   dwTimeReadsUnalignedDwords = LONG_MIN;
    //
    // Consecutive writes...
    //

#if BYTE_OPS

    dwStart = GetTickCount();
    for (j = WRITE_ITERATIONS; j != 0; j--)
    {
        pj = pvBits;
        for (i = NUM_BYTES; i != 0; i--)
        {
            *pj++ = (BYTE) i;
        }
    }
    dwTimeWritesConsecutiveBytes = GetTickCount() - dwStart;

    dwStart = GetTickCount();
    for (j = WRITE_ITERATIONS; j != 0; j--)
    {
        pus = pvBits;
        for (i = NUM_BYTES / 2; i != 0; i--)
        {
            *pus++ = (USHORT) i;
        }
    }
    dwTimeWritesConsecutiveWords = GetTickCount() - dwStart;

#endif

    dwStart = GetTickCount();
    for (j = WRITE_ITERATIONS; j != 0; j--)
    {
        pul = pvBits;
        for (i = NUM_BYTES / 4; i != 0; i--)
        {
            *pul++ = (ULONG) i;
        }
    }
    dwTimeWritesConsecutiveDwords = GetTickCount() - dwStart;

    //
    // Consecutive reads...
    //

#if BYTE_OPS

    dwStart = GetTickCount();
    for (j = READ_ITERATIONS; j != 0; j--)
    {
        pj = pvBits;
        for (i = NUM_BYTES; i != 0; i--)
        {
            uchars |= *pj++;
        }
    }
    dwTimeReadsConsecutiveBytes = GetTickCount() - dwStart;

    dwStart = GetTickCount();
    for (j = READ_ITERATIONS; j != 0; j--)
    {
        pus = pvBits;
        for (i = NUM_BYTES / 2; i != 0; i--)
        {
            ushorts |= *pus++;
        }
    }
    dwTimeReadsConsecutiveWords = GetTickCount() - dwStart;

#endif

    dwStart = GetTickCount();
    for (j = READ_ITERATIONS; j != 0; j--)
    {
        pul = pvBits;
        for (i = NUM_BYTES / 4; i != 0; i--)
        {
            ulongs |= *pul++;
        }
    }
    dwTimeReadsConsecutiveDwords = GetTickCount() - dwStart;

    //
    // Consecutive read/writes
    //

#if BYTE_OPS

    dwStart = GetTickCount();
    for (j = READ_ITERATIONS; j != 0; j--)
    {
        pj = pvBits;
        for (i = NUM_BYTES; i != 0; i--)
        {
            uchars |= *pj;
            *pj = uchars;
            pj++;
        }
    }
    dwTimeReadWritesConsecutiveBytes = GetTickCount() - dwStart;

    dwStart = GetTickCount();
    for (j = READ_ITERATIONS; j != 0; j--)
    {
        pus = pvBits;
        for (i = NUM_BYTES / 2; i != 0; i--)
        {
            ushorts |= *pus;
            *pus = ushorts;
            pus++;
        }
    }
    dwTimeReadWritesConsecutiveWords = GetTickCount() - dwStart;

#endif

    dwStart = GetTickCount();
    for (j = READ_ITERATIONS; j != 0; j--)
    {
        pul = pvBits;
        for (i = NUM_BYTES / 4; i != 0; i--)
        {
            ulongs |= *pul;
            *pul = ulongs;
            pul++;
        }
    }
    dwTimeReadWritesConsecutiveDwords = GetTickCount() - dwStart;

    //
    // Batched read/writes
    //

#if BYTE_OPS

    dwStart = GetTickCount();
    for (j = READ_ITERATIONS; j != 0; j--)
    {
        pj = pvBits;
        for (i = NUM_BYTES; i != 0; i--)
        {
            uchars |= *pj++;
        }
        pj = pvBits;
        for (i = NUM_BYTES; i != 0; i--)
        {
            *pj++ = (BYTE) i;
        }
    }
    dwTimeReadWritesBatchedBytes = GetTickCount() - dwStart;

    dwStart = GetTickCount();
    for (j = READ_ITERATIONS; j != 0; j--)
    {
        pus = pvBits;
        for (i = NUM_BYTES / 2; i != 0; i--)
        {
            ushorts |= *pus++;
        }
        pus = pvBits;
        for (i = NUM_BYTES / 2; i != 0; i--)
        {
            *pus++ = (USHORT) i;
        }
    }
    dwTimeReadWritesBatchedWords = GetTickCount() - dwStart;

#endif

    dwStart = GetTickCount();
    for (j = READ_ITERATIONS; j != 0; j--)
    {
        pul = pvBits;
        for (i = NUM_BYTES / 4; i != 0; i--)
        {
            ulongs |= *pul++;
        }
        pul = pvBits;
        for (i = NUM_BYTES / 4; i != 0; i--)
        {
            *pul++ = (ULONG) i;
        }
    }
    dwTimeReadWritesBatchedDwords = GetTickCount() - dwStart;

    //
    // Inplace writes...
    //

#if BYTE_OPS

    dwStart = GetTickCount();
    for (j = WRITE_ITERATIONS; j != 0; j--)
    {
        pj = pvBits;
        for (i = NUM_BYTES; i != 0; i--)
        {
            *pj = (BYTE) i;
        }
    }
    dwTimeWritesInplaceBytes = GetTickCount() - dwStart;

    dwStart = GetTickCount();
    for (j = WRITE_ITERATIONS; j != 0; j--)
    {
        pus = pvBits;
        for (i = NUM_BYTES / 2; i != 0; i--)
        {
            *pus = (USHORT) i;
        }
    }
    dwTimeWritesInplaceWords = GetTickCount() - dwStart;

#endif

    dwStart = GetTickCount();
    for (j = WRITE_ITERATIONS; j != 0; j--)
    {
        pul = pvBits;
        for (i = NUM_BYTES / 4; i != 0; i--)
        {
            *pul = (ULONG) i;
        }
    }
    dwTimeWritesInplaceDwords = GetTickCount() - dwStart;

    //
    // Inplace reads...
    //

#if BYTE_OPS

    dwStart = GetTickCount();
    for (j = READ_ITERATIONS; j != 0; j--)
    {
        pj = pvBits;
        for (i = NUM_BYTES; i != 0; i--)
        {
            uchars |= *pj;
        }
    }
    dwTimeReadsInplaceBytes = GetTickCount() - dwStart;

    dwStart = GetTickCount();
    for (j = READ_ITERATIONS; j != 0; j--)
    {
        pus = pvBits;
        for (i = NUM_BYTES / 2; i != 0; i--)
        {
            ushorts |= *pus;
        }
    }
    dwTimeReadsInplaceWords = GetTickCount() - dwStart;

#endif

    dwStart = GetTickCount();
    for (j = READ_ITERATIONS; j != 0; j--)
    {
        pul = pvBits;
        for (i = NUM_BYTES / 4; i != 0; i--)
        {
            ulongs |= *pul;
        }
    }
    dwTimeReadsInplaceDwords = GetTickCount() - dwStart;

    //
    // Random writes...
    //

#if BYTE_OPS

    dwStart = GetTickCount();
    for (j = WRITE_ITERATIONS; j != 0; j--)
    {
        pj = pvBits;
        for (i = NUM_BYTES; i != 0; i--)
        {
            *pj = (BYTE) i;
            pj += 64;
        }
    }
    dwTimeWritesRandomBytes = GetTickCount() - dwStart;

    dwStart = GetTickCount();
    for (j = WRITE_ITERATIONS; j != 0; j--)
    {
        pus = pvBits;
        for (i = NUM_BYTES / 2; i != 0; i--)
        {
            *pus = (USHORT) i;
            pus += 32;
        }
    }
    dwTimeWritesRandomWords = GetTickCount() - dwStart;

#endif

    dwStart = GetTickCount();
    for (j = WRITE_ITERATIONS; j != 0; j--)
    {
        pul = pvBits;
        for (i = NUM_BYTES / 4; i != 0; i--)
        {
            *pul = (ULONG) i;
            pul += 16;
        }
    }
    dwTimeWritesRandomDwords = GetTickCount() - dwStart;

    //
    // Random reads...
    //

#if BYTE_OPS

    dwStart = GetTickCount();
    for (j = READ_ITERATIONS; j != 0; j--)
    {
        pj = pvBits;
        for (i = NUM_BYTES; i != 0; i--)
        {
            uchars |= *pj;
            pj += 64;
        }
    }
    dwTimeReadsRandomBytes = GetTickCount() - dwStart;

    dwStart = GetTickCount();
    for (j = READ_ITERATIONS; j != 0; j--)
    {
        pus = pvBits;
        for (i = NUM_BYTES / 2; i != 0; i--)
        {
            ushorts |= *pus;
            pus += 32;
        }
    }
    dwTimeReadsRandomWords = GetTickCount() - dwStart;

#endif

    dwStart = GetTickCount();
    for (j = READ_ITERATIONS; j != 0; j--)
    {
        pul = pvBits;
        for (i = NUM_BYTES / 4; i != 0; i--)
        {
            ulongs |= *pul;
            pul += 16;
        }
    }
    dwTimeReadsRandomDwords = GetTickCount() - dwStart;

    //
    // Unaligned writes...
    //

#if BYTE_OPS

    dwStart = GetTickCount();
    for (j = WRITE_ITERATIONS; j != 0; j--)
    {
        pus = (USHORT*) ((BYTE*) pvBits + 1);
        for (i = NUM_BYTES / 2; i != 0; i--)
        {
            *pus++ = (USHORT) i;
        }
    }
    dwTimeWritesUnalignedWords = GetTickCount() - dwStart;

#endif

    dwStart = GetTickCount();
    for (j = WRITE_ITERATIONS; j != 0; j--)
    {
        pul = (ULONG*) ((BYTE*) pvBits + 1);
        for (i = NUM_BYTES / 4; i != 0; i--)
        {
            *pul++ = (ULONG) i;
        }
    }
    dwTimeWritesUnalignedDwords = GetTickCount() - dwStart;

    //
    // Unaligned reads...
    //

#if BYTE_OPS

    dwStart = GetTickCount();
    for (j = READ_ITERATIONS; j != 0; j--)
    {
        pus = (USHORT*) ((BYTE*) pvBits + 1);
        for (i = NUM_BYTES / 2; i != 0; i--)
        {
            ushorts |= *pus++;
        }
    }
    dwTimeReadsUnalignedWords = GetTickCount() - dwStart;

#endif

    dwStart = GetTickCount();
    for (j = READ_ITERATIONS; j != 0; j--)
    {
        pul = (ULONG*) ((BYTE*) pvBits + 1);
        for (i = NUM_BYTES / 4; i != 0; i--)
        {
            ulongs |= *pul++;
        }
    }
    dwTimeReadsUnalignedDwords = GetTickCount() - dwStart;

    lpSurface->lpVtbl->Unlock(lpSurface, ddsd.lpSurface);

    printf("Regular\n  Consecutive Writes: \t%2.2f, %2.2f, %2.2f\n  Consecutive Reads: \t%2.2f, %2.2f, %2.2f\n  Reads/writes: \t%2.2f, %2.2f, %2.2f\n  Batched reads/writes:\t%2.2f, %2.2f, %2.2f\n  Inplace Writes: \t%2.2f, %2.2f, %2.2f\n  Inplace Reads: \t%2.2f, %2.2f, %2.2f\n  Random Writes: \t%2.2f, %2.2f, %2.2f\n  Random Reads: \t%2.2f, %2.2f, %2.2f\n  Unaligned Writes: \t-, %2.2f, %2.2f\n  Unaligned Reads: \t-, %2.2f, %2.2f\n", 
        WRITE_MEGS / (FLOAT) dwTimeWritesConsecutiveBytes,
        WRITE_MEGS / (FLOAT) dwTimeWritesConsecutiveWords,
        WRITE_MEGS / (FLOAT) dwTimeWritesConsecutiveDwords,
        READ_MEGS / (FLOAT) dwTimeReadsConsecutiveBytes,
        READ_MEGS / (FLOAT) dwTimeReadsConsecutiveWords,
        READ_MEGS / (FLOAT) dwTimeReadsConsecutiveDwords,
        READ_MEGS / (FLOAT) dwTimeReadWritesConsecutiveBytes,
        READ_MEGS / (FLOAT) dwTimeReadWritesConsecutiveWords,
        READ_MEGS / (FLOAT) dwTimeReadWritesConsecutiveDwords,
        READ_MEGS / (FLOAT) dwTimeReadWritesBatchedBytes,
        READ_MEGS / (FLOAT) dwTimeReadWritesBatchedWords,
        READ_MEGS / (FLOAT) dwTimeReadWritesBatchedDwords,
        WRITE_MEGS / (FLOAT) dwTimeWritesInplaceBytes,
        WRITE_MEGS / (FLOAT) dwTimeWritesInplaceWords,
        WRITE_MEGS / (FLOAT) dwTimeWritesInplaceDwords,
        READ_MEGS / (FLOAT) dwTimeReadsInplaceBytes,
        READ_MEGS / (FLOAT) dwTimeReadsInplaceWords,
        READ_MEGS / (FLOAT) dwTimeReadsInplaceDwords,
        WRITE_MEGS / (FLOAT) dwTimeWritesRandomBytes,
        WRITE_MEGS / (FLOAT) dwTimeWritesRandomWords,
        WRITE_MEGS / (FLOAT) dwTimeWritesRandomDwords,
        READ_MEGS / (FLOAT) dwTimeReadsRandomBytes,
        READ_MEGS / (FLOAT) dwTimeReadsRandomWords,
        READ_MEGS / (FLOAT) dwTimeReadsRandomDwords,
        WRITE_MEGS / (FLOAT) dwTimeWritesUnalignedWords,
        WRITE_MEGS / (FLOAT) dwTimeWritesUnalignedDwords,
        READ_MEGS / (FLOAT) dwTimeReadsUnalignedWords,
        READ_MEGS / (FLOAT) dwTimeReadsUnalignedDwords);
}

/******************************Public*Routine******************************\
* vTestMmx
*
* Test MMX instructions
*
\**************************************************************************/

VOID vTestMmx(
    PVOID pvBits
    )
{

#if defined(_X86_)

    DWORD   dwStart;
    DWORD   dwTimeWritesMmxQwords = LONG_MIN;
    DWORD   dwTimeReadsMmxQwords = LONG_MIN;
    DWORD   dwTimeUnalignedWritesMmxQwords = LONG_MIN;
    DWORD   dwTimeUnalignedReadsMmxQwords = LONG_MIN;
    DWORD   dwTimeRandomWritesMmxQwords = LONG_MIN;
    DWORD   dwTimeRandomReadsMmxQwords = LONG_MIN;
    
    if (!IsProcessorFeaturePresent(PF_MMX_INSTRUCTIONS_AVAILABLE))
    {
        printf("MMX not detected.\n");
    }
    else
    {
        //
        // Mmx writes...
        //
    
        dwStart = GetTickCount();
        _asm {
            mov     eax, WRITE_ITERATIONS
        MmxOuterWrite:
            mov     ecx, (NUM_BYTES / 8)
            mov     edi, pvBits
        MmxInnerWrite:
            movq    [edi], mm0
            add     edi,8
            dec     ecx
            jnz     MmxInnerWrite
            dec     eax
            jnz     MmxOuterWrite
            emms
        }
        dwTimeWritesMmxQwords = GetTickCount() - dwStart;
    
        //
        // Mmx reads...
        //
    
        dwStart = GetTickCount();
        _asm {
            mov     eax, READ_ITERATIONS
        MmxOuterRead:
            mov     ecx, (NUM_BYTES / 8)
            mov     edi, pvBits
        MmxInnerRead:
            movq    mm0, [edi]
            add     edi,8
            dec     ecx
            jnz     MmxInnerRead
            dec     eax
            jnz     MmxOuterRead
            emms
        }
        dwTimeReadsMmxQwords = GetTickCount() - dwStart;
    
        //
        // Mmx unaligned writes...
        //
    
        dwStart = GetTickCount();
        _asm {
            mov     eax, WRITE_ITERATIONS
        MmxUnalignedOuterWrite:
            mov     ecx, (NUM_BYTES / 8)
            mov     edi, pvBits
            inc     edi
        MmxUnalignedInnerWrite:
            movq    [edi], mm0
            add     edi,8
            dec     ecx
            jnz     MmxUnalignedInnerWrite
            dec     eax
            jnz     MmxUnalignedOuterWrite
            emms
        }
        dwTimeUnalignedWritesMmxQwords = GetTickCount() - dwStart;
    
        //
        // Mmx unaligned reads...
        //
    
        dwStart = GetTickCount();
        _asm {
            mov     eax, READ_ITERATIONS
        MmxUnalignedOuterRead:
            mov     ecx, (NUM_BYTES / 8)
            mov     edi, pvBits
            inc     edi
        MmxUnalignedInnerRead:
            movq    mm0, [edi]
            add     edi,8
            dec     ecx
            jnz     MmxUnalignedInnerRead
            dec     eax
            jnz     MmxUnalignedOuterRead
            emms
        }

        dwTimeUnalignedReadsMmxQwords = GetTickCount() - dwStart;
    
        //
        // Mmx random writes...
        //
    
        dwStart = GetTickCount();
        _asm {
            mov     eax, WRITE_ITERATIONS
        MmxRandomOuterWrite:
            mov     ecx, (NUM_BYTES / 8)
            mov     edi, pvBits
        MmxRandomInnerWrite:
            movq    [edi], mm0
            add     edi,64
            dec     ecx
            jnz     MmxRandomInnerWrite
            dec     eax
            jnz     MmxRandomOuterWrite
            emms
        }
        dwTimeRandomWritesMmxQwords = GetTickCount() - dwStart;
    
        //
        // Mmx random reads...
        //
    
        dwStart = GetTickCount();
        _asm {
            mov     eax, READ_ITERATIONS
        MmxRandomOuterRead:
            mov     ecx, (NUM_BYTES / 8)
            mov     edi, pvBits
        MmxRandomInnerRead:
            movq    mm0, [edi]
            add     edi,64
            dec     ecx
            jnz     MmxRandomInnerRead
            dec     eax
            jnz     MmxRandomOuterRead
            emms
        }
        dwTimeRandomReadsMmxQwords = GetTickCount() - dwStart;

        printf("MMX\n  Consecutive Writes: \t%2.2f\n  Consecutive Reads: \t%2.2f\n  Unaligned Writes: \t%2.2f\n  Unaligned Reads: \t%2.2f\n  Random Writes: \t%2.2f\n  Random Reads: \t%2.2f\n",
            WRITE_MEGS / (FLOAT) dwTimeWritesMmxQwords,
            READ_MEGS / (FLOAT) dwTimeReadsMmxQwords,
            WRITE_MEGS / (FLOAT) dwTimeUnalignedWritesMmxQwords,
            READ_MEGS / (FLOAT) dwTimeUnalignedReadsMmxQwords,
            WRITE_MEGS / (FLOAT) dwTimeRandomWritesMmxQwords,
            READ_MEGS / (FLOAT) dwTimeRandomReadsMmxQwords);
    }

#endif

}

/******************************Public*Routine******************************\
* vTestKni
*
* Test Kni instructions
*
\**************************************************************************/

VOID vTestKni(
    PVOID pvBits
    )
{
    DWORD dwStart;
    DWORD dwTime;

#if defined(_X86_)

    if (!IsProcessorFeaturePresent(PF_XMMI_INSTRUCTIONS_AVAILABLE))
    {
        printf("SIMD instructions not detected.\n");
    }
    else
    {
        printf("SIMD\n");

        dwStart = GetTickCount();
        KniNt128Write(pvBits);
        dwTime = GetTickCount() - dwStart;

        printf("  128-bit NT writes: \t%2.2f\n", WRITE_MEGS / (FLOAT) dwTime);

        dwStart = GetTickCount();
        Kni128Read(pvBits);
        dwTime = GetTickCount() - dwStart;

        printf("  128-bit reads: \t%2.2f\n", READ_MEGS / (FLOAT) dwTime);

#if 0
    
        //
        // 64-bit non-temporal writes...
        //
    
        dwStart = GetTickCount();
        _asm {
            mov     eax, WRITE_ITERATIONS
        Kni64NtOuterWrite:
            mov     ecx, (NUM_BYTES / 8)
            mov     edi, pvBits
        Kni64NtInnerWrite:
            asdfasdf [edi], mm0

            // movntq  [edi], mm0
            add     edi,8
            dec     ecx
            jnz     Kni64NtInnerWrite
            dec     eax
            sfence
            jnz     Kni64NtOuterWrite
            emms
        }
        dwTime = GetTickCount() - dwStart;

        printf("  64-bit non-temporal writes: \t%2.2f\n", WRITE_MEGS / (FLOAT) dwTime);
    
        //
        // 128-bit non-temporal writes...
        //
    
        dwStart = GetTickCount();
        _asm {
            mov     eax, WRITE_ITERATIONS
        Kni128NtOuterWrite:
            mov     ecx, (NUM_BYTES / 16)
            mov     edi, pvBits
        Kni128NtInnerWrite:
            movntps [edi], xmm0
            add     edi,16
            dec     ecx
            jnz     Kni128NtInnerWrite
            dec     eax
            sfence
            jnz     Kni128NtOuterWrite
            emms
        }
        dwTime = GetTickCount() - dwStart;

        printf("  128-bit non-temporal writes: \t%2.2f\n", WRITE_MEGS / (FLOAT) dwTime);
    
        //
        // 128-bit normal writes...
        //
    
        dwStart = GetTickCount();
        _asm {
            mov     eax, WRITE_ITERATIONS
        Kni128OuterWrite:
            mov     ecx, (NUM_BYTES / 16)
            mov     edi, pvBits
        Kni128InnerWrite:
            movps   [edi], xmm0
            add     edi,16
            dec     ecx
            jnz     Kni128InnerWrite
            dec     eax
            sfence
            jnz     Kni128OuterWrite
            emms
        }
        dwTime = GetTickCount() - dwStart;

        printf("  128-bit normal writes: \t%2.2f\n", WRITE_MEGS / (FLOAT) dwTime);
    
        //
        // 128-bit normal reads...
        //
    
        dwStart = GetTickCount();
        _asm {
            mov     eax, READ_ITERATIONS
        Kni128OuterRead:
            mov     ecx, (NUM_BYTES / 16)
            mov     edi, pvBits
        Kni128InnerRead:
            movps   [edi], xmm0
            add     edi,16
            dec     ecx
            jnz     Kni128InnerRead
            dec     eax
            sfence
            jnz     Kni128OuterRead
            emms
        }
        dwTime = GetTickCount() - dwStart;

        printf("  128-bit normal reads: \t%2.2f\n", READ_MEGS / (FLOAT) dwTime);

        //
        // 32-bit reads with prefetch...
        //

        dwStart = GetTickCount();
        for (j = READ_ITERATIONS; j != 0; j--)
        {
            pul = pvBits;
            for (i = NUM_BYTES / 4; i != 0; i--)
            {
                ulongs |= *pul++;
            }
        }
        dwTime = GetTickCount() - dwStart;

        printf("  32-bit reads with prefetch: \t%2.2f\n", READ_MEGS / (FLOAT) dwTime);
    
#endif
    }

#endif

}

/******************************Public*Routine******************************\
* vTest
*
* This is the workhorse routine that does the test. The test is
* started by chosing it from the window menu.
*
* History:
*  Tue 08-Dec-1992 17:31:22 by Kirk Olynyk [kirko]
* Wrote it.
\**************************************************************************/


void
vTest(
    HWND hwnd
    )
{
    HDC     hdcScreen;
    VOID*   pvBits;
    ULONG   i;
    ULONG   j;
    ULONG   ul;
    volatile BYTE*   pj;
    volatile USHORT* pus;
    volatile ULONG*  pul;
    DWORD   dwStart;
    DWORD   dwTime;
    RECT    rect;

    if (lpSurface == NULL)
    {
        memset(&ddsd, 0, sizeof(ddsd));
        ddsd.dwSize = sizeof(ddsd);
        ddsd.ddsCaps.dwCaps = DDSCAPS_PRIMARYSURFACE;

        if ((DirectDrawCreate(NULL, &lpDD, NULL) != DD_OK) ||
            (lpDD->lpVtbl->SetCooperativeLevel(lpDD, hwnd, DDSCL_NORMAL) != DD_OK) ||
            (lpDD->lpVtbl->CreateSurface(lpDD, &ddsd, &lpSurface, NULL) != DD_OK))
        {
            MessageBox(0, "Initialization failure", "Uh oh", MB_OK);
            return;
        }
    }

    rect.left = 0;
    rect.top  = 0;
    rect.right  = 0;
    rect.bottom = 0;

    if (lpSurface->lpVtbl->Lock(lpSurface, &rect, &ddsd, DDLOCK_WAIT, NULL) != DD_OK)
    {
        if (!gbWarned)
        {
            MessageBox(0, "Driver not DirectDraw accelerated", "Uh oh", MB_OK);
        }

        return;
    }

    printf("Frame buffer performance test started.  Expect to see garbage at\n");
    printf("the top of your screen...\n\n");

    pvBits = ddsd.lpSurface;

    vTestRegular(pvBits);
    vTestMmx(pvBits);
    vTestKni(pvBits);

    lpSurface->lpVtbl->Unlock(lpSurface, ddsd.lpSurface);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\dlltest\wndstuff.h ===
/****************************** Module Header ******************************\
* Module Name: wndstuff.h
*
* Kent's Window Test.  To be used as a program template.
*
* Created: 09-May-91
* Author: KentD
*
* Copyright (c) 1991 Microsoft Corporation
\***************************************************************************/

#define DONTUSE(x) (x)

#define MM_NEW          0x8001
#define MM_EXIT         0x8002
#define MM_TEST         0x8003

#define IDB_BITMAPCMYKTEST  0x9001

VOID Test(HWND);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\dlltest\debug.h ===
/******************************Module*Header*******************************\
* Module Name: debug.h
*
* Copyright (c) 1999 Microsoft Corporation
*
\**************************************************************************/

extern void LBprintf(PCH, ...);
extern void LBreset(void);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\dciperf\wndstuff.h ===
/****************************** Module Header ******************************\
* Module Name: hello.h
*
* Kent's Window Test.  To be used as a program template.
*
* Created: 09-May-91
* Author: KentD
*
* Copyright (c) 1991 Microsoft Corporation
\***************************************************************************/

#define DONTUSE(x) (x)

#define MM_NEW          0x8001
#define MM_EXIT         0x8002
#define MM_TEST         0x8003

BOOL bInitApp(VOID);
VOID vTest(HWND);
LRESULT lMainWindowProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);

#define MY_WINDOWSTYLE_FLAGS       \
            (                      \
                WS_OVERLAPPED   |  \
                WS_CAPTION      |  \
                WS_BORDER       |  \
                WS_THICKFRAME   |  \
                WS_MAXIMIZEBOX  |  \
                WS_MINIMIZEBOX  |  \
                WS_CLIPCHILDREN |  \
                WS_VISIBLE      |  \
                WS_SYSMENU         \
            )
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\dciperf\wndstuff.c ===
/******************************Module*Header*******************************\
* Module Name: wndstuff.c
*
* This file contains the code to support a simple window that has
* a menu with a single item called "Test". When "Test" is selected
* vTest(HWND) is called.
*
* Created: 09-Dec-1992 10:44:31
* Author: Kirk Olynyk [kirko]
*
* Copyright (c) 1991 Microsoft Corporation
*
\**************************************************************************/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include "wndstuff.h"

HANDLE  ghInstance;
HWND    ghwndMain;
HBRUSH  ghbrWhite;

/***************************************************************************\
* main(argc, argv[])
*
* Sets up the message loop.
*
* History:
*  04-07-91 -by- KentD
* Wrote it.
\***************************************************************************/

_cdecl
main(
    INT   argc,
    PCHAR argv[])
{
    MSG    msg;
    HANDLE haccel;

    DONTUSE(argc);
    DONTUSE(argv);

    ghInstance = GetModuleHandle(NULL);

    if (!bInitApp())
    {
        return(0);
    }

    haccel = LoadAccelerators(ghInstance, MAKEINTRESOURCE(1));
    while (GetMessage(&msg, NULL, 0, 0))
    {
        if (!TranslateAccelerator(msg.hwnd, haccel, &msg))
        {
             TranslateMessage(&msg);
             DispatchMessage(&msg);
        }
    }
    return(1);
}

/***************************************************************************\
* bInitApp()
*
* Initializes app.
*
* History:
*  04-07-91 -by- KentD
* Wrote it.
\***************************************************************************/

BOOL bInitApp(VOID)
{
    WNDCLASS wc;

    ghbrWhite = CreateSolidBrush(RGB(0xFF,0xFF,0xFF));

    wc.style            = 0;
    wc.lpfnWndProc      = lMainWindowProc;
    wc.cbClsExtra       = 0;
    wc.cbWndExtra       = 0;
    wc.hInstance        = ghInstance;
    wc.hIcon            = LoadIcon(NULL, IDI_APPLICATION);
    wc.hCursor          = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground    = ghbrWhite;
    wc.lpszMenuName     = "MainMenu";
    wc.lpszClassName    = "TestClass";
    if (!RegisterClass(&wc))
    {
        return(FALSE);
    }
    ghwndMain =
      CreateWindowEx(
        0,
        "TestClass",
        "Win32 Test",
        MY_WINDOWSTYLE_FLAGS,
        80,
        70,
        400,
        300,
        NULL,
        NULL,
        ghInstance,
        NULL
        );
    if (ghwndMain == NULL)
    {
        return(FALSE);
    }
    SetFocus(ghwndMain);
    return(TRUE);
}

/***************************************************************************\
* lMainWindowProc(hwnd, message, wParam, lParam)
*
* Processes all messages for the main window.
*
* History:
*  04-07-91 -by- KentD
* Wrote it.
\***************************************************************************/

BOOL gbOn = FALSE;
POINTL ptlWindow;
SIZEL sizlWindow;

LRESULT
lMainWindowProc(
    HWND    hwnd,
    UINT    message,
    WPARAM  wParam,
    LPARAM  lParam
    )
{
    switch (message)
    {
    case WM_CREATE:

        vTest(hwnd);
        PostQuitMessage(0);
        return(DefWindowProc(hwnd, message, wParam, lParam));

    case WM_DESTROY:

        DeleteObject(ghbrWhite);
        PostQuitMessage(0);
        return(DefWindowProc(hwnd, message, wParam, lParam));

    default:

        return(DefWindowProc(hwnd, message, wParam, lParam));
    }
    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\dciperf\i386\kni.asm ===
title  "KNI Performance Test"
;++
;
; Copyright (c) 1998  Microsoft Corporation
;
; Module Name:
;
;    kni.asm
;
; Abstract:
;
;    Test KNI performance for video memory.  Based on PeterJ's zero.asm.
;
; Environment:
;
;    x86
;
; Revision History:
;
;--

.386p
        .xlist
include ks386.inc
include callconv.inc
        .list

;
; Register Definitions (for instruction macros).
;

rEAX            equ     0
rECX            equ     1
rEDX            equ     2
rEBX            equ     3
rESP            equ     4
rEBP            equ     5
rESI            equ     6
rEDI            equ     7

;
; Define SIMD instructions used in this module.
;

if 0

; these remain for reference only.   In theory the stuff following
; should generate the right code.

xorps_xmm0_xmm0 macro
                db      0FH, 057H, 0C0H
                endm

movntps_edx     macro   Offset
                db      0FH, 02BH, 042H, Offset
                endm

movaps_esp_xmm0 macro
                db      0FH, 029H, 004H, 024H
                endm

movaps_xmm0_esp macro
                db      0FH, 028H, 004H, 024H
                endm

endif

xorps           macro   XMMReg1, XMMReg2
                db      0FH, 057H, 0C0H + (XMMReg1 * 8) + XMMReg2
                endm

movntps         macro   GeneralReg, Offset, XMMReg
                db      0FH, 02BH, 040H + (XmmReg * 8) + GeneralReg, Offset
                endm
                
movaps_toreg    macro   GeneralReg, Offset, XMMReg
                db      0Fh, 028H, 040H + (XmmReg * 8) + GeneralReg, Offset
                endm
                
emms            macro
                db      0FH, 077H
                endm
                
sfence          macro
                db      0FH, 0AEH, 0F8H
                endm

movaps_load     macro   XMMReg, GeneralReg
                db      0FH, 028H, (XMMReg * 8) + 4, (4 * 8) + GeneralReg
                endm

movaps_store    macro   GeneralReg, XMMReg
                db      0FH, 029H, (XMMReg * 8) + 4, (4 * 8) + GeneralReg
                endm


;
; NPX Save and Restore
;

fxsave          macro   Register
                db      0FH, 0AEH, Register
                endm

fxrstor         macro   Register
                db      0FH, 0AEH, 8+Register
                endm

;
; Test constants
;

WRITE_ITERATIONS        equ     10000
READ_ITERATIONS         equ     1000
NUM_BYTES               equ     (8 * 1024)


_TEXT   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

;++
;
; KniNt128Write(
;     PVOID Address
;     )
;
; Routine Description:
;
;     64-bit non-temporal writes...
;
; Arguments:
;
;     (ecx) Address    Address to be written to
;
; Return Value:
;
;     None.
;
;--

cPublicFastCall KniNt128Write,1
cPublicFpo 0, 0

        push    edi
        mov     eax, WRITE_ITERATIONS
        
KniNt128WriteOuter::
        mov     edx, (NUM_BYTES / 16)
        mov     edi, ecx
        
KniNt128WriteInner::
        movntps rEDI, 0, 0                      ; store xmm0 at [edi]
        add     edi, 16
        dec     edx
        jnz     KniNt128WriteInner
        dec     eax
        sfence
        jnz     KniNt128WriteOuter
        emms

        pop     edi                             ; restore edi and return
        fstRET  KniNt128Write

fstENDP KniNt128Write

cPublicFastCall Kni128Read,1
cPublicFpo 0, 0

        push    edi
        mov     eax, READ_ITERATIONS
        
Kni128ReadOuter::
        mov     edx, (NUM_BYTES / 16)
        mov     edi, ecx
        
Kni128ReadInner::
        movaps_toreg rEDI, 0, 0                 ; read xmm0 from [edi]
        add     edi, 16
        dec     edx
        jnz     Kni128ReadInner
        dec     eax
        jnz     Kni128ReadOuter

        pop     edi                             ; restore edi and return
        fstRET  Kni128Read

fstENDP Kni128Read

_TEXT   ends
        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\dlltest\dlltest.cpp ===
/******************************Module*Header*******************************\
* Module Name: test.c
*
* Created: 09-Dec-1992 10:51:46          
* Author: Kirk Olynyk [kirko]
*
* Copyright (c) 1991 Microsoft Corporation
*
* Contains the test
*
\**************************************************************************/

#include <windows.h>
#include <objbase.h>
#include <math.h>             // sin & cos
#include "wndstuff.h"
#include "debug.h"

//
// Where is IStream included from?
//

#define IStream int

#include <gdiplus.h>

using namespace Gdiplus;

#ifndef ASSERT
    #define ASSERT(cond)    if (!(cond)) { DebugBreak(); }
#endif

/******************************Public*Routine******************************\
* vTest
*
* This is the workhorse routine that does the test. The test is
* started by chosing it from the window menu.
*
* History:
*  Tue 08-Dec-1992 17:31:22 by Kirk Olynyk [kirko]
* Wrote it.
\**************************************************************************/

class RectI
{
public:
    INT X;
    INT Y;
    INT Width;
    INT Height;
};

VOID TestRotatedLine(Graphics *g);
VOID TestLineWithTexture(Graphics *g);
VOID TestRegionExcludeClip(Graphics *g);
VOID TestRegionXorClip(Graphics *g);
VOID TestContainerClip(Graphics *g);
VOID TestContainer(Graphics *g);
VOID TestPolygons(Graphics *g);
VOID TestPaths(Graphics *g);
VOID TestPathIterators(Graphics *g);
VOID TestDashes(Graphics *g);
VOID TestWideningAndWarping(Graphics *g);
VOID TestRegions(Graphics *g);
VOID TestGradients(Graphics* g);
VOID TestHatches(Graphics* g);
VOID TestBitmaps(Graphics* g);
VOID TestPrimitives(Graphics *g);
VOID TestMixedObjects(Graphics *g);
VOID TestTexts(Graphics* g);
VOID TestTextAlongPath(Graphics *g);
VOID TestDerive(HWND hwnd);
VOID TestImaging(Graphics* g);
VOID TestBitmapGraphics(Graphics* g);
VOID TestDibsection(Graphics* g);
VOID TestCompoundLines(Graphics *g);
VOID TestImageSampling(Graphics *g);
VOID TestIcon(Graphics *g);

VOID TestWmfs(Graphics *g);
VOID TestMetaGetDC(Graphics *g, HWND hwnd);
VOID TestMetafileEnumeration(Graphics *g);
VOID TestMetafileTextureBrush(Graphics *g);
VOID TestGetHemf(HDC hdc);
VOID TestLargeMetafileObject(Graphics* g, HDC hdc);
VOID TestTextToMetafile(Graphics *g, HDC hdc);
VOID TestCmykSeparation(Graphics *g);
VOID TestDownLevelBitmapTransparency(Graphics *g, HDC hdc);
VOID DrawHatches(Graphics * g);


VOID
Test(
    HWND hwnd
    )
{
    HDC hdc = GetDC(hwnd);

    // Select in the halftone palette for 256-color display mode testing
    HPALETTE hpal = Graphics::GetHalftonePalette();
    SelectPalette(hdc, hpal, FALSE);
    RealizePalette(hdc);

    Graphics *g = new Graphics(hdc);

    TestMetaGetDC(g, hwnd); // this has to be the first test!

    // Test GetNearestColor
    Color c(0x32, 0x67, 0x98);
    g->GetNearestColor(&c);

    TestDownLevelBitmapTransparency(g, hdc);
    TestTextToMetafile(g, hdc);
    TestLargeMetafileObject(g, hdc);
    TestGetHemf(hdc);
    TestMetafileEnumeration(g);
    TestMetafileTextureBrush(g);
    TestRotatedLine(g);
    TestWmfs(g);

    g->SetSmoothingMode(SmoothingModeAntiAlias);

    // Scale everything up by scale
    REAL scale = (REAL) 1.2;
    g->SetPageUnit(UnitDisplay);
    g->SetPageScale(scale);
    g->RotateTransform(10);

    {
        HDC     hdc = GetDC(hwnd);
        {
            Metafile recording(L"TestEmfP.Emf", hdc);
            Graphics gMeta(&recording);

            gMeta.SetSmoothingMode(SmoothingModeAntiAlias);
            TestRegionExcludeClip(&gMeta);
            TestRegionXorClip(&gMeta);
            TestBitmaps(&gMeta);
            gMeta.RotateTransform(30);
            gMeta.SetSmoothingMode(SmoothingModeAntiAlias);
            TestContainer(&gMeta);
        }

        {
            Metafile playback(L"TestEmfP.Emf");
            g->DrawImage(&playback, 0, 0);
        }
        ReleaseDC(hwnd, hdc);
    }

    TestContainerClip(g);
    TestPolygons(g);
//    TestPaths(g);
    TestPathIterators(g);   // Identical to TestPaths except for using iterators.
    TestRegions(g);
    TestBitmaps(g);
    TestPrimitives(g);
    TestMixedObjects(g);
    TestGradients(g);
    TestHatches(g);
    TestTexts(g);
    TestDerive(hwnd);
    TestDashes(g);
    TestWideningAndWarping(g);
    TestImaging(g);
    TestBitmapGraphics(g);
    TestLineWithTexture(g);
    TestDibsection(g);
    TestCompoundLines(g);
    TestImageSampling(g);
    TestIcon(g);
    TestCmykSeparation(g);
    DrawHatches(g);

    {
        Metafile recordDown(L"Hatches.emf", hdc, EmfTypeEmfOnly);
        {
            Graphics    gMeta(&recordDown);
            
            DrawHatches(&gMeta);
        }
        g->DrawImage(&recordDown, 330, 0);
    }

    delete g;
    ReleaseDC(hwnd, hdc);
    DeleteObject(hpal);
}

VOID DrawHatches(Graphics * g)
{
    HatchBrush  h1 (HatchStyleHorizontal, Color(255, 0, 0), Color(0, 255, 255));
    HatchBrush  h2 (HatchStyleVertical, Color(255, 0, 0), Color(0, 255, 255));
    HatchBrush  h3 (HatchStyleForwardDiagonal, Color(255, 0, 0), Color(0, 255, 255));
    HatchBrush  h4 (HatchStyleBackwardDiagonal, Color(255, 0, 0), Color(0, 255, 255));
    HatchBrush  h5 (HatchStyleCross, Color(255, 0, 0), Color(0, 255, 255));
    HatchBrush  h6 (HatchStyleDiagonalCross, Color(255, 0, 0), Color(0, 255, 255));

    g->FillEllipse(&h1, 0, 0, 100, 100);
    g->FillEllipse(&h2, 110, 0, 100, 100);
    g->FillEllipse(&h3, 220, 0, 100, 100);
    g->FillEllipse(&h4, 0, 110, 100, 100);
    g->FillEllipse(&h5, 110, 110, 100, 100);
    g->FillEllipse(&h6, 220, 110, 100, 100);
}

VOID TestDownLevelBitmapTransparency(Graphics *g, HDC hdc)
{
    Metafile recordDown(L"DownLevelBm.emf", hdc, EmfTypeEmfOnly);
    {
        Graphics    gMeta(&recordDown);
        Bitmap      bm(50, 50, PixelFormat32bppARGB);
        {
            Graphics    gBitmap(&bm);
            gBitmap.Clear(Color(128, 255, 0, 0));
        }

        GraphicsPath    path;
    
        Rect    r(0,0,50,50);
        path.AddRectangle(r);
        SolidBrush  sb(Color(0, 0xFF, 0));
    
        gMeta.FillPath(&sb, &path);
        gMeta.DrawImage(&bm, 25, 25);
    }
    g->DrawImage(&recordDown, 200, 200);
}

VOID TestLargeMetafileObject(Graphics* g, HDC hdc)
{
    Metafile recording(L"Large.emf", hdc);
    {
        Image image(L"..\\data\\real3.jpg");
        TextureBrush textureBrush(&image, WrapModeTile);
        Matrix matrix;
        matrix.Scale(.2f, .2f);
        textureBrush.SetTransform(&matrix);
        Graphics gMeta(&recording);
        gMeta.FillRectangle(&textureBrush, 0, 0, 800, 600);
        Pen pen(&textureBrush, 40.0);
        pen.SetLineJoin(LineJoinMiter);
        PointF  spiralPoints[12] = {
            PointF(540.0f, 550.0f),
            PointF(540.0f,  75.0f),
            PointF( 60.0f,  75.0f),
            PointF( 60.0f, 460.0f),
            PointF(460.0f, 460.0f),
            PointF(460.0f, 140.0f),
            PointF(140.0f, 140.0f),
            PointF(140.0f, 400.0f),
            PointF(380.0f, 400.0f),
            PointF(380.0f, 190.0f),
            PointF(260.0f, 190.0f),
            PointF(260.0f, 350.0f),
            };

         gMeta.DrawLines(&pen, spiralPoints, 12);
    }
    g->DrawImage(&recording, 20, 300, 600, 400);
}

VOID TestGetHemf(HDC hdc)
{
    Metafile recording(L"Abcdefg.Emf", hdc);
    {
        Graphics gMeta(&recording);
        SolidBrush  sb(Color(0xFF, 0, 0));
        gMeta.FillRectangle(&sb, 0, 0, 20, 20);
    }
    HENHMETAFILE    hemf;
    hemf = recording.GetHENHMETAFILE();
    DeleteEnhMetaFile(hemf);
}

VOID TestMetafileTextureBrush(Graphics *g)
{
    Metafile m1(L"..\\data\\agree.emf");
    Rect r(0, 0, 50, 50);
    TextureBrush textureBrush(&m1, WrapModeTile, r);
    g->FillRectangle(&textureBrush, 0, 0, 800, 800);
}

extern "C"
BOOL CALLBACK
MyPlayMetafileRecordCallback(
    EmfPlusRecordType       recordType,
    UINT                    recordFlags,
    UINT                    recordDataSize,
    const BYTE *            recordData,
    VOID *                  callbackData
    )
{
    ((Metafile *)callbackData)->PlayRecord(recordType, recordFlags, recordDataSize, recordData);
    return TRUE;
}

VOID TestMetafileEnumeration(Graphics *g)
{
    Metafile m1(L"..\\data\\agree.emf");
    g->EnumerateMetafile(&m1, Rect(50, 10, 800, 500), MyPlayMetafileRecordCallback, &m1);

    Metafile m2(L"..\\data\\tiger.wmf");
    g->EnumerateMetafile(&m2, Rect(50, 10, 800, 500), MyPlayMetafileRecordCallback, &m2);
}

VOID DrawContainer(Graphics * g, ARGB * argb, INT count)
{
    Matrix    mymatrix;
    g->SetPageUnit(UnitInch);

    RectF clipRect(0,0,5,5);
    g->SetClip(clipRect);

    mymatrix.Translate(2.5, 2.5);
    mymatrix.Rotate(15);
    mymatrix.Translate(-2.5, -2.5);
    g->SetTransform(&mymatrix);

    Color   color(*argb++);
    SolidBrush contBrush(color);
    g->FillRectangle(&contBrush, 0, 0, 5, 5);
    if (--count == 0)
    {
        return;
    }
    RectF     destRect(.5, .5, 4, 4);
    RectF     srcRect(0, 0, 5, 5);
    INT id = g->BeginContainer(destRect, srcRect, UnitInch);
    g->ResetClip();
    DrawContainer (g, argb, count);
    g->EndContainer(id);
}

VOID TestContainerClip(Graphics *g)
{
    ARGB     colors[5];

    colors[0] = Color::MakeARGB(255, 255, 0, 0);
    colors[1] = Color::MakeARGB(255, 0, 255, 0);
    colors[2] = Color::MakeARGB(255, 0, 0, 255);
    colors[3] = Color::MakeARGB(255, 255, 255, 0);
    colors[4] = Color::MakeARGB(255, 0, 255, 255);

    GraphicsState s = g->Save();
    DrawContainer(g, colors, 5);
    g->Restore(s);
}

GraphicsPath      circlePath;
RectF        circleRect(0,0,4,4);
BOOL              circleInitialized = FALSE;

#define ROOT    0
#define LEFT    1
#define RIGHT   2
#define TOP     3
#define BOTTOM  4



VOID DrawFractal(Graphics * g, BYTE gray, INT side, INT count)
{
    ARGB        argb;

    switch (count % 3)
    {
    case 0:
        argb = Color::MakeARGB(255, 0, 0, gray);
        break;
    case 1:
        argb = Color::MakeARGB(255, 0, gray, 0);
        break;
    case 2:
        argb = Color::MakeARGB(255, gray, 0, 0);
        gray -= 60;
        break;
    }
    Color   color(argb);
    SolidBrush contBrush(color);
    g->SetPageUnit(UnitInch);
    g->FillPath(&contBrush, &circlePath);

    if (--count == 0)
    {
        return;
    }

    RectF               destRect;
    GraphicsContainer   cstate;

    if (side != LEFT)
    {
        destRect = RectF(4, 1, 2, 2);
        cstate = g->BeginContainer(destRect, circleRect, UnitInch);
        g->SetSmoothingMode(SmoothingModeAntiAlias);
        DrawFractal(g, gray, RIGHT, count);
        g->EndContainer(cstate);
    }
    if (side != TOP)
    {
        destRect = RectF(1, 4, 2, 2);
        cstate = g->BeginContainer(destRect, circleRect, UnitInch);
        g->SetSmoothingMode(SmoothingModeAntiAlias);
        DrawFractal(g, gray, BOTTOM, count);
        g->EndContainer(cstate);
    }
    if (side != RIGHT)
    {
        destRect = RectF(-2, 1, 2, 2);
        cstate = g->BeginContainer(destRect, circleRect, UnitInch);
        g->SetSmoothingMode(SmoothingModeAntiAlias);
        DrawFractal(g, gray, LEFT, count);
        g->EndContainer(cstate);
    }
    if (side != BOTTOM)
    {
        destRect = RectF(1, -2, 2, 2);
        cstate = g->BeginContainer(destRect, circleRect, UnitInch);
        g->SetSmoothingMode(SmoothingModeAntiAlias);
        DrawFractal(g, gray, TOP, count);
        g->EndContainer(cstate);
    }
}

VOID TestContainer(Graphics * g)
{
    if(!circleInitialized)
    {
        circlePath.AddEllipse(circleRect);
        circleInitialized = TRUE;
    }

    INT id = g->Save();
    g->TranslateTransform(5, 4);
    DrawFractal(g, 245, ROOT, 8);
    g->Restore(id);
}

/**************************************************************************\
* TestPolygons
*
* A test for drawing and filling of rectangles and polygons.
*
\**************************************************************************/

VOID TestPolygons(Graphics *g)
{
    REAL width = 4; // Pen width

    Color redColor(255, 0, 0);

    SolidBrush redBrush(redColor);
    g->FillRectangle(&redBrush, 20, 20, 50, 50);

    Color alphaColor(128, 0, 255, 0);

    SolidBrush alphaBrush(alphaColor);
    g->FillRectangle(&alphaBrush, 10, 10, 40, 40);

    PointF points[4];
    points[0].X = 50;
    points[0].Y = 50;
    points[1].X = 100;
    points[1].Y = 50;
    points[2].X = 120;
    points[2].Y = 120;
    points[3].X = 50;
    points[3].Y = 100;

    Color blueColor(128, 0, 0, 255);

    SolidBrush blueBrush(blueColor);
    g->FillPolygon(&blueBrush, points, 4);

    // Currently only Geometric pen works for lines. - ikkof 1/6/99.

    Color blackColor(0, 0, 0);
    SolidBrush blackBrush(blackColor);
    Pen blackPen(&blackBrush, width);
    blackPen.SetLineJoin(LineJoinRound);
    g->DrawPolygon(&blackPen, points, 4);
//    g->DrawLines(&blackPen, points, 4, FALSE);
}


/**************************************************************************\
* TestPaths
*
* A test for general paths.
*
\**************************************************************************/

VOID TestPaths(Graphics *g)
{
    REAL width = 4;         // Pen width
    PointF points[4];

    points[0].X = 100;
    points[0].Y = 10;
    points[1].X = -50;
    points[1].Y = 50;
    points[2].X = 150;
    points[2].Y = 200;
    points[3].X = 200;
    points[3].Y = 70;

    Color yellowColor(128, 255, 255, 0);
    SolidBrush yellowBrush(yellowColor);

    GraphicsPath* path = new GraphicsPath(FillModeAlternate);
    path->AddBeziers(points, 4);
    Matrix matrix;
    matrix.Scale(1.5, 1.5);

    // If you wanto to flatten the path before rendering,
    // Flatten() can be called.

    BOOL flattenFirst = FALSE;

    if(!flattenFirst)
    {
        // Don't flatten and keep the original path.
        // FillPath or DrawPath will flatten the path automatically
        // without modifying the original path.

        path->Transform(&matrix);
    }
    else
    {
        // Flatten this path.  The resultant path is made of line
        // segments.  The original path information is lost.

        path->Flatten(&matrix);
    }

    Color blackColor(0, 0, 0);

    SolidBrush blackBrush(blackColor);
    // Set the pen width in inch.
    width = 15;
    Pen blackPen(&blackBrush, width);
    blackPen.SetStartCap(LineCapRound);
//    blackPen.SetEndCap(LineCapSquare);
    blackPen.SetEndCap(LineCapArrowAnchor);
    Region * region = new Region(path);
    g->FillPath(&yellowBrush, path);
    g->DrawPath(&blackPen, path);
    delete path;
    delete region;
}


/**************************************************************************\
* TestPaths
*
* A test for general paths.
*
\**************************************************************************/

VOID TestPathIterators(Graphics *g)
{
    REAL width = 4;         // Pen width
    PointF points[4];

    points[0].X = 100;
    points[0].Y = 10;
    points[1].X = -50;
    points[1].Y = 50;
    points[2].X = 150;
    points[2].Y = 200;
    points[3].X = 200;
    points[3].Y = 70;

    Color yellowColor(128, 255, 255, 0);
    SolidBrush yellowBrush(yellowColor);

    GraphicsPath* path = new GraphicsPath(FillModeAlternate);
    path->AddBeziers(points, 4);
    Matrix matrix;
    matrix.Scale(1.5, 1.5);

    // If you wanto to flatten the path before rendering,
    // Flatten() can be called.

    BOOL flattenFirst = FALSE;

    if(!flattenFirst)
    {
        // Don't flatten and keep the original path.
        // FillPath or DrawPath will flatten the path automatically
        // without modifying the original path.

        path->Transform(&matrix);
    }
    else
    {
        // Flatten this path.  The resultant path is made of line
        // segments.  The original path information is lost.

        path->Flatten(&matrix);
    }

    Color blackColor(0, 0, 0);

    SolidBrush blackBrush(blackColor);
    // Set the pen width in inch.
    width = 15;
    Pen blackPen(&blackBrush, width);
    blackPen.SetStartCap(LineCapRound);
//    blackPen.SetEndCap(LineCapSquare);
    blackPen.SetEndCap(LineCapArrowAnchor);


    // Test for Path data getter and setter.

    INT count = path->GetPointCount();
    if(count > 0)
    {
        // Allocate points and types buffers.

        PathData pathData1;
        pathData1.Points = new PointF[count];
        pathData1.Types = new BYTE[count];

        if(pathData1.Points && pathData1.Types)
        {
            pathData1.Count = count;

            // Get the path data.

            if(path->GetPathData(&pathData1) == Ok)
            {
                GraphicsPath* path1 = new GraphicsPath(pathData1.Points,
                                                       pathData1.Types,
                                                       pathData1.Count,
                                                       FillModeAlternate);
                if(path1)
                {
                    g->FillPath(&yellowBrush, path1);
                }

                delete path1;
            }
        }
    }

    // Test for Path Iterator.

    GraphicsPathIterator iter(path);

    if(iter.GetLastStatus() == Ok)
    {
        count = iter.GetCount();

        PointF* newPts = new PointF[count];
        BYTE* newTypes = new BYTE[count];

        if(newPts && newTypes && count > 0)
        {
            // Get the path's points and types data by using
            // an enumeration method.

            INT resultCount = iter.Enumerate(newPts, newTypes, count);
            if (resultCount > 0)
            {
                GraphicsPath* path2 = new GraphicsPath(newPts,
                                                       newTypes,
                                                       resultCount,
                                                       FillModeAlternate);

                if(path2 && resultCount > 0)
                {
                    g->DrawPath(&blackPen, path2);

                    delete path2;
                }
            }
        }

        delete[] newPts;
        delete[] newTypes;
    }

    delete path;
}

/**************************************************************************\
* TestDashes
*
* A test for drawing dashed lines.
*
\**************************************************************************/

VOID TestDashes(Graphics *g)
{
    REAL width = 4;         // Pen width
    PointF points[4];

    points[0].X = 100;
    points[0].Y = 10;
    points[1].X = -50;
    points[1].Y = 50;
    points[2].X = 150;
    points[2].Y = 200;
    points[3].X = 200;
    points[3].Y = 70;

    Color yellowColor(128, 255, 255, 0);
    SolidBrush yellowBrush(yellowColor);

    GraphicsPath* path = new GraphicsPath(FillModeAlternate);
    path->AddBeziers(points, 4);
    Matrix matrix;
    matrix.Scale(1.5, 1.5);

    path->Transform(&matrix);

    Color blackColor(0, 0, 0);
    SolidBrush blackBrush(blackColor);
    // Set the pen width in inch.
    width = 15;
    Pen pen1(&blackBrush, width);
    pen1.SetDashStyle(DashStyleDashDotDot);
    pen1.SetDashCap(DashCapRound);
    g->DrawPath(&pen1, path);

    // Create a multiple segment with a closed segment.

    points[0].X = 50;
    points[0].Y = 50;
    points[1].X = 100;
    points[1].Y = 50;
    points[2].X = 120;
    points[2].Y = 120;
    points[3].X = 50;
    points[3].Y = 100;

    path->Reset();
    path->AddLines(points, 4);
    path->CloseFigure();

    points[0].X = 150;
    points[0].Y = 60;
    points[1].X = 200;
    points[1].Y = 150;
    path->AddLines(points, 2);
    path->Transform(&matrix);

    Color blueColor(128, 0, 0, 255);

    SolidBrush blueBrush(blueColor);

    width = 5;
    Pen pen2(&blueBrush, width);
    pen2.SetDashStyle(DashStyleDashDotDot);
    g->DrawPath(&pen2, path);

    delete path;
}

/**************************************************************************\
* TestWideningAndWarping
*
* A test for widening and warping paths.
*
\**************************************************************************/

VOID TestWideningAndWarping(Graphics *g)
{
    REAL width;         // Pen width
    RectF rect;

    rect.X = 250;
    rect.Y = -30;
    rect.Width = 150;
    rect.Height = 150;

    Color yellowColor(128, 255, 255, 0);
    SolidBrush yellowBrush(yellowColor);

    GraphicsPath* path = new GraphicsPath(FillModeAlternate);
    path->AddRectangle(rect);

    rect.Y = 70;
    path->AddEllipse(rect);

    Matrix matrix;

    Color blackColor(0, 0, 0);

    SolidBrush blackBrush(blackColor);

    // Set the pen width in inch.
    width = 15;
    Pen blackPen(&blackBrush, width);
    blackPen.SetStartCap(LineCapRound);
    blackPen.SetEndCap(LineCapSquare);

    path->Widen(&blackPen, &matrix);

    RectF bounds;

    path->GetBounds(&bounds);

    PointF destPoints[4];

    destPoints[0].X = bounds.X + bounds.Width/4;
    destPoints[0].Y = bounds.Y;
    destPoints[1].X = bounds.X + 3*bounds.Width/4;
    destPoints[1].Y = bounds.Y;
    destPoints[2].X = bounds.X;
    destPoints[2].Y = bounds.Y + bounds.Height;
    destPoints[3].X = bounds.X + bounds.Width;
    destPoints[3].Y = bounds.Y + bounds.Height;

    path->Warp(&destPoints[0], 4, bounds);

    g->FillPath(&yellowBrush, path);

    width = 0.05f;
    blackPen.SetWidth(width);
    g->DrawPath(&blackPen, path);
    delete path;
}

/**************************************************************************\
* TestRegions
*
* A test for region fill.
*
\**************************************************************************/

VOID TestRegions(Graphics *g)
{
    REAL width = 2;     // Pen width
    PointF points[5];

    REAL s, c, theta;
    REAL pi = 3.1415926535897932f;
    REAL scale = 30;
    PointF orig(200, 140);

    theta = -pi/2;

    // Create a star shape.
    for(INT i = 0; i < 5; i++)
    {
        s = sinf(theta);
        c = cosf(theta);
        points[i].X = scale*c + orig.X;
        points[i].Y = scale*s + orig.Y;
        theta += 0.8f*pi;
    }

    Color orangeColor(128, 255, 180, 0);

    SolidBrush orangeBrush(orangeColor);
    GraphicsPath* path = new GraphicsPath(FillModeAlternate);
//    Path* path = new GraphicsPath(Winding);
    path->AddPolygon(points, 5);

    Color blackColor(0, 0, 0);

    SolidBrush blackBrush(blackColor);
    Pen blackPen(&blackBrush, width);
    Region * region = new Region(path);

    Matrix m;
    g->GetTransform(&m);
    INT rectCount;
    rectCount = region->GetRegionScansCount(&m);
    Rect *  rects = new Rect[rectCount];
    region->GetRegionScans(&m, rects, &rectCount);
    delete rects;

    g->FillRegion(&orangeBrush, region);  // There is a BUG!
//    g->FillGraphicsPath(&orangeBrush, path);  // Fill path works fine.

    blackPen.SetLineJoin(LineJoinMiter);
    g->DrawPath(&blackPen, path);
    delete path;
    delete region;
}

GraphicsPath* CreateHeartPath(const RectF& rect)
{
    GpPointF points[7];
    points[0].X = 0;
    points[0].Y = 0;
    points[1].X = 1.00;
    points[1].Y = -1.00;
    points[2].X = 2.00;
    points[2].Y = 1.00;
    points[3].X = 0;
    points[3].Y = 2.00;
    points[4].X = -2.00;
    points[4].Y = 1.00;
    points[5].X = -1.00;
    points[5].Y = -1.00;
    points[6].X = 0;
    points[6].Y = 0;

    Matrix matrix;

    matrix.Scale(rect.Width/2, rect.Height/3, MatrixOrderAppend);
    matrix.Translate(3*rect.Width/2, 4*rect.Height/3, MatrixOrderAppend);
    matrix.TransformPoints(&points[0], 7);

    GraphicsPath* path = new GraphicsPath();

    if(path)
    {
        path->AddBeziers(&points[0], 7);
        path->CloseFigure();
    }

    return path;
}


/**************************************************************************\
* TestGradients
*
* A test for rectangle and radial gradients.
*
\**************************************************************************/

VOID TestGradients(Graphics* g)
{
    REAL width = 4; // Pen width

    // Create a rectangular gradient brush.

    RectF brushRect(0, 0, 32, 32);

    Color colors[5] = {
        Color(255, 255, 255, 255),
        Color(255, 255, 0, 0),
        Color(255, 0, 255, 0),
        Color(255, 0, 0, 255),
        Color(255, 0, 0, 0)
    };

// !! No longer used
//    RectangleGradientBrush rectGrad(brushRect, (Color*) &colors, WrapModeTile);

    // Rotate a brush.
    GpMatrix xForm;
    xForm.Rotate(30);
//    rectGrad.SetTransform(&xForm);

    // Change the wrapping mode and fill.

//    rectGrad.SetWrapMode(WrapModeTileFlipXY);
// !! No longer used
//    g->FillRectangle(&rectGrad, 350, 20, 100, 80);

    Color blackColor(0, 0, 0);

    SolidBrush blackBrush(blackColor);
    Pen blackPen(&blackBrush, width);

    g->DrawRectangle(&blackPen, brushRect);

    // Create a radial gradient brush.

    Color centerColor(255, 255, 255, 255);
    Color boundaryColor(255, 0, 0, 0);
    brushRect.X = 380;
    brushRect.Y = 130;
    brushRect.Width = 60;
    brushRect.Height = 32;
    PointF center;
    center.X = brushRect.X + brushRect.Width/2;
    center.Y = brushRect.Y + brushRect.Height/2;
    xForm.Reset();
    xForm.RotateAt(-30, center, MatrixOrderAppend);
// !! No longer used
//    RadialGradientBrush radGrad(brushRect, centerColor,
//                                boundaryColor, WrapModeClamp);
//    radGrad.SetTransform(&xForm);
//    g->FillRectangle(&radGrad, 320, 120, 120, 100);

//    Pen gradPen(&rectGrad, width);
//    g->DrawRectangle(&gradPen, 320, 120, 120, 100);

    // Triangle gradient.

    PointF points[7];
    points[0].X = 50;
    points[0].Y = 10;
    points[1].X = 200;
    points[1].Y = 20;
    points[2].X = 100;
    points[2].Y = 100;
    points[3].X = 30;
    points[3].Y = 120;

    Color colors1[5] = {
        Color(255, 255, 255, 0),
        Color(255, 255, 0, 0),
        Color(255, 0, 255, 0),
        Color(255, 0, 0, 255),
        Color(255, 0, 0, 0)
    };

// !! No longer used
//    TriangleGradientBrush triGrad(points, (Color*) &colors);
//    g->FillPolygon(&triGrad, points, 3);
    RectF triRect;
//    triGrad.GetRectangle(triRect);
//    g->FillRectangle(&triGrad, triRect);

    points[0].X = 200;
    points[0].Y = 300;
    points[1].X = 280;
    points[1].Y = 350;
    points[2].X = 220;
    points[2].Y = 420;
    points[3].X = 160;
    points[3].Y = 440;
    points[4].X = 120;
    points[4].Y = 370;

    PathGradientBrush polyGrad(points, 5);

    REAL blend[10];
    Color presetColors[10];
    REAL positions[10];
    INT count;
    INT i;

    count = 3;
    blend[0] = (REAL) 0;
    blend[1] = (REAL) 0;
    blend[2] = (REAL) 1;
    positions[0] = (REAL) 0;
    positions[1] = (REAL) 0.4;
    positions[2] = (REAL) 1;

    // Test for blending factors.

    polyGrad.SetBlend(&blend[0], &positions[0], count);

    polyGrad.SetCenterColor(centerColor);
    INT colorset = 5;
    polyGrad.SetSurroundColors(&colors1[0], &colorset);
    
//    g->FillPolygon(&polyGrad, points, 5);
    RectF polyRect;
    polyGrad.GetRectangle(&polyRect);
    g->FillRectangle(&polyGrad, polyRect);

    // Create a heart shaped path.

    RectF rect;
    rect.X = 300;
    rect.Y = 300;
    rect.Width = 150;
    rect.Height = 150;
    GraphicsPath *path = CreateHeartPath(rect);

    // Create a gradient from a path.

    PathGradientBrush pathGrad(path);
    delete path;
    pathGrad.SetCenterColor(centerColor);
    INT colorsset = 5;
    colors1[0] = Color(255, 255, 0, 0);
    pathGrad.SetSurroundColors(&colors1[0], &colorsset);
    pathGrad.GetRectangle(&polyRect);

    // Set the rect focus.

    PointF centerPt;

    pathGrad.GetCenterPoint(&centerPt);
    centerPt.X -= 15;
    centerPt.Y += 30;
    pathGrad.SetCenterPoint(centerPt);
    REAL xScale, yScale;
    pathGrad.GetFocusScales(&xScale, &yScale);
    xScale = 0.4f;
    yScale = 0.3f;
    pathGrad.SetFocusScales(xScale, yScale);

    g->FillRectangle(&pathGrad, polyRect);

    // Test for LineGradientBrush.

    RectF lineRect(120, -20, 200, 60);
    Color color1(200, 255, 255, 0);
    Color color2(200, 0, 0, 255);

    LinearGradientBrush lineGrad(lineRect, color1, color1,
                        LinearGradientModeForwardDiagonal);

    // Test for preset colors

    presetColors[0] = Color(200, 0, 255, 255);
    presetColors[1] = Color(200, 255, 255, 0);
    presetColors[2] = Color(200, 0, 255, 0);
    lineGrad.SetInterpolationColors(&presetColors[0], &positions[0], count);

    g->FillRectangle(&lineGrad, lineRect);
}


/**************************************************************************\
* TestHatches
*
* A test for hatch brushes
*
\**************************************************************************/

VOID TestHatches(Graphics* g)
{
    Color foreColor(0, 0, 0);
    Color backColor(255, 255, 255);

    int x, y;
    
    x = 0; y = 0;
    
    for (int i = HatchStyleMin; i <= HatchStyleMax; i++)
    {
        if ((i > 0) && ((i & 7) == 0))
        {
            x = 0;
            y += 100;
        }
        HatchBrush hatch((HatchStyle)i, foreColor, backColor);
        g->FillRectangle(&hatch, x, y, 100, 100);
        x += 100;
    }
}

/**************************************************************************\
* TestBitmaps
*
* A test for texture filling and DrawImage.
*
\**************************************************************************/

VOID TestBitmaps(Graphics* g)
{
    Point points[4];
    REAL width = 4;     // Pen width


    WCHAR filename[256];
    wcscpy(filename, L"../data/brick.jpg");
    Bitmap *bitmap = new Bitmap(filename);

    // Create a texture brush.

    RectI copyRect;
    copyRect.X = 0;
    copyRect.Y = 0;
    copyRect.Width = 40;
    copyRect.Height = 30;

    Bitmap *copiedBitmap = bitmap->Clone(copyRect.X, copyRect.Y,
                                         copyRect.Width, copyRect.Height,
                                         PixelFormat32bppARGB);

    if(copiedBitmap)
    {
        // Create a texture brush.

        TextureBrush textureBrush(copiedBitmap, WrapModeTile);

        //copiedBitmap->Dispose();

        // Create a radial gradient pen.

        Color redColor(255, 0, 0);

        SolidBrush redBrush(redColor);
        Pen redPen(&redBrush, width);

        GraphicsPath *path;

        points[0].X = 100;
        points[0].Y = 60;
        points[1].X = -50;
        points[1].Y = 60;
        points[2].X = 150;
        points[2].Y = 250;
        points[3].X = 200;
        points[3].Y = 120;
        path = new GraphicsPath(FillModeAlternate);
        path->AddBeziers(points, 4);
        g->FillPath(&textureBrush, path);
        g->DrawPath(&redPen, path);

        delete path;
        delete copiedBitmap;
    }

    delete bitmap;

    PointF destPoints[3];

    destPoints[0].X = 300;
    destPoints[0].Y = 50;
    destPoints[1].X = 450;
    destPoints[1].Y = 50;
    destPoints[2].X = 240;
    destPoints[2].Y = 200;

    Matrix mat;
    mat.Translate(0, 100);
    mat.TransformPoints(&destPoints[0], 3);
    wcscpy(filename, L"../data/apple1.png");
    bitmap = new Bitmap(filename);
    g->DrawImage(bitmap, &destPoints[0], 3);

    delete bitmap;

    destPoints[0].X = 30;
    destPoints[0].Y = 200;
    destPoints[1].X = 200;
    destPoints[1].Y = 200;
    destPoints[2].X = 200;
    destPoints[2].Y = 420;

    wcscpy(filename, L"../data/dog2.png");
    bitmap = new Bitmap(filename);
    g->DrawImage(bitmap, &destPoints[0], 3);

    delete bitmap;

    Color color(100, 128, 255, 0);

    SolidBrush brush(color);

    Point pts[10];
    INT count = 4;

    pts[0].X = 150;
    pts[0].Y = 60;
    pts[1].X = 100;
    pts[1].Y = 230;
    pts[2].X = 250;
    pts[2].Y = 260;
    pts[3].X = 350;
    pts[3].Y = 100;

    g->FillClosedCurve(&brush, pts, count);

    wcscpy(filename, L"../data/ballmer.jpg");
    bitmap = new Bitmap(filename);
    RectF destRect(220, 50, 180, 120);
    RectF srcRect;
    srcRect.X = 100;
    srcRect.Y = 40;
    srcRect.Width = 200;
    srcRect.Height = 200;
    g->DrawImage(bitmap, destRect, srcRect.X, srcRect.Y,
        srcRect.Width, srcRect.Height, UnitPixel);

    g->DrawImage(bitmap, pts, 3, (INT) srcRect.X, (INT) srcRect.Y,
       (INT) srcRect.Width, (INT) srcRect.Height, UnitPixel);

    delete bitmap;
}

/**************************************************************************\
* TestPrimitives
*
* A test for ellipse, arc, pie, curve, and closed curve.
*
\**************************************************************************/

VOID
TestPrimitives(
    Graphics* g
    )
{
    RectF rect;

    rect.X = 250;
    rect.Y = 230;
    rect.Width = 150;
    rect.Height = 100;

    Color color(128, 128, 255, 0);

    SolidBrush brush(color);

    REAL width = 1;

    Color blackColor(0, 0, 0);
    SolidBrush blackBrush(blackColor);
    Pen pen(&blackBrush, width);

//    g->FillEllipse(&brush, rect);
//    g->DrawEllipse(&pen, rect);
    REAL startAngle = 0;
    REAL sweepAngle = 240;
    g->FillPie(&brush, rect, startAngle, sweepAngle);
    g->DrawPie(&pen, rect, startAngle, sweepAngle);

    PointF pts[10];
    INT count = 4;

    pts[0].X = 200;
    pts[0].Y = 160;
    pts[1].X = 150;
    pts[1].Y = 230;
    pts[2].X = 200;
    pts[2].Y = 260;
    pts[3].X = 300;
    pts[3].Y = 200;

    g->FillClosedCurve(&brush, pts, count);
    g->DrawClosedCurve(&pen, pts, count);
}


/**************************************************************************\
* TestMixedObjects
*
* A test for different brushes and pens.
*
\**************************************************************************/

VOID TestMixedObjects(Graphics* g)
{
    PointF points[10];
    REAL width = 4;     // Pen width

    // Load bmp files.

    WCHAR *filename = L"winnt256.bmp";
    Bitmap *bitmap = new Bitmap(filename);

    // Create a texture brush.

    RectI copyRect;
    copyRect.X = 60;
    copyRect.Y = 60;
    copyRect.Width = 80;
    copyRect.Height = 60;
    Bitmap *copiedBitmap = bitmap->Clone(copyRect.X, copyRect.Y,
                                            copyRect.Width, copyRect.Height,
                                            PixelFormat32bppPARGB);

    // Create a rectangular gradient brush.

    RectF brushRect(0, 0, 32, 32);
    Color colors[4] = {
       Color(255, 255, 255, 255),
       Color(255, 255, 0, 0),
       Color(255, 0, 255, 0),
       Color(255, 0, 0, 255)
    };
// !! No longer supported
//    RectangleGradientBrush rectGrad(brushRect, (Color*)&colors, WrapModeTile);
    width = 8;
//    Pen gradPen(&rectGrad, width);

    if(copiedBitmap)
    {
        // Create a texture brush.

        TextureBrush textureBrush(copiedBitmap, WrapModeTile);

        delete copiedBitmap;

        // Create a radial gradient pen.

        points[3].X = 50;
        points[3].Y = 300;
        points[2].X = 100;
        points[2].Y = 300;
        points[1].X = 120;
        points[1].Y = 370;
        points[0].X = 50;
        points[0].Y = 350;

//        gradPen.SetLineJoin(LineJoinMiter);
        g->FillPolygon(&textureBrush, points, 4);
//        g->DrawPolygon(&gradPen, points, 4);
    }

    delete bitmap;
}

/**************************************************************************\
* TestTexts
*
* A test for drawing texts.
*
\**************************************************************************/

VOID TestTexts(Graphics *g)
{
    //Font font(L"Arial", 60);

    FontFamily  ff(L"Arial");
    RectF     rectf(20, 0, 300, 200);
    GraphicsPath  path;

    // Solid color text.

    Color color(128, 100, 0, 200);
    SolidBrush brush(color);
    path.AddString(L"Color", 5, &ff, 0, 60,  rectf, NULL);
    g->FillPath(&brush, &path);

    // Texture text.

    WCHAR filename[256];
    wcscpy(filename, L"../data/marble1.jpg");
    Bitmap *bitmap = new Bitmap(filename);
    TextureBrush textureBrush(bitmap, WrapModeTile);
    path.Reset();
    rectf.X = 200;
    rectf.Y = 20;
    path.AddString(L"Texture", 7, &ff, 0, 60, rectf, NULL);
    g->FillPath(&textureBrush, &path);
    delete bitmap;

    // Gradient text.

    rectf.X = 40;
    rectf.Y = 80;
    path.Reset();
    path.AddString(L"Gradient", 8, &ff, 0, 60, rectf, NULL);
    Color color1(255, 255, 0, 0);
    Color color2(255, 0, 255, 0);
    LinearGradientBrush lineGrad(rectf, color1, color2, 0.0f);
    g->FillPath(&lineGrad, &path);

    // Shadow test

    REAL charHeight = 60;
    REAL topMargin = - 5;
    rectf.X = 0;
    rectf.Y = - charHeight - topMargin; // Make y-coord of the base line
                                        // of the characters to be 0.

    path.Reset();
    path.AddString(L"Shadow", 6, &ff, 0, charHeight, rectf, NULL);
    GraphicsPath* clonePath = path.Clone();

    Color redColor(255, 0, 0);
    Color grayColor(128, 0, 0, 0);
    SolidBrush redBrush(redColor);
    SolidBrush grayBrush(grayColor);

    // Shadow part.

    REAL tx = 180, ty = 200;
    Matrix skew;
    skew.Scale(1.0, 0.5);
    skew.Shear(-2.0, 0, MatrixOrderAppend);
    skew.Translate(tx, ty, MatrixOrderAppend);
    clonePath->Transform(&skew);
    g->FillPath(&grayBrush, clonePath);
    delete clonePath;

    // Front part.

    Matrix trans1;
    trans1.Translate(tx, ty);
    path.Transform(&trans1);
    g->FillPath(&redBrush, &path);


    return;
/*
    REAL x = 200, y = 150;

    RectF brushRect(x, y, 150, 32);
    Color colors[4] = {
       Color(180, 255, 0, 0),
       Color(180, 0, 255, 0),
       Color(180, 255, 0, 0),
       Color(180, 0, 255, 0)
    };
    RectangleGradientBrush rectGrad(brushRect, (Color*)&colors, WrapModeTile);

    g->DrawString(L"GDI+", &font, &rectGrad, x, y);


    // And now with DrawText

    RectF rect(400, 200, 400, 400);

    g->DrawText(
        DrawTextDisplay,
        L"A few words powered by GDI+: \
\x3c3\x3bb\x3b1\x3b4 \
\x627\x644\x633\x644\x627\x645 \
\x5e9\x5dc\x5d5\x5dd \
\xe2d\xe4d\xe01\xe29\xe23\xe44\xe17\xe22 \
\x110\x068\x0ea\x300\x103",
       &font,           // Initial font
       &rectGrad,       // Initial brush (ignored for the time being)
        LANG_NEUTRAL,   // Initial language
       &rect            // Formatting rectangle
    );
*/

}

#ifdef TEXTV2
// We don't support text along a path in v1

VOID TestTextAlongPath(Graphics *g)
{
    Point points[4];

    points[3].X = 100;
    points[3].Y = 10;
    points[2].X = -50;
    points[2].Y = 50;
    points[1].X = 150;
    points[1].Y = 200;
    points[0].X = 200;
    points[0].Y = 70;

    GraphicsPath* path = new GraphicsPath(FillModeAlternate);
    path->AddBeziers(points, 4);
    Matrix matrix;
    matrix.Scale(1.5, 1.5);

    path->Transform(&matrix);

    Color textColor(180, 200, 0, 200);
    SolidBrush textBrush(textColor);

    WCHAR text[] = L"Windows 2000";

    REAL offset = 60;

    g->DrawString(text, 12, NULL, path, NULL, textBrush, offset);

    delete path;
}

#endif

/**************************************************************************\
* TestDerive
*
* Test
* A test for derivation support.
*
\**************************************************************************/

VOID
TestDerive(
    HWND hwnd
    )
{
    HDC hdcScreen = GetDC(hwnd);
    HRGN hrgn = CreateEllipticRgn(10, 10, 300, 300);

    SetMapMode(hdcScreen, MM_TWIPS);
    SelectClipRgn(hdcScreen, hrgn);
    HBRUSH hbrushRed = CreateSolidBrush(RGB(255, 0, 0));
    SelectObject(hdcScreen, hbrushRed);
    Rectangle(hdcScreen, 0, 0, 3000, -3000);

    {
        Graphics g(hdcScreen);
        SolidBrush solidBrush(Color(0, 255, 0));
        g.FillRectangle(&solidBrush, 0, -3000, 3000, 3000);
    }

    HBITMAP hbmBitmap = CreateCompatibleBitmap(hdcScreen, 50, 50);
    HDC hdcBitmap = CreateCompatibleDC(hdcScreen);
    SelectObject(hdcBitmap, hbmBitmap);
    SetWindowOrgEx(hdcBitmap, 40, 80, NULL);

    SelectObject(hdcBitmap, hbrushRed);
    Rectangle(hdcBitmap, 40, 80, 50, 50);

    {
        POINT point;
        Graphics g(hdcBitmap);
        SolidBrush solidBrush(Color(0, 0, 255));
        g.FillRectangle(&solidBrush, 40, 80, 90, 130);

        // The DC that we get back should have the same transform set
        // as that which we originally passed in:

        HDC hdcGet = g.GetHDC();
        point.x = 0;
        point.y = 0;
        DPtoLP(hdcGet, &point, 1);

        ASSERT((hdcGet != NULL) && (point.x == 40) && (point.y == 80));

        g.ReleaseHDC(hdcGet);
    }

    // The DC should have beeen returned to the top save level:

    INT saveLevel = SaveDC(hdcBitmap);
    ASSERT(saveLevel == 1);

    // The DC should have had its transform restored:

    POINT oldPoint;
    SetWindowOrgEx(hdcBitmap, 0, 0, &oldPoint);

    ASSERT((oldPoint.x == 40) && (oldPoint.y == 80));

    // Blt the (hopefully) blue square to the screen.  But first,
    // reset our transform on 'hdcScreen' the lazy way:

    ReleaseDC(hwnd, hdcScreen);
    hdcScreen = GetDC(hwnd);
    BitBlt(hdcScreen, 0, 0, 50, 50, hdcBitmap, 0, 0, SRCCOPY);
    ReleaseDC(hwnd, hdcScreen);

    // Test two equivalent methods.  This should result in two grey
    // squares, one on top of the other, each inset by a red circle
    // and the text "Ack!".

    hdcScreen = GetDC(hwnd);
    {
        // First:

        {
            Graphics g(hdcScreen);
            SolidBrush fillBrush(Color(128, 128, 128));
            g.FillRectangle(&fillBrush, 200, 200, 80, 80);
        }
        TextOutA(hdcScreen, 220, 230, "Ack!", 4);
        {
            Graphics g(hdcScreen);
            SolidBrush strokeBrush(Color(255, 0, 0));
            Pen pen(&strokeBrush, 0);
            g.DrawEllipse(&pen, 200, 200, 80, 80);
        }

        // Second:

        {
            Graphics g(hdcScreen);
            SolidBrush fillBrush(Color(128, 128, 128));
            g.FillRectangle(&fillBrush, 200, 300, 80, 80);

            HDC hdcNew = g.GetHDC();
            ASSERT(hdcNew != NULL);
            SetViewportOrgEx(hdcScreen, 220, 230, NULL);
            TextOutA(hdcNew, 0, 100, "Ack!", 4);
            SetViewportOrgEx(hdcScreen, 0, 0, NULL);
            g.ReleaseHDC(hdcNew);

            SolidBrush strokeBrush(Color(255, 0, 0));
            Pen pen(&strokeBrush, 0);
            g.DrawEllipse(&pen, 200, 300, 80, 80);
        }
    }
    ReleaseDC(hwnd, hdcScreen);
}

VOID TestRegionExcludeClip(Graphics *g)
{
    Gdiplus::Status     status;
    RectF               rect(100, 100, 500, 500);
    Gdiplus::Region     region(rect);

    rect.X = 50; rect.Y = 25; rect.Width = 100; rect.Height = 100;
    status = region.Exclude(rect);
    ASSERT(status == Ok);

    rect.X = 250;
    status = region.Exclude(rect);
    ASSERT(status == Ok);

    rect.X = 550;
    status = region.Exclude(rect);
    ASSERT(status == Ok);

    rect.X = 50; rect.Y = 150;  rect.Height = 75;
    status = region.Exclude(rect);
    ASSERT(status == Ok);

    rect.X = 550;
    status = region.Exclude(rect);
    ASSERT(status == Ok);

    rect.X = 300; rect.Y = 300; rect.Height = 125;
    status = region.Exclude(rect);
    ASSERT(status == Ok);

    rect.X = 550; rect.Y = 250; rect.Height = 75;
    status = region.Exclude(rect);
    ASSERT(status == Ok);

    rect.Y = 375;
    status = region.Exclude(rect);
    ASSERT(status == Ok);

    rect.Y = 550;
    status = region.Exclude(rect);
    ASSERT(status == Ok);

    rect.X = 350;
    status = region.Exclude(rect);
    ASSERT(status == Ok);

    rect.X = 50;
    status = region.Exclude(rect);
    ASSERT(status == Ok);

    rect.Y = 450;
    status = region.Exclude(rect);
    ASSERT(status == Ok);

    rect.Y = 315;
    status = region.Exclude(rect);
    ASSERT(status == Ok);

//    g->SetPageTransform(UnitDisplay, 0.5f);
    status = g->SetClip(&region);
    ASSERT(status == Ok);
    status = g->TranslateClip(-50.0f, -50.0f);
    ASSERT(status == Ok);

    Gdiplus::SolidBrush b(Gdiplus::Color::Purple);
    status = g->FillRectangle(&b, 0, 0, 800, 800);
    ASSERT(status == Ok);
    g->ResetClip();
//    g->SetPageTransform(UnitDisplay, 1.0f);
}

VOID TestRegionXorClip(Graphics *g)
{
    Gdiplus::Status     status;
    PointF              bez1[7];
    GraphicsPath *      pathBez1 = new GraphicsPath();
    ASSERT(pathBez1 != NULL);

    bez1[0].X = 200; bez1[0].Y = 275;
    bez1[1].X = 200; bez1[1].Y = 225;
    bez1[2].X = 300; bez1[2].Y = 225;
    bez1[3].X = 300; bez1[3].Y = 275;
    bez1[4].X = 300; bez1[4].Y = 325;
    bez1[5].X = 200; bez1[5].Y = 325;
    bez1[6].X = 200; bez1[6].Y = 275;

    status = pathBez1->AddBeziers(bez1, 7);
    ASSERT(status == Ok);

    PointF              bez2[7];
    GraphicsPath *      pathBez2 = new GraphicsPath();
    ASSERT(pathBez2 != NULL);

    bez2[0].X =  50; bez2[0].Y = 250;
    bez2[1].X =  50; bez2[1].Y =   0;
    bez2[2].X = 450; bez2[2].Y =   0;
    bez2[3].X = 450; bez2[3].Y = 250;
    bez2[4].X = 450; bez2[4].Y = 500;
    bez2[5].X =  50; bez2[5].Y = 500;
    bez2[6].X =  50; bez2[6].Y = 250;

    status = pathBez2->AddBeziers(bez2, 7);
    ASSERT(status == Ok);

    PointF              star[10];
    GraphicsPath *      pathStar = new GraphicsPath();
    ASSERT(pathStar != NULL);

    star[0].X =  12; star[0].Y = 192;
    star[1].X = 193; star[1].Y = 192;
    star[2].X = 250; star[2].Y =  20;
    star[3].X = 306; star[3].Y = 192;
    star[4].X = 487; star[4].Y = 192;
    star[5].X = 340; star[5].Y = 299;
    star[6].X = 396; star[6].Y = 472;
    star[7].X = 250; star[7].Y = 365;
    star[8].X = 103; star[8].Y = 472;
    star[9].X = 159; star[9].Y = 299;

    status = pathStar->AddPolygon(star, 10);
    ASSERT(status == Ok);

    RectF               regionRect(100, 100, 300, 300);
    Gdiplus::Region     region(pathStar);

    status = region.Xor(regionRect);
    ASSERT(status == Ok);

    status = region.Union(pathBez1);
    ASSERT(status == Ok);

    status = region.Xor(pathBez2);
    ASSERT(status == Ok);

    UINT    regionDataSize = region.GetDataSize();
    BYTE *  regionData = new BYTE[regionDataSize];
    ASSERT(regionData);

    region.GetData(regionData, regionDataSize, &regionDataSize);

    Gdiplus::Region region2(regionData, regionDataSize);

    delete [] regionData;

    status = g->SetClip(&region2);
    ASSERT(status == Ok);

    PointF      pointsRect[4];

    pointsRect[0].X = 0;
    pointsRect[0].Y = 0;
    pointsRect[1].X = 600;
    pointsRect[1].Y = 0;
    pointsRect[2].X = 600;
    pointsRect[2].Y = 600;
    pointsRect[3].X = 0;
    pointsRect[3].Y = 600;

    Gdiplus::SolidBrush alphaBrush(Color(128, 0, 255, 0));
    status = g->FillPolygon(&alphaBrush, pointsRect, 4);
    ASSERT(status == Ok);

    g->ResetClip();

    delete pathStar;
    delete pathBez1;
    delete pathBez2;
}

/**************************************************************************\
* TestImaging
*
* A test for imaging and DrawImage.
*
\**************************************************************************/

VOID RemapBlackAndWhiteMatrix(ColorMatrix *matrix, Color replaceBlack, Color replaceWhite)
{
    // Normalize the colors to 1.0.

    REAL normBlackRed   = ((REAL)replaceBlack.GetRed()  )/(REAL)255.0;
    REAL normBlackGreen = ((REAL)replaceBlack.GetGreen())/(REAL)255.0;
    REAL normBlackBlue  = ((REAL)replaceBlack.GetBlue() )/(REAL)255.0;
    REAL normBlackAlpha = ((REAL)replaceBlack.GetAlpha())/(REAL)255.0;

    REAL normWhiteRed   = ((REAL)replaceWhite.GetRed()  )/(REAL)255.0;
    REAL normWhiteGreen = ((REAL)replaceWhite.GetGreen())/(REAL)255.0;
    REAL normWhiteBlue  = ((REAL)replaceWhite.GetBlue() )/(REAL)255.0;
    REAL normWhiteAlpha = ((REAL)replaceWhite.GetAlpha())/(REAL)255.0;

    // Setup a matrix that will map white to transparent black and
    // black to the specified color.
    //
    //      | -B  -B  -B  -B   0 |
    //      |   r   g   b   a    |
    //      |                    |
    //      |  W   W   W   W   0 |
    //      |   r   g   b   a    |
    //      |                    |
    //      |  0   0   0   0   0 |
    //      |                    |
    //      |                    |
    //      |  0   0   0   0   0 |
    //      |                    |
    //      |                    |
    //      |  B   B   B   B   1 |
    //      |   r   g   b   a    |

    memset(matrix, 0, sizeof(ColorMatrix));

    matrix->m[0][0] = -normBlackRed;
    matrix->m[0][1] = -normBlackGreen;
    matrix->m[0][2] = -normBlackBlue;
    matrix->m[0][3] = -normBlackAlpha;

    matrix->m[1][0] =  normWhiteRed;
    matrix->m[1][1] =  normWhiteGreen;
    matrix->m[1][2] =  normWhiteBlue;
    matrix->m[1][3] =  normWhiteAlpha;

    matrix->m[4][0] =  normBlackRed;
    matrix->m[4][1] =  normBlackGreen;
    matrix->m[4][2] =  normBlackBlue;
    matrix->m[4][3] =  normBlackAlpha;
    matrix->m[4][4] =  1.0;
}

VOID NextDestRect(INT xRef, INT yRef, Rect *rect)
{
    rect->Y += rect->Height;

    if (rect->Y >= (yRef + (4 * rect->Height)))
    {
        rect->X += rect->Width;
        rect->Y = yRef;
    }
}

BOOL CALLBACK MyDrawImageAbort(VOID* data)
{
    UINT *count = (UINT*) data;

    *count += 1;

    //LBprintf("MyDrawImageAbort: %ld", *count);

    return FALSE;
}

VOID TestImaging(Graphics* g)
{
    // Load bmp files.

    WCHAR *filename = L"winnt256.bmp";

    Image *image = new Image(filename);

    // Get information on the image.

    UINT imageWidth = image->GetWidth();
    UINT imageHeight = image->GetHeight();

    // Source clip but preserve aspect ratio (destination is a square).

    if (imageWidth < imageHeight)
    {
        imageWidth  = (INT) ((REAL)imageWidth * (REAL).7);
        imageHeight = imageWidth;
    }
    else
    {
        imageHeight = (INT) ((REAL)imageHeight * (REAL).7);
        imageWidth  = imageHeight;
    }

    // Try to save thumbnail

    WCHAR *thumbfile = L"thumb256.bmp";

    CLSID _BmpCodecClsID_ =
    {
        0x557cf400,
        0x1a04,
        0x11d3,
        {0x9a, 0x73, 0x00, 0x00, 0xf8, 0x1e, 0xf3, 0x2e}
    };

    UINT abortCount = 0;

    ImageAttributes imgAttrib;

    Rect destRect(50, 10, 100, 100);

    // Make near-white to white transparent

#ifdef TESTOUTCROP
    g->DrawImage(image, destRect, -20, -20, imageOutCrop.Width+20, imageOutCrop.Height+20,
                 UnitPixel, &imgAttrib,
                 MyDrawImageAbort, (VOID*)&abortCount);
#else
    Color c1(200, 200, 200);
    Color c2(255, 255, 255);
    imgAttrib.SetColorKey(c2, c2);

    g->DrawImage(image, destRect, 0, 0, imageWidth, imageHeight,
                 UnitPixel, &imgAttrib,
                 MyDrawImageAbort, (VOID*)&abortCount);
#endif
    NextDestRect(50, 10, &destRect);

    ColorMatrix greyMatrix = {.25, .25, .25, 0, 0,
                              .25, .25, .25, 0, 0,
                              .25, .25, .25, 0, 0,
                              0, 0, 0, 1, 0,
                              (REAL).1, (REAL).1, (REAL).1, 0, 1};

    imgAttrib.ClearColorKey();
    imgAttrib.SetColorMatrix(&greyMatrix);

    g->DrawImage(image, destRect, 0, 0, imageWidth, imageHeight,
                 UnitPixel, &imgAttrib,
                 MyDrawImageAbort, (VOID*)&abortCount);
    NextDestRect(50, 10, &destRect);

    ColorMatrix pinkMatrix = {(REAL).33, .25, .25, 0, 0,
                              (REAL).33, .25, .25, 0, 0,
                              (REAL).33, .25, .25, 0, 0,
                              0, 0, 0, 1, 0,
                              0, 0, 0, 0, 1};

    imgAttrib.SetColorMatrix(&pinkMatrix, ColorMatrixFlagsSkipGrays);

    g->DrawImage(image, destRect, 0, 0, imageWidth, imageHeight,
                 UnitPixel, &imgAttrib,
                 MyDrawImageAbort, (VOID*)&abortCount);
    NextDestRect(50, 10, &destRect);

    ColorMatrix darkMatrix = {.75, 0, 0, 0, 0,
                              0, .75, 0, 0, 0,
                              0, 0, .75, 0, 0,
                              0, 0, 0, 1, 0,
                              0, 0, 0, 0, 1};

    imgAttrib.SetColorMatrix(&darkMatrix);

    g->DrawImage(image, destRect, 0, 0, imageWidth, imageHeight,
                 UnitPixel, &imgAttrib,
                 MyDrawImageAbort, (VOID*)&abortCount);
    NextDestRect(50, 10, &destRect);

    imgAttrib.ClearColorMatrix();
    imgAttrib.SetGamma(3.0);

    g->DrawImage(image, destRect, 0, 0, imageWidth, imageHeight,
                 UnitPixel, &imgAttrib,
                 MyDrawImageAbort, (VOID*)&abortCount);
    NextDestRect(50, 10, &destRect);

    imgAttrib.SetThreshold(0.5);

    g->DrawImage(image, destRect, 0, 0, imageWidth, imageHeight,
                 UnitPixel, &imgAttrib,
                 MyDrawImageAbort, (VOID*)&abortCount);
    NextDestRect(50, 10, &destRect);

    // red->blue, green->red, blue->green, alpha = 0.75
    ColorMatrix swapMatrix = {0, 0, 1, 0, 0,
                              1, 0, 0, 0, 0,
                              0, 1, 0, 0, 0,
                              0, 0, 0, .75, 0,
                              0, 0, 0, 0, 1};

    imgAttrib.SetColorMatrix(&swapMatrix);
    imgAttrib.ClearGamma();
    imgAttrib.ClearThreshold();

    g->DrawImage(image, destRect, 0, 0, imageWidth, imageHeight,
                 UnitPixel, &imgAttrib,
                 MyDrawImageAbort, (VOID*)&abortCount);
    NextDestRect(50, 10, &destRect);

    // red->blue, green->red, blue->green, alpha = 0.9
    ColorMatrix swapMatrix2 = {0, 0, 1, 0, 0,
                               1, 0, 0, 0, 0,
                               0, 1, 0, 0, 0,
                               0, 0, 0, 0, 0,
                               0, 0, 0, (REAL).9, 1};

    imgAttrib.SetNoOp();
    imgAttrib.SetColorMatrix(&swapMatrix2);

    g->DrawImage(image, destRect, 0, 0, imageWidth, imageHeight,
                 UnitPixel, &imgAttrib,
                 MyDrawImageAbort, (VOID*)&abortCount);
    NextDestRect(50, 10, &destRect);

    imgAttrib.ClearNoOp();

    g->DrawImage(image, destRect, 0, 0, imageWidth, imageHeight,
                 UnitPixel, &imgAttrib,
                 MyDrawImageAbort, (VOID*)&abortCount);
    NextDestRect(50, 10, &destRect);

    {
        Bitmap* bitmap = new Bitmap(imageWidth, imageHeight, g);
        if (bitmap)
        {
            Graphics *bitmapGraphics = Graphics::FromImage(bitmap);
            if (bitmapGraphics)
            {
                imgAttrib.ClearNoOp();
                imgAttrib.ClearColorMatrix();
                imgAttrib.ClearColorKey();
                imgAttrib.ClearGamma();
                imgAttrib.SetThreshold(0.5);

                Rect rect(0, 0, imageWidth, imageHeight);
                bitmapGraphics->DrawImage(image, rect,
                                          0, 0, imageWidth, imageHeight,
                                          UnitPixel, &imgAttrib,
                                          MyDrawImageAbort, (VOID*)&abortCount);

                delete bitmapGraphics;
            }
            else
                LBprintf("TestImaging: graphics from image");

            imgAttrib.ClearThreshold();

            ColorMatrix remapBlackAndWhite;

            RemapBlackAndWhiteMatrix(&remapBlackAndWhite, Gdiplus::Color::Maroon, 0);
            imgAttrib.SetColorMatrix(&remapBlackAndWhite);

            g->DrawImage(bitmap, destRect, 0, 0, imageWidth, imageHeight,
                         UnitPixel, &imgAttrib,
                         MyDrawImageAbort, (VOID*)&abortCount);
            NextDestRect(50, 10, &destRect);

            RemapBlackAndWhiteMatrix(&remapBlackAndWhite, 0, Gdiplus::Color::Green);
            imgAttrib.SetColorMatrix(&remapBlackAndWhite);

            g->DrawImage(bitmap, destRect, 0, 0, imageWidth, imageHeight,
                         UnitPixel, &imgAttrib,
                         MyDrawImageAbort, (VOID*)&abortCount);
            NextDestRect(50, 10, &destRect);

            Color blackRemap(128, 0xff, 0x00, 0x00);
            Color whiteRemap(128, 0x00, 0xff, 0x00);
            RemapBlackAndWhiteMatrix(&remapBlackAndWhite, blackRemap, whiteRemap);
            imgAttrib.SetColorMatrix(&remapBlackAndWhite);

            g->DrawImage(bitmap, destRect, 0, 0, imageWidth, imageHeight,
                         UnitPixel, &imgAttrib,
                         MyDrawImageAbort, (VOID*)&abortCount);
            NextDestRect(50, 10, &destRect);

            delete bitmap;
        }
        else
            LBprintf("TestImaging: bitmap creation failed");
    }

    g->Flush();

    delete image;
}

VOID TestBitmapGraphics(Graphics* g)
{
    INT bitmapSize = 500;

    WCHAR *filename = L"../data/apple1.png";
    Bitmap *bitmap = new Bitmap(filename);

    UINT imageWidth = bitmap->GetWidth();
    UINT imageHeight = bitmap->GetHeight();

    Graphics *bitmapGraphics = Graphics::FromImage(bitmap);

    if ((!bitmapGraphics) || (bitmapGraphics->GetLastStatus() != Ok))
        LBprintf("Bitmap.GetGraphics() failed");

    TestRegionExcludeClip(bitmapGraphics);
    TestRegionXorClip(bitmapGraphics);
    TestContainerClip(bitmapGraphics);
    TestContainer(bitmapGraphics);
    TestPolygons(bitmapGraphics);
    TestPaths(bitmapGraphics);
    TestRegions(bitmapGraphics);
    TestGradients(bitmapGraphics);
    TestHatches(bitmapGraphics);
    TestBitmaps(bitmapGraphics);
    TestPrimitives(bitmapGraphics);
    TestMixedObjects(bitmapGraphics);
    TestTexts(bitmapGraphics);
    TestImaging(bitmapGraphics);

    HDC hdc = bitmapGraphics->GetHDC();

    if (!hdc)
        LBprintf("Graphics.GetHdc() failed");

    LPSTR testString = "Hello, Boo-Boo!";
    TextOutA(hdc, 20, 20, testString, strlen(testString));
    SetBkMode(hdc, TRANSPARENT);
    TextOutA(hdc, 20, 200, testString, strlen(testString));

    bitmapGraphics->ReleaseHDC(hdc);

    delete bitmapGraphics;

    Rect destRect(100, 100, imageWidth, imageHeight);

    g->DrawImage(bitmap, destRect, 0, 0, imageWidth, imageHeight, UnitPixel);

    delete bitmap;
}

VOID TestWmfs(Graphics *g)
{
    GraphicsState s = g->Save();
    Metafile * playback = new Metafile(L"Globe.wmf");
//    Metafile * playback = new Metafile(L"..\\data\\Flower.wmf");
//    Metafile * playback = new Metafile(L"..\\\\radt\\vbssdb\\VbTests\\shadow\\WFCClientRuntime\\Libs\\WFCTestLib\\Util\\Images\\Flower.wmf");

    g->SetPageUnit(UnitInch);
    g->SetPageScale(1.0f);
    g->DrawImage(playback, 0.5f, 0.5f, 4.0f, 4.0f);
    delete playback;
    g->Restore(s);
}

Matrix * GetTransformFromHdc(HDC hdc);

VOID TestMetaGetDC(Graphics *g, HWND hwnd)
{
    {
        GpRectF     frameRect(0, 0, 100, 100);
        HDC hDC = GetDC ( hwnd );
        Gdiplus::Metafile emf ( L"test1.emf", hDC, frameRect, Gdiplus::MetafileFrameUnitPixel );
        ReleaseDC(hwnd, hDC);
        {
            Gdiplus::Graphics graphics ( &emf );
            HDC gDC = graphics.GetHDC ();
            SetWindowOrgEx(gDC, 100, 100, NULL);
            Matrix * m = GetTransformFromHdc(gDC);
            graphics.ReleaseHDC ( gDC );
            graphics.SetTransform(m);
            delete m;

            Gdiplus::Pen p ( Gdiplus::Color::Black, 1);
            graphics.DrawRectangle ( &p, 100, 100, 100, 100 );

            graphics.SetRenderingOrigin(10,3);
            gDC = graphics.GetHDC ();
            HBRUSH brush = CreateSolidBrush ( 0x00FF00 );
            HBRUSH prev  = ( HBRUSH ) SelectObject ( gDC, brush );
            ExtFloodFill(gDC, 170, 170, 0xffffff, FLOODFILLSURFACE);
            SelectObject ( gDC, prev );
            DeleteObject ( brush );
            graphics.ReleaseHDC ( gDC );
        }
    }

    Gdiplus::Metafile emf ( L"test1.emf" );
    g->DrawImage ( &emf, 10, 10 );
}

#define LTOF(x)         (static_cast<REAL>(x))
Matrix * GetTransformFromHdc(HDC hdc)
{
    POINT       points[3];
    PointF      destPoints[3];
    RectF       srcRect;
    RectF       destRect;

    // It would take a lot of time to call all the Win32 APIs to query
    // the transform: we would minimally have to call GetMapMode,
    // GetWindowOrgEx, and GetViewportOrgEx; and maximally also have to
    // call GetWorldTransform, GetViewportExtEx, and GetWindowExtEx.
    //
    // We cheat a little by making a single call to LPtoDP with a
    // parallelogram, and then inferring the result.  Note that we do
    // run the risk of some error, and on Win9x of overflow, since Win9x
    // only supports 16-bit coordinates.  To counteract this, we try to
    // choose large values that won't overflow.

    points[0].x = 0;
    points[0].y = 0;
    points[1].x = 8192;
    points[1].y = 0;
    points[2].x = 0;
    points[2].y = 8192;

    if (!LPtoDP(hdc, points, 3))
    {
        return NULL;
    }

    srcRect.X      = 0.0f;
    srcRect.Y      = 0.0f;
    srcRect.Width  = 8192.0f;
    srcRect.Height = 8192.0f;

    destPoints[0].X = LTOF(points[0].x);
    destPoints[0].Y = LTOF(points[0].y);
    destPoints[1].X = LTOF(points[1].x);
    destPoints[1].Y = LTOF(points[1].y);
    destPoints[2].X = LTOF(points[2].x);
    destPoints[2].Y = LTOF(points[2].y);

    return new Matrix(srcRect, destPoints);
}

VOID TestLineWithTexture(Graphics *g)
{
    Bitmap          andrew(L"Gio.jpg");
    TextureBrush    textureBrush(&andrew, WrapModeTile);
    Pen             pen(&textureBrush, 40.0);

    pen.SetLineJoin(LineJoinMiter);

    PointF  spiralPoints[12] = {
        PointF(540.0f, 550.0f),
        PointF(540.0f,  75.0f),
        PointF( 60.0f,  75.0f),
        PointF( 60.0f, 460.0f),
        PointF(460.0f, 460.0f),
        PointF(460.0f, 140.0f),
        PointF(140.0f, 140.0f),
        PointF(140.0f, 400.0f),
        PointF(380.0f, 400.0f),
        PointF(380.0f, 190.0f),
        PointF(260.0f, 190.0f),
        PointF(260.0f, 350.0f),
        };

     g->DrawLines(&pen, spiralPoints, 12);
}

VOID TestRotatedLine(Graphics *g)
{
    INT             i;
    SolidBrush      blueBrush(Color(128, 0, 0, 255));
    Pen             pen(&blueBrush, 10.0);
    GraphicsState   gState = g->Save();
    PointF          points[3];

    pen.SetDashStyle(DashStyleDot);
    pen.SetEndCap(LineCapRound);

    points[0].X = 200; points[0].Y = 200;
    points[1].X = 340; points[1].Y = 200;
    points[2].X = 340; points[2].Y = 345;

#define MYDEGREES     45
    for (i = 0; i < 360; i += MYDEGREES)
    {
        g->TranslateTransform(200, 200);
        g->RotateTransform(MYDEGREES);
        g->TranslateTransform(-200, -200);

        g->DrawLines(&pen, points, 3);
        g->Flush();
    }
    g->Restore(gState);
}

/**************************************************************************\
* TestDibsection
*
* This is a quick visual test for verifying that GDI+ properly draws
* to both top-down and bottom-up DIBSections.  A red square should
* appear in the upper-left corner of both black squares.
*
\**************************************************************************/

VOID TestDibsection(Graphics *g)
{
    BITMAPINFO bmi;
    HBITMAP hbm;
    HDC hdc;
    HDC hdcScreen;
    HBITMAP hbmOld;

    hdcScreen = g->GetHDC();
    hdc = CreateCompatibleDC(hdcScreen);
    SolidBrush blackBrush(Color::Black);
    SolidBrush redBrush(Color::Red);

    //////////////////////////////////////////////////////
    // First, create the DIB-section as bottom-up:

    RtlZeroMemory(&bmi, sizeof(bmi));

    bmi.bmiHeader.biSize        = sizeof(BITMAPINFOHEADER);
    bmi.bmiHeader.biWidth       = 31;
    bmi.bmiHeader.biHeight      = 31;
    bmi.bmiHeader.biPlanes      = 1;
    bmi.bmiHeader.biBitCount    = 32;
    bmi.bmiHeader.biCompression = BI_RGB;

    hbm = CreateDIBSection(hdcScreen, &bmi, DIB_RGB_COLORS, NULL, NULL, 0);
    hbmOld = (HBITMAP) SelectObject(hdc, hbm);

    {
        Graphics bitmap(hdc);

        bitmap.FillRectangle(&blackBrush, 0, 0, 31, 31);
        bitmap.FillRectangle(&redBrush, 0, 0, 8, 8);

        BitBlt(hdcScreen, 0, 0, 31, 31, hdc, 0, 0, SRCCOPY);
    }

    SelectObject(hdc, hbmOld);
    DeleteObject(hbm);

    //////////////////////////////////////////////////////
    // Now, create the DIB-section as top-down:

    bmi.bmiHeader.biHeight = -31;

    hbm = CreateDIBSection(hdcScreen, &bmi, DIB_RGB_COLORS, NULL, NULL, 0);
    hbmOld = (HBITMAP) SelectObject(hdc, hbm);

    {
        Graphics bitmap(hdc);

        bitmap.FillRectangle(&blackBrush, 0, 0, 31, 31);
        bitmap.FillRectangle(&redBrush, 0, 0, 8, 8);

        BitBlt(hdcScreen, 40, 0, 31, 31, hdc, 0, 0, SRCCOPY);
    }

    SelectObject(hdc, hbmOld);
    DeleteObject(hbm);

    //////////////////////////////////////////////////////

    g->ReleaseHDC(hdcScreen);
    DeleteObject(hdc);
}

/**************************************************************************\
* TestCompoundLines
*
* A test for compound lines.
*
\**************************************************************************/

VOID TestCompoundLines(Graphics *g)
{
    REAL width = 4;         // Pen width
    PointF points[4];

    points[0].X = 100;
    points[0].Y = 10;
    points[1].X = -50;
    points[1].Y = 50;
    points[2].X = 150;
    points[2].Y = 200;
    points[3].X = 200;
    points[3].Y = 70;

    Color yellowColor(128, 255, 255, 0);
    SolidBrush yellowBrush(yellowColor);

    GraphicsPath* path = new GraphicsPath(FillModeAlternate);
    path->AddBeziers(points, 4);

    points[0].X = 260;
    points[0].Y = 20;
    path->AddLines(points, 1);
    Matrix matrix;
    matrix.Scale(1.5, 1.5);
    matrix.Translate(0, 30);

    // If you wanto to flatten the path before rendering,
    // Flatten() can be called.

    BOOL flattenFirst = FALSE;

    if(!flattenFirst)
    {
        // Don't flatten and keep the original path.
        // FillPath or DrawPath will flatten the path automatically
        // without modifying the original path.

        path->Transform(&matrix);
    }
    else
    {
        // Flatten this path.  The resultant path is made of line
        // segments.  The original path information is lost.

        path->Flatten(&matrix);
    }

    Color blackColor(0, 0, 0);

    SolidBrush blackBrush(blackColor);
    // Set the pen width in inch.
    width = 15;
    Pen blackPen(&blackBrush, width);

    REAL* compoundArray = new REAL[6];
    compoundArray[0] = 0.0f;
    compoundArray[1] = 0.2f;
    compoundArray[2] = 0.4f;
    compoundArray[3] = 0.6f;
    compoundArray[4] = 0.8f;
    compoundArray[5] = 1.0f;
    blackPen.SetCompoundArray(&compoundArray[0], 6);
    blackPen.SetDashStyle(DashStyleDash);

    blackPen.SetStartCap(LineCapDiamondAnchor);
    blackPen.SetEndCap(LineCapArrowAnchor);

    g->FillPath(&yellowBrush, path);
    g->DrawPath(&blackPen, path);
    delete path;
}

VOID TestImageSampling(Graphics* g)
{
    // Load bmp files.

    WCHAR *filename = L"..\\data\\3x3.bmp";

    Image *image = new Image(filename);

    // Get information on the image.

    if (image && (image->GetLastStatus() == Ok))
    {
        UINT imageWidth = image->GetWidth();
        UINT imageHeight = image->GetHeight();

        if (image->GetLastStatus() == Ok)
        {
            if (imageHeight >= 2 && imageWidth >= 2)
            {
                // Draw the whole image

                Rect destRect(50, 10, 100, 100);
                g->DrawImage(image, destRect,
                             0, 0, imageWidth, imageHeight,
                             UnitPixel);

                // Stretch pixel (1, 1)

                NextDestRect(50, 10, &destRect);
                g->DrawImage(image, destRect,
                             1, 1, 1, 1,
                             UnitPixel);
            }
            else
                LBprintf("Image is %ldx%ld, 2x2 image or greater required",
                         imageWidth, imageHeight);
        }
    }
    else
        LBprintf("Failed to load image file %ws", filename);

    delete image;
}

VOID TestIcon(Graphics* g)
{
    Rect destRect(50, 10, 8, 8);

    // Load bmp files.

    //WCHAR *filename = L"..\\data\\nyt.ico";
    //WCHAR *filename = L"..\\data\\pos.ico";
    //WCHAR *filename = L"..\\data\\signl.ico";
    WCHAR *filename = L"..\\data\\wbros.ico";

    Image *image = new Image(filename);

    // Get information on the image.

    if (image)
    {
        if (image->GetLastStatus() == Ok)
        {
            UINT imageWidth = image->GetWidth();
            UINT imageHeight = image->GetHeight();

            if (image->GetLastStatus() == Ok)
            {
                LBprintf("icon size: %ld x %ld", imageWidth, imageHeight);

                g->DrawImage(image, destRect);
                g->Flush();

                NextDestRect(50, 10, &destRect);
                destRect.Width = 12;
                destRect.Height = 12;

                g->DrawImage(image, destRect);
                g->Flush();

                NextDestRect(50, 10, &destRect);
                destRect.Width = 16;
                destRect.Height = 16;

                g->DrawImage(image, destRect);
                g->Flush();

                NextDestRect(50, 10, &destRect);
                destRect.Width = 24;
                destRect.Height = 24;

                g->DrawImage(image, destRect);
                g->Flush();

                NextDestRect(50, 10, &destRect);
                destRect.Width = 32;
                destRect.Height = 32;

                g->DrawImage(image, destRect);
                g->Flush();

                NextDestRect(50, 10, &destRect);
                destRect.Width = 48;
                destRect.Height = 48;

                g->DrawImage(image, destRect,
                             0, 0, imageWidth, imageHeight,
                             UnitPixel
                             );
                g->Flush();

                NextDestRect(50, 10, &destRect);
                destRect.Width = 64;
                destRect.Height = 64;

                g->DrawImage(image, destRect,
                             0, 0, imageWidth, imageHeight,
                             UnitPixel
                             );
                g->Flush();
            }
            else
                LBprintf("Failed to get image width/height");
        }

        delete image;
    }
    else
        LBprintf("Failed to load image file %ws", filename);

    HICON hicon = LoadIcon(NULL, IDI_ERROR);

    if (hicon)
    {
        Bitmap *icon = new Bitmap(hicon);

        if (icon)
        {
            NextDestRect(50, 10, &destRect);
            destRect.Width = 32;
            destRect.Height = 32;

            g->DrawImage(icon, destRect);

            delete icon;
        }
        else
            LBprintf("Failed to create Bitmap from HICON");

        WCHAR *iconfile = L"..\\data\\pos.ico";

        Bitmap* bitmap = new Bitmap(iconfile);

        if (bitmap)
        {
            HDC hdc = g->GetHDC();
            if (hdc)
            {
                HICON hicon2;

                if (bitmap->GetHICON(&hicon2) == Ok)
                {
                    DrawIcon(hdc, 100, 100, hicon2);

                    DestroyIcon(hicon2);
                }
                else
                    LBprintf("Bitmap::GetHICON failed");

                g->ReleaseHDC(hdc);
            }

            delete bitmap;
        }
        else
            LBprintf("Failed to load %ws", iconfile);

        DestroyIcon(hicon);
    }
    else
        LBprintf("Failed to load Win32 icon IDI_ERROR");
}

VOID TestTextToMetafile(Graphics *g, HDC hdc)
{
    FontFamily  ff(L"Arial");
    RectF     rectf(20, 0, 300, 200);
    Font    font(&ff, 20, FontStyleBold, UnitPixel);
    SolidBrush brush(Color(128, 100, 0, 200));

    g->DrawString(L"The quick brown fox jumped over the lazy dog", -1,
                         &font, rectf, NULL, &brush);

    g->Flush();

    Metafile metaFile(L"Text.emf", hdc);
    {
        Graphics gMeta(&metaFile);
        gMeta.DrawString(L"ABCDEFG", 7,
                         &font, rectf, NULL, &brush);
    }
    g->DrawImage(&metaFile, 100, 100);
    g->Flush();
}

VOID TestCmykSeparation(Graphics *g)
{
    HINSTANCE hinst = GetModuleHandle(NULL);

    if (hinst)
    {
        Bitmap *bitmap = new Bitmap(hinst, MAKEINTRESOURCE(IDB_BITMAPCMYKTEST));

        // Get information on the bitmap.

        if (bitmap)
        {
            if (bitmap->GetLastStatus() == Ok)
            {
                UINT width = bitmap->GetWidth();
                UINT height = bitmap->GetHeight();

                if (bitmap->GetLastStatus() == Ok)
                {
                    Rect destRect(150, 10, 100, 100);

                    ImageAttributes imgAttrib;

                    imgAttrib.SetOutputChannelColorProfile(L"..\\data\\mswopallp8.icm");
                    imgAttrib.SetOutputChannel(ColorChannelFlagsC);
                    g->DrawImage(bitmap, destRect,
                                 0, 0, width, height,
                                 UnitPixel, &imgAttrib);
                    NextDestRect(150, 10, &destRect);

                    imgAttrib.SetOutputChannel(ColorChannelFlagsM);
                    g->DrawImage(bitmap, destRect,
                                 0, 0, width, height,
                                 UnitPixel, &imgAttrib);
                    NextDestRect(150, 10, &destRect);

                    imgAttrib.SetOutputChannel(ColorChannelFlagsY);
                    g->DrawImage(bitmap, destRect,
                                 0, 0, width, height,
                                 UnitPixel, &imgAttrib);
                    NextDestRect(150, 10, &destRect);

                    imgAttrib.SetOutputChannel(ColorChannelFlagsK);
                    g->DrawImage(bitmap, destRect,
                                 0, 0, width, height,
                                 UnitPixel, &imgAttrib);
                    NextDestRect(150, 10, &destRect);

                    imgAttrib.SetOutputChannelColorProfile(L"..\\data\\mswopintent.icm");
                    imgAttrib.SetOutputChannel(ColorChannelFlagsC);
                    g->DrawImage(bitmap, destRect,
                                 0, 0, width, height,
                                 UnitPixel, &imgAttrib);
                    NextDestRect(150, 10, &destRect);

                    imgAttrib.SetOutputChannel(ColorChannelFlagsM);
                    g->DrawImage(bitmap, destRect,
                                 0, 0, width, height,
                                 UnitPixel, &imgAttrib);
                    NextDestRect(150, 10, &destRect);

                    imgAttrib.SetOutputChannel(ColorChannelFlagsY);
                    g->DrawImage(bitmap, destRect,
                                 0, 0, width, height,
                                 UnitPixel, &imgAttrib);
                    NextDestRect(150, 10, &destRect);

                    imgAttrib.SetOutputChannel(ColorChannelFlagsK);
                    g->DrawImage(bitmap, destRect,
                                 0, 0, width, height,
                                 UnitPixel, &imgAttrib);
                    NextDestRect(150, 10, &destRect);

                    imgAttrib.ClearOutputChannelColorProfile();
                    imgAttrib.SetOutputChannel(ColorChannelFlagsC);
                    g->DrawImage(bitmap, destRect,
                                 0, 0, width, height,
                                 UnitPixel, &imgAttrib);
                    NextDestRect(150, 10, &destRect);

                    imgAttrib.SetOutputChannel(ColorChannelFlagsM);
                    g->DrawImage(bitmap, destRect,
                                 0, 0, width, height,
                                 UnitPixel, &imgAttrib);
                    NextDestRect(150, 10, &destRect);

                    imgAttrib.SetOutputChannel(ColorChannelFlagsY);
                    g->DrawImage(bitmap, destRect,
                                 0, 0, width, height,
                                 UnitPixel, &imgAttrib);
                    NextDestRect(150, 10, &destRect);

                    imgAttrib.SetOutputChannel(ColorChannelFlagsK);
                    g->DrawImage(bitmap, destRect,
                                 0, 0, width, height,
                                 UnitPixel, &imgAttrib);
                    NextDestRect(150, 10, &destRect);


                    imgAttrib.ClearOutputChannel();
                    g->DrawImage(bitmap, destRect,
                                 0, 0, width, height,
                                 UnitPixel, &imgAttrib);
                    NextDestRect(150, 10, &destRect);
                }
            }

            delete bitmap;
        }
        else
            LBprintf("Failed to bitmap resource");
    }
    else
        LBprintf("Failed to get module handle");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\drawimage\drawimage.cpp ===
/******************************Module*Header*******************************\
* Module Name: drawimage.cpp
*
* Created: 23 December 1999
* Author: Adrian Secchia [asecchia]
*
* Copyright (c) 1999,Microsoft Corporation
*
* This is the DrawImage unit test.
*
\**************************************************************************/

#include <windows.h>
#include <objbase.h>
#include <math.h>             // sin & cos

// Define away IStream
#define IStream int

#include <gdiplus.h>
#include <stdlib.h>
#include <stdio.h>
#include <tchar.h>

#include "drawimage.hpp"
#include "wndstuff.h"

using namespace Gdiplus;
#define USE_NEW_APIS 1
#define USE_NEW_APIS2 1


ImageAttributes *Img = NULL;

/***************************************************************************\
* DrawXXXX
*
* These routines are all the individual tests that this test
* suite will use.
\***************************************************************************/

// No fancy stuff - just put the whole image in the window.
// No rotation, stretching, etc.

#if 0
// cached bitmap in animated infinite loop

VOID DrawSimple(Graphics *g)
{
  unsigned short filename[1024];

  CachedBitmap *frame[32];
  Bitmap *temp;
  Graphics *gbmp;

  Unit u;
  RectF r;


  for(int i=0; i<32; i++) {
      wsprintf(filename, L"T%d.bmp", i);
      temp = new Bitmap(filename);
      temp->GetBounds(&r, &u);
//      r.Width *=2;
//      r.Height *=2;

      frame[i] = new CachedBitmap(temp, g);

//      gbmp = new Graphics(frame[i]);

//      gbmp->SetInterpolationMode(InterpolationModeHighQualityBilinear);

/*      Matrix *m = new Matrix(1.0f, 0.0f,
                             0.0f, -1.0f,
                             0.0f, r.Height);
      gbmp->SetTransform(m);
  */
//      gbmp->DrawImage(temp, 0, 0, (INT)r.Width, (INT)r.Height);

//      delete gbmp;
      delete temp;
//      delete m;
  }
  RectF s = r;

  i = 0;
  int j;

  while(++i) {

//    for(j=0; j<3; j++)
//    g->DrawImage(frame[i % 32], s, r.X, r.Y, r.Width, r.Height, UnitPixel);
      g->DrawCachedBitmap(frame[i % 32], 10, 10);
  }

}

#endif

VOID DrawSimple(Graphics *g)
{

    Bitmap *image = new Bitmap(FileName);

    Unit u;
    RectF r;

    image->GetBounds(&r, &u);

    RectF s = r;

    s.X = 31;
    s.Y = 27;
    
    s.Width *= 0.7f;
    s.Height *= 0.7f;

    g->DrawImage(image, s, r.X, r.Y, r.Width, r.Height, UnitPixel);
    g->SetClip(Rect(50, 70, 100, 10));
    
    ImageAttributes img;
    ColorMatrix flipRedBlue = {
        0, 1, 0, 0, 0,
        0, 0, 1, 0, 0,
        1, 0, 0, 0, 0,
        0, 0, 0, 1, 0,
        0, 0, 0, 0, 1
    };
    img.SetColorMatrix(&flipRedBlue);
    
    g->DrawImage(image, s, r.X, r.Y, r.Width, r.Height, UnitPixel, &img);
    g->ResetClip();

    delete image;
}

VOID DrawSpecialRotate(Graphics *g)
{
    Bitmap *image = new Bitmap(FileName);
    
    Unit u;
    RectF r;
    image->GetBounds(&r, &u);
    RectF s = r;

    ImageAttributes img;
    
    ColorMatrix flipRedBlue = {
        0, 1, 0, 0, 0,
        1, 0, 0, 0, 0,
        0, 0, 1, 0, 0,
        0, 0, 0, 1, 0,
        0, 0, 0, 0, 1
    };
    img.SetColorMatrix(&flipRedBlue);
    
    g->SetCompositingQuality(CompositingQualityGammaCorrected);

    Rect dstRect(0, 0, 50, 100);
    Rect srcRect(12, -14, 50, 100);
    
    g->TranslateTransform(s.Height, 0.0f);
    g->RotateTransform(90);
    g->DrawImage(image, s, r.X, r.Y, r.Width, r.Height, UnitPixel, Img);
    g->ResetTransform();

    g->TranslateTransform(s.Height, s.Width);
    g->RotateTransform(270);
    g->DrawImage(image, s, r.X, r.Y, r.Width, r.Height, UnitPixel, Img);
    g->ResetTransform();

    g->TranslateTransform(s.Width, s.Height+s.Width);
    g->RotateTransform(180);
    g->DrawImage(image, s, r.X, r.Y, r.Width, r.Height, UnitPixel, Img);
    g->ResetTransform();

    g->TranslateTransform(s.Width+2*s.Height, 0.0f);
    g->ScaleTransform(-1.0, 1.0);
    g->DrawImage(image, s, r.X, r.Y, r.Width, r.Height, UnitPixel, Img);
    g->ResetTransform();
    
    g->TranslateTransform(2*s.Height, s.Height*2);
    g->ScaleTransform(1.0, -1.0);
    g->DrawImage(image, s, r.X, r.Y, r.Width, r.Height, UnitPixel, Img);
    g->ResetTransform();

    g->TranslateTransform(s.Width+2*s.Height, 0.0f);
    g->ScaleTransform(-1.0, 1.0);
    g->RotateTransform(90);
    g->DrawImage(image, s, r.X, r.Y, r.Width, r.Height, UnitPixel, Img);
    g->ResetTransform();
    
    g->TranslateTransform(s.Width+3*s.Height, 2*s.Width);
    g->ScaleTransform(-1.0, 1.0);
    g->RotateTransform(270);
    g->DrawImage(image, s, r.X, r.Y, r.Width, r.Height, UnitPixel, Img);
    g->ResetTransform();
    
    
    
    //Rot180
    g->TranslateTransform(400.0f, 500.0f);
    g->RotateTransform(180);
    g->DrawImage(image, dstRect,srcRect.X, srcRect.Y, srcRect.Width, srcRect.Height+1, UnitPixel, &img);
    g->ResetTransform();

    g->TranslateTransform(400.0f, 500.0f);
    g->RotateTransform(180);
    g->DrawImage(image, dstRect,srcRect.X, srcRect.Y, srcRect.Width, srcRect.Height, UnitPixel);
    g->ResetTransform();
    
    //ID
    g->TranslateTransform(400.0f, 500.0f);
    g->RotateTransform(0);
    g->DrawImage(image, dstRect,srcRect.X, srcRect.Y, srcRect.Width, srcRect.Height+1, UnitPixel, &img);
    g->ResetTransform();

    g->TranslateTransform(400.0f, 500.0f);
    g->RotateTransform(0);
    g->DrawImage(image, dstRect,srcRect.X, srcRect.Y, srcRect.Width, srcRect.Height, UnitPixel);
    g->ResetTransform();

    //Rot270FlipX
    g->TranslateTransform(600.0f, 500.0f);
    g->ScaleTransform(-1.0f, 1.0f);
    g->RotateTransform(270);
    g->DrawImage(image, dstRect,srcRect.X, srcRect.Y, srcRect.Width, srcRect.Height+1, UnitPixel, &img);
    g->ResetTransform();

    g->TranslateTransform(600.0f, 500.0f);
    g->ScaleTransform(-1.0f, 1.0f);
    g->RotateTransform(270);
    g->DrawImage(image, dstRect,srcRect.X, srcRect.Y, srcRect.Width, srcRect.Height, UnitPixel);
    g->ResetTransform();

    //Rot270
    g->TranslateTransform(600.0f, 500.0f);
    g->RotateTransform(270);
    g->DrawImage(image, dstRect,srcRect.X, srcRect.Y, srcRect.Width, srcRect.Height+1, UnitPixel, &img);
    g->ResetTransform();

    g->TranslateTransform(600.0f, 500.0f);
    g->RotateTransform(270);
    g->DrawImage(image, dstRect,srcRect.X, srcRect.Y, srcRect.Width, srcRect.Height, UnitPixel);
    g->ResetTransform();

    //Rot90FlipX
    g->TranslateTransform(600.0f, 500.0f);
    g->ScaleTransform(-1.0f, 1.0f);
    g->RotateTransform(90);
    g->DrawImage(image, dstRect,srcRect.X, srcRect.Y, srcRect.Width, srcRect.Height+1, UnitPixel, &img);
    g->ResetTransform();

    g->TranslateTransform(600.0f, 500.0f);
    g->ScaleTransform(-1.0f, 1.0f);
    g->RotateTransform(90);
    g->DrawImage(image, dstRect,srcRect.X, srcRect.Y, srcRect.Width, srcRect.Height, UnitPixel);
    g->ResetTransform();

    //Rot90
    g->TranslateTransform(600.0f, 500.0f);
    g->RotateTransform(90);
    g->DrawImage(image, dstRect,srcRect.X, srcRect.Y, srcRect.Width, srcRect.Height+1, UnitPixel, &img);
    g->ResetTransform();

    g->TranslateTransform(600.0f, 500.0f);
    g->RotateTransform(90);
    g->DrawImage(image, dstRect,srcRect.X, srcRect.Y, srcRect.Width, srcRect.Height, UnitPixel);
    g->ResetTransform();

    // FlipX
    g->TranslateTransform(600.0f, 300.0f);
    g->ScaleTransform(-1.0f, 1.0f);
    g->DrawImage(image, dstRect,srcRect.X, srcRect.Y, srcRect.Width, srcRect.Height+1, UnitPixel, &img);
    g->ResetTransform();

    g->TranslateTransform(600.0f, 300.0f);
    g->ScaleTransform(-1.0f, 1.0f);
    g->DrawImage(image, dstRect,srcRect.X, srcRect.Y, srcRect.Width, srcRect.Height, UnitPixel);
    g->ResetTransform();

    // FlipY
    g->TranslateTransform(600.0f, 300.0f);
    g->ScaleTransform(1.0f, -1.0f);
    g->DrawImage(image, dstRect,srcRect.X, srcRect.Y, srcRect.Width, srcRect.Height+1, UnitPixel, &img);
    g->ResetTransform();

    g->TranslateTransform(600.0f, 300.0f);
    g->ScaleTransform(1.0f, -1.0f);
    g->DrawImage(image, dstRect,srcRect.X, srcRect.Y, srcRect.Width, srcRect.Height, UnitPixel);
    g->ResetTransform();

    delete image;
}




VOID DrawCachedBitmap(Graphics *g)
{
    Bitmap *image = new Bitmap(FileName);
    
    Bitmap *bmp = new Bitmap(100, 100, PixelFormat32bppPARGB);
    Graphics *gfx = new Graphics(bmp);
    gfx->DrawImage(image, Rect(0,0,100,100), 0,0,100,100, UnitPixel);
    gfx->SetCompositingMode(CompositingModeSourceCopy);
    SolidBrush brush(Color(0x7f0000ff));
    gfx->FillEllipse(&brush, 0, 0, 100, 100);
    brush.SetColor(Color(0x00000000));
    gfx->FillEllipse(&brush, 25, 25, 50, 50);

    delete image;
    delete gfx;
        
    CachedBitmap *cb = new CachedBitmap(bmp, g);

    int x;
    for(int i=0; i<=40; i++)
    {
        x = i-20;
        g->DrawCachedBitmap(cb, x*x, i*10);
    }

    delete cb;
    delete bmp;
}


// Slightly rotated stretch.
VOID DrawStretchRotation(Graphics *g)
{
  Image *image = new Bitmap(FileName);

  PointF dst[4];
  dst[0].X = 20;
  dst[0].Y = 0;
  dst[1].X = 900;
  dst[1].Y = 20;
  dst[2].X = 0;
  dst[2].Y = 700;

  g->DrawImage(image, dst, 3);
  delete image;
}

// Slightly rotated stretch.
VOID DrawShrinkRotation(Graphics *g)
{
  Image *image = new Bitmap(FileName);

  PointF dst[4];

  dst[0].X = 14.1521f;
  dst[0].Y = 11.0205f;
  dst[1].X = 25.4597f;
  dst[1].Y = 10.5023f;
  dst[2].X = 14.5403f;
  dst[2].Y = 19.4908f;


  g->DrawImage(image, dst, 3);
  delete image;
}

// Rotated stretch with source cropping.
VOID DrawCropRotation(Graphics *g)
{
  Image *image = new Bitmap(FileName);

  PointF dst[4];
  dst[0].X = 20;
  dst[0].Y = 0;
  dst[1].X = 180;
  dst[1].Y = 20;
  dst[2].X = 0;
  dst[2].Y = 140;

  g->DrawImage(image, dst, 3, 0, 0, 488, 400, UnitPixel);
  delete image;
}

// Draw multiple copybits with different source cropping and
// destination positions.
// Little squares are drawn in reverse order from their source position and
// only alternate squares from a checkerboard pattern are drawn.
// Note outcropping can occur along the bottom and right edge of the source -
// which would be the top and left row of squares in the output.
VOID DrawCopyCrop(Graphics *g)
{
  Image *image = new Bitmap(FileName);
  const INT xs = 10;
  const INT ys = 6;
  const INT step = 50;
  Rect s(0,0,step,step);
  for(int i=0; i<xs; i++) for(int j=0; j<ys; j++) {
      if(((i+j) & 0x1)==0x1) {
          s.X = i*step-15;
          s.Y = j*step-15;
          g->DrawImage(image, s,
                       (xs-i-1)*step, (ys-j-1)*step, step, step, UnitPixel);
      }
  }

  delete image;
}


// Pixel centering test. This test should show
// the correct pixel centering. The top left should be green and the bottom
// and right should be blending in the blend color
VOID DrawPixelCenter(Graphics *g)
{
  WCHAR *filename = L"../data/3x3.bmp";
  Image *image = new Bitmap(filename);


  Color black(0xff,0,0,0);
  Pen linepen(black, 1);

  RectF r(100.0f, 100.0f, 300.0f, 300.0f);

  for(int i=0; i<6; i++) {
      g->DrawLine(&linepen, 100*i, 0, 100*i, 600);
      g->DrawLine(&linepen, 0, 100*i, 600, 100*i);
  }

  g->DrawImage(image, r, 0.0f, 0.0f, 3.0f, 3.0f, UnitPixel, Img);
  delete image;
}

// Draw with palette modification.

VOID DrawPalette(Graphics *g)
{
    Image *image = new Bitmap(FileName, uICM==IDM_ICM);

    Unit u;
    RectF r;
    image->GetBounds(&r, &u);
    RectF s = r;
    s.X = 21;
    s.Y = 30;

    ColorPalette *palette = NULL;
    INT size;
    Status status;

    // Whack the first entry in the palette.

    size = image->GetPaletteSize();
    if(size > 0) {
        palette = (ColorPalette *)malloc(size);
        if(palette) {
            status = image->GetPalette(palette, size);
            if(status == Ok) {
                palette->Entries[0] = 0x7fff0000;
                status = image->SetPalette(palette);
            }
        }
    }

    g->DrawImage(image, r, r.X, r.Y, r.Width, r.Height, UnitPixel);

    free(palette);
    delete image;
}


// Specify source rectangle crop area not at the origin.
// Draw off the top of the window (negative destination).
VOID DrawICM(Graphics *g)
{
  Bitmap *image = new Bitmap(FileName, uICM==IDM_ICM);
  
  // Our ICM profile is hacked to flip the red and blue color channels
  // Apply a recolor matrix to flip them back so that if something breaks
  // ICM, the picture will look blue instead of the familiar colors.
  ColorMatrix flipRedBlue =
       {0, 1, 0, 0, 0,
        0, 0, 1, 0, 0,
        1, 0, 0, 0, 0,
        0, 0, 0, 1, 0,
        0, 0, 0, 0, 1};
  /*img->SetColorMatrix(&flipRedBlue);*/
        Unit u;
        RectF r;
        image->GetBounds(&r, &u);
        RectF s = r;
        s.X = 21;
        s.Y = 30;
  g->DrawImage(image, r, r.X, r.Y, r.Width, r.Height, UnitPixel, Img);

/*  CachedBitmap *cb = new CachedBitmap(image, g);
  g->DrawCachedBitmap(cb, 100, 100);
  delete cb;*/
  delete image;
}

// Draw a non rotated outcropped image.
VOID DrawOutCrop(Graphics *g)
{
  Image *image = new Bitmap(FileName);

  g->DrawImage(image, Rect(0,0,500,500), -500,-500,1500,1500, UnitPixel, Img);
  delete image;
}

// Do a non-trivial crop with a world transform applied.
VOID DrawCropWT(Graphics *g)
{
  Image *image = new Bitmap(FileName);

  g->TranslateTransform(0, 100.0f);
  g->DrawImage(image, 0, 0, 100,100,600,400, UnitPixel);
  g->ResetTransform();
  delete image;
}

// Non-trivial cropping combined with a horizontal flip and a world transform
VOID DrawHFlip(Graphics *g)
{
  Image *image = new Bitmap(FileName);

  PointF dst[4];
  dst[0].X = 400;
  dst[0].Y = 200;
  dst[1].X = 0;
  dst[1].Y = 200;
  dst[2].X = 400;
  dst[2].Y = 500;

  g->TranslateTransform(0, 100.0f);
  g->DrawImage(image, dst, 3, 100, 100, 600, 400, UnitPixel);
  g->ResetTransform();

  delete image;
}

// Non-trivial cropping combined with a vertical flip and a world transform
VOID DrawVFlip(Graphics *g)
{
  Image *image = new Bitmap(FileName);

  PointF dst[4];
  dst[0].X = 0;
  dst[0].Y = 500;
  dst[1].X = 400;
  dst[1].Y = 500;
  dst[2].X = 0;
  dst[2].Y = 200;

  g->TranslateTransform(0, 100.0f);
  g->DrawImage(image, dst, 3, 100, 100, 600, 400, UnitPixel);
  g->ResetTransform();

  delete image;
}


// Draw stretched image.
VOID DrawStretchS(Graphics *g)
{
  Image *image = new Bitmap(FileName);

  RectF r;

  for(int i=6; i<15; i++)
  {
      g->DrawImage(image, (i+1)*i*10/2-200, 300, i*10, i*10);
  }

  g->DrawImage(image, 0, 0, 470, 200);
  g->DrawImage(image, 500, 100, 300, 300);
  g->DrawImage(image, 100, 500, 400, 300);
  g->DrawImage(image, 500, 500, 300, 80);
  delete image;
}

// Draw stretched image.
VOID DrawStretchB(Graphics *g)
{
  Image *image = new Bitmap(FileName);
  g->DrawImage(image, 100, 100, 603, 603);
  delete image;
}


// Draw a rotated outcropped image.
VOID DrawOutCropR(Graphics *g)
{
  Image *image = new Bitmap(FileName);

  PointF dst[4];
  dst[0].X = 20;
  dst[0].Y = 0;
  dst[1].X = 180;
  dst[1].Y = 20;
  dst[2].X = 0;
  dst[2].Y = 140;

  g->DrawImage(image, dst, 3, -50,-50,600,400, UnitPixel);
  delete image;
}

// Simple no rotation, origin based source clip.
VOID DrawTest2(Graphics *g)
{
  Image *image = new Bitmap(FileName);
  g->DrawImage(image, 0, 0, 0, 0,100,100, UnitPixel);
  delete image;
}

/***************************************************************************\
* DoTest
*
* Sets up the graphics according to the selected parameters on the menu
* and then invokes the appropriate test routine from above.
\***************************************************************************/

VOID
DoTest(
    HWND hwnd
    )
{
  // Create a Graphics in the window.
//  Graphics *g = Graphics::GetFromHwnd(hwnd, uICMBack==IDM_ICM_BACK);

  HDC hdc = GetDC(hwnd);
  SetICMMode(hdc, (uICMBack==IDM_ICM_BACK)?ICM_ON:ICM_OFF);
  Graphics *g = new Graphics(hdc);

  g->SetSmoothingMode(SmoothingModeNone);

  // Choose the resampling mode.
  switch(uResample) {
  case IDM_BILINEAR:
      g->SetInterpolationMode(InterpolationModeBilinear);
  break;
  case IDM_BICUBIC:
      g->SetInterpolationMode(InterpolationModeBicubic);
  break;
  case IDM_NEARESTNEIGHBOR:
      g->SetInterpolationMode(InterpolationModeNearestNeighbor);
  break;
  case IDM_HIGHBILINEAR:
      g->SetInterpolationMode(InterpolationModeHighQualityBilinear);
  break;
  case IDM_HIGHBICUBIC:
      g->SetInterpolationMode(InterpolationModeHighQualityBicubic);
  break;
  default:
  break;
  }

  g->SetPixelOffsetMode(bPixelMode?PixelOffsetModeHalf:PixelOffsetModeNone);

  Img = new ImageAttributes();
  switch(uWrapMode)
  {
      case IDM_WRAPMODETILE: 
          Img->SetWrapMode(WrapModeTile, Color(0), FALSE);
      break;
      case IDM_WRAPMODEFLIPX:
          Img->SetWrapMode(WrapModeTileFlipX, Color(0), FALSE);
      break;
      case IDM_WRAPMODEFLIPY:
          Img->SetWrapMode(WrapModeTileFlipY, Color(0), FALSE);
      break;
      case IDM_WRAPMODEFLIPXY:
          Img->SetWrapMode(WrapModeTileFlipXY, Color(0), FALSE);
      break;
      case IDM_WRAPMODECLAMP0:
          Img->SetWrapMode(WrapModeClamp, Color(0), FALSE);
      break;
      case IDM_WRAPMODECLAMPFF:      
          Img->SetWrapMode(WrapModeClamp, Color(0xffff0000), FALSE);
      break;
  }
  // Choose the test to run
  switch(uCategory) {
  case IDM_ALL:
      DrawSimple(g);
      DrawStretchRotation(g);
      DrawShrinkRotation(g);
      DrawCropRotation(g);
      DrawCopyCrop(g);
      DrawICM(g);
      DrawTest2(g);
      DrawOutCrop(g);
      DrawOutCropR(g);
      DrawCropWT(g);
      DrawHFlip(g);
      DrawVFlip(g);
      DrawStretchB(g);
      DrawCachedBitmap(g);
      DrawStretchS(g);
      DrawPalette(g);
      DrawPixelCenter(g);
      DrawSpecialRotate(g);
  break;

  case IDM_OUTCROPR:
      DrawOutCropR(g);
  break;
  case IDM_OUTCROP:
      DrawOutCrop(g);
  break;
  case IDM_SIMPLE:
      DrawSimple(g);
  break;
  case IDM_STRETCHROTATION:
      DrawStretchRotation(g);
  break;
  case IDM_SHRINKROTATION:
      DrawShrinkRotation(g);
  break;
  case IDM_CROPROTATION:           //who says programmers don't do real work??
      DrawCropRotation(g);
  break;
  case IDM_PIXELCENTER:
      DrawPixelCenter(g);
  break;
  case IDM_COPYCROP:
      DrawCopyCrop(g);
  break;
  case IDM_DRAWPALETTE:
      DrawPalette(g);
  break;
  case IDM_DRAWICM:
      DrawICM(g);
  break;
  case IDM_DRAWIMAGE2:
      DrawTest2(g);
  break;
  case IDM_STRETCHB:
      DrawStretchB(g);
  break;
  case IDM_STRETCHS:
      DrawStretchS(g);
  break;
  case IDM_CACHEDBITMAP:
      DrawCachedBitmap(g);
  break;
  case IDM_CROPWT:
      DrawCropWT(g);
  break;
  case IDM_HFLIP:
      DrawHFlip(g);
  break;
  case IDM_VFLIP:
      DrawVFlip(g);
  break;
  case IDM_SPECIALROTATE:
      DrawSpecialRotate(g);
  break;


  default:
  break;
  }

  delete Img;
  Img = NULL;
  delete g;
  ReleaseDC(hwnd, hdc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\dlltest\wndstuff.cpp ===
/******************************Module*Header*******************************\
* Module Name: wndstuff.cpp
*
* This file contains the code to support a simple window that has
* a menu with a single item called "Test". When "Test" is selected
* vTest(HWND) is called.
*
* Created: 09-Dec-1992 10:44:31
* Author: Kirk Olynyk [kirko]
*
* Copyright (c) 1991 Microsoft Corporation
*
\**************************************************************************/

// for Win95 compile
#undef UNICODE
#undef _UNICODE

#include <windows.h>
#include <stdio.h>
#include <tchar.h>
#include <objbase.h>
#include <gdiplus.h>

#include "wndstuff.h"

#include "../gpinit.inc"

HINSTANCE ghInstance;
HWND ghwndMain;
HWND ghwndDebug;
HWND ghwndList;
HBRUSH ghbrWhite;

/***************************************************************************\
* lMainWindowProc(hwnd, message, wParam, lParam)
*
* Processes all messages for the main window.
*
* History:
*  04-07-91 -by- KentD
* Wrote it.
\***************************************************************************/

LONG_PTR
lMainWindowProc(
    HWND    hwnd,
    UINT    message,
    WPARAM  wParam,
    LPARAM  lParam
    )
{
    PAINTSTRUCT ps;

    switch (message)
    {
    case WM_CREATE:
/*        if (!InitializeEngine())
        {
            MessageBox(0, _T("Engine didn't initialize"), _T("Uh oh"), MB_OK);
        }
*/
        break;

    case WM_COMMAND:
        switch(LOWORD(wParam))
        {
        case MM_TEST:
            Test(hwnd);
            break;

        default:
            break;
        }
        break;

    case WM_DESTROY:
//        UninitializeEngine();

        DeleteObject(ghbrWhite);
        PostQuitMessage(0);
        return(DefWindowProc(hwnd, message, wParam, lParam));

    default:
        return(DefWindowProc(hwnd, message, wParam, lParam));
    }

    return(0);
}

/******************************Public*Routine******************************\
* DebugWndProc
*
* List box is maintained here.
*
\**************************************************************************/

LONG_PTR FAR PASCAL DebugWndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    RECT    rcl;
    HDC     hdc;
    LONG_PTR    lRet = 0;

// Process window message.

    switch (message)
    {
    case WM_SIZE:
        lRet = DefWindowProc(ghwndList, message, wParam, lParam);
        GetClientRect(ghwndMain, &rcl);
        MoveWindow(
            ghwndList,
            rcl.left, rcl.top,
            (rcl.right - rcl.left), (rcl.bottom - rcl.top),
            TRUE
            );
        UpdateWindow(ghwndList);
        break;

    case WM_DESTROY:
        PostQuitMessage(0);
        break;

    default:
        lRet = DefWindowProc(hwnd, message, wParam, lParam);
        break;
    }

    return lRet;
}

/******************************Public*Routine******************************\
* LBprintf
*
* ListBox printf implementation.
*
* History:
*  15-Dec-1994 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

void LBprintf(PCH msg, ...)
{
    if (ghwndList)
    {
        va_list ap;
        char buffer[256];

        va_start(ap, msg);

        vsprintf(buffer, msg, ap);

        SendMessage(ghwndList, LB_ADDSTRING, (WPARAM) 0, (LPARAM) buffer);
        SendMessage(ghwndList, WM_SETREDRAW, (WPARAM) TRUE, (LPARAM) 0);
        InvalidateRect(ghwndList, NULL, TRUE);
        UpdateWindow(ghwndList);

        va_end(ap);
    }
}

/******************************Public*Routine******************************\
* LBreset
*
* Reset ListBox state (clear).
*
* History:
*  15-Dec-1994 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

void LBreset()
{
    if (ghwndList)
        SendMessage(ghwndList, LB_RESETCONTENT, (WPARAM) FALSE, (LPARAM) 0);
}

/***************************************************************************\
* bInitApp()
*
* Initializes app.
*
* History:
*  04-07-91 -by- KentD
* Wrote it.
\***************************************************************************/

BOOL bInitApp(BOOL debug)
{
    WNDCLASS wc;

    ghbrWhite = CreateSolidBrush(RGB(0xFF,0xFF,0xFF));

    wc.style            = 0;
    wc.lpfnWndProc      = lMainWindowProc;
    wc.cbClsExtra       = 0;
    wc.cbWndExtra       = 0;
    wc.hInstance        = ghInstance;
    wc.hIcon            = LoadIcon(NULL, IDI_APPLICATION);
    wc.hCursor          = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground    = ghbrWhite;
    wc.lpszMenuName     = _T("MainMenu");
    wc.lpszClassName    = _T("TestClass");
    if (!RegisterClass(&wc))
    {
        return(FALSE);
    }
    ghwndMain =
      CreateWindowEx(
        0,
        _T("TestClass"),
        _T("Win32 Test"),
        WS_OVERLAPPED   |  
        WS_CAPTION      |  
        WS_BORDER       |  
        WS_THICKFRAME   |  
        WS_MAXIMIZEBOX  |  
        WS_MINIMIZEBOX  |  
        WS_CLIPCHILDREN |  
        WS_VISIBLE      |  
        WS_SYSMENU,
        80,
        70,
        500,
        500,
        NULL,
        NULL,
        ghInstance,
        NULL);

    if (ghwndMain == NULL)
    {
        return(FALSE);
    }

    if (debug)
    {
        RECT rcl;

        memset(&wc, 0, sizeof(wc));
        wc.style = 0;
        wc.lpfnWndProc = DebugWndProc;
        wc.cbClsExtra = 0;
        wc.cbWndExtra = 0;
        wc.hInstance = ghInstance;
        wc.hIcon = LoadIcon(NULL, IDI_APPLICATION);
        wc.hCursor = LoadCursor(NULL, IDC_ARROW);
        wc.hbrBackground = ghbrWhite;
        wc.lpszClassName = "DebugWClass";
        RegisterClass(&wc);

        ghwndDebug = CreateWindow(
            "DebugWClass",
            "Debug output",
            WS_OVERLAPPEDWINDOW|WS_MAXIMIZE,
            600,
            70,
            300,
            500,
            NULL,
            NULL,
            ghInstance,
            NULL
            );

        if (ghwndDebug)
        {
            ShowWindow(ghwndDebug, SW_NORMAL);
            UpdateWindow(ghwndDebug);

        // Create the list box to fill the main window.

            GetClientRect(ghwndDebug, &rcl);

            ghwndList = CreateWindow(
                "LISTBOX",
                "Debug output",
                WS_CHILD | WS_VISIBLE | WS_VSCROLL
                | WS_HSCROLL | LBS_NOINTEGRALHEIGHT,
                rcl.left, rcl.top,
                (rcl.right - rcl.left), (rcl.bottom - rcl.top),
                ghwndDebug,
                NULL,
                ghInstance,
                NULL
                );

            if (ghwndList)
            {
                SendMessage(
                    ghwndList,
                    WM_SETFONT,
                    (WPARAM) GetStockObject(ANSI_FIXED_FONT),
                    (LPARAM) FALSE
                    );

                LBreset();

                ShowWindow(ghwndList, SW_NORMAL);
                UpdateWindow(ghwndList);
            }
        }

    }

    SetFocus(ghwndMain);

    return(TRUE);
}

/***************************************************************************\
* main(argc, argv[])
*
* Sets up the message loop.
*
* History:
*  04-07-91 -by- KentD
* Wrote it.
\***************************************************************************/

_cdecl
main(
    INT   argc,
    PCHAR argv[])
{
    MSG    msg;
    HACCEL haccel;
    CHAR*  pSrc;
    CHAR*  pDst;

    if (!gGdiplusInitHelper.IsValid())
    {
        return 0;
    }
    
    BOOL wantDebugWindow = FALSE;

    CoInitialize(NULL);

    // Parse arguments

    for (argc--, argv++ ; argc && '-' == **argv ; argc--, argv++ )
    {
        switch ( *(++(*argv)) )
        {
        case 'd':
        case 'D':
            wantDebugWindow = TRUE;
            break;
        }
    }

    ghInstance = GetModuleHandle(NULL);

    if (!bInitApp(wantDebugWindow))
    {
        return(0);
    }

    haccel = LoadAccelerators(ghInstance, MAKEINTRESOURCE(1));
    while (GetMessage(&msg, NULL, 0, 0))
    {
        if (!TranslateAccelerator(msg.hwnd, haccel, &msg))
        {
             TranslateMessage(&msg);
             DispatchMessage(&msg);
        }
    }

    CoUninitialize();
    return(1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\drawimage\drawimage.hpp ===
/****************************** Module Header ******************************\
* Module Name: drawimage.hpp
*
* Created: 23 December 1999
* Author: Adrian Secchia [asecchia]
*
* Copyright (c) 1999 Microsoft Corporation
\***************************************************************************/

#pragma once

extern UINT uCategory;
extern UINT uResample;
extern UINT uRotation;
extern UINT uICM;
extern UINT uICMBack;
extern BOOL bPixelMode;
extern WCHAR FileName[MAX_PATH];
extern UINT uWrapMode;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\drawimage\wndstuff.cpp ===
/******************************Module*Header*******************************\
* Module Name: wndstuff.cpp
*
* Menu driven test environment.
*
* Created: 23 December 1999
* Author: Adrian Secchia [asecchia]
*
* Copyright (c) 1999 Microsoft Corporation
*
\**************************************************************************/

// for Win95 compile
#undef UNICODE
#undef _UNICODE

#include <windows.h>
#include <tchar.h>
#include <stdio.h>
#include <stdlib.h>
#include <objbase.h>

#include "wndstuff.h"

HINSTANCE ghInstance;
HWND ghwndMain;
HBRUSH ghbrWhite;
WCHAR FileName[MAX_PATH]=L"winnt256.bmp";

#include <gdiplus.h>

#include "../gpinit.inc"

// Store the user requested state for the DrawImage test.
UINT uCategory;
UINT uResample;
UINT uRotation;
UINT uICM;
UINT uICMBack;
BOOL bPixelMode = FALSE;
UINT uWrapMode = 0;


ULONG _cdecl
DbgPrint(
    CHAR* format,
    ...
    )

{
    va_list arglist;
    va_start(arglist, format);

    char buf[1024];

    _vsnprintf(buf, 1024, format, arglist);
    buf[1024-1]=0;

    OutputDebugStringA(buf);

    va_end(arglist);
    return 0;
}



/***************************************************************************\
* SetXXXX
*
* These routines set the state for the test. When the user selects
* an option from the menu, we store the state and mark the selection
* in the menu text.
* The DoTest routine queries the global variables (above) to determine
* which test to run and set the environment for the test.
\***************************************************************************/

VOID SetCategory(HWND hwnd, UINT uNewCategory)
{
    HMENU hmenu = GetMenu(hwnd);
    HMENU hmenu2 = GetSubMenu(hmenu, 2);
    CheckMenuItem(hmenu2, uCategory, MF_BYCOMMAND | MF_UNCHECKED);
    CheckMenuItem(hmenu2, uNewCategory, MF_BYCOMMAND | MF_CHECKED);
    uCategory = uNewCategory;
}

VOID SetResample(HWND hwnd, UINT uNewResample)
{
    HMENU hmenu = GetMenu(hwnd);
    HMENU hmenu2 = GetSubMenu(hmenu, 3);
    CheckMenuItem(hmenu2, uResample, MF_BYCOMMAND | MF_UNCHECKED);
    CheckMenuItem(hmenu2, uNewResample, MF_BYCOMMAND | MF_CHECKED);
    uResample = uNewResample;
}

VOID SetICM(HWND hwnd, UINT uNewICM)
{
    HMENU hmenu = GetMenu(hwnd);
    HMENU hmenu2 = GetSubMenu(hmenu, 5);
    CheckMenuItem(hmenu2, uICM, MF_BYCOMMAND | MF_UNCHECKED);
    CheckMenuItem(hmenu2, uNewICM, MF_BYCOMMAND | MF_CHECKED);
    uICM = uNewICM;
}

VOID SetICMBack(HWND hwnd, UINT uNewICM)
{
    HMENU hmenu = GetMenu(hwnd);
    HMENU hmenu2 = GetSubMenu(hmenu, 5);
    CheckMenuItem(hmenu2, uICMBack, MF_BYCOMMAND | MF_UNCHECKED);
    CheckMenuItem(hmenu2, uNewICM, MF_BYCOMMAND | MF_CHECKED);
    uICMBack = uNewICM;
}

VOID SetRotation(HWND hwnd, UINT uNewRotation)
{
    HMENU hmenu = GetMenu(hwnd);
    HMENU hmenu2 = GetSubMenu(hmenu, 6);
    CheckMenuItem(hmenu2, uRotation, MF_BYCOMMAND | MF_UNCHECKED);
    CheckMenuItem(hmenu2, uNewRotation, MF_BYCOMMAND | MF_CHECKED);
    uRotation = uNewRotation;
}

VOID SetPixelOffsetMode(HWND hwnd, UINT uPixelMode)
{
    HMENU hmenu = GetMenu(hwnd);
    HMENU hmenu2 = GetSubMenu(hmenu, 4);
    bPixelMode = !bPixelMode;
    CheckMenuItem(hmenu2, uPixelMode, MF_BYCOMMAND | (bPixelMode?MF_CHECKED:MF_UNCHECKED));
}


VOID SetWrapMode(HWND hwnd, UINT uNewWrapMode)
{
    HMENU hmenu = GetMenu(hwnd);
    HMENU hmenu2 = GetSubMenu(hmenu, 4);
    CheckMenuItem(hmenu2, uNewWrapMode, MF_BYCOMMAND | MF_CHECKED);
    CheckMenuItem(hmenu2, uWrapMode, MF_BYCOMMAND | MF_UNCHECKED);
    uWrapMode = uNewWrapMode;
}


inline BOOL
AnsiToUnicodeStr(
    const CHAR* ansiStr,
    WCHAR* unicodeStr,
    INT unicodeSize
    )
{
    return MultiByteToWideChar(CP_ACP,
                               0,
                               ansiStr,
                               -1,
                               unicodeStr,
                               unicodeSize) > 0;
}


void OpenFileProc(HWND hwnd)
{

    char locFileName[MAX_PATH];
    OPENFILENAME    ofn;

    ZeroMemory(&ofn, sizeof(ofn));

    ofn.lStructSize = sizeof(ofn);
    ofn.hwndOwner = hwnd;
    ofn.hInstance = ghInstance;
    ofn.lpstrFile = locFileName;
    ofn.nMaxFile = MAX_PATH;
    ofn.lpstrTitle = "Open Image";
    ofn.lpstrInitialDir = ".";
    ofn.Flags = OFN_FILEMUSTEXIST;
    locFileName[0] = '\0';

    // Present the file/open dialog

    if(GetOpenFileName(&ofn))
    {
        AnsiToUnicodeStr(locFileName, FileName, MAX_PATH);
    }
}



/***************************************************************************\
* lMainWindowProc(hwnd, message, wParam, lParam)
*
* Processes all messages for the main window.
\***************************************************************************/

LONG_PTR
lMainWindowProc(
    HWND    hwnd,
    UINT    message,
    WPARAM  wParam,
    LPARAM  lParam
    )
{
    PAINTSTRUCT ps;

    switch (message)
    {

    case WM_DEVMODECHANGE:
        DbgPrint("Devmode change\n");
        break;

    case WM_DEVICECHANGE:
        DbgPrint("Device change\n");
        break;

    case WM_DISPLAYCHANGE:
        DbgPrint("Display change\n");
        break;

    case WM_CREATE:
        break;

    case WM_SIZE:
        InvalidateRect(hwnd, NULL, FALSE);
        break;

    case WM_PAINT:
        BeginPaint(hwnd, &ps);
        DoTest(hwnd);
        EndPaint(hwnd, &ps);
        break;


    case WM_COMMAND:
        switch(LOWORD(wParam))
        {

        case IDM_OPENFILE:
            OpenFileProc(hwnd);
            InvalidateRect(hwnd, NULL, TRUE);
        break;

        case IDM_TEST:
            InvalidateRect(hwnd, NULL, TRUE);
        break;

        // Choose the test.
        case IDM_ALL:
        case IDM_OUTCROP:
        case IDM_OUTCROPR:
        case IDM_SIMPLE:
        case IDM_STRETCHROTATION:
        case IDM_SHRINKROTATION:
        case IDM_CROPROTATION:
        case IDM_COPYCROP:
        case IDM_DRAWICM:
        case IDM_DRAWPALETTE:
        case IDM_DRAWIMAGE2:
        case IDM_STRETCHB:
        case IDM_STRETCHS:
        case IDM_PIXELCENTER:
        case IDM_CACHEDBITMAP:
        case IDM_CROPWT:
        case IDM_HFLIP:
        case IDM_VFLIP:
        case IDM_SPECIALROTATE:
            SetCategory(hwnd, LOWORD(wParam));
            InvalidateRect(hwnd, NULL, TRUE);
        break;

        // Choose the world to device transformation
        case IDM_ROT0:
        case IDM_ROT10:
        case IDM_ROT30:
        case IDM_ROT45:
        case IDM_ROT60:
        case IDM_ROT90:
            SetRotation(hwnd, LOWORD(wParam));
            InvalidateRect(hwnd, NULL, TRUE);
        break;

        case IDM_ICM:
        case IDM_NOICM:
            SetICM(hwnd, LOWORD(wParam));
            InvalidateRect(hwnd, NULL, TRUE);
        break;

        case IDM_ICM_BACK:
        case IDM_ICM_NOBACK:
            SetICMBack(hwnd, LOWORD(wParam));
            InvalidateRect(hwnd, NULL, TRUE);
        break;


        // Choose the resample mode
        case IDM_BILINEAR:
        case IDM_BICUBIC:
        case IDM_NEARESTNEIGHBOR:
        case IDM_HIGHBILINEAR:
        case IDM_HIGHBICUBIC:
            SetResample(hwnd, LOWORD(wParam));
            InvalidateRect(hwnd, NULL, TRUE);
        break;

        // Set the PixelOffsetMode
        case IDM_PIXELMODE:
            SetPixelOffsetMode(hwnd, LOWORD(wParam));
            InvalidateRect(hwnd, NULL, TRUE);
        break;

        // Set the WrapMode
        case IDM_WRAPMODETILE:
        case IDM_WRAPMODEFLIPX:
        case IDM_WRAPMODEFLIPY:
        case IDM_WRAPMODEFLIPXY:
        case IDM_WRAPMODECLAMP0:
        case IDM_WRAPMODECLAMPFF:
            SetWrapMode(hwnd, LOWORD(wParam));
            InvalidateRect(hwnd, NULL, TRUE);
        break;

        case IDM_QUIT:
            exit(0);
        break;

        default:
            // The user selected an unimplemented menu item.
            MessageBox(hwnd,
                _T("Help me! - I've fallen and I can't get up!!!"),
                _T(""),
                MB_OK
            );
        break;

        }
        break;

    case WM_DESTROY:
        DeleteObject(ghbrWhite);
        PostQuitMessage(0);
        return(DefWindowProc(hwnd, message, wParam, lParam));

    default:
        return(DefWindowProc(hwnd, message, wParam, lParam));
    }

    return(0);
}

/***************************************************************************\
* bInitApp()
*
* Initializes the app.
\***************************************************************************/

BOOL bInitApp(VOID)
{
    WNDCLASS wc;

    // not quite so white background brush.
    ghbrWhite = CreateSolidBrush(RGB(0xFF,0xFF,0xFF));

    wc.style            = 0;
    wc.lpfnWndProc      = lMainWindowProc;
    wc.cbClsExtra       = 0;
    wc.cbWndExtra       = 0;
    wc.hInstance        = ghInstance;
    wc.hIcon            = LoadIcon(NULL, IDI_APPLICATION);
    wc.hCursor          = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground    = ghbrWhite;
    wc.lpszMenuName     = _T("MainMenu");
    wc.lpszClassName    = _T("TestClass");

    if(!RegisterClass(&wc)) { return FALSE; }

    ghwndMain = CreateWindowEx(
        0,
        _T("TestClass"),
        _T("Win32 Test"),
        WS_OVERLAPPED   |
        WS_CAPTION      |
        WS_BORDER       |
        WS_THICKFRAME   |
        WS_MAXIMIZEBOX  |
        WS_MINIMIZEBOX  |
        WS_CLIPCHILDREN |
        WS_VISIBLE      |
        WS_SYSMENU,
        80,
        70,
        500,
        500,
        NULL,
        NULL,
        ghInstance,
        NULL
    );

    if (ghwndMain == NULL)
    {
        return(FALSE);
    }
    SetFocus(ghwndMain);
    return TRUE;
}

/***************************************************************************\
* main(argc, argv[])
*
* Sets up the message loop.
\***************************************************************************/

_cdecl
main(
    INT   argc,
    PCHAR argv[])
{
    MSG    msg;
    HACCEL haccel;
    CHAR*  pSrc;
    CHAR*  pDst;

    if (!gGdiplusInitHelper.IsValid())
    {
        return 0;
    }

    ghInstance = GetModuleHandle(NULL);
    if(!bInitApp()) { return 0; }

    // Initialize the default menu selection.
    SetCategory(ghwndMain, IDM_DRAWICM);
    SetRotation(ghwndMain, IDM_ROT0);
    SetResample(ghwndMain, IDM_BICUBIC);
    SetICM(ghwndMain, IDM_NOICM);
    SetPixelOffsetMode(ghwndMain, IDM_PIXELMODE);
    SetICMBack(ghwndMain, IDM_ICM_NOBACK);
    SetWrapMode(ghwndMain, IDM_WRAPMODETILE);

    while(GetMessage (&msg, NULL, 0, 0))
    {
      if((ghwndMain == 0) || !IsDialogMessage(ghwndMain, &msg)) {
        TranslateMessage(&msg) ;
        DispatchMessage(&msg) ;
      }
    }

    return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\drawimage\wndstuff.h ===
/****************************** Module Header ******************************\
* Module Name: wndstuff.h
*
* Created: 23 December 1999
* Author: Adrian Secchia [asecchia]
*
* Copyright (c) 1999 Microsoft Corporation
\***************************************************************************/
#pragma once

#include <windows.h>
#include <winuser.h>
#include <commdlg.h>

#define DONTUSE(x) (x)

#define IDM_TEST                        40000

// tests
#define IDM_ALL                         40100
#define IDM_SIMPLE                      40101
#define IDM_DRAWICM                     40102
#define IDM_DRAWIMAGE2                  40103
#define IDM_STRETCHROTATION             40104
#define IDM_CROPROTATION                40105
#define IDM_COPYCROP                    40106
#define IDM_OUTCROP                     40107
#define IDM_OUTCROPR                    40108
#define IDM_STRETCHB                    40109
#define IDM_STRETCHS                    40110
#define IDM_SHRINKROTATION              40111
#define IDM_PIXELCENTER                 40112
#define IDM_DRAWPALETTE                 40113
#define IDM_CACHEDBITMAP                40114
#define IDM_CROPWT                      40115
#define IDM_HFLIP                       40116
#define IDM_VFLIP                       40117
#define IDM_SPECIALROTATE               40118



// Resample mode
#define IDM_BILINEAR                    40200
#define IDM_BICUBIC                     40201
#define IDM_NEARESTNEIGHBOR             40202
#define IDM_HIGHBILINEAR                40203
#define IDM_HIGHBICUBIC                 40204
#define IDM_PIXELMODE                   40205
#define IDM_WRAPMODETILE                40206
#define IDM_WRAPMODEFLIPX               40207
#define IDM_WRAPMODEFLIPY               40208
#define IDM_WRAPMODEFLIPXY              40209
#define IDM_WRAPMODECLAMP0              40210
#define IDM_WRAPMODECLAMPFF             40211

#define IDM_QUIT                        40300

#define IDM_ROT0                        40400
#define IDM_ROT10                       40401
#define IDM_ROT30                       40402
#define IDM_ROT45                       40403
#define IDM_ROT60                       40404
#define IDM_ROT90                       40405

#define IDM_ICM                         40500
#define IDM_NOICM                       40501
#define IDM_ICM_BACK                    40502
#define IDM_ICM_NOBACK                  40503

#define IDM_OPENFILE                    40600


ULONG _cdecl
DbgPrint(
    CHAR* format,
    ...
    );



VOID DoTest(HWND);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\driverhack\cbanding.cpp ===
/******************************Module*Header*******************************\
* Module Name: CBanding.cpp
*
\**************************************************************************/
#include "CBanding.h"
#include <limits.h>

extern HWND g_hWndMain;

CBanding::CBanding(BOOL bRegression)
{
	strcpy(m_szName,"Banding");
	m_bRegression=bRegression;
}

CBanding::~CBanding()
{
}

void CBanding::Draw(Graphics *g)
{
    TestBanding(g);
}

VOID CBanding::TestBanding(Graphics *g)
{

    Unit     u;
    RectF    rect;
    REAL     width = 10;
    RectF    copyRect;
    RECT     crect;
    WCHAR    filename[256];
    GraphicsPath *path;

    HINSTANCE hInst=GetModuleHandleA(NULL);

    Bitmap *bitmap = new Bitmap(hInst, L"MARBLE_BMP");

    bitmap->GetBounds(&copyRect, &u);

    GetClientRect(g_hWndMain, &crect);
    rect.X = (30.0f/450.0f*crect.right);
    rect.Y = (30.0f/450.0f*crect.bottom);
    rect.Width = (crect.right-(70.0f/450.0f*crect.right));
    rect.Height = (crect.bottom-(70.0f/450.0f*crect.bottom));

    path = new GraphicsPath(FillModeAlternate);

    path->AddRectangle(rect);

    // Our ICM profile is hacked to flip the red and blue color channels
    // Apply a recolor matrix to flip them back so that if something breaks
    // ICM, the picture will look blue instead of the familiar colors.

    ImageAttributes *img = new ImageAttributes();

    img->SetWrapMode(WrapModeTile, Color(0xffff0000), FALSE);

    ColorMatrix flipRedBlue =
       {0, 0, 1, 0, 0,
        0, 1, 0, 0, 0,
        1, 0, 0, 0, 0,
        0, 0, 0, 1, 0,
        0, 0, 0, 0, 1};
    img->SetColorMatrix(&flipRedBlue);
    img->SetWrapMode(WrapModeTile, Color(0xffff0000), FALSE);

    TextureBrush textureBrush(bitmap, copyRect, img);

    g->FillPath(&textureBrush, path);

    Color blackColor(128, 0, 0, 0);

    SolidBrush blackBrush(blackColor);
    Pen blackPen(&blackBrush, width);

    g->DrawPath(&blackPen, path);

    delete img;
    delete path;
    delete bitmap;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\driverhack\cextra.h ===
VOID ExtraInitializations();
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\driverhack\cextra.cpp ===
// Include all the primitives (classes derived from CPrimitive)
#include "CPaths.h"
#include "CBanding.h"
#include "CPrinting.h"
#include "CExtra.h"

// Create global objects for each individual primitive
//   First constructor param is the regression flag
//   If true, the test will take part of the regression suite
CPaths   g_Paths(true);
CBanding g_Banding(true);


void ExtraInitializations()
{
    g_Paths.Init();
    g_Banding.Init();

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\driverhack\afxres.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef __AFXRES_H__
#define __AFXRES_H__

#ifdef RC_INVOKED
#ifndef _INC_WINDOWS
#define _INC_WINDOWS
	#include "winres.h"           // extract from windows header
#endif
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

#ifdef APSTUDIO_INVOKED
#define APSTUDIO_HIDDEN_SYMBOLS
#endif

/////////////////////////////////////////////////////////////////////////////
// MFC resource types (see Technical note TN024 for implementation details)

#ifndef RC_INVOKED
#define RT_DLGINIT  MAKEINTRESOURCEA(240)
#define RT_TOOLBAR  MAKEINTRESOURCEA(241)
#endif

/////////////////////////////////////////////////////////////////////////////

#ifdef APSTUDIO_INVOKED
#undef APSTUDIO_HIDDEN_SYMBOLS
#endif

/////////////////////////////////////////////////////////////////////////////
// General style bits etc

// ControlBar styles
#define CBRS_ALIGN_LEFT     0x1000L
#define CBRS_ALIGN_TOP      0x2000L
#define CBRS_ALIGN_RIGHT    0x4000L
#define CBRS_ALIGN_BOTTOM   0x8000L
#define CBRS_ALIGN_ANY      0xF000L

#define CBRS_BORDER_LEFT    0x0100L
#define CBRS_BORDER_TOP     0x0200L
#define CBRS_BORDER_RIGHT   0x0400L
#define CBRS_BORDER_BOTTOM  0x0800L
#define CBRS_BORDER_ANY     0x0F00L

#define CBRS_TOOLTIPS       0x0010L
#define CBRS_FLYBY          0x0020L
#define CBRS_FLOAT_MULTI    0x0040L
#define CBRS_BORDER_3D      0x0080L
#define CBRS_HIDE_INPLACE   0x0008L
#define CBRS_SIZE_DYNAMIC   0x0004L
#define CBRS_SIZE_FIXED     0x0002L
#define CBRS_FLOATING       0x0001L

#define CBRS_GRIPPER        0x00400000L

#define CBRS_ORIENT_HORZ    (CBRS_ALIGN_TOP|CBRS_ALIGN_BOTTOM)
#define CBRS_ORIENT_VERT    (CBRS_ALIGN_LEFT|CBRS_ALIGN_RIGHT)
#define CBRS_ORIENT_ANY     (CBRS_ORIENT_HORZ|CBRS_ORIENT_VERT)

#define CBRS_ALL            0x0040FFFFL

// the CBRS_ style is made up of an alignment style and a draw border style
//  the alignment styles are mutually exclusive
//  the draw border styles may be combined
#define CBRS_NOALIGN        0x00000000L
#define CBRS_LEFT           (CBRS_ALIGN_LEFT|CBRS_BORDER_RIGHT)
#define CBRS_TOP            (CBRS_ALIGN_TOP|CBRS_BORDER_BOTTOM)
#define CBRS_RIGHT          (CBRS_ALIGN_RIGHT|CBRS_BORDER_LEFT)
#define CBRS_BOTTOM         (CBRS_ALIGN_BOTTOM|CBRS_BORDER_TOP)

/////////////////////////////////////////////////////////////////////////////
// Standard window components

// Mode indicators in status bar - these are routed like commands
#define ID_INDICATOR_EXT                0xE700  // extended selection indicator
#define ID_INDICATOR_CAPS               0xE701  // cap lock indicator
#define ID_INDICATOR_NUM                0xE702  // num lock indicator
#define ID_INDICATOR_SCRL               0xE703  // scroll lock indicator
#define ID_INDICATOR_OVR                0xE704  // overtype mode indicator
#define ID_INDICATOR_REC                0xE705  // record mode indicator
#define ID_INDICATOR_KANA               0xE706  // kana lock indicator

#define ID_SEPARATOR                    0   // special separator value

#ifndef RC_INVOKED  // code only
// Standard control bars (IDW = window ID)
#define AFX_IDW_CONTROLBAR_FIRST        0xE800
#define AFX_IDW_CONTROLBAR_LAST         0xE8FF

#define AFX_IDW_TOOLBAR                 0xE800  // main Toolbar for window
#define AFX_IDW_STATUS_BAR              0xE801  // Status bar window
#define AFX_IDW_PREVIEW_BAR             0xE802  // PrintPreview Dialog Bar
#define AFX_IDW_RESIZE_BAR              0xE803  // OLE in-place resize bar
#define AFX_IDW_REBAR                   0xE804  // COMCTL32 "rebar" Bar
#define AFX_IDW_DIALOGBAR               0xE805  // CDialogBar

// Note: If your application supports docking toolbars, you should
//  not use the following IDs for your own toolbars.  The IDs chosen
//  are at the top of the first 32 such that the bars will be hidden
//  while in print preview mode, and are not likely to conflict with
//  IDs your application may have used succesfully in the past.

#define AFX_IDW_DOCKBAR_TOP             0xE81B
#define AFX_IDW_DOCKBAR_LEFT            0xE81C
#define AFX_IDW_DOCKBAR_RIGHT           0xE81D
#define AFX_IDW_DOCKBAR_BOTTOM          0xE81E
#define AFX_IDW_DOCKBAR_FLOAT           0xE81F

// Macro for mapping standard control bars to bitmask (limit of 32)
#define AFX_CONTROLBAR_MASK(nIDC)   (1L << (nIDC - AFX_IDW_CONTROLBAR_FIRST))

// parts of Main Frame
#define AFX_IDW_PANE_FIRST              0xE900  // first pane (256 max)
#define AFX_IDW_PANE_LAST               0xE9ff
#define AFX_IDW_HSCROLL_FIRST           0xEA00  // first Horz scrollbar (16 max)
#define AFX_IDW_VSCROLL_FIRST           0xEA10  // first Vert scrollbar (16 max)

#define AFX_IDW_SIZE_BOX                0xEA20  // size box for splitters
#define AFX_IDW_PANE_SAVE               0xEA21  // to shift AFX_IDW_PANE_FIRST
#endif //!RC_INVOKED

#ifndef APSTUDIO_INVOKED

// common style for form views
#define AFX_WS_DEFAULT_VIEW             (WS_CHILD | WS_VISIBLE | WS_BORDER)

#endif //!APSTUDIO_INVOKED

/////////////////////////////////////////////////////////////////////////////
// Standard app configurable strings

// for application title (defaults to EXE name or name in constructor)
#define AFX_IDS_APP_TITLE               0xE000
// idle message bar line
#define AFX_IDS_IDLEMESSAGE             0xE001
// message bar line when in shift-F1 help mode
#define AFX_IDS_HELPMODEMESSAGE         0xE002
// document title when editing OLE embedding
#define AFX_IDS_APP_TITLE_EMBEDDING     0xE003
// company name
#define AFX_IDS_COMPANY_NAME            0xE004
// object name when server is inplace
#define AFX_IDS_OBJ_TITLE_INPLACE       0xE005

/////////////////////////////////////////////////////////////////////////////
// Standard Commands

// File commands
#define ID_FILE_NEW                     0xE100
#define ID_FILE_OPEN                    0xE101
#define ID_FILE_CLOSE                   0xE102
#define ID_FILE_SAVE                    0xE103
#define ID_FILE_SAVE_AS                 0xE104
#define ID_FILE_PAGE_SETUP              0xE105
#define ID_FILE_PRINT_SETUP             0xE106
#define ID_FILE_PRINT                   0xE107
#define ID_FILE_PRINT_DIRECT            0xE108
#define ID_FILE_PRINT_PREVIEW           0xE109
#define ID_FILE_UPDATE                  0xE10A
#define ID_FILE_SAVE_COPY_AS            0xE10B
#define ID_FILE_SEND_MAIL               0xE10C

#define ID_FILE_MRU_FIRST               0xE110
#define ID_FILE_MRU_FILE1               0xE110          // range - 16 max
#define ID_FILE_MRU_FILE2               0xE111
#define ID_FILE_MRU_FILE3               0xE112
#define ID_FILE_MRU_FILE4               0xE113
#define ID_FILE_MRU_FILE5               0xE114
#define ID_FILE_MRU_FILE6               0xE115
#define ID_FILE_MRU_FILE7               0xE116
#define ID_FILE_MRU_FILE8               0xE117
#define ID_FILE_MRU_FILE9               0xE118
#define ID_FILE_MRU_FILE10              0xE119
#define ID_FILE_MRU_FILE11              0xE11A
#define ID_FILE_MRU_FILE12              0xE11B
#define ID_FILE_MRU_FILE13              0xE11C
#define ID_FILE_MRU_FILE14              0xE11D
#define ID_FILE_MRU_FILE15              0xE11E
#define ID_FILE_MRU_FILE16              0xE11F
#define ID_FILE_MRU_LAST                0xE11F

// Edit commands
#define ID_EDIT_CLEAR                   0xE120
#define ID_EDIT_CLEAR_ALL               0xE121
#define ID_EDIT_COPY                    0xE122
#define ID_EDIT_CUT                     0xE123
#define ID_EDIT_FIND                    0xE124
#define ID_EDIT_PASTE                   0xE125
#define ID_EDIT_PASTE_LINK              0xE126
#define ID_EDIT_PASTE_SPECIAL           0xE127
#define ID_EDIT_REPEAT                  0xE128
#define ID_EDIT_REPLACE                 0xE129
#define ID_EDIT_SELECT_ALL              0xE12A
#define ID_EDIT_UNDO                    0xE12B
#define ID_EDIT_REDO                    0xE12C

// Window commands
#define ID_WINDOW_NEW                   0xE130
#define ID_WINDOW_ARRANGE               0xE131
#define ID_WINDOW_CASCADE               0xE132
#define ID_WINDOW_TILE_HORZ             0xE133
#define ID_WINDOW_TILE_VERT             0xE134
#define ID_WINDOW_SPLIT                 0xE135
#ifndef RC_INVOKED      // code only
#define AFX_IDM_WINDOW_FIRST            0xE130
#define AFX_IDM_WINDOW_LAST             0xE13F
#define AFX_IDM_FIRST_MDICHILD          0xFF00  // window list starts here
#endif //!RC_INVOKED

// Help and App commands
#define ID_APP_ABOUT                    0xE140
#define ID_APP_EXIT                     0xE141
#define ID_HELP_INDEX                   0xE142
#define ID_HELP_FINDER                  0xE143
#define ID_HELP_USING                   0xE144
#define ID_CONTEXT_HELP                 0xE145      // shift-F1
// special commands for processing help
#define ID_HELP                         0xE146      // first attempt for F1
#define ID_DEFAULT_HELP                 0xE147      // last attempt

// Misc
#define ID_NEXT_PANE                    0xE150
#define ID_PREV_PANE                    0xE151

// Format
#define ID_FORMAT_FONT                  0xE160

// OLE commands
#define ID_OLE_INSERT_NEW               0xE200
#define ID_OLE_EDIT_LINKS               0xE201
#define ID_OLE_EDIT_CONVERT             0xE202
#define ID_OLE_EDIT_CHANGE_ICON         0xE203
#define ID_OLE_EDIT_PROPERTIES          0xE204
#define ID_OLE_VERB_FIRST               0xE210     // range - 16 max
#ifndef RC_INVOKED      // code only
#define ID_OLE_VERB_LAST                0xE21F
#endif //!RC_INVOKED

// for print preview dialog bar
#define AFX_ID_PREVIEW_CLOSE            0xE300
#define AFX_ID_PREVIEW_NUMPAGE          0xE301      // One/Two Page button
#define AFX_ID_PREVIEW_NEXT             0xE302
#define AFX_ID_PREVIEW_PREV             0xE303
#define AFX_ID_PREVIEW_PRINT            0xE304
#define AFX_ID_PREVIEW_ZOOMIN           0xE305
#define AFX_ID_PREVIEW_ZOOMOUT          0xE306

// View commands (same number used as IDW used for control bar)
#define ID_VIEW_TOOLBAR                 0xE800
#define ID_VIEW_STATUS_BAR              0xE801
#define ID_VIEW_REBAR                   0xE804
#define ID_VIEW_AUTOARRANGE         0xE805
	// E810 -> E81F must be kept in order for RANGE macros
#define ID_VIEW_SMALLICON               0xE810
#define ID_VIEW_LARGEICON               0xE811
#define ID_VIEW_LIST                   0xE812
#define ID_VIEW_DETAILS                 0xE813
#define ID_VIEW_LINEUP                  0xE814
#define ID_VIEW_BYNAME                  0xE815
#define AFX_ID_VIEW_MINIMUM              ID_VIEW_SMALLICON
#define AFX_ID_VIEW_MAXIMUM              ID_VIEW_BYNAME
	// E800 -> E8FF reserved for other control bar commands

// RecordForm commands
#define ID_RECORD_FIRST                 0xE900
#define ID_RECORD_LAST                  0xE901
#define ID_RECORD_NEXT                  0xE902
#define ID_RECORD_PREV                  0xE903

/////////////////////////////////////////////////////////////////////////////
// Standard control IDs

#ifdef IDC_STATIC
#undef IDC_STATIC
#endif
#define IDC_STATIC              (-1)     // all static controls

/////////////////////////////////////////////////////////////////////////////
// Standard string error/warnings

#ifndef RC_INVOKED      // code only
#define AFX_IDS_SCFIRST                 0xEF00
#endif //!RC_INVOKED

#define AFX_IDS_SCSIZE                  0xEF00
#define AFX_IDS_SCMOVE                  0xEF01
#define AFX_IDS_SCMINIMIZE              0xEF02
#define AFX_IDS_SCMAXIMIZE              0xEF03
#define AFX_IDS_SCNEXTWINDOW            0xEF04
#define AFX_IDS_SCPREVWINDOW            0xEF05
#define AFX_IDS_SCCLOSE                 0xEF06
#define AFX_IDS_SCRESTORE               0xEF12
#define AFX_IDS_SCTASKLIST              0xEF13

#define AFX_IDS_MDICHILD                0xEF1F

#define AFX_IDS_DESKACCESSORY           0xEFDA

// General strings
#define AFX_IDS_OPENFILE                0xF000
#define AFX_IDS_SAVEFILE                0xF001
#define AFX_IDS_ALLFILTER               0xF002
#define AFX_IDS_UNTITLED                0xF003
#define AFX_IDS_SAVEFILECOPY            0xF004
#define AFX_IDS_PREVIEW_CLOSE           0xF005
#define AFX_IDS_UNNAMED_FILE            0xF006
#define AFX_IDS_HIDE                    0xF011

// MFC Standard Exception Error messages
#define AFX_IDP_NO_ERROR_AVAILABLE      0xF020
#define AFX_IDS_NOT_SUPPORTED_EXCEPTION 0xF021
#define AFX_IDS_RESOURCE_EXCEPTION      0xF022
#define AFX_IDS_MEMORY_EXCEPTION        0xF023
#define AFX_IDS_USER_EXCEPTION          0xF024

// Printing and print preview strings
#define AFX_IDS_PRINTONPORT             0xF040
#define AFX_IDS_ONEPAGE                 0xF041
#define AFX_IDS_TWOPAGE                 0xF042
#define AFX_IDS_PRINTPAGENUM            0xF043
#define AFX_IDS_PREVIEWPAGEDESC         0xF044
#define AFX_IDS_PRINTDEFAULTEXT         0xF045
#define AFX_IDS_PRINTDEFAULT            0xF046
#define AFX_IDS_PRINTFILTER             0xF047
#define AFX_IDS_PRINTCAPTION            0xF048
#define AFX_IDS_PRINTTOFILE             0xF049


// OLE strings
#define AFX_IDS_OBJECT_MENUITEM         0xF080
#define AFX_IDS_EDIT_VERB               0xF081
#define AFX_IDS_ACTIVATE_VERB           0xF082
#define AFX_IDS_CHANGE_LINK             0xF083
#define AFX_IDS_AUTO                    0xF084
#define AFX_IDS_MANUAL                  0xF085
#define AFX_IDS_FROZEN                  0xF086
#define AFX_IDS_ALL_FILES               0xF087
// dynamically changing menu items
#define AFX_IDS_SAVE_MENU               0xF088
#define AFX_IDS_UPDATE_MENU             0xF089
#define AFX_IDS_SAVE_AS_MENU            0xF08A
#define AFX_IDS_SAVE_COPY_AS_MENU       0xF08B
#define AFX_IDS_EXIT_MENU               0xF08C
#define AFX_IDS_UPDATING_ITEMS          0xF08D
// COlePasteSpecialDialog defines
#define AFX_IDS_METAFILE_FORMAT         0xF08E
#define AFX_IDS_DIB_FORMAT              0xF08F
#define AFX_IDS_BITMAP_FORMAT           0xF090
#define AFX_IDS_LINKSOURCE_FORMAT       0xF091
#define AFX_IDS_EMBED_FORMAT            0xF092
// other OLE utility strings
#define AFX_IDS_PASTELINKEDTYPE         0xF094
#define AFX_IDS_UNKNOWNTYPE             0xF095
#define AFX_IDS_RTF_FORMAT              0xF096
#define AFX_IDS_TEXT_FORMAT             0xF097
// OLE datatype format error strings
#define AFX_IDS_INVALID_CURRENCY        0xF098
#define AFX_IDS_INVALID_DATETIME        0xF099
#define AFX_IDS_INVALID_DATETIMESPAN    0xF09A

// General error / prompt strings
#define AFX_IDP_INVALID_FILENAME        0xF100
#define AFX_IDP_FAILED_TO_OPEN_DOC      0xF101
#define AFX_IDP_FAILED_TO_SAVE_DOC      0xF102
#define AFX_IDP_ASK_TO_SAVE             0xF103
#define AFX_IDP_FAILED_TO_CREATE_DOC    0xF104
#define AFX_IDP_FILE_TOO_LARGE          0xF105
#define AFX_IDP_FAILED_TO_START_PRINT   0xF106
#define AFX_IDP_FAILED_TO_LAUNCH_HELP   0xF107
#define AFX_IDP_INTERNAL_FAILURE        0xF108      // general failure
#define AFX_IDP_COMMAND_FAILURE         0xF109      // command failure
#define AFX_IDP_FAILED_MEMORY_ALLOC     0xF10A
#define AFX_IDP_UNREG_DONE              0xF10B
#define AFX_IDP_UNREG_FAILURE           0xF10C
#define AFX_IDP_DLL_LOAD_FAILED         0xF10D
#define AFX_IDP_DLL_BAD_VERSION         0xF10E

// DDV parse errors
#define AFX_IDP_PARSE_INT               0xF110
#define AFX_IDP_PARSE_REAL              0xF111
#define AFX_IDP_PARSE_INT_RANGE         0xF112
#define AFX_IDP_PARSE_REAL_RANGE        0xF113
#define AFX_IDP_PARSE_STRING_SIZE       0xF114
#define AFX_IDP_PARSE_RADIO_BUTTON      0xF115
#define AFX_IDP_PARSE_BYTE              0xF116
#define AFX_IDP_PARSE_UINT              0xF117
#define AFX_IDP_PARSE_DATETIME          0xF118
#define AFX_IDP_PARSE_CURRENCY          0xF119

// CFile/CArchive error strings for user failure
#define AFX_IDP_FAILED_INVALID_FORMAT   0xF120
#define AFX_IDP_FAILED_INVALID_PATH     0xF121
#define AFX_IDP_FAILED_DISK_FULL        0xF122
#define AFX_IDP_FAILED_ACCESS_READ      0xF123
#define AFX_IDP_FAILED_ACCESS_WRITE     0xF124
#define AFX_IDP_FAILED_IO_ERROR_READ    0xF125
#define AFX_IDP_FAILED_IO_ERROR_WRITE   0xF126

// OLE errors / prompt strings
#define AFX_IDP_STATIC_OBJECT           0xF180
#define AFX_IDP_FAILED_TO_CONNECT       0xF181
#define AFX_IDP_SERVER_BUSY             0xF182
#define AFX_IDP_BAD_VERB                0xF183
#define AFX_IDS_NOT_DOCOBJECT                0xF184
#define AFX_IDP_FAILED_TO_NOTIFY        0xF185
#define AFX_IDP_FAILED_TO_LAUNCH        0xF186
#define AFX_IDP_ASK_TO_UPDATE           0xF187
#define AFX_IDP_FAILED_TO_UPDATE        0xF188
#define AFX_IDP_FAILED_TO_REGISTER      0xF189
#define AFX_IDP_FAILED_TO_AUTO_REGISTER 0xF18A
#define AFX_IDP_FAILED_TO_CONVERT       0xF18B
#define AFX_IDP_GET_NOT_SUPPORTED       0xF18C
#define AFX_IDP_SET_NOT_SUPPORTED       0xF18D
#define AFX_IDP_ASK_TO_DISCARD          0xF18E
#define AFX_IDP_FAILED_TO_CREATE        0xF18F

// MAPI errors / prompt strings
#define AFX_IDP_FAILED_MAPI_LOAD        0xF190
#define AFX_IDP_INVALID_MAPI_DLL        0xF191
#define AFX_IDP_FAILED_MAPI_SEND        0xF192

#define AFX_IDP_FILE_NONE               0xF1A0
#define AFX_IDP_FILE_GENERIC            0xF1A1
#define AFX_IDP_FILE_NOT_FOUND          0xF1A2
#define AFX_IDP_FILE_BAD_PATH           0xF1A3
#define AFX_IDP_FILE_TOO_MANY_OPEN      0xF1A4
#define AFX_IDP_FILE_ACCESS_DENIED      0xF1A5
#define AFX_IDP_FILE_INVALID_FILE       0xF1A6
#define AFX_IDP_FILE_REMOVE_CURRENT     0xF1A7
#define AFX_IDP_FILE_DIR_FULL           0xF1A8
#define AFX_IDP_FILE_BAD_SEEK           0xF1A9
#define AFX_IDP_FILE_HARD_IO            0xF1AA
#define AFX_IDP_FILE_SHARING            0xF1AB
#define AFX_IDP_FILE_LOCKING            0xF1AC
#define AFX_IDP_FILE_DISKFULL           0xF1AD
#define AFX_IDP_FILE_EOF                0xF1AE

#define AFX_IDP_ARCH_NONE               0xF1B0
#define AFX_IDP_ARCH_GENERIC            0xF1B1
#define AFX_IDP_ARCH_READONLY           0xF1B2
#define AFX_IDP_ARCH_ENDOFFILE          0xF1B3
#define AFX_IDP_ARCH_WRITEONLY          0xF1B4
#define AFX_IDP_ARCH_BADINDEX           0xF1B5
#define AFX_IDP_ARCH_BADCLASS           0xF1B6
#define AFX_IDP_ARCH_BADSCHEMA          0xF1B7

#define AFX_IDS_OCC_SCALEUNITS_PIXELS   0xF1C0

// 0xf200-0xf20f reserved

// font names and point sizes
#define AFX_IDS_STATUS_FONT             0xF230
#define AFX_IDS_TOOLTIP_FONT            0xF231
#define AFX_IDS_UNICODE_FONT            0xF232
#define AFX_IDS_MINI_FONT               0xF233

// ODBC Database errors / prompt strings
#ifndef RC_INVOKED      // code only
#define AFX_IDP_SQL_FIRST                       0xF280
#endif //!RC_INVOKED
#define AFX_IDP_SQL_CONNECT_FAIL                0xF281
#define AFX_IDP_SQL_RECORDSET_FORWARD_ONLY      0xF282
#define AFX_IDP_SQL_EMPTY_COLUMN_LIST           0xF283
#define AFX_IDP_SQL_FIELD_SCHEMA_MISMATCH       0xF284
#define AFX_IDP_SQL_ILLEGAL_MODE                0xF285
#define AFX_IDP_SQL_MULTIPLE_ROWS_AFFECTED      0xF286
#define AFX_IDP_SQL_NO_CURRENT_RECORD           0xF287
#define AFX_IDP_SQL_NO_ROWS_AFFECTED            0xF288
#define AFX_IDP_SQL_RECORDSET_READONLY          0xF289
#define AFX_IDP_SQL_SQL_NO_TOTAL                0xF28A
#define AFX_IDP_SQL_ODBC_LOAD_FAILED            0xF28B
#define AFX_IDP_SQL_DYNASET_NOT_SUPPORTED       0xF28C
#define AFX_IDP_SQL_SNAPSHOT_NOT_SUPPORTED      0xF28D
#define AFX_IDP_SQL_API_CONFORMANCE             0xF28E
#define AFX_IDP_SQL_SQL_CONFORMANCE             0xF28F
#define AFX_IDP_SQL_NO_DATA_FOUND               0xF290
#define AFX_IDP_SQL_ROW_UPDATE_NOT_SUPPORTED    0xF291
#define AFX_IDP_SQL_ODBC_V2_REQUIRED            0xF292
#define AFX_IDP_SQL_NO_POSITIONED_UPDATES       0xF293
#define AFX_IDP_SQL_LOCK_MODE_NOT_SUPPORTED     0xF294
#define AFX_IDP_SQL_DATA_TRUNCATED              0xF295
#define AFX_IDP_SQL_ROW_FETCH                   0xF296
#define AFX_IDP_SQL_INCORRECT_ODBC              0xF297
#define AFX_IDP_SQL_UPDATE_DELETE_FAILED        0xF298
#define AFX_IDP_SQL_DYNAMIC_CURSOR_NOT_SUPPORTED    0xF299
#define AFX_IDP_SQL_FIELD_NOT_FOUND             0xF29A
#define AFX_IDP_SQL_BOOKMARKS_NOT_SUPPORTED     0xF29B
#define AFX_IDP_SQL_BOOKMARKS_NOT_ENABLED       0xF29C

// ODBC Database strings
#define AFX_IDS_DELETED                         0xF29D

// DAO Database errors / prompt strings
#ifndef RC_INVOKED      // code only
#define AFX_IDP_DAO_FIRST                       0xF2B0
#endif //!RC_INVOKED
#define AFX_IDP_DAO_ENGINE_INITIALIZATION       0xF2B0
#define AFX_IDP_DAO_DFX_BIND                    0xF2B1
#define AFX_IDP_DAO_OBJECT_NOT_OPEN             0xF2B2

// ICDAORecordset::GetRows Errors
//  These are not placed in DAO Errors collection
//  and must be handled directly by MFC.
#define AFX_IDP_DAO_ROWTOOSHORT                 0xF2B3
#define AFX_IDP_DAO_BADBINDINFO                 0xF2B4
#define AFX_IDP_DAO_COLUMNUNAVAILABLE           0xF2B5

/////////////////////////////////////////////////////////////////////////////
// Strings for ISAPI support

#define AFX_IDS_HTTP_TITLE              0xF2D1
#define AFX_IDS_HTTP_NO_TEXT            0xF2D2
#define AFX_IDS_HTTP_BAD_REQUEST        0xF2D3
#define AFX_IDS_HTTP_AUTH_REQUIRED      0xF2D4
#define AFX_IDS_HTTP_FORBIDDEN          0xF2D5
#define AFX_IDS_HTTP_NOT_FOUND          0xF2D6
#define AFX_IDS_HTTP_SERVER_ERROR       0xF2D7
#define AFX_IDS_HTTP_NOT_IMPLEMENTED    0xF2D8

/////////////////////////////////////////////////////////////////////////////
// AFX implementation - control IDs (AFX_IDC)

// Parts of dialogs
#define AFX_IDC_LISTBOX                 100
#define AFX_IDC_CHANGE                  101

// for print dialog
#define AFX_IDC_PRINT_DOCNAME           201
#define AFX_IDC_PRINT_PRINTERNAME       202
#define AFX_IDC_PRINT_PORTNAME          203
#define AFX_IDC_PRINT_PAGENUM           204

// Property Sheet control id's (determined with Spy++)
#define ID_APPLY_NOW                    0x3021
#define ID_WIZBACK                      0x3023
#define ID_WIZNEXT                      0x3024
#define ID_WIZFINISH                    0x3025
#define AFX_IDC_TAB_CONTROL             0x3020

/////////////////////////////////////////////////////////////////////////////
// IDRs for standard components

#ifndef RC_INVOKED  // code only
// These are really COMMDLG dialogs, so there usually isn't a resource
// for them, but these IDs are used as help IDs.
#define AFX_IDD_FILEOPEN                28676
#define AFX_IDD_FILESAVE                28677
#define AFX_IDD_FONT                    28678
#define AFX_IDD_COLOR                   28679
#define AFX_IDD_PRINT                   28680
#define AFX_IDD_PRINTSETUP              28681
#define AFX_IDD_FIND                    28682
#define AFX_IDD_REPLACE                 28683
#endif //!RC_INVOKED

// Standard dialogs app should leave alone (0x7801->)
#define AFX_IDD_NEWTYPEDLG              30721
#define AFX_IDD_PRINTDLG                30722
#define AFX_IDD_PREVIEW_TOOLBAR         30723

// Dialogs defined for OLE2UI library
#define AFX_IDD_INSERTOBJECT            30724
#define AFX_IDD_CHANGEICON              30725
#define AFX_IDD_CONVERT                 30726
#define AFX_IDD_PASTESPECIAL            30727
#define AFX_IDD_EDITLINKS               30728
#define AFX_IDD_FILEBROWSE              30729
#define AFX_IDD_BUSY                    30730

#define AFX_IDD_OBJECTPROPERTIES        30732
#define AFX_IDD_CHANGESOURCE            30733

// Standard cursors (0x7901->)
	// AFX_IDC = Cursor resources
#define AFX_IDC_CONTEXTHELP             30977       // context sensitive help
#define AFX_IDC_MAGNIFY                 30978       // print preview zoom
#define AFX_IDC_SMALLARROWS             30979       // splitter
#define AFX_IDC_HSPLITBAR               30980       // splitter
#define AFX_IDC_VSPLITBAR               30981       // splitter
#define AFX_IDC_NODROPCRSR              30982       // No Drop Cursor
#define AFX_IDC_TRACKNWSE               30983       // tracker
#define AFX_IDC_TRACKNESW               30984       // tracker
#define AFX_IDC_TRACKNS                 30985       // tracker
#define AFX_IDC_TRACKWE                 30986       // tracker
#define AFX_IDC_TRACK4WAY               30987       // tracker
#define AFX_IDC_MOVE4WAY                30988       // resize bar (server only)

// Mini frame window bitmap ID
#define AFX_IDB_MINIFRAME_MENU          30994

// CheckListBox checks bitmap ID
#define AFX_IDB_CHECKLISTBOX_NT         30995
#define AFX_IDB_CHECKLISTBOX_95         30996

// AFX standard accelerator resources
#define AFX_IDR_PREVIEW_ACCEL           30997

// AFX standard ICON IDs (for MFC V1 apps) (0x7A01->)
#define AFX_IDI_STD_MDIFRAME            31233
#define AFX_IDI_STD_FRAME               31234

/////////////////////////////////////////////////////////////////////////////
// AFX OLE control implementation - control IDs (AFX_IDC)

// Font property page
#define AFX_IDC_FONTPROP                1000
#define AFX_IDC_FONTNAMES               1001
#define AFX_IDC_FONTSTYLES              1002
#define AFX_IDC_FONTSIZES               1003
#define AFX_IDC_STRIKEOUT               1004
#define AFX_IDC_UNDERLINE               1005
#define AFX_IDC_SAMPLEBOX               1006

// Color property page
#define AFX_IDC_COLOR_BLACK             1100
#define AFX_IDC_COLOR_WHITE             1101
#define AFX_IDC_COLOR_RED               1102
#define AFX_IDC_COLOR_GREEN             1103
#define AFX_IDC_COLOR_BLUE              1104
#define AFX_IDC_COLOR_YELLOW            1105
#define AFX_IDC_COLOR_MAGENTA           1106
#define AFX_IDC_COLOR_CYAN              1107
#define AFX_IDC_COLOR_GRAY              1108
#define AFX_IDC_COLOR_LIGHTGRAY         1109
#define AFX_IDC_COLOR_DARKRED           1110
#define AFX_IDC_COLOR_DARKGREEN         1111
#define AFX_IDC_COLOR_DARKBLUE          1112
#define AFX_IDC_COLOR_LIGHTBROWN        1113
#define AFX_IDC_COLOR_DARKMAGENTA       1114
#define AFX_IDC_COLOR_DARKCYAN          1115
#define AFX_IDC_COLORPROP               1116
#define AFX_IDC_SYSTEMCOLORS            1117

// Picture porperty page
#define AFX_IDC_PROPNAME                1201
#define AFX_IDC_PICTURE                 1202
#define AFX_IDC_BROWSE                  1203
#define AFX_IDC_CLEAR                   1204

/////////////////////////////////////////////////////////////////////////////
// IDRs for OLE control standard components

// Standard propery page dialogs app should leave alone (0x7E01->)
#define AFX_IDD_PROPPAGE_COLOR         32257
#define AFX_IDD_PROPPAGE_FONT          32258
#define AFX_IDD_PROPPAGE_PICTURE       32259

#define AFX_IDB_TRUETYPE               32384

/////////////////////////////////////////////////////////////////////////////
// Standard OLE control strings

// OLE Control page strings
#define AFX_IDS_PROPPAGE_UNKNOWN        0xFE01
#define AFX_IDS_COLOR_DESKTOP           0xFE04
#define AFX_IDS_COLOR_APPWORKSPACE      0xFE05
#define AFX_IDS_COLOR_WNDBACKGND        0xFE06
#define AFX_IDS_COLOR_WNDTEXT           0xFE07
#define AFX_IDS_COLOR_MENUBAR           0xFE08
#define AFX_IDS_COLOR_MENUTEXT          0xFE09
#define AFX_IDS_COLOR_ACTIVEBAR         0xFE0A
#define AFX_IDS_COLOR_INACTIVEBAR       0xFE0B
#define AFX_IDS_COLOR_ACTIVETEXT        0xFE0C
#define AFX_IDS_COLOR_INACTIVETEXT      0xFE0D
#define AFX_IDS_COLOR_ACTIVEBORDER      0xFE0E
#define AFX_IDS_COLOR_INACTIVEBORDER    0xFE0F
#define AFX_IDS_COLOR_WNDFRAME          0xFE10
#define AFX_IDS_COLOR_SCROLLBARS        0xFE11
#define AFX_IDS_COLOR_BTNFACE           0xFE12
#define AFX_IDS_COLOR_BTNSHADOW         0xFE13
#define AFX_IDS_COLOR_BTNTEXT           0xFE14
#define AFX_IDS_COLOR_BTNHIGHLIGHT      0xFE15
#define AFX_IDS_COLOR_DISABLEDTEXT      0xFE16
#define AFX_IDS_COLOR_HIGHLIGHT         0xFE17
#define AFX_IDS_COLOR_HIGHLIGHTTEXT     0xFE18
#define AFX_IDS_REGULAR                 0xFE19
#define AFX_IDS_BOLD                    0xFE1A
#define AFX_IDS_ITALIC                  0xFE1B
#define AFX_IDS_BOLDITALIC              0xFE1C
#define AFX_IDS_SAMPLETEXT              0xFE1D
#define AFX_IDS_DISPLAYSTRING_FONT      0xFE1E
#define AFX_IDS_DISPLAYSTRING_COLOR     0xFE1F
#define AFX_IDS_DISPLAYSTRING_PICTURE   0xFE20
#define AFX_IDS_PICTUREFILTER           0xFE21
#define AFX_IDS_PICTYPE_UNKNOWN         0xFE22
#define AFX_IDS_PICTYPE_NONE            0xFE23
#define AFX_IDS_PICTYPE_BITMAP          0xFE24
#define AFX_IDS_PICTYPE_METAFILE        0xFE25
#define AFX_IDS_PICTYPE_ICON            0xFE26
#define AFX_IDS_COLOR_PPG               0xFE28
#define AFX_IDS_COLOR_PPG_CAPTION       0xFE29
#define AFX_IDS_FONT_PPG                0xFE2A
#define AFX_IDS_FONT_PPG_CAPTION        0xFE2B
#define AFX_IDS_PICTURE_PPG             0xFE2C
#define AFX_IDS_PICTURE_PPG_CAPTION     0xFE2D
#define AFX_IDS_PICTUREBROWSETITLE      0xFE30
#define AFX_IDS_BORDERSTYLE_0           0xFE31
#define AFX_IDS_BORDERSTYLE_1           0xFE32

// OLE Control verb names
#define AFX_IDS_VERB_EDIT               0xFE40
#define AFX_IDS_VERB_PROPERTIES         0xFE41

// OLE Control internal error messages
#define AFX_IDP_PICTURECANTOPEN         0xFE83
#define AFX_IDP_PICTURECANTLOAD         0xFE84
#define AFX_IDP_PICTURETOOLARGE         0xFE85
#define AFX_IDP_PICTUREREADFAILED       0xFE86

// Standard OLE Control error strings
#define AFX_IDP_E_ILLEGALFUNCTIONCALL       0xFEA0
#define AFX_IDP_E_OVERFLOW                  0xFEA1
#define AFX_IDP_E_OUTOFMEMORY               0xFEA2
#define AFX_IDP_E_DIVISIONBYZERO            0xFEA3
#define AFX_IDP_E_OUTOFSTRINGSPACE          0xFEA4
#define AFX_IDP_E_OUTOFSTACKSPACE           0xFEA5
#define AFX_IDP_E_BADFILENAMEORNUMBER       0xFEA6
#define AFX_IDP_E_FILENOTFOUND              0xFEA7
#define AFX_IDP_E_BADFILEMODE               0xFEA8
#define AFX_IDP_E_FILEALREADYOPEN           0xFEA9
#define AFX_IDP_E_DEVICEIOERROR             0xFEAA
#define AFX_IDP_E_FILEALREADYEXISTS         0xFEAB
#define AFX_IDP_E_BADRECORDLENGTH           0xFEAC
#define AFX_IDP_E_DISKFULL                  0xFEAD
#define AFX_IDP_E_BADRECORDNUMBER           0xFEAE
#define AFX_IDP_E_BADFILENAME               0xFEAF
#define AFX_IDP_E_TOOMANYFILES              0xFEB0
#define AFX_IDP_E_DEVICEUNAVAILABLE         0xFEB1
#define AFX_IDP_E_PERMISSIONDENIED          0xFEB2
#define AFX_IDP_E_DISKNOTREADY              0xFEB3
#define AFX_IDP_E_PATHFILEACCESSERROR       0xFEB4
#define AFX_IDP_E_PATHNOTFOUND              0xFEB5
#define AFX_IDP_E_INVALIDPATTERNSTRING      0xFEB6
#define AFX_IDP_E_INVALIDUSEOFNULL          0xFEB7
#define AFX_IDP_E_INVALIDFILEFORMAT         0xFEB8
#define AFX_IDP_E_INVALIDPROPERTYVALUE      0xFEB9
#define AFX_IDP_E_INVALIDPROPERTYARRAYINDEX 0xFEBA
#define AFX_IDP_E_SETNOTSUPPORTEDATRUNTIME  0xFEBB
#define AFX_IDP_E_SETNOTSUPPORTED           0xFEBC
#define AFX_IDP_E_NEEDPROPERTYARRAYINDEX    0xFEBD
#define AFX_IDP_E_SETNOTPERMITTED           0xFEBE
#define AFX_IDP_E_GETNOTSUPPORTEDATRUNTIME  0xFEBF
#define AFX_IDP_E_GETNOTSUPPORTED           0xFEC0
#define AFX_IDP_E_PROPERTYNOTFOUND          0xFEC1
#define AFX_IDP_E_INVALIDCLIPBOARDFORMAT    0xFEC2
#define AFX_IDP_E_INVALIDPICTURE            0xFEC3
#define AFX_IDP_E_PRINTERERROR              0xFEC4
#define AFX_IDP_E_CANTSAVEFILETOTEMP        0xFEC5
#define AFX_IDP_E_SEARCHTEXTNOTFOUND        0xFEC6
#define AFX_IDP_E_REPLACEMENTSTOOLONG       0xFEC7

/////////////////////////////////////////////////////////////////////////////

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#endif //__AFXRES_H__

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\driverhack\cbanding.h ===
/******************************Module*Header*******************************\
* Module Name: CBanding.h
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/

#ifndef __CBanding_H
#define __CBanding_H

#include "CPrimitive.h"

class CBanding : public CPrimitive  
{
public:
	CBanding(BOOL bRegression);
	virtual ~CBanding();

	void Draw(Graphics *g);

	VOID TestBanding(Graphics* g);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\driverhack\cfunctest.cpp ===
/******************************Module*Header*******************************\
* Module Name: CFuncTest.cpp
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/

#undef UNICODE
#undef _UNICODE

#include "CFuncTest.h"
#include "Resource.h"
#include "CHDC.h"
#include "windows.h"

void EnableGDIPlusDriverHacks(BOOL);
extern LPFNGDIPLUS glpfnDisplayPaletteWindowNotify;
extern HWND g_hWndMain;

extern CFuncTest g_FuncTest;        // Initialized in Main.cpp
extern HBRUSH g_hbrBackground;      // Initialized in Main.cpp
extern CHDC g_HDC;                  // Initialized in Main.cpp
extern int g_nResult;               // Initialized in Main.cpp
extern int gnPaths;

CFuncTest::CFuncTest()
{
    m_hWndDlg=NULL;
    m_hWndMain=NULL;
    m_bUsePageDelay=true;           // Default use page delay or page pause
    m_bEraseBkgd=true;              // Default erace background
    m_bAppendTest=false;            // Default append test
    m_bDriverHacks=false;           // Default enable printer driver hacks
    m_nPageDelay=1000;              // Default page delay
    m_nPageRow=0;
    m_nPageCol=0;
}

CFuncTest::~CFuncTest()
{
    EndDialog(m_hWndDlg,0);
    m_hWndDlg=NULL;
    m_hWndMain=NULL;
}

BOOL CFuncTest::Init(HWND hWndParent)
// Initializes functest
{
    HWND hWnd;
    char szDelay[10];
    char szNumPaths[10];

    m_hWndMain=hWndParent;

    // Create options dialog box
    m_hWndDlg=CreateDialogA(GetModuleHandleA(NULL),MAKEINTRESOURCEA(IDD_FUNCTEST),hWndParent,&DlgProc);
    if (m_hWndDlg==NULL)
        return false;

/*
    // Set default options in dialog box using defaults in constructor
    if (m_bUsePageDelay)
    {
        hWnd=GetDlgItem(m_hWndDlg,IDC_PAGEDELAY);
        SendMessageA(hWnd,BM_SETCHECK,(WPARAM)BST_CHECKED,0);
    }
    else
    {
        hWnd=GetDlgItem(m_hWndDlg,IDC_PAGEPAUSE);
        SendMessageA(hWnd,BM_SETCHECK,(WPARAM)BST_CHECKED,0);
    }

    hWnd=GetDlgItem(m_hWndDlg,IDC_DELAY);
    SendMessageA(hWnd,WM_SETTEXT,0,(LPARAM)_itoa(m_nPageDelay,szDelay,10));
*/

    hWnd=GetDlgItem(m_hWndDlg,IDC_NUMPATHS);
    SendMessageA(hWnd,WM_SETTEXT,0,(LPARAM)_itoa(gnPaths,szNumPaths,10));

    if (m_bEraseBkgd)
    {
        hWnd=GetDlgItem(m_hWndDlg,IDC_ERASEBKGD);
        SendMessageA(hWnd,BM_SETCHECK,(WPARAM)BST_CHECKED,0);
    }

    if (m_bDriverHacks)
    {
        hWnd=GetDlgItem(m_hWndDlg,IDC_DRIVERHACKS);
        SendMessageA(hWnd,BM_SETCHECK,(WPARAM)BST_CHECKED,0);
        glpfnDisplayPaletteWindowNotify(WindowNotifyEnumEnablePrnOpts);
    }
/*
    if (m_bAppendTest)
    {
        hWnd=GetDlgItem(m_hWndDlg,IDC_APPENDTEST);
        SendMessageA(hWnd,BM_SETCHECK,(WPARAM)BST_CHECKED,0);
        glpfnDisplayPaletteWindowNotify(WindowNotifyEnumDisablePrnOpts);
    }
*/

    return true;
}

void CFuncTest::RunSamples()
// Toggle options dialog box
{
    if (m_hWndDlg!=NULL)
    {
        if (!IsWindowVisible(m_hWndDlg))
            ShowWindow(m_hWndDlg,SW_SHOW);
        else
            ShowWindow(m_hWndDlg,SW_HIDE);
    }
}

BOOL CFuncTest::AddPrimitive(CPrimitive *pPrimitive)
// Adds a primitive to the primitive test list in options dialog box
{
    HWND hWnd;
    LRESULT iItem;

    hWnd=GetDlgItem(m_hWndDlg,IDC_PRIMITIVES);

    SendMessageA(hWnd,LB_SETSEL,(WPARAM)false,0);    // Reset selection

    iItem=SendMessageA(hWnd,LB_ADDSTRING,0,(LPARAM)pPrimitive->m_szName);
    if (iItem<0)
        return false;

    SendMessageA(hWnd,LB_SETSEL,(WPARAM)true,0);     // Pick top element as selection

    // Data is a pointer to the primitive base class
    SendMessageA(hWnd,LB_SETITEMDATA,(WPARAM)iItem,(LPARAM)pPrimitive);

    return true;
}

BOOL CFuncTest::AddOutput(COutput *pOutput)
// Adds an output to the output list in options dialog box
{
    HWND hWnd;
    LRESULT iItem;

    hWnd=GetDlgItem(m_hWndDlg,IDC_OUTPUTS);

    SendMessageA(hWnd,LB_SETSEL,(WPARAM)false,0);    // Reset selection

    iItem=SendMessageA(hWnd,LB_ADDSTRING,0,(LPARAM)pOutput->m_szName);
    if (iItem<0)
        return false;

    SendMessageA(hWnd,LB_SETSEL,(WPARAM)true,0);     // Pick top element as selection

    // Data is a pointer to the output base class
    SendMessageA(hWnd,LB_SETITEMDATA,(WPARAM)iItem,(LPARAM)pOutput);

    return true;
}

BOOL CFuncTest::AddSetting(CSetting *pSetting)
// Adds a setting to the settings list in options dialog box
{
    HWND hWnd;
    LRESULT iItem;

    hWnd=GetDlgItem(m_hWndDlg,IDC_SETTINGS);
    iItem=SendMessageA(hWnd,LB_ADDSTRING,0,(LPARAM)pSetting->m_szName);
    if (iItem<0)
        return false;

    // Data is a pointer to the setting base class
    SendMessageA(hWnd,LB_SETITEMDATA,(WPARAM)iItem,(LPARAM)pSetting);

    return true;
}

RECT CFuncTest::GetTestRect(int nCol,int nRow)
{
    RECT Rect;

    GetClientRect(g_hWndMain, &Rect);

    return Rect;
}

void CFuncTest::RunTest(COutput *pOutput,CPrimitive *pPrimitive)
// Runs one test using the given output, primitive, and settings that have m_bUseSetting=true
{
    char szBuffer[256];
    MSG Msg;
    Graphics *g=NULL;
    CSetting *pSetting;
    RECT Rect;
    HDC hDC;
    HWND hWnd;
    int iItem;
    LRESULT cItemMax;
    int nX;
    int nY;
    BOOL bFirstSetting=true;

    __try
    {
        sprintf(szBuffer,"%s on %s",pPrimitive->m_szName,pOutput->m_szName);

        Rect=GetTestRect(m_nPageCol,m_nPageRow);    // Get test area

        // Clear test area
        if (m_bEraseBkgd)
        {
            hDC=GetDC(m_hWndMain);
            FillRect(hDC,&Rect,g_hbrBackground);
            ReleaseDC(m_hWndMain,hDC);
        }

        if (m_bDriverHacks)
        {
            glpfnDisplayPaletteWindowNotify(WindowNotifyEnumEnablePrnOpts);
        }
        else
        {
            glpfnDisplayPaletteWindowNotify(WindowNotifyEnumDisablePrnOpts);
        }

        // Initialize output and get graphics pointer
        // Let pOutput modify the nX,nY in case we are drawing to a dib, we do not
        //   want to be translating.
        nX=Rect.left;
        nY=Rect.top;
        g=pOutput->PreDraw(nX,nY);
        if (g==NULL)
            return;

        // Move test to test area
        g->TranslateTransform((float)nX,(float)nY);

        // Set each setting in the list box
        hWnd=GetDlgItem(m_hWndDlg,IDC_SETTINGS);
        cItemMax=SendMessageA(hWnd,LB_GETCOUNT,0,0);
        for (iItem=0;iItem<cItemMax;iItem++) {
            pSetting=(CSetting*)SendMessageA(hWnd,LB_GETITEMDATA,(WPARAM)iItem,0);
            pSetting->Set(g);
            if (pSetting->m_bUseSetting)
            {
                if (bFirstSetting)
                {
                    strcat(szBuffer," (");
                    bFirstSetting=false;
                }
                else
                {
                    strcat(szBuffer,", ");
                }
                strcat(szBuffer,pSetting->m_szName);
            }
        }
        if (!bFirstSetting)
            strcat(szBuffer,")");

        // We do have some primitives (CachedBitmap) which don't respect the 
        // world transform so we need some way to access the offset to the
        // test rectangle.

        pPrimitive->SetOffset(nX, nY);

        // Draw primitive test
        pPrimitive->Draw(g);

        // Destroy graphics pointer
        delete g;

        // Finish off the output
        pOutput->PostDraw(Rect);

        // Write description of test
        hDC=GetDC(m_hWndMain);
        SetBkMode(hDC,TRANSPARENT);
        DrawTextA(hDC,szBuffer,-1,&Rect,DT_CENTER|DT_WORDBREAK);
        ReleaseDC(m_hWndMain,hDC);

        // Determine page col/row where next test will be drawn
        GetClientRect(m_hWndMain,&Rect);
        m_nPageCol++;
        if (m_nPageCol*TESTAREAWIDTH+TESTAREAWIDTH>Rect.right)
        {
            m_nPageCol=0;
            m_nPageRow++;
            if (m_nPageRow*TESTAREAHEIGHT+TESTAREAHEIGHT>Rect.bottom)
            // If graphics page is full, wait or pause
            {
                m_nPageRow=0;
                if (m_bUsePageDelay)
                    Sleep(m_nPageDelay);        // Wait
                else
                {                               // Pause for next input message
                    // Clear old input messages
                    while (GetInputState())
                        PeekMessageA(&Msg,NULL,0,0,PM_REMOVE);

                    // Wait for new input message
                    while (!GetInputState())
                        Sleep(100);
                }
            }
        }
    }__except(EXCEPTION_ACCESS_VIOLATION,1){
        printf("%s caused AV\n",szBuffer);
        g_nResult=1;                       // Return 1 if there was an AV
    }
}

void CFuncTest::InitRun()
// Initialise test run, grabs all info from the options dialog box
{
    HWND hWnd;
    char szDelay[10];
    char szNumPaths[10];
    RECT Rect;
    HDC hDC;

    // Hide options dialog
//  ShowWindow(m_hWndDlg,SW_HIDE);

    // Grab options
/*
    hWnd=GetDlgItem(m_hWndDlg,IDC_PAGEDELAY);
    if (SendMessageA(hWnd,BM_GETCHECK,0,0)==BST_CHECKED)
        m_bUsePageDelay=true;
    else
*/
        m_bUsePageDelay=false;

    hWnd=GetDlgItem(m_hWndDlg,IDC_NUMPATHS);
    SendMessageA(hWnd,WM_GETTEXT,(WPARAM)10,(LPARAM)szNumPaths);
    gnPaths=atoi(szNumPaths);

/*
    hWnd=GetDlgItem(m_hWndDlg,IDC_DELAY);
    SendMessageA(hWnd,WM_GETTEXT,(WPARAM)10,(LPARAM)szDelay);
    m_nPageDelay=atoi(szDelay);
*/

    hWnd=GetDlgItem(m_hWndDlg,IDC_ERASEBKGD);
    if (SendMessageA(hWnd,BM_GETCHECK,0,0)==BST_CHECKED)
        m_bEraseBkgd=true;
    else
        m_bEraseBkgd=false;

    hWnd=GetDlgItem(m_hWndDlg,IDC_DRIVERHACKS);
    if (SendMessageA(hWnd,BM_GETCHECK,0,0)==BST_CHECKED)
    {
        m_bDriverHacks=true;
        glpfnDisplayPaletteWindowNotify(WindowNotifyEnumEnablePrnOpts);
    }
    else
    {
        m_bDriverHacks=false;
        glpfnDisplayPaletteWindowNotify(WindowNotifyEnumDisablePrnOpts);
    }

/*
    hWnd=GetDlgItem(m_hWndDlg,IDC_APPENDTEST);
    if (SendMessageA(hWnd,BM_GETCHECK,0,0)==BST_CHECKED)
        m_bAppendTest=true;
    else
*/
        m_bAppendTest=false;

    // Erase entire main window
    if (!m_bAppendTest && m_bEraseBkgd)
    {
        GetClientRect(m_hWndMain,&Rect);
        hDC=GetDC(m_hWndMain);
        FillRect(hDC,&Rect,g_hbrBackground);
        ReleaseDC(m_hWndMain,hDC);
    }

    if (!m_bAppendTest)
    {
        // Reset page row/col
        m_nPageRow=0;
        m_nPageCol=0;
    }
}

void CFuncTest::EndRun()
{
    int nX;
    int nY;
    RECT rTestArea;
    RECT rWindow;
    HDC hDC;

    hDC=GetDC(m_hWndMain);
    GetClientRect(m_hWndMain,&rWindow);

    // Draw lines on bottom right corner of last test
    // Figure out what was the last m_nPageCol and m_nPageRow
    nX=m_nPageCol-1;
    nY=m_nPageRow;
    if (nX<0) {
        nX=(rWindow.right/(int)TESTAREAWIDTH)-1;
        nY--;
        if (nY<0) {
            nY=(rWindow.bottom/(int)TESTAREAHEIGHT)-1;
        }
    }
    // Get the x,y coordinates
    nX=nX*(int)TESTAREAWIDTH;
    nY=nY*(int)TESTAREAHEIGHT;
    // Draw both lines
/*
    Rectangle(hDC,nX+(int)TESTAREAWIDTH-3,nY,nX+(int)TESTAREAWIDTH,nY+(int)TESTAREAHEIGHT);
    Rectangle(hDC,nX,nY+(int)TESTAREAHEIGHT-3,nX+(int)TESTAREAWIDTH,nY+(int)TESTAREAWIDTH);
*/

    // Clear the rest of the test areas on page
    if (m_bEraseBkgd)
    {
        nX=m_nPageCol;
        nY=m_nPageRow;
        while ((nX>0) || (nY>0))
        {
            rTestArea=GetTestRect(nX,nY);
            FillRect(hDC,&rTestArea,g_hbrBackground);
            nX++;
            if (nX*TESTAREAWIDTH+TESTAREAWIDTH>rWindow.right)
            {
                nX=0;
                nY++;
                if (nY*TESTAREAHEIGHT+TESTAREAHEIGHT>rWindow.bottom)
                // If graphics page is full
                {
                    nY=0;
                }
            }
        }
    }

    ReleaseDC(m_hWndMain,hDC);
}

void CFuncTest::Run()
// Runs all selected tests
{
    COutput *pOutput;
    CPrimitive *pPrimitive;
    CSetting *pSetting;
    HWND hWnd;
    HWND hWndOutput;
    int iOutput;
    LRESULT cOutputMax;
    int iItem;
    LRESULT cItemMax;

    InitRun();      // Init test run

    // Do the selected output loop
    hWndOutput=GetDlgItem(m_hWndDlg,IDC_OUTPUTS);
    cOutputMax=SendMessageA(hWndOutput,LB_GETCOUNT,0,0);
    for (iOutput=0;iOutput<cOutputMax;iOutput++) {
        pOutput=(COutput*)SendMessageA(hWndOutput,LB_GETITEMDATA,(WPARAM)iOutput,0);
        if (SendMessageA(hWndOutput,LB_GETSEL,(WPARAM)iOutput,0)<=0)
            continue;

        // Set each setting according to what is selected in the list box
        hWnd=GetDlgItem(m_hWndDlg,IDC_SETTINGS);
        cItemMax=SendMessageA(hWnd,LB_GETCOUNT,0,0);
        for (iItem=0;iItem<cItemMax;iItem++) {
            pSetting=(CSetting*)SendMessageA(hWnd,LB_GETITEMDATA,(WPARAM)iItem,0);

            if (SendMessageA(hWnd,LB_GETSEL,(WPARAM)iItem,0)>0)
                pSetting->m_bUseSetting=true;
            else
                pSetting->m_bUseSetting=false;
        }

        // Draw each primitive selected in the list box
        hWnd=GetDlgItem(m_hWndDlg,IDC_PRIMITIVES);
        cItemMax=SendMessageA(hWnd,LB_GETCOUNT,0,0);
        for (iItem=0;iItem<cItemMax;iItem++) {
            pPrimitive=(CPrimitive*)SendMessageA(hWnd,LB_GETITEMDATA,(WPARAM)iItem,0);

            if (SendMessageA(hWnd,LB_GETSEL,(WPARAM)iItem,0)>0)
                RunTest(pOutput,pPrimitive);
        }
    }

    EndRun();
}

void CFuncTest::ClearAllSettings()
// Clear all settings to m_bUseSetting=false
{
    CSetting *pSetting;
    HWND hWnd;
    LRESULT cItemMax;
    int iItem;

    // Set all settings off
    hWnd=GetDlgItem(m_hWndDlg,IDC_SETTINGS);
    cItemMax=SendMessageA(hWnd,LB_GETCOUNT,0,0);
    for (iItem=0;iItem<cItemMax;iItem++) {
        pSetting=(CSetting*)SendMessageA(hWnd,LB_GETITEMDATA,(WPARAM)iItem,0);
        pSetting->m_bUseSetting=false;
    }
}

INT_PTR CALLBACK CFuncTest::DlgProc(HWND hWndDlg,UINT Msg,WPARAM wParam,LPARAM lParam)
// Options dialog proc
{
    switch (Msg)
    {
        case WM_INITDIALOG:
            return true;
        case WM_COMMAND:
            if (HIWORD(wParam)==BN_CLICKED)
            {
                switch (LOWORD(wParam))
                {
                    case IDC_RUN:
                        g_FuncTest.Run();
                        return true;
                    case IDC_CLOSE:
                        EndDialog(hWndDlg,0);
                        return true;
                }
            }
            else if (HIWORD(wParam)==LBN_DBLCLK)
            {
                switch (LOWORD(wParam))
                {
                    case IDC_PRIMITIVES:
                        g_FuncTest.Run();
                        return true;
                }
            }
            break;
        case WM_CLOSE:
            ShowWindow(hWndDlg,SW_HIDE);
            return true;
    }

    return false;
}

#define UNICODE
#define _UNICODE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\driverhack\cfunctest.h ===
/******************************Module*Header*******************************\
* Module Name: CFuncTest.h
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/

#ifndef __CFUNCTEST_H
#define __CFUNCTEST_H

#include "Global.h"
#include "CPrimitive.h"
#include "CSetting.h"
#include "COutput.h"

class CFuncTest  
{
public:
	CFuncTest();
	~CFuncTest();

	BOOL Init(HWND hWndParent);								// Initializes functest
	void RunSamples();										// Toggles option dialog
	static INT_PTR CALLBACK DlgProc(HWND hWndDlg,UINT uMsg,WPARAM wParam,LPARAM lParam);

	BOOL AddPrimitive(CPrimitive *pPrimitive);				// Add a primitive to test list
	BOOL AddOutput(COutput *pOutput);						// Add a graphics output to test list
	BOOL AddSetting(CSetting *pSetting);					// Add a graphics setting to test list

	RECT GetTestRect(int nCol,int nRow);					// Gets the test area located at nCol/nRow
	void RunTest(COutput *pOutput,CPrimitive *pPrimitive);	// Runs a specific test on a specific output
	void InitRun();											// Must be called before running a series of tests
	void EndRun();											// Must be called after running a series of tests
	void Run();												// Run the selected tests
	void RunRegression();									// Run regression tests

	void ClearAllSettings();								// Sets all settings in the list box to m_bUseSetting=false

	HWND m_hWndMain;										// Main window
	HWND m_hWndDlg;											// Dialog window
	BOOL m_bUsePageDelay;									// Use page delay or page pause
	BOOL m_bEraseBkgd;										// Erase old test background
	BOOL m_bDriverHacks;									// Enable printer driver hacks in GDIPlus
	BOOL m_bAppendTest;										// Appends test to previous tests
	int m_nPageDelay;										// Delay after each graphics page
	int m_nPageRow;											// Row to draw next test
	int m_nPageCol;											// Column to draw next test
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\driverhack\chwnd.h ===
/******************************Module*Header*******************************\
* Module Name: CHWND.h
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/

#ifndef __CHWND_H
#define __CHWND_H

#include "COutput.h"

class CHWND : public COutput  
{
public:
	CHWND(BOOL bRegression);
	virtual ~CHWND();

	Graphics *PreDraw(int &nOffsetX,int &nOffsetY);			// Set up graphics at the given X,Y offset
	void PostDraw(RECT rTestArea);							// Finish off graphics at rTestArea
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\driverhack\chdc.cpp ===
/******************************Module*Header*******************************\
* Module Name: CHDC.cpp
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/
#include "CHDC.h"
#include "CFuncTest.h"

extern CFuncTest g_FuncTest;

CHDC::CHDC(BOOL bRegression)
{
	strcpy(m_szName,"HDC");
	m_hPal=NULL;
	m_hOldPal=NULL;
	m_hDC=NULL;
	m_bRegression=bRegression;
}

CHDC::~CHDC()
{
}

Graphics *CHDC::PreDraw(int &nOffsetX,int &nOffsetY)
{
	Graphics *g=NULL;

	m_hDC=GetDC(g_FuncTest.m_hWndMain);
	g=Graphics::FromHDC(m_hDC);

	return g;
}

void CHDC::PostDraw(RECT rTestArea)
{
	if (m_hOldPal)
		SelectPalette(m_hDC,m_hOldPal,FALSE);

	ReleaseDC(g_FuncTest.m_hWndMain,m_hDC);
	DeleteObject(m_hPal);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\driverhack\chdc.h ===
/******************************Module*Header*******************************\
* Module Name: CHDC.h
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/

#ifndef __CHDC_H
#define __CHDC_H

#include "COutput.h"

class CHDC : public COutput  
{
public:
	CHDC(BOOL bRegression);
	virtual ~CHDC();

	Graphics *PreDraw(int &nOffsetX,int &nOffsetY);			// Set up graphics at the given X,Y offset
	void PostDraw(RECT rTestArea);							// Finish off graphics at rTestArea

	HPALETTE m_hPal;
	HPALETTE m_hOldPal;
	HDC m_hDC;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\driverhack\chwnd.cpp ===
/******************************Module*Header*******************************\
* Module Name: CHWND.cpp
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/
#include "CHWND.h"
#include "CFuncTest.h"

extern CFuncTest g_FuncTest;

CHWND::CHWND(BOOL bRegression)
{
	strcpy(m_szName,"HWND");
	m_bRegression=bRegression;
}

CHWND::~CHWND()
{
}

Graphics *CHWND::PreDraw(int &nOffsetX,int &nOffsetY)
{
	Graphics *g=NULL;

	g=Graphics::FromHWND(g_FuncTest.m_hWndMain);

	return g;
}

void CHWND::PostDraw(RECT rTestArea)
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\driverhack\coutput.cpp ===
/******************************Module*Header*******************************\
* Module Name: COutput.cpp
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/
#include "COutput.h"
#include "CFuncTest.h"

extern CFuncTest g_FuncTest;

COutput::COutput()
{
	strcpy(m_szName,"No name assigned");
	m_bRegression=false;
}

COutput::~COutput()
{

}

BOOL COutput::Init()
{
	return g_FuncTest.AddOutput(this);
}

void COutput::PostDraw(RECT rTestArea)
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\driverhack\coutput.h ===
/******************************Module*Header*******************************\
* Module Name: COutput.h
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/

#ifndef __COUTPUT_H
#define __COUTPUT_H

#include "Global.h"

class COutput  
{
public:
	COutput();
	virtual ~COutput();

	virtual BOOL Init();										// Add output to output list in functest dialog
	virtual Graphics *PreDraw(int &nOffsetX,int &nOffsetY)=0;	// Set up graphics at the given X,Y offset
	virtual void PostDraw(RECT rTestArea);						// Finish off graphics at rTestArea

	char m_szName[256];
	BOOL m_bRegression;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\driverhack\cpaths.h ===
/******************************Module*Header*******************************\
* Module Name: CPaths.h
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/

#ifndef __CPATHS_H
#define __CPATHS_H

#include "CPrimitive.h"

class CPaths : public CPrimitive  
{
public:
	CPaths(BOOL bRegression);
	virtual ~CPaths();

	void Draw(Graphics *g);

	VOID TestBezierPath(Graphics* g);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\driverhack\cpaths.cpp ===
/******************************Module*Header*******************************\
* Module Name: CPaths.cpp
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/
#include "CPaths.h"
#include <limits.h>
#include <stdio.h>

extern gnPaths;
extern HWND g_hWndMain;

CPaths::CPaths(BOOL bRegression)
{
	strcpy(m_szName,"Paths");
	m_bRegression=bRegression;
}

CPaths::~CPaths()
{
}

void CPaths::Draw(Graphics *g)
{
    TestBezierPath(g);
}

VOID CPaths::TestBezierPath(Graphics *g)
{
    REAL width = 4;         // Pen width
    REAL offset;
    Point points[4];
    RectF rect;
    RECT  crect;
    int   i;

    // find avg size of testarea. 4 => top & bottom strokes of path + a white
    // width wide border, plus 1 => the white square in the center
    GetClientRect(g_hWndMain, &crect);
    width = (REAL)((crect.bottom - crect.top) / ((4 * gnPaths) + 1));
    offset = width;

    Color blackColor(128, 0, 0, 0);
    SolidBrush blackBrush(blackColor);
    Pen blackPen(&blackBrush, width);

    for(i = 1; i <= gnPaths; i++) {

        GraphicsPath* path = new GraphicsPath(FillModeAlternate);

        rect.X = offset;
        rect.Y = offset;
        rect.Width = crect.right - (2 * offset);
        rect.Height = crect.bottom - (2 * offset);

        path->AddRectangle(rect);
        g->DrawPath(&blackPen, path);

        delete path;

        offset += (width * 2);

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\driverhack\cprimitive.h ===
/******************************Module*Header*******************************\
* Module Name: CPrimitive.h
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/

#ifndef __CPRIMITIVE_H
#define __CPRIMITIVE_H

#include "Global.h"

class CPrimitive  
{
public:
	CPrimitive();
	virtual ~CPrimitive();

	virtual BOOL Init();
	virtual void Draw(Graphics *g)=0;
    void SetOffset(int x, int y)
    {
        m_ix = x;
        m_iy = y;
    }

	char m_szName[256];
	BOOL m_bRegression;

    // Offset for this test.

    INT m_ix;
    INT m_iy;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\driverhack\cprimitive.cpp ===
/******************************Module*Header*******************************\
* Module Name: CPrimitive.cpp
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/
#include "CPrimitive.h"
#include "CFuncTest.h"

extern CFuncTest g_FuncTest;

CPrimitive::CPrimitive()
{
	strcpy(m_szName,"No name assigned");
	m_bRegression=false;
}

CPrimitive::~CPrimitive()
{

}

BOOL CPrimitive::Init()
{
	g_FuncTest.AddPrimitive(this);
	return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\driverhack\cprinter.h ===
/******************************Module*Header*******************************\
* Module Name: CPrinter.h
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/

#ifndef __CPRINTER_H
#define __CPRINTER_H

#include "COutput.h"

class CPrinter : public COutput  
{
public:
	CPrinter(BOOL bRegression);
	virtual ~CPrinter();

	BOOL Init();
	Graphics *PreDraw(int &nOffsetX,int &nOffsetY);			// Set up graphics at the given X,Y offset
	void PostDraw(RECT rTestArea);							// Finish off graphics at rTestArea

	HDC m_hDC;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\driverhack\cprinting.h ===
/******************************Module*Header*******************************\
* Module Name: CPrinting.h
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/

#ifndef __CPRINTING_H
#define __CPRINTING_H

#include "..\CPrimitive.h"

class CPrinting : public CPrimitive  
{
public:
	CPrinting(BOOL bRegression);
	virtual ~CPrinting();

	void Draw(Graphics *g);

	VOID TestPerfPrinting(Graphics *g);
	VOID TestTextPrinting(Graphics *g);
        
        VOID TestNolan1(Graphics *g);
        VOID TestNolan2(Graphics *g);

        VOID TestBug104604(Graphics *g);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\driverhack\cprinter.cpp ===
/******************************Module*Header*******************************\
* Module Name: CPrinter.cpp
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/
#include "CPrinter.h"

CPrinter::CPrinter(BOOL bRegression)
{
	m_hDC=NULL;
	strcpy(m_szName,"Printer");
	m_bRegression=bRegression;
}

CPrinter::~CPrinter()
{
}

BOOL CPrinter::Init()
{
	// hidden API to turn on our printing code
	DllExports::GdipDisplayPaletteWindowNotify((WindowNotifyEnum)0xFFFFFFFF);

	return COutput::Init();
}

Graphics *CPrinter::PreDraw(int &nOffsetX,int &nOffsetY)
{
	Graphics *g=NULL;

	PRINTDLGA pd =
	{
	   sizeof(PRINTDLG),
	   NULL,            // hwndOwner
	   NULL,            // hDevMode
	   NULL,            // hDevNames
	   NULL,            // hDC
	   PD_RETURNDC,
	   1,
	   1,
	   1,
	   1,
	   1,
	   GetModuleHandleA(NULL),
	   NULL,
	   NULL,            // print hook
	   NULL,            // setup hook
	   NULL,            // print template name
	   NULL,            // setup template name
	   NULL,            // hPrintTemplate
	   NULL             // hSetupTemplate
	};

	if (!PrintDlgA(&pd))
	{
	   MessageBoxA(NULL, "No printer selected.", NULL, MB_OK);
	   return NULL;
	}

	DOCINFOA docinfo;
	docinfo.cbSize        = sizeof(DOCINFO);
	docinfo.lpszDocName   = "GDI+ Print Test";
	docinfo.lpszOutput    = NULL;         // put name here to output to file
	docinfo.lpszDatatype  = NULL;         // data type 'emf' or 'raw'
	docinfo.fwType        = 0;

	m_hDC = pd.hDC;
	INT printJobID = StartDocA(m_hDC, &docinfo);
	StartPage(m_hDC);

	SetStretchBltMode(m_hDC, HALFTONE);
	SetBrushOrgEx(m_hDC, 0, 0, NULL);

	g = Graphics::FromHDC(m_hDC);

	return g;
}

void CPrinter::PostDraw(RECT rTestArea)
{
	EndPage(m_hDC);
	EndDoc(m_hDC);
	DeleteDC(m_hDC);

	MessageBoxA(NULL, "Print Functionality Test Complete.", NULL, MB_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\driverhack\csetting.cpp ===
/******************************Module*Header*******************************\
* Module Name: CSetting.cpp
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/
#include "CSetting.h"
#include "CFuncTest.h"

extern CFuncTest g_FuncTest;

CSetting::CSetting()
{
	strcpy(m_szName,"No name assigned");
	m_bUseSetting=false;
	m_bRegression=false;
}

CSetting::~CSetting()
{

}

BOOL CSetting::Init()
{
	g_FuncTest.AddSetting(this);
	return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\driverhack\cprinting.cpp ===
/******************************Module*Header*******************************\
* Module Name: CPrinting.cpp
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/
#include "CPrinting.h"

CPrinting::CPrinting(BOOL bRegression)
{
	strcpy(m_szName,"Printing");
	m_bRegression=bRegression;
}

CPrinting::~CPrinting()
{
}

VOID CPrinting::TestTextPrinting(Graphics *g)
{
    Font f(L"Arial", 60);

    FontFamily  ff(L"Arial");
    RectF	  rectf1( 20,   0, 300, 200);
    RectF	  rectf2( 20, 300, 300, 200);
    RectF	  rectf3(220,   0, 300, 200);
    RectF	  rectf4(220, 300, 300, 200);


    Color color1(0xff, 100, 0, 200);
    Color color2(128, 100, 0, 200);
    Color color3(0xff, 0, 100, 200);
    Color color4(128, 0, 100, 0);
    SolidBrush brush1(color1);
    SolidBrush brush2(color2);
    LinearGradientBrush brush3(rectf3, color3, color4, LinearGradientModeForwardDiagonal);

    g->DrawString(L"Color1", 6, &f, rectf1, NULL, &brush1);
    g->DrawString(L"Color2", 6, &f, rectf2, NULL, &brush2);
    g->DrawString(L"Color3", 6, &f, rectf3, NULL, &brush3);
}

VOID CPrinting::TestPerfPrinting(Graphics *g)
{
/*
   Analyze file size based on output of StretchDIBits.  The claim by DonC is that when we StretchDIBits a
   subrectangle of a large DIB, it sends the large DIB to the printer and then clips to the subrectangle.
   How stupid, but it apparently does on Win98 postscript.

   So this is the results of my test:  1000x1000 DIB (32bpp).  I blitted two chunks:

   This is 200x200 source rectangle (part of a band):

04/27/2000  03:00p              22,198 nt5pcl
04/27/2000  03:02p             268,860 nt5ps			// Level 1 ps
04/27/2000  02:47p              17,488 w98pcl
04/27/2000  02:47p           6,207,459 w98ps			// Level 1 ps

   This is 1000x200 source rectangle (an entire band):

04/27/2000  03:06p              80,291 nt5pcl
04/27/2000  03:06p           1,266,123 nt5ps			// Level 1 ps
04/27/2000  02:51p              60,210 w98pcl
04/27/2000  02:52p           6,207,457 w98ps			// Level 1 ps

   Also compared 32bpp vs. 24bpp DIB.  The results were contradictary:

  04/27/2000  03:59p      <DIR>          ..
  04/27/2000  03:06p              80,291 nt5pcl
  04/27/2000  03:51p             122,881 nt5pcl24
  04/27/2000  03:06p           1,266,123 nt5ps
  04/27/2000  03:51p           1,262,332 nt5ps24
  04/27/2000  02:51p              60,210 w98pcl
  04/27/2000  03:39p             101,216 w98pcl24
  04/27/2000  02:52p           6,207,457 w98ps
  04/27/2000  03:39p           6,207,457 w98ps24

*/
    if (1) 
    {
        BITMAPINFO bi;
        ZeroMemory(&bi, sizeof(BITMAPINFO));

        bi.bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
        bi.bmiHeader.biPlanes = 1;
        bi.bmiHeader.biCompression = BI_RGB;
        bi.bmiHeader.biSizeImage = 0;

        bi.bmiHeader.biWidth = 1000;
        bi.bmiHeader.biHeight = 1000;
        bi.bmiHeader.biBitCount = 32;

        ARGB* Bits = (ARGB*)malloc(bi.bmiHeader.biWidth *
                              bi.bmiHeader.biHeight *
                              sizeof(ARGB));

        ARGB* Ptr = Bits;

        // To eliminate RLE/ASCII85 encoding, set to random bits
        for (INT i=0; i<bi.bmiHeader.biHeight; i++)
            for (INT j=0; j<bi.bmiHeader.biWidth; j++) 
            {
                *Ptr++ = (ARGB)(i | (j<<16));
            }

        HDC hdc = g->GetHDC();

        StretchDIBits(hdc, 0, 0, 1000, 200, 
                      0, 700, 1000, 200, Bits, &bi,
                      DIB_RGB_COLORS, SRCCOPY);

        g->ReleaseHDC(hdc);

        free(Bits);

    }
}

void CPrinting::Draw(Graphics *g)
{
// TestPerfPrinting(g);
// TestTextPrinting(g);
TestBug104604(g);

if (0)
    {

#if 1
    HDC hdc = g->GetHDC();

    HDC bufHdc = CreateCompatibleDC(hdc);

    HBITMAP BufDIB = NULL;
    ARGB* argb;

    struct {
       BITMAPINFO bitmapInfo;
       RGBQUAD rgbQuad[4];
    } bmi;

    INT width=100;
    INT height=100;

    ZeroMemory(&bmi.bitmapInfo, sizeof(bmi.bitmapInfo));

    bmi.bitmapInfo.bmiHeader.biSize        = sizeof(BITMAPINFOHEADER);
    bmi.bitmapInfo.bmiHeader.biWidth       = width;
    bmi.bitmapInfo.bmiHeader.biHeight      = -height;
    bmi.bitmapInfo.bmiHeader.biPlanes      = 1;
    bmi.bitmapInfo.bmiHeader.biBitCount    = 24;
    bmi.bitmapInfo.bmiHeader.biCompression = BI_RGB;
	
    RGBQUAD red = { 0, 0, 0xFF, 0}; // red
    RGBQUAD green = { 0, 0xFF, 0, 0}; // green
    RGBQUAD blue = { 0xFF, 0, 0, 0}; // blue

    bmi.bitmapInfo.bmiColors[0] = red;
    bmi.bitmapInfo.bmiColors[1] = green;
    bmi.bitmapInfo.bmiColors[2] = blue;

    // if assert fails, then we didn't clean up properly by calling End()
//    ASSERT(BufDIB == NULL);

    BufDIB = CreateDIBSection(bufHdc,
                 &bmi.bitmapInfo,
                 DIB_RGB_COLORS,
                 (VOID**) &argb,
                 NULL,
                 0);
//    ASSERT(BufDIB != NULL);

    memset(argb, 0, 3*width*height);

    INT i,j;
    BYTE* tempptr = (BYTE*)argb;
    for (i=0; i<height; i++)
    {
        for (j=0; j<width; j++)
        {
            if (i==j)
            {
                *tempptr++ = 0xFF;
                *tempptr++ = 0x80;
                *tempptr++ = 0x40;
            }
            else
                tempptr += 3;    
        }
        if ((((ULONG_PTR)tempptr) % 4) != 0) tempptr += 4-(((ULONG_PTR)tempptr) % 4);
    }

    INT mode = GetMapMode(bufHdc);
//    WARNING(("MapMode printing = %08x\n", mode));

    SelectObject(bufHdc, BufDIB);
/*
for (i=0; i<100; i++)
{
    int result = StretchBlt(hdc, 0, i*2, 2*width, 2, bufHdc, 0, i, width, 0, SRCCOPY);
    INT joke = GetLastError();
	joke++;
}
 */
//	int result = StretchBlt(hdc, 0, 0, 50, 50, bufHdc, 0, 0, 50, 50, SRCCOPY);
	
	for (i=0; i<50; i++)
	{
		int result = StretchBlt(hdc, 0, 100+i*2, 100, 1, bufHdc, 0, i*2, 100, 1, SRCCOPY);
    }
//   int result = StretchBlt(hdc, 0, 0, 200, 200, bufHdc, 0, 0, 100, 100, SRCCOPY);

//    ASSERT(result != 0);

    g->ReleaseHDC(hdc);

    DeleteDC(bufHdc);
    DeleteObject(BufDIB);

#endif

#if 1
    REAL widthF = 4; // Pen width

    Color redColor(255, 0, 0);

    SolidBrush brush1(Color(0xFF,0xFF,0,0));
    SolidBrush brush2(Color(0x80,0x80,0,0));

    SolidBrush brush3(Color(0xFF,0xFF,0,0));
    SolidBrush brush4(Color(0x80,0x80,0,0));

    Color colors1[] = { Color(0xFF,0xFF,0,0),
                        Color(0xFF,0,0xFF,0),
                        Color(0xFF,0,0,0xFF),
                        Color(0xFF,0x80,0x80,0x80) };
    Color colors2[] = { Color(0x80,0xFF,0,0),
                        Color(0x80,0,0xFF,0),
                        Color(0x80,0,0,0xFF),
                        Color(0x80,0x80,0x80,0x80) };

    //SolidBrush brush3(colors1[2]);
    //SolidBrush brush4(colors2[2]);

    // Default Wrap: Clamp to small rectangle 
//    RectangleGradientBrush brush3(Rect(125,275,50,50),
//                                  &colors1[0]);//,
                                  //WrapModeClamp);
    // Default Wrap: Clamp to 
//    RectangleGradientBrush brush4(Rect(250,250,100,100),
//                                  &colors2[0]);//,
                                  //WrapModeClamp);

    g->SetPageScale(1.2f);

    // no path clip
    g->FillRectangle(&brush1, Rect(0,25,500,50));

    // tests solid + opaque combinations + path clip only
    g->FillEllipse(&brush1, Rect(100,100,100,100));
    g->FillEllipse(&brush2, Rect(300,100,100,100));
    g->FillEllipse(&brush3, Rect(100,250,100,100));
    g->FillEllipse(&brush4, Rect(300,250,100,100));

    // tests visible clip + path clip
    Region origRegion;
    g->GetClip(&origRegion);
    Region *newRegion = new Region();
    newRegion->MakeInfinite();

    //Rect horzRect(150, 600, 500, 25);
    //Rect vertRect(150, 600, 25, 500);
    Rect horzRect(100, 400, 500, 25);
    Rect vertRect(100, 400, 25, 500);
    Region *horzRegion = new Region(horzRect);
    Region *vertRegion = new Region(vertRect);

    for (i = 0; i < 10; i++)
    {   
        newRegion->Xor(horzRegion);
        newRegion->Xor(vertRegion);
        horzRegion->Translate(0, 50);
        vertRegion->Translate(50, 0);
    }
    delete horzRegion;
    delete vertRegion;

    // Set grid clipping
    g->SetClip(newRegion);

    // set wrap mode from Clamp to Tile    
//    brush3.SetWrapMode(WrapModeTile);
//    brush4.SetWrapMode(WrapModeTile);

    // tests solid + opaque combinations + visible clip +  path clip only

    g->FillEllipse(&brush1, Rect(100,400,100,100));
    g->FillEllipse(&brush2, Rect(300,400,100,100));
    g->FillEllipse(&brush3, Rect(100,550,100,100));
    g->FillEllipse(&brush4, Rect(300,550,100,100));

    // restore original clip region
    g->SetClip(&origRegion);
    delete newRegion;

    // Test case which stretches beyond GetTightBounds() DrawBounds API

    PointF pts[8];

    pts[0].X = 2150.0f; pts[0].Y = 2928.03f;
    pts[1].X = 1950.0f; pts[1].Y = 3205.47f;
    pts[2].X = 1750.0f; pts[2].Y = 2650.58f;
    pts[3].X = 1550.0f; pts[3].Y = 2928.03f;
    pts[4].X = 1550.0f; pts[4].Y = 3371.97f;
    pts[5].X = 1750.0f; pts[5].Y = 3094.53f;
    pts[6].X = 1950.0f; pts[6].Y = 3649.42f;
    pts[7].X = 2150.0f; pts[7].Y = 3371.97f;

    BYTE types[8] = { 1, 3, 3, 3, 1, 3, 3, 0x83 };


    Bitmap *bitmap = new Bitmap(L"winnt256.bmp");

    // Test g->DrawImage
    if (bitmap && bitmap->GetLastStatus() == Ok) 
    {

        int i;

        for (i=0; i<8; i++) 
        {
            pts[i].X = pts[i].X / 8.0f;
            pts[i].Y = pts[i].Y / 8.0f;
        }

        TextureBrush textureBrush(bitmap, WrapModeTile);

        GraphicsPath path(&pts[0], &types[0], 8);

        g->FillPath(&textureBrush, &path);

        // Text using WrapModeClamp
        for (i=0; i<8; i++)
           pts[i].X += 200.0f;

        TextureBrush textureBrush2(bitmap, WrapModeClamp);

        GraphicsPath path2(&pts[0], &types[0], 8);

        g->FillPath(&textureBrush2, &path2);

        delete bitmap;
    }

/*
    Font font(50.0f * g->GetDpiY() / 72.0f, // emSize
              FontFamily(L"Arial"), // faceName,
              0,
              (Unit)g->GetPageUnit()
              );

    // will fail on Win9x
    LPWSTR str = L"Printing Support is COOL";
    GpRectF layoutRect1(200, 200, 300, 100);
    GpRectF layoutRect2(200, 400, 300, 100);
    GpRectF layoutRect3(200, 600, 300, 100);
    GpRectF layoutRect4(200, 800, 300, 100);

    INT len = 0;
    LPWSTR strPtr = str;
    while (*str != '\0') { len++; str++; }

    StringFormat format1 = StringFormatDirectionRightToLeft;
    StringFormat format2 = StringFormatDirectionVertical;
    StringFormat format3 = StringFormatDirectionRightToLeft;
    StringFormat format4 = StringFormatDirectionVertical;

    // Test DDI: SolidText (Brush 1 or 2)
    g->DrawString(strPtr, len, &font, &layoutRect1, &format1, &brush1);
    g->DrawString(strPtr, len, &font, &layoutRect2, &format2, &brush2);   

    // Test DDI: BrushText (Brush 3 or 4)
    g->DrawString(strPtr, len, &font, &layoutRect3, &format3, &brush3);
    g->DrawString(strPtr, len, &font, &layoutRect4, &format4, &brush4);   

    // Test DDI: StrokePath
    // Test DDI: FillRegion
*/
#endif
    }

}

// Try this from Nolan Lettelier
VOID CPrinting::TestNolan1(Graphics *g)
{
/*	TestInit(hdc);

	Graphics *pg = Graphics::FromHDC(hdc);
	if (pg == NULL)
	{
		assert(0);
		return false;
	}

	int sts;
	int alpha = 255, red = 255, green = 0, blue = 255;
	Color c1(alpha,red,green,blue);
	Point p1(150,150), p2(300,300);
	Color c2(255, 255-red, 255-green, 255-blue);
	LineGradientBrush gb(p1, p2, c1, c2);

	Pen p(&gb, 50.0);

	sts = pg->DrawLine(&p,0, 0, 500, 500);
	assert(sts == Ok);

	sts = pg->DrawLine(&p,0,100, 500, 100);
	assert(sts == Ok);

	sts = pg->DrawLine(&p,0,350, 500, 350);
	assert(sts == Ok);

	sts = pg->DrawLine(&p,0,500, 500, 0);
	assert(sts == Ok);
	delete pg;
	return true;
        */
}

VOID CPrinting::TestNolan2(Graphics *g)
{
    /*
        CString lineText("NolanRules");
        
	Graphics *pg = g;
        if (pg == NULL)
	{
		assert(0);
		return false;
	}
        Unit origUnit = pg->GetPageUnit();
        Matrix origXform;
        pg->GetTransform(&origXform);

        pg->SetPageUnit(UnitInch);
        pg->ScaleTransform(8.0f/1000.0f, 8.0f/1000.0f);

	Status sts;
	int alpha = 255, red = 255, green = 0, blue = 255;
	RectF rg(150,150,300,175);
	Color c1(alpha,red,green,blue);
	Color c2(255, 255-red, 255-green, 255-blue);
	LineGradientBrush gb(rg, c1, c2, LineGradientModeVertical);

	WCHAR *famName[] = {
		L"Comic Sans MS"
		, L"Courier New"
		, L"Times New Roman"
		, L"Tahoma"
		, L"Arial"
		, L"Lucida Console"
		, L"Garamond"
		, L"Palatino"
		, L"Univers"
		, L"Marigold"
		, L"Albertus"
		, L"Antique Olive"
	};

	int famCount = sizeof(famName) / sizeof(WCHAR *);

	WCHAR *s = L"GDI+ GradientFill";
	
	RectF r(30,30,0,0);
	StringFormat sf(0);
	FontFamily *pFontFamily;

	float lineHeight = 60;
	int i;
	for (i = 0, r.Y = 30 ; r.Y < 800 ; r.Y += lineHeight, ++i)
	{
		pFontFamily = new FontFamily(famName[i % famCount]);
		while (pFontFamily == NULL || pFontFamily->GetLastStatus()
!= Ok)
		{
			delete pFontFamily;
			++i;
			pFontFamily = new FontFamily(famName[i % famCount]);
		}
			
		Font f(*pFontFamily, lineHeight * 5 / 6, 0, UnitPoint);
		sts = pg->DrawString(s, wcslen(s), &f, &r, &sf, &gb);
//		CHECK_RESULT(sts, "TestGradientLinearVertical2 DrawString");
		delete pFontFamily;
	}

	delete pg;
	
        pg->SetPageUnit(origUnit);
        pg->SetTransform(&origXform);
        return true;
*/

} // TestGradientLinearVertical2

VOID CPrinting::TestBug104604(Graphics *g)
{
    BYTE* memory = new BYTE[8*8*3];
    // checkerboard pattern
    for (INT i=0; i<8*8; i += 3)
    {
        if (i%2)
        {
            memory[i] = 0xff;
            memory[i+1] = 0;
            memory[i+2] = 0;
        }
        else
        {
            memory[i] = 0;
            memory[i+1] = 0;
            memory[i+2] = 0xff;
        }
    }
    
    Bitmap bitmap(8,8, 8*3, PixelFormat24bppRGB, memory);
    
    TextureBrush brush(&bitmap);

    g->SetCompositingMode(CompositingModeSourceCopy);
    g->FillRectangle(&brush, 0, 0, 100, 100);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\driverhack\csetting.h ===
/******************************Module*Header*******************************\
* Module Name: CSetting.h
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/

#ifndef __CSETTING_H
#define __CSETTING_H

#include "Global.h"

class CSetting  
{
public:
	CSetting();
	virtual ~CSetting();

	virtual BOOL Init();
	virtual void Set(Graphics *g)=0;

	char m_szName[256];
	BOOL m_bUseSetting;
	BOOL m_bRegression;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\driverhack\guid.c ===
/**************************************************************************\
* 
* Copyright (c) 1999  Microsoft Corporation
*
* Abstract:
*
*   GUID definition file
*
*   GUIDs that are needed by functest are defined here.
*
* Revision History:
*
*   10/22/1999 bhouse
*       Created it.
*
\**************************************************************************/

// NOTE: Since we use C++ precompiled headers this C file will not use
//       the precompiled header allowing us to define INITGUID and include
//       directdraw and d3d headers to generate the GUIDs defined by these
//       headers.

#define INITGUID
#include <ddraw.h>
#include <d3d.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\driverhack\main.cpp ===
/******************************Module*Header*******************************\
* Module Name: Main.cpp
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  28-Apr-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/

#undef UNICODE
#undef _UNICODE

#include <windows.h>
#include <commctrl.h>
#include "CFuncTest.h"
#include "resource.h"

CFuncTest g_FuncTest;                                   // FuncTest (handles test runs)
HBRUSH g_hbrBackground=NULL;                            // Main window background color
HWND g_hWndMain=NULL;                                   // Main window
int g_nResult=0;                                        // Result of test run
int gnPaths = 2;

// Include all the outputs (classes derived from COutput)
#include "CHWND.h"
#include "CHDC.h"
#include "CPrinter.h"

// Include all the primitives (classes derived from CPrimitive)
#include "CPaths.h"
#include "CBanding.h"
#include "CExtra.h"

// Create global objects for each individual output
//   First constructor param is the regression flag
//   If true, the test will take part of the regression suite
CHWND g_HWND(true);
CHDC g_HDC(true);
CPrinter g_Printer(false);


LPFNGDIPLUS glpfnDisplayPaletteWindowNotify;

// Create global objects for each individual setting
//   First constructor param is the regression flag
//   If true, the test will take part of the regression suite

LRESULT CALLBACK WndProc(HWND hWnd,UINT Msg,WPARAM wParam,LPARAM lParam)
// Main window proc
{
    switch (Msg)
    {
        case WM_COMMAND:                // Process menu buttons
            switch(LOWORD(wParam))
            {
                case IDM_RUN:
                    g_FuncTest.Run();
                    break;
                case IDM_SAMPLES:
                    g_FuncTest.RunSamples();
                    break;
                case IDM_QUIT:
                    exit(0);
                    break;
            }
            break;

        case WM_DESTROY:
            PostQuitMessage(0);
            break;
    }

    return DefWindowProcA(hWnd,Msg,wParam,lParam);
}

void WindowUninit()
// Uninitializes window
{
    if (g_hbrBackground!=NULL)      // Destroy background brush
    {
        DeleteObject((HGDIOBJ)g_hbrBackground);
        g_hbrBackground=NULL;
    }
    if (g_hWndMain!=NULL)           // Destroy main window
    {
        DestroyWindow(g_hWndMain);
        g_hWndMain=NULL;
    }
}

BOOL WindowInit()
// Creates window and starts up app
{
    WNDCLASSA wc;
	HINSTANCE hInst=GetModuleHandleA(NULL);

    // Create white background brush
    g_hbrBackground=CreateSolidBrush(RGB(0xFF,0xFF,0xFF));

    wc.style            = CS_HREDRAW | CS_VREDRAW;
    wc.lpfnWndProc      = WndProc;
    wc.cbClsExtra       = 0;
    wc.cbWndExtra       = 0;
    wc.hInstance        = hInst;
    wc.hIcon            = LoadIconA(NULL,MAKEINTRESOURCEA(32512));// IDI_APPLICATION);
    wc.hCursor          = LoadCursorA(NULL, IDC_ARROW);
    wc.hbrBackground    = g_hbrBackground;
    wc.lpszMenuName     = MAKEINTRESOURCEA(IDR_MENU1);
    wc.lpszClassName    = "DriverHack";
    if (!RegisterClassA(&wc))
		return false;

    g_hWndMain=CreateWindowExA(
		0,
        "DriverHack",
        "GDI+ Functionality Test",
        WS_OVERLAPPED|WS_CAPTION|WS_BORDER|WS_THICKFRAME|WS_MAXIMIZEBOX|
        WS_MINIMIZEBOX|WS_CLIPCHILDREN|WS_VISIBLE|WS_MAXIMIZE|WS_SYSMENU,
        CW_USEDEFAULT,
        CW_USEDEFAULT,
        CW_USEDEFAULT,
        CW_USEDEFAULT,
        NULL,
        NULL,
        hInst,
        NULL
    );
	HRESULT h=GetLastError();

    if (g_hWndMain==NULL)
        return false;

    ShowWindow(g_hWndMain,SW_SHOW);
    UpdateWindow(g_hWndMain);

    return true;
}

/***************************************************************************\
* main(argc, argv[])
*
* Sets up the message loop.
*
* History:
*  04-07-91 - Created  - KentD
*  04-28-00 - Modified - Jeff Vezina (t-jfvez)
*
\***************************************************************************/
__cdecl main(int argc,PCHAR argv[])
{
    MSG     msg;
    HMODULE hmodGdiPlus;

    CoInitialize(NULL);

    if (!WindowInit())
        return 0;
    if (!g_FuncTest.Init(g_hWndMain))
        return 0;

    hmodGdiPlus = LoadLibrary(TEXT("gdiplus.dll"));
    if(hmodGdiPlus) {
        glpfnDisplayPaletteWindowNotify = (LPFNGDIPLUS)
                 GetProcAddress(hmodGdiPlus, 
                                TEXT("GdipDisplayPaletteWindowNotify"));
    }
    if((glpfnDisplayPaletteWindowNotify == NULL) || (hmodGdiPlus == NULL)) {
        MessageBox(NULL,
                   "Unable to load gdiplus.dll",
                   "CfuncTest",
                   MB_OK);
        return FALSE;
    }
    
    // Init all primitives, graphics types, and graphics settings
    g_HWND.Init();
    g_HDC.Init();
    g_Printer.Init();

    // Put initializations into cextra.cpp, so that individual
    // developers can implement their own file for private usage.
    ExtraInitializations();

    while (GetMessageA(&msg,NULL,0,0)) {
        TranslateMessage(&msg);
        DispatchMessageA(&msg);
    }

    WindowUninit();

    FreeLibrary(hmodGdiPlus);

    CoUninitialize();

    return g_nResult;
}

#define UNICODE
#define _UNICODE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\driverhack\debug.h ===
/**************************************************************************\
*
* Copyright (c) 1998-2000  Microsoft Corporation
*
* Module Name:
*
*   Debugging macros
*
* Abstract:
*
*   Macros used for debugging purposes
*
* Revision History:
*
*   12/02/1998 davidx
*       Created it.
*   09/07/1999 agodfrey
*       Moved from Engine\Common
*   02/07/2000 agodfrey
*       Made more of it private (for bug #35561).
*       Changed the output function to add "\n" automatically.
*
\**************************************************************************/

#ifndef _DEBUG_H
#define _DEBUG_H

#ifdef __cplusplus
extern "C" {
#endif

// ONCE(code block)
//  Use this to make a code block execute only once per run.
//  Useful for cutting down on spew.
//  e.g.:
//      ONCE(WARNING(("Invalid arguments")));

#define ONCE(codeblock)      \
    {                        \
        static int doneOnce; \
        if (!doneOnce)       \
        {                    \
            { codeblock ; }  \
            doneOnce=1;      \
        }                    \
    }

#if DBG

// Global debug level

#define DBG_VERBOSE 1
#define DBG_TERSE   2
#define DBG_WARNING 3
#define DBG_RIP     4

extern int GpDebugLevel;

///////////////////////////// DEPRECATED STUFF ///////////////////////////////

// Raw output function. Emits debug messages. Its direct use is depracated.
// It's useful for private debugging, though.

unsigned long _cdecl DbgPrint(char*, ...);

// Strip the directory prefix from a filename

const char*
StripDirPrefix(
    const char* filename
    );

// Use of DBGMSG is depracated - it's supplied only because driverd3d.cpp uses
// it.

#define DBGMSG(level, prefix, msg)       \
        {                                \
            if (GpDebugLevel <= (level)) \
            {                            \
                DbgPrint("%s %s (%d): ", prefix, StripDirPrefix(__FILE__), __LINE__); \
                DbgPrint msg;            \
            }                            \
        }

///////////////////////////// PRIVATE STUFF //////////////////////////////////

// Just leave this function alone. You don't want to call it yourself. Trust me.
char * _cdecl GpParseDebugString(char* format, ...);

// Ditto for this one.
void _cdecl GpLogDebugEvent(int level, char *file, unsigned int line, char *message);

#define LOG_DEBUG_EVENT(level, msg)                                  \
    {                                                                \
        if (GpDebugLevel <= (level))                                 \
        {                                                            \
            char *debugOutput = GpParseDebugString msg;              \
            GpLogDebugEvent(level, __FILE__, __LINE__, debugOutput); \
        }                                                            \
    }

//////////////////////////////// THE GOOD STUFF //////////////////////////////

// These macros are used for debugging. They expand to
// whitespace on a free build.
//
// GpDebugLevel
//  Global variable which holds the current debug level. You can use it to
//  control the quantity of debug messages emitted.
//
// VERBOSE(msg)
//  Display a message if the current debug level is <= DBG_VERBOSE.
//
// TERSE(msg)
//  Display a message if the current debug level is <= DBG_TERSE.
//
// WARNING(msg)
//  Display a message if the current debug level is <= DBG_WARNING.
//  The message format is: WRN filename (linenumber): message
//
// ASSERT(cond)
//  Verify that a condition is true. If not, force a breakpoint.
//
// ASSERTMSG(cond, msg)
//  Verify that a condition is true. If not, display a message and
//  force a breakpoint.
//
// RIP(msg)
//  Display a message and force a breakpoint.
//
// Usage:
//
//  These macros require extra parentheses for the msg argument
//  for example:
//      WARNING(("App passed NULL pointer; ignoring it."));
//      ASSERTMSG(x > 0, ("x is less than 0"));
//
//  Each call to an output function is treated as a separate event -
//  if you want to build up a message, e.g. in a loop, build it up in a
//  string, and then call the output function.
//
//  This is because we don't always just output the string to the debugger -
//  when we link statically, we may send the output to a user-defined handler.
//
//  Don't put a trailing \n on the message. If the output is sent to the
//  debugger, the output function will add the \n itself.

#define VERBOSE(msg) LOG_DEBUG_EVENT(DBG_VERBOSE, msg)
#define TERSE(msg) LOG_DEBUG_EVENT(DBG_TERSE, msg)
#define WARNING(msg) LOG_DEBUG_EVENT(DBG_WARNING, msg)
#define RIP(msg) LOG_DEBUG_EVENT(DBG_RIP, msg)

#define ASSERT(cond)   \
    {                  \
        if (! (cond))  \
        {              \
            RIP(("Assertion failure: %s", #cond)); \
        }              \
    }

#define ASSERTMSG(cond, msg) \
    {                        \
        if (! (cond))        \
        {                    \
            RIP(msg);        \
        }                    \
    }

#else // !DBG

//--------------------------------------------------------------------------
// Retail build
//--------------------------------------------------------------------------

#define DBGMSG(level, prefix, msg) {}
#define VERBOSE(msg) {}
#define TERSE(msg) {}
#define WARNING(msg) {}

#define RIP(msg) {}
#define ASSERT(cond) {}
#define ASSERTMSG(cond, msg) {}

#endif // !DBG

#ifdef __cplusplus
}
#endif

#endif // !_DEBUG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\driverhack\debug.cpp ===
/**************************************************************************\
*
* Copyright (c) 1998-1999  Microsoft Corporation
*
* Abstract:
*
*   Debugging routines
*
* Revision History:
*
*   09/07/1999 agodfrey
*       Created it.
*
\**************************************************************************/
#include "global.h"

// Optional callback function for reporting a debug event.

enum GpAltDebugEventLevel
{
    GpAltDebugFatal,
    GpAltDebugWarning
};

#define GpAltDebugEventFunction 0
//DEBUGEVENTFUNCTION GpAltDebugEventFunction = NULL;

#if DBG

// GpDebugLevel is used to control the amount/severity of debugging messages
// that are actually output.

int GpDebugLevel = DBG_TERSE;

/**************************************************************************\
*
* Function Description:
*
*   Removes the path portion of a pathname
*
* Arguments:
*
*   [IN] str - pathname to strip
*
* Return Value:
*
*   A pointer to the filename portion of the pathname
*
* History:
*
*   09/07/1999 agodfrey
*       Moved from Entry\Initialize.cpp 
*
\**************************************************************************/

const char*
StripDirPrefix(
    const char* str
    )

{
    const char* p;

    p = strrchr(str, '\\');
    return p ? p+1 : str;
}

const int maxInputStringSize = 1024;

/**************************************************************************\
*
* Function Description:
*
*   Outputs to the debugger
*
* Arguments:
*
*   [IN] format - printf-like format string and variable arguments
*
* Return Value:
*
*   Zero. This is to conform to NTDLL's definition of DbgPrint.
*
* Notes:
*
*   There will be no output if a debugger is not connected.
*
* History:
*
*   09/07/1999 agodfrey
*       Moved from Entry\Initialize.cpp 
*
\**************************************************************************/

ULONG _cdecl
DbgPrint(
    char* format,
    ...
    )

{
    va_list arglist;
    va_start(arglist, format);
    
    char buf[maxInputStringSize];
    
    _vsnprintf(buf, maxInputStringSize, format, arglist);
    buf[maxInputStringSize-1]=0;
        
    OutputDebugStringA(buf);
    
    va_end(arglist);
    return 0;
}

// If we can't allocate memory for the debug string, we'll use this buffer
// in desperation. It's not thread-safe. I *did* say 'desperation'.

static char desperationBuffer[maxInputStringSize];

/**************************************************************************\
*
* Function Description:
*
*   Creates a new string, and sprintf's to it.
*
* Arguments:
*
*   [IN] format - printf-like format string and variable arguments
*
* Return Value:
*
*   The probably-newly-allocated string result.
*
* Notes:
*
*   This function is not intended for general use. It guards against memory
*   failure by using a global buffer. So, while the caller is responsible
*   for freeing the memory, the caller must also check for that buffer.
*   i.e. we only want DbgEmitMessage to call this.
*
*   It's also only mostly thread-safe, because if we run out of memory,
*   we'll use that global buffer in a non-protected way.
*
*   This is the only solution I could find so that I could move most of the
*   implementation details out of the header file. The root cause is that
*   macros don't handle multiple arguments natively, so we have to pass
*   the printf arguments as a single macro argument (in parentheses).
*   Which means, the function that consumes those arguments can have no
*   other arguments.
*
* History:
*
*   02/01/2000 agodfrey
*       Created it. Finally, I've found a way to get debug implementation
*       details out of the headers.
*
\**************************************************************************/

char * _cdecl
GpParseDebugString(
    char* format,
    ...
    )
{
    va_list arglist;
    va_start(arglist, format);
    
    // Don't use GpMalloc here so that we can use ASSERT and WARNING in 
    // our memory allocation routines.

    char *newBuf = static_cast<char *>(LocalAlloc(LMEM_FIXED, maxInputStringSize));
    if (!newBuf)
    {
        newBuf = desperationBuffer;
    }
    
    _vsnprintf(newBuf, maxInputStringSize, format, arglist);
    
    // Nuke the last byte, because MSDN isn't clear on what _vsnprintf does
    // in that case.
    
    newBuf[maxInputStringSize-1]=0;
        
    va_end(arglist);
    return newBuf;
}

/**************************************************************************\
*
* Function Description:
*
*   Processes a debug event. Frees the message string.
*
* Arguments:
*
* level   - The debug level of the event 
* file    - Should be __FILE__
* line    - Should be __LINE__
* message - The debug message.
*
* Notes:
*
*   You don't want to call this directly. That would be error-prone. 
*   Use ASSERT, WARNING, etc.
*
*   In Office, it will raise an 'assert' dialog if necessary.
*
*   Depending on the debug level, an identifying prefix will be output.
*
*   If the debug level is DBG_RIP, will suspend execution (e.g. by
*   hitting a breakpoint.)
*
* Note on Office interop:
*
*   Under Office, we'll pass WARNINGs and ASSERTs to a reporting function
*   they provide. Their function will breakpoint on ASSERTs.
*   Lesser events will just be sent to the debugger.
*
* History:
*
*   02/01/2000 agodfrey
*       Created it.
*
\**************************************************************************/

void _cdecl 
GpLogDebugEvent(
    int level, 
    char *file, 
    unsigned int line,
    char *message
    )
{
    // We may want to add things to the passed-in message. So we need
    // a temporary buffer
    
    const int maxOutputStringSize = maxInputStringSize + 100;
    char tempBuffer[maxOutputStringSize+1];
    
    // MSDN's _vsnprintf doc isn't clear on this, so just in case:
    tempBuffer[maxOutputStringSize] = 0;
    int altDebugLevel = -1;
    
    char *prefix = "";
    
    if (GpDebugLevel <= (level))
    {
        switch (level)
        {
        case DBG_WARNING:
            prefix = "WRN ";
            if (GpAltDebugEventFunction)
            {
                altDebugLevel = GpAltDebugWarning;
            }    
            break;
            
        case DBG_RIP:
            prefix = "RIP ";
            if (GpAltDebugEventFunction)
            {
                altDebugLevel = GpAltDebugFatal;
            }    
            break;
        }
        
        // The convention is that we append the trailing \n, not the caller.
        // Two reasons:
        // 1) Callers tend to forget it.
        // 2) More importantly, it encourages the caller to think of each
        //    call as a separate event. This is important in some cases - e.g.
        //    when Office produces a popup for each event.

        _snprintf(
            tempBuffer, 
            maxOutputStringSize, 
            "%s%s(%d): %s\n",
            prefix,
            StripDirPrefix(file),
            line,
            message
            );
        
        if (altDebugLevel >= 0)
        {
            //GpAltDebugEventFunction(altDebugLevel, tempBuffer);
        }
        else
        {
            OutputDebugStringA(tempBuffer);
        }
    }
    
    // Free the message buffer
    
    if (message != desperationBuffer)
    {
        LocalFree(message);
    }
    
    // Force a breakpoint, if it's warranted.
    
    if ((GpDebugLevel <= DBG_RIP) && (level == DBG_RIP) && (altDebugLevel < 0))
    {
        DebugBreak();
    }
}
    
#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\driverhack\global.h ===
/******************************Module*Header*******************************\
* Module Name: Global.h
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/

#ifndef __GLOBAL_H
#define __GLOBAL_H

#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <windows.h>
#include <objbase.h>
#include <math.h>
#include <winspool.h>
#include <commdlg.h>
#include <wingdi.h>
#include <ddraw.h>

#include "debug.h"

#define IStream int
#include <gdiplus.h>
using namespace Gdiplus;

#define TESTAREAWIDTH  800.0f
#define TESTAREAHEIGHT 800.0f

typedef void (*LPFNGDIPLUS)(WindowNotifyEnum);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\driverhack\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by functest.rc
//
#define IDR_MENU1                       101
#define IDD_FUNCTEST                    102
#define IDC_COMBINATION                 1000
#define IDC_REGRESSION                  1001
#define IDC_RUN                         1002
#define IDC_PRIMITIVES                  1003
#define IDC_OUTPUTS                     1004
#define IDC_SETTINGS                    1005
#define IDC_PAGEPAUSE                   1008
#define IDC_PAGEDELAY                   1009
#define IDC_DELAY                       1010
#define IDC_ERASEBKGD                   1011
#define IDC_APPENDTEST                  1012
#define IDC_DRIVERHACKS                 1013
#define IDC_CLOSE                       1014
#define IDC_NUMPATHS                    1015
#define IDM_ALL                         40000
#define IDM_POLYGONS                    40001
#define IDM_PATHS                       40002
#define IDM_REGIONS                     40003
#define IDM_GRADIENTS                   40004
#define IDM_BITMAPS                     40005
#define IDM_IMAGING                     40006
#define IDM_PRIMITIVES                  40007
#define IDM_MIXED                       40008
#define IDM_TEXT                        40009
#define IDM_CONTAINERS                  40010
#define IDM_CONTAINERCLIP               40011
#define IDM_HATCH                       40012
#define IDM_DASHES                      40013
#define IDM_SOURCECOPY                  40014
#define IDM_COMPOUNDLINES               40015
#define IDM_PRINTING                    40016
#define IDM_BACKPRINTING                40017
#define IDM_INSETLINES                  40018
#define IDM_HWND                        40100
#define IDM_DIB                         40101
#define IDM_PRINTER                     40102
#define IDM_D3D                         40103
#define IDM_DIB_FILE                    40104
#define IDM_1BPP                        40200
#define IDM_2BPP                        40201
#define IDM_4BPP                        40202
#define IDM_8BPP                        40203
#define IDM_16BPP                       40204
#define IDM_24BPP                       40205
#define IDM_32BPP                       40206
#define IDM_TEST1                       40300
#define IDM_TEST10                      40301
#define IDM_TEST100                     40302
#define IDM_TEST1000                    40303
#define IDM_TESTREGRESS                 40304
#define IDM_HALFTONE                    40305
#define IDM_ANTIALIAS                   40306
#define IDM_TESTHDC                     40307
#define IDM_NEWPRINT                    40308
#define IDM_CACHEBACK                   40309
#define IDM_HIGHCOMPOSITINGQUALITY      40310
#define IDM_QUIT                        40500
#define IDM_ROT0                        40600
#define IDM_ROT10                       40601
#define IDM_ROT30                       40602
#define IDM_ROT45                       40603
#define IDM_ROT60                       40604
#define IDM_ROT90                       40605
#define IDM_RUN                         41000
#define IDM_COMBINATION                 41001
#define IDM_REGRESSION                  41002
#define IDM_SAMPLES                     65535

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        103
#define _APS_NEXT_COMMAND_VALUE         41003
#define _APS_NEXT_CONTROL_VALUE         1012
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\emfdcode\debug.cpp ===
/**************************************************************************\
*
* Copyright (c) 1998-1999  Microsoft Corporation
*
* Abstract:
*
*   Debugging routines
*
* Revision History:
*
*   09/07/1999 agodfrey
*       Created it.
*
\**************************************************************************/
#include "global.h"

// Optional callback function for reporting a debug event.

enum GpAltDebugEventLevel
{
    GpAltDebugFatal,
    GpAltDebugWarning
};

#define GpAltDebugEventFunction 0
//DEBUGEVENTFUNCTION GpAltDebugEventFunction = NULL;

#if DBG

// GpDebugLevel is used to control the amount/severity of debugging messages
// that are actually output.

int GpDebugLevel = DBG_TERSE;

/**************************************************************************\
*
* Function Description:
*
*   Removes the path portion of a pathname
*
* Arguments:
*
*   [IN] str - pathname to strip
*
* Return Value:
*
*   A pointer to the filename portion of the pathname
*
* History:
*
*   09/07/1999 agodfrey
*       Moved from Entry\Initialize.cpp 
*
\**************************************************************************/

const char*
StripDirPrefix(
    const char* str
    )

{
    const char* p;

    p = strrchr(str, '\\');
    return p ? p+1 : str;
}

const int maxInputStringSize = 1024;

/**************************************************************************\
*
* Function Description:
*
*   Outputs to the debugger
*
* Arguments:
*
*   [IN] format - printf-like format string and variable arguments
*
* Return Value:
*
*   Zero. This is to conform to NTDLL's definition of DbgPrint.
*
* Notes:
*
*   There will be no output if a debugger is not connected.
*
* History:
*
*   09/07/1999 agodfrey
*       Moved from Entry\Initialize.cpp 
*
\**************************************************************************/

ULONG _cdecl
DbgPrint(
    char* format,
    ...
    )

{
    va_list arglist;
    va_start(arglist, format);
    
    char buf[maxInputStringSize];
    
    _vsnprintf(buf, maxInputStringSize, format, arglist);
    buf[maxInputStringSize-1]=0;
        
    OutputDebugStringA(buf);
    
    va_end(arglist);
    return 0;
}

// If we can't allocate memory for the debug string, we'll use this buffer
// in desperation. It's not thread-safe. I *did* say 'desperation'.

static char desperationBuffer[maxInputStringSize];

/**************************************************************************\
*
* Function Description:
*
*   Creates a new string, and sprintf's to it.
*
* Arguments:
*
*   [IN] format - printf-like format string and variable arguments
*
* Return Value:
*
*   The probably-newly-allocated string result.
*
* Notes:
*
*   This function is not intended for general use. It guards against memory
*   failure by using a global buffer. So, while the caller is responsible
*   for freeing the memory, the caller must also check for that buffer.
*   i.e. we only want DbgEmitMessage to call this.
*
*   It's also only mostly thread-safe, because if we run out of memory,
*   we'll use that global buffer in a non-protected way.
*
*   This is the only solution I could find so that I could move most of the
*   implementation details out of the header file. The root cause is that
*   macros don't handle multiple arguments natively, so we have to pass
*   the printf arguments as a single macro argument (in parentheses).
*   Which means, the function that consumes those arguments can have no
*   other arguments.
*
* History:
*
*   02/01/2000 agodfrey
*       Created it. Finally, I've found a way to get debug implementation
*       details out of the headers.
*
\**************************************************************************/

char * _cdecl
GpParseDebugString(
    char* format,
    ...
    )
{
    va_list arglist;
    va_start(arglist, format);
    
    // Don't use GpMalloc here so that we can use ASSERT and WARNING in 
    // our memory allocation routines.

    char *newBuf = static_cast<char *>(LocalAlloc(LMEM_FIXED, maxInputStringSize));
    if (!newBuf)
    {
        newBuf = desperationBuffer;
    }
    
    _vsnprintf(newBuf, maxInputStringSize, format, arglist);
    
    // Nuke the last byte, because MSDN isn't clear on what _vsnprintf does
    // in that case.
    
    newBuf[maxInputStringSize-1]=0;
        
    va_end(arglist);
    return newBuf;
}

/**************************************************************************\
*
* Function Description:
*
*   Processes a debug event. Frees the message string.
*
* Arguments:
*
* level   - The debug level of the event 
* file    - Should be __FILE__
* line    - Should be __LINE__
* message - The debug message.
*
* Notes:
*
*   You don't want to call this directly. That would be error-prone. 
*   Use ASSERT, WARNING, etc.
*
*   In Office, it will raise an 'assert' dialog if necessary.
*
*   Depending on the debug level, an identifying prefix will be output.
*
*   If the debug level is DBG_RIP, will suspend execution (e.g. by
*   hitting a breakpoint.)
*
* Note on Office interop:
*
*   Under Office, we'll pass WARNINGs and ASSERTs to a reporting function
*   they provide. Their function will breakpoint on ASSERTs.
*   Lesser events will just be sent to the debugger.
*
* History:
*
*   02/01/2000 agodfrey
*       Created it.
*
\**************************************************************************/

void _cdecl 
GpLogDebugEvent(
    int level, 
    char *file, 
    unsigned int line,
    char *message
    )
{
    // We may want to add things to the passed-in message. So we need
    // a temporary buffer
    
    const int maxOutputStringSize = maxInputStringSize + 100;
    char tempBuffer[maxOutputStringSize+1];
    
    // MSDN's _vsnprintf doc isn't clear on this, so just in case:
    tempBuffer[maxOutputStringSize] = 0;
    int altDebugLevel = -1;
    
    char *prefix = "";
    
    if (GpDebugLevel <= (level))
    {
        switch (level)
        {
        case DBG_WARNING:
            prefix = "WRN ";
            if (GpAltDebugEventFunction)
            {
                altDebugLevel = GpAltDebugWarning;
            }    
            break;
            
        case DBG_RIP:
            prefix = "RIP ";
            if (GpAltDebugEventFunction)
            {
                altDebugLevel = GpAltDebugFatal;
            }    
            break;
        }
        
        // The convention is that we append the trailing \n, not the caller.
        // Two reasons:
        // 1) Callers tend to forget it.
        // 2) More importantly, it encourages the caller to think of each
        //    call as a separate event. This is important in some cases - e.g.
        //    when Office produces a popup for each event.

        _snprintf(
            tempBuffer, 
            maxOutputStringSize, 
            "%s%s(%d): %s\n",
            prefix,
            StripDirPrefix(file),
            line,
            message
            );
        
        if (altDebugLevel >= 0)
        {
            //GpAltDebugEventFunction(altDebugLevel, tempBuffer);
        }
        else
        {
            OutputDebugStringA(tempBuffer);
        }
    }
    
    // Free the message buffer
    
    if (message != desperationBuffer)
    {
        LocalFree(message);
    }
    
    // Force a breakpoint, if it's warranted.
    
    if ((GpDebugLevel <= DBG_RIP) && (level == DBG_RIP) && (altDebugLevel < 0))
    {
        DebugBreak();
    }
}
    
#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\emfdcode\global.h ===
/******************************Module*Header*******************************\
* Module Name: Global.h
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/

#ifndef __GLOBAL_H
#define __GLOBAL_H

#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <windows.h>
#include <objbase.h>
#include <math.h>
#include <winspool.h>
#include <commdlg.h>
#include <wingdi.h>
#include <ddraw.h>

#include "debug.h"

#define IStream int
#include <gdiplus.h>
using namespace Gdiplus;

#define TESTAREAWIDTH  256.0f
#define TESTAREAHEIGHT 256.0f

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\emfdcode\debug.h ===
/**************************************************************************\
*
* Copyright (c) 1998-2000  Microsoft Corporation
*
* Module Name:
*
*   Debugging macros
*
* Abstract:
*
*   Macros used for debugging purposes
*
* Revision History:
*
*   12/02/1998 davidx
*       Created it.
*   09/07/1999 agodfrey
*       Moved from Engine\Common
*   02/07/2000 agodfrey
*       Made more of it private (for bug #35561).
*       Changed the output function to add "\n" automatically.
*
\**************************************************************************/

#ifndef _DEBUG_H
#define _DEBUG_H

#ifdef __cplusplus
extern "C" {
#endif

// ONCE(code block)
//  Use this to make a code block execute only once per run.
//  Useful for cutting down on spew.
//  e.g.:
//      ONCE(WARNING(("Invalid arguments")));

#define ONCE(codeblock)      \
    {                        \
        static int doneOnce; \
        if (!doneOnce)       \
        {                    \
            { codeblock ; }  \
            doneOnce=1;      \
        }                    \
    }

#if DBG

// Global debug level

#define DBG_VERBOSE 1
#define DBG_TERSE   2
#define DBG_WARNING 3
#define DBG_RIP     4

extern int GpDebugLevel;

///////////////////////////// DEPRECATED STUFF ///////////////////////////////

// Raw output function. Emits debug messages. Its direct use is depracated.
// It's useful for private debugging, though.

unsigned long _cdecl DbgPrint(char*, ...);

// Strip the directory prefix from a filename

const char*
StripDirPrefix(
    const char* filename
    );

// Use of DBGMSG is depracated - it's supplied only because driverd3d.cpp uses
// it.

#define DBGMSG(level, prefix, msg)       \
        {                                \
            if (GpDebugLevel <= (level)) \
            {                            \
                DbgPrint("%s %s (%d): ", prefix, StripDirPrefix(__FILE__), __LINE__); \
                DbgPrint msg;            \
            }                            \
        }

///////////////////////////// PRIVATE STUFF //////////////////////////////////

// Just leave this function alone. You don't want to call it yourself. Trust me.
char * _cdecl GpParseDebugString(char* format, ...);

// Ditto for this one.
void _cdecl GpLogDebugEvent(int level, char *file, unsigned int line, char *message);

#define LOG_DEBUG_EVENT(level, msg)                                  \
    {                                                                \
        if (GpDebugLevel <= (level))                                 \
        {                                                            \
            char *debugOutput = GpParseDebugString msg;              \
            GpLogDebugEvent(level, __FILE__, __LINE__, debugOutput); \
        }                                                            \
    }

//////////////////////////////// THE GOOD STUFF //////////////////////////////

// These macros are used for debugging. They expand to
// whitespace on a free build.
//
// GpDebugLevel
//  Global variable which holds the current debug level. You can use it to
//  control the quantity of debug messages emitted.
//
// VERBOSE(msg)
//  Display a message if the current debug level is <= DBG_VERBOSE.
//
// TERSE(msg)
//  Display a message if the current debug level is <= DBG_TERSE.
//
// WARNING(msg)
//  Display a message if the current debug level is <= DBG_WARNING.
//  The message format is: WRN filename (linenumber): message
//
// ASSERT(cond)
//  Verify that a condition is true. If not, force a breakpoint.
//
// ASSERTMSG(cond, msg)
//  Verify that a condition is true. If not, display a message and
//  force a breakpoint.
//
// RIP(msg)
//  Display a message and force a breakpoint.
//
// Usage:
//
//  These macros require extra parentheses for the msg argument
//  for example:
//      WARNING(("App passed NULL pointer; ignoring it."));
//      ASSERTMSG(x > 0, ("x is less than 0"));
//
//  Each call to an output function is treated as a separate event -
//  if you want to build up a message, e.g. in a loop, build it up in a
//  string, and then call the output function.
//
//  This is because we don't always just output the string to the debugger -
//  when we link statically, we may send the output to a user-defined handler.
//
//  Don't put a trailing \n on the message. If the output is sent to the
//  debugger, the output function will add the \n itself.

#define VERBOSE(msg) LOG_DEBUG_EVENT(DBG_VERBOSE, msg)
#define TERSE(msg) LOG_DEBUG_EVENT(DBG_TERSE, msg)
#define WARNING(msg) LOG_DEBUG_EVENT(DBG_WARNING, msg)
#define RIP(msg) LOG_DEBUG_EVENT(DBG_RIP, msg)

#define ASSERT(cond)   \
    {                  \
        if (! (cond))  \
        {              \
            RIP(("Assertion failure: %s", #cond)); \
        }              \
    }

#define ASSERTMSG(cond, msg) \
    {                        \
        if (! (cond))        \
        {                    \
            RIP(msg);        \
        }                    \
    }

#else // !DBG

//--------------------------------------------------------------------------
// Retail build
//--------------------------------------------------------------------------

#define DBGMSG(level, prefix, msg) {}
#define VERBOSE(msg) {}
#define TERSE(msg) {}
#define WARNING(msg) {}

#define RIP(msg) {}
#define ASSERT(cond) {}
#define ASSERTMSG(cond, msg) {}

#endif // !DBG

#ifdef __cplusplus
}
#endif

#endif // !_DEBUG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\emfdcode\cmndlg.c ===
/***********************************************************************

  MODULE     : CMNDLG.C

  FUNCTIONS  :

  COMMENTS   :

************************************************************************/

#include "windows.h"
#include "mfdcod32.h"

/**************************************************************************

  Function:  InitializeStruct(WORD, LPSTR)

   Purpose:  To initialize a structure for the current common dialog.
         This routine is called just before the common dialogs
         API is called.

   Returns:  void

   Comments:

   History:  Date      Author      Reason
         --------  ---------   -----------------------------------

          10/01/91  gregk       Created
          11/25/91  denniscr    mod for purposes of this app
          7/9/93    denniscr    modified for win32 and emf

**************************************************************************/

void InitializeStruct(wCommDlgType, lpStruct, lpszFilter)
WORD wCommDlgType;
LPSTR lpStruct;
LPSTR lpszFilter;
{
   LPFOCHUNK           lpFOChunk;
   LPFSCHUNK           lpFSChunk;

   switch (wCommDlgType)
   {
     case FILEOPENDLG:

       lpFOChunk = (LPFOCHUNK)lpStruct;

       *(lpFOChunk->szFile)            = 0;
       *(lpFOChunk->szFileTitle)       = 0;
       lpFOChunk->of.lStructSize       = OPENFILENAME_SIZE_VERSION_400;
       lpFOChunk->of.hwndOwner         = (HWND)hWndMain;
       lpFOChunk->of.hInstance         = (HANDLE)NULL;
       lpFOChunk->of.lpstrFilter       = gszFilter;
       lpFOChunk->of.lpstrCustomFilter = (LPSTR)NULL;
       lpFOChunk->of.nMaxCustFilter    = 0L;
       lpFOChunk->of.nFilterIndex      = 1L;
       lpFOChunk->of.lpstrFile         = lpFOChunk->szFile;
       lpFOChunk->of.nMaxFile          = (DWORD)sizeof(lpFOChunk->szFile);
       lpFOChunk->of.lpstrFileTitle    = lpFOChunk->szFileTitle;
       lpFOChunk->of.nMaxFileTitle     = 256;
       lpFOChunk->of.lpstrInitialDir     = (LPSTR)NULL;
       lpFOChunk->of.lpstrTitle        = (LPSTR)NULL;
       lpFOChunk->of.Flags             = OFN_HIDEREADONLY |
                                         OFN_PATHMUSTEXIST |
                                         OFN_FILEMUSTEXIST;
       lpFOChunk->of.nFileOffset       = 0;
       lpFOChunk->of.nFileExtension    = 0;
       lpFOChunk->of.lpstrDefExt       = (LPSTR)NULL;
       lpFOChunk->of.lCustData         = 0L;
       lpFOChunk->of.lpfnHook          = (LPOFNHOOKPROC)NULL;
       lpFOChunk->of.lpTemplateName    = (LPSTR)NULL;

       break;

     case FILESAVEDLG:

       lpFSChunk = (LPFSCHUNK)lpStruct;

       *(lpFSChunk->szFile)            = 0;
       *(lpFSChunk->szFileTitle)       = 0;
       lpFSChunk->of.lStructSize       = 0x4C; //OPENFILENAME_SIZE_VERSION_400
       lpFSChunk->of.hwndOwner         = (HWND)hWndMain;
       lpFSChunk->of.hInstance         = (HANDLE)NULL;
       lpFSChunk->of.lpstrFilter       = lpszFilter;
       lpFSChunk->of.lpstrCustomFilter = (LPSTR)NULL;
       lpFSChunk->of.nMaxCustFilter    = 0L;
       lpFSChunk->of.nFilterIndex      = 1L;
       lpFSChunk->of.lpstrFile         = lpFSChunk->szFile;
       lpFSChunk->of.nMaxFile          = (DWORD)sizeof(lpFSChunk->szFile);
       lpFSChunk->of.lpstrFileTitle  = lpFSChunk->szFileTitle;
       lpFSChunk->of.nMaxFileTitle     = 256;
       lpFSChunk->of.lpstrInitialDir     = (LPSTR)NULL;
       lpFSChunk->of.lpstrTitle        = (LPSTR)NULL;
       lpFSChunk->of.Flags             = OFN_HIDEREADONLY |
                                         OFN_OVERWRITEPROMPT;
       lpFSChunk->of.nFileOffset       = 0;
       lpFSChunk->of.nFileExtension    = 0;
       lpFSChunk->of.lpstrDefExt       = (LPSTR)"EMF";
       lpFSChunk->of.lCustData         = 0L;
       lpFSChunk->of.lpfnHook          = (LPOFNHOOKPROC)NULL;
       lpFSChunk->of.lpTemplateName    = (LPSTR)NULL;

       break;

     default:

       break;

   }

   return;
}

/***********************************************************************

  FUNCTION   : SplitPath

  PARAMETERS : LPSTR lpszFileName
           LPSTR lpszDrive
           LPSTR lpszDir
           LPSTR lpszFname
           LPSTR lpszExt

  PURPOSE    : split the fully qualified path into its components

  CALLS      : WINDOWS
         none

               APP
         none

  MESSAGES   : none

  RETURNS    : void

  COMMENTS   :

  HISTORY    : 1/16/91 - created - drc

************************************************************************/

void SplitPath( lpszFileName, lpszDrive, lpszDir, lpszFname, lpszExt)
LPSTR lpszFileName;
LPSTR lpszDrive;
LPSTR lpszDir;
LPSTR lpszFname;
LPSTR lpszExt;
{
  char  szPath[MAXFILTERLEN];
  LPSTR lpszPath;
  LPSTR lpszTemp;
  int   nFileNameLen = nExtOffset - (nFileOffset + 1);
  int   i;

  /* init ptrs */
  lpszPath = szPath;
  lpszTemp = lpszFileName;

  /* pick off the path */
  for (i = 0; i < nFileOffset; i++, lpszTemp++, lpszPath++)
    *lpszPath = *lpszTemp;
  *lpszPath = '\0';

  lpszPath = szPath;

  /* pick off the drive designator */
  for (i = 0; i < 2; i++, lpszPath++, lpszDrive++)
    *lpszDrive = *lpszPath;
  *lpszDrive = '\0';

  /* pick off the directory */
  while (*lpszPath != '\0')
    *lpszDir++ = *lpszPath++;
  *lpszDir = '\0';

  /* reset temp ptr */
  lpszTemp = lpszFileName;

  /* index to filename */
  lpszTemp += nFileOffset;

  /* pick off the filename */
  for (i = 0; i < nFileNameLen; i++, lpszTemp++, lpszFname++)
    *lpszFname = *lpszTemp;
  *lpszFname = '\0';

  /* reset temp ptr */
  lpszTemp = lpszFileName;

  /* index to file extension */
  lpszTemp += nExtOffset;

  /* pick off the ext */
  while (*lpszTemp != '\0')
    *lpszExt++ = *lpszTemp++;
  *lpszExt = '\0';

}

/***********************************************************************

  FUNCTION   : OpenFileDialog

  PARAMETERS : LPSTR lpszOpenName

  PURPOSE    : init the OPENFILE structure and call the file open
           common dialog

  CALLS      : WINDOWS
         GlobalAlloc
         GlobalLock
         GlobalFree
         wsprintf
         GetOpenFileName

               APP
         InitializeStruct

  MESSAGES   : none

  RETURNS    : int (see returns for GetOpenFileName)

  COMMENTS   :

  HISTORY    : 11/25/91 - created - drc

************************************************************************/

int OpenFileDialog(lpszOpenName)
LPSTR lpszOpenName;

{
   int       nRet;
   HANDLE    hChunk;
   LPFOCHUNK lpFOChunk;

   hChunk = GlobalAlloc(GMEM_FIXED, sizeof(FOCHUNK));

   if (hChunk)  {
      lpFOChunk = (LPFOCHUNK)GlobalLock(hChunk);
      if (!lpFOChunk)  {
     GlobalFree(hChunk);
     lpFOChunk=NULL;
     return(0);
      }
   }
   else {
      lpFOChunk=NULL;
      return(0);
   }


   InitializeStruct(FILEOPENDLG, (LPSTR)lpFOChunk, NULL);

   nRet = GetOpenFileName( &(lpFOChunk->of) );

   if (nRet)  {
      wsprintf(lpszOpenName, (LPSTR)"%s", lpFOChunk->of.lpstrFile);
      nExtOffset =  lpFOChunk->of.nFileExtension;
      nFileOffset = lpFOChunk->of.nFileOffset;
   }

   GlobalUnlock(hChunk);
   GlobalFree(hChunk);

   return(nRet);

}

/***********************************************************************

  FUNCTION   : SaveFileDialog

  PARAMETERS : LPSTR lpszOpenName

  PURPOSE    : init the OPENFILE structure and call the file open
           common dialog

  CALLS      : WINDOWS
         GlobalAlloc
         GlobalLock
         GlobalFree
         wsprintf
         GetOpenFileName

               APP
         InitializeStruct

  MESSAGES   : none

  RETURNS    : int (see returns for GetSaveFileName)

  COMMENTS   : this could easily be merged with OpenFileDialog.  This
           would decrease the redundancy but this is more illustrative.

  HISTORY    : 11/25/91 - created - drc

************************************************************************/

int SaveFileDialog(lpszSaveName, lpszFilter)
LPSTR lpszSaveName;
LPSTR lpszFilter;

{
   int       nRet;
   HANDLE    hChunk;
   LPFOCHUNK lpFOChunk;

   hChunk = GlobalAlloc(GMEM_FIXED, sizeof(FOCHUNK));

   if (hChunk)  {
      lpFOChunk = (LPFOCHUNK)GlobalLock(hChunk);
      if (!lpFOChunk)  {
     GlobalFree(hChunk);
     lpFOChunk=NULL;
     return(0);
      }
   }
   else {
      lpFOChunk=NULL;
      return(0);
   }


   InitializeStruct(FILESAVEDLG, (LPSTR)lpFOChunk, lpszFilter);

   nRet = GetSaveFileName( &(lpFOChunk->of) );

   if (nRet)
      wsprintf(lpszSaveName, (LPSTR)"%s", lpFOChunk->of.lpstrFile);

   GlobalUnlock(hChunk);
   GlobalFree(hChunk);

   return(nRet);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\emfdcode\dibstream.hpp ===
/**************************************************************************\
* 
* Copyright (c) 1999  Microsoft Corporation
*
* Module Name:
*
*   dibstream.hpp
*
* Abstract:
*
*   Wrap an IStream interface around DIB data.
*
* Revision History:
*
*   07/01/1999 davidx
*       Created it.
*
\**************************************************************************/

#ifndef _DIBSTREAM_HPP
#define _DIBSTREAM_HPP

// NOTE: This is not a thread-safe object.

class DibStream : public IStream
{
public:

    // Constructor

    DibStream(const BITMAPINFO* bmi, const BYTE* bits)
    {
        ComRefCount = 1;
        CurrentPos = 0;
        DibBits = bits;

        ZeroMemory(HeaderBuffer, sizeof(HeaderBuffer));

        // Figure out the size of header information

        HeaderSize = sizeof(BITMAPINFOHEADER);

        const BITMAPINFOHEADER* bmih = &bmi->bmiHeader;
        ULONG n = bmih->biClrUsed;

        if (n == 0)
        {
            switch (bmih->biBitCount)
            {
            case 1:
            case 4:
            case 8:
                n = 1 << bmih->biBitCount;
                break;

            case 16:
            case 32:
                if (bmih->biCompression == BI_BITFIELDS)
                    n = 3;
                break;
            }
        }

        HeaderSize += n * sizeof(RGBQUAD);

        memcpy(&HeaderBuffer[sizeof(BITMAPFILEHEADER)], bmi, HeaderSize);
        HeaderSize += sizeof(BITMAPFILEHEADER);

        // Figure out the size of bitmap data

        n = bmih->biSizeImage;

        if (n == 0 && bmih->biCompression == BI_RGB)
        {
            // Scanline is always DWORD-aligned

            n = ((bmih->biWidth * bmih->biBitCount) + 7) / 8;
            n = (n + 3) & ~3;

            n *= abs(bmih->biHeight);
        }

        TotalSize = HeaderSize + n;

        // Fix BMP file header information

        BITMAPFILEHEADER* fileHeader = (BITMAPFILEHEADER*) HeaderBuffer;
        
        fileHeader->bfType = 0x4D42;
        fileHeader->bfSize = TotalSize;
        fileHeader->bfOffBits = HeaderSize;
    }

    // Query interface

    STDMETHOD(QueryInterface)(REFIID riid, VOID** ppv)
    {
        if (riid == IID_IUnknown)
            *ppv = static_cast<IUnknown*>(this);
        else if (riid == IID_IStream)
            *ppv = static_cast<IStream*>(this);
        else
        {
            *ppv = NULL;
            return E_NOINTERFACE;
        }

        reinterpret_cast<IUnknown*>(*ppv)->AddRef();
        return S_OK;
    }

    // Increment reference count

    STDMETHOD_(ULONG, AddRef)(VOID)
    {
        return InterlockedIncrement(&ComRefCount);
    }

    // Decrement reference count

    STDMETHOD_(ULONG, Release)(VOID)
    {
        ULONG count = InterlockedDecrement(&ComRefCount);

        if (count == 0)
            delete this;

        return count;
    }

    // Read data

    STDMETHOD(Read)(
        VOID* buf,
        ULONG cb,
        ULONG* cbRead
        )
    {
        ULONG n = TotalSize - CurrentPos;

        if (cb > n)
            cb = n;

        if (CurrentPos >= HeaderSize)
        {
            // Read bitmap data

            memcpy(buf, DibBits + (CurrentPos - HeaderSize), cb);
        }
        else
        {
            // Read header data

            n = HeaderSize - CurrentPos;

            if (cb <= n)
            {
                memcpy(buf, &HeaderBuffer[CurrentPos], cb);
            }
            else
            {
                memcpy(buf, &HeaderBuffer[CurrentPos], n);
                memcpy((BYTE*) buf + n, DibBits, cb - n);
            }
        }

        CurrentPos += cb;
        *cbRead = cb;

        return S_OK;
    }

    // Change read pointer

    STDMETHOD(Seek)(
        LARGE_INTEGER offset,
        DWORD origin,
        ULARGE_INTEGER* newPos
        )
    {
        LONGLONG pos;

        switch (origin)
        {
        case STREAM_SEEK_SET:

            pos = offset.QuadPart;
            break;

        case STREAM_SEEK_END:

            pos = TotalSize;
            break;

        case STREAM_SEEK_CUR:

            pos = (LONGLONG) CurrentPos + offset.QuadPart;
            break;

        default:

            pos = -1;
            break;
        }

        if (pos < 0 || pos > TotalSize)
            return E_INVALIDARG;

        CurrentPos = (ULONG) pos;

        if (newPos)
            newPos->QuadPart = pos;

        return S_OK;
    }

    // Get information

    STDMETHOD(Stat)(
        STATSTG* statstg,
        DWORD statFlag
        )
    {
        ZeroMemory(statstg, sizeof(STATSTG));

        statstg->type = STGTY_STREAM;
        statstg->cbSize.QuadPart = TotalSize;
        statstg->grfMode = STGM_READ;

        return S_OK;
    }

    STDMETHOD(Write)(
        const VOID* buf,
        ULONG cb,
        ULONG* cbWritten
        )
    {
        return STG_E_ACCESSDENIED;
    }

    STDMETHOD(CopyTo)(
        IStream* stream,
        ULARGE_INTEGER cb,
        ULARGE_INTEGER* cbRead,
        ULARGE_INTEGER* cbWritten
        )
    {
        return E_NOTIMPL;
    }

    STDMETHOD(SetSize)(
        ULARGE_INTEGER newSize
        )
    {
        return E_NOTIMPL;
    }

    STDMETHOD(Commit)(
        DWORD commitFlags
        )
    {
        return S_OK;
    }

    STDMETHOD(Revert)()
    {
        return E_NOTIMPL;
    }

    STDMETHOD(LockRegion)(
        ULARGE_INTEGER offset,
        ULARGE_INTEGER cb,
        DWORD lockType
        )
    {
        return E_NOTIMPL;
    }

    STDMETHOD(UnlockRegion)(
        ULARGE_INTEGER offset,
        ULARGE_INTEGER cb,
        DWORD lockType
        )
    {
        return E_NOTIMPL;
    }

    STDMETHOD(Clone)(
        IStream** stream
        )
    {
        return E_NOTIMPL;
    }

private:

    LONG ComRefCount;
    ULONG HeaderSize;
    ULONG TotalSize;
    ULONG CurrentPos;
    const BYTE* DibBits;

    // Large enough buffer for storing bitmap file header information

    BYTE HeaderBuffer[sizeof(BITMAPFILEHEADER) +
                      sizeof(BITMAPINFOHEADER) +
                      sizeof(RGBQUAD) * 256];
};

#endif // !_DIBSTREAM_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\emfdcode\dlgproc.c ===
/***********************************************************************

  MODULE     : DLGPROC.C

  FUNCTIONS  : WMFRecDlgProc
               EnumRangeDlgProc
               PlayFromListDlgProc
               HeaderDlgProc
               PlaceableHeaderDlgProc
               ClpHeaderDlgProc
               ListDlgProc
               About

  COMMENTS   :

  HISTORY    : 1/16/91 - created - drc

************************************************************************/

#include "windows.h"
#include "mfdcod32.h"

#define GDIP_WMF_RECORD_BASE            0x00010000
#define GDIP_WMF_RECORD_TO_EMFPLUS(n)   ((INT)((n) | GDIP_WMF_RECORD_BASE))

/***********************************************************************

  FUNCTION   : WMFRecDlgProc

  PARAMETERS : HWND hDlg
               unsigned message
               WORD wParam
               LONG lParam

  PURPOSE    : dialog procedure to handle the user input from the
               dialog box that displays the contents of the metafile
               record.

  CALLS      : WINDOWS
                 lstrcpy
                 GlobalLock
                 GlobalUnlock
                 wsprintf
                 SendDlgItemMessage
                 EndDialog
               APP
                 WaitCursor

  MESSAGES   : WM_INITDIALOG
               WM_COMMAND

  RETURNS    : BOOL

  COMMENTS   :

  HISTORY    : 1/16/91 - created - drc
               6/30/93 - modified to work with EMF under Win32 - denniscr

************************************************************************/

INT_PTR CALLBACK WMFRecDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
  int i;
  char szMetaFunction[50];
  HFONT hFont;
  static int iButton = IDB_HEX ;
  static RECT rcWnd = { 0, 0, 0, 0 };

  switch (message)
  {
  case WM_INITDIALOG:
      //
      //font for the parameters listbox
      //
      hFont = GetStockObject(ANSI_FIXED_FONT);

      if( rcWnd.bottom != rcWnd.top && rcWnd.right != rcWnd.left)
        SetWindowPos(hDlg, HWND_NOTOPMOST, rcWnd.left, rcWnd.top, rcWnd.right - rcWnd.left, rcWnd.bottom - rcWnd.top, 0 ) ;
      //
      //select that font into the parameter listbox
      //
      SendDlgItemMessage(hDlg, IDL_PARAMETERS, WM_SETFONT, (WPARAM) hFont, (LPARAM)FALSE);
      //
      //initialize the controls of the dialog box to reflect the
      //contents of the current metafile record
      //
      //but first, lookup the metafile function
      //
      if (bEnhMeta)
      {
        for (i = NUMMETAFUNCTIONS; i < NUMENHMETARECORDS; i++)
        {
          if (emfMetaRec.iType == emfMetaRecords[i].iType)
            break;
        }
        //
        //if not found then it is an unknown record
        //
        if (emfMetaRec.iType != emfMetaRecords[i].iType)
            lstrcpy((LPSTR)szMetaFunction, (LPSTR)"Unknown");
        else
            lstrcpy((LPSTR)szMetaFunction,(LPSTR)emfMetaRecords[i].szRecordName);
        //
        //init the size control
        //
        SetDlgItemInt(hDlg, IDE_RECSIZE, (UINT)emfMetaRec.nSize, FALSE);
        //
        //load the parameter listbox with the parameters displayed in hex bytes
        //
        LoadParameterLB(hDlg, (emfMetaRec.nSize - sizeof(emfMetaRec.nSize) -
                        sizeof(emfMetaRec.iType))/sizeof(DWORD), iButton);
      }
      else
      {
        for (i = 0; i < NUMMETAFUNCTIONS; i++)
        {
          if (GDIP_WMF_RECORD_TO_EMFPLUS(MetaRec.rdFunction) == (INT)emfMetaRecords[i].iType)
            break;
        }
        //
        //if not found then it is an unknown record
        //
        if (GDIP_WMF_RECORD_TO_EMFPLUS(MetaRec.rdFunction) != (INT)emfMetaRecords[i].iType)
            lstrcpy((LPSTR)szMetaFunction, (LPSTR)"Unknown");
        else
            lstrcpy((LPSTR)szMetaFunction,(LPSTR)emfMetaRecords[i].szRecordName);
        //
        //init the size control
        //
        SetDlgItemInt(hDlg, IDE_RECSIZE, (DWORD)MetaRec.rdSize, FALSE);
        //
        //load the parameter listbox with the parameters displayed in hex bytes
        //
        LoadParameterLB(hDlg, MetaRec.rdSize - 3, iButton);
      }

      //
      //init the record number
      ///
      SetDlgItemInt(hDlg, IDE_RECNUM, iRecNum, FALSE);
      //
      //init the function name control
      //
      SetDlgItemText(hDlg, IDE_FUNCTION, (LPSTR)szMetaFunction);
      //
      //check the Hex radio button
      //
      SendDlgItemMessage(hDlg, iButton, BM_SETCHECK, TRUE, 0L);
      //
      //load the parameter listbox with the parameters displayed in hex bytes
      //
      return(TRUE);
      break;

   case WM_COMMAND:
      switch(LOWORD(wParam))
        {

        /* this will handle the checking and  unchecking of the three buttons */
        case IDB_HEX:
        case IDB_DEC:
        case IDB_CHAR:
        case IDB_WORD:
            CheckRadioButton(hDlg, IDB_HEX,  IDB_CHAR, LOWORD(wParam));
            if (bEnhMeta)
              LoadParameterLB(hDlg, (emfMetaRec.nSize - sizeof(emfMetaRec.nSize) -
                              sizeof(emfMetaRec.iType))/sizeof(DWORD), LOWORD(wParam));
            else
              LoadParameterLB(hDlg, MetaRec.rdSize - 3,  LOWORD(wParam));
            iButton = LOWORD(wParam);
            break;

        case IDGO:
            /* display the hourglass cursor while metafile is playing */
            WaitCursor(TRUE);

            bPlayItAll = TRUE;
            bEnumRange = FALSE;
            /* fall through with appropriate flags set */

        case IDOK:
            GetWindowRect( hDlg, &rcWnd ) ;
            bPlayRec = TRUE;
            /* fall through with appropriate flags set */

        case IDCANCEL:
            EndDialog(hDlg, TRUE);
            return(TRUE);
            break;

        case IDQUITENUM:
            /* quit the enumeration.  Setup Dialogbox to return
               FALSE as this return value is checked in a test
               to end the enumeration */
            EndDialog(hDlg, FALSE);
            return(TRUE);
            break;

        default:
           return (FALSE);
        }
     break;

  default:
     return(FALSE);
     break;
   }
return (TRUE);
}

/***********************************************************************

  FUNCTION   : EnumRangeDlgProc

  PARAMETERS : HWND hDlg
               unsigned message
               WORD wParam
               LONG lParam

  PURPOSE    : This dialog box lets the user specify whether all records
               or a range are to be played.

  CALLS      : WINDOWS
                 SendDlgItemMessage
                 GetDlgItemInt
                 HIWORD
                 MessageBox
                 SetFocus
                 InvalidateClientRect
                 EndDialog

  MESSAGES   : WM_INITDIALOG
               WM_COMMAND

  RETURNS    : BOOL

  COMMENTS   :

  HISTORY    : 1/16/91 - created - Dennis Crain

************************************************************************/

INT_PTR CALLBACK EnumRangeDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    BOOL lpTranslated;
    RECT rect;

    switch (message) {
        case WM_INITDIALOG:
            /* play all of the mf records is the default */
            SendDlgItemMessage(hDlg, IDCB_ALL, BM_SETCHECK, 1, 0L);
            return (TRUE);

        case WM_COMMAND:
            switch (LOWORD(wParam))
                {
                case IDE_FROM:

                    /* if the user elects to play a range of record then
                       turn the play all check off */

            if (HIWORD(wParam) == EN_CHANGE)
                        SendDlgItemMessage(hDlg, IDCB_ALL, BM_SETCHECK, 0, 0L);
                    break;

                case IDE_TO:
            if (HIWORD(wParam) == EN_CHANGE)
                        SendDlgItemMessage(hDlg, IDCB_ALL, BM_SETCHECK, 0, 0L);
                    break;

                case IDOK:

                   /* if a range of records is to be played */

                   if ( !IsDlgButtonChecked(hDlg, IDCB_ALL) ) {

                     /* set the enumerate range flag */
                     bEnumRange = TRUE;

                     /* initialize the play record flag */
                     bPlayRec = FALSE;

                     /* get the range */
                     iStartRange = GetDlgItemInt(hDlg, IDE_FROM, (BOOL FAR *)&lpTranslated, FALSE);

                     /* trap the error where the start value has not been entered */
                     if (!iStartRange) {
                         MessageBox(hWndMain, "Invalid FROM value",
                                    NULL, MB_OK | MB_ICONEXCLAMATION);
                         SetFocus(GetDlgItem(hDlg, IDE_FROM));
                     break;

                     }

                     iEndRange = GetDlgItemInt(hDlg, IDE_TO, (BOOL FAR *)&lpTranslated, FALSE);
                     if (!iEndRange) {
                         MessageBox(hWndMain, "Invalid TO value",
                                    NULL, MB_OK | MB_ICONEXCLAMATION);
                         SetFocus(GetDlgItem(hDlg, IDE_TO));

                        break;
                     }

                   }
                   /* all records are to be played */
                   else {
                     /* set the enumerate range to false */
                     bEnumRange = FALSE;

                     /* initialize the play it all flag - yes this should
                        be false! */
                     bPlayItAll = FALSE;

                     /* init the play record flag */
                     bPlayRec = TRUE;
                   }
                   /* force paint of the client area */
                   GetClientRect(hWndMain, (LPRECT)&rect);
                   InvalidateRect(hWndMain, (LPRECT)&rect, TRUE);

                   EndDialog(hDlg, TRUE);
                   return (TRUE);
                   break;

                case IDCANCEL:
                   /* user didn't really want to play the metafile */
                   bEnumRange = FALSE;
                   bPlayItAll = TRUE;
                   bPlayRec   = FALSE;
                   EndDialog(hDlg, IDCANCEL);
                   return (TRUE);
                   break;

                default:
                   return (FALSE);
                }
        break;
    }
    return (FALSE);                           /* Didn't process a message    */
}

/***********************************************************************

  FUNCTION   : PlayFromListDlgProc

  PARAMETERS : HWND hDlg
               unsigned message
               WORD wParam
               LONG lParam

  PURPOSE    : a means to indicate whether the selected or unselected
               records among the list of metafile records are to be
               played.

  CALLS      : WINDOWS
                 SendDlgItemMessage
                 IsDlgButtonChecked
                 HIWORD

  MESSAGES   : WM_INITDIALOG
               WM_COMMAND

  RETURNS    : BOOL

  COMMENTS   :

  HISTORY    : 1/16/91 - created - Dennis Crain

************************************************************************/

INT_PTR CALLBACK PlayFromListDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    switch (message) {
        case WM_INITDIALOG:
            /* the default is to play the selected records */
            SendDlgItemMessage(hDlg, IDCB_SEL, BM_SETCHECK, 1, 0L);
            return (TRUE);

        case WM_COMMAND:
            switch (LOWORD(wParam))
            {
              case IDOK:
                /* was the play selected or play unselected button checked? */
                if ( IsDlgButtonChecked(hDlg, IDCB_SEL) )
                    bPlaySelList = TRUE;
                else
                    bPlaySelList = FALSE;

                EndDialog(hDlg, TRUE);
                return (TRUE);

              case IDCB_SEL:
                /* show the button click */
        if (HIWORD(wParam) == BN_CLICKED)
                   SendDlgItemMessage(hDlg, IDCB_UNSEL, BM_SETCHECK, 0, 0L);
                break;

              case IDCB_UNSEL:
                /* show the button click */
        if (HIWORD(wParam) == BN_CLICKED)
                   SendDlgItemMessage(hDlg, IDCB_SEL, BM_SETCHECK, 0, 0L);
                break;

              default:
                return (FALSE);

            }
            break;
    }
    return (FALSE);
}

/***********************************************************************

  FUNCTION   : EnhMetaHeaderDlgProc

  PARAMETERS : HWND hDlg
               unsigned message
               WORD wParam
               LONG lParam

  PURPOSE    : show the "standard" metafile header as described in the
               Windows SDK section 9.5.1 of the SDK Reference volume 2

  CALLS      : WINDOWS
                 wsprintf
                 SetDlgItemText
                 EndDialog

  MESSAGES   : WM_INITDIALOG
               WM_COMMAND

  RETURNS    : BOOL

  COMMENTS   : Enhanced Metafile header format
    DWORD   iType;              // Record type EMR_HEADER
    DWORD   nSize;              // Record size in bytes.  This may be greater
                                // than the sizeof(ENHMETAHEADER).
    RECTL   rclBounds;          // Inclusive-inclusive bounds in device units
    RECTL   rclFrame;           // Inclusive-inclusive Picture Frame of metafile in .01 mm units
    DWORD   dSignature;         // Signature.  Must be ENHMETA_SIGNATURE.
    DWORD   nVersion;           // Version number
    DWORD   nBytes;             // Size of the metafile in bytes
    DWORD   nRecords;           // Number of records in the metafile
    WORD    nHandles;           // Number of handles in the handle table
                                // Handle index zero is reserved.
    WORD    sReserved;          // Reserved.  Must be zero.
    DWORD   nDescription;       // Number of chars in the unicode description string
                                // This is 0 if there is no description string
    DWORD   offDescription;     // Offset to the metafile description record.
                                // This is 0 if there is no description string
    DWORD   nPalEntries;        // Number of entries in the metafile palette.
    SIZEL   szlDevice;          // Size of the reference device in pels
    SIZEL   szlMillimeters;     // Size of the reference device in millimeters

  HISTORY    : 6/29/93 - created - Dennis Crain

************************************************************************/

INT_PTR CALLBACK EnhMetaHeaderDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    char szBuf[30];

    switch (message) {
        case WM_INITDIALOG:
            //
            //format the record type
            //
            wsprintf((LPSTR)szBuf, "%x", EmfPtr.lpEMFHdr->iType);
            SetDlgItemText(hDlg, IDC_ITYPE, (LPSTR)szBuf);
            //
            //format the size of the header
            //
            wsprintf((LPSTR)szBuf, "%d", EmfPtr.lpEMFHdr->nSize);
            SetDlgItemText(hDlg, IDC_NSIZE, (LPSTR)szBuf);
            //
            //format the signature
            //
            wsprintf((LPSTR)szBuf, "%x", EmfPtr.lpEMFHdr->dSignature);
            SetDlgItemText(hDlg, IDC_DSIGNATURE, (LPSTR)szBuf);
            //
            //format the version
            //
            wsprintf((LPSTR)szBuf, "%d", EmfPtr.lpEMFHdr->nVersion);
            SetDlgItemText(hDlg, IDC_NVERSION, (LPSTR)szBuf);
            //
            //format the size of metafile in bytes
            //
            wsprintf((LPSTR)szBuf, "%d", EmfPtr.lpEMFHdr->nBytes);
            SetDlgItemText(hDlg, IDC_NBYTES, (LPSTR)szBuf);
            //
            //format the number of records
            //
            wsprintf((LPSTR)szBuf, "%d", EmfPtr.lpEMFHdr->nRecords);
            SetDlgItemText(hDlg, IDC_NRECORDS, (LPSTR)szBuf);
            //
            //format the number of handles
            //
            wsprintf((LPSTR)szBuf, "%d", EmfPtr.lpEMFHdr->nHandles);
            SetDlgItemText(hDlg, IDC_NHANDLES, (LPSTR)szBuf);
            //
            //format the number of chars in the description string
            //
            wsprintf((LPSTR)szBuf, "%d", EmfPtr.lpEMFHdr->nDescription);
            SetDlgItemText(hDlg, IDC_NDESCRIPTION, (LPSTR)szBuf);
            //
            //format the offset to the description
            //
            wsprintf((LPSTR)szBuf, "%d", EmfPtr.lpEMFHdr->offDescription);
            SetDlgItemText(hDlg, IDC_OFFDESCRIPTION, (LPSTR)szBuf);
            //
            //if a description string exists then write it to static control
            //
            if (EmfPtr.lpDescStr)
                SetDlgItemText(hDlg, IDC_DESCSTRING, EmfPtr.lpDescStr);
            //
            //format the number of palette entries
            //
            wsprintf((LPSTR)szBuf, "%d", EmfPtr.lpEMFHdr->nPalEntries);
            SetDlgItemText(hDlg, IDC_NPALENTRIES, (LPSTR)szBuf);
            //
            //format szlDevice values
            //
            wsprintf((LPSTR)szBuf, "%d", EmfPtr.lpEMFHdr->szlDevice.cx);
            SetDlgItemText(hDlg, IDC_DEVCX, (LPSTR)szBuf);
            wsprintf((LPSTR)szBuf, "%d", EmfPtr.lpEMFHdr->szlDevice.cy);
            SetDlgItemText(hDlg, IDC_DEVCY, (LPSTR)szBuf);
            //
            //format szlMillimeters values
            //
            wsprintf((LPSTR)szBuf, "%d", EmfPtr.lpEMFHdr->szlMillimeters.cx);
            SetDlgItemText(hDlg, IDC_MILLCX, (LPSTR)szBuf);
            wsprintf((LPSTR)szBuf, "%d", EmfPtr.lpEMFHdr->szlMillimeters.cy);
            SetDlgItemText(hDlg, IDC_MILLCY, (LPSTR)szBuf);
            //
            //format rclBounds values
            //
            wsprintf((LPSTR)szBuf, "%d", EmfPtr.lpEMFHdr->rclBounds.left);
            SetDlgItemText(hDlg, IDC_BOUNDSL, (LPSTR)szBuf);
            wsprintf((LPSTR)szBuf, "%d", EmfPtr.lpEMFHdr->rclBounds.top);
            SetDlgItemText(hDlg, IDC_BOUNDST, (LPSTR)szBuf);
            wsprintf((LPSTR)szBuf, "%d", EmfPtr.lpEMFHdr->rclBounds.right);
            SetDlgItemText(hDlg, IDC_BOUNDSR, (LPSTR)szBuf);
            wsprintf((LPSTR)szBuf, "%d", EmfPtr.lpEMFHdr->rclBounds.bottom);
            SetDlgItemText(hDlg, IDC_BOUNDSB, (LPSTR)szBuf);
            //
            //format rclFrame values
            //
            wsprintf((LPSTR)szBuf, "%d", EmfPtr.lpEMFHdr->rclFrame.left);
            SetDlgItemText(hDlg, IDC_FRAMEL, (LPSTR)szBuf);
            wsprintf((LPSTR)szBuf, "%d", EmfPtr.lpEMFHdr->rclFrame.top);
            SetDlgItemText(hDlg, IDC_FRAMET, (LPSTR)szBuf);
            wsprintf((LPSTR)szBuf, "%d", EmfPtr.lpEMFHdr->rclFrame.right);
            SetDlgItemText(hDlg, IDC_FRAMER, (LPSTR)szBuf);
            wsprintf((LPSTR)szBuf, "%d", EmfPtr.lpEMFHdr->rclFrame.bottom);
            SetDlgItemText(hDlg, IDC_FRAMEB, (LPSTR)szBuf);

            return (TRUE);

        case WM_COMMAND:
            if (LOWORD(wParam) == IDOK) {
                EndDialog(hDlg, TRUE);
                return (TRUE);
            }
            break;
    }
    return (FALSE);
}

/***********************************************************************

  FUNCTION   : HeaderDlgProc

  PARAMETERS : HWND hDlg
               unsigned message
               WORD wParam
               LONG lParam

  PURPOSE    : show the "standard" metafile header as described in the
               Windows SDK section 9.5.1 of the SDK Reference volume 2

  CALLS      : WINDOWS
                 wsprintf
                 SetDlgItemText
                 EndDialog

  MESSAGES   : WM_INITDIALOG
               WM_COMMAND

  RETURNS    : BOOL

  COMMENTS   : Metafile header format

               WORD    mtType;
               WORD    mtHeaderSize;
               WORD    mtVersion;
               DWORD   mtSize;
               WORD    mtNoObjects;
               DWORD   mtMaxRecord;

               These fields have the following  meanings:

               Field          Definition

               mtType         specifies whether the metafile is in
                              memory or recorded in a disk file.
                              1 == memory 2 == disk

               mtHeaderSize   Specifies the size in words of the metafile
                              header

               mtVersion      Specifies the Windows version number.

               mtSize         Specifies the size in words of the file

               mtNoObjects    Specifies the maximum number of objects that
                              exist in the metafile at the same time

               mtMaxRecord    Specifies the size in words of the largest
                              record in the metafile.

               mtNoParameters Is not used

  HISTORY    : 1/16/91 - created - Dennis Crain

************************************************************************/

INT_PTR CALLBACK HeaderDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    char szBuf[30];

    switch (message) {
        case WM_INITDIALOG:
            /* format the Windows version number */
            wsprintf((LPSTR)szBuf, "%x", mfHeader.mtVersion);
            SetDlgItemText(hDlg, IDS_VER, (LPSTR)szBuf);

            /* format the size of the metafile */
            wsprintf((LPSTR)szBuf, "%lu", mfHeader.mtSize * 2L);
            SetDlgItemText(hDlg, IDS_SIZE, (LPSTR)szBuf);

            /* format the maximum numbers of objects that exist
               in the metafile at the same time */
            wsprintf((LPSTR)szBuf, "%d", mfHeader.mtNoObjects);
            SetDlgItemText(hDlg, IDS_OBJECTS, (LPSTR)szBuf);

            /* format the size of the largest record in the metafile */
            wsprintf((LPSTR)szBuf, "%lu", mfHeader.mtMaxRecord);
            SetDlgItemText(hDlg, IDS_MAXREC, (LPSTR)szBuf);
            return (TRUE);

        case WM_COMMAND:
            if (LOWORD(wParam) == IDOK) {
                EndDialog(hDlg, TRUE);
                return (TRUE);
            }
            break;
    }
    return (FALSE);
}

/***********************************************************************

  FUNCTION   : PlaceableHeaderDlgProc

  PARAMETERS : HWND hDlg
               unsigned message
               WORD wParam
               LONG lParam

  PURPOSE    : show the "extended" header of Placeable Metafiles.

  CALLS      : WINDOWS
                 wsprintf
                 SetDlgItemText
                 EndDialog

  MESSAGES   : WM_INITDIALOG
               WM_COMMAND

  RETURNS    : BOOL

  COMMENTS   : Placeable metafile format

               DWORD    key;
               HANDLE   hmf;
               RECT     bbox;
               WORD     inch;
               DWORD    reserved;
               WORD     checksum;
               char     metafileData[];

               These fields have the following  meanings:

               Field         Definition

               key           Binary key that uniquely identifies this
                             file type.  This must be 0x9AC6CDD7L.

               hmf           Unused;  must be zero.

               bbox          The coordinates of a rectangle that tightly
                             bounds the picture. These coordinates are in
                             metafile units as defined below.

               inch          The number of metafile units to the inch.  To
                             avoid numeric overflow in PageMaker, this value
                             should be less than 1440.

               reserved      A reserved double word.  Must be zero.

               checksum      A checksum of the 10 words that precede it,
                             calculated by XORing zero with these 10 words
                             and putting the result in the checksum field.

               metafileData  The actual content of the Windows metafile
                             retrieved by copying the data returned by
                             GetMetafileBits to the file.  The number of
                             bytes should be equal to the MS-DOS file length
                             minus 22.  The content of a PageMaker placeable
                             metafile  cannot currently exceed 64K (this may
                             have changed in 4.0).

  HISTORY    : 1/16/91 - created - Dennis Crain

************************************************************************/

INT_PTR CALLBACK PlaceableHeaderDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    char szBuf[30];

    switch (message) {
        case WM_INITDIALOG:
            /* format the key */
            wsprintf((LPSTR)szBuf, "%lx", placeableWMFHeader.key);
            SetDlgItemText(hDlg, IDS_KEY, (LPSTR)szBuf);

            /* format the x origin of the bounding rectangle */
            wsprintf((LPSTR)szBuf, "%d", placeableWMFHeader.bbox.left);
            SetDlgItemText(hDlg, IDS_LEFT, (LPSTR)szBuf);

            /* format the x extent of the bounding rectangle */
            wsprintf((LPSTR)szBuf, "%d", placeableWMFHeader.bbox.right);
            SetDlgItemText(hDlg, IDS_RIGHT, (LPSTR)szBuf);

            /* format the y origin of the bounding rectangle */
            wsprintf((LPSTR)szBuf, "%d", placeableWMFHeader.bbox.top);
            SetDlgItemText(hDlg, IDS_TOP, (LPSTR)szBuf);

            /* format the y extent of the bounding rectangle */
            wsprintf((LPSTR)szBuf, "%d", placeableWMFHeader.bbox.bottom);
            SetDlgItemText(hDlg, IDS_BOT, (LPSTR)szBuf);

            /* format the number of metafile units per inch */
            wsprintf((LPSTR)szBuf, "%d", placeableWMFHeader.inch);
            SetDlgItemText(hDlg, IDS_INCH, (LPSTR)szBuf);

            /* format the checksum */
            wsprintf((LPSTR)szBuf, "%x", placeableWMFHeader.checksum);
            SetDlgItemText(hDlg, IDS_CHKSUM, (LPSTR)szBuf);

            return (TRUE);

        case WM_COMMAND:                      /* message: received a command */
            if (LOWORD(wParam) == IDOK) {
                EndDialog(hDlg, TRUE);        /* Exits the dialog box        */
                return (TRUE);
            }
            break;
    }
    return (FALSE);                           /* Didn't process a message    */
}

/***********************************************************************

  FUNCTION   : ClpHeaderDlgProc

  PARAMETERS : HWND hDlg
               unsigned message
               WORD wParam
               LONG lParam

  PURPOSE    : show the METAFILEPICT associated with the clipboard
               metafile.  This format is described on page 7-52 of
               the Windows SDK Reference Volume 2.

  CALLS      : WINDOWS
                 lstrcpy
                 wsprintf
                 SetDlgItemText
                 EndDialog

  MESSAGES   : WM_INITDIALOG
               WM_COMMAND

  RETURNS    : BOOL

  COMMENTS   : METAFILEPICT format

               int    mm;
               int    xExt;
               int    yExt;
               HANDLE hMF;

               These fields have the following  meanings:

               Field         Definition

               mm            specifies the mapping mode in which the picture
                             is drawn.

               xExt          specifies the size of the metafile picture for
                             all modes except MM_ISOTROPIC and ANISOTROPIC
                             modes. See SDK reference for more info.

               yExt          as above...

               hMF           Identifies a memory metafile.

  HISTORY    : 1/16/91 - created - Dennis Crain
               7/1/93  - modified for win32

************************************************************************/

INT_PTR CALLBACK ClpHeaderDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    char szBuf[30];
    long lmm = (lpOldMFP != NULL) ? lpOldMFP->mm : lpMFP->mm;
    long lxExt = (lpOldMFP != NULL) ? lpOldMFP->xExt : lpMFP->xExt;
    long lyExt = (lpOldMFP != NULL) ? lpOldMFP->yExt : lpMFP->yExt;

    switch (message) {
        case WM_INITDIALOG:
            /*format the mapping mode */
        lstrcpy((LPSTR)szBuf, (lmm == MM_TEXT)    ? (LPSTR)"MM_TEXT"       :
                  (lmm == MM_LOMETRIC)            ? (LPSTR)"MM_LOMETRIC" :
                  (lmm == MM_HIMETRIC)            ? (LPSTR)"MM_HIMETRIC" :
                  (lmm == MM_LOENGLISH)           ? (LPSTR)"MM_LOENGLISH":
                  (lmm == MM_HIENGLISH)           ? (LPSTR)"MM_HIENGLISH":
                  (lmm == MM_TWIPS)               ? (LPSTR)"MM_TWIPS"     :
                  (lmm == MM_ISOTROPIC)           ? (LPSTR)"MM_ISOTROPIC":
                  (lmm == MM_ANISOTROPIC)         ? (LPSTR)"MM_ANISOTROPIC":
                                                    (LPSTR)"UNKOWN");
            SetDlgItemText(hDlg, IDE_MM, (LPSTR)szBuf);

            /* format the xExt */
        wsprintf((LPSTR)szBuf, "%d", lxExt);
            SetDlgItemText(hDlg, IDE_XEXT, (LPSTR)szBuf);

            /* format the yExt */
        wsprintf((LPSTR)szBuf, "%d", lyExt);
            SetDlgItemText(hDlg, IDE_YEXT, (LPSTR)szBuf);

            return (TRUE);

        case WM_COMMAND:
            if (LOWORD(wParam) == IDOK) {
                EndDialog(hDlg, TRUE);
                return (TRUE);
            }
            break;
    }
    return (FALSE);
}

/***********************************************************************

  FUNCTION   : ListDlgProc

  PARAMETERS : HWND hDlg
               unsigned message
               WORD wParam
               LONG lParam

  PURPOSE    :

  CALLS      : WINDOWS
                 GetMetaFile
                 GetDC
                 EnumMetaFile
                 MakeProcInstance
                 FreeProcInstance
                 ReleaseDC
                 EndDialog
                 DeleteMetaFile
                 MessageBox
                 SendDlgItemMessage
                 GlobalAlloc
                 GlobalLock
                 DialogBox
               APP
                 PlayIt

  MESSAGES   : WM_INITDIALOG
               WM_COMMAND

  RETURNS    : BOOL

  COMMENTS   :

  HISTORY    :

************************************************************************/

void GetMetaFileAndEnum(
    HWND hwnd,
    HDC hDC,
    int iAction);

INT_PTR CALLBACK ListDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    HDC hDC;

    CurrenthDlg = hDlg;
    switch (message) {
        case WM_INITDIALOG:
            hDC = GetDC(hWndMain);
            //
            //initalize the current record number
            //
            iRecNum = 0;
            //
            //enumerate the records into the listbox
            //
            GetMetaFileAndEnum(hWndMain, hDC, ENUMMFLIST);
            ReleaseDC(hWndMain, hDC);
            return (TRUE);

        case WM_COMMAND:
            switch(LOWORD(wParam))
            {
              case IDOK:

              case IDCANCEL:
                 EndDialog(hDlg, TRUE);
                 return(TRUE);
                 break;

              case IDL_PLAY:

                 //get the number of selected items

                 iNumSel = (DWORD) SendDlgItemMessage(hDlg,
                                              IDL_LBREC,
                                              LB_GETSELCOUNT,
                                              0,
                                              0L);

                 //allocate a buffer large enough to save the indexes

                 hSelMem = GlobalAlloc(GHND, iNumSel * sizeof(int));

                 //lock it down and assign a long ptr to it

                 if (hSelMem) {
                    lpSelMem = (int FAR *)GlobalLock(hSelMem);
                    if (!lpSelMem)
                        return(FALSE);
                 }
                 else
                    return(FALSE);

                 //get the actual indexes and put in buffer

                 iLBItemsInBuf = (DWORD) SendDlgItemMessage(hDlg,
                                                            IDL_LBREC,
                                                            LB_GETSELITEMS,
                                                            (WORD)iNumSel,
                                                            (LPARAM)lpSelMem);

                 bEnumRange = FALSE;
                 bPlayItAll = FALSE;
                 bPlayList  = TRUE;
                 iCount = 0; //reset index into lpSelMem

                 /*dialog to play selected or unselected records*/

                 DialogBox(hInst,
                           "PLAYWHAT",
                           hDlg,
                           PlayFromListDlgProc);

                 /* end this dialog prematurely to get on with playing of recs */
                 EndDialog(hDlg, TRUE);

                 /* play the metafile to the appropriate destination */
                 PlayMetaFileToDest(hWndMain, iDestDC);

                 break;

              default:
                 return (FALSE);
            }
            break;

    }
    return (FALSE);
}

/****************************************************************************

    FUNCTION: About(HWND, unsigned, WORD, LONG)

    PURPOSE:  Processes messages for "About" dialog box

    MESSAGES:

        WM_INITDIALOG - initialize dialog box
        WM_COMMAND    - Input received

    COMMENTS:

        No initialization is needed for this particular dialog box, but TRUE
        must be returned to Windows.

        Wait for user to click on "Ok" button, then close the dialog box.

****************************************************************************/

INT_PTR CALLBACK About(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    switch (message) {
        case WM_INITDIALOG:                /* message: initialize dialog box */
            return (TRUE);

        case WM_COMMAND:                      /* message: received a command */
            if (LOWORD(wParam) == IDOK                /* "OK" box selected?          */
                || LOWORD(wParam) == IDCANCEL) {      /* System menu close command? */
                EndDialog(hDlg, TRUE);        /* Exits the dialog box        */
                return (TRUE);
            }
            break;
    }
    return (FALSE);                           /* Didn't process a message    */
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\emfdcode\mfdcod32.c ===
/***************************************************************************

    PROGRAM: mfdcod32

    PURPOSE: view and decode Windows Metafiles and Enhanced Metafiles.

    FUNCTIONS:

    WinMain() - calls initialization function, processes message loop
    InitApplication() - initializes window data and registers window
    InitInstance() - saves instance handle and creates main window
    MainWndProc() - processes messages
    WaitCursor() - loads hourglass cursor/restores original cursor

    HISTORY: 1/16/91 - wrote it - Dennis Crain
             5/20/93 - ported to win32 (NT) - Dennis Crain
             7/1/93  - added enhanced metafile functionality - denniscr

***************************************************************************/

#define MAIN

#include <windows.h>
#include <windowsx.h>
#include "mfdcod32.h"

int      iDestDC;

/**********************************************************************

  FUNCTION   : WinMain

  PARAMETERS : HANDLE
               HANDLE
               LPSTR
               int

  PURPOSE    : calls initialization function, processes message loop

  CALLS      : WINDOWS
                GetMessage
                TranslateMessage
                DispatchMessage

               APP
                InitApplication

  RETURNS    : int

  COMMENTS   : Windows recognizes this function by name as the initial entry
               point for the program.  This function calls the application
               initialization routine, if no other instance of the program is
               running, and always calls the instance initialization routine.
               It then executes a message retrieval and dispatch loop that is
               the top-level control structure for the remainder of execution.
               The loop is terminated when a WM_QUIT message is received, at
               which time this function exits the application instance by
               returning the value passed by PostQuitMessage().

               If this function must abort before entering the message loop,
               it returns the conventional value NULL.

  HISTORY    : 1/16/91 - created - denniscr

***********************************************************************/

int APIENTRY WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)
{
    MSG msg;

    if (!hPrevInstance)
    if (!InitApplication(hInstance))
        return (FALSE);
    //
    //Perform initializations that apply to a specific instance
    //
    if (!InitInstance(hInstance, nCmdShow))
    return (FALSE);
    //
    //Acquire and dispatch messages until a WM_QUIT message is received.
    //
    while (GetMessage(&msg, NULL, 0, 0))
    {
      TranslateMessage(&msg);
      DispatchMessage(&msg);
    }
    return ((int) msg.wParam);

    UNREFERENCED_PARAMETER( lpCmdLine );
}

/**********************************************************************

  FUNCTION   : InitApplication

  PARAMETERS : HANDLE hInstance

  PURPOSE    : Initializes window data and registers window class

  CALLS      : WINDOWS
         RegisterClass

  MESSAGES   : none

  RETURNS    : BOOL

  COMMENTS   : This function is called at initialization time only if no
           other instances of the application are running.  This function
           performs initialization tasks that can be done once for any
           number of running instances.

           In this case, we initialize a window class by filling out a
           data structure of type WNDCLASS and calling the Windows
           RegisterClass() function.  Since all instances of this
           application use the same window class, we only need to do this
           when the first instance is initialized.

  HISTORY    : 1/16/91 - created - modified from SDK sample app GENERIC

***********************************************************************/

BOOL InitApplication(hInstance)
HINSTANCE hInstance;                       // current instance
{
    WNDCLASS  wc;

    bInPaint = FALSE;
    //
    //Fill in window class structure with parameters that describe the
    //main window.
    //
    wc.style = 0;                         //Class style(s)
    wc.lpfnWndProc = MainWndProc;         //Function to retrieve messages for
                                          //windows of this class
    wc.cbClsExtra = 0;                    //No per-class extra data
    wc.cbWndExtra = 0;                    //No per-window extra data
    wc.hInstance = hInstance;             //Application that owns the class
    wc.hIcon = LoadIcon(hInstance, "WMFICON");
    wc.hCursor = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = (HBRUSH) (COLOR_BTNSHADOW + 1);
    wc.lpszMenuName =  "MetaMenu";        //Name of menu resource in .RC file
    wc.lpszClassName = "MetaWndClass";    //Name used in call to CreateWindow
    //
    //Register the window class and return success/failure code
    //
    return (RegisterClass(&wc));

}

/**********************************************************************

  FUNCTION   : InitInstance

  PARAMETERS : HANDLE  hInstance - Current instance identifier
           int     nCmdShow  - Param for first ShowWindow() call

  PURPOSE    : Saves instance handle and creates main window

  CALLS      : WINDOWS
         CreateWindow
         ShowWindow
         UpdateWindow

  MESSAGES   : none

  RETURNS    : BOOL

  COMMENTS   : This function is called at initialization time for every
           instance of this application.  This function performs
           initialization tasks that cannot be shared by multiple
           instances.

           In this case, we save the instance handle in a static variable
           and create and display the main program window.

  HISTORY    :

***********************************************************************/

BOOL InitInstance(hInstance, nCmdShow)
HINSTANCE  hInstance;          // Current instance identifier.
int        nCmdShow;           // Param for first ShowWindow() call.
{
    HWND   hWnd;               // Main window handle.
    HDC    hDC ;               // Main DC handle

    // Save the instance handle in static variable, which will be used in
    // many subsequence calls from this application to Windows.

    hInst = hInstance;

    // Create a main window for this application instance.

    hWnd = CreateWindow(
    "MetaWndClass",                 // See RegisterClass() call.
    APPNAME,                        // Text for window title bar.
    WS_OVERLAPPEDWINDOW,            // Window style.
    CW_USEDEFAULT,                  // Default horizontal position.
    CW_USEDEFAULT,                  // Default vertical position.
    CW_USEDEFAULT,                  // Default width.
    CW_USEDEFAULT,                  // Default height.
    NULL,                           // Overlapped windows have no parent.
    NULL,                           // Use the window class menu.
    hInstance,                      // This instance owns this window.
    NULL                            // Pointer not needed.
    );
    //
    // If window could not be created, return "failure"
    //
    if (!hWnd)
    return (FALSE);

    hWndMain = hWnd;

    //
    // Make the window visible; update its client area; and return "success"
    //
    ShowWindow(hWnd, nCmdShow);  // Show the window
    UpdateWindow(hWnd);          // Sends WM_PAINT message
    return (TRUE);               // Returns the value from PostQuitMessage

}

BOOL bConvertToGdiPlus = FALSE;
BOOL bUseGdiPlusToPlay = FALSE;

/**********************************************************************

  FUNCTION   : MainWndProc

  PARAMETERS : HWND hWnd        -  window handle
           unsigned message -  type of message
           WORD wParam      -  additional information
           LONG lParam      -  additional information

  PURPOSE    : Processes messages

  CALLS      :

  MESSAGES   : WM_CREATE

           WM_COMMAND

         wParams
         - IDM_EXIT
         - IDM_ABOUT
         - IDM_OPEN
         - IDM_PRINT
         - IDM_PRINTDLG
         - IDM_LIST
         - IDM_CLEAR
         - IDM_ENUM
         - IDM_ENUMRANGE
         - IDM_ALLREC
         - IDM_DESTDISPLAY
         - IDM_DESTMETA
         - IDM_HEADER
         - IDM_CLIPHDR
         - IDM_PLACEABLEHDR

           WM_DESTROY

  RETURNS    : long

  COMMENTS   :

  HISTORY    : 1/16/91 - created - drc

***********************************************************************/

LRESULT CALLBACK MainWndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    RECT        rect;
    INT_PTR     iFOpenRet;
    char        TempOpenName[128];
    INT_PTR     iDlgRet;
    BOOL        releaseDC = FALSE;

    switch (message)
    {
    case WM_CREATE:
        //
        // init the state of the menu items
        //
        CheckMenuItem(GetMenu(hWnd), IDM_DESTDISPLAY, MF_CHECKED);
        break;

    case WM_COMMAND:
        //
        // message: command from application menu
        //
        switch (LOWORD(wParam))
        {

        case IDM_EXIT: // file exit menu option

           PostQuitMessage(0);
           break;

        case IDM_ABOUT: // about box

           DialogBox(hInst,                      // current instance
                "AboutBox",                  // resource to use
                 hWnd,                       // parent handle
                 About);               // About() instance address
           break;

        case IDM_OPEN: // select a metafile to open

            // save the name of previously opened file
            if (lstrlen((LPSTR)OpenName) != 0)
            lstrcpy((LPSTR)TempOpenName, (LPSTR)OpenName);
            //
            // initialize file info flags
            //
            if (!bMetaFileOpen) {
              bBadFile = FALSE;
              bValidFile = FALSE;
            }
            //
            // clear the client area
            //
            GetClientRect(hWnd, (LPRECT)&rect);
            InvalidateRect(hWnd, (LPRECT)&rect, TRUE);
            //
            // call file open dlg
            //
            iFOpenRet = OpenFileDialog((LPSTR)OpenName);
            //
            // if a file was selected
            //
            if (iFOpenRet)
            {
              //
              // if file contains a valid metafile and it was rendered
              //
              if (!ProcessFile(hWnd, (LPSTR)OpenName))
              lstrcpy((LPSTR)OpenName, (LPSTR)TempOpenName);
            }
            else
              lstrcpy((LPSTR)OpenName, (LPSTR)TempOpenName);
            break;

        case IDM_SAVEAS:
            {
              int   iSaveRet;
              LPSTR   lpszFilter;
              //
              //get a name of a file to copy the metafile to
              //
              lpszFilter = (bEnhMeta) ? gszSaveWMFFilter : gszSaveEMFFilter;

              iSaveRet = SaveFileDialog((LPSTR)SaveName, lpszFilter);
              //
              //if the file selected is this metafile then warn user
              //
              if (!lstrcmp((LPSTR)OpenName, (LPSTR)SaveName))
                MessageBox(hWnd, (LPSTR)"Cannot overwrite the opened metafile!",
                           (LPSTR)"Copy Metafile", MB_OK | MB_ICONEXCLAMATION);

              else
              //
              //the user didn't hit the cancel button
              //
              if (iSaveRet)
              {
                HDC hrefDC;

                WaitCursor(TRUE);
                if (!bEnhMeta)
                  ConvertWMFtoEMF(hMF, (LPSTR)SaveName);
                else
                {
                  // Try to get a printer DC by default

                  //hrefDC = GetPrinterDC(FALSE);
                  hrefDC = NULL;
                  if (hrefDC == NULL)
                  {
                      releaseDC = TRUE;
                      hrefDC = GetDC(NULL);
                  }
                  ConvertEMFtoWMF(hrefDC, hemf, (LPSTR)SaveName);
                  if (releaseDC)
                  {
                      ReleaseDC(hWnd, hrefDC);
                  }
                  else
                  {
                      DeleteDC(hrefDC);
                  }
                }
              }
            }
            break;

        case IDM_PRINT: // play the metafile to a printer DC
            PrintWMF(FALSE);
            break;
        case IDM_PRINTDLG:
            PrintWMF(TRUE);
            break;

        case IDM_LIST: // list box containing all records of metafile

            WaitCursor(TRUE);
            DialogBox(hInst,             // current instance
                 "LISTRECS",                         // resource to use
                  hWnd,                      // parent handle
                  ListDlgProc);            // About() instance address
            WaitCursor(FALSE);
            break;

        case IDM_CLEAR: // clear the client area

            GetClientRect(hWnd, (LPRECT)&rect);
            InvalidateRect(hWnd, (LPRECT)&rect, TRUE);
            break;

        case IDM_ENUM: // play - step - all menu option

            // set flags appropriately before playing to destination
            bEnumRange = FALSE;
            bPlayItAll = FALSE;
            PlayMetaFileToDest(hWnd, iDestDC);
            break;

        case IDM_ENUMRANGE: // play - step - range menu option
            //
            // odd logic here...this just forces evaluation of the
            //   enumeration range in MetaEnumProc. We are not "playing
            //   it all"
            //
            bPlayItAll = TRUE;

            iDlgRet = DialogBox(hInst,"ENUMRANGE",hWnd,EnumRangeDlgProc);
            //
            // if cancel button not pressed, play to destination
            //
            if (iDlgRet != IDCANCEL)
              PlayMetaFileToDest(hWnd, iDestDC);
            break;


        case IDM_ALLREC: // play - all menu option
            //
            // set flag appropriately and play to destination
            //
            bEnumRange = FALSE;
            bPlayItAll = TRUE;
            bPlayRec = TRUE;
            PlayMetaFileToDest(hWnd, iDestDC);
            break;

        case IDM_DESTDISPLAY: // play - destination - display menu option

            CheckMenuItem(GetMenu(hWnd), IDM_DESTDISPLAY, MF_CHECKED);
            CheckMenuItem(GetMenu(hWnd), IDM_DESTMETA, MF_UNCHECKED);
            CheckMenuItem(GetMenu(hWnd), IDM_DESTDIB, MF_UNCHECKED);
            CheckMenuItem(GetMenu(hWnd), IDM_DESTPRN, MF_UNCHECKED);

            //
            // set destination flag to display
            //
            iDestDC = DESTDISPLAY;
            break;

        case IDM_DESTMETA: // play - destination - metafile menu option

            CheckMenuItem(GetMenu(hWnd), IDM_DESTDISPLAY, MF_UNCHECKED);
            CheckMenuItem(GetMenu(hWnd), IDM_DESTMETA, MF_CHECKED);
            CheckMenuItem(GetMenu(hWnd), IDM_DESTDIB, MF_UNCHECKED);
            CheckMenuItem(GetMenu(hWnd), IDM_DESTPRN, MF_UNCHECKED);

            // set destination flag to metafile
            iDestDC = DESTMETA;
            break;

        case IDM_DESTDIB:
            CheckMenuItem(GetMenu(hWnd), IDM_DESTDISPLAY, MF_UNCHECKED);
            CheckMenuItem(GetMenu(hWnd), IDM_DESTMETA, MF_UNCHECKED);
            CheckMenuItem(GetMenu(hWnd), IDM_DESTDIB, MF_CHECKED);
            CheckMenuItem(GetMenu(hWnd), IDM_DESTPRN, MF_UNCHECKED);

            iDestDC = DESTDIB;
            break;

        case IDM_DESTPRN:
            CheckMenuItem(GetMenu(hWnd), IDM_DESTDISPLAY, MF_UNCHECKED);
            CheckMenuItem(GetMenu(hWnd), IDM_DESTMETA, MF_UNCHECKED);
            CheckMenuItem(GetMenu(hWnd), IDM_DESTDIB, MF_UNCHECKED);
            CheckMenuItem(GetMenu(hWnd), IDM_DESTPRN, MF_CHECKED);

            iDestDC = DESTPRN;
            break;

        case IDM_ENHHEADER:
           if (bValidFile)
             DialogBox(hInst,"ENHMETAHEADER",hWnd,EnhMetaHeaderDlgProc);
           break;

        case IDM_HEADER: // display the common metafile header
           if (bValidFile)
             DialogBox(hInst,"HEADER",hWnd,HeaderDlgProc);
           break;

        case IDM_CLIPHDR: // display the metafilepict of a clipboard file
           if (bValidFile)
             DialogBox(hInst, "CLIPHDR", hWnd, ClpHeaderDlgProc);
           break;

        case IDM_PLACEABLEHDR: // display the placeable metafile header
           if (bValidFile)
             DialogBox(hInst,"PLACEABLEHDR",hWnd, PlaceableHeaderDlgProc);
           break;

        case IDM_GDIPLUS_CONVERT:
            //
            // clear the client area
            //
            GetClientRect(hWnd, (LPRECT)&rect);
            InvalidateRect(hWnd, (LPRECT)&rect, TRUE);

            if (!bConvertToGdiPlus)
            {
                bConvertToGdiPlus = TRUE;
                CheckMenuItem(GetMenu(hWnd), IDM_GDIPLUS_CONVERT, MF_CHECKED);
                goto NoGdipPlay;
            }
            else
            {
NoGdipConvert:
                bConvertToGdiPlus = FALSE;
                CheckMenuItem(GetMenu(hWnd), IDM_GDIPLUS_CONVERT, MF_UNCHECKED);
            }
            break;

        // use (or not) GDI+ to play the metafile
        case IDM_GDIPLUS_PLAY:
            //
            // clear the client area
            //
            GetClientRect(hWnd, (LPRECT)&rect);
            InvalidateRect(hWnd, (LPRECT)&rect, TRUE);

            if (!bUseGdiPlusToPlay)
            {
                bUseGdiPlusToPlay = TRUE;
                CheckMenuItem(GetMenu(hWnd), IDM_GDIPLUS_PLAY, MF_CHECKED);
                goto NoGdipConvert;
            }
            else
            {
NoGdipPlay:
                bUseGdiPlusToPlay = FALSE;
                CheckMenuItem(GetMenu(hWnd), IDM_GDIPLUS_PLAY, MF_UNCHECKED);
            }
            break;

        default:  // let Windows process it
            return (DefWindowProc(hWnd, message, wParam, lParam));
        }
        break;

    case WM_DESTROY: // message: window being destroyed
        //
        //if memory for metafile pict is around nuke it
        //
        if (lpMFP != NULL || lpOldMFP != NULL)
        {
          GlobalUnlock(hMFP);
          GlobalFree(hMFP);
        }
        //
        //if the memory for placeable and clipboard wmf bits is around
        //free it
        //
        if (lpMFBits != NULL)
          GlobalFreePtr(lpMFBits);
        //
        //if the memory for the emf header, desc string and palette
        //is still around then nuke it
        //
        if (EmfPtr.lpEMFHdr)
          GlobalFreePtr(EmfPtr.lpEMFHdr);
        if (EmfPtr.lpDescStr)
          GlobalFreePtr(EmfPtr.lpDescStr);
        if (EmfPtr.lpPal)
          GlobalFreePtr(EmfPtr.lpPal);

        PostQuitMessage(0);
        break;


    default:  // passes it on if unproccessed
        return (DefWindowProc(hWnd, message, wParam, lParam));
    }
    return ((LRESULT)0);
}

/**********************************************************************

  FUNCTION   : WaitCursor

  PARAMETERS : BOOL bWait - TRUE for the hour glass cursor
                FALSE to return to the previous cursor

  PURPOSE    : toggle the mouse cursor to the hourglass and back

  CALLS      : WINDOWS
         LoadCursor
         SetCursor

  MESSAGES   : none

  RETURNS    : void

  COMMENTS   :

  HISTORY    : 1/16/91 - created - drc

***********************************************************************/

void WaitCursor(bWait)
BOOL bWait;
{
  HCURSOR hCursor;
  static HCURSOR hOldCursor;
  //
  // if hourglass cursor is to be used
  //
  if (bWait)
  {
    hCursor = LoadCursor(NULL, IDC_WAIT);
    hOldCursor = SetCursor(hCursor);
  }
  else
    SetCursor(hOldCursor);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\emfdcode\mfdcod32.h ===
#include "resource.h"
#include "commdlg.h"

#define     GlobalSizePtr(lp)       \
                (GlobalUnlockPtr(lp), (BOOL)GlobalSize(GlobalPtrHandle(lp)))

#define  APPNAME     "Metafile Decoder"

#define  DESTDISPLAY     0
#define  DESTMETA        1
#define  DESTDIB         2
#define  DESTPRN         3

extern int      iDestDC;
//
//common dialog structures and constants
//
#define MAXFILTERLEN 256

typedef struct tagFOCHUNK  {
        OPENFILENAME of;
        char szFile[256];
        char szFileTitle[256];
} FOCHUNK;

typedef FOCHUNK FAR *LPFOCHUNK;
typedef FOCHUNK FAR *LPFSCHUNK;
typedef WORD (CALLBACK* FARHOOK)(HWND,UINT,WPARAM,LPARAM);
//
//structure of ptrs to global memory for emf header and
//description string
//
typedef struct tagEHNMETAMEMPTR  {
        LPENHMETAHEADER lpEMFHdr;
        LPTSTR          lpDescStr;
        LPPALETTEENTRY  lpPal;
        WORD            palNumEntries;
} EHNMETAMEMPTR, *PEHNMETAMEMPTR, *LPEHNMETAMEMPTR;
//
//clipboard data definitions
//
#define      CLP_ID         0xC350
#define      CLP_NT_ID      0xC351
#define      CLPBK_NT_ID    0xC352
#define      CLPMETANAMEMAX 79
//
//NT clipboard file header
//
typedef struct  {
   WORD        FileIdentifier;
   WORD        FormatCount;
} NTCLIPFILEHEADER;
//
// NT clipboard file format header
//
typedef struct  {
   DWORD FormatID;
   DWORD DataLen;
   DWORD DataOffset;
   WCHAR  Name[CLPMETANAMEMAX];
} NTCLIPFILEFORMAT, *LPNTCLIPFILEFORMAT;

//
//Win 3.1 clipboard file header
//
#pragma pack(1)
typedef struct {
        WORD FileIdentifier;
        WORD FormatCount;
} CLIPFILEHEADER;
//
//Win 3.1 clipboard format header
//
typedef struct {
        WORD  FormatID;
        DWORD DataLen;
        DWORD DataOffset;
        char  Name[CLPMETANAMEMAX];
} CLIPFILEFORMAT, FAR *LPCLIPFILEFORMAT;
//
//Win 3.1 metafilepict structure
//
typedef struct tagOLDMETAFILEPICT {
    short      mm;
    short      xExt;
    short      yExt;
    WORD       hMF;
} OLDMETAFILEPICT;

typedef OLDMETAFILEPICT FAR *LPOLDMETAFILEPICT;
//
//placeable metafile data definitions
//
typedef struct tagOLDRECT
{
    short   left;
    short   top;
    short   right;
    short   bottom;
} OLDRECT;
//
//placeable metafile header
//
typedef struct {
        DWORD   key;
        WORD    hmf;
        OLDRECT bbox;
        WORD    inch;
        DWORD   reserved;
        WORD    checksum;
}PLACEABLEWMFHEADER;
#pragma pack()

#define  PLACEABLEKEY    0x9AC6CDD7
//
//metafile function table lookup data definitions
//
#define  NUMENHMETARECORDS             255  // includes WFM, EMF, EMF+
typedef struct tagEMFMETARECORDS {
        char *szRecordName;
        DWORD iType;
} EMFMETARECORDS, *LPEMFMETARECORDS;

#define  NUMMETAFUNCTIONS 79                // WMF record types
/*
typedef struct tagMETAFUNCTIONS {
        char *szFuncName;
        WORD value;
} METAFUNCTIONS;
*/

typedef LPWORD  LPPARAMETERS;
typedef LPDWORD LPEMFPARAMETERS;
//
//global vars for main module
//
#ifdef MAIN

HANDLE hInst;
HANDLE CurrenthDlg;
HANDLE hSaveCursor;
HWND   hWndMain;
HWND   hWndList;

LPPARAMETERS lpMFParams;
LPEMFPARAMETERS lpEMFParams;
HANDLE hMem;
HANDLE hSelMem;
int FAR *lpSelMem;
EHNMETAMEMPTR EmfPtr;
//
//flags
//
BOOL bInPaint;
BOOL bPlayRec;
BOOL bPlayItAll;
BOOL bBadFile      = FALSE;
BOOL bValidFile    = FALSE;
BOOL bEnhMeta      = FALSE;
BOOL bMetaFileOpen = FALSE;
BOOL bMetaInRam    = FALSE;
BOOL bPlaceableMeta= FALSE;
BOOL bPlayList     = FALSE;
BOOL bPlaySelList  = TRUE;
BOOL bEnumRange;

int  iEnumAction;
int  iStartRange;
int  iEndRange;

DWORD iCount = 0;               //index into lpSelMem
DWORD iNumSel = 0;               //number of listbox selections

//
//common fo dialog vars
//
char gszSaveEMFFilter[MAXFILTERLEN]="Enhanced MetaFile(*.EMF)\0*.EMF\0\0";
char gszSaveWMFFilter[MAXFILTERLEN]="Windows MetaFile(*.WMF)\0*.WMF\0\0";
char gszFilter[MAXFILTERLEN]="All Supported File Types(*.EMF,*.WMF,*.CLP)\0*.EMF;*.WMF;*.CLP\0Enhanced MetaFiles(*.EMF)\0*.EMF\0Windows Metafiles(*.WMF)\0*.WMF\0Clipboard Pictures(*.CLP)\0*.CLP\0\0";
char gszBuffer[MAXFILTERLEN];
int  nFileOffset;
int  nExtOffset;
//
//file io related vars
//
char                  OpenName[144];
char                  SaveName[144];
char                  str[255];
OFSTRUCT              ofStruct;
DWORD                 iLBItemsInBuf;
char                  fnameext[20];
//
//metafile related vars
//
HANDLE                hMF;
HENHMETAFILE          hemf;
METAFILEPICT          MFP;
METARECORD            MetaRec;
METAHEADER            mfHeader;
PLACEABLEWMFHEADER    placeableWMFHeader;
ENHMETAHEADER         emfHeader;
ENHMETARECORD         emfMetaRec;
DWORD                 iRecNum = 0;
HANDLE                hMFP;
LPMETAFILEPICT        lpMFP = NULL;
LPOLDMETAFILEPICT     lpOldMFP = NULL;
HGLOBAL               hMFBits;
LPSTR                 lpMFBits = NULL;

//
//printer variables
//
HDC                   hPr;                 // handle for printer device context
POINT                 PhysPageSize;        // information about the page
BOOL                  bAbort;              // FALSE if user cancels printing
HWND                  hAbortDlgWnd;
FARPROC               lpAbortDlg;
FARPROC               lpAbortProc;

#endif /* if defined MAIN */
//
//externs
//
#ifndef MAIN

extern HANDLE         hInst;
extern HANDLE         CurrenthDlg;
extern HANDLE         hSaveCursor;
extern HWND           hWndMain;
extern HWND           hWndList;

extern LPPARAMETERS   lpMFParams;
extern LPEMFPARAMETERS lpEMFParams;
extern HANDLE         hMem;
extern HANDLE         hSelMem;
extern int FAR        *lpSelMem;
extern EHNMETAMEMPTR  EmfPtr;
//
//flags
//
extern BOOL           bInPaint;
extern BOOL           bPlayRec;
extern BOOL           bPlayItAll;
extern BOOL           bBadFile;
extern BOOL           bValidFile;
extern BOOL           bEnhMeta;
extern BOOL           bMetaFileOpen;
extern BOOL           bMetaInRam;
extern BOOL           bPlaceableMeta;
extern BOOL           bPlayList;
extern BOOL           bPlaySelList;
extern BOOL           bEnumRange;

extern int            iEnumAction;
extern int            iStartRange;
extern int            iEndRange;

extern DWORD          iCount;              //index into lpSelMem
extern DWORD          iNumSel;             //number of listbox selections
//
//common dialog vars
//
extern char gszSaveEMFFilter[MAXFILTERLEN];
extern char gszSaveWMFFilter[MAXFILTERLEN];
extern char gszFilter[MAXFILTERLEN];
extern char gszBuffer[MAXFILTERLEN];
extern int  nFileOffset;
extern int  nExtOffset;
//
//file io related vars
//
extern char           OpenName[144];
extern char           SaveName[144];
extern char           str[256];
extern OFSTRUCT       ofStruct;
extern DWORD          iLBItemsInBuf;
extern char           fnameext[20];
//
//metafile related vars
//
extern HANDLE         hMF;
extern HENHMETAFILE   hemf;
extern METAFILEPICT   MFP;
extern METARECORD     MetaRec;
extern METAHEADER     mfHeader;
extern PLACEABLEWMFHEADER  placeableWMFHeader;
extern ENHMETAHEADER  emfHeader;
extern ENHMETARECORD  emfMetaRec;
extern DWORD          iRecNum;
extern EMFMETARECORDS emfMetaRecords[];
// extern METAFUNCTIONS  MetaFunctions[];
extern HANDLE         hMFP;
extern LPMETAFILEPICT lpMFP;
extern LPOLDMETAFILEPICT lpOldMFP;
extern HGLOBAL        hMFBits;
extern LPSTR          lpMFBits;
//
//printer variables
//
extern HDC            hPr;                 // handle for printer device context
extern POINT          PhysPageSize;        // information about the page
extern BOOL           bAbort;              // FALSE if user cancels printing
extern HWND           hAbortDlgWnd;

#endif /* if !defined MAIN */
//
//function prototypes
//
//
//MFDCOD32.C

int     APIENTRY WinMain(HINSTANCE, HINSTANCE, LPSTR, int);
BOOL    InitApplication(HANDLE);
BOOL    InitInstance(HANDLE, int);
LRESULT CALLBACK MainWndProc(HWND, UINT, WPARAM, LPARAM);
HANDLE  FAR PASCAL OpenDlg(HWND, unsigned, WORD, LONG);
void    WaitCursor(BOOL);
//
//WMFMETA.C
//
int    CALLBACK EnhMetaFileEnumProc(HDC, LPHANDLETABLE, LPENHMETARECORD, int, LPARAM);
int    CALLBACK MetaEnumProc(HDC, LPHANDLETABLE, LPMETARECORD, int, LPARAM);
BOOL   LoadParameterLB(HWND, DWORD, int);
BOOL   PlayMetaFileToDest(HWND, int);
BOOL   RenderClipMeta(LPVOID, int, WORD);
BOOL   RenderPlaceableMeta(int);
void   SetPlaceableExts(HDC, PLACEABLEWMFHEADER, int);
void   SetNonPlaceableExts(HDC, int);
VOID   SetClipMetaExts(HDC, LPMETAFILEPICT, LPOLDMETAFILEPICT, int);
BOOL   ProcessFile(HWND, LPSTR);
BOOL   ProcessWMF(HWND hWnd, LPSTR lpFileName);
BOOL   ProcessCLP(HWND hWnd, LPSTR lpFileName);
BOOL   ProcessEMF(HWND hWnd, LPSTR lpFileName);
BOOL   GetEMFCoolStuff(void);
BOOL   GetEMFCoolStuff(void);
int    EnumMFIndirect(HDC hDC, LPHANDLETABLE lpHTable,
                      LPMETARECORD lpMFR,
                      LPENHMETARECORD lpEMFR,
                      int nObj, LPARAM lpData);
BOOL ConvertWMFtoEMF(HMETAFILE hmf, LPSTR lpszFileName);
BOOL ConvertEMFtoWMF(HDC hrefDC, HENHMETAFILE hEMF, LPSTR lpszFileName);
//
//DLGPROC.C
//
INT_PTR CALLBACK WMFRecDlgProc(HWND, unsigned, WPARAM, LPARAM);
INT_PTR CALLBACK EnhMetaHeaderDlgProc(HWND, unsigned, WPARAM, LPARAM);
INT_PTR CALLBACK HeaderDlgProc(HWND, unsigned, WPARAM, LPARAM);
INT_PTR CALLBACK ClpHeaderDlgProc(HWND, unsigned, WPARAM, LPARAM);
INT_PTR CALLBACK PlaceableHeaderDlgProc(HWND, unsigned, WPARAM, LPARAM);
INT_PTR CALLBACK EnumRangeDlgProc(HWND, unsigned, WPARAM, LPARAM);
INT_PTR CALLBACK ListDlgProc(HWND, unsigned, WPARAM, LPARAM);
INT_PTR CALLBACK PlayFromListDlgProc(HWND, unsigned, WPARAM, LPARAM);
INT_PTR CALLBACK About(HWND, unsigned, WPARAM, LPARAM);
//
//WMFPRINT.C
//
BOOL    PrintWMF(BOOL);
HANDLE  GetPrinterDC(BOOL);
INT_PTR CALLBACK AbortDlg(HWND, unsigned, WPARAM, LPARAM);
BOOL    CALLBACK AbortProc(HDC, int);
//
//CMNDLG.C
//
void InitializeStruct(WORD, LPSTR, LPSTR);
int  OpenFileDialog(LPSTR);
int  SaveFileDialog(LPSTR, LPSTR);
void SplitPath( LPSTR, LPSTR, LPSTR, LPSTR, LPSTR);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\emfdcode\resource.h ===
//{{NO_DEPENDENCIES}}
// App Studio generated include file.
// Used by MFDCOD32.RC
//
#define WMFDISPLAY                      0
#define ENUMMFSTEP                      0
#define FILEOPENDLG                     0
#define WMFPRINTER                      1
#define IDM_VIEW                        1
#define ENUMMFLIST                      1
#define FILESAVEDLG                     1
#define IDM_PLAY                        2
#define DEC                             10
#define HEX                             16
#define IDGO                            99
#define IDE_RECNUM                      100
#define IDE_RECSIZE                     101
#define _APS_NEXT_COMMAND_VALUE         101
#define _APS_NEXT_SYMED_VALUE           101
#define IDE_FUNCTION                    102
#define _APS_NEXT_RESOURCE_VALUE        102
#define IDL_PARAMETERS                  103
#define IDM_ABOUT                       104
#define IDM_OPEN                        105
#define IDM_ENUM                        106
#define IDC_FILENAME                    107
#define IDC_EDIT                        108
#define IDC_FILES                       109
#define IDC_LISTBOX                     110
#define IDC_PATH                        111
#define IDM_HEADER                      112
#define IDS_VER                         113
#define IDS_SIZE                        114
#define IDS_OBJECTS                     115
#define IDS_MAXREC                      116
#define IDM_EXIT                        117
#define IDM_ALLREC                      118
#define IDM_GOTOREC                     119
#define IDM_CLEAR                       120
#define IDM_ENUMRANGE                   121
#define IDE_FROM                        122
#define IDE_TO                          123
#define IDCB_ALL                        124
#define IDL_PLAY                        125
#define IDL_PRINT                       126
#define IDM_LIST                        127
#define IDL_LBREC                       128
#define IDM_MM                          129
#define IDE_EDITMM                      130
#define IDCHANGE                        131
#define IDQUITENUM                      132
#define IDM_PRINT                       133
#define IDM_CLIPHDR                     134
#define IDM_PLACEABLEHDR                135
#define IDE_MM                          136
#define IDE_XEXT                        137
#define IDE_YEXT                        138
#define IDE_HMF                         139
#define IDS_KEY                         140
#define IDS_LEFT                        141
#define IDS_RIGHT                       142
#define IDS_TOP                         143
#define IDS_BOT                         144
#define IDS_INCH                        145
#define IDS_CHKSUM                      146
#define IDCB_SEL                        147
#define IDCB_UNSEL                      148
#define IDM_DESTDISPLAY                 149
#define IDM_DESTMETA                    150
#define IDB_HEX                         151
#define IDB_DEC                         152
#define IDB_CHAR                        153
#define IDM_SAVEAS                      154
#define IDM_HELPCONTENTS                155
#define IDM_GDIPLUS_CONVERT             156
#define IDB_WORD                        157
#define IDM_PRINTDLG                    158
#define IDM_GDIPLUS_PLAY                159
#define IDM_DESTDIB                     160
#define IDM_DESTPRN                     161

#define IDM_ENHHEADER					200
#define IDC_ITYPE                       1000
#define IDC_NSIZE                       1001
#define IDC_DSIGNATURE                  1002
#define IDC_NVERSION                    1003
#define IDC_NBYTES                      1004
#define IDC_NRECORDS                    1005
#define IDC_NHANDLES                    1006
#define IDC_NDESCRIPTION                1007
#define IDC_OFFDESCRIPTION              1008
#define IDC_NPALENTRIES                 1009
#define IDC_DESCSTRING                  1010
#define IDC_DEVCX                       1011
#define IDC_DEVCY                       1012
#define IDC_MILLCX                      1013
#define IDC_MILLCY                      1014
#define IDC_BOUNDSL                     1015
#define IDC_BOUNDST                     1016
#define IDC_BOUNDSR                     1017
#define IDC_BOUNDSB                     1018
#define IDC_FRAMEL                      1019
#define IDC_FRAMET                      1020
#define IDC_FRAMER                      1021
#define IDC_FRAMEB                      1022
#define IDC_STATIC                      -1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\emfdcode\mydata.hpp ===
#include "Gdiplus.h"

class MYPATTERNBRUSH
{
public:
    UINT            bitsOffset;
    BITMAPINFO *    bmi;

    MYPATTERNBRUSH()
    {
        bitsOffset = 0;
        bmi = NULL;
    }
    ~MYPATTERNBRUSH()
    {
        if (bmi != NULL)
            delete [] bmi;
    }
};

class MYOBJECTS
{
public:
    enum MYOBJECTTYPE
    {
        UnknownObjectType,
        PenObjectType,
        BrushObjectType,
    };
    MYOBJECTTYPE        type;
    UINT                color;
    int                 penWidth;
    int                 patIndex;
    MYPATTERNBRUSH *    brushPattern;

    MYOBJECTS()
    {
        type = UnknownObjectType;
        color = 0;
        penWidth = 1;
        patIndex = -1;
        brushPattern = NULL;
    }
    
    ~MYOBJECTS()
    {
        if (brushPattern != NULL)
            delete brushPattern;
    }
};

class MYDATA
{
public:
    int                         recordNum;
    int                         numObjects;
    int                         containerId;
    HWND                        hwnd;
    Gdiplus::Graphics *         g;
    Gdiplus::Metafile *         metafile;
    SIZEL                       windowExtent;
    SIZEL                       viewportExtent;
    UINT                        mapMode;
    POINTL                      viewportOrg;
    POINTL                      windowOrg;
    float                       dx;
    float                       dy;
    float                       scaleX;
    float                       scaleY;
    MYOBJECTS *                 pObjects;
    MYPATTERNBRUSH *            curBrushPattern;
    int                         curPatIndex;
    int                         curBrush;
    int                         curPen;
    int                         curPenWidth;
    Gdiplus::FillMode           fillMode;
    Gdiplus::PointF             curPos;
    DWORD                       arcDirection;
    Gdiplus::GraphicsPath *     path;
    BOOL                        pathOpen;
    float                       miterLimit;
    Gdiplus::Matrix             matrix;

    MYDATA(HWND inHwnd) 
    { 
        g = NULL;
        hwnd = inHwnd;
        recordNum = 0;
        numObjects = 0;
        containerId = 0;
        mapMode = MM_TEXT; 
        count = 0; 
        windowExtent.cx = 100; 
        windowExtent.cy = 100; 
        viewportExtent.cx = 100; 
        viewportExtent.cy = 100;
        viewportOrg.x = 0;
        viewportOrg.y = 0;
        windowOrg.x = 0;
        windowOrg.y = 0;
        dx = 0;
        dy = 0;
        scaleX = 1;
        scaleY = 1;
        pObjects = NULL;
        curBrushPattern = NULL;
        curPatIndex = -1;
        curBrush = 0;
        curPen = 0;
        curPenWidth = 1;
        fillMode = Gdiplus::FillModeAlternate;
        curPos.X = 0;
        curPos.Y = 0;
        arcDirection = AD_COUNTERCLOCKWISE;
        path = NULL;
        pathOpen = FALSE;
        miterLimit = 10;
    }
    ~MYDATA()
    {
        delete [] pObjects;
        delete path;
    }
    
    void PushId(int id)
    {
        if (count >= 10) count--;
        ids[count++] = id;
    }
    int PopId()
    {
        if (count <= 0) return 0;
        return ids[--count];
    }

protected:
    int ids[10];
    int count;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\emfdcode\wmfprint.c ===
/***********************************************************************

  MODULE     : WMFPRINT.C

  FUNCTIONS  : PrintWMF
               GetPrinterDC
               AbortProc
               AbortDlg

  COMMENTS   :

************************************************************************/

#include "windows.h"
#include "mfdcod32.h"

PRINTDLG pd;

/***********************************************************************

  FUNCTION   : PrintWMF

  PARAMETERS : void

  PURPOSE    : draw the metafile on a printer dc

  CALLS      : WINDOWS
                 wsprintf
                 MessageBox
                 MakeProcInstance
                 Escape
                 CreateDialog
                 SetMapMode
                 SetViewportOrg
                 SetViewportExt
                 EnableWindow
                 PlayMetaFile
                 DestroyWindow
                 DeleteDC

               APP
                 WaitCursor
                 GetPrinterDC
                 SetPlaceableExts
                 SetClipMetaExts

  MESSAGES   : none

  RETURNS    : BOOL - 0 if unable to print 1 if successful

  COMMENTS   :

  HISTORY    : 1/16/91 - created - drc
               7/9/93 - modified for win32 and emf

************************************************************************/

BOOL PrintWMF(BOOL Dialog)
{
  char str[50];
  POINT lpPT;
  SIZE  lpSize;
  DOCINFO di;
  RECT rc;
  //
  //display the hourglass cursor
  //
  WaitCursor(TRUE);
  //
  //get a DC for the printer
  //
  hPr = GetPrinterDC(Dialog);
  //
  //if a DC could not be created then report the error and return
  //
  if (!hPr)
  {
    WaitCursor(FALSE);
    wsprintf((LPSTR)str, "Cannot print %s", (LPSTR)fnameext);
    MessageBox(hWndMain, (LPSTR)str, NULL, MB_OK | MB_ICONHAND);
    return (FALSE);
  }
  //
  //define the abort function
  //
  SetAbortProc(hPr, AbortProc);
  //
  //Initialize the members of a DOCINFO structure.
  //
  memset(&di, 0, sizeof(di));
  di.cbSize = sizeof(DOCINFO);
  di.lpszDocName = (bEnhMeta) ? "Print EMF" : "Print WMF";
  di.lpszOutput = (LPTSTR) NULL;
  //
  //Begin a print job by calling the StartDoc
  //function.
  //
  if (SP_ERROR == (StartDoc(hPr, &di)))
  {
  //if (Escape(hPr, STARTDOC, 4, "Metafile", (LPSTR) NULL) < 0)  {
    MessageBox(hWndMain, "Unable to start print job",
               NULL, MB_OK | MB_ICONHAND);
    DeleteDC(hPr);
  }
  //
  //clear the abort flag
  //
  bAbort = FALSE;
  //
  //Create the Abort dialog box (modeless)
  //
  hAbortDlgWnd = CreateDialog(hInst, "AbortDlg", hWndMain, AbortDlg);
  //
  //if the dialog was not created report the error
  //
  if (!hAbortDlgWnd)
  {
    WaitCursor(FALSE);
    MessageBox(hWndMain, "NULL Abort window handle",
               NULL, MB_OK | MB_ICONHAND);
    return (FALSE);
  }
  //
  //show Abort dialog
  //
  ShowWindow (hAbortDlgWnd, SW_NORMAL);
  //
  //disable the main window to avoid reentrancy problems
  //
  EnableWindow(hWndMain, FALSE);
  WaitCursor(FALSE);
  //
  //if we are still committed to printing
  //
  if (!bAbort)
  {
    //
    //if this is a placeable metafile then set its origins and extents
    //
    if (bPlaceableMeta)
        SetPlaceableExts(hPr, placeableWMFHeader, WMFPRINTER);
    //
    //if this is a metafile contained within a clipboard file then set
    //its origins and extents accordingly
    //
    if ( (bMetaInRam) && (!bPlaceableMeta) )
    SetClipMetaExts(hPr, lpMFP, lpOldMFP, WMFPRINTER);
    //
    //if this is a "traditional" windows metafile
    //
    rc.left = 0;
    rc.top = 0;
    rc.right = GetDeviceCaps(hPr, HORZRES);
    rc.bottom = GetDeviceCaps(hPr, VERTRES);

    if (!bMetaInRam)
    {
      SetMapMode(hPr, MM_TEXT);
      SetViewportOrgEx(hPr, 0, 0, &lpPT);
      //
      //set the extents to the driver supplied values for horizontal
      //and vertical resolution
      //
      SetViewportExtEx(hPr, rc.right, rc.bottom, &lpSize );
    }
    //
    //play the metafile directly to the printer.
    //No enumeration involved here
    //
    if (bEnhMeta)
    {
      DPtoLP(hPr, (LPPOINT)&rc, 2);
      PlayEnhMetaFile(hPr, hemf, &rc);
    }
    else
      PlayMetaFile(hPr, hMF);
  }
  //
  //eject page and end the print job
  //
  Escape(hPr, NEWFRAME, 0, 0L, 0L);

  EndDoc(hPr);

  EnableWindow(hWndMain, TRUE);
  //
  //destroy the Abort dialog box
  //
  DestroyWindow(hAbortDlgWnd);

  DeleteDC(hPr);

  return(TRUE);
}

/***********************************************************************

  FUNCTION   : GetPrinterDC

  PARAMETERS : BOOL: Do we want to show a print DLG?

  PURPOSE    : Get hDc for current device on current output port according
               to info in WIN.INI.

  CALLS      : WINDOWS
                 GetProfileString
                 AnsiNext
                 CreateDC

  MESSAGES   : none

  RETURNS    : HANDLE - hDC > 0 if success  hDC = 0 if failure

  COMMENTS   : Searches WIN.INI for information about what printer is
               connected, and if found, creates a DC for the printer.

  HISTORY    : 1/16/91 - created - denniscr

************************************************************************/

HANDLE GetPrinterDC(BOOL Dialog)
{

  memset(&pd, 0, sizeof(PRINTDLG));
  pd.lStructSize = sizeof(PRINTDLG);
  pd.Flags = PD_RETURNDC | (Dialog?0:PD_RETURNDEFAULT);
  pd.hwndOwner = hWndMain ;
  return ((PrintDlg(&pd) != 0) ? pd.hDC : NULL);
}

/***********************************************************************

  FUNCTION   : AbortProc

  PARAMETERS : HDC hPr - printer DC
               int Code - printing status

  PURPOSE    : process messages for the abort dialog box

  CALLS      : WINDOWS
                 PeekMessage
                 IsDialogMessage
                 TranslateMessage
                 DispatchMessage

  MESSAGES   : none

  RETURNS    : int

  COMMENTS   :

  HISTORY    : 1/16/91 - created - denniscr

************************************************************************/

BOOL CALLBACK AbortProc(HDC hPr, int Code)
{
  MSG msg;
  //
  //Process messages intended for the abort dialog box
  //
  while (!bAbort && PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
      if (!IsDialogMessage(hAbortDlgWnd, &msg))
      {
          TranslateMessage(&msg);
          DispatchMessage(&msg);
      }
  //
  //bAbort is TRUE (return is FALSE) if the user has aborted
  //
  return (!bAbort);
}

/***********************************************************************

  FUNCTION   : AbortDlg

  PARAMETERS : HWND hDlg;
               unsigned msg;
               WORD wParam;
               LONG lParam;

  PURPOSE    : Processes messages for printer abort dialog box

  CALLS      : WINDOWS
                 SetFocus

  MESSAGES   : WM_INITDIALOG - initialize dialog box
               WM_COMMAND    - Input received

  RETURNS    : BOOL

  COMMENTS   : This dialog box is created while the program is printing,
               and allows the user to cancel the printing process.

  HISTORY    : 1/16/91 - created - denniscr

************************************************************************/

INT_PTR CALLBACK AbortDlg(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    switch(msg)
    {
        //
        //Watch for Cancel button, RETURN key, ESCAPE key, or SPACE BAR
        //
        case WM_INITDIALOG:
            //
            //Set the focus to the Cancel box of the dialog
            //
            SetFocus(GetDlgItem(hDlg, IDCANCEL));
            return (TRUE);

        case WM_COMMAND:
            return (bAbort = TRUE);

        }
    return (FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\emfdcode\wmfmeta.cpp ===
/***********************************************************************

  MODULE     : WMFMETA.CPP

  FUNCTIONS  : MetaEnumProc
               GetMetaFileAndEnum
               LoadParameterLB
               PlayMetaFileToDest
               RenderClipMeta
               RenderPlaceableMeta
               SetPlaceableExts
               SetClipMetaExts
               ProcessFile

  COMMENTS   :

************************************************************************/

#include <windows.h>
#include <windowsx.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <objbase.h>
extern "C" {
#include "mfdcod32.h"
}
extern "C" {
  extern BOOL bConvertToGdiPlus;
  extern BOOL bUseGdiPlusToPlay;
}

#include "GdiPlus.h"

#include "MyData.hpp"
#include "dibstream.hpp"

#include "../gpinit.inc"

#ifndef ASSERT
#ifdef _DEBUG           // poor man's assert
#define ASSERT(cond)    if (!(cond)) { int b = 0; b = 1 / b; }
#else
#define ASSERT(cond)
#endif
#endif

// Check if a source is needed in a 3-way bitblt operation.
// This works on both rop and rop3.  We assume that a rop contains zero
// in the high byte.
//
// This is tested by comparing the rop result bits with source (column A
// below) vs. those without source (column B).  If the two cases are
// identical, then the effect of the rop does not depend on the source
// and we don't need a source device.  Recall the rop construction from
// input (pattern, source, target --> result):
//
//      P S T | R   A B         mask for A = 0CCh
//      ------+--------         mask for B =  33h
//      0 0 0 | x   0 x
//      0 0 1 | x   0 x
//      0 1 0 | x   x 0
//      0 1 1 | x   x 0
//      1 0 0 | x   0 x
//      1 0 1 | x   0 x
//      1 1 0 | x   x 0
//      1 1 1 | x   x 0

#define ISSOURCEINROP3(rop3)    \
        (((rop3) & 0xCCCC0000) != (((rop3) << 2) & 0xCCCC0000))

#ifndef EMR_SETICMMODE
#define EMR_SETICMMODE                  98
#define EMR_CREATECOLORSPACE            99
#define EMR_SETCOLORSPACE              100
#define EMR_DELETECOLORSPACE           101
#define EMR_GLSRECORD                  102
#define EMR_GLSBOUNDEDRECORD           103
#define EMR_PIXELFORMAT                104
#endif

#ifndef EMR_DRAWESCAPE
#define EMR_DRAWESCAPE                 105
#define EMR_EXTESCAPE                  106
#define EMR_STARTDOC                   107
#define EMR_SMALLTEXTOUT               108
#define EMR_FORCEUFIMAPPING            109
#define EMR_NAMEDESCAPE                110
#define EMR_COLORCORRECTPALETTE        111
#define EMR_SETICMPROFILEA             112
#define EMR_SETICMPROFILEW             113
#define EMR_ALPHABLEND                 114
#define EMR_SETLAYOUT                  115
#define EMR_TRANSPARENTBLT             116
#define EMR_GRADIENTFILL               118
#define EMR_SETLINKEDUFIS              119
#define EMR_SETTEXTJUSTIFICATION       120
#define EMR_COLORMATCHTOTARGETW        121
#define EMR_CREATECOLORSPACEW          122
#endif

#define TOREAL(i)   (static_cast<float>(i))


//
// Wrap a GDI+ TextureBrush object around DIB data
//

class DibBrush
{
public:

    DibBrush(const BITMAPINFO* bmi, const BYTE* bits) :
        dibStream(bmi, bits),
        bitmap(&dibStream),
        brush(&bitmap)
    {
    }

    operator Gdiplus::TextureBrush*()
    {
        return &brush;
    }

private:

    DibStream dibStream;
    Gdiplus::Bitmap bitmap;
    Gdiplus::TextureBrush brush;
};

//
//lookup table for EMF and WMF metafile records
//
EMFMETARECORDS emfMetaRecords[] = {
    "WmfSetBkColor"                    , Gdiplus::WmfRecordTypeSetBkColor                ,
    "WmfSetBkMode"                     , Gdiplus::WmfRecordTypeSetBkMode                 ,
    "WmfSetMapMode"                    , Gdiplus::WmfRecordTypeSetMapMode                ,
    "WmfSetROP2"                       , Gdiplus::WmfRecordTypeSetROP2                   ,
    "WmfSetRelAbs"                     , Gdiplus::WmfRecordTypeSetRelAbs                 ,
    "WmfSetPolyFillMode"               , Gdiplus::WmfRecordTypeSetPolyFillMode           ,
    "WmfSetStretchBltMode"             , Gdiplus::WmfRecordTypeSetStretchBltMode         ,
    "WmfSetTextCharExtra"              , Gdiplus::WmfRecordTypeSetTextCharExtra          ,
    "WmfSetTextColor"                  , Gdiplus::WmfRecordTypeSetTextColor              ,
    "WmfSetTextJustification"          , Gdiplus::WmfRecordTypeSetTextJustification      ,
    "WmfSetWindowOrg"                  , Gdiplus::WmfRecordTypeSetWindowOrg              ,
    "WmfSetWindowExt"                  , Gdiplus::WmfRecordTypeSetWindowExt              ,
    "WmfSetViewportOrg"                , Gdiplus::WmfRecordTypeSetViewportOrg            ,
    "WmfSetViewportExt"                , Gdiplus::WmfRecordTypeSetViewportExt            ,
    "WmfOffsetWindowOrg"               , Gdiplus::WmfRecordTypeOffsetWindowOrg           ,
    "WmfScaleWindowExt"                , Gdiplus::WmfRecordTypeScaleWindowExt            ,
    "WmfOffsetViewportOrg"             , Gdiplus::WmfRecordTypeOffsetViewportOrg         ,
    "WmfScaleViewportExt"              , Gdiplus::WmfRecordTypeScaleViewportExt          ,
    "WmfLineTo"                        , Gdiplus::WmfRecordTypeLineTo                    ,
    "WmfMoveTo"                        , Gdiplus::WmfRecordTypeMoveTo                    ,
    "WmfExcludeClipRect"               , Gdiplus::WmfRecordTypeExcludeClipRect           ,
    "WmfIntersectClipRect"             , Gdiplus::WmfRecordTypeIntersectClipRect         ,
    "WmfArc"                           , Gdiplus::WmfRecordTypeArc                       ,
    "WmfEllipse"                       , Gdiplus::WmfRecordTypeEllipse                   ,
    "WmfFloodFill"                     , Gdiplus::WmfRecordTypeFloodFill                 ,
    "WmfPie"                           , Gdiplus::WmfRecordTypePie                       ,
    "WmfRectangle"                     , Gdiplus::WmfRecordTypeRectangle                 ,
    "WmfRoundRect"                     , Gdiplus::WmfRecordTypeRoundRect                 ,
    "WmfPatBlt"                        , Gdiplus::WmfRecordTypePatBlt                    ,
    "WmfSaveDC"                        , Gdiplus::WmfRecordTypeSaveDC                    ,
    "WmfSetPixel"                      , Gdiplus::WmfRecordTypeSetPixel                  ,
    "WmfOffsetClipRgn"                 , Gdiplus::WmfRecordTypeOffsetClipRgn             ,
    "WmfTextOut"                       , Gdiplus::WmfRecordTypeTextOut                   ,
    "WmfBitBlt"                        , Gdiplus::WmfRecordTypeBitBlt                    ,
    "WmfStretchBlt"                    , Gdiplus::WmfRecordTypeStretchBlt                ,
    "WmfPolygon"                       , Gdiplus::WmfRecordTypePolygon                   ,
    "WmfPolyline"                      , Gdiplus::WmfRecordTypePolyline                  ,
    "WmfEscape"                        , Gdiplus::WmfRecordTypeEscape                    ,
    "WmfRestoreDC"                     , Gdiplus::WmfRecordTypeRestoreDC                 ,
    "WmfFillRegion"                    , Gdiplus::WmfRecordTypeFillRegion                ,
    "WmfFrameRegion"                   , Gdiplus::WmfRecordTypeFrameRegion               ,
    "WmfInvertRegion"                  , Gdiplus::WmfRecordTypeInvertRegion              ,
    "WmfPaintRegion"                   , Gdiplus::WmfRecordTypePaintRegion               ,
    "WmfSelectClipRegion"              , Gdiplus::WmfRecordTypeSelectClipRegion          ,
    "WmfSelectObject"                  , Gdiplus::WmfRecordTypeSelectObject              ,
    "WmfSetTextAlign"                  , Gdiplus::WmfRecordTypeSetTextAlign              ,
    "WmfDrawText"                      , Gdiplus::WmfRecordTypeDrawText                  ,
    "WmfChord"                         , Gdiplus::WmfRecordTypeChord                     ,
    "WmfSetMapperFlags"                , Gdiplus::WmfRecordTypeSetMapperFlags            ,
    "WmfExtTextOut"                    , Gdiplus::WmfRecordTypeExtTextOut                ,
    "WmfSetDIBToDev"                   , Gdiplus::WmfRecordTypeSetDIBToDev               ,
    "WmfSelectPalette"                 , Gdiplus::WmfRecordTypeSelectPalette             ,
    "WmfRealizePalette"                , Gdiplus::WmfRecordTypeRealizePalette            ,
    "WmfAnimatePalette"                , Gdiplus::WmfRecordTypeAnimatePalette            ,
    "WmfSetPalEntries"                 , Gdiplus::WmfRecordTypeSetPalEntries             ,
    "WmfPolyPolygon"                   , Gdiplus::WmfRecordTypePolyPolygon               ,
    "WmfResizePalette"                 , Gdiplus::WmfRecordTypeResizePalette             ,
    "WmfDIBBitBlt"                     , Gdiplus::WmfRecordTypeDIBBitBlt                 ,
    "WmfDIBStretchBlt"                 , Gdiplus::WmfRecordTypeDIBStretchBlt             ,
    "WmfDIBCreatePatternBrush"         , Gdiplus::WmfRecordTypeDIBCreatePatternBrush     ,
    "WmfStretchDIB"                    , Gdiplus::WmfRecordTypeStretchDIB                ,
    "WmfExtFloodFill"                  , Gdiplus::WmfRecordTypeExtFloodFill              ,
    "WmfSetLayout"                     , Gdiplus::WmfRecordTypeSetLayout                 ,
    "WmfResetDC"                       , Gdiplus::WmfRecordTypeResetDC                   ,
    "WmfStartDoc"                      , Gdiplus::WmfRecordTypeStartDoc                  ,
    "WmfStartPage"                     , Gdiplus::WmfRecordTypeStartPage                 ,
    "WmfEndPage"                       , Gdiplus::WmfRecordTypeEndPage                   ,
    "WmfAbortDoc"                      , Gdiplus::WmfRecordTypeAbortDoc                  ,
    "WmfEndDoc"                        , Gdiplus::WmfRecordTypeEndDoc                    ,
    "WmfDeleteObject"                  , Gdiplus::WmfRecordTypeDeleteObject              ,
    "WmfCreatePalette"                 , Gdiplus::WmfRecordTypeCreatePalette             ,
    "WmfCreateBrush"                   , Gdiplus::WmfRecordTypeCreateBrush               ,
    "WmfCreatePatternBrush"            , Gdiplus::WmfRecordTypeCreatePatternBrush        ,
    "WmfCreatePenIndirect"             , Gdiplus::WmfRecordTypeCreatePenIndirect         ,
    "WmfCreateFontIndirect"            , Gdiplus::WmfRecordTypeCreateFontIndirect        ,
    "WmfCreateBrushIndirect"           , Gdiplus::WmfRecordTypeCreateBrushIndirect       ,
    "WmfCreateBitmapIndirect"          , Gdiplus::WmfRecordTypeCreateBitmapIndirect      ,
    "WmfCreateBitmap"                  , Gdiplus::WmfRecordTypeCreateBitmap              ,
    "WmfCreateRegion"                  , Gdiplus::WmfRecordTypeCreateRegion              ,
    "EmfHeader"                        , Gdiplus::EmfRecordTypeHeader                     ,
    "EmfPolyBezier"                    , Gdiplus::EmfRecordTypePolyBezier                 ,
    "EmfPolygon"                       , Gdiplus::EmfRecordTypePolygon                    ,
    "EmfPolyline"                      , Gdiplus::EmfRecordTypePolyline                   ,
    "EmfPolyBezierTo"                  , Gdiplus::EmfRecordTypePolyBezierTo               ,
    "EmfPolyLineTo"                    , Gdiplus::EmfRecordTypePolyLineTo                 ,
    "EmfPolyPolyline"                  , Gdiplus::EmfRecordTypePolyPolyline               ,
    "EmfPolyPolygon"                   , Gdiplus::EmfRecordTypePolyPolygon                ,
    "EmfSetWindowExtEx"                , Gdiplus::EmfRecordTypeSetWindowExtEx             ,
    "EmfSetWindowOrgEx"                , Gdiplus::EmfRecordTypeSetWindowOrgEx             ,
    "EmfSetViewportExtEx"              , Gdiplus::EmfRecordTypeSetViewportExtEx           ,
    "EmfSetViewportOrgEx"              , Gdiplus::EmfRecordTypeSetViewportOrgEx           ,
    "EmfSetBrushOrgEx"                 , Gdiplus::EmfRecordTypeSetBrushOrgEx              ,
    "EmfEOF"                           , Gdiplus::EmfRecordTypeEOF                        ,
    "EmfSetPixelV"                     , Gdiplus::EmfRecordTypeSetPixelV                  ,
    "EmfSetMapperFlags"                , Gdiplus::EmfRecordTypeSetMapperFlags             ,
    "EmfSetMapMode"                    , Gdiplus::EmfRecordTypeSetMapMode                 ,
    "EmfSetBkMode"                     , Gdiplus::EmfRecordTypeSetBkMode                  ,
    "EmfSetPolyFillMode"               , Gdiplus::EmfRecordTypeSetPolyFillMode            ,
    "EmfSetROP2"                       , Gdiplus::EmfRecordTypeSetROP2                    ,
    "EmfSetStretchBltMode"             , Gdiplus::EmfRecordTypeSetStretchBltMode          ,
    "EmfSetTextAlign"                  , Gdiplus::EmfRecordTypeSetTextAlign               ,
    "EmfSetColorAdjustment"            , Gdiplus::EmfRecordTypeSetColorAdjustment         ,
    "EmfSetTextColor"                  , Gdiplus::EmfRecordTypeSetTextColor               ,
    "EmfSetBkColor"                    , Gdiplus::EmfRecordTypeSetBkColor                 ,
    "EmfOffsetClipRgn"                 , Gdiplus::EmfRecordTypeOffsetClipRgn              ,
    "EmfMoveToEx"                      , Gdiplus::EmfRecordTypeMoveToEx                   ,
    "EmfSetMetaRgn"                    , Gdiplus::EmfRecordTypeSetMetaRgn                 ,
    "EmfExcludeClipRect"               , Gdiplus::EmfRecordTypeExcludeClipRect            ,
    "EmfIntersectClipRect"             , Gdiplus::EmfRecordTypeIntersectClipRect          ,
    "EmfScaleViewportExtEx"            , Gdiplus::EmfRecordTypeScaleViewportExtEx         ,
    "EmfScaleWindowExtEx"              , Gdiplus::EmfRecordTypeScaleWindowExtEx           ,
    "EmfSaveDC"                        , Gdiplus::EmfRecordTypeSaveDC                     ,
    "EmfRestoreDC"                     , Gdiplus::EmfRecordTypeRestoreDC                  ,
    "EmfSetWorldTransform"             , Gdiplus::EmfRecordTypeSetWorldTransform          ,
    "EmfModifyWorldTransform"          , Gdiplus::EmfRecordTypeModifyWorldTransform       ,
    "EmfSelectObject"                  , Gdiplus::EmfRecordTypeSelectObject               ,
    "EmfCreatePen"                     , Gdiplus::EmfRecordTypeCreatePen                  ,
    "EmfCreateBrushIndirect"           , Gdiplus::EmfRecordTypeCreateBrushIndirect        ,
    "EmfDeleteObject"                  , Gdiplus::EmfRecordTypeDeleteObject               ,
    "EmfAngleArc"                      , Gdiplus::EmfRecordTypeAngleArc                   ,
    "EmfEllipse"                       , Gdiplus::EmfRecordTypeEllipse                    ,
    "EmfRectangle"                     , Gdiplus::EmfRecordTypeRectangle                  ,
    "EmfRoundRect"                     , Gdiplus::EmfRecordTypeRoundRect                  ,
    "EmfArc"                           , Gdiplus::EmfRecordTypeArc                        ,
    "EmfChord"                         , Gdiplus::EmfRecordTypeChord                      ,
    "EmfPie"                           , Gdiplus::EmfRecordTypePie                        ,
    "EmfSelectPalette"                 , Gdiplus::EmfRecordTypeSelectPalette              ,
    "EmfCreatePalette"                 , Gdiplus::EmfRecordTypeCreatePalette              ,
    "EmfSetPaletteEntries"             , Gdiplus::EmfRecordTypeSetPaletteEntries          ,
    "EmfResizePalette"                 , Gdiplus::EmfRecordTypeResizePalette              ,
    "EmfRealizePalette"                , Gdiplus::EmfRecordTypeRealizePalette             ,
    "EmfExtFloodFill"                  , Gdiplus::EmfRecordTypeExtFloodFill               ,
    "EmfLineTo"                        , Gdiplus::EmfRecordTypeLineTo                     ,
    "EmfArcTo"                         , Gdiplus::EmfRecordTypeArcTo                      ,
    "EmfPolyDraw"                      , Gdiplus::EmfRecordTypePolyDraw                   ,
    "EmfSetArcDirection"               , Gdiplus::EmfRecordTypeSetArcDirection            ,
    "EmfSetMiterLimit"                 , Gdiplus::EmfRecordTypeSetMiterLimit              ,
    "EmfBeginPath"                     , Gdiplus::EmfRecordTypeBeginPath                  ,
    "EmfEndPath"                       , Gdiplus::EmfRecordTypeEndPath                    ,
    "EmfCloseFigure"                   , Gdiplus::EmfRecordTypeCloseFigure                ,
    "EmfFillPath"                      , Gdiplus::EmfRecordTypeFillPath                   ,
    "EmfStrokeAndFillPath"             , Gdiplus::EmfRecordTypeStrokeAndFillPath          ,
    "EmfStrokePath"                    , Gdiplus::EmfRecordTypeStrokePath                 ,
    "EmfFlattenPath"                   , Gdiplus::EmfRecordTypeFlattenPath                ,
    "EmfWidenPath"                     , Gdiplus::EmfRecordTypeWidenPath                  ,
    "EmfSelectClipPath"                , Gdiplus::EmfRecordTypeSelectClipPath             ,
    "EmfAbortPath"                     , Gdiplus::EmfRecordTypeAbortPath                  ,
    "EmfReserved_069"                  , Gdiplus::EmfRecordTypeReserved_069               ,
    "EmfGdiComment"                    , Gdiplus::EmfRecordTypeGdiComment                 ,
    "EmfFillRgn"                       , Gdiplus::EmfRecordTypeFillRgn                    ,
    "EmfFrameRgn"                      , Gdiplus::EmfRecordTypeFrameRgn                   ,
    "EmfInvertRgn"                     , Gdiplus::EmfRecordTypeInvertRgn                  ,
    "EmfPaintRgn"                      , Gdiplus::EmfRecordTypePaintRgn                   ,
    "EmfExtSelectClipRgn"              , Gdiplus::EmfRecordTypeExtSelectClipRgn           ,
    "EmfBitBlt"                        , Gdiplus::EmfRecordTypeBitBlt                     ,
    "EmfStretchBlt"                    , Gdiplus::EmfRecordTypeStretchBlt                 ,
    "EmfMaskBlt"                       , Gdiplus::EmfRecordTypeMaskBlt                    ,
    "EmfPlgBlt"                        , Gdiplus::EmfRecordTypePlgBlt                     ,
    "EmfSetDIBitsToDevice"             , Gdiplus::EmfRecordTypeSetDIBitsToDevice          ,
    "EmfStretchDIBits"                 , Gdiplus::EmfRecordTypeStretchDIBits              ,
    "EmfExtCreateFontIndirect"         , Gdiplus::EmfRecordTypeExtCreateFontIndirect      ,
    "EmfExtTextOutA"                   , Gdiplus::EmfRecordTypeExtTextOutA                ,
    "EmfExtTextOutW"                   , Gdiplus::EmfRecordTypeExtTextOutW                ,
    "EmfPolyBezier16"                  , Gdiplus::EmfRecordTypePolyBezier16               ,
    "EmfPolygon16"                     , Gdiplus::EmfRecordTypePolygon16                  ,
    "EmfPolyline16"                    , Gdiplus::EmfRecordTypePolyline16                 ,
    "EmfPolyBezierTo16"                , Gdiplus::EmfRecordTypePolyBezierTo16             ,
    "EmfPolylineTo16"                  , Gdiplus::EmfRecordTypePolylineTo16               ,
    "EmfPolyPolyline16"                , Gdiplus::EmfRecordTypePolyPolyline16             ,
    "EmfPolyPolygon16"                 , Gdiplus::EmfRecordTypePolyPolygon16              ,
    "EmfPolyDraw16"                    , Gdiplus::EmfRecordTypePolyDraw16                 ,
    "EmfCreateMonoBrush"               , Gdiplus::EmfRecordTypeCreateMonoBrush            ,
    "EmfCreateDIBPatternBrushPt"       , Gdiplus::EmfRecordTypeCreateDIBPatternBrushPt    ,
    "EmfExtCreatePen"                  , Gdiplus::EmfRecordTypeExtCreatePen               ,
    "EmfPolyTextOutA"                  , Gdiplus::EmfRecordTypePolyTextOutA               ,
    "EmfPolyTextOutW"                  , Gdiplus::EmfRecordTypePolyTextOutW               ,
    "EmfSetICMMode"                    , Gdiplus::EmfRecordTypeSetICMMode                 ,
    "EmfCreateColorSpace"              , Gdiplus::EmfRecordTypeCreateColorSpace           ,
    "EmfSetColorSpace"                 , Gdiplus::EmfRecordTypeSetColorSpace              ,
    "EmfDeleteColorSpace"              , Gdiplus::EmfRecordTypeDeleteColorSpace           ,
    "EmfGLSRecord"                     , Gdiplus::EmfRecordTypeGLSRecord                  ,
    "EmfGLSBoundedRecord"              , Gdiplus::EmfRecordTypeGLSBoundedRecord           ,
    "EmfPixelFormat"                   , Gdiplus::EmfRecordTypePixelFormat                ,
    "EmfDrawEscape"                    , Gdiplus::EmfRecordTypeDrawEscape                 ,
    "EmfExtEscape"                     , Gdiplus::EmfRecordTypeExtEscape                  ,
    "EmfStartDoc"                      , Gdiplus::EmfRecordTypeStartDoc                   ,
    "EmfSmallTextOut"                  , Gdiplus::EmfRecordTypeSmallTextOut               ,
    "EmfForceUFIMapping"               , Gdiplus::EmfRecordTypeForceUFIMapping            ,
    "EmfNamedEscape"                   , Gdiplus::EmfRecordTypeNamedEscape                ,
    "EmfColorCorrectPalette"           , Gdiplus::EmfRecordTypeColorCorrectPalette        ,
    "EmfSetICMProfileA"                , Gdiplus::EmfRecordTypeSetICMProfileA             ,
    "EmfSetICMProfileW"                , Gdiplus::EmfRecordTypeSetICMProfileW             ,
    "EmfAlphaBlend"                    , Gdiplus::EmfRecordTypeAlphaBlend                 ,
    "EmfSetLayout"                     , Gdiplus::EmfRecordTypeSetLayout                  ,
    "EmfTransparentBlt"                , Gdiplus::EmfRecordTypeTransparentBlt             ,
    "EmfReserved_117"                  , Gdiplus::EmfRecordTypeReserved_117               ,
    "EmfGradientFill"                  , Gdiplus::EmfRecordTypeGradientFill               ,
    "EmfSetLinkedUFIs"                 , Gdiplus::EmfRecordTypeSetLinkedUFIs              ,
    "EmfSetTextJustification"          , Gdiplus::EmfRecordTypeSetTextJustification       ,
    "EmfColorMatchToTargetW"           , Gdiplus::EmfRecordTypeColorMatchToTargetW        ,
    "EmfCreateColorSpaceW"             , Gdiplus::EmfRecordTypeCreateColorSpaceW          ,
    "EmfPlusHeader"                    , Gdiplus::EmfPlusRecordTypeHeader                 ,
    "EmfPlusEndOfFile"                 , Gdiplus::EmfPlusRecordTypeEndOfFile              ,
    "EmfPlusComment"                   , Gdiplus::EmfPlusRecordTypeComment                ,
    "EmfPlusGetDC"                     , Gdiplus::EmfPlusRecordTypeGetDC                  ,
    "EmfPlusMultiFormatStart"          , Gdiplus::EmfPlusRecordTypeMultiFormatStart       ,
    "EmfPlusMultiFormatSection"        , Gdiplus::EmfPlusRecordTypeMultiFormatSection     ,
    "EmfPlusMultiFormatEnd"            , Gdiplus::EmfPlusRecordTypeMultiFormatEnd         ,
    "EmfPlusObject"                    , Gdiplus::EmfPlusRecordTypeObject                 ,
    "EmfPlusClear"                     , Gdiplus::EmfPlusRecordTypeClear                  ,
    "EmfPlusFillRects"                 , Gdiplus::EmfPlusRecordTypeFillRects              ,
    "EmfPlusDrawRects"                 , Gdiplus::EmfPlusRecordTypeDrawRects              ,
    "EmfPlusFillPolygon"               , Gdiplus::EmfPlusRecordTypeFillPolygon            ,
    "EmfPlusDrawLines"                 , Gdiplus::EmfPlusRecordTypeDrawLines              ,
    "EmfPlusFillEllipse"               , Gdiplus::EmfPlusRecordTypeFillEllipse            ,
    "EmfPlusDrawEllipse"               , Gdiplus::EmfPlusRecordTypeDrawEllipse            ,
    "EmfPlusFillPie"                   , Gdiplus::EmfPlusRecordTypeFillPie                ,
    "EmfPlusDrawPie"                   , Gdiplus::EmfPlusRecordTypeDrawPie                ,
    "EmfPlusDrawArc"                   , Gdiplus::EmfPlusRecordTypeDrawArc                ,
    "EmfPlusFillRegion"                , Gdiplus::EmfPlusRecordTypeFillRegion             ,
    "EmfPlusFillPath"                  , Gdiplus::EmfPlusRecordTypeFillPath               ,
    "EmfPlusDrawPath"                  , Gdiplus::EmfPlusRecordTypeDrawPath               ,
    "EmfPlusFillClosedCurve"           , Gdiplus::EmfPlusRecordTypeFillClosedCurve        ,
    "EmfPlusDrawClosedCurve"           , Gdiplus::EmfPlusRecordTypeDrawClosedCurve        ,
    "EmfPlusDrawCurve"                 , Gdiplus::EmfPlusRecordTypeDrawCurve              ,
    "EmfPlusDrawBeziers"               , Gdiplus::EmfPlusRecordTypeDrawBeziers            ,
    "EmfPlusDrawImage"                 , Gdiplus::EmfPlusRecordTypeDrawImage              ,
    "EmfPlusDrawImagePoints"           , Gdiplus::EmfPlusRecordTypeDrawImagePoints        ,
    "EmfPlusDrawString"                , Gdiplus::EmfPlusRecordTypeDrawString             ,
    "EmfPlusSetRenderingOrigin"        , Gdiplus::EmfPlusRecordTypeSetRenderingOrigin     ,
    "EmfPlusSetAntiAliasMode"          , Gdiplus::EmfPlusRecordTypeSetAntiAliasMode       ,
    "EmfPlusSetTextRenderingHint"      , Gdiplus::EmfPlusRecordTypeSetTextRenderingHint   ,
    "EmfPlusSetTextContrast"           , Gdiplus::EmfPlusRecordTypeSetTextContrast        ,
    "EmfPlusSetInterpolationMode"      , Gdiplus::EmfPlusRecordTypeSetInterpolationMode   ,
    "EmfPlusSetPixelOffsetMode"        , Gdiplus::EmfPlusRecordTypeSetPixelOffsetMode     ,
    "EmfPlusSetCompositingMode"        , Gdiplus::EmfPlusRecordTypeSetCompositingMode     ,
    "EmfPlusSetCompositingQuality"     , Gdiplus::EmfPlusRecordTypeSetCompositingQuality  ,
    "EmfPlusSave"                      , Gdiplus::EmfPlusRecordTypeSave                   ,
    "EmfPlusRestore"                   , Gdiplus::EmfPlusRecordTypeRestore                ,
    "EmfPlusBeginContainer"            , Gdiplus::EmfPlusRecordTypeBeginContainer         ,
    "EmfPlusBeginContainerNoParams"    , Gdiplus::EmfPlusRecordTypeBeginContainerNoParams ,
    "EmfPlusEndContainer"              , Gdiplus::EmfPlusRecordTypeEndContainer           ,
    "EmfPlusSetWorldTransform"         , Gdiplus::EmfPlusRecordTypeSetWorldTransform      ,
    "EmfPlusResetWorldTransform"       , Gdiplus::EmfPlusRecordTypeResetWorldTransform    ,
    "EmfPlusMultiplyWorldTransform"    , Gdiplus::EmfPlusRecordTypeMultiplyWorldTransform ,
    "EmfPlusTranslateWorldTransform"   , Gdiplus::EmfPlusRecordTypeTranslateWorldTransform,
    "EmfPlusScaleWorldTransform"       , Gdiplus::EmfPlusRecordTypeScaleWorldTransform    ,
    "EmfPlusRotateWorldTransform"      , Gdiplus::EmfPlusRecordTypeRotateWorldTransform   ,
    "EmfPlusSetPageTransform"          , Gdiplus::EmfPlusRecordTypeSetPageTransform       ,
    "EmfPlusResetClip"                 , Gdiplus::EmfPlusRecordTypeResetClip              ,
    "EmfPlusSetClipRect"               , Gdiplus::EmfPlusRecordTypeSetClipRect            ,
    "EmfPlusSetClipPath"               , Gdiplus::EmfPlusRecordTypeSetClipPath            ,
    "EmfPlusSetClipRegion"             , Gdiplus::EmfPlusRecordTypeSetClipRegion          ,
    "EmfPlusOffsetClip"                , Gdiplus::EmfPlusRecordTypeOffsetClip             ,
    "EmfPlusDrawDriverString"          , Gdiplus::EmfPlusRecordTypeDrawDriverString       ,
};

/*
METAFUNCTIONS MetaFunctions[] = {

     "SETBKCOLOR",           0x0201,
     "SETBKMODE",            0x0102,
     "SETMAPMODE",           0x0103,
     "SETROP2",              0x0104,
     "SETRELABS",            0x0105,
     "SETPOLYFILLMODE",      0x0106,
     "SETSTRETCHBLTMODE",    0x0107,
     "SETTEXTCHAREXTRA",     0x0108,
     "SETTEXTCOLOR",         0x0209,
     "SETTEXTJUSTIFICATION", 0x020A,
     "SETWINDOWORG",         0x020B,
     "SETWINDOWEXT",         0x020C,
     "SETVIEWPORTORG",       0x020D,
     "SETVIEWPORTEXT",       0x020E,
     "OFFSETWINDOWORG",      0x020F,
     "SCALEWINDOWEXT",       0x0400,
     "OFFSETVIEWPORTORG",    0x0211,
     "SCALEVIEWPORTEXT",     0x0412,
     "LINETO",               0x0213,
     "MOVETO",               0x0214,
     "EXCLUDECLIPRECT",      0x0415,
     "INTERSECTCLIPRECT",    0x0416,
     "ARC",                  0x0817,
     "ELLIPSE",              0x0418,
     "FLOODFILL",            0x0419,
     "PIE",                  0x081A,
     "RECTANGLE",            0x041B,
     "ROUNDRECT",            0x061C,
     "PATBLT",               0x061D,
     "SAVEDC",               0x001E,
     "SETPIXEL",             0x041F,
     "OFFSETCLIPRGN",        0x0220,
     "TEXTOUT",              0x0521,
     "BITBLT",               0x0922,
     "STRETCHBLT",           0x0B23,
     "POLYGON",              0x0324,
     "POLYLINE",             0x0325,
     "ESCAPE",               0x0626,
     "RESTOREDC",            0x0127,
     "FILLREGION",           0x0228,
     "FRAMEREGION",          0x0429,
     "INVERTREGION",         0x012A,
     "PAINTREGION",          0x012B,
     "SELECTCLIPREGION",     0x012C,
     "SELECTOBJECT",         0x012D,
     "SETTEXTALIGN",         0x012E,
     "DRAWTEXT",             0x062F,
     "CHORD",                0x0830,
     "SETMAPPERFLAGS",       0x0231,
     "EXTTEXTOUT",           0x0a32,
     "SETDIBTODEV",          0x0d33,
     "SELECTPALETTE",        0x0234,
     "REALIZEPALETTE",       0x0035,
     "ANIMATEPALETTE",       0x0436,
     "SETPALENTRIES",        0x0037,
     "POLYPOLYGON",          0x0538,
     "RESIZEPALETTE",        0x0139,
     "DIBBITBLT",            0x0940,
     "DIBSTRETCHBLT",        0x0b41,
     "DIBCREATEPATTERNBRUSH",0x0142,
     "STRETCHDIB",           0x0f43,
     "DELETEOBJECT",         0x01f0,
     "CREATEPALETTE",        0x00f7,
     "CREATEBRUSH",          0x00F8,
     "CREATEPATTERNBRUSH",   0x01F9,
     "CREATEPENINDIRECT",    0x02FA,
     "CREATEFONTINDIRECT",   0x02FB,
     "CREATEBRUSHINDIRECT",  0x02FC,
     "CREATEBITMAPINDIRECT", 0x02FD,
     "CREATEBITMAP",         0x06FE,
     "CREATEREGION",         0x06FF,
};
*/

/***********************************************************************

  FUNCTION   : MetaEnumProc

  PARAMETERS : HDC           hDC
               LPHANDLETABLE lpHTable
               LPMETARECORD  lpMFR
               int           nObj
               LPARAM        lpClientData


  PURPOSE    : callback for EnumMetaFile.

  CALLS      : EnumMFIndirect()

  MESSAGES   : none

  RETURNS    : int

  COMMENTS   :

  HISTORY    : 1/16/91 - created - drc
               5/6/93  - modified for Win32 - denniscr

************************************************************************/

int CALLBACK MetaEnumProc(
HDC           hDC,
LPHANDLETABLE lpHTable,
LPMETARECORD  lpMFR,
int           nObj,
LPARAM        lpClientData)

{
  return EnumMFIndirect(hDC, lpHTable, lpMFR, NULL, nObj, lpClientData);
}

/***********************************************************************

  FUNCTION   : LoadParameterLB

  PARAMETERS : HWND  hDlg
           DWORD dwParams
           int   nRadix - HEX to display contents in base 16
                  DEC to display contents in base 10

  PURPOSE    : display the parameters of the metafile record in
           the parameter listbox

  CALLS      : WINDOWS
         GlobalLock
         GlobalUnlock
         SendDlgItemMessage
         wsprintf
         lstrlen

  MESSAGES   : WM_SETREDRAW
           WM_RESETCONTENT
           LB_ADDSTRING

  RETURNS    : BOOL

  COMMENTS   :

  HISTORY    : 1/16/91 - created - drc

************************************************************************/

BOOL LoadParameterLB(
HWND         hDlg,
DWORD        dwParams,
int          nRadix)
{
  DWORD i;
  BYTE nHiByte, nLoByte;
  BYTE nHiByteHi, nLoByteHi;
  WORD wHiWord, wLoWord;
  char szBuffer[40];
  char szDump[100];
  int  iValue = 0;
  DWORD dwValue = 0;

  switch (nRadix)  /* if nRadix is not a valid value, return FALSE */
  {
    case IDB_HEX:
    case IDB_DEC:
    case IDB_CHAR:
    case IDB_WORD:
        break;

    default :
        return FALSE;
  }
  //
  //init the strings
  //
  *szBuffer = '\0';
  *szDump = '\0';
  //
  //turn off redrawing of the listbox
  //
  SendDlgItemMessage(hDlg, IDL_PARAMETERS, WM_SETREDRAW, FALSE, 0L);
  //
  //reset the contents of the listbox
  //
  SendDlgItemMessage(hDlg, IDL_PARAMETERS, LB_RESETCONTENT, 0, 0L);

  // don't load an entire bitmap or other image into the dialog in hex
  if (dwParams > 1024)
  {
    dwParams = 1024;
  }

  if (bEnhMeta)
  {
    //
    //lock the memory where the parameters can be found
    //
    if (NULL == (lpEMFParams = (LPEMFPARAMETERS)GlobalLock(hMem)))
      return (FALSE);
    //
    //loop through the metafile record parameters
    //
    for (i = 0; i < dwParams; i++)
    {

      /* get the high and low byte of the parameter word */
      wHiWord = HIWORD(lpEMFParams[i]);
      wLoWord = LOWORD(lpEMFParams[i]);
      nLoByteHi = LOBYTE(wHiWord);
      nHiByteHi = HIBYTE(wHiWord);
      nLoByte   = LOBYTE(wLoWord);
      nHiByte   = HIBYTE(wLoWord);

      switch (nRadix)
      {
        case IDB_HEX: /* if we are to display as hexadecimal */
           /* format the bytes for the hex part of dump */
           wsprintf((LPSTR)szBuffer, (LPSTR)"%08x ", lpEMFParams[i]);
           break;

        case IDB_DEC:
           /* format the bytes for the decimal part of dump */
           dwValue = lpEMFParams[i];
           wsprintf((LPSTR)szBuffer, (LPSTR)"%lu ", dwValue );
           break;

        case IDB_CHAR:
           wsprintf((LPSTR)szBuffer, (LPSTR)"%c%c%c%c",
                    (nLoByte > 0x20) ? nLoByte : 0x2E,
                    (nHiByte > 0x20) ? nHiByte : 0x2E,
                    (nLoByteHi > 0x20) ? nLoByteHi : 0x2E,
                    (nHiByteHi > 0x20) ? nHiByteHi : 0x2E);
           break;

        case IDB_WORD: /* if we are to display as hexadecimal */
           /* format the bytes for the hex part of dump */
           wsprintf((LPSTR)szBuffer, (LPSTR)"%04x %04x ", wLoWord, wHiWord );
           break;


        default :
          return FALSE;
      }


      /* concatenate it onto whatever we have already formatted */
      lstrcat((LPSTR)szDump, (LPSTR)szBuffer);

      /* use every 8 words for hex/dec dump */
      if (!((i + 1) % 4))
      {

        /*add the string to the listbox */
        SendDlgItemMessage(hDlg, IDL_PARAMETERS, LB_ADDSTRING, 0, (LPARAM)(LPSTR)szDump);

        /* re-init the hex/dec strings in preparation for next 8 words */
        *szDump = '\0';
      }
    }


  }
  else
  {
    /* lock the memory where the parameters can be found */
    if (NULL == (lpMFParams = (LPPARAMETERS)GlobalLock(hMem)))
      return (FALSE);

    /* loop through the metafile record parameters */
    for (i = 0; i < dwParams; i++)
    {

      /* get the high and low byte of the parameter word */
      nHiByte = HIBYTE(lpMFParams[i]);
      nLoByte = LOBYTE(lpMFParams[i]);

      switch (nRadix)
      {
        case IDB_HEX: /* if we are to display as hexadecimal */
           /* format the bytes for the hex part of dump */
           wsprintf((LPSTR)szBuffer, (LPSTR)"%02x %02x ", nLoByte, nHiByte );
           break;

        case IDB_DEC:
           /* format the bytes for the decimal part of dump */
           iValue = lpMFParams[i];
           wsprintf((LPSTR)szBuffer, (LPSTR)"%d ", iValue );
           break;

        case IDB_CHAR:
           wsprintf((LPSTR)szBuffer, (LPSTR)"%c%c",
                    (nLoByte > 0x20) ? nLoByte : 0x2E,
                    (nHiByte > 0x20) ? nHiByte : 0x2E);
           break;

        case IDB_WORD: /* if we are to display as hexadecimal */
           /* format the bytes for the hex part of dump */
           wsprintf((LPSTR)szBuffer, (LPSTR)"%02x%02x ", nHiByte, nLoByte );
           break;

        default :
          return FALSE;
      }


      /* concatenate it onto whatever we have already formatted */
      lstrcat((LPSTR)szDump, (LPSTR)szBuffer);

      /* use every 8 words for hex/dec dump */
      if (!((i + 1) % 8))
      {

        /*add the string to the listbox */
        SendDlgItemMessage(hDlg, IDL_PARAMETERS, LB_ADDSTRING, 0, (LPARAM)(LPSTR)szDump);

        /* re-init the hex/dec strings in preparation for next 8 words */
        *szDump = '\0';
      }
    }
  } //else
  //
  //dump any leftover hex/dec dump
  //
  if (lstrlen((LPSTR)szDump))
    SendDlgItemMessage(hDlg, IDL_PARAMETERS, LB_ADDSTRING, 0, (LPARAM)(LPSTR)szDump);
  //
  //enable redraw to the listbox
  //
  SendDlgItemMessage(hDlg, IDL_PARAMETERS, WM_SETREDRAW, TRUE, 0L);
  //
  //redraw it
  //
  InvalidateRect(GetDlgItem(hDlg,IDL_PARAMETERS), NULL, TRUE);
  //
  //unlock the memory used for the parameters
  //
  GlobalUnlock(hMem);

  return (TRUE);

}

extern "C"
void GetMetaFileAndEnum(
    HWND hwnd,
    HDC hDC,
    int iAction);

/***********************************************************************

  FUNCTION   : PlayMetaFileToDest

  PARAMETERS : HWND hWnd
               int  nDest - DC to play metafile to
                 DESTDISPLAY - play to the display
                 DESTMETA    - play into another metafile

  PURPOSE    : begin the enumeration of the metafile to the user selected
               destination.  Perform the housekeeping needs appropriate
               to that destination.

  CALLS      : WINDOWS
                 GetClientRect
                 InvalidateRect
                 GetDC
                 SetMapMode
                 OpenFileDialog
                 MessageBox
                 CreateMetaFile
                 DeleteMetaFile
                 CloseMetaFile

               APP
                 WaitCursor
                 SetClipMetaExts
                 SetPlaceableExts
                 GetMetaFileAndEnum

  MESSAGES   : none

  RETURNS    : int

  COMMENTS   :

  HISTORY    : 1/16/91 - created - drc

************************************************************************/

BOOL PlayMetaFileToDest(
HWND hWnd,
int  nDest)
{
  HDC hDC;
  RECT rect;
  int iSaveRet;
  //
  //if the file opened contained a valid metafile
  //
  if (bValidFile)
  {
    //
    //init the record count
    //
    iRecNum = 0;
    //
    //if we are stepping the metafile then clear the client area
    //
    if (!bPlayItAll)
    {
      GetClientRect(hWnd, (LPRECT)&rect);
      InvalidateRect(hWnd, (LPRECT)&rect, TRUE);
    }

    switch (nDest)
    {
      //
      //playing metafile to the display
      //
      case DESTDISPLAY:
        WaitCursor(TRUE);
        hDC = GetDC(hWnd);

        if (!bUseGdiPlusToPlay)
        {
            //
            //metafile read in from a clipboard file
            //
            if ( bMetaInRam && !bPlaceableMeta && !bEnhMeta)
              SetClipMetaExts(hDC, lpMFP, lpOldMFP, WMFDISPLAY);
            //
            //Windows placeable metafile
            //
            if (bPlaceableMeta && !bEnhMeta)
                SetPlaceableExts(hDC, placeableWMFHeader, WMFDISPLAY);
            //
            //Windows metafile
            //
            if (!bMetaInRam && !bEnhMeta)
            {
                SetNonPlaceableExts(hDC, WMFDISPLAY);
            }
        }
        //
        //begin the enumeration of the metafile
        //

        DWORD start, end;
        DWORD renderTime;
        char tmpBuf[512];

        start = GetTickCount();

        GetMetaFileAndEnum(hWnd, hDC, ENUMMFSTEP);

        end = GetTickCount();
        renderTime = end - start;
        wsprintf(tmpBuf, "Time: %d", renderTime);

        SetWindowText(hWnd, tmpBuf);

        ReleaseDC(hWnd, hDC);
        WaitCursor(FALSE);
        break;

    case DESTMETA:
        //
        //get a name of a file to play the metafile into
        //
        iSaveRet = SaveFileDialog((LPSTR)SaveName, (LPSTR)gszSaveEMFFilter);
        //
        //if the file selected is this metafile then warn user
        //
        if (!lstrcmp((LPSTR)OpenName, (LPSTR)SaveName))
          MessageBox(hWnd, (LPSTR)"Cannot overwrite the opened metafile!",
                           (LPSTR)"Play to Metafile", MB_OK | MB_ICONEXCLAMATION);

        else
          //
          //the user didn't hit the cancel button
          //
          if (iSaveRet)
          {
            WaitCursor(TRUE);
            //
            //create a disk based metafile
            //
            hDC = (bEnhMeta) ? CreateEnhMetaFile(NULL, (LPSTR)SaveName, NULL, NULL)
                             : CreateMetaFile((LPSTR)SaveName);
            //
            //begin the enumeration of the metafile
            //
            GetMetaFileAndEnum(hWnd, hDC, ENUMMFSTEP);
            //
            //done playing so close the metafile and delete the handle
            //
            if (bEnhMeta)
              DeleteEnhMetaFile(CloseEnhMetaFile(hDC));
            else
              DeleteMetaFile(CloseMetaFile(hDC));

            WaitCursor(FALSE);
          }

        break;

    case DESTDIB:
        {
            /* extents for the display DC */
            GetClientRect(hWndMain, &rect);
            INT cx = rect.right - rect.left;
            INT cy = rect.bottom - rect.top;

    /*        SetMapMode(hDC, ((lpOldMFP != NULL) ? lpOldMFP->mm : lpMFP->mm));

            SetViewportOrgEx(hDC, 0, 0, &lpPT);
     */

            WaitCursor(TRUE);
            hDC = GetDC(hWnd);
            BITMAPINFOHEADER bmi;
            memset(&bmi, 0, sizeof(BITMAPINFOHEADER));
            bmi.biSize = sizeof(BITMAPINFOHEADER);
            bmi.biBitCount = 24;
            bmi.biWidth = cx;
            bmi.biHeight = -cy;
            bmi.biPlanes = 1;

            VOID* bits = NULL;

            HBITMAP hBmp = CreateDIBSection(hDC, (BITMAPINFO*) &bmi, 0, &bits, NULL, 0);
            HDC hDCBmp = CreateCompatibleDC(hDC);
            ::SelectObject(hDCBmp, hBmp);

            FillRect(hDCBmp, &rect, (HBRUSH) ::GetStockObject(GRAY_BRUSH));

            if (!bUseGdiPlusToPlay)
            {
                //
                //metafile read in from a clipboard file
                //
                if ( bMetaInRam && !bPlaceableMeta && !bEnhMeta)
                  SetClipMetaExts(hDCBmp, lpMFP, lpOldMFP, WMFDISPLAY);
                //
                //Windows placeable metafile
                //
                if (bPlaceableMeta && !bEnhMeta)
                    SetPlaceableExts(hDCBmp, placeableWMFHeader, WMFDISPLAY);
                //
                //Windows metafile
                //
                if (!bMetaInRam && !bEnhMeta)
                {
                    SetNonPlaceableExts(hDCBmp, WMFDISPLAY);
                }
            }
            //
            //begin the enumeration of the metafile
            //

            start = GetTickCount();

            GetMetaFileAndEnum(hWnd, hDCBmp, ENUMMFSTEP);


            end = GetTickCount();
            renderTime = end - start;
            wsprintf(tmpBuf, "Time: %d", renderTime);

            SetWindowText(hWnd, tmpBuf);
            StretchDIBits(hDC, 0, 0, cx, cy, 0, 0, cx, cy, bits, (BITMAPINFO*)&bmi, 0, SRCCOPY);
            DeleteDC(hDCBmp);
            DeleteObject((HGDIOBJ) hBmp);

            ReleaseDC(hWnd, hDC);
            WaitCursor(FALSE);
            break;

        }
    case DESTPRN:
{
    HDC hPr = (HDC)NULL;
    PRINTDLG pd;

    memset(&pd, 0, sizeof(PRINTDLG));
    pd.lStructSize = sizeof(PRINTDLG);
    pd.Flags = PD_RETURNDC;
    pd.hwndOwner = hWndMain;

    //
    //get a DC for the printer
    //

    if (PrintDlg(&pd) != 0)
        hPr= pd.hDC;
    else
        break;

    //
    //if a DC could not be created then report the error and return
    //

    if (!hPr)
    {
        WaitCursor(FALSE);
        wsprintf((LPSTR)str, "Cannot print %s", (LPSTR)fnameext);
        MessageBox(hWndMain, (LPSTR)str, NULL, MB_OK | MB_ICONHAND);
        break;
    }

    //
    //define the abort function
    //

    SetAbortProc(hPr, AbortProc);

    //
    //Initialize the members of a DOCINFO structure.
    //

    DOCINFO di;
    memset(&di, 0, sizeof(di));
    di.cbSize = sizeof(DOCINFO);
    di.lpszDocName = (bEnhMeta) ? "Print EMF" : "Print WMF";
    di.lpszOutput = (LPTSTR) NULL;

    //
    //Begin a print job by calling the StartDoc
    //function.
    //

    if (SP_ERROR == (StartDoc(hPr, &di)))
    {
        //if (Escape(hPr, STARTDOC, 4, "Metafile", (LPSTR) NULL) < 0)  {
        MessageBox(hWndMain, "Unable to start print job",
                   NULL, MB_OK | MB_ICONHAND);
        DeleteDC(hPr);
        break;
    }

    //
    //clear the abort flag
    //

    bAbort = FALSE;

    //
    //Create the Abort dialog box (modeless)
    //

    hAbortDlgWnd = CreateDialog((HINSTANCE)hInst, "AbortDlg", hWndMain, AbortDlg);

    //
    //if the dialog was not created report the error
    //

    if (!hAbortDlgWnd)
    {
        WaitCursor(FALSE);
        MessageBox(hWndMain, "NULL Abort window handle",
                   NULL, MB_OK | MB_ICONHAND);
        break;
    }

    //
    //show Abort dialog
    //

    ShowWindow (hAbortDlgWnd, SW_NORMAL);

    //
    //disable the main window to avoid reentrancy problems
    //

    EnableWindow(hWndMain, FALSE);
    WaitCursor(FALSE);

    //
    //if we are still committed to printing
    //
       if (!bUseGdiPlusToPlay)
        {
            //
            //if this is a placeable metafile then set its origins and extents
            //

            if (bPlaceableMeta)
                SetPlaceableExts(hPr, placeableWMFHeader, WMFPRINTER);

            //
            //if this is a metafile contained within a clipboard file then set
            //its origins and extents accordingly
            //

            if ( (bMetaInRam) && (!bPlaceableMeta) )
                SetClipMetaExts(hPr, lpMFP, lpOldMFP, WMFPRINTER);
        }

      //
      //if this is a "traditional" windows metafile
      //
      RECT rc;

      rc.left = 0;
      rc.top = 0;
      rc.right = GetDeviceCaps(hPr, HORZRES);
      rc.bottom = GetDeviceCaps(hPr, VERTRES);

      POINT lpPT;
      SIZE lpSize;
      if (TRUE || !bMetaInRam)
      {
          SetMapMode(hPr, MM_TEXT);
          SetViewportOrgEx(hPr, 0, 0, &lpPT);

          //
          //set the extents to the driver supplied values for horizontal
          //and vertical resolution
          //

          SetViewportExtEx(hPr, rc.right, rc.bottom, &lpSize );
      }

      //
      //play the metafile directly to the printer.
      //No enumeration involved here
      //

      GetMetaFileAndEnum(hWnd, hPr, ENUMMFSTEP);

    //
    //eject page and end the print job
    //
    Escape(hPr, NEWFRAME, 0, 0L, 0L);

    EndDoc(hPr);

    EnableWindow(hWndMain, TRUE);

    //
    //destroy the Abort dialog box
    //
    DestroyWindow(hAbortDlgWnd);

    DeleteDC(hPr);

}


    default:
        break;
    }
    //
    //if playing list records then free the memory used for the list of
    //selected records
    //
    if (bPlayList)
    {
      GlobalUnlock(hSelMem);
      GlobalFree(hSelMem);
      bPlayList = FALSE;
    }
    //
    //success
    //
    return (TRUE);
  }
  else
    //
    //not a valid metafile
    //
    return (FALSE);
}

/***********************************************************************

  FUNCTION   : RenderClipMeta

  PARAMETERS : CLIPFILEFORMAT   *ClipHeader
               int          fh

  PURPOSE    : read metafile bits, metafilepict and metafile header
               of the metafile contained within a clipboard file

  CALLS      : WINDOWS
                 GlobalAlloc
                 GlobalLock
                 GlobalUnlock
                 GlobalFree
                 MessageBox
                 _llseek
                 _lread
                 _lclose
                 SetMetaFileBits

  MESSAGES   : none

  RETURNS    : BOOL

  COMMENTS   :

  HISTORY    : 1/16/91 - created - drc
               5/23/93 - ported to NT.  it must handle 3.1 clipboard
                         as well as NT clipboard files - drc

************************************************************************/

BOOL RenderClipMeta(LPVOID lpvClipHeader, int fh, WORD ClipID)
{
  int               wBytesRead;
  long              lBytesRead;
  long              lSize;
  DWORD             lOffset;
  DWORD             dwSizeOfMetaFilePict;
  BOOL              bEMF = FALSE;
  LPNTCLIPFILEFORMAT lpNTClp;
  LPCLIPFILEFORMAT    lpClp;
  //
  //cast the void ptr to the clipfile header appropriately
  //
  if (bEnhMeta)
  {
    lpNTClp = (LPNTCLIPFILEFORMAT)lpvClipHeader;
    bEMF = TRUE;
  }
  else
    lpClp = (LPCLIPFILEFORMAT)lpvClipHeader;
  //
  //obtain the appropriate size of the metafilepict. win16 vs win32
  //
  dwSizeOfMetaFilePict = (ClipID == CLP_ID) ?
              sizeof(OLDMETAFILEPICT) :
              sizeof(METAFILEPICT);
  //
  //free any memory already allocated for the METAFILEPICT
  //
  if (lpMFP != NULL || lpOldMFP != NULL)
  {
    GlobalFreePtr(lpMFP);
    lpMFP = NULL;
  }
  //
  //allocate enough memory to read the metafile bits into
  //
  if (!(lpMFBits = (char*)GlobalAllocPtr(GHND, ((bEMF) ? lpNTClp->DataLen
                                            : lpClp->DataLen - dwSizeOfMetaFilePict))))
    return(FALSE);
  //
  //offset to the metafile bits
  //
  lOffset = ((bEMF) ? lpNTClp->DataOffset : lpClp->DataOffset + dwSizeOfMetaFilePict );
  //
  //size of metafile bits
  //
  lSize = (long)( ((bEMF) ? lpNTClp->DataLen : lpClp->DataLen - dwSizeOfMetaFilePict));
  //
  //seek to the beginning of the metafile bits
  //
  _llseek(fh, lOffset, 0);
  //
  //read the metafile bits
  //
  lBytesRead = _hread(fh, lpMFBits, lSize);
  //
  //if unable to read the metafile bits bail out
  //
  if( lBytesRead == -1 || lBytesRead < lSize)
  {
    GlobalFreePtr(lpMFBits);
    MessageBox(hWndMain, "Unable to read metafile bits",
                     NULL, MB_OK | MB_ICONHAND);
    return(FALSE);
  }
  //
  //return to beginning to read metafile header
  //
  _llseek(fh, lOffset, 0);
  //
  //read the metafile header
  //
  if (!bEMF)
    wBytesRead = _lread(fh, (LPSTR)&mfHeader, sizeof(METAHEADER));
  else
    wBytesRead = _lread(fh, (LPSTR)&emfHeader, sizeof(ENHMETAHEADER));
  //
  //if unable to read the header return
  //
  if( wBytesRead == -1 || (WORD)wBytesRead < ((bEMF) ? sizeof(ENHMETAHEADER) : sizeof(METAHEADER)) )
  {
    MessageBox(hWndMain, "Unable to read metafile header",
                     NULL, MB_OK | MB_ICONHAND);
    return(FALSE);
  }
  //
  //set the metafile bits to the memory allocated for that purpose
  //
  if (bEMF)
    //
    //win32
    //
    hemf = SetEnhMetaFileBits(GlobalSizePtr(lpMFBits), (const unsigned char *)lpMFBits);
  else
    //
    //win16
    //
    hMF  = SetMetaFileBitsEx(GlobalSizePtr(lpMFBits), (const unsigned char *)lpMFBits);

  if ( NULL == ((bEMF) ? hemf : hMF))
  {
    MessageBox(hWndMain, "Unable to set metafile bits",
               NULL, MB_OK | MB_ICONHAND);

    return(FALSE);
  }
  //
  //allocate memory for the metafile pict structure
  //
  if (!(hMFP = GlobalAlloc(GHND, dwSizeOfMetaFilePict)))
  {
    MessageBox(hWndMain, "Unable allocate memory for metafile pict",
                     NULL, MB_OK | MB_ICONHAND);
    return(FALSE);
  }
  //
  //lock the memory
  //
  if (ClipID == CLP_ID)
    lpOldMFP = (LPOLDMETAFILEPICT)GlobalLock(hMFP);
  else
    lpMFP = (LPMETAFILEPICT)GlobalLock(hMFP);

  if (!lpMFP && !lpOldMFP)
    {
      MessageBox(hWndMain, "unable to lock metafile pict memory",
                     NULL, MB_OK | MB_ICONHAND);
      GlobalFree(hMFP);
      return(FALSE);
    }
  //
  //reposition to the start of the METAFILEPICT header.
  //
  _llseek(fh, ((bEMF) ? lpNTClp->DataOffset : lpClp->DataOffset), 0);
  //
  //read the metafile pict structure
  //
  wBytesRead = _lread(fh, ((ClipID == CLP_ID) ? (LPVOID)lpOldMFP : (LPVOID)lpMFP),
              dwSizeOfMetaFilePict);
  //
  //if unable to read, return
  //
  if( wBytesRead == -1 || wBytesRead < (long)dwSizeOfMetaFilePict)  {
    MessageBox(hWndMain, "Unable to read metafile pict",
             NULL, MB_OK | MB_ICONHAND);
    GlobalUnlock(hMFP);
    GlobalFree(hMFP);
    return(FALSE);
  }

  if (bEnhMeta)
    GetEMFCoolStuff();
//DENNIS - check this out....

  /* update metafile handle */
  if (ClipID == CLP_ID)
     lpOldMFP->hMF = (WORD)hMF;
  else
     lpMFP->hMF = (HMETAFILE)hemf;

  return(TRUE);
}

/***********************************************************************

  FUNCTION   : RenderPlaceableMeta

  PARAMETERS : int fh - filehandle to the placeable metafile

  PURPOSE    : read the metafile bits, metafile header and placeable
               metafile header of a placeable metafile.

  CALLS      : WINDOWS
                 GlobalAlloc
                 GlobalLock
                 Global
                 DeleteMetaFile
                 SetMetaFileBits
                 _llseek
                 _lread
                 _lclose
                 MessageBox


  MESSAGES   : none

  RETURNS    : BOOL

  COMMENTS   :

  HISTORY    : 1/16/91 - created - drc
               7/1/93 - modified for win32 - denniscr

************************************************************************/

BOOL RenderPlaceableMeta(
int fh)
{
  int      wBytesRead;
  long     lBytesRead;
  DWORD    dwSize;
  //
  //if there is currently a metafile loaded, get rid of it
  //
  if (bMetaInRam && hMF && !bEnhMeta)
    DeleteMetaFile((HMETAFILE)hMF);
  //
  //seek to beginning of file and read placeable header
  //
  _llseek(fh, 0, 0);
  //
  //read the placeable header
  //
  wBytesRead = _lread(fh, (LPSTR)&placeableWMFHeader, sizeof(PLACEABLEWMFHEADER));
  //
  //if there is an error, return
  //
  if( wBytesRead == -1 || wBytesRead < sizeof(PLACEABLEWMFHEADER) )  {
    MessageBox(hWndMain, "Unable to read placeable header",
                     NULL, MB_OK | MB_ICONHAND);
    return(FALSE);
  }
  //
  //return to read metafile header
  //
  _llseek(fh, sizeof(placeableWMFHeader), 0);
  //
  //read the metafile header
  //
  wBytesRead = _lread(fh, (LPSTR)&mfHeader, sizeof(METAHEADER));
  //
  //if there is an error return
  //
  if( wBytesRead == -1 || wBytesRead < sizeof(METAHEADER) )  {
    MessageBox(hWndMain, "Unable to read metafile header",
                     NULL, MB_OK | MB_ICONHAND);
    return(FALSE);
  }
  //
  //allocate memory for the metafile bits
  //
  if (!(lpMFBits = (char *)GlobalAllocPtr(GHND, (mfHeader.mtSize * 2L))))
  {
    MessageBox(hWndMain, "Unable to allocate memory for metafile bits",
                     NULL, MB_OK | MB_ICONHAND);
    return(FALSE);
  }
  //
  //seek to the metafile bits
  //
  _llseek(fh, sizeof(placeableWMFHeader), 0);
  //
  //read metafile bits
  //
  lBytesRead = _hread(fh, lpMFBits, mfHeader.mtSize * 2);
  //
  //if there was an error
  //
  if( lBytesRead == -1 )
  {
     MessageBox(hWndMain, "Unable to read metafile bits",
                NULL, MB_OK | MB_ICONHAND);
     GlobalFreePtr(lpMFBits);
     return(FALSE);
  }
  //
  //set the metafile bits to the memory that we allocated
  //
  dwSize = GlobalSizePtr(lpMFBits);

  if (!(hMF = SetMetaFileBitsEx(dwSize, (const unsigned char *)lpMFBits)))
    return(FALSE);

  return(TRUE);
}

/***********************************************************************

  FUNCTION   : SetPlaceableExts

  PARAMETERS : HDC               hDC
               PLACEABLEWMFHEADER phdr
               int               nDest

  PURPOSE    : set the origins and extents on the DC to correspond with
               the origins and extents specified within the placeable
               metafile header

  CALLS      : WINDOWS
                 GetClientRect
                 SetMapMode
                 SetWindowOrg
                 SetWindowExt
                 SetViewportOrg
                 SetViewportExt

               C runtime
                 labs

  MESSAGES   : none

  RETURNS    : void

  COMMENTS   :

  HISTORY    : 1/16/91 - created - drc

************************************************************************/

void SetPlaceableExts(HDC hDC, PLACEABLEWMFHEADER phdr, int nDest)
{
  RECT        rect;
  POINT       lpPT;
  SIZE        lpSize;

  /* if setting the extents on the display DC */
  if (nDest != WMFPRINTER)
    GetClientRect(hWndMain, &rect);

  SetMapMode(hDC, MM_ANISOTROPIC);

  /* set the windows origin to correspond to the bounding box origin
     contained in the placeable header */
  SetWindowOrgEx(hDC, phdr.bbox.left, phdr.bbox.top, &lpPT);

  /* set the window extents based on the abs value of the bbox coords */
  SetWindowExtEx(hDC,phdr.bbox.right -phdr.bbox.left,
           phdr.bbox.bottom -phdr.bbox.top,
           &lpSize);

  /* set the viewport origin and extents */
  if (nDest != WMFPRINTER)
    {
      SetViewportOrgEx(hDC, 0, 0, &lpPT);
      SetViewportExtEx(hDC, rect.right, rect.bottom, &lpSize);
    }
  else
    {
      SetViewportOrgEx(hPr, 0, 0, &lpPT);
      SetViewportExtEx(hPr,GetDeviceCaps(hPr, HORZRES),
             GetDeviceCaps(hPr, VERTRES),
             &lpSize);
    }
}

void SetNonPlaceableExts(HDC hDC, int nDest)
{
  RECT        rect;
  POINT       lpPT;
  SIZE        lpSize;

  /* if setting the extents on the display DC */
  if (nDest != WMFPRINTER)
    GetClientRect(hWndMain, &rect);

  SetMapMode(hDC, MM_ANISOTROPIC);

  /* set the viewport origin and extents */
  if (nDest != WMFPRINTER)
    {
      SetViewportOrgEx(hDC, 0, 0, &lpPT);
      SetViewportExtEx(hDC, rect.right, rect.bottom, &lpSize);
    }
  else
    {
      SetViewportOrgEx(hPr, 0, 0, &lpPT);
      SetViewportExtEx(hPr,GetDeviceCaps(hPr, HORZRES),
             GetDeviceCaps(hPr, VERTRES),
             &lpSize);
    }
}


/***********************************************************************

  FUNCTION   : SetClipMetaExts

  PARAMETERS : HDC          hDC
               METAFILEPICT MFP
               int          nDest

  PURPOSE    : set the extents to the client rect for clipboard metafiles

  CALLS      : WINDOWS
                 GetClientRect
                 IntersectClipRect
                 SetMapMode
                 SetViewportOrg
                 SetViewportExt
                 SetWindowExt

  MESSAGES   : none

  RETURNS    : void

  COMMENTS   : this is not as robust as it could be.  A more complete
               approach might be something like Petzold discusses in
               his Programming Windows book on page 793 in the
               function PrepareMetaFile().

  HISTORY    : 1/16/91 - created - drc

************************************************************************/

void SetClipMetaExts(
HDC       hDC,
LPMETAFILEPICT    lpMFP,
LPOLDMETAFILEPICT lpOldMFP,
int       nDest)
{
  int   cx, cy;
  RECT  rect;
  POINT lpPT;
  SIZE  lpSize;
  long  lmm;
  long  lxExt;
  long  lyExt;

  /* extents for the display DC */
  if (nDest != WMFPRINTER)
    {
      GetClientRect(hWndMain, &rect);
      cx = rect.right - rect.left;
      cy = rect.bottom - rect.top;
      IntersectClipRect(hDC, rect.left, rect.top, rect.right, rect.bottom);
    }

  SetMapMode(hDC, ((lpOldMFP != NULL) ? lpOldMFP->mm : lpMFP->mm));

  /* set physical origin to 0, 0 */
  SetViewportOrgEx(hDC, 0, 0, &lpPT);

  /* given the mapping mode specified in the metafilepict */
  lmm = (lpOldMFP != NULL) ? lpOldMFP->mm : lpMFP->mm;
  lxExt = (lpOldMFP != NULL) ? lpOldMFP->xExt : lpMFP->xExt;
  lyExt = (lpOldMFP != NULL) ? lpOldMFP->yExt : lpMFP->yExt;

  switch (lmm)  {
    case MM_ISOTROPIC:
      if (lxExt && lyExt)
    SetWindowExtEx(hDC, lxExt, lyExt, &lpSize);

        /* fall through */

    case MM_ANISOTROPIC:
      if (nDest != WMFPRINTER)
    SetViewportExtEx(hDC, cx, cy, &lpSize);
      else
    SetViewportExtEx(hDC, GetDeviceCaps(hDC, HORZRES),
                GetDeviceCaps(hDC, VERTRES), &lpSize );
    break;

    default:
      break;
  }

}

/***********************************************************************

  FUNCTION   : ProcessFile

  PARAMETERS : HWND  hWnd
               LPSTR lpFileName

  PURPOSE    : open the metafile, determine if it contains a valid
               metafile, decide what type of metafile it is (wmf,
               clipboard, or placeable) and take care of some menu
               housekeeping tasks.

  CALLS      :

  MESSAGES   : none

  RETURNS    : BOOL

  COMMENTS   :

  HISTORY    : 1/16/91 - created - drc

************************************************************************/

BOOL ProcessFile(
HWND  hWnd,
LPSTR lpFileName)
{
  //
  //for openfiledialog
  //
  char drive[3];
  char dir[MAX_PATH+1];
  char fname[MAX_PATH+1];
  char ext[5];

  char * pchCorrectSir;
  //
  //initialize these global handles to metafiles
  //
  if (hMF && !bMetaInRam)
  {
    DeleteMetaFile((HMETAFILE)hMF);
    hMF = NULL;
  }
  if (hemf && !bMetaInRam)
  {
    DeleteEnhMetaFile(hemf);
    hemf = NULL;
  }

  if (lpMFBits)
  {
    GlobalFreePtr(lpMFBits);
    lpMFBits = NULL;
    hemf = NULL;
    hMF = NULL;
  }

  bEnhMeta = FALSE;
  //
  //split the fully qualified filename into its components
  //
  SplitPath( lpFileName, (LPSTR)drive,
          (LPSTR)dir, (LPSTR)fname, (LPSTR)ext);

  pchCorrectSir = _strupr( _strdup( ext ) );
  //
  //if the memory for the emf header, desc string and palette
  //is still around then nuke it
  //
  if (EmfPtr.lpEMFHdr)
  {
    GlobalFreePtr(EmfPtr.lpEMFHdr);
    EmfPtr.lpEMFHdr = NULL ;
  }
  if (EmfPtr.lpDescStr)
  {
    GlobalFreePtr(EmfPtr.lpDescStr);
    EmfPtr.lpDescStr = NULL ;
  }
  if (EmfPtr.lpPal)
  {
    GlobalFreePtr(EmfPtr.lpPal);
    EmfPtr.lpPal = NULL ;
  }
  //
  //if the file is an enhanced metafile
  //
  if (lstrcmp((LPSTR)pchCorrectSir, (LPSTR)"CLP") == 0)
    return ProcessCLP(hWnd, lpFileName);
  //
  //if the file is a Windows metafile or a Windows or placeable metafile
  //as per the normal naming conventions
  //
  if (lstrcmp((LPSTR)pchCorrectSir, (LPSTR)"WMF") == 0)
    return ProcessWMF(hWnd, lpFileName);
  //
  //if the file is a clipboard file
  //
  if (lstrcmp((LPSTR)pchCorrectSir, (LPSTR)"EMF") == 0)
    return ProcessEMF(hWnd, lpFileName);

  return FALSE;
}

/***********************************************************************

  FUNCTION   : ProcessWMF

  PARAMETERS : HWND  hWnd
               LPSTR lpFileName

  PURPOSE    : open the metafile and determine if it is a Windows metafile or
               placeable metafile.  Then take care of some menu housekeeping
               tasks.

  CALLS      :

  MESSAGES   : none

  RETURNS    : BOOL

  COMMENTS   :

  HISTORY    : 6/23/93 - created - drc

************************************************************************/

BOOL ProcessWMF(HWND hWnd, LPSTR lpFileName)
{
  int        fh;
  int        wBytesRead;
  DWORD      dwIsPlaceable;
  char       szCaption[144];

  /* for openfiledialog */
  char drive[3];
  char dir[MAX_PATH+1];
  char fname[MAX_PATH+1];
  char ext[5];
  char * pchCorrectSir;
    //
    //split the fully qualified filename into its components
    //
    SplitPath( lpFileName, (LPSTR)drive,
            (LPSTR)dir, (LPSTR)fname, (LPSTR)ext);

    pchCorrectSir = _strupr( _strdup( ext ) );
    //
    //try to open the file.  It's existence has already been
    //checked by OpenFileDialog
    //
    fh = _lopen(lpFileName, OF_READ);
    //
    //if opened successfully
    //
    if (fh != -1)
    {
      //
      //always disable the clipboard and EMF header menu if we get here
      //
      EnableMenuItem(GetMenu(hWnd), IDM_CLIPHDR, MF_DISABLED | MF_GRAYED);
      EnableMenuItem(GetMenu(hWnd), IDM_ENHHEADER, MF_DISABLED | MF_GRAYED);
      //
      // read the first dword of the file to see if it is a placeable wmf
      //
      wBytesRead = _lread(fh,(LPSTR)&dwIsPlaceable, sizeof(dwIsPlaceable));

      if (wBytesRead == -1 || wBytesRead < sizeof(dwIsPlaceable))
      {
        _lclose(fh);
        MessageBox(hWndMain, "unable to read file", NULL,
                   MB_OK | MB_ICONEXCLAMATION);
        return (FALSE);

      }
      //
      // if this is windows metafile, not a placeable wmf
      //
      if (dwIsPlaceable != PLACEABLEKEY)
      {
        //  if (!bMetaInRam)
        hMF = GetMetaFile((LPSTR)OpenName);
        //
        //disable placeable header menu item
        //
        EnableMenuItem(GetMenu(hWnd), IDM_PLACEABLEHDR, MF_DISABLED|MF_GRAYED);
        //
        //seek to the beginning of the file
        //
        _llseek(fh, 0, 0);
        //
        //read the wmf header
        //
        wBytesRead = _lread(fh, (LPSTR)&mfHeader, sizeof(METAHEADER));
        //
        //done with file so close it
        //
        _lclose(fh);
        //
        //if read failed
        //
        if (wBytesRead == -1 || wBytesRead < sizeof(dwIsPlaceable))
        {
          MessageBox(hWndMain, "unable to read metafile header", NULL,
                     MB_OK | MB_ICONEXCLAMATION);
          return (FALSE);
        }
      }
      //
      //this is a placeable metafile
      //
      else
      {
        //
        //enable the placeable header menu item
        //
        EnableMenuItem(GetMenu(hWnd), IDM_PLACEABLEHDR, MF_ENABLED);
        //
        //convert the placeable format into something that can
        //be used with GDI metafile functions
        //
        RenderPlaceableMeta(fh);
        //
        //close the file
        //
        _lclose(fh);

      }
      //
      //at this point we have a metafile header regardless of whether
      //the metafile was a windows metafile or a placeable metafile
      //so check to see if it is valid.  There is really no good
      //way to do this so just make sure that the mtType is either
      //1 or 2 (memory or disk file)
      //
      if ( (mfHeader.mtType != 1) && (mfHeader.mtType != 2) )
      {
        //
        //set the program flags appropriately
        //
        bBadFile = TRUE;
        bMetaFileOpen = FALSE;
        bValidFile = FALSE;
        //
        //let the user know that this is an invalid metafile
        //
        MessageBox(hWndMain, "This file is not a valid metafile",
                   NULL, MB_OK | MB_ICONEXCLAMATION);
        //
        //restore the caption text to the default
        //
        SetWindowText(hWnd, (LPSTR)APPNAME);
        //
        //disable menu items, indicating that a valid metafile has not been
        //loaded
        //
        EnableMenuItem(GetMenu(hWnd), IDM_VIEW, MF_DISABLED|MF_GRAYED|MF_BYPOSITION);
        EnableMenuItem(GetMenu(hWnd), IDM_PLAY, MF_DISABLED|MF_GRAYED|MF_BYPOSITION);
        EnableMenuItem(GetMenu(hWnd), IDM_PRINT, MF_DISABLED|MF_GRAYED);
        EnableMenuItem(GetMenu(hWnd), IDM_PRINTDLG, MF_DISABLED|MF_GRAYED);
        EnableMenuItem(GetMenu(hWnd), IDM_SAVEAS, MF_DISABLED|MF_GRAYED);
        //
        //refresh the menu bar to reflect above changes
        //
        DrawMenuBar(hWnd);
      }
      //
      //this is a valid metafile...at least based on the above criteria
      //
      else
      {
        //
        //modify and update the caption text
        //
        wsprintf((LPSTR)szCaption, (LPSTR)"%s - %s.%s",
                 (LPSTR)APPNAME, (LPSTR)fname, (LPSTR)ext);
        //
        //this could be used by the printing routines if unable to print
        //
        wsprintf((LPSTR)fnameext, (LPSTR)"%s.%s", (LPSTR)fname, (LPSTR)ext);

        SetWindowText(hWnd, (LPSTR)szCaption);
        //
        //enable the appropriate menu items
        //
        EnableMenuItem(GetMenu(hWnd), IDM_VIEW, MF_ENABLED|MF_BYPOSITION);
        EnableMenuItem(GetMenu(hWnd), IDM_PLAY, MF_ENABLED|MF_BYPOSITION);
        EnableMenuItem(GetMenu(hWnd), IDM_PRINT, MF_ENABLED);
        EnableMenuItem(GetMenu(hWnd), IDM_PRINTDLG, MF_ENABLED);
        EnableMenuItem(GetMenu(hWnd), IDM_SAVEAS, MF_ENABLED);
        EnableMenuItem(GetMenu(hWnd), IDM_HEADER, MF_ENABLED);
        //
        //refresh the menu bar to reflect above changes
        //
        DrawMenuBar(hWnd);
        //
        //set global flags appropriately
        //
        bValidFile = TRUE;
        bMetaFileOpen = TRUE;

        if (dwIsPlaceable != PLACEABLEKEY)
        {
          bPlaceableMeta = FALSE;
          bMetaInRam = FALSE;
        }
        else
        {
          bPlaceableMeta = TRUE;
          bMetaInRam = TRUE;
        }
      }
      return (TRUE);

    } //if fh != -1
    else
      return (FALSE);
}

/***********************************************************************

  FUNCTION   : ProcessCLP

  PARAMETERS : HWND  hWnd
               LPSTR lpFileName

  PURPOSE    : open the metafile contained in the clipboard file and
               take care of some menu housekeeping tasks.

  CALLS      :

  MESSAGES   : none

  RETURNS    : BOOL

  COMMENTS   :

  HISTORY    : 6/23/93 - created - drc

************************************************************************/


BOOL ProcessCLP(HWND hWnd, LPSTR lpFileName)
{
  WORD             i;
  int              fh;
  DWORD            HeaderPos;
  DWORD            nSizeOfClipHeader;
  DWORD            nSizeOfClipFormat;
  NTCLIPFILEHEADER NTFileHeader;
  NTCLIPFILEFORMAT NTClipHeader;
  CLIPFILEHEADER   FileHeader;
  CLIPFILEFORMAT   ClipHeader;
  char             szCaption[144];
  WORD             wFileID;
  BOOL             bMetaFound = FALSE;
  LPVOID           lpvAddressOfHdr;

  /* for openfiledialog */
  char drive[3];
  char dir[MAX_PATH+1];
  char fname[MAX_PATH+1];
  char ext[5];
  char * pchCorrectSir;
    //
    //split the fully qualified filename into its components
    //
    SplitPath( lpFileName, (LPSTR)drive,
            (LPSTR)dir, (LPSTR)fname, (LPSTR)ext);

    pchCorrectSir = _strupr( _strdup( ext ) );
    //
    //try to open the file.  It's existence has already been
    //checked by OpenFileDialog
    fh = _lopen(lpFileName, OF_READ);
    //
    //if opened successfully
    if (fh != -1 )
    {
      //
      // read the clipboard fileidentifier
      //
      wFileID = 0;
      _lread(fh, (LPSTR)&wFileID, sizeof(WORD));
      _llseek(fh, 0, 0);
      //
      //if this is not a valid clipboard file based on the file
      //identifier of the file header
      //
      if (wFileID != CLP_ID && wFileID != CLP_NT_ID && wFileID != CLPBK_NT_ID)
      {

        _lclose(fh);
        MessageBox(hWndMain, "This file is not a valid clipboard file",
                   NULL, MB_OK | MB_ICONEXCLAMATION);
        return (FALSE);
      }
      switch (wFileID)
      {
        case CLP_ID:
            _lread(fh, (LPSTR)&FileHeader, sizeof(CLIPFILEHEADER));
            nSizeOfClipHeader = sizeof(CLIPFILEHEADER);
            nSizeOfClipFormat = sizeof(CLIPFILEFORMAT);
            HeaderPos = nSizeOfClipHeader;
          break;

        case CLP_NT_ID:
        case CLPBK_NT_ID:
            NTFileHeader.FormatCount = 0;
            _lread(fh, (LPSTR)&NTFileHeader, sizeof(NTCLIPFILEHEADER));
            nSizeOfClipHeader = sizeof(NTCLIPFILEHEADER);
            nSizeOfClipFormat = sizeof(NTCLIPFILEFORMAT);
            HeaderPos = nSizeOfClipHeader;
          break;

        default:
          break;
      }
      //
      //search the formats contained within the clipboard file looking
      //for a metafile.  Break if and when it is found
      //
      for (i=0;
           i < ((wFileID == CLP_ID) ? FileHeader.FormatCount : NTFileHeader.FormatCount);
           i++)
      {

        _llseek(fh, HeaderPos, 0);
        //
        //read the clipboard header found at current position
        //
        lpvAddressOfHdr = (wFileID == CLP_ID) ? (LPVOID)&ClipHeader : (LPVOID)&NTClipHeader;

        if(_lread(fh, (LPSTR)lpvAddressOfHdr, nSizeOfClipFormat) < nSizeOfClipFormat)
        //if(_lread(fh, (LPSTR)&ClipHeader, nSizeOfClipHeader) < nSizeOfClipHeader)
        {
          _lclose(fh);
          MessageBox(hWndMain, "read of clipboard header failed",
                       NULL, MB_OK | MB_ICONEXCLAMATION);
          return (FALSE);
        }
        //
        //increment the file offset to data
        //
        HeaderPos += nSizeOfClipFormat;
        //
        //if a metafile was found break...
        //this break assumes that CF_METAFILEPICT formats are always written before CF_ENHMETAFILE
        //formats.
        //
        if (wFileID == CLP_ID && ClipHeader.FormatID == CF_METAFILEPICT)
        {
          bMetaFound = TRUE;
          break;
        }

        if (wFileID == CLP_NT_ID || wFileID == CLPBK_NT_ID)
        {
          if (NTClipHeader.FormatID == CF_ENHMETAFILE)
//          HeaderPos += NTClipHeader.DataLen;
          //else
          {
            bMetaFound = TRUE;
            break;
          }
        }

      }  //for i < formatcount

      if (bMetaFound)
      {
        //
        //if there is currently a metafile loaded delete it.
        //
        if (wFileID == CLP_ID)
        {
          if ((bMetaInRam) && (hMF))
          {
            DeleteMetaFile((HMETAFILE)hMF);
            hMF = NULL;
          }
        }
        else
        {
          if ((bMetaInRam) && (hemf))
          {
            DeleteEnhMetaFile(hemf);
            hemf = NULL;
          }
        }

        //
        //modify and update the caption text
        //
        wsprintf((LPSTR)szCaption, (LPSTR)"%s - %s.%s",
                   (LPSTR)APPNAME, (LPSTR)fname, (LPSTR)ext);
        //
        //this could be used by the printing routines if unable to print
        //
        wsprintf((LPSTR)fnameext, (LPSTR)"%s.%s", (LPSTR)fname, (LPSTR)ext);

        SetWindowText(hWnd, (LPSTR)szCaption);
        //
        //enable the appropriate menu items
        //
        if (wFileID == CLP_ID)
        {
          EnableMenuItem(GetMenu(hWnd), IDM_ENHHEADER, MF_DISABLED | MF_GRAYED);
          EnableMenuItem(GetMenu(hWnd), IDM_HEADER, MF_ENABLED);
        }
        else
        {
          EnableMenuItem(GetMenu(hWnd), IDM_ENHHEADER, MF_ENABLED);
          EnableMenuItem(GetMenu(hWnd), IDM_HEADER, MF_DISABLED | MF_GRAYED);
        }

        EnableMenuItem(GetMenu(hWnd), IDM_PLACEABLEHDR, MF_DISABLED|MF_GRAYED);
        EnableMenuItem(GetMenu(hWnd), IDM_CLIPHDR, MF_ENABLED);
        EnableMenuItem(GetMenu(hWnd), IDM_VIEW, MF_ENABLED|MF_BYPOSITION);
        EnableMenuItem(GetMenu(hWnd), IDM_PLAY, MF_ENABLED|MF_BYPOSITION);
        EnableMenuItem(GetMenu(hWnd), IDM_PRINT, MF_ENABLED);
        EnableMenuItem(GetMenu(hWnd), IDM_PRINTDLG, MF_ENABLED);
        EnableMenuItem(GetMenu(hWnd), IDM_SAVEAS, MF_ENABLED);
        //
        //refresh the menu bar
        //
        DrawMenuBar(hWnd);
        //
        //set the program flags appropriately
        //
        bValidFile = TRUE;
        bMetaFileOpen = TRUE;
        bMetaInRam = TRUE;
        bPlaceableMeta = FALSE;
        bEnhMeta = (wFileID == CLP_ID) ? FALSE : TRUE;
        //
        //convert the metafile contained within the clipboard file into
        //a format useable with GDI metafile functions
        //
        if (!RenderClipMeta(((wFileID == CLP_ID)? (LPVOID)&ClipHeader : (LPVOID)&NTClipHeader),
                              fh,
                              FileHeader.FileIdentifier))

          MessageBox(hWndMain, "Unable to render format",
                       NULL, MB_OK | MB_ICONEXCLAMATION);
        _lclose(fh);

      }
      //
      //a metafile was not found within the clipboard file
      //
      else
      {
        bBadFile = TRUE;
        bMetaFileOpen = FALSE;
        bValidFile = FALSE;
        bEnhMeta = FALSE;
        //
        //let the user know
        //
        MessageBox(hWndMain, "This CLP file doesn't contain a valid metafile",
                     NULL, MB_OK | MB_ICONEXCLAMATION);
        //
        //restore the caption text to default
        //
        SetWindowText(hWnd, (LPSTR)APPNAME);
        //
        //disable previously enabled menu items
        //
        EnableMenuItem(GetMenu(hWnd), IDM_VIEW, MF_DISABLED|MF_GRAYED|MF_BYPOSITION);
        EnableMenuItem(GetMenu(hWnd), IDM_PLAY, MF_DISABLED|MF_GRAYED|MF_BYPOSITION);
        EnableMenuItem(GetMenu(hWnd), IDM_PRINT, MF_DISABLED|MF_GRAYED);
        EnableMenuItem(GetMenu(hWnd), IDM_PRINTDLG, MF_DISABLED|MF_GRAYED);
        EnableMenuItem(GetMenu(hWnd), IDM_SAVEAS, MF_DISABLED|MF_GRAYED);
        //
        //refresh the menu bar to reflect these changes
        //
        DrawMenuBar(hWnd);
        _lclose(fh);
      }
      return (TRUE);
    }
    else
      return (FALSE);
}

/***********************************************************************

  FUNCTION   : ProcessEMF

  PARAMETERS : HWND  hWnd
               LPSTR lpFileName

  PURPOSE    : open the metafile contained in the clipboard file and
               take care of some menu housekeeping tasks.

  CALLS      :

  MESSAGES   : none

  RETURNS    : BOOL

  COMMENTS   :

  HISTORY    : 6/23/93 - created - drc

************************************************************************/


BOOL ProcessEMF(HWND hWnd, LPSTR lpFileName)
{
  char           szCaption[144];

  /* for openfiledialog */
  char drive[3];
  char dir[MAX_PATH+1];
  char fname[MAX_PATH+1];
  char ext[5];
  char * pchCorrectSir;

  bEnhMeta = FALSE;
    //
    //split the fully qualified filename into its components
    //
    SplitPath( lpFileName, (LPSTR)drive,
            (LPSTR)dir, (LPSTR)fname, (LPSTR)ext);

    pchCorrectSir = _strupr( _strdup( ext ) );
    //
    //always disable the clipboard, WMF and Placeable header menu if we get here
    //
    EnableMenuItem(GetMenu(hWnd), IDM_CLIPHDR, MF_DISABLED | MF_GRAYED);
    EnableMenuItem(GetMenu(hWnd), IDM_HEADER, MF_DISABLED | MF_GRAYED);
    EnableMenuItem(GetMenu(hWnd), IDM_PLACEABLEHDR, MF_DISABLED|MF_GRAYED);
    //
    //if emf was successfully opened
    //
    if (!hemf)
      hemf = GetEnhMetaFile(lpFileName);

    if (hemf)
    {
      GetEMFCoolStuff();
      //
      //modify and update the caption text
      //
      wsprintf((LPSTR)szCaption, (LPSTR)"%s - %s.%s",
                 (LPSTR)APPNAME, (LPSTR)fname, (LPSTR)ext);
      //
      //this could be used by the printing routines if unable to print
      //
      wsprintf((LPSTR)fnameext, (LPSTR)"%s.%s", (LPSTR)fname, (LPSTR)ext);

      SetWindowText(hWnd, (LPSTR)szCaption);
      //
      //enable the appropriate menu items
      //
      EnableMenuItem(GetMenu(hWnd), IDM_ENHHEADER, MF_ENABLED);
      EnableMenuItem(GetMenu(hWnd), IDM_VIEW, MF_ENABLED|MF_BYPOSITION);
      EnableMenuItem(GetMenu(hWnd), IDM_PLAY, MF_ENABLED|MF_BYPOSITION);
      EnableMenuItem(GetMenu(hWnd), IDM_PRINT, MF_ENABLED);
      EnableMenuItem(GetMenu(hWnd), IDM_PRINTDLG, MF_ENABLED);
      EnableMenuItem(GetMenu(hWnd), IDM_SAVEAS, MF_ENABLED);
      //
      //refresh the menu bar
      //
      DrawMenuBar(hWnd);
      //
      //set the program flags appropriately
      //
      bValidFile = TRUE;
      bMetaFileOpen = TRUE;
      bEnhMeta = TRUE;
      bMetaInRam = FALSE;
      bPlaceableMeta = FALSE;

    }
//    DeleteEnhMetaFile(hemf);
    else
    {
      bEnhMeta = FALSE;
      bValidFile = FALSE;
      bBadFile = TRUE;
      bMetaFileOpen = FALSE;
      //
      //let the user know
      //
      MessageBox(hWndMain, "This EMF file doesn't contain a valid metafile",
                     NULL, MB_OK | MB_ICONEXCLAMATION);
      //
      //restore the caption text to default
      //
      SetWindowText(hWnd, (LPSTR)APPNAME);
      //
      //disable previously enabled menu items
      //
      EnableMenuItem(GetMenu(hWnd), IDM_VIEW, MF_DISABLED|MF_GRAYED|MF_BYPOSITION);
      EnableMenuItem(GetMenu(hWnd), IDM_PLAY, MF_DISABLED|MF_GRAYED|MF_BYPOSITION);
      EnableMenuItem(GetMenu(hWnd), IDM_PRINT, MF_DISABLED|MF_GRAYED);
      EnableMenuItem(GetMenu(hWnd), IDM_PRINTDLG, MF_DISABLED|MF_GRAYED);
      EnableMenuItem(GetMenu(hWnd), IDM_SAVEAS, MF_DISABLED|MF_GRAYED);
      //
      //refresh the menu bar to reflect these changes
      //
      DrawMenuBar(hWnd);
    }

    return TRUE;
}

/***********************************************************************

  FUNCTION   : GetEMFCoolStuff

  PARAMETERS :

  PURPOSE    :

  CALLS      :

  MESSAGES   :

  RETURNS    :

  COMMENTS   :

  HISTORY    : created 7/8/93 - denniscr

************************************************************************/
BOOL GetEMFCoolStuff()
{
    //
    //init these ptrs
    //
    EmfPtr.lpEMFHdr  = NULL;
    EmfPtr.lpDescStr = NULL;
    EmfPtr.lpPal     = NULL;

    if (hemf)
    {
      //
      //obtain the sizes of the emf header, description string and palette
      //
      UINT uiHdrSize = GetEnhMetaFileHeader(hemf, 0, NULL);
      UINT uiDescStrSize = GetEnhMetaFileDescription(hemf, 0, NULL);
      UINT uiPalEntries = GetEnhMetaFilePaletteEntries(hemf, 0, NULL);
      //
      //if these are lengths > 0 then allocate memory to store them
      //
      if (uiHdrSize)
        EmfPtr.lpEMFHdr = (LPENHMETAHEADER)GlobalAllocPtr(GHND, uiHdrSize);
      if (uiDescStrSize)
        EmfPtr.lpDescStr = (LPTSTR)GlobalAllocPtr(GHND, uiDescStrSize);
      if (uiPalEntries)
        EmfPtr.lpPal = (LPPALETTEENTRY)GlobalAllocPtr(GHND, uiPalEntries * sizeof(PALETTEENTRY));
      //
      //so far the emf seems to be valid so continue
      //
      if (uiHdrSize)
      {
        //
        //get the actual emf header and description string
        //
        if (!GetEnhMetaFileHeader(hemf, uiHdrSize, EmfPtr.lpEMFHdr))
        {
          MessageBox(hWndMain, "unable to read enhanced metafile header", NULL,
                   MB_OK | MB_ICONEXCLAMATION);
          bValidFile = FALSE;
          return (FALSE);
        }
        else
        {
          //
          //get the description string if it exists
          //
          if (uiDescStrSize)
            GetEnhMetaFileDescription(hemf, uiDescStrSize, EmfPtr.lpDescStr);
          //
          //get the palette if it exists
          //
          if (uiPalEntries)
          {
            GetEnhMetaFilePaletteEntries(hemf, uiPalEntries, EmfPtr.lpPal);
            EmfPtr.palNumEntries = (WORD)uiPalEntries;
          }
        }
      }
   }
   return (TRUE);
}

float NormalizeAngle (double angle)
{
    if (angle >= 0)
    {
        while (angle >= 360)
        {
            angle -= 360;
        }
    }
    else
    {
        while (angle < 0)
        {
            angle += 360;
        }
    }
    return static_cast<float>(angle);
}

#define PI                  3.1415926535897932384626433832795
#define RADIANS_TO_DEGREES  (180.0 / PI)

float PointToAngle(float x, float y, float w, float h, float xVector, float yVector)
{
    BOOL        bScale = TRUE;

    if (w == h)
    {
        if (w == 0)
        {
            return 0;
        }
        bScale = FALSE;
    }

    float horRadius = w / 2;
    float verRadius = h / 2;
    float xOrigin = x + horRadius;
    float yOrigin = y + verRadius;

    if (horRadius == 0)
    {
        double  dAngle = asin(((double)(yVector - yOrigin)) / verRadius);

        if (xOrigin > xVector)
        {
            dAngle = PI - dAngle;
        }
        return NormalizeAngle(dAngle * RADIANS_TO_DEGREES);
    }
    else if (verRadius == 0)
    {
        double dAngle = acos(((double)(xVector - xOrigin)) / horRadius);

        if (yOrigin > yVector)
        {
            dAngle = -dAngle;
        }
        return NormalizeAngle(dAngle * RADIANS_TO_DEGREES);
    }

    if (yOrigin == yVector)
    {
        return static_cast<float>((xOrigin <= xVector) ? 0 : 180);
    }

    if (xOrigin == xVector)
    {
        return static_cast<float>((yOrigin < yVector) ? 90 : 270);;
    }

    if (bScale)
    {
        xVector = (float)(xOrigin + ((xVector - xOrigin) * ((double)verRadius / horRadius)));
    }

    return NormalizeAngle(atan2(yVector - yOrigin, xVector - xOrigin) * RADIANS_TO_DEGREES);
}

#define HS_DDI_MAX      6

typedef struct {
    BITMAPINFOHEADER    bmiHeader;
    RGBQUAD             bmiColors[2];
} HATCHBRUSHINFO;

HATCHBRUSHINFO  hatchBrushInfo = {
    { sizeof(BITMAPINFOHEADER), 8, 8, 1, 1, BI_RGB, 32, 0, 0, 2, 0 },
    { { 255, 255, 255, 0 }, { 0, 0, 0, 0 } }
};

ULONG HatchPatterns[HS_DDI_MAX][8] = {

// Scans have to be DWORD aligned:

    { 0x00,                // ........     HS_HORIZONTAL 0
      0x00,                // ........
      0x00,                // ........
      0xff,                // ********
      0x00,                // ........
      0x00,                // ........
      0x00,                // ........
      0x00 },              // ........

    { 0x08,                // ....*...     HS_VERTICAL 1
      0x08,                // ....*...
      0x08,                // ....*...
      0x08,                // ....*...
      0x08,                // ....*...
      0x08,                // ....*...
      0x08,                // ....*...
      0x08 },              // ....*...

    { 0x80,                // *.......     HS_FDIAGONAL 2
      0x40,                // .*......
      0x20,                // ..*.....
      0x10,                // ...*....
      0x08,                // ....*...
      0x04,                // .....*..
      0x02,                // ......*.
      0x01 },              // .......*

    { 0x01,                // .......*     HS_BDIAGONAL 3
      0x02,                // ......*.
      0x04,                // .....*..
      0x08,                // ....*...
      0x10,                // ...*....
      0x20,                // ..*.....
      0x40,                // .*......
      0x80 },              // *.......

    { 0x08,                // ....*...     HS_CROSS 4
      0x08,                // ....*...
      0x08,                // ....*...
      0xff,                // ********
      0x08,                // ....*...
      0x08,                // ....*...
      0x08,                // ....*...
      0x08 },              // ....*...

    { 0x81,                // *......*     HS_DIAGCROSS 5
      0x42,                // .*....*.
      0x24,                // ..*..*..
      0x18,                // ...**...
      0x18,                // ...**...
      0x24,                // ..*..*..
      0x42,                // .*....*.
      0x81 }               // *......*
};

/***********************************************************************

  FUNCTION   : EnhMetaFileEnumProc

  PARAMETERS : HDC           hDC
               LPHANDLETABLE lpHTable
               LPMETARECORD  lpMFR
               int           nObj
               LPARAM        lpData


  PURPOSE    : callback for EnumEnhMetaFile.

  CALLS      : EnumMFIndirect()

  MESSAGES   : none

  RETURNS    : int

  COMMENTS   :

  HISTORY    : created 6/30/93 - denniscr

************************************************************************/
int CALLBACK EnhMetaFileEnumProc(HDC hDC, LPHANDLETABLE lpHTable,
                                 LPENHMETARECORD lpEMFR, int nObj, LPARAM lpData)
{
  return EnumMFIndirect(hDC, lpHTable, NULL, lpEMFR, nObj, lpData);
}

void GetPixelSize (Gdiplus::Graphics * g, float * cx, float * cy)
{
    Gdiplus::PointF     points[2];

    points[0].X = points[0].Y = 0;
    points[1].X = points[1].Y = 1;

    g->TransformPoints(Gdiplus::CoordinateSpaceWorld, Gdiplus::CoordinateSpaceDevice, points, 2);

    *cx = points[1].X - points[0].X;
    *cy = points[1].Y - points[0].Y;
}

void GpPlayEnhMetaFileRecord(HDC hDC, LPHANDLETABLE lpHTable,
                            LPENHMETARECORD lpEMFR,
                            UINT nObj, LPARAM lpData)
{
if (!lpData) return;

    MYDATA *  myData = (MYDATA *)lpData;
    Gdiplus::Graphics * g = myData->g;

    myData->recordNum++;

    XFORM xForm;
    GetWorldTransform(hDC, &xForm);

    INT mapMode = GetMapMode(hDC);

    POINT org;
    SIZE size;
    GetViewportOrgEx(hDC, &org);
    GetViewportExtEx(hDC, &size);
    GetWindowOrgEx(hDC, &org);
    GetWindowExtEx(hDC, &size);

    switch (lpEMFR->iType)
    {
    case EMR_HEADER:
        {
            PENHMETAHEADER     pHeader = (PENHMETAHEADER)lpEMFR;
            RECT               clientRect;

            myData->recordNum = 1;
            myData->pObjects = new MYOBJECTS[pHeader->nHandles];
            myData->numObjects = pHeader->nHandles;
            GetClientRect(myData->hwnd, &clientRect);
            int         clientWidth  = clientRect.right - clientRect.left;
            int         clientHeight = clientRect.bottom - clientRect.top;
            myData->windowExtent.cx   = clientWidth;
            myData->windowExtent.cy   = clientHeight;
            myData->viewportExtent.cx = clientWidth;
            myData->viewportExtent.cy = clientHeight;
            float       dstX      = TOREAL(clientRect.left);
            float       dstY      = TOREAL(clientRect.top);
            float       dstWidth  = TOREAL(clientWidth);
            float       dstHeight = TOREAL(clientHeight);
            float       srcWidth  = TOREAL(pHeader->rclFrame.right -  pHeader->rclFrame.left);
            float       srcHeight = TOREAL(pHeader->rclFrame.bottom -  pHeader->rclFrame.top);

    #if 0
            if (srcHeight * dstWidth >= dstHeight * srcWidth)
            {
                float oldDstWidth = dstWidth;
                dstWidth = srcWidth * dstHeight / srcHeight;
                dstX += (oldDstWidth - dstWidth) / 2;
            }
            else
            {
                float oldDstHeight = dstHeight;
                dstHeight = srcHeight * dstWidth / srcWidth;
                dstY += (oldDstHeight - dstHeight) / 2;
            }
    #endif
            g->SetPageUnit(Gdiplus::UnitPixel);

            using Gdiplus::RectF;
            RectF       dstRect(dstX, dstY, dstWidth, dstHeight);

            int     deviceLeft   = pHeader->rclBounds.left;
            int     deviceRight  = pHeader->rclBounds.right;
            int     deviceTop    = pHeader->rclBounds.top;
            int     deviceBottom = pHeader->rclBounds.bottom;

//          if ((deviceLeft > deviceRight) ||
//              (deviceTop  > deviceBottom))
            {
                SIZEL   deviceSize = pHeader->szlDevice;
                SIZEL   mmSize     = pHeader->szlMillimeters;

                if ((deviceSize.cx <= 0) || (deviceSize.cy <= 0) ||
                    (mmSize.cx <= 0) || (mmSize.cy <= 0))
                {
                    ASSERT(0);

                    // Take a wild guess
                    deviceSize.cx = 1024;
                    deviceSize.cy = 768;
                    mmSize.cx = 320;
                    mmSize.cy = 240;
                }
                deviceLeft   = MulDiv(pHeader->rclFrame.left,   deviceSize.cx, (mmSize.cx * 100));
                deviceRight  = MulDiv(pHeader->rclFrame.right,  deviceSize.cx, (mmSize.cx * 100));
                deviceTop    = MulDiv(pHeader->rclFrame.top,    deviceSize.cy, (mmSize.cy * 100));
                deviceBottom = MulDiv(pHeader->rclFrame.bottom, deviceSize.cy, (mmSize.cy * 100));
            }

            RectF       srcRect(TOREAL(deviceLeft),
                                    TOREAL(deviceTop),
                                    TOREAL(deviceRight -  deviceLeft),
                                    TOREAL(deviceBottom -  deviceTop));
            myData->containerId = g->BeginContainer(dstRect, srcRect, Gdiplus::UnitPixel);

            g->SetPageUnit(Gdiplus::UnitPixel); // Assume MM_TEXT
        }
        break;

    case EMR_POLYBEZIER:
        {
            PEMRPOLYBEZIER     pBezier = (PEMRPOLYBEZIER)lpEMFR;

            if (pBezier->cptl > 0)
            {
                int                 i = pBezier->cptl;
                Gdiplus::PointF *   points = new Gdiplus::PointF[i];

                do
                {
                    i--;
                    points[i].X = TOREAL(pBezier->aptl[i].x);
                    points[i].Y = TOREAL(pBezier->aptl[i].y);
                } while (i > 0);

                if (!myData->pathOpen)
                {
                    if (myData->curPen != 0)
                    {
                        Gdiplus::Pen    pen(Gdiplus::Color(myData->curPen), TOREAL(myData->curPenWidth));
                        pen.SetMiterLimit(myData->miterLimit);

                        g->DrawBeziers(&pen, points, pBezier->cptl);
                    }
                }
                else
                {
                    myData->path->AddBeziers(points, pBezier->cptl);
                }

                delete [] points;
            }
        }
        break;

    case EMR_POLYGON:
        {
            PEMRPOLYGON     pPolygon = (PEMRPOLYGON)lpEMFR;

            if (pPolygon->cptl > 0)
            {
                int                 i = pPolygon->cptl;
                Gdiplus::PointF *   points = new Gdiplus::PointF[i];

                do
                {
                    i--;
                    points[i].X = TOREAL(pPolygon->aptl[i].x);
                    points[i].Y = TOREAL(pPolygon->aptl[i].y);
                } while (i > 0);

                if (!myData->pathOpen)
                {
                    Gdiplus::GraphicsPath   path(myData->fillMode);
                    path.AddPolygon(points, pPolygon->cptl);

                    if (myData->curBrush != 0)
                    {
                        if (myData->curPatIndex < 0)
                        {
                            if (myData->curBrushPattern == NULL)
                            {
                                Gdiplus::SolidBrush brush(Gdiplus::Color(myData->curBrush));
                                g->FillPath(&brush, &path);
                            }
                            else
                            {
                                BITMAPINFO *        bmi  = (BITMAPINFO *)myData->curBrushPattern->bmi;
                                BYTE *              bits = ((BYTE *)bmi) + myData->curBrushPattern->bitsOffset;

                                DibBrush brush(bmi, bits);
                                g->FillPath(brush, &path);
                            }
                        }
                        else
                        {
                            BITMAPINFO *            bmi  = (BITMAPINFO *)&hatchBrushInfo;
                            BYTE *                  bits = (BYTE *)HatchPatterns[myData->curPatIndex];

                            bmi->bmiColors[1].rgbRed   = (myData->curBrush & Gdiplus::Color::RedMask)   >> Gdiplus::Color::RedShift;
                            bmi->bmiColors[1].rgbGreen = (myData->curBrush & Gdiplus::Color::GreenMask) >> Gdiplus::Color::GreenShift;
                            bmi->bmiColors[1].rgbBlue  = (myData->curBrush & Gdiplus::Color::BlueMask)  >> Gdiplus::Color::BlueShift;

                            DibBrush brush(bmi, bits);
                            g->FillPath(brush, &path);
                        }
                    }
                    if (myData->curPen != 0)
                    {
                        Gdiplus::Pen    pen(Gdiplus::Color(myData->curPen), TOREAL(myData->curPenWidth));
                        pen.SetMiterLimit(myData->miterLimit);

                        g->DrawPath(&pen, &path);
                    }
                }
                else
                {
                    myData->path->AddPolygon(points, pPolygon->cptl);
                }

                delete [] points;
            }
        }
        break;

    case EMR_POLYLINE:
        {
            PEMRPOLYLINE     pPolyline = (PEMRPOLYLINE)lpEMFR;

            if (pPolyline->cptl > 0)
            {
                int                 i = pPolyline->cptl;
                Gdiplus::PointF *   points = new Gdiplus::PointF[i];

                do
                {
                    i--;
                    points[i].X = TOREAL(pPolyline->aptl[i].x);
                    points[i].Y = TOREAL(pPolyline->aptl[i].y);
                } while (i > 0);

                if (!myData->pathOpen)
                {
                    if (myData->curPen != 0)
                    {
                        Gdiplus::Pen    pen(Gdiplus::Color(myData->curPen), TOREAL(myData->curPenWidth));
                        pen.SetMiterLimit(myData->miterLimit);

                        g->DrawLines(&pen, points, pPolyline->cptl);
                    }
                }
                else
                {
                    myData->path->AddLines(points, pPolyline->cptl);
                }

                delete [] points;
            }
        }
        break;

    case EMR_POLYBEZIERTO:
        {
            PEMRPOLYBEZIERTO     pBezier = (PEMRPOLYBEZIERTO)lpEMFR;

            if (pBezier->cptl > 0)
            {
                int                 i = pBezier->cptl;
                Gdiplus::PointF *   points = new Gdiplus::PointF[i+1];

                do
                {
                    points[i].X = TOREAL(pBezier->aptl[i-1].x);
                    points[i].Y = TOREAL(pBezier->aptl[i-1].y);
                    i--;
                } while (i > 0);

                points[0] = myData->curPos;
                myData->curPos = points[pBezier->cptl];

                if (!myData->pathOpen)
                {
                    if (myData->curPen != 0)
                    {
                        Gdiplus::Pen    pen(Gdiplus::Color(myData->curPen), TOREAL(myData->curPenWidth));
                        pen.SetMiterLimit(myData->miterLimit);

                        g->DrawBeziers(&pen, points, pBezier->cptl+1);
                    }
                }
                else
                {
                    myData->path->AddBeziers(points, pBezier->cptl+1);
                }

                delete [] points;
            }
        }
        break;

    case EMR_POLYLINETO:
        {
            PEMRPOLYLINETO     pPolyline = (PEMRPOLYLINETO)lpEMFR;

            if (pPolyline->cptl > 0)
            {
                int                 i = pPolyline->cptl;
                Gdiplus::PointF *   points = new Gdiplus::PointF[i+1];

                do
                {
                    points[i].X = TOREAL(pPolyline->aptl[i-1].x);
                    points[i].Y = TOREAL(pPolyline->aptl[i-1].y);
                    i--;
                } while (i > 0);

                points[0] = myData->curPos;
                myData->curPos = points[pPolyline->cptl];

                if (!myData->pathOpen)
                {
                    if (myData->curPen != 0)
                    {
                        Gdiplus::Pen    pen(Gdiplus::Color(myData->curPen), TOREAL(myData->curPenWidth));
                        pen.SetMiterLimit(myData->miterLimit);

                        g->DrawLines(&pen, points, pPolyline->cptl+1);
                    }
                }
                else
                {
                    myData->path->AddLines(points, pPolyline->cptl+1);
                }

                delete [] points;
            }
        }
        break;

    case EMR_POLYPOLYLINE:
        {
            PEMRPOLYPOLYLINE     pPolyline = (PEMRPOLYPOLYLINE)lpEMFR;

            if ((pPolyline->cptl > 0) && (pPolyline->nPolys > 0))
            {
                int                 i = pPolyline->cptl;
                Gdiplus::PointF *   points = new Gdiplus::PointF[i];
                POINTL *            metaPoints = (POINTL *)(pPolyline->aPolyCounts + pPolyline->nPolys);

                do
                {
                    i--;
                    points[i].X = TOREAL(metaPoints[i].x);
                    points[i].Y = TOREAL(metaPoints[i].y);
                } while (i > 0);

                if (!myData->pathOpen)
                {
                    if (myData->curPen != 0)
                    {
                        Gdiplus::Pen    pen(Gdiplus::Color(myData->curPen), TOREAL(myData->curPenWidth));
                        pen.SetMiterLimit(myData->miterLimit);

                        i = 0;
                        Gdiplus::PointF *   tmpPoints = points;
                        DWORD       count;
                        do
                        {
                            count = pPolyline->aPolyCounts[i];
                            g->DrawLines(&pen, tmpPoints, count);
                            tmpPoints += count;
                        } while ((UINT)++i < pPolyline->nPolys);
                    }
                }
                else
                {
                    i = 0;
                    Gdiplus::PointF *   tmpPoints = points;
                    DWORD       count;
                    do
                    {
                        count = pPolyline->aPolyCounts[i];
                        myData->path->AddLines(tmpPoints, count);
                        tmpPoints += count;
                    } while ((UINT)++i < pPolyline->nPolys);
                }

                delete [] points;
            }
        }
        break;

    case EMR_POLYPOLYGON:
        {
            PEMRPOLYPOLYGON     pPolygon = (PEMRPOLYPOLYGON)lpEMFR;

            if ((pPolygon->cptl > 0) && (pPolygon->nPolys > 0))
            {
                int                 i = pPolygon->cptl;
                Gdiplus::PointF *   points = new Gdiplus::PointF[i];
                POINTL *            metaPoints = (POINTL *)(pPolygon->aPolyCounts + pPolygon->nPolys);

                do
                {
                    i--;
                    points[i].X = TOREAL(metaPoints[i].x);
                    points[i].Y = TOREAL(metaPoints[i].y);
                } while (i > 0);

                Gdiplus::GraphicsPath   path(myData->fillMode);
                Gdiplus::GraphicsPath * tmpPath = &path;

                if (myData->pathOpen)
                {
                    tmpPath = myData->path;
                }

                Gdiplus::PointF *   tmpPoints = points;
                DWORD       count;
                i = 0;
                do
                {
                    count = pPolygon->aPolyCounts[i];
                    tmpPath->StartFigure();
                    tmpPath->AddPolygon(tmpPoints, count);
                    tmpPoints += count;
                } while ((UINT)++i < pPolygon->nPolys);

                if (myData->path == NULL)
                {
                    if (myData->curBrush != 0)
                    {
                        if (myData->curPatIndex < 0)
                        {
                            if (myData->curBrushPattern == NULL)
                            {
                                Gdiplus::SolidBrush brush(Gdiplus::Color(myData->curBrush));
                                g->FillPath(&brush, &path);
                            }
                            else
                            {
                                BITMAPINFO *        bmi  = (BITMAPINFO *)myData->curBrushPattern->bmi;
                                BYTE *              bits = ((BYTE *)bmi) + myData->curBrushPattern->bitsOffset;

                                DibBrush brush(bmi, bits);
                                g->FillPath(brush, &path);
                            }
                        }
                        else
                        {
                            BITMAPINFO *            bmi  = (BITMAPINFO *)&hatchBrushInfo;
                            BYTE *                  bits = (BYTE *)HatchPatterns[myData->curPatIndex];

                            bmi->bmiColors[1].rgbRed   = (myData->curBrush & Gdiplus::Color::RedMask)   >> Gdiplus::Color::RedShift;
                            bmi->bmiColors[1].rgbGreen = (myData->curBrush & Gdiplus::Color::GreenMask) >> Gdiplus::Color::GreenShift;
                            bmi->bmiColors[1].rgbBlue  = (myData->curBrush & Gdiplus::Color::BlueMask)  >> Gdiplus::Color::BlueShift;

                            DibBrush brush(bmi, bits);
                            g->FillPath(brush, &path);
                        }
                    }
                    if (myData->curPen != 0)
                    {
                        Gdiplus::Pen    pen(Gdiplus::Color(myData->curPen), TOREAL(myData->curPenWidth));
                        pen.SetMiterLimit(myData->miterLimit);

                        g->DrawPath(&pen, &path);
                    }
                }

                delete [] points;
            }
        }
        break;

    case EMR_SETWINDOWEXTEX:
        {
            PEMRSETWINDOWEXTEX     pWindowExt = (PEMRSETWINDOWEXTEX)lpEMFR;

            if (((myData->mapMode == MM_ANISOTROPIC) ||
                 (myData->mapMode == MM_ISOTROPIC)) &&
                (pWindowExt->szlExtent.cx != 0) &&  // Note: Can be < 0!!!
                (pWindowExt->szlExtent.cy != 0) &&
                (pWindowExt->szlExtent.cx != myData->windowExtent.cx) &&
                (pWindowExt->szlExtent.cy != myData->windowExtent.cy))
            {
                myData->windowExtent = pWindowExt->szlExtent;

                float   oldDx = myData->dx;
                float   oldDy = myData->dy;
                float   oldSx = myData->scaleX;
                float   oldSy = myData->scaleY;

                float   sX = (float)myData->viewportExtent.cx / myData->windowExtent.cx;
                float   sY = (float)myData->viewportExtent.cy / myData->windowExtent.cy;

                if (myData->mapMode == MM_ISOTROPIC)
                {
                    if (sX < sY)
                    {
                        sY = sX;
                    }
                    else
                    {
                        sX = sY;
                    }
                }

                myData->scaleX = sX;
                myData->scaleY = sY;
                myData->dx     = (myData->viewportOrg.x / sX) - myData->windowOrg.x;
                myData->dy     = (myData->viewportOrg.y / sY) - myData->windowOrg.y;

                Gdiplus::Matrix     matrix;

                matrix.Scale(sX, sY);
                matrix.Translate(myData->dx, myData->dy);
                matrix.Translate(-oldDx, -oldDy);
                matrix.Scale(1 / oldSx, 1 / oldSy);

                g->MultiplyTransform(&matrix, Gdiplus::MatrixOrderAppend);
            }
        }
        break;

    case EMR_SETWINDOWORGEX:
        {
            PEMRSETWINDOWORGEX     pWindowOrg = (PEMRSETWINDOWORGEX)lpEMFR;

            if ((pWindowOrg->ptlOrigin.x != myData->windowOrg.x) &&
                (pWindowOrg->ptlOrigin.y != myData->windowOrg.y))
            {
                myData->windowOrg = pWindowOrg->ptlOrigin;

                float   oldDx = myData->dx;
                float   oldDy = myData->dy;
                float   oldSx = myData->scaleX;
                float   oldSy = myData->scaleY;

                myData->dx = (myData->viewportOrg.x / oldSx) - myData->windowOrg.x;
                myData->dy = (myData->viewportOrg.y / oldSy) - myData->windowOrg.y;

                Gdiplus::Matrix     matrix;

                matrix.Scale(oldSx, oldSy);
                matrix.Translate(myData->dx, myData->dy);
                matrix.Translate(-oldDx, -oldDy);
                matrix.Scale(1 / oldSx, 1 / oldSy);

                g->MultiplyTransform(&matrix, Gdiplus::MatrixOrderAppend);
            }
        }
        break;

    case EMR_SETVIEWPORTEXTEX:
        {
            PEMRSETVIEWPORTEXTEX     pViewportExt = (PEMRSETVIEWPORTEXTEX)lpEMFR;

            if (((myData->mapMode == MM_ANISOTROPIC) ||
                 (myData->mapMode == MM_ISOTROPIC)) &&
                (pViewportExt->szlExtent.cx > 0) &&
                (pViewportExt->szlExtent.cy > 0) &&
                (pViewportExt->szlExtent.cx != myData->viewportExtent.cx) &&
                (pViewportExt->szlExtent.cy != myData->viewportExtent.cy))
            {
                myData->viewportExtent = pViewportExt->szlExtent;

                float   oldDx = myData->dx;
                float   oldDy = myData->dy;
                float   oldSx = myData->scaleX;
                float   oldSy = myData->scaleY;

                float   sX = (float)myData->viewportExtent.cx / myData->windowExtent.cx;
                float   sY = (float)myData->viewportExtent.cy / myData->windowExtent.cy;

                if (myData->mapMode == MM_ISOTROPIC)
                {
                    if (sX < sY)
                    {
                        sY = sX;
                    }
                    else
                    {
                        sX = sY;
                    }
                }

                myData->scaleX = sX;
                myData->scaleY = sY;
                myData->dx     = (myData->viewportOrg.x / sX) - myData->windowOrg.x;
                myData->dy     = (myData->viewportOrg.y / sY) - myData->windowOrg.y;

                Gdiplus::Matrix     matrix;

                matrix.Scale(sX, sY);
                matrix.Translate(myData->dx, myData->dy);
                matrix.Translate(-oldDx, -oldDy);
                matrix.Scale(1 / oldSx, 1 / oldSy);

                g->MultiplyTransform(&matrix, Gdiplus::MatrixOrderAppend);
            }
        }
        break;

    case EMR_SETVIEWPORTORGEX:
        {
            PEMRSETVIEWPORTORGEX     pViewportOrg = (PEMRSETVIEWPORTORGEX)lpEMFR;

            if ((pViewportOrg->ptlOrigin.x != myData->viewportOrg.x) &&
                (pViewportOrg->ptlOrigin.y != myData->viewportOrg.y))
            {
                myData->viewportOrg = pViewportOrg->ptlOrigin;

                float   oldDx = myData->dx;
                float   oldDy = myData->dy;
                float   oldSx = myData->scaleX;
                float   oldSy = myData->scaleY;

                myData->dx = (myData->viewportOrg.x / oldSx) - myData->windowOrg.x;
                myData->dy = (myData->viewportOrg.y / oldSy) - myData->windowOrg.y;

                Gdiplus::Matrix     matrix;

                matrix.Scale(oldSx, oldSy);
                matrix.Translate(myData->dx, myData->dy);
                matrix.Translate(-oldDx, -oldDy);
                matrix.Scale(1 / oldSx, 1 / oldSy);

                g->MultiplyTransform(&matrix, Gdiplus::MatrixOrderAppend);
            }
        }
        break;

    case EMR_SETBRUSHORGEX:
        break;

    case EMR_EOF:
        g->EndContainer(myData->containerId);
        break;

    case EMR_SETPIXELV:
        {
            PEMRSETPIXELV     pSetPixel = (PEMRSETPIXELV)lpEMFR;

            COLORREF        cRef = pSetPixel->crColor;

            ASSERT((cRef & 0x01000000) == 0);

            Gdiplus::SolidBrush brush(Gdiplus::Color(Gdiplus::Color::MakeARGB(0xff,
                                    GetRValue(cRef), GetGValue(cRef), GetBValue(cRef))));
            g->FillRectangle(&brush, TOREAL(pSetPixel->ptlPixel.x), TOREAL(pSetPixel->ptlPixel.y), TOREAL(1), TOREAL(1));
        }
        break;

    case EMR_SETMAPPERFLAGS:    // for font mapping
        break;

    case EMR_SETMAPMODE:
        {
            PEMRSETMAPMODE     pMapMode = (PEMRSETMAPMODE)lpEMFR;
            if (myData->mapMode != pMapMode->iMode)
            {
                float   sX, sY;

                myData->mapMode = pMapMode->iMode;

                switch (pMapMode->iMode)
                {
                case MM_TEXT:
                    g->SetPageUnit(Gdiplus::UnitPixel);
                    sX = sY = 1;
                    break;
                case MM_LOMETRIC:
                    g->SetPageUnit(Gdiplus::UnitMillimeter);
                    g->SetPageScale(TOREAL(.1));
                    sX = sY = 1;
                    break;
                case MM_HIMETRIC:
                    g->SetPageUnit(Gdiplus::UnitMillimeter);
                    g->SetPageScale(TOREAL(.01));
                    sX = sY = 1;
                    break;
                case MM_LOENGLISH:
                    g->SetPageUnit(Gdiplus::UnitInch);
                    g->SetPageScale(TOREAL(.01));
                    sX = sY = 1;
                    break;
                case MM_HIENGLISH:
                    g->SetPageUnit(Gdiplus::UnitInch);
                    g->SetPageScale(TOREAL(.001));
                    sX = sY = 1;
                    break;
                case MM_TWIPS:
                    g->SetPageUnit(Gdiplus::UnitPoint);
                    g->SetPageScale(TOREAL(.05));
                    sX = sY = 1;
                    break;
                case MM_ISOTROPIC:
                    g->SetPageUnit(Gdiplus::UnitPixel);
                    sX = (float)myData->viewportExtent.cx / myData->windowExtent.cx;
                    sY = (float)myData->viewportExtent.cy / myData->windowExtent.cy;
                    if (sX < sY)
                    {
                        sY = sX;
                    }
                    else
                    {
                        sX = sY;
                    }
                    break;
                case MM_ANISOTROPIC:
                    g->SetPageUnit(Gdiplus::UnitPixel);
                    sX = (float)myData->viewportExtent.cx / myData->windowExtent.cx;
                    sY = (float)myData->viewportExtent.cy / myData->windowExtent.cy;
                    break;
                }

                float   oldDx = myData->dx;
                float   oldDy = myData->dy;
                float   oldSx = myData->scaleX;
                float   oldSy = myData->scaleY;

                myData->scaleX = sX;
                myData->scaleY = sY;
                myData->dx     = (myData->viewportOrg.x / sX) - myData->windowOrg.x;
                myData->dy     = (myData->viewportOrg.y / sY) - myData->windowOrg.y;

                Gdiplus::Matrix     matrix;

                matrix.Scale(sX, sY);
                matrix.Translate(myData->dx, myData->dy);
                matrix.Translate(-oldDx, -oldDy);
                matrix.Scale(1 / oldSx, 1 / oldSy);

                g->MultiplyTransform(&matrix, Gdiplus::MatrixOrderAppend);
            }
        }
        break;

    case EMR_SETBKMODE:
        break;

    case EMR_SETPOLYFILLMODE:
        {
            PEMRSETPOLYFILLMODE     pPolyfillMode = (PEMRSETPOLYFILLMODE)lpEMFR;

            myData->fillMode = (pPolyfillMode->iMode == ALTERNATE) ? Gdiplus::FillModeAlternate : Gdiplus::FillModeWinding;
        }
        break;

    case EMR_SETROP2:
        break;

    case EMR_SETSTRETCHBLTMODE:
#ifdef _DEBUG
        {
            PEMRSETSTRETCHBLTMODE     pStretchBltMode = (PEMRSETSTRETCHBLTMODE)lpEMFR;

            int     mode;

            switch (pStretchBltMode->iMode)
            {
            case BLACKONWHITE:
                mode = 1;
                break;
            case WHITEONBLACK:
                mode = 2;
                break;
            case COLORONCOLOR:
                mode = 3;
                break;
            case HALFTONE:
                mode = 4;
                break;
            }
        }
#endif
        break;

    case EMR_SETTEXTALIGN:
        break;

    case EMR_SETCOLORADJUSTMENT:
        break;

    case EMR_SETTEXTCOLOR:
        break;

    case EMR_SETBKCOLOR:
        break;

    case EMR_OFFSETCLIPRGN:
        {
            PEMROFFSETCLIPRGN     pOffsetClipRgn = (PEMROFFSETCLIPRGN)lpEMFR;

            g->TranslateClip(TOREAL(pOffsetClipRgn->ptlOffset.x), TOREAL(pOffsetClipRgn->ptlOffset.y));
        }
        break;

    case EMR_MOVETOEX:
        {
            PEMRMOVETOEX     pMoveTo = (PEMRMOVETOEX)lpEMFR;

            myData->curPos.X = TOREAL(pMoveTo->ptl.x);
            myData->curPos.Y = TOREAL(pMoveTo->ptl.y);
        }
        break;

    case EMR_SETMETARGN:
        break;

    case EMR_EXCLUDECLIPRECT:
        {
            PEMREXCLUDECLIPRECT     pExcludeClipRect = (PEMREXCLUDECLIPRECT)lpEMFR;

            Gdiplus::RectF      clipRect(TOREAL(pExcludeClipRect->rclClip.left),
                                             TOREAL(pExcludeClipRect->rclClip.top),
                                             TOREAL(pExcludeClipRect->rclClip.right - pExcludeClipRect->rclClip.left),
                                             TOREAL(pExcludeClipRect->rclClip.bottom - pExcludeClipRect->rclClip.top));
            g->ExcludeClip(clipRect);
        }
        break;

    case EMR_INTERSECTCLIPRECT:
        {
            PEMRINTERSECTCLIPRECT     pIntersectClipRect = (PEMRINTERSECTCLIPRECT)lpEMFR;

            Gdiplus::RectF      eRect;

            eRect.X = TOREAL(pIntersectClipRect->rclClip.left);
            eRect.Y = TOREAL(pIntersectClipRect->rclClip.top);
            eRect.Width = TOREAL(pIntersectClipRect->rclClip.right - pIntersectClipRect->rclClip.left);
            eRect.Height = TOREAL(pIntersectClipRect->rclClip.bottom - pIntersectClipRect->rclClip.top);

            g->IntersectClip(eRect);
        }
        break;

    case EMR_SCALEVIEWPORTEXTEX:
        {
            PEMRSCALEVIEWPORTEXTEX     pViewportExt = (PEMRSCALEVIEWPORTEXTEX)lpEMFR;

            if (((myData->mapMode == MM_ANISOTROPIC) ||
                 (myData->mapMode == MM_ISOTROPIC)) &&
                (pViewportExt->xNum != 0) &&
                (pViewportExt->yNum != 0) &&
                (pViewportExt->xDenom != 0) &&
                (pViewportExt->yDenom != 0))
            {
                myData->viewportExtent.cx =  (myData->viewportExtent.cx * pViewportExt->xNum) / pViewportExt->xDenom;
                myData->viewportExtent.cy =  (myData->viewportExtent.cy * pViewportExt->yNum) / pViewportExt->yDenom;

                float   oldDx = myData->dx;
                float   oldDy = myData->dy;
                float   oldSx = myData->scaleX;
                float   oldSy = myData->scaleY;

                float   sX = (float)myData->viewportExtent.cx / myData->windowExtent.cx;
                float   sY = (float)myData->viewportExtent.cy / myData->windowExtent.cy;

                if (myData->mapMode == MM_ISOTROPIC)
                {
                    if (sX < sY)
                    {
                        sY = sX;
                    }
                    else
                    {
                        sX = sY;
                    }
                }

                myData->scaleX = sX;
                myData->scaleY = sY;
                myData->dx     = (myData->viewportOrg.x / sX) - myData->windowOrg.x;
                myData->dy     = (myData->viewportOrg.y / sY) - myData->windowOrg.y;

                Gdiplus::Matrix     matrix;

                matrix.Scale(sX, sY);
                matrix.Translate(myData->dx, myData->dy);
                matrix.Translate(-oldDx, -oldDy);
                matrix.Scale(1 / oldSx, 1 / oldSy);

                g->MultiplyTransform(&matrix, Gdiplus::MatrixOrderAppend);
            }
        }
        break;

    case EMR_SCALEWINDOWEXTEX:
        {
            PEMRSCALEWINDOWEXTEX     pWindowExt = (PEMRSCALEWINDOWEXTEX)lpEMFR;

            if (((myData->mapMode == MM_ANISOTROPIC) ||
                 (myData->mapMode == MM_ISOTROPIC)) &&
                (pWindowExt->xNum != 0) &&
                (pWindowExt->yNum != 0) &&
                (pWindowExt->xDenom != 0) &&
                (pWindowExt->yDenom != 0))
            {
                myData->windowExtent.cx =  (myData->windowExtent.cx * pWindowExt->xNum) / pWindowExt->xDenom;
                myData->windowExtent.cy =  (myData->windowExtent.cy * pWindowExt->yNum) / pWindowExt->yDenom;

                float   oldDx = myData->dx;
                float   oldDy = myData->dy;
                float   oldSx = myData->scaleX;
                float   oldSy = myData->scaleY;

                float   sX = (float)myData->viewportExtent.cx / myData->windowExtent.cx;
                float   sY = (float)myData->viewportExtent.cy / myData->windowExtent.cy;

                if (myData->mapMode == MM_ISOTROPIC)
                {
                    if (sX < sY)
                    {
                        sY = sX;
                    }
                    else
                    {
                        sX = sY;
                    }
                }

                myData->scaleX = sX;
                myData->scaleY = sY;
                myData->dx     = (myData->viewportOrg.x / sX) - myData->windowOrg.x;
                myData->dy     = (myData->viewportOrg.y / sY) - myData->windowOrg.y;

                Gdiplus::Matrix     matrix;

                matrix.Scale(sX, sY);
                matrix.Translate(myData->dx, myData->dy);
                matrix.Translate(-oldDx, -oldDy);
                matrix.Scale(1 / oldSx, 1 / oldSy);

                g->MultiplyTransform(&matrix, Gdiplus::MatrixOrderAppend);
            }
        }
        break;

    case EMR_SAVEDC:
        {
            myData->PushId(g->Save());
        }
        break;

    case EMR_RESTOREDC:
        {
            g->Restore(myData->PopId());
        }
        break;

    case EMR_SETWORLDTRANSFORM:
        {
            PEMRSETWORLDTRANSFORM     pXform = (PEMRSETWORLDTRANSFORM)lpEMFR;

            Gdiplus::Matrix     newMatrix(pXform->xform.eM11,
                                          pXform->xform.eM12,
                                          pXform->xform.eM21,
                                          pXform->xform.eM22,
                                          pXform->xform.eDx,
                                          pXform->xform.eDy);

            if (newMatrix.IsInvertible())
            {
                myData->matrix.Invert();
                myData->matrix.Multiply(&newMatrix);
                g->MultiplyTransform(&(myData->matrix));
                myData->matrix.SetElements(pXform->xform.eM11,
                                           pXform->xform.eM12,
                                           pXform->xform.eM21,
                                           pXform->xform.eM22,
                                           pXform->xform.eDx,
                                           pXform->xform.eDy);
            }
        }
        break;

    case EMR_MODIFYWORLDTRANSFORM:
        {
            PEMRMODIFYWORLDTRANSFORM     pXform = (PEMRMODIFYWORLDTRANSFORM)lpEMFR;

            switch (pXform->iMode)
            {
            case MWT_IDENTITY:
            default:
                {
                    myData->matrix.Invert();
                    g->MultiplyTransform(&(myData->matrix));
                    myData->matrix.Reset();
                }
                break;

            case MWT_LEFTMULTIPLY:
                {
                    Gdiplus::Matrix     newMatrix(pXform->xform.eM11,
                                                  pXform->xform.eM12,
                                                  pXform->xform.eM21,
                                                  pXform->xform.eM22,
                                                  pXform->xform.eDx,
                                                  pXform->xform.eDy);

                    if (newMatrix.IsInvertible())
                    {
                        myData->matrix.Multiply(&newMatrix);
                        g->MultiplyTransform(&newMatrix);
                    }
                }
                break;

            case MWT_RIGHTMULTIPLY:
                {
                    Gdiplus::Matrix     newMatrix(pXform->xform.eM11,
                                                  pXform->xform.eM12,
                                                  pXform->xform.eM21,
                                                  pXform->xform.eM22,
                                                  pXform->xform.eDx,
                                                  pXform->xform.eDy);

                    if (newMatrix.IsInvertible())
                    {
                        Gdiplus::Matrix *   inverse = myData->matrix.Clone();
                        inverse->Invert();

                        myData->matrix.Multiply(&newMatrix, Gdiplus::MatrixOrderAppend);
                        inverse->Multiply(&(myData->matrix));
                        g->MultiplyTransform(inverse);
                        delete inverse;
                    }
                }
                break;
            }
        }
        break;

    case EMR_SELECTOBJECT:
        {
            PEMRSELECTOBJECT     pObject = (PEMRSELECTOBJECT)lpEMFR;

            int     objectIndex = pObject->ihObject;

            if ((objectIndex & ENHMETA_STOCK_OBJECT) != 0)
            {
                switch (objectIndex & (~ENHMETA_STOCK_OBJECT))
                {
                case WHITE_BRUSH:
                    myData->curBrush = 0xFFFFFFFF;
                    break;
                case LTGRAY_BRUSH:
                    myData->curBrush = 0xFFC0C0C0;
                    break;
                case GRAY_BRUSH:
                    myData->curBrush = 0xFF808080;
                    break;
                case DKGRAY_BRUSH:
                    myData->curBrush = 0xFF404040;
                    break;
                case BLACK_BRUSH:
                    myData->curBrush = 0xFF000000;
                    break;
                case NULL_BRUSH:
                    myData->curBrush = 0x00000000;
                    break;
                case WHITE_PEN:
                    myData->curPen = 0xFFFFFFFF;
                    break;
                case BLACK_PEN:
                    myData->curPen = 0xFF000000;
                    break;
                case NULL_PEN:
                    myData->curPen = 0x00000000;
                    break;
                }
            }
            else
            {
                ASSERT(objectIndex < myData->numObjects);
                if (myData->pObjects[objectIndex].type == MYOBJECTS::PenObjectType)
                {
                    myData->curPen = myData->pObjects[objectIndex].color;
                    myData->curPenWidth = myData->pObjects[objectIndex].penWidth;
                }
                else if (myData->pObjects[objectIndex].type == MYOBJECTS::BrushObjectType)
                {
                    myData->curBrush        = myData->pObjects[objectIndex].color;
                    myData->curBrushPattern = myData->pObjects[objectIndex].brushPattern;
#if 1
                    myData->curPatIndex     = myData->pObjects[objectIndex].patIndex;

#else
static dodo = 0;
myData->curPatIndex = dodo++ % 6;
#endif
                }
            }
        }
        break;

    case EMR_CREATEPEN:
        {
            PEMRCREATEPEN       pPen = (PEMRCREATEPEN)lpEMFR;
            COLORREF            cRef = pPen->lopn.lopnColor;

            ASSERT((cRef & 0x01000000) == 0);

            ASSERT(pPen->ihPen < myData->numObjects);

            delete myData->pObjects[pPen->ihPen].brushPattern;
            myData->pObjects[pPen->ihPen].brushPattern = NULL;

            myData->pObjects[pPen->ihPen].type  = MYOBJECTS::PenObjectType;

            myData->pObjects[pPen->ihPen].color = Gdiplus::Color::MakeARGB(0xff,
                        GetRValue(cRef), GetGValue(cRef), GetBValue(cRef));

            myData->pObjects[pPen->ihPen].penWidth = pPen->lopn.lopnWidth.x;
        }
        break;

    case EMR_CREATEBRUSHINDIRECT:
        {
            PEMRCREATEBRUSHINDIRECT     pBrush = (PEMRCREATEBRUSHINDIRECT)lpEMFR;
            COLORREF                    cRef   = pBrush->lb.lbColor;

            ASSERT((cRef & 0x01000000) == 0);

            ASSERT(pBrush->ihBrush < myData->numObjects);

            myData->pObjects[pBrush->ihBrush].type  = MYOBJECTS::BrushObjectType;
            myData->pObjects[pBrush->ihBrush].patIndex = -1;
            delete myData->pObjects[pBrush->ihBrush].brushPattern;
            myData->pObjects[pBrush->ihBrush].brushPattern = NULL;
            if (pBrush->lb.lbStyle == BS_NULL)
            {
                myData->pObjects[pBrush->ihBrush].color = 0x00000000;
            }
            else
            {
                // Hatch Styles
                if (pBrush->lb.lbStyle == BS_HATCHED)
                {
                    switch (pBrush->lb.lbHatch)
                    {
                    case HS_HORIZONTAL:         /* ----- */
                    case HS_VERTICAL:           /* ||||| */
                    case HS_FDIAGONAL:          /* \\\\\ */
                    case HS_BDIAGONAL:          /* ///// */
                    case HS_CROSS:              /* +++++ */
                    case HS_DIAGCROSS:          /* xxxxx */
                        myData->pObjects[pBrush->ihBrush].patIndex = pBrush->lb.lbHatch;
                        break;
                    }
                }
                myData->pObjects[pBrush->ihBrush].color = Gdiplus::Color::MakeARGB(0xff,
                            GetRValue(cRef), GetGValue(cRef), GetBValue(cRef));
            }
        }
        break;

    case EMR_DELETEOBJECT:
        {
#if 0
            PEMRDELETEOBJECT     pObject = (PEMRDELETEOBJECT)lpEMFR;

            int     objectIndex = pObject->ihObject;

            ASSERT(objectIndex < myData->numObjects);

            if (myData->pObjects[objectIndex].type == MYOBJECTS::BrushObjectType)
            {
                if (myData->curBrushPattern != myData->pObjects[objectIndex].brushPattern)
                {
                    delete myData->pObjects[objectIndex].brushPattern;
                    myData->pObjects[objectIndex].brushPattern = NULL;
                }
            }
#endif
        }
        break;

    case EMR_ANGLEARC:
        break;

    case EMR_ELLIPSE:
        {
            PEMRELLIPSE     pEllipse = (PEMRELLIPSE)lpEMFR;

            float   x = TOREAL(pEllipse->rclBox.left);
            float   y = TOREAL(pEllipse->rclBox.top);
            float   w = TOREAL(pEllipse->rclBox.right - x);
            float   h = TOREAL(pEllipse->rclBox.bottom - y);

            if (!myData->pathOpen)
            {
                Gdiplus::GraphicsPath   path(myData->fillMode);

                path.AddEllipse(x, y, w, h);

                if (myData->curBrush != 0)
                {
                    if (myData->curPatIndex < 0)
                    {
                        if (myData->curBrushPattern == NULL)
                        {
                            Gdiplus::SolidBrush brush(Gdiplus::Color(myData->curBrush));
                            g->FillPath(&brush, &path);
                        }
                        else
                        {
                            BITMAPINFO *        bmi  = (BITMAPINFO *)myData->curBrushPattern->bmi;
                            BYTE *              bits = ((BYTE *)bmi) + myData->curBrushPattern->bitsOffset;

                            DibBrush brush(bmi, bits);
                            g->FillPath(brush, &path);
                        }
                    }
                    else
                    {
                        BITMAPINFO *            bmi  = (BITMAPINFO *)&hatchBrushInfo;
                        BYTE *                  bits = (BYTE *)HatchPatterns[myData->curPatIndex];

                        bmi->bmiColors[1].rgbRed   = (myData->curBrush & Gdiplus::Color::RedMask)   >> Gdiplus::Color::RedShift;
                        bmi->bmiColors[1].rgbGreen = (myData->curBrush & Gdiplus::Color::GreenMask) >> Gdiplus::Color::GreenShift;
                        bmi->bmiColors[1].rgbBlue  = (myData->curBrush & Gdiplus::Color::BlueMask)  >> Gdiplus::Color::BlueShift;

                        DibBrush brush(bmi, bits);
                        g->FillPath(brush, &path);
                    }
                }
                if (myData->curPen != 0)
                {
                    Gdiplus::Pen    pen(Gdiplus::Color(myData->curPen), TOREAL(myData->curPenWidth));
                    pen.SetMiterLimit(myData->miterLimit);

                    g->DrawPath(&pen, &path);
                }
            }
            else
            {
                myData->path->AddEllipse(x, y, w, h);
            }
        }
        break;

    case EMR_RECTANGLE:
        {
            PEMRRECTANGLE     pRect = (PEMRRECTANGLE)lpEMFR;

            float   x = TOREAL(pRect->rclBox.left);
            float   y = TOREAL(pRect->rclBox.top);
            float   w = TOREAL(pRect->rclBox.right - x);
            float   h = TOREAL(pRect->rclBox.bottom - y);

            if (!myData->pathOpen)
            {
                if (myData->curBrush != 0)
                {
                    if (myData->curPatIndex < 0)
                    {
                        if (myData->curBrushPattern == NULL)
                        {
                            Gdiplus::SolidBrush brush(Gdiplus::Color(myData->curBrush));
                            g->FillRectangle(&brush, x, y, w, h);
                        }
                        else
                        {
                            BITMAPINFO *        bmi  = (BITMAPINFO *)myData->curBrushPattern->bmi;
                            BYTE *              bits = ((BYTE *)bmi) + myData->curBrushPattern->bitsOffset;

                            DibBrush brush(bmi, bits);
                            g->FillRectangle(brush, x, y, w, h);
                        }
                    }
                    else
                    {
                        BITMAPINFO *            bmi  = (BITMAPINFO *)&hatchBrushInfo;
                        BYTE *                  bits = (BYTE *)HatchPatterns[myData->curPatIndex];

                        bmi->bmiColors[1].rgbRed   = (myData->curBrush & Gdiplus::Color::RedMask)   >> Gdiplus::Color::RedShift;
                        bmi->bmiColors[1].rgbGreen = (myData->curBrush & Gdiplus::Color::GreenMask) >> Gdiplus::Color::GreenShift;
                        bmi->bmiColors[1].rgbBlue  = (myData->curBrush & Gdiplus::Color::BlueMask)  >> Gdiplus::Color::BlueShift;

                        DibBrush brush(bmi, bits);
                        g->FillRectangle(brush, x, y, w, h);
                    }
                }
                if (myData->curPen != 0)
                {
                    Gdiplus::Pen    pen(Gdiplus::Color(myData->curPen), TOREAL(myData->curPenWidth));
                    pen.SetMiterLimit(myData->miterLimit);

                    g->DrawRectangle(&pen, x, y, w, h);
                }
            }
            else
            {
                myData->path->AddRectangle(Gdiplus::RectF(x, y, w, h));
            }
        }
        break;

    case EMR_ROUNDRECT: // for now, ignore the szlCorner param of round corners
        {
            PEMRROUNDRECT     pRect = (PEMRROUNDRECT)lpEMFR;

            float   x = TOREAL(pRect->rclBox.left);
            float   y = TOREAL(pRect->rclBox.top);
            float   w = TOREAL(pRect->rclBox.right - x);
            float   h = TOREAL(pRect->rclBox.bottom - y);

            if (!myData->pathOpen)
            {
                if (myData->curBrush != 0)
                {
                    if (myData->curPatIndex < 0)
                    {
                        if (myData->curBrushPattern == NULL)
                        {
                            Gdiplus::SolidBrush brush(Gdiplus::Color(myData->curBrush));
                            g->FillRectangle(&brush, x, y, w, h);
                        }
                        else
                        {
                            BITMAPINFO *        bmi  = (BITMAPINFO *)myData->curBrushPattern->bmi;
                            BYTE *              bits = ((BYTE *)bmi) + myData->curBrushPattern->bitsOffset;

                            DibBrush brush(bmi, bits);
                            g->FillRectangle(brush, x, y, w, h);
                        }
                    }
                    else
                    {
                        BITMAPINFO *            bmi  = (BITMAPINFO *)&hatchBrushInfo;
                        BYTE *                  bits = (BYTE *)HatchPatterns[myData->curPatIndex];

                        bmi->bmiColors[1].rgbRed   = (myData->curBrush & Gdiplus::Color::RedMask)   >> Gdiplus::Color::RedShift;
                        bmi->bmiColors[1].rgbGreen = (myData->curBrush & Gdiplus::Color::GreenMask) >> Gdiplus::Color::GreenShift;
                        bmi->bmiColors[1].rgbBlue  = (myData->curBrush & Gdiplus::Color::BlueMask)  >> Gdiplus::Color::BlueShift;

                        DibBrush brush(bmi, bits);
                        g->FillRectangle(brush, x, y, w, h);
                    }
                }
                if (myData->curPen != 0)
                {
                    Gdiplus::Pen    pen(Gdiplus::Color(myData->curPen), TOREAL(myData->curPenWidth));
                    pen.SetMiterLimit(myData->miterLimit);

                    g->DrawRectangle(&pen, x, y, w, h);
                }
            }
            else
            {
                myData->path->AddRectangle(Gdiplus::RectF(x, y, w, h));
            }
        }
        break;

    case EMR_ARC:
        {
            PEMRARC     pArc = (PEMRARC)lpEMFR;

            float   x = TOREAL(pArc->rclBox.left);
            float   y = TOREAL(pArc->rclBox.top);
            float   w = TOREAL(pArc->rclBox.right - x);
            float   h = TOREAL(pArc->rclBox.bottom - y);
            float   startAngle = PointToAngle(x, y, w, h, TOREAL(pArc->ptlStart.x), TOREAL(pArc->ptlStart.y));
            float   endAngle   = PointToAngle(x, y, w, h, TOREAL(pArc->ptlEnd.x), TOREAL(pArc->ptlEnd.y));
            if (endAngle <= startAngle)
            {
                endAngle += 360;
            }
            float   sweepAngle = endAngle - startAngle;
            if ((myData->arcDirection != AD_COUNTERCLOCKWISE) && (sweepAngle < 360))
            {
                sweepAngle = 360 - sweepAngle;
            }

            if (!myData->pathOpen)
            {
                if (myData->curPen != 0)
                {
                    Gdiplus::Pen    pen(Gdiplus::Color(myData->curPen), TOREAL(myData->curPenWidth));
                    pen.SetMiterLimit(myData->miterLimit);

                    g->DrawArc(&pen, x, y, w, h, startAngle, sweepAngle);
                }
            }
            else
            {
                myData->path->AddArc(x, y, w, h, startAngle, sweepAngle);
            }
        }
        break;

    case EMR_CHORD:
        break;

    case EMR_PIE:
        {
            PEMRARC     pPie = (PEMRARC)lpEMFR;

            float   x = TOREAL(pPie->rclBox.left);
            float   y = TOREAL(pPie->rclBox.top);
            float   w = TOREAL(pPie->rclBox.right - x);
            float   h = TOREAL(pPie->rclBox.bottom - y);
            float   startAngle = PointToAngle(x, y, w, h, TOREAL(pPie->ptlStart.x), TOREAL(pPie->ptlStart.y));
            float   endAngle   = PointToAngle(x, y, w, h, TOREAL(pPie->ptlEnd.x), TOREAL(pPie->ptlEnd.y));
            if (endAngle <= startAngle)
            {
                endAngle += 360;
            }
            float   sweepAngle = endAngle - startAngle;
            if ((myData->arcDirection != AD_COUNTERCLOCKWISE) && (sweepAngle < 360))
            {
                sweepAngle = 360 - sweepAngle;
            }
            if (!myData->pathOpen)
            {
                Gdiplus::GraphicsPath   path(myData->fillMode);
                path.AddPie(x, y, w, h, startAngle, sweepAngle);

                if (myData->curBrush != 0)
                {
                    if (myData->curPatIndex < 0)
                    {
                        if (myData->curBrushPattern == NULL)
                        {
                            Gdiplus::SolidBrush brush(Gdiplus::Color(myData->curBrush));
                            g->FillPath(&brush, &path);
                        }
                        else
                        {
                            BITMAPINFO *        bmi  = (BITMAPINFO *)myData->curBrushPattern->bmi;
                            BYTE *              bits = ((BYTE *)bmi) + myData->curBrushPattern->bitsOffset;

                            DibBrush brush(bmi, bits);
                            g->FillPath(brush, &path);
                        }
                    }
                    else
                    {
                        BITMAPINFO *            bmi  = (BITMAPINFO *)&hatchBrushInfo;
                        BYTE *                  bits = (BYTE *)HatchPatterns[myData->curPatIndex];

                        bmi->bmiColors[1].rgbRed   = (myData->curBrush & Gdiplus::Color::RedMask)   >> Gdiplus::Color::RedShift;
                        bmi->bmiColors[1].rgbGreen = (myData->curBrush & Gdiplus::Color::GreenMask) >> Gdiplus::Color::GreenShift;
                        bmi->bmiColors[1].rgbBlue  = (myData->curBrush & Gdiplus::Color::BlueMask)  >> Gdiplus::Color::BlueShift;

                        DibBrush brush(bmi, bits);
                        g->FillPath(brush, &path);
                    }
                }
                if (myData->curPen != 0)
                {
                    Gdiplus::Pen    pen(Gdiplus::Color(myData->curPen), TOREAL(myData->curPenWidth));
                    pen.SetMiterLimit(myData->miterLimit);

                    g->DrawPath(&pen, &path);
                }
            }
            else
            {
                myData->path->AddPie(x, y, w, h, startAngle, sweepAngle);
            }
        }
        break;

    case EMR_SELECTPALETTE:
        break;

    case EMR_CREATEPALETTE:
        break;

    case EMR_SETPALETTEENTRIES:
        break;

    case EMR_RESIZEPALETTE:
        break;

    case EMR_REALIZEPALETTE:
        break;

    case EMR_EXTFLOODFILL:
        break;

    case EMR_LINETO:
        {
            PEMRMOVETOEX     pLineTo = (PEMRMOVETOEX)lpEMFR;

            float   x = TOREAL(pLineTo->ptl.x);
            float   y = TOREAL(pLineTo->ptl.y);

            if (!myData->pathOpen)
            {
                if (myData->curPen != 0)
                {
                    Gdiplus::Pen    pen(Gdiplus::Color(myData->curPen), TOREAL(myData->curPenWidth));
                    pen.SetMiterLimit(myData->miterLimit);

                    g->DrawLine(&pen, (float)myData->curPos.X, (float)myData->curPos.Y, x, y);
                }
            }
            else
            {
                myData->path->AddLine((float)myData->curPos.X, (float)myData->curPos.Y, x, y);
            }

            myData->curPos.X = x;
            myData->curPos.Y = y;
        }
        break;

    case EMR_ARCTO:
        {
            // !!! Set and use current position

            PEMRARCTO     pArc = (PEMRARCTO)lpEMFR;

            float   x = TOREAL(pArc->rclBox.left);
            float   y = TOREAL(pArc->rclBox.top);
            float   w = TOREAL(pArc->rclBox.right - x);
            float   h = TOREAL(pArc->rclBox.bottom - y);
            float   startAngle = PointToAngle(x, y, w, h, TOREAL(pArc->ptlStart.x), TOREAL(pArc->ptlStart.y));
            float   endAngle   = PointToAngle(x, y, w, h, TOREAL(pArc->ptlEnd.x), TOREAL(pArc->ptlEnd.y));
            if (endAngle <= startAngle)
            {
                endAngle += 360;
            }
            float   sweepAngle = endAngle - startAngle;
            if ((myData->arcDirection != AD_COUNTERCLOCKWISE) && (sweepAngle < 360))
            {
                sweepAngle = 360 - sweepAngle;
            }

            if (!myData->pathOpen)
            {
                if (myData->curPen != 0)
                {
                    Gdiplus::Pen    pen(Gdiplus::Color(myData->curPen), TOREAL(myData->curPenWidth));
                    pen.SetMiterLimit(myData->miterLimit);

                    g->DrawArc(&pen, x, y, w, h, startAngle, sweepAngle);
                }
            }
            else
            {
                myData->path->AddArc(x, y, w, h, startAngle, sweepAngle);
            }
        }
        break;

    case EMR_POLYDRAW:
        break;

    case EMR_SETARCDIRECTION:
        {
            PEMRSETARCDIRECTION     pArcDirection = (PEMRSETARCDIRECTION)lpEMFR;

            myData->arcDirection = pArcDirection->iArcDirection;
        }
        break;

    case EMR_SETMITERLIMIT:
        {
            PEMRSETMITERLIMIT     pMiterLimit = (PEMRSETMITERLIMIT)lpEMFR;

            myData->miterLimit = pMiterLimit->eMiterLimit;
        }
        break;

    case EMR_BEGINPATH:
        {
            delete myData->path;

            myData->path = new Gdiplus::GraphicsPath (myData->fillMode);
            myData->pathOpen = (myData->path != NULL);
        }
        break;

    case EMR_ENDPATH:
        myData->pathOpen = FALSE;
        break;

    case EMR_CLOSEFIGURE:
        {
            if (myData->pathOpen)
            {
                myData->path->CloseFigure();
            }
        }
        break;

    case EMR_FILLPATH:
        {
            if (myData->path != NULL)
            {
                if (myData->curBrush != 0)
                {
                    if (myData->curPatIndex < 0)
                    {
                        if (myData->curBrushPattern == NULL)
                        {
                            Gdiplus::SolidBrush brush(Gdiplus::Color(myData->curBrush));
                            g->FillPath(&brush, myData->path);
                        }
                        else
                        {
                            BITMAPINFO *        bmi  = (BITMAPINFO *)myData->curBrushPattern->bmi;
                            BYTE *              bits = ((BYTE *)bmi) + myData->curBrushPattern->bitsOffset;

                            DibBrush brush(bmi, bits);
                            g->FillPath(brush, myData->path);
                        }
                    }
                    else
                    {
                        BITMAPINFO *            bmi  = (BITMAPINFO *)&hatchBrushInfo;
                        BYTE *                  bits = (BYTE *)HatchPatterns[myData->curPatIndex];

                        bmi->bmiColors[1].rgbRed   = (myData->curBrush & Gdiplus::Color::RedMask)   >> Gdiplus::Color::RedShift;
                        bmi->bmiColors[1].rgbGreen = (myData->curBrush & Gdiplus::Color::GreenMask) >> Gdiplus::Color::GreenShift;
                        bmi->bmiColors[1].rgbBlue  = (myData->curBrush & Gdiplus::Color::BlueMask)  >> Gdiplus::Color::BlueShift;

                        DibBrush brush(bmi, bits);
                        g->FillPath(brush, myData->path);
                    }
                }
                delete myData->path;
                myData->path = NULL;
                myData->pathOpen = FALSE;
            }
        }
        break;

    case EMR_STROKEANDFILLPATH:
        {
            if (myData->path != NULL)
            {
                if (myData->curBrush != 0)
                {
                    if (myData->curPatIndex < 0)
                    {
                        if (myData->curBrushPattern == NULL)
                        {
                            Gdiplus::SolidBrush brush(Gdiplus::Color(myData->curBrush));
                            g->FillPath(&brush, myData->path);
                        }
                        else
                        {
                            BITMAPINFO *        bmi  = (BITMAPINFO *)myData->curBrushPattern->bmi;
                            BYTE *              bits = ((BYTE *)bmi) + myData->curBrushPattern->bitsOffset;

                            DibBrush brush(bmi, bits);
                            g->FillPath(brush, myData->path);
                        }
                    }
                    else
                    {
                        BITMAPINFO *            bmi  = (BITMAPINFO *)&hatchBrushInfo;
                        BYTE *                  bits = (BYTE *)HatchPatterns[myData->curPatIndex];

                        bmi->bmiColors[1].rgbRed   = (myData->curBrush & Gdiplus::Color::RedMask)   >> Gdiplus::Color::RedShift;
                        bmi->bmiColors[1].rgbGreen = (myData->curBrush & Gdiplus::Color::GreenMask) >> Gdiplus::Color::GreenShift;
                        bmi->bmiColors[1].rgbBlue  = (myData->curBrush & Gdiplus::Color::BlueMask)  >> Gdiplus::Color::BlueShift;

                        DibBrush brush(bmi, bits);
                        g->FillPath(brush, myData->path);
                    }
                }
                if (myData->curPen != 0)
                {
                    Gdiplus::Pen    pen(Gdiplus::Color(myData->curPen), TOREAL(myData->curPenWidth));
                    pen.SetMiterLimit(myData->miterLimit);

                    g->DrawPath(&pen, myData->path);
                }
                delete myData->path;
                myData->path = NULL;
                myData->pathOpen = FALSE;
            }
        }
        break;

    case EMR_STROKEPATH:
        {
            if (myData->path != NULL)
            {
                if (myData->curPen != 0)
                {
                    Gdiplus::Pen    pen(Gdiplus::Color(myData->curPen), TOREAL(myData->curPenWidth));
                    pen.SetMiterLimit(myData->miterLimit);

                    g->DrawPath(&pen, myData->path);
                }
                delete myData->path;
                myData->path = NULL;
                myData->pathOpen = FALSE;
            }
        }
        break;

    case EMR_FLATTENPATH:
        {
            if (myData->path != NULL)
            {
                myData->path->Flatten(NULL);
            }
        }
        break;

    case EMR_WIDENPATH:
        {
            if (myData->path != NULL)
            {
                Gdiplus::Pen    pen(Gdiplus::Color(myData->curPen), TOREAL(myData->curPenWidth));
                pen.SetMiterLimit(myData->miterLimit);

                myData->path->Widen(&pen);
            }
        }
        break;

    case EMR_SELECTCLIPPATH:
        {
            if (myData->path != NULL)
            {
                PEMRSELECTCLIPPATH     pSetClipPath = (PEMRSELECTCLIPPATH)lpEMFR;

                switch (pSetClipPath->iMode)
                {
                case RGN_COPY:
                default:
                    g->SetClip(myData->path);
                    break;
                case RGN_AND:
                    {
                        Gdiplus::Region     region(myData->path);
                        g->IntersectClip(&region);
                    }
                    break;
                case RGN_DIFF:
                    {
                        Gdiplus::Region     region(myData->path);
                        Gdiplus::Region curClip;
                        g->GetClip(&curClip);
                        curClip.Exclude(&region);
                        g->SetClip(&curClip);
                    }
                    break;
                case RGN_OR:
                    {
                        Gdiplus::Region     region(myData->path);
                        Gdiplus::Region curClip;
                        g->GetClip(&curClip);
                        curClip.Union(&region);
                        g->SetClip(&curClip);
                    }
                    break;
                case RGN_XOR:
                    {
                        Gdiplus::Region     region(myData->path);
                        Gdiplus::Region curClip;
                        g->GetClip(&curClip);
                        curClip.Xor(&region);
                        g->SetClip(&curClip);
                    }
                    break;
                }
                delete myData->path;
                myData->path = NULL;
                myData->pathOpen = FALSE;
            }
        }
        break;

    case EMR_ABORTPATH:
        {
            if (myData->path != NULL)
            {
                delete myData->path;
                myData->path = NULL;
                myData->pathOpen = FALSE;
            }
        }
        break;

    case EMR_GDICOMMENT:
        break;

    case EMR_FILLRGN:
        break;

    case EMR_FRAMERGN:
        break;

    case EMR_INVERTRGN:
        break;

    case EMR_PAINTRGN:
        break;

    case EMR_EXTSELECTCLIPRGN:
        break;

    case EMR_BITBLT:
        {
            PEMRBITBLT     pBitBlt = (PEMRBITBLT)lpEMFR;

            switch (pBitBlt->dwRop)
            {
            case BLACKNESS:
                {
                    Gdiplus::SolidBrush brush(Gdiplus::Color(0xff000000));
                    float cx, cy;
                    GetPixelSize (g, &cx, &cy);
                    g->FillRectangle(&brush, TOREAL(pBitBlt->xDest), TOREAL(pBitBlt->yDest), TOREAL(pBitBlt->cxDest + cx), TOREAL(pBitBlt->cyDest + cy));
                }
                return;
            case WHITENESS:
                {
                    Gdiplus::SolidBrush brush(Gdiplus::Color(0xffffffff));
                    float cx, cy;
                    GetPixelSize (g, &cx, &cy);
                    g->FillRectangle(&brush, TOREAL(pBitBlt->xDest), TOREAL(pBitBlt->yDest), TOREAL(pBitBlt->cxDest + 1), TOREAL(pBitBlt->cyDest + 1));
                }
                return;
            default:
                if (!ISSOURCEINROP3(pBitBlt->dwRop))
                {
                    if (myData->curBrush != 0)
                    {
                        if (myData->curPatIndex < 0)
                        {
                            if (myData->curBrushPattern == NULL)
                            {
                                Gdiplus::SolidBrush brush(Gdiplus::Color(myData->curBrush));
                                float cx, cy;
                                GetPixelSize (g, &cx, &cy);
                                g->FillRectangle(&brush, TOREAL(pBitBlt->xDest), TOREAL(pBitBlt->yDest), TOREAL(pBitBlt->cxDest + cx), TOREAL(pBitBlt->cyDest + cy));
                            }
                            else
                            {
                                BITMAPINFO *        bmi  = (BITMAPINFO *)myData->curBrushPattern->bmi;
                                BYTE *              bits = ((BYTE *)bmi) + myData->curBrushPattern->bitsOffset;

                                DibBrush brush(bmi, bits);
                                float cx, cy;
                                GetPixelSize (g, &cx, &cy);
                                g->FillRectangle(brush, TOREAL(pBitBlt->xDest), TOREAL(pBitBlt->yDest), TOREAL(pBitBlt->cxDest + cx), TOREAL(pBitBlt->cyDest + cy));
                            }
                        }
                        else
                        {
                            BITMAPINFO *            bmi  = (BITMAPINFO *)&hatchBrushInfo;
                            BYTE *                  bits = (BYTE *)HatchPatterns[myData->curPatIndex];

                            bmi->bmiColors[1].rgbRed   = (myData->curBrush & Gdiplus::Color::RedMask)   >> Gdiplus::Color::RedShift;
                            bmi->bmiColors[1].rgbGreen = (myData->curBrush & Gdiplus::Color::GreenMask) >> Gdiplus::Color::GreenShift;
                            bmi->bmiColors[1].rgbBlue  = (myData->curBrush & Gdiplus::Color::BlueMask)  >> Gdiplus::Color::BlueShift;

                            DibBrush brush(bmi, bits);
                            float cx, cy;
                            GetPixelSize (g, &cx, &cy);
                            g->FillRectangle(brush, TOREAL(pBitBlt->xDest), TOREAL(pBitBlt->yDest), TOREAL(pBitBlt->cxDest + cx), TOREAL(pBitBlt->cyDest + cy));
                        }
                    }
                    return;
                }
                break;
            }

            // Else assume SRCCOPY
            BITMAPINFO *bmi = (BITMAPINFO *)(((BYTE *)pBitBlt) + pBitBlt->offBmiSrc);
            BYTE *bits      = ((BYTE *)pBitBlt) + pBitBlt->offBitsSrc;

            DibStream dibStream(bmi, bits);
            Gdiplus::Bitmap         gpBitmap(&dibStream);
            Gdiplus::RectF destRect(TOREAL(pBitBlt->xDest),
                                         TOREAL(pBitBlt->yDest),
                                         TOREAL(pBitBlt->cxDest),
                                         TOREAL(pBitBlt->cyDest));

            g->DrawImage(&gpBitmap, destRect,
                         TOREAL(pBitBlt->xSrc),
                         TOREAL(pBitBlt->ySrc),
                         TOREAL(pBitBlt->cxDest),
                         TOREAL(pBitBlt->cyDest),
                         Gdiplus::UnitPixel);

        }
        break;

    case EMR_STRETCHBLT:
        {
            PEMRSTRETCHBLT     pStretchBlt = (PEMRSTRETCHBLT)lpEMFR;

            switch (pStretchBlt->dwRop)
            {
            case BLACKNESS:
                {
                    Gdiplus::SolidBrush brush(Gdiplus::Color(0xff000000));
                    float cx, cy;
                    GetPixelSize (g, &cx, &cy);
                    g->FillRectangle(&brush, TOREAL(pStretchBlt->xDest), TOREAL(pStretchBlt->yDest), TOREAL(pStretchBlt->cxDest + cx), TOREAL(pStretchBlt->cyDest + cy));
                }
                return;
            case WHITENESS:
                {
                    Gdiplus::SolidBrush brush(Gdiplus::Color(0xffffffff));
                    float cx, cy;
                    GetPixelSize (g, &cx, &cy);
                    g->FillRectangle(&brush, TOREAL(pStretchBlt->xDest), TOREAL(pStretchBlt->yDest), TOREAL(pStretchBlt->cxDest + cx), TOREAL(pStretchBlt->cyDest + cy));
                }
                return;
            default:
                if (!ISSOURCEINROP3(pStretchBlt->dwRop))
                {
                    float cx, cy;
                    GetPixelSize (g, &cx, &cy);
                    if (myData->curBrush != 0)
                    {
                        if (myData->curPatIndex < 0)
                        {
                            if (myData->curBrushPattern == NULL)
                            {
                                Gdiplus::SolidBrush brush(Gdiplus::Color(myData->curBrush));
                                g->FillRectangle(&brush, TOREAL(pStretchBlt->xDest), TOREAL(pStretchBlt->yDest), TOREAL(pStretchBlt->cxDest + cx), TOREAL(pStretchBlt->cyDest + cy));
                            }
                            else
                            {
                                BITMAPINFO *        bmi  = (BITMAPINFO *)myData->curBrushPattern->bmi;
                                BYTE *              bits = ((BYTE *)bmi) + myData->curBrushPattern->bitsOffset;

                                DibBrush brush(bmi, bits);
                                g->FillRectangle(brush, TOREAL(pStretchBlt->xDest), TOREAL(pStretchBlt->yDest), TOREAL(pStretchBlt->cxDest + cx), TOREAL(pStretchBlt->cyDest + cy));
                            }
                        }
                        else
                        {
                            BITMAPINFO *            bmi  = (BITMAPINFO *)&hatchBrushInfo;
                            BYTE *                  bits = (BYTE *)HatchPatterns[myData->curPatIndex];

                            bmi->bmiColors[1].rgbRed   = (myData->curBrush & Gdiplus::Color::RedMask)   >> Gdiplus::Color::RedShift;
                            bmi->bmiColors[1].rgbGreen = (myData->curBrush & Gdiplus::Color::GreenMask) >> Gdiplus::Color::GreenShift;
                            bmi->bmiColors[1].rgbBlue  = (myData->curBrush & Gdiplus::Color::BlueMask)  >> Gdiplus::Color::BlueShift;

                            DibBrush brush(bmi, bits);
                            g->FillRectangle(brush, TOREAL(pStretchBlt->xDest), TOREAL(pStretchBlt->yDest), TOREAL(pStretchBlt->cxDest + cx), TOREAL(pStretchBlt->cyDest + cy));
                        }
                    }
                    return;
                }
                break;
            }

            // Else assume SRCCOPY
            BITMAPINFO *bmi = (BITMAPINFO *)(((BYTE *)pStretchBlt) + pStretchBlt->offBmiSrc);
            BYTE *bits      = ((BYTE *)pStretchBlt) + pStretchBlt->offBitsSrc;

            DibStream dibStream(bmi, bits);
            Gdiplus::Bitmap         gpBitmap(&dibStream);
            Gdiplus::RectF destRect(TOREAL(pStretchBlt->xDest),
                                         TOREAL(pStretchBlt->yDest),
                                         TOREAL(pStretchBlt->cxDest),
                                         TOREAL(pStretchBlt->cyDest));

            g->DrawImage(&gpBitmap, destRect,
                         TOREAL(pStretchBlt->xSrc),
                         TOREAL(pStretchBlt->ySrc),
                         TOREAL(pStretchBlt->cxSrc),
                         TOREAL(pStretchBlt->cySrc),
                         Gdiplus::UnitPixel);
        }
        break;

    case EMR_MASKBLT:
        break;

    case EMR_PLGBLT:
        break;

    case EMR_SETDIBITSTODEVICE:
        break;
#if 0
typedef struct tagEMRSETDIBITSTODEVICE
{
    EMR     emr;
    RECTL   rclBounds;          // Inclusive-inclusive bounds in device units
    LONG    xDest;
    LONG    yDest;
    LONG    xSrc;
    LONG    ySrc;
    LONG    cxSrc;
    LONG    cySrc;
    DWORD   offBmiSrc;          // Offset to the source BITMAPINFO structure
    DWORD   cbBmiSrc;           // Size of the source BITMAPINFO structure
    DWORD   offBitsSrc;         // Offset to the source bitmap bits
    DWORD   cbBitsSrc;          // Size of the source bitmap bits
    DWORD   iUsageSrc;          // Source bitmap info color table usage
    DWORD   iStartScan;
    DWORD   cScans;
} EMRSETDIBITSTODEVICE, *PEMRSETDIBITSTODEVICE;
#endif

    case EMR_STRETCHDIBITS:
        {
            PEMRSTRETCHDIBITS     pStretchBlt = (PEMRSTRETCHDIBITS)lpEMFR;

            switch (pStretchBlt->dwRop)
            {
            case BLACKNESS:
                {
                    float cx, cy;
                    GetPixelSize (g, &cx, &cy);
                    Gdiplus::SolidBrush brush(Gdiplus::Color(0xff000000));
                    g->FillRectangle(&brush, TOREAL(pStretchBlt->xDest), TOREAL(pStretchBlt->yDest), TOREAL(pStretchBlt->cxDest + cx), TOREAL(pStretchBlt->cyDest + cy));
                }
                return;
            case WHITENESS:
                {
                    float cx, cy;
                    GetPixelSize (g, &cx, &cy);
                    Gdiplus::SolidBrush brush(Gdiplus::Color(0xffffffff));
                    g->FillRectangle(&brush, TOREAL(pStretchBlt->xDest), TOREAL(pStretchBlt->yDest), TOREAL(pStretchBlt->cxDest + cx), TOREAL(pStretchBlt->cyDest + cy));
                }
                return;
            default:
                if (!ISSOURCEINROP3(pStretchBlt->dwRop))
                {
                    float cx, cy;
                    GetPixelSize (g, &cx, &cy);
                    if (myData->curBrush != 0)
                    {
                        if (myData->curPatIndex < 0)
                        {
                            if (myData->curBrushPattern == NULL)
                            {
                                Gdiplus::SolidBrush brush(Gdiplus::Color(myData->curBrush));
                                g->FillRectangle(&brush, TOREAL(pStretchBlt->xDest), TOREAL(pStretchBlt->yDest), TOREAL(pStretchBlt->cxDest + cx), TOREAL(pStretchBlt->cyDest + cy));
                            }
                            else
                            {
                                BITMAPINFO *        bmi  = (BITMAPINFO *)myData->curBrushPattern->bmi;
                                BYTE *              bits = ((BYTE *)bmi) + myData->curBrushPattern->bitsOffset;

                                DibBrush brush(bmi, bits);
                                g->FillRectangle(brush, TOREAL(pStretchBlt->xDest), TOREAL(pStretchBlt->yDest), TOREAL(pStretchBlt->cxDest + cx), TOREAL(pStretchBlt->cyDest + cy));
                            }
                        }
                        else
                        {
                            BITMAPINFO *            bmi  = (BITMAPINFO *)&hatchBrushInfo;
                            BYTE *                  bits = (BYTE *)HatchPatterns[myData->curPatIndex];

                            bmi->bmiColors[1].rgbRed   = (myData->curBrush & Gdiplus::Color::RedMask)   >> Gdiplus::Color::RedShift;
                            bmi->bmiColors[1].rgbGreen = (myData->curBrush & Gdiplus::Color::GreenMask) >> Gdiplus::Color::GreenShift;
                            bmi->bmiColors[1].rgbBlue  = (myData->curBrush & Gdiplus::Color::BlueMask)  >> Gdiplus::Color::BlueShift;

                            DibBrush brush(bmi, bits);
                            g->FillRectangle(brush, TOREAL(pStretchBlt->xDest), TOREAL(pStretchBlt->yDest), TOREAL(pStretchBlt->cxDest + cx), TOREAL(pStretchBlt->cyDest + cy));
                        }
                    }
                    return;
                }
                break;
            }

            // Else assume SRCCOPY
            BITMAPINFO *bmi = (BITMAPINFO *)(((BYTE *)pStretchBlt) + pStretchBlt->offBmiSrc);
            BYTE *bits      = ((BYTE *)pStretchBlt) + pStretchBlt->offBitsSrc;

            DibStream dibStream(bmi, bits);
            Gdiplus::Bitmap         gpBitmap(&dibStream);
            Gdiplus::RectF destRect(TOREAL(pStretchBlt->xDest),
                                         TOREAL(pStretchBlt->yDest),
                                         TOREAL(pStretchBlt->cxDest),
                                         TOREAL(pStretchBlt->cyDest));

            g->DrawImage(&gpBitmap, destRect,
                         TOREAL(pStretchBlt->xSrc),
                         TOREAL(pStretchBlt->ySrc),
                         TOREAL(pStretchBlt->cxSrc),
                         TOREAL(pStretchBlt->cySrc),
                         Gdiplus::UnitPixel);
        }
        break;

    case EMR_EXTCREATEFONTINDIRECTW:
        break;

    case EMR_EXTTEXTOUTA:
        break;

    case EMR_EXTTEXTOUTW:
        break;

    case EMR_POLYBEZIER16:
        {
            PEMRPOLYBEZIER16     pBezier = (PEMRPOLYBEZIER16)lpEMFR;

            if (pBezier->cpts > 0)
            {
                int                 i = pBezier->cpts;
                Gdiplus::PointF *   points = new Gdiplus::PointF[i];

                do
                {
                    i--;
                    points[i].X = pBezier->apts[i].x;
                    points[i].Y = pBezier->apts[i].y;
                } while (i > 0);

                if (!myData->pathOpen)
                {
                    if (myData->curPen != 0)
                    {
                        Gdiplus::Pen    pen(Gdiplus::Color(myData->curPen), TOREAL(myData->curPenWidth));
                        pen.SetMiterLimit(myData->miterLimit);

                        g->DrawBeziers(&pen, points, pBezier->cpts);
                    }
                }
                else
                {
                    myData->path->AddBeziers(points, pBezier->cpts);
                }

                delete [] points;
            }
        }
        break;

    case EMR_POLYGON16:
        {
            PEMRPOLYGON16     pPolygon = (PEMRPOLYGON16)lpEMFR;

            if (pPolygon->cpts > 0)
            {
                int                 i = pPolygon->cpts;
                Gdiplus::PointF *   points = new Gdiplus::PointF[i];

                do
                {
                    i--;
                    points[i].X = pPolygon->apts[i].x;
                    points[i].Y = pPolygon->apts[i].y;
                } while (i > 0);

                if (!myData->pathOpen)
                {
                    Gdiplus::GraphicsPath   path(myData->fillMode);
                    path.AddPolygon(points, pPolygon->cpts);

                    if (myData->curBrush != 0)
                    {
                        if (myData->curPatIndex < 0)
                        {
                            if (myData->curBrushPattern == NULL)
                            {
                                Gdiplus::SolidBrush brush(Gdiplus::Color(myData->curBrush));
                                g->FillPath(&brush, &path);
                            }
                            else
                            {
                                BITMAPINFO *        bmi  = (BITMAPINFO *)myData->curBrushPattern->bmi;
                                BYTE *              bits = ((BYTE *)bmi) + myData->curBrushPattern->bitsOffset;

                                DibBrush brush(bmi, bits);
                                g->FillPath(brush, &path);
                            }
                        }
                        else
                        {
                            BITMAPINFO *            bmi  = (BITMAPINFO *)&hatchBrushInfo;
                            BYTE *                  bits = (BYTE *)HatchPatterns[myData->curPatIndex];

                            bmi->bmiColors[1].rgbRed   = (myData->curBrush & Gdiplus::Color::RedMask)   >> Gdiplus::Color::RedShift;
                            bmi->bmiColors[1].rgbGreen = (myData->curBrush & Gdiplus::Color::GreenMask) >> Gdiplus::Color::GreenShift;
                            bmi->bmiColors[1].rgbBlue  = (myData->curBrush & Gdiplus::Color::BlueMask)  >> Gdiplus::Color::BlueShift;

                            DibBrush brush(bmi, bits);
                            g->FillPath(brush, &path);
                        }
                    }
                    if (myData->curPen != 0)
                    {
                        Gdiplus::Pen    pen(Gdiplus::Color(myData->curPen), TOREAL(myData->curPenWidth));
                        pen.SetMiterLimit(myData->miterLimit);

                        g->DrawPath(&pen, &path);
                    }
                }
                else
                {
                    myData->path->AddPolygon(points, pPolygon->cpts);
                }
                delete [] points;
            }
        }
        break;

    case EMR_POLYLINE16:
        {
            PEMRPOLYLINE16     pPolyline = (PEMRPOLYLINE16)lpEMFR;

            if (pPolyline->cpts > 0)
            {
                int                 i = pPolyline->cpts;
                Gdiplus::PointF *   points = new Gdiplus::PointF[i];

                do
                {
                    i--;
                    points[i].X = pPolyline->apts[i].x;
                    points[i].Y = pPolyline->apts[i].y;
                } while (i > 0);

                if (!myData->pathOpen)
                {
                    if (myData->curPen != 0)
                    {
                        Gdiplus::Pen    pen(Gdiplus::Color(myData->curPen), TOREAL(myData->curPenWidth));
                        pen.SetMiterLimit(myData->miterLimit);

                        g->DrawLines(&pen, points, pPolyline->cpts);
                    }
                }
                else
                {
                    myData->path->AddLines(points, pPolyline->cpts);
                }

                delete [] points;
            }
        }
        break;

    case EMR_POLYBEZIERTO16:
        {
            PEMRPOLYBEZIERTO16     pBezier = (PEMRPOLYBEZIERTO16)lpEMFR;

            if (pBezier->cpts > 0)
            {
                int                 i = pBezier->cpts;
                Gdiplus::PointF *   points = new Gdiplus::PointF[i+1];

                do
                {
                    points[i].X = pBezier->apts[i-1].x;
                    points[i].Y = pBezier->apts[i-1].y;
                    i--;
                } while (i > 0);

                points[0] = myData->curPos;
                myData->curPos = points[pBezier->cpts];

                if (!myData->pathOpen)
                {
                    if (myData->curPen != 0)
                    {
                        Gdiplus::Pen    pen(Gdiplus::Color(myData->curPen), TOREAL(myData->curPenWidth));
                        pen.SetMiterLimit(myData->miterLimit);

                        g->DrawBeziers(&pen, points, pBezier->cpts+1);
                    }
                }
                else
                {
                    myData->path->AddBeziers(points, pBezier->cpts+1);
                }

                delete [] points;
            }
        }
        break;

    case EMR_POLYLINETO16:
        {
            PEMRPOLYLINETO16     pPolyline = (PEMRPOLYLINETO16)lpEMFR;

            if (pPolyline->cpts > 0)
            {
                int                 i = pPolyline->cpts;
                Gdiplus::PointF *   points = new Gdiplus::PointF[i+1];

                do
                {
                    points[i].X = pPolyline->apts[i-1].x;
                    points[i].Y = pPolyline->apts[i-1].y;
                    i--;
                } while (i > 0);

                points[0] = myData->curPos;
                myData->curPos = points[pPolyline->cpts];

                if (!myData->pathOpen)
                {
                    if (myData->curPen != 0)
                    {
                        Gdiplus::Pen    pen(Gdiplus::Color(myData->curPen), TOREAL(myData->curPenWidth));
                        pen.SetMiterLimit(myData->miterLimit);

                        g->DrawLines(&pen, points, pPolyline->cpts+1);
                    }
                }
                else
                {
                    myData->path->AddLines(points, pPolyline->cpts+1);
                }

                delete [] points;
            }
        }
        break;

    case EMR_POLYPOLYLINE16:
        {
            PEMRPOLYPOLYLINE16     pPolyline = (PEMRPOLYPOLYLINE16)lpEMFR;

            if ((pPolyline->cpts > 0) && (pPolyline->nPolys > 0))
            {
                int                 i = pPolyline->cpts;
                Gdiplus::PointF *   points = new Gdiplus::PointF[i];
                POINTS *            metaPoints = (POINTS *)(pPolyline->aPolyCounts + pPolyline->nPolys);

                do
                {
                    i--;
                    points[i].X = metaPoints[i].x;
                    points[i].Y = metaPoints[i].y;
                } while (i > 0);

                if (!myData->pathOpen)
                {
                    if (myData->curPen != 0)
                    {
                        Gdiplus::Pen    pen(Gdiplus::Color(myData->curPen), TOREAL(myData->curPenWidth));
                        pen.SetMiterLimit(myData->miterLimit);

                        i = 0;
                        Gdiplus::PointF *   tmpPoints = points;
                        DWORD       count;
                        do
                        {
                            count = pPolyline->aPolyCounts[i];
                            g->DrawLines(&pen, tmpPoints, count);
                            tmpPoints += count;
                        } while ((UINT)++i < pPolyline->nPolys);
                    }
                }
                else
                {
                    i = 0;
                    Gdiplus::PointF *   tmpPoints = points;
                    DWORD       count;
                    do
                    {
                        count = pPolyline->aPolyCounts[i];
                        myData->path->AddLines(tmpPoints, count);
                        tmpPoints += count;
                    } while ((UINT)++i < pPolyline->nPolys);
                }

                delete [] points;
            }
        }
        break;

    case EMR_POLYPOLYGON16:
        {
            PEMRPOLYPOLYGON16     pPolygon = (PEMRPOLYPOLYGON16)lpEMFR;

            if ((pPolygon->cpts > 0) && (pPolygon->nPolys > 0))
            {
                int                 i = pPolygon->cpts;
                Gdiplus::PointF *   points = new Gdiplus::PointF[i];
                POINTS *            metaPoints = (POINTS *)(pPolygon->aPolyCounts + pPolygon->nPolys);

                do
                {
                    i--;
                    points[i].X = metaPoints[i].x;
                    points[i].Y = metaPoints[i].y;
                } while (i > 0);

                Gdiplus::GraphicsPath   path(myData->fillMode);
                Gdiplus::GraphicsPath * tmpPath = &path;

                if (myData->pathOpen)
                {
                    tmpPath = myData->path;
                }

                Gdiplus::PointF *   tmpPoints = points;
                DWORD       count;
                i = 0;
                do
                {
                    count = pPolygon->aPolyCounts[i];
                    tmpPath->StartFigure();
                    tmpPath->AddPolygon(tmpPoints, count);
                    tmpPoints += count;
                } while ((UINT)++i < pPolygon->nPolys);

                if (!myData->pathOpen)
                {
                    if (myData->curBrush != 0)
                    {
                        if (myData->curPatIndex < 0)
                        {
                            if (myData->curBrushPattern == NULL)
                            {
                                Gdiplus::SolidBrush brush(Gdiplus::Color(myData->curBrush));
                                g->FillPath(&brush, &path);
                            }
                            else
                            {
                                BITMAPINFO *        bmi  = (BITMAPINFO *)myData->curBrushPattern->bmi;
                                BYTE *              bits = ((BYTE *)bmi) + myData->curBrushPattern->bitsOffset;

                                DibBrush brush(bmi, bits);
                                g->FillPath(brush, &path);
                            }
                        }
                        else
                        {
                            BITMAPINFO *            bmi  = (BITMAPINFO *)&hatchBrushInfo;
                            BYTE *                  bits = (BYTE *)HatchPatterns[myData->curPatIndex];

                            bmi->bmiColors[1].rgbRed   = (myData->curBrush & Gdiplus::Color::RedMask)   >> Gdiplus::Color::RedShift;
                            bmi->bmiColors[1].rgbGreen = (myData->curBrush & Gdiplus::Color::GreenMask) >> Gdiplus::Color::GreenShift;
                            bmi->bmiColors[1].rgbBlue  = (myData->curBrush & Gdiplus::Color::BlueMask)  >> Gdiplus::Color::BlueShift;

                            DibBrush brush(bmi, bits);
                            g->FillPath(brush, &path);
                        }
                    }
                    if (myData->curPen != 0)
                    {
                        Gdiplus::Pen    pen(Gdiplus::Color(myData->curPen), TOREAL(myData->curPenWidth));
                        pen.SetMiterLimit(myData->miterLimit);

                        g->DrawPath(&pen, &path);
                    }
                }

                delete [] points;
            }
        }
        break;

    case EMR_POLYDRAW16:
        break;

    case EMR_CREATEMONOBRUSH:
        break;

    case EMR_CREATEDIBPATTERNBRUSHPT:
        {
            PEMRCREATEDIBPATTERNBRUSHPT     pBrush = (PEMRCREATEDIBPATTERNBRUSHPT)lpEMFR;

            ASSERT(pBrush->ihBrush < myData->numObjects);

            myData->pObjects[pBrush->ihBrush].type  = MYOBJECTS::BrushObjectType;
            myData->pObjects[pBrush->ihBrush].color  = 0xFF808080;
            myData->pObjects[pBrush->ihBrush].patIndex = -1;
            delete myData->pObjects[pBrush->ihBrush].brushPattern;
            myData->pObjects[pBrush->ihBrush].brushPattern = new MYPATTERNBRUSH();

            if (myData->pObjects[pBrush->ihBrush].brushPattern != NULL)
            {
                BYTE *  data = new BYTE[pBrush->cbBmi + pBrush->cbBits];

                if (data != NULL)
                {
                    memcpy(data, ((BYTE *)pBrush) + pBrush->offBmi, pBrush->cbBmi);
                    memcpy(data + pBrush->cbBmi, ((BYTE *)pBrush) + pBrush->offBits, pBrush->cbBits);
                    myData->pObjects[pBrush->ihBrush].brushPattern->bmi = (BITMAPINFO *)data;
                    myData->pObjects[pBrush->ihBrush].brushPattern->bitsOffset = pBrush->cbBmi;
                }
                else
                {
                    delete myData->pObjects[pBrush->ihBrush].brushPattern;
                    myData->pObjects[pBrush->ihBrush].brushPattern = NULL;
                }
            }
        }
        break;

    case EMR_EXTCREATEPEN:
        {
            PEMREXTCREATEPEN        pPen = (PEMREXTCREATEPEN)lpEMFR;
            COLORREF                cRef = pPen->elp.elpColor;

            ASSERT((cRef & 0x01000000) == 0);

            ASSERT(pPen->ihPen < myData->numObjects);

            delete myData->pObjects[pPen->ihPen].brushPattern;
            myData->pObjects[pPen->ihPen].brushPattern = NULL;

            myData->pObjects[pPen->ihPen].type  = MYOBJECTS::PenObjectType;
            myData->pObjects[pPen->ihPen].color = Gdiplus::Color::MakeARGB(0xff,
                        GetRValue(cRef), GetGValue(cRef), GetBValue(cRef));

            myData->pObjects[pPen->ihPen].penWidth = pPen->elp.elpWidth;
        }
        break;

    case EMR_POLYTEXTOUTA:
        break;

    case EMR_POLYTEXTOUTW:
        break;

    case EMR_SETICMMODE:
    case EMR_CREATECOLORSPACE:
    case EMR_SETCOLORSPACE:
    case EMR_DELETECOLORSPACE:
    case EMR_GLSRECORD:
    case EMR_GLSBOUNDEDRECORD:
    case EMR_PIXELFORMAT:
        break;

    case EMR_DRAWESCAPE:
    case EMR_EXTESCAPE:
    case EMR_STARTDOC:
    case EMR_SMALLTEXTOUT:
    case EMR_FORCEUFIMAPPING:
    case EMR_NAMEDESCAPE:
    case EMR_COLORCORRECTPALETTE:
    case EMR_SETICMPROFILEA:
    case EMR_SETICMPROFILEW:
    case EMR_ALPHABLEND:
    case EMR_SETLAYOUT:
    case EMR_TRANSPARENTBLT:
    case EMR_GRADIENTFILL:
    case EMR_SETLINKEDUFIS:
    case EMR_SETTEXTJUSTIFICATION:
    case EMR_COLORMATCHTOTARGETW:
    case EMR_CREATECOLORSPACEW:
        break;
    }
}

BOOL StepRecord(
    Gdiplus::EmfPlusRecordType      recordType,
    UINT                            recordFlags,
    UINT                            recordDataSize,
    const BYTE *                    recordData,
    VOID *                          callbackData,
    HDC                             hDC = NULL,
    LPHANDLETABLE                   lpHTable = NULL,
    LPMETARECORD                    lpMFR = NULL,
    LPENHMETARECORD                 lpEMFR = NULL,
    int                             nObj = 0
    );

VOID ListRecord(
    Gdiplus::EmfPlusRecordType      recordType
    );

/***********************************************************************

  FUNCTION   : EnumMFIndirect

  PARAMETERS : HDC             hDC
               LPHANDLETABLE   lpHTable
               LPMETARECORD    lpMFR
               LPENHMETARECORD lpEMFR
               int             nObj
               LPARAM          lpData


  PURPOSE    : called by EnumMetaFile and EnumEnhMetaFile.  Handles the stepping of
               each metafile record.

  MESSAGES   : none

  RETURNS    : int

  COMMENTS   : ENUMMFSTEP is used whenever records are to be played,
               regardless of whether you are playing records from the
               list, stepping all, or stepping a range.

               ENUMMFLIST is used when you need to add strings to a listbox
               that describe the type of reocrd.

  HISTORY    : created 7/1/93 - denniscr

************************************************************************/
using Gdiplus::EmfPlusRecordType;

int EnumMFIndirect(HDC hDC, LPHANDLETABLE lpHTable,
                            LPMETARECORD lpMFR,
                            LPENHMETARECORD lpEMFR,
                            int nObj, LPARAM lpData)
{
  BOOL DlgRet = TRUE;
  //
  // what is the enumeration action that we are taking?
  //
  switch (iEnumAction)
  {
    //
    //if the enumeration was entered ala the step metafile menu selection
    //
    case ENUMMFSTEP:
        if (bEnhMeta)
        {
            return StepRecord((EmfPlusRecordType)(lpEMFR->iType),
                              0, lpEMFR->nSize - sizeof(EMR),
                              (BYTE *)lpEMFR->dParm, (VOID *)lpData,
                              hDC, lpHTable, lpMFR, lpEMFR, nObj);
        }
        else
        {
            return StepRecord(GDIP_WMF_RECORD_TO_EMFPLUS(lpMFR->rdFunction),
                              0, ((LONG)lpMFR->rdSize * 2) - 6,
                              ((BYTE *)lpMFR) + 6, (VOID *)lpData,
                              hDC, lpHTable, lpMFR, lpEMFR, nObj);
        }

    case ENUMMFLIST:
        if (bEnhMeta)
        {
            ListRecord((Gdiplus::EmfPlusRecordType)lpEMFR->iType);
        }
        else
        {
            ListRecord(GDIP_WMF_RECORD_TO_EMFPLUS(lpMFR->rdFunction));
        }
        //
        //keep enumerating
        //
        return(1);
  }
  return 0;
}

/***********************************************************************

  FUNCTION   : ConvertEMFtoWMF

  PARAMETERS : HENHMETAFILE hEMF - handle to enhanced metafile
               LPSTR lpszFileName - filename of disked based metafile


  PURPOSE    : Convert an Windows metafile to an enhanced metafile

  MESSAGES   : none

  RETURNS    : int

  COMMENTS   :

  HISTORY    : created 7/22/93 - denniscr

************************************************************************/

BOOL ConvertWMFtoEMF(HMETAFILE hmf, LPSTR lpszFileName)
{
  LPSTR        lpWinMFBits;
  UINT         uiSizeBuf;
  HENHMETAFILE hEnhMF;
  BOOL         bRet = TRUE;
  //
  //get the size of the Windows metafile associated with hMF
  //
  if ((uiSizeBuf = GetMetaFileBitsEx((HMETAFILE)hMF, 0, NULL)))
  {
    //
    //allocate enough memory to hold metafile bits
    //
    lpWinMFBits = (char *)GlobalAllocPtr(GHND, uiSizeBuf);
    //
    //get the bits of the Windows metafile associated with hMF
    //
    if (lpWinMFBits && GetMetaFileBitsEx((HMETAFILE)hMF, uiSizeBuf, (LPVOID)lpWinMFBits))
    {
      //
      //copy the bits into a memory based enhanced metafile
      //
      hEnhMF = SetWinMetaFileBits(uiSizeBuf, (LPBYTE)lpWinMFBits, NULL, NULL);
      //
      //copy the enhanced metafile to a disk based enhanced metafile
      //
      CopyEnhMetaFile(hEnhMF, lpszFileName);
      //
      //done with the memory base enhanced metafile so get rid of it
      //
      DeleteEnhMetaFile(hEnhMF);
      //
      //done with the actual memory used to store bits so nuke it
      //
      GlobalFreePtr(lpWinMFBits);
    }
    else
      bRet = FALSE;
  }
  else
    bRet = FALSE;
  return (bRet);
}

/***********************************************************************

  FUNCTION   : ConvertEMFtoWMF

  PARAMETERS : HENHMETAFILE hEMF - handle to enhanced metafile
               LPSTR lpszFileName - filename of disked based metafile


  PURPOSE    : Convert an enhanced metafile to an Windows metafile

  MESSAGES   : none

  RETURNS    : int

  COMMENTS   :

  HISTORY    : created 7/22/93 - denniscr

************************************************************************/

BOOL ConvertEMFtoWMF(HDC hrefDC, HENHMETAFILE hEMF, LPSTR lpszFileName)
{
  LPSTR        lpEMFBits;
  UINT         uiSizeBuf;
  HMETAFILE    hWMF;
  BOOL         bRet = TRUE;
  DWORD        dwBytesWritten ;
  //
  //get the size of the Windows metafile associated with hMF
  //

  if ((uiSizeBuf = Gdiplus::Metafile::EmfToWmfBits(hemf, 0, NULL, MM_ANISOTROPIC,
        Gdiplus::EmfToWmfBitsFlagsIncludePlaceable)))
  {
    //
    //allocate enough memory to hold metafile bits
    //
    lpEMFBits = (LPSTR)GlobalAllocPtr(GHND, uiSizeBuf);
    //
    //get the bits of the enhanced metafile associated with hEMF
    //
    if (lpEMFBits && Gdiplus::Metafile::EmfToWmfBits(hEMF, uiSizeBuf,(LPBYTE)lpEMFBits,
         MM_ANISOTROPIC, Gdiplus::EmfToWmfBitsFlagsIncludePlaceable))

    {
        // Create a file and dump the metafile bits into it
        HANDLE hFile = CreateFile(lpszFileName, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL );
        if(hFile != INVALID_HANDLE_VALUE)
        {
            WriteFile( hFile, (LPCVOID) lpEMFBits, uiSizeBuf, &dwBytesWritten, NULL ) ;
            CloseHandle(hFile);
        }

/*
        //
        //copy the bits into a memory based Windows metafile
        //
        hWMF = SetMetaFileBitsEx(uiSizeBuf, (LPBYTE)lpEMFBits);
        //
        //copy the Windows metafile to a disk based Windows metafile
        //
        CopyMetaFile(hWMF, lpszFileName);
        //
        //done with the memory base enhanced metafile so get rid of it
        //
        DeleteMetaFile((HMETAFILE)hMF);
*/
        //
        //done with the actual memory used to store bits so nuke it
        //
        GlobalFreePtr(lpEMFBits);
    }
    else
      bRet = FALSE;
  }
  else
    bRet = FALSE;
  return (bRet);
}

BOOL StepRecord(
    Gdiplus::EmfPlusRecordType      recordType,
    UINT                            recordFlags,
    UINT                            recordDataSize,
    const BYTE *                    recordData,
    VOID *                          callbackData,
    HDC                             hDC,
    LPHANDLETABLE                   lpHTable,
    LPMETARECORD                    lpMFR,
    LPENHMETARECORD                 lpEMFR,
    int                             nObj
    )
{
    //
    //keep track of the current metafile record number
    //
    iRecNum++;

    //
    //allocate memory for the record.  this memory will be used by
    //other functions that need to use the contents of the record
    //
    hMem = GlobalAlloc(GPTR /*GHND*/, (bEnhMeta) ? sizeof(EMR) + recordDataSize :
                                                   6 + recordDataSize);
    //
    //if the memory was successfully allocated
    //
    if (hMem)
    {
        BOOL DlgRet = TRUE;

        if (bEnhMeta)
        {
            //
            //obtain a long pointer to this memory
            //
            if ((lpEMFParams = (LPEMFPARAMETERS)GlobalLock(hMem)) == NULL)
            {
                //
                //we were unable to allocate memory for the record
                //
                MessageBox(hWndMain, "Memory allocation failed",
                            NULL, MB_OK | MB_ICONHAND);
            }
            else
            {
                //
                //copy the contents of the record to the global memory
                //
                emfMetaRec.nSize = sizeof(EMR) + recordDataSize;
                emfMetaRec.iType = recordType;
                unsigned long i;
                for (i = 0;(DWORD)i < recordDataSize / sizeof(DWORD); i++)
                {
                    *lpEMFParams++ = ((DWORD *)recordData)[i];
                }
            }
        }
        else
        {
            /* obtain a long pointer to this memory */
            lpMFParams = (LPPARAMETERS)GlobalLock(hMem);

            /* copy the contents of the record to the global memory */
            MetaRec.rdSize = (6 + recordDataSize) / 2;
            MetaRec.rdFunction = GDIP_EMFPLUS_RECORD_TO_WMF(recordType);
            DWORD i;
            for (i = 0; (DWORD)i < (recordDataSize / 2); i++)
            {
                *lpMFParams++ = ((WORD *)recordData)[i];
            }
        }
        GlobalUnlock(hMem);
        //
        //if STEPPING through metafile records that have been selected
        //by selecting the menu options Play - Step - All, Play - Step -
        //Range, or selecting records from the View - List listbox
        //
        if ( !bPlayItAll
            || ( bEnumRange && iRecNum >= (WORD)iStartRange && iRecNum <= (WORD)iEndRange )
            || ( bPlayList && !bPlayItAll ) )
        {
            //
            //if playing records selected from the View - List
            //listbox of records
            if (bPlayList)
            {
                //
                //if playing the selected records
                //
                if (bPlaySelList)
                {
                    //
                    //if done playing the selected records then stop the enumeration
                    //
                    if (iCount == iNumSel)
                    {
                        return(0);
                    }

                    //
                    //if this is a selected record then play it
                    //
                    if ((WORD)lpSelMem[iCount] == iRecNum - 1)
                    {
                        //
                        //initialize flag
                        //
                        bPlayRec = FALSE;
                        //
                        //increment the count
                        //
                        iCount = (iCount < iLBItemsInBuf) ? ++iCount : iCount;
                        //
                        //call the dialog box that lets you play or ignore this record */
                        //
                        DlgRet = (BOOL) DialogBox((HINSTANCE)hInst, (LPSTR)"WMFDLG", hWndMain, WMFRecDlgProc);
                    }
                    else
                    {
                        //
                        //initialize flag and do nothing else
                        //
                        bPlayRec = FALSE;
                    }
                }
                //
                //playing the unselected records
                //
                else
                {
                    //
                    //if this is one of the selected records then increment
                    //the record count and init a flag but do nothing else
                    //
                    if ((WORD)lpSelMem[iCount] == iRecNum - 1)
                    {
                        //
                        //set count to next selected record in listbox
                        //
                        iCount = (iCount < iLBItemsInBuf) ? ++iCount : iCount;
                        bPlayRec = FALSE;
                    }
                    //
                    //this is not one of the selected records which is what we
                    //want in this case.  So, init a flag give the user the
                    //opportunity to play the record
                    //
                    else
                    {
                        bPlayRec = FALSE;
                        DlgRet = (BOOL) DialogBox((HINSTANCE)hInst, (LPSTR)"WMFDLG", hWndMain, WMFRecDlgProc);
                    }
                }

            } //bPlayList
            //
            //stepping records from the Play - Step menu option
            //
            else
            {
                //
                //init a flag and show the record contents
                //
                bPlayRec = FALSE;
                iCount = (iCount < iLBItemsInBuf) ? ++iCount : iCount;
                DlgRet = (BOOL) DialogBox((HINSTANCE)hInst, (LPSTR)"WMFDLG", hWndMain, WMFRecDlgProc);
            }
        } //end of STEPPING the metafile
        //
        //bPlayItAll is TRUE.  This is set when the user either
        //selects the menu option Play - All or pushes the GO button
        //in the view record dialog box
        //
        else
        {
            //
            //we were stepping records selected from the listbox and
            //the user pressed the GO button
            //
            //Don't bother returning 0 to stop enumeration.  We need to
            //play to the end of the metafile in this case anyway
            //
            if (bPlayList)
            {
                //
                //we were playing the selected records
                //
                if (bPlaySelList)
                {
                    //
                    //if all of the selected records have been played then
                    //stop the enumeration
                    //
                    if (iCount == iNumSel)
                    {
                        return(0);
                    }
                    //
                    //set bPlayRec so the record will be played without user
                    //interation and then update the record counter
                    //
                    if ((WORD)lpSelMem[iCount] == iRecNum - 1)
                    {
                        bPlayRec = TRUE;
                        iCount = (iCount < iLBItemsInBuf) ? ++iCount : iCount;
                    }
                    else
                    //
                    //it wasn't one of the selected records so don't play
                    //
                    {
                        bPlayRec = FALSE;
                    }
                }
                //
                //we were playing the unselected records
                //
                else
                {
                    //
                    //if it is a selected record then set bPlayRec to FALSE
                    //so the record is not played
                    //
                    if ((WORD)lpSelMem[iCount] == iRecNum - 1)
                    {
                        bPlayRec = FALSE;
                        iCount = (iCount < iLBItemsInBuf) ? ++iCount : iCount;
                    }
                    else
                    {
                        //
                        //play the record
                        //
                        bPlayRec = TRUE;
                    }
                }
            } //bPlayList
        } //GO button pushed
        //
        //Stop the enumeration if you were stepping a range and have
        //finished playing that range OR the user selected pushed
        //the STOP button in the view record dialog box
        //
        if ( ((bEnumRange) && (iRecNum > (WORD)iEndRange)) || (!DlgRet) )
        {
            bPlayRec = FALSE;
            //
            //stop enumeration
            //
            return(0);
        }

    } //if (hMem)
    else
    //
    //we were unable to allocate memory for the record
    //
    {
        MessageBox(hWndMain, "Memory allocation failed",
                        NULL, MB_OK | MB_ICONHAND);
    }
    //
    //Regardless of the method the user elected to play the
    //records, check the flag.  If it is set then play the
    //record
    //
    if (bPlayRec)
    {
        if (bUseGdiPlusToPlay)
        {
            ((MYDATA *)callbackData)->metafile->PlayRecord(recordType, recordFlags, recordDataSize, recordData);
        }
        else if (bEnhMeta)
        {
            if (bConvertToGdiPlus)
            {
                GpPlayEnhMetaFileRecord(hDC, lpHTable, lpEMFR, (UINT)nObj, (LPARAM)callbackData);
            }
            else
            {
                PlayEnhMetaFileRecord(hDC, lpHTable, lpEMFR, (UINT)nObj);
            }
        }
        else if(!PlayMetaFileRecord(hDC, lpHTable, lpMFR, (UINT)nObj))
        {
            ASSERT(FALSE);
        }
    }
    //
    //done with the record so get rid of it
    //
    GlobalFree(hMem);
    //
    //if we made it this far then continue the enumeration
    //
    return(1);
}


VOID ListRecord(
    Gdiplus::EmfPlusRecordType      recordType
    )
{
  char szMetaFunction[100];

   iRecNum++;
   //
   //format the listbox string
   //
   wsprintf((LPSTR)szMetaFunction, (LPSTR)"%d - ", iRecNum);
   //
   //get the function number contained in the record
   //
   if (bEnhMeta)
     emfMetaRec.iType = recordType;
   else
     MetaRec.rdFunction = GDIP_EMFPLUS_RECORD_TO_WMF(recordType);

   //
   //lookup the function number in the structure MetaFunctions
   //
   int i;
   if (bEnhMeta)
   {
       for (i = NUMMETAFUNCTIONS; i < NUMENHMETARECORDS; i++)
       {
           if (recordType == (INT)emfMetaRecords[i].iType)
             break;
       }
   }
   else // WMF
   {
       for (i = 0; i < NUMMETAFUNCTIONS; i++)
       {
           if (recordType == (INT)emfMetaRecords[i].iType)
             break;
       }
   }

   //
   //if the function number is not found then describe this record
   //as an "Unknown" type otherwise use the corresponding name
   //found in the lookup
   //
   if (recordType != (INT)emfMetaRecords[i].iType)
     lstrcat((LPSTR)szMetaFunction, (LPSTR)"Unknown");
   else
     lstrcat((LPSTR)szMetaFunction,(LPSTR)emfMetaRecords[i].szRecordName);
   //
   //add the string to the listbox
   //
   SendDlgItemMessage((HWND)CurrenthDlg, IDL_LBREC, LB_ADDSTRING, 0,
                      (LPARAM)(LPSTR)szMetaFunction);
}

extern "C"
BOOL CALLBACK
PlayGdipMetafileRecordCallback(
    Gdiplus::EmfPlusRecordType      recordType,
    UINT                            recordFlags,
    UINT                            recordDataSize,
    const BYTE *                    recordData,
    VOID *                          callbackData
    )
{
    switch (iEnumAction)
    {
    case ENUMMFSTEP:
        return StepRecord(recordType, recordFlags, recordDataSize, recordData, callbackData);

    case ENUMMFLIST:
        ListRecord(recordType);
        break;
    }
    return TRUE;
}

/***********************************************************************

  FUNCTION   : GetMetaFileAndEnum

  PARAMETERS : HDC hDC

  PURPOSE    : load the metafile if it has not already been loaded and
               begin enumerating it

  CALLS      : WINDOWS
                 GetMetaFile
                 MakeProcInstance
                 EnumMetaFile
                 FreeProcInstance
                 DeleteMetaFile
                 MessageBox

  MESSAGES   : none

  RETURNS    : void

  COMMENTS   :

  HISTORY    : 1/16/91 - created - drc
               7/1/93 - modified to work with EMFs - denniscr

************************************************************************/
extern "C"
void GetMetaFileAndEnum(
HWND hwnd,
HDC hDC,
int iAction)
{
   MYDATA  myData(hwnd);

   iEnumAction = iAction;
   //
   //if this is an enhanced metafile (emf)
   //
   RECT rc;
   GetClientRect(hWndMain, &rc);

   HPALETTE hpal = NULL;

   if (bEnhMeta)
   {

     if (hemf)
     {
       LPLOGPALETTE lpLogPal;
       HPALETTE hPal;
       int i;
       //
       //allocate memory for the logical palette including the array of
       //palette entries
       //
       lpLogPal = (LPLOGPALETTE) GlobalAllocPtr( GHND,  sizeof(LOGPALETTE) +
                                               (sizeof (PALETTEENTRY) * EmfPtr.palNumEntries));
       if (lpLogPal)
       {
         //
         //proceed only if there is a valid ptr to logical palette
         //and a palette array obtained from the emf
         //
         if (EmfPtr.lpPal)
         {
           lpLogPal->palVersion = 0x300;
           lpLogPal->palNumEntries = EmfPtr.palNumEntries;
           //
           //copy palette entries into palentry array
           //
           for (i = 0; i < EmfPtr.palNumEntries; i++)
             lpLogPal->palPalEntry[i] = *EmfPtr.lpPal++;
           //
           //reposition the ptr back to the beginning should we call this
           //code again
           //
           EmfPtr.lpPal -= EmfPtr.palNumEntries;
           //
           //create, select and realize the palette
           //
           if ((hPal = CreatePalette((LPLOGPALETTE)lpLogPal)))
           {
             SelectPalette(hDC, hPal, FALSE);
             RealizePalette(hDC);
           }
         }

        if (bUseGdiPlusToPlay)
        {
            // Select in the halftone palette for 256-color display mode testing
            hpal = Gdiplus::Graphics::GetHalftonePalette();
            SelectPalette(hDC, hpal, FALSE);
            RealizePalette(hDC);

            // Need to delete this before returning;
            myData.g = Gdiplus::Graphics::FromHDC(hDC);
myData.g->SetPixelOffsetMode(Gdiplus::PixelOffsetModeHalf);
myData.g->SetInterpolationMode(Gdiplus::InterpolationModeNearestNeighbor);
        }

         //
         //enumerate the EMF.  this is a bit odd simply because PlayEnhMetaFile
         //really obviates the need for doing this (this cannot be said for WMFs).
         //this app does it simply because it may be stepping the metafile records.
         //Most apps are generally not concerned about doing this.
         //
        if (bUseGdiPlusToPlay && (myData.g != NULL))
        {
            Gdiplus::Metafile m1(hemf);
            Gdiplus::Rect r1(rc.left, rc.top, rc.right - rc.left, rc.bottom - rc.top);
            myData.metafile = &m1;
            if(myData.g->EnumerateMetafile(&m1, r1, PlayGdipMetafileRecordCallback, &myData) != Gdiplus::Ok)
                MessageBox(NULL, "An Error Occured while playing this metafile", "Error", MB_OK | MB_ICONERROR);
            myData.metafile = NULL;
        }
        else
        {
            // the rect needs to be inclusive-inclusive!!!
            rc.right--;
            rc.bottom--;
            if(!EnumEnhMetaFile(hDC, hemf, (ENHMFENUMPROC)EnhMetaFileEnumProc, (void*)&myData, &rc))
                MessageBox(NULL, "Error", "An Error Occured while playing this metafile", MB_OK | MB_ICONERROR);
        }

         //
         //free palette memory
         //
         GlobalFreePtr(lpLogPal);
       }
     }
   }
   else
   {
     //
     //if there is a valid handle to a metafile begin enumerating it
     //
     if (hMF)
     {
        if (bUseGdiPlusToPlay)
        {
            // Select in the halftone palette for 256-color display mode testing
            hpal = Gdiplus::Graphics::GetHalftonePalette();
            SelectPalette(hDC, hpal, FALSE);
            RealizePalette(hDC);

            // Need to delete this before returning;
            myData.g = Gdiplus::Graphics::FromHDC(hDC);
        }

        if (bUseGdiPlusToPlay && (myData.g != NULL))
        {
            Gdiplus::WmfPlaceableFileHeader * wmfPlaceableFileHeader = NULL;

            if (bPlaceableMeta)
            {
                wmfPlaceableFileHeader = (Gdiplus::WmfPlaceableFileHeader *)&placeableWMFHeader;
            }

            Gdiplus::Metafile m1((HMETAFILE)hMF, wmfPlaceableFileHeader);
            Gdiplus::Rect r1(rc.left, rc.top, rc.right - rc.left, rc.bottom - rc.top);
            myData.metafile = &m1;
            if (myData.g->EnumerateMetafile(&m1, r1, PlayGdipMetafileRecordCallback, &myData) != Gdiplus::Ok)
                MessageBox(NULL, "An Error Occured while playing this metafile", "Error", MB_OK | MB_ICONERROR);
            myData.metafile = NULL;
        }
        else
        {
            if (!EnumMetaFile(hDC, (HMETAFILE)hMF, (MFENUMPROC) MetaEnumProc, (LPARAM) 0))
                MessageBox(NULL, "An Error Occured while playing this metafile", "Error", MB_OK | MB_ICONERROR);
        }
     }
     else
       MessageBox(hWndMain, "Invalid metafile handle",
                  NULL, MB_OK | MB_ICONHAND);
   }

    if (myData.g != NULL )
    {
        SelectObject(hDC, GetStockObject(DEFAULT_PALETTE));
        DeleteObject(hpal);
        myData.g->Flush();
        delete myData.g;
        myData.g = NULL;
    }

   return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\emfdcode\wmfprint.cpp ===
/***********************************************************************

  MODULE     : WMFPRINT.C

  FUNCTIONS  : PrintWMF
               GetPrinterDC
               AbortProc
               AbortDlg

  COMMENTS   :

************************************************************************/

#include <windows.h>
#include <windowsx.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <objbase.h>
extern "C" {
#include "mfdcod32.h"
}
extern "C" {
  extern BOOL bConvertToGdiPlus;
  extern BOOL bUseGdiPlusToPlay;
}

#include "GdiPlus.h"

int PrintToGdiPlus(HDC hdc, RECT * rc)
{
    // 'rc' is device co-ordinates of rectangle.
    // Convert to world space.

    if (bEnhMeta) 
    {
        Gdiplus::Metafile m1(hemf);
        Gdiplus::Rect r1(rc->left, rc->top, rc->right - rc->left, rc->bottom - rc->top);
        Gdiplus::Graphics g(hdc);
        g.SetPageUnit(Gdiplus::UnitPixel);
    
        if(g.DrawImage(&m1, r1) != Gdiplus::Ok)
            MessageBox(NULL, "An Error Occured while printing metafile with GDI+", "Error", MB_OK | MB_ICONERROR);
    }
    else
    {
        Gdiplus::Metafile m1((HMETAFILE)hMF, NULL);
        Gdiplus::Rect r1(rc->left, rc->top, rc->right - rc->left, rc->bottom - rc->top);
        Gdiplus::Graphics g(hdc);
        g.SetPageUnit(Gdiplus::UnitPixel);
    
        if(g.DrawImage(&m1, r1) != Gdiplus::Ok)
            MessageBox(NULL, "An Error Occured while printing metafile with GDI+", "Error", MB_OK | MB_ICONERROR);
    }

    return 1;
}

extern BOOL bUseGdiPlusToPlay;

PRINTDLG pd;

/***********************************************************************

  FUNCTION   : PrintWMF

  PARAMETERS : void

  PURPOSE    : draw the metafile on a printer dc

  CALLS      : WINDOWS
                 wsprintf
                 MessageBox
                 MakeProcInstance
                 Escape
                 CreateDialog
                 SetMapMode
                 SetViewportOrg
                 SetViewportExt
                 EnableWindow
                 PlayMetaFile
                 DestroyWindow
                 DeleteDC

               APP
                 WaitCursor
                 GetPrinterDC
                 SetPlaceableExts
                 SetClipMetaExts

  MESSAGES   : none

  RETURNS    : BOOL - 0 if unable to print 1 if successful

  COMMENTS   :

  HISTORY    : 1/16/91 - created - drc
               7/9/93 - modified for win32 and emf

************************************************************************/

BOOL PrintWMF(BOOL Dialog)
{
    char str[50];
    POINT lpPT;
    SIZE  lpSize;
    DOCINFO di;
    RECT rc;

    memset(&di, 0, sizeof(di));
    
    //
    //display the hourglass cursor
    //
    
    WaitCursor(TRUE);
    
    //
    //get a DC for the printer
    //
    
    hPr = (HDC)GetPrinterDC(Dialog);
    
    //
    //if a DC could not be created then report the error and return
    //
    
    if (!hPr)
    {
        WaitCursor(FALSE);
        wsprintf((LPSTR)str, "Cannot print %s", (LPSTR)fnameext);
        MessageBox(hWndMain, (LPSTR)str, NULL, MB_OK | MB_ICONHAND);
        return (FALSE);
    }
    
    //
    //define the abort function
    //
    
    SetAbortProc(hPr, AbortProc);
    
    //
    //Initialize the members of a DOCINFO structure.
    //
    
    di.cbSize = sizeof(DOCINFO);
    di.lpszDocName = (bEnhMeta) ? "Print EMF" : "Print WMF";
    di.lpszOutput = (LPTSTR) NULL;
    
    //
    //Begin a print job by calling the StartDoc
    //function.
    //
    
    if (SP_ERROR == (StartDoc(hPr, &di)))
    {
        //if (Escape(hPr, STARTDOC, 4, "Metafile", (LPSTR) NULL) < 0)  {
        MessageBox(hWndMain, "Unable to start print job",
                   NULL, MB_OK | MB_ICONHAND);
        DeleteDC(hPr);
        return (FALSE);
    }
    
    //
    //clear the abort flag
    //
    
    bAbort = FALSE;
    
    //
    //Create the Abort dialog box (modeless)
    //
    
    hAbortDlgWnd = CreateDialog((HINSTANCE)hInst, "AbortDlg", hWndMain, AbortDlg);
    
    //
    //if the dialog was not created report the error
    //
    
    if (!hAbortDlgWnd)
    {
        WaitCursor(FALSE);
        MessageBox(hWndMain, "NULL Abort window handle",
                   NULL, MB_OK | MB_ICONHAND);
        return (FALSE);
    }
    
    //
    //show Abort dialog
    //
    
    ShowWindow (hAbortDlgWnd, SW_NORMAL);
    
    //
    //disable the main window to avoid reentrancy problems
    //
    
    EnableWindow(hWndMain, FALSE);
    WaitCursor(FALSE);
    
    //
    //if we are still committed to printing
    //

    if (!bAbort)
    {
        if (!bUseGdiPlusToPlay) 
        {
            //
            //if this is a placeable metafile then set its origins and extents
            //
            
            if (bPlaceableMeta)
                SetPlaceableExts(hPr, placeableMFHeader, WMFPRINTER);
            
            //
            //if this is a metafile contained within a clipboard file then set
            //its origins and extents accordingly
            //
            
            if ( (bMetaInRam) && (!bplaceableMeta) )
                SetClipMetaExts(hPr, lpMFP, lpOldMFP, WMFPRINTER);
        }
      
      //
      //if this is a "traditional" windows metafile
      //
      rc.left = 0;
      rc.top = 0;
      rc.right = GetDeviceCaps(hPr, HORZRES);
      rc.bottom = GetDeviceCaps(hPr, VERTRES);

      if (!bMetaInRam)
      {
          SetMapMode(hPr, MM_TEXT);
          SetViewportOrgEx(hPr, 0, 0, &lpPT);
          
          //
          //set the extents to the driver supplied values for horizontal
          //and vertical resolution
          //
          
          SetViewportExtEx(hPr, rc.right, rc.bottom, &lpSize );
      }

      //
      //play the metafile directly to the printer.
      //No enumeration involved here
      //

      if (bUseGdiPlusToPlay) 
      {
          PrintToGdiPlus(hPr, &rc);
      }
      else
      {
          if (bEnhMeta)
          {
              DPtoLP(hPr, (LPPOINT)&rc, 2);
              PlayEnhMetaFile(hPr, hemf, &rc);
          }
          else
              PlayMetaFile(hPr, (HMETAFILE)hMF);
      }
    }
    
    //
    //eject page and end the print job
    //
    Escape(hPr, NEWFRAME, 0, 0L, 0L);

    EndDoc(hPr);

    EnableWindow(hWndMain, TRUE);
    
    //
    //destroy the Abort dialog box
    //
    DestroyWindow(hAbortDlgWnd);

    DeleteDC(hPr);

    return(TRUE);
}

/***********************************************************************

  FUNCTION   : GetPrinterDC

  PARAMETERS : BOOL: Do we want to show a print DLG?

  PURPOSE    : Get hDc for current device on current output port according
               to info in WIN.INI.

  CALLS      : WINDOWS
                 GetProfileString
                 AnsiNext
                 CreateDC

  MESSAGES   : none

  RETURNS    : HANDLE - hDC > 0 if success  hDC = 0 if failure

  COMMENTS   : Searches WIN.INI for information about what printer is
               connected, and if found, creates a DC for the printer.

  HISTORY    : 1/16/91 - created - denniscr

************************************************************************/

HANDLE GetPrinterDC(BOOL Dialog)
{

  memset(&pd, 0, sizeof(PRINTDLG));
  pd.lStructSize = sizeof(PRINTDLG);
  pd.Flags = PD_RETURNDC | (Dialog?0:PD_RETURNDEFAULT);
  pd.hwndOwner = hWndMain ;
  return ((PrintDlg(&pd) != 0) ? pd.hDC : NULL);
}

/***********************************************************************

  FUNCTION   : AbortProc

  PARAMETERS : HDC hPr - printer DC
               int Code - printing status

  PURPOSE    : process messages for the abort dialog box

  CALLS      : WINDOWS
                 PeekMessage
                 IsDialogMessage
                 TranslateMessage
                 DispatchMessage

  MESSAGES   : none

  RETURNS    : int

  COMMENTS   :

  HISTORY    : 1/16/91 - created - denniscr

************************************************************************/

BOOL CALLBACK AbortProc(HDC hPr, int Code)
{
  MSG msg;
  //
  //Process messages intended for the abort dialog box
  //
  while (!bAbort && PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
      if (!IsDialogMessage(hAbortDlgWnd, &msg))
      {
          TranslateMessage(&msg);
          DispatchMessage(&msg);
      }
  //
  //bAbort is TRUE (return is FALSE) if the user has aborted
  //
  return (!bAbort);
}

/***********************************************************************

  FUNCTION   : AbortDlg

  PARAMETERS : HWND hDlg;
               unsigned msg;
               WORD wParam;
               LONG lParam;

  PURPOSE    : Processes messages for printer abort dialog box

  CALLS      : WINDOWS
                 SetFocus

  MESSAGES   : WM_INITDIALOG - initialize dialog box
               WM_COMMAND    - Input received

  RETURNS    : BOOL

  COMMENTS   : This dialog box is created while the program is printing,
               and allows the user to cancel the printing process.

  HISTORY    : 1/16/91 - created - denniscr

************************************************************************/

INT_PTR CALLBACK AbortDlg(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    switch(msg)
    {
        //
        //Watch for Cancel button, RETURN key, ESCAPE key, or SPACE BAR
        //
        case WM_INITDIALOG:
            //
            //Set the focus to the Cancel box of the dialog
            //
            SetFocus(GetDlgItem(hDlg, IDCANCEL));
            return (TRUE);

        case WM_COMMAND:
            return (bAbort = TRUE);

        }
    return (FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\fonttest\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by wndstuff.rc
//
#define MAINMENU                        101
#define IDM_MAINMENU                    101
#define IDD_DIALOG1                     102
#define ID_DLG_CREATEFONT               102
#define IDD_CREATEFONT                  102
#define IDD_DRAWGLYPHS                  103
#define IDD_GETGLYPHMETRICS             104
#define IDD_PATHGLYPHS                  105
#define IDD_ADDFONTFILE                 106
#define IDD_REMOVEFONT                  107
#define IDC_FAMILYNAME                  1000
#define IDC_FONT_FAMILYNAME             1000
#define ID_FONTSIZE                     1001
#define IDC_FONT_SIZE                   1002
#define ID_FONTUNIT                     1003
#define IDC_FONT_UNIT                   1004
#define ID_FONTSTYLE                    1005
#define IDC_FONT_REGULAR                1006
#define IDC_FONT_BOLD                   1007
#define IDC_FONT_BOLDITALIC             1008
#define IDC_FONT_ITALIC                 1009
#define IDC_UNITWORLD                   1010
#define IDC_UNITDISPLAY                 1011
#define IDC_UNITPIXEL                   1012
#define IDC_UNITINCH                    1013
#define IDC_UNITPT                      1014
#define IDC_UNITDOC                     1015
#define IDC_UNITMM                      1016
#define IDC_DG_GLYPHINDICES             1017
#define IDC_PX                          1018
#define IDC_DG_PX                       1019
#define IDC_PY                          1020
#define IDC_DG_PY                       1021
#define IDC_FLAGS                       1023
#define IDC_GGM_FL_DEFAULT              1025
#define IDC_GGM_FL_VMTX                 1026
#define IDC_GGM_FL_SIMBOLD              1027
#define IDC_GGM_FL_SIMITALIC            1028
#define ID_GGM_GLYPHINDICES             1029
#define IDC_GGM_GLYPHINDICES            1030
#define IDC_EDIT1                       1031
#define IDC_FONTFILENAME                1031
#define IDC_FILEPATH                    1031
#define IDC_ADDFONTFLAG                 1033
#define IDC_PUBLIC                      1034
#define IDC_PRIVATE                     1035
#define IDC_NOTENUM                     1035
#define IDD_LOADASIMAGE                 1036
#define IDC_DG_GDIPLUS                  1037
#define IDM_TEST                        40001
#define IDM_CREATEFONT                  40002
#define IDM_DRAWGLYPHS                  40003
#define IDM_PATHGLYPHS                  40005
#define ID_ADDFONTFILE                  40006
#define ID_REMOVEFONTFILE               40007
#define ID_ANTIALIAS_ON                 40012
#define ID_ANTIALIAS_OFF                40013
#define ID_FAMILY                       -1
#define IDC_GLYPHINDEX                  -1
#define IDC_GGM_FLAGS                   -1
#define IDC_FILENAME                    -1
#define IDC_REMOVEFONT                  -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        108
#define _APS_NEXT_COMMAND_VALUE         40013
#define _APS_NEXT_CONTROL_VALUE         1038
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\fonttest\precomp.hpp ===
#include <windows.h>
#include <objbase.h>
#include <math.h>             // sin & cos

//
// Where is IStream included from?
//

#define IStream int

#include "gdiplus.h"
using namespace Gdiplus;

#define DG_NOGDI            4

#define MAX_GLYPH_COUNT       100

//copy from winddi.h

typedef ULONG       HGLYPH;
typedef LONG        FIX;

// point in the 32.32 bit precission

typedef struct _POINTQF    // ptq
{
    LARGE_INTEGER x;
    LARGE_INTEGER y;
} POINTQF, *PPOINTQF;

typedef struct _GLYPHBITS
{
    POINTL      ptlOrigin;
    SIZEL       sizlBitmap;
    BYTE        aj[1];
} GLYPHBITS;

typedef union _GLYPHDEF
{
    GLYPHBITS  *pgb;
//    PATHOBJ    *ppo;
    PVOID       *ppo;
} GLYPHDEF;

typedef struct _GLYPHDATA {
        GLYPHDEF gdf;
        HGLYPH   hg;
        FIX      fxD;
        FIX      fxA;
        FIX      fxAB;
        FIX      fxInkTop;
        FIX      fxInkBottom;
        RECTL    rclInk;
        POINTQF  ptqD;
} GLYPHDATA;

typedef GpStatus (*FN_GDIPDRAWGLYPHS)(GpGraphics*, UINT16*, INT, GpFont*, GpBrush*, INT*, INT*, INT);
typedef GpStatus (*FN_GDIPPATHADDGLYPHS)(GpPath*, UINT16*, INT, GpFont*, REAL*, REAL*, INT);
typedef GpStatus (*FN_GDIPSETTEXTRENDERINGHINT)(GpGraphics *graphics, TextRenderingHint mode);


enum AddFontFlag
{
	AddFontFlagPublic = 0,
	AddFontFlagNotEnumerate = 1
};


// globals
extern HINSTANCE ghInst;
extern HWND ghWndMain;
extern HWND ghWndList;
extern HBRUSH ghbrWhite;
extern HINSTANCE ghGdiplus;
extern Font *gFont;
extern FN_GDIPDRAWGLYPHS gfnGdipDrawGlyphs;
extern FN_GDIPPATHADDGLYPHS gfnGdipPathAddGlyphs;
extern FN_GDIPSETTEXTRENDERINGHINT gfnGdipSetTextRenderingHint;

void Dbgprintf(PCH msg, ...);
void CreateNewFont(char*, FLOAT, FontStyle, Unit);
void TestDrawGlyphs(HWND hwnd, UINT16 *glyphIndices, INT count, INT *px, INT *py, INT flags);
void TestPathGlyphs(HWND hwnd, UINT16 *glyphIndices, INT count, REAL *px, REAL *py, INT flags);

void TestAddFontFile(CHAR* fileName, INT flag, BOOL loasAsImage);
void TestRemoveFontFile(char* fileName);
void TestTextAntiAliasOn();
void TestTextAntiAliasOff();
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\fonttest\fonttest.cpp ===
/******************************Module*Header*******************************\
* Module Name: test.c
*
* Created: 09-Dec-1992 10:51:46
* Author: Kirk Olynyk [kirko]
*
* Copyright (c) 1991 Microsoft Corporation
*
* Contains the test
*
\**************************************************************************/

#include "precomp.hpp"

// globals

Font    *gFont = NULL;
BOOL    gTextAntiAlias = FALSE;
InstalledFontCollection gInstalledFontCollection;
PrivateFontCollection gPrivateFontCollection;


///////////////////////////////////////////////////////////////////////////////
//  Test function prototypes

VOID    TestFonts(VOID);
GraphicsPath* CreateHeartPath(const RectF& rect);
VOID    TestGradients(Graphics *g);


///////////////////////////////////////////////////////////////////////////////

VOID Test(HWND hwnd)
{
    Graphics *g = Graphics::FromHWND(hwnd);
    TestGradients(g);
    TestFonts();
    delete g;
}


///////////////////////////////////////////////////////////////////////////////
//  Font test functions

VOID TestFonts(VOID)
{
    //  Test font family enumeration
    INT numFamilies = gInstalledFontCollection.GetFamilyCount();
    Dbgprintf("%d installed font families loaded.", numFamilies);
    Dbgprintf("");

    FontFamily* families = new FontFamily[numFamilies];
    INT numFound;
    gInstalledFontCollection.GetFamilies(numFamilies, families, &numFound);

    Dbgprintf("Enumerated font families:");
    for (int f = 0; f < numFound; f++)
    {
        WCHAR faceName[LF_FACESIZE];
        families[f].GetFamilyName(faceName);
        Dbgprintf("  %ws", faceName);
    }
    Dbgprintf("");
    delete [] families;

    // Enumerate the private font families
    numFamilies = gPrivateFontCollection.GetFamilyCount();
    Dbgprintf("%d private font families loaded.", numFamilies);
    Dbgprintf("");

    if (numFamilies != 0)
    {
        families = new FontFamily[numFamilies];
        gPrivateFontCollection.GetFamilies(numFamilies, families, &numFound);

        Dbgprintf("PRIVATE enumerated font families:");
        for (int f = 0; f < numFound; f++)
        {
            WCHAR faceName[LF_FACESIZE];
            families[f].GetFamilyName(faceName);
            Dbgprintf("  %ws", faceName);
        }
        Dbgprintf("");
        delete [] families;
    }


    //HFONT hfont = NULL;
    //Font* font = new Font(hfont);//10, "Arial");

    Font* font = new Font(&FontFamily(L"Arial"), 10);

    //  Test text output
    Color blue(0, 0, 255, 255);
    SolidBrush blueBrush(blue);

#if 0
    g->DrawStringI(
           L"Hi",
           NULL,
           0, 0,           // x,y
           NULL, 0,        // pdx, flags
           &blueBrush      // GpBrush*
           );
#endif

    if (font != NULL)
    {
        delete font;
    }

}


///////////////////////////////////////////////////////////////////////////////

GraphicsPath* CreateHeartPath(const RectF& rect)
{
    GpPointF points[7];
    points[0].X = 0;
    points[0].Y = 0;
    points[1].X = 1.00;
    points[1].Y = -1.00;
    points[2].X = 2.00;
    points[2].Y = 1.00;
    points[3].X = 0;
    points[3].Y = 2.00;
    points[4].X = -2.00;
    points[4].Y = 1.00;
    points[5].X = -1.00;
    points[5].Y = -1.00;
    points[6].X = 0;
    points[6].Y = 0;

    Matrix matrix;

    matrix.Scale(rect.Width/2, rect.Height/3, MatrixOrderAppend);
    matrix.Translate(3*rect.Width/2, 4*rect.Height/3, MatrixOrderAppend);
    matrix.TransformPoints(&points[0], 7);

    GraphicsPath* path = new GraphicsPath();

    if(path)
    {
        path->AddBeziers(&points[0], 7);
        path->CloseFigure();
    }

    return path;
}


/**************************************************************************\
* TestGradients
*
* A test for rectangle and radial gradients.
*
\**************************************************************************/

VOID TestGradients(Graphics* g)
{
    REAL width = 4; // Pen width

    // Create a rectangular gradient brush.

    RectF brushRect(0, 0, 32, 32);

    Color colors[5] = {
        Color(255, 255, 255, 255),
        Color(255, 255, 0, 0),
        Color(255, 0, 255, 0),
        Color(255, 0, 0, 255),
        Color(255, 0, 0, 0)
    };


    Color blackColor(0, 0, 0);

    SolidBrush blackBrush(blackColor);
    Pen blackPen(&blackBrush, width);

    g->DrawRectangle(&blackPen, brushRect);

    // Create a radial gradient brush.

    Color centerColor(255, 255, 255, 255);
    Color boundaryColor(255, 0, 0, 0);
    brushRect.X = 380;
    brushRect.Y = 130;
    brushRect.Width = 60;
    brushRect.Height = 32;
    PointF center;
    center.X = brushRect.X + brushRect.Width/2;
    center.Y = brushRect.Y + brushRect.Height/2;

    // Triangle gradient.

    PointF points[7];
    points[0].X = 50;
    points[0].Y = 10;
    points[1].X = 200;
    points[1].Y = 20;
    points[2].X = 100;
    points[2].Y = 100;
    points[3].X = 30;
    points[3].Y = 120;

    Color colors1[5] = {
        Color(255, 255, 255, 0),
        Color(255, 255, 0, 0),
        Color(255, 0, 255, 0),
        Color(255, 0, 0, 255),
        Color(255, 0, 0, 0)
    };

    points[0].X = 200;
    points[0].Y = 300;
    points[1].X = 280;
    points[1].Y = 350;
    points[2].X = 220;
    points[2].Y = 420;
    points[3].X = 160;
    points[3].Y = 440;
    points[4].X = 120;
    points[4].Y = 370;

    PathGradientBrush polyGrad(points, 5);

    REAL blend[10];
    Color presetColors[10];
    REAL positions[10];
    INT count;
    INT i;

    count = 3;
    blend[0] = (REAL) 0;
    blend[1] = (REAL) 0;
    blend[2] = (REAL) 1;
    positions[0] = (REAL) 0;
    positions[1] = (REAL) 0.4;
    positions[2] = (REAL) 1;

    // Test for blending factors.

    polyGrad.SetBlend(&blend[0], &positions[0], count);

    polyGrad.SetCenterColor(centerColor);
    INT colorset = 5;
    polyGrad.SetSurroundColors(&colors1[0], &colorset);
    
//    g->FillPolygon(&polyGrad, points, 5);
    RectF polyRect;
    polyGrad.GetRectangle(&polyRect);
    g->FillRectangle(&polyGrad, polyRect);

    // Create a heart shaped path.

    RectF rect;
    rect.X = 300;
    rect.Y = 300;
    rect.Width = 150;
    rect.Height = 150;
    GraphicsPath *path = CreateHeartPath(rect);

    // Create a gradient from a path.

    PathGradientBrush pathGrad(path);
    delete path;
    pathGrad.SetCenterColor(centerColor);
    INT colorsset = 5;
    colors1[0] = Color(255, 255, 0, 0);
    pathGrad.SetSurroundColors(&colors1[0], &colorsset);
    pathGrad.GetRectangle(&polyRect);

    // Test for LineGradientBrush.

    RectF lineRect(120, -20, 200, 60);
    Color color1(200, 255, 255, 0);
    Color color2(200, 0, 0, 255);

}

/////////////////////////////////////////////////////////////////////////////
//  CreateNewFont
//
//  History
//  Aug-1999    -by-    Xudong Wu [tessiew]
/////////////////////////////////////////////////////////////////////////////

void CreateNewFont(char *name, FLOAT size, FontStyle style, Unit unit)
{
    Dbgprintf("Calling CreateNewFont");

    // convert ansi to unicode

    WCHAR wcname[MAX_PATH];

    memset(wcname, 0, sizeof(wcname));
    MultiByteToWideChar(CP_ACP, 0, name, strlen(name), wcname, MAX_PATH);

    // for now ignore all other unit than UnitWorld

    FontFamily *  pFamily;

	pFamily = new FontFamily(wcname);

	if (pFamily->GetLastStatus() != Ok)
	{
		pFamily = new FontFamily(wcname, &gPrivateFontCollection);
	}

    if (gFont != NULL)
    {
        delete gFont;
    }

    gFont = (Font*) new Font(pFamily, size, style, unit);

    if (gFont == NULL)
    {
        Dbgprintf("failed to create a new font");
    }
    else
    {
        if (gFont->IsAvailable())
        {
            Dbgprintf("new font created");
        }
        else
        {
            Dbgprintf("can't create font");
            delete gFont;
            gFont = NULL;
        }
    }

    if (pFamily != NULL)
    {
        delete pFamily;
    }
    
	Dbgprintf("");
}

///////////////////////////////////////////////////////////////////////////////
//  TestDrawGlyphs
//
//  History
//  Aug-1999    -by-    Xudong Wu [tessiew]
//////////////////////////////////////////////////////////////////////////////

VOID TestDrawGlyphs(
    HWND hwnd,
    UINT16 *glyphIndices,
    INT count,
    INT *px,
    INT *py,
    INT flags)
{
    FontFamily family;
    INT        style;
    REAL size;
    Unit unit;

    if (gFont)
    {
        Status status;
        status = gFont->GetFamily(&family);
        style = gFont->GetStyle();
        size = gFont->GetSize();
        unit = gFont->GetUnit();

        SolidBrush redBrush(Color(255,0,0));
        //HatchBrush hatBrush(HatchStyleDiagonalCross, Color(255,0,0), Color(128,128,128));

        Graphics *g = Graphics::FromHWND(hwnd);

        Dbgprintf("Graphics.DrawGlyphs");
        Dbgprintf("Font:: size  %f   style  %d  unit  %d", size, style, unit);

        Dbgprintf("glyphIndices px  py");
        for (INT i=0; i<count; i++)
        {
                Dbgprintf("%d  %d  %d", glyphIndices[i], px[i], py[i]);
        }
        Dbgprintf("");

            

        //g->DrawGlyphs(glyphIndices, count, gFont, &redBrush, px, py, flags);

        //  Gradient brush
        RectF gradRect(0, 0, 32, 32);
        Color colors[5] = {
            Color(255, 255, 255, 255),
            Color(255, 255, 0, 0),
            Color(255, 0, 255, 0),
            Color(255, 0, 0, 255),
            Color(255, 0, 0, 0)
        };

        PVOID Gpg = (PVOID)(g);
        PVOID font = (PVOID)gFont;
        PVOID brush = (PVOID)&redBrush;
        GpGraphics* gpg = *((GpGraphics**)Gpg);
        
        GpFont* gpfont = *((GpFont**)font);
        GpBrush* gpbrush = ((GpBrush**)brush)[1];
        //GpBrush* gpbrushHat = ((GpBrush**)&hatBrush)[1];

        if (gTextAntiAlias)
            (*gfnGdipSetTextRenderingHint)(gpg, TextRenderingHintAntiAlias);
        else
            (*gfnGdipSetTextRenderingHint)(gpg, TextRenderingHintSingleBitPerPixelGridFit);

        if (gfnGdipDrawGlyphs)
        {
            (*gfnGdipDrawGlyphs)(gpg, glyphIndices, count, gpfont, gpbrush, px, py, flags);
            
            /*
            if (flags & DG_XCONSTANT)
                px[0] += 1600;
            else if (flags & DG_YCONSTANT)
                py[0] += 1600;
            
            (*gfnGdipDrawGlyphs)(gpg, glyphIndices, count, gpfont, gpbrushHat, px, py, flags);
            */
        } else 
		{
			PointF *origins;
			origins = new PointF[count];

			for (INT i=0; i<count; i++)
			{
				origins[i].X = (float)px[i] / (float)16.0;
				origins[i].Y = (float)py[i] / (float)16.0;
			}

			g->DrawDriverString(
				glyphIndices,
				count,
				gFont,
				&redBrush,
				origins,
				0, //g_DriverOptions,
				NULL //&g_DriverTransform
        );
		}

        g->Flush();
        delete g;
    }
}


///////////////////////////////////////////////////////////////////////////////
//  TestPathGlyphs
//
//  History
//  Aug-1999    -by-    Xudong Wu [tessiew]
//////////////////////////////////////////////////////////////////////////////

VOID TestPathGlyphs(
    HWND hwnd,
    UINT16 *glyphIndices,
    INT count,
    REAL *px,
    REAL *py,
    INT flags)
{
    INT  style;
    REAL size;
    Unit unit;

    if (gFont)
    {
        style = gFont->GetStyle();
        size = gFont->GetSize();
        unit = gFont->GetUnit();

        SolidBrush redBrush(Color(255,0,0));
        SolidBrush blkBrush(Color(0,0,0));
        Pen blkPen(&blkBrush, (REAL)1);

        Graphics *g = Graphics::FromHWND(hwnd);

        Dbgprintf("Add Glyphs To Path");
        Dbgprintf("Font:: size  %f   style  %d  unit  %d", size, style, unit);

        Dbgprintf("glyphIndices px  py");
        for (INT i=0; i<count; i++)
        {
                Dbgprintf("%d  %d  %d", glyphIndices[i], INT(px[i]), INT(py[i]));
        }
        Dbgprintf("");

        GraphicsPath pathRed;
        GraphicsPath pathBlk;

        PVOID ptrv = (PVOID)gFont;
        GpFont* gpfont = *((GpFont**)ptrv);
        ptrv = (PVOID)&pathRed;
        GpPath* gpPathRed = *((GpPath**)ptrv);
        ptrv = (PVOID)&pathBlk;
        GpPath* gpPathBlk = *((GpPath**)ptrv);

        if (gfnGdipPathAddGlyphs)
        {
            (*gfnGdipPathAddGlyphs)(gpPathRed, glyphIndices, count, gpfont, px, py, flags);
            g->FillPath(&redBrush, &pathRed);

            for (INT i=0; i<count; i++)
            {
                    py[i] += 50.0;
            }

            (*gfnGdipPathAddGlyphs)(gpPathBlk, glyphIndices, count, gpfont, px, py, flags);
            g->DrawPath(&blkPen, &pathBlk);
        }

        delete g;
    }
}


/////////////////////////////////////////////////////////////////////////////
//  AddFontFile
//
//  History
//  Nov-1999    -by-    Xudong Wu [tessiew]
/////////////////////////////////////////////////////////////////////////////

void TestAddFontFile(char *fileName, INT flag, BOOL loadAsImage)
{
    Dbgprintf("Calling AddFontFile");
    Dbgprintf("filename %s  flag  %d  loadAsImage  %d", fileName, flag, loadAsImage);

    if ((flag == AddFontFlagPublic) && loadAsImage)
    {
        Dbgprintf("Cannot load a memory image in the installed font collection");
        return;
    }

    if (loadAsImage)
    {
        HANDLE hFile, hFileMapping;

        hFile = CreateFileA(fileName,
                            GENERIC_READ,
                            FILE_SHARE_READ,
                            0,
                            OPEN_EXISTING,
                            FILE_ATTRIBUTE_NORMAL,
                            0);

        if (hFile != INVALID_HANDLE_VALUE)
        {
            DWORD   cjSize;
            PVOID   pFontFile;

            cjSize = GetFileSize(hFile, NULL);

            if (cjSize == -1)
                Dbgprintf("GetFileSize() failed\n");
            else
            {
                hFileMapping = CreateFileMapping(hFile, 0, PAGE_READONLY, 0, 0, NULL);
    
                if (hFileMapping)
                {
                    pFontFile = MapViewOfFile(hFileMapping, FILE_MAP_READ, 0, 0, 0);
    
                    if(pFontFile)
                    {
                        if (gPrivateFontCollection.AddMemoryFont((BYTE*)pFontFile,
                                                                 cjSize) == Ok)
                            Dbgprintf("AddMemoryFont to private font collection");
                        else
                            Dbgprintf("AddMemoryFont to private font collection failed");

                        UnmapViewOfFile(pFontFile);
                    }
                    else
                        Dbgprintf("MapViewOfFile() failed");
                    
                    CloseHandle(hFileMapping);
                }
                else
                    Dbgprintf("CreateFileMapping() failed");
            }
            CloseHandle(hFile);            
        }
        else
            Dbgprintf("CreateFileA failed");
    }
    else
    {
        WCHAR wcname[MAX_PATH];    
        memset(wcname, 0, sizeof(wcname));
        MultiByteToWideChar(CP_ACP, 0, fileName, strlen(fileName), wcname, MAX_PATH);

        if (flag == AddFontFlagPublic)
        {
            /* // add this code in version 2 (when InstallFontFile is exposed)
            if (gInstalledFontCollection.InstallFontFile(wcname) == Ok)
            {
                Dbgprintf("InstallFontFile to installed font collection");
            }
            else
            {
                Dbgprintf("InstallFontFile to installed font collection failed");
            }
            */
            Dbgprintf("InstallFontFile to installed font collection failed (API not yet exposed)");
        }
        else
        {
            if (gPrivateFontCollection.AddFontFile(wcname) == Ok)
            {
                Dbgprintf("AddFontFile to private font collection");
            }
            else
            {
                Dbgprintf("AddFontFile to private font collection failed");
            }
        }
    }
}

/////////////////////////////////////////////////////////////////////////////
//  RemoveFontFile
//
//  History
//  Nov-1999    -by-    Xudong Wu [tessiew]
/////////////////////////////////////////////////////////////////////////////

void TestRemoveFontFile(char* fileName)
{
    WCHAR wcname[MAX_PATH];

    memset(wcname, 0, sizeof(wcname));
    MultiByteToWideChar(CP_ACP, 0, fileName, strlen(fileName), wcname, MAX_PATH);
    /* // add this code in version 2 (when UninstallFontFile is exposed)
    if (gInstalledFontCollection.UninstallFontFile(wcname) == Ok)
    {
        Dbgprintf("UninstallFontFile from installed font collection");
    }
    else
    {
        Dbgprintf("UninstallFontFile from installed font collection failed");
    }
    */
    Dbgprintf("UninstallFontFile from installed font collection failed (API not yet exposed)");
}

void TestTextAntiAliasOn()
{
    gTextAntiAlias = TRUE;
}

void TestTextAntiAliasOff()
{
    gTextAntiAlias = FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\fonttest\wndstuff.h ===
/****************************** Module Header ******************************\
* Module Name: wndstuff.h
*
* Kent's Window Test.  To be used as a program template.
*
* Created: 09-May-91
* Author: KentD
*
* Copyright (c) 1991 Microsoft Corporation
\***************************************************************************/

#include "resource.h"

#define CONVERTTOUINT16     0
#define CONVERTTOINT        1
#define CONVERTTOFLOAT      2

void Test(HWND hwnd);
INT_PTR ShowDialogBox(DLGPROC, int);

INT_PTR CALLBACK CreateFontDlgProc(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK DrawGlyphsDlgProc(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK PathGlyphsDlgProc(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK GetGlyphMetricsDlgProc(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK AddFontFileDlgProc(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK RemoveFontDlgProc(HWND, UINT, WPARAM, LPARAM);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\fonttest\wndstuff.cpp ===
/******************************Module*Header*******************************\
* Module Name: wndstuff.cpp
*
* This file contains the code to support a simple window that has
* a menu with a single item called "Test". When "Test" is selected
* vTest(HWND) is called.
*
* Created: 09-Dec-1992 10:44:31
* Author: Kirk Olynyk [kirko]
*
* Copyright (c) 1991 Microsoft Corporation
*
\**************************************************************************/
#include <tchar.h>
#include <stdio.h>

#include "precomp.hpp"
#include "wndstuff.h"

#include "../gpinit.inc"

// globals
HINSTANCE ghInst;
HWND ghWndMain;
HWND ghwndDebug;
HBRUSH ghbrWhite;

HINSTANCE  ghGdiplus = NULL;
FN_GDIPDRAWGLYPHS gfnGdipDrawGlyphs = NULL;
FN_GDIPPATHADDGLYPHS gfnGdipPathAddGlyphs = NULL;
FN_GDIPSETTEXTRENDERINGHINT gfnGdipSetTextRenderingHint = NULL;

/***************************************************************************\
* lMainWindowProc(hwnd, message, wParam, lParam)
*
* Processes all messages for the main window.
*
* History:
*  04-07-91 -by- KentD
* Wrote it.
\***************************************************************************/

LONG_PTR
lMainWindowProc(
    HWND    hwnd,
    UINT    message,
    WPARAM  wParam,
    LPARAM  lParam
    )
{
    PAINTSTRUCT ps;

    switch (message)
    {
    case WM_CREATE:

        if (ghGdiplus || (ghGdiplus = LoadLibrary("gdiplus.dll")))
        {
            gfnGdipDrawGlyphs =(FN_GDIPDRAWGLYPHS) GetProcAddress(ghGdiplus, "GdipDrawGlyphs");
            gfnGdipPathAddGlyphs = (FN_GDIPPATHADDGLYPHS) GetProcAddress(ghGdiplus, "GdipPathAddGlyphs");
            gfnGdipSetTextRenderingHint =(FN_GDIPSETTEXTRENDERINGHINT) GetProcAddress(ghGdiplus, "GdipSetTextRenderingHint");
        }

//        if (gfnGdipDrawGlyphs == NULL)
//            EnableMenuItem(GetMenu(hwnd), IDM_DRAWGLYPHS, MF_GRAYED);

        if (gfnGdipPathAddGlyphs == NULL)
            EnableMenuItem(GetMenu(hwnd), IDM_PATHGLYPHS, MF_GRAYED);

        break;

    case WM_COMMAND:
        switch(LOWORD(wParam))
        {
        case IDM_TEST:
            Test(hwnd);
            break;

        case IDM_CREATEFONT:
            ShowDialogBox(CreateFontDlgProc, IDD_CREATEFONT);
            break;

        case IDM_DRAWGLYPHS:
            ShowDialogBox(DrawGlyphsDlgProc, IDD_DRAWGLYPHS);
            break;

        case IDM_PATHGLYPHS:
            ShowDialogBox(PathGlyphsDlgProc, IDD_DRAWGLYPHS);
            break;

        case ID_ADDFONTFILE:
            ShowDialogBox(AddFontFileDlgProc, IDD_ADDFONTFILE);
            break;

        case ID_REMOVEFONTFILE:
            ShowDialogBox(RemoveFontDlgProc, IDD_REMOVEFONT);
            break;
        case ID_ANTIALIAS_ON:
            TestTextAntiAliasOn();
            break;
        case ID_ANTIALIAS_OFF:
            TestTextAntiAliasOff();
            break;

        default:
            break;
        }
        break;

    case WM_DESTROY:
        DeleteObject(ghbrWhite);
        if (gFont)
            delete gFont;
        PostQuitMessage(0);
        return(DefWindowProc(hwnd, message, wParam, lParam));

    default:
        return(DefWindowProc(hwnd, message, wParam, lParam));
    }

    return(0);
}

/***************************************************************************\
* bInitApp()
*
* Initializes app.
*
* History:
*  04-07-91 -by- KentD
* Wrote it.
\***************************************************************************/

BOOL bInitApp(VOID)
{
    WNDCLASS wc;
    
    if (!gGdiplusInitHelper.IsValid())
    {
        return(FALSE);
    }

    ghbrWhite = CreateSolidBrush(RGB(0xFF,0xFF,0xFF));

    wc.style            = 0;
    wc.lpfnWndProc      = lMainWindowProc;
    wc.cbClsExtra       = 0;
    wc.cbWndExtra       = 0;
    wc.hInstance        = ghInst;
    wc.hIcon            = LoadIcon(NULL, IDI_APPLICATION);
    wc.hCursor          = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground    = (HBRUSH) (COLOR_WINDOW + 1);
    wc.lpszMenuName     = MAKEINTRESOURCE(IDM_MAINMENU);
    wc.lpszClassName    = _T("TestClass");
    if (!RegisterClass(&wc))
    {
        return(FALSE);
    }
    ghWndMain =
      CreateWindowEx(
        0,
        _T("TestClass"),
        _T("Gdiplus Font Test"),
        WS_OVERLAPPED   |
        WS_CAPTION      |
        WS_BORDER       |
        WS_THICKFRAME   |
        WS_MAXIMIZEBOX  |
        WS_MINIMIZEBOX  |
        WS_CLIPCHILDREN |
        WS_VISIBLE      |
        WS_SYSMENU,
        80,
        70,
        500,
        500,
        NULL,
        NULL,
        ghInst,
        NULL);
    if (ghWndMain == NULL)
    {
        return(FALSE);
    }
    SetFocus(ghWndMain);

    ghwndDebug = CreateWindow(
            "LISTBOX",
            "GdiplusFontTest Debugging",
            WS_VISIBLE | WS_SYSMENU | WS_VSCROLL | WS_THICKFRAME | WS_MINIMIZEBOX,
            600, 70, 400, 700,
            NULL,
            NULL,
            ghInst,
            NULL);

    if (ghwndDebug)
    {
        SendMessage(ghwndDebug, WM_SETFONT, (WPARAM)GetStockObject(ANSI_FIXED_FONT), (LPARAM)FALSE);
        SendMessage(ghwndDebug, LB_RESETCONTENT, (WPARAM) FALSE, (LPARAM) 0);

        ShowWindow(ghwndDebug, SW_NORMAL);
        UpdateWindow(ghwndDebug);
    }

    return(TRUE);
}


INT_PTR ShowDialogBox(DLGPROC DialogProc, int iResource)
{
    INT_PTR rc = -1;
    //DLGPROC lpProc;

    //if (lpProc = MakeProcInstance(DialogProc, ghInst))
    //{
    //    rc = DialogBox(ghInst,
    //            MAKEINTRESOURCE(iResource),
    //            ghWndMain,
    //            (DLGPROC) lpProc);
    //}

    //FreeProcInstance( lpProc );
    
    rc = DialogBox( ghInst,
                    MAKEINTRESOURCE(iResource),
                    ghWndMain,
                    DialogProc);

    return rc;
}


/***************************************************************************\
* main(argc, argv[])
*
* Sets up the message loop.
*
* History:
*  04-07-91 -by- KentD
* Wrote it.
\***************************************************************************/

_cdecl
main(
    INT   argc,
    PCHAR argv[])
{
    MSG    msg;
    HACCEL haccel;
    CHAR*  pSrc;
    CHAR*  pDst;

    ghInst = GetModuleHandle(NULL);

    if (!bInitApp())
    {
        return(0);
    }

    haccel = LoadAccelerators(ghInst, MAKEINTRESOURCE(1));
    while (GetMessage(&msg, NULL, 0, 0))
    {
        if (!TranslateAccelerator(msg.hwnd, haccel, &msg))
        {
             TranslateMessage(&msg);
             DispatchMessage(&msg);
        }
    }
    return(1);
}

//*****************************************************************************
//*******************   G E T   D L G   I T E M   F L O A T *******************
//*****************************************************************************

FLOAT
GetDlgItemFLOAT(
      HWND  hdlg
    , int   id
    )
{
    char ach[50];

    memset(ach,0,sizeof(ach));
    return((FLOAT)(GetDlgItemText(hdlg,id,ach,sizeof(ach))?atof(ach):0.0));
}

//*****************************************************************************
//*******************   S E T   D L G   I T E M   F L O A T *******************
//*****************************************************************************

void
SetDlgItemFLOAT(
      HWND    hdlg
    , int     id
    , FLOAT   e
    )
{
  static char ach[25];

  ach[0] = '\0';
  sprintf(ach, "%f", e);
  SetDlgItemText(hdlg, id, ach);
}


///////////////////////////////////////////////////////////////////////////////
// CreateFontDlgProc()
//
// History:
//
//  Aug-1999 Xudong Wu [tessiew]
// Wrote it.
///////////////////////////////////////////////////////////////////////////////

INT_PTR CALLBACK CreateFontDlgProc(
    HWND hdlg,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam)
{
    static char szName[MAX_PATH];
    LPSTR name;
    FLOAT  size;
    FontStyle style;
    Unit unit;

    switch(msg)
    {
    case WM_INITDIALOG:
        SetDlgItemText(hdlg, IDC_FONT_FAMILYNAME, "Arial");
        SendDlgItemMessage(hdlg, IDC_FONT_FAMILYNAME, EM_LIMITTEXT, sizeof(szName), 0);

        SetDlgItemFLOAT(hdlg, IDC_FONT_SIZE, 30);
        CheckRadioButton(hdlg, IDC_FONT_REGULAR, IDC_FONT_ITALIC, IDC_FONT_REGULAR);
        CheckRadioButton(hdlg, IDC_UNITWORLD, IDC_UNITMM, IDC_UNITWORLD);

        return TRUE;

    case WM_COMMAND:
        switch(LOWORD(wParam))
        {
        case IDOK:
            szName[0] = 0;
            GetDlgItemText(hdlg, IDC_FONT_FAMILYNAME, szName, sizeof(szName));

            if (lstrlen(szName))
            {
                size = GetDlgItemFLOAT(hdlg, IDC_FONT_SIZE);
                if (size)
                {
                    if (IsDlgButtonChecked(hdlg, IDC_FONT_REGULAR))
                        style = FontStyleRegular;
                    else if (IsDlgButtonChecked(hdlg, IDC_FONT_BOLD))
                        style = FontStyleBold;
                    else if (IsDlgButtonChecked(hdlg, IDC_FONT_ITALIC))
                        style = FontStyleItalic;
                    else if (IsDlgButtonChecked(hdlg, IDC_FONT_BOLDITALIC))
                        style = FontStyleBoldItalic;

                    if (IsDlgButtonChecked(hdlg, IDC_UNITWORLD))
                        unit = UnitWorld;
                    else if (IsDlgButtonChecked(hdlg, IDC_UNITDISPLAY))
                    {
//                        ASSERT(0);  // UnitDisplay not valid !!!
                        unit = UnitPixel;
                    }
                    else if (IsDlgButtonChecked(hdlg, IDC_UNITPIXEL))
                        unit = UnitPixel;
                    else if (IsDlgButtonChecked(hdlg, IDC_UNITPT))
                        unit = UnitPoint;
                    else if (IsDlgButtonChecked(hdlg, IDC_UNITINCH))
                        unit = UnitInch;
                    else if (IsDlgButtonChecked(hdlg, IDC_UNITDOC))
                        unit = UnitDocument;
                    else if (IsDlgButtonChecked(hdlg, IDC_UNITMM))
                        unit = UnitMillimeter;

                    CreateNewFont(szName, size, style, unit);
                }
            }

            EndDialog(hdlg, TRUE);
            return TRUE;

        case IDCANCEL:
            EndDialog(hdlg, FALSE);
            return TRUE;
        }
        break;

    case WM_CLOSE:
        EndDialog(hdlg, FALSE);
        return TRUE;
    }

    return FALSE;
}

///////////////////////////////////////////////////////////////////////////////
// GetNumber
//
// History:
//
//  Aug-1999 Xudong Wu [tessiew]
// Wrote it.
///////////////////////////////////////////////////////////////////////////////

BOOL GetNumber(char* numstr, PVOID out, INT* count, INT flag)
{
    char  *pchar = numstr;
    INT   i, num = 0;
    FLOAT numf = 0, *pf;
    UINT16  *puint16;
    INT     *pint;

    if (*pchar != 0)
    {
        num = atoi(numstr);
        numf = (FLOAT)atof(numstr);

        if (num == 0 || numf == 0)
        {
            return FALSE;
        }

        if (flag == CONVERTTOUINT16)
        {
            puint16 = (UINT16*) out;
            puint16 += *count;
            *puint16 = (UINT16)num;
        }
        else if (flag == CONVERTTOINT)
        {
            pint = (INT*) out;
            pint += *count;
            *pint = num;
        }
        else
        {
            pf = (FLOAT*) out;
            pf += *count;
            *pf = numf;
        }

        *count = *count + 1;
    }

    return TRUE;
}

///////////////////////////////////////////////////////////////////////////////
// ParseStrToNumbers
//
// History:
//
//  Aug-1999 Xudong Wu [tessiew]
// Wrote it.
///////////////////////////////////////////////////////////////////////////////

BOOL ParseStrToNumbers(char* str, PVOID out, INT* count, INT flag)
{
    char    *pchar = str, *pnum;
    char    anum[30];
    BOOL    bRet = TRUE;

    *count = 0;
    pnum = anum;
    *pnum = 0;

    while (*pchar)
    {
        if (*pchar == ' ' || *pchar == ',')
        {
            *pnum = 0;
            if (!GetNumber(anum, out, count, flag))
                return FALSE;
            pnum = anum;
            *pnum = 0;
            pchar++;
        }
        else if (*str < '0' || *str > '9')
        {
            return FALSE;
        }
        else
        {
            *pnum ++ = *pchar ++;
        }
    }

    *pnum = 0;
    if (!GetNumber(anum, out, count, flag))
        bRet = FALSE;;

    return bRet;
}


///////////////////////////////////////////////////////////////////////////////
// DrawGlyphsDlgProc
//
// History:
//
//  Aug-1999  -by- Xudong Wu [tessiew]
// Wrote it.
///////////////////////////////////////////////////////////////////////////////

INT_PTR CALLBACK DrawGlyphsDlgProc(
    HWND hdlg,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam)
{
    UINT16  glyphIndices[MAX_GLYPH_COUNT];
    INT     count, xycount;
    INT     px[MAX_GLYPH_COUNT];
    INT     py[MAX_GLYPH_COUNT];
    INT     flags;
    char    glyphStr[4*MAX_GLYPH_COUNT];

    switch(msg)
    {
    case WM_INITDIALOG:
        SetDlgItemText(hdlg, IDC_DG_GLYPHINDICES, "55, 72, 86, 87");
        SetDlgItemText(hdlg, IDC_DG_PX, "1600, 1920, 2240, 2560");
        SetDlgItemText(hdlg, IDC_DG_PY, "1600, 1600, 1600, 1600");
        return TRUE;

    case WM_COMMAND:
        switch(LOWORD(wParam))
        {
        case IDOK:
            glyphStr[0] = 0;

            GetDlgItemText(hdlg, IDC_DG_GLYPHINDICES, glyphStr, sizeof(glyphStr));

            if (ParseStrToNumbers(glyphStr, (PVOID)glyphIndices, &count, CONVERTTOUINT16))
            {
                glyphStr[0] = 0;
                GetDlgItemText(hdlg, IDC_DG_PX, glyphStr, sizeof(glyphStr));

                if (ParseStrToNumbers(glyphStr, (PVOID)px, &xycount, CONVERTTOINT))
                {
                    glyphStr[0] = 0;
                    GetDlgItemText(hdlg, IDC_DG_PY, glyphStr, sizeof(glyphStr));

                    if (ParseStrToNumbers(glyphStr, (PVOID)py, &xycount, CONVERTTOINT))
                    {

                        if (IsDlgButtonChecked(hdlg, IDC_DG_GDIPLUS))
                            flags |= DG_NOGDI;

                        TestDrawGlyphs(ghWndMain, glyphIndices, count, px, py, flags);
                    }
                }
            }

            EndDialog(hdlg, TRUE);
            return TRUE;

        case IDCANCEL:
            EndDialog(hdlg, FALSE);
            return TRUE;
        }
        break;

    case WM_CLOSE:
        EndDialog(hdlg, FALSE);
        return TRUE;
    }

    return FALSE;
}

///////////////////////////////////////////////////////////////////////////////
// PathGlyphsDlgProc
//
// History:
//
//  Aug-1999  -by- Xudong Wu [tessiew]
// Wrote it.
///////////////////////////////////////////////////////////////////////////////

INT_PTR CALLBACK PathGlyphsDlgProc(
    HWND hdlg,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam)
{
   UINT16  glyphIndices[MAX_GLYPH_COUNT];
    INT     count, xycount;
    INT     px[MAX_GLYPH_COUNT];
    INT     py[MAX_GLYPH_COUNT];
    INT     flags;
    char    glyphStr[4*MAX_GLYPH_COUNT];
    REAL    prx[MAX_GLYPH_COUNT];
    REAL    pry[MAX_GLYPH_COUNT];

    switch(msg)
    {
    case WM_INITDIALOG:
        SetDlgItemText(hdlg, IDC_DG_GLYPHINDICES, "55, 72, 86, 87");
        SetDlgItemText(hdlg, IDC_DG_PX, "100, 120, 140, 160");
        SetDlgItemText(hdlg, IDC_DG_PY, "100, 100, 100, 100");
        return TRUE;

    case WM_COMMAND:
        switch(LOWORD(wParam))
        {
        case IDOK:
            glyphStr[0] = 0;

            GetDlgItemText(hdlg, IDC_DG_GLYPHINDICES, glyphStr, sizeof(glyphStr));

            if (ParseStrToNumbers(glyphStr, (PVOID)glyphIndices, &count, CONVERTTOUINT16))
            {
                glyphStr[0] = 0;
                GetDlgItemText(hdlg, IDC_DG_PX, glyphStr, sizeof(glyphStr));

                if (ParseStrToNumbers(glyphStr, (PVOID)px, &xycount, CONVERTTOINT))
                {
                    glyphStr[0] = 0;
                    GetDlgItemText(hdlg, IDC_DG_PY, glyphStr, sizeof(glyphStr));

                    if (ParseStrToNumbers(glyphStr, (PVOID)py, &xycount, CONVERTTOINT))
                    {

                        // Generate REAL glyph psitions
                        for (INT i=0; i<count; i++)
                        {
                            prx[i] = REAL(px[i]);
                            pry[i] = REAL(py[i]);
                        }
                        flags = 0;

                        TestPathGlyphs(ghWndMain, glyphIndices, count, prx, pry, flags);
                    }
                }
            }

            EndDialog(hdlg, TRUE);
            return TRUE;

        case IDCANCEL:
            EndDialog(hdlg, FALSE);
            return TRUE;
        }
        break;

    case WM_CLOSE:
        EndDialog(hdlg, FALSE);
        return TRUE;
    }

    return FALSE;
}

////////////////////////////////////////////////////////////////
// GetGlyphMetricsDlgProc
//
// History:
//
//  Aug-18-1999  -by- Xudong Wu [tessiew]
// Wrote it.
///////////////////////////////////////////////////////////////

INT_PTR CALLBACK GetGlyphMetricsDlgProc(
    HWND hdlg,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam)
{
    UINT16  glyphIndices[MAX_GLYPH_COUNT];
    INT     count, xycount;
    INT     px[MAX_GLYPH_COUNT];
    INT     py[MAX_GLYPH_COUNT];
    INT     flags;
    char    glyphStr[4*MAX_GLYPH_COUNT];

    switch(msg)
    {
    case WM_INITDIALOG:
        SetDlgItemText(hdlg, IDC_GGM_GLYPHINDICES, "55, 72, 86, 87");
        CheckRadioButton(hdlg, IDC_GGM_FL_DEFAULT, IDC_GGM_FL_SIMITALIC, IDC_GGM_FL_DEFAULT);
        return TRUE;

    case WM_COMMAND:
        switch(LOWORD(wParam))
        {
        case IDOK:
            glyphStr[0] = 0;

            GetDlgItemText(hdlg, IDC_GGM_GLYPHINDICES, glyphStr, sizeof(glyphStr));

            if (ParseStrToNumbers(glyphStr, (PVOID)glyphIndices, &count, CONVERTTOUINT16))
            {
                if (IsDlgButtonChecked(hdlg, IDC_GGM_FL_DEFAULT))
                    flags = 0;
                else if (IsDlgButtonChecked(hdlg, IDC_GGM_FL_VMTX))
                    flags = 1;
                else if (IsDlgButtonChecked(hdlg, IDC_GGM_FL_SIMBOLD))
                    flags = 2;
                else if (IsDlgButtonChecked(hdlg, IDC_GGM_FL_SIMITALIC))
                    flags = 3;

            }

            EndDialog(hdlg, TRUE);
            return TRUE;

        case IDCANCEL:
            EndDialog(hdlg, FALSE);
            return TRUE;
        }
        break;

    case WM_CLOSE:
        EndDialog(hdlg, FALSE);
        return TRUE;
    }

    return FALSE;
}

///////////////////////////////////////////////////////////////////////////////
// CreateFontDlgProc()
//
// History:
//
//  Nov-1999 Xudong Wu [tessiew]
// Wrote it.
///////////////////////////////////////////////////////////////////////////////

INT_PTR CALLBACK AddFontFileDlgProc(
    HWND hdlg,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam)
{
    static char szName[MAX_PATH];
    LPSTR name;
    INT flag;
    BOOL loadAsImage = FALSE;

    switch(msg)
    {
    case WM_INITDIALOG:
        CheckRadioButton(hdlg, IDC_PUBLIC, IDC_NOTENUM, IDC_PUBLIC);
        return TRUE;

    case WM_COMMAND:
        switch(LOWORD(wParam))
        {
        case IDOK:
            szName[0] = 0;

            GetDlgItemText(hdlg, IDC_FONTFILENAME, szName, sizeof(szName));
            if (IsDlgButtonChecked(hdlg, IDC_PUBLIC))
                flag = AddFontFlagPublic;
            else
                flag = AddFontFlagNotEnumerate;
            if (IsDlgButtonChecked(hdlg, IDD_LOADASIMAGE))
                loadAsImage = TRUE;

            if (lstrlen(szName))
            {
                TestAddFontFile(szName, flag, loadAsImage);
            }

            EndDialog(hdlg, TRUE);
            return TRUE;

        case IDCANCEL:
            EndDialog(hdlg, FALSE);
            return TRUE;
        }
        break;

    case WM_CLOSE:
        EndDialog(hdlg, FALSE);
        return TRUE;
    }

    return FALSE;
}

///////////////////////////////////////////////////////////////////////////////
// RemoveFontDlgProc()
//
// History:
//
//  Dec-1999 Xudong Wu [tessiew]
// Wrote it.
///////////////////////////////////////////////////////////////////////////////
INT_PTR CALLBACK RemoveFontDlgProc(
    HWND hdlg,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam)
{
    char ach[50];

    switch(msg)
    {
    case WM_COMMAND:
        switch(LOWORD(wParam))
        {
        case IDOK:
            GetDlgItemText(hdlg, IDC_FILEPATH, ach, sizeof(ach));
            TestRemoveFontFile(ach);
            EndDialog(hdlg, TRUE);
            return TRUE;
        
        case IDCANCEL:
            EndDialog(hdlg, FALSE);
            return TRUE;
        }
        break;

    case WM_CLOSE:
        EndDialog(hdlg, FALSE);
        return TRUE;
    }
    return FALSE;
}

/******************************Public*Routine******************************\
* Dbgprintf
*
* ListBox printf implementation.
*
* History:
*  Aug-18-1999 -by- Xudong Wu [tessiew]
* Wrote it.
\**************************************************************************/

void Dbgprintf(PCH msg, ...)
{
    va_list ap;
    char buffer[256];

    va_start(ap, msg);

    vsprintf(buffer, msg, ap);

    if (ghwndDebug)
    {
        SendMessage(ghwndDebug, LB_ADDSTRING, (WPARAM) 0, (LPARAM) buffer);
        SendMessage(ghwndDebug, WM_SETREDRAW, (WPARAM) TRUE, (LPARAM) 0);
        InvalidateRect(ghwndDebug, NULL, TRUE);
        UpdateWindow(ghwndDebug);
    }

    va_end(ap);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\fractal\gdipscsave.h ===
#ifndef __GDIPSCSAVE_H
#define __GDIPSCSAVE_H

#include <windows.h>
#include <objbase.h>
#include <scrnsave.h>
#include "resource.h"
//#include <imaging.h>
#include <gdiplus.h>

using namespace Gdiplus;

//#include <stdio.h>

#define MINVEL  1                             /* minimum number of fractals    */ 
#define MAXVEL  10                            /* maximum number of fractals    */ 
#define DEFVEL  3                             /* default number of fractals    */ 
 
#define REDRAWTIME  2000                      /* number of milliseconds between redraws */

#define MAXHEIGHWAYLEVEL  14                  /* Maximum number of levels for heighway dragon */
#define MINHEIGHWAYLEVEL  7                   /* Minimum number of levels for heighway dragon */

DWORD   nNumFracts = DEFVEL;                   /* number of fractals variable   */ 
DWORD   nFractType = 0;                        /* Type of fractal to draw       */
WCHAR   szAppName[APPNAMEBUFFERLEN];           /* .ini section name             */ 
WCHAR   szTemp[20];                            /* temporary array of characters */ 
BOOL    fMandelbrot = FALSE;                   /* TRUE if mandelbrot sets used */

#define HKEY_PREFERENCES TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\ScreenSaver\\Preferences")

//FILE *stream;

VOID FillSierpinski(Graphics *g, PointF one, PointF two, PointF three, int level, Brush *pBrush, Pen *pPen);
VOID DrawSierpinski(HDC hDC, HWND hwnd, RECT rc, int iColor);
VOID DrawHieghway(HDC hDC, HWND hwnd, RECT rc, int iColor);
VOID IterateHieghway(PointF *points, PointF *newpoints, int *iSize);
VOID DrawTree(HDC hDC, HWND hwnd, RECT rc, int iColor);
VOID DrawBranch(HWND hwnd, Graphics *g, GraphicsPath *path, int iLevel, 
              PointF *scale, REAL *rotate, PointF *translate, 
              int iBranches, int iColor);
VOID DrawJulia(HDC hDC, HWND hwnd, RECT rc, int iColor, BOOL fMandelbrot);
ARGB IndexToSpectrum(INT index);
INT SpectrumToIndex(ARGB argb);
INT MakeColor(INT c1, INT c2, INT deltamax);
INT MakeColor(INT c1, INT c2, INT c3, INT c4, INT deltamax);
BYTE MakeAlpha(BYTE a1, BYTE a2, INT deltamax);
BYTE MakeAlpha(BYTE a1, BYTE a2, BYTE a3, BYTE a4, INT deltamax);
BOOL HalfPlasma(HWND& hwnd, Graphics& g,BitmapData &bmpd, INT x0, INT y0, INT x1, INT y1,REAL scale);
VOID DrawPlasma(HDC hDC, HWND hwnd, RECT rc, int iColor);
VOID GetFractalConfig (DWORD *nType, DWORD *nSize);
VOID SetFractalConfig (DWORD nType, DWORD nSize);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\fractal\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by gdipscsv.rc
//
#define IDS_DESCRIPTION                 1
#define ID_OK                           1001
#define ID_CANCEL                       1002
#define IDC_RADIOTYPE1                  1003
#define IDC_RADIOTYPE2                  1004
#define IDC_RADIOTYPE3                  1005
#define IDC_RADIOTYPE4                  1006
#define IDC_RADIOTYPE5                  1007
#define DLG_SCRNSAVECONFIGURE           2003
#define ID_SPEED                        2004

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        2009
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1004
#define _APS_NEXT_SYMED_VALUE           2007
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\fractal\afxres.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef __AFXRES_H__
#define __AFXRES_H__

#ifdef RC_INVOKED
#ifndef _INC_WINDOWS
#define _INC_WINDOWS
	#include "winres.h"           // extract from windows header
#endif
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

#ifdef APSTUDIO_INVOKED
#define APSTUDIO_HIDDEN_SYMBOLS
#endif

/////////////////////////////////////////////////////////////////////////////
// MFC resource types (see Technical note TN024 for implementation details)

#ifndef RC_INVOKED
#define RT_DLGINIT  MAKEINTRESOURCEA(240)
#define RT_TOOLBAR  MAKEINTRESOURCEA(241)
#endif

/////////////////////////////////////////////////////////////////////////////

#ifdef APSTUDIO_INVOKED
#undef APSTUDIO_HIDDEN_SYMBOLS
#endif

/////////////////////////////////////////////////////////////////////////////
// General style bits etc

// ControlBar styles
#define CBRS_ALIGN_LEFT     0x1000L
#define CBRS_ALIGN_TOP      0x2000L
#define CBRS_ALIGN_RIGHT    0x4000L
#define CBRS_ALIGN_BOTTOM   0x8000L
#define CBRS_ALIGN_ANY      0xF000L

#define CBRS_BORDER_LEFT    0x0100L
#define CBRS_BORDER_TOP     0x0200L
#define CBRS_BORDER_RIGHT   0x0400L
#define CBRS_BORDER_BOTTOM  0x0800L
#define CBRS_BORDER_ANY     0x0F00L

#define CBRS_TOOLTIPS       0x0010L
#define CBRS_FLYBY          0x0020L
#define CBRS_FLOAT_MULTI    0x0040L
#define CBRS_BORDER_3D      0x0080L
#define CBRS_HIDE_INPLACE   0x0008L
#define CBRS_SIZE_DYNAMIC   0x0004L
#define CBRS_SIZE_FIXED     0x0002L
#define CBRS_FLOATING       0x0001L

#define CBRS_GRIPPER        0x00400000L

#define CBRS_ORIENT_HORZ    (CBRS_ALIGN_TOP|CBRS_ALIGN_BOTTOM)
#define CBRS_ORIENT_VERT    (CBRS_ALIGN_LEFT|CBRS_ALIGN_RIGHT)
#define CBRS_ORIENT_ANY     (CBRS_ORIENT_HORZ|CBRS_ORIENT_VERT)

#define CBRS_ALL            0x0040FFFFL

// the CBRS_ style is made up of an alignment style and a draw border style
//  the alignment styles are mutually exclusive
//  the draw border styles may be combined
#define CBRS_NOALIGN        0x00000000L
#define CBRS_LEFT           (CBRS_ALIGN_LEFT|CBRS_BORDER_RIGHT)
#define CBRS_TOP            (CBRS_ALIGN_TOP|CBRS_BORDER_BOTTOM)
#define CBRS_RIGHT          (CBRS_ALIGN_RIGHT|CBRS_BORDER_LEFT)
#define CBRS_BOTTOM         (CBRS_ALIGN_BOTTOM|CBRS_BORDER_TOP)

/////////////////////////////////////////////////////////////////////////////
// Standard window components

// Mode indicators in status bar - these are routed like commands
#define ID_INDICATOR_EXT                0xE700  // extended selection indicator
#define ID_INDICATOR_CAPS               0xE701  // cap lock indicator
#define ID_INDICATOR_NUM                0xE702  // num lock indicator
#define ID_INDICATOR_SCRL               0xE703  // scroll lock indicator
#define ID_INDICATOR_OVR                0xE704  // overtype mode indicator
#define ID_INDICATOR_REC                0xE705  // record mode indicator
#define ID_INDICATOR_KANA               0xE706  // kana lock indicator

#define ID_SEPARATOR                    0   // special separator value

#ifndef RC_INVOKED  // code only
// Standard control bars (IDW = window ID)
#define AFX_IDW_CONTROLBAR_FIRST        0xE800
#define AFX_IDW_CONTROLBAR_LAST         0xE8FF

#define AFX_IDW_TOOLBAR                 0xE800  // main Toolbar for window
#define AFX_IDW_STATUS_BAR              0xE801  // Status bar window
#define AFX_IDW_PREVIEW_BAR             0xE802  // PrintPreview Dialog Bar
#define AFX_IDW_RESIZE_BAR              0xE803  // OLE in-place resize bar
#define AFX_IDW_REBAR                   0xE804  // COMCTL32 "rebar" Bar
#define AFX_IDW_DIALOGBAR               0xE805  // CDialogBar

// Note: If your application supports docking toolbars, you should
//  not use the following IDs for your own toolbars.  The IDs chosen
//  are at the top of the first 32 such that the bars will be hidden
//  while in print preview mode, and are not likely to conflict with
//  IDs your application may have used succesfully in the past.

#define AFX_IDW_DOCKBAR_TOP             0xE81B
#define AFX_IDW_DOCKBAR_LEFT            0xE81C
#define AFX_IDW_DOCKBAR_RIGHT           0xE81D
#define AFX_IDW_DOCKBAR_BOTTOM          0xE81E
#define AFX_IDW_DOCKBAR_FLOAT           0xE81F

// Macro for mapping standard control bars to bitmask (limit of 32)
#define AFX_CONTROLBAR_MASK(nIDC)   (1L << (nIDC - AFX_IDW_CONTROLBAR_FIRST))

// parts of Main Frame
#define AFX_IDW_PANE_FIRST              0xE900  // first pane (256 max)
#define AFX_IDW_PANE_LAST               0xE9ff
#define AFX_IDW_HSCROLL_FIRST           0xEA00  // first Horz scrollbar (16 max)
#define AFX_IDW_VSCROLL_FIRST           0xEA10  // first Vert scrollbar (16 max)

#define AFX_IDW_SIZE_BOX                0xEA20  // size box for splitters
#define AFX_IDW_PANE_SAVE               0xEA21  // to shift AFX_IDW_PANE_FIRST
#endif //!RC_INVOKED

#ifndef APSTUDIO_INVOKED

// common style for form views
#define AFX_WS_DEFAULT_VIEW             (WS_CHILD | WS_VISIBLE | WS_BORDER)

#endif //!APSTUDIO_INVOKED

/////////////////////////////////////////////////////////////////////////////
// Standard app configurable strings

// for application title (defaults to EXE name or name in constructor)
#define AFX_IDS_APP_TITLE               0xE000
// idle message bar line
#define AFX_IDS_IDLEMESSAGE             0xE001
// message bar line when in shift-F1 help mode
#define AFX_IDS_HELPMODEMESSAGE         0xE002
// document title when editing OLE embedding
#define AFX_IDS_APP_TITLE_EMBEDDING     0xE003
// company name
#define AFX_IDS_COMPANY_NAME            0xE004
// object name when server is inplace
#define AFX_IDS_OBJ_TITLE_INPLACE       0xE005

/////////////////////////////////////////////////////////////////////////////
// Standard Commands

// File commands
#define ID_FILE_NEW                     0xE100
#define ID_FILE_OPEN                    0xE101
#define ID_FILE_CLOSE                   0xE102
#define ID_FILE_SAVE                    0xE103
#define ID_FILE_SAVE_AS                 0xE104
#define ID_FILE_PAGE_SETUP              0xE105
#define ID_FILE_PRINT_SETUP             0xE106
#define ID_FILE_PRINT                   0xE107
#define ID_FILE_PRINT_DIRECT            0xE108
#define ID_FILE_PRINT_PREVIEW           0xE109
#define ID_FILE_UPDATE                  0xE10A
#define ID_FILE_SAVE_COPY_AS            0xE10B
#define ID_FILE_SEND_MAIL               0xE10C

#define ID_FILE_MRU_FIRST               0xE110
#define ID_FILE_MRU_FILE1               0xE110          // range - 16 max
#define ID_FILE_MRU_FILE2               0xE111
#define ID_FILE_MRU_FILE3               0xE112
#define ID_FILE_MRU_FILE4               0xE113
#define ID_FILE_MRU_FILE5               0xE114
#define ID_FILE_MRU_FILE6               0xE115
#define ID_FILE_MRU_FILE7               0xE116
#define ID_FILE_MRU_FILE8               0xE117
#define ID_FILE_MRU_FILE9               0xE118
#define ID_FILE_MRU_FILE10              0xE119
#define ID_FILE_MRU_FILE11              0xE11A
#define ID_FILE_MRU_FILE12              0xE11B
#define ID_FILE_MRU_FILE13              0xE11C
#define ID_FILE_MRU_FILE14              0xE11D
#define ID_FILE_MRU_FILE15              0xE11E
#define ID_FILE_MRU_FILE16              0xE11F
#define ID_FILE_MRU_LAST                0xE11F

// Edit commands
#define ID_EDIT_CLEAR                   0xE120
#define ID_EDIT_CLEAR_ALL               0xE121
#define ID_EDIT_COPY                    0xE122
#define ID_EDIT_CUT                     0xE123
#define ID_EDIT_FIND                    0xE124
#define ID_EDIT_PASTE                   0xE125
#define ID_EDIT_PASTE_LINK              0xE126
#define ID_EDIT_PASTE_SPECIAL           0xE127
#define ID_EDIT_REPEAT                  0xE128
#define ID_EDIT_REPLACE                 0xE129
#define ID_EDIT_SELECT_ALL              0xE12A
#define ID_EDIT_UNDO                    0xE12B
#define ID_EDIT_REDO                    0xE12C

// Window commands
#define ID_WINDOW_NEW                   0xE130
#define ID_WINDOW_ARRANGE               0xE131
#define ID_WINDOW_CASCADE               0xE132
#define ID_WINDOW_TILE_HORZ             0xE133
#define ID_WINDOW_TILE_VERT             0xE134
#define ID_WINDOW_SPLIT                 0xE135
#ifndef RC_INVOKED      // code only
#define AFX_IDM_WINDOW_FIRST            0xE130
#define AFX_IDM_WINDOW_LAST             0xE13F
#define AFX_IDM_FIRST_MDICHILD          0xFF00  // window list starts here
#endif //!RC_INVOKED

// Help and App commands
#define ID_APP_ABOUT                    0xE140
#define ID_APP_EXIT                     0xE141
#define ID_HELP_INDEX                   0xE142
#define ID_HELP_FINDER                  0xE143
#define ID_HELP_USING                   0xE144
#define ID_CONTEXT_HELP                 0xE145      // shift-F1
// special commands for processing help
#define ID_HELP                         0xE146      // first attempt for F1
#define ID_DEFAULT_HELP                 0xE147      // last attempt

// Misc
#define ID_NEXT_PANE                    0xE150
#define ID_PREV_PANE                    0xE151

// Format
#define ID_FORMAT_FONT                  0xE160

// OLE commands
#define ID_OLE_INSERT_NEW               0xE200
#define ID_OLE_EDIT_LINKS               0xE201
#define ID_OLE_EDIT_CONVERT             0xE202
#define ID_OLE_EDIT_CHANGE_ICON         0xE203
#define ID_OLE_EDIT_PROPERTIES          0xE204
#define ID_OLE_VERB_FIRST               0xE210     // range - 16 max
#ifndef RC_INVOKED      // code only
#define ID_OLE_VERB_LAST                0xE21F
#endif //!RC_INVOKED

// for print preview dialog bar
#define AFX_ID_PREVIEW_CLOSE            0xE300
#define AFX_ID_PREVIEW_NUMPAGE          0xE301      // One/Two Page button
#define AFX_ID_PREVIEW_NEXT             0xE302
#define AFX_ID_PREVIEW_PREV             0xE303
#define AFX_ID_PREVIEW_PRINT            0xE304
#define AFX_ID_PREVIEW_ZOOMIN           0xE305
#define AFX_ID_PREVIEW_ZOOMOUT          0xE306

// View commands (same number used as IDW used for control bar)
#define ID_VIEW_TOOLBAR                 0xE800
#define ID_VIEW_STATUS_BAR              0xE801
#define ID_VIEW_REBAR                   0xE804
#define ID_VIEW_AUTOARRANGE         0xE805
	// E810 -> E81F must be kept in order for RANGE macros
#define ID_VIEW_SMALLICON               0xE810
#define ID_VIEW_LARGEICON               0xE811
#define ID_VIEW_LIST                   0xE812
#define ID_VIEW_DETAILS                 0xE813
#define ID_VIEW_LINEUP                  0xE814
#define ID_VIEW_BYNAME                  0xE815
#define AFX_ID_VIEW_MINIMUM              ID_VIEW_SMALLICON
#define AFX_ID_VIEW_MAXIMUM              ID_VIEW_BYNAME
	// E800 -> E8FF reserved for other control bar commands

// RecordForm commands
#define ID_RECORD_FIRST                 0xE900
#define ID_RECORD_LAST                  0xE901
#define ID_RECORD_NEXT                  0xE902
#define ID_RECORD_PREV                  0xE903

/////////////////////////////////////////////////////////////////////////////
// Standard control IDs

#ifdef IDC_STATIC
#undef IDC_STATIC
#endif
#define IDC_STATIC              (-1)     // all static controls

/////////////////////////////////////////////////////////////////////////////
// Standard string error/warnings

#ifndef RC_INVOKED      // code only
#define AFX_IDS_SCFIRST                 0xEF00
#endif //!RC_INVOKED

#define AFX_IDS_SCSIZE                  0xEF00
#define AFX_IDS_SCMOVE                  0xEF01
#define AFX_IDS_SCMINIMIZE              0xEF02
#define AFX_IDS_SCMAXIMIZE              0xEF03
#define AFX_IDS_SCNEXTWINDOW            0xEF04
#define AFX_IDS_SCPREVWINDOW            0xEF05
#define AFX_IDS_SCCLOSE                 0xEF06
#define AFX_IDS_SCRESTORE               0xEF12
#define AFX_IDS_SCTASKLIST              0xEF13

#define AFX_IDS_MDICHILD                0xEF1F

#define AFX_IDS_DESKACCESSORY           0xEFDA

// General strings
#define AFX_IDS_OPENFILE                0xF000
#define AFX_IDS_SAVEFILE                0xF001
#define AFX_IDS_ALLFILTER               0xF002
#define AFX_IDS_UNTITLED                0xF003
#define AFX_IDS_SAVEFILECOPY            0xF004
#define AFX_IDS_PREVIEW_CLOSE           0xF005
#define AFX_IDS_UNNAMED_FILE            0xF006
#define AFX_IDS_HIDE                    0xF011

// MFC Standard Exception Error messages
#define AFX_IDP_NO_ERROR_AVAILABLE      0xF020
#define AFX_IDS_NOT_SUPPORTED_EXCEPTION 0xF021
#define AFX_IDS_RESOURCE_EXCEPTION      0xF022
#define AFX_IDS_MEMORY_EXCEPTION        0xF023
#define AFX_IDS_USER_EXCEPTION          0xF024

// Printing and print preview strings
#define AFX_IDS_PRINTONPORT             0xF040
#define AFX_IDS_ONEPAGE                 0xF041
#define AFX_IDS_TWOPAGE                 0xF042
#define AFX_IDS_PRINTPAGENUM            0xF043
#define AFX_IDS_PREVIEWPAGEDESC         0xF044
#define AFX_IDS_PRINTDEFAULTEXT         0xF045
#define AFX_IDS_PRINTDEFAULT            0xF046
#define AFX_IDS_PRINTFILTER             0xF047
#define AFX_IDS_PRINTCAPTION            0xF048
#define AFX_IDS_PRINTTOFILE             0xF049


// OLE strings
#define AFX_IDS_OBJECT_MENUITEM         0xF080
#define AFX_IDS_EDIT_VERB               0xF081
#define AFX_IDS_ACTIVATE_VERB           0xF082
#define AFX_IDS_CHANGE_LINK             0xF083
#define AFX_IDS_AUTO                    0xF084
#define AFX_IDS_MANUAL                  0xF085
#define AFX_IDS_FROZEN                  0xF086
#define AFX_IDS_ALL_FILES               0xF087
// dynamically changing menu items
#define AFX_IDS_SAVE_MENU               0xF088
#define AFX_IDS_UPDATE_MENU             0xF089
#define AFX_IDS_SAVE_AS_MENU            0xF08A
#define AFX_IDS_SAVE_COPY_AS_MENU       0xF08B
#define AFX_IDS_EXIT_MENU               0xF08C
#define AFX_IDS_UPDATING_ITEMS          0xF08D
// COlePasteSpecialDialog defines
#define AFX_IDS_METAFILE_FORMAT         0xF08E
#define AFX_IDS_DIB_FORMAT              0xF08F
#define AFX_IDS_BITMAP_FORMAT           0xF090
#define AFX_IDS_LINKSOURCE_FORMAT       0xF091
#define AFX_IDS_EMBED_FORMAT            0xF092
// other OLE utility strings
#define AFX_IDS_PASTELINKEDTYPE         0xF094
#define AFX_IDS_UNKNOWNTYPE             0xF095
#define AFX_IDS_RTF_FORMAT              0xF096
#define AFX_IDS_TEXT_FORMAT             0xF097
// OLE datatype format error strings
#define AFX_IDS_INVALID_CURRENCY        0xF098
#define AFX_IDS_INVALID_DATETIME        0xF099
#define AFX_IDS_INVALID_DATETIMESPAN    0xF09A

// General error / prompt strings
#define AFX_IDP_INVALID_FILENAME        0xF100
#define AFX_IDP_FAILED_TO_OPEN_DOC      0xF101
#define AFX_IDP_FAILED_TO_SAVE_DOC      0xF102
#define AFX_IDP_ASK_TO_SAVE             0xF103
#define AFX_IDP_FAILED_TO_CREATE_DOC    0xF104
#define AFX_IDP_FILE_TOO_LARGE          0xF105
#define AFX_IDP_FAILED_TO_START_PRINT   0xF106
#define AFX_IDP_FAILED_TO_LAUNCH_HELP   0xF107
#define AFX_IDP_INTERNAL_FAILURE        0xF108      // general failure
#define AFX_IDP_COMMAND_FAILURE         0xF109      // command failure
#define AFX_IDP_FAILED_MEMORY_ALLOC     0xF10A
#define AFX_IDP_UNREG_DONE              0xF10B
#define AFX_IDP_UNREG_FAILURE           0xF10C
#define AFX_IDP_DLL_LOAD_FAILED         0xF10D
#define AFX_IDP_DLL_BAD_VERSION         0xF10E

// DDV parse errors
#define AFX_IDP_PARSE_INT               0xF110
#define AFX_IDP_PARSE_REAL              0xF111
#define AFX_IDP_PARSE_INT_RANGE         0xF112
#define AFX_IDP_PARSE_REAL_RANGE        0xF113
#define AFX_IDP_PARSE_STRING_SIZE       0xF114
#define AFX_IDP_PARSE_RADIO_BUTTON      0xF115
#define AFX_IDP_PARSE_BYTE              0xF116
#define AFX_IDP_PARSE_UINT              0xF117
#define AFX_IDP_PARSE_DATETIME          0xF118
#define AFX_IDP_PARSE_CURRENCY          0xF119

// CFile/CArchive error strings for user failure
#define AFX_IDP_FAILED_INVALID_FORMAT   0xF120
#define AFX_IDP_FAILED_INVALID_PATH     0xF121
#define AFX_IDP_FAILED_DISK_FULL        0xF122
#define AFX_IDP_FAILED_ACCESS_READ      0xF123
#define AFX_IDP_FAILED_ACCESS_WRITE     0xF124
#define AFX_IDP_FAILED_IO_ERROR_READ    0xF125
#define AFX_IDP_FAILED_IO_ERROR_WRITE   0xF126

// OLE errors / prompt strings
#define AFX_IDP_STATIC_OBJECT           0xF180
#define AFX_IDP_FAILED_TO_CONNECT       0xF181
#define AFX_IDP_SERVER_BUSY             0xF182
#define AFX_IDP_BAD_VERB                0xF183
#define AFX_IDS_NOT_DOCOBJECT                0xF184
#define AFX_IDP_FAILED_TO_NOTIFY        0xF185
#define AFX_IDP_FAILED_TO_LAUNCH        0xF186
#define AFX_IDP_ASK_TO_UPDATE           0xF187
#define AFX_IDP_FAILED_TO_UPDATE        0xF188
#define AFX_IDP_FAILED_TO_REGISTER      0xF189
#define AFX_IDP_FAILED_TO_AUTO_REGISTER 0xF18A
#define AFX_IDP_FAILED_TO_CONVERT       0xF18B
#define AFX_IDP_GET_NOT_SUPPORTED       0xF18C
#define AFX_IDP_SET_NOT_SUPPORTED       0xF18D
#define AFX_IDP_ASK_TO_DISCARD          0xF18E
#define AFX_IDP_FAILED_TO_CREATE        0xF18F

// MAPI errors / prompt strings
#define AFX_IDP_FAILED_MAPI_LOAD        0xF190
#define AFX_IDP_INVALID_MAPI_DLL        0xF191
#define AFX_IDP_FAILED_MAPI_SEND        0xF192

#define AFX_IDP_FILE_NONE               0xF1A0
#define AFX_IDP_FILE_GENERIC            0xF1A1
#define AFX_IDP_FILE_NOT_FOUND          0xF1A2
#define AFX_IDP_FILE_BAD_PATH           0xF1A3
#define AFX_IDP_FILE_TOO_MANY_OPEN      0xF1A4
#define AFX_IDP_FILE_ACCESS_DENIED      0xF1A5
#define AFX_IDP_FILE_INVALID_FILE       0xF1A6
#define AFX_IDP_FILE_REMOVE_CURRENT     0xF1A7
#define AFX_IDP_FILE_DIR_FULL           0xF1A8
#define AFX_IDP_FILE_BAD_SEEK           0xF1A9
#define AFX_IDP_FILE_HARD_IO            0xF1AA
#define AFX_IDP_FILE_SHARING            0xF1AB
#define AFX_IDP_FILE_LOCKING            0xF1AC
#define AFX_IDP_FILE_DISKFULL           0xF1AD
#define AFX_IDP_FILE_EOF                0xF1AE

#define AFX_IDP_ARCH_NONE               0xF1B0
#define AFX_IDP_ARCH_GENERIC            0xF1B1
#define AFX_IDP_ARCH_READONLY           0xF1B2
#define AFX_IDP_ARCH_ENDOFFILE          0xF1B3
#define AFX_IDP_ARCH_WRITEONLY          0xF1B4
#define AFX_IDP_ARCH_BADINDEX           0xF1B5
#define AFX_IDP_ARCH_BADCLASS           0xF1B6
#define AFX_IDP_ARCH_BADSCHEMA          0xF1B7

#define AFX_IDS_OCC_SCALEUNITS_PIXELS   0xF1C0

// 0xf200-0xf20f reserved

// font names and point sizes
#define AFX_IDS_STATUS_FONT             0xF230
#define AFX_IDS_TOOLTIP_FONT            0xF231
#define AFX_IDS_UNICODE_FONT            0xF232
#define AFX_IDS_MINI_FONT               0xF233

// ODBC Database errors / prompt strings
#ifndef RC_INVOKED      // code only
#define AFX_IDP_SQL_FIRST                       0xF280
#endif //!RC_INVOKED
#define AFX_IDP_SQL_CONNECT_FAIL                0xF281
#define AFX_IDP_SQL_RECORDSET_FORWARD_ONLY      0xF282
#define AFX_IDP_SQL_EMPTY_COLUMN_LIST           0xF283
#define AFX_IDP_SQL_FIELD_SCHEMA_MISMATCH       0xF284
#define AFX_IDP_SQL_ILLEGAL_MODE                0xF285
#define AFX_IDP_SQL_MULTIPLE_ROWS_AFFECTED      0xF286
#define AFX_IDP_SQL_NO_CURRENT_RECORD           0xF287
#define AFX_IDP_SQL_NO_ROWS_AFFECTED            0xF288
#define AFX_IDP_SQL_RECORDSET_READONLY          0xF289
#define AFX_IDP_SQL_SQL_NO_TOTAL                0xF28A
#define AFX_IDP_SQL_ODBC_LOAD_FAILED            0xF28B
#define AFX_IDP_SQL_DYNASET_NOT_SUPPORTED       0xF28C
#define AFX_IDP_SQL_SNAPSHOT_NOT_SUPPORTED      0xF28D
#define AFX_IDP_SQL_API_CONFORMANCE             0xF28E
#define AFX_IDP_SQL_SQL_CONFORMANCE             0xF28F
#define AFX_IDP_SQL_NO_DATA_FOUND               0xF290
#define AFX_IDP_SQL_ROW_UPDATE_NOT_SUPPORTED    0xF291
#define AFX_IDP_SQL_ODBC_V2_REQUIRED            0xF292
#define AFX_IDP_SQL_NO_POSITIONED_UPDATES       0xF293
#define AFX_IDP_SQL_LOCK_MODE_NOT_SUPPORTED     0xF294
#define AFX_IDP_SQL_DATA_TRUNCATED              0xF295
#define AFX_IDP_SQL_ROW_FETCH                   0xF296
#define AFX_IDP_SQL_INCORRECT_ODBC              0xF297
#define AFX_IDP_SQL_UPDATE_DELETE_FAILED        0xF298
#define AFX_IDP_SQL_DYNAMIC_CURSOR_NOT_SUPPORTED    0xF299
#define AFX_IDP_SQL_FIELD_NOT_FOUND             0xF29A
#define AFX_IDP_SQL_BOOKMARKS_NOT_SUPPORTED     0xF29B
#define AFX_IDP_SQL_BOOKMARKS_NOT_ENABLED       0xF29C

// ODBC Database strings
#define AFX_IDS_DELETED                         0xF29D

// DAO Database errors / prompt strings
#ifndef RC_INVOKED      // code only
#define AFX_IDP_DAO_FIRST                       0xF2B0
#endif //!RC_INVOKED
#define AFX_IDP_DAO_ENGINE_INITIALIZATION       0xF2B0
#define AFX_IDP_DAO_DFX_BIND                    0xF2B1
#define AFX_IDP_DAO_OBJECT_NOT_OPEN             0xF2B2

// ICDAORecordset::GetRows Errors
//  These are not placed in DAO Errors collection
//  and must be handled directly by MFC.
#define AFX_IDP_DAO_ROWTOOSHORT                 0xF2B3
#define AFX_IDP_DAO_BADBINDINFO                 0xF2B4
#define AFX_IDP_DAO_COLUMNUNAVAILABLE           0xF2B5

/////////////////////////////////////////////////////////////////////////////
// Strings for ISAPI support

#define AFX_IDS_HTTP_TITLE              0xF2D1
#define AFX_IDS_HTTP_NO_TEXT            0xF2D2
#define AFX_IDS_HTTP_BAD_REQUEST        0xF2D3
#define AFX_IDS_HTTP_AUTH_REQUIRED      0xF2D4
#define AFX_IDS_HTTP_FORBIDDEN          0xF2D5
#define AFX_IDS_HTTP_NOT_FOUND          0xF2D6
#define AFX_IDS_HTTP_SERVER_ERROR       0xF2D7
#define AFX_IDS_HTTP_NOT_IMPLEMENTED    0xF2D8

/////////////////////////////////////////////////////////////////////////////
// AFX implementation - control IDs (AFX_IDC)

// Parts of dialogs
#define AFX_IDC_LISTBOX                 100
#define AFX_IDC_CHANGE                  101

// for print dialog
#define AFX_IDC_PRINT_DOCNAME           201
#define AFX_IDC_PRINT_PRINTERNAME       202
#define AFX_IDC_PRINT_PORTNAME          203
#define AFX_IDC_PRINT_PAGENUM           204

// Property Sheet control id's (determined with Spy++)
#define ID_APPLY_NOW                    0x3021
#define ID_WIZBACK                      0x3023
#define ID_WIZNEXT                      0x3024
#define ID_WIZFINISH                    0x3025
#define AFX_IDC_TAB_CONTROL             0x3020

/////////////////////////////////////////////////////////////////////////////
// IDRs for standard components

#ifndef RC_INVOKED  // code only
// These are really COMMDLG dialogs, so there usually isn't a resource
// for them, but these IDs are used as help IDs.
#define AFX_IDD_FILEOPEN                28676
#define AFX_IDD_FILESAVE                28677
#define AFX_IDD_FONT                    28678
#define AFX_IDD_COLOR                   28679
#define AFX_IDD_PRINT                   28680
#define AFX_IDD_PRINTSETUP              28681
#define AFX_IDD_FIND                    28682
#define AFX_IDD_REPLACE                 28683
#endif //!RC_INVOKED

// Standard dialogs app should leave alone (0x7801->)
#define AFX_IDD_NEWTYPEDLG              30721
#define AFX_IDD_PRINTDLG                30722
#define AFX_IDD_PREVIEW_TOOLBAR         30723

// Dialogs defined for OLE2UI library
#define AFX_IDD_INSERTOBJECT            30724
#define AFX_IDD_CHANGEICON              30725
#define AFX_IDD_CONVERT                 30726
#define AFX_IDD_PASTESPECIAL            30727
#define AFX_IDD_EDITLINKS               30728
#define AFX_IDD_FILEBROWSE              30729
#define AFX_IDD_BUSY                    30730

#define AFX_IDD_OBJECTPROPERTIES        30732
#define AFX_IDD_CHANGESOURCE            30733

// Standard cursors (0x7901->)
	// AFX_IDC = Cursor resources
#define AFX_IDC_CONTEXTHELP             30977       // context sensitive help
#define AFX_IDC_MAGNIFY                 30978       // print preview zoom
#define AFX_IDC_SMALLARROWS             30979       // splitter
#define AFX_IDC_HSPLITBAR               30980       // splitter
#define AFX_IDC_VSPLITBAR               30981       // splitter
#define AFX_IDC_NODROPCRSR              30982       // No Drop Cursor
#define AFX_IDC_TRACKNWSE               30983       // tracker
#define AFX_IDC_TRACKNESW               30984       // tracker
#define AFX_IDC_TRACKNS                 30985       // tracker
#define AFX_IDC_TRACKWE                 30986       // tracker
#define AFX_IDC_TRACK4WAY               30987       // tracker
#define AFX_IDC_MOVE4WAY                30988       // resize bar (server only)

// Mini frame window bitmap ID
#define AFX_IDB_MINIFRAME_MENU          30994

// CheckListBox checks bitmap ID
#define AFX_IDB_CHECKLISTBOX_NT         30995
#define AFX_IDB_CHECKLISTBOX_95         30996

// AFX standard accelerator resources
#define AFX_IDR_PREVIEW_ACCEL           30997

// AFX standard ICON IDs (for MFC V1 apps) (0x7A01->)
#define AFX_IDI_STD_MDIFRAME            31233
#define AFX_IDI_STD_FRAME               31234

/////////////////////////////////////////////////////////////////////////////
// AFX OLE control implementation - control IDs (AFX_IDC)

// Font property page
#define AFX_IDC_FONTPROP                1000
#define AFX_IDC_FONTNAMES               1001
#define AFX_IDC_FONTSTYLES              1002
#define AFX_IDC_FONTSIZES               1003
#define AFX_IDC_STRIKEOUT               1004
#define AFX_IDC_UNDERLINE               1005
#define AFX_IDC_SAMPLEBOX               1006

// Color property page
#define AFX_IDC_COLOR_BLACK             1100
#define AFX_IDC_COLOR_WHITE             1101
#define AFX_IDC_COLOR_RED               1102
#define AFX_IDC_COLOR_GREEN             1103
#define AFX_IDC_COLOR_BLUE              1104
#define AFX_IDC_COLOR_YELLOW            1105
#define AFX_IDC_COLOR_MAGENTA           1106
#define AFX_IDC_COLOR_CYAN              1107
#define AFX_IDC_COLOR_GRAY              1108
#define AFX_IDC_COLOR_LIGHTGRAY         1109
#define AFX_IDC_COLOR_DARKRED           1110
#define AFX_IDC_COLOR_DARKGREEN         1111
#define AFX_IDC_COLOR_DARKBLUE          1112
#define AFX_IDC_COLOR_LIGHTBROWN        1113
#define AFX_IDC_COLOR_DARKMAGENTA       1114
#define AFX_IDC_COLOR_DARKCYAN          1115
#define AFX_IDC_COLORPROP               1116
#define AFX_IDC_SYSTEMCOLORS            1117

// Picture porperty page
#define AFX_IDC_PROPNAME                1201
#define AFX_IDC_PICTURE                 1202
#define AFX_IDC_BROWSE                  1203
#define AFX_IDC_CLEAR                   1204

/////////////////////////////////////////////////////////////////////////////
// IDRs for OLE control standard components

// Standard propery page dialogs app should leave alone (0x7E01->)
#define AFX_IDD_PROPPAGE_COLOR         32257
#define AFX_IDD_PROPPAGE_FONT          32258
#define AFX_IDD_PROPPAGE_PICTURE       32259

#define AFX_IDB_TRUETYPE               32384

/////////////////////////////////////////////////////////////////////////////
// Standard OLE control strings

// OLE Control page strings
#define AFX_IDS_PROPPAGE_UNKNOWN        0xFE01
#define AFX_IDS_COLOR_DESKTOP           0xFE04
#define AFX_IDS_COLOR_APPWORKSPACE      0xFE05
#define AFX_IDS_COLOR_WNDBACKGND        0xFE06
#define AFX_IDS_COLOR_WNDTEXT           0xFE07
#define AFX_IDS_COLOR_MENUBAR           0xFE08
#define AFX_IDS_COLOR_MENUTEXT          0xFE09
#define AFX_IDS_COLOR_ACTIVEBAR         0xFE0A
#define AFX_IDS_COLOR_INACTIVEBAR       0xFE0B
#define AFX_IDS_COLOR_ACTIVETEXT        0xFE0C
#define AFX_IDS_COLOR_INACTIVETEXT      0xFE0D
#define AFX_IDS_COLOR_ACTIVEBORDER      0xFE0E
#define AFX_IDS_COLOR_INACTIVEBORDER    0xFE0F
#define AFX_IDS_COLOR_WNDFRAME          0xFE10
#define AFX_IDS_COLOR_SCROLLBARS        0xFE11
#define AFX_IDS_COLOR_BTNFACE           0xFE12
#define AFX_IDS_COLOR_BTNSHADOW         0xFE13
#define AFX_IDS_COLOR_BTNTEXT           0xFE14
#define AFX_IDS_COLOR_BTNHIGHLIGHT      0xFE15
#define AFX_IDS_COLOR_DISABLEDTEXT      0xFE16
#define AFX_IDS_COLOR_HIGHLIGHT         0xFE17
#define AFX_IDS_COLOR_HIGHLIGHTTEXT     0xFE18
#define AFX_IDS_REGULAR                 0xFE19
#define AFX_IDS_BOLD                    0xFE1A
#define AFX_IDS_ITALIC                  0xFE1B
#define AFX_IDS_BOLDITALIC              0xFE1C
#define AFX_IDS_SAMPLETEXT              0xFE1D
#define AFX_IDS_DISPLAYSTRING_FONT      0xFE1E
#define AFX_IDS_DISPLAYSTRING_COLOR     0xFE1F
#define AFX_IDS_DISPLAYSTRING_PICTURE   0xFE20
#define AFX_IDS_PICTUREFILTER           0xFE21
#define AFX_IDS_PICTYPE_UNKNOWN         0xFE22
#define AFX_IDS_PICTYPE_NONE            0xFE23
#define AFX_IDS_PICTYPE_BITMAP          0xFE24
#define AFX_IDS_PICTYPE_METAFILE        0xFE25
#define AFX_IDS_PICTYPE_ICON            0xFE26
#define AFX_IDS_COLOR_PPG               0xFE28
#define AFX_IDS_COLOR_PPG_CAPTION       0xFE29
#define AFX_IDS_FONT_PPG                0xFE2A
#define AFX_IDS_FONT_PPG_CAPTION        0xFE2B
#define AFX_IDS_PICTURE_PPG             0xFE2C
#define AFX_IDS_PICTURE_PPG_CAPTION     0xFE2D
#define AFX_IDS_PICTUREBROWSETITLE      0xFE30
#define AFX_IDS_BORDERSTYLE_0           0xFE31
#define AFX_IDS_BORDERSTYLE_1           0xFE32

// OLE Control verb names
#define AFX_IDS_VERB_EDIT               0xFE40
#define AFX_IDS_VERB_PROPERTIES         0xFE41

// OLE Control internal error messages
#define AFX_IDP_PICTURECANTOPEN         0xFE83
#define AFX_IDP_PICTURECANTLOAD         0xFE84
#define AFX_IDP_PICTURETOOLARGE         0xFE85
#define AFX_IDP_PICTUREREADFAILED       0xFE86

// Standard OLE Control error strings
#define AFX_IDP_E_ILLEGALFUNCTIONCALL       0xFEA0
#define AFX_IDP_E_OVERFLOW                  0xFEA1
#define AFX_IDP_E_OUTOFMEMORY               0xFEA2
#define AFX_IDP_E_DIVISIONBYZERO            0xFEA3
#define AFX_IDP_E_OUTOFSTRINGSPACE          0xFEA4
#define AFX_IDP_E_OUTOFSTACKSPACE           0xFEA5
#define AFX_IDP_E_BADFILENAMEORNUMBER       0xFEA6
#define AFX_IDP_E_FILENOTFOUND              0xFEA7
#define AFX_IDP_E_BADFILEMODE               0xFEA8
#define AFX_IDP_E_FILEALREADYOPEN           0xFEA9
#define AFX_IDP_E_DEVICEIOERROR             0xFEAA
#define AFX_IDP_E_FILEALREADYEXISTS         0xFEAB
#define AFX_IDP_E_BADRECORDLENGTH           0xFEAC
#define AFX_IDP_E_DISKFULL                  0xFEAD
#define AFX_IDP_E_BADRECORDNUMBER           0xFEAE
#define AFX_IDP_E_BADFILENAME               0xFEAF
#define AFX_IDP_E_TOOMANYFILES              0xFEB0
#define AFX_IDP_E_DEVICEUNAVAILABLE         0xFEB1
#define AFX_IDP_E_PERMISSIONDENIED          0xFEB2
#define AFX_IDP_E_DISKNOTREADY              0xFEB3
#define AFX_IDP_E_PATHFILEACCESSERROR       0xFEB4
#define AFX_IDP_E_PATHNOTFOUND              0xFEB5
#define AFX_IDP_E_INVALIDPATTERNSTRING      0xFEB6
#define AFX_IDP_E_INVALIDUSEOFNULL          0xFEB7
#define AFX_IDP_E_INVALIDFILEFORMAT         0xFEB8
#define AFX_IDP_E_INVALIDPROPERTYVALUE      0xFEB9
#define AFX_IDP_E_INVALIDPROPERTYARRAYINDEX 0xFEBA
#define AFX_IDP_E_SETNOTSUPPORTEDATRUNTIME  0xFEBB
#define AFX_IDP_E_SETNOTSUPPORTED           0xFEBC
#define AFX_IDP_E_NEEDPROPERTYARRAYINDEX    0xFEBD
#define AFX_IDP_E_SETNOTPERMITTED           0xFEBE
#define AFX_IDP_E_GETNOTSUPPORTEDATRUNTIME  0xFEBF
#define AFX_IDP_E_GETNOTSUPPORTED           0xFEC0
#define AFX_IDP_E_PROPERTYNOTFOUND          0xFEC1
#define AFX_IDP_E_INVALIDCLIPBOARDFORMAT    0xFEC2
#define AFX_IDP_E_INVALIDPICTURE            0xFEC3
#define AFX_IDP_E_PRINTERERROR              0xFEC4
#define AFX_IDP_E_CANTSAVEFILETOTEMP        0xFEC5
#define AFX_IDP_E_SEARCHTEXTNOTFOUND        0xFEC6
#define AFX_IDP_E_REPLACEMENTSTOOLONG       0xFEC7

/////////////////////////////////////////////////////////////////////////////

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#endif //__AFXRES_H__

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\fractal\gdipscsave.cpp ===
/**************************************************************************
*
* Copyright (c) 1998-2000, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   Gdipscsave.cpp
*
* Abstract:
*
*   Demonstration GDI+ based screen saver with several different
*   fractal patterns
*
* Revision History:
*
*   8/17/2000  peterost - Created it.
*
***************************************************************************/

#include "gdipscsave.h"
#include <math.h>
#include "../gpinit.inc"

extern HINSTANCE hMainInstance; /* screen saver instance handle  */ 
 
/**********************************************************************
*
*  Handle configuration dialog
*
***********************************************************************/

BOOL WINAPI ScreenSaverConfigureDialog (HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{ 
    static HWND hNumber; /* handle to number of fractals scroll bar */ 
    static HWND hOK;     /* handle to OK push button */ 
 
    switch(message) 
    { 
        case WM_INITDIALOG: 
 
			/* Retrieve the application name from the .rc file. */
			LoadString(hMainInstance,idsAppName,szAppName,40);
 
            /* Retrieve any redraw speed data from the registry. */ 
            GetFractalConfig (&nFractType, &nNumFracts);
  
            /* Initialize the number of fractals scroll bar control. */ 
            hNumber = GetDlgItem(hDlg, ID_SPEED); 
            SetScrollRange(hNumber, SB_CTL, MINVEL, MAXVEL, FALSE); 
            SetScrollPos(hNumber, SB_CTL, nNumFracts, TRUE); 

            /* Initialize the type of fractals radio buttons */
            CheckRadioButton(hDlg, IDC_RADIOTYPE1, IDC_RADIOTYPE5, IDC_RADIOTYPE1+nFractType);

            /* Retrieve a handle to the OK push button control. */ 
            hOK = GetDlgItem(hDlg, IDOK); 
 
            return TRUE; 
 
        case WM_HSCROLL: 
 
            /* 
             * Process scroll bar input, adjusting the nNumFracts 
             * value as appropriate. 
             */ 
 
            switch (LOWORD(wParam)) 
                { 
                    case SB_PAGEUP: 
                        --nNumFracts; 
                    break; 
 
                    case SB_LINEUP: 
                        --nNumFracts; 
                    break; 
 
                    case SB_PAGEDOWN: 
                        ++nNumFracts; 
                    break; 
 
                    case SB_LINEDOWN: 
                        ++nNumFracts; 
                    break; 
 
                    case SB_THUMBPOSITION: 
                        nNumFracts = HIWORD(wParam); 
                    break; 
 
                    case SB_BOTTOM: 
                        nNumFracts = MINVEL; 
                    break; 
 
                    case SB_TOP: 
                        nNumFracts = MAXVEL; 
                    break; 
 
                    case SB_THUMBTRACK: 
                    case SB_ENDSCROLL: 
                        return TRUE; 
                    break; 
                } 
                if ((int) nNumFracts <= MINVEL) 
                    nNumFracts = MINVEL; 
                if ((int) nNumFracts >= MAXVEL) 
                    nNumFracts = MAXVEL; 
 
                SetScrollPos((HWND) lParam, SB_CTL, nNumFracts, TRUE); 
            break; 
 
        case WM_COMMAND: 
            switch(LOWORD(wParam)) 
            { 
                case ID_OK: 
                    if (IsDlgButtonChecked(hDlg, IDC_RADIOTYPE1))
                        nFractType = 0;
                    else if (IsDlgButtonChecked(hDlg, IDC_RADIOTYPE2))
                        nFractType = 1;
                    else if (IsDlgButtonChecked(hDlg, IDC_RADIOTYPE3))
                        nFractType = 2;
                    else if (IsDlgButtonChecked(hDlg, IDC_RADIOTYPE4))
                        nFractType = 3;
                    else
                        nFractType = 4;
                    SetFractalConfig(nFractType, nNumFracts);
 
                case ID_CANCEL: 
                    EndDialog(hDlg, LOWORD(wParam) == IDOK); 
                return TRUE; 
            } 
    } 
    return FALSE; 
} 
 
BOOL WINAPI RegisterDialogClasses(
    HANDLE  hInst
    )
{ 
    return TRUE; 
} 

LRESULT WINAPI ScreenSaverProcW (HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{ 
static HDC          hdc;    /* device-context handle */ 
static RECT         rc;     /* RECT structure */ 
static UINT         uTimer; /* timer identifier */ 
static DWORD        dwNumDrawn = -1;
 
    switch(message) 
    { 
        case WM_CREATE: 
 
            // Retrieve the application name from the .rc file. 
            LoadString(hMainInstance, idsAppName, szAppName, 40); 
  
            // Retrieve any configuration data from the registry.
            GetFractalConfig (&nFractType, &nNumFracts); 

            // Set a timer for the screen saver window 
            uTimer = SetTimer(hwnd, 1, 1000, NULL); 

            srand( (unsigned)GetTickCount() );
            fMandelbrot = rand()%2;

//            stream = fopen( "fprintf.out", "w" );
//            fprintf(stream, "initialized\n");

            break; 
 
        case WM_ERASEBKGND: 
 
           /* 
            * The WM_ERASEBKGND message is issued before the 
            * WM_TIMER message, allowing the screen saver to 
            * paint the background as appropriate. 
            */ 
 
            hdc = GetDC(hwnd); 
            GetClientRect (hwnd, &rc); 
            FillRect (hdc, &rc, (HBRUSH)GetStockObject(BLACK_BRUSH)); 
            ReleaseDC(hwnd,hdc); 
            break; 
 
        case WM_TIMER: 
 
           /* 
            * The WM_TIMER message is issued at REDRAWTIME. This 
            * code repaints the entire desktop with black brush every time
            * nNumFracts fractals have been drawn, and calls the appropriate
            * fractal rendering function based on nFractType
            */ 
 
            if (uTimer)
                KillTimer(hwnd, uTimer);

            hdc = GetDC(hwnd); 
            GetClientRect(hwnd, &rc); 
            if (++dwNumDrawn >= nNumFracts) 
            {
                dwNumDrawn = 0;
                
                FillRect(hdc, &rc, (HBRUSH)GetStockObject(BLACK_BRUSH));
            }

            switch (nFractType)
            {
                case 0:
                    DrawSierpinski(hdc, hwnd, rc, dwNumDrawn);
                    break;
                case 1:
                    DrawHieghway(hdc, hwnd, rc, dwNumDrawn);
                    break;
                case 2:
                    DrawTree(hdc, hwnd, rc, dwNumDrawn);
                    break;
                case 3:
                    DrawPlasma(hdc, hwnd, rc, dwNumDrawn);
                    break;
                case 4:
                    DrawJulia(hdc, hwnd, rc, dwNumDrawn, fMandelbrot);
                    break;
            }

            uTimer = SetTimer(hwnd, 1, REDRAWTIME, NULL); 

            ReleaseDC(hwnd,hdc); 
            break; 
 
        case WM_DESTROY: 
 
           /* 
            * When the WM_DESTROY message is issued, the screen saver 
            * must destroy any of the timers that were set at WM_CREATE 
            * time. 
            */ 
//            fclose(stream);
            if (uTimer) 
                KillTimer(hwnd, uTimer); 
            break; 
    } 
 
    // DefScreenSaverProc processes any messages ignored by ScreenSaverProc. 
    return DefScreenSaverProc(hwnd, message, wParam, lParam); 
} 
 
VOID FillSierpinski(HWND hwnd, Graphics *g, PointF one, PointF two, PointF three, int level, Brush *pBrush, Pen *pPen)
{
    MSG msg;

    if (level == 4 &&
         PeekMessage(&msg, hwnd, WM_KEYFIRST, WM_MOUSELAST, PM_NOREMOVE))
    {
        return;
    }
       
   g->DrawLine(pPen, one, two);
   g->DrawLine(pPen, two, three);
   g->DrawLine(pPen, three, one);

   PointF midpoints[3];
   midpoints[0].X = (two.X + one.X) / 2;
   midpoints[0].Y = (two.Y + one.Y) / 2;
   midpoints[1].X = (three.X + two.X) / 2;
   midpoints[1].Y = (three.Y + two.Y) / 2;
   midpoints[2].X = (one.X + three.X) / 2;
   midpoints[2].Y = (one.Y + three.Y) / 2;

   GraphicsPath triangle;
   triangle.AddPolygon(midpoints, 3); 
   g->FillPath(pBrush, &triangle);

   if (level-- > 0)
   {
       FillSierpinski(hwnd, g, two, midpoints[0], midpoints[1], level, pBrush, pPen);
       FillSierpinski(hwnd, g, three, midpoints[1], midpoints[2], level, pBrush, pPen);
       FillSierpinski(hwnd, g, one, midpoints[0], midpoints[2], level, pBrush, pPen);
   }

}

VOID DrawSierpinski(HDC hDC, HWND hwnd, RECT rc, int iColor)
{
    Graphics g(hDC);
    PointF points[3];
    Color  colors[3] = {
            Color(160,255,0,0),
            Color(130,0,255,0),
            Color(110,0,0,255)};
    int nColors = 3, iMinLen = 6;

    // Get some good random points.  Limit angles to be > 20 degrees, so
    // there are no skinny triangles
    for (int j = 0; j <= 20; j++)
    {
        for (int i = 0; i<= 2; i++)
        {
            points[i].X = (REAL)(rand() % (rc.right - rc.left));
            points[i].Y = (REAL)(rand() % (rc.bottom - rc.top));
        }

        double a,b,c,cosa,cosb,cosc;

        a = sqrt(pow(points[0].X - points[1].X, 2) + pow(points[0].Y - points[1].Y, 2));
        b = sqrt(pow(points[2].X - points[1].X, 2) + pow(points[2].Y - points[1].Y, 2));
        c = sqrt(pow(points[0].X - points[2].X, 2) + pow(points[0].Y - points[2].Y, 2));
        iMinLen = (int)min(a,min(b,c));
//fprintf(stream, " %6f  %6f  %6f   %d\n", a, b, c, j);

        cosa = (pow(a,2) - pow(b,2) - pow(c,2)) / (-2 * b * c);
        cosb = (pow(b,2) - pow(a,2) - pow(c,2)) / (-2 * a * c);
        cosc = (pow(c,2) - pow(a,2) - pow(b,2)) / (-2 * a * b);
//fprintf(stream, " %6f  %6f  %6f   %d\n", cosa, cosb, cosc, j);
        if ((fabs(cosa) < 0.939) && 
            (fabs(cosb) < 0.939) && 
            (fabs(cosc) < 0.939) &&
            (a > 35))
        {
//            fprintf(stream, "broke\n");
            break;
        }       
    }
            
    PathGradientBrush brush(points, nColors);
    brush.SetSurroundColors(colors, &nColors);

    Pen pen(Color(90, (255-iColor*90)%256, 0, (iColor*60)%256));

    g.SetSmoothingMode(SmoothingModeAntiAlias);

    FillSierpinski(hwnd, &g, points[0], points[1], points[2], min(6,max(3,iMinLen/70)), &brush, &pen);
}

VOID DrawHieghway(HDC hDC, HWND hwnd, RECT rc, int iColor)
{
   static PointF p1[16390], p2[16390];

   int iSize = 2, iLen, iPad = (rc.bottom - rc.top) / 4;
   PointF *parr1, *parr2, *ptemp;


   // Calculate a starting line that is not too close to the edges of the screen
   p1[0].X = (REAL)(iPad + (rand() % (rc.right - rc.left - iPad*2)));
   p1[0].Y = (REAL)(iPad + (rand() % (rc.bottom - rc.top - iPad*2)));
   iLen = (rand() % (min(rc.right - rc.left, rc.bottom - rc.top) / 2)) + iPad/2;
   
   if (rand() & 1)
   {
       p1[1].X = p1[0].X;
       if (p1[0].Y > (rc.bottom - rc.top)/2)
           p1[1].Y = p1[0].Y - iLen;
       else
           p1[1].Y = p1[0].Y + iLen;
   }
   else
   {
       if (p1[0].X > (rc.right - rc.left)/2)
           p1[1].X = p1[0].X - iLen;
       else
           p1[1].X = p1[0].X + iLen;
       p1[1].Y = p1[0].Y;
   }

  PointF pgrad1(p1[0].X, p1[0].Y), pgrad2(p1[1].X, p1[1].Y);
//fprintf(stream, " %6f  %6f  %6f  %6f\n", p1[0].X, p1[0].Y, p1[1].X, p1[1].Y);

   parr1 = p1;
   parr2 = p2;

   // Create dragon pattern to a level which is more or less dependent on the
   // overall size of the pattern.
   for (int i=0; i<max(MINHEIGHWAYLEVEL,min(sqrt(iLen/2), MAXHEIGHWAYLEVEL)); i++)
   {
      IterateHieghway(parr1, parr2, &iSize);
      ptemp = parr1;
      parr1 = parr2;
      parr2 = ptemp;
   }

   // Draw the resultant pattern with a gradient pen with random colors.
   Graphics g(hDC);
   LinearGradientBrush brush(pgrad1, pgrad2, 
        Color(230, (rand()%200)+55, (rand()%128)+55, rand()%256),
        Color(180, (rand()%100)+155, rand()%256, (rand()%200)+55));
   brush.SetWrapMode(WrapModeTileFlipXY);
   Pen pen(&brush);

// fprintf(stream, " %d  %d \n", iLen, iSize);

   MSG msg;

   for (int j=0; j<(iSize-1); j++)
   {
      g.DrawLine(&pen, parr1[j], parr1[j+1]);

      // Drawing takes a long time, so check for queued message periodically
      if (j%1000 == 0 &&
          PeekMessage(&msg, hwnd, WM_KEYFIRST, WM_MOUSELAST, PM_NOREMOVE))
      {
          break;
      }

   }

}

VOID IterateHieghway(PointF *points, PointF *newpoints, int *iSize)
{
   int j = 0;
   REAL x1,x2,y1,y2;
   BOOL right = TRUE;
   
   for (int i = 0; i < (*iSize - 1); i++)
   {
       x1 = points[i].X;
       x2 = points[i+1].X;
       y1 = points[i].Y;
       y2 = points[i+1].Y;

      newpoints[j].X = x1;
      newpoints[j++].Y = y1;

       if (y1 == y2)
       {
          newpoints[j].X = (x2 + x1) / 2;
          if (x2 > x1)
              if (right)
                 newpoints[j++].Y = y1 + (x2-x1)/2;
              else
                 newpoints[j++].Y = y1 - (x2-x1)/2;
          else // if (x1 > x2)
              if (right)
                 newpoints[j++].Y = y1 - (x1-x2)/2;
              else
                 newpoints[j++].Y = y1 + (x1-x2)/2;
      }
      else if (x1 == x2)
      {
          newpoints[j].Y = (y2 + y1) / 2;
          if (y2 > y1)
              if (right)
                  newpoints[j++].X = x1 - (y2-y1)/2;
              else
                  newpoints[j++].X = x1 + (y2-y1)/2;
          else  // if (y1 > y2)
              if (right)
                  newpoints[j++].X = x1 + (y1-y2)/2;
              else
                  newpoints[j++].X = x1 - (y1-y2)/2;
      }
      else
      {
          if ((x1 > x2 && y1 > y2) ||
              (x2 > x1 && y2 > y1))
          {
              if (right)
              {
                  newpoints[j].X = x1;
                  newpoints[j++].Y = y2;
              }
              else
              {
                  newpoints[j].X = x2;
                  newpoints[j++].Y = y1;
              }
          }
          else // if ((x2 > x1 && y1 > y2) ||
               //     (x1 > x2 && y2 > y1))
          {
              if (right)
              {
                  newpoints[j].X = x2;
                  newpoints[j++].Y = y1;
              }
              else
              {
                  newpoints[j].X = x1;
                  newpoints[j++].Y = y2;
              }
          }
      }

      right = !right;
  }

  newpoints[j].X = x2;
  newpoints[j++].Y = y2;
  
  *iSize = j;
}

VOID DrawTree(HDC hDC, HWND hwnd, RECT rc, int iColor)
{
/*    PointF points[] = {PointF(50,100),
                       PointF(70,100),
                       PointF(68,70),
                       PointF(58,56),
                       PointF(80,47),
                       PointF(65,24),
                       PointF(58,27),
                       PointF(68,43),
                       PointF(47,52),
                       PointF(55,70),
                       PointF(50,100)};
    PointF  scale[] = {PointF((REAL)0.7, (REAL)0.7), 
                       PointF((REAL)0.7, (REAL)0.7), 
                       PointF((REAL)0.7, (REAL)0.7)};
    REAL    rotate[] = {-65, -10, 65};
    PointF  translate[] = {PointF(-100,2), PointF(20,-45), PointF(35,-167)};
*/
    PointF points[3][11] = {PointF(50,100),
                            PointF(65,100),
                            PointF(62,30),
                            PointF(53,30),
                            PointF(50,100),
                            PointF(0,0),
                            PointF(0,0),
                            PointF(0,0),
                            PointF(0,0),
                            PointF(0,0),
                            PointF(0,0),
                       
                            PointF(50,100),
                            PointF(70,100),
                            PointF(68,70),
                            PointF(58,56),
                            PointF(80,47),
                            PointF(65,24),
                            PointF(58,27),
                            PointF(68,43),
                            PointF(47,52),
                            PointF(55,70),
                            PointF(50,100),
    
                            PointF(0,100),
                            PointF(15,100),
                            PointF(12,30),
                            PointF(3,30),
                            PointF(0,100),
                            PointF(0,0),
                            PointF(0,0),
                            PointF(0,0),
                            PointF(0,0),
                            PointF(0,0),
                            PointF(0,0)};
    int     numPoints[3] = {5,11,5};
    int     numBranches[3] = {3,4,3};
    int     numLevels[3] = {7,7,9};
    PointF  scale[3][4] = {PointF((REAL)0.7, (REAL)0.7), 
                           PointF((REAL)0.7, (REAL)0.7), 
                           PointF((REAL)0.7, (REAL)0.7),
                           PointF(0,0),
                       
                           PointF((REAL)0.75, (REAL)0.75), 
                           PointF((REAL)0.6, (REAL)0.6), 
                           PointF((REAL)0.8, (REAL)0.8),
                           PointF((REAL)0.35, (REAL)0.35),
    
                           PointF((REAL)0.65, (REAL)0.65), 
                           PointF((REAL)0.6, (REAL)0.6), 
                           PointF((REAL)0.6, (REAL)0.6),
                           PointF(0,0)};
    REAL    rotate[3][4] = {1, -35, 27, 0,
                            -65, -10, 65, 20,
                            0, -55, 55, 0};
    PointF  translate[3][4] = {PointF(24,-50), 
                               PointF(-33,10), 
                               PointF(50,-67),
                               PointF(0,0),
                                
                               PointF(-100,2), 
                               PointF(25,-40), 
                               PointF(25,-160),
                               PointF(180,25),
    
                               PointF(4,-55), 
                               PointF(-95,-30), 
                               PointF(95,-50),
                               PointF(0,0)};
//fprintf(stream, "%f  %f  %f  %f \n", points[0][0].X, points[0][1].X, points[0][2].X, points[0][3].X);
    Graphics g(hDC);
    GraphicsPath path;
    REAL  rScale = (REAL)(rand() % (rc.bottom - rc.top)) / 350;
    if (rScale < 0.2)
        rScale = 0.2f;
    REAL xTrans = (REAL)(rand() % ((rc.right - rc.left) * 2/3)) + ((rc.right - rc.left) * 1/6);
    REAL yTrans = (REAL)(rand() % ((rc.bottom - rc.top) * 2/3)) + ((rc.bottom - rc.top) * 1/6);
    REAL rRotate = (REAL)(rand() % 360);
    int iTree = rand() % 3;

//fprintf(stream, " %6f  %6f  %6f  %6f\n", rScale, xTrans, yTrans, rRotate);

    path.AddPolygon(points[iTree],numPoints[iTree]);
    g.TranslateTransform(xTrans, yTrans);
    g.ScaleTransform(rScale, rScale);
    g.RotateTransform(rRotate);
    DrawBranch(hwnd, &g, &path,  rScale < 1 ? numLevels[iTree]-1 : numLevels[iTree], 
                scale[iTree], rotate[iTree], translate[iTree], numBranches[iTree], 
                iColor);
}

VOID DrawBranch(HWND hwnd, Graphics *g, GraphicsPath *path, int iLevel, 
              PointF *scale, REAL *rotate, PointF *translate, 
              int iBranches, int iColor)
{
    MSG   msg;

    if (iLevel == 0 ||
        (iLevel == 6 &&
         PeekMessage(&msg, hwnd, WM_KEYFIRST, WM_MOUSELAST, PM_NOREMOVE)))
    {
        return;
    }
        
    SolidBrush brush(Color(200, rand()%256,(255-iLevel*20)%256,(iColor*125)%200 + rand()%50));
    g->FillPath(&brush, path);

    for (int i = 0; i<iBranches; i++)
    {
        GraphicsState state = g->Save();

        g->ScaleTransform(scale[i].X, scale[i].Y);
        g->RotateTransform(rotate[i]);
        g->TranslateTransform(translate[i].X, translate[i].Y);

        DrawBranch(hwnd, g, path,iLevel-1,scale,rotate,translate,iBranches,iColor);

        g->Restore(state);
    }
}

VOID DrawJulia(HDC hDC, HWND hwnd, RECT rc, int iColor, BOOL fMandelbrot)
{
    Graphics g(hDC);
    REAL cx=(REAL)0.3,cy=(REAL)0.588888;
    REAL x0,y0=-1.25,xI,yI=1.25;
    REAL xCenter, yCenter, delta=(REAL)(0.2/pow(2.5,iColor));
    REAL scrnx=(REAL)(rc.right-rc.left), scrny=(REAL)(rc.bottom-rc.top);
    REAL nx=scrnx,ny=scrny;
    int niter=45+8*(iColor+1),i,ncolors=28;
    Bitmap bitmap((int)nx, (int)ny, PixelFormat32bppARGB);

    if (fMandelbrot)
    {
        xCenter=(REAL)-0.561;
        yCenter=(REAL)-0.6432;
        x0 = (REAL)-1.75;
        xI = (REAL)1.0;
    }
    else
    {
        x0 = (REAL)-1.25;
        xI = (REAL)1.25;
        xCenter=(REAL)-0.11014;
        yCenter=(REAL)-0.509;
    }
    if (iColor > 0)
    {
       x0=(REAL)(xCenter-delta); 
       xI=(REAL)(xCenter+delta);
       y0=(REAL)(yCenter-delta); 
        yI=(REAL)(yCenter+delta);
    }

//    bitmap.LockBits

/*    SolidBrush brushs[] =
        {SolidBrush(Color(255,128,0,0)),
         SolidBrush(Color(255,255,0,0)),
         SolidBrush(Color(255,0,128,0)),
         SolidBrush(Color(255,0,255,0)),
         SolidBrush(Color(255,0,0,128)),
         SolidBrush(Color(255,0,0,255)),
         SolidBrush(Color(255,128,128,0)),
         SolidBrush(Color(255,255,255,0)),
         SolidBrush(Color(255,0,128,128)),
         SolidBrush(Color(255,0,255,255)),
         SolidBrush(Color(255,128,0,128)),
         SolidBrush(Color(255,255,0,255))};
    SolidBrush brushs[] =
        {SolidBrush(Color(255,248,40,18)),
         SolidBrush(Color(255,245,117,21)),
         SolidBrush(Color(255,255,171,18)),
         SolidBrush(Color(255,246,235,20)),
         SolidBrush(Color(255,213,255,13)),
         SolidBrush(Color(255,93,253,13)),
         SolidBrush(Color(255,13,253,218)),
         SolidBrush(Color(255,14,190,252)),
         SolidBrush(Color(255,15,116,255)),
         SolidBrush(Color(255,15,15,255)),
         SolidBrush(Color(255,207,15,250)),
         SolidBrush(Color(255,255,80,245))};
    Color colors[] =
        {Color(255,248,40,18),
         Color(255,245,117,21),
         Color(255,255,171,18),
         Color(255,246,235,20),
         Color(255,213,255,13),
         Color(255,93,253,13),
         Color(255,13,253,218),
         Color(255,14,190,252),
         Color(255,15,116,255),
         Color(255,15,15,255),
         Color(255,207,15,250),
         Color(255,255,80,245)};
     Color colors[] =
        {Color(255,0,0,0),
         Color(255,0,0,180),
         Color(255,0,30,150),
         Color(255,0,60,120),
         Color(255,0,90,90),
         Color(255,0,120,60),
         Color(255,0,150,30),
         Color(255,0,180,0),
         Color(255,30,150,0),
         Color(255,60,120,0),
         Color(255,90,90,0),
         Color(255,120,60,0),
         Color(255,150,30,0),
         Color(255,180,0,0),
         Color(255,150,0,30),
         Color(255,120,0,60),
         Color(255,90,0,90),
         Color(255,60,0,120),
         Color(255,30,0,150)};
*/     Color colors[] =
        {Color(255,0,0,0),
         Color(255,0,0,180),
         Color(255,0,20,160),
         Color(255,0,40,140),
         Color(255,0,60,120),
         Color(255,0,80,100),
         Color(255,0,100,80),
         Color(255,0,120,60),
         Color(255,0,140,40),
         Color(255,0,160,20),
         Color(255,0,180,0),
         Color(255,20,160,0),
         Color(255,40,140,0),
         Color(255,60,120,0),
         Color(255,80,100,0),
         Color(255,100,80,0),
         Color(255,120,60,0),
         Color(255,140,40,0),
         Color(255,160,20,0),
         Color(255,180,0,0),
         Color(255,160,0,20),
         Color(255,140,0,40),
         Color(255,120,0,60),
         Color(255,100,0,80),
         Color(255,80,0,100),
         Color(255,60,0,120),
         Color(255,40,0,140),
         Color(255,20,0,160),
        };
/*    Color colors[] =
        {Color(255,0,0,0),
         Color(255,0,89,186),
         Color(255,0,155,186),
         Color(255,0,186,155),
         Color(255,0,186,27),
         Color(255,186,186,0),
         Color(255,186,155,0),
         Color(255,186,118,0),
         Color(255,186,60,0),
         Color(255,186,0,0),
         Color(255,186,0,186),
         Color(255,97,0,186),
         Color(255,0,4,186)};

    Color colors[2];
    colors[0]=Color(255,rand()%256,rand()%256,rand()%256);
*/
    REAL dx,dy,px,py,x,y;
    REAL xx,yy,xsquared,ysquared;

        dx=(xI-x0)/nx;
        dy=(yI-y0)/ny;
        
        for (py=0; py<ny; py++)
        {
            MSG msg;

            if ((int)py % 50 == 0 &&
                PeekMessage(&msg, hwnd, WM_KEYFIRST, WM_MOUSELAST, PM_NOREMOVE))
                return;

            for (px=0; px<nx; px++)
            {
                x=x0+(px*dx);
                y=y0+(py*dy);

                if (fMandelbrot)
                {
                     cx=x;
                     cy=y;
                     x=0;
                     y=0;
                }
            
                xsquared=0;
                ysquared=0;

                for(i=0; (i<niter)&&(xsquared+ysquared < 4); i++)
                {
                    xsquared= x*x;
                    ysquared= y*y;
                    xx=xsquared - ysquared + cx;
                    yy = x * y * 2 + cy;
                    x = xx;
                    y = yy;
                }

                if (i==niter) 
                    i = 0;
                else
                    i = (i % (ncolors-1)) + 1;

                bitmap.SetPixel((int)px, (int)py, colors[i]);

//            g->FillRectangle((Brush*)&(brushs[i]), (int)px,(int)py,(int)1,(int)1);

            }
        }

        g.DrawImage(&bitmap, 0,0);
}

//index must be in range 0...5f9 (length 5fa)

//#define PLASMA_INDEX_MOD 0x5fa
//#define PLASMA_INDEX_MOD 0x2fd
INT PLASMA_TYPE;
INT PLASMA_INDEX_MOD;
ARGB IndexToSpectrum(INT index)
{
    //index = (index + PLASMA_INDEX_MOD) % PLASMA_INDEX_MOD;

    if ((index < 0) || (index >= PLASMA_INDEX_MOD))
        DebugBreak();
    
    INT r,g,b;

    switch (PLASMA_TYPE)
    {
    case 0:

        r = max(0, min(0xff, (0x1fe - abs(0x2fd - ((index+0x2fd) % PLASMA_INDEX_MOD)))));
        g = max(0, min(0xff, (0x1fe - abs(0x2fd - ((index+0xff) % PLASMA_INDEX_MOD)))));
        b = max(0, min(0xff, (0x1fe - abs(0x2fd - ((index+0x4fb) % PLASMA_INDEX_MOD)))));

        if (!((r == 0xff) || (g == 0xff) || (b == 0xff)))
            DebugBreak();

        if ((r == 0xff) && (g == 0) && (b == 0) && (index != 0))
            DebugBreak();
        break;
    case 1:
        r = 0;
        g = 0;
        b = 0;

        if (index < 0xff)
        {
            r = 0xff - index;
            g = index;
        }
        else if (index < 0x1fe)
        {
            g = 0xff - (index - 0xff);
            b = index - 0xff;
        }
        else
        {
            b = 0xff - (index - 0x1fe);
            r = index - 0x1fe;
        }
        break;
    case 2:
        r = 0xff;
        b = 0xff;
        g = 0xff;

        if (index < 0xff)
        {
            r = index;
            g = 0xff - index;
        }
        else if (index < 0x1fe)
        {
            g = index - 0xff;
            b = 0xff - (index - 0xff);
        }
        else
        {
            b = index - 0x1fe;
            r = 0xff - (index - 0x1fe);
        }
        break;
    }
/*
    return (0xff000000    |
            (BYTE)r << 16 |
            (BYTE)g << 8  |
            (BYTE)b);
*/
    
    return (((rand() % 255) + 1) << 24    |
            (BYTE)r << 16 |
            (BYTE)g << 8  |
            (BYTE)b);

}

INT SpectrumToIndex(ARGB argb)
{

    BYTE r = (BYTE)((argb & 0x00ff0000) >> 16);
    BYTE g = (BYTE)((argb & 0x0000ff00) >> 8);
    BYTE b = (BYTE)(argb & 0x000000ff);

    switch(PLASMA_TYPE)
    {
    case 0:
        //Is red high?
        if (0xff == r)
        {
            //...and is blue present?
            if (b > 0)
            {
                return PLASMA_INDEX_MOD - b;
            }
            else
            {
                return g;
            }
        }
        //how 'bout green?
        if (0xff == g)
        {
            if (r > 0)
            {
                return 0x1fe - r;
            }
            else
            {
                return 0x1fe + b;
            }
        }
        //else blue
        if (0xff == b)
        {
            if (g > 0)
            {
                return 0x3fc - g;
            }
            else
            {
                return 0x3fc + r;
            }
        }

        //WTH?
        DebugBreak();

        break;
    case 1:

        if (r == 0xff)
        {
            return 0;
        }
        if (g != 0)
        {
            if (r > 0)
            {
                return g;
            }
            else
            {
                return 0xff + b;
            }
        }
        if (b != 0)
        {
            return 0x1fe + r;
        }
        break;
    case 2:
        if (b == 0xff)
        {
            return r;
        }
        if (r == 0xff)
        {
            return 0xff + g;
        }
        if (g == 0xff)
        {
            return 0x1fe + b;
        }
        break;
    }
    
    DebugBreak();
    return -1;
}

INT MakeColor(INT c1, INT c2, INT deltamax)
{
    INT c = ((c1 + c2) >> 1) + ((deltamax > 0) ? ((rand() % (2*deltamax)) - deltamax) : 0);

    if (c < 0)
        c = 0;

    if (c > (PLASMA_INDEX_MOD - 1))
        c = PLASMA_INDEX_MOD - 1;

    if ((c < 0) || (c > PLASMA_INDEX_MOD - 1))
        DebugBreak();

    return c;
}

INT MakeColor(INT c1, INT c2, INT c3, INT c4, INT deltamax)
{
    INT c = ((c1 + c2 + c3 + c4) >> 2) + ((deltamax > 0) ? ((rand() % (2*deltamax)) - deltamax) : 0);

    if (c < 0)
        c = 0;

    if (c > (PLASMA_INDEX_MOD - 1))
        c = PLASMA_INDEX_MOD - 1;


    if ((c < 0) || (c > PLASMA_INDEX_MOD - 1))
        DebugBreak();

    return c;
}

BYTE MakeAlpha(BYTE a1, BYTE a2, INT deltamax)
{
    deltamax = (deltamax * 0xff) / PLASMA_INDEX_MOD;

    BYTE a = (((int)a1 + (int)a2) >> 1) + ((deltamax > 0) ? ((rand() % (2*deltamax)) - deltamax) : 0);

    if (a < 1)
        a = 1;

    if (a > 0xff)
        a = 0xff;

    return a;
}

BYTE MakeAlpha(BYTE a1, BYTE a2, BYTE a3, BYTE a4, INT deltamax)
{
    deltamax = (deltamax * 0xff) / PLASMA_INDEX_MOD;

    BYTE a = (((int)a1 + (int)a2 + (int)a3 + (int)a4) >> 2) + ((deltamax > 0) ? ((rand() % (2*deltamax)) - deltamax) : 0);

    if (a < 1)
        a = 1;

    if (a > 0xff)
        a = 0xff;

    return a;
}

//Note that this only works on squares! You want something else? Scale the graphics.
//BOOL HalfPlasma(HWND& hwnd, Graphics& g,BitmapData &bmpd, INT x0, INT y0, INT x1, INT y1, const Color& c00, const Color& c10, const Color& c01, const Color& c11,REAL scale)
BOOL HalfPlasma(HWND& hwnd, Graphics& g,BitmapData &bmpd, INT x0, INT y0, INT x1, INT y1,REAL scale)
{
    MSG msg;

    // Drawing takes a long time, so check for queued message periodically
    if (PeekMessage(&msg, hwnd, WM_KEYFIRST, WM_MOUSELAST, PM_NOREMOVE))
        return FALSE;

    if (((x0 + 1) >= x1) &&
        ((y0 + 1) >= y1))
    {
        return TRUE;
    }

    INT c00 = SpectrumToIndex(*((ARGB*)((BYTE*)bmpd.Scan0 + y0*bmpd.Stride) + x0));
    INT c10 = SpectrumToIndex(*((ARGB*)((BYTE*)bmpd.Scan0 + y0*bmpd.Stride) + x1));
    INT c01 = SpectrumToIndex(*((ARGB*)((BYTE*)bmpd.Scan0 + y1*bmpd.Stride) + x0));
    INT c11 = SpectrumToIndex(*((ARGB*)((BYTE*)bmpd.Scan0 + y1*bmpd.Stride) + x1));
    INT ch0, c0h, c1h, ch1, chh;

    BYTE a00 = (BYTE)((*((ARGB*)((BYTE*)bmpd.Scan0 + y0*bmpd.Stride) + x0) & 0xff000000) >> 24);
    BYTE a10 = (BYTE)((*((ARGB*)((BYTE*)bmpd.Scan0 + y0*bmpd.Stride) + x1) & 0xff000000) >> 24);
    BYTE a01 = (BYTE)((*((ARGB*)((BYTE*)bmpd.Scan0 + y1*bmpd.Stride) + x0) & 0xff000000) >> 24);
    BYTE a11 = (BYTE)((*((ARGB*)((BYTE*)bmpd.Scan0 + y1*bmpd.Stride) + x1) & 0xff000000) >> 24);
    BYTE ah0, a0h, a1h, ah1, ahh;

    INT deltamax = (INT)((x1 - x0)/scale);
    INT half = (x1 + 1 - x0) >> 1;
    INT xh = x0 + half;
    INT yh = y0 + half;

    if (0 == (*((ARGB*)((BYTE*)bmpd.Scan0 + y0*bmpd.Stride) + xh) & 0xff000000))
    {
        ch0 = MakeColor(c00,c10,deltamax);
        ah0 = MakeAlpha(a00,a10,deltamax);
        *((ARGB*)((BYTE*)bmpd.Scan0 + y0*bmpd.Stride) + xh) = (IndexToSpectrum(ch0) & 0x00ffffff) | (ah0 << 24);
    }
    else
    {
        ch0 = SpectrumToIndex(*((ARGB*)((BYTE*)bmpd.Scan0 + y0*bmpd.Stride) + xh));
        ah0 = (BYTE)((*((ARGB*)((BYTE*)bmpd.Scan0 + y0*bmpd.Stride) + xh) & 0xff000000) >> 24);
    }

    if (0 == (*((ARGB*)((BYTE*)bmpd.Scan0 + yh*bmpd.Stride) + x0) & 0xff000000))
    {
        c0h = MakeColor(c00, c01, deltamax);
        a0h = MakeAlpha(a00, a01, deltamax);
        *((ARGB*)((BYTE*)bmpd.Scan0 + yh*bmpd.Stride) + x0) = (IndexToSpectrum(c0h) & 0x00ffffff) | (a0h << 24);
    }
    else
    {
        c0h = SpectrumToIndex(*((ARGB*)((BYTE*)bmpd.Scan0 + yh*bmpd.Stride) + x0));
        a0h = (BYTE)((*((ARGB*)((BYTE*)bmpd.Scan0 + yh*bmpd.Stride) + x0) & 0xff000000) >> 24);
    }

    if (0 == (*((ARGB*)((BYTE*)bmpd.Scan0 + yh*bmpd.Stride) + x1) & 0xff000000))
    {
        c1h = MakeColor(c10,c11,deltamax);
        a1h = MakeAlpha(a10,a11,deltamax);
        *((ARGB*)((BYTE*)bmpd.Scan0 + yh*bmpd.Stride) + x1) = (IndexToSpectrum(c1h) & 0x00ffffff) | (a1h << 24);
    }
    else
    {
        c1h = SpectrumToIndex(*((ARGB*)((BYTE*)bmpd.Scan0 + yh*bmpd.Stride) + x1));
        a1h = (BYTE)((*((ARGB*)((BYTE*)bmpd.Scan0 + yh*bmpd.Stride) + x1) & 0xff000000) >> 24);
    }

    if (0 == (*((ARGB*)((BYTE*)bmpd.Scan0 + y1*bmpd.Stride) + xh) & 0xff000000))
    {
        ch1 = MakeColor(c01,c11,deltamax);
        ah1 = MakeAlpha(a01,a11,deltamax);
        *((ARGB*)((BYTE*)bmpd.Scan0 + y1*bmpd.Stride) + xh) = (IndexToSpectrum(ch1) & 0x00ffffff) | (ah1 << 24);
    }
    else
    {
        ch1 = SpectrumToIndex(*((ARGB*)((BYTE*)bmpd.Scan0 + y1*bmpd.Stride) + xh));
        ah1 = (BYTE)((*((ARGB*)((BYTE*)bmpd.Scan0 + y1*bmpd.Stride) + xh) & 0xff000000) >> 24);
    }

    if (0 == (*((ARGB*)((BYTE*)bmpd.Scan0 + yh*bmpd.Stride) + xh) & 0xff000000))
    {
        chh = MakeColor(ch0,c0h,c1h,ch1,deltamax);
        ahh = MakeAlpha(ah0,a0h,a1h,ah1,deltamax);
        *((ARGB*)((BYTE*)bmpd.Scan0 + yh*bmpd.Stride) + xh) = (IndexToSpectrum(chh) & 0x00ffffff) | (ahh << 24);
    }

    if (!HalfPlasma(hwnd, g, bmpd,x0,y0,xh,yh,scale)) return FALSE;
    if (!HalfPlasma(hwnd, g, bmpd,xh,y0,x1,yh,scale)) return FALSE;
    if (!HalfPlasma(hwnd, g, bmpd,x0,yh,xh,y1,scale)) return FALSE;
    if (!HalfPlasma(hwnd, g, bmpd,xh,yh,x1,y1,scale)) return FALSE;

    return TRUE;
}

INT fx = 0;
INT fy = 0;

VOID DrawPlasma(HDC hDC, HWND hwnd, RECT rc, int iColor)
{
    Graphics g(hDC);
    INT x0,y0,x1,y1;
    REAL scale;
    BYTE alpha = 255;
    BOOL abort = FALSE;

    INT w = 1;
    INT size = min((rc.right - rc.left), (rc.bottom-rc.top));

    while(size > 0)
    {
        size >>= 1;
        w <<= 1;
    }

    if (rand() % 2)
    {
        w = min(w,1 << ((rand() % 5) + 4));
    }
    else
    {
        w = min(w,32);
    }


    Bitmap bmp(w,w,PixelFormat32bppARGB);
    Rect rect(0,0,w,w);
    BitmapData bmpd;
    bmp.LockBits(rect,0,PixelFormat32bppARGB,&bmpd);

    for (INT x = 0; x < w; x++)
    {
        for (INT y = 0; y < w; y++)
        {
            *((ARGB*)((BYTE*)bmpd.Scan0 + y*bmpd.Stride) + x) = Color::MakeARGB(0,0,0,0);
        }
    }

    x0 = 0;
    y0 = 0;
    x1 = x0 + w - 1;
    y1 = y0 + w - 1;

    switch(PLASMA_TYPE = (rand() % 3))
    {
    case 0:
        PLASMA_INDEX_MOD = 0x5fa;
        break;
    case 1:
    case 2:
        PLASMA_INDEX_MOD = 0x2fd;
        break;
    }

    scale = ((REAL)(w))/((REAL)PLASMA_INDEX_MOD);
    REAL sx = ((REAL)(rc.right-rc.left))/((REAL)(x1 - x0 + 1));
    REAL sy = ((REAL)(rc.bottom-rc.top))/((REAL)(y1 - y0 + 1));
            
    g.SetSmoothingMode(SmoothingModeAntiAlias);

    BYTE intMode = rand() % 3;

    switch(intMode)
    {
    case 2:
        g.SetInterpolationMode(InterpolationModeHighQualityBicubic);
        break;
    case 1:
        g.SetInterpolationMode(InterpolationModeHighQualityBilinear);
        break;
    case 0:
        g.SetInterpolationMode(InterpolationModeNearestNeighbor);
        break;
    }

    /*
    *((ARGB*)((BYTE*)bmpd.Scan0 + y0*bmpd.Stride) + x0) = IndexToSpectrum(rand() % PLASMA_INDEX_MOD) ;
    *((ARGB*)((BYTE*)bmpd.Scan0 + y0*bmpd.Stride) + x1) = IndexToSpectrum(rand() % PLASMA_INDEX_MOD);
    *((ARGB*)((BYTE*)bmpd.Scan0 + y1*bmpd.Stride) + x0) = IndexToSpectrum(rand() % PLASMA_INDEX_MOD);
    *((ARGB*)((BYTE*)bmpd.Scan0 + y1*bmpd.Stride) + x1) = IndexToSpectrum(rand() % PLASMA_INDEX_MOD);
*/

    *((ARGB*)((BYTE*)bmpd.Scan0 + y0*bmpd.Stride) + x0) = (IndexToSpectrum(rand() % PLASMA_INDEX_MOD) & 0x00ffffff) | ((rand() % 255) << 24);
    *((ARGB*)((BYTE*)bmpd.Scan0 + y0*bmpd.Stride) + x1) = (IndexToSpectrum(rand() % PLASMA_INDEX_MOD) & 0x00ffffff) | ((rand() % 255) << 24);;
    *((ARGB*)((BYTE*)bmpd.Scan0 + y1*bmpd.Stride) + x0) = (IndexToSpectrum(rand() % PLASMA_INDEX_MOD) & 0x00ffffff) | ((rand() % 255) << 24);;
    *((ARGB*)((BYTE*)bmpd.Scan0 + y1*bmpd.Stride) + x1) = (IndexToSpectrum(rand() % PLASMA_INDEX_MOD) & 0x00ffffff) | ((rand() % 255) << 24);;

    abort = !HalfPlasma(hwnd,g,bmpd,x0,y0,x1,y1,scale);

    bmp.UnlockBits(&bmpd);

    PointF points[3];

    if (!abort)
    {       

        // Get some good random points.  Limit angles to be > 20 degrees, so
        // there are no skinny rects
        for (int j = 0; j <= 20; j++)
        {
            for (int i = 0; i<= 2; i++)
            {
                points[i].X = (REAL)(rand() % (rc.right - rc.left));
                points[i].Y = (REAL)(rand() % (rc.bottom - rc.top));
            }

            double a,b,c,cosa,cosb,cosc;

            a = sqrt(pow(points[0].X - points[1].X, 2) + pow(points[0].Y - points[1].Y, 2));
            b = sqrt(pow(points[2].X - points[1].X, 2) + pow(points[2].Y - points[1].Y, 2));
            c = sqrt(pow(points[0].X - points[2].X, 2) + pow(points[0].Y - points[2].Y, 2));
            int iMinLen = (int)min(a,min(b,c));

            cosa = (pow(a,2) - pow(b,2) - pow(c,2)) / (-2 * b * c);
            cosb = (pow(b,2) - pow(a,2) - pow(c,2)) / (-2 * a * c);
            cosc = (pow(c,2) - pow(a,2) - pow(b,2)) / (-2 * a * b);
            if ((fabs(cosa) < 0.939) && 
                (fabs(cosb) < 0.939) && 
                (fabs(cosc) < 0.939) &&
                (a > 35))
            {
                break;
            }    
        }

        //g.DrawImage(&bmp,points,3); 
        INT halfKernel = intMode;
        g.DrawImage(&bmp, points, 3, (REAL)-halfKernel, (REAL)-halfKernel, 
                    (REAL)(w+halfKernel), (REAL)(w+halfKernel), UnitPixel, NULL, NULL, NULL); 
    }
}

VOID GetFractalConfig (DWORD *nType, DWORD *nSize)
{

        #define MYBUFFSIZE  32

        HKEY    hKey;
        HRESULT hr;
        DWORD   dwType;
        DWORD   dwBuffLen = sizeof(DWORD);
        
        hr = RegCreateKeyEx(HKEY_CURRENT_USER,
                            HKEY_PREFERENCES,
                            NULL,NULL, 
                            REG_OPTION_NON_VOLATILE, 
                            KEY_READ | KEY_WRITE,NULL,&hKey, NULL);
    
        if (ERROR_SUCCESS != hr)
        {
            *nSize = 4;
            *nType = 0;
            goto Done;
        }
    
        hr =  RegQueryValueEx(hKey, TEXT("FractalScnSvrType"),NULL,&dwType,
                              (LPBYTE)nType, &dwBuffLen);
    
        if (ERROR_SUCCESS != hr || dwType != REG_DWORD)
        {
            *nSize = 4;
            *nType = 0;
            goto Done;
        }

        dwBuffLen = MYBUFFSIZE;

        hr =  RegQueryValueEx(hKey, TEXT("FractalScnSvrNumber"),NULL,&dwType,
                              (LPBYTE)nSize, &dwBuffLen);
    
        if (ERROR_SUCCESS != hr || dwType != REG_DWORD)
        {
            *nSize = 4;
        }
Done:
        RegCloseKey(hKey);
    
}

VOID SetFractalConfig (DWORD nType, DWORD nSize)
{
        HKEY    hKey;
        HRESULT hr;
        DWORD   dwType = REG_DWORD;
        
        hr = RegCreateKeyEx(HKEY_CURRENT_USER,
                            HKEY_PREFERENCES,
                            NULL,NULL, 
                            REG_OPTION_NON_VOLATILE, 
                            KEY_READ | KEY_WRITE,NULL,&hKey, NULL);
    
        if (ERROR_SUCCESS != hr)
        {
            goto Done;
        }
    
        hr =  RegSetValueEx(hKey, TEXT("FractalScnSvrType"),NULL,dwType,
                              (LPBYTE)&nType, sizeof(DWORD));
    
        if (ERROR_SUCCESS != hr || dwType != REG_DWORD)
        {
            goto Done;
        }

        hr =  RegSetValueEx(hKey, TEXT("FractalScnSvrNumber"),NULL,dwType,
                              (LPBYTE)&nSize, sizeof(DWORD));
    
Done:
        RegCloseKey(hKey);
    

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\frametest\frametest.cpp ===
//
// Sample code for using GDI+
//
// Revision History:
//
//   10/01/1999 Min Liu (minliu)
//       Created it.
//

#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <windows.h>
#include <commctrl.h>
#include <objbase.h>
#include <commdlg.h>

#include <initguid.h>
#include "imaging.h"
#include <gdiplus.h>
#include <gdiplusflat.h>
#include "frametest.h"

using namespace Gdiplus;

#include "../gpinit.inc"

#define MYWNDCLASSNAME      "FrameTest"
#define K_DEFAULT_X         0
#define K_DEFAULT_Y         0
#define K_DEFAULT_WIDTH     300
#define K_DEFAULT_HEIGHT    300
#define MAX_FILENAME_LENGTH 1024
#define K_DEFAULT_DELAY     20

CHAR*               g_pcAppName;            // Application name
HINSTANCE           g_hAppInstance;         // Handle of the app instance
CHAR                g_acImageName[MAX_PATH];// Current image filename
INT                 g_iCurrentPageIndex;    // Current page/frame index (0 base)
UINT                g_uiTotalPages = 0;     // Total pages in current image
HWND                g_hwndMain;             // Handle to app's main window
HWND                g_hwndStatus;           // Handle to status window
HWND                g_hwndDecoderDlg;       // Handle to set color key dialog
HWND                g_hwndColorMapDlg;      // Handle to set color map dialog
HWND                g_hwndAnnotationDlg;    // Handle to annotation dialog
HWND                g_hwndJpegSaveDlg;      // Handle to JPEG save dialog
HWND                g_hwndTiffSaveDlg;      // Handle to TIFF save dialog
EncoderParameters*  g_pEncoderParams = NULL;// Encoder parameters

//
// User preferred window size and initial position
//
INT                 g_iWinWidth = K_DEFAULT_WIDTH;
INT                 g_iWinHeight = K_DEFAULT_HEIGHT;
INT                 g_iWinX = K_DEFAULT_X;
INT                 g_iWinY = K_DEFAULT_Y;

//
// Image info
//
UINT                g_ImageWidth;           // Image width
UINT                g_ImageHeight;          // Image height
UINT                g_ImageFlags;           // Image flag
PixelFormat         g_ImagePixelFormat;     // Image pixel format
double              g_ImageXDpi;            // DPI info in X
double              g_ImageYDpi;            // DPI info in Y
GUID                g_ImageRawDataFormat;   // RAW data format

UINT                g_uiDelay = K_DEFAULT_DELAY;
                                            // Delay between frames for anima.
Image*              g_pImage = NULL;        // Pointer to current Image object
ImageAttributes*    g_pDrawAttrib = NULL;   // Pointer to draw attributes
PointF*             g_pDestPoints = NULL;   // Transformation points
INT                 g_DestPointCount = 0;   // number of transformation points
REAL                g_SourceX = NULL;       // current image X offset
REAL                g_SourceY = NULL;       // current image Y offset
REAL                g_SourceWidth = NULL;   // current image width
REAL                g_SourceHeight = NULL;  // current image height
BOOL                g_LoadImageWithICM = TRUE;
                                            // Flag for loading image with ICM
                                            // convertion or not
BOOL                g_bRotated = FALSE;

REAL                g_dScale = 1;

BOOL                g_fFitToWindow_w = FALSE;
BOOL                g_fFitToWindow_h = FALSE;
InterpolationMode   g_InterpolationMode = InterpolationModeHighQualityBicubic;
WrapMode            g_WrapMode = WrapModeTileFlipXY;

void
ValidateArguments(int   argc,
                  char* argv[])
{
    g_pcAppName = *argv++;
    argc--;

    while ( argc > 0 )
    {
        if ( strcmp(*argv, "-w") == 0 )
        {
            argc--;
            argv++;

            if ( argc == 0 )
            {
                // Not enough parameters

                USAGE();
                exit(1);
            }
            
            g_iWinWidth = atoi(*argv++);
            argc--;
        }
        else if ( strcmp(*argv, "-h") == 0 )
        {
            argc--;
            argv++;

            if ( argc == 0 )
            {
                // Not enough parameters

                USAGE();
                exit(1);
            }
            
            g_iWinHeight = atoi(*argv++);
            argc--;
        }
        else if ( strcmp(*argv, "-x") == 0 )
        {
            argc--;
            argv++;

            if ( argc == 0 )
            {
                // Not enough parameters

                USAGE();
                exit(1);
            }
            
            g_iWinX = atoi(*argv++);
            argc--;
        }
        else if ( strcmp(*argv, "-y") == 0 )
        {
            argc--;
            argv++;

            if ( argc == 0 )
            {
                // Not enough parameters

                USAGE();
                exit(1);
            }
            
            g_iWinY = atoi(*argv++);
            argc--;
        }
        else if ( strcmp(*argv, "-?") == 0 )
        {
            USAGE();
            exit(1);
        }
        else
        {
            // Get the image name

            strcpy(g_acImageName, *argv++);
            VERBOSE(("Image file name %s\n",g_acImageName));
            argc--;
        }
    }// while ( argc > 0 )
}// ValidateArguments()

// Update image info

BOOL
UpdateImageInfo()
{
    SizeF sizeF;

    g_ImageWidth = g_pImage->GetWidth();
    g_ImageHeight = g_pImage->GetHeight();
    g_ImageXDpi = g_pImage->GetVerticalResolution();
    g_ImageYDpi = g_pImage->GetHorizontalResolution();    
    g_ImagePixelFormat = g_pImage->GetPixelFormat();
    g_ImageFlags = g_pImage->GetFlags();
    g_pImage->GetRawFormat(&g_ImageRawDataFormat);

    return TRUE;
}// UpdateImageInfo()

//
// Force a refresh of the image window
//
inline VOID
RefreshImageDisplay()
{
    SendMessage(g_hwndMain, WM_ERASEBKGND, WPARAM(GetDC(g_hwndMain)), NULL);

    InvalidateRect(g_hwndMain, NULL, FALSE);

    // Update window title

    CHAR    title[2 * MAX_PATH];
    CHAR*   p = title;

    CHAR myChar = '%';
    sprintf(p, "(%d%c) Page %d of image %s", (INT)(g_dScale * 100), myChar,
            g_iCurrentPageIndex + 1, g_acImageName);

    SetWindowText(g_hwndMain, title);
}// RefreshImageDisplay()

inline void
ResetImageAttribute()
{
    if ( g_pDrawAttrib != NULL )
    {
        delete g_pDrawAttrib;
        g_pDrawAttrib = NULL;
    }

    g_pDrawAttrib = new ImageAttributes();

    g_pDrawAttrib->SetWrapMode(g_WrapMode, Color(0), FALSE);
}// ResetImageAttribute()

//
// Sets up the current page for decompressing in a multi-page image
//
VOID
SetCurrentPage()
{
    // QueryFrame dimension info

    UINT    uiDimCount = g_pImage->GetFrameDimensionsCount();

    GUID*   pMyGuid = (GUID*)malloc(uiDimCount * sizeof(GUID));
    if ( pMyGuid == NULL )
    {
        return;
    }

    Status rCode = g_pImage->GetFrameDimensionsList(pMyGuid, uiDimCount);

    if ( (rCode != Ok) && (rCode != NotImplemented) )
    {
        return;
    }
    // Set current frame

    rCode = g_pImage->SelectActiveFrame(pMyGuid, g_iCurrentPageIndex);

    if ( (rCode != Ok) && (rCode != NotImplemented) )
    {
        VERBOSE(("SelectActiveFrame() failed\n"));
        free(pMyGuid);
        return;
    }

    free(pMyGuid);

    // Get image info for current frame

    if ( UpdateImageInfo() == FALSE )
    {
        VERBOSE(("UpdateImageInfo() failed\n"));
        return;
    }

    // Check if we need to set 'Fit window width"
    // We will do a fit to window iff the "Scale factor is not set" and "Image
    // is bigger than current window"

    HMENU hMenu = GetMenu(g_hwndMain);

    if ( ((INT)g_ImageWidth > g_iWinWidth)
       ||((INT)g_ImageHeight > g_iWinHeight) )
    {
        g_fFitToWindow_w = TRUE;
        g_dScale = (REAL)g_iWinWidth / g_ImageWidth;
        
        CheckMenuItem(hMenu, IDM_VIEW_ZOOM_FITWINDOW_W,
                      MF_BYCOMMAND | MF_CHECKED);
    }
    else
    {
        g_dScale = 1;
        g_fFitToWindow_w = FALSE;
        g_fFitToWindow_h = FALSE;
        CheckMenuItem(hMenu, IDM_VIEW_ZOOM_FITWINDOW_W,
                      MF_BYCOMMAND | MF_UNCHECKED);
        CheckMenuItem(hMenu, IDM_VIEW_ZOOM_FITWINDOW_H,
                      MF_BYCOMMAND | MF_UNCHECKED);
    }

    RefreshImageDisplay();
}// SetCurrentPage()

//
// Create an image object from a file
//
BOOL
OpenImageFile(
    const CHAR* filename
    )
{
    if ( (NULL == filename) || (strlen(filename) < 1) )
    {
        return FALSE;
    }

    // We need to free the previous image resource and clean the draw attrib

    if ( g_pImage != NULL )
    {
        delete g_pImage;
    }

    ResetImageAttribute();

    if ( g_pDestPoints != NULL )
    {
        delete g_pDestPoints;
        g_pDestPoints = NULL;
    }

    // Convert filename to a WCHAR

    WCHAR namestr[MAX_FILENAME_LENGTH];

    if ( !AnsiToUnicodeStr(filename, namestr, MAX_FILENAME_LENGTH) )
    {
        VERBOSE(("OpenImageFile:Convert %s to a WCHAR failed\n", filename));
        return FALSE;
    }

    if ( g_LoadImageWithICM == TRUE )
    {
        g_pImage = new Image(namestr, g_LoadImageWithICM);
    }
    else
    {
        g_pImage = new Image(namestr);
    }

    UINT    uiDimCount = g_pImage->GetFrameDimensionsCount();

    GUID*   pMyGuid = (GUID*)malloc(uiDimCount * sizeof(GUID));
    if ( pMyGuid == NULL )
    {
        return FALSE;
    }

    Status rCode = g_pImage->GetFrameDimensionsList(pMyGuid, uiDimCount);

    if ( (rCode != Ok) && (rCode != NotImplemented) )
    {
        return FALSE;
    }
    
    // Get total number of pages in this image
    // !!!Todo need a for() loop here

    g_uiTotalPages = g_pImage->GetFrameCount(pMyGuid);
    if ( g_uiTotalPages == 0 )
    {
        // If the decoder doesn't support frame count query, we can just
        // assume it has only 1 image. For example, gif decoder will fail
        // if the query GUID is FRAMEDIM_PAGE

        g_uiTotalPages = 1;
    }
    g_iCurrentPageIndex = 0;

    if ( pMyGuid != NULL )
    {
        free(pMyGuid);
    }

    SetCurrentPage();

    return TRUE;
}// OpenImageFile()

//
// Open image file
//
VOID
DoOpen(
    HWND hwnd
    )
{
    OPENFILENAME    ofn;

    ZeroMemory(&ofn, sizeof(ofn));

    ofn.lStructSize = sizeof(ofn);
    ofn.hwndOwner = hwnd;
    ofn.hInstance = g_hAppInstance;
    ofn.lpstrFile = g_acImageName;
    ofn.nMaxFile = MAX_PATH;
    ofn.lpstrTitle = "Open Image File";
    ofn.lpstrInitialDir = ".";
    ofn.Flags = OFN_FILEMUSTEXIST;
    g_acImageName[0] = '\0';

    // Make up the file type filter string

    ImageCodecInfo* codecs;
    UINT            count;
    if ( g_pDestPoints != NULL )
    {
        free(g_pDestPoints);
    }
    g_DestPointCount = 0;
    GpStatus status;
    UINT cbCodecs = 0;
    GetImageDecodersSize(&count, &cbCodecs);
    codecs = static_cast<ImageCodecInfo *>(malloc (cbCodecs));
    if (codecs == NULL)
    {
        return;
    }
    status = GetImageDecoders(count, cbCodecs, codecs);
    if (status != Ok)
    {
        return;
    }

    CHAR* filter = MakeFilterFromCodecs(count, codecs, TRUE);

    if (codecs)
    {
        free(codecs);
    }

    if ( !filter )
    {
        VERBOSE(("DoOpen--MakeFilterFromCodecs() failed\n"));
        return;
    }

    ofn.lpstrFilter = filter;

    // Present the file/open dialog

    if ( GetOpenFileName(&ofn) )
    {
        OpenImageFile(g_acImageName);
    }

    free(filter);
}// DoOpen()

//
// Open image file
//
VOID
DoOpenAudioFile(
    HWND hwnd
    )
{
    OPENFILENAME    ofn;
    char    audioFileName[256];

    ZeroMemory(&ofn, sizeof(ofn));

    ofn.lStructSize = sizeof(ofn);
    ofn.hwndOwner = hwnd;
    ofn.hInstance = g_hAppInstance;
    ofn.lpstrFile = audioFileName;
    ofn.nMaxFile = MAX_PATH;
    ofn.lpstrTitle = "Attach Audio File To Image";
    ofn.lpstrInitialDir = ".";
    ofn.Flags = OFN_FILEMUSTEXIST;
    g_acImageName[0] = '\0';

    // Make up the file type filter string

    ofn.lpstrFilter = ".wav";

    // Present the file/open dialog

    if ( GetOpenFileName(&ofn) )
    {
        UINT    uiTextLength = strlen(audioFileName);
        
        PropertyItem myItem;
        myItem.id = PropertyTagExifRelatedWav;
        myItem.length = uiTextLength;
        myItem.type = TAG_TYPE_ASCII;

        myItem.value = malloc(uiTextLength);
        if ( myItem.value != NULL )
        {
            strcpy((char*)myItem.value, audioFileName);
        
            Status rCode = g_pImage->SetPropertyItem(&myItem);
            if ( (rCode != Ok) && (rCode != NotImplemented) )
            {
                VERBOSE(("SetPropertyItem() failed\n"));
            }
        }
    }
}// DoOpenAudioFile()

#define STEPS 100

VOID
CreateBackgroundBitmap()
{
    BitmapData bmpData;

    Bitmap* myBmp = new Bitmap(g_iWinWidth, g_iWinHeight, PIXFMT_32BPP_ARGB);

    Rect rect(0, 0, g_iWinWidth, g_iWinHeight);
    Status status = myBmp->LockBits(&rect,
                                    ImageLockModeWrite,
                                    PIXFMT_32BPP_ARGB,
                                    &bmpData);

    // Make a horizontal blue gradient

    UINT x, y;
    ARGB colors[STEPS];

    for (x=0; x < STEPS; x++)
    {
        colors[x] = MAKEARGB(128, 0, 0, x * 255 / (STEPS-1));
    }

    for (y=0; y < STEPS; y++)
    {
        ARGB* p = (ARGB*)((BYTE*)bmpData.Scan0 + y * bmpData.Stride);

        for (x=0; x < STEPS; x++)
        {
            *p++ = colors[(x+y) % STEPS];
        }
    }

    status = myBmp->UnlockBits(&bmpData);

    if ( g_pImage != NULL )
    {
        delete g_pImage;
        g_pImage = NULL;
    }

    g_pImage = myBmp;

    UpdateImageInfo();

    return;
}// CreateBackgroundBitmap()

//
// Handle window repaint event
//
VOID
DoPaint(
    HWND hwnd,
    HDC *phdc = NULL
    )
{
    if ( g_pImage == NULL )
    {
        return;
    }
    else
    {
        HDC         hdc;
        PAINTSTRUCT ps;
        RECT        rect;
        ImageInfo   imageInfo;

        if (!phdc)
        {
            hdc = BeginPaint(hwnd, &ps);
        }
        else
        {
            hdc = *phdc;
        }

        // Get current window's client area. Used for paint later

        GetClientRect(hwnd, &rect);

        ULONG   ulWinWidth = (ULONG)(rect.right - rect.left);
        ULONG   ulWinHeight = (ULONG)(rect.bottom - rect.top);

        // Make up a dest rect that we need image to draw to

        REAL    dDestImageWidth = g_ImageWidth * g_dScale;
        REAL    dDestImageHeight = g_ImageHeight * g_dScale;
        
        Rect    dstRect(rect.left, rect.top, (UINT)(dDestImageWidth),
                        (UINT)(dDestImageHeight));

        RectF srcRect;
        Unit  srcUnit;

        g_pImage->GetBounds(&srcRect, &srcUnit);

        Graphics* pGraphics = new Graphics(hdc);
        if ( pGraphics == NULL )
        {
            VERBOSE(("DoPaint--new Graphics() failed"));
            return;
        }

        pGraphics->SetInterpolationMode(g_InterpolationMode);

        // Width and height, in pixel, of the src image need to be drawn

        UINT    uiImageWidth = g_ImageWidth;
        UINT    uiImageHeight = g_ImageHeight;

        // Adjust the src image region need to be drawn.
        // If the image is bigger than the viewable area, we just need to
        // paint partial image, the viewable size
#if 0
        if ( ulWinWidth < dDestImageWidth )
        {
            uiImageWidth = (UINT)(ulWinWidth / g_dScale);
        }

        if ( ulWinHeight < uiImageHeight )
        {
            uiImageHeight = (UINT)(ulWinHeight / g_dScale);
        }
#endif

        if ( (g_DestPointCount == 0) && (g_SourceWidth == 0) )
        {
            // Simple case, draw to destRect

            pGraphics->DrawImage(g_pImage,
                                 dstRect,
                                 (UINT)srcRect.GetLeft(),
                                 (UINT)srcRect.GetTop(),
                                 uiImageWidth,
                                 uiImageHeight,
                                 UnitPixel,
                                 g_pDrawAttrib,
                                 NULL,
                                 NULL);
        }
        else if ( (g_DestPointCount == 0) && (g_SourceWidth != 0) )
        {
            // This case will allow cropping, etc.

            pGraphics->DrawImage(g_pImage,
                                 dstRect,
                                 (int)g_SourceX,
                                 (int)g_SourceY,
                                 (int)g_SourceWidth,
                                 (int)g_SourceHeight,
                                 UnitPixel,
                                 g_pDrawAttrib,
                                 NULL,
                                 NULL);
        }
        else if ( (g_DestPointCount != 0) && (g_SourceWidth == 0) )
        {
            // This case will allow cropping, etc.

            if ( g_DestPointCount == 4 )
            {
                // Hack until draw image support 4 transform points

                pGraphics->DrawImage(g_pImage,
                                     g_pDestPoints,
                                     3,
                                     0,
                                     0,
                                     (float)uiImageWidth,
                                     (float)uiImageHeight,
                                     UnitPixel,
                                     g_pDrawAttrib,
                                     NULL,
                                     NULL);
            }
            else
            {
                pGraphics->DrawImage(g_pImage,
                                     g_pDestPoints,
                                     g_DestPointCount,
                                     0,
                                     0,
                                     (float)uiImageWidth,
                                     (float)uiImageHeight,
                                     UnitPixel,
                                     g_pDrawAttrib,
                                     NULL,
                                     NULL);
            }
        }
        else
        {
            // This case will allow both cropping and rotation

            if ( g_DestPointCount == 4 )
            {
                // Hack until DrawImage supports 4 transform points

                pGraphics->DrawImage(g_pImage,
                                     g_pDestPoints,
                                     3,
                                     g_SourceX,
                                     g_SourceY,
                                     g_SourceWidth,
                                     g_SourceHeight,
                                     UnitPixel,
                                     g_pDrawAttrib,
                                     NULL,
                                     NULL);
            }
            else
            {
                pGraphics->DrawImage(g_pImage,
                                     g_pDestPoints,
                                     g_DestPointCount,
                                     g_SourceX,
                                     g_SourceY,
                                     g_SourceWidth,
                                     g_SourceHeight,
                                     UnitPixel,
                                     g_pDrawAttrib,
                                     NULL,
                                     NULL);
            }
        }

        delete pGraphics;

//        FillRect(hdc, &rect, (HBRUSH)GetStockObject(BLACK_BRUSH));

        if (!phdc)
            EndPaint(hwnd, &ps);
    }
}// DoPaint()

VOID
DoPrint(HWND hwnd)
{
    PRINTDLG printdlg;
    memset(&printdlg, 0, sizeof(PRINTDLG));
    printdlg.lStructSize = sizeof(PRINTDLG);
    printdlg.hwndOwner = hwnd;
    DEVMODE dm;
    memset(&dm, 0, sizeof(DEVMODE));
    dm.dmICMMethod = DMICMMETHOD_SYSTEM;
    printdlg.hDevMode = &dm;
    printdlg.hDevNames = NULL;
    printdlg.hDC = NULL;
    printdlg.Flags = PD_RETURNDC;
    if (PrintDlg(&printdlg))
    {        
        DOCINFO di;
        memset(&di, 0, sizeof(DOCINFO));
        di.cbSize = sizeof(DOCINFO);
        di.lpszDocName = g_acImageName;
        di.lpszOutput = (LPTSTR)NULL;
        di.lpszDatatype = (LPTSTR)NULL;
        di.fwType = 0;
        StartDoc(printdlg.hDC, &di);
        StartPage(printdlg.hDC);

        // Use GDI+ printing code to do the real print job

        DoPaint(hwnd, &printdlg.hDC);
        
        EndPage(printdlg.hDC);
        EndDoc(printdlg.hDC);
    }
    else
    {
        DWORD error = CommDlgExtendedError();
        if (error)
        {
            char errormessage[100];
            sprintf(errormessage, "PrintDlg error: %d", error);
            MessageBox(hwnd, errormessage, "PrintDlg error", MB_OK);
        }
    }
}// DoPrint()

BOOL
SetJpegDefaultParameters()
{
    // Set default quality level as 100, unsigned value

    SetDlgItemInt(g_hwndJpegSaveDlg, IDC_SAVEJPEG_QEFIELD, 100, FALSE);
    
    // Set No transform as default

    CheckRadioButton(g_hwndJpegSaveDlg,
                     IDC_SAVEJPEG_R90,
                     IDC_SAVEJPEG_NOTRANSFORM,
                     IDC_SAVEJPEG_NOTRANSFORM);
    
    return TRUE;
}// SetJpegDefaultParameters()

BOOL
SetTiffDefaultParameters()
{
    // Set default color depth and compression method as the same as current
    // image

    CheckRadioButton(g_hwndTiffSaveDlg,
                     IDC_SAVETIFF_1BPP,
                     IDC_SAVETIFF_ASSOURCE,
                     IDC_SAVETIFF_ASSOURCE);
    
    CheckRadioButton(g_hwndTiffSaveDlg,
                     IDC_SAVETIFF_CCITT4,
                     IDC_SAVETIFF_COMPASSOURCE,
                     IDC_SAVETIFF_COMPASSOURCE);

    // If the source image is multi-frame, check "save as multi-frame" on

    if ( g_uiTotalPages > 1 )
    {
        SendDlgItemMessage(g_hwndTiffSaveDlg, IDC_SAVETIFF_MULTIFRAME,
                           BM_SETCHECK, 0, 0);
    }
    
    return TRUE;
}// SetTiffDefaultParameters()

/*****************************************************************************\
*
*  FUNCTION   : DecoderParamDlgProc(hDlg, uiMessage, wParam, lParam)
*
*  PURPOSE    : Dialog function for the Decoder Parameter settings dialog
*
\*****************************************************************************/
INT_PTR CALLBACK
DecoderParamDlgProc(
    HWND         hDlg,
    UINT         uiMessage,
    WPARAM       wParam,
    LPARAM       lParam
    )
{
    switch ( uiMessage )
    {
    case WM_COMMAND:
        switch ( LOWORD(wParam) )
        {
        case IDC_COLORKEY_CANCEL:
            // End the dialog and return FALSE. So we won't do anything

            EndDialog(hDlg, FALSE);

            break;

        case IDC_COLORKEY_OK:
            // User hit the OK button. First, we need to get the values user
            // entered

            char    acTemp[20];
            UINT    uiTempLow;
            UINT    uiTempHigh;

            UINT    TransKeyLow = 0x0;
            UINT    TransKeyHigh = 0x0;

            // Get the RED key

            uiTempLow = GetDlgItemInt(g_hwndDecoderDlg, IDC_TRANS_LOWER_RFIELD,
                                      NULL, FALSE);
            uiTempHigh = GetDlgItemInt(g_hwndDecoderDlg,
                                       IDC_TRANS_HIGHER_RFIELD, NULL, FALSE);

            if ( (uiTempLow > 255) || (uiTempHigh > 255)
               ||(uiTempLow > uiTempHigh) )
            {
                VERBOSE(("Input key value should be within 0 to 255"));
                VERBOSE(("Lower key should be smaller or equal to higher key"));
                
                break;
            }

            TransKeyLow = ((uiTempLow & 0xff) << 16);
            TransKeyHigh = ((uiTempHigh & 0xff) << 16);

            // Get the Green key

            uiTempLow = GetDlgItemInt(g_hwndDecoderDlg, IDC_TRANS_LOWER_GFIELD,
                                      NULL, FALSE);
            uiTempHigh = GetDlgItemInt(g_hwndDecoderDlg,
                                       IDC_TRANS_HIGHER_GFIELD, NULL, FALSE);

            if ( (uiTempLow > 255)
               ||(uiTempHigh > 255)
               ||(uiTempLow > uiTempHigh) )
            {
                VERBOSE(("Input key value should be within 0 to 255"));
                VERBOSE(("Lower key should be smaller or equal to higher key"));
                
                break;
            }

            TransKeyLow |= ((uiTempLow & 0xff) << 8);
            TransKeyHigh |= ((uiTempHigh & 0xff) << 8);
            
            // Get the Blue key

            uiTempLow = GetDlgItemInt(g_hwndDecoderDlg, IDC_TRANS_LOWER_BFIELD,
                                      NULL, FALSE);
            uiTempHigh = GetDlgItemInt(g_hwndDecoderDlg,
                                       IDC_TRANS_HIGHER_BFIELD, NULL, FALSE);

            if ( (uiTempLow > 255)
               ||(uiTempHigh > 255)
               ||(uiTempLow > uiTempHigh) )
            {
                VERBOSE(("Input key value should be within 0 to 255"));
                VERBOSE(("Lower key should be smaller or equal to higher key"));
                
                break;
            }

            TransKeyLow |= (uiTempLow & 0xff);
            TransKeyHigh |= (uiTempHigh & 0xff);
            
            // Get the C key

            uiTempLow = GetDlgItemInt(g_hwndDecoderDlg, IDC_TRANS_LOWER_CFIELD,
                                      NULL, FALSE);
            uiTempHigh = GetDlgItemInt(g_hwndDecoderDlg,
                                       IDC_TRANS_HIGHER_CFIELD, NULL, FALSE);

            if ( (uiTempLow > 255)
               ||(uiTempHigh > 255)
               ||(uiTempLow > uiTempHigh) )
            {
                VERBOSE(("Input key value should be within 0 to 255"));
                VERBOSE(("Lower key should be smaller or equal to higher key"));
                
                break;
            }

            TransKeyLow |= ((uiTempLow & 0xff) << 24);
            TransKeyHigh |= ((uiTempHigh & 0xff) << 24);
            
            // Up to this point, the TRANSKEY, lower and higher, should be in
            // the format of 0x00RRGGBB for RGB image or 0xCCMMYYKK for CMYK
            // image
            
            // Set draw attributes

            if ( g_pDrawAttrib != NULL )
            {
                delete g_pDrawAttrib;
            }

            g_pDrawAttrib = new ImageAttributes();
                
            Color   lowKey(TransKeyLow);
            Color   highKey(TransKeyHigh);
                    
            g_pDrawAttrib->SetColorKey(lowKey, highKey);

            RefreshImageDisplay();

            EndDialog(hDlg, TRUE);
            
            break;
        }// switch on WM_COMMAND

        break;

    case WM_INITDIALOG:
        // Remember the dialog handle so that we can use it to deal with items
        // in this dialog

        g_hwndDecoderDlg = hDlg;

        // Set initial values

        SetDlgItemInt(g_hwndDecoderDlg, IDC_TRANS_LOWER_RFIELD, 250, FALSE);
        SetDlgItemInt(g_hwndDecoderDlg, IDC_TRANS_LOWER_GFIELD, 250, FALSE);
        SetDlgItemInt(g_hwndDecoderDlg, IDC_TRANS_LOWER_BFIELD, 250, FALSE);
        SetDlgItemInt(g_hwndDecoderDlg, IDC_TRANS_LOWER_CFIELD, 250, FALSE);
        SetDlgItemInt(g_hwndDecoderDlg, IDC_TRANS_HIGHER_RFIELD, 255, FALSE);
        SetDlgItemInt(g_hwndDecoderDlg, IDC_TRANS_HIGHER_GFIELD, 255, FALSE);
        SetDlgItemInt(g_hwndDecoderDlg, IDC_TRANS_HIGHER_BFIELD, 255, FALSE);
        SetDlgItemInt(g_hwndDecoderDlg, IDC_TRANS_HIGHER_CFIELD, 255, FALSE);

        return TRUE;
    }

    return FALSE;
}// DecoderParamDlgProc()

INT_PTR CALLBACK
ColorMapDlgProc(
    HWND         hDlg,
    UINT         uiMessage,
    WPARAM       wParam,
    LPARAM       lParam
    )
{
    switch ( uiMessage )
    {
    case WM_COMMAND:
        switch ( LOWORD(wParam) )
        {
        case IDC_COLORMAP_CANCEL:
            // End the dialog and return FALSE. So we won't do anything

            EndDialog(hDlg, FALSE);

            break;

        case IDC_COLORMAP_OK:
            // User hit the OK button. First, we need to get the values user
            // entered
            
            if ( NULL == g_pImage )
            {
                // If there is no image, just close the dialog

                EndDialog(hDlg, TRUE);

                break;
            }

            char    acTemp[20];
            UINT    uiOldR;
            UINT    uiNewR;
            UINT    uiOldG;
            UINT    uiNewG;
            UINT    uiOldB;
            UINT    uiNewB;
            UINT    uiOldA;
            UINT    uiNewA;

            // Get the RED key

            uiOldR = GetDlgItemInt(g_hwndColorMapDlg, IDC_MAP_OLD_RFIELD,
                                   NULL, FALSE);
            uiNewR = GetDlgItemInt(g_hwndColorMapDlg,
                                   IDC_MAP_NEW_RFIELD, NULL, FALSE);

            if ( (uiOldR > 255) || (uiNewR > 255) )
            {
                VERBOSE(("Input key value should be within 0 to 255"));                
                break;
            }

            // Get the Green key

            uiOldG = GetDlgItemInt(g_hwndColorMapDlg, IDC_MAP_OLD_GFIELD,
                                   NULL, FALSE);
            uiNewG = GetDlgItemInt(g_hwndColorMapDlg,
                                   IDC_MAP_NEW_GFIELD, NULL, FALSE);

            if ( (uiOldG > 255) || (uiNewG > 255) )
            {
                VERBOSE(("Input key value should be within 0 to 255"));                
                break;
            }

            // Get the Blue key

            uiOldB = GetDlgItemInt(g_hwndColorMapDlg, IDC_MAP_OLD_BFIELD,
                                   NULL, FALSE);
            uiNewB = GetDlgItemInt(g_hwndColorMapDlg,
                                   IDC_MAP_NEW_BFIELD, NULL, FALSE);

            if ( (uiOldB > 255) || (uiNewB > 255) )
            {
                VERBOSE(("Input key value should be within 0 to 255"));                
                break;
            }

            // Get the A key

            uiOldA = GetDlgItemInt(g_hwndColorMapDlg, IDC_MAP_OLD_AFIELD,
                                   NULL, FALSE);
            uiNewA = GetDlgItemInt(g_hwndColorMapDlg,
                                   IDC_MAP_NEW_AFIELD, NULL, FALSE);

            if ( (uiOldA > 255) || (uiNewA > 255) )
            {
                VERBOSE(("Input key value should be within 0 to 255"));                
                break;
            }

            // Set draw attributes
            
            if ( g_pDrawAttrib == NULL )
            {
                g_pDrawAttrib = new ImageAttributes();
                if ( g_pDrawAttrib == NULL )
                {
                    return FALSE;
                }
            }

            ColorMap myColorMap;
            Color   oldColor((BYTE)uiOldA, (BYTE)uiOldR, (BYTE)uiOldG,
                             (BYTE)uiOldB);
            Color   newColor((BYTE)uiNewA, (BYTE)uiNewR, (BYTE)uiNewG,
                             (BYTE)uiNewB);

            myColorMap.oldColor = oldColor;
            myColorMap.newColor = newColor;

            g_pDrawAttrib->SetRemapTable(1, &myColorMap, ColorAdjustTypeBitmap);
                                    
            RefreshImageDisplay();
            EndDialog(hDlg, TRUE);
            
            break;
        }// switch()

        break;

    case WM_INITDIALOG:
        // Remember the dialog handle so that we can use it to deal with items
        // in this dialog

        g_hwndColorMapDlg = hDlg;

        // Set initial values

        SetDlgItemInt(g_hwndColorMapDlg, IDC_MAP_OLD_RFIELD, 255, FALSE);
        SetDlgItemInt(g_hwndColorMapDlg, IDC_MAP_OLD_GFIELD, 0, FALSE);
        SetDlgItemInt(g_hwndColorMapDlg, IDC_MAP_OLD_BFIELD, 0, FALSE);
        SetDlgItemInt(g_hwndColorMapDlg, IDC_MAP_OLD_AFIELD, 255, FALSE);
        SetDlgItemInt(g_hwndColorMapDlg, IDC_MAP_NEW_RFIELD, 0, FALSE);
        SetDlgItemInt(g_hwndColorMapDlg, IDC_MAP_NEW_GFIELD, 255, FALSE);
        SetDlgItemInt(g_hwndColorMapDlg, IDC_MAP_NEW_BFIELD, 0, FALSE);
        SetDlgItemInt(g_hwndColorMapDlg, IDC_MAP_NEW_AFIELD, 255, FALSE);

        return TRUE;
    }// switch ( uiMessage )

    return FALSE;
}// ColorMapDlgProc()

INT_PTR CALLBACK
AnnotationDlgProc(
    HWND         hDlg,
    UINT         uiMessage,
    WPARAM       wParam,
    LPARAM       lParam
    )
{
    switch ( uiMessage )
    {
    case WM_COMMAND:
        switch ( LOWORD(wParam) )
        {
        case IDC_ANNOTATION_CANCEL:
            // End the dialog and return FALSE. So we won't do anything

            EndDialog(hDlg, FALSE);

            break;

        case IDC_ANNOTATION_OK:
            // User hit the OK button. First, we need to get the values user
            // entered
            
            if ( NULL == g_pImage )
            {
                // If there is no image, just close the dialog

                EndDialog(hDlg, TRUE);

                break;
            }

            char    acTemp[200];
            UINT    uiTextLength = 0;

            uiTextLength = GetDlgItemText(g_hwndAnnotationDlg,
                                          IDC_ANNOTATION_EDITOR, acTemp, 200);
            
            if ( uiTextLength > 0 )
            {
                // Add 1 for the NULL terminator

                uiTextLength++;

                PropertyItem myItem;
                myItem.id = PropertyTagExifUserComment;
                myItem.length = uiTextLength;
                myItem.type = TAG_TYPE_ASCII;

                myItem.value = malloc(uiTextLength);
                if ( myItem.value != NULL )
                {
                    strcpy((char*)myItem.value, acTemp);

                    Status rCode = g_pImage->SetPropertyItem(&myItem);
                    if ( (rCode != Ok) && (rCode != NotImplemented) )
                    {
                        VERBOSE(("SetPropertyItem() failed\n"));
                    }
                    
                    free(myItem.value);
                }
            }

            EndDialog(hDlg, TRUE);
            
            break;
        }// switch()

        break;

    case WM_INITDIALOG:
        // Remember the dialog handle so that we can use it to deal with items
        // in this dialog

        g_hwndAnnotationDlg = hDlg;

        // Check to see if the image has annotation in it

        // Check the size for this property item

        if ( g_pImage != NULL )
        {
            UINT uiItemSize = g_pImage->GetPropertyItemSize(
                                                    PropertyTagExifUserComment);

            if ( uiItemSize != 0 )
            {
                // Allocate memory and get this property item

                PropertyItem* pBuffer = (PropertyItem*)malloc(uiItemSize);
                if ( pBuffer == NULL )
                {
                    return FALSE;
                }

                if ( g_pImage->GetPropertyItem(PropertyTagExifUserComment,
                                               uiItemSize, pBuffer) == Ok )
                {        
                    // Set initial values

                    SetDlgItemText(g_hwndAnnotationDlg, IDC_ANNOTATION_EDITOR,
                                  (char*)pBuffer->value);
                    return TRUE;
                }
                else
                {
                    // Can't get property item. Something wrong

                    return FALSE;
                }
            }
            else
            {
                // No this property item, just initialize it with NULL

                SetDlgItemText(g_hwndAnnotationDlg, IDC_ANNOTATION_EDITOR, "");
            }
        }
        
        return TRUE;
    }// switch ( uiMessage )

    return FALSE;
}// AnnotationDlgProc()

#define  NO_TRANSFORM 9999

/*****************************************************************************\
*
*  FUNCTION   : JpegSaveDlgProc(hDlg, uiMessage, wParam, lParam)
*
*  PURPOSE    : Dialog function for the Encoder Parameter settings dialog
*
\*****************************************************************************/
INT_PTR CALLBACK
JpegSaveDlgProc(
    HWND         hDlg,
    UINT         uiMessage,
    WPARAM       wParam,
    LPARAM       lParam
    )
{
    static ULONG   flagValueTransform = NO_TRANSFORM; // No transform at all

    switch ( uiMessage )
    {
    case WM_COMMAND:
        switch ( LOWORD(wParam) )
        {
        case IDC_SAVEJPEG_CANCEL:
            // End the dialog and return FALSE. So we won't save this image

            EndDialog(hDlg, FALSE);

            break;

        case IDC_SAVEJPEG_OK:
            // User hit the OK button. First, we need to set the EncoderParam
            // based on user selection

            if ( g_pImage == NULL )
            {
                VERBOSE(("EncoderParamDlgProc: No image avail\n"));
                EndDialog(hDlg, FALSE);
            }
            else
            {
                if ( g_pEncoderParams != NULL )
                {
                    free(g_pEncoderParams);
                    g_pEncoderParams = NULL;
                }
                
                if ( flagValueTransform != NO_TRANSFORM )
                {
                    // User has set lossless transform, so we need set encoder
                    // parameter

                    g_pEncoderParams =
                         (EncoderParameters*)malloc(sizeof(EncoderParameters));

                    g_pEncoderParams->Parameter[0].Guid = EncoderTransformation;
                    g_pEncoderParams->Parameter[0].Type =
                                                EncoderParameterValueTypeLong;
                    g_pEncoderParams->Parameter[0].NumberOfValues = 1;
                    g_pEncoderParams->Parameter[0].Value =
                                                (VOID*)&flagValueTransform;
                    g_pEncoderParams->Count = 1;
                }

                EndDialog(hDlg, TRUE);
            }
            
            break;

        case IDC_SAVEJPEG_R90:
            flagValueTransform = EncoderValueTransformRotate90;
            break;

        case IDC_SAVEJPEG_R180:
            flagValueTransform = EncoderValueTransformRotate180;
            break;
        
        case IDC_SAVEJPEG_R270:
            flagValueTransform = EncoderValueTransformRotate270;
            break;
        
        case IDC_SAVEJPEG_HFLIP:
            flagValueTransform = EncoderValueTransformFlipHorizontal;
            break;
        
        case IDC_SAVEJPEG_VFLIP:
            flagValueTransform = EncoderValueTransformFlipVertical;
            break;
        
        default:
            break;
        }

        break;

    case WM_INITDIALOG:
        // Remember the dialog handle so that we can use it to deal with items
        // in this dialog

        g_hwndJpegSaveDlg = hDlg;
        flagValueTransform = NO_TRANSFORM;

        SetJpegDefaultParameters();

        return TRUE;
    }

    return FALSE;
}// JpegSaveDlgProc()

/*****************************************************************************\
*
*  FUNCTION   : TiffSaveDlgProc(hDlg, uiMessage, wParam, lParam)
*
*  PURPOSE    : Dialog function for the Encoder Parameter settings dialog
*
\*****************************************************************************/
INT_PTR CALLBACK
TiffSaveDlgProc(
    HWND         hDlg,
    UINT         uiMessage,
    WPARAM       wParam,
    LPARAM       lParam
    )
{
    static PixelFormat   flagColorDepth = g_ImagePixelFormat; // Default color depth
    static compressMethod = 0;
    static ULONG   colorTemp = 0;

    switch ( uiMessage )
    {
    case WM_COMMAND:
        switch ( LOWORD(wParam) )
        {
        case IDC_SAVETIFFDLG_CANCEL:
            // End the dialog and return FALSE. So we won't save this image

            EndDialog(hDlg, FALSE);

            break;

        case IDC_SAVETIFFDLG_OK:
        {
            // User hit the OK button. First, we need to set the EncoderParam
            // based on user selection

            if ( g_pImage == NULL )
            {
                VERBOSE(("EncoderParamDlgProc: No image avail\n"));
                EndDialog(hDlg, FALSE);
            }
            else
            {
                if ( g_pEncoderParams != NULL )
                {
                    free(g_pEncoderParams);
                    g_pEncoderParams = NULL;
                }
                
                UINT    numOfParamSet = 0;

                if ( flagColorDepth != g_ImagePixelFormat )
                {
                    numOfParamSet++;
                }

                if ( compressMethod != 0 )
                {
                    numOfParamSet++;
                }

                if ( numOfParamSet > 0 )
                {
                    int iTemp = 0;

                    // User has set new color depth, so we need set encoder
                    // parameter for it

                    g_pEncoderParams =
                        (EncoderParameters*)malloc(sizeof(EncoderParameters) +
                                     numOfParamSet * sizeof(EncoderParameter));

                    if ( compressMethod != 0 )
                    {
                        // Set compression method

                        g_pEncoderParams->Parameter[iTemp].Guid =
                                                EncoderCompression;
                        g_pEncoderParams->Parameter[iTemp].Type =
                                                EncoderParameterValueTypeLong;
                        g_pEncoderParams->Parameter[iTemp].NumberOfValues = 1;
                        g_pEncoderParams->Parameter[iTemp].Value =
                                                (VOID*)&compressMethod;

                        iTemp++;
                        g_pEncoderParams->Count = iTemp;
                    }

                    if ( flagColorDepth != g_ImagePixelFormat )
                    {
                        // Set color depth

                        g_pEncoderParams->Parameter[iTemp].Guid =
                                                EncoderColorDepth;
                        g_pEncoderParams->Parameter[iTemp].Type =
                                                EncoderParameterValueTypeLong;
                        g_pEncoderParams->Parameter[iTemp].NumberOfValues = 1;
                        g_pEncoderParams->Parameter[iTemp].Value =
                                                (VOID*)&colorTemp;

                        iTemp++;
                        g_pEncoderParams->Count = iTemp;
                    }                    
                }// if ( numOfParamSet > 0 )
                
                EndDialog(hDlg, TRUE);
            }
        }
            
            break;

        case IDC_SAVETIFF_1BPP:
            flagColorDepth = PIXFMT_1BPP_INDEXED;
            colorTemp = 1;
            break;

        case IDC_SAVETIFF_4BPP:
            flagColorDepth = PIXFMT_4BPP_INDEXED;
            colorTemp = 4;
            break;
        
        case IDC_SAVETIFF_8BPP:
            flagColorDepth = PIXFMT_8BPP_INDEXED;
            colorTemp = 8;
            break;
        
        case IDC_SAVETIFF_24BPP:
            flagColorDepth = PIXFMT_24BPP_RGB;
            colorTemp = 24;
            break;
        
        case IDC_SAVETIFF_32ARGB:
            flagColorDepth = PIXFMT_32BPP_ARGB;
            colorTemp = 32;
            break;
        
        case IDC_SAVETIFF_CCITT3:
            compressMethod = EncoderValueCompressionCCITT3;
            break;

        case IDC_SAVETIFF_CCITT4:
            compressMethod = EncoderValueCompressionCCITT4;
            break;
        
        case IDC_SAVETIFF_RLE:
            compressMethod = EncoderValueCompressionRle;
            break;

        case IDC_SAVETIFF_LZW:
            compressMethod = EncoderValueCompressionLZW;
            break;

        case IDC_SAVETIFF_UNCOMPRESSED:
            compressMethod = EncoderValueCompressionNone;
            break;

        case IDC_SAVETIFF_COMPASSOURCE:
            compressMethod = 0;
            break;

        default:
            break;
        }

        break;

    case WM_INITDIALOG:
        // Remember the dialog handle so that we can use it to deal with items
        // in this dialog

        g_hwndTiffSaveDlg = hDlg;
        flagColorDepth = g_ImagePixelFormat; // Default color depth
        compressMethod = 0;
        colorTemp = 0;

        SetTiffDefaultParameters();

        return TRUE;
    }

    return FALSE;
}// TiffSaveDlgProc()

BOOL
StartSaveImage(
    const CHAR*     filename,
    const CLSID*    clsid
    )
{
    // Convert filename to a WCHAR

    WCHAR namestr[MAX_FILENAME_LENGTH];

    if ( !AnsiToUnicodeStr(filename, namestr, MAX_FILENAME_LENGTH) )
    {
        VERBOSE(("StartSaveImage: Convert %s to a WCHAR failed\n", filename));

        return FALSE;
    }

    if ( g_pImage != NULL )
    {
        CLSID tempClsID = *clsid;
        Status rCode = Ok;

        // Popup a dialog to let user set up the encoder parameters

        if ( tempClsID == K_JPEGCLSID )
        {
            if ( ShowMyDialog((INT)IDD_SAVEJPEGDLG, g_hwndMain,
                              JpegSaveDlgProc) == FALSE )
            {
                return FALSE;
            }
        }
        else if ( tempClsID == K_TIFFCLSID )
        {
            if ( ShowMyDialog((INT)IDD_SAVETIFFDLG, g_hwndMain,
                              TiffSaveDlgProc) == FALSE )
            {
                return FALSE;
            }
        }

        // Note: during the save dialog, the g_pEncoderParams will be set
        // depends on the user selection. Default is NULL

        rCode = g_pImage->Save(namestr, &tempClsID, g_pEncoderParams);

        free(g_pEncoderParams);
        g_pEncoderParams = NULL;

        if ( (rCode != Ok) && (rCode != NotImplemented) )
        {
            VERBOSE(("StartSaveImage--SaveToFile() failed\n"));
            return FALSE;
        }

        return TRUE;
    }
    else
    {
        VERBOSE(("StartSaveImage(): No image to save\n"));
        return FALSE;
    }
}// StartSaveImage()

BOOL
SaveCurrentFrame()
{
    GUID    guid = FRAMEDIM_PAGE;
    
    if ( NULL == g_pImage )
    {
        VERBOSE(("SaveCurrentFrame(): No image available\n"));
        return FALSE;
    }

    Status rCode = Ok;
        
        // Append the current frame

        ULONG  flagValueLastFrame = EncoderValueLastFrame;
        ULONG  flagValueDim = EncoderValueFrameDimensionPage;

        EncoderParameters*  pMyEncoderParams = (EncoderParameters*)malloc
                                               (2 * sizeof(EncoderParameters));

        pMyEncoderParams->Parameter[0].Guid = EncoderSaveFlag;
        pMyEncoderParams->Parameter[0].Type = EncoderParameterValueTypeLong;
        pMyEncoderParams->Parameter[0].NumberOfValues = 1;
        pMyEncoderParams->Parameter[0].Value = (VOID*)&flagValueDim;
        
#if 0
        pMyEncoderParams->Parameter[1].Guid = EncoderSaveFlag;
        pMyEncoderParams->Parameter[1].Type = EncoderParameterValueTypeLong;
        pMyEncoderParams->Parameter[1].NumberOfValues = 1;
        pMyEncoderParams->Parameter[1].Value = (VOID*)& flagValueLastFrame;

        pMyEncoderParams->Count = 2;
#endif
        pMyEncoderParams->Count = 1;
        
#if 1
        rCode = g_pImage->SaveAdd(pMyEncoderParams);
        
        free(pMyEncoderParams);
        if ( (rCode != Ok) && (rCode != NotImplemented) )
        {
            VERBOSE(("SaveAdd() failed\n"));
            return FALSE;
        }

#else   // Save append testing        
        WCHAR *filename = L"x:/foo.jpg";

        Image* newImage = new Image(filename);
        rCode = g_pImage->SaveAdd(newImage, pMyEncoderParams);
        delete newImage;
        if ( (rCode != Ok) && (rCode != NotImplemented) )
        {
            VERBOSE(("SaveAppend() failed\n"));
            return FALSE;
        }
#endif

    return TRUE;
}// SaveCurrentFrame()

VOID
CleanUp()
{
    // Clean up before quit

    if ( NULL != g_pImage )
    {
        delete g_pImage;
        g_pImage = NULL;
    }

    if ( NULL != g_pDrawAttrib )
    {
        delete g_pDrawAttrib;
        g_pDrawAttrib = NULL;
    }
    
    if ( NULL != g_pDestPoints )
    {
        delete g_pDestPoints;
        g_pDestPoints = NULL;
    }
}// CleanUp()

VOID
DoNextPage()
{
    g_iCurrentPageIndex++;

    // Check if we already at the last page of the image
    // Note: g_iCurrentPageIndex is 0 based. So the max page index we can reach
    // is g_uiTotalPages - 1

    if ( g_iCurrentPageIndex >= (INT)g_uiTotalPages )
    {
        g_iCurrentPageIndex = g_uiTotalPages - 1;
    }

    // Display current page

    SetCurrentPage();
}// DoNextPage()

VOID
DoPreviousPage()
{
    g_iCurrentPageIndex--;

    if ( g_iCurrentPageIndex < 0 )
    {
        g_iCurrentPageIndex = 0;
    }

    // Display current page

    SetCurrentPage();
}// DoPreviousPage()

VOID
DoAnimated()
{
    if ( g_uiTotalPages < 2 )
    {
        return;
    }

    // Reset the page to the first page

    g_iCurrentPageIndex = 0;

    // Display current page

    SetCurrentPage();

    SetTimer(g_hwndMain, 0, g_uiDelay * 10, NULL);
}// DoNextPage()

VOID
DoSave(
    HWND hwnd
    )
{
    OPENFILENAME    ofn;
    CHAR            filename[MAX_PATH];

    ZeroMemory(&ofn, sizeof(ofn));

    ofn.lStructSize = sizeof(ofn);
    ofn.hwndOwner = hwnd;
    ofn.hInstance = g_hAppInstance;
    ofn.lpstrFile = filename;
    ofn.nMaxFile = MAX_PATH;
    ofn.lpstrTitle = "Save Image File";
    ofn.lpstrInitialDir = ".";
    ofn.Flags = OFN_CREATEPROMPT | OFN_OVERWRITEPROMPT;
    filename[0] = '\0';

    // Make up the file type filter string

    ImageCodecInfo* codecs;
    UINT            count;

    GpStatus status;
    UINT cbCodecs = 0;
    GetImageEncodersSize(&count, &cbCodecs);
    codecs = static_cast<ImageCodecInfo *>(malloc (cbCodecs));
    if (codecs == NULL)
    {
        return;
    }
    
    status = GetImageEncoders(count, cbCodecs, codecs);
    if (status != Ok)
    {
        return;
    }
    
    CHAR* filter = MakeFilterFromCodecs(count, codecs, FALSE);

    if ( !filter )
    {
        VERBOSE(("DoSave---MakeFilterFromCodecs() failed\n"));
    }
    else
    {
        ofn.lpstrFilter = filter;

        // Present the file/save dialog

        if ( GetSaveFileName(&ofn) )
        {
            INT iIndex = ofn.nFilterIndex;

            if ( (iIndex < 0) || (iIndex > (INT)count) )
            {
                iIndex = 0;
            }
            else
            {
                iIndex--;
            }

            // Get the image encoder

            if ( StartSaveImage(filename, &codecs[iIndex].Clsid) == FALSE )
            {
                // Fail to get an image encoder

                return;
            }
        }   

        free(filter);
    }// Filter != NULL 

    if (codecs)
    {
        free(codecs);
    }

}// DoSave()

//
// Flip or rotate the image in memory
//
VOID
DoTransFlipRotate(
    HWND hwnd,
    INT menuCmd
    )
{
    switch ( menuCmd )
    {
    case IDM_TRANSFORM_HORIZONTALFLIP:
        g_pImage->RotateFlip(RotateNoneFlipX);

        break;

    case IDM_TRANSFORM_VERTICALFLIP:
        g_pImage->RotateFlip(RotateNoneFlipY);

        break;

    case IDM_TRANSFORM_ROTATE90:
        g_pImage->RotateFlip(Rotate90FlipNone);

        break;

    case IDM_TRANSFORM_ROTATE180:
        g_pImage->RotateFlip(Rotate180FlipNone);

        break;

    case IDM_TRANSFORM_ROTATE270:
        g_pImage->RotateFlip(Rotate270FlipNone);

        break;

    default:
        break;
    }
    
    UpdateImageInfo();
    RefreshImageDisplay();
}

//
// Flip or rotate the image, just for effect. No change to the source image
//
VOID
DoFlipRotate(
    HWND hwnd,
    INT menuCmd
    )
{
    Matrix mat;
    REAL tmpX, tmpY;
    int i;

    if ( g_pImage == NULL )
    {
        return;
    }

    Graphics* pGraphics = Graphics::FromHWND(hwnd);

    if ( (g_DestPointCount != 4) && (g_pDestPoints != NULL) )
    {
        free(g_pDestPoints);
    }

    g_DestPointCount = 4;
    if ( g_pDestPoints == NULL )
    {
        g_pDestPoints = (PointF*)malloc(g_DestPointCount * sizeof(PointF));
        if ( g_pDestPoints == NULL )
        {
            return;
        }

        g_pDestPoints[0].X = 0;                       // top left
        g_pDestPoints[0].Y = 0;
        g_pDestPoints[1].X = (float)g_ImageWidth - 1;  // top right
        g_pDestPoints[1].Y = 0;
        g_pDestPoints[2].X = 0;                       // bottom left
        g_pDestPoints[2].Y = (float)g_ImageHeight - 1;
        g_pDestPoints[3].X = (float)g_ImageWidth - 1;  // bottom right
        g_pDestPoints[3].Y = (float)g_ImageHeight - 1;

    }

    switch ( menuCmd )
    {
    case IDM_VIEW_HORIZONTALFLIP:
        if ( ((g_pDestPoints[1].X - g_pDestPoints[0].X)
              == (float)g_ImageWidth)
             ||((g_pDestPoints[0].X - g_pDestPoints[1].X)
                == (float)g_ImageWidth) )
        {
            tmpX = g_pDestPoints[0].X;
            tmpY = g_pDestPoints[0].Y;
            g_pDestPoints[0].X = g_pDestPoints[1].X;
            g_pDestPoints[0].Y = g_pDestPoints[1].Y;
            g_pDestPoints[1].X = tmpX;
            g_pDestPoints[1].Y = tmpY;
            tmpX = g_pDestPoints[3].X;
            tmpY = g_pDestPoints[3].Y;
            g_pDestPoints[3].X = g_pDestPoints[2].X;
            g_pDestPoints[3].Y = g_pDestPoints[2].Y; 
            g_pDestPoints[2].X = tmpX;
            g_pDestPoints[2].Y = tmpY;
        }
        else
        {
            tmpX = g_pDestPoints[0].X;
            tmpY = g_pDestPoints[0].Y;
            g_pDestPoints[0].X = g_pDestPoints[2].X;
            g_pDestPoints[0].Y = g_pDestPoints[2].Y;
            g_pDestPoints[2].X = tmpX;
            g_pDestPoints[2].Y = tmpY;
            tmpX = g_pDestPoints[3].X;
            tmpY = g_pDestPoints[3].Y;
            g_pDestPoints[3].X = g_pDestPoints[1].X;
            g_pDestPoints[3].Y = g_pDestPoints[1].Y; 
            g_pDestPoints[1].X = tmpX;
            g_pDestPoints[1].Y = tmpY;
        }

        break;

    case IDM_VIEW_VERTICALFLIP:
        if (((g_pDestPoints[1].X - g_pDestPoints[0].X) == (float)g_ImageWidth) ||
            ((g_pDestPoints[0].X - g_pDestPoints[1].X) == (float)g_ImageWidth))
        {
            tmpX = g_pDestPoints[0].X;
            tmpY = g_pDestPoints[0].Y;
            g_pDestPoints[0].X = g_pDestPoints[2].X;
            g_pDestPoints[0].Y = g_pDestPoints[2].Y;
            g_pDestPoints[2].X = tmpX;
            g_pDestPoints[2].Y = tmpY;
            tmpX = g_pDestPoints[3].X;
            tmpY = g_pDestPoints[3].Y;
            g_pDestPoints[3].X = g_pDestPoints[1].X;
            g_pDestPoints[3].Y = g_pDestPoints[1].Y; 
            g_pDestPoints[1].X = tmpX;
            g_pDestPoints[1].Y = tmpY;
        }
        else
        {
            tmpX = g_pDestPoints[0].X;
            tmpY = g_pDestPoints[0].Y;
            g_pDestPoints[0].X = g_pDestPoints[1].X;
            g_pDestPoints[0].Y = g_pDestPoints[1].Y;
            g_pDestPoints[1].X = tmpX;
            g_pDestPoints[1].Y = tmpY;
            tmpX = g_pDestPoints[3].X;
            tmpY = g_pDestPoints[3].Y;
            g_pDestPoints[3].X = g_pDestPoints[2].X;
            g_pDestPoints[3].Y = g_pDestPoints[2].Y; 
            g_pDestPoints[2].X = tmpX;
            g_pDestPoints[2].Y = tmpY;
        }

        break;

    case IDM_VIEW_ROTATE90:
        if (((g_pDestPoints[1].X - g_pDestPoints[0].X) == (float)g_ImageWidth - 1) ||
            ((g_pDestPoints[0].X - g_pDestPoints[1].X) == (float)g_ImageWidth - 1))
        {
            tmpX = g_pDestPoints[0].X;
            tmpY = g_pDestPoints[0].Y;
            g_pDestPoints[0].X = g_pDestPoints[1].X;
            g_pDestPoints[0].Y = g_pDestPoints[1].Y;
            g_pDestPoints[1].X = g_pDestPoints[3].X;
            g_pDestPoints[1].Y = g_pDestPoints[3].Y;
            g_pDestPoints[3].X = g_pDestPoints[2].X;
            g_pDestPoints[3].Y = g_pDestPoints[2].Y; 
            g_pDestPoints[2].X = tmpX;
            g_pDestPoints[2].Y = tmpY;
            for (i=0;i<4;i++)
            {
                if (g_pDestPoints[i].X == (float)g_ImageWidth - 1)
                {
                    g_pDestPoints[i].X = (float)g_ImageHeight - 1;
                }
                else if (g_pDestPoints[i].X == (float)g_ImageHeight - 1)
                {
                    g_pDestPoints[i].X = (float)g_ImageWidth - 1;
                }
                if (g_pDestPoints[i].Y == (float)g_ImageWidth - 1)
                {
                    g_pDestPoints[i].Y = (float)g_ImageHeight - 1;
                }
                else if (g_pDestPoints[i].Y == (float)g_ImageHeight - 1)
                {
                    g_pDestPoints[i].Y = (float)g_ImageWidth - 1;
                }
            }
        }
        else
        {
            tmpX = g_pDestPoints[0].X;
            tmpY = g_pDestPoints[0].Y;
            g_pDestPoints[0].X = g_pDestPoints[1].X;
            g_pDestPoints[0].Y = g_pDestPoints[1].Y;
            g_pDestPoints[1].X = g_pDestPoints[3].X;
            g_pDestPoints[1].Y = g_pDestPoints[3].Y;
            g_pDestPoints[3].X = g_pDestPoints[2].X;
            g_pDestPoints[3].Y = g_pDestPoints[2].Y; 
            g_pDestPoints[2].X = tmpX;
            g_pDestPoints[2].Y = tmpY;
            for (i=0;i<4;i++)
            {
                if (g_pDestPoints[i].X == (float)g_ImageWidth - 1)
                {
                    g_pDestPoints[i].X = (float)g_ImageHeight - 1;
                }
                else if (g_pDestPoints[i].X == (float)g_ImageHeight - 1)
                {
                    g_pDestPoints[i].X = (float)g_ImageWidth - 1;
                }
                if (g_pDestPoints[i].Y == (float)g_ImageWidth - 1)
                {
                    g_pDestPoints[i].Y = (float)g_ImageHeight - 1;
                }
                else if (g_pDestPoints[i].Y == (float)g_ImageHeight - 1)
                {
                    g_pDestPoints[i].Y = (float)g_ImageWidth - 1;
                }
            }
        }

        g_bRotated = !g_bRotated;

        break;

    case IDM_VIEW_ROTATE270:
        if (((g_pDestPoints[1].X - g_pDestPoints[0].X) == (float)g_ImageWidth) ||
            ((g_pDestPoints[0].X - g_pDestPoints[1].X) == (float)g_ImageWidth))
        {
            tmpX = g_pDestPoints[2].X;
            tmpY = g_pDestPoints[2].Y;
            g_pDestPoints[2].X = g_pDestPoints[3].X;
            g_pDestPoints[2].Y = g_pDestPoints[3].Y;
            g_pDestPoints[3].X = g_pDestPoints[1].X;
            g_pDestPoints[3].Y = g_pDestPoints[1].Y;
            g_pDestPoints[1].X = g_pDestPoints[0].X;
            g_pDestPoints[1].Y = g_pDestPoints[0].Y; 
            g_pDestPoints[0].X = tmpX;
            g_pDestPoints[0].Y = tmpY;
            for (i=0;i<4;i++)
            {
                if (g_pDestPoints[i].X == (float)g_ImageWidth)
                {
                    g_pDestPoints[i].X = (float)g_ImageHeight;
                }
                else if (g_pDestPoints[i].X == (float)g_ImageHeight)
                {
                    g_pDestPoints[i].X = (float)g_ImageWidth;
                }
                if (g_pDestPoints[i].Y == (float)g_ImageWidth)
                {
                    g_pDestPoints[i].Y = (float)g_ImageHeight;
                }
                else if (g_pDestPoints[i].Y == (float)g_ImageHeight)
                {
                    g_pDestPoints[i].Y = (float)g_ImageWidth;
                }
            }
        }
        else
        {
            tmpX = g_pDestPoints[2].X;
            tmpY = g_pDestPoints[2].Y;
            g_pDestPoints[2].X = g_pDestPoints[3].X;
            g_pDestPoints[2].Y = g_pDestPoints[3].Y;
            g_pDestPoints[3].X = g_pDestPoints[1].X;
            g_pDestPoints[3].Y = g_pDestPoints[1].Y;
            g_pDestPoints[1].X = g_pDestPoints[0].X;
            g_pDestPoints[1].Y = g_pDestPoints[0].Y; 
            g_pDestPoints[0].X = tmpX;
            g_pDestPoints[0].Y = tmpY;
            for (i=0;i<4;i++)
            {
                if (g_pDestPoints[i].X == (float)g_ImageWidth)
                {
                    g_pDestPoints[i].X = (float)g_ImageHeight;
                }
                else if (g_pDestPoints[i].X == (float)g_ImageHeight)
                {
                    g_pDestPoints[i].X = (float)g_ImageWidth;
                }
                if (g_pDestPoints[i].Y == (float)g_ImageWidth)
                {
                    g_pDestPoints[i].Y = (float)g_ImageHeight;
                }
                else if (g_pDestPoints[i].Y == (float)g_ImageHeight)
                {
                    g_pDestPoints[i].Y = (float)g_ImageWidth;
                }
            }
        }

        g_bRotated = !g_bRotated;

        break;
    }// switch ( menuCmd )
    mat.TransformPoints(g_pDestPoints, g_DestPointCount);

    RefreshImageDisplay();

    delete pGraphics;

    RefreshImageDisplay();
}// DoFlipRotate()

VOID
DoGetProperties(
    VOID
    )
{
    UINT    numOfProperty;
    UINT    itemSize;
    PropertyItem*   pBuffer = NULL;
    PropertyItem*   pTotalBuffer = NULL;

    // Check how many property items in this image

    numOfProperty = g_pImage->GetPropertyCount();

    VERBOSE(("There are %d property items in image %s\n", numOfProperty,
             g_acImageName));
    // Get all the property ID list from the image

    PROPID* pList = (PROPID*)malloc(numOfProperty * sizeof(PROPID));
    if ( pList == NULL )
    {
        return;
    }

    Status rCode = g_pImage->GetPropertyIdList(numOfProperty, pList);
    if ( (rCode != Ok) && (rCode != NotImplemented) )
    {
        VERBOSE(("GetPropertyIdList() failed\n"));
        return;
    }

//#define UNITTEST 0

#if defined(UNITTEST)
    for ( int i = 0; i < (int)numOfProperty; ++i )
    {
        // Show Property ID

        VERBOSE(("ID[%d] = 0x%x, (%d) ", i, pList[i], pList[i]));

        // Check the size for this property item

        itemSize = g_pImage->GetPropertyItemSize(pList[i]);

        VERBOSE(("size = %d, ", itemSize));

        // Allocate memory and get this property item

        pBuffer = (PropertyItem*)malloc(itemSize);
        if ( pBuffer == NULL )
        {
            return;
        }

        rCode = g_pImage->GetPropertyItem(pList[i], itemSize, pBuffer);
        if ( (rCode != Ok) && (rCode != NotImplemented) )
        {
            VERBOSE(("GetPropertyItem() failed\n"));
            return;
        }

        DisplayPropertyItem(pBuffer);

        free(pBuffer);

        // Test RemovePropertyItem()

        rCode = g_pImage->RemovePropertyItem(pList[i]);
        if ( (rCode != Ok) && (rCode != NotImplemented) )
        {
            VERBOSE(("RemovePropertyItem() failed\n"));
            return;
        }
    }// Loop through the list

    free(pList);
#endif

    rCode = g_pImage->GetPropertySize(&itemSize, &numOfProperty);
    if ( (rCode != Ok) && (rCode != NotImplemented) )
    {
        VERBOSE(("GetPropertySize() failed\n"));
        return;
    }

    pTotalBuffer = (PropertyItem*)malloc(itemSize);
    rCode = g_pImage->GetAllPropertyItems(itemSize, numOfProperty,
                                          pTotalBuffer);
    if ( (rCode != Ok) && (rCode != NotImplemented) )
    {
        VERBOSE(("GetAllPropertyItems() failed\n"));
        return;
    }

    PropertyItem*   pTemp = pTotalBuffer;
    for ( int j = 0; j < (int)numOfProperty; ++j )
    {
        DisplayPropertyItem(pTemp);

        pTemp++;
    }

    free(pTotalBuffer);
}// DoGetProperties()

VOID
DoViewThumbnail()
{
    // Get build in thumbnail

    Image* pThumbImage = g_pImage->GetThumbnailImage(0, 0);

    if ( pThumbImage == NULL )
    {
        VERBOSE(("Image %s doesn't have a thumbnail\n", g_acImageName));
        return;
    }

    if ( NULL != g_pImage )
    {
        delete g_pImage;
    }

    g_pImage = pThumbImage;

    UpdateImageInfo();
    g_dScale = 1;
    RefreshImageDisplay();
}// DoViewThumbnail()

VOID
DoChannelView(
    INT menuCmd
    )
{
    if ( g_pDrawAttrib != NULL )
    {
        delete g_pDrawAttrib;
    }

    g_pDrawAttrib = new ImageAttributes();

    switch ( menuCmd )
    {
    case IDM_VIEW_CHANNEL_C:
        g_pDrawAttrib->SetOutputChannel(ColorChannelFlagsC);

        break;

    case IDM_VIEW_CHANNEL_M:
        g_pDrawAttrib->SetOutputChannel(ColorChannelFlagsM);

        break;

    case IDM_VIEW_CHANNEL_Y:
        g_pDrawAttrib->SetOutputChannel(ColorChannelFlagsY);

        break;

    case IDM_VIEW_CHANNEL_K:
        g_pDrawAttrib->SetOutputChannel(ColorChannelFlagsK);

        break;

    default:
        return;
    }

    RefreshImageDisplay();

    return;
}// DoChannelView()

VOID
DisplayImageInfo()
{
    VERBOSE(("\nInformation for frame %d of Image %s\n",
             g_iCurrentPageIndex + 1, g_acImageName));
    VERBOSE(("--------------------------------\n"));
    VERBOSE(("Width = %d\n", g_ImageWidth));
    VERBOSE(("Height = %d\n", g_ImageHeight));

    if ( g_ImageFlags & IMGFLAG_HASREALPIXELSIZE )
    {
        VERBOSE(("---The pixel size info is from the original image\n"));
    }
    else
    {
        VERBOSE(("---The pixel size info is NOT from the original image\n"));
    }
    
    switch ( g_ImagePixelFormat )
    {
    case PIXFMT_1BPP_INDEXED:
        VERBOSE(("Color depth: 1 BPP INDEXED\n"));
        
        break;

    case PIXFMT_4BPP_INDEXED:
        VERBOSE(("Color depth: 4 BPP INDEXED\n"));
        
        break;

    case PIXFMT_8BPP_INDEXED:
        VERBOSE(("Color depth: 8 BPP INDEXED\n"));
        
        break;

    case PIXFMT_16BPP_GRAYSCALE:
        VERBOSE(("Color depth: 16 BPP GRAY SCALE\n"));
        
        break;

    case PIXFMT_16BPP_RGB555:
        VERBOSE(("Color depth: 16 BPP RGB 555\n"));
        
        break;

    case PIXFMT_16BPP_RGB565:
        VERBOSE(("Color depth: 16 BPP RGB 565\n"));
        
        break;

    case PIXFMT_16BPP_ARGB1555:
        VERBOSE(("Color depth: 16 BPP ARGB 1555\n"));
        
        break;

    case PIXFMT_24BPP_RGB:
        VERBOSE(("Color depth: 24 BPP RGB\n"));
        
        break;

    case PIXFMT_32BPP_RGB:
        VERBOSE(("Color depth: 32 BPP RGB\n"));
        
        break;

    case PIXFMT_32BPP_ARGB:
        VERBOSE(("Color depth: 32 BPP ARGB\n"));
        
        break;

    case PIXFMT_32BPP_PARGB:
        VERBOSE(("Color depth: 32 BPP PARGB\n"));
        
        break;

    case PIXFMT_48BPP_RGB:
        VERBOSE(("Color depth: 48 BPP PARGB\n"));
        
        break;

    case PIXFMT_64BPP_ARGB:
        VERBOSE(("Color depth: 64 BPP ARGB\n"));
        
        break;

    case PIXFMT_64BPP_PARGB:
        VERBOSE(("Color depth: 64 BPP PARGB\n"));
        
        break;

    default:
        break;
    }// Color format

    VERBOSE(("X DPI (dots per inch) = %f\n", g_ImageXDpi));
    VERBOSE(("Y DPI (dots per inch) = %f\n", g_ImageYDpi));

    if ( g_ImageFlags & IMGFLAG_HASREALDPI )
    {
        VERBOSE(("---The DPI info is from the original image\n"));
    }
    else
    {
        VERBOSE(("---The DPI info is NOT from the original image\n"));
    }

    // Parse image info flags

    if ( g_ImageFlags & SINKFLAG_HASALPHA )
    {
        VERBOSE(("This image contains alpha pixels\n"));
        
        if ( g_ImageFlags & IMGFLAG_HASTRANSLUCENT )
        {
            VERBOSE(("---It has non-0 and 1 alpha pixels (TRANSLUCENT)\n"));
        }
    }
    else
    {
        VERBOSE(("This image does not contain alpha pixels\n"));
    }

    // Figure out origianl file format

    if ( g_ImageRawDataFormat == IMGFMT_MEMORYBMP )
    {
        VERBOSE(("RawDataFormat is MEMORYBMP\n"));
    }
    else if ( g_ImageRawDataFormat == IMGFMT_BMP )
    {
        VERBOSE(("RawDataFormat is BMP\n"));
    }
    else if ( g_ImageRawDataFormat == IMGFMT_EMF )
    {
        VERBOSE(("RawDataFormat is EMF\n"));
    }
    else if ( g_ImageRawDataFormat == IMGFMT_WMF )
    {
        VERBOSE(("RawDataFormat is WMF\n"));
    }
    else if ( g_ImageRawDataFormat == IMGFMT_JPEG )
    {
        VERBOSE(("RawDataFormat is JPEG\n"));
    }
    else if ( g_ImageRawDataFormat == IMGFMT_PNG )
    {
        VERBOSE(("RawDataFormat is PNG\n"));
    }
    else if ( g_ImageRawDataFormat == IMGFMT_GIF )
    {
        VERBOSE(("RawDataFormat is GIF\n"));
    }
    else if ( g_ImageRawDataFormat == IMGFMT_TIFF )
    {
        VERBOSE(("RawDataFormat is TIFF\n"));
    }
    else if ( g_ImageRawDataFormat == IMGFMT_EXIF )
    {
        VERBOSE(("RawDataFormat is EXIF\n"));
    }
    else if ( g_ImageRawDataFormat == IMGFMT_ICO )
    {
        VERBOSE(("RawDataFormat is ICO\n"));
    }
    else if ( g_ImageRawDataFormat == IMGFMT_PHOTOCD )
    {
        VERBOSE(("RawDataFormat is PHOTOCD\n"));
    }
    else if ( g_ImageRawDataFormat == IMGFMT_FLASHPIX )
    {
        VERBOSE(("RawDataFormat is FLASHPIX\n"));
    }
    else
    {
        VERBOSE(("RawDataFormat is UNDEFINED\n"));
    }
    
    // Figure out origianl color space

    if ( g_ImageFlags & IMGFLAG_COLORSPACE_RGB )
    {
        VERBOSE(("This image is in RGB color space\n"));
    }
    else if ( g_ImageFlags & IMGFLAG_COLORSPACE_CMYK )
    {
        VERBOSE(("This image is in CMYK color space\n"));
    }
    else if ( g_ImageFlags & IMGFLAG_COLORSPACE_GRAY )
    {
        VERBOSE(("This image is a gray scale image\n"));
    }
    else if ( g_ImageFlags & IMGFLAG_COLORSPACE_YCCK )
    {
        VERBOSE(("This image is in YCCK color space\n"));
    }
    else if ( g_ImageFlags & IMGFLAG_COLORSPACE_YCBCR )
    {
        VERBOSE(("This image is in YCBCR color space\n"));
    }
}// DisplayImageInfo()

//
// Convert the current image to a bitmap
//

VOID
DoConvertToBitmap(
    HWND    hwnd,
    INT     menuCmd
    )
{
    // Map menu selection to its corresponding pixel format

    PixelFormatID pixfmt;

    switch (menuCmd)
    {
    case IDM_CONVERT_8BIT:
        pixfmt = PIXFMT_8BPP_INDEXED;

        break;

    case IDM_CONVERT_16BITRGB555:
        pixfmt = PIXFMT_16BPP_RGB555;

        break;

    case IDM_CONVERT_16BITRGB565:
        pixfmt = PIXFMT_16BPP_RGB565;

        break;

    case IDM_CONVERT_24BITRGB:
        pixfmt = PIXFMT_24BPP_RGB;

        break;

    case IDM_CONVERT_32BITRGB:
        pixfmt = PIXFMT_32BPP_RGB;

        break;

    case IDM_CONVERT_32BITARGB:
    default:
        pixfmt = PIXFMT_32BPP_ARGB;

        break;
    }

    // Convert the current image to a bitmap image

    if ( g_pImage != NULL )
    {
        Bitmap* pNewBmp = ((Bitmap*)g_pImage)->Clone(0, 0, g_ImageWidth,
                                                     g_ImageHeight, pixfmt);
        if ( pNewBmp == NULL )
        {
            VERBOSE(("Clone failed in DoConvertToBitmap()\n"));
            return;
        }

        //Release the old one

        if ( g_pImage != NULL )
        {
            delete g_pImage;
        }

        g_pImage = (Image*)pNewBmp;
    }

    RefreshImageDisplay();
}// DoConvertToBitmap()

//
// Crop the image
//
// NOTE: We're not spending time here to do a fancy UI.
//  So we'll just inset the image by 5 pixels each time.
//

VOID
DoCrop(
    HWND hwnd
    )
{
    if ( g_SourceWidth == 0 )
    {
        // initialize global source width and height if not previously
        // initialized

        if ( g_pImage == NULL )
        {
            return;
        }

        g_SourceWidth = (REAL)g_ImageWidth;
        g_SourceHeight = (REAL)g_ImageHeight;
    }

    // check to make sure source image is still at least one pixel big
    if ( (g_SourceWidth - g_SourceX) > 11 )
    {
        g_SourceX += 10;
    }

    if ( (g_SourceHeight - g_SourceY) > 11 )
    {
        g_SourceY += 10;
    }

    if ( (g_SourceWidth - g_SourceX) > 6 )
    {
        g_SourceWidth -= 5;
    }

    if ( (g_SourceHeight - g_SourceY) > 6 )
    {
        g_SourceHeight -= 5;
    }

    RefreshImageDisplay();
}// DoCrop()

void
DoRender()
{
    // Check if we have anything special for drawing

    if ( (g_pDrawAttrib == NULL) && (g_pDestPoints == NULL) )
    {
        // Nothing special, we don't need "render"

        return;
    }

    Bitmap* pNewBitmap = NULL;

    // Create a Graphics object from this memory DC and draw onto it

    if ( g_bRotated == TRUE )
    {
        pNewBitmap = new Bitmap(g_ImageHeight,
                                g_ImageWidth,
                                PIXFMT_32BPP_ARGB);
    }
    else
    {
        pNewBitmap = new Bitmap(g_ImageWidth,
                                g_ImageHeight,
                                PIXFMT_32BPP_ARGB);
    }
    
    if ( pNewBitmap == NULL )
    {
        return;
    }

    Graphics* pGraphics = new Graphics(pNewBitmap);

    REAL rWidth = (REAL)g_ImageWidth;
    REAL rHeight = (REAL)g_ImageHeight;
    
    if ( g_SourceWidth != 0 )
    {
        rWidth = g_SourceWidth;
    }

    if ( g_SourceHeight != 0 )
    {
        rHeight = g_SourceHeight;
    }

    if ( g_pDestPoints != NULL )
    {
        pGraphics->DrawImage(g_pImage,
                            g_pDestPoints,
                            3,                 // Should use g_DestPointCount,
                            g_SourceX,
                            g_SourceY,
                            rWidth,
                            rHeight,
                            UnitPixel,
                            g_pDrawAttrib,
                            NULL,
                            NULL);
    }
    else
    {
        Rect dstRect(0, 0, g_ImageWidth, g_ImageHeight);
        
        pGraphics->DrawImage(g_pImage,
                             dstRect,
                             (INT)g_SourceX,
                             (INT)g_SourceY,
                             (INT)rWidth,
                             (INT)rHeight,
                             UnitPixel,
                             g_pDrawAttrib,
                             NULL,
                             NULL);
    }

    if ( g_pImage != NULL )
    {
        delete g_pImage;
    }

    g_pImage = (Image*)pNewBitmap;

    delete pGraphics;

    // Clear up all the drawing special attributes since we have already done
    // the render

    if ( g_pDrawAttrib != NULL )
    {
        delete g_pDrawAttrib;
        g_pDrawAttrib = NULL;
    }

    if ( g_pDestPoints != NULL )
    {
        delete g_pDestPoints;
        g_pDestPoints = NULL;
        g_DestPointCount = 0;
    }
    
    RefreshImageDisplay();
}// DoRender()

VOID
DoICM()
{
    HMENU hMenu = GetMenu(g_hwndMain);
    UINT ulRC = GetMenuState(hMenu, IDM_EFFECT_ICC, MF_BYCOMMAND);

    if ( ulRC == MF_CHECKED )
    {
        // Turn ICM off

        CheckMenuItem(hMenu, IDM_EFFECT_ICC, MF_BYCOMMAND | MF_UNCHECKED);

        // Check if we loaded the image with ICM on or off

        if ( g_LoadImageWithICM == TRUE )
        {
            // The image we loaded is ICM converted. We need to through it
            // away and load a new one without the convertion

            g_LoadImageWithICM = FALSE;
            OpenImageFile(g_acImageName);
        }
    }
    else
    {
        // Turn ICM on

        CheckMenuItem(hMenu, IDM_EFFECT_ICC, MF_BYCOMMAND | MF_CHECKED);

        // Check if we loaded the image with ICM on or off

        if ( g_LoadImageWithICM == FALSE )
        {
            // The image we loaded without ICM converted. We need to through
            // it away and load a new one with the convertion

            g_LoadImageWithICM = TRUE;
            OpenImageFile(g_acImageName);
        }
    }
}// DoICM()

VOID
DoGamma()
{
    // Set gamma

    if ( g_pDrawAttrib == NULL )
    {
        g_pDrawAttrib = new ImageAttributes();
    }

    REAL    rGamma = 1.5;

    g_pDrawAttrib->SetGamma(rGamma);
}

VOID
DoMenuCommand(
    HWND    hwnd,
    INT     menuCmd
    )
{
    HMENU hMenu = GetMenu(g_hwndMain);

    switch ( menuCmd )
    {
    case IDM_FILE_OPEN:
        // Before we open a new image. We need be sure we have done the save
        // for previous image

        CleanUp();

        // Now open a new image

        DoOpen(hwnd);
        
        break;

    case IDM_FILE_SAVE:
        DoSave(hwnd);
        
        break;
                          
    case IDM_FILE_SAVEFRAME:
        // Save the current frame

        SaveCurrentFrame();

        break;

    case IDM_FILE_PRINT:
        DoPrint(hwnd);

        break;

    case IDM_VIEW_NEXTPAGE:
        DoNextPage();

        break;

    case IDM_VIEW_PREVIOUSPAGE:
        DoPreviousPage();

        break;

    case IDM_VIEW_ANIMATED:
        DoAnimated();
        break;

    case IDM_VIEW_THUMBNAIL:
        DoViewThumbnail();

        break;

    case IDM_VIEW_CHANNEL_C:
    case IDM_VIEW_CHANNEL_M:
    case IDM_VIEW_CHANNEL_Y:
    case IDM_VIEW_CHANNEL_K:
    case IDM_VIEW_CHANNEL_R:
    case IDM_VIEW_CHANNEL_G:
    case IDM_VIEW_CHANNEL_B:
    case IDM_VIEW_CHANNEL_L:
        DoChannelView(menuCmd);

        break;

    case IDM_VIEW_ZOOM_IN:
        g_dScale = g_dScale * 2;
        g_fFitToWindow_w = FALSE;
        g_fFitToWindow_h = FALSE;

        RefreshImageDisplay();
        
        break;

    case IDM_VIEW_ZOOM_OUT:
        g_dScale = g_dScale / 2;
        g_fFitToWindow_w = FALSE;
        g_fFitToWindow_h = FALSE;

        CheckMenuItem(hMenu, IDM_VIEW_ZOOM_FITWINDOW_W,
                      MF_BYCOMMAND | MF_UNCHECKED);
        CheckMenuItem(hMenu, IDM_VIEW_ZOOM_FITWINDOW_H,
                      MF_BYCOMMAND | MF_UNCHECKED);
        
        RefreshImageDisplay();
        
        break;

    case IDM_VIEW_ZOOM_FITWINDOW_W:
        g_dScale = (REAL)g_iWinWidth / g_ImageWidth;

        g_fFitToWindow_w = TRUE;
        g_fFitToWindow_h = FALSE;

        ToggleScaleFactorMenu(IDM_VIEW_ZOOM_FITWINDOW_W, GetMenu(g_hwndMain));

        RefreshImageDisplay();
        
        break;
    
    case IDM_VIEW_ZOOM_FITWINDOW_H:
        g_dScale = (REAL)g_iWinHeight / g_ImageHeight;

        g_fFitToWindow_h = TRUE;
        g_fFitToWindow_w = FALSE;

        ToggleScaleFactorMenu(IDM_VIEW_ZOOM_FITWINDOW_H, GetMenu(g_hwndMain));

        RefreshImageDisplay();
        
        break;
    
    case IDM_VIEW_ZOOM_REALSIZE:
        g_dScale = 1.0;

        g_fFitToWindow_w = FALSE;
        g_fFitToWindow_h = FALSE;

        ToggleScaleFactorMenu(IDM_VIEW_ZOOM_REALSIZE, GetMenu(g_hwndMain));
        RefreshImageDisplay();

        break;

    case IDM_VIEW_OPTION_BILINEAR:
        g_InterpolationMode = InterpolationModeBilinear;
        ToggleScaleOptionMenu(IDM_VIEW_OPTION_BILINEAR, GetMenu(g_hwndMain));
        RefreshImageDisplay();

        break;

    case IDM_VIEW_OPTION_BICUBIC:
        g_InterpolationMode = InterpolationModeBicubic;
        ToggleScaleOptionMenu(IDM_VIEW_OPTION_BICUBIC, GetMenu(g_hwndMain));
        RefreshImageDisplay();

        break;
    
    case IDM_VIEW_OPTION_NEARESTNEIGHBOR:
        g_InterpolationMode = InterpolationModeNearestNeighbor;
        ToggleScaleOptionMenu(IDM_VIEW_OPTION_NEARESTNEIGHBOR,
                              GetMenu(g_hwndMain));
        RefreshImageDisplay();

        break;
    
    case IDM_VIEW_OPTION_HIGHLINEAR:
        g_InterpolationMode = InterpolationModeHighQualityBilinear;
        ToggleScaleOptionMenu(IDM_VIEW_OPTION_HIGHLINEAR, GetMenu(g_hwndMain));
        RefreshImageDisplay();

        break;
    
    case IDM_VIEW_OPTION_HIGHCUBIC:
        g_InterpolationMode = InterpolationModeHighQualityBicubic;
        ToggleScaleOptionMenu(IDM_VIEW_OPTION_HIGHCUBIC, GetMenu(g_hwndMain));
        RefreshImageDisplay();

        break;
    
    case IDM_VIEW_OPTION_WRAPMODETILE:
        g_WrapMode = WrapModeTile;
        g_pDrawAttrib->SetWrapMode(g_WrapMode, Color(0), FALSE);
        ToggleWrapModeOptionMenu(IDM_VIEW_OPTION_WRAPMODETILE,
                                 GetMenu(g_hwndMain));
        RefreshImageDisplay();
        
        break;

    case IDM_VIEW_OPTION_WRAPMODEFLIPX:
        g_WrapMode = WrapModeTileFlipX;
        g_pDrawAttrib->SetWrapMode(g_WrapMode, Color(0), FALSE);
        ToggleWrapModeOptionMenu(IDM_VIEW_OPTION_WRAPMODEFLIPX,
                                 GetMenu(g_hwndMain));
        RefreshImageDisplay();
        
        break;
    
    case IDM_VIEW_OPTION_WRAPMODEFLIPY:
        g_WrapMode = WrapModeTileFlipY;
        g_pDrawAttrib->SetWrapMode(g_WrapMode, Color(0), FALSE);
        ToggleWrapModeOptionMenu(IDM_VIEW_OPTION_WRAPMODEFLIPY,
                                 GetMenu(g_hwndMain));
        RefreshImageDisplay();
        
        break;

    case IDM_VIEW_OPTION_WRAPMODEFLIPXY:
        g_WrapMode = WrapModeTileFlipXY;
        g_pDrawAttrib->SetWrapMode(g_WrapMode, Color(0), FALSE);
        ToggleWrapModeOptionMenu(IDM_VIEW_OPTION_WRAPMODEFLIPXY,
                                 GetMenu(g_hwndMain));
        RefreshImageDisplay();
        
        break;

    case IDM_VIEW_OPTION_WRAPMODECLAMP0:
        g_WrapMode = WrapModeClamp;
        g_pDrawAttrib->SetWrapMode(g_WrapMode, Color(0), FALSE);
        ToggleWrapModeOptionMenu(IDM_VIEW_OPTION_WRAPMODECLAMP0,
                                 GetMenu(g_hwndMain));
        RefreshImageDisplay();

        break;

    case IDM_VIEW_OPTION_WRAPMODECLAMPFF:
        g_WrapMode = WrapModeClamp;
        g_pDrawAttrib->SetWrapMode(g_WrapMode, Color(0xffff0000), FALSE);
        ToggleWrapModeOptionMenu(IDM_VIEW_OPTION_WRAPMODECLAMPFF,
                                 GetMenu(g_hwndMain));
        RefreshImageDisplay();

        break;

    case IDM_VIEW_CROP:
        DoCrop(hwnd);
        break;

    case IDM_VIEW_HORIZONTALFLIP:
    case IDM_VIEW_VERTICALFLIP:
    case IDM_VIEW_ROTATE90:
    case IDM_VIEW_ROTATE270:
        DoFlipRotate(hwnd, menuCmd);

        break;

    case IDM_TRANSFORM_HORIZONTALFLIP:
    case IDM_TRANSFORM_VERTICALFLIP:
    case IDM_TRANSFORM_ROTATE90:
    case IDM_TRANSFORM_ROTATE180:
    case IDM_TRANSFORM_ROTATE270:
        DoTransFlipRotate(hwnd, menuCmd);

        break;
    
    case IDM_VIEW_ATTR_PROPERTY:
        DoGetProperties();
        break;
    
    case IDM_VIEW_ATTR_INFO:
        DisplayImageInfo();
        break;
    
    case IDM_FILE_RENDER:
        DoRender();

        break;

    case IDM_FILE_QUIT:
        CleanUp();

        PostQuitMessage(0);
        
        break;

    case IDM_CONVERT_8BIT:
    case IDM_CONVERT_16BITRGB555:
    case IDM_CONVERT_16BITRGB565:
    case IDM_CONVERT_24BITRGB:
    case IDM_CONVERT_32BITRGB:
    case IDM_CONVERT_32BITARGB:
        DoConvertToBitmap(hwnd, menuCmd);
        
        break;
    
    case IDM_EFFECT_TRANSKEY:
        // Popup a dialog to let user set up the transparent key

        if ( ShowMyDialog((INT)IDD_COLORKEYDLG, g_hwndMain,
                          DecoderParamDlgProc) == FALSE )

        {
            return;
        }

        break;

    case IDM_EFFECT_COLORMAP:
        // Popup a dialog to let user set up the color map value

        if ( ShowMyDialog((INT)IDD_COLORMAPDLG, g_hwndMain,
                          ColorMapDlgProc) == FALSE )

        {
            return;
        }
        
        break;

    case IDM_EFFECT_ICC:
        DoICM();        
        break;

    case IDM_EFFECT_GAMMA:
        DoGamma();
        break;
    
    case IDM_ANNOTATION_ANNOTATION:
        // Popup a dialog to let user modify/add annotation

        if ( ShowMyDialog((INT)IDD_ANNOTATIONDLG, g_hwndMain,
                          AnnotationDlgProc) == FALSE )

        {
            return;
        }

        break;

    case IDM_ANNOTATION_SOFTWARE:
        break;

    case IDM_ANNOTATION_AUDIOFILE:
        DoOpenAudioFile(hwnd);
    }
}// DoMenuCommand()

void
DoMouseMove(
    WPARAM  wParam,
    LPARAM lParam
    )
{
    if ( (wParam & MK_LBUTTON) && (g_pImage != NULL)
       &&(g_ImageRawDataFormat != IMGFMT_EMF)
       &&(g_ImageRawDataFormat != IMGFMT_WMF) )
    {
        int x = LOWORD(lParam);
        int y = HIWORD(lParam);
        char szAnsiMessage[256];

        if ( (x >= 0) && (y >= 0)
          && (x < (INT)g_ImageWidth) && ( y < (INT)g_ImageHeight) )
        {
            Color    color;
            ((Bitmap*)g_pImage)->GetPixel(x, y, &color);
        
            sprintf(szAnsiMessage, "(%d, %d) (%d, %d, %d, %d)", x, y,
                    color.GetAlpha(), color.GetRed(), color.GetGreen(),
                    color.GetBlue());
        }
        else
        {
            sprintf(szAnsiMessage, "Out of image bounds");
        }

        SetWindowText(g_hwndStatus, szAnsiMessage);
    }

    return;
}// DoMouseMove()

//
// Window callback procedure
//
LRESULT CALLBACK
MyWindowProc(
    HWND    hwnd,
    UINT    iMsg,
    WPARAM  wParam,
    LPARAM  lParam
    )
{
    switch ( iMsg )
    {
    case WM_COMMAND:
        DoMenuCommand(hwnd, LOWORD(wParam));

        break;

    case WM_KEYDOWN:
        switch ( wParam )
        {
        case VK_NEXT:

            // Page Down
            
            DoNextPage();
            
            break;

        case VK_PRIOR:

            // Page Up

            DoPreviousPage();
            
            break;

        case VK_F1:

            // F1 key for image info

            UpdateImageInfo();
            DisplayImageInfo();
            break;

        case VK_F2:
            // F2 for property items

            DoGetProperties();
            
            break;

        case VK_F3:
            
            // F3 key for animation

            DoAnimated();

            break;

        case VK_F4:
            // F4 for ICM

            DoICM();
            
            break;

        default:
            return DefWindowProc(hwnd, iMsg, wParam, lParam);
        }
        
        break;
    
    case WM_PAINT:
        DoPaint(hwnd);
        break;

    case WM_SIZE:
        g_iWinWidth = LOWORD(lParam);
        g_iWinHeight = HIWORD(lParam);

        if ( g_fFitToWindow_w == TRUE )
        {
            g_dScale = (REAL)g_iWinWidth / g_ImageWidth;
        }
        else if ( g_fFitToWindow_h == TRUE )
        {
            g_dScale = (REAL)g_iWinHeight / g_ImageHeight;
        }

        // Resize the status window

        int x;
        int y;
        int cx;
        int cy;

        RECT rWindow;

        // Keep status window height the same

        GetWindowRect(g_hwndStatus, &rWindow);
        cy = rWindow.bottom - rWindow.top;

        x = 0;
        y = g_iWinHeight - cy;
        cx = g_iWinWidth;
        MoveWindow(g_hwndStatus, x, y, cx, cy, TRUE);
        SetWindowText(g_hwndStatus, "");

        RefreshImageDisplay();
        break;

    case WM_MOUSEMOVE:
        DoMouseMove(wParam, lParam);

        break;

    case WM_TIMER:
        KillTimer(g_hwndMain, 0);
        
        DoNextPage();
        
        if ( (UINT)g_iCurrentPageIndex < (g_uiTotalPages - 1) )
        {
            // View the next frame

            SetTimer(g_hwndMain, 0, g_uiDelay * 10, NULL);
        }

        break;

    case WM_DESTROY:
        CleanUp();
        
        PostQuitMessage(0);
        
        break;

    default:
        return DefWindowProc(hwnd, iMsg, wParam, lParam);
    }

    return 0;
}// MyWindowProc()

//
// Create main application window
//
VOID
CreateMainWindow(
    int iX,
    int iY,
    int iWidth,
    int iHeight
    )
{
    HBRUSH hBrush = CreateHatchBrush(HS_HORIZONTAL,
                                     RGB(0, 200, 0));

    // Register window class

    WNDCLASS wndClass =
    {
        CS_HREDRAW|CS_VREDRAW,
        MyWindowProc,
        0,
        0,
        g_hAppInstance,
        LoadIcon(NULL, IDI_APPLICATION),
        LoadCursor(NULL, IDC_ARROW),
        hBrush,
        MAKEINTRESOURCE(IDR_MAINMENU),
        MYWNDCLASSNAME
    };

    RegisterClass(&wndClass);

    g_hwndMain = CreateWindow(MYWNDCLASSNAME,
                              MYWNDCLASSNAME,
                              WS_OVERLAPPEDWINDOW,
                              iX,
                              iY,
                              iWidth,
                              iHeight,
                              NULL,
                              NULL,
                              g_hAppInstance,
                              NULL);

    g_hwndStatus = CreateStatusWindow(WS_CHILD | WS_VISIBLE,
                                     (LPCSTR)"Ready", 
                                     g_hwndMain, 
                                     2);

    if ( !g_hwndMain || (!g_hwndStatus) )
    {
        VERBOSE(("CreateMainWindow---CreateStatusWindow() failed"));
        exit(-1);
    }
}// CreateMainWindow()

//
// Main program entrypoint
//
INT _cdecl
main(
    int     argc,
    char*   argv[]
    )
{
    if (!gGdiplusInitHelper.IsValid())
    {
        return 0;
    }

    // Parse input parameters

    ValidateArguments(argc, argv);

    g_hAppInstance = GetModuleHandle(NULL);

    g_iCurrentPageIndex = 0;
    
    // Create the main application window

    CreateMainWindow(g_iWinX, g_iWinY, g_iWinWidth, g_iWinHeight);

    // Open an image

    if ( OpenImageFile(g_acImageName) == FALSE )
    {
        // The user probably didn't give us image name or a wrong image name
        // Create our own background image now

        CreateBackgroundBitmap();
    }

    // After OpenImageFile() and CreateBackgroundBitmap(), we
    // should have an IImage obj which points to the current frame/page. If not,
    // end application

    ShowWindow(g_hwndMain, SW_SHOW);
    HMENU hMenu = GetMenu(g_hwndMain);

    CheckMenuItem(hMenu, IDM_VIEW_OPTION_HIGHCUBIC, MF_BYCOMMAND | MF_CHECKED);

    ResetImageAttribute();
    CheckMenuItem(hMenu, IDM_VIEW_OPTION_WRAPMODEFLIPXY,
                  MF_BYCOMMAND | MF_CHECKED);
    
    // Turn ICM on

    CheckMenuItem(hMenu, IDM_EFFECT_ICC, MF_BYCOMMAND | MF_CHECKED);
    
    // Main message loop

    MSG     msg;

    while (GetMessage(&msg, NULL, 0, 0))
    {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }

    return (INT)(msg.wParam);
}// main()

#if 0   // Set quality test
        UINT  uiSize = g_pImage->GetEncoderParameterListSize(&tempClsID);
        EncoderParameters*  pBuffer = (EncoderParameters*)malloc(uiSize);
        rCode = g_pImage->GetEncoderParameterList(&tempClsID, uiSize,
                                                  pBuffer);
            UINT qualityLevel = 50;
            pMyEncoderParams->Parameter[0].Guid = EncoderQuality;
            pMyEncoderParams->Parameter[0].Type = EncoderParameterValueTypeLong;
            pMyEncoderParams->Parameter[0].NumberOfValues = 1;
            pMyEncoderParams->Parameter[0].Value = (VOID*)&qualityLevel;
#endif

#if 0 // Save quantization table test
            static const unsigned short luminance_tbl[64] = {
              16,  11,  10,  16,  24,  40,  51,  61,
              12,  12,  14,  19,  26,  58,  60,  55,
              14,  13,  16,  24,  40,  57,  69,  56,
              14,  17,  22,  29,  51,  87,  80,  62,
              18,  22,  37,  56,  68, 109, 103,  77,
              24,  35,  55,  64,  81, 104, 113,  92,
              49,  64,  78,  87, 103, 121, 120, 101,
              72,  92,  95,  98, 112, 100, 103,  99
            };
            static const unsigned short chrominance_tbl[64] = {
              17,  18,  24,  47,  99,  99,  99,  99,
              18,  21,  26,  66,  99,  99,  99,  99,
              24,  26,  56,  99,  99,  99,  99,  99,
              47,  66,  99,  99,  99,  99,  99,  99,
              99,  99,  99,  99,  99,  99,  99,  99,
              99,  99,  99,  99,  99,  99,  99,  99,
              99,  99,  99,  99,  99,  99,  99,  99,
              99,  99,  99,  99,  99,  99,  99,  99
            };

            pMyEncoderParams = (EncoderParameters*)malloc
                               (2 * sizeof(EncoderParameters));

            pMyEncoderParams->Parameter[0].Guid = ENCODER_LUMINANCE_TABLE;
            pMyEncoderParams->Parameter[0].Type = EncoderParameterValueTypeShort;
            pMyEncoderParams->Parameter[0].NumberOfValues = 64;
            pMyEncoderParams->Parameter[0].Value = (VOID*)luminance_tbl;
            pMyEncoderParams->Parameter[1].Guid = ENCODER_CHROMINANCE_TABLE;
            pMyEncoderParams->Parameter[1].Type = EncoderParameterValueTypeShort;
            pMyEncoderParams->Parameter[1].NumberOfValues = 64;
            pMyEncoderParams->Parameter[1].Value = (VOID*)chrominance_tbl;
            pMyEncoderParams->Count = 2;
#endif // UNITTEST
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\frametest\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by frametest.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        1001
#define _APS_NEXT_COMMAND_VALUE         40005
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           1001
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\functest\cantialias.h ===
/******************************Module*Header*******************************\
* Module Name: CAntialias.h
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/

#ifndef __CANTIALIAS_H
#define __CANTIALIAS_H

#include "CSetting.h"

class CAntialias : public CSetting  
{
public:
	CAntialias(BOOL bRegression);
	virtual ~CAntialias();

	void Set(Graphics *g);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\frametest\frametest.h ===
#ifndef _FRAMETEST_H_
#define _FRAMETEST_H_

#define IDR_MAINMENU                100
#define IDR_ACCELTABLE              101

#define IDM_FILE_OPEN               200
#define IDM_FILE_SAVE               201
#define IDM_FILE_SAVEFRAME          202
#define IDM_FILE_RENDER             203
#define IDM_FILE_PRINT              204
#define IDM_FILE_QUIT               205

#define IDM_VIEW_NEXTPAGE           300
#define IDM_VIEW_PREVIOUSPAGE       301
#define IDM_VIEW_THUMBNAIL          302
#define IDM_VIEW_CHANNEL_C          303
#define IDM_VIEW_CHANNEL_M          304
#define IDM_VIEW_CHANNEL_Y          305
#define IDM_VIEW_CHANNEL_K          306
#define IDM_VIEW_CHANNEL_R          307
#define IDM_VIEW_CHANNEL_G          308
#define IDM_VIEW_CHANNEL_B          309
#define IDM_VIEW_CHANNEL_L          310
#define IDM_VIEW_CHANNEL_A          311
#define IDM_VIEW_ATTR_INFO          312
#define IDM_VIEW_ATTR_PROPERTY      313
#define IDM_VIEW_ANIMATED           314
#define IDM_VIEW_ZOOM_IN            315
#define IDM_VIEW_ZOOM_OUT           316
#define IDM_VIEW_ZOOM_FITWINDOW_W   317
#define IDM_VIEW_ZOOM_FITWINDOW_H   318
#define IDM_VIEW_ZOOM_REALSIZE      319
#define IDM_VIEW_OPTION_BILINEAR    320
#define IDM_VIEW_OPTION_BICUBIC     321
#define IDM_VIEW_OPTION_NEARESTNEIGHBOR 322
#define IDM_VIEW_OPTION_HIGHLINEAR  323
#define IDM_VIEW_OPTION_HIGHCUBIC   324
#define IDM_VIEW_OPTION_PIXELMODE   325
#define IDM_VIEW_OPTION_WRAPMODETILE 326
#define IDM_VIEW_OPTION_WRAPMODEFLIPX 327
#define IDM_VIEW_OPTION_WRAPMODEFLIPY 328
#define IDM_VIEW_OPTION_WRAPMODEFLIPXY 329
#define IDM_VIEW_OPTION_WRAPMODECLAMP0 330
#define IDM_VIEW_OPTION_WRAPMODECLAMPFF 331
#define IDM_VIEW_CROP               332
#define IDM_VIEW_ROTATE90           333
#define IDM_VIEW_ROTATE270          334
#define IDM_VIEW_HORIZONTALFLIP     335
#define IDM_VIEW_VERTICALFLIP       336

#define IDM_EFFECT_TRANSKEY         400
#define IDM_EFFECT_COLORMAP         401
#define IDM_EFFECT_ICC              402
#define IDM_EFFECT_GAMMA            403

#define IDM_TRANSFORM_ROTATE90      430
#define IDM_TRANSFORM_ROTATE180     431
#define IDM_TRANSFORM_ROTATE270     432
#define IDM_TRANSFORM_HORIZONTALFLIP 433
#define IDM_TRANSFORM_VERTICALFLIP  434

#define IDM_CONVERT_8BIT            500
#define IDM_CONVERT_16BITRGB555     501
#define IDM_CONVERT_16BITRGB565     502
#define IDM_CONVERT_24BITRGB        503
#define IDM_CONVERT_32BITRGB        504
#define IDM_CONVERT_32BITARGB       505

#define IDM_ANNOTATION_ANNOTATION   520
#define IDM_ANNOTATION_SOFTWARE     521
#define IDM_ANNOTATION_AUDIOFILE    522

// Set color key dialog

#define IDD_COLORKEYDLG             700
#define IDC_COLORKEY_OK             701
#define IDC_COLORKEY_CANCEL         702

#define IDC_TRANS_R                 710
#define IDC_TRANS_G                 711
#define IDC_TRANS_B                 712
#define IDC_TRANS_C                 713
#define IDC_TRANS_LOWER_RFIELD      714
#define IDC_TRANS_LOWER_GFIELD      715
#define IDC_TRANS_LOWER_BFIELD      716
#define IDC_TRANS_LOWER_CFIELD      717
#define IDC_TRANS_HIGHER_RFIELD     718
#define IDC_TRANS_HIGHER_CFIELD     719
#define IDC_TRANS_HIGHER_GFIELD     720
#define IDC_TRANS_HIGHER_BFIELD     721
#define IDC_TRANS_LOWERCOLOR        722
#define IDC_TRANS_HIGHERCOLOR       723

// Color map dialog

#define IDD_COLORMAPDLG             800
#define IDC_COLORMAP_OK             801
#define IDC_COLORMAP_CANCEL         802

#define IDC_MAP_OLDCOLOR            810
#define IDC_MAP_NEWCOLOR            811
#define IDC_MAP_R                   812
#define IDC_MAP_G                   813
#define IDC_MAP_B                   814
#define IDC_MAP_A                   815
#define IDC_MAP_OLD_RFIELD          816
#define IDC_MAP_OLD_GFIELD          817
#define IDC_MAP_OLD_BFIELD          818
#define IDC_MAP_OLD_AFIELD          819
#define IDC_MAP_NEW_RFIELD          820
#define IDC_MAP_NEW_GFIELD          821
#define IDC_MAP_NEW_BFIELD          822
#define IDC_MAP_NEW_AFIELD          823

// Annotation dialog

#define IDD_ANNOTATIONDLG           900
#define IDC_ANNOTATION_OK           901
#define IDC_ANNOTATION_CANCEL       902

#define IDC_ANNOTATION_EDITOR       910

// JPEG save dialog

#define IDD_SAVEJPEGDLG             1000
#define IDC_SAVEJPEG_OK             1001
#define IDC_SAVEJPEG_CANCEL         1002
#define IDC_SAVEJPEG_QEFIELD        1003
#define IDC_SAVEJPEG_QSLIDER        1004
#define IDC_SAVEJPEG_QUALITY        1005
#define IDC_SAVEJPEG_R90            1006
#define IDC_SAVEJPEG_R180           1007
#define IDC_SAVEJPEG_R270           1008
#define IDC_SAVEJPEG_HFLIP          1009
#define IDC_SAVEJPEG_VFLIP          1010
#define IDC_SAVEJPEG_NOTRANSFORM    1011
#define IDC_SAVEJPEG_LOSSLESSTEXT   1012

// TIFF save dialog

#define IDD_SAVETIFFDLG             1100
#define IDC_SAVETIFFDLG_OK          1101
#define IDC_SAVETIFFDLG_CANCEL      1102
#define IDC_SAVETIFF_COLORDEPTH     1103
#define IDC_SAVETIFF_1BPP           1104
#define IDC_SAVETIFF_4BPP           1105
#define IDC_SAVETIFF_8BPP           1106
#define IDC_SAVETIFF_24BPP          1107
#define IDC_SAVETIFF_32ARGB         1108
#define IDC_SAVETIFF_ASSOURCE       1109
#define IDC_SAVETIFF_COMPRESSMETHOD 1110
#define IDC_SAVETIFF_CCITT3         1111
#define IDC_SAVETIFF_CCITT4         1112
#define IDC_SAVETIFF_RLE            1113
#define IDC_SAVETIFF_LZW            1114
#define IDC_SAVETIFF_UNCOMPRESSED   1115
#define IDC_SAVETIFF_COMPASSOURCE   1116
#define IDC_SAVETIFF_MULTIFRAME     1117

const CLSID K_JPEGCLSID =
{
    0x557cf401,
    0x1a04,
    0x11d3,
    {0x9a, 0x73, 0x00, 0x00, 0xf8, 0x1e, 0xf3, 0x2e}
};

const CLSID K_TIFFCLSID =
{
    0x557cf405,
    0x1a04,
    0x11d3,
    {0x9a, 0x73, 0x00, 0x00, 0xf8, 0x1e, 0xf3, 0x2e}
};

void    USAGE();
BOOL    AnsiToUnicodeStr(const CHAR* ansiStr,
                         WCHAR* unicodeStr,
                         INT unicodeSize);
BOOL    UnicodeToAnsiStr(const WCHAR* unicodeStr,
                         CHAR* ansiStr,
                         INT ansiSize);
CHAR*   MakeFilterFromCodecs(UINT count,
                             const ImageCodecInfo* codecs,
                             BOOL open);
BOOL    ShowMyDialog(INT     id,
                     HWND    hwnd,
                     DLGPROC fpfn);
VOID    FileTimeToDosTime(FILETIME fileTime);
VOID    DisplayTagName(PROPID id);
VOID    DisplayPropertyItem(PropertyItem* pItem);
VOID    ToggleWrapModeOptionMenu(UINT uiMenuItem,
                                 HMENU   hMenu);
VOID    ToggleScaleOptionMenu(UINT    uiMenuItem,
                                 HMENU   hMenu);
VOID    ToggleScaleFactorMenu(UINT    uiMenuItem,
                              HMENU   hMenu);

#if DBG
#define VERBOSE(args) printf args
#else
#define VERBOSE(args)
#endif

#endif // _FRAMETEST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\functest\cantialias.cpp ===
/******************************Module*Header*******************************\
* Module Name: CAntialias.cpp
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/
#include "CAntialias.h"

CAntialias::CAntialias(BOOL bRegression)
{
	strcpy(m_szName,"Antialias");
	m_bRegression=bRegression;
}

CAntialias::~CAntialias()
{

}

void CAntialias::Set(Graphics *g)
{
	g->SetSmoothingMode(m_bUseSetting ? SmoothingModeAntiAlias : SmoothingModeNone);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\functest\cbitmap.cpp ===
/******************************Module*Header*******************************\
* Module Name: CBitmap.cpp
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  08-08-2000 - asecchia
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/
#include "CBitmap.h"
#include "CFuncTest.h"

extern CFuncTest g_FuncTest;

CBitmap::CBitmap(BOOL bRegression, PixelFormat pixelFormat)
{
    switch(pixelFormat) {
    case PixelFormat1bppIndexed:
    sprintf(m_szName,"Bitmap %s ", "1bppIndexed");
    break;
    case PixelFormat4bppIndexed:    	
    sprintf(m_szName,"Bitmap %s ", "4bppIndexed");
    break;
    case PixelFormat8bppIndexed:        
    sprintf(m_szName,"Bitmap %s ", "8bppIndexed");
    break;
    case PixelFormat16bppGrayScale:     
    sprintf(m_szName,"Bitmap %s ", "16bppGrayScale");
    break;
    case PixelFormat16bppRGB555:        
    sprintf(m_szName,"Bitmap %s ", "16bppRGB555");
    break;
    case PixelFormat16bppRGB565:        
    sprintf(m_szName,"Bitmap %s ", "16bppRGB565");
    break;
    case PixelFormat16bppARGB1555:      
    sprintf(m_szName,"Bitmap %s ", "16bppARGB1555");
    break;
    case PixelFormat24bppRGB:           
    sprintf(m_szName,"Bitmap %s ", "24bppRGB");
    break;
    case PixelFormat32bppRGB:           
    sprintf(m_szName,"Bitmap %s ", "32bppRGB");
    break;
    case PixelFormat32bppARGB:          
    sprintf(m_szName,"Bitmap %s ", "32bppARGB");
    break;
    case PixelFormat32bppPARGB:         
    sprintf(m_szName,"Bitmap %s ", "32bppPARGB");
    break;
    case PixelFormat48bppRGB:           
    sprintf(m_szName,"Bitmap %s ", "48bppRGB");
    break;
    case PixelFormat64bppARGB:          
    sprintf(m_szName,"Bitmap %s ", "64bppARGB");
    break;
    case PixelFormat64bppPARGB:         
    sprintf(m_szName,"Bitmap %s ", "64bppPARGB");
    break;
    }
	m_PixelFormat=pixelFormat;
	m_bRegression=bRegression;
}

CBitmap::~CBitmap()
{
}

Graphics *CBitmap::PreDraw(int &nOffsetX,int &nOffsetY)
{
	Graphics *g=NULL;
    m_bmp = new Bitmap((INT)TESTAREAWIDTH, (INT)TESTAREAHEIGHT, m_PixelFormat);

    g = new Graphics(m_bmp);

	// Since we are doing the test on another surface
	nOffsetX=0;
	nOffsetY=0;

	return g;
}

void CBitmap::PostDraw(RECT rTestArea)
{
    HDC hdcOrig = GetDC(g_FuncTest.m_hWndMain);
    Graphics *g = new Graphics(hdcOrig);
    g->DrawImage(m_bmp, rTestArea.left, rTestArea.top, 0, 0, (INT)TESTAREAWIDTH, (INT)TESTAREAHEIGHT, UnitPixel);

    delete m_bmp;
    delete g;
    m_bmp = NULL;
	ReleaseDC(g_FuncTest.m_hWndMain,hdcOrig);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\functest\cbitmap.h ===
/******************************Module*Header*******************************\
* Module Name: CBitmap.h
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  08-08-2000 - asecchia
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/

#ifndef __CBITMAP_H
#define __CBITMAP_H

#include "COutput.h"



class CBitmap : public COutput  
{
public:
	CBitmap(BOOL bRegression, PixelFormat pixelFormat);
	virtual ~CBitmap();

	Graphics *PreDraw(int &nOffsetX,int &nOffsetY);			// Set up graphics at the given X,Y offset
	void PostDraw(RECT rTestArea);							// Finish off graphics at rTestArea

	BOOL WriteBitmap(char *szTitle, HBITMAP hbitmap, INT width, INT height);
	void InitPalettes();									// Initialize palettes

    Bitmap *m_bmp;

	PixelFormat m_PixelFormat;											// # of bits to use
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\frametest\winutil.cpp ===
//-----------------------------------------------------------------------------
//
// Common utility functions
//
//-----------------------------------------------------------------------------
#include <stdio.h>
#include <windows.h>
#include <objbase.h>
#include <initguid.h>
#include "imaging.h"
#include "gdiplusimaging.h"
#include "frametest.h"

BOOL
AnsiToUnicodeStr(
    const CHAR* ansiStr,
    WCHAR* unicodeStr,
    INT unicodeSize
    )
{
    return MultiByteToWideChar(CP_ACP,
                               0,
                               ansiStr,
                               -1,
                               unicodeStr,
                               unicodeSize) > 0;
}

BOOL
UnicodeToAnsiStr(
    const WCHAR* unicodeStr,
    CHAR* ansiStr,
    INT ansiSize
    )
{
    return WideCharToMultiByte(
                CP_ACP,
                0,
                unicodeStr,
                -1,
                ansiStr,
                ansiSize,
                NULL,
                NULL) > 0;
}

void
USAGE()
{
    printf("******************************************************\n");
    printf("Usage: frametest [-?] [-w width] [-h height] [-x x] [-y y] Img\n");
    printf("-w-----------Specify the window width. Default is 300\n");
    printf("-h-----------Specify the window height. Default is 300\n");
    printf("-x-----------Specify the window X position. Default is 0\n");
    printf("-y-----------Specify the window Y position. Default is 0\n");
    printf("-?-----------Print this usage message\n");
    printf("ImageFile----File to be opened\n");
    printf("Use PageDown and PageUp to goto next/previous page\n");
}// USAGE()

#define SizeofWSTR(s) (sizeof(WCHAR) * (wcslen(s) + 1))
#define SizeofSTR(s) (strlen(s) + 1)

//
// Compose a file type filter string given an array of
// ImageCodecInfo structures
//

CHAR*
MakeFilterFromCodecs(
    UINT count,
    const ImageCodecInfo* codecs,
    BOOL open
    )
{
    static const CHAR allFiles[] = "All Files\0*.*";

    // Figure out the total size of the filter string

    UINT    index;
    UINT    size;

    for ( index = size = 0; index < count; ++index )
    {
        size += SizeofWSTR(codecs[index].FormatDescription)
              + SizeofWSTR(codecs[index].FilenameExtension);
    }

    if ( open )
    {
        size += sizeof(allFiles);
    }
    
    size += sizeof(CHAR);

    // Allocate memory

    CHAR *filter = (CHAR*)malloc(size);
    CHAR* p = filter;
    const WCHAR* ws;

    if ( !filter )
    {
        return NULL;
    }

    if ( open )
    {
        memcpy(p, allFiles, sizeof(allFiles));
        p += sizeof(allFiles);
    }

    for ( index = 0; index < count; ++index )
    {
        ws = codecs[index].FormatDescription;
        size = SizeofWSTR(ws);

        if ( UnicodeToAnsiStr(ws, p, size) )
        {
            p += SizeofSTR(p);
        }
        else
        {
            break;
        }

        ws = codecs[index].FilenameExtension;
        size = SizeofWSTR(ws);

        if ( UnicodeToAnsiStr(ws, p, size) )
        {
            p += SizeofSTR(p);
        }
        else
        {
            break;
        }
    }

    if ( index < count )
    {
        free(filter);
        return NULL;
    }

    *((CHAR*)p) = '\0';

    return filter;
}// MakeFilterFromCodecs()

/****************************************************************************\
*
*  FUNCTION   : ShowMyDialog(int id,HWND hwnd,FARPROC fpfn)
*
*  PURPOSE    : This function displays a dialog box
*
*  RETURNS    : The exit code.
*
\****************************************************************************/
BOOL
ShowMyDialog(
    INT     id,
    HWND    hwnd,
    DLGPROC fpfn
    )
{
    BOOL        fRC;
    HINSTANCE   hInst;

    hInst = (HINSTANCE)GetWindowLongPtr(hwnd, GWLP_HINSTANCE);
    fRC = (BOOL)DialogBox(hInst, MAKEINTRESOURCE(id), hwnd, fpfn);
    FreeProcInstance(fpfn);

    return fRC;
}// ShowMyDialog()

typedef struct _SFFS
{
    // Search Find File Structure

    unsigned char buff[21]; // dos search info
    unsigned char wAttr;
    union
    {
        unsigned short timeVariable;    // RPC47
        unsigned int time:16;
        struct
        {
            unsigned int sec : 5;
            unsigned int mint: 6;
            unsigned int hr  : 5;
        };
    };
    union
    {
        unsigned short dateVariable;
        unsigned int date:16;
        struct
        {
            unsigned int dom : 5;
            unsigned int mon : 4;
            unsigned int yr  : 7;
        };
    };
    unsigned long cbFile;
    unsigned char szFileName[13];
} SFFS;

VOID
FileTimeToDosTime(
    FILETIME fileTime
    )
{
    SFFS sffs;
    INT yr, mo, dy, sc;

    if ( CoFileTimeToDosDateTime(&fileTime,
         &sffs.dateVariable, &sffs.timeVariable))
    {
        yr = sffs.yr + 1980;
        mo = sffs.mon;
        dy = sffs.dom;
//        sc = (DWORD)sffs.hr * 3600 + sffs.mint * 60 + sffs.sec * 2;

        printf("%d:%d:%d %d:%d:%d\n", yr, mo, dy, sffs.hr, sffs.mint,sffs.sec);
    }
}

VOID
DisplayTagName(PROPID id)
{
    VERBOSE(("ID=%d [0x%x] ", id, id));

    // Print the TAG name according to its ID

    switch ( id )
    {
    case TAG_EXIF_IFD:
        VERBOSE(("EXIF IFD: "));
        break;

    case TAG_GPS_IFD:
        VERBOSE(("GPS IFD: "));
        break;

    case TAG_NEW_SUBFILE_TYPE:
        VERBOSE(("New Subfile Type: "));
        break;

    case TAG_SUBFILE_TYPE:
        VERBOSE(("Subfile Type: "));
        break;

    case TAG_IMAGE_WIDTH:
        VERBOSE(("Image Width: "));
        break;

    case TAG_IMAGE_HEIGHT:
        VERBOSE(("Image Height: "));
        break;

    case TAG_BITS_PER_SAMPLE:
        VERBOSE(("Bits Per Sample: "));
        break;

    case TAG_COMPRESSION:
        VERBOSE(("Compression: "));
        break;

    case TAG_THUMBNAIL_COMPRESSION:
        VERBOSE(("Thumbnail Compression: "));
        break;

    case TAG_THUMBNAIL_RESOLUTION_X:
        VERBOSE(("Thumbnail X resolution: "));
        break;

    case TAG_THUMBNAIL_RESOLUTION_Y:
        VERBOSE(("Thumbnail Y resolution: "));
        break;
    
    case TAG_THUMBNAIL_RESOLUTION_UNIT:
        VERBOSE(("Thumbnail resolution unit: "));
        break;
    
    case TAG_PHOTOMETRIC_INTERP:
        VERBOSE(("Photometric Interpolation: "));
        break;

    case TAG_THRESH_HOLDING:
        VERBOSE(("Photometric Interpolation: "));
        break;
    
    case TAG_CELL_WIDTH:
        VERBOSE(("Cell Width: "));
        break;

    case TAG_CELL_HEIGHT:
        VERBOSE(("Cell Height: "));
        break;

    case TAG_FILL_ORDER:
        VERBOSE(("Fill Order: "));
        break;

    case TAG_DOCUMENT_NAME:
        VERBOSE(("Document name: "));
        break;

    case TAG_ORIENTATION:
        VERBOSE(("Orientation: "));
        break;

    case TAG_SAMPLES_PER_PIXEL:
        VERBOSE(("Sample Per Pixel: "));
        break;

    case TAG_PLANAR_CONFIG:
        VERBOSE(("Planar Configuration: "));
        break;

    case TAG_PAGE_NAME:
        VERBOSE(("Page Name: "));
        break;

    case TAG_X_POSITION:
        VERBOSE(("X Position: "));
        break;

    case TAG_Y_POSITION:
        VERBOSE(("Y Position: "));
        break;

    case TAG_FREE_OFFSET:
        VERBOSE(("Free Offset: "));
        break;

    case TAG_FREE_BYTE_COUNTS:
        VERBOSE(("Free Byte Count: "));
        break;

    case TAG_GRAY_RESPONSE_UNIT:
        VERBOSE(("Gray Response Unit: "));
        break;

    case TAG_GRAY_RESPONSE_CURVE:
        VERBOSE(("Gray Response Curve: "));
        break;

    case TAG_T4_OPTION:
        VERBOSE(("T4 Option: "));
        break;

    case TAG_T6_OPTION:
        VERBOSE(("T6 Option: "));
        break;

    case TAG_YCbCr_SUBSAMPLING:
        VERBOSE(("YCbCr Subsampling: "));
        break;

    case TAG_YCbCr_POSITIONING:
        VERBOSE(("YCbCr position: "));
        break;

    case TAG_MIN_SAMPLE_VALUE:
        VERBOSE(("Min sample value: "));
        break;
    
    case TAG_MAX_SAMPLE_VALUE:
        VERBOSE(("Max sample value: "));
        break;

    case TAG_X_RESOLUTION:
        VERBOSE(("X Resolution: "));
        break;

    case TAG_Y_RESOLUTION:
        VERBOSE(("Y Resolution: "));
        break;

    case TAG_RESOLUTION_UNIT:
        VERBOSE(("Resolution UNIT: "));
        break;

    case TAG_PAGE_NUMBER:
        VERBOSE(("Page Number: "));
        break;

    case TAG_HOST_COMPUTER:
        VERBOSE(("Host Computer: "));
        break;
    
    case TAG_PREDICTOR:
        VERBOSE(("Predictor: "));
        break;

    case TAG_RESOLUTION_X_UNIT:
        VERBOSE(("X Resolution UNIT: "));
        break;

    case TAG_RESOLUTION_Y_UNIT:
        VERBOSE(("Y Resolution UNIT: "));
        break;

    case TAG_RESOLUTION_X_LENGTH_UNIT:
        VERBOSE(("X Resolution UNIT LENGTH: "));
        break;

    case TAG_RESOLUTION_Y_LENGTH_UNIT:
        VERBOSE(("Y Resolution UNIT LENGTH: "));
        break;

    case TAG_STRIP_OFFSETS:
        VERBOSE(("Strip Offsets: "));
        break;

    case TAG_ROWS_PER_STRIP:
        VERBOSE(("Rows Per Strip: "));
        break;

    case TAG_STRIP_BYTES_COUNT:
        VERBOSE(("Strip Bytes Count: "));
        break;

    case TAG_JPEG_INTER_FORMAT:
        VERBOSE(("JPEG thumbnail offset: "));
        break;

    case TAG_JPEG_INTER_LENGTH:
        VERBOSE(("JPEG thumbnail Length: "));
        break;

    case TAG_TRANSFER_FUNCTION:
        VERBOSE(("Transfer Function: "));
        break;

    case TAG_WHITE_POINT:
        VERBOSE(("White Point: "));
        break;

    case TAG_PRIMAY_CHROMATICS:
        VERBOSE(("Primay_Chromatics: "));
        break;

    case TAG_COLOR_MAP:
        VERBOSE(("Color Map: "));
        break;

    case TAG_HALFTONE_HINTS:
        VERBOSE(("HalfTone Hints: "));
        break;

    case TAG_TILE_WIDTH:
        VERBOSE(("Tile Width: "));
        break;

    case TAG_TILE_LENGTH:
        VERBOSE(("Tile Height: "));
        break;

    case TAG_TILE_OFFSET:
        VERBOSE(("Tile Offset: "));
        break;

    case TAG_TILE_BYTE_COUNTS:
        VERBOSE(("Tile Byte Count: "));
        break;

    case TAG_INK_SET:
        VERBOSE(("Ink Set: "));
        break;

    case TAG_INK_NAMES:
        VERBOSE(("Ink Names: "));
        break;

    case TAG_NUMBER_OF_INKS:
        VERBOSE(("Number of Inks: "));
        break;

    case TAG_DOT_RANGE:
        VERBOSE(("Dot Range: "));
        break;

    case TAG_TARGET_PRINTER:
        VERBOSE(("Target Printer: "));
        break;

    case TAG_EXTRA_SAMPLES:
        VERBOSE(("Extra Samples: "));
        break;

    case TAG_SAMPLE_FORMAT:
        VERBOSE(("Sample Format: "));
        break;

    case TAG_SMIN_SAMPLE_VALUE:
        VERBOSE(("SMin Sample Value: "));
        break;

    case TAG_SMAX_SAMPLE_VALUE:
        VERBOSE(("SMax Sample Value: "));
        break;

    case TAG_TRANSFER_RANGE:
        VERBOSE(("Transfer Range: "));
        break;

    case TAG_JPEG_PROC:
        VERBOSE(("JPEG Proc: "));
        break;

    case TAG_JPEG_RESTART_INTERVAL:
        VERBOSE(("JPEG Restart Interval: "));
        break;

    case TAG_JPEG_LOSSLESS_PREDICTORS:
        VERBOSE(("JPEG Lossless Predictors: "));
        break;

    case TAG_JPEG_POINT_TRANSFORMS:
        VERBOSE(("JPEG Point Transforms: "));
        break;

    case TAG_JPEG_Q_TABLES:
        VERBOSE(("JPEG Q Tables: "));
        break;

    case TAG_JPEG_DC_TABLES:
        VERBOSE(("JPEG DC Tables: "));
        break;

    case TAG_JPEG_AC_TABLES:
        VERBOSE(("JPEG AC Tables: "));
        break;

    case TAG_YCbCr_COEFFICIENTS:
        VERBOSE(("YCbCr Coefficients: "));
        break;

    case TAG_REF_BLACK_WHITE:
        VERBOSE(("ReferenceBlackWhite: "));
        break;

    case TAG_DATE_TIME:
        VERBOSE(("Date Time: "));
        break;

    case TAG_IMAGE_DESCRIPTION:
        VERBOSE(("Description: "));
        break;

    case TAG_EQUIP_MAKE:
        VERBOSE(("Equipment Make "));
        break;

    case TAG_EQUIP_MODEL:
        VERBOSE(("Equipment Model "));
        break;

    case TAG_SOFTWARE_USED:
        VERBOSE(("Software Used: "));
        break;

    case TAG_ARTIST:
        VERBOSE(("Artist: "));
        break;

    case TAG_COPYRIGHT:
        VERBOSE(("Copyright: "));
        break;

    case TAG_PRINT_FLAGS:
        VERBOSE(("Print flags: "));
        break;

    case TAG_PRINT_FLAGS_VERSION:
        VERBOSE(("Print flags information---Version: "));
        break;

    case TAG_PRINT_FLAGS_CROP:
        VERBOSE(("Print flags information---Crop: "));
        break;

    case TAG_PRINT_FLAGS_BLEEDWIDTH:
        VERBOSE(("Print flags information---Bleed Width: "));
        break;

    case TAG_PRINT_FLAGS_BLEEDWIDTHSCALE:
        VERBOSE(("Print flags information---Bleed Width Scale: "));
        break;

    case TAG_COLORTRANSFER_FUNCTION:
        VERBOSE(("Color transfer function--"));
        break;

    case TAG_PIXEL_UNIT:
        VERBOSE(("Pixel UNIT: "));
        break;

    case TAG_PIXEL_PER_UNIT_X:
        VERBOSE(("Pixels Per UNIT in X: "));
        break;

    case TAG_PIXEL_PER_UNIT_Y:
        VERBOSE(("Pixels Per UNIT in Y: "));
        break;

    case TAG_PALETTE_HISTOGRAM:
        VERBOSE(("Palette histogram: "));
        break;

    case TAG_HALFTONE_LPI:
        VERBOSE(("Color halftoning information LPI:"));
        break;

    case TAG_HALFTONE_LPI_UNIT:
        VERBOSE(("Color halftoning information LPI UNIT:"));
        break;

    case TAG_HALFTONE_DEGREE:
        VERBOSE(("Color halftoning information Degree:"));
        break;

    case TAG_HALFTONE_SHAPE:
        VERBOSE(("Color halftoning information Shape:"));
        break;

    case TAG_HALFTONE_MISC:
        VERBOSE(("Color halftoning information Misc:"));
        break;

    case TAG_HALFTONE_SCREEN:
        VERBOSE(("Color halftoning information Screen:"));
        break;

    case TAG_JPEG_QUALITY:
        VERBOSE(("JPEG quality: "));
        break;

    case TAG_GRID_SIZE:
        VERBOSE(("Grid and guides: "));
        break;

    case TAG_THUMBNAIL_FORMAT:
        VERBOSE(("Thumbnail Data Format: "));
        break;

    case TAG_THUMBNAIL_WIDTH:
    case TAG_THUMBNAIL_IMAGE_WIDTH:
        VERBOSE(("Thumbnail Width: "));
        break;

    case TAG_THUMBNAIL_HEIGHT:
    case TAG_THUMBNAIL_IMAGE_HEIGHT:
        VERBOSE(("Thumbnail Height: "));
        break;

    case TAG_THUMBNAIL_COLORDEPTH:
        VERBOSE(("Thumbnail Color depth: "));
        break;

    case TAG_THUMBNAIL_PLANES:
        VERBOSE(("Thumbnail Number of plane: "));
        break;

    case TAG_THUMBNAIL_RAWBYTES:
        VERBOSE(("Thumbnail Raw bytes (bytes): "));
        break;

    case TAG_THUMBNAIL_SIZE:
        VERBOSE(("Thumbnail Data Size (bytes): "));
        break;

    case TAG_THUMBNAIL_COMPRESSED_SIZE:
        VERBOSE(("Thumbnail Compressed Size (bytes): "));
        break;

    case TAG_THUMBNAIL_DATA:
        VERBOSE(("Thumbnail data bits: "));
        break;
        
    case TAG_LUMINANCE_TABLE:
        VERBOSE(("Luminance table "));
        break;

    case TAG_CHROMINANCE_TABLE:
        VERBOSE(("Chrominance table "));
        break;

    case TAG_IMAGE_TITLE:
        VERBOSE(("Image title: "));
        break;

    case TAG_ICC_PROFILE:
        VERBOSE(("ICC PROFILE "));
        break;

    case TAG_ICC_PROFILE_DESCRIPTOR:
        VERBOSE(("ICC PROFILE descriptor: "));
        break;
    
    case TAG_SRGB_RENDERING_INTENT:
        VERBOSE(("sRGB rendering intent: "));
        break;

    case TAG_GAMMA:
        VERBOSE(("GAMMA "));
        break;

    case TAG_FRAMEDELAY:
        VERBOSE(("Frame delay "));
        break;

    case TAG_LOOPCOUNT:
        VERBOSE(("Loop count "));
        break;

    case EXIF_TAG_VER:
        VERBOSE(("EXIF Version: "));
        break;

    case EXIF_TAG_FPX_VER:
        VERBOSE(("FlashPixVersion Version: "));
        break;

    case EXIF_TAG_COLOR_SPACE:
        VERBOSE(("Color Space: "));
        break;

    case EXIF_TAG_COMP_CONFIG:
        VERBOSE(("Components Configuration: "));
        break;

    case EXIF_TAG_COMP_BPP:
        VERBOSE(("Components Bits Per Pixel: "));
        break;

    case EXIF_TAG_PIX_X_DIM:
        VERBOSE(("Pixel X Dimension: "));
        break;

    case EXIF_TAG_PIX_Y_DIM:
        VERBOSE(("Pixel Y Dimension: "));
        break;

    case EXIF_TAG_MAKER_NOTE:
        VERBOSE(("Maker Note: "));
        break;

    case EXIF_TAG_USER_COMMENT:
        VERBOSE(("User Comments: "));
        break;

    case EXIF_TAG_RELATED_WAV:
        VERBOSE(("Related WAV File: "));
        break;

    case EXIF_TAG_D_T_ORIG:
        VERBOSE(("Date Time Original: "));
        break;

    case EXIF_TAG_D_T_DIGITIZED:
        VERBOSE(("Date Time Digitized: "));
        break;

    case EXIF_TAG_D_T_SUBSEC:
        VERBOSE(("Date & Time subseconds: "));
        break;

    case EXIF_TAG_D_T_ORIG_SS:
        VERBOSE(("Date & Time original subseconds: "));
        break;

    case EXIF_TAG_D_T_DIG_SS:
        VERBOSE(("Date & Time digitized subseconds: "));
        break;

    case EXIF_TAG_EXPOSURE_TIME:
        VERBOSE(("Exposure Time: "));
        break;

    case EXIF_TAG_F_NUMBER:
        VERBOSE(("F Number: "));
        break;

    case EXIF_TAG_EXPOSURE_PROG:
        VERBOSE(("Exposure Program: "));
        break;

    case EXIF_TAG_SPECTRAL_SENSE:
        VERBOSE(("Spectral Sense: "));
        break;

    case EXIF_TAG_ISO_SPEED:
        VERBOSE(("ISO Speed: "));
        break;

    case EXIF_TAG_OECF:
        VERBOSE(("Opto-Electric Conversion Function values: "));
        break;

    case EXIF_TAG_SHUTTER_SPEED:
        VERBOSE(("Shutter Speed: "));
        break;

    case EXIF_TAG_APERATURE:
        VERBOSE(("Aperature: "));
        break;

    case EXIF_TAG_BRIGHTNESS:
        VERBOSE(("Brightness: "));
        break;

    case EXIF_TAG_EXPOSURE_BIAS:
        VERBOSE(("Exposure Bias: "));
        break;

    case EXIF_TAG_MAX_APERATURE:
        VERBOSE(("Max Aperature: "));
        break;

    case EXIF_TAG_SUBJECT_DIST:
        VERBOSE(("Subject Distance: "));
        break;

    case EXIF_TAG_METERING_MODE:
        VERBOSE(("Metering Mode: "));
        break;

    case EXIF_TAG_LIGHT_SOURCE:
        VERBOSE(("Light Source: "));
        break;

    case EXIF_TAG_FLASH:
        VERBOSE(("Flash: "));
        break;

    case EXIF_TAG_FOCAL_LENGTH:
        VERBOSE(("Focal Length: "));
        break;

    case EXIF_TAG_FLASH_ENERGY:
        VERBOSE(("Flash Energy: "));
        break;

    case EXIF_TAG_SPATIAL_FR:
        VERBOSE(("Spacial Frequency Response: "));
        break;

    case EXIF_TAG_FOCAL_X_RES:
        VERBOSE(("Focal Plane X Resolution: "));
        break;

    case EXIF_TAG_FOCAL_Y_RES:
        VERBOSE(("Focal Plane Y Resolution: "));
        break;

    case EXIF_TAG_FOCAL_RES_UNIT:
        VERBOSE(("Focal Plane Resolution Unit: "));
        break;

    case EXIF_TAG_SUBJECT_LOC:
        VERBOSE(("Subject Location: "));
        break;

    case EXIF_TAG_EXPOSURE_INDEX:
        VERBOSE(("Exposure Index: "));
        break;

    case EXIF_TAG_SENSING_METHOD:
        VERBOSE(("Sensing Method: "));
        break;

    case EXIF_TAG_FILE_SOURCE:
        VERBOSE(("File Source: "));
        break;

    case EXIF_TAG_SCENE_TYPE:
        VERBOSE(("Scene Type: "));
        break;

    case EXIF_TAG_CFA_PATTERN:
        VERBOSE(("CFA Pattern: "));
        break;

    case EXIF_TAG_INTEROP:
        VERBOSE(("Interoperability Unit: "));
        break;

    case GPS_TAG_VER:
        VERBOSE(("GPS Version: "));
        break;

    case GPS_TAG_LATTITUDE_REF:
        VERBOSE(("GPS Lattitude Reference: "));
        break;

    case GPS_TAG_LATTITUDE:
        VERBOSE(("GPS Lattitude: "));
        break;

    case GPS_TAG_LONGITUDE_REF:
        VERBOSE(("GPS Longitude Reference: "));
        break;

    case GPS_TAG_LONGITUDE:
        VERBOSE(("GPS Longitude: "));
        break;

    case GPS_TAG_ALTITUDE_REF:
        VERBOSE(("GPS Altitude Reference: "));
        break;

    case GPS_TAG_ALTITUDE:
        VERBOSE(("GPS Altitude: "));
        break;

    case GPS_TAG_GPS_TIME:
        VERBOSE(("GPS Time: "));
        break;

    case GPS_TAG_GPS_SATELLITES:
        VERBOSE(("GPS Satellites: "));
        break;

    case GPS_TAG_GPS_STATUS:
        VERBOSE(("GPS Status: "));
        break;

    case GPS_TAG_GPS_MEASURE_MODE:
        VERBOSE(("GPS Measure Mode: "));
        break;

    case GPS_TAG_GPS_DOP:
        VERBOSE(("GPS Measurement precision: "));
        break;

    case GPS_TAG_SPEED_REF:
        VERBOSE(("GPS Speed Reference: "));
        break;

    case GPS_TAG_SPEED:
        VERBOSE(("GPS Speed: "));
        break;

    case GPS_TAG_TRACK_REF:
        VERBOSE(("GPS Track Reference: "));
        break;

    case GPS_TAG_TRACK:
        VERBOSE(("GPS Track: "));
        break;

    case GPS_TAG_IMG_DIR_REF:
        VERBOSE(("GPS Image Direction Reference: "));
        break;

    case GPS_TAG_IMG_DIR:
        VERBOSE(("GPS Image Direction: "));
        break;

    case GPS_TAG_MAP_DATUM:
        VERBOSE(("GPS Map Datum: "));
        break;

    case GPS_TAG_DEST_LAT_REF:
        VERBOSE(("GPS Destination Latitude Reference: "));
        break;

    case GPS_TAG_DEST_LAT:
        VERBOSE(("GPS Destination Latitude: "));
        break;

    case GPS_TAG_DEST_LONG_REF:
        VERBOSE(("GPS Longitude Reference: "));
        break;

    case GPS_TAG_DEST_LONG:
        VERBOSE(("GPS Longitude: "));
        break;

    case GPS_TAG_DEST_BEAR_REF:
        VERBOSE(("GPS Destination Bear Reference: "));
        break;

    case GPS_TAG_DEST_BEAR:
        VERBOSE(("GPS Destination Bear: "));
        break;

    case GPS_TAG_DEST_DIST_REF:
        VERBOSE(("GPS Destination Distance Reference: "));
        break;

    case GPS_TAG_DEST_DIST:
        VERBOSE(("GPS Destination Distance: "));
        break;

    default:
        VERBOSE(("Unknown Tag "));
        break;
    }
}// DisplayTagName()

VOID
DisplayPropertyItem(
    PropertyItem* pItem
    )
{
    // Print out the name first

    DisplayTagName(pItem->id);

    switch ( pItem->type )
    {
    case TAG_TYPE_BYTE:
    {
        // Print pItem->length bytes of information

        BYTE* pcTemp = (BYTE*)pItem->value;

        for ( int i = 0; i < (int)pItem->length; ++i )
        {
            VERBOSE(("%2.2x", *pcTemp++));
        }
        VERBOSE(("\n"));

#if 0 //(THUMBNAIL DATA testing)
        if ( pItem->id == TAG_THUMBNAIL_DATA )
        {
            FILE* fHandle = fopen("foo.jpg", "w");
            fwrite(pItem->value, 1, pItem->length, fHandle);
            fclose(fHandle);
        }
#endif
        break;
    }

    case TAG_TYPE_ASCII:
        VERBOSE(("%s\n", pItem->value));
        break;

    case TAG_TYPE_SHORT:
    {
        int iTotalItems = pItem->length / sizeof(SHORT);
        
        unsigned short* pusTemp = (unsigned short*)pItem->value;
        
        for ( int i = 0; i < iTotalItems; ++i )
        {
            VERBOSE(("%d ", *pusTemp));
            pusTemp++;
        }

        VERBOSE(("\n"));
        break;
    }

    case TAG_TYPE_LONG:
    {
        int iTotalItems = pItem->length / sizeof(LONG);

        long* plTemp = (long*)pItem->value;
        
        for ( int i = 0; i < iTotalItems; ++i )
        {
            VERBOSE(("%ld ", *plTemp));
            plTemp++;
        }

        VERBOSE(("\n"));

        break;
    }

    case TAG_TYPE_RATIONAL:
    case TAG_TYPE_SRATIONAL:
    {
        // Each RATIONAL/SRATIONAL contains 2 LONGs

        INT     iNumOfValue = pItem->length / ( 2 * sizeof(LONG) );
        LONG*   pLong = (LONG*)pItem->value;

        for ( int i = 0; i < iNumOfValue; ++i )
        {
            LONG    lNum = *pLong;
            LONG    lDen = *(pLong + 1);
        
            VERBOSE(("%f ", (float)lNum/lDen));
            pLong += 2;
        }
        VERBOSE(("\n"));

        break;
    }

    case TAG_TYPE_UNDEFINED:
    {
        // Print pItem->length bytes of information

        BYTE* pcTemp = (BYTE*)pItem->value;

        for ( int i = 0; i < (int)pItem->length; ++i )
        {
            VERBOSE(("%2.2x ", *pcTemp++));
        }

        VERBOSE(("\n"));
        break;
    }

    case TAG_TYPE_SLONG:
        VERBOSE(("%p\n", pItem->value));
        break;

    default:
        VERBOSE(("Unknown VT type\n"));
        break;
    }
}// DisplayPropertyItem()

VOID
ToggleScaleFactorMenu(
    UINT    uiMenuItem,
    HMENU   hMenu
    )
{
    for ( UINT uiTemp = IDM_VIEW_ZOOM_FITWINDOW_W;
         uiTemp <= IDM_VIEW_ZOOM_REALSIZE; uiTemp++ )
    {
        if ( uiTemp == uiMenuItem )
        {
            CheckMenuItem(hMenu, uiMenuItem, MF_BYCOMMAND | MF_CHECKED);
        }
        else
        {
            CheckMenuItem(hMenu, uiTemp, MF_BYCOMMAND | MF_UNCHECKED);
        }
    }
}// ToggleScaleFactorMenu()

VOID
ToggleScaleOptionMenu(
    UINT    uiMenuItem,
    HMENU   hMenu
    )
{
    for ( UINT uiTemp = IDM_VIEW_OPTION_BILINEAR;
         uiTemp <= IDM_VIEW_OPTION_HIGHCUBIC; uiTemp++ )
    {
        if ( uiTemp == uiMenuItem )
        {
            CheckMenuItem(hMenu, uiMenuItem, MF_BYCOMMAND | MF_CHECKED);
        }
        else
        {
            CheckMenuItem(hMenu, uiTemp, MF_BYCOMMAND | MF_UNCHECKED);
        }
    }
}// ToggleScaleOptionMenu()

VOID
ToggleWrapModeOptionMenu(
    UINT    uiMenuItem,
    HMENU   hMenu
    )
{
    for ( UINT uiTemp = IDM_VIEW_OPTION_WRAPMODETILE;
         uiTemp <= IDM_VIEW_OPTION_WRAPMODECLAMPFF; uiTemp++ )
    {
        if ( uiTemp == uiMenuItem )
        {
            CheckMenuItem(hMenu, uiMenuItem, MF_BYCOMMAND | MF_CHECKED);
        }
        else
        {
            CheckMenuItem(hMenu, uiTemp, MF_BYCOMMAND | MF_UNCHECKED);
        }
    }
}// ToggleWrapModeOptionMenu()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\functest\afxres.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef __AFXRES_H__
#define __AFXRES_H__

#ifdef RC_INVOKED
#ifndef _INC_WINDOWS
#define _INC_WINDOWS
	#include "winres.h"           // extract from windows header
#endif
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

#ifdef APSTUDIO_INVOKED
#define APSTUDIO_HIDDEN_SYMBOLS
#endif

/////////////////////////////////////////////////////////////////////////////
// MFC resource types (see Technical note TN024 for implementation details)

#ifndef RC_INVOKED
#define RT_DLGINIT  MAKEINTRESOURCEA(240)
#define RT_TOOLBAR  MAKEINTRESOURCEA(241)
#endif

/////////////////////////////////////////////////////////////////////////////

#ifdef APSTUDIO_INVOKED
#undef APSTUDIO_HIDDEN_SYMBOLS
#endif

/////////////////////////////////////////////////////////////////////////////
// General style bits etc

// ControlBar styles
#define CBRS_ALIGN_LEFT     0x1000L
#define CBRS_ALIGN_TOP      0x2000L
#define CBRS_ALIGN_RIGHT    0x4000L
#define CBRS_ALIGN_BOTTOM   0x8000L
#define CBRS_ALIGN_ANY      0xF000L

#define CBRS_BORDER_LEFT    0x0100L
#define CBRS_BORDER_TOP     0x0200L
#define CBRS_BORDER_RIGHT   0x0400L
#define CBRS_BORDER_BOTTOM  0x0800L
#define CBRS_BORDER_ANY     0x0F00L

#define CBRS_TOOLTIPS       0x0010L
#define CBRS_FLYBY          0x0020L
#define CBRS_FLOAT_MULTI    0x0040L
#define CBRS_BORDER_3D      0x0080L
#define CBRS_HIDE_INPLACE   0x0008L
#define CBRS_SIZE_DYNAMIC   0x0004L
#define CBRS_SIZE_FIXED     0x0002L
#define CBRS_FLOATING       0x0001L

#define CBRS_GRIPPER        0x00400000L

#define CBRS_ORIENT_HORZ    (CBRS_ALIGN_TOP|CBRS_ALIGN_BOTTOM)
#define CBRS_ORIENT_VERT    (CBRS_ALIGN_LEFT|CBRS_ALIGN_RIGHT)
#define CBRS_ORIENT_ANY     (CBRS_ORIENT_HORZ|CBRS_ORIENT_VERT)

#define CBRS_ALL            0x0040FFFFL

// the CBRS_ style is made up of an alignment style and a draw border style
//  the alignment styles are mutually exclusive
//  the draw border styles may be combined
#define CBRS_NOALIGN        0x00000000L
#define CBRS_LEFT           (CBRS_ALIGN_LEFT|CBRS_BORDER_RIGHT)
#define CBRS_TOP            (CBRS_ALIGN_TOP|CBRS_BORDER_BOTTOM)
#define CBRS_RIGHT          (CBRS_ALIGN_RIGHT|CBRS_BORDER_LEFT)
#define CBRS_BOTTOM         (CBRS_ALIGN_BOTTOM|CBRS_BORDER_TOP)

/////////////////////////////////////////////////////////////////////////////
// Standard window components

// Mode indicators in status bar - these are routed like commands
#define ID_INDICATOR_EXT                0xE700  // extended selection indicator
#define ID_INDICATOR_CAPS               0xE701  // cap lock indicator
#define ID_INDICATOR_NUM                0xE702  // num lock indicator
#define ID_INDICATOR_SCRL               0xE703  // scroll lock indicator
#define ID_INDICATOR_OVR                0xE704  // overtype mode indicator
#define ID_INDICATOR_REC                0xE705  // record mode indicator
#define ID_INDICATOR_KANA               0xE706  // kana lock indicator

#define ID_SEPARATOR                    0   // special separator value

#ifndef RC_INVOKED  // code only
// Standard control bars (IDW = window ID)
#define AFX_IDW_CONTROLBAR_FIRST        0xE800
#define AFX_IDW_CONTROLBAR_LAST         0xE8FF

#define AFX_IDW_TOOLBAR                 0xE800  // main Toolbar for window
#define AFX_IDW_STATUS_BAR              0xE801  // Status bar window
#define AFX_IDW_PREVIEW_BAR             0xE802  // PrintPreview Dialog Bar
#define AFX_IDW_RESIZE_BAR              0xE803  // OLE in-place resize bar
#define AFX_IDW_REBAR                   0xE804  // COMCTL32 "rebar" Bar
#define AFX_IDW_DIALOGBAR               0xE805  // CDialogBar

// Note: If your application supports docking toolbars, you should
//  not use the following IDs for your own toolbars.  The IDs chosen
//  are at the top of the first 32 such that the bars will be hidden
//  while in print preview mode, and are not likely to conflict with
//  IDs your application may have used succesfully in the past.

#define AFX_IDW_DOCKBAR_TOP             0xE81B
#define AFX_IDW_DOCKBAR_LEFT            0xE81C
#define AFX_IDW_DOCKBAR_RIGHT           0xE81D
#define AFX_IDW_DOCKBAR_BOTTOM          0xE81E
#define AFX_IDW_DOCKBAR_FLOAT           0xE81F

// Macro for mapping standard control bars to bitmask (limit of 32)
#define AFX_CONTROLBAR_MASK(nIDC)   (1L << (nIDC - AFX_IDW_CONTROLBAR_FIRST))

// parts of Main Frame
#define AFX_IDW_PANE_FIRST              0xE900  // first pane (256 max)
#define AFX_IDW_PANE_LAST               0xE9ff
#define AFX_IDW_HSCROLL_FIRST           0xEA00  // first Horz scrollbar (16 max)
#define AFX_IDW_VSCROLL_FIRST           0xEA10  // first Vert scrollbar (16 max)

#define AFX_IDW_SIZE_BOX                0xEA20  // size box for splitters
#define AFX_IDW_PANE_SAVE               0xEA21  // to shift AFX_IDW_PANE_FIRST
#endif //!RC_INVOKED

#ifndef APSTUDIO_INVOKED

// common style for form views
#define AFX_WS_DEFAULT_VIEW             (WS_CHILD | WS_VISIBLE | WS_BORDER)

#endif //!APSTUDIO_INVOKED

/////////////////////////////////////////////////////////////////////////////
// Standard app configurable strings

// for application title (defaults to EXE name or name in constructor)
#define AFX_IDS_APP_TITLE               0xE000
// idle message bar line
#define AFX_IDS_IDLEMESSAGE             0xE001
// message bar line when in shift-F1 help mode
#define AFX_IDS_HELPMODEMESSAGE         0xE002
// document title when editing OLE embedding
#define AFX_IDS_APP_TITLE_EMBEDDING     0xE003
// company name
#define AFX_IDS_COMPANY_NAME            0xE004
// object name when server is inplace
#define AFX_IDS_OBJ_TITLE_INPLACE       0xE005

/////////////////////////////////////////////////////////////////////////////
// Standard Commands

// File commands
#define ID_FILE_NEW                     0xE100
#define ID_FILE_OPEN                    0xE101
#define ID_FILE_CLOSE                   0xE102
#define ID_FILE_SAVE                    0xE103
#define ID_FILE_SAVE_AS                 0xE104
#define ID_FILE_PAGE_SETUP              0xE105
#define ID_FILE_PRINT_SETUP             0xE106
#define ID_FILE_PRINT                   0xE107
#define ID_FILE_PRINT_DIRECT            0xE108
#define ID_FILE_PRINT_PREVIEW           0xE109
#define ID_FILE_UPDATE                  0xE10A
#define ID_FILE_SAVE_COPY_AS            0xE10B
#define ID_FILE_SEND_MAIL               0xE10C

#define ID_FILE_MRU_FIRST               0xE110
#define ID_FILE_MRU_FILE1               0xE110          // range - 16 max
#define ID_FILE_MRU_FILE2               0xE111
#define ID_FILE_MRU_FILE3               0xE112
#define ID_FILE_MRU_FILE4               0xE113
#define ID_FILE_MRU_FILE5               0xE114
#define ID_FILE_MRU_FILE6               0xE115
#define ID_FILE_MRU_FILE7               0xE116
#define ID_FILE_MRU_FILE8               0xE117
#define ID_FILE_MRU_FILE9               0xE118
#define ID_FILE_MRU_FILE10              0xE119
#define ID_FILE_MRU_FILE11              0xE11A
#define ID_FILE_MRU_FILE12              0xE11B
#define ID_FILE_MRU_FILE13              0xE11C
#define ID_FILE_MRU_FILE14              0xE11D
#define ID_FILE_MRU_FILE15              0xE11E
#define ID_FILE_MRU_FILE16              0xE11F
#define ID_FILE_MRU_LAST                0xE11F

// Edit commands
#define ID_EDIT_CLEAR                   0xE120
#define ID_EDIT_CLEAR_ALL               0xE121
#define ID_EDIT_COPY                    0xE122
#define ID_EDIT_CUT                     0xE123
#define ID_EDIT_FIND                    0xE124
#define ID_EDIT_PASTE                   0xE125
#define ID_EDIT_PASTE_LINK              0xE126
#define ID_EDIT_PASTE_SPECIAL           0xE127
#define ID_EDIT_REPEAT                  0xE128
#define ID_EDIT_REPLACE                 0xE129
#define ID_EDIT_SELECT_ALL              0xE12A
#define ID_EDIT_UNDO                    0xE12B
#define ID_EDIT_REDO                    0xE12C

// Window commands
#define ID_WINDOW_NEW                   0xE130
#define ID_WINDOW_ARRANGE               0xE131
#define ID_WINDOW_CASCADE               0xE132
#define ID_WINDOW_TILE_HORZ             0xE133
#define ID_WINDOW_TILE_VERT             0xE134
#define ID_WINDOW_SPLIT                 0xE135
#ifndef RC_INVOKED      // code only
#define AFX_IDM_WINDOW_FIRST            0xE130
#define AFX_IDM_WINDOW_LAST             0xE13F
#define AFX_IDM_FIRST_MDICHILD          0xFF00  // window list starts here
#endif //!RC_INVOKED

// Help and App commands
#define ID_APP_ABOUT                    0xE140
#define ID_APP_EXIT                     0xE141
#define ID_HELP_INDEX                   0xE142
#define ID_HELP_FINDER                  0xE143
#define ID_HELP_USING                   0xE144
#define ID_CONTEXT_HELP                 0xE145      // shift-F1
// special commands for processing help
#define ID_HELP                         0xE146      // first attempt for F1
#define ID_DEFAULT_HELP                 0xE147      // last attempt

// Misc
#define ID_NEXT_PANE                    0xE150
#define ID_PREV_PANE                    0xE151

// Format
#define ID_FORMAT_FONT                  0xE160

// OLE commands
#define ID_OLE_INSERT_NEW               0xE200
#define ID_OLE_EDIT_LINKS               0xE201
#define ID_OLE_EDIT_CONVERT             0xE202
#define ID_OLE_EDIT_CHANGE_ICON         0xE203
#define ID_OLE_EDIT_PROPERTIES          0xE204
#define ID_OLE_VERB_FIRST               0xE210     // range - 16 max
#ifndef RC_INVOKED      // code only
#define ID_OLE_VERB_LAST                0xE21F
#endif //!RC_INVOKED

// for print preview dialog bar
#define AFX_ID_PREVIEW_CLOSE            0xE300
#define AFX_ID_PREVIEW_NUMPAGE          0xE301      // One/Two Page button
#define AFX_ID_PREVIEW_NEXT             0xE302
#define AFX_ID_PREVIEW_PREV             0xE303
#define AFX_ID_PREVIEW_PRINT            0xE304
#define AFX_ID_PREVIEW_ZOOMIN           0xE305
#define AFX_ID_PREVIEW_ZOOMOUT          0xE306

// View commands (same number used as IDW used for control bar)
#define ID_VIEW_TOOLBAR                 0xE800
#define ID_VIEW_STATUS_BAR              0xE801
#define ID_VIEW_REBAR                   0xE804
#define ID_VIEW_AUTOARRANGE         0xE805
	// E810 -> E81F must be kept in order for RANGE macros
#define ID_VIEW_SMALLICON               0xE810
#define ID_VIEW_LARGEICON               0xE811
#define ID_VIEW_LIST                   0xE812
#define ID_VIEW_DETAILS                 0xE813
#define ID_VIEW_LINEUP                  0xE814
#define ID_VIEW_BYNAME                  0xE815
#define AFX_ID_VIEW_MINIMUM              ID_VIEW_SMALLICON
#define AFX_ID_VIEW_MAXIMUM              ID_VIEW_BYNAME
	// E800 -> E8FF reserved for other control bar commands

// RecordForm commands
#define ID_RECORD_FIRST                 0xE900
#define ID_RECORD_LAST                  0xE901
#define ID_RECORD_NEXT                  0xE902
#define ID_RECORD_PREV                  0xE903

/////////////////////////////////////////////////////////////////////////////
// Standard control IDs

#ifdef IDC_STATIC
#undef IDC_STATIC
#endif
#define IDC_STATIC              (-1)     // all static controls

/////////////////////////////////////////////////////////////////////////////
// Standard string error/warnings

#ifndef RC_INVOKED      // code only
#define AFX_IDS_SCFIRST                 0xEF00
#endif //!RC_INVOKED

#define AFX_IDS_SCSIZE                  0xEF00
#define AFX_IDS_SCMOVE                  0xEF01
#define AFX_IDS_SCMINIMIZE              0xEF02
#define AFX_IDS_SCMAXIMIZE              0xEF03
#define AFX_IDS_SCNEXTWINDOW            0xEF04
#define AFX_IDS_SCPREVWINDOW            0xEF05
#define AFX_IDS_SCCLOSE                 0xEF06
#define AFX_IDS_SCRESTORE               0xEF12
#define AFX_IDS_SCTASKLIST              0xEF13

#define AFX_IDS_MDICHILD                0xEF1F

#define AFX_IDS_DESKACCESSORY           0xEFDA

// General strings
#define AFX_IDS_OPENFILE                0xF000
#define AFX_IDS_SAVEFILE                0xF001
#define AFX_IDS_ALLFILTER               0xF002
#define AFX_IDS_UNTITLED                0xF003
#define AFX_IDS_SAVEFILECOPY            0xF004
#define AFX_IDS_PREVIEW_CLOSE           0xF005
#define AFX_IDS_UNNAMED_FILE            0xF006
#define AFX_IDS_HIDE                    0xF011

// MFC Standard Exception Error messages
#define AFX_IDP_NO_ERROR_AVAILABLE      0xF020
#define AFX_IDS_NOT_SUPPORTED_EXCEPTION 0xF021
#define AFX_IDS_RESOURCE_EXCEPTION      0xF022
#define AFX_IDS_MEMORY_EXCEPTION        0xF023
#define AFX_IDS_USER_EXCEPTION          0xF024

// Printing and print preview strings
#define AFX_IDS_PRINTONPORT             0xF040
#define AFX_IDS_ONEPAGE                 0xF041
#define AFX_IDS_TWOPAGE                 0xF042
#define AFX_IDS_PRINTPAGENUM            0xF043
#define AFX_IDS_PREVIEWPAGEDESC         0xF044
#define AFX_IDS_PRINTDEFAULTEXT         0xF045
#define AFX_IDS_PRINTDEFAULT            0xF046
#define AFX_IDS_PRINTFILTER             0xF047
#define AFX_IDS_PRINTCAPTION            0xF048
#define AFX_IDS_PRINTTOFILE             0xF049


// OLE strings
#define AFX_IDS_OBJECT_MENUITEM         0xF080
#define AFX_IDS_EDIT_VERB               0xF081
#define AFX_IDS_ACTIVATE_VERB           0xF082
#define AFX_IDS_CHANGE_LINK             0xF083
#define AFX_IDS_AUTO                    0xF084
#define AFX_IDS_MANUAL                  0xF085
#define AFX_IDS_FROZEN                  0xF086
#define AFX_IDS_ALL_FILES               0xF087
// dynamically changing menu items
#define AFX_IDS_SAVE_MENU               0xF088
#define AFX_IDS_UPDATE_MENU             0xF089
#define AFX_IDS_SAVE_AS_MENU            0xF08A
#define AFX_IDS_SAVE_COPY_AS_MENU       0xF08B
#define AFX_IDS_EXIT_MENU               0xF08C
#define AFX_IDS_UPDATING_ITEMS          0xF08D
// COlePasteSpecialDialog defines
#define AFX_IDS_METAFILE_FORMAT         0xF08E
#define AFX_IDS_DIB_FORMAT              0xF08F
#define AFX_IDS_BITMAP_FORMAT           0xF090
#define AFX_IDS_LINKSOURCE_FORMAT       0xF091
#define AFX_IDS_EMBED_FORMAT            0xF092
// other OLE utility strings
#define AFX_IDS_PASTELINKEDTYPE         0xF094
#define AFX_IDS_UNKNOWNTYPE             0xF095
#define AFX_IDS_RTF_FORMAT              0xF096
#define AFX_IDS_TEXT_FORMAT             0xF097
// OLE datatype format error strings
#define AFX_IDS_INVALID_CURRENCY        0xF098
#define AFX_IDS_INVALID_DATETIME        0xF099
#define AFX_IDS_INVALID_DATETIMESPAN    0xF09A

// General error / prompt strings
#define AFX_IDP_INVALID_FILENAME        0xF100
#define AFX_IDP_FAILED_TO_OPEN_DOC      0xF101
#define AFX_IDP_FAILED_TO_SAVE_DOC      0xF102
#define AFX_IDP_ASK_TO_SAVE             0xF103
#define AFX_IDP_FAILED_TO_CREATE_DOC    0xF104
#define AFX_IDP_FILE_TOO_LARGE          0xF105
#define AFX_IDP_FAILED_TO_START_PRINT   0xF106
#define AFX_IDP_FAILED_TO_LAUNCH_HELP   0xF107
#define AFX_IDP_INTERNAL_FAILURE        0xF108      // general failure
#define AFX_IDP_COMMAND_FAILURE         0xF109      // command failure
#define AFX_IDP_FAILED_MEMORY_ALLOC     0xF10A
#define AFX_IDP_UNREG_DONE              0xF10B
#define AFX_IDP_UNREG_FAILURE           0xF10C
#define AFX_IDP_DLL_LOAD_FAILED         0xF10D
#define AFX_IDP_DLL_BAD_VERSION         0xF10E

// DDV parse errors
#define AFX_IDP_PARSE_INT               0xF110
#define AFX_IDP_PARSE_REAL              0xF111
#define AFX_IDP_PARSE_INT_RANGE         0xF112
#define AFX_IDP_PARSE_REAL_RANGE        0xF113
#define AFX_IDP_PARSE_STRING_SIZE       0xF114
#define AFX_IDP_PARSE_RADIO_BUTTON      0xF115
#define AFX_IDP_PARSE_BYTE              0xF116
#define AFX_IDP_PARSE_UINT              0xF117
#define AFX_IDP_PARSE_DATETIME          0xF118
#define AFX_IDP_PARSE_CURRENCY          0xF119

// CFile/CArchive error strings for user failure
#define AFX_IDP_FAILED_INVALID_FORMAT   0xF120
#define AFX_IDP_FAILED_INVALID_PATH     0xF121
#define AFX_IDP_FAILED_DISK_FULL        0xF122
#define AFX_IDP_FAILED_ACCESS_READ      0xF123
#define AFX_IDP_FAILED_ACCESS_WRITE     0xF124
#define AFX_IDP_FAILED_IO_ERROR_READ    0xF125
#define AFX_IDP_FAILED_IO_ERROR_WRITE   0xF126

// OLE errors / prompt strings
#define AFX_IDP_STATIC_OBJECT           0xF180
#define AFX_IDP_FAILED_TO_CONNECT       0xF181
#define AFX_IDP_SERVER_BUSY             0xF182
#define AFX_IDP_BAD_VERB                0xF183
#define AFX_IDS_NOT_DOCOBJECT                0xF184
#define AFX_IDP_FAILED_TO_NOTIFY        0xF185
#define AFX_IDP_FAILED_TO_LAUNCH        0xF186
#define AFX_IDP_ASK_TO_UPDATE           0xF187
#define AFX_IDP_FAILED_TO_UPDATE        0xF188
#define AFX_IDP_FAILED_TO_REGISTER      0xF189
#define AFX_IDP_FAILED_TO_AUTO_REGISTER 0xF18A
#define AFX_IDP_FAILED_TO_CONVERT       0xF18B
#define AFX_IDP_GET_NOT_SUPPORTED       0xF18C
#define AFX_IDP_SET_NOT_SUPPORTED       0xF18D
#define AFX_IDP_ASK_TO_DISCARD          0xF18E
#define AFX_IDP_FAILED_TO_CREATE        0xF18F

// MAPI errors / prompt strings
#define AFX_IDP_FAILED_MAPI_LOAD        0xF190
#define AFX_IDP_INVALID_MAPI_DLL        0xF191
#define AFX_IDP_FAILED_MAPI_SEND        0xF192

#define AFX_IDP_FILE_NONE               0xF1A0
#define AFX_IDP_FILE_GENERIC            0xF1A1
#define AFX_IDP_FILE_NOT_FOUND          0xF1A2
#define AFX_IDP_FILE_BAD_PATH           0xF1A3
#define AFX_IDP_FILE_TOO_MANY_OPEN      0xF1A4
#define AFX_IDP_FILE_ACCESS_DENIED      0xF1A5
#define AFX_IDP_FILE_INVALID_FILE       0xF1A6
#define AFX_IDP_FILE_REMOVE_CURRENT     0xF1A7
#define AFX_IDP_FILE_DIR_FULL           0xF1A8
#define AFX_IDP_FILE_BAD_SEEK           0xF1A9
#define AFX_IDP_FILE_HARD_IO            0xF1AA
#define AFX_IDP_FILE_SHARING            0xF1AB
#define AFX_IDP_FILE_LOCKING            0xF1AC
#define AFX_IDP_FILE_DISKFULL           0xF1AD
#define AFX_IDP_FILE_EOF                0xF1AE

#define AFX_IDP_ARCH_NONE               0xF1B0
#define AFX_IDP_ARCH_GENERIC            0xF1B1
#define AFX_IDP_ARCH_READONLY           0xF1B2
#define AFX_IDP_ARCH_ENDOFFILE          0xF1B3
#define AFX_IDP_ARCH_WRITEONLY          0xF1B4
#define AFX_IDP_ARCH_BADINDEX           0xF1B5
#define AFX_IDP_ARCH_BADCLASS           0xF1B6
#define AFX_IDP_ARCH_BADSCHEMA          0xF1B7

#define AFX_IDS_OCC_SCALEUNITS_PIXELS   0xF1C0

// 0xf200-0xf20f reserved

// font names and point sizes
#define AFX_IDS_STATUS_FONT             0xF230
#define AFX_IDS_TOOLTIP_FONT            0xF231
#define AFX_IDS_UNICODE_FONT            0xF232
#define AFX_IDS_MINI_FONT               0xF233

// ODBC Database errors / prompt strings
#ifndef RC_INVOKED      // code only
#define AFX_IDP_SQL_FIRST                       0xF280
#endif //!RC_INVOKED
#define AFX_IDP_SQL_CONNECT_FAIL                0xF281
#define AFX_IDP_SQL_RECORDSET_FORWARD_ONLY      0xF282
#define AFX_IDP_SQL_EMPTY_COLUMN_LIST           0xF283
#define AFX_IDP_SQL_FIELD_SCHEMA_MISMATCH       0xF284
#define AFX_IDP_SQL_ILLEGAL_MODE                0xF285
#define AFX_IDP_SQL_MULTIPLE_ROWS_AFFECTED      0xF286
#define AFX_IDP_SQL_NO_CURRENT_RECORD           0xF287
#define AFX_IDP_SQL_NO_ROWS_AFFECTED            0xF288
#define AFX_IDP_SQL_RECORDSET_READONLY          0xF289
#define AFX_IDP_SQL_SQL_NO_TOTAL                0xF28A
#define AFX_IDP_SQL_ODBC_LOAD_FAILED            0xF28B
#define AFX_IDP_SQL_DYNASET_NOT_SUPPORTED       0xF28C
#define AFX_IDP_SQL_SNAPSHOT_NOT_SUPPORTED      0xF28D
#define AFX_IDP_SQL_API_CONFORMANCE             0xF28E
#define AFX_IDP_SQL_SQL_CONFORMANCE             0xF28F
#define AFX_IDP_SQL_NO_DATA_FOUND               0xF290
#define AFX_IDP_SQL_ROW_UPDATE_NOT_SUPPORTED    0xF291
#define AFX_IDP_SQL_ODBC_V2_REQUIRED            0xF292
#define AFX_IDP_SQL_NO_POSITIONED_UPDATES       0xF293
#define AFX_IDP_SQL_LOCK_MODE_NOT_SUPPORTED     0xF294
#define AFX_IDP_SQL_DATA_TRUNCATED              0xF295
#define AFX_IDP_SQL_ROW_FETCH                   0xF296
#define AFX_IDP_SQL_INCORRECT_ODBC              0xF297
#define AFX_IDP_SQL_UPDATE_DELETE_FAILED        0xF298
#define AFX_IDP_SQL_DYNAMIC_CURSOR_NOT_SUPPORTED    0xF299
#define AFX_IDP_SQL_FIELD_NOT_FOUND             0xF29A
#define AFX_IDP_SQL_BOOKMARKS_NOT_SUPPORTED     0xF29B
#define AFX_IDP_SQL_BOOKMARKS_NOT_ENABLED       0xF29C

// ODBC Database strings
#define AFX_IDS_DELETED                         0xF29D

// DAO Database errors / prompt strings
#ifndef RC_INVOKED      // code only
#define AFX_IDP_DAO_FIRST                       0xF2B0
#endif //!RC_INVOKED
#define AFX_IDP_DAO_ENGINE_INITIALIZATION       0xF2B0
#define AFX_IDP_DAO_DFX_BIND                    0xF2B1
#define AFX_IDP_DAO_OBJECT_NOT_OPEN             0xF2B2

// ICDAORecordset::GetRows Errors
//  These are not placed in DAO Errors collection
//  and must be handled directly by MFC.
#define AFX_IDP_DAO_ROWTOOSHORT                 0xF2B3
#define AFX_IDP_DAO_BADBINDINFO                 0xF2B4
#define AFX_IDP_DAO_COLUMNUNAVAILABLE           0xF2B5

/////////////////////////////////////////////////////////////////////////////
// Strings for ISAPI support

#define AFX_IDS_HTTP_TITLE              0xF2D1
#define AFX_IDS_HTTP_NO_TEXT            0xF2D2
#define AFX_IDS_HTTP_BAD_REQUEST        0xF2D3
#define AFX_IDS_HTTP_AUTH_REQUIRED      0xF2D4
#define AFX_IDS_HTTP_FORBIDDEN          0xF2D5
#define AFX_IDS_HTTP_NOT_FOUND          0xF2D6
#define AFX_IDS_HTTP_SERVER_ERROR       0xF2D7
#define AFX_IDS_HTTP_NOT_IMPLEMENTED    0xF2D8

/////////////////////////////////////////////////////////////////////////////
// AFX implementation - control IDs (AFX_IDC)

// Parts of dialogs
#define AFX_IDC_LISTBOX                 100
#define AFX_IDC_CHANGE                  101

// for print dialog
#define AFX_IDC_PRINT_DOCNAME           201
#define AFX_IDC_PRINT_PRINTERNAME       202
#define AFX_IDC_PRINT_PORTNAME          203
#define AFX_IDC_PRINT_PAGENUM           204

// Property Sheet control id's (determined with Spy++)
#define ID_APPLY_NOW                    0x3021
#define ID_WIZBACK                      0x3023
#define ID_WIZNEXT                      0x3024
#define ID_WIZFINISH                    0x3025
#define AFX_IDC_TAB_CONTROL             0x3020

/////////////////////////////////////////////////////////////////////////////
// IDRs for standard components

#ifndef RC_INVOKED  // code only
// These are really COMMDLG dialogs, so there usually isn't a resource
// for them, but these IDs are used as help IDs.
#define AFX_IDD_FILEOPEN                28676
#define AFX_IDD_FILESAVE                28677
#define AFX_IDD_FONT                    28678
#define AFX_IDD_COLOR                   28679
#define AFX_IDD_PRINT                   28680
#define AFX_IDD_PRINTSETUP              28681
#define AFX_IDD_FIND                    28682
#define AFX_IDD_REPLACE                 28683
#endif //!RC_INVOKED

// Standard dialogs app should leave alone (0x7801->)
#define AFX_IDD_NEWTYPEDLG              30721
#define AFX_IDD_PRINTDLG                30722
#define AFX_IDD_PREVIEW_TOOLBAR         30723

// Dialogs defined for OLE2UI library
#define AFX_IDD_INSERTOBJECT            30724
#define AFX_IDD_CHANGEICON              30725
#define AFX_IDD_CONVERT                 30726
#define AFX_IDD_PASTESPECIAL            30727
#define AFX_IDD_EDITLINKS               30728
#define AFX_IDD_FILEBROWSE              30729
#define AFX_IDD_BUSY                    30730

#define AFX_IDD_OBJECTPROPERTIES        30732
#define AFX_IDD_CHANGESOURCE            30733

// Standard cursors (0x7901->)
	// AFX_IDC = Cursor resources
#define AFX_IDC_CONTEXTHELP             30977       // context sensitive help
#define AFX_IDC_MAGNIFY                 30978       // print preview zoom
#define AFX_IDC_SMALLARROWS             30979       // splitter
#define AFX_IDC_HSPLITBAR               30980       // splitter
#define AFX_IDC_VSPLITBAR               30981       // splitter
#define AFX_IDC_NODROPCRSR              30982       // No Drop Cursor
#define AFX_IDC_TRACKNWSE               30983       // tracker
#define AFX_IDC_TRACKNESW               30984       // tracker
#define AFX_IDC_TRACKNS                 30985       // tracker
#define AFX_IDC_TRACKWE                 30986       // tracker
#define AFX_IDC_TRACK4WAY               30987       // tracker
#define AFX_IDC_MOVE4WAY                30988       // resize bar (server only)

// Mini frame window bitmap ID
#define AFX_IDB_MINIFRAME_MENU          30994

// CheckListBox checks bitmap ID
#define AFX_IDB_CHECKLISTBOX_NT         30995
#define AFX_IDB_CHECKLISTBOX_95         30996

// AFX standard accelerator resources
#define AFX_IDR_PREVIEW_ACCEL           30997

// AFX standard ICON IDs (for MFC V1 apps) (0x7A01->)
#define AFX_IDI_STD_MDIFRAME            31233
#define AFX_IDI_STD_FRAME               31234

/////////////////////////////////////////////////////////////////////////////
// AFX OLE control implementation - control IDs (AFX_IDC)

// Font property page
#define AFX_IDC_FONTPROP                1000
#define AFX_IDC_FONTNAMES               1001
#define AFX_IDC_FONTSTYLES              1002
#define AFX_IDC_FONTSIZES               1003
#define AFX_IDC_STRIKEOUT               1004
#define AFX_IDC_UNDERLINE               1005
#define AFX_IDC_SAMPLEBOX               1006

// Color property page
#define AFX_IDC_COLOR_BLACK             1100
#define AFX_IDC_COLOR_WHITE             1101
#define AFX_IDC_COLOR_RED               1102
#define AFX_IDC_COLOR_GREEN             1103
#define AFX_IDC_COLOR_BLUE              1104
#define AFX_IDC_COLOR_YELLOW            1105
#define AFX_IDC_COLOR_MAGENTA           1106
#define AFX_IDC_COLOR_CYAN              1107
#define AFX_IDC_COLOR_GRAY              1108
#define AFX_IDC_COLOR_LIGHTGRAY         1109
#define AFX_IDC_COLOR_DARKRED           1110
#define AFX_IDC_COLOR_DARKGREEN         1111
#define AFX_IDC_COLOR_DARKBLUE          1112
#define AFX_IDC_COLOR_LIGHTBROWN        1113
#define AFX_IDC_COLOR_DARKMAGENTA       1114
#define AFX_IDC_COLOR_DARKCYAN          1115
#define AFX_IDC_COLORPROP               1116
#define AFX_IDC_SYSTEMCOLORS            1117

// Picture porperty page
#define AFX_IDC_PROPNAME                1201
#define AFX_IDC_PICTURE                 1202
#define AFX_IDC_BROWSE                  1203
#define AFX_IDC_CLEAR                   1204

/////////////////////////////////////////////////////////////////////////////
// IDRs for OLE control standard components

// Standard propery page dialogs app should leave alone (0x7E01->)
#define AFX_IDD_PROPPAGE_COLOR         32257
#define AFX_IDD_PROPPAGE_FONT          32258
#define AFX_IDD_PROPPAGE_PICTURE       32259

#define AFX_IDB_TRUETYPE               32384

/////////////////////////////////////////////////////////////////////////////
// Standard OLE control strings

// OLE Control page strings
#define AFX_IDS_PROPPAGE_UNKNOWN        0xFE01
#define AFX_IDS_COLOR_DESKTOP           0xFE04
#define AFX_IDS_COLOR_APPWORKSPACE      0xFE05
#define AFX_IDS_COLOR_WNDBACKGND        0xFE06
#define AFX_IDS_COLOR_WNDTEXT           0xFE07
#define AFX_IDS_COLOR_MENUBAR           0xFE08
#define AFX_IDS_COLOR_MENUTEXT          0xFE09
#define AFX_IDS_COLOR_ACTIVEBAR         0xFE0A
#define AFX_IDS_COLOR_INACTIVEBAR       0xFE0B
#define AFX_IDS_COLOR_ACTIVETEXT        0xFE0C
#define AFX_IDS_COLOR_INACTIVETEXT      0xFE0D
#define AFX_IDS_COLOR_ACTIVEBORDER      0xFE0E
#define AFX_IDS_COLOR_INACTIVEBORDER    0xFE0F
#define AFX_IDS_COLOR_WNDFRAME          0xFE10
#define AFX_IDS_COLOR_SCROLLBARS        0xFE11
#define AFX_IDS_COLOR_BTNFACE           0xFE12
#define AFX_IDS_COLOR_BTNSHADOW         0xFE13
#define AFX_IDS_COLOR_BTNTEXT           0xFE14
#define AFX_IDS_COLOR_BTNHIGHLIGHT      0xFE15
#define AFX_IDS_COLOR_DISABLEDTEXT      0xFE16
#define AFX_IDS_COLOR_HIGHLIGHT         0xFE17
#define AFX_IDS_COLOR_HIGHLIGHTTEXT     0xFE18
#define AFX_IDS_REGULAR                 0xFE19
#define AFX_IDS_BOLD                    0xFE1A
#define AFX_IDS_ITALIC                  0xFE1B
#define AFX_IDS_BOLDITALIC              0xFE1C
#define AFX_IDS_SAMPLETEXT              0xFE1D
#define AFX_IDS_DISPLAYSTRING_FONT      0xFE1E
#define AFX_IDS_DISPLAYSTRING_COLOR     0xFE1F
#define AFX_IDS_DISPLAYSTRING_PICTURE   0xFE20
#define AFX_IDS_PICTUREFILTER           0xFE21
#define AFX_IDS_PICTYPE_UNKNOWN         0xFE22
#define AFX_IDS_PICTYPE_NONE            0xFE23
#define AFX_IDS_PICTYPE_BITMAP          0xFE24
#define AFX_IDS_PICTYPE_METAFILE        0xFE25
#define AFX_IDS_PICTYPE_ICON            0xFE26
#define AFX_IDS_COLOR_PPG               0xFE28
#define AFX_IDS_COLOR_PPG_CAPTION       0xFE29
#define AFX_IDS_FONT_PPG                0xFE2A
#define AFX_IDS_FONT_PPG_CAPTION        0xFE2B
#define AFX_IDS_PICTURE_PPG             0xFE2C
#define AFX_IDS_PICTURE_PPG_CAPTION     0xFE2D
#define AFX_IDS_PICTUREBROWSETITLE      0xFE30
#define AFX_IDS_BORDERSTYLE_0           0xFE31
#define AFX_IDS_BORDERSTYLE_1           0xFE32

// OLE Control verb names
#define AFX_IDS_VERB_EDIT               0xFE40
#define AFX_IDS_VERB_PROPERTIES         0xFE41

// OLE Control internal error messages
#define AFX_IDP_PICTURECANTOPEN         0xFE83
#define AFX_IDP_PICTURECANTLOAD         0xFE84
#define AFX_IDP_PICTURETOOLARGE         0xFE85
#define AFX_IDP_PICTUREREADFAILED       0xFE86

// Standard OLE Control error strings
#define AFX_IDP_E_ILLEGALFUNCTIONCALL       0xFEA0
#define AFX_IDP_E_OVERFLOW                  0xFEA1
#define AFX_IDP_E_OUTOFMEMORY               0xFEA2
#define AFX_IDP_E_DIVISIONBYZERO            0xFEA3
#define AFX_IDP_E_OUTOFSTRINGSPACE          0xFEA4
#define AFX_IDP_E_OUTOFSTACKSPACE           0xFEA5
#define AFX_IDP_E_BADFILENAMEORNUMBER       0xFEA6
#define AFX_IDP_E_FILENOTFOUND              0xFEA7
#define AFX_IDP_E_BADFILEMODE               0xFEA8
#define AFX_IDP_E_FILEALREADYOPEN           0xFEA9
#define AFX_IDP_E_DEVICEIOERROR             0xFEAA
#define AFX_IDP_E_FILEALREADYEXISTS         0xFEAB
#define AFX_IDP_E_BADRECORDLENGTH           0xFEAC
#define AFX_IDP_E_DISKFULL                  0xFEAD
#define AFX_IDP_E_BADRECORDNUMBER           0xFEAE
#define AFX_IDP_E_BADFILENAME               0xFEAF
#define AFX_IDP_E_TOOMANYFILES              0xFEB0
#define AFX_IDP_E_DEVICEUNAVAILABLE         0xFEB1
#define AFX_IDP_E_PERMISSIONDENIED          0xFEB2
#define AFX_IDP_E_DISKNOTREADY              0xFEB3
#define AFX_IDP_E_PATHFILEACCESSERROR       0xFEB4
#define AFX_IDP_E_PATHNOTFOUND              0xFEB5
#define AFX_IDP_E_INVALIDPATTERNSTRING      0xFEB6
#define AFX_IDP_E_INVALIDUSEOFNULL          0xFEB7
#define AFX_IDP_E_INVALIDFILEFORMAT         0xFEB8
#define AFX_IDP_E_INVALIDPROPERTYVALUE      0xFEB9
#define AFX_IDP_E_INVALIDPROPERTYARRAYINDEX 0xFEBA
#define AFX_IDP_E_SETNOTSUPPORTEDATRUNTIME  0xFEBB
#define AFX_IDP_E_SETNOTSUPPORTED           0xFEBC
#define AFX_IDP_E_NEEDPROPERTYARRAYINDEX    0xFEBD
#define AFX_IDP_E_SETNOTPERMITTED           0xFEBE
#define AFX_IDP_E_GETNOTSUPPORTEDATRUNTIME  0xFEBF
#define AFX_IDP_E_GETNOTSUPPORTED           0xFEC0
#define AFX_IDP_E_PROPERTYNOTFOUND          0xFEC1
#define AFX_IDP_E_INVALIDCLIPBOARDFORMAT    0xFEC2
#define AFX_IDP_E_INVALIDPICTURE            0xFEC3
#define AFX_IDP_E_PRINTERERROR              0xFEC4
#define AFX_IDP_E_CANTSAVEFILETOTEMP        0xFEC5
#define AFX_IDP_E_SEARCHTEXTNOTFOUND        0xFEC6
#define AFX_IDP_E_REPLACEMENTSTOOLONG       0xFEC7

/////////////////////////////////////////////////////////////////////////////

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#endif //__AFXRES_H__

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\functest\cbitmaps.cpp ===
/******************************Module*Header*******************************\
* Module Name: CBitmaps.cpp
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/
#include "CBitmaps.h"

CBitmaps::CBitmaps(BOOL bRegression)
{
	strcpy(m_szName,"Image : Filters");
	m_bRegression=bRegression;
}

CBitmaps::~CBitmaps()
{
}

void CBitmaps::Draw(Graphics *g)
{
    Bitmap *bitmap = new Bitmap(L"..\\data\\3x3.bmp");

    PointF dest[3]; 

    for(int i=0; i<=InterpolationModeHighQualityBicubic; i++)
    {
        // for all the interpolation modes 

        g->SetInterpolationMode((InterpolationMode)i);

        // simple scale

        dest[0].X = (float)0/1024.0f*TESTAREAWIDTH;
        dest[0].Y = (float)i*100.0f/768.0f*TESTAREAHEIGHT;
        dest[1].X = (float)100/1024.0f*TESTAREAWIDTH;
        dest[1].Y = (float)i*100.0f/768.0f*TESTAREAHEIGHT;
        dest[2].X = (float)0/1024.0f*TESTAREAWIDTH;
        dest[2].Y = (float)(100+i*100.0f)/768.0f*TESTAREAHEIGHT;
        g->DrawImage(bitmap, dest, 3, 0, 0, 3, 3, UnitPixel);

        // rotate 90

        dest[0].X = (float)200/1024.0f*TESTAREAWIDTH;
        dest[0].Y = (float)i*100.0f/768.0f*TESTAREAHEIGHT;
        dest[1].X = (float)200/1024.0f*TESTAREAWIDTH;
        dest[1].Y = (float)(100+i*100.0f)/768.0f*TESTAREAHEIGHT;
        dest[2].X = (float)100/1024.0f*TESTAREAWIDTH;
        dest[2].Y = (float)i*100.0f/768.0f*TESTAREAHEIGHT;
        g->DrawImage(bitmap, dest, 3, 0, 0, 3, 3, UnitPixel);
    
        // rotate 180

        dest[0].X = (float)300/1024.0f*TESTAREAWIDTH;
        dest[0].Y = (float)(100+i*100.0f)/768.0f*TESTAREAHEIGHT;
        dest[1].X = (float)200/1024.0f*TESTAREAWIDTH;
        dest[1].Y = (float)(100+i*100.0f)/768.0f*TESTAREAHEIGHT;
        dest[2].X = (float)300/1024.0f*TESTAREAWIDTH;
        dest[2].Y = (float)i*100.0f/768.0f*TESTAREAHEIGHT;
        g->DrawImage(bitmap, dest, 3, 0, 0, 3, 3, UnitPixel);
        
        // rotate 270

        dest[0].X = (float)300/1024.0f*TESTAREAWIDTH;
        dest[0].Y = (float)(100+i*100.0f)/768.0f*TESTAREAHEIGHT;
        dest[1].X = (float)300/1024.0f*TESTAREAWIDTH;
        dest[1].Y = (float)i*100.0f/768.0f*TESTAREAHEIGHT;
        dest[2].X = (float)400/1024.0f*TESTAREAWIDTH;
        dest[2].Y = (float)(100+i*100.0f)/768.0f*TESTAREAHEIGHT;
        g->DrawImage(bitmap, dest, 3, 0, 0, 3, 3, UnitPixel);
    }

    delete bitmap;

    WCHAR *filename = L"..\\data\\winnt256.bmp";
    bitmap = new Bitmap(filename);

    dest[0].X = (int)(300.0f/450.0f*TESTAREAWIDTH);
    dest[0].Y = (int)(50.0f/450.0f*TESTAREAHEIGHT);
    dest[1].X = (int)(450.0f/450.0f*TESTAREAWIDTH);
    dest[1].Y = (int)(50.0f/450.0f*TESTAREAHEIGHT);
    dest[2].X = (int)(240.0f/450.0f*TESTAREAWIDTH);
    dest[2].Y = (int)(200.0f/450.0f*TESTAREAHEIGHT);
    g->DrawImage(bitmap, &dest[0], 3);

    Image *imageThumb = bitmap->GetThumbnailImage(32, 32);
    RectF thumbRect(
        (int)(220.0f/450.0f*TESTAREAWIDTH), 
        (int)(50.0f/450.0f*TESTAREAHEIGHT), 
        (REAL) imageThumb->GetWidth(), 
        (REAL) imageThumb->GetHeight()
    );
    g->DrawImage(imageThumb, thumbRect);
    delete imageThumb;
    

    g->SetInterpolationMode(InterpolationModeHighQualityBicubic);

    dest[0].X = (int)(300.0f/450.0f*TESTAREAWIDTH);
    dest[0].Y = (int)(250.0f/450.0f*TESTAREAHEIGHT);
    dest[1].X = (int)(450.0f/450.0f*TESTAREAWIDTH);
    dest[1].Y = (int)(250.0f/450.0f*TESTAREAHEIGHT);
    dest[2].X = (int)(300.0f/450.0f*TESTAREAWIDTH);
    dest[2].Y = (int)(400.0f/450.0f*TESTAREAHEIGHT);
    g->DrawImage(bitmap, &dest[0], 3);
    
    delete bitmap;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\functest\cbkgradient.cpp ===
/******************************Module*Header*******************************\
* Module Name: CBKGradient.cpp
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/
#include "CBKGradient.h"
#include "CFuncTest.h"

extern CFuncTest g_FuncTest;

CBKGradient::CBKGradient(BOOL bRegression)
{
	strcpy(m_szName,"BKGradient");
	m_bRegression=bRegression;
}

CBKGradient::~CBKGradient()
{

}

void CBKGradient::Set(Graphics *g)
{
    Color color1b(255, 255, 0, 0);
    Color color2b(128, 0, 0, 255);
	RectF Rect;

	if (!m_bUseSetting)
		return;

	Rect.X=0.0f;
	Rect.Y=0.0f;
	Rect.Width=TESTAREAWIDTH;
	Rect.Height=TESTAREAHEIGHT;

	LinearGradientBrush LinearGrad(Rect, color1b, color2b,//color1b,color1b
                        LinearGradientModeForwardDiagonal);

	g->FillRectangle(&LinearGrad,Rect);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\functest\cbitmaps.h ===
/******************************Module*Header*******************************\
* Module Name: CBitmaps.h
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/

#ifndef __CBITMAPS_H
#define __CBITMAPS_H

#include "CPrimitive.h"

class CBitmaps : public CPrimitive  
{
public:
	CBitmaps(BOOL bRegression);
	virtual ~CBitmaps();

	void Draw(Graphics *g);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\functest\cbkgradient.h ===
/******************************Module*Header*******************************\
* Module Name: CBKGradient.h
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/

#ifndef __CBKGRADIENT_H
#define __CBKGRADIENT_H

#include "CSetting.h"

class CBKGradient : public CSetting  
{
public:
	CBKGradient(BOOL bRegression);
	virtual ~CBKGradient();

	void Set(Graphics *g);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\functest\ccachedbitmap.cpp ===
/******************************Module*Header*******************************\
* Module Name: CCachedBitmap.cpp
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  06-01-2000 - Adrian Secchia [asecchia]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/
#include "CCachedBitmap.h"

int PrimeNumbers[1000] = {
      2,     3,     5,     7,    11,    13,    17,    19,    23,    29,
     31,    37,    41,    43,    47,    53,    59,    61,    67,    71,
     73,    79,    83,    89,    97,   101,   103,   107,   109,   113,
    127,   131,   137,   139,   149,   151,   157,   163,   167,   173,
    179,   181,   191,   193,   197,   199,   211,   223,   227,   229,
    233,   239,   241,   251,   257,   263,   269,   271,   277,   281,
    283,   293,   307,   311,   313,   317,   331,   337,   347,   349,
    353,   359,   367,   373,   379,   383,   389,   397,   401,   409,
    419,   421,   431,   433,   439,   443,   449,   457,   461,   463,
    467,   479,   487,   491,   499,   503,   509,   521,   523,   541,
    547,   557,   563,   569,   571,   577,   587,   593,   599,   601,
    607,   613,   617,   619,   631,   641,   643,   647,   653,   659,
    661,   673,   677,   683,   691,   701,   709,   719,   727,   733,
    739,   743,   751,   757,   761,   769,   773,   787,   797,   809,
    811,   821,   823,   827,   829,   839,   853,   857,   859,   863,
    877,   881,   883,   887,   907,   911,   919,   929,   937,   941,
    947,   953,   967,   971,   977,   983,   991,   997,  1009,  1013,
   1019,  1021,  1031,  1033,  1039,  1049,  1051,  1061,  1063,  1069,
   1087,  1091,  1093,  1097,  1103,  1109,  1117,  1123,  1129,  1151,
   1153,  1163,  1171,  1181,  1187,  1193,  1201,  1213,  1217,  1223,
   1229,  1231,  1237,  1249,  1259,  1277,  1279,  1283,  1289,  1291,
   1297,  1301,  1303,  1307,  1319,  1321,  1327,  1361,  1367,  1373,
   1381,  1399,  1409,  1423,  1427,  1429,  1433,  1439,  1447,  1451,
   1453,  1459,  1471,  1481,  1483,  1487,  1489,  1493,  1499,  1511,
   1523,  1531,  1543,  1549,  1553,  1559,  1567,  1571,  1579,  1583,
   1597,  1601,  1607,  1609,  1613,  1619,  1621,  1627,  1637,  1657,
   1663,  1667,  1669,  1693,  1697,  1699,  1709,  1721,  1723,  1733,
   1741,  1747,  1753,  1759,  1777,  1783,  1787,  1789,  1801,  1811,
   1823,  1831,  1847,  1861,  1867,  1871,  1873,  1877,  1879,  1889,
   1901,  1907,  1913,  1931,  1933,  1949,  1951,  1973,  1979,  1987,
   1993,  1997,  1999,  2003,  2011,  2017,  2027,  2029,  2039,  2053,
   2063,  2069,  2081,  2083,  2087,  2089,  2099,  2111,  2113,  2129,
   2131,  2137,  2141,  2143,  2153,  2161,  2179,  2203,  2207,  2213,
   2221,  2237,  2239,  2243,  2251,  2267,  2269,  2273,  2281,  2287,
   2293,  2297,  2309,  2311,  2333,  2339,  2341,  2347,  2351,  2357,
   2371,  2377,  2381,  2383,  2389,  2393,  2399,  2411,  2417,  2423,
   2437,  2441,  2447,  2459,  2467,  2473,  2477,  2503,  2521,  2531,
   2539,  2543,  2549,  2551,  2557,  2579,  2591,  2593,  2609,  2617,
   2621,  2633,  2647,  2657,  2659,  2663,  2671,  2677,  2683,  2687,
   2689,  2693,  2699,  2707,  2711,  2713,  2719,  2729,  2731,  2741,
   2749,  2753,  2767,  2777,  2789,  2791,  2797,  2801,  2803,  2819,
   2833,  2837,  2843,  2851,  2857,  2861,  2879,  2887,  2897,  2903,
   2909,  2917,  2927,  2939,  2953,  2957,  2963,  2969,  2971,  2999,
   3001,  3011,  3019,  3023,  3037,  3041,  3049,  3061,  3067,  3079,
   3083,  3089,  3109,  3119,  3121,  3137,  3163,  3167,  3169,  3181,
   3187,  3191,  3203,  3209,  3217,  3221,  3229,  3251,  3253,  3257,
   3259,  3271,  3299,  3301,  3307,  3313,  3319,  3323,  3329,  3331,
   3343,  3347,  3359,  3361,  3371,  3373,  3389,  3391,  3407,  3413,
   3433,  3449,  3457,  3461,  3463,  3467,  3469,  3491,  3499,  3511,
   3517,  3527,  3529,  3533,  3539,  3541,  3547,  3557,  3559,  3571,
   3581,  3583,  3593,  3607,  3613,  3617,  3623,  3631,  3637,  3643,
   3659,  3671,  3673,  3677,  3691,  3697,  3701,  3709,  3719,  3727,
   3733,  3739,  3761,  3767,  3769,  3779,  3793,  3797,  3803,  3821,
   3823,  3833,  3847,  3851,  3853,  3863,  3877,  3881,  3889,  3907,
   3911,  3917,  3919,  3923,  3929,  3931,  3943,  3947,  3967,  3989,
   4001,  4003,  4007,  4013,  4019,  4021,  4027,  4049,  4051,  4057,
   4073,  4079,  4091,  4093,  4099,  4111,  4127,  4129,  4133,  4139,
   4153,  4157,  4159,  4177,  4201,  4211,  4217,  4219,  4229,  4231,
   4241,  4243,  4253,  4259,  4261,  4271,  4273,  4283,  4289,  4297,
   4327,  4337,  4339,  4349,  4357,  4363,  4373,  4391,  4397,  4409,
   4421,  4423,  4441,  4447,  4451,  4457,  4463,  4481,  4483,  4493,
   4507,  4513,  4517,  4519,  4523,  4547,  4549,  4561,  4567,  4583,
   4591,  4597,  4603,  4621,  4637,  4639,  4643,  4649,  4651,  4657,
   4663,  4673,  4679,  4691,  4703,  4721,  4723,  4729,  4733,  4751,
   4759,  4783,  4787,  4789,  4793,  4799,  4801,  4813,  4817,  4831,
   4861,  4871,  4877,  4889,  4903,  4909,  4919,  4931,  4933,  4937,
   4943,  4951,  4957,  4967,  4969,  4973,  4987,  4993,  4999,  5003,
   5009,  5011,  5021,  5023,  5039,  5051,  5059,  5077,  5081,  5087,
   5099,  5101,  5107,  5113,  5119,  5147,  5153,  5167,  5171,  5179,
   5189,  5197,  5209,  5227,  5231,  5233,  5237,  5261,  5273,  5279,
   5281,  5297,  5303,  5309,  5323,  5333,  5347,  5351,  5381,  5387,
   5393,  5399,  5407,  5413,  5417,  5419,  5431,  5437,  5441,  5443,
   5449,  5471,  5477,  5479,  5483,  5501,  5503,  5507,  5519,  5521,
   5527,  5531,  5557,  5563,  5569,  5573,  5581,  5591,  5623,  5639,
   5641,  5647,  5651,  5653,  5657,  5659,  5669,  5683,  5689,  5693,
   5701,  5711,  5717,  5737,  5741,  5743,  5749,  5779,  5783,  5791,
   5801,  5807,  5813,  5821,  5827,  5839,  5843,  5849,  5851,  5857,
   5861,  5867,  5869,  5879,  5881,  5897,  5903,  5923,  5927,  5939,
   5953,  5981,  5987,  6007,  6011,  6029,  6037,  6043,  6047,  6053,
   6067,  6073,  6079,  6089,  6091,  6101,  6113,  6121,  6131,  6133,
   6143,  6151,  6163,  6173,  6197,  6199,  6203,  6211,  6217,  6221,
   6229,  6247,  6257,  6263,  6269,  6271,  6277,  6287,  6299,  6301,
   6311,  6317,  6323,  6329,  6337,  6343,  6353,  6359,  6361,  6367,
   6373,  6379,  6389,  6397,  6421,  6427,  6449,  6451,  6469,  6473,
   6481,  6491,  6521,  6529,  6547,  6551,  6553,  6563,  6569,  6571,
   6577,  6581,  6599,  6607,  6619,  6637,  6653,  6659,  6661,  6673,
   6679,  6689,  6691,  6701,  6703,  6709,  6719,  6733,  6737,  6761,
   6763,  6779,  6781,  6791,  6793,  6803,  6823,  6827,  6829,  6833,
   6841,  6857,  6863,  6869,  6871,  6883,  6899,  6907,  6911,  6917,
   6947,  6949,  6959,  6961,  6967,  6971,  6977,  6983,  6991,  6997,
   7001,  7013,  7019,  7027,  7039,  7043,  7057,  7069,  7079,  7103,
   7109,  7121,  7127,  7129,  7151,  7159,  7177,  7187,  7193,  7207,
   7211,  7213,  7219,  7229,  7237,  7243,  7247,  7253,  7283,  7297,
   7307,  7309,  7321,  7331,  7333,  7349,  7351,  7369,  7393,  7411,
   7417,  7433,  7451,  7457,  7459,  7477,  7481,  7487,  7489,  7499,
   7507,  7517,  7523,  7529,  7537,  7541,  7547,  7549,  7559,  7561,
   7573,  7577,  7583,  7589,  7591,  7603,  7607,  7621,  7639,  7643,
   7649,  7669,  7673,  7681,  7687,  7691,  7699,  7703,  7717,  7723,
   7727,  7741,  7753,  7757,  7759,  7789,  7793,  7817,  7823,  7829,
   7841,  7853,  7867,  7873,  7877,  7879,  7883,  7901,  7907,  7919
};


//
// Greatest Common Factor
// Example: 24=2.2.2.3 20=2.2.5 gcf(24,20)=4=2.2
//

int gcf(int a, int b) {
  int gcftot=1;
  int minab = min(a,b);
  int limit = (int) sqrt((float)minab);
  int pf;

  int i=0;
  pf = PrimeNumbers[i];
  do {
    if( (a % pf == 0) &&                 //does this prime number divide into
        (b % pf == 0) ) {                //what we have left?
      a /= pf;                           //remove this common factor
      b /= pf;
      gcftot *= pf;                      //remember this common factor
    } else {
      pf = PrimeNumbers[++i];            //start on the next prime number
    }
  } while ((i<1000) && (pf<=limit));

  return gcftot;
}


CCachedBitmap::CCachedBitmap(BOOL bRegression)
{
	strcpy(m_szName,"Image : CachedBitmap");
	m_bRegression=bRegression;
}

CCachedBitmap::~CCachedBitmap()
{
}

void CCachedBitmap::Draw(Graphics *g)
{
    Bitmap *image = new Bitmap(L"..\\Data\\winnt256.bmp");

    // Create a 32bpp premultiplied surface to composite drawing
    // so we can initialize the CachedBitmap.

    Bitmap *bmp = new Bitmap(
        (INT)(TESTAREAWIDTH/4), 
        (INT)(TESTAREAHEIGHT/4), 
        PixelFormat32bppPARGB
    );
    
    // Compute the size of the source image.

    Unit u;
    RectF s;
    image->GetBounds(&s, &u);
    
    // Size of the destination image (compositing buffer).

    RectF d(
        0, 0, 
        (INT)(TESTAREAWIDTH/4), 
        (INT)(TESTAREAHEIGHT/4)
    );

    PointF dp[3];
    dp[0].X = 0;
    dp[0].Y = d.Height/2;
    dp[1].X = d.Width/2;
    dp[1].Y = 0;
    dp[2].X = d.Width/2;
    dp[2].Y = d.Height;

    // Wrap a graphics around our compositing buffer image and set
    // the interpolation mode.

    Graphics *gbmp = new Graphics(bmp);
    gbmp->SetInterpolationMode(InterpolationModeHighQualityBicubic);

    // Initialize the bits in the compositing buffer.

    gbmp->DrawImage(
        image, 
        dp, 3, s.X, s.Y, 
        s.Width, s.Height,
        UnitPixel
    );

    // Initialize the CachedBitmap with the compositing buffer.

    CachedBitmap *cb = new CachedBitmap(bmp, g);
    
    delete gbmp;
    delete bmp;
    
    #define _2PI 2*3.141592653689
    

    // These are the a and b coefficients for the hypocycloid

    int a = 52;
    int b = 42;

    // Compute the center point for the cycle.

    float fXo=(TESTAREAWIDTH-d.Width)/2;
    float fYo=(TESTAREAHEIGHT-d.Height)/2;
    
    float ScaleX = fXo/( (a>b)?a:a+b );
    float ScaleY = fYo/( (a>b)?a:a+b );


    int cycle=b/gcf(a,b);    //number of times round the outer circle
    int Num = cycle*10;

    // Draw the bitmaps tracking the cycloid path.

    for(int i=0; i<Num; i++) {
      float t = (float)(cycle*_2PI*i/Num);
      g->DrawCachedBitmap(
          cb,
          (INT)(fXo+ScaleX*((a-b)*cos(t)+b*cos((a-b)*t/b))),
          (INT)(fYo+ScaleY*((a-b)*sin(t)-b*sin((a-b)*t/b)))
      );
    }

    #undef _2PI

    delete cb;
    delete image;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\functest\ccompoundlines.cpp ===
/******************************Module*Header*******************************\
* Module Name: CCompoundLines.cpp
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/
#include "CCompoundLines.h"

CCompoundLines::CCompoundLines(BOOL bRegression)
{
	strcpy(m_szName,"Lines : Compound");
	m_bRegression=bRegression;
}

CCompoundLines::~CCompoundLines()
{
}

void CCompoundLines::Draw(Graphics *g)
{
    REAL width = 4;         // Pen width
    PointF points[4];

    points[0].X = 100.0f/280.0f*TESTAREAWIDTH;
    points[0].Y = 50.0f/280.0f*TESTAREAHEIGHT;
    points[1].X = -50.0f/280.0f*TESTAREAWIDTH;
    points[1].Y = 190.0f/280.0f*TESTAREAHEIGHT;
    points[2].X = 150.0f/280.0f*TESTAREAWIDTH;
    points[2].Y = 320.0f/280.0f*TESTAREAHEIGHT;
    points[3].X = 200.0f/280.0f*TESTAREAWIDTH;
    points[3].Y = 110.0f/280.0f*TESTAREAHEIGHT;

    Color yellowColor(128, 255, 255, 0);
    SolidBrush yellowBrush(yellowColor);

    GraphicsPath* path = new GraphicsPath(FillModeAlternate);
    path->AddBeziers(points, 4);

    points[0].X = 260.0f/280.0f*TESTAREAWIDTH;
    points[0].Y = 20.0f/280.0f*TESTAREAHEIGHT;
    path->AddLines(points, 1);
    Matrix matrix;
//    matrix.Scale(1.25, 1.25);
//    matrix.Translate(30.0f/1024.0f*TESTAREAWIDTH, 30.0f/768.0f*TESTAREAHEIGHT);

    // If you wanto to flatten the path before rendering,
    // Flatten() can be called.

    BOOL flattenFirst = FALSE;

    if(!flattenFirst)
    {
        // Don't flatten and keep the original path.
        // FillPath or DrawPath will flatten the path automatically
        // without modifying the original path.

        path->Transform(&matrix);
    }
    else
    {
        // Flatten this path.  The resultant path is made of line
        // segments.  The original path information is lost.

        path->Flatten(&matrix);
    }

    Color blackColor(0, 0, 0);

    SolidBrush blackBrush(blackColor);
    width = 3;
    Pen blackPen(&blackBrush, width);

    REAL* compoundArray = new REAL[6];
    compoundArray[0] = 0.0f;
    compoundArray[1] = 0.2f;
    compoundArray[2] = 0.4f;
    compoundArray[3] = 0.6f;
    compoundArray[4] = 0.8f;
    compoundArray[5] = 1.0f;
    blackPen.SetCompoundArray(&compoundArray[0], 6);
    blackPen.SetDashStyle(DashStyleDash);

    blackPen.SetStartCap(LineCapDiamondAnchor);    
    blackPen.SetEndCap(LineCapArrowAnchor);

    g->FillPath(&yellowBrush, path);
    g->DrawPath(&blackPen, path);
    delete path;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\functest\ccachedbitmap.h ===
/******************************Module*Header*******************************\
* Module Name: CCachedBitmap.h
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  06-01-2000 - Adrian Secchia [asecchia]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/

#ifndef __CCACHEDBITMAP_H
#define __CCACHEDBITMAP_H

#include "CPrimitive.h"

class CCachedBitmap : public CPrimitive  
{
public:
	CCachedBitmap(BOOL bRegression);
	virtual ~CCachedBitmap();

	void Draw(Graphics *g);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\functest\cchecker.h ===
/******************************Module*Header*******************************\
* Module Name: CChecker.h
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/

#ifndef __CCHECKER_H
#define __CCHECKER_H

#include "CSetting.h"

class CChecker : public CSetting  
{
public:
	CChecker(BOOL bRegression);
	virtual ~CChecker();

	BOOL Init();
	void Set(Graphics *g);

	Region *m_paRegion;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\functest\cchecker.cpp ===
/******************************Module*Header*******************************\
* Module Name: CChecker.cpp
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/
#include "CChecker.h"
#include "CFuncTest.h"

extern CFuncTest g_FuncTest;

CChecker::CChecker(BOOL bRegression)
{
	strcpy(m_szName,"Checker");
	m_bRegression=bRegression;
	m_paRegion=NULL;
}

CChecker::~CChecker()
{
	if (m_paRegion!=NULL) {
		delete m_paRegion;
		m_paRegion=NULL;
	}
}

BOOL CChecker::Init()
{
    // Create clip region pattern
    m_paRegion=new Region();

	return CSetting::Init();
}

void CChecker::Set(Graphics *g)
{
	int cCheckerMax=0;
	int nCheckerSize=64;
	Matrix mat;

	g->ResetClip();
	if (!m_bUseSetting)
		return;

    m_paRegion->MakeInfinite();

    Rect horzRect(0, 0, (int)TESTAREAWIDTH, nCheckerSize);
    Rect vertRect(0, 0, nCheckerSize, (int)TESTAREAHEIGHT);
    Region *horzRegion = new Region(horzRect);
    Region *vertRegion = new Region(vertRect);

	if (TESTAREAWIDTH>TESTAREAHEIGHT)
		cCheckerMax=(int)TESTAREAWIDTH/nCheckerSize*2+1;
	else
		cCheckerMax=(int)TESTAREAHEIGHT/nCheckerSize*2+1;

    for (INT i = 0; i < 5; i++)
    {   
        m_paRegion->Xor(horzRegion);
        m_paRegion->Xor(vertRegion);
        horzRegion->Translate(0, nCheckerSize*2);
        vertRegion->Translate(nCheckerSize*2, 0);
    }
    delete horzRegion;
    delete vertRegion;

	g->SetClip(m_paRegion);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\functest\ccompoundlines.h ===
/******************************Module*Header*******************************\
* Module Name: CCompoundLines.h
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/

#ifndef __CCOMPOUNDLINES_H
#define __CCOMPOUNDLINES_H

#include "CPrimitive.h"

class CCompoundLines : public CPrimitive  
{
public:
	CCompoundLines(BOOL bRegression);
	virtual ~CCompoundLines();

	void Draw(Graphics *g);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\functest\ccontainer.cpp ===
/******************************Module*Header*******************************\
* Module Name: CContainer.cpp
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/
#include "CContainer.h"

#define ROOT    0
#define LEFT    1
#define RIGHT   2
#define TOP     3
#define BOTTOM  4

CContainer::CContainer(BOOL bRegression)
{
	strcpy(m_szName,"Container");
	m_circlePath=NULL;
	m_circleRect.X=0;
	m_circleRect.Y=0;
	m_circleRect.Width=(int)(TESTAREAWIDTH/4.0f);
	m_circleRect.Height=(int)(TESTAREAHEIGHT/4.0f);
	m_bRegression=bRegression;
}

CContainer::~CContainer()
{
}

void CContainer::Draw(Graphics *g)
{
    m_circlePath = new GraphicsPath;
    m_circlePath->AddEllipse(m_circleRect);

    // !!! [agodfrey] Question: If I add the next line, why do I get no output?
    // m_circlePath->AddEllipse(m_circleRect);
    
    INT id = g->Save();
    g->TranslateTransform((int)(TESTAREAWIDTH/4.0f), (int)(TESTAREAHEIGHT/4.0f));
    DrawFractal(g, 245, ROOT, 8);
    g->Restore(id);
    delete m_circlePath;
}

void CContainer::DrawFractal(Graphics * g, BYTE gray, INT side, INT count)
{
    ARGB        argb;

    switch (count % 3)
    {
    case 0:
        argb = Color::MakeARGB(255, 0, 0, gray);
        break;
    case 1:
        argb = Color::MakeARGB(255, 0, gray, 0);
        break;
    case 2:
        argb = Color::MakeARGB(255, gray, 0, 0);
        gray -= 60;
        break;
    }
    Color   color(argb);
    SolidBrush contBrush(color);
    g->SetPageUnit(UnitPixel);
    g->FillPath(&contBrush, m_circlePath);
    
    if (--count == 0)
    {
        return;
    }

    Rect               destRect;
    GraphicsContainer  cstate;

    if (side != LEFT)
    {
        destRect = Rect((int)(TESTAREAWIDTH/4.0f), (int)(TESTAREAHEIGHT/16.0f), (int)(TESTAREAWIDTH/8.0f), (int)(TESTAREAHEIGHT/8.0f));
        cstate = g->BeginContainer(destRect, m_circleRect, UnitPixel);
        g->SetSmoothingMode(SmoothingModeAntiAlias);
        DrawFractal(g, gray, RIGHT, count);
        g->EndContainer(cstate);
    }
    if (side != TOP)
    {
        destRect = Rect((int)(TESTAREAWIDTH/16.0f), (int)(TESTAREAHEIGHT/4.0f), (int)(TESTAREAWIDTH/8.0f), (int)(TESTAREAHEIGHT/8.0f));
        cstate = g->BeginContainer(destRect, m_circleRect, UnitPixel);
        g->SetSmoothingMode(SmoothingModeNone);
        DrawFractal(g, gray, BOTTOM, count);
        g->EndContainer(cstate);
    }
    if (side != RIGHT)
    {
        destRect = Rect(-(int)(TESTAREAWIDTH/8.0f), (int)(TESTAREAHEIGHT/16.0f), (int)(TESTAREAWIDTH/8.0f), (int)(TESTAREAHEIGHT/8.0f));
        cstate = g->BeginContainer(destRect, m_circleRect, UnitPixel);
        g->SetSmoothingMode(SmoothingModeAntiAlias);
        DrawFractal(g, gray, LEFT, count);
        g->EndContainer(cstate);
    }
    if (side != BOTTOM)
    {
        destRect = Rect((int)(TESTAREAWIDTH/16.0f), -(int)(TESTAREAHEIGHT/8.0f), (int)(TESTAREAWIDTH/8.0f), (int)(TESTAREAHEIGHT/8.0f));
        cstate = g->BeginContainer(destRect, m_circleRect, UnitPixel);
        g->SetSmoothingMode(SmoothingModeNone);
        DrawFractal(g, gray, TOP, count);
        g->EndContainer(cstate);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\functest\ccontainer.h ===
/******************************Module*Header*******************************\
* Module Name: CContainer.h
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/

#ifndef __CCONTAINER_H
#define __CCONTAINER_H

#include "CPrimitive.h"

class CContainer : public CPrimitive  
{
public:
	CContainer(BOOL bRegression);
	virtual ~CContainer();

	void Draw(Graphics *g);
	void DrawFractal(Graphics * g, BYTE gray, INT side, INT count);

	GraphicsPath *m_circlePath;
	Rect m_circleRect;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\functest\ccontainerclip.cpp ===
/******************************Module*Header*******************************\
* Module Name: CContainerClip.cpp
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/
#include "CContainerClip.h"

CContainerClip::CContainerClip(BOOL bRegression)
{
	strcpy(m_szName,"ContainerClip");
	m_bRegression=bRegression;
}

CContainerClip::~CContainerClip()
{
}

void CContainerClip::Draw(Graphics *g)
{
    ARGB     colors[5];
    
    colors[0] = Color::MakeARGB(255, 255, 0, 0);
    colors[1] = Color::MakeARGB(255, 0, 255, 0);
    colors[2] = Color::MakeARGB(255, 0, 0, 255);
    colors[3] = Color::MakeARGB(255, 255, 255, 0);
    colors[4] = Color::MakeARGB(255, 0, 255, 255);

    GraphicsState s = g->Save();
    DrawContainer(g, colors, 5);
    g->Restore(s);
}

VOID CContainerClip::DrawContainer(Graphics * g, ARGB * argb, INT count)
{
    Matrix    mymatrix;
	int nX;
	int nY;

    g->SetPageUnit(UnitPixel);

	g->GetTransform(&mymatrix);
	nX=(int)mymatrix.OffsetX();
	nY=(int)mymatrix.OffsetY();

    Rect clipRect(0,0,(int)TESTAREAWIDTH, (int)TESTAREAHEIGHT);
    g->SetClip(clipRect);

    mymatrix.Translate((int)(TESTAREAWIDTH/2.0f), (int)(TESTAREAHEIGHT/2.0f));
    mymatrix.Rotate(15);
    mymatrix.Translate(-(int)(TESTAREAWIDTH/2.0f), -(int)(TESTAREAHEIGHT/2.0f));
    g->SetTransform(&mymatrix);

    Color   color(*argb++); 
    SolidBrush contBrush(color);
    g->FillRectangle(&contBrush, 0, 0, (int)TESTAREAWIDTH, (int)TESTAREAHEIGHT);
    if (--count == 0)
    {
        return;
    }
    RectF     destRect((int)(TESTAREAWIDTH/10.0f), (int)(TESTAREAHEIGHT/10.0f), (int)(TESTAREAWIDTH/1.25f), (int)(TESTAREAHEIGHT/1.25f));
    RectF     srcRect(0, 0, (int)TESTAREAWIDTH, (int)TESTAREAHEIGHT);
    INT id = g->BeginContainer(destRect, srcRect, UnitPixel);
    g->ResetClip();
    DrawContainer (g, argb, count);
    g->EndContainer(id);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\functest\ccontainerclip.h ===
/******************************Module*Header*******************************\
* Module Name: CContainerClip.h
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/

#ifndef __CCONTAINERCLIP_H
#define __CCONTAINERCLIP_H

#include "CPrimitive.h"

class CContainerClip : public CPrimitive  
{
public:
	CContainerClip(BOOL bRegression);
	virtual ~CContainerClip();

	void Draw(Graphics *g);

	void DrawContainer(Graphics * g, ARGB * argb, INT count);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\functest\cdashes.cpp ===
/******************************Module*Header*******************************\
* Module Name: CDashes.cpp
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/
#include "CDashes.h"

CDashes::CDashes(BOOL bRegression)
{
	strcpy(m_szName,"Lines : Dash, Misc");
	m_bRegression=bRegression;
}

CDashes::~CDashes()
{
}

void CDashes::Draw(Graphics *g)
{
/*
    REAL width = 4;         // Pen width
    PointF points[4];

    points[0].X = 100;
    points[0].Y = 10;
    points[1].X = -50;
    points[1].Y = 50;
    points[2].X = 150;
    points[2].Y = 200;
    points[3].X = 200;
    points[3].Y = 70;

    Color yellowColor(128, 255, 255, 0);
    SolidBrush yellowBrush(yellowColor);

    GraphicsPath* path = new GraphicsPath(FillModeAlternate);
    path->AddBeziers(points, 4);
    Matrix matrix;
    matrix.Scale(1.5, 1.5);

    path->Transform(&matrix);

    Color blackColor(0, 0, 0);
    SolidBrush blackBrush(blackColor);
    
    // Set the pen width in inch.
    width = (REAL) 0.2;
    Pen pen1(&blackBrush, width, UnitInch);
    pen1.SetDashStyle(DashStyleDashDotDot);
    pen1.SetDashCap(LineCapRound);
    g->DrawPath(&pen1, path);

    // Create a multiple segment with a closed segment.
    points[0].X = 50;
    points[0].Y = 50;
    points[1].X = 100;
    points[1].Y = 50;
    points[2].X = 120;
    points[2].Y = 120;
    points[3].X = 50;
    points[3].Y = 100;    

    path->Reset();
    path->AddLines(points, 4);
    path->CloseFigure();

    points[0].X = 150;
    points[0].Y = 60;
    points[1].X = 200;
    points[1].Y = 150;
    path->AddLines(points, 2);
    path->Transform(&matrix);

    Color blueColor(128, 0, 0, 255);

    SolidBrush blueBrush(blueColor);

    width = 5;
    Pen pen2(&blueBrush, width);
    pen2.SetDashStyle(DashStyleDashDotDot);
    g->DrawPath(&pen2, path);

    delete path;
*/
    float factor = 100.0f/g->GetDpiX(); //g->GetDpiX()/100.0f;
  
    // Test GDI punting on pen drawing.
    Color col0(0xff,0x80,0x80,0x80);
    Color col1(0xff,0x80,0,0);
    Color col2(0xff,0,0x80,0);
    Color col3(0xff,0,0,0x80);

    Pen pen0a(col0, factor*1.0f);   // Basic PS_COSMETIC, solid pen
    Pen pen0b(col0, 2.0f);   // Basic PS_GEOMETRIC, solid pen

    // PS_COSMETIC with LINE CAP + MITER JOIN + DASH STYLE
    Pen pen1a(col1, factor*1.0f);
    pen1a.SetLineCap(LineCapFlat, LineCapFlat, DashCapFlat);
    pen1a.SetLineJoin(LineJoinMiter); 
    pen1a.SetMiterLimit(4.0f);
    pen1a.SetDashStyle(DashStyleDot);
    
    // PS_GEOMETRIC with LINE CAP + MITER JOIN + DASH STYLE
    Pen pen1b(col1, 2.0f);
    pen1b.SetLineCap(LineCapRound, LineCapRound, DashCapRound);
    pen1b.SetLineJoin(LineJoinMiter);
    pen1b.SetMiterLimit(4.0f);
    pen1b.SetDashStyle(DashStyleDashDotDot);

    // PS_COSMETIC + LINE CAP + BEVEL JOIN + DASH STYLE
    Pen pen2a(col2, factor*1.0f);
    pen2a.SetLineCap(LineCapArrowAnchor, LineCapArrowAnchor, DashCapFlat);
    pen2a.SetLineJoin(LineJoinBevel);
    pen2a.SetDashStyle(DashStyleDash);

    // PS_GEOMETRIC + LINE CAP + BEVEL JOIN + DASH STYLE
    Pen pen2b(col2, 2.0f);
    pen2b.SetLineCap(LineCapSquare, LineCapSquare, DashCapFlat);
    pen2b.SetLineJoin(LineJoinRound);
//    pen2b.SetDashStyle(DashStyleDot);
    pen2b.SetDashStyle(DashStyleDashDot);

    // PS_GEOMETRIC + SOLID LINE + FLAT CAP + BEVEL JOIN
    Pen pen3(col1, 2.0f);
    pen3.SetLineCap(LineCapFlat, LineCapFlat, DashCapFlat);
    pen3.SetLineJoin(LineJoinBevel);

    // PS_GEOMETRIC + SOLID LINE + SQUARE CAP + MITER JOIN (LIMIT 10 - NON RECTANGLE)
    Pen pen3b(col1, 2.0f);
    pen3b.SetLineCap(LineCapSquare, LineCapSquare, DashCapFlat);
    pen3b.SetLineJoin(LineJoinMiter);
    pen3b.SetMiterLimit(4.4f);

    // PS_GEOMETRIC + SOLID LINE + ROUND CAP + MITER JOIN (NON RECTANGLE)
    Pen pen3c(col1, 2.0f);
    pen3c.SetLineCap(LineCapRound, LineCapRound, DashCapRound);
    pen3c.SetLineJoin(LineJoinMiter);
    pen3c.SetMiterLimit(0.75f);

    g->SetPageScale(1.0f);

//    Matrix m;
//    m.Reset();
//    g->SetTransform(&m);

    g->DrawRectangle(&pen0a, (int)(100.0f/600.0f*TESTAREAWIDTH), (int)(100.0f/600.0f*TESTAREAHEIGHT), (int)(100.0f/600.0f*TESTAREAWIDTH), (int)(100.0f/600.0f*TESTAREAHEIGHT));
    g->DrawRectangle(&pen0b, (int)(100.0f/600.0f*TESTAREAWIDTH), (int)(250.0f/600.0f*TESTAREAHEIGHT), (int)(100.0f/600.0f*TESTAREAWIDTH), (int)(100.0f/600.0f*TESTAREAHEIGHT));
    g->DrawRectangle(&pen1a, (int)(250.0f/600.0f*TESTAREAWIDTH), (int)(100.0f/600.0f*TESTAREAHEIGHT), (int)(100.0f/600.0f*TESTAREAWIDTH), (int)(100.0f/600.0f*TESTAREAHEIGHT));
    g->DrawRectangle(&pen1b, (int)(250.0f/600.0f*TESTAREAWIDTH), (int)(250.0f/600.0f*TESTAREAHEIGHT), (int)(100.0f/600.0f*TESTAREAWIDTH), (int)(100.0f/600.0f*TESTAREAHEIGHT));
    g->DrawRectangle(&pen2a, (int)(400.0f/600.0f*TESTAREAWIDTH), (int)(100.0f/600.0f*TESTAREAHEIGHT), (int)(100.0f/600.0f*TESTAREAWIDTH), (int)(100.0f/600.0f*TESTAREAHEIGHT));
    g->DrawRectangle(&pen2b, (int)(400.0f/600.0f*TESTAREAWIDTH), (int)(250.0f/600.0f*TESTAREAHEIGHT), (int)(100.0f/600.0f*TESTAREAWIDTH), (int)(100.0f/600.0f*TESTAREAHEIGHT));
    
    // Alter pens, PS_GEOMETRIC + DOT + ROUND CAP + ROUND JOIN
    pen2b.SetDashStyle(DashStyleDot);
    g->DrawRectangle(&pen2b, (int)(425.0f/600.0f*TESTAREAWIDTH), (int)(275.0f/600.0f*TESTAREAHEIGHT), (int)(50.0f/600.0f*TESTAREAWIDTH), (int)(50.0f/600.0f*TESTAREAHEIGHT));

    INT i;
    Point newPts[4];
    newPts[0].X = (int)(175.0f/600.0f*TESTAREAWIDTH); newPts[0].Y = (int)(400.0f/600.0f*TESTAREAHEIGHT);
    newPts[1].X = (int)(250.0f/600.0f*TESTAREAWIDTH); newPts[1].Y = (int)(450.0f/600.0f*TESTAREAHEIGHT);
    newPts[2].X = (int)(175.0f/600.0f*TESTAREAWIDTH); newPts[2].Y = (int)(500.0f/600.0f*TESTAREAHEIGHT);
    newPts[3].X = (int)(100.0f/600.0f*TESTAREAWIDTH); newPts[3].Y = (int)(450.0f/600.0f*TESTAREAHEIGHT);

    g->DrawPolygon(&pen3, &newPts[0], 4);

    newPts[0].X = (int)(175.0f/600.0f*TESTAREAWIDTH); newPts[0].Y = (int)(400.0f/600.0f*TESTAREAHEIGHT);
    newPts[1].X = (int)(175.0f/600.0f*TESTAREAWIDTH); newPts[1].Y = (int)(500.0f/600.0f*TESTAREAHEIGHT);
    newPts[2].X = (int)(100.0f/600.0f*TESTAREAWIDTH); newPts[2].Y = (int)(425.0f/600.0f*TESTAREAHEIGHT);
    for (i=0; i<3; i++) newPts[i].X += (int)(150.0f/600.0f*TESTAREAWIDTH);
    g->DrawLines(&pen3b, &newPts[0], 3);

    for (i=0; i<3; i++) newPts[i].X += (int)(150.0f/600.0f*TESTAREAWIDTH);
    g->DrawLines(&pen3c, &newPts[0], 3);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\functest\cdashes.h ===
/******************************Module*Header*******************************\
* Module Name: CDashes.h
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/

#ifndef __CDASHES_H
#define __CDASHES_H

#include "CPrimitive.h"

class CDashes : public CPrimitive  
{
public:
	CDashes(BOOL bRegression);
	virtual ~CDashes();

	void Draw(Graphics *g);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\functest\cdash.cpp ===
/**************************************************************************
*
* Copyright (c) 2000 Microsoft Corporation
*
* Module Name:
*
*   <an unabbreviated name for the module (not the filename)>
*
* Abstract:
*
*   <Description of what this module does>
*
* Notes:
*
*   <optional>
*
* Created:
*
*   08/28/2000 asecchia
*      Created it.
*
**************************************************************************/

/**************************************************************************
*
* Function Description:
*
*   <Description of what the function does>
*
* Arguments:
*
*   [<blank> | OUT | IN/OUT] argument-name - description of argument
*   ......
*
* Return Value:
*
*   return-value - description of return value
*   or NONE
*
* Created:
*
*   08/28/2000 asecchia
*      Created it.
*
**************************************************************************/
#include "CDash.hpp"
#include <limits.h>

#ifndef M_PI
#define M_PI 3.1415926536
#endif

CDash::CDash(BOOL bRegression)
{
	strcpy(m_szName,"Lines : Dash Offset");
	m_bRegression=bRegression;
}

void CDash::Draw(Graphics *g)
{
   RectF d(
        0, 
        0, 
        (INT)(TESTAREAWIDTH), 
        (INT)(TESTAREAHEIGHT)
    );

    Pen pen(Color(0xff7f7fff), 10.0f);
    Pen thinPen(Color(0xff000000), 0.0f);

    float dashArray[4] = {
        2.0f, 3.0f
    };

    pen.SetDashPattern(dashArray, 2);

    GraphicsPath *gp;
    
    pen.SetEndCap(LineCapRoundAnchor);
    
    GraphicsPath fez(FillModeWinding);
    fez.AddLine(0, 0, -2, -2);
    fez.AddLine(-2, -2, 2, -2);
    fez.AddLine(2, -2, 0, 0);
    fez.CloseFigure();
    
    CustomLineCap cap(&fez, NULL);
    Status status = cap.GetLastStatus();
    cap.SetBaseInset(1.0f);
    
    pen.SetCustomStartCap(&cap);

    INT i;
    for(i=0;i<20; i++)
    {
        pen.SetDashOffset((float)(i)/4.0f);
        gp = new GraphicsPath();
        gp->AddLine(0, 20+i*11, 199, 20+i*11);    
        
        g->DrawPath(&pen, gp);
        
        gp->Widen(&pen, NULL, FALSE);
        
        g->DrawPath(&thinPen, gp);
        delete gp;
    }
}


CDash2::CDash2(BOOL bRegression)
{
	strcpy(m_szName,"Lines : Dash Cap Round");
	m_bRegression=bRegression;
}

void CDash2::Draw(Graphics *g)
{
    Pen pen(Color(0xff000000), 20.0f);

    pen.SetDashStyle(DashStyleDot);
    pen.SetDashCap(DashCapRound);

    GraphicsPath gp;    
    
    gp.AddBezier(20,10, 30, 10, 120, 100, 70, 150); 
    
    g->DrawPath(&pen, &gp);
}

CDash3::CDash3(BOOL bRegression)
{
	strcpy(m_szName,"Lines : Dash, Caps");
	m_bRegression=bRegression;
}

void CDash3::Draw(Graphics *g)
{
   RectF d(
        0, 
        0, 
        (INT)(TESTAREAWIDTH), 
        (INT)(TESTAREAHEIGHT)
    );

    Pen pen(Color(0xff0000ff), 12.0f);

    float dashArray[4] = {
        3.0f, 3.0f
    };

    pen.SetDashPattern(dashArray, 2);

    LineCap CapArray[9] = {
        LineCapFlat         ,
        LineCapSquare       ,
        LineCapRound        ,
        LineCapTriangle     ,
        LineCapNoAnchor     ,
        LineCapSquareAnchor ,
        LineCapRoundAnchor  ,
        LineCapDiamondAnchor,
        LineCapArrowAnchor  
    };
    
    DashCap DashCapArray[3] = {
        DashCapFlat         ,
        DashCapRound        ,
        DashCapTriangle
    };
    
    Color Rainbow[8] = {
        Color(0xff000000),  //infra-dead? ultra-violent?
        Color(0xffff0000),  //red
        Color(0xffff7f00),  //orange
        Color(0xffffff00),  //yellow
        Color(0xff00ff00),  //green
        Color(0xff0000ff),  //blue
        Color(0xff7f00ff),  //indigo?
        Color(0xffff00ff)   //violet?
    };
    
    GraphicsPath *gp;
    
    INT i;
    for(i=0;i<20; i++)
    {
        pen.SetDashOffset((float)(i)/4.0f);
        pen.SetDashCap(DashCapArray[i%3]);
        pen.SetColor(Rainbow[i%8]);
        gp = new GraphicsPath();
        gp->AddLine(20, 20+i*20, 210, 20+(i+1)*20);    
        g->DrawPath(&pen, gp);
        delete gp;
    }
}

CDash4::CDash4(BOOL bRegression)
{
	strcpy(m_szName,"Lines : Dash, Clone Pen");
	m_bRegression=bRegression;
}


void CDash4::Draw(Graphics *g)
{
    Pen pen(Color(0xff000000), 20.0f);

    pen.SetDashStyle(DashStyleDot);
    pen.SetDashCap(DashCapRound);
    pen.SetStartCap(LineCapRound);
    pen.SetEndCap(LineCapArrowAnchor);
    
    Pen *cpen = pen.Clone();
    
    GraphicsPath gp1;    
    GraphicsPath gp2;    
    
    gp1.AddBezier(20,30, 30, 30, 120, 130, 70, 180); 
    g->DrawPath(&pen, &gp1);
    
    gp2.AddBezier(60,30, 70, 30, 160, 130, 110, 180); 
    g->DrawPath(cpen, &gp2);
    
    delete cpen;
}

CDash5::CDash5(BOOL bRegression)
{
	strcpy(m_szName,"Lines : Linear Gradient Pen");
	m_bRegression=bRegression;
}


void CDash5::Draw(Graphics *g)
{
    Color presetColors[10];
    REAL positions[10];
    INT count;
    count = 3;
    positions[0] = (REAL) 0;
    positions[1] = (REAL) 0.4;
    positions[2] = (REAL) 1;
    RectF lineRect(50, 50, 100, 100);
    RectF lineRect1(10, 10, 200, 200);
    Color color1(0xff00ff00);
    Color color2(0xff00ffff);

    LinearGradientBrush lineGrad(
        lineRect, 
        color1, 
        color2,
        LinearGradientModeVertical
    );

    // Test for preset colors

    presetColors[0] = Color(0xffff0000);
    presetColors[1] = Color(0xffffff00);
    presetColors[2] = Color(0xff0000ff);
    lineGrad.SetInterpolationColors(&presetColors[0], &positions[0], count);
    lineGrad.SetWrapMode(WrapModeTileFlipXY);

    g->FillRectangle(&lineGrad, lineRect);

    Pen gradpen(&lineGrad, 45);
    g->DrawRectangle(&gradpen, lineRect1);
}


CDash6::CDash6(BOOL bRegression)
{
	strcpy(m_szName,"Lines : Caps");
	m_bRegression=bRegression;
}

void CDash6::Draw(Graphics *g)
{
   RectF d(
        0, 
        0, 
        (INT)(TESTAREAWIDTH), 
        (INT)(TESTAREAHEIGHT)
    );

    Pen pen(Color(0x7f7f7fff), 15.0f);

    float dashArray[4] = {
        3.0f, 1.0f
    };

    pen.SetDashPattern(dashArray, 2);
    pen.SetDashCap(DashCapRound);
    
    float carray[4] = { 0.0f, 0.3f, 0.5f, 1.0f };
    pen.SetCompoundArray(carray, 4);

    pen.SetEndCap(LineCapRoundAnchor);
    
    GraphicsPath someCap(FillModeWinding);
    someCap.AddLine(0, 0, -2, -2);
    someCap.AddLine(-2, -2, 2, -2);
    someCap.AddLine(2, -2, 0, 0);
    someCap.CloseFigure();
    
    CustomLineCap cap(&someCap, NULL);
    cap.SetBaseInset(1.0f);
    
    pen.SetCustomStartCap(&cap);

    Point points[6];
    points[0].X = 100;
    points[0].Y = 100;
    points[1].X = 15;
    points[1].Y = 100;
    points[2].X = 15;
    points[2].Y = 15;
    points[3].X = 200;
    points[3].Y = 15;
    points[4].X = 200;
    points[4].Y = 100;
    points[5].X = 100;
    points[5].Y = 150;
    
    GraphicsPath gp;
    gp.AddLines(points, 6);    
    
    g->DrawPath(&pen, &gp);
    
    for(int i=0; i<6; i++) { points[i].Y += 30; points[i].X += 15; }
    
    pen.SetEndCap(LineCapArrowAnchor);
    pen.SetStartCap(LineCapDiamondAnchor);
    pen.SetColor(Color(0x7fff7f7f));
    
    GraphicsPath gp1;
    gp1.AddLines(points, 6);
    
    gp1.StartFigure();
    gp1.AddLine(100, 200, 115, 202);
    
    g->DrawPath(&pen, &gp1);

    pen.SetStartCap(LineCapArrowAnchor);
    
    pen.SetColor(Color(0x7f7fff7f));
    GraphicsPath gp2;
    gp2.AddLine(100, 100, 115, 102);
    g->DrawPath(&pen, &gp2);

    // inset stroke capped line
    GraphicsPath cappath;
    PointF cappnts[] = {PointF(2.0f,-2.0f), PointF(0,0), PointF(-2.0f,-2.0f)};
    cappath.AddLines(cappnts, 3);
    CustomLineCap strokecap(NULL,&cappath);
    strokecap.SetStrokeCaps(LineCapRound, LineCapTriangle);
    Pen leftPen(Color(180,255,128,0), 13.0f);
    leftPen.SetAlignment(PenAlignmentInset);
    leftPen.SetCustomEndCap(&strokecap);
    leftPen.SetCustomStartCap(&strokecap);
    GraphicsPath gp3;
    gp3.AddBezier(35,241, 10,150, 110,160, 140,220);
    g->DrawPath(&leftPen, &gp3);
    
}


CDash7::CDash7(BOOL bRegression)
{
	strcpy(m_szName,"Lines : Clipping");
	m_bRegression=bRegression;
}

void CDash7::Draw(Graphics *g)
{
    PointF points[8];
    
    points[0].X = -64.0f+304.0f;
    points[0].Y = -45.0f+206.0f;
    points[1].X = -64.0f+242.669f;
    points[1].Y = -45.0f+192.624f;
    points[2].X = -64.0f+229.5f;
    points[2].Y = -45.0f+128.0f;
    points[3].X = -64.0f+216.331f;
    points[3].Y = -45.0f+192.624f;
    points[4].X = -64.0f+155.05f;
    points[4].Y = -45.0f+206.5f;
    points[5].X = -64.0f+216.331f;
    points[5].Y = -45.0f+220.376f;
    points[6].X = -64.0f+229.5f;
    points[6].Y = -45.0f+285.0f;
    points[7].X = -64.0f+242.669f;
    points[7].Y = -45.0f+220.376f;
    
    Pen pen(Color(0xff000000), 0.0f);
    Pen fatpen(Color(0xff0000ff), 20.0f);
    
    GraphicsPath gp;
    gp.AddPolygon(points, 8);
    
    RectF bounds;
    gp.GetBounds(&bounds, NULL, &fatpen); 
    
    g->DrawPath(&fatpen, &gp);
    g->DrawPath(&pen, &gp);
    
    g->DrawRectangle(&pen, bounds);

    points[0].X = 304.0f;
    points[0].Y = 206.0f;
    points[1].X = 242.669f;
    points[1].Y = 192.624f;
    points[2].X = 229.5f;
    points[2].Y = 128.0f;
    points[3].X = 216.331f;
    points[3].Y = 192.624f;
    points[4].X = 155.05f;
    points[4].Y = 206.5f;
    points[5].X = 216.331f;
    points[5].Y = 220.376f;
    points[6].X = 229.5f;
    points[6].Y = 285.0f;
    points[7].X = 242.669f;
    points[7].Y = 220.376f;
    
    GraphicsPath gp1;
    gp1.AddPolygon(points, 8);
    
    g->DrawPath(&pen, &gp1);
}    


CDash8::CDash8(BOOL bRegression)
{
	strcpy(m_szName,"Lines : Unit Sizes");
	m_bRegression=bRegression;
}

void CDash8::Draw(Graphics *g)
{
/*
    UnitWorld,      // 0 -- World coordinate (non-physical unit)
    UnitDisplay,    // 1 -- Variable -- for PageTransform only
    UnitPixel,      // 2 -- Each unit is one device pixel.
    UnitPoint,      // 3 -- Each unit is a printer's point, or 1/72 inch.
    UnitInch,       // 4 -- Each unit is 1 inch.
    UnitDocument,   // 5 -- Each unit is 1/300 inch.
    UnitMillimeter  // 6 -- Each unit is 1 millimeter.
*/

    Pen pen(Color(0x3f0000ff), 0.0f);
    pen.SetStartCap(LineCapArrowAnchor);
    pen.SetDashStyle(DashStyleDot);
    pen.SetDashCap(DashCapRound);
    
    Unit unit = g->GetPageUnit();
    Matrix transform;
    REAL elements[6];
    g->GetTransform(&transform);
  
    pen.SetColor(0xff0000ff);
    pen.SetWidth(0.0f);
    g->DrawLine(&pen, 20, 40, 200, 20);
    pen.SetColor(0x3f0000ff);
    pen.SetWidth(19.2f);
    g->DrawLine(&pen, 20, 20, 200, 75);

    g->ResetTransform();
    g->SetPageUnit(UnitInch);  
    transform.GetElements(elements);    
    Matrix inch;
    elements[4] *= 1.0f/96.0f;
    elements[5] *= 1.0f/96.0f;
    inch.SetElements(
        elements[0],
        elements[1],
        elements[2],
        elements[3],
        elements[4],
        elements[5]
    );
    g->SetTransform(&inch);
    
    pen.SetColor(Color(0xffff0000));
    pen.SetWidth(0.0f);
    g->DrawLine(&pen, 0.0f, 2.5f, 2.0f, 0.1f);
    pen.SetColor(Color(0x3fff0000));
    pen.SetWidth(0.2f);
    g->DrawLine(&pen, 0.0f, 0.1f, 2.0f, 2.5f);

    
    g->ResetTransform();
    g->SetPageUnit(UnitMillimeter);  
    
    transform.GetElements(elements);    
    Matrix millimeter;
    elements[4] *= 0.26458333f;
    elements[5] *= 0.26458333f;
    millimeter.SetElements(
        elements[0],
        elements[1],
        elements[2],
        elements[3],
        elements[4],
        elements[5]
    );
    g->SetTransform(&millimeter);
    
    pen.SetColor(Color(0xff00ff00));
    pen.SetWidth(0.0f);
    g->DrawLine(&pen, 0, 55, 55, 10);
    pen.SetColor(Color(0x3f00ff00));
    pen.SetWidth(5.08f);
    g->DrawLine(&pen, 0, 10, 55, 55);
    
    
    g->SetPageUnit(unit);
    g->SetTransform(&transform);
}    



CDash9::CDash9(BOOL bRegression)
{
	strcpy(m_szName,"Lines : Dash, multiple subpaths");
	m_bRegression=bRegression;
}

void CDash9::Draw(Graphics *g)
{
    GraphicsPath gp;
    
    for(int i=0; i<10; i++)
    {
        gp.AddLine(50+i*10, 50, 50+i*10, 200);
        gp.StartFigure();
    }
    
    Pen pen(Color(0xff000000), 3.0f);
    
    float dash[] = {8.0f, 4.0f};
    pen.SetDashPattern(dash, 2);
    pen.SetDashCap(DashCapRound);
    
    g->DrawPath(&pen, &gp);
}



extern int gcf(int a, int b);

PointF *ComputeHypocycloid(
    INT a,      // These are the a and b coefficients for the hypocycloid
    INT b,
    float r,    // pen radius
    RectF rect,
    INT size,
    INT *count  // out parameter
)
{
    #define _2PI 2*3.141592653689
    
    // Compute the center point for the cycle.

    float fXo = rect.X + rect.Width/2.0f;
    float fYo = rect.Y + rect.Height/2.0f;
    
    float ScaleX = 0.5f*rect.Width/( (a>b)?a:a+b );
    float ScaleY = 0.5f*rect.Height/( (a>b)?a:a+b );


    int cycle=b/gcf(a,b);    //number of times round the outer circle
    *count = cycle*size;

    PointF *points = new PointF[*count];
    
    // ... tracking the cycloid path.

    for(int i=0; i<*count; i++) {
      
      float t = (float)(cycle*_2PI*i/(*count));  // parametric parameter...
      
      points[i].X = (float)(fXo+ScaleX*((a-b)*cos(t)+r*cos((a-b)*t/b)));
      points[i].Y = (float)(fYo+ScaleY*((a-b)*sin(t)-r*sin((a-b)*t/b)));
    }

    #undef _2PI
    return points;
}


CWiden::CWiden(BOOL bRegression)
{
	strcpy(m_szName,"Lines : Widen");
	m_bRegression=bRegression;
}

void CWiden::Draw(Graphics *g)
{
    PointF starpoints[5];
    REAL s, c, theta;
    PointF orig((int)(TESTAREAWIDTH/2.0f), (int)(TESTAREAHEIGHT/2.0f));

    theta = (float)-M_PI/2;

    // Create a star shape.
    for(INT i = 0; i < 5; i++)
    {
        s = sinf(theta);
        c = cosf(theta);
        starpoints[i].X = (int)(80.0f/250.0f*TESTAREAWIDTH)*c + orig.X;
        starpoints[i].Y = (int)(80.0f/250.0f*TESTAREAHEIGHT)*s + orig.Y;
        theta += (float)(0.8f*M_PI);
    }
    SolidBrush starbrush(Color(0x3fff00ff));
    Pen penwide(Color(0x7f0000ff), 20.0f);
    Pen linepen(Color(0xff000000), 0.0f);

    GraphicsPath* path = new GraphicsPath(FillModeAlternate);
    
    path->AddPolygon(starpoints, 5);
    path->Widen(&penwide);
    g->FillPath(&starbrush, path);
    g->DrawPath(&linepen, path);

    delete path;
    
    
    
    float marginX = 20;
    float marginY = 20;
    INT count;
    PointF *points = ComputeHypocycloid(
        52, 12, 7.0f, 
        RectF(
            marginX, marginY, 
            TESTAREAWIDTH-2.0f*marginX, 
            TESTAREAHEIGHT-2.0f*marginY
        ),
        50,
        &count
    );
    
    GraphicsPath gp;
    gp.AddPolygon(points, count);
    Pen pen(Color(0xff000000), 12.0f);
    gp.Widen(&pen);
    SolidBrush brush(Color(0x3f0000ff));
    g->FillPath(&brush, &gp);
    Pen thinPen(Color(0xff000000), 0.0f);
    g->DrawPath(&thinPen, &gp);
}    

CWidenO::CWidenO(BOOL bRegression)
{
	strcpy(m_szName,"Lines : Widen, Outline");
	m_bRegression=bRegression;
}

void CWidenO::Draw(Graphics *g)
{
    PointF starpoints[5];
    REAL s, c, theta;
    PointF orig((int)(TESTAREAWIDTH/2.0f), (int)(TESTAREAHEIGHT/2.0f));

    theta = (float)-M_PI/2;

    // Create a star shape.
    for(INT i = 0; i < 5; i++)
    {
        s = sinf(theta);
        c = cosf(theta);
        starpoints[i].X = (int)(80.0f/250.0f*TESTAREAWIDTH)*c + orig.X;
        starpoints[i].Y = (int)(80.0f/250.0f*TESTAREAHEIGHT)*s + orig.Y;
        theta += (float)(0.8f*M_PI);
    }
    SolidBrush starbrush(Color(0x7f7f00ff));
    Pen penwide(Color(0x7f000000), 20.0f);
    Pen linepen(Color(0xff000000), 0.0f);

    GraphicsPath* path = new GraphicsPath(FillModeAlternate);
    
    path->AddPolygon(starpoints, 5);
    path->Widen(&penwide);
    path->Outline();
    g->FillPath(&starbrush, path);
    g->DrawPath(&linepen, path);

    delete path;


    float marginX = 20;
    float marginY = 20;
    INT count;
    PointF *points = ComputeHypocycloid(
        52, 12, 7.0f, 
        RectF(
            marginX, marginY, 
            TESTAREAWIDTH-2.0f*marginX, 
            TESTAREAHEIGHT-2.0f*marginY
        ),
        50,
        &count
    );
    
    GraphicsPath gp;
    gp.AddPolygon(points, count);
    Pen pen(Color(0xff000000), 12.0f);
    Pen strokePen(Color(0xff0000ff), 0.0f);
    g->DrawPath(&strokePen, &gp);
    gp.Widen(&pen);
    gp.Outline();
    SolidBrush brush(Color(0x3f0000ff));
    g->FillPath(&brush, &gp);
    Pen thinPen(Color(0xff000000), 0.0f);
    g->DrawPath(&thinPen, &gp);
}    

CWidenOO::CWidenOO(BOOL bRegression)
{
	strcpy(m_szName,"Lines : Widen, Outline twice");
	m_bRegression=bRegression;
}

void CWidenOO::Draw(Graphics *g)
{
    PointF starpoints[5];
    REAL s, c, theta;
    PointF orig((int)(TESTAREAWIDTH/2.0f), (int)(TESTAREAHEIGHT/2.0f));

    theta = (float)-M_PI/2;

    // Create a star shape.
    for(INT i = 0; i < 5; i++)
    {
        s = sinf(theta);
        c = cosf(theta);
        starpoints[i].X = (int)(80.0f/250.0f*TESTAREAWIDTH)*c + orig.X;
        starpoints[i].Y = (int)(80.0f/250.0f*TESTAREAHEIGHT)*s + orig.Y;
        theta += (float)(0.8f*M_PI);
    }
    SolidBrush starbrush(Color(0x3f7f00ff));
    Pen penwide(Color(0x7f000000), 20.0f);
    Pen linepen(Color(0xff000000), 0.0f);

    GraphicsPath* path = new GraphicsPath(FillModeAlternate);
    
    path->AddPolygon(starpoints, 5);
    path->Outline();
    path->Widen(&penwide);
    path->Outline();
    g->FillPath(&starbrush, path);
    g->DrawPath(&linepen, path);

    delete path;
    
    
    float marginX = 20;
    float marginY = 20;
    INT count;
    PointF *points = ComputeHypocycloid(
        52, 12, 7.0f, 
        RectF(
            marginX, marginY, 
            TESTAREAWIDTH-2.0f*marginX, 
            TESTAREAHEIGHT-2.0f*marginY
        ),
        50,
        &count
    );
    
    GraphicsPath gp;
    gp.AddPolygon(points, count);
    Pen pen(Color(0xff000000), 12.0f);
    gp.Outline();
    gp.Widen(&pen);
    gp.Outline();
    SolidBrush brush(Color(0x3f0000ff));
    g->FillPath(&brush, &gp);
    Pen thinPen(Color(0xff000000), 0.0f);
    g->DrawPath(&thinPen, &gp);
}    


CFlatten::CFlatten(BOOL bRegression)
{
	strcpy(m_szName,"Lines : Flatten Limits");
	m_bRegression=bRegression;
}

void CFlatten::Draw(Graphics *g)
{
    LinearGradientBrush lbrush(
        PointF(0.0f, 0.0f),
        PointF(0.0f, TESTAREAHEIGHT),
        Color(0xff0000ff),
        Color(0xff00ff00)
    );
    
    lbrush.SetGammaCorrection(FALSE);

    // Bad flatness.
    
    GraphicsPath gp;
    gp.AddEllipse(20.0f, 40.0f, TESTAREAWIDTH-40.0f, TESTAREAHEIGHT-80.0f);
    gp.Flatten(NULL, 6.0f);
    
    Pen blackPen(Color(0xff000000), 0.0f);
    
    Pen linePen(&lbrush, 25.0f);
    g->DrawPath(&linePen, &gp);
    
    // Good flatness.
    
    gp.Reset();
    gp.AddEllipse(20.0f, 40.0f, TESTAREAWIDTH-40.0f, TESTAREAHEIGHT-80.0f);
    gp.Flatten(NULL, 0.25f);
    
    Pen redPen(Color(0x7fff0000), 5.0f);
    g->DrawPath(&redPen, &gp);
    gp.Widen(&redPen);
    g->DrawPath(&blackPen, &gp);
    
    
    // Add a curve with a bazillion points to see what an ideal flattened curve
    // should look like at our device flattening default.
    
    float marginX = 30;
    float marginY = 50;
    INT count;
    PointF *points = ComputeHypocycloid(
        52, 24, 20.0f, 
        RectF(
            marginX, marginY, 
            TESTAREAWIDTH-2.0f*marginX, 
            TESTAREAHEIGHT-2.0f*marginY
        ),
        100,
        &count
    );
    
    LinearGradientBrush lbrush2(
        PointF(0.0f, 0.0f),
        PointF(0.0f, TESTAREAHEIGHT),
        Color(0xffffff00),
        Color(0xffff002f)
    );
    
    lbrush2.SetGammaCorrection(FALSE);
    
    gp.Reset();
    gp.AddClosedCurve(points, count);
    Pen lpen(&lbrush2, 2.0f);
    g->DrawPath(&lpen, &gp);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\functest\cdash.hpp ===
/**************************************************************************
*
* Copyright (c) 2000 Microsoft Corporation
*
* Module Name:
*
*   <an unabbreviated name for the module (not the filename)>
*
* Abstract:
*
*   <Description of what this module does>
*
* Notes:
*
*   <optional>
*
* Created:
*
*   08/28/2000 asecchia
*      Created it.
*
**************************************************************************/

#ifndef _CDASH_HPP
#define _CDASH_HPP


#include "CPrimitive.h"

class CDash : public CPrimitive
{
public:
	CDash(BOOL bRegression);
	void Draw(Graphics *g);
};

class CDash2 : public CPrimitive
{
public:
	CDash2(BOOL bRegression);
	void Draw(Graphics *g);
};

class CDash3 : public CPrimitive
{
public:
	CDash3(BOOL bRegression);
	void Draw(Graphics *g);
};

class CDash4 : public CPrimitive
{
public:
	CDash4(BOOL bRegression);
	void Draw(Graphics *g);
};

class CDash5 : public CPrimitive
{
public:
	CDash5(BOOL bRegression);
	void Draw(Graphics *g);
};

class CDash6 : public CPrimitive
{
public:
	CDash6(BOOL bRegression);
	void Draw(Graphics *g);
};

class CDash7 : public CPrimitive
{
public:
	CDash7(BOOL bRegression);
	void Draw(Graphics *g);
};

class CDash8 : public CPrimitive
{
public:
	CDash8(BOOL bRegression);
	void Draw(Graphics *g);
};

class CDash9 : public CPrimitive
{
public:
	CDash9(BOOL bRegression);
	void Draw(Graphics *g);
};

class CWiden : public CPrimitive
{
public:
	CWiden(BOOL bRegression);
	void Draw(Graphics *g);
};

class CWidenO : public CPrimitive
{
public:
	CWidenO(BOOL bRegression);
	void Draw(Graphics *g);
};

class CWidenOO : public CPrimitive
{
public:
	CWidenOO(BOOL bRegression);
	void Draw(Graphics *g);
};

class CFlatten : public CPrimitive
{
public:
	CFlatten(BOOL bRegression);
	void Draw(Graphics *g);
};



#define DASH_GLOBALS \
CWiden g_Widen(true);\
CWidenO g_WidenO(true);\
CWidenOO g_WidenOO(true);\
CFlatten g_Flatten(true);\
CDash g_Dash(true);\
CDash2 g_Dash2(true);\
CDash3 g_Dash3(true);\
CDash4 g_Dash4(true);\
CDash5 g_Dash5(true);\
CDash6 g_Dash6(true);\
CDash7 g_Dash7(true);\
CDash8 g_Dash8(true);\
CDash9 g_Dash9(true);

#define DASH_INIT \
g_Widen.Init();\
g_WidenO.Init();\
g_WidenOO.Init();\
g_Flatten.Init();\
g_Dash.Init();\
g_Dash2.Init();\
g_Dash3.Init();\
g_Dash4.Init();\
g_Dash5.Init();\
g_Dash6.Init();\
g_Dash7.Init();\
g_Dash8.Init();\
g_Dash9.Init();


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\functest\cextra.h ===
VOID ExtraInitializations();
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\functest\cdib.h ===
/******************************Module*Header*******************************\
* Module Name: CDIB.h
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/

#ifndef __CDIB_H
#define __CDIB_H

#include "COutput.h"

typedef RGBQUAD RGBQUAD1[2];
typedef RGBQUAD RGBQUAD2[4];
typedef RGBQUAD RGBQUAD4[16];
typedef RGBQUAD RGBQUAD8[256];
typedef RGBQUAD RGBQUAD16[3];
typedef RGBQUAD RGBQUAD24[3];
typedef RGBQUAD RGBQUAD32[3];

class CDIB : public COutput  
{
public:
    CDIB(BOOL bRegression,int nBits);
    virtual ~CDIB();

    Graphics *PreDraw(int &nOffsetX,int &nOffsetY);         // Set up graphics at the given X,Y offset
    void PostDraw(RECT rTestArea);                          // Finish off graphics at rTestArea

    void InitPalettes();                                    // Initialize palettes

    HDC m_hDC;                                              // DC of DIB
    HBITMAP m_hBM;                                          // Bitmap of DIB
    HBITMAP m_hBMOld;                                       // Bitmap of old drawing surface
    HPALETTE m_hpal;
    HPALETTE m_hpalOld;

    RGBQUAD1 m_rgbQuad1;                                    // 1 bit palette
    RGBQUAD2 m_rgbQuad2;                                    // 2 bit palette
    RGBQUAD4 m_rgbQuad4;                                    // 4 bit palette
    RGBQUAD8 m_rgbQuad8;                                    // 8 bit palette
    RGBQUAD16 m_rgbQuad16;                                  // 16 bit palette
    RGBQUAD24 m_rgbQuad24;                                  // 24 bit palette
    RGBQUAD32 m_rgbQuad32;                                  // 32 bit palette
    int m_nBits;                                            // # of bits to use
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\functest\cdirect3d.h ===
/******************************Module*Header*******************************\
* Module Name: CDirect3D.h
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/

#ifndef __CDIRECT3D_H
#define __CDIRECT3D_H

#include "COutput.h"

class CDirect3D : public COutput  
{
public:
	CDirect3D(BOOL bRegression);
	virtual ~CDirect3D();

	BOOL Init();
	Graphics *PreDraw(int &nOffsetX,int &nOffsetY);			// Set up graphics at the given X,Y offset
	void PostDraw(RECT rTestArea);							// Finish off graphics at rTestArea

	LPDIRECTDRAW7 m_paDD7;									// DirectDraw 7
	LPDIRECTDRAWSURFACE7 m_paDDSurf7;						// DirectDraw surface 7
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\functest\cdirect3d.cpp ===
/******************************Module*Header*******************************\
* Module Name: CDirect3D.cpp
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/
#include "CDirect3D.h"
#include "CFuncTest.h"

extern CFuncTest g_FuncTest;

CDirect3D::CDirect3D(BOOL bRegression)
{
	strcpy(m_szName,"Direct3D");
	m_paDD7=NULL;
	m_paDDSurf7=NULL;
	m_bRegression=bRegression;
}

CDirect3D::~CDirect3D()
{
	if (m_paDD7!=NULL)
	{
		m_paDD7->Release();
		m_paDD7=NULL;
	}
}

BOOL CDirect3D::Init()
{
#if HW_ACCELERATION_SUPPORT
	if (DirectDrawCreateEx(NULL,(void **)&m_paDD7,IID_IDirectDraw7,NULL)!=DD_OK)
		return false;

	if (gDD->SetCooperativeLevel(m_hWnd,DDSCL_NORMAL)!=DD_OK)
		return false;
#endif

	return COutput::Init();
}

Graphics *CDirect3D::PreDraw(int &nOffsetX,int &nOffsetY)
{
	Graphics *g=NULL;

#if HW_ACCELERATION_SUPPORT
	DDSURFACEDESC2 ddsd;

	ZeroMemory(&ddsd, sizeof(ddsd));
	ddsd.dwSize = sizeof(ddsd);

	ddsd.dwFlags = DDSD_CAPS | DDSD_HEIGHT | DDSD_WIDTH;
	ddsd.ddsCaps.dwCaps = DDSCAPS_OFFSCREENPLAIN | DDSCAPS_3DDEVICE;
	ddsd.ddsCaps.dwCaps |= DDSCAPS_SYSTEMMEMORY;
	
	switch(depth)
	{
	case 32:
		ddsd.dwFlags |= DDSD_PIXELFORMAT;
		ddsd.ddpfPixelFormat.dwSize = sizeof(ddsd.ddpfPixelFormat);
		ddsd.ddpfPixelFormat.dwFlags = DDPF_RGB;
		ddsd.ddpfPixelFormat.dwRGBBitCount = 32;
		ddsd.ddpfPixelFormat.dwRBitMask = 0xFF0000;
		ddsd.ddpfPixelFormat.dwGBitMask = 0xFF00;
		ddsd.ddpfPixelFormat.dwBBitMask = 0xFF;
		break;
	case 16:
		ddsd.dwFlags |= DDSD_PIXELFORMAT;
		ddsd.ddpfPixelFormat.dwSize = sizeof(ddsd.ddpfPixelFormat);
		ddsd.ddpfPixelFormat.dwFlags = DDPF_RGB;
		ddsd.ddpfPixelFormat.dwRGBBitCount = 16;
		ddsd.ddpfPixelFormat.dwRBitMask = 0xEC00;
		ddsd.ddpfPixelFormat.dwGBitMask = 0x3E0;
		ddsd.ddpfPixelFormat.dwBBitMask = 0x1F;
		break;
	default:
		MessageBoxA(NULL,
					"Unsupprted depth for D3D", 
					"", 
					MB_OK);
		return;
	}

	ddsd.dwWidth = (int)TESTAREAWIDTH;
	ddsd.dwHeight = (int)TESTAREAHEIGHT;
	
	HRESULT err;
	
	err = m_paDD7->CreateSurface(&ddsd, &dds, NULL);
	if(err != DD_OK)
	{
	    MessageBoxA(NULL,
	               "Unable to create surface", 
	               "", 
	               MB_OK);
	    return;
	}
	
	HDC hdc;
	 
	err = m_paDDSurf7->GetDC(&hdc);
	
#if 0
	if(err != DD_OK)
	{
	    MessageBoxA(NULL,
	               "Unable to get DC from DDraw surface", 
	               "", 
	               MB_OK);
	    m_paDDSurf7->Release();
	    return;
	}
	
	g = Graphics::GetFromHdc(hdc);
	
	BitBlt(hdc, 0, 0, (int)TESTAREAWIDTH, (int)TESTAREAHEIGHT, NULL, 0, 0, WHITENESS);
	
	m_paDDSurf7->ReleaseDC(hdc);
#else
	BitBlt(hdc, 0, 0, (int)TESTAREAWIDTH, (int)TESTAREAHEIGHT, NULL, 0, 0, WHITENESS);
	
	m_paDDSurf7->ReleaseDC(hdc);
	
	bitmap = new Bitmap(dds);
	
	g = new Graphics(bitmap);
#endif

	// Since we are doing the test on another surface
	nOffsetX=0;
	nOffsetY=0;
#endif

	return g;
}

void CDirect3D::PostDraw(RECT rTestArea)
{
#if HW_ACCELERATION_SUPPORT
	delete bitmap;

	HRESULT err;
	HDC hdc;
	HDC hdcOrig = GetDC(g_FuncTest.m_hWndMain);

	err = m_paDDSurf7->GetDC(&hdc);
	if(err == DD_OK)
	{
	    BitBlt(hdcOrig, rTestArea.left, rTestArea.top, (int)TESTAREAWIDTH, (int)TESTAREAHEIGHT, hdc, 0, 0, SRCCOPY);
	}
	m_paDDSurf7->ReleaseDC(hdc);
	m_paDDSurf7->Release();
	ReleaseDC(g_FuncTest.m_hWndMain, hdcOrig);
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\functest\cdib.cpp ===
/******************************Module*Header*******************************\
* Module Name: CDIB.cpp
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/
#include "CDIB.h"
#include "CFuncTest.h"
#include "CHalftone.h"

extern CHalftone g_Halftone;
extern CFuncTest g_FuncTest;

CDIB::CDIB(BOOL bRegression,int nBits)
{
    sprintf(m_szName,"DIB %d bit",nBits);
    if (nBits>1)
        strcat(m_szName,"s");

    m_nBits=nBits;
    m_hDC=NULL;
    m_hBM=NULL;
    m_hBMOld=NULL;
    m_hpal=NULL;
    m_hpalOld=NULL;

    InitPalettes();
    m_bRegression=bRegression;
}

CDIB::~CDIB()
{
}

Graphics *CDIB::PreDraw(int &nOffsetX,int &nOffsetY)
{
    Graphics *g=NULL;
    PVOID pvBits = NULL;
    HDC hdcWnd=GetDC(g_FuncTest.m_hWndMain);

    // these combined give BITMAPINFO structure.
    struct {
        BITMAPINFOHEADER bmih;
        union {
            RGBQUAD1 rgbquad1;
            RGBQUAD2 rgbquad2;
            RGBQUAD4 rgbquad4;
            RGBQUAD8 rgbquad8;
            RGBQUAD16 rgbquad16;
            RGBQUAD24 rgbquad24;
            RGBQUAD32 rgbquad32;
        };
    } bmi;

    bmi.bmih.biSize = sizeof(BITMAPINFOHEADER);
    bmi.bmih.biWidth = (int)TESTAREAWIDTH;
    bmi.bmih.biHeight = (int)TESTAREAHEIGHT;
    bmi.bmih.biPlanes = 1;
    bmi.bmih.biBitCount = (WORD)m_nBits;
    bmi.bmih.biCompression = BI_RGB;
    bmi.bmih.biSizeImage = 0;
    bmi.bmih.biXPelsPerMeter = 0;
    bmi.bmih.biYPelsPerMeter = 0;
    bmi.bmih.biClrUsed = 0;             // only used for <= 16bpp
    bmi.bmih.biClrImportant = 0;

    // create appropriate rgb table.
    switch (m_nBits)
    {
    case 1: memcpy(bmi.rgbquad1, m_rgbQuad1, sizeof(m_rgbQuad1));
            break;
    
    case 2: memcpy(bmi.rgbquad2, m_rgbQuad2, sizeof(m_rgbQuad2));
            break;
    
    case 4: memcpy(bmi.rgbquad4, m_rgbQuad4, sizeof(m_rgbQuad4));
            break;
    
    case 8: memcpy(bmi.rgbquad8, m_rgbQuad8, sizeof(m_rgbQuad8));
            break;
    
    case 16: memcpy(bmi.rgbquad16, m_rgbQuad16, sizeof(m_rgbQuad16));
            break;
    
    case 24: memcpy(bmi.rgbquad24, m_rgbQuad24, sizeof(m_rgbQuad24));
            break;
    
    case 32: memcpy(bmi.rgbquad32, m_rgbQuad32, sizeof(m_rgbQuad32));
            break;
    }

    if ((m_nBits == 8) && g_Halftone.m_bUseSetting)
    {
        m_hpal = DllExports::GdipCreateHalftonePalette();
        
        BYTE aj[sizeof(PALETTEENTRY) * 256];
        LPPALETTEENTRY lppe = (LPPALETTEENTRY) aj;
        RGBQUAD *prgb = (RGBQUAD *) &bmi.rgbquad8;
        ULONG i;
    
        if (GetPaletteEntries(m_hpal, 0, 256, lppe))
        {
            UINT i;

            for (i = 0; i < 256; i++)
            {
                prgb[i].rgbRed      = lppe[i].peRed;
                prgb[i].rgbGreen    = lppe[i].peGreen;
                prgb[i].rgbBlue     = lppe[i].peBlue;
                prgb[i].rgbReserved = 0;
            }
        }
        
    }

    m_hBM=CreateDIBSection(hdcWnd,(BITMAPINFO*)&bmi,DIB_RGB_COLORS,&pvBits,NULL,0);
    if (!m_hBM)
    {
        MessageBoxA(NULL,"Can't create DIB Section.","",MB_OK);
        return NULL;
    }

    // create DC for our DIB
    m_hDC=CreateCompatibleDC(hdcWnd);
    m_hBMOld=(HBITMAP)SelectObject(m_hDC,m_hBM);
    
    if (m_hpal)
    {
        m_hpalOld = SelectPalette(m_hDC, m_hpal, FALSE);
    }

    // Set the background to main window background
    BitBlt(m_hDC, 0, 0, (int)TESTAREAWIDTH, (int)TESTAREAHEIGHT, hdcWnd, nOffsetX, nOffsetY, SRCCOPY);
//  PatBlt(m_hDC, 0, 0, (int)TESTAREAWIDTH, (int)TESTAREAHEIGHT, WHITENESS);           

//  if (m_nBits == 32)
//      g = Graphics::FromDib32(pvBits, rClient.right, rClient.bottom);
//  else
        g = Graphics::FromHDC(m_hDC);

    // Since we are doing the test on another surface
    nOffsetX=0;
    nOffsetY=0;

    ReleaseDC(g_FuncTest.m_hWndMain,hdcWnd);

    return g;
}

void CDIB::PostDraw(RECT rTestArea)
{
    // blit from the DIB to screen so we see the results, we use
    // GDI for this.
    HDC hdcOrig = GetDC(g_FuncTest.m_hWndMain);

    HPALETTE hpalScreenOld = NULL;
    if (m_hpal)
    {
        hpalScreenOld = SelectPalette(hdcOrig, m_hpal, FALSE);
        RealizePalette(hdcOrig);
    }
    BitBlt(hdcOrig, rTestArea.left, rTestArea.top, (int)TESTAREAWIDTH, (int)TESTAREAHEIGHT, m_hDC, 0, 0, SRCCOPY);
    if (m_hpal)
    {
        SelectPalette(hdcOrig, hpalScreenOld, FALSE);
    }

    ReleaseDC(g_FuncTest.m_hWndMain,hdcOrig);
    
    SelectObject(m_hDC,m_hBMOld);
    if (m_hpal)
    {
        SelectPalette(m_hDC, m_hpalOld, FALSE);
        DeleteObject(m_hpal);
        m_hpal=NULL;
    }
    DeleteDC(m_hDC);
    DeleteObject(m_hBM);
}

void CDIB::InitPalettes()
{
    BYTE red=0,green=0,blue=0;
    RGBQUAD1 rgbQuad1 = { { 0, 0, 0, 0 }, 
                          { 0xff, 0xff, 0xff, 0 } };
    RGBQUAD2 rgbQuad2 = { { 0x80, 0x80, 0x80, 0 },
                          { 0x80, 0, 0, 0 },
                          { 0, 0x80, 0, 0 },
                          { 0, 0, 0x80, 0 } };
    RGBQUAD4 rgbQuad4 = {  // B    G    R
                            { 0,   0,   0,   0 },       // 0
                            { 0,   0,   0x80,0 },       // 1
                            { 0,   0x80,0,   0 },       // 2
                            { 0,   0x80,0x80,0 },       // 3
                            { 0x80,0,   0,   0 },       // 4
                            { 0x80,0,   0x80,0 },       // 5
                            { 0x80,0x80,0,   0 },       // 6
                            { 0x80,0x80,0x80,0 },       // 7
                            { 0xC0,0xC0,0xC0,0 },       // 8
                            { 0,   0,   0xFF,0 },       // 9
                            { 0,   0xFF,0,   0 },       // 10
                            { 0,   0xFF,0xFF,0 },       // 11
                            { 0xFF,0,   0,   0 },       // 12
                            { 0xFF,0,   0xFF,0 },       // 13
                            { 0xFF,0xFF,0,   0 },       // 14
                            { 0xFF,0xFF,0xFF,0 } };     // 15
    RGBQUAD16 rgbQuad16 = { { 0, 0x7c, 0, 0 }, { 0xe0, 03, 0, 0 }, { 0x1f, 0, 0, 0 } };
    RGBQUAD24 rgbQuad24 = { { 0, 0, 0xff, 0 }, { 0, 0xff, 0, 0 }, { 0xff, 0, 0, 0 } };
    RGBQUAD32 rgbQuad32 = { { 0, 0, 0xff, 0 }, { 0, 0xff, 0, 0 }, { 0xff, 0, 0 ,0 } };

    memcpy(m_rgbQuad1,rgbQuad1,sizeof(rgbQuad1));
    memcpy(m_rgbQuad2,rgbQuad2,sizeof(rgbQuad2));
    memcpy(m_rgbQuad4,rgbQuad4,sizeof(rgbQuad4));
    memcpy(m_rgbQuad16,rgbQuad16,sizeof(rgbQuad16));
    memcpy(m_rgbQuad24,rgbQuad24,sizeof(rgbQuad24));
    memcpy(m_rgbQuad32,rgbQuad32,sizeof(rgbQuad32));

    // This is a very arbitrary palette. Anyhoo, it's not the GDI+ halftone
    // palette, which I guess is all we want to test. It is kinda lucky that
    // the VGA colors are present, but that's all we need.

    ZeroMemory(m_rgbQuad8,sizeof(m_rgbQuad8));
    for (INT i=0; i<256; i++)
    {
        m_rgbQuad8[i].rgbRed=red;
        m_rgbQuad8[i].rgbGreen=green;
        m_rgbQuad8[i].rgbBlue=blue;

        if (!(red+=32))
        {
            if (!(green+=32))
            {
                blue+=64;
            }
        }
    }

    // for system colors (last 20), use those from 4 bpp palette table.
    for (INT j=248; j<256; j++)
    {
        m_rgbQuad8[j].rgbRed=m_rgbQuad4[j-240].rgbRed;
        m_rgbQuad8[j].rgbGreen=m_rgbQuad4[j-240].rgbGreen;
        m_rgbQuad8[j].rgbBlue=m_rgbQuad4[j-240].rgbBlue;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\functest\cextra.cpp ===
// Include all the primitives (classes derived from CPrimitive)
#include "CPolygons.h"
#include "CCachedBitmap.h"
#include "CBitmaps.h"
#include "CCompoundLines.h"
#include "CContainer.h"
#include "CContainerClip.h"
#include "CDashes.h"
#include "CPathGradient.hpp"
#include "CGradients.h"
#include "CImaging.h"
#include "CRecolor.h"
#include "CSystemColor.h"
#include "CInsetLines.h"
#include "CMixedObjects.h"
#include "CPaths.h"
#include "CDash.hpp"
#include "CLines.hpp"
#include "CPrimitives.h"
#include "CRegions.h"
#include "CText.h"
#include "printtest\CPrinting.h"
#include "CRegression.h"
#include "CSourceCopy.h"
#include "CExtra.h"
#include "CReadWrite.h"
#include "CFillMode.h"

// Create global objects for each individual primitive
//   First constructor param is the regression flag
//   If true, the test will take part of the regression suite
CPolygons g_Polygons(true);
CBitmaps g_Bitmaps(true);
CCachedBitmap g_CachedBitmap(true);
CCompoundLines g_CompoundLines(true);
CContainer g_Container(true);
CContainerClip g_ContainerClip(true);
CDashes g_Dashes(true);

DASH_GLOBALS
INSET_GLOBALS
GRADIENT_GLOBALS
PATHGRADIENT_GLOBALS
LINES_GLOBALS

CImaging g_Imaging(true);
CRecolor g_Recolor(true);
CSystemColor g_SystemColor(false);
CMixedObjects g_MixedObjects(true);
CPaths g_Paths(true);
CJoins g_Joins(true);
CPrimitives g_Primitives(true);
CRegions g_Regions(true);
CText g_Text(true);
CSourceCopy g_SourceCopy(true);
CReadWrite g_ReadWrite(false);
CFillMode g_FillMode(true);

void ExtraInitializations()
{
    g_Polygons.Init();
    g_Bitmaps.Init();
    g_CachedBitmap.Init();
    g_CompoundLines.Init();
    g_Container.Init();
    g_ContainerClip.Init();
    g_Dashes.Init();
    DASH_INIT;
    INSET_INIT;
    GRADIENT_INIT;
    PATHGRADIENT_INIT;
    LINES_INIT;
    g_Imaging.Init();
    g_Recolor.Init();
    g_SystemColor.Init();
    g_MixedObjects.Init();
    g_Paths.Init();
    g_Joins.Init();
    g_Primitives.Init();
    g_Regions.Init();
    g_Text.Init();
    g_SourceCopy.Init();
    g_ReadWrite.Init();
    g_FillMode.Init();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\functest\cfile.cpp ===
/******************************Module*Header*******************************\
* Module Name: CFile.cpp
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/
#include "CFile.h"
#include "CFuncTest.h"

extern CFuncTest g_FuncTest;

CFile::CFile(BOOL bRegression,int nBits)
{
	sprintf(m_szName,"File %d bits",nBits);
	m_nBits=nBits;
	m_hDC=NULL;
	m_hBM=NULL;
	m_hBMOld=NULL;

	InitPalettes();
	m_bRegression=bRegression;
}

CFile::~CFile()
{
}

Graphics *CFile::PreDraw(int &nOffsetX,int &nOffsetY)
{
	Graphics *g=NULL;
	PVOID pvBits = NULL;
	HDC hdcWnd=GetDC(g_FuncTest.m_hWndMain);

	// these combined give BITMAPINFO structure.
	struct {
	    BITMAPINFOHEADER bmih;
	    union {
	        RGBQUAD1 rgbquad1;
	        RGBQUAD2 rgbquad2;
	        RGBQUAD4 rgbquad4;
	        RGBQUAD8 rgbquad8;
	        RGBQUAD16 rgbquad16;
	        RGBQUAD24 rgbquad24;
	        RGBQUAD32 rgbquad32;
	    };
	} bmi;

	bmi.bmih.biSize = sizeof(BITMAPINFOHEADER);
	bmi.bmih.biWidth = (int)TESTAREAWIDTH;
	bmi.bmih.biHeight = (int)TESTAREAHEIGHT;
	bmi.bmih.biPlanes = 1;
	bmi.bmih.biBitCount = (WORD)m_nBits;
	bmi.bmih.biCompression = BI_RGB;
	bmi.bmih.biSizeImage = 0;
	bmi.bmih.biXPelsPerMeter = 0;
	bmi.bmih.biYPelsPerMeter = 0;
	bmi.bmih.biClrUsed = 0;             // only used for <= 16bpp
	bmi.bmih.biClrImportant = 0;

	// create appropriate rgb table.
	switch (m_nBits)
	{
	case 1: memcpy(bmi.rgbquad1, m_rgbQuad1, sizeof(m_rgbQuad1));
	        break;

	case 2: memcpy(bmi.rgbquad2, m_rgbQuad2, sizeof(m_rgbQuad2));
	        break;

	case 4: memcpy(bmi.rgbquad4, m_rgbQuad4, sizeof(m_rgbQuad4));
	        break;

	case 8: memcpy(bmi.rgbquad8, m_rgbQuad8, sizeof(m_rgbQuad8));
	        break;

	case 16: memcpy(bmi.rgbquad16, m_rgbQuad16, sizeof(m_rgbQuad16));
	        break;

	case 24: memcpy(bmi.rgbquad24, m_rgbQuad24, sizeof(m_rgbQuad24));
	        break;

	case 32: memcpy(bmi.rgbquad32, m_rgbQuad32, sizeof(m_rgbQuad32));
	        break;
	}

	m_hBM=CreateDIBSection(hdcWnd,(BITMAPINFO*)&bmi,DIB_RGB_COLORS,&pvBits,NULL,0);
	if (!m_hBM)
	{
	    MessageBoxA(NULL,"Can't create DIB Section.","",MB_OK);
	    return NULL;
	}

	// create DC for our DIB
	m_hDC=CreateCompatibleDC(hdcWnd);
	m_hBMOld=(HBITMAP)SelectObject(m_hDC,m_hBM);

	// Set the background to main window background
	BitBlt(m_hDC, 0, 0, (int)TESTAREAWIDTH, (int)TESTAREAHEIGHT, hdcWnd, nOffsetX, nOffsetY, SRCCOPY);
//	PatBlt(m_hDC, 0, 0, (int)TESTAREAWIDTH, (int)TESTAREAHEIGHT, WHITENESS);           

//	if (m_nBits == 32)
//		g = Graphics::FromDib32(pvBits, rClient.right, rClient.bottom);
//	else
		g = Graphics::FromHDC(m_hDC);

	// Since we are doing the test on another surface
	nOffsetX=0;
	nOffsetY=0;

	ReleaseDC(g_FuncTest.m_hWndMain,hdcWnd);

	return g;
}

void CFile::PostDraw(RECT rTestArea)
{
	char *szTitle="TestDIB.bmp";
	HDC hdcOrig = GetDC(g_FuncTest.m_hWndMain);

	// blit from the DIB to screen so we see the results, we use
	// GDI for this.

	BitBlt(hdcOrig, rTestArea.left, rTestArea.top, (int)TESTAREAWIDTH, (int)TESTAREAHEIGHT, m_hDC, 0, 0, SRCCOPY);

    BOOL success = WriteBitmap(szTitle, m_hBM, (int)TESTAREAWIDTH, (int)TESTAREAHEIGHT);

	ReleaseDC(g_FuncTest.m_hWndMain,hdcOrig);
	SelectObject(m_hDC,m_hBMOld);
	DeleteDC(m_hDC);
	DeleteObject(m_hBM);
}

void CFile::InitPalettes()
{
	BYTE red=0,green=0,blue=0;
	RGBQUAD1 rgbQuad1 = { { 0, 0, 0, 0 }, 
		                  { 0xff, 0xff, 0xff, 0 } };
	RGBQUAD2 rgbQuad2 = { { 0x80, 0x80, 0x80, 0 },
		                  { 0x80, 0, 0, 0 },
			              { 0, 0x80, 0, 0 },
				          { 0, 0, 0x80, 0 } };
	RGBQUAD4 rgbQuad4 =	{  // B    G    R
							{ 0,   0,   0,   0 },       // 0
							{ 0,   0,   0x80,0 },       // 1
							{ 0,   0x80,0,   0 },       // 2
							{ 0,   0x80,0x80,0 },       // 3
							{ 0x80,0,   0,   0 },       // 4
							{ 0x80,0,   0x80,0 },       // 5
							{ 0x80,0x80,0,   0 },       // 6
							{ 0x80,0x80,0x80,0 },       // 7
							{ 0xC0,0xC0,0xC0,0 },       // 8
							{ 0,   0,   0xFF,0 },       // 9
							{ 0,   0xFF,0,   0 },       // 10
							{ 0,   0xFF,0xFF,0 },       // 11
							{ 0xFF,0,   0,   0 },       // 12
							{ 0xFF,0,   0xFF,0 },       // 13
							{ 0xFF,0xFF,0,   0 },       // 14
							{ 0xFF,0xFF,0xFF,0 } };     // 15
	RGBQUAD16 rgbQuad16 = { { 0, 0x7c, 0, 0 }, { 0xe0, 03, 0, 0 }, { 0x1f, 0, 0, 0 } };
	RGBQUAD24 rgbQuad24 = { { 0, 0, 0xff, 0 }, { 0, 0xff, 0, 0 }, { 0xff, 0, 0, 0 } };
	RGBQUAD32 rgbQuad32 = { { 0, 0, 0xff, 0 }, { 0, 0xff, 0, 0 }, { 0xff, 0, 0 ,0 } };

	memcpy(m_rgbQuad1,rgbQuad1,sizeof(rgbQuad1));
	memcpy(m_rgbQuad2,rgbQuad2,sizeof(rgbQuad2));
	memcpy(m_rgbQuad4,rgbQuad4,sizeof(rgbQuad4));
	memcpy(m_rgbQuad16,rgbQuad16,sizeof(rgbQuad16));
	memcpy(m_rgbQuad24,rgbQuad24,sizeof(rgbQuad24));
	memcpy(m_rgbQuad32,rgbQuad32,sizeof(rgbQuad32));

	ZeroMemory(m_rgbQuad8,sizeof(m_rgbQuad8));
	for (INT i=0; i<256; i++)
	{
		m_rgbQuad8[i].rgbRed=red;
		m_rgbQuad8[i].rgbGreen=green;
		m_rgbQuad8[i].rgbBlue=blue;

		if (!(red+=32))
		{
			if (!(green+=32))
			{
				blue+=64;
			}
		}
	}

	// for system colors (last 20), use those from 4 bpp palette table.
	for (INT j=248; j<256; j++)
	{
		m_rgbQuad8[j].rgbRed=m_rgbQuad4[j-240].rgbRed;
		m_rgbQuad8[j].rgbGreen=m_rgbQuad4[j-240].rgbGreen;
		m_rgbQuad8[j].rgbBlue=m_rgbQuad4[j-240].rgbBlue;
	}
}

BOOL CFile::WriteBitmap(char *szTitle, HBITMAP hbitmap, INT width, INT height)
{
    BITMAPFILEHEADER    fileHeader;
    BITMAPINFOHEADER    infoHeader;

    memset(&fileHeader, 0, sizeof(fileHeader));
    memset(&infoHeader, 0, sizeof(infoHeader));

    fileHeader.bfType = 0x4d42;
    fileHeader.bfOffBits = sizeof(fileHeader) + sizeof(infoHeader);

    infoHeader.biSize = sizeof(infoHeader);
    infoHeader.biPlanes = 1;
    infoHeader.biWidth = width;
    infoHeader.biHeight = height;
    infoHeader.biBitCount = 24;
    infoHeader.biXPelsPerMeter = 3780;
    infoHeader.biYPelsPerMeter = 3780;

    BITMAPINFO bmInfo;
    bmInfo.bmiHeader = infoHeader;
    VOID* bits = malloc(infoHeader.biWidth*infoHeader.biHeight*3);

    BOOL success = FALSE;

    if(bits)
    {
        HDC hdc = CreateCompatibleDC(NULL);
        INT n = GetDIBits(hdc, hbitmap, 0, height,
            bits, &bmInfo, DIB_RGB_COLORS);

        infoHeader.biHeight = n;
        INT bitsSize = infoHeader.biHeight*infoHeader.biWidth*3;
        fileHeader.bfSize = sizeof(fileHeader) + sizeof(infoHeader)
            + bitsSize;

        DeleteDC(hdc);

        HANDLE hFile = CreateFileA(szTitle,
            GENERIC_WRITE,
            0,
            NULL,
            CREATE_ALWAYS,
            FILE_ATTRIBUTE_NORMAL,
            NULL);

        BOOL deleteFile = FALSE;
        DWORD dwPtr;
        DWORD dwError;

        if(hFile == INVALID_HANDLE_VALUE)
            goto cleanUp2;

        dwPtr = SetFilePointer (hFile, 0, NULL, FILE_BEGIN) ; 

        dwError;

        if(dwPtr == 0xFFFFFFFF && (dwError = GetLastError()) != NO_ERROR)
        {
            deleteFile = TRUE;
            goto cleanUp1;
        }

        DWORD bytesToWrite;
        DWORD bytesWritten;

        bytesToWrite = sizeof(fileHeader);
        success = WriteFile(
                hFile,
                &fileHeader,
                bytesToWrite,
                &bytesWritten,
                NULL);

        if(!success || bytesWritten != bytesToWrite)
        {
            success = FALSE;
            deleteFile = TRUE;
            goto cleanUp1;
        }

        bytesToWrite = sizeof(infoHeader);
        success = WriteFile(
                hFile,
                &infoHeader,
                bytesToWrite,
                &bytesWritten,
                NULL);

        if(!success || bytesWritten != bytesToWrite)
        {
            success = FALSE;
            deleteFile = TRUE;
            goto cleanUp1;
        }

        bytesToWrite = bitsSize;
        success = WriteFile(
                hFile,
                bits,
                bytesToWrite,
                &bytesWritten,
                NULL);

        if(!success || bytesWritten != bytesToWrite)
        {
            success = FALSE;
            deleteFile = TRUE;
            goto cleanUp1;
        }

        success = TRUE;

cleanUp1:
        CloseHandle(hFile);
        if(deleteFile)
            DeleteFileA(szTitle);

cleanUp2:
        free(bits);
    }

    return success;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\functest\cfillmode.cpp ===
/******************************Module*Header*******************************\
* Module Name: CPaths.cpp
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/
#include "CFillMode.h"
#include <limits.h>

CFillMode::CFillMode(BOOL bRegression)
{
	strcpy(m_szName,"Test Winding Fill Mode");
	m_bRegression=bRegression;
}

CFillMode::~CFillMode()
{
}

VOID TestEscherNewPath(Graphics* g);

void CFillMode::Draw(Graphics *g)
{
    // Create an ALTERNATE non-zero winding fill mode path.

    GraphicsPath p1(FillModeAlternate);

    p1.AddEllipse(0, 0, 100, 100);
    p1.CloseFigure();


    GraphicsPath p2(FillModeAlternate);
    
    p2.AddEllipse(10, 10, 80, 80);
    p2.CloseFigure();
   
    // Both paths should be same direction.  Filling with even-odd rule
    // gives a donut while non-zero gives a filled circle.

    p1.AddPath(&p2, FALSE);

    LinearGradientBrush brush(Point(0,0), Point(100,100), Color(0xFF,0,0xFF,0), Color(0xFF, 0xFF, 0, 0));

    g->FillPath(&brush, &p1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\functest\cfillmode.h ===
/******************************Module*Header*******************************\
* Module Name: CFillMode.h
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/

#ifndef __CFILLMODE_H
#define __CFILLMODE_H

#include "CPrimitive.h"

class CFillMode : public CPrimitive  
{
public:
	CFillMode(BOOL bRegression);
	virtual ~CFillMode();

	void Draw(Graphics *g);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\functest\cfunctest.h ===
/******************************Module*Header*******************************\
* Module Name: CFuncTest.h
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/

#ifndef __CFUNCTEST_H
#define __CFUNCTEST_H

#include "Global.h"
#include "CPrimitive.h"
#include "CSetting.h"
#include "COutput.h"

class CFuncTest  
{
public:
	CFuncTest();
	~CFuncTest();

	BOOL Init(HWND hWndParent);								// Initializes functest
	void RunOptions();										// Toggles option dialog
	static INT_PTR CALLBACK DlgProc(HWND hWndDlg,UINT uMsg,WPARAM wParam,LPARAM lParam);

	BOOL AddPrimitive(CPrimitive *pPrimitive);				// Add a primitive to test list
	BOOL AddOutput(COutput *pOutput);						// Add a graphics output to test list
	BOOL AddSetting(CSetting *pSetting);					// Add a graphics setting to test list

	RECT GetTestRect(int nCol,int nRow);					// Gets the test area located at nCol/nRow
	void RunTest(COutput *pOutput,CPrimitive *pPrimitive);	// Runs a specific test on a specific output
	void InitRun();											// Must be called before running a series of tests
	void EndRun();											// Must be called after running a series of tests
	void Run();												// Run the selected tests
	void RunRegression();									// Run regression tests

	void ClearAllSettings();								// Sets all settings in the list box to m_bUseSetting=false

	HWND m_hWndMain;										// Main window
	HWND m_hWndDlg;											// Dialog window
	BOOL m_bUsePageDelay;									// Use page delay or page pause
	BOOL m_bEraseBkgd;										// Erase old test background
	BOOL m_bAppendTest;										// Appends test to previous tests
	int m_nPageDelay;										// Delay after each graphics page
	int m_nPageRow;											// Row to draw next test
	int m_nPageCol;											// Column to draw next test
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\functest\cfile.h ===
/******************************Module*Header*******************************\
* Module Name: CFile.h
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/

#ifndef __CFILE_H
#define __CFILE_H

#include "COutput.h"

typedef RGBQUAD RGBQUAD1[2];
typedef RGBQUAD RGBQUAD2[4];
typedef RGBQUAD RGBQUAD4[16];
typedef RGBQUAD RGBQUAD8[256];
typedef RGBQUAD RGBQUAD16[3];
typedef RGBQUAD RGBQUAD24[3];
typedef RGBQUAD RGBQUAD32[3];

class CFile : public COutput  
{
public:
	CFile(BOOL bRegression,int nBits);
	virtual ~CFile();

	Graphics *PreDraw(int &nOffsetX,int &nOffsetY);			// Set up graphics at the given X,Y offset
	void PostDraw(RECT rTestArea);							// Finish off graphics at rTestArea

	BOOL WriteBitmap(char *szTitle, HBITMAP hbitmap, INT width, INT height);
	void InitPalettes();									// Initialize palettes

	HDC m_hDC;												// DC of DIB
	HBITMAP m_hBM;											// Bitmap of DIB
	HBITMAP m_hBMOld;										// Bitmap of old drawing surface

	RGBQUAD1 m_rgbQuad1;									// 1 bit palette
	RGBQUAD2 m_rgbQuad2;									// 2 bit palette
	RGBQUAD4 m_rgbQuad4;									// 4 bit palette
	RGBQUAD8 m_rgbQuad8;									// 8 bit palette
	RGBQUAD16 m_rgbQuad16;									// 16 bit palette
	RGBQUAD24 m_rgbQuad24;									// 24 bit palette
	RGBQUAD32 m_rgbQuad32;									// 32 bit palette
	int m_nBits;											// # of bits to use
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\functest\cfunctest.cpp ===
/******************************Module*Header*******************************\
* Module Name: CFuncTest.cpp
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/

#undef UNICODE
#undef _UNICODE

#include "CFuncTest.h"
#include "Resource.h"
#include "CRegression.h"
#include "CHDC.h"

extern CFuncTest g_FuncTest;        // Initialized in Main.cpp
extern HBRUSH g_hbrBackground;      // Initialized in Main.cpp
extern CRegression g_Regression;    // Initialized in Main.cpp
extern CHDC g_HDC;                  // Initialized in Main.cpp
extern int g_nResult;               // Initialized in Main.cpp

CFuncTest::CFuncTest()
{
    m_hWndDlg=NULL;
    m_hWndMain=NULL;
    m_bUsePageDelay=true;           // Default use page delay or page pause
    m_bEraseBkgd=true;              // Default erace background
    m_bAppendTest=false;            // Default append test
    m_nPageDelay=1000;              // Default page delay
    m_nPageRow=0;
    m_nPageCol=0;
}

CFuncTest::~CFuncTest()
{
    EndDialog(m_hWndDlg,0);
    m_hWndDlg=NULL;
    m_hWndMain=NULL;
}

BOOL CFuncTest::Init(HWND hWndParent)
// Initializes functest
{
    HWND hWnd;
    char szDelay[10];

    m_hWndMain=hWndParent;

    // Create options dialog box
    m_hWndDlg=CreateDialogA(GetModuleHandleA(NULL),MAKEINTRESOURCEA(IDD_FUNCTEST),hWndParent,&DlgProc);
    if (m_hWndDlg==NULL)
        return false;

    // Set default options in dialog box using defaults in constructor
    if (m_bUsePageDelay)
    {
        hWnd=GetDlgItem(m_hWndDlg,IDC_PAGEDELAY);
        SendMessageA(hWnd,BM_SETCHECK,(WPARAM)BST_CHECKED,0);
    }
    else
    {
        hWnd=GetDlgItem(m_hWndDlg,IDC_PAGEPAUSE);
        SendMessageA(hWnd,BM_SETCHECK,(WPARAM)BST_CHECKED,0);
    }
    hWnd=GetDlgItem(m_hWndDlg,IDC_DELAY);
    SendMessageA(hWnd,WM_SETTEXT,0,(LPARAM)_itoa(m_nPageDelay,szDelay,10));
    if (m_bEraseBkgd)
    {
        hWnd=GetDlgItem(m_hWndDlg,IDC_ERASEBKGD);
        SendMessageA(hWnd,BM_SETCHECK,(WPARAM)BST_CHECKED,0);
    }
    if (m_bAppendTest)
    {
        hWnd=GetDlgItem(m_hWndDlg,IDC_APPENDTEST);
        SendMessageA(hWnd,BM_SETCHECK,(WPARAM)BST_CHECKED,0);
    }

    return true;
}

void CFuncTest::RunOptions()
// Toggle options dialog box
{
    if (m_hWndDlg!=NULL)
    {
        if (!IsWindowVisible(m_hWndDlg))
            ShowWindow(m_hWndDlg,SW_SHOW);
        else
            ShowWindow(m_hWndDlg,SW_HIDE);
    }
}

BOOL CFuncTest::AddPrimitive(CPrimitive *pPrimitive)
// Adds a primitive to the primitive test list in options dialog box
{
    HWND hWnd;
    LRESULT iItem;

    hWnd=GetDlgItem(m_hWndDlg,IDC_PRIMITIVES);

    SendMessageA(hWnd,LB_SETSEL,(WPARAM)false,0);    // Reset selection

    iItem=SendMessageA(hWnd,LB_ADDSTRING,0,(LPARAM)pPrimitive->m_szName);
    if (iItem<0)
        return false;

    SendMessageA(hWnd,LB_SETSEL,(WPARAM)true,0);     // Pick top element as selection

    // Data is a pointer to the primitive base class
    SendMessageA(hWnd,LB_SETITEMDATA,(WPARAM)iItem,(LPARAM)pPrimitive);

    return true;
}

BOOL CFuncTest::AddOutput(COutput *pOutput)
// Adds an output to the output list in options dialog box
{
    HWND hWnd;
    LRESULT iItem;

    hWnd=GetDlgItem(m_hWndDlg,IDC_OUTPUTS);

    SendMessageA(hWnd,LB_SETSEL,(WPARAM)false,0);    // Reset selection

    iItem=SendMessageA(hWnd,LB_ADDSTRING,0,(LPARAM)pOutput->m_szName);
    if (iItem<0)
        return false;

    SendMessageA(hWnd,LB_SETSEL,(WPARAM)true,0);     // Pick top element as selection

    // Data is a pointer to the output base class
    SendMessageA(hWnd,LB_SETITEMDATA,(WPARAM)iItem,(LPARAM)pOutput);

    return true;
}

BOOL CFuncTest::AddSetting(CSetting *pSetting)
// Adds a setting to the settings list in options dialog box
{
    HWND hWnd;
    LRESULT iItem;

    hWnd=GetDlgItem(m_hWndDlg,IDC_SETTINGS);
    iItem=SendMessageA(hWnd,LB_ADDSTRING,0,(LPARAM)pSetting->m_szName);
    if (iItem<0)
        return false;

    // Data is a pointer to the setting base class
    SendMessageA(hWnd,LB_SETITEMDATA,(WPARAM)iItem,(LPARAM)pSetting);

    return true;
}

RECT CFuncTest::GetTestRect(int nCol,int nRow)
{
    RECT Rect;

    // Create test area rect
    Rect.top=nRow*(int)TESTAREAHEIGHT;
    Rect.left=nCol*(int)TESTAREAWIDTH;
    Rect.right=Rect.left+(int)TESTAREAWIDTH;
    Rect.bottom=Rect.top+(int)TESTAREAHEIGHT;

    return Rect;
}

void CFuncTest::RunTest(COutput *pOutput,CPrimitive *pPrimitive)
// Runs one test using the given output, primitive, and settings that have m_bUseSetting=true
{
    char szBuffer[256];
    MSG Msg;
    Graphics *g=NULL;
    CSetting *pSetting;
    RECT Rect;
    HDC hDC;
    HWND hWnd;
    int iItem;
    LRESULT cItemMax;
    int nX;
    int nY;
    BOOL bFirstSetting=true;

    __try
    {
        sprintf(szBuffer,"%s on %s",pPrimitive->m_szName,pOutput->m_szName);

        Rect=GetTestRect(m_nPageCol,m_nPageRow);    // Get test area

        // Clear test area
        if (m_bEraseBkgd)
        {
            hDC=GetDC(m_hWndMain);
            FillRect(hDC,&Rect,g_hbrBackground);
            ReleaseDC(m_hWndMain,hDC);
        }

        // Initialize output and get graphics pointer
        // Let pOutput modify the nX,nY in case we are drawing to a dib, we do not
        //   want to be translating.
        nX=Rect.left;
        nY=Rect.top;
        g=pOutput->PreDraw(nX,nY);
        if (g==NULL)
            return;

        // Move test to test area
        g->TranslateTransform((float)nX,(float)nY);

        // Set each setting in the list box
        hWnd=GetDlgItem(m_hWndDlg,IDC_SETTINGS);
        cItemMax=SendMessageA(hWnd,LB_GETCOUNT,0,0);
        for (iItem=0;iItem<cItemMax;iItem++) {
            pSetting=(CSetting*)SendMessageA(hWnd,LB_GETITEMDATA,(WPARAM)iItem,0);
            pSetting->Set(g);
            if (pSetting->m_bUseSetting)
            {
                if (bFirstSetting)
                {
                    strcat(szBuffer," (");
                    bFirstSetting=false;
                }
                else
                {
                    strcat(szBuffer,", ");
                }
                strcat(szBuffer,pSetting->m_szName);
            }
        }
        if (!bFirstSetting)
            strcat(szBuffer,")");

        // We do have some primitives (CachedBitmap) which don't respect the 
        // world transform so we need some way to access the offset to the
        // test rectangle.

        pPrimitive->SetOffset(nX, nY);

        // Draw primitive test
        pPrimitive->Draw(g);

        // Destroy graphics pointer
        delete g;

        // Finish off the output
        pOutput->PostDraw(Rect);

        // Write description of test
        hDC=GetDC(m_hWndMain);
        SetBkMode(hDC,TRANSPARENT);
        DrawTextA(hDC,szBuffer,-1,&Rect,DT_CENTER|DT_WORDBREAK);
        ReleaseDC(m_hWndMain,hDC);

        // Determine page col/row where next test will be drawn
        GetClientRect(m_hWndMain,&Rect);
        m_nPageCol++;
        if (m_nPageCol*TESTAREAWIDTH+TESTAREAWIDTH>Rect.right)
        {
            m_nPageCol=0;
            m_nPageRow++;
            if (m_nPageRow*TESTAREAHEIGHT+TESTAREAHEIGHT>Rect.bottom)
            // If graphics page is full, wait or pause
            {
                m_nPageRow=0;
                if (m_bUsePageDelay)
                    Sleep(m_nPageDelay);        // Wait
                else
                {                               // Pause for next input message
                    // Clear old input messages
                    while (GetInputState())
                        PeekMessageA(&Msg,NULL,0,0,PM_REMOVE);

                    // Wait for new input message
                    while (!GetInputState())
                        Sleep(100);
                }
            }
        }
    }__except(EXCEPTION_ACCESS_VIOLATION,1){
        printf("%s caused AV\n",szBuffer);
        g_nResult=1;                       // Return 1 if there was an AV
    }
}

void CFuncTest::InitRun()
// Initialise test run, grabs all info from the options dialog box
{
    HWND hWnd;
    char szDelay[10];
    RECT Rect;
    HDC hDC;

    // Hide options dialog
//  ShowWindow(m_hWndDlg,SW_HIDE);

    // Grab options
    hWnd=GetDlgItem(m_hWndDlg,IDC_PAGEDELAY);
    if (SendMessageA(hWnd,BM_GETCHECK,0,0)==BST_CHECKED)
        m_bUsePageDelay=true;
    else
        m_bUsePageDelay=false;

    hWnd=GetDlgItem(m_hWndDlg,IDC_DELAY);
    SendMessageA(hWnd,WM_GETTEXT,(WPARAM)10,(LPARAM)szDelay);
    m_nPageDelay=atoi(szDelay);

    hWnd=GetDlgItem(m_hWndDlg,IDC_ERASEBKGD);
    if (SendMessageA(hWnd,BM_GETCHECK,0,0)==BST_CHECKED)
        m_bEraseBkgd=true;
    else
        m_bEraseBkgd=false;

    hWnd=GetDlgItem(m_hWndDlg,IDC_APPENDTEST);
    if (SendMessageA(hWnd,BM_GETCHECK,0,0)==BST_CHECKED)
        m_bAppendTest=true;
    else
        m_bAppendTest=false;

    // Erase entire main window
    if (!m_bAppendTest && m_bEraseBkgd)
    {
        GetClientRect(m_hWndMain,&Rect);
        hDC=GetDC(m_hWndMain);
        FillRect(hDC,&Rect,g_hbrBackground);
        ReleaseDC(m_hWndMain,hDC);
    }

    if (!m_bAppendTest)
    {
        // Reset page row/col
        m_nPageRow=0;
        m_nPageCol=0;
    }
}

void CFuncTest::EndRun()
{
    int nX;
    int nY;
    RECT rTestArea;
    RECT rWindow;
    HDC hDC;

    hDC=GetDC(m_hWndMain);
    GetClientRect(m_hWndMain,&rWindow);

    // Draw lines on bottom right corner of last test
    // Figure out what was the last m_nPageCol and m_nPageRow
    nX=m_nPageCol-1;
    nY=m_nPageRow;
    if (nX<0) {
        nX=(rWindow.right/(int)TESTAREAWIDTH)-1;
        nY--;
        if (nY<0) {
            nY=(rWindow.bottom/(int)TESTAREAHEIGHT)-1;
        }
    }
    // Get the x,y coordinates
    nX=nX*(int)TESTAREAWIDTH;
    nY=nY*(int)TESTAREAHEIGHT;
    // Draw both lines
    Rectangle(hDC,nX+(int)TESTAREAWIDTH-3,nY,nX+(int)TESTAREAWIDTH,nY+(int)TESTAREAHEIGHT);
    Rectangle(hDC,nX,nY+(int)TESTAREAHEIGHT-3,nX+(int)TESTAREAWIDTH,nY+(int)TESTAREAWIDTH);

    // Clear the rest of the test areas on page
    if (m_bEraseBkgd)
    {
        nX=m_nPageCol;
        nY=m_nPageRow;
        while ((nX>0) || (nY>0))
        {
            rTestArea=GetTestRect(nX,nY);
            FillRect(hDC,&rTestArea,g_hbrBackground);
            nX++;
            if (nX*TESTAREAWIDTH+TESTAREAWIDTH>rWindow.right)
            {
                nX=0;
                nY++;
                if (nY*TESTAREAHEIGHT+TESTAREAHEIGHT>rWindow.bottom)
                // If graphics page is full
                {
                    nY=0;
                }
            }
        }
    }

    ReleaseDC(m_hWndMain,hDC);
}

void CFuncTest::Run()
// Runs all selected tests
{
    COutput *pOutput;
    CPrimitive *pPrimitive;
    CSetting *pSetting;
    HWND hWnd;
    HWND hWndOutput;
    int iOutput;
    LRESULT cOutputMax;
    int iItem;
    LRESULT cItemMax;

    InitRun();      // Init test run

    // Do the selected output loop
    hWndOutput=GetDlgItem(m_hWndDlg,IDC_OUTPUTS);
    cOutputMax=SendMessageA(hWndOutput,LB_GETCOUNT,0,0);
    for (iOutput=0;iOutput<cOutputMax;iOutput++) {
        pOutput=(COutput*)SendMessageA(hWndOutput,LB_GETITEMDATA,(WPARAM)iOutput,0);
        if (SendMessageA(hWndOutput,LB_GETSEL,(WPARAM)iOutput,0)<=0)
            continue;

        // Set each setting according to what is selected in the list box
        hWnd=GetDlgItem(m_hWndDlg,IDC_SETTINGS);
        cItemMax=SendMessageA(hWnd,LB_GETCOUNT,0,0);
        for (iItem=0;iItem<cItemMax;iItem++) {
            pSetting=(CSetting*)SendMessageA(hWnd,LB_GETITEMDATA,(WPARAM)iItem,0);

            if (SendMessageA(hWnd,LB_GETSEL,(WPARAM)iItem,0)>0)
                pSetting->m_bUseSetting=true;
            else
                pSetting->m_bUseSetting=false;
        }

        // Draw each primitive selected in the list box
        hWnd=GetDlgItem(m_hWndDlg,IDC_PRIMITIVES);
        cItemMax=SendMessageA(hWnd,LB_GETCOUNT,0,0);
        for (iItem=0;iItem<cItemMax;iItem++) {
            pPrimitive=(CPrimitive*)SendMessageA(hWnd,LB_GETITEMDATA,(WPARAM)iItem,0);

            if (SendMessageA(hWnd,LB_GETSEL,(WPARAM)iItem,0)>0)
                RunTest(pOutput,pPrimitive);
        }
    }

    EndRun();
}

void CFuncTest::RunRegression()
// Runs regression test suite
{
    COutput *pOutput;
    CPrimitive *pPrimitive;
    CSetting *pSetting;
    HWND hWnd;
    HWND hWndOutput;
    int iOutput;
    LRESULT cOutputMax;
    int iItem;
    LRESULT cItemMax;

    InitRun();      // Init test run

    // Do the output regression loop
    hWndOutput=GetDlgItem(m_hWndDlg,IDC_OUTPUTS);
    cOutputMax=SendMessageA(hWndOutput,LB_GETCOUNT,0,0);
    for (iOutput=0;iOutput<cOutputMax;iOutput++) {
        pOutput=(COutput*)SendMessageA(hWndOutput,LB_GETITEMDATA,(WPARAM)iOutput,0);
        if (!pOutput->m_bRegression)
            continue;

        ClearAllSettings();
        RunTest(pOutput,&g_Regression);
    }

    // Do the primitive regression loop
    hWnd=GetDlgItem(m_hWndDlg,IDC_PRIMITIVES);
    cItemMax=SendMessageA(hWnd,LB_GETCOUNT,0,0);
    for (iItem=0;iItem<cItemMax;iItem++) {
        pPrimitive=(CPrimitive*)SendMessageA(hWnd,LB_GETITEMDATA,(WPARAM)iItem,0);
        if (!pPrimitive->m_bRegression)
            continue;

        ClearAllSettings();
        RunTest(&g_HDC,pPrimitive);
    }

    // Do the settings regression loop
    hWnd=GetDlgItem(m_hWndDlg,IDC_SETTINGS);
    cItemMax=SendMessageA(hWnd,LB_GETCOUNT,0,0);
    for (iItem=0;iItem<cItemMax;iItem++) {
        pSetting=(CSetting*)SendMessageA(hWnd,LB_GETITEMDATA,(WPARAM)iItem,0);
        if (!pSetting->m_bRegression)
            continue;

        ClearAllSettings();
        pSetting->m_bUseSetting=true;
        RunTest(&g_HDC,&g_Regression);
    }

    EndRun();
}

void CFuncTest::ClearAllSettings()
// Clear all settings to m_bUseSetting=false
{
    CSetting *pSetting;
    HWND hWnd;
    LRESULT cItemMax;
    int iItem;

    // Set all settings off
    hWnd=GetDlgItem(m_hWndDlg,IDC_SETTINGS);
    cItemMax=SendMessageA(hWnd,LB_GETCOUNT,0,0);
    for (iItem=0;iItem<cItemMax;iItem++) {
        pSetting=(CSetting*)SendMessageA(hWnd,LB_GETITEMDATA,(WPARAM)iItem,0);
        pSetting->m_bUseSetting=false;
    }
}

INT_PTR CALLBACK CFuncTest::DlgProc(HWND hWndDlg,UINT Msg,WPARAM wParam,LPARAM lParam)
// Options dialog proc
{
    switch (Msg)
    {
        case WM_INITDIALOG:
            return true;
        case WM_COMMAND:
            if (HIWORD(wParam)==BN_CLICKED)
            {
                switch (LOWORD(wParam))
                {
                    case IDC_RUN:
                        g_FuncTest.Run();
                        return true;
                    case IDC_REGRESSION:
                        g_FuncTest.RunRegression();
                        return true;
                }
            }
            else if (HIWORD(wParam)==LBN_DBLCLK)
            {
                switch (LOWORD(wParam))
                {
                    case IDC_PRIMITIVES:
                        g_FuncTest.Run();
                        return true;
                }
            }
            break;
        case WM_CLOSE:
            ShowWindow(hWndDlg,SW_HIDE);
            return true;
    }

    return false;
}

#define UNICODE
#define _UNICODE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\functest\chalfpixel.cpp ===
/******************************Module*Header*******************************\
* Module Name: CAntialias.cpp
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/
#include "CHalfPixel.h"

CHalfPixel::CHalfPixel(BOOL bRegression)
{
	strcpy(m_szName,"Half Pixel Offset");
	m_bRegression=bRegression;
}

CHalfPixel::~CHalfPixel()
{
}

void CHalfPixel::Set(Graphics *g)
{
    g->SetPixelOffsetMode(
        m_bUseSetting ? PixelOffsetModeHalf : PixelOffsetModeNone
    );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\functest\cgradients.cpp ===
/******************************Module*Header*******************************\
* Module Name: CGradients.cpp
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/
#include "CGradients.h"

GraphicsPath *CreateHeartPath(const RectF& rect)
{
    GpPointF points[7];
    points[0].X = 0;
    points[0].Y = 0;
    points[1].X = 1.00;
    points[1].Y = -1.00;
    points[2].X = 2.00;
    points[2].Y = 1.00;
    points[3].X = 0;
    points[3].Y = 2.00;
    points[4].X = -2.00;
    points[4].Y = 1.00;
    points[5].X = -1.00;
    points[5].Y = -1.00;
    points[6].X = 0;
    points[6].Y = 0;

    Matrix matrix;

    matrix.Scale(rect.Width/2, rect.Height/3, MatrixOrderAppend);
    matrix.Translate(3*rect.Width/2, 4*rect.Height/3, MatrixOrderAppend);
    matrix.TransformPoints(&points[0], 7);

    GraphicsPath* path = new GraphicsPath();
    
    if(path)
    {
        path->AddBeziers(&points[0], 7);
        path->CloseFigure();
    }

    return path;
}

CScaledGradients::CScaledGradients(BOOL bRegression)
{
	strcpy(m_szName,"Gradient : Path,Scaled,Tiled");
	m_bRegression=bRegression;
}

void CScaledGradients::Draw(Graphics *g)
{
    Status st;

    RectF heartRect(-100,0,500,500);
    GraphicsPath *heartPath = CreateHeartPath(heartRect);
    Matrix matrix;
    matrix.Translate(-460, -480);
    st = heartPath->Flatten(&matrix);
    
    Bitmap bitmap(250,250);

    Graphics *bg = Graphics::FromImage(&bitmap);

    PathGradientBrush pathGrad(heartPath);

    INT count = 3;
    REAL blend[3];
    blend[0] = (REAL) 0;
    blend[1] = (REAL) 0.5;
    blend[2] = (REAL) 1;
    REAL positions[3];
    positions[0] = (REAL) 0;
    positions[1] = (REAL) 0.4;
    positions[2] = (REAL) 1;
    
    st = pathGrad.SetBlend(&blend[0], &positions[0], count);
    st = pathGrad.SetCenterColor(Color(128,0,128,80));
    st = pathGrad.SetWrapMode(WrapModeTileFlipXY);

    count = heartPath->GetPointCount();
    Color* surColors = (Color*)new Color[count];
    INT iColor = 255/count;
    for (INT i=0; i<count; i++)
    {
        float pos = (float)i/(count-1);
        surColors[i].SetValue(
            (((INT)(255.0f-i))   << 24) | 
            (((INT)(255.0f*pos)) << 16) | 
            ((INT)(255.0f*(1.0f-pos)))
        );
    }
    st = pathGrad.SetSurroundColors(surColors, &count);

    GraphicsPath r1, r2;
    RectF sqrect(0,140,600,1000);
    r1.AddRectangle(sqrect);
    sqrect.Width *= 2.3f;
    r2.AddRectangle(sqrect);

    st = bg->ScaleTransform(0.2f, 0.2f);
    
    st = bg->FillPath(&pathGrad, &r1);
    st = bg->TranslateTransform(400, 0);
    st = bg->ScaleTransform(0.66f, 1.33f);
    st = bg->FillPath(&pathGrad, &r2);

    st = g->DrawImage(&bitmap,0,0,0,0,250,250,UnitPixel);

    delete heartPath;
    delete surColors;
    delete bg;
}

CGradients::CGradients(BOOL bRegression)
{
	strcpy(m_szName,"Gradient : Misc");
	m_bRegression=bRegression;
}

void CGradients::Draw(Graphics *g)
{
    // Test FillRectangle call
    Color rc1(0xFF,0xFF,0,0);       // red
    Color rc2(0xFF,0xFF,0,0); 
    Color rc3(0x80,0xFF,0,0); 
    Color rc4(0x80,0,0xff,0);
    Color rc5(0x40,0,0,0xff); 
    Color rc6(0x40,0x80,0x80,0);

    SolidBrush rcb1(rc1);
    SolidBrush rcb2(rc2);
    SolidBrush rcb3(rc3);
    SolidBrush rcb4(rc4);
    SolidBrush rcb5(rc5);
    SolidBrush rcb6(rc6);

    g->FillRectangle(&rcb1, RectF((int)(0.0f/360.0f*TESTAREAWIDTH), (int)(0.0f/360.0f*TESTAREAHEIGHT), (int)(50.0f/360.0f*TESTAREAWIDTH), (int)(50.0f/360.0f*TESTAREAHEIGHT)));
    g->FillRectangle(&rcb2, RectF((int)(50.0f/360.0f*TESTAREAWIDTH), (int)(0.0f/360.0f*TESTAREAHEIGHT), (int)(50.0f/360.0f*TESTAREAWIDTH), (int)(50.0f/360.0f*TESTAREAHEIGHT)));
    g->FillRectangle(&rcb3, RectF((int)(100.0f/360.0f*TESTAREAWIDTH), (int)(0.0f/360.0f*TESTAREAHEIGHT), (int)(50.0f/360.0f*TESTAREAWIDTH), (int)(50.0f/360.0f*TESTAREAHEIGHT)));
    g->FillRectangle(&rcb4, RectF((int)(150.0f/360.0f*TESTAREAWIDTH), (int)(0.0f/360.0f*TESTAREAHEIGHT), (int)(50.0f/360.0f*TESTAREAWIDTH), (int)(50.0f/360.0f*TESTAREAHEIGHT)));
    g->FillRectangle(&rcb5, RectF((int)(200.0f/360.0f*TESTAREAWIDTH), (int)(0.0f/360.0f*TESTAREAHEIGHT), (int)(50.0f/360.0f*TESTAREAWIDTH), (int)(50.0f/360.0f*TESTAREAHEIGHT)));
    g->FillRectangle(&rcb6, RectF((int)(250.0f/360.0f*TESTAREAWIDTH), (int)(0.0f/360.0f*TESTAREAHEIGHT), (int)(50.0f/360.0f*TESTAREAWIDTH), (int)(50.0f/360.0f*TESTAREAHEIGHT)));

    RectF rf[6] = {
        RectF((int)(0.0f/360.0f*TESTAREAWIDTH), (int)(50.0f/360.0f*TESTAREAHEIGHT), (int)(50.0f/360.0f*TESTAREAWIDTH), (int)(50.0f/360.0f*TESTAREAHEIGHT)),
        RectF((int)(50.0f/360.0f*TESTAREAWIDTH), (int)(50.0f/360.0f*TESTAREAHEIGHT), (int)(50.0f/360.0f*TESTAREAWIDTH), (int)(50.0f/360.0f*TESTAREAHEIGHT)),
        RectF((int)(100.0f/360.0f*TESTAREAWIDTH), (int)(50.0f/360.0f*TESTAREAHEIGHT), (int)(50.0f/360.0f*TESTAREAWIDTH), (int)(50.0f/360.0f*TESTAREAHEIGHT)),
        RectF((int)(150.0f/360.0f*TESTAREAWIDTH), (int)(50.0f/360.0f*TESTAREAHEIGHT), (int)(50.0f/360.0f*TESTAREAWIDTH), (int)(50.0f/360.0f*TESTAREAHEIGHT)),
        RectF((int)(200.0f/360.0f*TESTAREAWIDTH), (int)(50.0f/360.0f*TESTAREAHEIGHT), (int)(50.0f/360.0f*TESTAREAWIDTH), (int)(50.0f/360.0f*TESTAREAHEIGHT)),
        RectF((int)(250.0f/360.0f*TESTAREAWIDTH), (int)(50.0f/360.0f*TESTAREAHEIGHT), (int)(50.0f/360.0f*TESTAREAWIDTH), (int)(50.0f/360.0f*TESTAREAHEIGHT))
    };

    RectF polyRect;
    Color centerColor(255, 255, 255, 255);
    Color boundaryColor(255, 0, 0, 0);

    REAL width = 4; // Pen width

    // Create a rectangular gradient brush.

    RectF brushRect(0, 0, 3, 3);

    Color colors[5] = {
        Color(255, 255, 255, 255),
        Color(255, 255, 0, 0),
        Color(255, 0, 255, 0),
        Color(255, 0, 0, 255),
        Color(255, 0, 0, 0)
    };
    PointF points[7];


    // Rotate a brush.
    GpMatrix xForm;
    xForm.Rotate(155);

    // Change the wrapping mode and fill.

    REAL blend[10];
    Color presetColors[10];
    Color presetColorsb[10];
    REAL positions[10];
    INT count;

    Color blackColor(0, 0, 0);

    SolidBrush blackBrush(blackColor);
    Pen blackPen(&blackBrush, width);

    g->DrawRectangle(&blackPen, brushRect);

    // Create a radial gradient brush.

    brushRect.X = (int)(380.0f/360.0f*TESTAREAWIDTH);
    brushRect.Y = (int)(130.0f/360.0f*TESTAREAHEIGHT);
    brushRect.Width = (int)(60.0f/360.0f*TESTAREAWIDTH);
    brushRect.Height = (int)(32.0f/360.0f*TESTAREAHEIGHT);
    PointF center;
    center.X = brushRect.X + brushRect.Width/2;
    center.Y = brushRect.Y + brushRect.Height/2;
    xForm.Reset();
    xForm.RotateAt(-30, center, MatrixOrderAppend);
    
    // Triangle Gradient Brush no longer supported.
    
    points[0].X = (int)(200.0f/360.0f*TESTAREAWIDTH);
    points[0].Y = (int)(300.0f/360.0f*TESTAREAHEIGHT);
    points[1].X = (int)(280.0f/360.0f*TESTAREAWIDTH);
    points[1].Y = (int)(350.0f/360.0f*TESTAREAHEIGHT);
    points[2].X = (int)(220.0f/360.0f*TESTAREAWIDTH);
    points[2].Y = (int)(420.0f/360.0f*TESTAREAHEIGHT);
    points[3].X = (int)(160.0f/360.0f*TESTAREAWIDTH);
    points[3].Y = (int)(440.0f/360.0f*TESTAREAHEIGHT);
    points[4].X = (int)(120.0f/360.0f*TESTAREAWIDTH);
    points[4].Y = (int)(370.0f/360.0f*TESTAREAHEIGHT);

    Matrix matrix;
    matrix.Translate((int)(20.0f/360.0f*TESTAREAWIDTH), -(int)(160.0f/360.0f*TESTAREAHEIGHT));

    matrix.TransformPoints(points, 5);

    PathGradientBrush polyGrad(points, 5, WrapModeTile);

    count = 3;
    blend[0] = (REAL) 0;
    blend[1] = (REAL) 0;
    blend[2] = (REAL) 1;
    positions[0] = (REAL) 0;
    positions[1] = (REAL) 0.4;
    positions[2] = (REAL) 1;

    // Test for blending factors.

    polyGrad.SetBlend(&blend[0], &positions[0], count);

    polyGrad.SetCenterColor(centerColor);
    count = 5;
    polyGrad.SetSurroundColors(colors, &count);
    polyRect.X = 0;
    polyRect.Y = 0;
    polyRect.Width = (int) TESTAREAWIDTH;
    polyRect.Height = (int) TESTAREAHEIGHT;
    g->FillRectangle(&polyGrad, polyRect);

    // Create a heart shaped path.

    RectF rect;
    rect.X = (int)(300.0f/360.0f*TESTAREAWIDTH);
    rect.Y = (int)(300.0f/360.0f*TESTAREAHEIGHT);
    rect.Width = (int)(150.0f/360.0f*TESTAREAWIDTH);
    rect.Height = (int)(150.0f/360.0f*TESTAREAHEIGHT);
    GraphicsPath *path = CreateHeartPath(rect);

    // Create a gradient from a path.

    PathGradientBrush pathGrad(path);
    delete path;

    pathGrad.SetCenterColor(centerColor);
    count = pathGrad.GetSurroundColorCount();
    Color* surColors = (Color*)new Color[count];
    pathGrad.GetSurroundColors(surColors, &count);
    surColors[0] = Color(255, 255, 0, 0);
    count = 1;
    pathGrad.SetSurroundColors(surColors, &count);

    pathGrad.GetRectangle(&polyRect);

    // Set the rect focus.

    PointF centerPt;

    pathGrad.GetCenterPoint(&centerPt);
    centerPt.X -= 3;
    centerPt.Y += 6;
    pathGrad.SetCenterPoint(centerPt);
    REAL xScale, yScale;
    pathGrad.GetFocusScales(&xScale, &yScale);
    xScale = 0.4f;
    yScale = 0.3f;
    pathGrad.SetFocusScales(xScale, yScale);

    g->FillRectangle(&pathGrad, polyRect);

    RectF lineRect((int)(120.0f/360.0f*TESTAREAWIDTH), (int)(0.0f/360.0f*TESTAREAHEIGHT), (int)(200.0f/360.0f*TESTAREAWIDTH), (int)(60.0f/360.0f*TESTAREAHEIGHT));
    Color color1(200, 255, 255, 0);
    Color color2(200, 0, 0, 255);

    LinearGradientBrush LinearGrad(lineRect, color1, color1,
                        LinearGradientModeForwardDiagonal);

    RectF lineRectb((int)(120.0f/360.0f*TESTAREAWIDTH), (int)(300.0f/360.0f*TESTAREAHEIGHT), (int)(200.0f/360.0f*TESTAREAWIDTH), (int)(60.0f/360.0f*TESTAREAHEIGHT));
    Color color1b(20, 255, 255, 0);
    Color color2b(20, 0, 0, 255);

    LinearGradientBrush LinearGradb(lineRectb, color1b, color1b,
                        LinearGradientModeForwardDiagonal);

    // Test for preset colors

    presetColors[0] = Color(200, 0, 255, 255);
    presetColors[1] = Color(200, 255, 255, 0);
    presetColors[2] = Color(200, 0, 255, 0);
    presetColorsb[0] = Color(20, 0, 255, 255);
    presetColorsb[1] = Color(20, 255, 255, 0);
    presetColorsb[2] = Color(20, 0, 255, 0);
    count = 3;

    count = 3;
    blend[0] = (REAL) 0;
    blend[1] = (REAL) 0;
    blend[2] = (REAL) 1;
    positions[0] = (REAL) 0;
    positions[1] = (REAL) 0.4;
    positions[2] = (REAL) 1;

    LinearGrad.SetInterpolationColors(&presetColors[0], &positions[0], count);
    LinearGradb.SetInterpolationColors(&presetColorsb[0], &positions[0], count);

    g->FillRectangle(&LinearGrad, lineRect);
    g->FillRectangle(&LinearGradb, lineRectb);
    
    RectF rectl(90.0f/360.0f*TESTAREAWIDTH, 120.0f/360.0f*TESTAREAHEIGHT, 120.0f/360.0f*TESTAREAWIDTH, 120.0f/360.0f*TESTAREAHEIGHT);
    PointF pt1(rectl.X+rectl.Width/2.0f, rectl.Y);
    PointF pt2(rectl.X+rectl.Width/2.0f, rectl.Y+rectl.Height);

    LinearGradientBrush linbrush(pt1, pt2,
                                 Color(0xFF, 0xFF, 0, 0), 
                                 Color(0xFF, 0, 0xFF, 0));

    GraphicsPath pathl;
    pathl.AddRectangle(rectl);

    SolidBrush sbrush(Color(0xFF,0xFF,0,0));

    g->FillRectangle(&sbrush, rectl);
    g->FillPath(&linbrush, &pathl);
}


CAlphaGradient::CAlphaGradient(BOOL bRegression)
{
	strcpy(m_szName,"Gradient : Premultiplied Interpolation");
	m_bRegression=bRegression;
}

void CAlphaGradient::Draw(Graphics *g)
{
    GraphicsPath gp;
    
    PointF points[3];
    
    points[0].X = (int)(0.5f*TESTAREAWIDTH);
    points[0].Y = (int)(0.0f*TESTAREAHEIGHT);
    points[1].X = (int)(1.0f*TESTAREAWIDTH);
    points[1].Y = (int)(0.7f*TESTAREAHEIGHT);
    points[2].X = (int)(0.0f*TESTAREAWIDTH);
    points[2].Y = (int)(0.4f*TESTAREAHEIGHT);
    
    gp.AddPolygon(points, 3);
    
    Color colors[3] = { 0xffff0000, 0xff00ff00, 0x00000000 };
    int count = 3; 
    
    PathGradientBrush brush(&gp);
    brush.SetSurroundColors(colors, &count);
    
    brush.SetCenterColor(0xaa555500);
    brush.SetCenterPoint(PointF(
        (points[0].X+points[1].X+points[2].X)/3.0f,
        (points[0].Y+points[1].Y+points[2].Y)/3.0f
    ));
    
    g->FillPath(&brush, &gp);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\functest\chalfpixel.h ===
/******************************Module*Header*******************************\
* Module Name: CAntialias.h
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/

#ifndef __CHALFPIXEL_H
#define __CHALFPIXEL_H

#include "CSetting.h"

class CHalfPixel : public CSetting  
{
public:
	CHalfPixel(BOOL bRegression);
	virtual ~CHalfPixel();

	void Set(Graphics *g);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\functest\cgradients.h ===
/******************************Module*Header*******************************\
* Module Name: CGradients.h
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/

#ifndef __CGRADIENTS_H
#define __CGRADIENTS_H

#include "CPrimitive.h"

GraphicsPath *CreateHeartPath(const RectF& rect);

class CGradients : public CPrimitive  
{
public:
	CGradients(BOOL bRegression);
	void Draw(Graphics *g);
};

class CScaledGradients : public CPrimitive  
{
public:
	CScaledGradients(BOOL bRegression);
	void Draw(Graphics *g);
};

class CAlphaGradient : public CPrimitive  
{
public:
	CAlphaGradient(BOOL bRegression);
	void Draw(Graphics *g);
};


#define GRADIENT_GLOBALS \
CGradients g_Gradients(true); \
CScaledGradients g_ScaledGradients(true); \
CAlphaGradient g_AlphaGradient(true);

#define GRADIENT_INIT \
g_Gradients.Init();\
g_ScaledGradients.Init();\
g_AlphaGradient.Init();



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\functest\chalftone.h ===
/******************************Module*Header*******************************\
* Module Name: CHalftone.h
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/

#ifndef __CHALFTONE_H
#define __CHALFTONE_H

#include "CSetting.h"

class CHalftone : public CSetting  
{
public:
	CHalftone(BOOL bRegression);
	virtual ~CHalftone();

	void Set(Graphics *g);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\functest\chdc.h ===
/******************************Module*Header*******************************\
* Module Name: CHDC.h
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/

#ifndef __CHDC_H
#define __CHDC_H

#include "COutput.h"

class CHDC : public COutput  
{
public:
	CHDC(BOOL bRegression);
	virtual ~CHDC();

	Graphics *PreDraw(int &nOffsetX,int &nOffsetY);			// Set up graphics at the given X,Y offset
	void PostDraw(RECT rTestArea);							// Finish off graphics at rTestArea

	HPALETTE m_hPal;
	HPALETTE m_hOldPal;
	HDC m_hDC;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\functest\chwnd.h ===
/******************************Module*Header*******************************\
* Module Name: CHWND.h
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/

#ifndef __CHWND_H
#define __CHWND_H

#include "COutput.h"

class CHWND : public COutput  
{
public:
	CHWND(BOOL bRegression);
	virtual ~CHWND();

	Graphics *PreDraw(int &nOffsetX,int &nOffsetY);			// Set up graphics at the given X,Y offset
	void PostDraw(RECT rTestArea);							// Finish off graphics at rTestArea
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\functest\chatch.cpp ===
/******************************Module*Header*******************************\
* Module Name: CHatch.cpp
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/
#include "CHatch.h"
#include "CFuncTest.h"

extern CFuncTest g_FuncTest;

CHatch::CHatch(BOOL bRegression)
{
	strcpy(m_szName,"Hatch");
	m_bRegression=bRegression;
}

CHatch::~CHatch()
{
}

void CHatch::Set(Graphics *g)
{
    if (!m_bUseSetting)
    return;

    Color foreColor(50, 0 , 0, 0);
    Color backColor(128, 255, 255, 255);

    HatchBrush hatch(
        HatchStyleDiagonalCross, 
        foreColor, 
        backColor
    );

    g->FillRectangle(
        &hatch, 
        0, 0, 
        (int)TESTAREAWIDTH, 
        (int)TESTAREAHEIGHT
    );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\functest\chalftone.cpp ===
/******************************Module*Header*******************************\
* Module Name: CHalftone.cpp
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/
#include "CHalftone.h"

CHalftone::CHalftone(BOOL bRegression)
{
	strcpy(m_szName,"Halftone");
	m_bRegression=bRegression;
}

CHalftone::~CHalftone()
{

}

void CHalftone::Set(Graphics *g)
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\functest\chatch.h ===
/******************************Module*Header*******************************\
* Module Name: CHatch.h
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/

#ifndef __CHATCH_H
#define __CHATCH_H

#include "CSetting.h"

class CHatch : public CSetting
{
public:
	CHatch(BOOL bRegression);
	virtual ~CHatch();

	void Set(Graphics *g);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\functest\chwnd.cpp ===
/******************************Module*Header*******************************\
* Module Name: CHWND.cpp
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/
#include "CHWND.h"
#include "CFuncTest.h"
#include "CHalftone.h"

extern CFuncTest g_FuncTest;
extern CHalftone g_Halftone;

CHWND::CHWND(BOOL bRegression)
{
	strcpy(m_szName,"HWND");
	m_bRegression=bRegression;
}

CHWND::~CHWND()
{
}

Graphics *CHWND::PreDraw(int &nOffsetX,int &nOffsetY)
{
	Graphics *g=NULL;

	g=Graphics::FromHWND(g_FuncTest.m_hWndMain);

	return g;
}

void CHWND::PostDraw(RECT rTestArea)
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\functest\chdc.cpp ===
/******************************Module*Header*******************************\
* Module Name: CHDC.cpp
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/
#include "CHDC.h"
#include "CFuncTest.h"
#include "CHalftone.h"

extern CFuncTest g_FuncTest;
extern CHalftone g_Halftone;

CHDC::CHDC(BOOL bRegression)
{
	strcpy(m_szName,"HDC");
	m_hPal=NULL;
	m_hOldPal=NULL;
	m_hDC=NULL;
	m_bRegression=bRegression;
}

CHDC::~CHDC()
{
}

Graphics *CHDC::PreDraw(int &nOffsetX,int &nOffsetY)
{
	Graphics *g=NULL;

	m_hDC=GetDC(g_FuncTest.m_hWndMain);
	if (g_Halftone.m_bUseSetting)
	{
		m_hPal=DllExports::GdipCreateHalftonePalette();
		m_hOldPal=SelectPalette(m_hDC,m_hPal,FALSE);
		RealizePalette(m_hDC);
	}
	g=Graphics::FromHDC(m_hDC);

	return g;
}

void CHDC::PostDraw(RECT rTestArea)
{
	if (m_hOldPal)
		SelectPalette(m_hDC,m_hOldPal,FALSE);

	ReleaseDC(g_FuncTest.m_hWndMain,m_hDC);
	DeleteObject(m_hPal);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\functest\cinsetlines.h ===
/******************************Module*Header*******************************\
* Module Name: CInsetLines.h
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/

#ifndef __CINSETLINES_H
#define __CINSETLINES_H

#include "CPrimitive.h"

class CInsetLines : public CPrimitive  
{
public:
	CInsetLines(BOOL bRegression);
	void Draw(Graphics *g);
};

class CInset2 : public CPrimitive  
{
public:
	CInset2(BOOL bRegression);
	void Draw(Graphics *g);
};

class CInset3 : public CPrimitive  
{
public:
	CInset3(BOOL bRegression);
	void Draw(Graphics *g);
};

class CInset4 : public CPrimitive  
{
public:
	CInset4(BOOL bRegression);
	void Draw(Graphics *g);
};


#define INSET_GLOBALS \
CInsetLines g_Inset(true);\
CInset2 g_Inset2(true);\
CInset3 g_Inset3(true);\
CInset4 g_Inset4(true);

#define INSET_INIT \
g_Inset.Init();\
g_Inset2.Init();\
g_Inset3.Init();\
g_Inset4.Init();



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\functest\cimaging.h ===
/******************************Module*Header*******************************\
* Module Name: CImaging.h
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/

#ifndef __CIMAGING_H
#define __CIMAGING_H

#include "CPrimitive.h"

class CImaging : public CPrimitive  
{
public:
	CImaging(BOOL bRegression);
	virtual ~CImaging();

	void Draw(Graphics *g);

	static BOOL CALLBACK MyDrawImageAbort(VOID* data);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\functest\cimaging.cpp ===
/******************************Module*Header*******************************\
* Module Name: CImaging.cpp
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/
#include "CImaging.h"

CImaging::CImaging(BOOL bRegression)
{
	strcpy(m_szName,"Image : Misc");
	m_bRegression=bRegression;
}

CImaging::~CImaging()
{
}

BOOL CALLBACK CImaging::MyDrawImageAbort(VOID* data)
{
    UINT *count = (UINT*) data;

    *count += 1;

    return FALSE;
}

void CImaging::Draw(Graphics *g)
{

    Point points[4];
    REAL width = 4;     // Pen width

    WCHAR filename[256];
	wcscpy(filename,L"..\\data\\4x5_trans_Q60_cropped_1k.jpg");

    // Open the image with the appropriate ICM mode.

    Bitmap *bitmap = new Bitmap(filename, TRUE);

    // Create a texture brush.

    Unit u;
    RectF copyRect;
    bitmap->GetBounds(&copyRect, &u);

    // Choose an interesting portion of the source image to display
    // in the texture brush.

    copyRect.X = copyRect.Width/2-1;
    copyRect.Width = copyRect.Width/4-1;
    copyRect.X += copyRect.Width;
    copyRect.Height = copyRect.Height/2-1;
  
    // Our ICM profile is hacked to flip the red and blue color channels
    // Apply a recolor matrix to flip them back so that if something breaks
    // ICM, the picture will look blue instead of the familiar colors.

    ImageAttributes *img = new ImageAttributes();
    img->SetWrapMode(WrapModeTile, Color(0xffff0000), FALSE);
    ColorMatrix flipRedBlue = 
       {0, 0, 1, 0, 0,
        0, 1, 0, 0, 0,
        1, 0, 0, 0, 0,
        0, 0, 0, 1, 0,
        0, 0, 0, 0, 1};
    img->SetColorMatrix(&flipRedBlue);
    img->SetWrapMode(WrapModeTile, Color(0xffff0000), FALSE);

    // Create a texture brush.                      
    TextureBrush textureBrush(bitmap, copyRect, img);

    // Create a radial gradient pen.

    Color redColor(255, 0, 0);

    SolidBrush redBrush(redColor);
    Pen redPen(&redBrush, width);

    GraphicsPath *path;

    points[0].X = (int)((float)(100*3+300)/1024.0f*TESTAREAWIDTH);
    points[0].Y = (int)((float)(60*3-100)/768.0f*TESTAREAHEIGHT);
    points[1].X = (int)((float)(-50*3+300)/1024.0f*TESTAREAWIDTH);
    points[1].Y = (int)((float)(60*3-100)/768.0f*TESTAREAHEIGHT);
    points[2].X = (int)((float)(150*3+300)/1024.0f*TESTAREAWIDTH);
    points[2].Y = (int)((float)(250*3-100)/768.0f*TESTAREAHEIGHT);
    points[3].X = (int)((float)(200*3+300)/1024.0f*TESTAREAWIDTH);
    points[3].Y = (int)((float)(120*3-100)/768.0f*TESTAREAHEIGHT);
    path = new GraphicsPath(FillModeAlternate);
    path->AddBeziers(points, 4);    
    g->FillPath(&textureBrush, path);
    g->DrawPath(&redPen, path);

    delete img;
    delete path;
    delete bitmap;


    // Draw the apple png

    PointF destPoints[3];

    destPoints[0].X = (float)300/1024.0f*TESTAREAWIDTH;
    destPoints[0].Y = (float)50/768.0f*TESTAREAHEIGHT;
    destPoints[1].X = (float)450/1024.0f*TESTAREAWIDTH;
    destPoints[1].Y = (float)50/768.0f*TESTAREAHEIGHT;
    destPoints[2].X = (float)240/1024.0f*TESTAREAWIDTH;
    destPoints[2].Y = (float)200/768.0f*TESTAREAHEIGHT;
 
    Matrix mat;
    mat.Translate(0, 100);
    mat.TransformPoints(&destPoints[0], 3);
    wcscpy(filename, L"../data/apple1.png");
    bitmap = new Bitmap(filename);
    g->DrawImage(bitmap, &destPoints[0], 3);
 
    delete bitmap;


    // Draw the dog png

    destPoints[0].X = (float)30/1024.0f*TESTAREAWIDTH;
    destPoints[0].Y = (float)200/768.0f*TESTAREAHEIGHT;
    destPoints[1].X = (float)200/1024.0f*TESTAREAWIDTH;
    destPoints[1].Y = (float)200/768.0f*TESTAREAHEIGHT;
    destPoints[2].X = (float)200/1024.0f*TESTAREAWIDTH;
    destPoints[2].Y = (float)420/768.0f*TESTAREAHEIGHT;

    wcscpy(filename, L"..\\data\\dog2.png");
    bitmap = new Bitmap(filename);
    g->DrawImage(bitmap, &destPoints[0], 3);
    delete bitmap;
    
    // Draw the Balmer jpeg

    wcscpy(filename, L"..\\data\\ballmer.jpg");    
    bitmap = new Bitmap(filename);

    RectF destRect(
        TESTAREAWIDTH/2.0f, 
        TESTAREAHEIGHT/2.0f, 
        TESTAREAWIDTH/2.0f, 
        TESTAREAHEIGHT/2.0f
    );
    
    RectF srcRect;
    srcRect.X = 100;
    srcRect.Y = 40;
    srcRect.Width = 200;
    srcRect.Height = 200;

    g->DrawImage(
        bitmap, 
        destRect, 
        srcRect.X, 
        srcRect.Y,
        srcRect.Width, 
        srcRect.Height, 
        UnitPixel
    );

    delete bitmap;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\functest\clines.hpp ===
/**************************************************************************
*
* Copyright (c) 2000 Microsoft Corporation
*
* Module Name:
*
*   <an unabbreviated name for the module (not the filename)>
*
* Abstract:
*
*   <Description of what this module does>
*
* Notes:
*
*   <optional>
*
* Created:
*
*   08/28/2000 asecchia
*      Created it.
*
**************************************************************************/

#ifndef _CLINES_HPP
#define _CLINES_HPP


#include "CPrimitive.h"

class CLinesNominal : public CPrimitive
{
public:
	CLinesNominal(BOOL bRegression);
	void Draw(Graphics *g);
};

class CLinesFat : public CPrimitive
{
public:
	CLinesFat(BOOL bRegression);
	void Draw(Graphics *g);
};

class CLinesMirrorPen : public CPrimitive
{
public:
	CLinesMirrorPen(BOOL bRegression);
	void Draw(Graphics *g);
};


#define LINES_GLOBALS \
CLinesNominal g_LinesNominal(true);\
CLinesFat g_LinesFat(true);\
CLinesMirrorPen g_LinesMirrorPen(true);

#define LINES_INIT \
g_LinesNominal.Init();\
g_LinesFat.Init();\
g_LinesMirrorPen.Init();


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\functest\cinsetlines.cpp ===
/******************************Module*Header*******************************\
* Module Name: CInsetLines.cpp
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/
#include "CInsetLines.h"

CInsetLines::CInsetLines(BOOL bRegression)
{
	strcpy(m_szName,"Lines : Inset Pen");
	m_bRegression=bRegression;
}

void CInsetLines::Draw(Graphics *g)
{
    INT count = 5;
    BYTE t[] = {0x00, 0x01, 0x01, 0x01, 0x81};

    PointF p[5];

    p[0].X = 104.0f/450.0f*TESTAREAWIDTH;  p[0].Y = 98.0f/450.0f*TESTAREAHEIGHT;
    p[1].X = 379.0f/450.0f*TESTAREAWIDTH;  p[1].Y = 97.0f/450.0f*TESTAREAHEIGHT;
    p[2].X = 385.0f/450.0f*TESTAREAWIDTH;  p[2].Y = 355.0f/450.0f*TESTAREAHEIGHT;
    p[3].X = 249.0f/450.0f*TESTAREAWIDTH;  p[3].Y = 47.0f/450.0f*TESTAREAHEIGHT;
    p[4].X = 109.0f/450.0f*TESTAREAWIDTH;  p[4].Y = 350.0f/450.0f*TESTAREAHEIGHT;

    PointF p1[5];
    p1[0].X = 120.0f/450.0f*TESTAREAWIDTH;	p1[0].Y = 98.0f/450.0f*TESTAREAHEIGHT;
    p1[1].X = 362.0f/450.0f*TESTAREAWIDTH;	p1[1].Y = 64.0f/450.0f*TESTAREAHEIGHT;
    p1[2].X = 383.0f/450.0f*TESTAREAWIDTH;	p1[2].Y = 395.0f/450.0f*TESTAREAHEIGHT;
    p1[3].X = 92.0f/450.0f*TESTAREAWIDTH;	p1[3].Y = 394.0f/450.0f*TESTAREAHEIGHT;
    p1[4].X = 447.0f/450.0f*TESTAREAWIDTH;	p1[4].Y = 243.0f/450.0f*TESTAREAHEIGHT;

    GraphicsPath* path = new GraphicsPath(p1, t, count);
    path->CloseFigure();
    path->AddLine(50, 100, 150, 150);

    Color blackColor(0, 0, 0);

    SolidBrush brush(blackColor);

    REAL width = 10;
    Pen pen(&brush, width);
    pen.SetAlignment(PenAlignmentInset);
        
    g->DrawPath(&pen, path);

    delete path;
}

CInset2::CInset2(BOOL bRegression)
{
	strcpy(m_szName,"Lines : Inset Pen, Dash");
	m_bRegression=bRegression;
}

void CInset2::Draw(Graphics *g)
{
    INT count = 5;
    BYTE t[] = {0x00, 0x01, 0x01, 0x01, 0x81};

    PointF p[5];

    p[0].X = 104.0f/450.0f*TESTAREAWIDTH;  p[0].Y = 98.0f/450.0f*TESTAREAHEIGHT;
    p[1].X = 379.0f/450.0f*TESTAREAWIDTH;  p[1].Y = 97.0f/450.0f*TESTAREAHEIGHT;
    p[2].X = 385.0f/450.0f*TESTAREAWIDTH;  p[2].Y = 355.0f/450.0f*TESTAREAHEIGHT;
    p[3].X = 249.0f/450.0f*TESTAREAWIDTH;  p[3].Y = 47.0f/450.0f*TESTAREAHEIGHT;
    p[4].X = 109.0f/450.0f*TESTAREAWIDTH;  p[4].Y = 350.0f/450.0f*TESTAREAHEIGHT;

    PointF p1[5];
    p1[0].X = 120.0f/450.0f*TESTAREAWIDTH;	p1[0].Y = 98.0f/450.0f*TESTAREAHEIGHT;
    p1[1].X = 362.0f/450.0f*TESTAREAWIDTH;	p1[1].Y = 64.0f/450.0f*TESTAREAHEIGHT;
    p1[2].X = 383.0f/450.0f*TESTAREAWIDTH;	p1[2].Y = 395.0f/450.0f*TESTAREAHEIGHT;
    p1[3].X = 92.0f/450.0f*TESTAREAWIDTH;	p1[3].Y = 394.0f/450.0f*TESTAREAHEIGHT;
    p1[4].X = 447.0f/450.0f*TESTAREAWIDTH;	p1[4].Y = 243.0f/450.0f*TESTAREAHEIGHT;

    GraphicsPath* path = new GraphicsPath(p1, t, count);
    path->CloseFigure();
    path->AddLine(50, 100, 150, 150);

    Color blackColor(0, 0, 0);

    SolidBrush brush(blackColor);

    REAL width = 10.0f;
    Pen pen(&brush, width);
    pen.SetAlignment(PenAlignmentInset);
    pen.SetDashStyle(DashStyleDashDot);
    pen.SetDashCap(DashCapRound);
        
    g->DrawPath(&pen, path);

    delete path;
}


CInset3::CInset3(BOOL bRegression)
{
	strcpy(m_szName,"Lines : Inset Pen, Compound");
	m_bRegression=bRegression;
}

void CInset3::Draw(Graphics *g)
{
    INT count = 5;
    BYTE t[] = {0x00, 0x01, 0x01, 0x01, 0x81};

    PointF p[5];

    p[0].X = 104.0f/450.0f*TESTAREAWIDTH;  p[0].Y = 98.0f/450.0f*TESTAREAHEIGHT;
    p[1].X = 379.0f/450.0f*TESTAREAWIDTH;  p[1].Y = 97.0f/450.0f*TESTAREAHEIGHT;
    p[2].X = 385.0f/450.0f*TESTAREAWIDTH;  p[2].Y = 355.0f/450.0f*TESTAREAHEIGHT;
    p[3].X = 249.0f/450.0f*TESTAREAWIDTH;  p[3].Y = 47.0f/450.0f*TESTAREAHEIGHT;
    p[4].X = 109.0f/450.0f*TESTAREAWIDTH;  p[4].Y = 350.0f/450.0f*TESTAREAHEIGHT;

    PointF p1[5];
    p1[0].X = 120.0f/450.0f*TESTAREAWIDTH;	p1[0].Y = 98.0f/450.0f*TESTAREAHEIGHT;
    p1[1].X = 362.0f/450.0f*TESTAREAWIDTH;	p1[1].Y = 64.0f/450.0f*TESTAREAHEIGHT;
    p1[2].X = 383.0f/450.0f*TESTAREAWIDTH;	p1[2].Y = 395.0f/450.0f*TESTAREAHEIGHT;
    p1[3].X = 92.0f/450.0f*TESTAREAWIDTH;	p1[3].Y = 394.0f/450.0f*TESTAREAHEIGHT;
    p1[4].X = 447.0f/450.0f*TESTAREAWIDTH;	p1[4].Y = 243.0f/450.0f*TESTAREAHEIGHT;

    GraphicsPath* path = new GraphicsPath(p1, t, count);
    path->CloseFigure();
    path->AddLine(50, 100, 150, 150);

    Color blackColor(0, 0, 0);

    SolidBrush brush(blackColor);

    REAL width = 10.0f;
    Pen pen(&brush, width);
    pen.SetAlignment(PenAlignmentInset);
    
    float carray[4] = { 0.0f, 0.3f, 0.5f, 1.0f };
    pen.SetCompoundArray(carray, 4);
        
    g->DrawPath(&pen, path);

    delete path;
}

CInset4::CInset4(BOOL bRegression)
{
	strcpy(m_szName,"Lines : Compound, Dash");
	m_bRegression=bRegression;
}

void CInset4::Draw(Graphics *g)
{
    INT count = 5;
    BYTE t[] = {0x00, 0x01, 0x01, 0x01, 0x81};

    PointF p[5];

    p[0].X = 104.0f/450.0f*TESTAREAWIDTH;  p[0].Y = 98.0f/450.0f*TESTAREAHEIGHT;
    p[1].X = 379.0f/450.0f*TESTAREAWIDTH;  p[1].Y = 97.0f/450.0f*TESTAREAHEIGHT;
    p[2].X = 385.0f/450.0f*TESTAREAWIDTH;  p[2].Y = 355.0f/450.0f*TESTAREAHEIGHT;
    p[3].X = 249.0f/450.0f*TESTAREAWIDTH;  p[3].Y = 47.0f/450.0f*TESTAREAHEIGHT;
    p[4].X = 109.0f/450.0f*TESTAREAWIDTH;  p[4].Y = 350.0f/450.0f*TESTAREAHEIGHT;

    PointF p1[5];
    p1[0].X = 120.0f/450.0f*TESTAREAWIDTH;	p1[0].Y = 98.0f/450.0f*TESTAREAHEIGHT;
    p1[1].X = 362.0f/450.0f*TESTAREAWIDTH;	p1[1].Y = 64.0f/450.0f*TESTAREAHEIGHT;
    p1[2].X = 383.0f/450.0f*TESTAREAWIDTH;	p1[2].Y = 395.0f/450.0f*TESTAREAHEIGHT;
    p1[3].X = 92.0f/450.0f*TESTAREAWIDTH;	p1[3].Y = 394.0f/450.0f*TESTAREAHEIGHT;
    p1[4].X = 447.0f/450.0f*TESTAREAWIDTH;	p1[4].Y = 243.0f/450.0f*TESTAREAHEIGHT;

    GraphicsPath* path = new GraphicsPath(p1, t, count);
    path->CloseFigure();
    path->AddLine(50, 100, 150, 150);

    Color blackColor(0, 0, 0);

    SolidBrush brush(blackColor);

    REAL width = 10.0f;
    Pen pen(&brush, width);
    
    pen.SetDashCap(DashCapRound);
    pen.SetDashStyle(DashStyleDashDot);
    float carray[8] = { 0.0f, 0.15f, 0.25f, 0.5f, 0.5f, 0.75f, 0.85f, 1.0f };
//    pen.SetCompoundArray(carray, 8);
        
    g->DrawPath(&pen, path);

    delete path;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\functest\coutput.cpp ===
/******************************Module*Header*******************************\
* Module Name: COutput.cpp
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/
#include "COutput.h"
#include "CFuncTest.h"

extern CFuncTest g_FuncTest;

COutput::COutput()
{
	strcpy(m_szName,"No name assigned");
	m_bRegression=false;
}

COutput::~COutput()
{

}

BOOL COutput::Init()
{
	return g_FuncTest.AddOutput(this);
}

void COutput::PostDraw(RECT rTestArea)
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\functest\coutput.h ===
/******************************Module*Header*******************************\
* Module Name: COutput.h
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/

#ifndef __COUTPUT_H
#define __COUTPUT_H

#include "Global.h"

class COutput  
{
public:
	COutput();
	virtual ~COutput();

	virtual BOOL Init();										// Add output to output list in functest dialog
	virtual Graphics *PreDraw(int &nOffsetX,int &nOffsetY)=0;	// Set up graphics at the given X,Y offset
	virtual void PostDraw(RECT rTestArea);						// Finish off graphics at rTestArea

	char m_szName[256];
	BOOL m_bRegression;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\functest\cmetafile.h ===
/******************************Module*Header*******************************\
* Module Name: CMetafile.h
*
* This file contains the code to support the functionality test harness
* for GDI+.  
*
* Created:  14-Sep-2000 - DCurtis
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/

#ifndef __CMETAFILE_H
#define __CMETAFILE_H

#include "COutput.h"

class CMetafile : public COutput  
{
public:
   // CMetafile(BOOL bRegression, MetafileType metafileType)
   // : CMetafile(bRegression, metafileType, FALSE) {};

	CMetafile(BOOL bRegression, MetafileType metafileType, BOOL recordFile = FALSE);
	virtual ~CMetafile();

	Graphics *PreDraw(int &nOffsetX,int &nOffsetY);			// Set up graphics at the given X,Y offset
	void PostDraw(RECT rTestArea);							// Finish off graphics at rTestArea

	Gdiplus::Metafile *		GdipMetafile;
    EmfType                 RecordType;
    MetafileType            FinalType;
    BOOL                    RecordFile;
};

#endif	// __CMETAFILE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\functest\cmetafile.cpp ===
/******************************Module*Header*******************************\
* Module Name: CMetafile.cpp
*
* This file contains the code to support the functionality test harness
* for GDI+.  
*
* Created:  14-Sep-2000 - DCurtis
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/
#include "CMetafile.h"
#include "CFuncTest.h"

extern CFuncTest g_FuncTest;

CMetafile::CMetafile(BOOL bRegression,MetafileType metafileType,BOOL recordFile)
{
	m_bRegression = bRegression;

    switch (metafileType)
    {
#if 0   // not yet implemented
    case MetafileTypeWmf:                // Standard WMF
	    sprintf(m_szName,"Metafile WMF");
        RecordType = EmfTypeEmfOnly;
        break;
        
    case MetafileTypeWmfPlaceable:      // Placeable Metafile format
	    sprintf(m_szName,"Metafile WMF Placeable");
        RecordType = EmfTypeEmfOnly;
        break;
#endif        
    case MetafileTypeEmf:                // EMF (not EMF+)
	    sprintf(m_szName,"Metafile EMF");
        RecordType = EmfTypeEmfOnly;
        break;
        
    case MetafileTypeEmfPlusOnly:        // EMF+ without dual, down-level records
	    sprintf(m_szName,"Metafile EMF+");
        RecordType = EmfTypeEmfPlusOnly;
        break;
        
    case MetafileTypeEmfPlusDual:        // EMF+ with dual, down-level records
    default:
	    sprintf(m_szName,"Metafile EMF+ Dual");
        RecordType = EmfTypeEmfPlusDual;
        break;
    }  

    if (recordFile) 
    {
        strcat(m_szName, "(File)");
    }
    RecordFile = recordFile;
    FinalType = metafileType;
}

CMetafile::~CMetafile()
{
    delete GdipMetafile;
}

Graphics *
CMetafile::PreDraw(int &nOffsetX,int &nOffsetY)
{
	Graphics *      g = NULL;
	HDC             referenceHdc = ::GetDC(g_FuncTest.m_hWndMain);
    RectF           frameRect;
    
    if (referenceHdc != NULL)
    {
        frameRect.X = frameRect.Y = 0;
        frameRect.Width  = (int)TESTAREAWIDTH;
        frameRect.Height = (int)TESTAREAHEIGHT;

        if (RecordFile) 
        {
            GdipMetafile = new Metafile(L"test.emf",
                                        referenceHdc,
                                        RecordType,
                                        NULL);
        }
        else
        {
            GdipMetafile = new Metafile(referenceHdc,
                                        frameRect,
                                        MetafileFrameUnitPixel,
                                        RecordType,
                                        NULL);
        }
        g = new Graphics(GdipMetafile);
    }

	// Since we are doing the test on another surface
	nOffsetX = 0;
	nOffsetY = 0;

	ReleaseDC(g_FuncTest.m_hWndMain, referenceHdc);

	return g;
}

void CMetafile::PostDraw(RECT rTestArea)
{
	// play from the Metafile to screen so we see the results
	
    if (RecordFile) 
    {
        delete GdipMetafile;
        // close file

        GdipMetafile = new Metafile(L"test.emf");
        // read from file
    }

    HDC hdcOrig = GetDC(g_FuncTest.m_hWndMain);
    {
        Graphics    g(hdcOrig);

        RectF       destRect((REAL)rTestArea.left, (REAL)rTestArea.top, TESTAREAWIDTH, TESTAREAHEIGHT);

        g.DrawImage(GdipMetafile, destRect, 0, 0, TESTAREAWIDTH, TESTAREAHEIGHT, UnitPixel);
    }

	ReleaseDC(g_FuncTest.m_hWndMain, hdcOrig);

    delete GdipMetafile;
    GdipMetafile = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\functest\clines.cpp ===
/**************************************************************************
*
* Copyright (c) 2000 Microsoft Corporation
*
* Module Name:
*
*   <an unabbreviated name for the module (not the filename)>
*
* Abstract:
*
*   <Description of what this module does>
*
* Notes:
*
*   <optional>
*
* Created:
*
*   08/28/2000 asecchia
*      Created it.
*
**************************************************************************/

/**************************************************************************
*
* Function Description:
*
*   <Description of what the function does>
*
* Arguments:
*
*   [<blank> | OUT | IN/OUT] argument-name - description of argument
*   ......
*
* Return Value:
*
*   return-value - description of return value
*   or NONE
*
* Created:
*
*   08/28/2000 asecchia
*      Created it.
*
**************************************************************************/
#include "CLines.hpp"

#ifndef M_PI
#define M_PI 3.1415926536
#endif

CLinesNominal::CLinesNominal(BOOL bRegression)
{
	strcpy(m_szName,"Lines : Slope, Nominal");
	m_bRegression=bRegression;
}

void CLinesNominal::Draw(Graphics *g)
{
    RectF rect(0, 0, TESTAREAWIDTH, TESTAREAHEIGHT);
    Pen pen(Color(0xff000000), 0.0f);
    
    // control the center ring size.
    
    const double center_r = 0.82;
    
    // control the total size of the object.
    
    const double scale = 0.44;
    
    // number of lines.
    
    const int n_lines = 40;
    
    for(int i = 0; i<n_lines; i++)
    {
        double angle = (double)2.0*M_PI*i/n_lines;  // radians
        
        float x1 = (float)((0.5+scale*cos(angle))*rect.Width);
        float y1 = (float)((0.5+scale*sin(angle))*rect.Height);
        
        float x2 = (float)((0.5+scale*cos(angle+M_PI*center_r))*rect.Width);
        float y2 = (float)((0.5+scale*sin(angle+M_PI*center_r))*rect.Height);
        
        g->DrawLine(&pen, x1, y1, x2, y2);
    }
}

CLinesFat::CLinesFat(BOOL bRegression)
{
	strcpy(m_szName,"Lines : Slope, 3 pixel wide");
	m_bRegression=bRegression;
}

void CLinesFat::Draw(Graphics *g)
{
    RectF rect(0, 0, TESTAREAWIDTH, TESTAREAHEIGHT);
    Pen pen(Color(0xff000000), 3.0f);
    
    // control the center ring size.
    
    const double center_r = 0.82;
    
    // control the total size of the object.
    
    const double scale = 0.44;
    
    // number of lines.
    
    const int n_lines = 40;
    
    for(int i = 0; i<n_lines; i++)
    {
        double angle = (double)2.0*M_PI*i/n_lines;  // radians
        
        float x1 = (float)((0.5+scale*cos(angle))*rect.Width);
        float y1 = (float)((0.5+scale*sin(angle))*rect.Height);
        
        float x2 = (float)((0.5+scale*cos(angle+M_PI*center_r))*rect.Width);
        float y2 = (float)((0.5+scale*sin(angle+M_PI*center_r))*rect.Height);
        
        g->DrawLine(&pen, x1, y1, x2, y2);
    }
}


CLinesMirrorPen::CLinesMirrorPen(BOOL bRegression)
{
	strcpy(m_szName,"Lines : Pen, Mirror Transform");
	m_bRegression=bRegression;
}

void CLinesMirrorPen::Draw(Graphics *g)
{
  const int endpt = 220;

  Matrix m;
  g->GetTransform(&m);

  GraphicsPath gp;
  gp.AddLine(10, 10, endpt, endpt);
  GraphicsPath gp2;
  gp2.AddLine(10, endpt, endpt, 10);
  
  Pen pen(Color(0x8f0000ff), 20);
  pen.SetEndCap(LineCapArrowAnchor);
  
  g->DrawPath(&pen, &gp);
  
  // Pen mirror transform.
  
  pen.ScaleTransform(1.0f, -1.0f);
  
  g->DrawPath(&pen, &gp2);
  
  // Mirror the world to device transform.
  
  g->ScaleTransform(1.0f, -1.0f);
  g->TranslateTransform(0.0f, (float)-endpt);
  
  pen.SetColor(0x3fff0000);
  
  g->DrawPath(&pen, &gp);
  
  // Combination pen and world to device mirror transform.
  
  pen.ScaleTransform(1.0f, -1.0f);
  
  g->DrawPath(&pen, &gp2);

  // Mirror the world to device transform.

  g->SetTransform(&m);
  g->ScaleTransform(-1.0f, 1.0f);
  g->TranslateTransform((float)-endpt, 20.0f);
  
  pen.SetColor(0x3f00ff00);
  
  g->DrawPath(&pen, &gp);
  
  // Combination pen and world to device mirror transform.
  
  pen.ScaleTransform(1.0f, -1.0f);
  
  g->DrawPath(&pen, &gp2);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\functest\cmixedobjects.cpp ===
/******************************Module*Header*******************************\
* Module Name: CMixedObjects.cpp
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/
#include "CMixedObjects.h"

class RectI
{
public:
    INT X;
    INT Y; 
    INT Width;
    INT Height;
};

CMixedObjects::CMixedObjects(BOOL bRegression)
{
	strcpy(m_szName,"MixedObjects");
	m_bRegression=bRegression;
}

CMixedObjects::~CMixedObjects()
{
}

void CMixedObjects::Draw(Graphics *g)
{
    Point points[10];
    REAL width = 4;     // Pen width

    // Load bmp files.

    WCHAR *filename = L"..\\data\\winnt256.bmp";
    Bitmap *bitmap = new Bitmap(filename);

    // Create a texture brush.

    RectI copyRect;
    copyRect.X = 60;
    copyRect.Y = 60;
    copyRect.Width = 80;
    copyRect.Height = 60;
    Bitmap *copiedBitmap = bitmap->Clone(copyRect.X, copyRect.Y,
                                         copyRect.Width, copyRect.Height,
                                         PixelFormat32bppARGB);

    // Create a rectangular gradient brush.

    RectF brushRect(0, 0, 10, 10);
    Color colors[4] = {
       Color(255, 255, 255, 255),
       Color(255, 255, 0, 0),
       Color(255, 0, 255, 0),
       Color(255, 0, 0, 255)
    };

//    RectangleGradientBrush rectGrad(brushRect, (Color*)&colors, WrapModeTile);
    width = 8;
//    Pen gradPen(&rectGrad, width);

    if(copiedBitmap)
    {
        // Create a texture brush.

        TextureBrush textureBrush(copiedBitmap, WrapModeTile);

        delete copiedBitmap;

        // Create a radial gradient pen.

        points[3].X = (int)(50.0f/400.0f*TESTAREAWIDTH);
        points[3].Y = (int)(80.0f/400.0f*TESTAREAHEIGHT);
        points[2].X = (int)(200.0f/400.0f*TESTAREAWIDTH);
        points[2].Y = (int)(200.0f/400.0f*TESTAREAHEIGHT);
        points[1].X = (int)(220.0f/400.0f*TESTAREAWIDTH);
        points[1].Y = (int)(340.0f/400.0f*TESTAREAHEIGHT);
        points[0].X = (int)(50.0f/400.0f*TESTAREAWIDTH);
        points[0].Y = (int)(250.0f/400.0f*TESTAREAHEIGHT);

        Matrix mat;
        mat.Rotate(30);
        textureBrush.SetTransform(&mat);
//        gradPen.SetLineJoin(LineJoinMiter);
//        g->FillPolygon(&textureBrush, points, 4);
        Pen pen(&textureBrush, 30);
        g->DrawPolygon(&pen, points, 4);
    }

    delete bitmap;
}

/**************************************************************************\
* TestTexts
*
* A test for drawing texts.
*
\**************************************************************************/

VOID CMixedObjects::TestTexts(Graphics *g)
{
    //Font font(L"Arial", 60);

    FontFamily  ff(L"Arial");
    RectF	  rectf(20, 0, 300, 200);
    GraphicsPath  path;

    // Solid color text.

    Color color(128, 100, 0, 200);
    SolidBrush brush(color);
    path.AddString(L"Color", 5, &ff, 0, 60,  rectf, NULL);
    g->FillPath(&brush, &path);

    // Texture text.

    WCHAR filename[256];
    wcscpy(filename, L"..\\data\\marble1.jpg");
    Bitmap *bitmap = new Bitmap(filename);                          
    TextureBrush textureBrush(bitmap, WrapModeTile);
    path.Reset();
    rectf.X = 200;
    rectf.Y = 20;
    path.AddString(L"Texture", 7, &ff, 0, 60, rectf, NULL);
    g->FillPath(&textureBrush, &path);
    delete bitmap;

    // Gradient text.

    rectf.X = 40;
    rectf.Y = 80;
    path.Reset();
    path.AddString(L"Gradient", 8, &ff, 0, 60, rectf, NULL);
    Color color1(255, 255, 0, 0);
    Color color2(255, 0, 255, 0);
    LinearGradientBrush lineGrad(rectf, color1, color2, 0.0f);
    g->FillPath(&lineGrad, &path);

    // Shadow test

    REAL charHeight = 60;
	REAL topMargin = - 5;
    rectf.X = 0;
    rectf.Y = - charHeight - topMargin; // Make y-coord of the base line
										// of the characters to be 0.

    path.Reset();
    path.AddString(L"Shadow", 6, &ff, 0, charHeight, rectf, NULL);
    GraphicsPath* clonePath = path.Clone();

    Color redColor(255, 0, 0);
    Color grayColor(128, 0, 0, 0);
    SolidBrush redBrush(redColor);
    SolidBrush grayBrush(grayColor);

    // Shadow part.

	REAL tx = 180, ty = 200;
    Matrix skew;
    skew.Scale(1.0, 0.5);
    skew.Shear(-2.0, 0, MatrixOrderAppend);
    skew.Translate(tx, ty, MatrixOrderAppend);
    clonePath->Transform(&skew);
    g->FillPath(&grayBrush, clonePath);
    delete clonePath;

    // Front part.

	Matrix trans1;
    trans1.Translate(tx, ty);
    path.Transform(&trans1);
    g->FillPath(&redBrush, &path);


    return;
/*
    REAL x = 200, y = 150;

    RectF brushRect(x, y, 150, 32);
    Color colors[4] = {
       Color(180, 255, 0, 0),
       Color(180, 0, 255, 0),
       Color(180, 255, 0, 0),
       Color(180, 0, 255, 0)
    };
//    RectangleGradientBrush rectGrad(brushRect, (Color*)&colors, WrapModeTile);

//    g->DrawString(L"GDI+", &font, &rectGrad, x, y);


    // And now with DrawText

    RectF rect(400, 200, 400, 400);

    g->DrawText(
        DrawTextDisplay,
        L"A few words powered by GDI+: \
\x3c3\x3bb\x3b1\x3b4 \
\x627\x644\x633\x644\x627\x645 \
\x5e9\x5dc\x5d5\x5dd \
\xe2d\xe4d\xe01\xe29\xe23\xe44\xe17\xe22 \
\x110\x068\x0ea\x300\x103",
       &font,           // Initial font
       &rectGrad,       // Initial brush (ignored for the time being)
        LANG_NEUTRAL,   // Initial language
       &rect            // Formatting rectangle
    );
*/

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\functest\cmixedobjects.h ===
/******************************Module*Header*******************************\
* Module Name: CMixedObjects.h
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/

#ifndef __CMIXEDOBJECTS_H
#define __CMIXEDOBJECTS_H

#include "CPrimitive.h"

class CMixedObjects : public CPrimitive  
{
public:
	CMixedObjects(BOOL bRegression);
	virtual ~CMixedObjects();

	void Draw(Graphics *g);

	VOID TestTexts(Graphics *g);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\functest\cprimitive.cpp ===
/******************************Module*Header*******************************\
* Module Name: CPrimitive.cpp
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/
#include "CPrimitive.h"
#include "CFuncTest.h"

extern CFuncTest g_FuncTest;

CPrimitive::CPrimitive()
{
	strcpy(m_szName,"No name assigned");
	m_bRegression=false;
}

CPrimitive::~CPrimitive()
{

}

BOOL CPrimitive::Init()
{
	g_FuncTest.AddPrimitive(this);
	return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\functest\cprimitive.h ===
/******************************Module*Header*******************************\
* Module Name: CPrimitive.h
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/

#ifndef __CPRIMITIVE_H
#define __CPRIMITIVE_H

#include "Global.h"

class CPrimitive  
{
public:
	CPrimitive();
	virtual ~CPrimitive();

	virtual BOOL Init();
	virtual void Draw(Graphics *g)=0;
    void SetOffset(int x, int y)
    {
        m_ix = x;
        m_iy = y;
    }

	char m_szName[256];
	BOOL m_bRegression;

    // Offset for this test.

    INT m_ix;
    INT m_iy;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\functest\cpathgradient.hpp ===
/**************************************************************************
*
* Copyright (c) 2000 Microsoft Corporation
*
* Module Name:
*
*   <an unabbreviated name for the module (not the filename)>
*
* Abstract:
*
*   <Description of what this module does>
*
* Notes:
*
*   <optional>
*
* Created:
*
*   08/30/2000 asecchia
*      Created it.
*
**************************************************************************/

#ifndef _CPATHGRADIENT_HPP
#define _CPATHGRADIENT_HPP

#include "CPrimitive.h"

class CPathGradient : public CPrimitive
{
public:
	CPathGradient(BOOL bRegression);
	void Draw(Graphics *g);
};

class CPathGradient2 : public CPrimitive
{
public:
	CPathGradient2(BOOL bRegression);
	void Draw(Graphics *g);
};

class CPathGradient3 : public CPrimitive
{
public:
	CPathGradient3(BOOL bRegression);
	void Draw(Graphics *g);
};


class CLinearGradient : public CPrimitive
{
public:
	CLinearGradient(BOOL bRegression);
	void Draw(Graphics *g);
};

class CLinearGradient2 : public CPrimitive
{
public:
	CLinearGradient2(BOOL bRegression);
	void Draw(Graphics *g);
};


#define PATHGRADIENT_GLOBALS \
CPathGradient g_PathGradient(true);\
CPathGradient2 g_PathGradient2(true);\
CPathGradient3 g_PathGradient3(true);\
CLinearGradient g_LinearGradient(true);\
CLinearGradient2 g_LinearGradient2(true);

#define PATHGRADIENT_INIT \
g_PathGradient.Init();\
g_PathGradient2.Init();\
g_PathGradient3.Init();\
g_LinearGradient.Init();\
g_LinearGradient2.Init();


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\functest\cpathgradient.cpp ===
/**************************************************************************
*
* Copyright (c) 2000 Microsoft Corporation
*
* Module Name:
*
*   <an unabbreviated name for the module (not the filename)>
*
* Abstract:
*
*   <Description of what this module does>
*
* Notes:
*
*   <optional>
*
* Created:
*
*   08/30/2000 asecchia
*      Created it.
*
**************************************************************************/

/**************************************************************************
*
* Function Description:
*
*   <Description of what the function does>
*
* Arguments:
*
*   [<blank> | OUT | IN/OUT] argument-name - description of argument
*   ......
*
* Return Value:
*
*   return-value - description of return value
*   or NONE
*
* Created:
*
*   08/30/2000 asecchia
*      Created it.
*
**************************************************************************/

#include "CPathGradient.hpp"

#ifndef M_PI
#define M_PI 3.1415926536
#endif


CPathGradient::CPathGradient(BOOL bRegression)
{
	strcpy(m_szName,"Gradient : Path");
	m_bRegression=bRegression;
}

void CPathGradient::Draw(Graphics *g)
{
    PointF points[7];
    points[0].X = 0.0f;
    points[0].Y = 0.0f;
    points[1].X = TESTAREAWIDTH;
    points[1].Y = 0.0f;
    points[2].X = TESTAREAWIDTH;
    points[2].Y = TESTAREAHEIGHT;
    points[3].X = 0.0f;
    points[3].Y = TESTAREAHEIGHT;
    points[4].X = 50.0f;
    points[4].Y = 100.0f;
    points[5].X = -1.00;
    points[5].Y = -1.00;
    points[6].X = 0;
    points[6].Y = 0;


    Color colors[6];
    colors[0] = Color(0xff000000);
    colors[1] = Color(0xffff0000);
    colors[2] = Color(0xff00ff00);
    colors[3] = Color(0xffff00ff);
    colors[4] = Color(0xffffff00);
    colors[5] = Color(0xff00ffff);
    
    
    float blend[6] = {0.0f, 0.1f, 0.3f, 0.5f, 0.7f, 1.0f};

    Pen pen(Color(0xff000000), 10.0f);


    GraphicsPath gp;
    gp.AddPolygon(points, 4);
    
    PathGradientBrush brush(points, 4);
    brush.SetCenterPoint(points[4]);
    brush.SetCenterColor(Color(0xff0000ff));

    Status status;
    INT count = 4;
    status = brush.SetSurroundColors(colors, &count);
    
    status = brush.SetInterpolationColors(colors, blend, 6);
    
    
    status = g->FillPath(&brush, &gp);
}


CPathGradient2::CPathGradient2(BOOL bRegression)
{
	strcpy(m_szName,"Gradient : Path, 1D, Gamma Corrected");
	m_bRegression=bRegression;
}

void CPathGradient2::Draw(Graphics *g)
{
    PointF points[7];
    points[0].X = 0.0f;
    points[0].Y = 0.0f;
    points[1].X = TESTAREAWIDTH;
    points[1].Y = 0.0f;
    points[2].X = TESTAREAWIDTH;
    points[2].Y = TESTAREAHEIGHT;
    points[3].X = 0.0f;
    points[3].Y = TESTAREAHEIGHT;
    points[4].X = 50.0f;
    points[4].Y = 100.0f;
    points[5].X = -1.00;
    points[5].Y = -1.00;
    points[6].X = 0;
    points[6].Y = 0;


    Color colors[6];
    colors[0] = Color(0xff0000ff);
    colors[1] = Color(0xff0000ff);
    colors[2] = Color(0xff0000ff);
    colors[3] = Color(0xff0000ff);
    colors[4] = Color(0xffffff00);
    colors[5] = Color(0xff00ffff);
    
    
    GraphicsPath gp;
    gp.AddPolygon(points, 4);
    
    PathGradientBrush brush(points, 4);
    brush.SetCenterPoint(points[4]);
    brush.SetCenterColor(Color(0x3f00ff00));

    Status status;
    INT count = 4;
    status = brush.SetSurroundColors(colors, &count);
    status = g->FillPath(&brush, &gp);
}



CPathGradient3::CPathGradient3(BOOL bRegression)
{
	strcpy(m_szName,"Gradient : Path, Gamma Corrected");
	m_bRegression=bRegression;
}

void CPathGradient3::Draw(Graphics *g)
{
    // width and height of our test rectangle.
    
    float width = TESTAREAWIDTH;
    float height = TESTAREAHEIGHT;
    
    // center point.
    
    float cx = width/2.0f;
    float cy = height/2.0f;
    
    PointF *points = new PointF[100];
    Color *colors = new Color[100];
    
    // Create the path and some random list of repeating colors.
    
    for(INT i=0;i<100;i++)
    {
        float angle = ((2.0f*(float)M_PI)*i)/100.0f;
        points[i].X = cx*(1.0f + (float)cos(angle));
        points[i].Y = cy*(1.0f + (float)sin(angle));
        colors[i] = Color(
            (i%10>0)?0xff:0x3f,
            (i%4>0)?0xff:0x00,
            (i%4==1)?0xff:0x3f,
            (i%6==2)?0xff:0x00
        );
    }

    // make the path.
    
    GraphicsPath gp;
    gp.AddPolygon(points, 100);
    
    // make the brush.
    
    INT count = 100;
    PathGradientBrush brush(points, 100);
    brush.SetCenterPoint(PointF(cx, cy));
    brush.SetCenterColor(Color(0x00000000));
    brush.SetSurroundColors(colors, &count);
    
    // Fill it.
    
    g->FillPath(&brush, &gp);
}



CLinearGradient::CLinearGradient(BOOL bRegression)
{
	strcpy(m_szName,"Gradient : Linear");
	m_bRegression=bRegression;
}

void CLinearGradient::Draw(Graphics *g)
{
    PointF points[4];
    points[0].X = 0.0f;
    points[0].Y = 0.0f;
    points[1].X = TESTAREAWIDTH;
    points[1].Y = 0.0f;
    points[2].X = TESTAREAWIDTH;
    points[2].Y = TESTAREAHEIGHT;
    points[3].X = 0.0f;
    points[3].Y = TESTAREAHEIGHT;
    
    GraphicsPath gp;
    gp.AddPolygon(points, 4);
    
    LinearGradientBrush brush(
        PointF(0.0f, 0.0f),
        PointF(TESTAREAWIDTH, TESTAREAHEIGHT),
        Color(0xffff0000),
        Color(0xff0000ff)
    );
    
    brush.SetGammaCorrection(FALSE);
    Status status = g->FillPath(&brush, &gp);
}

CLinearGradient2::CLinearGradient2(BOOL bRegression)
{
	strcpy(m_szName,"Gradient : Linear, Gamma Corrected");
	m_bRegression=bRegression;
}

void CLinearGradient2::Draw(Graphics *g)
{
    PointF points[4];
    points[0].X = 0.0f;
    points[0].Y = 0.0f;
    points[1].X = TESTAREAWIDTH;
    points[1].Y = 0.0f;
    points[2].X = TESTAREAWIDTH;
    points[2].Y = TESTAREAHEIGHT;
    points[3].X = 0.0f;
    points[3].Y = TESTAREAHEIGHT;
    
    GraphicsPath gp;
    gp.AddPolygon(points, 4);
    
    LinearGradientBrush brush(
        PointF(0.0f, 0.0f),
        PointF(TESTAREAWIDTH, TESTAREAHEIGHT),
        Color(0xffff0000),
        Color(0xff0000ff)
    );
    
    brush.SetGammaCorrection(TRUE);
    Status status = g->FillPath(&brush, &gp);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\functest\cprinter.h ===
/******************************Module*Header*******************************\
* Module Name: CPrinter.h
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/

#ifndef __CPRINTER_H
#define __CPRINTER_H

#include "COutput.h"

class CPrinter : public COutput  
{
public:
	CPrinter(BOOL bRegression);
	virtual ~CPrinter();

	BOOL Init();
	Graphics *PreDraw(int &nOffsetX,int &nOffsetY);			// Set up graphics at the given X,Y offset
	void PostDraw(RECT rTestArea);							// Finish off graphics at rTestArea

	HDC m_hDC;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\functest\cpaths.cpp ===
/******************************Module*Header*******************************\
* Module Name: CPaths.cpp
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/
#include "CPaths.h"
#include <limits.h>

CJoins::CJoins(BOOL bRegression)
{
	strcpy(m_szName,"Lines : Joins");
	m_bRegression=bRegression;
}

CJoins::~CJoins()
{
}

void CJoins::Draw(Graphics *g)
{
    Pen pen(Color(128,0,0), 8.5f);
    pen.SetMiterLimit(4.0f);

    g->TranslateTransform(20,30);
    for (INT j = 0; j<4; j++)
    {
        pen.SetLineJoin((LineJoin)j);
        INT x=0, y=0;
        for (INT x=0, y=-5; x<40; x+=8, y+=15)
        {
            Point points[] = {Point(0,0), Point(36,0), Point(x,y)};
            GraphicsPath corner;
            corner.AddPolygon(points,3);
            g->DrawPath(&pen,&corner);
            g->TranslateTransform(0,(REAL)(y+15));
        }
        g->TranslateTransform(60,-200);
    }
    g->TranslateTransform(-260,-30);
}       	

CPaths::CPaths(BOOL bRegression)
{
	strcpy(m_szName,"Paths");
	m_bRegression=bRegression;
}

CPaths::~CPaths()
{
}

VOID TestEscherNewPath(Graphics* g);

void CPaths::Draw(Graphics *g)
{
    TestBezierPath(g);
	TestSinglePixelWidePath(g);
	TestTextAlongPath(g);

	TestFreeFormPath2(g);
	TestLeakPath(g);
	TestExcelCurvePath(g);
        TestPie(g);

//	  TestDegenerateBezierPath(g);
//    TestEscherNewPath(g);
}

VOID CPaths::TestBezierPath(Graphics *g)
{
    REAL width = 4;         // Pen width
    Point points[4];

    points[0].X = (int)(100.0f/450.0f*TESTAREAWIDTH);
    points[0].Y = (int)(10.0f/450.0f*TESTAREAHEIGHT);
    points[1].X = (int)(-50.0f/450.0f*TESTAREAWIDTH);
    points[1].Y = (int)(50.0f/450.0f*TESTAREAHEIGHT);
    points[2].X = (int)(150.0f/450.0f*TESTAREAWIDTH);
    points[2].Y = (int)(200.0f/450.0f*TESTAREAHEIGHT);
    points[3].X = (int)(200.0f/450.0f*TESTAREAWIDTH);
    points[3].Y = (int)(70.0f/450.0f*TESTAREAHEIGHT);

    Color yellowColor(128, 255, 255, 0);
    SolidBrush yellowBrush(yellowColor);

    GraphicsPath* path = new GraphicsPath(FillModeAlternate);
    path->AddBeziers(points, 4);

    path->SetMarker();

    RectF rect;

    rect.X = (int)(150.0f/450.0f*TESTAREAWIDTH);
    rect.Y = (int)(150.0f/450.0f*TESTAREAHEIGHT);
    rect.Width = (int)(100.0f/450.0f*TESTAREAWIDTH);
    rect.Height = (int)(100.0f/450.0f*TESTAREAHEIGHT);

    path->AddRectangle(rect);
    
    Matrix matrix;
    matrix.Scale(1.5, 1.5);

    Color colors[2];
    colors[0].SetValue(Color::MakeARGB(128, 0, 255, 0));
    colors[1].SetValue(Color::MakeARGB(128, 0, 0, 255));

    SolidBrush brush1(colors[0]);
    GraphicsPath path1;

    GraphicsPathIterator iter(path);

    INT i = 0;

    while(iter.NextMarker(&path1) > 0)
    {
        // Change the brush color.

        brush1.SetColor(colors[(i & 0x01)]);

        // Fill each marker path.

//        g->FillPath(&brush1, &path1);
        i++;
    }

    // If you wanto to flatten the path before rendering,
    // Flatten() can be called.

    BOOL flattenFirst = FALSE;

    if(!flattenFirst)
    {
        // Don't flatten and keep the original path.
        // FillPath or DrawPath will flatten the path automatically
        // without modifying the original path.

        path->Transform(&matrix);
    }
    else
    {
        // Flatten this path.  The resultant path is made of line
        // segments.  The original path information is lost.

        path->Flatten(&matrix);
    }
    
    Color blackColor(128, 0, 0, 0);

    SolidBrush blackBrush(blackColor);
    // Set the pen width in inch.
    width = 6;
    Pen blackPen(&blackBrush, width);
    Matrix mat;
    mat.Scale(1.0f, 0.6f);
//    blackPen.SetTransform(&mat);
    blackPen.SetStartCap(LineCapTriangle);
//    blackPen.SetStartCap(LineCapRoundAnchor);
//    blackPen.SetEndCap(LineCapSquare);
//    blackPen.SetEndCap(LineCapArrowAnchor);
    blackPen.SetEndCap(LineCapTriangle);
//    blackPen.SetEndCap(LineCapDiamondAnchor);
//	blackPen.SetAlignment(PenAlignmentRight);
    blackPen.SetLineJoin(LineJoinRound);

    GraphicsPath fillPath, strokePath;

    rect.X = -2;
    rect.Y = -2;
    rect.Width = 4;
    rect.Height = 4;
    fillPath.AddRectangle(rect);

    CustomLineCap customCap(NULL, &fillPath);
    customCap.SetBaseInset(1.0f);
    blackPen.SetCustomEndCap(&customCap);

    AdjustableArrowCap arrowCap(4, 4, FALSE);
    arrowCap.SetMiddleInset(1);
    arrowCap.SetStrokeCaps(LineCapRound, LineCapRound);
    arrowCap.SetStrokeJoin(LineJoinRound);
    blackPen.SetCustomStartCap(&arrowCap);

    path->Reverse();

    Region * region = new Region(path);
    g->FillPath(&yellowBrush, path);
    g->DrawPath(&blackPen, path);
    delete path;
    delete region;

    Pen pen2(&blackBrush, 10);
    path = new GraphicsPath(FillModeWinding);
    points[0].X = (int)(100.0f/450.0f*TESTAREAWIDTH);  points[0].Y = (int)(20.0f/450.0f*TESTAREAHEIGHT);
    points[1].X = (int)(0.0f/450.0f*TESTAREAWIDTH);    points[1].Y = (int)(20.0f/450.0f*TESTAREAHEIGHT);
    points[2].X = (int)(250.0f/450.0f*TESTAREAWIDTH);  points[2].Y = (int)(20.0f/450.0f*TESTAREAHEIGHT);
    points[3].X = (int)(150.0f/450.0f*TESTAREAWIDTH);  points[3].Y = (int)(20.0f/450.0f*TESTAREAHEIGHT);
    path->AddBeziers(points, 4);
//    path->AddLines(points, 4);
    g->DrawPath(&pen2, path);
    delete path;

    path = new GraphicsPath();
    rect.X = (int)(100.0f/450.0f*TESTAREAWIDTH);
    rect.Y = (int)(40.0f/450.0f*TESTAREAHEIGHT);
    rect.Width = (int)(50.0f/450.0f*TESTAREAWIDTH);
    rect.Height = (int)(50.0f/450.0f*TESTAREAHEIGHT);
    path->AddRectangle(rect);
    g->DrawPath(&pen2, path);
    delete path;

    Point pts[10];
    INT count = 4;

    pts[0].X = (int)(200.0f/450.0f*TESTAREAWIDTH);
    pts[0].Y = (int)(160.0f/450.0f*TESTAREAHEIGHT);
    pts[1].X = (int)(150.0f/450.0f*TESTAREAWIDTH);
    pts[1].Y = (int)(230.0f/450.0f*TESTAREAHEIGHT);
    pts[2].X = (int)(200.0f/450.0f*TESTAREAWIDTH);
    pts[2].Y = (int)(260.0f/450.0f*TESTAREAHEIGHT);
    pts[3].X = (int)(300.0f/450.0f*TESTAREAWIDTH);
    pts[3].Y = (int)(200.0f/450.0f*TESTAREAHEIGHT);

//    g->FillClosedCurve(&brush, pts, count);

    pts[0].X = (int)(100.0f/450.0f*TESTAREAWIDTH); pts[0].Y = (int)(50.0f/450.0f*TESTAREAHEIGHT);
    pts[1].X = (int)(50.0f/450.0f*TESTAREAWIDTH);  pts[1].Y = (int)(50.0f/450.0f*TESTAREAHEIGHT);
    pts[2].X = (int)(200.0f/450.0f*TESTAREAWIDTH); pts[2].Y = (int)(50.0f/450.0f*TESTAREAHEIGHT);
    pts[3].X = (int)(150.0f/450.0f*TESTAREAWIDTH); pts[3].Y = (int)(50.0f/450.0f*TESTAREAHEIGHT);

    count = 4;
//    g->DrawClosedCurve(&pen2, pts, count);
    g->DrawCurve(&pen2, pts, count);

    pts[0].X = (int)(65.0f/450.0f*TESTAREAWIDTH);
    pts[0].Y = (int)(20.0f/450.0f*TESTAREAHEIGHT);
    pts[1].X = (int)(20.0f/450.0f*TESTAREAWIDTH);
    pts[1].Y = (int)(110.0f/450.0f*TESTAREAHEIGHT);
    pts[2].X = (int)(110.0f/450.0f*TESTAREAWIDTH);
    pts[2].Y = (int)(50.0f/450.0f*TESTAREAHEIGHT);
    pts[3].X = (int)(20.0f/450.0f*TESTAREAWIDTH);
    pts[3].Y = (int)(50.0f/450.0f*TESTAREAHEIGHT);
    path = new GraphicsPath();
    pen2.SetWidth(1);
    path->AddBeziers(pts, 4);
    g->DrawPath(&pen2, path);
    delete path;
}

VOID CPaths::TestSinglePixelWidePath(Graphics *g)
{
    Point points[4];

    points[0].X = (int)(30.0f/450.0f*TESTAREAWIDTH);
    points[0].Y = (int)(30.0f/450.0f*TESTAREAHEIGHT);
    points[1].X = points[0].X + (int)(100.0f/450.0f*TESTAREAWIDTH);
    points[1].Y = points[0].Y + (int)(3.0f/450.0f*TESTAREAHEIGHT);
    points[2].X = points[1].X - (int)(3.0f/450.0f*TESTAREAWIDTH);
    points[2].Y = points[1].Y + (int)(100.0f/450.0f*TESTAREAHEIGHT);
    points[3].X = points[2].X - (int)(45.0f/450.0f*TESTAREAWIDTH);
    points[3].Y = points[2].Y - (int)(45.0f/450.0f*TESTAREAHEIGHT);

    Color blackColor(0, 0, 0);
    SolidBrush blackBrush(blackColor);
    Pen blackPen(&blackBrush, 1.0);

    GraphicsPath* path = new GraphicsPath(FillModeAlternate);
    path->AddLines(points, 4);

    // Set the pen width in inch.
    g->DrawPath(&blackPen, path);

    delete path;
}

VOID CPaths::TestTextAlongPath(Graphics *g)
{
    Point points[4];

    points[3].X = (int)(100.0f/450.0f*TESTAREAWIDTH);
    points[3].Y = (int)(10.0f/450.0f*TESTAREAHEIGHT);
    points[2].X = (int)(-50.0f/450.0f*TESTAREAWIDTH);
    points[2].Y = (int)(50.0f/450.0f*TESTAREAHEIGHT);
    points[1].X = (int)(150.0f/450.0f*TESTAREAWIDTH);
    points[1].Y = (int)(200.0f/450.0f*TESTAREAHEIGHT);
    points[0].X = (int)(200.0f/450.0f*TESTAREAWIDTH);
    points[0].Y = (int)(70.0f/450.0f*TESTAREAHEIGHT);

    GraphicsPath* path = new GraphicsPath(FillModeAlternate);
    path->AddBeziers(points, 4);
    Matrix matrix;
    matrix.Scale(1.5, 1.5);

    path->Transform(&matrix);

    Color textColor(180, 200, 0, 200);
    SolidBrush textBrush(textColor);

    WCHAR szText[]=L"Windows 2000";

    REAL offset=60;

//    g->DrawString(text, 12, NULL, path, NULL, &textBrush, offset);

    delete path;
}

VOID CPaths::TestFreeFormPath1(Graphics* g)
{
    INT count = 55;
    GpPointF pts[60];

    pts[ 0].X = 4.879999e+002f/600.0f*TESTAREAWIDTH; pts[ 0].Y =  3.059999e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 1].X = 4.772343e+002f/600.0f*TESTAREAWIDTH; pts[ 1].Y =  3.024114e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 2].X = 4.573341e+002f/600.0f*TESTAREAWIDTH; pts[ 2].Y =  3.019402e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 3].X = 4.476240e+002f/600.0f*TESTAREAWIDTH; pts[ 3].Y =  3.019402e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 4].X = 4.419999e+002f/600.0f*TESTAREAWIDTH; pts[ 4].Y =  3.019999e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 5].X = 4.379999e+002f/600.0f*TESTAREAWIDTH; pts[ 5].Y =  3.013333e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 6].X = 4.335999e+002f/600.0f*TESTAREAWIDTH; pts[ 6].Y =  3.018000e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 7].X = 4.299999e+002f/600.0f*TESTAREAWIDTH; pts[ 7].Y =  2.999999e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 8].X = 4.266666e+002f/600.0f*TESTAREAWIDTH; pts[ 8].Y =  2.983333e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 9].X = 4.236666e+002f/600.0f*TESTAREAWIDTH; pts[ 9].Y =  2.955333e+002f/600.0f*TESTAREAHEIGHT;
    pts[10].X = 4.199999e+002f/600.0f*TESTAREAWIDTH; pts[10].Y =  2.949999e+002f/600.0f*TESTAREAHEIGHT;
    pts[11].X = 4.059999e+002f/600.0f*TESTAREAWIDTH; pts[11].Y =  2.929999e+002f/600.0f*TESTAREAHEIGHT;
    pts[12].X = 4.059999e+002f/600.0f*TESTAREAWIDTH; pts[12].Y =  2.929999e+002f/600.0f*TESTAREAHEIGHT;
    pts[13].X = 3.965333e+002f/600.0f*TESTAREAWIDTH; pts[13].Y =  2.873333e+002f/600.0f*TESTAREAHEIGHT;
    pts[14].X = 3.802666e+002f/600.0f*TESTAREAWIDTH; pts[14].Y =  2.774000e+002f/600.0f*TESTAREAHEIGHT;
    pts[15].X = 3.739999e+002f/600.0f*TESTAREAWIDTH; pts[15].Y =  2.680000e+002f/600.0f*TESTAREAHEIGHT;
    pts[16].X = 3.965333e+002f/600.0f*TESTAREAWIDTH; pts[16].Y =  2.873333e+002f/600.0f*TESTAREAHEIGHT;
    pts[17].X = 3.802666e+002f/600.0f*TESTAREAWIDTH; pts[17].Y =  2.774000e+002f/600.0f*TESTAREAHEIGHT;
    pts[18].X = 3.739999e+002f/600.0f*TESTAREAWIDTH; pts[18].Y =  2.680000e+002f/600.0f*TESTAREAHEIGHT;
    pts[19].X = 3.725333e+002f/600.0f*TESTAREAWIDTH; pts[19].Y =  2.658000e+002f/600.0f*TESTAREAHEIGHT;
    pts[20].X = 3.708666e+002f/600.0f*TESTAREAWIDTH; pts[20].Y =  2.635333e+002f/600.0f*TESTAREAHEIGHT;
    pts[21].X = 3.699999e+002f/600.0f*TESTAREAWIDTH; pts[21].Y =  2.610000e+002f/600.0f*TESTAREAHEIGHT;
    pts[22].X = 3.725333e+002f/600.0f*TESTAREAWIDTH; pts[22].Y =  2.658000e+002f/600.0f*TESTAREAHEIGHT;
    pts[23].X = 3.708666e+002f/600.0f*TESTAREAWIDTH; pts[23].Y =  2.635333e+002f/600.0f*TESTAREAHEIGHT;
    pts[24].X = 3.699999e+002f/600.0f*TESTAREAWIDTH; pts[24].Y =  2.610000e+002f/600.0f*TESTAREAHEIGHT;
    pts[25].X = 3.691333e+002f/600.0f*TESTAREAWIDTH; pts[25].Y =  2.584000e+002f/600.0f*TESTAREAHEIGHT;
    pts[26].X = 3.679999e+002f/600.0f*TESTAREAWIDTH; pts[26].Y =  2.530000e+002f/600.0f*TESTAREAHEIGHT;
    pts[27].X = 3.679999e+002f/600.0f*TESTAREAWIDTH; pts[27].Y =  2.530000e+002f/600.0f*TESTAREAHEIGHT;
    pts[28].X = 3.679999e+002f/600.0f*TESTAREAWIDTH; pts[28].Y =  2.530000e+002f/600.0f*TESTAREAHEIGHT;
    pts[29].X = 3.658666e+002f/600.0f*TESTAREAWIDTH; pts[29].Y =  2.318666e+002f/600.0f*TESTAREAHEIGHT;
    pts[30].X = 3.691333e+002f/600.0f*TESTAREAWIDTH; pts[30].Y =  2.203333e+002f/600.0f*TESTAREAHEIGHT;
    pts[31].X = 3.839999e+002f/600.0f*TESTAREAWIDTH; pts[31].Y =  2.070000e+002f/600.0f*TESTAREAHEIGHT;
    pts[32].X = 3.893333e+002f/600.0f*TESTAREAWIDTH; pts[32].Y =  2.022000e+002f/600.0f*TESTAREAHEIGHT;
    pts[33].X = 3.931999e+002f/600.0f*TESTAREAWIDTH; pts[33].Y =  1.964000e+002f/600.0f*TESTAREAHEIGHT;
    pts[34].X = 3.999999e+002f/600.0f*TESTAREAWIDTH; pts[34].Y =  1.930000e+002f/600.0f*TESTAREAHEIGHT;
    pts[35].X = 4.053327e+002f/600.0f*TESTAREAWIDTH; pts[35].Y =  1.903467e+002f/600.0f*TESTAREAHEIGHT;
    pts[36].X = 4.059866e+002f/600.0f*TESTAREAWIDTH; pts[36].Y =  1.899501e+002f/600.0f*TESTAREAHEIGHT;
    pts[37].X = 4.062323e+002f/600.0f*TESTAREAWIDTH; pts[37].Y =  1.899501e+002f/600.0f*TESTAREAHEIGHT;
    pts[38].X = 4.063370e+002f/600.0f*TESTAREAWIDTH; pts[38].Y =  1.899501e+002f/600.0f*TESTAREAHEIGHT;
    pts[39].X = 4.063676e+002f/600.0f*TESTAREAWIDTH; pts[39].Y =  1.900222e+002f/600.0f*TESTAREAHEIGHT;
    pts[40].X = 4.066551e+002f/600.0f*TESTAREAWIDTH; pts[40].Y =  1.900222e+002f/600.0f*TESTAREAHEIGHT;
    pts[41].X = 4.074044e+002f/600.0f*TESTAREAWIDTH; pts[41].Y =  1.900222e+002f/600.0f*TESTAREAHEIGHT;
    pts[42].X = 4.098989e+002f/600.0f*TESTAREAWIDTH; pts[42].Y =  1.895324e+002f/600.0f*TESTAREAHEIGHT;
    pts[43].X = 4.199999e+002f/600.0f*TESTAREAWIDTH; pts[43].Y =  1.860000e+002f/600.0f*TESTAREAHEIGHT;
    pts[44].X = 4.269999e+002f/600.0f*TESTAREAWIDTH; pts[44].Y =  1.835333e+002f/600.0f*TESTAREAHEIGHT;
    pts[45].X = 4.337999e+002f/600.0f*TESTAREAWIDTH; pts[45].Y =  1.789333e+002f/600.0f*TESTAREAHEIGHT;
    pts[46].X = 4.409999e+002f/600.0f*TESTAREAWIDTH; pts[46].Y =  1.770000e+002f/600.0f*TESTAREAHEIGHT;
    pts[47].X = 4.475333e+002f/600.0f*TESTAREAWIDTH; pts[47].Y =  1.752000e+002f/600.0f*TESTAREAHEIGHT;
    pts[48].X = 4.543333e+002f/600.0f*TESTAREAWIDTH; pts[48].Y =  1.751333e+002f/600.0f*TESTAREAHEIGHT;
    pts[49].X = 4.609999e+002f/600.0f*TESTAREAWIDTH; pts[49].Y =  1.740000e+002f/600.0f*TESTAREAHEIGHT;
    pts[50].X = 4.643333e+002f/600.0f*TESTAREAWIDTH; pts[50].Y =  1.734666e+002f/600.0f*TESTAREAHEIGHT;
    pts[51].X = 4.675999e+002f/600.0f*TESTAREAWIDTH; pts[51].Y =  1.720000e+002f/600.0f*TESTAREAHEIGHT;
    pts[52].X = 4.709999e+002f/600.0f*TESTAREAWIDTH; pts[52].Y =  1.720000e+002f/600.0f*TESTAREAHEIGHT;
    pts[53].X = 5.279999e+002f/600.0f*TESTAREAWIDTH; pts[53].Y =  1.720000e+002f/600.0f*TESTAREAHEIGHT;
    pts[54].X = 5.279999e+002f/600.0f*TESTAREAWIDTH; pts[54].Y =  1.720000e+002f/600.0f*TESTAREAHEIGHT;


    BYTE typs[] = {
        00, 03, 03, 03, //  0 -  3
        01, 03, 03, 03, //  4 -  7
        03, 03, 03, 01, //  8 - 11
        01, 03, 03, 03, // 12 - 15
        03, 03, 03, 03, // 16 - 19
        03, 03, 03, 03, // 20 - 23
        03, 03, 03, 03, // 24 - 27
        01, 03, 03, 03, // 28 - 31
        03, 03, 03, 03, // 32 - 35
        03, 03, 03, 03, // 36 - 39
        03, 03, 03, 03, // 40 - 43
        03, 03, 03, 03, // 44 - 47
        03, 03, 03, 03, // 48 - 51
        03, 01, 01      // 52 - 54
    };

    PointF pts2[4];
    pts2[0].X = 3.739999e+002f/600.0f*TESTAREAWIDTH; pts2[0].Y =  2.680000e+002f/600.0f*TESTAREAHEIGHT;
    pts2[1].X = 3.965333e+002f/600.0f*TESTAREAWIDTH; pts2[1].Y =  2.873333e+002f/600.0f*TESTAREAHEIGHT;
    pts2[2].X = 3.802666e+002f/600.0f*TESTAREAWIDTH; pts2[2].Y =  2.774000e+002f/600.0f*TESTAREAHEIGHT;
    pts2[3].X = 3.739999e+002f/600.0f*TESTAREAWIDTH; pts2[3].Y =  2.680000e+002f/600.0f*TESTAREAHEIGHT;
    pts2[4].X = 3.739999e+002f/600.0f*TESTAREAWIDTH; pts2[4].Y =  2.680000e+002f/600.0f*TESTAREAHEIGHT;

    BYTE typs2[] = {0, 3, 3, 3, 1};

    INT count1 = count;
    INT offset1 = 0;
//    offset1 = 15;
//    count1 = 19;
    count1 -= offset1;
    GpPointF* pts1 = &pts[0] + offset1;
    BYTE* typs1 = &typs[0] + offset1;

    GraphicsPath* path
        = new GraphicsPath(pts1, typs1, count1);
//        = new GraphicsPath(&pts2[0], &typs2[0], 4);

    Matrix mat;
    mat.Translate((int)(-300.0f/600.0f*TESTAREAWIDTH), (int)(-200.0f/600.0f*TESTAREAHEIGHT));
    path->Transform(&mat);
    Matrix mat1;
//    mat1.Scale(5, 5);
//    path->Transform(&mat1);

    REAL width = 20;
    Color color(128, 0, 0, 0);
    SolidBrush brush(color);
    Pen pen(&brush, width);
    pen.SetLineJoin(LineJoinRound);

    g->DrawPath(&pen, path);

    delete path;
}

VOID CPaths::TestFreeFormPath2(Graphics* g)
{
    INT count = 118;
    GpPointF pts[118];

    pts[  0].X = 1.680000e+002f/600.0f*TESTAREAWIDTH; pts[  0].Y = 2.120000e+002f/600.0f*TESTAREAHEIGHT;
    pts[  1].X = 1.686667e+002f/600.0f*TESTAREAWIDTH; pts[  1].Y = 2.016666e+002f/600.0f*TESTAREAHEIGHT;
    pts[  2].X = 1.688667e+002f/600.0f*TESTAREAWIDTH; pts[  2].Y = 1.912666e+002f/600.0f*TESTAREAHEIGHT;
    pts[  3].X = 1.700000e+002f/600.0f*TESTAREAWIDTH; pts[  3].Y = 1.810000e+002f/600.0f*TESTAREAHEIGHT;
    pts[  4].X = 1.686667e+002f/600.0f*TESTAREAWIDTH; pts[  4].Y = 2.016666e+002f/600.0f*TESTAREAHEIGHT;
    pts[  5].X = 1.688667e+002f/600.0f*TESTAREAWIDTH; pts[  5].Y = 1.912666e+002f/600.0f*TESTAREAHEIGHT;
    pts[  6].X = 1.700000e+002f/600.0f*TESTAREAWIDTH; pts[  6].Y = 1.810000e+002f/600.0f*TESTAREAHEIGHT;
    pts[  7].X = 1.703333e+002f/600.0f*TESTAREAWIDTH; pts[  7].Y = 1.780666e+002f/600.0f*TESTAREAHEIGHT;
    pts[  8].X = 1.754666e+002f/600.0f*TESTAREAWIDTH; pts[  8].Y = 1.652000e+002f/600.0f*TESTAREAHEIGHT;
    pts[  9].X = 1.760000e+002f/600.0f*TESTAREAWIDTH; pts[  9].Y = 1.630000e+002f/600.0f*TESTAREAHEIGHT;

    pts[ 10].X = 1.703333e+002f/600.0f*TESTAREAWIDTH; pts[ 10].Y = 1.780666e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 11].X = 1.754666e+002f/600.0f*TESTAREAWIDTH; pts[ 11].Y = 1.652000e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 12].X = 1.760000e+002f/600.0f*TESTAREAWIDTH; pts[ 12].Y = 1.630000e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 13].X = 1.763333e+002f/600.0f*TESTAREAWIDTH; pts[ 13].Y = 1.617333e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 14].X = 1.772666e+002f/600.0f*TESTAREAWIDTH; pts[ 14].Y = 1.574666e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 15].X = 1.780000e+002f/600.0f*TESTAREAWIDTH; pts[ 15].Y = 1.560000e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 16].X = 1.763333e+002f/600.0f*TESTAREAWIDTH; pts[ 16].Y = 1.617333e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 17].X = 1.772666e+002f/600.0f*TESTAREAWIDTH; pts[ 17].Y = 1.574666e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 18].X = 1.780000e+002f/600.0f*TESTAREAWIDTH; pts[ 18].Y = 1.560000e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 19].X = 1.826666e+002f/600.0f*TESTAREAWIDTH; pts[ 19].Y = 1.467333e+002f/600.0f*TESTAREAHEIGHT;

    pts[ 20].X = 1.880000e+002f/600.0f*TESTAREAWIDTH; pts[ 20].Y = 1.452666e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 21].X = 1.950000e+002f/600.0f*TESTAREAWIDTH; pts[ 21].Y = 1.390000e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 22].X = 1.993333e+002f/600.0f*TESTAREAWIDTH; pts[ 22].Y = 1.351333e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 23].X = 2.037333e+002f/600.0f*TESTAREAWIDTH; pts[ 23].Y = 1.306667e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 24].X = 2.090000e+002f/600.0f*TESTAREAWIDTH; pts[ 24].Y = 1.280000e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 25].X = 1.993333e+002f/600.0f*TESTAREAWIDTH; pts[ 25].Y = 1.351333e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 26].X = 2.037333e+002f/600.0f*TESTAREAWIDTH; pts[ 26].Y = 1.306667e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 27].X = 2.090000e+002f/600.0f*TESTAREAWIDTH; pts[ 27].Y = 1.280000e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 28].X = 2.206000e+002f/600.0f*TESTAREAWIDTH; pts[ 28].Y = 1.222000e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 29].X = 2.332666e+002f/600.0f*TESTAREAWIDTH; pts[ 29].Y = 1.208667e+002f/600.0f*TESTAREAHEIGHT;

    pts[ 30].X = 2.460000e+002f/600.0f*TESTAREAWIDTH; pts[ 30].Y = 1.200000e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 31].X = 2.206000e+002f/600.0f*TESTAREAWIDTH; pts[ 31].Y = 1.222000e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 32].X = 2.332666e+002f/600.0f*TESTAREAWIDTH; pts[ 32].Y = 1.208667e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 33].X = 2.460000e+002f/600.0f*TESTAREAWIDTH; pts[ 33].Y = 1.200000e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 34].X = 2.531333e+002f/600.0f*TESTAREAWIDTH; pts[ 34].Y = 1.206000e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 35].X = 2.632000e+002f/600.0f*TESTAREAWIDTH; pts[ 35].Y = 1.206000e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 36].X = 2.700000e+002f/600.0f*TESTAREAWIDTH; pts[ 36].Y = 1.240000e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 37].X = 2.734666e+002f/600.0f*TESTAREAWIDTH; pts[ 37].Y = 1.257333e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 38].X = 2.763333e+002f/600.0f*TESTAREAWIDTH; pts[ 38].Y = 1.288000e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 39].X = 2.799999e+002f/600.0f*TESTAREAWIDTH; pts[ 39].Y = 1.300000e+002f/600.0f*TESTAREAHEIGHT;

    pts[ 40].X = 2.858000e+002f/600.0f*TESTAREAWIDTH; pts[ 40].Y = 1.319333e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 41].X = 2.889333e+002f/600.0f*TESTAREAWIDTH; pts[ 41].Y = 1.338667e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 42].X = 2.939999e+002f/600.0f*TESTAREAWIDTH; pts[ 42].Y = 1.370000e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 43].X = 2.858000e+002f/600.0f*TESTAREAWIDTH; pts[ 43].Y = 1.319333e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 44].X = 2.889333e+002f/600.0f*TESTAREAWIDTH; pts[ 44].Y = 1.338667e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 45].X = 2.939999e+002f/600.0f*TESTAREAWIDTH; pts[ 45].Y = 1.370000e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 46].X = 3.058666e+002f/600.0f*TESTAREAWIDTH; pts[ 46].Y = 1.443333e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 47].X = 3.215333e+002f/600.0f*TESTAREAWIDTH; pts[ 47].Y = 1.503333e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 48].X = 3.299999e+002f/600.0f*TESTAREAWIDTH; pts[ 48].Y = 1.620000e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 49].X = 3.332666e+002f/600.0f*TESTAREAWIDTH; pts[ 49].Y = 1.664666e+002f/600.0f*TESTAREAHEIGHT;

    pts[ 50].X = 3.385999e+002f/600.0f*TESTAREAWIDTH; pts[ 50].Y = 1.723333e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 51].X = 3.399999e+002f/600.0f*TESTAREAWIDTH; pts[ 51].Y = 1.780000e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 52].X = 3.411333e+002f/600.0f*TESTAREAWIDTH; pts[ 52].Y = 1.826666e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 53].X = 3.418666e+002f/600.0f*TESTAREAWIDTH; pts[ 53].Y = 1.873333e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 54].X = 3.429999e+002f/600.0f*TESTAREAWIDTH; pts[ 54].Y = 1.920000e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 55].X = 3.428666e+002f/600.0f*TESTAREAWIDTH; pts[ 55].Y = 1.949333e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 56].X = 3.430666e+002f/600.0f*TESTAREAWIDTH; pts[ 56].Y = 2.178666e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 57].X = 3.399999e+002f/600.0f*TESTAREAWIDTH; pts[ 57].Y = 2.250000e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 58].X = 3.428666e+002f/600.0f*TESTAREAWIDTH; pts[ 58].Y = 1.949333e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 59].X = 3.430666e+002f/600.0f*TESTAREAWIDTH; pts[ 59].Y = 2.178666e+002f/600.0f*TESTAREAHEIGHT;

    pts[ 60].X = 3.399999e+002f/600.0f*TESTAREAWIDTH; pts[ 60].Y = 2.250000e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 61].X = 3.363333e+002f/600.0f*TESTAREAWIDTH; pts[ 61].Y = 2.334666e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 62].X = 3.344666e+002f/600.0f*TESTAREAWIDTH; pts[ 62].Y = 2.390000e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 63].X = 3.279999e+002f/600.0f*TESTAREAWIDTH; pts[ 63].Y = 2.460000e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 64].X = 3.363333e+002f/600.0f*TESTAREAWIDTH; pts[ 64].Y = 2.334666e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 65].X = 3.344666e+002f/600.0f*TESTAREAWIDTH; pts[ 65].Y = 2.390000e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 66].X = 3.279999e+002f/600.0f*TESTAREAWIDTH; pts[ 66].Y = 2.460000e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 67].X = 3.257333e+002f/600.0f*TESTAREAWIDTH; pts[ 67].Y = 2.484000e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 68].X = 3.233333e+002f/600.0f*TESTAREAWIDTH; pts[ 68].Y = 2.506666e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 69].X = 3.209999e+002f/600.0f*TESTAREAWIDTH; pts[ 69].Y = 2.530000e+002f/600.0f*TESTAREAHEIGHT;

    pts[ 70].X = 3.257333e+002f/600.0f*TESTAREAWIDTH; pts[ 70].Y = 2.484000e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 71].X = 3.233333e+002f/600.0f*TESTAREAWIDTH; pts[ 71].Y = 2.506666e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 72].X = 3.209999e+002f/600.0f*TESTAREAWIDTH; pts[ 72].Y = 2.530000e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 73].X = 3.193333e+002f/600.0f*TESTAREAWIDTH; pts[ 73].Y = 2.546666e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 74].X = 3.170666e+002f/600.0f*TESTAREAWIDTH; pts[ 74].Y = 2.558666e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 75].X = 3.159999e+002f/600.0f*TESTAREAWIDTH; pts[ 75].Y = 2.579999e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 76].X = 3.115999e+002f/600.0f*TESTAREAWIDTH; pts[ 76].Y = 2.668000e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 77].X = 3.043999e+002f/600.0f*TESTAREAWIDTH; pts[ 77].Y = 2.708000e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 78].X = 2.969999e+002f/600.0f*TESTAREAWIDTH; pts[ 78].Y = 2.769999e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 79].X = 2.905999e+002f/600.0f*TESTAREAWIDTH; pts[ 79].Y = 2.823333e+002f/600.0f*TESTAREAHEIGHT;

    pts[ 80].X = 2.981333e+002f/600.0f*TESTAREAWIDTH; pts[ 80].Y = 2.784666e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 81].X = 2.869999e+002f/600.0f*TESTAREAWIDTH; pts[ 81].Y = 2.839999e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 82].X = 2.905999e+002f/600.0f*TESTAREAWIDTH; pts[ 82].Y = 2.823333e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 83].X = 2.981333e+002f/600.0f*TESTAREAWIDTH; pts[ 83].Y = 2.784666e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 84].X = 2.869999e+002f/600.0f*TESTAREAWIDTH; pts[ 84].Y = 2.839999e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 85].X = 2.815333e+002f/600.0f*TESTAREAWIDTH; pts[ 85].Y = 2.867333e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 86].X = 2.755333e+002f/600.0f*TESTAREAWIDTH; pts[ 86].Y = 2.874666e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 87].X = 2.700000e+002f/600.0f*TESTAREAWIDTH; pts[ 87].Y = 2.899999e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 88].X = 2.655213e+002f/600.0f*TESTAREAWIDTH; pts[ 88].Y = 2.920783e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 89].X = 2.649243e+002f/600.0f*TESTAREAWIDTH; pts[ 89].Y = 2.926785e+002f/600.0f*TESTAREAHEIGHT;

    pts[ 90].X = 2.649243e+002f/600.0f*TESTAREAWIDTH; pts[ 90].Y = 2.928842e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 91].X = 2.649243e+002f/600.0f*TESTAREAWIDTH; pts[ 91].Y = 2.929590e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 92].X = 2.650032e+002f/600.0f*TESTAREAWIDTH; pts[ 92].Y = 2.929816e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 93].X = 2.650032e+002f/600.0f*TESTAREAWIDTH; pts[ 93].Y = 2.930042e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 94].X = 2.650032e+002f/600.0f*TESTAREAWIDTH; pts[ 94].Y = 2.930609e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 95].X = 2.645045e+002f/600.0f*TESTAREAWIDTH; pts[ 95].Y = 2.931171e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 96].X = 2.610000e+002f/600.0f*TESTAREAWIDTH; pts[ 96].Y = 2.939999e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 97].X = 2.543333e+002f/600.0f*TESTAREAWIDTH; pts[ 97].Y = 2.936666e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 98].X = 2.476666e+002f/600.0f*TESTAREAWIDTH; pts[ 98].Y = 2.935999e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 99].X = 2.410000e+002f/600.0f*TESTAREAWIDTH; pts[ 99].Y = 2.929999e+002f/600.0f*TESTAREAHEIGHT;

    pts[100].X = 2.543333e+002f/600.0f*TESTAREAWIDTH; pts[100].Y = 2.936666e+002f/600.0f*TESTAREAHEIGHT;
    pts[101].X = 2.476666e+002f/600.0f*TESTAREAWIDTH; pts[101].Y = 2.935999e+002f/600.0f*TESTAREAHEIGHT;
    pts[102].X = 2.410000e+002f/600.0f*TESTAREAWIDTH; pts[102].Y = 2.929999e+002f/600.0f*TESTAREAHEIGHT;
    pts[103].X = 2.379333e+002f/600.0f*TESTAREAWIDTH; pts[103].Y = 2.927333e+002f/600.0f*TESTAREAHEIGHT;
    pts[104].X = 2.376000e+002f/600.0f*TESTAREAWIDTH; pts[104].Y = 2.913333e+002f/600.0f*TESTAREAHEIGHT;
    pts[105].X = 2.350000e+002f/600.0f*TESTAREAWIDTH; pts[105].Y = 2.899999e+002f/600.0f*TESTAREAHEIGHT;
    pts[106].X = 2.300000e+002f/600.0f*TESTAREAWIDTH; pts[106].Y = 2.875333e+002f/600.0f*TESTAREAHEIGHT;
    pts[107].X = 2.252000e+002f/600.0f*TESTAREAWIDTH; pts[107].Y = 2.857333e+002f/600.0f*TESTAREAHEIGHT;
    pts[108].X = 2.210000e+002f/600.0f*TESTAREAWIDTH; pts[108].Y = 2.819999e+002f/600.0f*TESTAREAHEIGHT;
    pts[109].X = 2.158666e+002f/600.0f*TESTAREAWIDTH; pts[109].Y = 2.774666e+002f/600.0f*TESTAREAHEIGHT;

    pts[110].X = 2.125333e+002f/600.0f*TESTAREAWIDTH; pts[110].Y = 2.706666e+002f/600.0f*TESTAREAHEIGHT;
    pts[111].X = 2.070000e+002f/600.0f*TESTAREAWIDTH; pts[111].Y = 2.669999e+002f/600.0f*TESTAREAHEIGHT;
    pts[112].X = 2.047333e+002f/600.0f*TESTAREAWIDTH; pts[112].Y = 2.635999e+002f/600.0f*TESTAREAHEIGHT;
    pts[113].X = 2.058666e+002f/600.0f*TESTAREAWIDTH; pts[113].Y = 2.648666e+002f/600.0f*TESTAREAHEIGHT;
    pts[114].X = 2.040000e+002f/600.0f*TESTAREAWIDTH; pts[114].Y = 2.629999e+002f/600.0f*TESTAREAHEIGHT;
    pts[115].X = 2.047333e+002f/600.0f*TESTAREAWIDTH; pts[115].Y = 2.635999e+002f/600.0f*TESTAREAHEIGHT;
    pts[116].X = 2.058666e+002f/600.0f*TESTAREAWIDTH; pts[116].Y = 2.648666e+002f/600.0f*TESTAREAHEIGHT;
    pts[117].X = 2.040000e+002f/600.0f*TESTAREAWIDTH; pts[117].Y = 2.629999e+002f/600.0f*TESTAREAHEIGHT;


    BYTE typs[] = {
        00, 03, 03, 03, 03, 03, 03, 03, 03, 03,
        03, 03, 03, 03, 03, 03, 03, 03, 03, 03,
        03, 03, 03, 03, 03, 03, 03, 03, 03, 03,
        03, 03, 03, 03, 03, 03, 03, 03, 03, 03,
        03, 03, 03, 03, 03, 03, 03, 03, 03, 03,
        03, 03, 03, 03, 03, 03, 03, 03, 03, 03,
        03, 03, 03, 03, 03, 03, 03, 03, 03, 03,
        03, 03, 03, 03, 03, 03, 03, 03, 03, 03,
        03, 03, 03, 03, 03, 03, 03, 03, 03, 03,
        03, 03, 03, 03, 03, 03, 03, 03, 03, 03,
        03, 03, 03, 03, 03, 03, 03, 03, 03, 03,
        03, 03, 03, 03, 03, 03, 03, 03
    };


    INT count1 = count;
    INT offset1 = 0;
//    offset1 = 15;
//    count1 = 19;
    count1 -= offset1;
    GpPointF* pts1 = &pts[0] + offset1;
    BYTE* typs1 = &typs[0] + offset1;

    GraphicsPath* path
        = new GraphicsPath(pts1, typs1, count1);

    Matrix mat;
//    mat.Translate(-300, - 200);
//    path->Transform(&mat);
    Matrix mat1;
//    mat1.Scale(5, 5);
//    path->Transform(&mat1);

    REAL width = 20;
    Color color(128, 0, 0, 0);
    SolidBrush brush(color);
    Pen pen(&brush, width);
    pen.SetLineJoin(LineJoinRound);

    g->DrawPath(&pen, path);

    delete path;
}

VOID CPaths::TestLeakPath(Graphics* g)
{
    INT count = 83;
    GpPointF p[83];
    BYTE t[83];

    t[0] = 0;   p[0].X = 1106.0f/600.0f*TESTAREAWIDTH;  p[0].Y = 1751.0f/600.0f*TESTAREAHEIGHT;

    t[1] = 3;   p[1].X = 1083.0f/600.0f*TESTAREAWIDTH;  p[1].Y = 1733.0f/600.0f*TESTAREAHEIGHT;
    t[2] = 3;   p[2].X = 1050.0f/600.0f*TESTAREAWIDTH;  p[2].Y = 1735.0f/600.0f*TESTAREAHEIGHT;
    t[3] = 3;   p[3].X = 1029.0f/600.0f*TESTAREAWIDTH;  p[3].Y = 1756.0f/600.0f*TESTAREAHEIGHT;
    t[4] = 3;   p[4].X = 1014.0f/600.0f*TESTAREAWIDTH;  p[4].Y = 1771.0f/600.0f*TESTAREAHEIGHT;
    t[5] = 3;   p[5].X = 1009.0f/600.0f*TESTAREAWIDTH;  p[5].Y = 1792.0f/600.0f*TESTAREAHEIGHT;
    t[6] = 3;   p[6].X = 1013.0f/600.0f*TESTAREAWIDTH;  p[6].Y = 1811.0f/600.0f*TESTAREAHEIGHT;

    t[7] = 1;   p[7].X = 1014.0f/600.0f*TESTAREAWIDTH;  p[7].Y = 1811.0f/600.0f*TESTAREAHEIGHT;

    t[8] = 3;   p[8].X = 999.0f/600.0f*TESTAREAWIDTH;   p[8].Y = 1811.0f/600.0f*TESTAREAHEIGHT;
    t[9] = 3;   p[9].X = 985.0f/600.0f*TESTAREAWIDTH;   p[9].Y = 1817.0f/600.0f*TESTAREAHEIGHT;
    t[10] = 3;  p[10].X = 975.0f/600.0f*TESTAREAWIDTH;  p[10].Y = 1828.0f/600.0f*TESTAREAHEIGHT;
    t[11] = 3;  p[11].X = 952.0f/600.0f*TESTAREAWIDTH;  p[11].Y = 1850.0f/600.0f*TESTAREAHEIGHT;
    t[12] = 3;  p[12].X = 952.0f/600.0f*TESTAREAWIDTH;  p[12].Y = 1887.0f/600.0f*TESTAREAHEIGHT;
    t[13] = 3;  p[13].X = 974.0f/600.0f*TESTAREAWIDTH;  p[13].Y = 1909.0f/600.0f*TESTAREAHEIGHT;
    t[14] = 3;  p[14].X = 976.0f/600.0f*TESTAREAWIDTH;  p[14].Y = 1910.0f/600.0f*TESTAREAHEIGHT;
    t[15] = 3;  p[15].X = 977.0f/600.0f*TESTAREAWIDTH;  p[15].Y = 1912.0f/600.0f*TESTAREAHEIGHT;
    t[16] = 3;  p[16].X = 979.0f/600.0f*TESTAREAWIDTH;  p[16].Y = 1913.0f/600.0f*TESTAREAHEIGHT;

    t[17] = 1;  p[17].X = 979.0f/600.0f*TESTAREAWIDTH;  p[17].Y = 1913.0f/600.0f*TESTAREAHEIGHT;

    t[18] = 3;  p[18].X = 969.0f/600.0f*TESTAREAWIDTH;  p[18].Y = 1948.0f/600.0f*TESTAREAHEIGHT;
    t[19] = 3;  p[19].X = 978.0f/600.0f*TESTAREAWIDTH;  p[19].Y = 1986.0f/600.0f*TESTAREAHEIGHT;
    t[20] = 3;  p[20].X = 1004.0f/600.0f*TESTAREAWIDTH; p[20].Y = 2011.0f/600.0f*TESTAREAHEIGHT;
    t[21] = 3;  p[21].X = 1017.0f/600.0f*TESTAREAWIDTH; p[21].Y = 2024.0f/600.0f*TESTAREAHEIGHT;
    t[22] = 3;  p[22].X = 1033.0f/600.0f*TESTAREAWIDTH; p[22].Y = 2033.0f/600.0f*TESTAREAHEIGHT;
    t[23] = 3;  p[23].X = 1051.0f/600.0f*TESTAREAWIDTH; p[23].Y = 2038.0f/600.0f*TESTAREAHEIGHT;

    t[24] = 1;  p[24].X = 1051.0f/600.0f*TESTAREAWIDTH; p[24].Y = 2038.0f/600.0f*TESTAREAHEIGHT;

    t[25] = 3;  p[25].X = 1044.0f/600.0f*TESTAREAWIDTH; p[25].Y = 2067.0f/600.0f*TESTAREAHEIGHT;
    t[26] = 3;  p[26].X = 1053.0f/600.0f*TESTAREAWIDTH; p[26].Y = 2097.0f/600.0f*TESTAREAHEIGHT;
    t[27] = 3;  p[27].X = 1074.0f/600.0f*TESTAREAWIDTH; p[27].Y = 2118.0f/600.0f*TESTAREAHEIGHT;
    t[28] = 3;  p[28].X = 1101.0f/600.0f*TESTAREAWIDTH; p[28].Y = 2145.0f/600.0f*TESTAREAHEIGHT;
    t[29] = 3;  p[29].X = 1114.0f/600.0f*TESTAREAWIDTH; p[29].Y = 2151.0f/600.0f*TESTAREAHEIGHT;
    t[30] = 3;  p[30].X = 1179.0f/600.0f*TESTAREAWIDTH; p[30].Y = 2132.0f/600.0f*TESTAREAHEIGHT;


    t[31] = 1;  p[31].X = 1178.0f/600.0f*TESTAREAWIDTH; p[31].Y = 2132.0f/600.0f*TESTAREAHEIGHT;

    t[32] = 3;  p[32].X = 1181.0f/600.0f*TESTAREAWIDTH; p[32].Y = 2146.0f/600.0f*TESTAREAHEIGHT;
    t[33] = 3;  p[33].X = 1188.0f/600.0f*TESTAREAWIDTH; p[33].Y = 2159.0f/600.0f*TESTAREAHEIGHT;
    t[34] = 3;  p[34].X = 1198.0f/600.0f*TESTAREAWIDTH; p[34].Y = 2169.0f/600.0f*TESTAREAHEIGHT;
    t[35] = 3;  p[35].X = 1228.0f/600.0f*TESTAREAWIDTH; p[35].Y = 2198.0f/600.0f*TESTAREAHEIGHT;
    t[36] = 3;  p[36].X = 1275.0f/600.0f*TESTAREAWIDTH; p[36].Y = 2198.0f/600.0f*TESTAREAHEIGHT;
    t[37] = 3;  p[37].X = 1305.0f/600.0f*TESTAREAWIDTH; p[37].Y = 2168.0f/600.0f*TESTAREAHEIGHT;

    t[38] = 1;  p[38].X = 1306.0f/600.0f*TESTAREAWIDTH; p[38].Y = 2168.0f/600.0f*TESTAREAHEIGHT;

    t[39] = 3;  p[39].X = 1341.0f/600.0f*TESTAREAWIDTH; p[39].Y = 2194.0f/600.0f*TESTAREAHEIGHT;
    t[40] = 3;  p[40].X = 1390.0f/600.0f*TESTAREAWIDTH; p[40].Y = 2190.0f/600.0f*TESTAREAHEIGHT;
    t[41] = 3;  p[41].X = 1422.0f/600.0f*TESTAREAWIDTH; p[41].Y = 2158.0f/600.0f*TESTAREAHEIGHT;
    t[42] = 3;  p[42].X = 1436.0f/600.0f*TESTAREAWIDTH; p[42].Y = 2144.0f/600.0f*TESTAREAHEIGHT;
    t[43] = 3;  p[43].X = 1445.0f/600.0f*TESTAREAWIDTH; p[43].Y = 2126.0f/600.0f*TESTAREAHEIGHT;
    t[44] = 3;  p[44].X = 1448.0f/600.0f*TESTAREAWIDTH; p[44].Y = 2107.0f/600.0f*TESTAREAHEIGHT;

    t[45] = 1;  p[45].X = 1448.0f/600.0f*TESTAREAWIDTH; p[45].Y = 2106.0f/600.0f*TESTAREAHEIGHT;

    t[46] = 3;  p[46].X = 1457.0f/600.0f*TESTAREAWIDTH; p[46].Y = 2103.0f/600.0f*TESTAREAHEIGHT;
    t[47] = 3;  p[47].X = 1465.0f/600.0f*TESTAREAWIDTH; p[47].Y = 2097.0f/600.0f*TESTAREAHEIGHT;
    t[48] = 3;  p[48].X = 1472.0f/600.0f*TESTAREAWIDTH; p[48].Y = 2091.0f/600.0f*TESTAREAHEIGHT;
    t[49] = 3;  p[49].X = 1494.0f/600.0f*TESTAREAWIDTH; p[49].Y = 2068.0f/600.0f*TESTAREAHEIGHT;
    t[50] = 3;  p[50].X = 1499.0f/600.0f*TESTAREAWIDTH; p[50].Y = 2033.0f/600.0f*TESTAREAHEIGHT;
    t[51] = 3;  p[51].X = 1484.0f/600.0f*TESTAREAWIDTH; p[51].Y = 2006.0f/600.0f*TESTAREAHEIGHT;

    t[52] = 1;  p[52].X = 1489.0f/600.0f*TESTAREAWIDTH; p[52].Y = 2006.0f/600.0f*TESTAREAHEIGHT;

    t[53] = 3;  p[53].X = 1502.0f/600.0f*TESTAREAWIDTH; p[53].Y = 1981.0f/600.0f*TESTAREAHEIGHT;
    t[54] = 3;  p[54].X = 1499.0f/600.0f*TESTAREAWIDTH; p[54].Y = 1946.0f/600.0f*TESTAREAHEIGHT;
    t[55] = 3;  p[55].X = 1478.0f/600.0f*TESTAREAWIDTH; p[55].Y = 1925.0f/600.0f*TESTAREAHEIGHT;
    t[56] = 3;  p[56].X = 1464.0f/600.0f*TESTAREAWIDTH; p[56].Y = 1911.0f/600.0f*TESTAREAHEIGHT;
    t[57] = 3;  p[57].X = 1446.0f/600.0f*TESTAREAWIDTH; p[57].Y = 1905.0f/600.0f*TESTAREAHEIGHT;
    t[58] = 3;  p[58].X = 1427.0f/600.0f*TESTAREAWIDTH; p[58].Y = 1907.0f/600.0f*TESTAREAHEIGHT;

    t[59] = 1;  p[59].X = 1429.0f/600.0f*TESTAREAWIDTH; p[59].Y = 1907.0f/600.0f*TESTAREAHEIGHT;

    t[60] = 3;  p[60].X = 1430.0f/600.0f*TESTAREAWIDTH; p[60].Y = 1889.0f/600.0f*TESTAREAHEIGHT;
    t[61] = 3;  p[61].X = 1424.0f/600.0f*TESTAREAWIDTH; p[61].Y = 1871.0f/600.0f*TESTAREAHEIGHT;
    t[62] = 3;  p[62].X = 1412.0f/600.0f*TESTAREAWIDTH; p[62].Y = 1859.0f/600.0f*TESTAREAHEIGHT;
    t[63] = 3;  p[63].X = 1396.0f/600.0f*TESTAREAWIDTH; p[63].Y = 1843.0f/600.0f*TESTAREAHEIGHT;
    t[64] = 3;  p[64].X = 1374.0f/600.0f*TESTAREAWIDTH; p[64].Y = 1838.0f/600.0f*TESTAREAHEIGHT;
    t[65] = 3;  p[65].X = 1353.0f/600.0f*TESTAREAWIDTH; p[65].Y = 1845.0f/600.0f*TESTAREAHEIGHT;

    t[66] = 1;  p[66].X = 1352.0f/600.0f*TESTAREAWIDTH; p[66].Y = 1846.0f/600.0f*TESTAREAHEIGHT;

    t[67] = 3;  p[67].X = 1352.0f/600.0f*TESTAREAWIDTH; p[67].Y = 1828.0f/600.0f*TESTAREAHEIGHT;
    t[68] = 3;  p[68].X = 1345.0f/600.0f*TESTAREAWIDTH; p[68].Y = 1810.0f/600.0f*TESTAREAHEIGHT;
    t[69] = 3;  p[69].X = 1332.0f/600.0f*TESTAREAWIDTH; p[69].Y = 1797.0f/600.0f*TESTAREAHEIGHT;
    t[70] = 3;  p[70].X = 1314.0f/600.0f*TESTAREAWIDTH; p[70].Y = 1779.0f/600.0f*TESTAREAHEIGHT;
    t[71] = 3;  p[71].X = 1287.0f/600.0f*TESTAREAWIDTH; p[71].Y = 1773.0f/600.0f*TESTAREAHEIGHT;
    t[72] = 3;  p[72].X = 1262.0f/600.0f*TESTAREAWIDTH; p[72].Y = 1781.0f/600.0f*TESTAREAHEIGHT;

    t[73] = 1;  p[73].X = 1262.0f/600.0f*TESTAREAWIDTH; p[73].Y = 1781.0f/600.0f*TESTAREAHEIGHT;

    t[74] = 3;  p[74].X = 1258.0f/600.0f*TESTAREAWIDTH; p[74].Y = 1766.0f/600.0f*TESTAREAHEIGHT;
    t[75] = 3;  p[75].X = 1250.0f/600.0f*TESTAREAWIDTH; p[75].Y = 1752.0f/600.0f*TESTAREAHEIGHT;
    t[76] = 3;  p[76].X = 1239.0f/600.0f*TESTAREAWIDTH; p[76].Y = 1741.0f/600.0f*TESTAREAHEIGHT;
    t[77] = 3;  p[77].X = 1205.0f/600.0f*TESTAREAWIDTH; p[77].Y = 1706.0f/600.0f*TESTAREAHEIGHT;
    t[78] = 3;  p[78].X = 1149.0f/600.0f*TESTAREAWIDTH; p[78].Y = 1707.0f/600.0f*TESTAREAHEIGHT;
    t[79] = 3;  p[79].X = 1114.0f/600.0f*TESTAREAWIDTH; p[79].Y = 1742.0f/600.0f*TESTAREAHEIGHT;
    t[80] = 3;  p[80].X = 1111.0f/600.0f*TESTAREAWIDTH; p[80].Y = 1745.0f/600.0f*TESTAREAHEIGHT;
    t[81] = 3;  p[81].X = 1108.0f/600.0f*TESTAREAWIDTH; p[81].Y = 1748.0f/600.0f*TESTAREAHEIGHT;
    t[82] = 0x83;  p[82].X = 1106.0f/600.0f*TESTAREAWIDTH; p[82].Y = 1751.0f/600.0f*TESTAREAHEIGHT;


    INT count1 = count;
    INT offset1 = 0;
    count1 -= offset1;
    GpPointF* pts1 = &p[0] + offset1;
    BYTE* typs1 = &t[0] + offset1;

    GraphicsPath* path
        = new GraphicsPath(pts1, typs1, count1);

    RectF rect;
    path->GetBounds(&rect);
    
    Matrix m;
    m.Scale(0.8f, 0.8f);
    m.Scale(TESTAREAWIDTH/rect.Width, TESTAREAHEIGHT/rect.Height);
    m.Translate(-rect.X, -rect.Y);
    path->Transform(&m);

    REAL width = 6;
    Color color(128, 0, 0, 0);
    SolidBrush brush(color);
    Pen pen(&brush, width);
    pen.SetLineJoin(LineJoinRound);

    g->DrawPath(&pen, path);

    delete path;
}


VOID CPaths::TestExcelCurvePath(Graphics *g)
{
    INT count = 9;
    PointF p[9];
    BYTE t[] = {00, 01, 03, 03, 03, 03, 03, 03, 01};

    p[0].X = 4.070000e+002f/600.0f*TESTAREAWIDTH; p[0].Y = 8.400000e+001f/600.0f*TESTAREAHEIGHT;
    p[1].X = 1.324267e+002f/600.0f*TESTAREAWIDTH; p[1].Y = 1.177392e+002f/600.0f*TESTAREAHEIGHT;
    p[2].X = 1.324267e+002f/600.0f*TESTAREAWIDTH; p[2].Y = 1.196965e+002f/600.0f*TESTAREAHEIGHT;
    p[3].X = 1.332627e+002f/600.0f*TESTAREAWIDTH; p[3].Y = 1.217801e+002f/600.0f*TESTAREAHEIGHT;
    p[4].X = 1.350000e+002f/600.0f*TESTAREAWIDTH; p[4].Y = 1.240000e+002f/600.0f*TESTAREAHEIGHT;
    p[5].X = 1.590000e+002f/600.0f*TESTAREAWIDTH; p[5].Y = 1.546667e+002f/600.0f*TESTAREAHEIGHT;
    p[6].X = 3.550000e+002f/600.0f*TESTAREAWIDTH; p[6].Y = 2.113333e+002f/600.0f*TESTAREAHEIGHT;
    p[7].X = 5.510000e+002f/600.0f*TESTAREAWIDTH; p[7].Y = 2.680000e+002f/600.0f*TESTAREAHEIGHT;
    p[8].X = 5.510000e+002f/600.0f*TESTAREAWIDTH; p[8].Y = 2.680000e+002f/600.0f*TESTAREAHEIGHT;

    GraphicsPath* path
        = new GraphicsPath(p, t, count);

    REAL width = 1;
    Color color(128, 0, 0, 0);
    SolidBrush brush(color);
    Pen pen(&brush, width);

    g->DrawPath(&pen, path);

    delete path;
}

VOID CPaths::TestDegenerateBezierPath(Graphics *g)
{
    REAL width = 4;         // Pen width
    Point points[4];
    
    GraphicsPath* path = new GraphicsPath(FillModeWinding);
    points[0].X = INT_MIN;  points[0].Y = INT_MAX;
    points[1].X = INT_MIN;  points[1].Y = INT_MIN;
    points[2].X = INT_MIN;  points[2].Y = INT_MIN;
    points[3].X = INT_MIN;  points[3].Y = INT_MIN;
    path->AddBeziers(points, 4);

    Color blackColor(128, 0, 0, 0);
    SolidBrush blackBrush(blackColor);
    Color yellowColor(128, 255, 255, 0);
    SolidBrush yellowBrush(yellowColor);

    width = 6;
    Pen blackPen(&blackBrush, width);

    g->FillPath(&yellowBrush, path);
//    g->DrawPath(&blackPen, path);
    g->DrawBezier(&blackPen, points[0], points[1], points[2], points[3]);
    delete path;
}

VOID TestEscherNewPath(Graphics* g)
{
    INT count = 0x2b;
    PointF p[0x2b];
    BYTE t[0x2b];
    
    memset(&t[0], 3, count);
    t[0] = 0;

    p[0x00].X =  0.0000f; p[0x00].Y = 118.667f;
    p[0x01].X = 96.9648f; p[0x01].Y = 161.683f;
    p[0x02].X = 193.482f; p[0x02].Y = 204.793f;
    p[0x03].X = 232.976f; p[0x03].Y = 205.164f;
    p[0x04].X = 96.9648f; p[0x04].Y = 161.683f;
    p[0x05].X = 193.482f; p[0x05].Y = 204.793f;
    p[0x06].X = 232.976f; p[0x06].Y = 205.164f;
    p[0x07].X = 272.470f; p[0x07].Y = 205.534f;
    p[0x08].X = 233.440f; p[0x08].Y = 132.202f;
    p[0x09].X = 236.777f; p[0x09].Y = 120.799f;
    p[0x0a].X = 240.115f; p[0x0a].Y = 109.396f;
    p[0x0b].X = 246.233f; p[0x0b].Y = 126.083f;
    p[0x0c].X = 252.908f; p[0x0c].Y = 136.467f;
    p[0x0d].X = 259.583f; p[0x0d].Y = 146.850f;
    p[0x0e].X = 276.456f; p[0x0e].Y = 182.357f;
    p[0x0f].X = 276.827f; p[0x0f].Y = 182.914f;

    p[0x10].X = 259.583f; p[0x10].Y = 146.850f;
    p[0x11].X = 276.456f; p[0x11].Y = 182.357f;
    p[0x12].X = 276.827f; p[0x12].Y = 182.914f;
    p[0x13].X = 276.829f; p[0x13].Y = 182.917f;
    p[0x14].X = 276.831f; p[0x14].Y = 182.918f;
    p[0x15].X = 276.831f; p[0x15].Y = 182.918f;
    p[0x16].X = 276.832f; p[0x16].Y = 182.918f;
    p[0x17].X = 276.832f; p[0x17].Y = 182.917f;
    p[0x18].X = 276.832f; p[0x18].Y = 182.916f;
    p[0x19].X = 276.832f; p[0x19].Y = 182.546f;
    p[0x1a].X = 260.180f; p[0x1a].Y = 139.438f;
    p[0x1b].X = 255.890f; p[0x1b].Y = 139.438f;
    p[0x1c].X = 255.616f; p[0x1c].Y = 139.438f;
    p[0x1d].X = 255.392f; p[0x1d].Y = 139.614f;
    p[0x1e].X = 255.226f; p[0x1e].Y = 139.990f;
    p[0x1f].X = 252.445f; p[0x1f].Y = 146.294f;

    p[0x20].X = 256.524f; p[0x20].Y = 210.077f;
    p[0x21].X = 259.861f; p[0x21].Y = 220.831f;
    p[0x22].X = 263.199f; p[0x22].Y = 231.585f;
    p[0x23].X = 270.523f; p[0x23].Y = 207.296f;
    p[0x24].X = 275.066f; p[0x24].Y = 204.422f;
    p[0x25].X = 277.365f; p[0x25].Y = 202.967f;
    p[0x26].X = 279.427f; p[0x26].Y = 202.486f;
    p[0x27].X = 281.383f; p[0x27].Y = 202.486f;
    p[0x28].X = 283.292f; p[0x28].Y = 202.486f;
    p[0x29].X = 285.101f; p[0x29].Y = 202.944f;
    p[0x2a].X = 286.932f; p[0x2a].Y = 203.402f;


    GraphicsPath* path
        = new GraphicsPath(p, t, count);

    REAL width = 0.555903f;
    Color color(128, 0, 0, 0);
    SolidBrush brush(color);
    Pen pen(&brush, width);

    path->Widen(&pen);
    g->FillPath(&brush, path);

//    g->DrawPath(&pen, path);

    delete path;
}

VOID CPaths::TestPie(Graphics *g)
{
    // Provided by good old Nolan

    Color c(0xff, 0xff, 0, 0);
    SolidBrush b(c);
    Pen p(&b, 10.0f);

    Status status = g->DrawPie(&p, 75, 350, 800, 110, 180, 0);
//    ASSERT(status == Ok);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\functest\cprinting.h ===
/******************************Module*Header*******************************\
* Module Name: CPrinting.h
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/

#ifndef __CPRINTING_H
#define __CPRINTING_H

#include "..\CPrimitive.h"

class CPrinting : public CPrimitive  
{
public:
	CPrinting(BOOL bRegression);
	virtual ~CPrinting();

	void Draw(Graphics *g);

	VOID TestPerfPrinting(Graphics *g);
	VOID TestTextPrinting(Graphics *g);
        
        VOID TestNolan1(Graphics *g);
        VOID TestNolan2(Graphics *g);

        VOID TestBug104604(Graphics *g);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\functest\cpolygons.h ===
/******************************Module*Header*******************************\
* Module Name: CPolygons.h
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/

#ifndef __CPOLYGONS_H
#define __CPOLYGONS_H

#include "CPrimitive.h"

class CPolygons : public CPrimitive  
{
public:
	CPolygons(BOOL bRegression);
	virtual ~CPolygons();

	void Draw(Graphics *g);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\functest\cpaths.h ===
/******************************Module*Header*******************************\
* Module Name: CPaths.h
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/

#ifndef __CPATHS_H
#define __CPATHS_H

#include "CPrimitive.h"

class CJoins : public CPrimitive  
{
public:
	CJoins(BOOL bRegression);
	virtual ~CJoins();

	void Draw(Graphics *g);
};

class CPaths : public CPrimitive  
{
public:
	CPaths(BOOL bRegression);
	virtual ~CPaths();

	void Draw(Graphics *g);

	VOID TestBezierPath(Graphics* g);
	VOID TestSinglePixelWidePath(Graphics* g);
	VOID TestTextAlongPath(Graphics* g);
	VOID TestFreeFormPath1(Graphics* g);
	VOID TestFreeFormPath2(Graphics* g);
	VOID TestLeakPath(Graphics* g);
	VOID TestExcelCurvePath(Graphics* g);
	VOID TestDegenerateBezierPath(Graphics* g);
        VOID TestPie(Graphics *g);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\functest\cpolygons.cpp ===
/******************************Module*Header*******************************\
* Module Name: CPolygons.cpp
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/
#include "CPolygons.h"

CPolygons::CPolygons(BOOL bRegression)
{
	strcpy(m_szName,"Polygons");
	m_bRegression=bRegression;
}

CPolygons::~CPolygons()
{
}

void CPolygons::Draw(Graphics *g)
{
    REAL width = 4; // Pen width

    Color redColor(255, 0, 0);

    SolidBrush redBrush(redColor);
    g->FillRectangle(&redBrush, (int)(20.0f/150.0f*TESTAREAWIDTH), (int)(20.0f/150.0f*TESTAREAHEIGHT), (int)(50.0f/150.0f*TESTAREAWIDTH), (int)(50.0f/150.0f*TESTAREAHEIGHT));

    Color alphaColor(128, 0, 255, 0);

    SolidBrush alphaBrush(alphaColor);
    g->FillRectangle(&alphaBrush, (int)(10.0f/150.0f*TESTAREAWIDTH), (int)(10.0f/150.0f*TESTAREAHEIGHT), (int)(40.0f/150.0f*TESTAREAWIDTH), (int)(40.0f/150.0f*TESTAREAHEIGHT));

    Point points[4];
    points[0].X = (int)(50.0f/150.0f*TESTAREAWIDTH);
    points[0].Y = (int)(50.0f/150.0f*TESTAREAHEIGHT);
    points[1].X = (int)(100.0f/150.0f*TESTAREAWIDTH);
    points[1].Y = (int)(50.0f/150.0f*TESTAREAHEIGHT);
    points[2].X = (int)(120.0f/150.0f*TESTAREAWIDTH);
    points[2].Y = (int)(120.0f/150.0f*TESTAREAHEIGHT);
    points[3].X = (int)(50.0f/150.0f*TESTAREAWIDTH);
    points[3].Y = (int)(100.0f/150.0f*TESTAREAHEIGHT);

    Color blueColor(128, 0, 0, 255);

    SolidBrush blueBrush(blueColor);
    g->FillPolygon(&blueBrush, points, 4);

    // Currently only Geometric pen works for lines. - ikkof 1/6/99.

    Color blackColor(0, 0, 0);
    SolidBrush blackBrush(blackColor);
    width = 16;
    Pen blackPen(&blackBrush, width);
    blackPen.SetLineJoin(LineJoinRound);
//    blackPen.SetLineJoin(LineJoinBevel);
    g->DrawPolygon(&blackPen, points, 4);
//    g->DrawLines(&blackPen, points, 4, FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\functest\cprimitives.h ===
/******************************Module*Header*******************************\
* Module Name: CPrimitives.h
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/

#ifndef __CPRIMITIVES_H
#define __CPRIMITIVES_H

#include "CPrimitive.h"

class CPrimitives : public CPrimitive  
{
public:
	CPrimitives(BOOL bRegression);
	virtual ~CPrimitives();

	void Draw(Graphics *g);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\functest\cprimitives.cpp ===
/******************************Module*Header*******************************\
* Module Name: CPrimitives.cpp
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/
#include "CPrimitives.h"

CPrimitives::CPrimitives(BOOL bRegression)
{
	strcpy(m_szName,"Primitives");
	m_bRegression=bRegression;
}

CPrimitives::~CPrimitives()
{
}

void CPrimitives::Draw(Graphics *g)
{
    Rect rect;

    rect.X = (int)(100.0f/400.0f*TESTAREAWIDTH);
    rect.Y = (int)(160.0f/400.0f*TESTAREAHEIGHT);
    rect.Width = (int)(230.0f/400.0f*TESTAREAWIDTH);
    rect.Height = (int)(180.0f/400.0f*TESTAREAHEIGHT);

    Color color(128, 128, 255, 0);

    SolidBrush brush(color);

    REAL width = 1;

    Color blackColor(0, 0, 0);
    SolidBrush blackBrush(blackColor);
    Pen pen(&blackBrush, width);

//    g->FillEllipse(&brush, rect);
//    g->DrawEllipse(&pen, rect);
    REAL startAngle = 0;
    REAL sweepAngle = 240;
    g->FillPie(&brush, rect, startAngle, sweepAngle);
    g->DrawPie(&pen, rect, startAngle, sweepAngle);

    Point pts[10];
    INT count = 4;

    pts[0].X = (int)(100.0f/400.0f*TESTAREAWIDTH);
    pts[0].Y = (int)(60.0f/400.0f*TESTAREAHEIGHT);
    pts[1].X = (int)(50.0f/400.0f*TESTAREAWIDTH);
    pts[1].Y = (int)(130.0f/400.0f*TESTAREAHEIGHT);
    pts[2].X = (int)(200.0f/400.0f*TESTAREAWIDTH);
    pts[2].Y = (int)(260.0f/400.0f*TESTAREAHEIGHT);
    pts[3].X = (int)(300.0f/400.0f*TESTAREAWIDTH);
    pts[3].Y = (int)(80.0f/400.0f*TESTAREAHEIGHT);

    g->FillClosedCurve(&brush, pts, count);
    g->DrawClosedCurve(&pen, pts, count);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\functest\cprinter.cpp ===
/******************************Module*Header*******************************\
* Module Name: CPrinter.cpp
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/
#include "CPrinter.h"

CPrinter::CPrinter(BOOL bRegression)
{
    m_hDC=NULL;
    strcpy(m_szName,"Printer");
    m_bRegression=bRegression;
}

CPrinter::~CPrinter()
{
}

BOOL CPrinter::Init()
{
    return COutput::Init();
}

Graphics *CPrinter::PreDraw(int &nOffsetX,int &nOffsetY)
{
    Graphics *g=NULL;

    PRINTDLGA pd =
    {
       sizeof(PRINTDLG),
       NULL,            // hwndOwner
       NULL,            // hDevMode
       NULL,            // hDevNames
       NULL,            // hDC
       PD_RETURNDC,
       1,
       1,
       1,
       1,
       1,
       GetModuleHandleA(NULL),
       NULL,
       NULL,            // print hook
       NULL,            // setup hook
       NULL,            // print template name
       NULL,            // setup template name
       NULL,            // hPrintTemplate
       NULL             // hSetupTemplate
    };

    if (!PrintDlgA(&pd))
    {
       MessageBoxA(NULL, "No printer selected.", NULL, MB_OK);
       return NULL;
    }

    DOCINFOA docinfo;
    docinfo.cbSize        = sizeof(DOCINFO);
    docinfo.lpszDocName   = "GDI+ Print Test";
    docinfo.lpszOutput    = NULL;         // put name here to output to file
    docinfo.lpszDatatype  = NULL;         // data type 'emf' or 'raw'
    docinfo.fwType        = 0;

    m_hDC = pd.hDC;
    INT printJobID = StartDocA(m_hDC, &docinfo);
    StartPage(m_hDC);

    SetStretchBltMode(m_hDC, HALFTONE);
    SetBrushOrgEx(m_hDC, 0, 0, NULL);

    g = Graphics::FromHDC(m_hDC);

    return g;
}

void CPrinter::PostDraw(RECT rTestArea)
{
    EndPage(m_hDC);
    EndDoc(m_hDC);
    DeleteDC(m_hDC);

    MessageBoxA(NULL, "Print Functionality Test Complete.", NULL, MB_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\functest\cprinting.cpp ===
/******************************Module*Header*******************************\
* Module Name: CPrinting.cpp
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/
#include "CPrinting.h"

CPrinting::CPrinting(BOOL bRegression)
{
	strcpy(m_szName,"Printing");
	m_bRegression=bRegression;
}

CPrinting::~CPrinting()
{
}

VOID CPrinting::TestTextPrinting(Graphics *g)
{
    Font f(L"Arial", 60);

    FontFamily  ff(L"Arial");
    RectF	  rectf1( 20,   0, 300, 200);
    RectF	  rectf2( 20, 300, 300, 200);
    RectF	  rectf3(220,   0, 300, 200);
    RectF	  rectf4(220, 300, 300, 200);


    Color color1(0xff, 100, 0, 200);
    Color color2(128, 100, 0, 200);
    Color color3(0xff, 0, 100, 200);
    Color color4(128, 0, 100, 0);
    SolidBrush brush1(color1);
    SolidBrush brush2(color2);
    LinearGradientBrush brush3(rectf3, color3, color4, LinearGradientModeForwardDiagonal);

    g->DrawString(L"Color1", 6, &f, rectf1, NULL, &brush1);
    g->DrawString(L"Color2", 6, &f, rectf2, NULL, &brush2);
    g->DrawString(L"Color3", 6, &f, rectf3, NULL, &brush3);
}

VOID CPrinting::TestPerfPrinting(Graphics *g)
{
/*
   Analyze file size based on output of StretchDIBits.  The claim by DonC is that when we StretchDIBits a
   subrectangle of a large DIB, it sends the large DIB to the printer and then clips to the subrectangle.
   How stupid, but it apparently does on Win98 postscript.

   So this is the results of my test:  1000x1000 DIB (32bpp).  I blitted two chunks:

   This is 200x200 source rectangle (part of a band):

04/27/2000  03:00p              22,198 nt5pcl
04/27/2000  03:02p             268,860 nt5ps			// Level 1 ps
04/27/2000  02:47p              17,488 w98pcl
04/27/2000  02:47p           6,207,459 w98ps			// Level 1 ps

   This is 1000x200 source rectangle (an entire band):

04/27/2000  03:06p              80,291 nt5pcl
04/27/2000  03:06p           1,266,123 nt5ps			// Level 1 ps
04/27/2000  02:51p              60,210 w98pcl
04/27/2000  02:52p           6,207,457 w98ps			// Level 1 ps

   Also compared 32bpp vs. 24bpp DIB.  The results were contradictary:

  04/27/2000  03:59p      <DIR>          ..
  04/27/2000  03:06p              80,291 nt5pcl
  04/27/2000  03:51p             122,881 nt5pcl24
  04/27/2000  03:06p           1,266,123 nt5ps
  04/27/2000  03:51p           1,262,332 nt5ps24
  04/27/2000  02:51p              60,210 w98pcl
  04/27/2000  03:39p             101,216 w98pcl24
  04/27/2000  02:52p           6,207,457 w98ps
  04/27/2000  03:39p           6,207,457 w98ps24

*/
    if (1) 
    {
        BITMAPINFO bi;
        ZeroMemory(&bi, sizeof(BITMAPINFO));

        bi.bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
        bi.bmiHeader.biPlanes = 1;
        bi.bmiHeader.biCompression = BI_RGB;
        bi.bmiHeader.biSizeImage = 0;

        bi.bmiHeader.biWidth = 1000;
        bi.bmiHeader.biHeight = 1000;
        bi.bmiHeader.biBitCount = 32;

        ARGB* Bits = (ARGB*)malloc(bi.bmiHeader.biWidth *
                              bi.bmiHeader.biHeight *
                              sizeof(ARGB));

        ARGB* Ptr = Bits;

        // To eliminate RLE/ASCII85 encoding, set to random bits
        for (INT i=0; i<bi.bmiHeader.biHeight; i++)
            for (INT j=0; j<bi.bmiHeader.biWidth; j++) 
            {
                *Ptr++ = (ARGB)(i | (j<<16));
            }

        HDC hdc = g->GetHDC();

        StretchDIBits(hdc, 0, 0, 1000, 200, 
                      0, 700, 1000, 200, Bits, &bi,
                      DIB_RGB_COLORS, SRCCOPY);

        g->ReleaseHDC(hdc);

        free(Bits);

    }
}

void CPrinting::Draw(Graphics *g)
{
// TestPerfPrinting(g);
// TestTextPrinting(g);
TestBug104604(g);

if (0)
    {

#if 1
    HDC hdc = g->GetHDC();

    HDC bufHdc = CreateCompatibleDC(hdc);

    HBITMAP BufDIB = NULL;
    ARGB* argb;

    struct {
       BITMAPINFO bitmapInfo;
       RGBQUAD rgbQuad[4];
    } bmi;

    INT width=100;
    INT height=100;

    ZeroMemory(&bmi.bitmapInfo, sizeof(bmi.bitmapInfo));

    bmi.bitmapInfo.bmiHeader.biSize        = sizeof(BITMAPINFOHEADER);
    bmi.bitmapInfo.bmiHeader.biWidth       = width;
    bmi.bitmapInfo.bmiHeader.biHeight      = -height;
    bmi.bitmapInfo.bmiHeader.biPlanes      = 1;
    bmi.bitmapInfo.bmiHeader.biBitCount    = 24;
    bmi.bitmapInfo.bmiHeader.biCompression = BI_RGB;
	
    RGBQUAD red = { 0, 0, 0xFF, 0}; // red
    RGBQUAD green = { 0, 0xFF, 0, 0}; // green
    RGBQUAD blue = { 0xFF, 0, 0, 0}; // blue

    bmi.bitmapInfo.bmiColors[0] = red;
    bmi.bitmapInfo.bmiColors[1] = green;
    bmi.bitmapInfo.bmiColors[2] = blue;

    // if assert fails, then we didn't clean up properly by calling End()
//    ASSERT(BufDIB == NULL);

    BufDIB = CreateDIBSection(bufHdc,
                 &bmi.bitmapInfo,
                 DIB_RGB_COLORS,
                 (VOID**) &argb,
                 NULL,
                 0);
//    ASSERT(BufDIB != NULL);

    memset(argb, 0, 3*width*height);

    INT i,j;
    BYTE* tempptr = (BYTE*)argb;
    for (i=0; i<height; i++)
    {
        for (j=0; j<width; j++)
        {
            if (i==j)
            {
                *tempptr++ = 0xFF;
                *tempptr++ = 0x80;
                *tempptr++ = 0x40;
            }
            else
                tempptr += 3;    
        }
        if ((((ULONG_PTR)tempptr) % 4) != 0) tempptr += 4-(((ULONG_PTR)tempptr) % 4);
    }

    INT mode = GetMapMode(bufHdc);
//    WARNING(("MapMode printing = %08x\n", mode));

    SelectObject(bufHdc, BufDIB);
/*
for (i=0; i<100; i++)
{
    int result = StretchBlt(hdc, 0, i*2, 2*width, 2, bufHdc, 0, i, width, 0, SRCCOPY);
    INT joke = GetLastError();
	joke++;
}
 */
//	int result = StretchBlt(hdc, 0, 0, 50, 50, bufHdc, 0, 0, 50, 50, SRCCOPY);
	
	for (i=0; i<50; i++)
	{
		int result = StretchBlt(hdc, 0, 100+i*2, 100, 1, bufHdc, 0, i*2, 100, 1, SRCCOPY);
    }
//   int result = StretchBlt(hdc, 0, 0, 200, 200, bufHdc, 0, 0, 100, 100, SRCCOPY);

//    ASSERT(result != 0);

    g->ReleaseHDC(hdc);

    DeleteDC(bufHdc);
    DeleteObject(BufDIB);

#endif

#if 1
    REAL widthF = 4; // Pen width

    Color redColor(255, 0, 0);

    SolidBrush brush1(Color(0xFF,0xFF,0,0));
    SolidBrush brush2(Color(0x80,0x80,0,0));

    SolidBrush brush3(Color(0xFF,0xFF,0,0));
    SolidBrush brush4(Color(0x80,0x80,0,0));

    Color colors1[] = { Color(0xFF,0xFF,0,0),
                        Color(0xFF,0,0xFF,0),
                        Color(0xFF,0,0,0xFF),
                        Color(0xFF,0x80,0x80,0x80) };
    Color colors2[] = { Color(0x80,0xFF,0,0),
                        Color(0x80,0,0xFF,0),
                        Color(0x80,0,0,0xFF),
                        Color(0x80,0x80,0x80,0x80) };

    //SolidBrush brush3(colors1[2]);
    //SolidBrush brush4(colors2[2]);

    // Default Wrap: Clamp to small rectangle 
//    RectangleGradientBrush brush3(Rect(125,275,50,50),
//                                  &colors1[0]);//,
                                  //WrapModeClamp);
    // Default Wrap: Clamp to 
//    RectangleGradientBrush brush4(Rect(250,250,100,100),
//                                  &colors2[0]);//,
                                  //WrapModeClamp);

    g->SetPageScale(1.2f);

    // no path clip
    g->FillRectangle(&brush1, Rect(0,25,500,50));

    // tests solid + opaque combinations + path clip only
    g->FillEllipse(&brush1, Rect(100,100,100,100));
    g->FillEllipse(&brush2, Rect(300,100,100,100));
    g->FillEllipse(&brush3, Rect(100,250,100,100));
    g->FillEllipse(&brush4, Rect(300,250,100,100));

    // tests visible clip + path clip
    Region origRegion;
    g->GetClip(&origRegion);
    Region *newRegion = new Region();
    newRegion->MakeInfinite();

    //Rect horzRect(150, 600, 500, 25);
    //Rect vertRect(150, 600, 25, 500);
    Rect horzRect(100, 400, 500, 25);
    Rect vertRect(100, 400, 25, 500);
    Region *horzRegion = new Region(horzRect);
    Region *vertRegion = new Region(vertRect);

    for (i = 0; i < 10; i++)
    {   
        newRegion->Xor(horzRegion);
        newRegion->Xor(vertRegion);
        horzRegion->Translate(0, 50);
        vertRegion->Translate(50, 0);
    }
    delete horzRegion;
    delete vertRegion;

    // Set grid clipping
    g->SetClip(newRegion);

    // set wrap mode from Clamp to Tile    
//    brush3.SetWrapMode(WrapModeTile);
//    brush4.SetWrapMode(WrapModeTile);

    // tests solid + opaque combinations + visible clip +  path clip only

    g->FillEllipse(&brush1, Rect(100,400,100,100));
    g->FillEllipse(&brush2, Rect(300,400,100,100));
    g->FillEllipse(&brush3, Rect(100,550,100,100));
    g->FillEllipse(&brush4, Rect(300,550,100,100));

    // restore original clip region
    g->SetClip(&origRegion);
    delete newRegion;

    // Test case which stretches beyond GetTightBounds() DrawBounds API

    PointF pts[8];

    pts[0].X = 2150.0f; pts[0].Y = 2928.03f;
    pts[1].X = 1950.0f; pts[1].Y = 3205.47f;
    pts[2].X = 1750.0f; pts[2].Y = 2650.58f;
    pts[3].X = 1550.0f; pts[3].Y = 2928.03f;
    pts[4].X = 1550.0f; pts[4].Y = 3371.97f;
    pts[5].X = 1750.0f; pts[5].Y = 3094.53f;
    pts[6].X = 1950.0f; pts[6].Y = 3649.42f;
    pts[7].X = 2150.0f; pts[7].Y = 3371.97f;

    BYTE types[8] = { 1, 3, 3, 3, 1, 3, 3, 0x83 };


    Bitmap *bitmap = new Bitmap(L"winnt256.bmp");

    // Test g->DrawImage
    if (bitmap && bitmap->GetLastStatus() == Ok) 
    {

        int i;

        for (i=0; i<8; i++) 
        {
            pts[i].X = pts[i].X / 8.0f;
            pts[i].Y = pts[i].Y / 8.0f;
        }

        TextureBrush textureBrush(bitmap, WrapModeTile);

        GraphicsPath path(&pts[0], &types[0], 8);

        g->FillPath(&textureBrush, &path);

        // Text using WrapModeClamp
        for (i=0; i<8; i++)
           pts[i].X += 200.0f;

        TextureBrush textureBrush2(bitmap, WrapModeClamp);

        GraphicsPath path2(&pts[0], &types[0], 8);

        g->FillPath(&textureBrush2, &path2);

        delete bitmap;
    }

/*
    Font font(50.0f * g->GetDpiY() / 72.0f, // emSize
              FontFamily(L"Arial"), // faceName,
              0,
              (Unit)g->GetPageUnit()
              );

    // will fail on Win9x
    LPWSTR str = L"Printing Support is COOL";
    GpRectF layoutRect1(200, 200, 300, 100);
    GpRectF layoutRect2(200, 400, 300, 100);
    GpRectF layoutRect3(200, 600, 300, 100);
    GpRectF layoutRect4(200, 800, 300, 100);

    INT len = 0;
    LPWSTR strPtr = str;
    while (*str != '\0') { len++; str++; }

    StringFormat format1 = StringFormatDirectionRightToLeft;
    StringFormat format2 = StringFormatDirectionVertical;
    StringFormat format3 = StringFormatDirectionRightToLeft;
    StringFormat format4 = StringFormatDirectionVertical;

    // Test DDI: SolidText (Brush 1 or 2)
    g->DrawString(strPtr, len, &font, &layoutRect1, &format1, &brush1);
    g->DrawString(strPtr, len, &font, &layoutRect2, &format2, &brush2);   

    // Test DDI: BrushText (Brush 3 or 4)
    g->DrawString(strPtr, len, &font, &layoutRect3, &format3, &brush3);
    g->DrawString(strPtr, len, &font, &layoutRect4, &format4, &brush4);   

    // Test DDI: StrokePath
    // Test DDI: FillRegion
*/
#endif
    }

}

// Try this from Nolan Lettelier
VOID CPrinting::TestNolan1(Graphics *g)
{
/*	TestInit(hdc);

	Graphics *pg = Graphics::FromHDC(hdc);
	if (pg == NULL)
	{
		assert(0);
		return false;
	}

	int sts;
	int alpha = 255, red = 255, green = 0, blue = 255;
	Color c1(alpha,red,green,blue);
	Point p1(150,150), p2(300,300);
	Color c2(255, 255-red, 255-green, 255-blue);
	LineGradientBrush gb(p1, p2, c1, c2);

	Pen p(&gb, 50.0);

	sts = pg->DrawLine(&p,0, 0, 500, 500);
	assert(sts == Ok);

	sts = pg->DrawLine(&p,0,100, 500, 100);
	assert(sts == Ok);

	sts = pg->DrawLine(&p,0,350, 500, 350);
	assert(sts == Ok);

	sts = pg->DrawLine(&p,0,500, 500, 0);
	assert(sts == Ok);
	delete pg;
	return true;
        */
}

VOID CPrinting::TestNolan2(Graphics *g)
{
    /*
        CString lineText("NolanRules");
        
	Graphics *pg = g;
        if (pg == NULL)
	{
		assert(0);
		return false;
	}
        Unit origUnit = pg->GetPageUnit();
        Matrix origXform;
        pg->GetTransform(&origXform);

        pg->SetPageUnit(UnitInch);
        pg->ScaleTransform(8.0f/1000.0f, 8.0f/1000.0f);

	Status sts;
	int alpha = 255, red = 255, green = 0, blue = 255;
	RectF rg(150,150,300,175);
	Color c1(alpha,red,green,blue);
	Color c2(255, 255-red, 255-green, 255-blue);
	LineGradientBrush gb(rg, c1, c2, LineGradientModeVertical);

	WCHAR *famName[] = {
		L"Comic Sans MS"
		, L"Courier New"
		, L"Times New Roman"
		, L"Tahoma"
		, L"Arial"
		, L"Lucida Console"
		, L"Garamond"
		, L"Palatino"
		, L"Univers"
		, L"Marigold"
		, L"Albertus"
		, L"Antique Olive"
	};

	int famCount = sizeof(famName) / sizeof(WCHAR *);

	WCHAR *s = L"GDI+ GradientFill";
	
	RectF r(30,30,0,0);
	StringFormat sf(0);
	FontFamily *pFontFamily;

	float lineHeight = 60;
	int i;
	for (i = 0, r.Y = 30 ; r.Y < 800 ; r.Y += lineHeight, ++i)
	{
		pFontFamily = new FontFamily(famName[i % famCount]);
		while (pFontFamily == NULL || pFontFamily->GetLastStatus()
!= Ok)
		{
			delete pFontFamily;
			++i;
			pFontFamily = new FontFamily(famName[i % famCount]);
		}
			
		Font f(*pFontFamily, lineHeight * 5 / 6, 0, UnitPoint);
		sts = pg->DrawString(s, wcslen(s), &f, &r, &sf, &gb);
//		CHECK_RESULT(sts, "TestGradientLinearVertical2 DrawString");
		delete pFontFamily;
	}

	delete pg;
	
        pg->SetPageUnit(origUnit);
        pg->SetTransform(&origXform);
        return true;
*/

} // TestGradientLinearVertical2

VOID CPrinting::TestBug104604(Graphics *g)
{
    BYTE* memory = new BYTE[8*8*3];
    // checkerboard pattern
    for (INT i=0; i<8*8; i += 3)
    {
        if (i%2)
        {
            memory[i] = 0xff;
            memory[i+1] = 0;
            memory[i+2] = 0;
        }
        else
        {
            memory[i] = 0;
            memory[i+1] = 0;
            memory[i+2] = 0xff;
        }
    }
    
    Bitmap bitmap(8,8, 8*3, PixelFormat24bppRGB, memory);
    
    TextureBrush brush(&bitmap);

    g->SetCompositingMode(CompositingModeSourceCopy);
    g->FillRectangle(&brush, 0, 0, 100, 100);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\functest\cquality.h ===
/******************************Module*Header*******************************\
* Module Name: CQuality.h
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/

#ifndef __CQUALITY_H
#define __CQUALITY_H

#include "CSetting.h"

class CQuality : public CSetting  
{
public:
	CQuality(BOOL bRegression);
	virtual ~CQuality();

	void Set(Graphics *g);
};

class CCompositingMode : public CSetting  
{
public:
	CCompositingMode(BOOL bRegression);
	virtual ~CCompositingMode();

	void Set(Graphics *g);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\functest\cquality.cpp ===
/******************************Module*Header*******************************\
* Module Name: CQuality.cpp
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/
#include "CQuality.h"

CQuality::CQuality(BOOL bRegression)
{
	strcpy(m_szName,"Quality");
	m_bRegression=bRegression;
}

CQuality::~CQuality()
{
}

void CQuality::Set(Graphics *g)
{
	g->SetCompositingQuality(m_bUseSetting ? CompositingQualityHighQuality : CompositingQualityHighSpeed);
}

CCompositingMode::CCompositingMode(BOOL bRegression)
{
	strcpy(m_szName,"Source Copy");
	m_bRegression=bRegression;
}

CCompositingMode::~CCompositingMode()
{
}

void CCompositingMode::Set(Graphics *g)
{
	g->SetCompositingMode(m_bUseSetting ? CompositingModeSourceCopy : CompositingModeSourceOver);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\functest\creadwrite.h ===
/******************************Module*Header*******************************\
* Module Name: CReadWrite.h
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/

#ifndef __CREADWRITE_H
#define __CREADWRITE_H

#include "CPrimitive.h"

class CReadWrite : public CPrimitive  
{
public:
	CReadWrite(BOOL bRegression);
	virtual ~CReadWrite();

	void Draw(Graphics *g);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\functest\creadwrite.cpp ===
/******************************Module*Header*******************************\
* Module Name: CReadWrite.cpp
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/
#include "CReadWrite.h"
#include "CFuncTest.h"

extern CFuncTest g_FuncTest;

CReadWrite::CReadWrite(BOOL bRegression)
{
	strcpy(m_szName,"ReadWrite");
	m_bRegression=bRegression;
}

CReadWrite::~CReadWrite()
{
}

void CReadWrite::Draw(Graphics *g)
{
	Bitmap *paBmTest=new Bitmap((int)TESTAREAWIDTH,(int)TESTAREAHEIGHT,PixelFormat32bppARGB);
	Graphics *gTest;
	HDC hdcBkgBitmap;
	HDC hdcScreen;

	gTest=new Graphics(paBmTest);
	gTest->Clear(Color(255,206,206,206));
	delete gTest;
	g->DrawImage(paBmTest,0,0,0,0,(int)TESTAREAWIDTH,(int)TESTAREAHEIGHT,UnitPixel);

	for (int i=0;i<20;i++) {
		hdcScreen=g->GetHDC();

		gTest=new Graphics(paBmTest);
		hdcBkgBitmap=gTest->GetHDC();
		StretchBlt(hdcBkgBitmap,0,0,(int)TESTAREAWIDTH,(int)TESTAREAHEIGHT,hdcScreen,m_ix,m_iy,(int)TESTAREAWIDTH,(int)TESTAREAHEIGHT,SRCCOPY);
		gTest->ReleaseHDC(hdcBkgBitmap);
		delete gTest;

		g->ReleaseHDC(hdcScreen);

		g->DrawImage(paBmTest,0,0,0,0,(int)TESTAREAWIDTH,(int)TESTAREAHEIGHT,UnitPixel);
	}

	delete paBmTest;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\functest\crecolor.cpp ===
/******************************Module*Header*******************************\
* Module Name: CRecolor.cpp
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  06-06-2000 Adrian Secchia [asecchia]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/
#include "CRecolor.h"

CRecolor::CRecolor(BOOL bRegression)
{
	strcpy(m_szName,"Image : Recolor");
	m_bRegression=bRegression;
}

CRecolor::~CRecolor()
{
}

BOOL CALLBACK CRecolor::MyDrawImageAbort(VOID* data)
{
    UINT *count = (UINT*) data;

    *count += 1;

    return FALSE;
}

void CRecolor::Draw(Graphics *g)
{
    // Load bmp files.

    WCHAR *filename = L"..\\data\\winnt256.bmp";
    Image *image = new Image(filename);
    
    UINT abortCount = 0;

    ImageAttributes imgAttrib;

    Point destTopLeft(2, 2);

    Rect destRect(
        destTopLeft.X,
        destTopLeft.Y,
        (int)(TESTAREAWIDTH/3)-2, 
        (int)(TESTAREAHEIGHT/3)-2
    );

    // Make near-white to white transparent

    Color c1(200, 200, 200);
    Color c2(255, 255, 255);
    imgAttrib.SetColorKey(c1, c2);

    g->DrawImage(image, destRect, 0, 0, 180, 180, UnitPixel, &imgAttrib,
                 MyDrawImageAbort, (VOID*)&abortCount);

    ColorMatrix darkMatrix = {.75, 0, 0, 0, 0,
                              0, .75, 0, 0, 0,
                              0, 0, .75, 0, 0,
                              0, 0, 0, 1, 0,
                              0, 0, 0, 0, 1};

    ColorMatrix greyMatrix = {.25, .25, .25, 0, 0,
                              .25, .25, .25, 0, 0,
                              .25, .25, .25, 0, 0,
                              0, 0, 0, 1, 0,
                              (REAL).1, (REAL).1, (REAL).1, 0, 1};

    ColorMatrix pinkMatrix = {(REAL).33, .25, .25, 0, 0,
                              (REAL).33, .25, .25, 0, 0,
                              (REAL).33, .25, .25, 0, 0,
                              0, 0, 0, 1, 0,
                              0, 0, 0, 0, 1};

    // red->blue, green->red, blue->green, alpha = 0.75
    ColorMatrix swapMatrix = {0, 0, 1, 0, 0,
                              1, 0, 0, 0, 0,
                              0, 1, 0, 0, 0,
                              0, 0, 0, .75, 0,
                              0, 0, 0, 0, 1};

    // red->blue, green->red, blue->green, alpha = 0.9
    ColorMatrix swapMatrix2 = {0, 0, 1, 0, 0,
                               1, 0, 0, 0, 0,
                               0, 1, 0, 0, 0,
                               0, 0, 0, 0, 0,
                               0, 0, 0, (REAL).9, 1};

    imgAttrib.ClearColorKey();
    imgAttrib.SetColorMatrix(&greyMatrix);

    destRect.Y += destRect.Height;

    g->DrawImage(image, destRect, 0, 0, 180, 180, UnitPixel, &imgAttrib,
                 MyDrawImageAbort, (VOID*)&abortCount);

    imgAttrib.SetColorMatrix(&pinkMatrix, ColorMatrixFlagsSkipGrays);

    destRect.Y += destRect.Height;

    g->DrawImage(image, destRect, 0, 0, 180, 180, UnitPixel, &imgAttrib,
                 MyDrawImageAbort, (VOID*)&abortCount);

    imgAttrib.SetColorMatrix(&darkMatrix);

    destRect.X += destRect.Width;
    destRect.Y = destTopLeft.Y;

    g->DrawImage(image, destRect, 0, 0, 180, 180, UnitPixel, &imgAttrib,
                 MyDrawImageAbort, (VOID*)&abortCount);

    destRect.Y += destRect.Height;

    imgAttrib.ClearColorMatrix();
    imgAttrib.SetGamma(3.0);

    g->DrawImage(image, destRect, 0, 0, 180, 180, UnitPixel, &imgAttrib,
                 MyDrawImageAbort, (VOID*)&abortCount);

    destRect.Y += destRect.Height;

    imgAttrib.SetThreshold(0.5);

    g->DrawImage(image, destRect, 0, 0, 180, 180, UnitPixel, &imgAttrib,
                 MyDrawImageAbort, (VOID*)&abortCount);

    imgAttrib.SetColorMatrix(&swapMatrix);
    imgAttrib.ClearGamma();
    imgAttrib.ClearThreshold();

    destRect.X += destRect.Width;
    destRect.Y = destTopLeft.Y;

    g->DrawImage(image, destRect, 0, 0, 180, 180, UnitPixel, &imgAttrib,
                 MyDrawImageAbort, (VOID*)&abortCount);

    destRect.Y += destRect.Height;

    imgAttrib.SetNoOp();
    imgAttrib.SetColorMatrix(&swapMatrix2);

    g->DrawImage(image, destRect, 0, 0, 180, 180, UnitPixel, &imgAttrib,
                 MyDrawImageAbort, (VOID*)&abortCount);
    destRect.Y += destRect.Height;

    imgAttrib.ClearNoOp();

    g->DrawImage(image, destRect, 0, 0, 180, 180, UnitPixel, &imgAttrib,
                 MyDrawImageAbort, (VOID*)&abortCount);

    delete image;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\functest\crecolor.h ===
/******************************Module*Header*******************************\
* Module Name: CRecolor.h
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  06-06-2000 Adrian Secchia [asecchia]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/

#ifndef __CRECOLOR_H
#define __CRECOLOR_H

#include "CPrimitive.h"

class CRecolor : public CPrimitive  
{
public:
	CRecolor(BOOL bRegression);
	virtual ~CRecolor();

	void Draw(Graphics *g);

	static BOOL CALLBACK MyDrawImageAbort(VOID* data);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\functest\csetting.cpp ===
/******************************Module*Header*******************************\
* Module Name: CSetting.cpp
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/
#include "CSetting.h"
#include "CFuncTest.h"

extern CFuncTest g_FuncTest;

CSetting::CSetting()
{
	strcpy(m_szName,"No name assigned");
	m_bUseSetting=false;
	m_bRegression=false;
}

CSetting::~CSetting()
{

}

BOOL CSetting::Init()
{
	g_FuncTest.AddSetting(this);
	return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\functest\cregions.h ===
/******************************Module*Header*******************************\
* Module Name: CRegions.h
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/

#ifndef __CREGIONS_H
#define __CREGIONS_H

#include "CPrimitive.h"

class CRegions : public CPrimitive  
{
public:
	CRegions(BOOL bRegression);
	virtual ~CRegions();

	void Draw(Graphics *g);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\functest\csetting.h ===
/******************************Module*Header*******************************\
* Module Name: CSetting.h
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/

#ifndef __CSETTING_H
#define __CSETTING_H

#include "Global.h"

class CSetting  
{
public:
	CSetting();
	virtual ~CSetting();

	virtual BOOL Init();
	virtual void Set(Graphics *g)=0;

	char m_szName[256];
	BOOL m_bUseSetting;
	BOOL m_bRegression;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\functest\cregression.cpp ===
/******************************Module*Header*******************************\
* Module Name: CRegression.cpp
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/
#include "CRegression.h"

CRegression::CRegression(BOOL bRegression)
{
	strcpy(m_szName,"Regression");
	m_bRegression=bRegression;
}

CRegression::~CRegression()
{
}

void CRegression::Draw(Graphics *g)
{
    REAL width = 4; // Pen width

    Color redColor(255, 0, 0);

    SolidBrush redBrush(redColor);
    g->FillRectangle(&redBrush, (int)(20.0f/150.0f*TESTAREAWIDTH), (int)(20.0f/150.0f*TESTAREAHEIGHT), (int)(50.0f/150.0f*TESTAREAWIDTH), (int)(50.0f/150.0f*TESTAREAHEIGHT));

    Color alphaColor(128, 0, 255, 0);

    SolidBrush alphaBrush(alphaColor);
    g->FillRectangle(&alphaBrush, (int)(10.0f/150.0f*TESTAREAWIDTH), (int)(10.0f/150.0f*TESTAREAHEIGHT), (int)(40.0f/150.0f*TESTAREAWIDTH), (int)(40.0f/150.0f*TESTAREAHEIGHT));

    Point points[4];
    points[0].X = (int)(50.0f/150.0f*TESTAREAWIDTH);
    points[0].Y = (int)(50.0f/150.0f*TESTAREAHEIGHT);
    points[1].X = (int)(100.0f/150.0f*TESTAREAWIDTH);
    points[1].Y = (int)(50.0f/150.0f*TESTAREAHEIGHT);
    points[2].X = (int)(120.0f/150.0f*TESTAREAWIDTH);
    points[2].Y = (int)(120.0f/150.0f*TESTAREAHEIGHT);
    points[3].X = (int)(50.0f/150.0f*TESTAREAWIDTH);
    points[3].Y = (int)(100.0f/150.0f*TESTAREAHEIGHT);

    Color blueColor(128, 0, 0, 255);

    SolidBrush blueBrush(blueColor);
    g->FillPolygon(&blueBrush, points, 4);

    // Currently only Geometric pen works for lines. - ikkof 1/6/99.

    Color blackColor(0, 0, 0);
    SolidBrush blackBrush(blackColor);
    width = 16;
    Pen blackPen(&blackBrush, width);
    blackPen.SetLineJoin(LineJoinRound);
//    blackPen.SetLineJoin(LineJoinBevel);
    g->DrawPolygon(&blackPen, points, 4);
//    g->DrawLines(&blackPen, points, 4, FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\functest\crotate.cpp ===
/******************************Module*Header*******************************\
* Module Name: CRotate.cpp
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/
#include "CRotate.h"
#include "CFuncTest.h"

extern CFuncTest g_FuncTest;

CRotate::CRotate(BOOL bRegression,int nAngle)
{
	sprintf(m_szName,"Rotate %d",nAngle);
	m_bRegression=bRegression;
	m_nAngle=nAngle;
}

CRotate::~CRotate()
{

}

void CRotate::Set(Graphics *g)
{
	if (m_bUseSetting)
	{
		g->TranslateTransform(TESTAREAWIDTH/2.0f,TESTAREAHEIGHT/2.0f);
		g->RotateTransform((float)m_nAngle);
		g->TranslateTransform(-TESTAREAWIDTH/2.0f,-TESTAREAHEIGHT/2.0f);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\functest\cregions.cpp ===
/******************************Module*Header*******************************\
* Module Name: CRegions.cpp
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/
#include "CRegions.h"
#include <math.h>

CRegions::CRegions(BOOL bRegression)
{
	strcpy(m_szName,"Regions");
	m_bRegression=bRegression;
}

CRegions::~CRegions()
{
}

void CRegions::Draw(Graphics *g)
{
    REAL width = 2;     // Pen width
    PointF points[5];
    
    REAL s, c, theta;
    REAL pi = 3.1415926535897932f;
    PointF orig((int)(TESTAREAWIDTH/2.0f), (int)(TESTAREAHEIGHT/2.0f));

    theta = -pi/2;

    // Create a star shape.
    for(INT i = 0; i < 5; i++)
    {
        s = sinf(theta);
        c = cosf(theta);
        points[i].X = (int)(125.0f/250.0f*TESTAREAWIDTH)*c + orig.X;
        points[i].Y = (int)(125.0f/250.0f*TESTAREAHEIGHT)*s + orig.Y;
        theta += 0.8f*pi;
    }

    Color orangeColor(128, 255, 180, 0);

    SolidBrush orangeBrush(orangeColor);
    GraphicsPath* path = new GraphicsPath(FillModeAlternate);
//    Path* path = new GraphicsPath(Winding);
    path->AddPolygon(points, 5);
    
    Color blackColor(0, 0, 0);

    SolidBrush blackBrush(blackColor);
    Pen blackPen(&blackBrush, width);
    Region * region = new Region(path);

    g->FillRegion(&orangeBrush, region);  // There is a BUG!
//    g->FillGraphicsPath(&orangeBrush, path);  // Fill path works fine.
    
    blackPen.SetLineJoin(LineJoinMiter);
    g->DrawPath(&blackPen, path);
    delete path;
    delete region;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\functest\cregression.h ===
/******************************Module*Header*******************************\
* Module Name: CRegression.h
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/

#ifndef __CREGRESSION_H
#define __CREGRESSION_H

#include "CPrimitive.h"

class CRegression : public CPrimitive  
{
public:
	CRegression(BOOL bRegression);
	virtual ~CRegression();

	void Draw(Graphics *g);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\functest\crotate.h ===
/******************************Module*Header*******************************\
* Module Name: CRotate.h
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/

#ifndef __CROTATE_H
#define __CROTATE_H

#include "CSetting.h"

class CRotate : public CSetting  
{
public:
	CRotate(BOOL bRegression,int nAngle);
	virtual ~CRotate();

	void Set(Graphics *g);

	int m_nAngle;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\functest\debug.cpp ===
/**************************************************************************\
*
* Copyright (c) 1998-1999  Microsoft Corporation
*
* Abstract:
*
*   Debugging routines
*
* Revision History:
*
*   09/07/1999 agodfrey
*       Created it.
*
\**************************************************************************/
#include "global.h"

// Optional callback function for reporting a debug event.

enum GpAltDebugEventLevel
{
    GpAltDebugFatal,
    GpAltDebugWarning
};

#define GpAltDebugEventFunction 0
//DEBUGEVENTFUNCTION GpAltDebugEventFunction = NULL;

#if DBG

// GpDebugLevel is used to control the amount/severity of debugging messages
// that are actually output.

int GpDebugLevel = DBG_TERSE;

/**************************************************************************\
*
* Function Description:
*
*   Removes the path portion of a pathname
*
* Arguments:
*
*   [IN] str - pathname to strip
*
* Return Value:
*
*   A pointer to the filename portion of the pathname
*
* History:
*
*   09/07/1999 agodfrey
*       Moved from Entry\Initialize.cpp 
*
\**************************************************************************/

const char*
StripDirPrefix(
    const char* str
    )

{
    const char* p;

    p = strrchr(str, '\\');
    return p ? p+1 : str;
}

const int maxInputStringSize = 1024;

/**************************************************************************\
*
* Function Description:
*
*   Outputs to the debugger
*
* Arguments:
*
*   [IN] format - printf-like format string and variable arguments
*
* Return Value:
*
*   Zero. This is to conform to NTDLL's definition of DbgPrint.
*
* Notes:
*
*   There will be no output if a debugger is not connected.
*
* History:
*
*   09/07/1999 agodfrey
*       Moved from Entry\Initialize.cpp 
*
\**************************************************************************/

ULONG _cdecl
DbgPrint(
    char* format,
    ...
    )

{
    va_list arglist;
    va_start(arglist, format);
    
    char buf[maxInputStringSize];
    
    _vsnprintf(buf, maxInputStringSize, format, arglist);
    buf[maxInputStringSize-1]=0;
        
    OutputDebugStringA(buf);
    
    va_end(arglist);
    return 0;
}

// If we can't allocate memory for the debug string, we'll use this buffer
// in desperation. It's not thread-safe. I *did* say 'desperation'.

static char desperationBuffer[maxInputStringSize];

/**************************************************************************\
*
* Function Description:
*
*   Creates a new string, and sprintf's to it.
*
* Arguments:
*
*   [IN] format - printf-like format string and variable arguments
*
* Return Value:
*
*   The probably-newly-allocated string result.
*
* Notes:
*
*   This function is not intended for general use. It guards against memory
*   failure by using a global buffer. So, while the caller is responsible
*   for freeing the memory, the caller must also check for that buffer.
*   i.e. we only want DbgEmitMessage to call this.
*
*   It's also only mostly thread-safe, because if we run out of memory,
*   we'll use that global buffer in a non-protected way.
*
*   This is the only solution I could find so that I could move most of the
*   implementation details out of the header file. The root cause is that
*   macros don't handle multiple arguments natively, so we have to pass
*   the printf arguments as a single macro argument (in parentheses).
*   Which means, the function that consumes those arguments can have no
*   other arguments.
*
* History:
*
*   02/01/2000 agodfrey
*       Created it. Finally, I've found a way to get debug implementation
*       details out of the headers.
*
\**************************************************************************/

char * _cdecl
GpParseDebugString(
    char* format,
    ...
    )
{
    va_list arglist;
    va_start(arglist, format);
    
    // Don't use GpMalloc here so that we can use ASSERT and WARNING in 
    // our memory allocation routines.

    char *newBuf = static_cast<char *>(LocalAlloc(LMEM_FIXED, maxInputStringSize));
    if (!newBuf)
    {
        newBuf = desperationBuffer;
    }
    
    _vsnprintf(newBuf, maxInputStringSize, format, arglist);
    
    // Nuke the last byte, because MSDN isn't clear on what _vsnprintf does
    // in that case.
    
    newBuf[maxInputStringSize-1]=0;
        
    va_end(arglist);
    return newBuf;
}

/**************************************************************************\
*
* Function Description:
*
*   Processes a debug event. Frees the message string.
*
* Arguments:
*
* level   - The debug level of the event 
* file    - Should be __FILE__
* line    - Should be __LINE__
* message - The debug message.
*
* Notes:
*
*   You don't want to call this directly. That would be error-prone. 
*   Use ASSERT, WARNING, etc.
*
*   In Office, it will raise an 'assert' dialog if necessary.
*
*   Depending on the debug level, an identifying prefix will be output.
*
*   If the debug level is DBG_RIP, will suspend execution (e.g. by
*   hitting a breakpoint.)
*
* Note on Office interop:
*
*   Under Office, we'll pass WARNINGs and ASSERTs to a reporting function
*   they provide. Their function will breakpoint on ASSERTs.
*   Lesser events will just be sent to the debugger.
*
* History:
*
*   02/01/2000 agodfrey
*       Created it.
*
\**************************************************************************/

void _cdecl 
GpLogDebugEvent(
    int level, 
    char *file, 
    unsigned int line,
    char *message
    )
{
    // We may want to add things to the passed-in message. So we need
    // a temporary buffer
    
    const int maxOutputStringSize = maxInputStringSize + 100;
    char tempBuffer[maxOutputStringSize+1];
    
    // MSDN's _vsnprintf doc isn't clear on this, so just in case:
    tempBuffer[maxOutputStringSize] = 0;
    int altDebugLevel = -1;
    
    char *prefix = "";
    
    if (GpDebugLevel <= (level))
    {
        switch (level)
        {
        case DBG_WARNING:
            prefix = "WRN ";
            if (GpAltDebugEventFunction)
            {
                altDebugLevel = GpAltDebugWarning;
            }    
            break;
            
        case DBG_RIP:
            prefix = "RIP ";
            if (GpAltDebugEventFunction)
            {
                altDebugLevel = GpAltDebugFatal;
            }    
            break;
        }
        
        // The convention is that we append the trailing \n, not the caller.
        // Two reasons:
        // 1) Callers tend to forget it.
        // 2) More importantly, it encourages the caller to think of each
        //    call as a separate event. This is important in some cases - e.g.
        //    when Office produces a popup for each event.

        _snprintf(
            tempBuffer, 
            maxOutputStringSize, 
            "%s%s(%d): %s\n",
            prefix,
            StripDirPrefix(file),
            line,
            message
            );
        
        if (altDebugLevel >= 0)
        {
            //GpAltDebugEventFunction(altDebugLevel, tempBuffer);
        }
        else
        {
            OutputDebugStringA(tempBuffer);
        }
    }
    
    // Free the message buffer
    
    if (message != desperationBuffer)
    {
        LocalFree(message);
    }
    
    // Force a breakpoint, if it's warranted.
    
    if ((GpDebugLevel <= DBG_RIP) && (level == DBG_RIP) && (altDebugLevel < 0))
    {
        DebugBreak();
    }
}
    
#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\functest\debug.h ===
/**************************************************************************\
*
* Copyright (c) 1998-2000  Microsoft Corporation
*
* Module Name:
*
*   Debugging macros
*
* Abstract:
*
*   Macros used for debugging purposes
*
* Revision History:
*
*   12/02/1998 davidx
*       Created it.
*   09/07/1999 agodfrey
*       Moved from Engine\Common
*   02/07/2000 agodfrey
*       Made more of it private (for bug #35561).
*       Changed the output function to add "\n" automatically.
*
\**************************************************************************/

#ifndef _DEBUG_H
#define _DEBUG_H

#ifdef __cplusplus
extern "C" {
#endif

// ONCE(code block)
//  Use this to make a code block execute only once per run.
//  Useful for cutting down on spew.
//  e.g.:
//      ONCE(WARNING(("Invalid arguments")));

#define ONCE(codeblock)      \
    {                        \
        static int doneOnce; \
        if (!doneOnce)       \
        {                    \
            { codeblock ; }  \
            doneOnce=1;      \
        }                    \
    }

#if DBG

// Global debug level

#define DBG_VERBOSE 1
#define DBG_TERSE   2
#define DBG_WARNING 3
#define DBG_RIP     4

extern int GpDebugLevel;

///////////////////////////// DEPRECATED STUFF ///////////////////////////////

// Raw output function. Emits debug messages. Its direct use is depracated.
// It's useful for private debugging, though.

unsigned long _cdecl DbgPrint(char*, ...);

// Strip the directory prefix from a filename

const char*
StripDirPrefix(
    const char* filename
    );

// Use of DBGMSG is depracated - it's supplied only because driverd3d.cpp uses
// it.

#define DBGMSG(level, prefix, msg)       \
        {                                \
            if (GpDebugLevel <= (level)) \
            {                            \
                DbgPrint("%s %s (%d): ", prefix, StripDirPrefix(__FILE__), __LINE__); \
                DbgPrint msg;            \
            }                            \
        }

///////////////////////////// PRIVATE STUFF //////////////////////////////////

// Just leave this function alone. You don't want to call it yourself. Trust me.
char * _cdecl GpParseDebugString(char* format, ...);

// Ditto for this one.
void _cdecl GpLogDebugEvent(int level, char *file, unsigned int line, char *message);

#define LOG_DEBUG_EVENT(level, msg)                                  \
    {                                                                \
        if (GpDebugLevel <= (level))                                 \
        {                                                            \
            char *debugOutput = GpParseDebugString msg;              \
            GpLogDebugEvent(level, __FILE__, __LINE__, debugOutput); \
        }                                                            \
    }

//////////////////////////////// THE GOOD STUFF //////////////////////////////

// These macros are used for debugging. They expand to
// whitespace on a free build.
//
// GpDebugLevel
//  Global variable which holds the current debug level. You can use it to
//  control the quantity of debug messages emitted.
//
// VERBOSE(msg)
//  Display a message if the current debug level is <= DBG_VERBOSE.
//
// TERSE(msg)
//  Display a message if the current debug level is <= DBG_TERSE.
//
// WARNING(msg)
//  Display a message if the current debug level is <= DBG_WARNING.
//  The message format is: WRN filename (linenumber): message
//
// ASSERT(cond)
//  Verify that a condition is true. If not, force a breakpoint.
//
// ASSERTMSG(cond, msg)
//  Verify that a condition is true. If not, display a message and
//  force a breakpoint.
//
// RIP(msg)
//  Display a message and force a breakpoint.
//
// Usage:
//
//  These macros require extra parentheses for the msg argument
//  for example:
//      WARNING(("App passed NULL pointer; ignoring it."));
//      ASSERTMSG(x > 0, ("x is less than 0"));
//
//  Each call to an output function is treated as a separate event -
//  if you want to build up a message, e.g. in a loop, build it up in a
//  string, and then call the output function.
//
//  This is because we don't always just output the string to the debugger -
//  when we link statically, we may send the output to a user-defined handler.
//
//  Don't put a trailing \n on the message. If the output is sent to the
//  debugger, the output function will add the \n itself.

#define VERBOSE(msg) LOG_DEBUG_EVENT(DBG_VERBOSE, msg)
#define TERSE(msg) LOG_DEBUG_EVENT(DBG_TERSE, msg)
#define WARNING(msg) LOG_DEBUG_EVENT(DBG_WARNING, msg)
#define RIP(msg) LOG_DEBUG_EVENT(DBG_RIP, msg)

#define ASSERT(cond)   \
    {                  \
        if (! (cond))  \
        {              \
            RIP(("Assertion failure: %s", #cond)); \
        }              \
    }

#define ASSERTMSG(cond, msg) \
    {                        \
        if (! (cond))        \
        {                    \
            RIP(msg);        \
        }                    \
    }

#else // !DBG

//--------------------------------------------------------------------------
// Retail build
//--------------------------------------------------------------------------

#define DBGMSG(level, prefix, msg) {}
#define VERBOSE(msg) {}
#define TERSE(msg) {}
#define WARNING(msg) {}

#define RIP(msg) {}
#define ASSERT(cond) {}
#define ASSERTMSG(cond, msg) {}

#endif // !DBG

#ifdef __cplusplus
}
#endif

#endif // !_DEBUG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\functest\global.h ===
/******************************Module*Header*******************************\
* Module Name: Global.h
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/

#ifndef __GLOBAL_H
#define __GLOBAL_H

#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <windows.h>
#include <objbase.h>
#include <math.h>
#include <winspool.h>
#include <commdlg.h>
#include <wingdi.h>
#include <ddraw.h>

#include "debug.h"

#define IStream int
#include <gdiplus.h>
using namespace Gdiplus;

#define TESTAREAWIDTH  256.0f
#define TESTAREAHEIGHT 256.0f

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\functest\csourcecopy.cpp ===
/******************************Module*Header*******************************\
* Module Name: CSourceCopy.cpp
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/
#include "CSourceCopy.h"

CSourceCopy::CSourceCopy(BOOL bRegression)
{
	strcpy(m_szName,"SourceCopy");
	m_bRegression=bRegression;
}

CSourceCopy::~CSourceCopy()
{
}

void CSourceCopy::Draw(Graphics *g)
{
    // This test demonstrates SetCompositingMode by drawing two overlapping
    // rectangles, using SourceCopy, into a temporary bitmap, then drawing
    // the bitmap (using SourceOver), onto the screen over a background.

    // Make a temporary surface
    Bitmap bmTemp((int)(300.0f/150.0f*TESTAREAWIDTH), (int)(300.0f/150.0f*TESTAREAHEIGHT), PixelFormat32bppPARGB);
    Graphics gTemp(&bmTemp);
    Graphics *gt=&gTemp;
    
    // First, draw a blue checkerboard pattern on the output Graphics
    SolidBrush blueBrush(Color::Blue);
    int i,j;
    for (i=0;i<3;i++)
	{
        for (j=0;j<3;j++)
        {
            if ((i+j) & 1)
            {
                g->FillRectangle(
                    &blueBrush, 
                    (int)((100.0f+i*30.0f)/200.0f*TESTAREAWIDTH), 
                    (int)((100.0f+j*30.0f)/200.0f*TESTAREAHEIGHT), 
                    (int)(30.0f/200.0f*TESTAREAHEIGHT),
                    (int)(30.0f/200.0f*TESTAREAHEIGHT));
            }        
        }
	}

    gt->SetCompositingMode(CompositingModeSourceCopy);
    gt->SetSmoothingMode(g->GetSmoothingMode());

    // Clear the bitmap to the transparent color
    gt->Clear(Color(0,0,0,0));

    // Draw two overlapping rectangles to the temporary surface
    SolidBrush halfRedBrush(Color(128, 255, 0, 0));
    gt->FillRectangle(&halfRedBrush, (int)(28.0f/150.0f*TESTAREAWIDTH), (int)(84.0f/150.0f*TESTAREAHEIGHT), (int)(90.0f/150.0f*TESTAREAWIDTH), (int)(50.0f/150.0f*TESTAREAHEIGHT));

    SolidBrush halfGreenBrush(Color(128, 0, 255, 0));
    gt->FillRectangle(&halfGreenBrush, (int)(40.0f/150.0f*TESTAREAWIDTH), (int)(40.0f/150.0f*TESTAREAHEIGHT), (int)(100.0f/150.0f*TESTAREAWIDTH), (int)(60.0f/150.0f*TESTAREAHEIGHT));
    
    // SourceOver the result to the output Graphics
    g->DrawImage(&bmTemp, 0, 0, 0, 0, (int)TESTAREAWIDTH, (int)TESTAREAHEIGHT, UnitPixel);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\functest\csystemcolor.cpp ===
/******************************Module*Header*******************************\
* Module Name: CSystemColor.cpp
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* SystemColor test. This test isn't much use as a part of the regression suite.
* It's intended to test drawing using the 4 "magic" system colors in 8bpp.
* Solid fills using these colors should look solid, not be dithered to some
* nearby colors.
*
* I made this to repro #308874 (system colors being dithered when rendering to
* an 8bpp DIBSection - note, NOT the Terminal Server issue).
* To repro, be in 8bpp mode, select "Output: DIB 8 bits", this Primitive, and
* "Settings: Halftone".
*
* Created:  03-14-2001 agodfrey
*
* Copyright (c) 2001 Microsoft Corporation
*
\**************************************************************************/
#include "CSystemColor.h"

CSystemColor::CSystemColor(BOOL bRegression)
{
    strcpy(m_szName,"SystemColors");
    m_bRegression=bRegression;
}

CSystemColor::~CSystemColor()
{
}

static int sysColorNum[4] = {
    COLOR_3DSHADOW,
    COLOR_3DFACE,
    COLOR_3DHIGHLIGHT,
    COLOR_DESKTOP
};

void CSystemColor::Draw(Graphics *g)
{
    int i;
    
    for (i=0; i<4; i++) {
        int x = (i % 2) * (int) (TESTAREAWIDTH/2);
        int y = (i / 2) * (int) (TESTAREAHEIGHT/2);
        
        DWORD sysColor = ::GetSysColor(sysColorNum[i]);
        
        Color color;
        color.SetFromCOLORREF(sysColor);
        
        SolidBrush solidBrush1(color);
        
        // GetNearestColor shouldn't modify the color at all
        g->GetNearestColor(&color);
        SolidBrush solidBrush2(color);

        Rect rect1(
            x, 
            y, 
            (int) (TESTAREAWIDTH/2),
            (int) (TESTAREAHEIGHT/4)
        );
        Rect rect2(
            x, 
            y + (int) (TESTAREAHEIGHT/4), 
            (int) (TESTAREAWIDTH/2),
            (int) (TESTAREAHEIGHT/4)
        );
        g->FillRectangle(&solidBrush1, rect1);
        g->FillRectangle(&solidBrush2, rect2);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\functest\guid.c ===
/**************************************************************************\
* 
* Copyright (c) 1999  Microsoft Corporation
*
* Abstract:
*
*   GUID definition file
*
*   GUIDs that are needed by functest are defined here.
*
* Revision History:
*
*   10/22/1999 bhouse
*       Created it.
*
\**************************************************************************/

// NOTE: Since we use C++ precompiled headers this C file will not use
//       the precompiled header allowing us to define INITGUID and include
//       directdraw and d3d headers to generate the GUIDs defined by these
//       headers.

#define INITGUID
#include <ddraw.h>
#include <d3d.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\functest\csourcecopy.h ===
/******************************Module*Header*******************************\
* Module Name: CSourceCopy.h
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/

#ifndef __CSOURCECOPY_H
#define __CSOURCECOPY_H

#include "CPrimitive.h"

class CSourceCopy : public CPrimitive  
{
public:
	CSourceCopy(BOOL bRegression);
	virtual ~CSourceCopy();

	void Draw(Graphics *g);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\functest\csystemcolor.h ===
/******************************Module*Header*******************************\
* Module Name: CSystemColor.h
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  03-14-2001 agodfrey
*
* Copyright (c) 2001 Microsoft Corporation
*
\**************************************************************************/

#ifndef __CSYSTEMCOLOR_H
#define __CSYSTEMCOLOR_H

#include "CPrimitive.h"

class CSystemColor : public CPrimitive  
{
public:
    CSystemColor(BOOL bRegression);
    virtual ~CSystemColor();

    void Draw(Graphics *g);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\functest\ctext.h ===
/******************************Module*Header*******************************\
* Module Name: CText.h
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/

#ifndef __CTEXT_H
#define __CTEXT_H

#include "CPrimitive.h"

class CText : public CPrimitive  
{
public:
	CText(BOOL bRegression);
	virtual ~CText();

	void Draw(Graphics *g);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\functest\ctext.cpp ===
/******************************Module*Header*******************************\
* Module Name: CText.cpp
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/
#include "CText.h"

CText::CText(BOOL bRegression)
{
	strcpy(m_szName,"Text");
	m_bRegression=bRegression;
}

CText::~CText()
{
}

void CText::Draw(Graphics *g)
{
    //Font font(L"Arial", 60);

    FontFamily  ff(L"Arial");
    RectF	  rectf(20.0f/500.0f*TESTAREAWIDTH, 0.0f/500.0f*TESTAREAHEIGHT, 500.0f/500.0f*TESTAREAWIDTH, 300.0f/500.0f*TESTAREAHEIGHT);
    GraphicsPath  path;

    // Solid color text.
    Color color(128, 100, 0, 200);
    SolidBrush brush(color);
    path.AddString(L"Color", 5, &ff, 0, 100.0f/500.0f*TESTAREAWIDTH,  rectf, NULL);
    g->FillPath(&brush, &path);

    // Texture text.
    WCHAR filename[256];
    wcscpy(filename, L"../data/marble1.jpg");
    Bitmap *bitmap = new Bitmap(filename);                          
    TextureBrush textureBrush(bitmap, WrapModeTile);
    path.Reset();
    rectf.Y = 100.0f/500.0f*TESTAREAWIDTH;
    path.AddString(L"Texture", 7, &ff, 0, 100.0f/500.0f*TESTAREAWIDTH, rectf, NULL);
    g->FillPath(&textureBrush, &path);
    delete bitmap;

    // Gradient text.
    rectf.Y = 200.0f/500.0f*TESTAREAWIDTH;
    path.Reset();
    path.AddString(L"Gradient", 8, &ff, 0, 100.0f/500.0f*TESTAREAWIDTH, rectf, NULL);
    Color color1(255, 255, 0, 0);
    Color color2(255, 0, 255, 0);
    LinearGradientBrush lineGrad(rectf, color1, color2, 0.0f);
    g->FillPath(&lineGrad, &path);

    // Shadow test
    REAL charHeight = 100.0f/500.0f*TESTAREAWIDTH;
	REAL topMargin = - 5;
    rectf.Y = - charHeight - topMargin; // Make y-coord of the base line
										// of the characters to be 0.

    path.Reset();
    path.AddString(L"Shadow", 6, &ff, 0, charHeight, rectf, NULL);
    GraphicsPath* clonePath = path.Clone();

    Color redColor(255, 0, 0);
    Color grayColor(128, 0, 0, 0);
    SolidBrush redBrush(redColor);
    SolidBrush grayBrush(grayColor);

    // Shadow part.
	REAL tx = 0.0f/500.0f*TESTAREAWIDTH, ty = 400.0f/500.0f*TESTAREAHEIGHT;
    Matrix skew;
    skew.Scale(1.0, 0.5);
    skew.Shear(-2.0, 0, MatrixOrderAppend);
    skew.Translate(tx, ty, MatrixOrderAppend);
    clonePath->Transform(&skew);
    g->FillPath(&grayBrush, clonePath);
    delete clonePath;

    // Front part.
	Matrix trans1;
    trans1.Translate(tx, ty);
    path.Transform(&trans1);
    g->FillPath(&redBrush, &path);


    return;
/*
    REAL x = 200, y = 150;

    RectF brushRect(x, y, 150, 32);
    Color colors[4] = {
       Color(180, 255, 0, 0),
       Color(180, 0, 255, 0),
       Color(180, 255, 0, 0),
       Color(180, 0, 255, 0)
    };
//    RectangleGradientBrush rectGrad(brushRect, (Color*)&colors, WrapModeTile);

//    g->DrawString(L"GDI+", &font, &rectGrad, x, y);


    // And now with DrawText

    RectF rect(400, 200, 400, 400);

    g->DrawText(
        DrawTextDisplay,
        L"A few words powered by GDI+: \
\x3c3\x3bb\x3b1\x3b4 \
\x627\x644\x633\x644\x627\x645 \
\x5e9\x5dc\x5d5\x5dd \
\xe2d\xe4d\xe01\xe29\xe23\xe44\xe17\xe22 \
\x110\x068\x0ea\x300\x103",
       &font,           // Initial font
       &rectGrad,       // Initial brush (ignored for the time being)
        LANG_NEUTRAL,   // Initial language
       &rect            // Formatting rectangle
    );
*/
}


/*
int CALLBACK TestSpecificFont(CONST LOGFONT *lplf,CONST TEXTMETRIC *lptm,DWORD dwType,LPARAM lpData)
{
    static REAL x = 50, y = 50;

    HFONT hf = CreateFontIndirect(lplf);
 
    Graphics *g = (Graphics*) lpData;

    Color red(0x80FF0000); 
    Brush *brush = new SolidBrush(red);

//    g->DrawString(L"This is a test.", (VOID*)hf, brush, x, y);

    delete brush;

    x = x + lplf->lfWidth * 2;
    y = y + lplf->lfHeight + 5;

    DeleteObject(hf);

    return 1;
}

VOID TestText(Graphics *g, HWND hwnd)
{
    HDC hdc = GetDC(hwnd);

    // enumerate the fonts in the system
    EnumFonts(hdc, NULL, &TestSpecificFont, (LPARAM)g); 

    ReleaseDC(hwnd, hdc); 
}

void CText::Draw(Graphics *g)
{
    Point points[4];
    REAL width = 4;     // Pen width
    WCHAR filename[]=L"../data/4x5_trans_Q60_cropped_1k.jpg";

    // Open the image with the appropriate ICM mode.
    Bitmap *bitmap = new Bitmap(filename, TRUE);

    // Create a texture brush.

    Unit u;
    RectF copyRect;
    bitmap->GetBounds(&copyRect, &u);
    
    copyRect.X = copyRect.Width/2-1;
    copyRect.Width = copyRect.Width/4-1;
    copyRect.X += copyRect.Width;
    copyRect.Height = copyRect.Height/2-1;
  
    // Our ICM profile is hacked to flip the red and blue color channels
    // Apply a recolor matrix to flip them back so that if something breaks
    // ICM, the picture will look blue instead of the familiar colors.
    ImageAttributes *img = new ImageAttributes();
    img->SetWrapMode(WrapModeTile, Color(0xffff0000), FALSE);
    ColorMatrix flipRedBlue = 
       {0, 0, 1, 0, 0,
        0, 1, 0, 0, 0,
        1, 0, 0, 0, 0,
        0, 0, 0, 1, 0,
        0, 0, 0, 0, 1};
    img->SetColorMatrix(&flipRedBlue);
    img->SetICMMode(TRUE);
    img->SetWrapMode(WrapModeTile, Color(0xffff0000), FALSE);

    // Create a texture brush.                      
    TextureBrush textureBrush(bitmap, copyRect, img);

    // Create a radial gradient pen.

    Color redColor(255, 0, 0);

    SolidBrush redBrush(redColor);
    Pen redPen(&redBrush, width);

    GraphicsPath *path;

    points[0].X = 100*3+300;
    points[0].Y = 60*3-100;
    points[1].X = -50*3+300;
    points[1].Y = 60*3-100;
    points[2].X = 150*3+300;
    points[2].Y = 250*3-100;
    points[3].X = 200*3+300;
    points[3].Y = 120*3-100;
    path = new GraphicsPath(FillModeAlternate);
    path->AddBeziers(points, 4);    
    g->FillPath(&textureBrush, path);
    g->DrawPath(&redPen, path);

    delete img;
    delete path;
    delete bitmap;

    PointF destPoints[3];

    destPoints[0].X = 300;
    destPoints[0].Y = 50;
    destPoints[1].X = 450;
    destPoints[1].Y = 50;
    destPoints[2].X = 240;
    destPoints[2].Y = 200;
 
    Matrix mat;
    mat.Translate(0, 100);
    mat.TransformPoints(&destPoints[0], 3);
    wcscpy(filename, L"../data/apple1.png");
    bitmap = new Bitmap(filename);
    g->DrawImage(bitmap, &destPoints[0], 3);
 
    delete bitmap;

    destPoints[0].X = 30;
    destPoints[0].Y = 200;
    destPoints[1].X = 200;
    destPoints[1].Y = 200;
    destPoints[2].X = 200;
    destPoints[2].Y = 420;

    wcscpy(filename, L"../data/dog2.png");
    bitmap = new Bitmap(filename);
    g->DrawImage(bitmap, &destPoints[0], 3);
 
    delete bitmap;

    Color color(100, 128, 255, 0);

    SolidBrush brush(color);

    Point pts[10];
    INT count = 4;

    pts[0].X = 150;
    pts[0].Y = 60;
    pts[1].X = 100;
    pts[1].Y = 230;
    pts[2].X = 250;
    pts[2].Y = 260;
    pts[3].X = 350;
    pts[3].Y = 100;

    g->FillClosedCurve(&brush, pts, count);

    wcscpy(filename, L"../data/ballmer.jpg");
    bitmap = new Bitmap(filename);
    RectF destRect(220, 50, 180, 120);
    RectF srcRect;
    srcRect.X = 100;
    srcRect.Y = 40;
    srcRect.Width = 200;
    srcRect.Height = 200;
    g->DrawImage(bitmap, destRect, srcRect.X, srcRect.Y,
        srcRect.Width, srcRect.Height, UnitPixel);
    delete bitmap;
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\functest\printtest\cbackprinting.h ===
/******************************Module*Header*******************************\
* Module Name: CBackPrinting.h
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/

#ifndef __CBACKPRINTING_H
#define __CBACKPRINTING_H

#include "..\CPrimitive.h"

class CBackPrinting : public CPrimitive  
{
public:
	CBackPrinting(BOOL bRegression);
	virtual ~CBackPrinting();

	void Draw(Graphics *g);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\functest\printtest\cprintbitmap.h ===
/******************************Module*Header*******************************\
* Module Name: CBitmaps.h
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/

#ifndef __CPRINTBITMAPS_H
#define __CPRINTBITMAPS_H

#include "..\CPrimitive.h"

class CPrintBitmap : public CPrimitive  
{
public:
	CPrintBitmap(BOOL bRegression);
	virtual ~CPrintBitmap();

	void Draw(Graphics *g);
        void Draw2(Graphics *g);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\functest\printtest\cbackprinting.cpp ===
/******************************Module*Header*******************************\
* Module Name: CBackPrinting.cpp
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/
#include "CBackPrinting.h"

CBackPrinting::CBackPrinting(BOOL bRegression)
{
        strcpy(m_szName,"Background Printing");
	m_bRegression=bRegression;
}

CBackPrinting::~CBackPrinting()
{
}

void CBackPrinting::Draw(Graphics *g)
{
    Bitmap *bitmap = new Bitmap(L"..\\data\\winnt256.bmp");

    // Test g->DrawImage
    if (bitmap && bitmap->GetLastStatus() == Ok) 
    {
        ImageAttributes imageAttributes;
#if 0
        if (CacheBack) 
           imageAttributes.SetCachedBackgroundImage();
        else
           imageAttributes.ClearCachedBackgroundImage();
#endif
        RectF rect(0.0f,0.0f,TESTAREAWIDTH,TESTAREAHEIGHT);

        // Page #1 should use VDP
        g->DrawImage(bitmap, 
                     rect, rect.X, rect.Y, rect.Width, rect.Height, 
                     UnitPixel,
                     &imageAttributes, NULL, NULL);

        HDC hdc = g->GetHDC();
        EndPage(hdc);
        g->ReleaseHDC(hdc);

        // Page #2 should use VDP form
        g->DrawImage(bitmap, 
                     rect, rect.X, rect.Y, rect.Width, rect.Height, 
                     UnitPixel,
                     &imageAttributes, NULL, NULL);

        delete bitmap;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\functest\printtest\cprinting.h ===
/******************************Module*Header*******************************\
* Module Name: CPrinting.h
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/

#ifndef __CPRINTING_H
#define __CPRINTING_H

#include "..\CPrimitive.h"

class CPrinting : public CPrimitive  
{
public:
	CPrinting(BOOL bRegression);
	virtual ~CPrinting();

	void Draw(Graphics *g);

	VOID TestPerfPrinting(Graphics *g);
	VOID TestTextPrinting(Graphics *g);
        
        VOID TestNolan1(Graphics *g);
        VOID TestNolan2(Graphics *g);

        VOID TestBug104604(Graphics *g);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\functest\printtest\cprintbitmap.cpp ===
/******************************Module*Header*******************************\
* Module Name: CPrintBitmap.cpp
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/
#include "CPrintBitmap.h"
#include <gdiplus.h>
CPrintBitmap::CPrintBitmap(BOOL bRegression)
{
        strcpy(m_szName,"Bitmaps");
        m_bRegression=bRegression;
}

CPrintBitmap::~CPrintBitmap()
{
}

void CPrintBitmap::Draw(Graphics *g)
{
Bitmap bm4bpp(L"4bpp.bmp");
Bitmap bmpng(L"upsidedown.png");
Bitmap bmpgif(L"upsidedown.bmp");

Rect rect1(0,0,100,100);
Rect rect2(100,50,100,100);
Rect rect3(250,50,100,100);

g->DrawImage(&bm4bpp, rect1);
g->DrawImage(&bmpng, rect2);
g->DrawImage(&bmpgif, rect3);

#if 0
    //Draw2(g);

    Bitmap arrowBmp(L"DataGridRow.star.bmp");
    Size size;
    size.Width = arrowBmp.GetWidth();
    size.Height = arrowBmp.GetHeight();
    Rect rect(40, 40, size.Width, size.Height);
#if 1
    ColorMap colorMap;
    colorMap.oldColor = Color(0xFF,0,0,0);
    colorMap.newColor = Color(0xFF,0,0xFF,0);
    ImageAttributes imgattr;
    imgattr.SetRemapTable(1, &colorMap, ColorAdjustTypeBitmap);
    g->DrawImage(&arrowBmp, 
                 rect, 
                 0, 0, rect.Width, rect.Height, 
                 UnitPixel,
                 &imgattr);
#endif 
    g->DrawImage(&arrowBmp, rect);
#endif
}

void CPrintBitmap::Draw2(Graphics *g)
{
#if 0
    WCHAR filename[256];
    wcscpy(filename, L"035.tif");

    // Open the image with the appropriate ICM mode.
    Bitmap *bitmap = new Bitmap(filename, TRUE);

    Region region;

    region.MakeInfinite();

    REAL sizeF = 500.0f;
    INT size = 500;

    Matrix m;
    m.RotateAt(180.0f, PointF(sizeF/2.0f, sizeF/2.0f));
    
    g->SetTransform(&m);
    g->SetClip(&region);
    g->SetPageUnit(UnitWorld);

    BitmapData bitmapData;
/*
    SizeF szF;
    bitmap->GetPhysicalDimension(&szF);
    Size sz;
    sz.Width = (INT)szF.Width;
    sz.Height = (INT)szF.Height;
*/

    Size sz;
    sz.Width = bitmap->GetWidth();
    sz.Height = bitmap->GetHeight();

    Rect rect(0, 0, sz.Width, sz.Height);

    bitmap->LockBits(rect, ImageLockModeRead, PixelFormat32bppARGB, &bitmapData);

    HDC hdc = g->GetHDC();

    struct {
        BITMAPINFO bi;
        RGBQUAD rgbQuad[2];
    } b;

    memset(&b, 0, sizeof(BITMAPINFO));
        
    sz.Width = bitmapData.Width;
    sz.Height = bitmapData.Height;

    b.bi.bmiHeader.biSize = sizeof(BITMAPINFO);
    b.bi.bmiHeader.biWidth = sz.Width;
    b.bi.bmiHeader.biHeight = sz.Height/2;
    b.bi.bmiHeader.biPlanes = 1;
    b.bi.bmiHeader.biBitCount = 32;        // try 24 also
    b.bi.bmiHeader.biCompression = BI_RGB;
    b.bi.bmiHeader.biSizeImage = 0;
    b.bi.bmiHeader.biClrUsed = 0;

    b.bi.bmiColors[0].rgbBlue = 0;
    b.bi.bmiColors[0].rgbGreen = 0;
    b.bi.bmiColors[0].rgbRed = 0xFF;
    b.bi.bmiColors[0].rgbReserved = 0;

    b.bi.bmiColors[1].rgbBlue = 0;
    b.bi.bmiColors[1].rgbGreen = 0xFF;
    b.bi.bmiColors[1].rgbRed = 0;
    b.bi.bmiColors[1].rgbReserved = 0;

    b.bi.bmiColors[2].rgbBlue = 0xFF;
    b.bi.bmiColors[2].rgbGreen = 0;
    b.bi.bmiColors[2].rgbRed = 0;
    b.bi.bmiColors[2].rgbReserved = 0;

    BYTE* ptr = (BYTE*)bitmapData.Scan0 + (sizeof(ARGB)*sz.Width)*(sz.Height-1);
#if 0
    int factor = 3;

    int result1 = 
    StretchDIBits(hdc,
                  0, 
                  0,
                  factor*sz.Width,
                  factor*sz.Height/2,
                  0,
                  0,
                  sz.Width,
                  sz.Height/2,
                  (BYTE*)bitmapData.Scan0,
                  (BITMAPINFO*)&b.bi,
                  DIB_RGB_COLORS,
                  SRCCOPY);
    
    int result2 = 
    StretchDIBits(hdc,
              0, 
              factor*sz.Height/2,
              factor*sz.Width,
              factor*sz.Height/2,
              0,
              0,
              sz.Width,
              sz.Height/2,
              ((BYTE*)bitmapData.Scan0) - (bitmapData.Stride*(sz.Height/2)),
              (BITMAPINFO*)&b.bi,
              DIB_RGB_COLORS,
              SRCCOPY);
    
    int error = GetLastError();
#endif

    g->ReleaseHDC(hdc);
    bitmap->UnlockBits(&bitmapData);

    g->DrawImage(bitmap, Rect(0, 0, size, size));
    delete bitmap;
    
#endif

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\functest\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Functest.rc
//
#define IDR_MENU1                       101
#define IDD_FUNCTEST                    102
#define ID_APP                          103
#define IDC_COMBINATION                 1000
#define IDC_REGRESSION                  1001
#define IDC_RUN                         1002
#define IDC_PRIMITIVES                  1003
#define IDC_OUTPUTS                     1004
#define IDC_SETTINGS                    1005
#define IDC_PAGEPAUSE                   1008
#define IDC_PAGEDELAY                   1009
#define IDC_DELAY                       1010
#define IDC_ERASEBKGD                   1011
#define IDC_APPENDTEST                  1012
#define IDM_ALL                         40000
#define IDM_POLYGONS                    40001
#define IDM_PATHS                       40002
#define IDM_REGIONS                     40003
#define IDM_GRADIENTS                   40004
#define IDM_BITMAPS                     40005
#define IDM_IMAGING                     40006
#define IDM_PRIMITIVES                  40007
#define IDM_MIXED                       40008
#define IDM_TEXT                        40009
#define IDM_CONTAINERS                  40010
#define IDM_CONTAINERCLIP               40011
#define IDM_HATCH                       40012
#define IDM_DASHES                      40013
#define IDM_SOURCECOPY                  40014
#define IDM_COMPOUNDLINES               40015
#define IDM_PRINTING                    40016
#define IDM_BACKPRINTING                40017
#define IDM_INSETLINES                  40018
#define IDM_HWND                        40100
#define IDM_DIB                         40101
#define IDM_PRINTER                     40102
#define IDM_D3D                         40103
#define IDM_DIB_FILE                    40104
#define IDM_1BPP                        40200
#define IDM_2BPP                        40201
#define IDM_4BPP                        40202
#define IDM_8BPP                        40203
#define IDM_16BPP                       40204
#define IDM_24BPP                       40205
#define IDM_32BPP                       40206
#define IDM_TEST1                       40300
#define IDM_TEST10                      40301
#define IDM_TEST100                     40302
#define IDM_TEST1000                    40303
#define IDM_TESTREGRESS                 40304
#define IDM_HALFTONE                    40305
#define IDM_ANTIALIAS                   40306
#define IDM_TESTHDC                     40307
#define IDM_NEWPRINT                    40308
#define IDM_CACHEBACK                   40309
#define IDM_HIGHCOMPOSITINGQUALITY      40310
#define IDM_QUIT                        40500
#define IDM_ROT0                        40600
#define IDM_ROT10                       40601
#define IDM_ROT30                       40602
#define IDM_ROT45                       40603
#define IDM_ROT60                       40604
#define IDM_ROT90                       40605
#define IDM_RUN                         41000
#define IDM_COMBINATION                 41001
#define IDM_REGRESSION                  41002
#define IDM_OPTIONS                     65535

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        104
#define _APS_NEXT_COMMAND_VALUE         41003
#define _APS_NEXT_CONTROL_VALUE         1012
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\functest\printtest\cextra.cpp ===
// Include all the primitives (classes derived from CPrimitive)
#if 0
#include "..\CPolygons.h"
#include "..\CBitmaps.h"
#include "..\CCompoundLines.h"
#include "..\CContainer.h"
#include "..\CContainerClip.h"
#include "..\CDashes.h"
#include "..\CGradients.h"
#include "..\CHatch.h"
#include "..\CImaging.h"
#include "..\CInsetLines.h"
#include "..\CMixedObjects.h"
#include "..\CPaths.h"
#include "..\CPrimitives.h"
#include "..\CRegions.h"
#include "..\CRegression.h"
#include "..\CSourceCopy.h"
#include "..\CExtra.h"
#endif

#include "CPrinting.h"
#include "cbackprinting.h"
#include "cprivateprinting.h"
#include "cprinttext.h"
#include "..\CText.h"
#include "CPrintBitmap.h"
#include "CGradients.h"

// Create global objects for each individual primitive
//   First constructor param is the regression flag
//   If true, the test will take part of the regression suite
#if 0
CPolygons g_Polygons(true);
CBitmaps g_Bitmaps(true);
CCompoundLines g_CompoundLines(true);
CContainer g_Container(true);
CContainerClip g_ContainerClip(true);
CDashes g_Dashes(true);
CGradients g_Gradients(true);
CHatch g_Hatch(true);
CImaging g_Imaging(true);
CInsetLines g_InsetLines(true);
CMixedObjects g_MixedObjects(true);
CPaths g_Paths(true);
CPrimitives g_Primitives(true);
CRegions g_Regions(true);
CText g_Text(true);
CRegression g_Regression(true);
CSourceCopy g_SourceCopy(true);
#endif

CPrinting g_Printing(false);
CBackPrinting g_cbackPrint(false);
CPrivatePrinting g_privPrint(false);
CText g_Text(true);
CPrintText g_PrintText(false);
CPrintBitmap g_PrintBitmap(false);
CGradients g_Gradients(false);

void ExtraInitializations()
{
#if 0
    g_Polygons.Init();
    g_Bitmaps.Init();
    g_CompoundLines.Init();
    g_Container.Init();
    g_ContainerClip.Init();
    g_Dashes.Init();
    g_Gradients.Init();
    g_Hatch.Init();
    g_Imaging.Init();
    g_InsetLines.Init();
    g_MixedObjects.Init();
    g_Paths.Init();
    g_Primitives.Init();
    g_Regions.Init();
    g_Text.Init();
    g_Regression.Init();
    g_SourceCopy.Init();
#endif

    g_Text.Init();
    g_Printing.Init();
    g_cbackPrint.Init();
    g_privPrint.Init();
    g_PrintText.Init();
    g_PrintBitmap.Init();
    g_Gradients.Init();

//Gdiplus::DllExports::GdipDisplayPaletteWindowNotify(WindowNotifyEnumDisable);
//exit(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\functest\main.cpp ===
/******************************Module*Header*******************************\
* Module Name: Main.cpp
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  28-Apr-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/

#undef UNICODE
#undef _UNICODE

#include <windows.h>
#include <commctrl.h>
#include <objbase.h>
#include <gdiplus.h>
#include "CFuncTest.h"
#include "resource.h"

CFuncTest g_FuncTest;                                   // FuncTest (handles test runs)
HBRUSH g_hbrBackground=NULL;                            // Main window background color
HWND g_hWndMain=NULL;                                   // Main window
int g_nResult=0;                                        // Result of test run

// Include all the outputs (classes derived from COutput)
#include "CHWND.h"
#include "CHDC.h"
#include "CFile.h"
#include "CBitmap.h"
#include "CDIB.h"
#include "CDirect3D.h"
#include "CPrinter.h"
#include "CMetafile.h"

// Include all the primitives (classes derived from CPrimitive)
#include "CPolygons.h"
#include "CBitmaps.h"
#include "CCachedBitmap.h"
#include "CCompoundLines.h"
#include "CContainer.h"
#include "CContainerClip.h"
#include "CDashes.h"
#include "CPathGradient.hpp"
#include "CDash.hpp"
#include "CLines.hpp"
#include "CGradients.h"
#include "CHatch.h"
#include "CImaging.h"
#include "CRecolor.h"
#include "CInsetLines.h"
#include "CMixedObjects.h"
#include "CPaths.h"
#include "CPrimitives.h"
#include "CRegions.h"
#include "CText.h"
#include "CRegression.h"
#include "CSourceCopy.h"
#include "CExtra.h"

// Include all the settings (classes derived from CSetting)
#include "CAntialias.h"
#include "CHalfPixel.h"
#include "CQuality.h"
#include "CHalftone.h"
#include "CChecker.h"
#include "CRotate.h"
#include "CBKGradient.h"
#include "CHatch.h"

#include "../gpinit.inc"

// Create global objects for each individual output
//   First constructor param is the regression flag
//   If true, the test will take part of the regression suite
CHWND g_HWND(true);
CHDC g_HDC(true);
CDirect3D g_Direct3D(false);
CPrinter g_Printer(false);
CDIB g_DIB1(true,1);
CDIB g_DIB2(false,2);
CDIB g_DIB4(true,4);
CDIB g_DIB8(true,8);
CDIB g_DIB16(true,16);
CDIB g_DIB24(true,24);
CDIB g_DIB32(true,32);
CFile g_File1(false,1);
CFile g_File2(false,2);
CFile g_File4(false,4);
CFile g_File8(false,8);
CFile g_File16(false,16);
CFile g_File24(false,24);
CFile g_File32(false,32);

CBitmap g_Bitmap1(false, PixelFormat1bppIndexed);
CBitmap g_Bitmap4(false, PixelFormat4bppIndexed);
CBitmap g_Bitmap8(false, PixelFormat8bppIndexed);
CBitmap g_Bitmap16Gray(false, PixelFormat16bppGrayScale);
CBitmap g_Bitmap16555(false, PixelFormat16bppRGB555);
CBitmap g_Bitmap16565(false, PixelFormat16bppRGB565);
CBitmap g_Bitmap161555(false, PixelFormat16bppARGB1555);
CBitmap g_Bitmap24(false, PixelFormat24bppRGB);
CBitmap g_Bitmap32RGB(false, PixelFormat32bppRGB);
CBitmap g_Bitmap32ARGB(false, PixelFormat32bppARGB);
CBitmap g_Bitmap32PARGB(false, PixelFormat32bppPARGB);
CBitmap g_Bitmap48RGB(false, PixelFormat48bppRGB);
CBitmap g_Bitmap64ARGB(false, PixelFormat64bppARGB);
CBitmap g_Bitmap64PARGB(false, PixelFormat64bppPARGB);

CMetafile g_MetafileEMF(false, MetafileTypeEmf);
CMetafile g_MetafileEMFPlus(false, MetafileTypeEmfPlusOnly);
CMetafile g_MetafileEMFPlusDual(true, MetafileTypeEmfPlusDual);

CMetafile g_MetafileEMFF(false, MetafileTypeEmf, true);
CMetafile g_MetafileEMFPlusF(false, MetafileTypeEmfPlusOnly, true);
CMetafile g_MetafileEMFPlusDualF(true, MetafileTypeEmfPlusDual, true);

CRegression g_Regression(true);

// Create global objects for each individual setting
//   First constructor param is the regression flag
//   If true, the test will take part of the regression suite
CAntialias g_Antialias(true);
CHalfPixel g_HalfPixel(true);
CQuality g_Quality(true);
CCompositingMode g_CompositingMode(true);
CHalftone g_Halftone(true);
CChecker g_Checker(true);
CRotate g_Rotate13(true,13);
CRotate g_Rotate45(true,45);
CBKGradient g_BKGradient(true);
CHatch g_Hatch(true);

LRESULT CALLBACK WndProc(HWND hWnd,UINT Msg,WPARAM wParam,LPARAM lParam)
// Main window proc
{
    switch (Msg)
    {
        case WM_COMMAND:                // Process menu buttons
            switch(LOWORD(wParam))
            {
                case IDM_RUN:
                    g_FuncTest.Run();
                    break;
                case IDM_REGRESSION:
                    g_FuncTest.RunRegression();
                    break;
                case IDM_OPTIONS:
                    g_FuncTest.RunOptions();
                    break;
                case IDM_QUIT:
                    {
                        HWND hwnd = g_hWndMain;
                        g_hWndMain = NULL;
                        DestroyWindow(hwnd);
                    }
                    break;
            }
            break;
        case WM_DESTROY:
            PostQuitMessage(0);
            break;
    }

    return DefWindowProcA(hWnd,Msg,wParam,lParam);
}

void WindowUninit()
// Uninitializes window
{
    if (g_hbrBackground!=NULL)      // Destroy background brush
    {
        DeleteObject((HGDIOBJ)g_hbrBackground);
        g_hbrBackground=NULL;
    }
    if (g_hWndMain!=NULL)           // Destroy main window
    {
        DestroyWindow(g_hWndMain);
        g_hWndMain=NULL;
    }
}

BOOL WindowInit()
// Creates window and starts up app
{
    WNDCLASSA wc;
    HINSTANCE hInst=GetModuleHandleA(NULL);

    // Create white background brush
    g_hbrBackground=CreateSolidBrush(RGB(0xFF,0xFF,0xFF));

    wc.style            = 0;
    wc.lpfnWndProc      = WndProc;
    wc.cbClsExtra       = 0;
    wc.cbWndExtra       = 0;
    wc.hInstance        = hInst;
    wc.hIcon            = LoadIconA(GetModuleHandle(NULL),MAKEINTRESOURCEA(ID_APP));
    wc.hCursor          = LoadCursorA(NULL,MAKEINTRESOURCEA(32512));
    wc.hbrBackground    = g_hbrBackground;
    wc.lpszMenuName     = MAKEINTRESOURCEA(IDR_MENU1);
    wc.lpszClassName    = "Functest";
    if (!RegisterClassA(&wc))
        return false;

    g_hWndMain=CreateWindowExA(
        0,
        "Functest",
        "GDI+ Functionality Test",
        WS_OVERLAPPED|WS_CAPTION|WS_BORDER|WS_THICKFRAME|WS_MAXIMIZEBOX|
        WS_MINIMIZEBOX|WS_CLIPCHILDREN|WS_VISIBLE|WS_MAXIMIZE|WS_SYSMENU,
        CW_USEDEFAULT,
        CW_USEDEFAULT,
        800,
        600,
        NULL,
        NULL,
        hInst,
        NULL
    );
    HRESULT h=GetLastError();

    if (g_hWndMain==NULL)
        return false;

    UpdateWindow(g_hWndMain);
    ShowWindow(g_hWndMain,SW_SHOW);

    return true;
}

/***************************************************************************\
* main(argc, argv[])
*
* Sets up the message loop.
*
* History:
*  04-07-91 - Created  - KentD
*  04-28-00 - Modified - Jeff Vezina (t-jfvez)
*
\***************************************************************************/
__cdecl main(int argc,PCHAR argv[])
{
    MSG msg;

    if (!gGdiplusInitHelper.IsValid())
    {
        return 0;
    }
    
    CoInitialize(NULL);

    if (!WindowInit())
        return 0;
    if (!g_FuncTest.Init(g_hWndMain))
        return 0;

    // Init all primitives, graphics types, and graphics settings
    g_HWND.Init();
    g_HDC.Init();
    g_Direct3D.Init();
    g_Printer.Init();
    g_DIB1.Init();
    g_DIB2.Init();
    g_DIB4.Init();
    g_DIB8.Init();
    g_DIB16.Init();
    g_DIB24.Init();
    g_DIB32.Init();
    g_File1.Init();
    g_File2.Init();
    g_File4.Init();
    g_File8.Init();
    g_File16.Init();
    g_File24.Init();
    g_File32.Init();

    g_Bitmap1.Init();
    g_Bitmap4.Init();
    g_Bitmap8.Init();
    g_Bitmap16Gray.Init();
    g_Bitmap16555.Init();
    g_Bitmap16565.Init();
    g_Bitmap161555.Init();
    g_Bitmap24.Init();
    g_Bitmap32RGB.Init();
    g_Bitmap32ARGB.Init();
    g_Bitmap32PARGB.Init();
    g_Bitmap48RGB.Init();
    g_Bitmap64ARGB.Init();
    g_Bitmap64PARGB.Init();

    g_MetafileEMF.Init();
    g_MetafileEMFPlus.Init();
    g_MetafileEMFPlusDual.Init();
    
    g_MetafileEMFF.Init();
    g_MetafileEMFPlusF.Init();
    g_MetafileEMFPlusDualF.Init();




    g_Regression.Init();

    g_Antialias.Init();
    g_Quality.Init();
    g_CompositingMode.Init();
    g_HalfPixel.Init();
    g_Halftone.Init();
    g_Checker.Init();
    g_Rotate13.Init();
    g_Rotate45.Init();
    g_BKGradient.Init();
    g_Hatch.Init();

    // Put initializations into cextra.cpp, so that individual
    // developers can implement their own file for private usage.
    ExtraInitializations();

    for (int i=1;i<argc;i++)
    {
        if ((_stricmp(argv[i],"/?")==0) || (_stricmp(argv[i],"?")==0) || (_stricmp(argv[i],"-?")==0))
        {
            printf("Functest command line parameters:\n");
            printf("/? - Show the command line parameters\n");
            printf("/regression - Run the regression test immediately\n");
            return 1;
        }
        else if (_stricmp(argv[i],"/regression")==0)
        {
            g_FuncTest.RunRegression();
            SendMessageA(g_FuncTest.m_hWndMain,WM_CLOSE,0,0);
            return g_nResult;
        }
    }

    while (GetMessageA(&msg,NULL,0,0)) {
        TranslateMessage(&msg);
        DispatchMessageA(&msg);
    }

    WindowUninit();

    CoUninitialize();

    return g_nResult;
}

#define UNICODE
#define _UNICODE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\functest\printtest\cprinttext.h ===
/******************************Module*Header*******************************\
* Module Name: CPrintText.h
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/

#ifndef __CPRINTTEXT_H
#define __CPRINTTEXT_H

#include "..\CPrimitive.h"

class CPrintText : public CPrimitive  
{
public:
	CPrintText(BOOL bRegression);
	virtual ~CPrintText();

	void Draw(Graphics *g);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\functest\printtest\cprivateprinting.h ===
/******************************Module*Header*******************************\
* Module Name: CPrinting.h
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/

#ifndef __CPRIVATEPRINTING_H
#define __CPRIVATEPRINTING_H

#include "..\CPrimitive.h"

class CPrivatePrinting : public CPrimitive  
{
public:
	CPrivatePrinting(BOOL bRegression);
	virtual ~CPrivatePrinting();

	void Draw(Graphics *g);
    
        // Pattern fill using GDI TextureBrush
        VOID TestBug104604(Graphics *g);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\functest\printtest\cprinttext.cpp ===
/******************************Module*Header*******************************\
* Module Name: CPrintText.cpp
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/
#include "CPrintText.h"

CPrintText::CPrintText(BOOL bRegression)
{
        strcpy(m_szName,"Print Text");
        m_bRegression=bRegression;
}

CPrintText::~CPrintText()
{
}

void CPrintText::Draw(Graphics *g)
{
    //Font font(L"Arial", 60);

    Matrix m;
    g->SetTransform(&m);
   
    g->SetPageUnit(UnitDisplay);
    
    FontFamily  familyArial(L"Arial");
    Font fontArialS(&familyArial, 10.0f);
    Font fontArialL(&familyArial, 50.0f);

    FontFamily familyTahoma(L"Tahoma");
    Font fontTahomaS(&familyTahoma, 10.0f);
    Font fontTahomaL(&familyTahoma, 50.0f);

    FontFamily familyPapyrus(L"Papyrus");
    Font fontPapyrusS(&familyPapyrus, 10.0f);
    Font fontPapyrusL(&familyPapyrus, 50.0f);
    
    FontFamily familyOutlook(L"MS Outlook");
    Font fontOutlookS(&familyOutlook, 10.0f);
    Font fontOutlookL(&familyOutlook, 50.0f);

    Color color3(0xff, 100, 0, 200);
    Color color4(0x80, 0, 100, 50);
    SolidBrush brushSolidOpaque(color3);
    SolidBrush brushSolidAlpha(color4);
    
    WCHAR filename[256];
    wcscpy(filename, L"marble1.jpg");
    Bitmap *bitmap = new Bitmap(filename);                          
    TextureBrush textureBrush(bitmap, WrapModeTile);
    
    RectF rectf(20.0f, 0.0f, 50.0f, 25.0f);
    
    rectf.Y = 200.0f;
    Color color1(255, 255, 0, 0);
    Color color2(255, 0, 255, 0);
    LinearGradientBrush lineGradBrush(rectf, color1, color2, 0.0f);
    

/*  For reference:
    
    Status
    DrawString(
        IN const WCHAR        *string,
        IN INT                 length,
        IN const Font         *font,
        IN const RectF        &layoutRect,
        IN const StringFormat *stringFormat,
        IN const Brush        *brush
*/

    // Small text (punt to GDI)
    g->DrawString(L"Small Solid Opaque", 
                  18, 
                  &fontArialS, 
                  PointF(rectf.X, rectf.Y), 
                  &brushSolidOpaque);

    // Small text (with Alpha)
    g->DrawString(L"Small Solid Alpha", 
                  17, 
                  &fontTahomaS,
                  PointF(rectf.X, rectf.Y + rectf.Height), 
                  &brushSolidAlpha);

    // Large text (punt to GDI)
    g->DrawString(L"Large Solid Opaque", 
                  18, 
                  &fontArialL, 
                  PointF(rectf.X, rectf.Y + rectf.Height*2), 
                  &brushSolidOpaque);

    // Large text (with Alpha)
    g->DrawString(L"Large Solid Alpha", 
                  17, 
                  &fontTahomaL,
                  PointF(rectf.X, rectf.Y + rectf.Height*4), 
                  &brushSolidAlpha);

    rectf.Y += rectf.Height*2;

    // Small text with texture
    g->DrawString(L"Small Texture", 
                  13, 
                  &fontPapyrusS, 
                  PointF(rectf.X, rectf.Y + rectf.Height*6), 
                  &textureBrush);

    // Small text with line gradient
    g->DrawString(L"Small Line Grad", 
                  15, 
                  &fontOutlookS,
                  PointF(rectf.X, rectf.Y + rectf.Height*7), 
                  &lineGradBrush);

    // Large text (punt to GDI)
    g->DrawString(L"Large Line Grad", 
                  15, 
                  &fontPapyrusL, 
                  PointF(rectf.X, rectf.Y + rectf.Height*8), 
                  &lineGradBrush);

    // Small text (with Alpha)
    g->DrawString(L"Large Texture", 
                  13,
                  &fontOutlookL,
                  PointF(rectf.X, rectf.Y + rectf.Height*12), 
                  &textureBrush);

    // Shadow part.
    REAL tx = 0.0f/500.0f*TESTAREAWIDTH, ty = 400.0f/500.0f*TESTAREAHEIGHT;
    Matrix skew;
    skew.Scale(1.0, 0.5);
    skew.Shear(-2.0, 0, MatrixOrderAppend);
    skew.Translate(tx, ty, MatrixOrderAppend);
    g->SetTransform(&skew);
    g->DrawString(L"Shadow", 6, &fontPapyrusL, PointF(rectf.X, rectf.Y), &brushSolidOpaque);

    delete bitmap;
    
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\functest\printtest\cprinting.cpp ===
/******************************Module*Header*******************************\
* Module Name: CPrinting.cpp
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/
#include "CPrinting.h"

CPrinting::CPrinting(BOOL bRegression)
{
        strcpy(m_szName,"Printing");
        m_bRegression=bRegression;
}

CPrinting::~CPrinting()
{
}

VOID CPrinting::TestTextPrinting(Graphics *g)
{
    Font f(L"Arial", 60);

    FontFamily  ff(L"Arial");
    RectF	  rectf1( 20,   0, 300, 200);
    RectF	  rectf2( 20, 300, 300, 200);
    RectF	  rectf3(220,   0, 300, 200);
    RectF	  rectf4(220, 300, 300, 200);


    Color color1(0xff, 100, 0, 200);
    Color color2(128, 100, 0, 200);
    Color color3(0xff, 0, 100, 200);
    Color color4(128, 0, 100, 0);
    SolidBrush brush1(color1);
    SolidBrush brush2(color2);
    LinearGradientBrush brush3(rectf3, color3, color4, LinearGradientModeForwardDiagonal);

    g->DrawString(L"Color1", 6, &f, rectf1, NULL, &brush1);
    g->DrawString(L"Color2", 6, &f, rectf2, NULL, &brush2);
    g->DrawString(L"Color3", 6, &f, rectf3, NULL, &brush3);
}

VOID CPrinting::TestPerfPrinting(Graphics *g)
{
/*
   Analyze file size based on output of StretchDIBits.  The claim by DonC is that when we StretchDIBits a
   subrectangle of a large DIB, it sends the large DIB to the printer and then clips to the subrectangle.
   but it apparently does on Win98 postscript.

   So this is the results of my test:  1000x1000 DIB (32bpp).  I blitted two chunks:

   This is 200x200 source rectangle (part of a band):

04/27/2000  03:00p              22,198 nt5pcl
04/27/2000  03:02p             268,860 nt5ps			// Level 1 ps
04/27/2000  02:47p              17,488 w98pcl
04/27/2000  02:47p           6,207,459 w98ps			// Level 1 ps

   This is 1000x200 source rectangle (an entire band):

04/27/2000  03:06p              80,291 nt5pcl
04/27/2000  03:06p           1,266,123 nt5ps			// Level 1 ps
04/27/2000  02:51p              60,210 w98pcl
04/27/2000  02:52p           6,207,457 w98ps			// Level 1 ps

   Also compared 32bpp vs. 24bpp DIB.  The results were contradictary:

  04/27/2000  03:59p      <DIR>          ..
  04/27/2000  03:06p              80,291 nt5pcl
  04/27/2000  03:51p             122,881 nt5pcl24
  04/27/2000  03:06p           1,266,123 nt5ps
  04/27/2000  03:51p           1,262,332 nt5ps24
  04/27/2000  02:51p              60,210 w98pcl
  04/27/2000  03:39p             101,216 w98pcl24
  04/27/2000  02:52p           6,207,457 w98ps
  04/27/2000  03:39p           6,207,457 w98ps24

*/
    if (1) 
    {
        BITMAPINFO bi;
        ZeroMemory(&bi, sizeof(BITMAPINFO));

        bi.bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
        bi.bmiHeader.biPlanes = 1;
        bi.bmiHeader.biCompression = BI_RGB;
        bi.bmiHeader.biSizeImage = 0;

        bi.bmiHeader.biWidth = 1000;
        bi.bmiHeader.biHeight = 1000;
        bi.bmiHeader.biBitCount = 32;

        ARGB* Bits = (ARGB*)malloc(bi.bmiHeader.biWidth *
                              bi.bmiHeader.biHeight *
                              sizeof(ARGB));

        ARGB* Ptr = Bits;

        // To eliminate RLE/ASCII85 encoding, set to random bits
        for (INT i=0; i<bi.bmiHeader.biHeight; i++)
            for (INT j=0; j<bi.bmiHeader.biWidth; j++) 
            {
                *Ptr++ = (ARGB)(i | (j<<16));
            }

        HDC hdc = g->GetHDC();

        StretchDIBits(hdc, 0, 0, 1000, 200, 
                      0, 700, 1000, 200, Bits, &bi,
                      DIB_RGB_COLORS, SRCCOPY);

        g->ReleaseHDC(hdc);

        free(Bits);

    }
}

void CPrinting::Draw(Graphics *g)
{
// TestPerfPrinting(g);
// TestTextPrinting(g);
TestBug104604(g);

if (0)
    {

#if 1
    HDC hdc = g->GetHDC();

    HDC bufHdc = CreateCompatibleDC(hdc);

    HBITMAP BufDIB = NULL;
    ARGB* argb;

    struct {
       BITMAPINFO bitmapInfo;
       RGBQUAD rgbQuad[4];
    } bmi;

    INT width=100;
    INT height=100;

    ZeroMemory(&bmi.bitmapInfo, sizeof(bmi.bitmapInfo));

    bmi.bitmapInfo.bmiHeader.biSize        = sizeof(BITMAPINFOHEADER);
    bmi.bitmapInfo.bmiHeader.biWidth       = width;
    bmi.bitmapInfo.bmiHeader.biHeight      = -height;
    bmi.bitmapInfo.bmiHeader.biPlanes      = 1;
    bmi.bitmapInfo.bmiHeader.biBitCount    = 24;
    bmi.bitmapInfo.bmiHeader.biCompression = BI_RGB;
	
    RGBQUAD red = { 0, 0, 0xFF, 0}; // red
    RGBQUAD green = { 0, 0xFF, 0, 0}; // green
    RGBQUAD blue = { 0xFF, 0, 0, 0}; // blue

    bmi.bitmapInfo.bmiColors[0] = red;
    bmi.bitmapInfo.bmiColors[1] = green;
    bmi.bitmapInfo.bmiColors[2] = blue;

    // if assert fails, then we didn't clean up properly by calling End()
//    ASSERT(BufDIB == NULL);

    BufDIB = CreateDIBSection(bufHdc,
                 &bmi.bitmapInfo,
                 DIB_RGB_COLORS,
                 (VOID**) &argb,
                 NULL,
                 0);
//    ASSERT(BufDIB != NULL);

    memset(argb, 0, 3*width*height);

    INT i,j;
    BYTE* tempptr = (BYTE*)argb;
    for (i=0; i<height; i++)
    {
        for (j=0; j<width; j++)
        {
            if (i==j)
            {
                *tempptr++ = 0xFF;
                *tempptr++ = 0x80;
                *tempptr++ = 0x40;
            }
            else
                tempptr += 3;    
        }
        if ((((ULONG_PTR)tempptr) % 4) != 0) tempptr += 4-(((ULONG_PTR)tempptr) % 4);
    }

    INT mode = GetMapMode(bufHdc);
//    WARNING(("MapMode printing = %08x\n", mode));

    SelectObject(bufHdc, BufDIB);
/*
for (i=0; i<100; i++)
{
    int result = StretchBlt(hdc, 0, i*2, 2*width, 2, bufHdc, 0, i, width, 0, SRCCOPY);
    INT joke = GetLastError();
	joke++;
}
 */
//	int result = StretchBlt(hdc, 0, 0, 50, 50, bufHdc, 0, 0, 50, 50, SRCCOPY);
	
	for (i=0; i<50; i++)
	{
		int result = StretchBlt(hdc, 0, 100+i*2, 100, 1, bufHdc, 0, i*2, 100, 1, SRCCOPY);
    }
//   int result = StretchBlt(hdc, 0, 0, 200, 200, bufHdc, 0, 0, 100, 100, SRCCOPY);

//    ASSERT(result != 0);

    g->ReleaseHDC(hdc);

    DeleteDC(bufHdc);
    DeleteObject(BufDIB);

#endif

#if 1
    REAL widthF = 4; // Pen width

    Color redColor(255, 0, 0);

    SolidBrush brush1(Color(0xFF,0xFF,0,0));
    SolidBrush brush2(Color(0x80,0x80,0,0));

    SolidBrush brush3(Color(0xFF,0xFF,0,0));
    SolidBrush brush4(Color(0x80,0x80,0,0));

    Color colors1[] = { Color(0xFF,0xFF,0,0),
                        Color(0xFF,0,0xFF,0),
                        Color(0xFF,0,0,0xFF),
                        Color(0xFF,0x80,0x80,0x80) };
    Color colors2[] = { Color(0x80,0xFF,0,0),
                        Color(0x80,0,0xFF,0),
                        Color(0x80,0,0,0xFF),
                        Color(0x80,0x80,0x80,0x80) };

    //SolidBrush brush3(colors1[2]);
    //SolidBrush brush4(colors2[2]);

    // Default Wrap: Clamp to small rectangle 
//    RectangleGradientBrush brush3(Rect(125,275,50,50),
//                                  &colors1[0]);//,
                                  //WrapModeClamp);
    // Default Wrap: Clamp to 
//    RectangleGradientBrush brush4(Rect(250,250,100,100),
//                                  &colors2[0]);//,
                                  //WrapModeClamp);

    g->SetPageScale(1.2f);

    // no path clip
    g->FillRectangle(&brush1, Rect(0,25,500,50));

    // tests solid + opaque combinations + path clip only
    g->FillEllipse(&brush1, Rect(100,100,100,100));
    g->FillEllipse(&brush2, Rect(300,100,100,100));
    g->FillEllipse(&brush3, Rect(100,250,100,100));
    g->FillEllipse(&brush4, Rect(300,250,100,100));

    // tests visible clip + path clip
    Region origRegion;
    g->GetClip(&origRegion);
    Region *newRegion = new Region();
    newRegion->MakeInfinite();

    //Rect horzRect(150, 600, 500, 25);
    //Rect vertRect(150, 600, 25, 500);
    Rect horzRect(100, 400, 500, 25);
    Rect vertRect(100, 400, 25, 500);
    Region *horzRegion = new Region(horzRect);
    Region *vertRegion = new Region(vertRect);

    for (i = 0; i < 10; i++)
    {   
        newRegion->Xor(horzRegion);
        newRegion->Xor(vertRegion);
        horzRegion->Translate(0, 50);
        vertRegion->Translate(50, 0);
    }
    delete horzRegion;
    delete vertRegion;

    // Set grid clipping
    g->SetClip(newRegion);

    // set wrap mode from Clamp to Tile    
//    brush3.SetWrapMode(WrapModeTile);
//    brush4.SetWrapMode(WrapModeTile);

    // tests solid + opaque combinations + visible clip +  path clip only

    g->FillEllipse(&brush1, Rect(100,400,100,100));
    g->FillEllipse(&brush2, Rect(300,400,100,100));
    g->FillEllipse(&brush3, Rect(100,550,100,100));
    g->FillEllipse(&brush4, Rect(300,550,100,100));

    // restore original clip region
    g->SetClip(&origRegion);
    delete newRegion;

    // Test case which stretches beyond GetTightBounds() DrawBounds API

    PointF pts[8];

    pts[0].X = 2150.0f; pts[0].Y = 2928.03f;
    pts[1].X = 1950.0f; pts[1].Y = 3205.47f;
    pts[2].X = 1750.0f; pts[2].Y = 2650.58f;
    pts[3].X = 1550.0f; pts[3].Y = 2928.03f;
    pts[4].X = 1550.0f; pts[4].Y = 3371.97f;
    pts[5].X = 1750.0f; pts[5].Y = 3094.53f;
    pts[6].X = 1950.0f; pts[6].Y = 3649.42f;
    pts[7].X = 2150.0f; pts[7].Y = 3371.97f;

    BYTE types[8] = { 1, 3, 3, 3, 1, 3, 3, 0x83 };


    Bitmap *bitmap = new Bitmap(L"winnt256.bmp");

    // Test g->DrawImage
    if (bitmap && bitmap->GetLastStatus() == Ok) 
    {

        int i;

        for (i=0; i<8; i++) 
        {
            pts[i].X = pts[i].X / 8.0f;
            pts[i].Y = pts[i].Y / 8.0f;
        }

        TextureBrush textureBrush(bitmap, WrapModeTile);

        GraphicsPath path(&pts[0], &types[0], 8);

        g->FillPath(&textureBrush, &path);

        // Text using WrapModeClamp
        for (i=0; i<8; i++)
           pts[i].X += 200.0f;

        TextureBrush textureBrush2(bitmap, WrapModeClamp);

        GraphicsPath path2(&pts[0], &types[0], 8);

        g->FillPath(&textureBrush2, &path2);

        delete bitmap;
    }

/*
    Font font(50.0f * g->GetDpiY() / 72.0f, // emSize
              FontFamily(L"Arial"), // faceName,
              0,
              (Unit)g->GetPageUnit()
              );

    // will fail on Win9x
    LPWSTR str = L"Printing Support is COOL";
    GpRectF layoutRect1(200, 200, 300, 100);
    GpRectF layoutRect2(200, 400, 300, 100);
    GpRectF layoutRect3(200, 600, 300, 100);
    GpRectF layoutRect4(200, 800, 300, 100);

    INT len = 0;
    LPWSTR strPtr = str;
    while (*str != '\0') { len++; str++; }

    StringFormat format1 = StringFormatDirectionRightToLeft;
    StringFormat format2 = StringFormatDirectionVertical;
    StringFormat format3 = StringFormatDirectionRightToLeft;
    StringFormat format4 = StringFormatDirectionVertical;

    // Test DDI: SolidText (Brush 1 or 2)
    g->DrawString(strPtr, len, &font, &layoutRect1, &format1, &brush1);
    g->DrawString(strPtr, len, &font, &layoutRect2, &format2, &brush2);   

    // Test DDI: BrushText (Brush 3 or 4)
    g->DrawString(strPtr, len, &font, &layoutRect3, &format3, &brush3);
    g->DrawString(strPtr, len, &font, &layoutRect4, &format4, &brush4);   

    // Test DDI: StrokePath
    // Test DDI: FillRegion
*/
#endif
    }

}

// Try this from Nolan Lettelier
VOID CPrinting::TestNolan1(Graphics *g)
{
/*	TestInit(hdc);

	Graphics *pg = Graphics::FromHDC(hdc);
	if (pg == NULL)
	{
		assert(0);
		return false;
	}

	int sts;
	int alpha = 255, red = 255, green = 0, blue = 255;
	Color c1(alpha,red,green,blue);
	Point p1(150,150), p2(300,300);
	Color c2(255, 255-red, 255-green, 255-blue);
	LineGradientBrush gb(p1, p2, c1, c2);

	Pen p(&gb, 50.0);

	sts = pg->DrawLine(&p,0, 0, 500, 500);
	assert(sts == Ok);

	sts = pg->DrawLine(&p,0,100, 500, 100);
	assert(sts == Ok);

	sts = pg->DrawLine(&p,0,350, 500, 350);
	assert(sts == Ok);

	sts = pg->DrawLine(&p,0,500, 500, 0);
	assert(sts == Ok);
	delete pg;
	return true;
        */
}

VOID CPrinting::TestNolan2(Graphics *g)
{
    /*
        CString lineText("NolanRules");
        
	Graphics *pg = g;
        if (pg == NULL)
	{
		assert(0);
		return false;
	}
        Unit origUnit = pg->GetPageUnit();
        Matrix origXform;
        pg->GetTransform(&origXform);

        pg->SetPageUnit(UnitInch);
        pg->ScaleTransform(8.0f/1000.0f, 8.0f/1000.0f);

	Status sts;
	int alpha = 255, red = 255, green = 0, blue = 255;
	RectF rg(150,150,300,175);
	Color c1(alpha,red,green,blue);
	Color c2(255, 255-red, 255-green, 255-blue);
	LineGradientBrush gb(rg, c1, c2, LineGradientModeVertical);

	WCHAR *famName[] = {
		L"Comic Sans MS"
		, L"Courier New"
		, L"Times New Roman"
		, L"Tahoma"
		, L"Arial"
		, L"Lucida Console"
		, L"Garamond"
		, L"Palatino"
		, L"Univers"
		, L"Marigold"
		, L"Albertus"
		, L"Antique Olive"
	};

	int famCount = sizeof(famName) / sizeof(WCHAR *);

	WCHAR *s = L"GDI+ GradientFill";
	
	RectF r(30,30,0,0);
	StringFormat sf(0);
	FontFamily *pFontFamily;

	float lineHeight = 60;
	int i;
	for (i = 0, r.Y = 30 ; r.Y < 800 ; r.Y += lineHeight, ++i)
	{
		pFontFamily = new FontFamily(famName[i % famCount]);
		while (pFontFamily == NULL || pFontFamily->GetLastStatus()
!= Ok)
		{
			delete pFontFamily;
			++i;
			pFontFamily = new FontFamily(famName[i % famCount]);
		}
			
		Font f(*pFontFamily, lineHeight * 5 / 6, 0, UnitPoint);
		sts = pg->DrawString(s, wcslen(s), &f, &r, &sf, &gb);
//		CHECK_RESULT(sts, "TestGradientLinearVertical2 DrawString");
		delete pFontFamily;
	}

	delete pg;
	
        pg->SetPageUnit(origUnit);
        pg->SetTransform(&origXform);
        return true;
*/

} // TestGradientLinearVertical2

VOID CPrinting::TestBug104604(Graphics *g)
{
    BYTE* memory = new BYTE[8*8*3];
    // checkerboard pattern
    for (INT i=0; i<8*8; i += 3)
    {
        if (i%2)
        {
            memory[i] = 0xff;
            memory[i+1] = 0;
            memory[i+2] = 0;
        }
        else
        {
            memory[i] = 0;
            memory[i+1] = 0;
            memory[i+2] = 0xff;
        }
    }
    
    Bitmap bitmap(8,8, 8*3, PixelFormat24bppRGB, memory);
    
    TextureBrush brush(&bitmap);

    g->SetCompositingMode(CompositingModeSourceCopy);
    g->FillRectangle(&brush, 0, 0, 100, 100);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\gdiptest\dynarray.hpp ===
/**************************************************************************\
* 
* Copyright (c) 1998  Microsoft Corporation
*
* Module Name:
*
*   dynarray.hpp
*
* Abstract:
*
*   Dynamic array template classes. See DynamicArrays.doc in the Specs 
*   directory.
*
*   DynArray is a container which keeps its contents in a contiguous buffer,
*   reallocating memory as necessary. It accepts an optional initial
*   allocation, which is used unless it is too small to accommodate the
*   elements.
*
*   DynArrayIA is a cosmetic wrapper which encapsulates the intial allocation,
*   allowing the dynamic array to be treated like a normal class.
*
* Revision History:
*
*   12/02/1998 davidx
*       Created it.
*   02/26/1999 agodfrey
*       Revamped it to use an implementation class (DynArrayImpl). 
*       Now the template part of it can compile to nothing, or be small enough
*       to inline efficiently, so that using the template with many different
*       types doesn't cause code bloat.
*
*       Also, I added a version (DynArrayIA) which makes using an initial
*       allocation much easier.
*
* Notes:
*
*   12/02/1998 davidx
*   Changes from the previous version in gdiplus prototype:
*   + getData: Use &dynarr[index] instead.
*   + increaseCount: Use addMultiple instead (2nd variation).
*   + replace: Use dynarr[index] = newItem.
*   + attachData: Use dynarr.replaceWith(dynarr2).
*   + constructor: No longer takes initialCapacity, use ReserveSpace instead
*   + new constructor: Takes a stack array which is used for buffer (faster).
*
*   02/26/1999 agodfrey
*   + Use the 'implementation class' to avoid code bloat for out-of-line
*     functions.
*   + GetCapacity: Unused, not useful - removed.
*   + Reset: Added 'shrink' flag (default true). If it's false, Reset sets the
*     count to zero but doesn't free the memory. This is preferable to
*     SetCount(0).
*   + Made ShrinkToSize() reuse the initial allocation. This also makes the
*     growing and shrinking logic simpler - 'no initial allocation' is treated
*     like an initial allocation of size zero (at memory location 'NULL').
*
\**************************************************************************/

#ifndef _DYNARRAY_HPP
#define _DYNARRAY_HPP

template <class T> class DynArray : public DynArrayImpl
{
public:
    
    // Default allocation step size

    enum
    {
        DEFAULT_STEPSIZE = 512
    };
    
    // Constructor
    //
    //   initalAllocation - the initial allocation, which can be global,
    //                      static or dynamic memory (or NULL)
    //   allocSize        - size of the initial allocation 
    //                      (0 if there is none)
    //   stepSize         - number of elements added each time the buffer grows

    DynArray(
        T *initialAllocation, 
        UINT allocSize, 
        UINT stepSize = DEFAULT_STEPSIZE
        ):
        DynArrayImpl(initialAllocation, allocSize, stepSize)
    {
    }

    // Constructor (no initial allocation)
    //
    //   stepSize - number of elements added each time the buffer grows

    DynArray(UINT stepSize = DEFAULT_STEPSIZE):
        DynArrayImpl(NULL, 0, stepSize)
    {
    }

    // Destructor

    ~DynArray()
    {
        if (DataBuffer != InitialAllocation)
        {
           GpFree(DataBuffer);
        }
    }

    // Change the step size to the specified value

    VOID SetStepSize(UINT stepSize = DEFAULT_STEPSIZE)
    {
        ASSERT(stepSize > 0);
        StepSize = stepSize;
    }
    
    // Return a pointer to the array data
    //   NOTE: We intentionally avoid type conversion operator here
    //   to reduce the chances for confusion.

    T *GetDataBuffer() const
    {
        return static_cast<T *>(DataBuffer);
    }

    // Index operator

    T &operator[](INT n) const
    {
        ASSERT(n >= 0 && (UINT)n < Count);
        return GetDataBuffer()[n];
    }

    // First/last element of the array

    T &First() const
    {
        ASSERT(Count > 0);
        return GetDataBuffer()[0];
    }

    T &Last() const
    {
        ASSERT(Count > 0);
        return GetDataBuffer()[Count-1];
    }
        
    // Number of elements in the array

    INT GetCount() const
    {
        return Count;
    }

    // Reset the dynamic array to empty state
    //
    // shrink - If FALSE, don't free the current buffer.

    VOID Reset(BOOL shrink=TRUE)
    {
        Count = 0;
        if (shrink)
        {
            ShrinkToSize();
        }
    }

    // Shrink the dynamic array capacity to be just big enough
    // for the number of existing elements in the array.
    //
    // This reuses the initial allocation if possible.

    VOID ShrinkToSize()
    {
        DynArrayImpl::ShrinkToSize(sizeof(T));
    }

    // Add a new element to the end of the dynamic array

    GpStatus Add(const T& newItem)
    {
        return DynArrayImpl::AddMultiple(sizeof(T), 1, &newItem);
    }

    // Add multiple items to the end of the dynamic array

    GpStatus AddMultiple(const T* newItems, INT n)
    {
        return DynArrayImpl::AddMultiple(sizeof(T), n, newItems);
    }
    
    // Another variation of addMultiple above
    //
    // In this case, the data for the new elements are
    // not available. Instead, we'll do the following:
    //  (1) reserve the space for additional elements
    //  (2) increase the Count by the number of additional elements
    //  (3) return a pointer to the first new elements

    T *AddMultiple(INT n)
    {
        return static_cast<T *>(DynArrayImpl::AddMultiple(sizeof(T), n));
    }

    // Detach the data buffer from the dynamic array
    // Cannot be used if there is an initial allocation

    T *DetachData()
    {
        return static_cast<T *>(DynArrayImpl::DetachData());
    }
    
    // Detatch the buffer from another array, and set this array
    // to point to it. NOTE: This modifies the other array.

    VOID ReplaceWith(DynArray<T> *dynarr)
    {
        if (DataBuffer != InitialAllocation)
        {
            GpFree(DataBuffer);
        }

        Count = dynarr->Count;
        Capacity = dynarr->Capacity;
        DataBuffer = dynarr->DetachData();
    }
    
    // More dangerous interface:
    //
    // These functions are alternatives to Add/AddMultiple.
    // They can be used to reduce overhead, but you have to know what
    // you're doing.
    //
    // AdjustCount/SetCount - modify the count directly, without growing or
    //   shrinking the array.
    // ReserveSpace - grow the buffer, but don't actually add any elements to
    //   the array.
    
    VOID AdjustCount(UINT addElts)
    {
        Count += addElts;
    }

    VOID SetCount(UINT count)
    {
        Count = count;
    }
    
    GpStatus ReserveSpace(UINT newElements)
    {
        return Grow(sizeof(T), newElements);
    }

	// !! This is added as a hack to allow bitwise cloning
	//    of DynArray types.

	GpStatus RenewDataBuffer()
	{
		void *oldDataBuffer = DataBuffer;
		void *oldInitialAllocation = InitialAllocation;

		InitialAllocation = NULL;
		AllocSize = 0;

		DataBuffer = (VOID*) malloc(Capacity*sizeof(T));
		memcpy(DataBuffer, oldDataBuffer, Capacity*sizeof(T));

		return Ok;
	}

};

// DynArrayIA: A version of DynArray which encapsulates the initial allocation.
//
// For example:
//
// DynArrayIA<MyType, 10> array(16);
//
// This declares a DynArray of MyType objects, with an initial allocation of
// 10 elements, and a step size of 16. Such a declaration can be used on
// the stack or in another object.

template <class T, int ALLOCSIZE> class DynArrayIA : public DynArray<T>
{
public:

    // Constructor
    //
    //   stepSize - number of elements added each time the buffer grows

    DynArrayIA(UINT stepSize = DEFAULT_STEPSIZE):
        DynArray<T>(InitialAllocationBuffer, ALLOCSIZE, stepSize)
    {
    }

private:
    T InitialAllocationBuffer[ALLOCSIZE];
};

#endif // !_DYNARRAY_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\functest\printtest\cprivateprinting.cpp ===
/******************************Module*Header*******************************\
* Module Name: CPrinting.cpp
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/
#include "CPrivatePrinting.h"

CPrivatePrinting::CPrivatePrinting(BOOL bRegression)
{
        strcpy(m_szName,"Private Printing");
        m_bRegression=bRegression;
}

CPrivatePrinting::~CPrivatePrinting()
{
}

void CPrivatePrinting::Draw(Graphics *g)
{

    // Pattern fill using GDI TextureBrush
    TestBug104604(g);
}

VOID CPrivatePrinting::TestBug104604(Graphics *g)
{
    BYTE* memory = new BYTE[8*8*3];
    // checkerboard pattern
    for (INT i=0; i<8*8; i += 3)
    {
        if (i%2)
        {
            memory[i] = 0xff;
            memory[i+1] = 0;
            memory[i+2] = 0;
        }
        else
        {
            memory[i] = 0;
            memory[i+1] = 0;
            memory[i+2] = 0xff;
        }
    }

    // Use GDI+ to do texture fill.

    Bitmap bitmap(8,8, 8*3, PixelFormat24bppRGB, memory);
    
    TextureBrush brush(&bitmap);
    g->SetCompositingMode(CompositingModeSourceCopy);

    g->FillRectangle(&brush, 200, 0, 100, 100);

    // Use GDI to do the same thing.

    HBITMAP hbm = CreateBitmap(8, 8, 1, 24, memory);
    if (hbm) 
    {
        LOGBRUSH logBrush;
        logBrush.lbStyle = BS_PATTERN;
        logBrush.lbHatch = (ULONG_PTR) hbm;

        HBRUSH hbr = CreateBrushIndirect(&logBrush);

        if (hbr) 
        {
            POINT pts[4];
            pts[0].x = 0; pts[0].y = 0;
            pts[1].x = 100; pts[1].y = 0;
            pts[2].x = 100; pts[2].y = 100;
            pts[3].x = 0; pts[3].y = 100;

            HDC hdc = g->GetHDC();
            if (hdc) 
            {
                HBRUSH oldBr = (HBRUSH)SelectObject(hdc, hbr);
                Polygon(hdc, &pts[0], 4);
                SelectObject(hdc, oldBr);
                g->ReleaseHDC(hdc);
            }
            DeleteObject(hbr);
        }
        DeleteObject(hbm);
    }
    
    if (memory)
    {
        delete memory;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\gdiptest\debug.h ===
/**************************************************************************\
* 
* Copyright (c) 1998  Microsoft Corporation
*
* Module Name:
*
*   debug.h
*
* Abstract:
*
*   Macros used for debugging purposes
*
* Revision History:
*
*   12/02/1998 davidx
*       Created it.
*
\**************************************************************************/

#ifndef _DEBUG_H
#define _DEBUG_H

#ifdef __cplusplus
extern "C" {
#endif

//
// These macros are used for debugging purposes. They expand
// to white spaces on a free build. Here is a brief description
// of what they do and how they are used:
//
// _debugLevel
//  Global variable which set the current debug level to control
//  the amount of debug messages emitted.
//
// VERBOSE(msg)
//  Display a message if the current debug level is <= DBG_VERBOSE.
//
// TERSE(msg)
//  Display a message if the current debug level is <= DBG_TERSE.
//
// WARNING(msg)
//  Display a message if the current debug level is <= DBG_WARNING.
//  The message format is: WRN filename (linenumber): message
//
// ASSERT(cond)
//  Verify a condition is true. If not, force a breakpoint.
//
// ASSERTMSG(cond, msg)
//  Verify a condition is true. If not, display a message and 
//  force a breakpoint.
//
// RIP(msg)
//  Display a message and force a breakpoint.
//
// Usage:
//
//  These macros require extra parantheses for the msg argument
//  for example:
//      WARNING(("App passed NULL pointer, ignoring...\n"));
//      ASSERTMSG(x > 0, ("x is less than 0\n"));
//

#if DBG

#ifndef _COMPLUS_GDI

// Global debug level

#define DBG_VERBOSE 1
#define DBG_TERSE   2
#define DBG_WARNING 3
#define DBG_RIP     4

extern INT _debugLevel;

//--------------------------------------------------------------------------
// Debug build for native DLL
//--------------------------------------------------------------------------

// Emit debug messages

VOID DbgPrint(const CHAR*, ...);

// Strip the directory prefix from a filename

const CHAR*
StripDirPrefix(
    const CHAR* filename
    );

#define DBGMSG(level, prefix, msg) \
        { \
            if (_debugLevel <= (level)) \
            { \
                DbgPrint("%s %s (%d): ", prefix, StripDirPrefix(__FILE__), __LINE__); \
                DbgPrint msg; \
            } \
        }

#define DBGPRINT(level, msg) \
        { \
            if (_debugLevel <= (level)) \
            { \
                DbgPrint msg; \
            } \
        }
    
#else // _COMPLUS_GDI

//--------------------------------------------------------------------------
// Debug build COM+ IL
//--------------------------------------------------------------------------

VOID DbgPrint(const WCHAR* msg);
VOID DebugBreak();

#define DBGMSG(level, prefix, msg) \
        DbgPrint(L"*** DEBUG MESSAGE\n")

#define DBGPRINT(level, msg) \
        DbgPrint(L"*** DEBUG MESSAGE\n")

#endif // _COMPLUS_GDI

#define VERBOSE(msg) DBGPRINT(DBG_VERBOSE, msg)
#define TERSE(msg) DBGPRINT(DBG_TERSE, msg)
#define WARNING(msg) DBGMSG(DBG_WARNING, "WRN", msg)

#define ASSERT(cond) \
        { \
            if (! (cond)) \
            { \
                RIP(("\n")); \
            } \
        }

#define ASSERTMSG(cond, msg) \
        { \
            if (! (cond)) \
            { \
                RIP(msg); \
            } \
        }

#define RIP(msg) \
        { \
            DBGMSG(DBG_RIP, "RIP", msg); \
            DebugBreak(); \
        }

#else // !DBG

//--------------------------------------------------------------------------
// Retail build
//--------------------------------------------------------------------------

#define VERBOSE(msg)
#define TERSE(msg)
#define WARNING(msg)

#define ASSERT(cond)
#define ASSERTMSG(cond, msg)
#define RIP(msg)
#define DBGMSG(level, prefix, msg) 
#define DBGPRINT(level, msg)

#endif // !DBG

#ifdef __cplusplus
}
#endif

#endif // !_DEBUG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\gdiptest\dynarrayimpl.cpp ===
/**************************************************************************\
* 
* Copyright (c) 1998  Microsoft Corporation
*
* Module Name:
*
*   Dynamic array implementation class
*
* Abstract:
*
*   This is the class which implements the dynamic array. 
*   It is used by the wrapper template classes DynArray and DynArrayIA.
*
* Created:
*
*  2/18/1999 agodfrey
*
\**************************************************************************/

#include "gdiptest.h"

/**************************************************************************\
*
* Function Description:
*
*   DynArrayImpl constructor
*
* Arguments:
*
*   initialAllocation - initial allocation, or NULL
*   allocSize         - size of the initial allocation
*   stepSize          - number of elements added each time the buffer grows
*
* Return Value:
*
*   NONE
*
* Created:
*
*   2/25/1999 agodfrey
*
\**************************************************************************/

DynArrayImpl::DynArrayImpl(
    void *initialAllocation, 
    UINT allocSize, 
    UINT stepSize
    )
{
    ASSERT((initialAllocation != NULL) || (allocSize == 0));

    DataBuffer = InitialAllocation = initialAllocation;
    Capacity = AllocSize = allocSize;
    Count = 0;
    StepSize = stepSize;
}

/**************************************************************************\
*
* Function Description:
*
*   Shrink the buffer so that it is just big enough for the items
*   the dynamic array holds.
*
* Arguments:
*
*   eltSize - size of each array element
*
* Return Value:
*
*   NONE
*
* Created:
*
*   1/18/1999 agodfrey
*     Added code to reuse the initial allocation.
*
\**************************************************************************/

VOID DynArrayImpl::ShrinkToSize(UINT eltSize) 
{
    ASSERT(Count <= Capacity);

    if (DataBuffer == InitialAllocation)
    {
        // Since we're shrinking, we know that the current data buffer
        // is big enough.
        
        return;
    }

    if (Count <= AllocSize)
    {
        // The buffer will fit into the initial allocation.

        GpFree(DataBuffer);
        DataBuffer = InitialAllocation;
        Capacity = AllocSize;
        return;
    }

    // If we get here, we know that DataBuffer points to dynamic memory,
    // and that Count != 0.
    //
    // The second point is important because GpRealloc(x, 0) returns
    // a pointer to a valid zero-length buffer.

    void *newbuf = GpRealloc(DataBuffer, Count*eltSize);

    if (!newbuf)
    {
        // GpRealloc failed. Keep the current allocation
        
        WARNING(("ShrinkToSize: GpRealloc failed"));
        return;
    }

    DataBuffer = newbuf;
    Capacity = Count;
}

/**************************************************************************\
*
* Function Description:
*
*   Add space for new elements (if necessary). Does not update Count.
*
* Arguments:
*
*   eltSize     - size of each array element
*   newElements - the number of new elements
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   1/18/1999 agodfrey
*
\**************************************************************************/

GpStatus DynArrayImpl::Grow(UINT eltSize, UINT newElements)
{
    UINT newCount = Count + newElements;

    if (newCount <= Capacity)
    {
        return Ok;
    }

    ASSERT(newCount > 0);

    // Round up new capacity to be a multiple of allocation step size

    Capacity = StepSize * ((newCount + StepSize - 1) / StepSize);

    void *newbuf;

    if (DataBuffer == InitialAllocation)
    {
        // Do our first dynamic allocation

        newbuf = GpMalloc(Capacity*eltSize);

        if (newbuf && Count)
        {
            GpMemcpy(newbuf, DataBuffer, Count*eltSize);
        }
    }
    else
    {
        // Reallocate memory

        newbuf = GpRealloc(DataBuffer, Capacity*eltSize);
    }

    if (!newbuf)
    {
        WARNING(("Grow: alloc failed\n"));
        return OutOfMemory;
    }

    DataBuffer = newbuf;

    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   Detach the data buffer from the dynamic array.
*   Cannot be used if there is an initial allocation.
*
* Return Value:
*
*   The data buffer
*
* Created:
*
*   2/25/1999 agodfrey
*
\**************************************************************************/
    
void *DynArrayImpl::DetachData()
{
    ASSERT(InitialAllocation == NULL);

    void *data = DataBuffer;

    DataBuffer = NULL;
    Count = Capacity = 0;

    return data;
}

/**************************************************************************\
*
* Function Description:
*
*   Add new, uninitialized elements, and return a pointer to them.
*
* Arguments:
*
*   eltSize     - size of each element
*   newElements - number of new elements
*
* Return Value:
* 
*   Pointer to the new space, or NULL on failure
*
* Created:
*
*   2/25/1999 agodfrey
*
\**************************************************************************/
    
void *DynArrayImpl::AddMultiple(UINT eltSize, UINT newElements)
{
    ASSERT(newElements>0);

    if (Grow(eltSize, newElements) != Ok)
        return NULL;

    void *newSpace = static_cast<BYTE *>(DataBuffer) + Count * eltSize;
    Count += newElements;

    return newSpace;
}

/**************************************************************************\
*
* Function Description:
*
*   Add new elements, initializing them with the given data.
*
* Arguments:
*
*   eltSize     - size of each element
*   newElements - number of new elements
*   newData     - the data to be copied into the new space
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   2/25/1999 agodfrey
*
\**************************************************************************/
    
GpStatus DynArrayImpl::AddMultiple(
    UINT eltSize, 
    UINT newElements, 
    const void *newData
    )
{
    ASSERT(newElements>0);

    GpStatus status = Grow(eltSize, newElements);
     
    if (status == Ok)
    {
        // NOTE: assume T is a shallow data type, i.e.
        //  it doesn't contain nested references.

        GpMemcpy(
            static_cast<BYTE *>(DataBuffer) + Count * eltSize, 
            newData, 
            newElements * eltSize
            );
        Count += newElements;
    }

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\gdiptest\dynarrayimpl.hpp ===
/**************************************************************************\
* 
* Copyright (c) 1998  Microsoft Corporation
*
* Module Name:
*
*   Dynamic array implementation class
*
* Abstract:
*
*   This class contains definitions of functions which can't (or shouldn't)
*   be inlined. We use a separate implementation class because this allows us
*   to avoid the code bloat template classes produce; every instance of the
*   DynArray template can use the same version of each out-of-line member.
*
*   The DynArray data members need to be declared here, because they are
*   used by DynArrayImpl.
*
* Created:
*
*  2/18/1999 agodfrey
*
\**************************************************************************/

class DynArrayImpl
{
protected:
    
    // Constructor
    //
    //   initalAllocation - the initial allocation, which can be global,
    //                      static or dynamic memory (or NULL)
    //   allocSize        - size of the initial allocation 
    //                      (0 if there is none)
    //   stepSize         - number of elements added each time the buffer grows

    DynArrayImpl(void *initialAllocation, UINT allocSize, UINT stepSize);
    
    // Shrink the buffer so that it is just big enough for the items
    // the dynamic array holds.

    VOID ShrinkToSize(UINT eltSize);
    
    // Add space for new elements (if necessary). Does not update Count.
    // eltSize           - size of each element
    // newElements       - number of new elements

    GpStatus Grow(UINT eltSize, UINT newElements);

    // Add new, uninitialized elements, and return a pointer to them.
    // eltSize     - size of each element
    // newElements - number of new elements

    void *AddMultiple(UINT eltSize, UINT newElements);
    
    // Add new elements, initializing them with the given data.
    // eltSize     - size of each element
    // newElements - number of new elements
    // newData     - the data to be copied into the new space
    
    GpStatus AddMultiple(UINT eltSize, UINT newElements, const void *newData);
    
    // Detach the data buffer from the dynamic array.
    // Cannot be used if there is an initial allocation.

    void *DetachData();

    // Capacity, StepSize, AllocSize and Count are all measured in elements,
    // not bytes.

    void *DataBuffer;
    void *InitialAllocation;
    UINT AllocSize;
    UINT Capacity;
    UINT StepSize;
    UINT Count;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\gdiptest\gdipbrush.hpp ===
#ifndef _GDIPBRUSH_HPP
#define _GDIPBRUSH_HPP

class TestBrush;
class TestSolidBrush;
class TestTextureBrush;
class TestRectangleGradientBrush;
class TestRadialGradientBrush;
class TestTriangleGradientBrush;
class TestPathGradientBrush;
class TestHatchBrush;

//
// Interface class to inherit from GDI+ Brush objects
//

class TestBrushInterface : public TestConfigureInterface,
						   public TestDialogInterface
{
public:
	TestBrushInterface() : brush(NULL) {};

	~TestBrushInterface()
	{
		delete brush;
	}

	// acquire brush object
	virtual Brush* GetBrush() { return brush; }

	virtual INT GetType() = 0;

protected:
	// pointer to underlying GDI+ brush object
	Brush *brush;
};

class TestBrush : public TestBrushInterface
{
public:
	static TestBrush* CreateNewBrush(INT type);

	virtual VOID AddToFile(OutputFile* outfile, INT id = 0) = 0;
	virtual TestBrush* Clone() = 0;
};

class TestSolidBrush : public TestBrush
{
public:
	TestSolidBrush() 
	{
		argb = 0x80000000;
	}

	// Configuration Interface
	virtual BOOL ChangeSettings(HWND hwnd);
	virtual VOID Initialize();

	// Dialog Management Interface
	virtual	VOID InitDialog(HWND hwnd);
	virtual BOOL SaveValues(HWND hwnd);
	virtual BOOL ProcessDialog(HWND hwnd, 
					UINT msg, 
					WPARAM wParam, 
					LPARAM lParam);

	// output brush setup to File
	virtual VOID AddToFile(OutputFile* outfile, INT id = 0);

	// return type of brush
	virtual INT GetType()
	{
		return SolidColorBrush;
	};

	// Clone interface
	virtual TestBrush* Clone() 
	{
		TestSolidBrush *newBrush = new TestSolidBrush();
		*newBrush = *this;					// bitwise copy

		if (brush)
			newBrush->brush = brush->Clone();	// clone GDI+ brush

		return newBrush;
	};

private:
	ARGB argb;
};

class TestTextureBrush : public TestBrush
{
public:
	TestTextureBrush() 
	{
		filename = NULL;
		bitmap = NULL;
		wrapMode = 0;
		matrix = NULL;
	}

	~TestTextureBrush()
	{
		if (filename)
			free(filename);

		delete bitmap;
		delete matrix;
	}

	// Configuration Interface
	virtual BOOL ChangeSettings(HWND hwnd);
	virtual VOID Initialize();

	// Dialog Management Interface
	virtual	VOID InitDialog(HWND hwnd);
	virtual BOOL SaveValues(HWND hwnd);
	virtual BOOL ProcessDialog(HWND hwnd, 
					UINT msg, 
					WPARAM wParam, 
					LPARAM lParam);

	// output brush setup to File
	virtual VOID AddToFile(OutputFile* outfile, INT id = 0);

	// return type of brush
	virtual INT GetType()
	{
		return TextureFillBrush;
	};

	// Clone interface
	virtual TestBrush* Clone() 
	{
		TestTextureBrush *newBrush = new TestTextureBrush();
		*newBrush = *this;					// bitwise copy
		
		if (brush)
			newBrush->brush = brush->Clone();	// clone GDI+ brush
		
		if (bitmap)
			newBrush->bitmap = (Bitmap*)bitmap->Clone();
		
		if (matrix)
			newBrush->matrix = matrix->Clone();

		if (filename)
		{
#ifdef UNICODE
			newBrush->filename = _wcsdup(filename);
#else
			newBrush->filename = _strdup(filename);
#endif
		}

		return newBrush;
	};

private:
	Bitmap *bitmap;
	LPTSTR filename;
	INT wrapMode;
	Matrix *matrix;
};

class TestRectGradBrush : public TestBrush
{
public:
	friend class TestRectGradShape;

	TestRectGradBrush() 
	{
		horzBlend = vertBlend = NULL;
		wrapMode = 0;
		matrix = NULL;
	}

	~TestRectGradBrush()
	{
		if (horzBlend)
			free(horzBlend);
		
		if (vertBlend)
			free(vertBlend);

		delete matrix;
	}

	// Configuration Interface
	virtual BOOL ChangeSettings(HWND hwnd);
	virtual VOID Initialize();

	// Dialog Management Interface
	virtual	VOID InitDialog(HWND hwnd);
	virtual BOOL SaveValues(HWND hwnd);
	virtual BOOL ProcessDialog(HWND hwnd, 
					UINT msg, 
					WPARAM wParam, 
					LPARAM lParam);

	// output brush setup to File
	virtual VOID AddToFile(OutputFile* outfile, INT id = 0);

	// return type of brush
	virtual INT GetType()
	{
		return RectGradBrush;
	};

	// Clone interface
	virtual TestBrush* Clone() 
	{
		TestRectGradBrush *newBrush = new TestRectGradBrush();
		*newBrush = *this;					// bitwise copy
		
		if (brush)
			newBrush->brush = brush->Clone();	// clone GDI+ brush
				
		if (matrix)
			newBrush->matrix = matrix->Clone();

		if (horzCount && horzBlend)
		{
			INT pos;

			newBrush->horzBlend = (REAL*)malloc(sizeof(REAL)*horzCount);
			for (pos = 0; pos < horzCount; pos++)
				newBrush->horzBlend[pos] = horzBlend[pos];
		}

		if (vertCount && vertBlend)
		{
			INT pos;

			newBrush->vertBlend = (REAL*)malloc(sizeof(REAL)*vertCount);
			for (pos = 0; pos < vertCount; pos++)
				newBrush->vertBlend[pos] = vertBlend[pos];
		}

		return newBrush;
	};

private:
	ERectangle rect;
	ARGB argb[4];

	INT horzCount, vertCount;
	REAL *horzBlend, *vertBlend;

	INT wrapMode;
	Matrix *matrix;
};

class TestRadialGradBrush : public TestBrush
{
public:
	friend class TestRadialGradShape;

	TestRadialGradBrush() 
	{
		blend = NULL;
		matrix = NULL;
		wrapMode = 0;
	}

	~TestRadialGradBrush()
	{
		if (blend)
			free(blend);

		delete matrix;
	}

	// Configuration Interface
	virtual BOOL ChangeSettings(HWND hwnd);
	virtual VOID Initialize();

	// Dialog Management Interface
	virtual	VOID InitDialog(HWND hwnd);
	virtual BOOL SaveValues(HWND hwnd);
	virtual BOOL ProcessDialog(HWND hwnd, 
					UINT msg, 
					WPARAM wParam, 
					LPARAM lParam);

	// output brush setup to File
	virtual VOID AddToFile(OutputFile* outfile, INT id = 0);

	// return type of brush
	virtual INT GetType()
	{
		return RadialGradBrush;
	};

	// Clone interface
	virtual TestBrush* Clone() 
	{
		TestRadialGradBrush *newBrush = new TestRadialGradBrush();
		*newBrush = *this;					// bitwise copy
	
		if (brush)
			newBrush->brush = brush->Clone();	// clone GDI+ brush
	
		if (matrix)
			newBrush->matrix = matrix->Clone();

		if (blendCount && blend)
		{
			INT pos;

			blend = (REAL*)malloc(sizeof(REAL)*blendCount);
			for (pos = 0; pos < blendCount; pos++)
				newBrush->blend[pos] = blend[pos];
		}

		return newBrush;
	};

private:
	ERectangle rect;
	ARGB centerARGB, boundaryARGB;
	
	INT blendCount;
	REAL *blend;

	INT wrapMode;
	Matrix *matrix;
};

class TestTriangleGradBrush : public TestBrush
{
public:
	friend class TestTriangleGradShape;
	
	TestTriangleGradBrush() 
	{
        pts[0].X = 10; pts[0].Y = 10;
        pts[1].X = 90; pts[1].Y = 10;
        pts[2].X = 50; pts[2].Y = 100;

        blend[0] = blend[1] = blend[2] = NULL;

        argb[0] = 0x80FF0000;
        argb[1] = 0x8000FF00;
        argb[2] = 0x800000FF;

		wrapMode = 0;
		matrix = NULL;
	}

	~TestTriangleGradBrush()
	{
		for (INT pos = 0; pos < 3; pos++)
			if (blend[pos])
				free(blend[pos]);

		delete matrix;
	}

	// Configuration Interface
	virtual BOOL ChangeSettings(HWND hwnd);
	virtual VOID Initialize();

	// Dialog Management Interface
	virtual	VOID InitDialog(HWND hwnd);
	virtual BOOL SaveValues(HWND hwnd);
	virtual BOOL ProcessDialog(HWND hwnd, 
					UINT msg, 
					WPARAM wParam, 
					LPARAM lParam);

	// output brush setup to File
	virtual VOID AddToFile(OutputFile* outfile, INT id = 0);

	// return type of brush
	virtual INT GetType()
	{
		return TriangleGradBrush;
	};

	// Clone interface
	virtual TestBrush* Clone() 
	{
		TestTriangleGradBrush *newBrush = new TestTriangleGradBrush();
		*newBrush = *this;					// bitwise copy
		
		if (brush)
			newBrush->brush = brush->Clone();	// clone GDI+ brush
				
		if (matrix)
			newBrush->matrix = matrix->Clone();

		for (INT pos = 0; pos < 3; pos++)
		{
			if (count[pos] && blend[pos])
			{
				newBrush->blend[pos] = (REAL*)malloc(sizeof(REAL)*count[pos]);
				for (INT pos2 = 0; pos2 < 3; pos2++)
					newBrush->blend[pos][pos2] = blend[pos][pos2];
			}
			else
			{
				newBrush->blend[pos] = NULL;
				newBrush->count[pos] = 0;
			}
		}

		return newBrush;
	};

private:
    ARGB argb[3];
    Point pts[3];
    INT count[3];           // blend factor counts
    REAL* blend[3];
	
	INT wrapMode;
	Matrix *matrix;
};

class TestPathGradBrush : public TestBrush
{
public:
	friend class TestTriangleGradShape;
	
	TestPathGradBrush() 
	{
		pts.Add(Point(100,100));
		pts.Add(Point(100,50));
		pts.Add(Point(150,150));
		pts.Add(Point(50,150));

        surroundBlend = centerBlend = NULL;
		surroundCount = centerCount = 0;
	
		argb.Add((ARGB)0x80000000);
        argb.Add((ARGB)0x80FF0000);
        argb.Add((ARGB)0x8000FF00);
        argb.Add((ARGB)0x800000FF);

		wrapMode = 0;
		matrix = NULL;
	}

	~TestPathGradBrush()
	{
		if (surroundBlend)
			free(surroundBlend);

		if (centerBlend)
			free(centerBlend);

		delete matrix;
	}

	// Configuration Interface
	virtual BOOL ChangeSettings(HWND hwnd);
	virtual VOID Initialize();

	// Dialog Management Interface
	virtual	VOID InitDialog(HWND hwnd);
	virtual BOOL SaveValues(HWND hwnd);
	virtual BOOL ProcessDialog(HWND hwnd, 
					UINT msg, 
					WPARAM wParam, 
					LPARAM lParam);

	// output brush setup to File
	virtual VOID AddToFile(OutputFile* outfile, INT id = 0);

	// return type of brush
	virtual INT GetType()
	{
		return PathGradBrush;
	};

	// Clone interface
	virtual TestBrush* Clone() 
	{
		TestPathGradBrush *newBrush = new TestPathGradBrush();
		*newBrush = *this;					// bitwise copy
		
		if (brush)
			newBrush->brush = brush->Clone();	// clone GDI+ brush
				
		if (matrix)
			newBrush->matrix = matrix->Clone();

		// !! HACK POLICE !! HACK ALERT !!
		// internally clone the DataBuffer pointer

		pts.RenewDataBuffer();
		argb.RenewDataBuffer();

		if (surroundCount && surroundBlend)
		{
			newBrush->surroundBlend = (REAL*) malloc(sizeof(REAL)*surroundCount);
			memcpy(newBrush->surroundBlend, surroundBlend, sizeof(REAL)*surroundCount);
		}
		else
			newBrush->surroundBlend = NULL;
		
		if (centerCount && centerBlend)
		{
			newBrush->centerBlend = (REAL*) malloc(sizeof(REAL)*centerCount);
			memcpy(newBrush->centerBlend, centerBlend, sizeof(REAL)*centerCount);
		}
		else
			newBrush->centerBlend = NULL;

		return newBrush;
	};

private:
	ARGBArray argb;
	PointArray pts;

    REAL* surroundBlend;
	REAL* centerBlend;

	INT surroundCount;           // blend factor counts
	INT centerCount;
	
	INT wrapMode;
	Matrix *matrix;
};

class TestHatchBrush : public TestBrush
{
public:
	TestHatchBrush() 
	{
		foreArgb = 0xFF000000;
		backArgb = 0xFFFFFFFF;
		hatch = 0;
	}

	// Configuration Interface
	virtual BOOL ChangeSettings(HWND hwnd);
	virtual VOID Initialize();

	// Dialog Management Interface
	virtual	VOID InitDialog(HWND hwnd);
	virtual BOOL SaveValues(HWND hwnd);
	virtual BOOL ProcessDialog(HWND hwnd, 
							   UINT msg, 
							   WPARAM wParam, 
							   LPARAM lParam);

	// output brush setup to File
	virtual VOID AddToFile(OutputFile* outfile, INT id = 0);

	// return type of brush
	virtual INT GetType()
	{
		return HatchFillBrush;
	};

	// Clone interface
	virtual TestBrush* Clone() 
	{
		TestHatchBrush *newBrush = new TestHatchBrush();
		*newBrush = *this;					// bitwise copy

		if (brush)
			newBrush->brush = brush->Clone();	// clone GDI+ brush

		return newBrush;
	};

private:
	ARGB foreArgb, backArgb;
	INT hatch;
};

#endif // _GDIPBRUSH_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\gdiptest\gdipclip.cpp ===
#include "gdiptest.h"

//*******************************************************************
//
// TestShapeRegion
//
//
//
//*******************************************************************

BOOL TestShapeRegion :: ChangeSettings(HWND hwndParent)
{
	BOOL ok = DialogBoxParam(hInst,
							MAKEINTRESOURCE(IDD_SHAPE_DLG),
							hwndParent,
							AllDialogBox,
							(LPARAM)((TestDialogInterface*)this));


	if (ok)
	{
		// discard the saved original tree
		delete origTree;
		origTree = NULL;

		return TRUE;
	}
	else
	{
		// restore original clip region tree

		delete clipTree;
		clipTree = origTree;
		origTree = NULL;
		return FALSE;
	}
}

VOID TestShapeRegion :: Initialize()
{
	shapeStack = NULL;
}

VOID TestShapeRegion :: Initialize(ShapeStack *stack, 
								   TestShape* current,
								   BOOL useClip)
{
	origUseClip = useClip;

	origStack = stack;

	shapeStack->Reset();

	shapeStack->Push(current);
	
	for (INT pos = stack->GetCount()-1; pos>=0; pos--)
	{
		TestShape* shape = stack->GetPosition(pos);

		shapeStack->Push(shape);
		
		shape->dwFlags = shape->GetDisabled() 
									? ShapeDisabled : 0;
	}

	origTree = clipTree->Clone();	
}

VOID TestShapeRegion :: AddClipNode(HWND hwnd, NodeType newType)
{
	TestShape* curShape = NULL;

	TVITEMEX itemex;
	HWND hwndList;
	HWND hwndTree;

	if (newType == DataNode)
	{
		hwndList = GetDlgItem(hwnd, IDC_SHAPE_LIST);
		INT curIndex = SendMessage(hwndList, LB_GETCURSEL, 0, 0);
		DeleteObject(hwndList);
	
		if (curIndex == LB_ERR)
		{
			DeleteObject(hwndList);
			WarningBox(_T("Failed to find shape in list."));
			return;
		}
		else if (curIndex == 0)
		{
			DeleteObject(hwndList);
			WarningBox(_T("Can't add current (incomplete) shape in list."));
			return;
		}
	
		curShape = shapeStack->GetPosition(curIndex);
	}
	
	hwndTree = GetDlgItem(hwnd, IDC_CLIP_TREE);

	HTREEITEM curSelect = TreeView_GetSelection(hwndTree);

	if (!curSelect)
	{
		DeleteObject(hwndTree);
		WarningBox(_T("No clip item selected."));
		return;
	}

	itemex.hItem = (HTREEITEM) curSelect;  
	itemex.mask = TVIF_PARAM;

	if (TreeView_GetItem(hwndTree, &itemex))
	{
		ClipTree* curNode = (ClipTree*) itemex.lParam;

		// we found current item
		ClipTree* newNode = new ClipTree(newType, curShape);
		if (newType == DataNode)
		{

			// if item is 'AND', 'OR' ,'XOR' then add as child
			if (curNode->type != DataNode)
			{
				itemex.cChildren = 1;
				itemex.mask = TVIF_CHILDREN;
				TreeView_SetItem(hwndTree, &itemex);

				curNode->AddChild(newNode);
			}
			else
			{
				// add as sibling to current node
				curNode->AddSibling(newNode);
			}

			// since node has no right siblings or children,
			// this should add in relation to node's parent and
			// left sibling.

			newNode->AddToTreeView(hwndTree);
		}
		else
		{
			// we are adding an AND, XOR, OR node.
			if (curNode->type != DataNode)
			{
				// simply change the current node's value
				curNode->type = newType;
				if (curNode->nodeName)
					free(curNode->nodeName);
				
				curNode->nodeName = ClipTree::GetNodeName(curNode->type,
														  curNode->notNode,
														  curNode->data);

				itemex.pszText = curNode->nodeName;
				itemex.cchTextMax = _tcslen(itemex.pszText)+1;
				itemex.mask = TVIF_TEXT;
				TreeView_SetItem(hwndTree, &itemex);

				delete newNode;
				newNode = NULL;
			}
			else
			{
				// adding an operand type to non-operand node
				// replace current node with ourselves and add
				// them as parent

				curNode->AddAsParent(newNode);

				// delete old data item
				TreeView_DeleteItem(hwndTree, curNode->GetHTREEITEM());
				
				// add new operand node
				newNode->AddToTreeView(hwndTree);
				
				// recreate data item subtree under operand node
				curNode->CreateTreeView(hwndTree);

				clipTree = newNode->GetRoot();

				// fool select below...
				newNode = curNode;
			}
		}

		if (newNode)
			TreeView_SelectItem(hwndTree, newNode->GetHTREEITEM());
	}
	else
   		WarningBox(_T("Failed to find selected tree node."));

	DeleteObject(hwndTree);
}

VOID TestShapeRegion :: RemoveClipNode(HWND hwnd)
{
	HWND hwndTree = GetDlgItem(hwnd, IDC_CLIP_TREE);

	HTREEITEM curSelect = TreeView_GetSelection(hwndTree);

	if (!curSelect)
	{
		DeleteObject(hwndTree);
		WarningBox(_T("No clip node selected."));
		return;
	}

	TVITEMEX itemex;
	itemex.hItem = (HTREEITEM) curSelect;  
	itemex.mask = TVIF_PARAM;

	if (TreeView_GetItem(hwndTree, &itemex))
	{
		// we found current item
		ClipTree* curNode = (ClipTree*) itemex.lParam;

		if (curSelect == clipTree->GetHTREEITEM())
		{
			DeleteObject(hwndTree);
			WarningBox(_T("Can't delete root of tree."));
			return;
		}

		ClipTree* nextFocusNode;

		if (curNode->prevSibling)
			nextFocusNode = curNode->GetPrevSibling();
		else if (curNode->nextSibling)
			nextFocusNode = curNode->GetNextSibling();
		else
			nextFocusNode = curNode->GetParent();

		if (curNode->HasChildren())
		{
			if (MessageBox(hwnd, _T("Remove All Children Regions?"), _T(""), MB_YESNO) == IDYES)
			{
				TreeView_DeleteItem(hwndTree, curNode->GetHTREEITEM());

				// delete all children
				delete curNode;
			}
			else
			{
				ClipTree* parent = curNode->GetParent();

				nextFocusNode = curNode->GetFirstChild();

				// merge children with parent node
				curNode->MoveChildrenToParent();

				delete curNode;

				// delete parent's subtree, then add it back
				TreeView_DeleteItem(hwndTree, parent->GetHTREEITEM());

				// recreate tree view based on new hierarchy
				parent->CreateTreeView(hwndTree);

				clipTree = parent->GetRoot();
			}
		}
		else
		{
			// no children, just remove this single node
			TreeView_DeleteItem(hwndTree, curNode->GetHTREEITEM());

			delete curNode;
		}

		if (nextFocusNode)
			TreeView_SelectItem(hwndTree, nextFocusNode->GetHTREEITEM());
	}
	else
		WarningBox(_T("Failed to find selected tree."));

	DeleteObject(hwndTree);
}

VOID TestShapeRegion :: ToggleNotNode(HWND hwnd)
{
	HWND hwndTree = GetDlgItem(hwnd, IDC_CLIP_TREE);

	HTREEITEM curSelect = TreeView_GetSelection(hwndTree);

	if (!curSelect)
	{
		DeleteObject(hwndTree);
		WarningBox(_T("No clip item selected."));
		return;
	}

	TVITEMEX itemex;
	itemex.hItem = (HTREEITEM) curSelect;  
	itemex.mask = TVIF_PARAM;

	if (TreeView_GetItem(hwndTree, &itemex))
	{
		// we found current item
		ClipTree* curNode = (ClipTree*) itemex.lParam;

		curNode->notNode = !curNode->notNode;

		free(curNode->nodeName);

		itemex.pszText = curNode->nodeName = 
							ClipTree::GetNodeName(curNode->type,
												  curNode->notNode,
												  curNode->data);
		itemex.mask = TVIF_HANDLE | TVIF_TEXT;
		TreeView_SetItem(hwndTree, &itemex);
	}

	DeleteObject(hwndTree);
}

VOID TestShapeRegion :: ShiftCurrentShape(HWND hwnd, INT dir)
{
	HWND hwndList = GetDlgItem(hwnd, IDC_SHAPE_LIST);

	INT curSel = SendMessage(hwndList, LB_GETCURSEL, 0, 0);
	INT maxList = SendMessage(hwndList, LB_GETCOUNT, 0, 0);

	if (curSel == LB_ERR)
	{
		WarningBox(_T("No shape selected."));
		DeleteObject(hwndList);
		return;
	}
	else if (dir<0 && curSel <= 1)
	{
		WarningBox(_T("Can't move up!"));
		DeleteObject(hwndList);
		return;
	}
	else if (dir>0 && (curSel == maxList-1 || curSel == 0))
	{
		WarningBox(_T("Can't move down!"));
		DeleteObject(hwndList);
		return;
	}

	// swap shape items to shift up or down

	TestShape** shapeList = shapeStack->GetDataBuffer();
	TestShape* swapTemp = NULL;

	swapTemp = shapeList[curSel+dir];
	shapeList[curSel+dir] = shapeList[curSel];
	shapeList[curSel] = swapTemp;

	SendMessage(hwndList, LB_DELETESTRING, (WPARAM) curSel+dir, 0);

	SendMessage(hwndList, LB_INSERTSTRING, curSel,
		(LPARAM) shapeList[curSel]->GetShapeName());

	DeleteObject(hwndList);
}

VOID TestShapeRegion :: ToggleDisableShape(HWND hwnd)
{
	HWND hwndList = GetDlgItem(hwnd, IDC_SHAPE_LIST);

	INT curSel = SendMessage(hwndList, LB_GETCURSEL, 0, 0);
	
	if (curSel == LB_ERR)
	{
		WarningBox(_T("No shape selected."));
		DeleteObject(hwndList);
		return;
	}

	TestShape* shape = shapeStack->GetPosition(curSel);

	// toggle disable state of shape
	shape->dwFlags ^= ShapeDisabled;

//	SetDisabled(!shape->GetDisabled());

	// name may change based on disabled status
	SendMessage(hwndList, LB_DELETESTRING, (WPARAM) curSel, 0);

	SendMessage(hwndList, LB_INSERTSTRING, (WPARAM) curSel,
								(LPARAM) shape->GetShapeName());
	
	SendMessage(hwndList, LB_SETCURSEL, (WPARAM) curSel, 0);

	DeleteObject(hwndList);
}

VOID TestShapeRegion :: UpdateShapePicture(HWND hwnd)
{
	HWND hwndShape;
	HDC hdcPic;
	HWND hwndFrame;
	HDC hdcFrame;
	RECT rectDst;
	SIZE size;

	INT curSel;

	hwndShape = GetDlgItem(hwnd, IDC_SHAPE_LIST);
	
	curSel = SendMessage(hwndShape, LB_GETCURSEL, 0, 0);

	hwndFrame = GetDlgItem(hwnd, IDC_SHAPE_PIC);
	GetClientRect(hwndFrame, &rectDst);
	hdcFrame = GetDC(hwndFrame);

	if (curSel == LB_ERR || curSel <= 0)
	{
badpic:
		// white GDI brush
		HBRUSH hbr = CreateSolidBrush(0x00FFFFFF);

		FillRect(hdcFrame, &rectDst, hbr);

		DeleteObject(hbr);
		DeleteObject(hwndFrame);
		DeleteObject(hdcFrame);
		DeleteObject(hwndShape);
		return;
	}

	hdcPic = shapeStack->GetPosition(curSel)->CreatePictureDC(hwnd, &rectDst);
	
	if (!hdcPic)
		goto badpic;
	
	// blit shape picture into the given frame
	// NOTE: should be same size
	BitBlt(hdcFrame, 
		   rectDst.left,
		   rectDst.top,
		   rectDst.right - rectDst.left,
		   rectDst.bottom - rectDst.top,
		   hdcPic,
		   0,
		   0,
		   SRCCOPY);

	ReleaseDC(hwndFrame, hdcFrame);
	DeleteObject(hwndFrame);
	DeleteObject(hwndShape);	
}

VOID TestShapeRegion :: CleanUpPictures(HWND hwnd)
{
	HWND hwndShape;
	HDC hdcPic;
	INT count;

	// !! This code is obsolete,
	//    it should only be used if we wish to recreate the pictures on
	//    each iteration

/*
	hwndShape = GetDlgItem(hwnd, IDC_SHAPE_LIST);

	count = SendMessage(hwndShape, LB_GETCOUNT, 0, 0);

	// clean up picture hwnd for each picture...
	for (INT pos = 0; pos < count; pos++)
	{
		hdcPic = (HDC) SendMessage(hwndShape, LB_GETITEMDATA, (WPARAM)pos, 0);
		if (hdcPic)
			DeleteDC(hdcPic);
	}

	DeleteObject(hwndShape);
*/
}

VOID TestShapeRegion :: InitDialog(HWND hwnd)
{
	HWND hwndTV;
	HWND hwndShape;

	RECT frameRect;
	HWND hwndFrame;

	hwndFrame = GetDlgItem(hwnd, IDC_SHAPE_PIC);
	GetWindowRect(hwndFrame, &frameRect);
	DeleteObject(hwndFrame);

	// display list of shapes
	hwndShape = GetDlgItem(hwnd, IDC_SHAPE_LIST);
	for (INT pos = 0; pos < shapeStack->GetCount(); pos++)
	{
		TestShape* shape = shapeStack->GetPosition(pos);

		SendMessage(hwndShape, LB_ADDSTRING, 0, (LPARAM)shape->GetShapeName());
	}
	DeleteObject(hwndShape);

	// add root of clip region tree to Tree View control
	// for display/editing

	hwndTV = GetDlgItem(hwnd, IDC_CLIP_TREE);
	clipTree = clipTree->GetRoot();

	HTREEITEM topTree = clipTree->CreateTreeView(hwndTV);

	// select root of tree
	TreeView_SelectItem(hwndTV, topTree);

	// expand entire tree
	TreeView_Expand(hwndTV, topTree, TVM_EXPAND);

	DeleteObject(hwndTV);

	SetDialogCheck(hwnd, IDC_CLIP_BOOL, origUseClip);
}

BOOL TestShapeRegion :: SaveValues(HWND hwnd)
{
	origUseClip = GetDialogCheck(hwnd, IDC_CLIP_BOOL);
	
	origStack->Reset();

	for (INT pos = shapeStack->GetCount()-1; pos >= 1; pos--)
	{
		TestShape* shape = shapeStack->GetPosition(pos);

		origStack->Push(shape);
		
		shape->SetDisabled(shape->dwFlags & ShapeDisabled);
	}
	
	return FALSE;
}

BOOL TestShapeRegion :: ProcessDialog(HWND hwnd, 
									  UINT msg, 
									  WPARAM wParam, 
									  LPARAM lParam)
{
	if (msg == WM_COMMAND)
	{
		switch(LOWORD(wParam))
		{
		case IDC_OK:
			if (SaveValues(hwnd))
				WarningBeep();
			else
			{
				CleanUpPictures(hwnd);
				::EndDialog(hwnd, TRUE);
			}
			break;

		case IDC_SHAPE_UP:
			ShiftCurrentShape(hwnd, -1);
			break;

		case IDC_SHAPE_DOWN:
			ShiftCurrentShape(hwnd, +1);
			break;

		case IDC_SHAPE_DISABLE:
			ToggleDisableShape(hwnd);
			break;
		
		case IDC_SHAPE_PEN:
		case IDC_SHAPE_BRUSH:
			break;

		case IDC_CLIP_ADD:
			AddClipNode(hwnd);
			break;

		case IDC_CLIP_REMOVE:
			RemoveClipNode(hwnd);
			break;

		case IDC_CLIP_AND:
			AddClipNode(hwnd, AndNode);
			break;

		case IDC_CLIP_OR:
			AddClipNode(hwnd, OrNode);
			break;

		case IDC_CLIP_XOR:
			AddClipNode(hwnd, XorNode);
			break;

		case IDC_CLIP_NOT:
			ToggleNotNode(hwnd);
			break;

		case IDC_SHAPE_LIST:
			if (HIWORD(wParam) == LBN_SELCHANGE)
				UpdateShapePicture(hwnd);
			break;

		case IDC_REFRESH_PIC:
			UpdateShapePicture(hwnd);
			break;

		case IDC_CANCEL:
			CleanUpPictures(hwnd);
			::EndDialog(hwnd, FALSE);
			break;

		default:
			return FALSE;
		}

		return TRUE;
	}

	return FALSE;
}

Region* TestShapeRegion :: GetClipRegion()
{
	// caller must free
	return clipTree->GetRegion();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\gdiptest\gdipclip.h ===
enum NodeType
{
	DataNode = 0,
	AndNode = 1,
	OrNode = 2,
	XorNode = 3
};

// shape flags for temporary editing
#define ShapeDisabled		0x00000001

template <class Data> class TreeNode
{
public:
	friend class TestShapeRegion;

	TreeNode(NodeType type = DataNode, Data* data = NULL, BOOL notNode = FALSE)
	{
		this->type = type;
		this->data = data;
		this->notNode = notNode;
		nodeName = NULL;

		if (data)
		{
			// !! violates we are a template class.. Yipes!! hacky!!
			path = new GraphicsPath();
			data->AddToPath(path);
		}
		else
			path = NULL;

		nextSibling = NULL;
		prevSibling = NULL;
		parent = NULL;
		firstChild = NULL;

		hItem = (HTREEITEM)-1;
	}
	
	~TreeNode()
	{
		if (nodeName)
			free(nodeName);

		TreeNode* next = firstChild;
		while (next)
		{	
			TreeNode* nextnext = next->nextSibling;
			delete next;
			next = nextnext;
		}

		if (nextSibling)
			nextSibling->prevSibling = prevSibling;

		if (prevSibling)
			prevSibling->nextSibling = nextSibling;

		if (parent && parent->firstChild == this)
			parent->firstChild = nextSibling;

		if (path)
			delete path;
	};
	
	TreeNode* GetRoot()
	{
		TreeNode* next = parent;

		while (next && next->parent)
			next = next->parent;

		return next ? next : this;
	}

	BOOL HasChildren()
	{
		return (firstChild) ? TRUE : FALSE;
	}

	TreeNode* GetParent()
	{
		return parent;
	}

	TreeNode* GetNextSibling()
	{
		return nextSibling;
	}

	TreeNode* GetPrevSibling()
	{
		return prevSibling;
	}

	TreeNode* GetFirstChild()
	{
		return firstChild;
	}

	VOID MoveChildrenToParent()
	{
		ASSERT(parent);

		TreeNode* lastSibling = parent->firstChild;
		while (lastSibling->nextSibling)
			lastSibling = lastSibling->nextSibling;

		lastSibling->nextSibling = firstChild;
		if (firstChild)
			firstChild->prevSibling = lastSibling;

		lastSibling = firstChild;
		while (lastSibling)
		{
			lastSibling->parent = parent;
			lastSibling = lastSibling->nextSibling;
		}

		firstChild = NULL;
	}

	HTREEITEM CreateTreeView(HWND hwndTV)
	{
		HTREEITEM hTreeItem = AddToTreeView(hwndTV);

		if (nextSibling)
			nextSibling->CreateTreeView(hwndTV);

		if (firstChild)
			firstChild->CreateTreeView(hwndTV);

		return hTreeItem;
	}

	HTREEITEM AddToTreeView(HWND hwndTV)
	{
		nodeName = GetNodeName(type, notNode, data);

		TVINSERTSTRUCT insertStruct =
		{
			parent ? (HTREEITEM)parent->GetHTREEITEM() : TVI_ROOT,
			prevSibling ? (HTREEITEM)prevSibling->GetHTREEITEM() : TVI_FIRST,
		};
		
		TVITEMEX itemex =
		{
			TVIF_CHILDREN|
				TVIF_PARAM|
				TVIF_STATE|
				TVIF_TEXT,				// mask
			(HTREEITEM)(NULL),			// identifies TV item
			0,							// state
			0,							// stateMask
			nodeName,					// text to display
			0,							// cchTextMax
			0,							// iImage
			0,							// iSelectedImage
			(firstChild ? 1 : 0),		// cChildren
			(LPARAM)(this),				// lParam
			1							// iIntegral
		};

		// !! wasn't able to compile into one assignment !?!?
		insertStruct.itemex = itemex;

		hItem = TreeView_InsertItem(hwndTV, &insertStruct);

		return hItem;
	};

	VOID AddChild(TreeNode* node)
	{
		if (!firstChild)
		{
			firstChild = node;

			node->parent = this;
			node->prevSibling = NULL;
			
			node->nextSibling = NULL;
			node->firstChild = NULL;
		}
		else
		{
			TreeNode* next = firstChild;

			while (next->nextSibling)
				next = next->nextSibling;

			next->nextSibling = node;
			node->parent = this;
			node->prevSibling = next;

			node->nextSibling = NULL;
			node->firstChild = NULL;
		}
	};

	VOID AddSibling(TreeNode* node)
	{
		TreeNode* next = this;

		while (next->nextSibling)
			next = next->nextSibling;

		if (next)
		{
			next->nextSibling = node;
			node->parent = this->parent;
			node->prevSibling = next;

			node->nextSibling = NULL;
			node->firstChild = NULL;
		}
		else
			ASSERT(FALSE);
	};

	VOID AddAsParent(TreeNode* newParent)
	{
		newParent->parent = parent;
		newParent->prevSibling = prevSibling;
		newParent->nextSibling = nextSibling;
		newParent->firstChild = this;

		if (parent && parent->firstChild == this)
			parent->firstChild = newParent;

		if (prevSibling)
			prevSibling->nextSibling = newParent;
		
		if (nextSibling)
			nextSibling->prevSibling = newParent;

		nextSibling = NULL;
		prevSibling = NULL;
		parent = newParent;
	}

	BOOL IsEmpty()
	{
		return (type == DataNode) && (notNode) && (data == NULL);
	}

	BOOL IsInfinite()
	{
		return (type == DataNode) && (!notNode) && (data == NULL);
	}

	HTREEITEM GetHTREEITEM()
	{
		return hItem;
	}

	static LPTSTR GetNodeName(NodeType type, 
							  BOOL notNode,
							  Data* data)
	{
		TCHAR tmpName[MAX_PATH];
		LPTSTR name;

		switch(type)
		{
		case DataNode:
			// !! won't work on other template class types.
			if (data)
			{
				if (notNode)
				{
					name = &tmpName[0];

					_stprintf(&tmpName[0],
						_T("NOT %s"),
						data->GetShapeName());

				}
				else
					name = data->GetShapeName();
			}
			else
			{
				if (notNode)
					name = _T("Empty");
				else
					name = _T("Infinite");
			}
			break;
		
		case AndNode:
			if (notNode)
				name = _T("NAND");
			else
				name = _T("AND");
			break;

		case OrNode:
			if (notNode)
				name = _T("NOR");
			else
				name = _T("OR");
			break;

		case XorNode:
			if (notNode)
				name = _T("NXOR");
			else
				name = _T("XOR");
			break;

		default:
			ASSERT(FALSE);
			return _T("Unknown!?!");
		};
		
		return _tcsdup(name);
	}

	Region* GetRegion()
	{
		Region* newRegion = NULL;

		switch(type)
		{
		case DataNode:
		{
			if (path)
				newRegion = new Region(path);
			else
			{
				newRegion = new Region();
				newRegion->SetInfinite();
			}
			break;
		}

		case AndNode:
		case OrNode:
		case XorNode:
		{
			Region* curRegion;
			TreeNode* curNode = firstChild;
			
			newRegion = new Region();
			if (type == AndNode)
				newRegion->SetInfinite();
			else
				newRegion->SetEmpty();

			while (curNode)
			{
				curRegion = curNode->GetRegion();
				
				if (type == AndNode)
					newRegion->And(curRegion);
				else if (type == OrNode)
					newRegion->Or(curRegion);
				else
				{
					ASSERT(type == XorNode);
					newRegion->Xor(curRegion);
				}

				curNode = curNode->nextSibling;
				delete curRegion;
			}

			break;
		}

		default:
			ASSERT(FALSE);
			break;
		}
		
		// complement the current region
		if (notNode)
		{
			Region *tmpRegion = new Region();
			tmpRegion->SetInfinite();
			newRegion->Complement(tmpRegion);
			delete tmpRegion;
		}

		return newRegion;
	}

	TreeNode* Clone()
	{
		TreeNode* newNode = new TreeNode(type, data, notNode);
		TreeNode* curNode = firstChild;
		TreeNode* newSibling = NULL;

		// loop through all children, clone and add to 'newNode'
		while (curNode)
		{
			TreeNode *newChild = curNode->Clone();

			newChild->nodeName = GetNodeName(type, notNode, data);

			if (!newSibling)
				newSibling = newNode->firstChild = newChild;
			else 
			{
				newSibling->nextSibling = newChild;
				newChild->prevSibling = newSibling;
				newSibling = newChild;
			}

			newChild->parent = newNode;
			curNode = curNode->nextSibling;
		}
		
		return newNode;
	}

private:
	NodeType type;
	BOOL notNode;

	LPTSTR nodeName;

	TreeNode* nextSibling;
	TreeNode* prevSibling;
	TreeNode* firstChild;
	TreeNode* parent;

	HTREEITEM hItem;

	GraphicsPath* path;			// GDI+ path for shape
	
	Data* data;
};

typedef TreeNode<TestShape> ClipTree;

class TestShapeRegion : public TestConfigureInterface,
						public TestDialogInterface
{
public:
	TestShapeRegion()
	{
		clipTree = new ClipTree(AndNode, NULL, FALSE);
		origTree = NULL;

		shapeStack = new ShapeStack();
		origStack = NULL;
	}

	~TestShapeRegion()
	{
		delete clipTree;
		delete shapeStack;

		// do not delete 'origTree' or 'origStack'
		// these are temporary references for saving under 'OK'
	}

	//  configuration management
	virtual BOOL ChangeSettings(HWND hwnd);
	virtual VOID Initialize();
	virtual VOID Initialize(ShapeStack* stack, TestShape* current, BOOL useClip);

	// dialog control interface methods
	virtual VOID InitDialog(HWND hwnd);
	virtual BOOL SaveValues(HWND hwnd);
	virtual BOOL ProcessDialog(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);

	Region* GetClipRegion();
	BOOL GetClipBool()
	{
		return origUseClip;
	}

protected:
	VOID AddClipNode(HWND hwnd, NodeType type = DataNode);
	VOID RemoveClipNode(HWND hwnd);
	VOID ToggleNotNode(HWND hwnd);

	VOID ShiftCurrentShape(HWND hwnd, INT dir);
	VOID ToggleDisableShape(HWND hwnd);

	VOID UpdateShapePicture(HWND hwnd);
	VOID CleanUpPictures(HWND hwnd);

private:
	// currently modified parameters
	ShapeStack* shapeStack;
	ClipTree* clipTree;

	// original saved parameters
	ShapeStack* origStack;
	ClipTree* origTree;
	BOOL origUseClip;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\gdiptest\gdipbrush.cpp ===
#include "gdiptest.h"

extern const TCHAR* fileExtList = 
					_T("BMP files\0*.BMP\0"
					   "JPG files\0*.JPG\0"
					   "GIF files\0*.GIF\0"
					   "All files\0*.*\0");

extern const TCHAR* defaultExt = _T("jpg");

TestBrush* TestBrush::CreateNewBrush(INT type)
{
	switch (type)
	{
	case SolidColorBrush:
		return new TestSolidBrush();

	case TextureFillBrush:
		return new TestTextureBrush();

	case RectGradBrush:
		return new TestRectGradBrush();

	case RadialGradBrush:
		return new TestRadialGradBrush();

	case TriangleGradBrush:
		return new TestTriangleGradBrush();

	case PathGradBrush:
		return new TestPathGradBrush();

	case HatchFillBrush:
		return new TestHatchBrush();

	// !!! Other brush types

	default:
		NotImplementedBox();
		return NULL;
	}
}

//*******************************************************************
//
// TestSolidBrush
//
//
//
//*******************************************************************

BOOL TestSolidBrush :: ChangeSettings(HWND hwndParent)
{
	BOOL ok = DialogBoxParam(hInst,
							MAKEINTRESOURCE(IDD_SOLIDBRUSH_DLG),
							hwndParent,
							AllDialogBox,
							(LPARAM)((TestDialogInterface*)this));


	if (ok)
	{
		// initialize a new GDI+ brush with settings
		delete brush;
		
		Color solidcolor(argb);
		
		brush = new SolidBrush(solidcolor);

		return TRUE;
	}
	
	return FALSE;
};

VOID TestSolidBrush :: Initialize()
{
	argb = 0x80000000;

	delete brush;
	
	Color solidcolor(argb);
						      
	brush = new SolidBrush(solidcolor);
}

VOID TestSolidBrush :: AddToFile(OutputFile* outfile, INT id)
{
	TCHAR colorStr[MAX_PATH];
	TCHAR brushStr[MAX_PATH];

	if (id)
	{
		_stprintf(&colorStr[0], _T("color%d"), id);
		_stprintf(&brushStr[0], _T("brush%d"), id);
	}
	else
	{
		_tcscpy(&colorStr[0], _T("color"));
		_tcscpy(&brushStr[0], _T("brush"));
	}

	outfile->ColorDeclaration(&colorStr[0], 
							  &argb);

	outfile->BlankLine();

	outfile->Declaration(_T("SolidBrush"), 
						 &brushStr[0], 
						 _T("%s"), 
						 &colorStr[0]);
}

VOID TestSolidBrush :: InitDialog(HWND hwnd)
{
	SetDialogLong(hwnd, IDC_SB_ALPHA, argb >> Color::AlphaShift);
}

BOOL TestSolidBrush :: SaveValues(HWND hwnd)
{
	BOOL warning = FALSE;

	argb = (argb & ~Color::AlphaMask) |
		      (GetDialogLong(hwnd, IDC_SB_ALPHA) 
				  << Color::AlphaShift);
	
	if (warning)
		InitDialog(hwnd);

	return warning;
}

BOOL TestSolidBrush :: ProcessDialog(HWND hwnd, 
							UINT msg, 
							WPARAM wParam, 
							LPARAM lParam)
{
	if (msg == WM_COMMAND)
	{
		switch(LOWORD(wParam))
		{
		case IDC_OK:
			if (SaveValues(hwnd))
				WarningBeep();
			else
				::EndDialog(hwnd, TRUE);
			break;

		case IDC_SB_COLORBUTTON:
			UpdateRGBColor(hwnd, IDC_SB_PIC, argb);
			break;

		case IDC_REFRESH_PIC:
			UpdateColorPicture(hwnd, IDC_SB_PIC, argb);
			break;

		case IDC_CANCEL:
			::EndDialog(hwnd, FALSE);
			break;

		default:
			return FALSE;
		}

		return TRUE;
	}

	return FALSE;
}

//*******************************************************************
//
// TestTextureBrush
//
//
//
//*******************************************************************

BOOL TestTextureBrush :: ChangeSettings(HWND hwndParent)
{
	BOOL ok = DialogBoxParam(hInst,
							MAKEINTRESOURCE(IDD_TEXTURE_DLG),
							hwndParent,
							AllDialogBox,
							(LPARAM)((TestDialogInterface*)this));


	if (ok)
	{
		// try open file first
		if (!filename || !bitmap)
			return FALSE;

		// initialize a new GDI+ brush with settings
		delete brush;

		TextureBrush *texBrush = new TextureBrush(bitmap, 
											wrapValue[wrapMode]);
		texBrush->SetTransform(matrix);

		brush = texBrush;

		// release bitmap
		delete bitmap;
		bitmap = NULL;

		return TRUE;
	}
	
	return FALSE;
};

VOID TestTextureBrush :: Initialize()
{
	filename = NULL;
	wrapMode = Tile;
	
	delete matrix;
	matrix = new Matrix();
	
	ASSERT(!bitmap);

	delete brush;

	// no image is black
	brush = blackBrush->Clone();
}

VOID TestTextureBrush::AddToFile(OutputFile* outfile, INT id)
{
	TCHAR brushStr[MAX_PATH];
	TCHAR matrixStr[MAX_PATH];
	TCHAR bitmapStr[MAX_PATH];

	if (id)
	{
		_stprintf(&brushStr[0], _T("brush%d"), id);
		_stprintf(&matrixStr[0], _T("matrix%d"), id);
		_stprintf(&bitmapStr[0], _T("bitmap%d"), id);
	}
	else
	{
		_tcscpy(&brushStr[0], _T("brush"));
		_tcscpy(&matrixStr[0], _T("matrix"));
		_tcscpy(&bitmapStr[0], _T("bitmap"));
	}

	outfile->Declaration(_T("Bitmap"), 
						 &bitmapStr[0], 
						 "%s",
						 outfile->WStr(filename));

	outfile->BlankLine();

	outfile->Declaration(_T("TextureBrush"), 
						 &brushStr[0], 
						 _T("%s, %s"),
						 outfile->Ref(&bitmapStr[0]),
						 wrapStr[wrapMode]);

	outfile->BlankLine();

	outfile->SetMatrixDeclaration(&brushStr[0],
								  _T("SetTransform"), 
								  &matrixStr[0],
								  matrix);
}

VOID TestTextureBrush :: InitDialog(HWND hwnd)
{
	SetDialogText(hwnd, IDC_TEXTURE_FILENAME, filename, FALSE);
	SetDialogCombo(hwnd, IDC_BRUSH_WRAP, wrapList, numWrap, wrapMode);
}

BOOL TestTextureBrush :: SaveValues(HWND hwnd)
{
	BOOL warning = FALSE;

	TCHAR fname[MAX_PATH];

	GetDialogText(hwnd, IDC_TEXTURE_FILENAME, &fname[0], MAX_PATH-1);

	if (filename)
		free(filename);

	filename = _tcsdup(&fname[0]);

	wrapMode = GetDialogCombo(hwnd, IDC_BRUSH_WRAP);

	return FALSE;
}

BOOL TestTextureBrush :: ProcessDialog(HWND hwnd, 
							UINT msg, 
							WPARAM wParam, 
							LPARAM lParam)
{
	if (msg == WM_COMMAND)
	{
		switch(LOWORD(wParam))
		{
		case IDC_OK:
			if (SaveValues(hwnd))
				WarningBeep();
			else
				::EndDialog(hwnd, TRUE);
			break;

		case IDC_TEXTURE_FILEBUTTON:
			{
				TCHAR fname[MAX_PATH];
	
				GetDialogText(hwnd, IDC_TEXTURE_FILENAME, &fname[0], MAX_PATH-1);

				OPENFILENAME ofn =
				{
					sizeof(OPENFILENAME),
					hwnd,
					0,
					fileExtList,
					NULL,
					0,
					1,
					&fname[0],
					MAX_PATH-1,
					NULL,
					0,
					NULL,
					NULL,
					OFN_PATHMUSTEXIST,
					0,
					0,
					defaultExt,
					NULL,
					NULL,
					NULL
				};

				if ((GetOpenFileName(&ofn) == TRUE) &&
					fname[0] != '\0')
				{
					HANDLE hFile = CreateFile(fname,
								  GENERIC_READ,
								  FILE_SHARE_READ,
								  NULL,
								  OPEN_EXISTING,
								  0,
								  0);

					if (!hFile)
					{
						WarningBox(_T("Can't open file for reading."));
						return TRUE;
					}

					CloseHandle(hFile);

#ifdef UNICODE
					LPWSTR wFilename = &fname[0];
#else // !UNICODE
					LPWSTR wFilename = (LPWSTR)malloc(sizeof(WCHAR)*(strlen(&fname[0])+1));

					MultiByteToWideChar(CP_ACP, 
						0,
						&fname[0], 
						strlen(&fname[0])+1,
						wFilename,
						strlen(&fname[0])+1);
#endif
					if (bitmap)
						delete bitmap;

					bitmap = new Bitmap(wFilename);

#ifndef UNICODE
					free(wFilename);
#endif
					if (!bitmap || bitmap->GetLastStatus() != Ok)
					{
						WarningBox(_T("Can't load bitmap file."));
						
						if (bitmap)
							delete bitmap;
					}
					else
					{
						SetDialogText(hwnd, IDC_TEXTURE_FILENAME, &fname[0], FALSE);
					}
				}
			}
			break;

		case IDC_BRUSH_TRANSFORM:
			{
				TestTransform transDlg;
				
				transDlg.Initialize(&matrix);

				transDlg.ChangeSettings(hwnd);
			}
			break;

		case IDC_CANCEL:
			::EndDialog(hwnd, FALSE);
			break;

		default:
			return FALSE;
		}

		return TRUE;
	}

	return FALSE;
}

//*******************************************************************
//
// TestRectGradBrush
//
//
//
//*******************************************************************

BOOL TestRectGradBrush :: ChangeSettings(HWND hwndParent)
{
	BOOL ok = DialogBoxParam(hInst,
							MAKEINTRESOURCE(IDD_RECTGRAD_DLG),
							hwndParent,
							AllDialogBox,
							(LPARAM)((TestDialogInterface*)this));

	if (ok)
	{
		// initialize a new GDI+ brush with settings
		delete brush;

		Color colors[4] =
		{
			Color(argb[0]),
			Color(argb[1]),
			Color(argb[2]),
			Color(argb[3])
		};

		RectangleGradientBrush* rectBrush =
			 new RectangleGradientBrush(rect,
										(Color*)&colors[0],
										wrapValue[wrapMode]);
		rectBrush->SetTransform(matrix);
		rectBrush->SetHorizontalBlend(horzBlend, horzCount);
		rectBrush->SetVerticalBlend(vertBlend, vertCount);

		brush = rectBrush;
		return TRUE;
	}
	
	return FALSE;
};

VOID TestRectGradBrush :: Initialize()
{
	rect.X = rect.Y = 0;
	rect.Width = rect.Height = 100;

	// !! need editing support for these...
	horzCount = 0;
	horzBlend = NULL;
	vertCount = 0;
	vertBlend = NULL;

	wrapMode = 0;
	delete matrix;
	matrix = new Matrix();

	argb[0] = 0xFFFFFFFF;
	argb[1] = 0xFFFF0000;
	argb[2] = 0xFF00FF00;
	argb[3] = 0xFF0000FF;
	
	Color colors[4] =
	{ 
		Color(argb[0]),
		Color(argb[1]),
		Color(argb[2]),
		Color(argb[3])
	};

	delete brush;

	RectangleGradientBrush *rectBrush =
		 new RectangleGradientBrush(rect,
									(Color*)&colors[0],
									wrapValue[wrapMode]);

	rectBrush->SetTransform(matrix);
	rectBrush->SetHorizontalBlend(horzBlend, horzCount);
	rectBrush->SetVerticalBlend(vertBlend, vertCount);

	brush = rectBrush;
}

VOID TestRectGradBrush::AddToFile(OutputFile* outfile, INT id)
{
	TCHAR brushStr[MAX_PATH];
	TCHAR rectStr[MAX_PATH];
	TCHAR matrixStr[MAX_PATH];
	TCHAR colorsStr[MAX_PATH];
	TCHAR blend1Str[MAX_PATH];
	TCHAR blend2Str[MAX_PATH];

	if (id)
	{
		_stprintf(&brushStr[0], _T("brush%d"), id);
		_stprintf(&rectStr[0], _T("rect%db"), id);
		_stprintf(&matrixStr[0], _T("matrix%d"), id);
		_stprintf(&colorsStr[0], _T("colors%db"), id);
		_stprintf(&blend1Str[0], _T("horzBlend%db"), id);
		_stprintf(&blend2Str[0], _T("vertBlend%db"), id);
	}
	else
	{
		_tcscpy(&brushStr[0], _T("brush"));
		_tcscpy(&rectStr[0], _T("rectb"));
		_tcscpy(&matrixStr[0], _T("matrixb"));
		_tcscpy(&colorsStr[0], _T("colors"));
		_tcscpy(&blend1Str[0], _T("horzBlend"));
		_tcscpy(&blend2Str[0], _T("vertBlend"));
	}

	outfile->ColorDeclaration(&colorsStr[0], 
							  &argb[0],
							  4);

	outfile->BlankLine();

	outfile->RectangleDeclaration(&rectStr[0],
								  rect);

	outfile->BlankLine();

	outfile->Declaration(_T("RectangleGradientBrush"), 
						 &brushStr[0], 
						 _T("%s, %s, %s"),
						 &rectStr[0],
						 outfile->RefArray(&colorsStr[0]),
						 wrapStr[wrapMode]);

	outfile->BlankLine();

	outfile->SetMatrixDeclaration(&brushStr[0], 
								  _T("SetTransform"), 
								  &matrixStr[0],
								  matrix);

	if (horzBlend && horzCount) 
	{
		outfile->BlankLine();

	  	outfile->SetBlendDeclaration(&brushStr[0],
									 _T("SetHorizontalBlend"),
									 &blend1Str[0], 
									 horzBlend, 
									 horzCount);
	}

	if (vertBlend && vertCount)
	{
		outfile->BlankLine();

		outfile->SetBlendDeclaration(&brushStr[0],
									 _T("SetVerticalBlend"),
									 &blend2Str[0], 
									 vertBlend, 
									 vertCount);
	}
}

VOID TestRectGradBrush :: InitDialog(HWND hwnd)
{
	SetDialogReal(hwnd, IDC_RECTGRAD_X,		 rect.X);
	SetDialogReal(hwnd, IDC_RECTGRAD_Y,		 rect.Y);
	SetDialogReal(hwnd, IDC_RECTGRAD_WIDTH,  rect.Width);
	SetDialogReal(hwnd, IDC_RECTGRAD_HEIGHT, rect.Height);

	SetDialogLong(hwnd, IDC_RECTGRAD_ALPHA1, argb[0] >> Color::AlphaShift);
	SetDialogLong(hwnd, IDC_RECTGRAD_ALPHA2, argb[1] >> Color::AlphaShift);
	SetDialogLong(hwnd, IDC_RECTGRAD_ALPHA3, argb[2] >> Color::AlphaShift);
	SetDialogLong(hwnd, IDC_RECTGRAD_ALPHA4, argb[3] >> Color::AlphaShift);
	
	SetDialogCombo(hwnd, IDC_BRUSH_WRAP, wrapList, numWrap, wrapMode);

	// !! is this a bug: can't paint colors in this call??
	SendMessage(hwnd, WM_COMMAND, IDC_REFRESH_PIC, 0);
}


BOOL TestRectGradBrush :: SaveValues(HWND hwnd)
{
	BOOL warning = FALSE;

	rect.X = GetDialogReal(hwnd, IDC_RECTGRAD_X);
	rect.Y = GetDialogReal(hwnd, IDC_RECTGRAD_Y);
	rect.Width = GetDialogReal(hwnd, IDC_RECTGRAD_WIDTH);
	rect.Height = GetDialogReal(hwnd, IDC_RECTGRAD_HEIGHT);

	argb[0] = (argb[0] & ~Color::AlphaMask)
				| (GetDialogLong(hwnd, IDC_RECTGRAD_ALPHA1) 
					<< Color::AlphaShift);
	
	argb[1] = (argb[1] & ~Color::AlphaMask)
				| (GetDialogLong(hwnd, IDC_RECTGRAD_ALPHA2) 
					<< Color::AlphaShift);

	argb[2] = (argb[2] & ~Color::AlphaMask)
				| (GetDialogLong(hwnd, IDC_RECTGRAD_ALPHA3) 
					<< Color::AlphaShift);

	argb[3] = (argb[3] & ~Color::AlphaMask)
				| (GetDialogLong(hwnd, IDC_RECTGRAD_ALPHA4) 
					<< Color::AlphaShift);

	wrapMode = GetDialogCombo(hwnd, IDC_BRUSH_WRAP);

	return FALSE;
}

BOOL TestRectGradBrush :: ProcessDialog(HWND hwnd, 
							UINT msg, 
							WPARAM wParam, 
							LPARAM lParam)
{
	if (msg == WM_COMMAND)
	{
		switch(LOWORD(wParam))
		{
		case IDC_OK:
			if (SaveValues(hwnd))
				WarningBeep();
			else
				::EndDialog(hwnd, TRUE);
			break;

		case IDC_RECTGRAD_COLOR1:
			UpdateRGBColor(hwnd, IDC_RECTGRAD_PIC1, argb[0]);
			break;

		case IDC_RECTGRAD_COLOR2:
			UpdateRGBColor(hwnd, IDC_RECTGRAD_PIC2, argb[1]);
			break;

		case IDC_RECTGRAD_COLOR3:
			UpdateRGBColor(hwnd, IDC_RECTGRAD_PIC3, argb[2]);
			break;

		case IDC_RECTGRAD_COLOR4:
			UpdateRGBColor(hwnd, IDC_RECTGRAD_PIC4, argb[3]);
			break;

		case IDC_REFRESH_PIC:
			UpdateColorPicture(hwnd, IDC_RECTGRAD_PIC1, argb[0] & ~Color::AlphaMask);
			UpdateColorPicture(hwnd, IDC_RECTGRAD_PIC2, argb[1] & ~Color::AlphaMask);
			UpdateColorPicture(hwnd, IDC_RECTGRAD_PIC3, argb[2] & ~Color::AlphaMask);	
			UpdateColorPicture(hwnd, IDC_RECTGRAD_PIC4, argb[3] & ~Color::AlphaMask);
			break;

		case IDC_BRUSH_TRANSFORM:
			{
				TestTransform transDlg;
				
				transDlg.Initialize(&matrix);

				transDlg.ChangeSettings(hwnd);
			}
			break;

		case IDC_CANCEL:
			::EndDialog(hwnd, FALSE);
			break;

		default:
			return FALSE;
		}

		return TRUE;
	}

	return FALSE;
}

//*******************************************************************
//
// TestRadialGradBrush
//
//
//
//*******************************************************************

BOOL TestRadialGradBrush :: ChangeSettings(HWND hwndParent)
{
	BOOL ok = DialogBoxParam(hInst,
							MAKEINTRESOURCE(IDD_RADGRAD_DLG),
							hwndParent,
							AllDialogBox,
							(LPARAM)((TestDialogInterface*)this));


	if (ok)
	{
		// initialize a new GDI+ brush with settings
		delete brush;

		Color centerColor(centerARGB);
		Color boundaryColor(boundaryARGB);

		RadialGradientBrush *radBrush 
			  = new RadialGradientBrush(rect,
										centerColor,
										boundaryColor,
										wrapValue[wrapMode]);
		
		radBrush->SetTransform(matrix);
		
		if (blend && blendCount)
			radBrush->SetBlend(blend, blendCount);
		
		brush = radBrush;

		return TRUE;
	}
	
	return FALSE;
};

VOID TestRadialGradBrush :: Initialize()
{
	delete matrix;
	matrix = new Matrix();

	rect.X = rect.Y = 0;
	rect.Width = rect.Height = 100;

	// !! need editing support for these...
	blendCount = 0;
	blend = NULL;

	wrapMode = 0;
	matrix->Reset();

	centerARGB = 0xFFFFFFFF;
	boundaryARGB = 0xFF000000;
	
	Color centerColor(centerARGB);
	Color boundaryColor(boundaryARGB);
	
	delete brush;

	RadialGradientBrush *radBrush =
			new RadialGradientBrush(rect,
									centerColor,
									boundaryColor,
									wrapValue[wrapMode]);

	radBrush->SetTransform(matrix);
	radBrush->SetBlend(blend, blendCount);

	brush = radBrush;
}

VOID TestRadialGradBrush::AddToFile(OutputFile* outfile, INT id)
{
	TCHAR brushStr[MAX_PATH];
	TCHAR matrixStr[MAX_PATH];
	TCHAR rectStr[MAX_PATH];
	TCHAR color1Str[MAX_PATH];
	TCHAR color2Str[MAX_PATH];
	TCHAR blendStr[MAX_PATH];

	if (id)
	{
		_stprintf(&brushStr[0], _T("brush%d"), id);
		_stprintf(&matrixStr[0], _T("matrix%d"), id);
		_stprintf(&rectStr[0], _T("rect%db"), id);
		_stprintf(&color1Str[0], _T("centerColor%db"), id);
		_stprintf(&color2Str[0], _T("boundaryColor%db"), id);
		_stprintf(&blendStr[0], _T("radialBlend%db"), id);
	}
	else
	{
		_tcscpy(&brushStr[0], _T("brush"));
		_tcscpy(&matrixStr[0], _T("matrix"));
		_tcscpy(&rectStr[0], _T("rectb"));
		_tcscpy(&color1Str[0], _T("centerColor"));
		_tcscpy(&color2Str[0], _T("boundaryColor"));
		_tcscpy(&blendStr[0], _T("radialBlend"));
	}

	outfile->ColorDeclaration(&color1Str[0], 
							  &centerARGB,
							  0);

	outfile->BlankLine();

	outfile->ColorDeclaration(&color2Str[0],
							  &boundaryARGB,
							  0);

	outfile->BlankLine();

	outfile->RectangleDeclaration(&rectStr[0],
								  rect);

	outfile->BlankLine();

	outfile->Declaration(_T("RadialGradientBrush"), 
						 &brushStr[0], 
						 _T("%s, %s, %s, %s"),
						 &rectStr[0],
						 &color1Str[0],
						 &color2Str[0],
						 wrapStr[wrapMode]);

	outfile->BlankLine();

	outfile->SetMatrixDeclaration(&brushStr[0], 
								  _T("SetTransform"), 
								  &matrixStr[0],
								  matrix);

	outfile->BlankLine();

	if (blend && blendCount)
	{
		outfile->BlankLine();

		outfile->SetBlendDeclaration(&brushStr[0],
									 _T("SetBlend"),
									 &blendStr[0], 
									 blend, 
									 blendCount);
	}
}

VOID TestRadialGradBrush :: InitDialog(HWND hwnd)
{
	SetDialogReal(hwnd, IDC_RADGRAD_X,		 rect.X);
	SetDialogReal(hwnd, IDC_RADGRAD_Y,		 rect.Y);
	SetDialogReal(hwnd, IDC_RADGRAD_WIDTH,   rect.Width);
	SetDialogReal(hwnd, IDC_RADGRAD_HEIGHT,  rect.Height);

	SetDialogLong(hwnd, IDC_RADGRAD_CENTERALPHA, centerARGB >> Color::AlphaShift);
	SetDialogLong(hwnd, IDC_RADGRAD_BOUNDARYALPHA, boundaryARGB >> Color::AlphaShift);
	
	SetDialogCombo(hwnd, IDC_BRUSH_WRAP, wrapList, numWrap, wrapMode);
}

BOOL TestRadialGradBrush :: SaveValues(HWND hwnd)
{
	BOOL warning = FALSE;

	rect.X = GetDialogReal(hwnd, IDC_RADGRAD_X);
	rect.Y = GetDialogReal(hwnd, IDC_RADGRAD_Y);
	rect.Width = GetDialogReal(hwnd, IDC_RADGRAD_WIDTH);
	rect.Height = GetDialogReal(hwnd, IDC_RADGRAD_HEIGHT);

	centerARGB = (centerARGB & ~Color::AlphaMask)
				| (GetDialogLong(hwnd, IDC_RADGRAD_CENTERALPHA) 
					<< Color::AlphaShift);
	
	boundaryARGB = (boundaryARGB & ~Color::AlphaMask)
				| (GetDialogLong(hwnd, IDC_RADGRAD_BOUNDARYALPHA) 
					<< Color::AlphaShift);

	wrapMode = GetDialogCombo(hwnd, IDC_BRUSH_WRAP);

	return FALSE;
}

BOOL TestRadialGradBrush :: ProcessDialog(HWND hwnd, 
							UINT msg, 
							WPARAM wParam, 
							LPARAM lParam)
{
	if (msg == WM_COMMAND)
	{
		switch(LOWORD(wParam))
		{
		case IDC_OK:
			if (SaveValues(hwnd))
				WarningBeep();
			else
				::EndDialog(hwnd, TRUE);
			break;

		case IDC_RADGRAD_CENTER:
			UpdateRGBColor(hwnd, IDC_RADGRAD_PICC, centerARGB);
			break;

		case IDC_RADGRAD_BOUNDARY:
			UpdateRGBColor(hwnd, IDC_RADGRAD_PICB, boundaryARGB);
			break;

		case IDC_REFRESH_PIC:
			UpdateColorPicture(hwnd, IDC_RADGRAD_PICC, centerARGB & ~Color::AlphaMask);
			UpdateColorPicture(hwnd, IDC_RADGRAD_PICB, boundaryARGB & ~Color::AlphaMask);
			break;
		
		case IDC_BRUSH_TRANSFORM:
			{
				TestTransform transDlg;
				
				transDlg.Initialize(&matrix);

				transDlg.ChangeSettings(hwnd);
			}
			break;

		case IDC_CANCEL:
			::EndDialog(hwnd, FALSE);
			break;

		default:
			return FALSE;
		}

		return TRUE;
	}

	return FALSE;
}

//*******************************************************************
//
// TestTriangleGradBrush
//
//
//
//*******************************************************************

BOOL TestTriangleGradBrush :: ChangeSettings(HWND hwndParent)
{
	BOOL ok = DialogBoxParam(hInst,
							MAKEINTRESOURCE(IDD_TRIGRAD_DLG),
							hwndParent,
							AllDialogBox,
							(LPARAM)((TestDialogInterface*)this));


	if (ok)
	{
		// initialize a new GDI+ brush with settings
		delete brush;

		Color colors[3] =
		{
			Color(argb[0]),
			Color(argb[1]),
			Color(argb[2])
		};

		TriangleGradientBrush *triBrush 
			  = new TriangleGradientBrush(
						(Point*)&pts[0],
						(Color*)&colors[0],
						wrapValue[wrapMode]);

		triBrush->SetTransform(matrix);
		triBrush->SetBlend0(blend[0], count[0]);
		triBrush->SetBlend1(blend[1], count[1]);
		triBrush->SetBlend2(blend[2], count[2]);
		
		brush = triBrush;

		return TRUE;
	}
	
	return FALSE;
};

VOID TestTriangleGradBrush :: Initialize()
{
	delete matrix;
	matrix = new Matrix();

	pts[0].X = 10; pts[0].Y = 10;
	pts[1].X = 90; pts[1].Y = 10;
	pts[2].X = 50; pts[2].Y = 100;

	blend[0] = blend[1] = blend[2] = NULL;
	count[0] = count[1] = count[2] = 0;
		
	argb[0] = 0x80FF0000;
	argb[1] = 0x8000FF00;
	argb[2] = 0x800000FF;
	
	Color colors[3] = 
	{
		Color(argb[0]),
		Color(argb[1]),
		Color(argb[2])
	};

	wrapMode = 0;
	
	delete brush;

	TriangleGradientBrush *triBrush 
		  = new TriangleGradientBrush(
					(Point*)(&pts[0]),
					(Color*)(&colors[0]),
					wrapValue[wrapMode]);

	triBrush->SetTransform(matrix);
	triBrush->SetBlend0(blend[0], count[0]);
	triBrush->SetBlend1(blend[1], count[1]);
	triBrush->SetBlend2(blend[2], count[2]);
		
	brush = triBrush;
}

VOID TestTriangleGradBrush::AddToFile(OutputFile* outfile, INT id)
{
	INT pos;

	TCHAR brushStr[MAX_PATH];
	TCHAR matrixStr[MAX_PATH];
	TCHAR ptsStr[MAX_PATH];
	TCHAR colorsStr[MAX_PATH];
	TCHAR blendStr[3][MAX_PATH];

	if (id)
	{
		_stprintf(&brushStr[0], _T("brush%d"), id);
		_stprintf(&matrixStr[0], _T("matrix%db"), id);
		_stprintf(&ptsStr[0], _T("pts%db"), id);
		_stprintf(&colorsStr[0], _T("colors%db"), id);
		_stprintf(&blendStr[0][0], _T("blend%db01"), id);
		_stprintf(&blendStr[1][0], _T("blend%db12"), id);
		_stprintf(&blendStr[2][0], _T("blend%db20"), id);
	}
	else
	{
		_tcscpy(&brushStr[0], _T("brush"));
		_tcscpy(&brushStr[0], _T("matrixb"));
		_tcscpy(&ptsStr[0], _T("ptsb"));
		_tcscpy(&colorsStr[0], _T("colors"));
		_tcscpy(&blendStr[0][0], _T("blend01"));
		_tcscpy(&blendStr[1][0], _T("blend12"));
		_tcscpy(&blendStr[2][0], _T("blend20"));
	}

	outfile->PointDeclaration(&ptsStr[0],
							  &pts[0],
							  3);

	outfile->BlankLine();

	outfile->ColorDeclaration(&colorsStr[0], 
							  &argb[0],
							  3);

	outfile->BlankLine();

	outfile->Declaration(_T("TriangleGradientBrush"), 
						 &brushStr[0], 
						 _T("%s, %s, %s"),
						 outfile->RefArray(&ptsStr[0]),
						 outfile->RefArray(&colorsStr[0]),
						 wrapStr[wrapMode]);

	outfile->BlankLine();


	outfile->SetMatrixDeclaration(&brushStr[0], 
								  _T("SetTransform"), 
								  &matrixStr[0],
								  matrix);

	if (blend[0] && count[0])
	{
		outfile->BlankLine();
	
		outfile->SetBlendDeclaration(&brushStr[0],
									 _T("SetBlend01"),
									 &blendStr[0][0],
									 blend[0], 
									 count[0]);
	}

	if (blend[1] && count[1])
	{
		outfile->BlankLine();

		outfile->SetBlendDeclaration(&brushStr[0],
									 _T("SetBlend12"),
									 &blendStr[1][0],
									 blend[1], 
									 count[1]);
	}

	if (blend[2] && count[2])
	{
		outfile->BlankLine();

		outfile->SetBlendDeclaration(&brushStr[0],
									 _T("SetBlend20"),
									 &blendStr[2][0],
									 blend[2], 
									 count[2]);
	}
}

VOID TestTriangleGradBrush :: InitDialog(HWND hwnd)
{
	TCHAR tmp[MAX_PATH];

	_stprintf(tmp, "(%.f,%.f)", pts[0].X, pts[0].Y);
	SetDialogText(hwnd, IDC_TRIGRAD_PT1,	&tmp[0], FALSE);
	_stprintf(tmp, "(%.f,%.f)", pts[1].X, pts[1].Y);
	SetDialogText(hwnd, IDC_TRIGRAD_PT2,	&tmp[0], FALSE);
	_stprintf(tmp, "(%.f,%.f)", pts[2].X, pts[2].Y);
	SetDialogText(hwnd, IDC_TRIGRAD_PT3,	&tmp[0], FALSE);
	
	SetDialogCombo(hwnd, IDC_BRUSH_WRAP, wrapList, numWrap, wrapMode);
}

BOOL TestTriangleGradBrush :: SaveValues(HWND hwnd)
{
	BOOL warning = FALSE;

	wrapMode = GetDialogCombo(hwnd, IDC_BRUSH_WRAP);

	return FALSE;
}

BOOL TestTriangleGradBrush :: ProcessDialog(HWND hwnd, 
							UINT msg, 
							WPARAM wParam, 
							LPARAM lParam)
{
	if (msg == WM_COMMAND)
	{
		switch(LOWORD(wParam))
		{
		case IDC_OK:
			if (SaveValues(hwnd))
				WarningBeep();
			else
				::EndDialog(hwnd, TRUE);
			break;

		case IDC_TRIGRAD_BUTTON:
		{
			EnableDialogControl(hwnd, IDC_TRIGRAD_BUTTON, FALSE);

			// create gradient edit shape
			TestTriangleGradShape *triGradShape
				= new TestTriangleGradShape();

			triGradShape->Initialize(&pts[0],
									 &argb[0],
									 (REAL**)&blend,
									 &count[0]);
			
			// create new draw object for window
			// and initialize it with this shape
			TestGradDraw *gradDraw = new TestGradDraw();
			gradDraw->Initialize(triGradShape);

			if (gradDraw->ChangeSettings(hwnd))
			{
				memcpy(&pts[0], 
					   triGradShape->GetPoints(),
					   sizeof(Point)*3);
				
				memcpy(&argb[0],
					   triGradShape->GetARGB(),
					   sizeof(ARGB)*3);

				INT newCount[3];

				memcpy(&newCount[0],
					   triGradShape->GetBlendCount(),
					   sizeof(INT)*3);

				REAL** newBlend = triGradShape->GetBlend();

				for (INT i = 0; i < 3; i++)
				{
					if (count[i] && blend[i])
					{
						count[i] = 0;
						free(blend[i]);
						blend[i] = NULL;
					}

					count[i] = newCount[i];
					blend[i] = (REAL*) malloc(sizeof(REAL)*count[i]);
					memcpy(blend[i], newBlend[i], sizeof(REAL)*count[i]);
				}

				// update points in dialog box
				InitDialog(hwnd);

				// update color pictures
				InvalidateRect(hwnd, NULL, TRUE);

			}  // ChangeSettings(hwnd);

			delete triGradShape;
			delete gradDraw;

			EnableDialogControl(hwnd, IDC_TRIGRAD_BUTTON, TRUE);
			EnableDialogControl(hwnd, IDC_OK, TRUE);
			EnableDialogControl(hwnd, IDC_CANCEL, TRUE);

			// update color pictures if necessary
			UpdateWindow(hwnd);
			InvalidateRect(hwnd, NULL, FALSE);
			break;
		}

		case IDC_REFRESH_PIC:
			UpdateColorPicture(hwnd, IDC_TRIGRAD_PIC1, argb[0] & ~Color::AlphaMask);
			UpdateColorPicture(hwnd, IDC_TRIGRAD_PIC2, argb[1] & ~Color::AlphaMask);
			UpdateColorPicture(hwnd, IDC_TRIGRAD_PIC3, argb[2] & ~Color::AlphaMask);
			break;
		
		case IDC_BRUSH_TRANSFORM:
			{
				TestTransform transDlg;
				
				transDlg.Initialize(&matrix);

				transDlg.ChangeSettings(hwnd);
			}
			break;

		case IDC_CANCEL:
			::EndDialog(hwnd, FALSE);
			break;

		default:
			return FALSE;
		}

		return TRUE;
	}

	return FALSE;
}

//*******************************************************************
//
// TestPathGradBrush
//
//
//
//*******************************************************************

BOOL TestPathGradBrush :: ChangeSettings(HWND hwndParent)
{
	BOOL ok = DialogBoxParam(hInst,
							MAKEINTRESOURCE(IDD_POLYGRAD_DLG),
							hwndParent,
							AllDialogBox,
							(LPARAM)((TestDialogInterface*)this));


	if (ok)
	{
		// initialize a new GDI+ brush with settings
		delete brush;

		PathGradientBrush *polyBrush
			  = new PathGradientBrush((Point*)&pts[1],
										 pts.GetCount()-1);

		polyBrush->SetTransform(matrix);
		polyBrush->SetWrapMode(wrapValue[wrapMode]);

//		polyBrush->SetSurroundBlend(surroundBlend, surroundCount);
		polyBrush->SetBlend(centerBlend, centerCount);

		polyBrush->SetCenterPoint(pts[0]);

		Color centerColor(argb[0]);
		polyBrush->SetCenterColor(argb[0]);

		for (INT pos = 1; pos < argb.GetCount(); pos++)
		{
			Color color(argb[pos]);
			polyBrush->SetSurroundColor(color, pos-1);
		}
		
		brush = polyBrush;

		return TRUE;
	}
	
	return FALSE;
};

VOID TestPathGradBrush :: Initialize()
{
	delete matrix;
	matrix = new Matrix();

	pts.Reset();

	pts.Add(Point(100,100));
	pts.Add(Point(100,50));
	pts.Add(Point(150,150));
	pts.Add(Point(50,150));

    surroundBlend = centerBlend = NULL;
	surroundCount = centerCount = 0;
	
	argb.Reset();

	argb.Add((ARGB)0x80000000);
    argb.Add((ARGB)0x80FF0000);
    argb.Add((ARGB)0x8000FF00);
    argb.Add((ARGB)0x800000FF);

	wrapMode = 0;

	// initialize a new GDI+ brush with settings
	delete brush;

	PathGradientBrush *polyBrush
		  = new PathGradientBrush((Point*)&pts[1],
										 pts.GetCount()-1);

	polyBrush->SetTransform(matrix);
	polyBrush->SetWrapMode(wrapValue[wrapMode]);

	polyBrush->SetCenterPoint(pts[0]);

	Color centerColor(argb[0]);
	polyBrush->SetCenterColor(argb[0]);

	for (INT pos = 1; pos < argb.GetCount(); pos++)
	{
		Color color(argb[pos]);
		polyBrush->SetSurroundColor(color, pos-1);
	}
		
	brush = polyBrush;
}

VOID TestPathGradBrush :: AddToFile(OutputFile* outfile, INT id)
{
	INT pos;

	TCHAR brushStr[MAX_PATH];
	TCHAR matrixStr[MAX_PATH];
	TCHAR ptsStr[MAX_PATH];
	TCHAR colorStr[MAX_PATH];
	TCHAR blendStr[MAX_PATH];

	if (id)
	{
		_stprintf(&brushStr[0], _T("brush%d"), id);
		_stprintf(&matrixStr[0], _T("matrix%d"), id);
		_stprintf(&ptsStr[0], _T("pts%db"), id);
		_stprintf(&colorStr[0], _T("centerColor%db"), id);
		_stprintf(&blendStr[0], _T("radialBlend%db01"), id);
	}
	else
	{
		_tcscpy(&brushStr[0], _T("brush"));
		_tcscpy(&matrixStr[0], _T("matrixb"));
		_tcscpy(&ptsStr[0], _T("ptsb"));
		_tcscpy(&colorStr[0], _T("centerColor"));
		_tcscpy(&blendStr[0], _T("radialBlend"));
	}

	outfile->PointDeclaration(&ptsStr[0],
							  &pts[1],
							  pts.GetCount()-1);

	outfile->BlankLine();

	outfile->Declaration(_T("PathGradientBrush"), 
						 &brushStr[0], 
						 _T("%s, %d, %s"),
						 outfile->RefArray(&ptsStr[0]),
						 pts.GetCount()-1,
						 wrapStr[wrapMode]);

	if (id)
	{
		_stprintf(&ptsStr[0], _T("centerpt%db"), id);
		_stprintf(&colorStr[0], _T("centerColor%db"), id);
	}
	else
	{
		_tcscpy(&ptsStr[0], _T("centerpt"));
		_stprintf(&colorStr[0], _T("centerColor"));
	}

	outfile->BlankLine();

	outfile->SetMatrixDeclaration(&brushStr[0], 
								  _T("SetTransform"), 
								  &matrixStr[0],
								  matrix);

	outfile->BlankLine();

	outfile->SetPointDeclaration(&brushStr[0],
								 _T("SetCenterPoint"),
								 &ptsStr[0],
								 &pts[0]);

	outfile->BlankLine();

	outfile->SetColorDeclaration(&brushStr[0],
								 _T("SetCenterColor"),
								 &colorStr[0], 
								 &argb[0]);

	if (centerBlend && centerCount)
	{
		outfile->BlankLine();
		
		outfile->SetBlendDeclaration(&brushStr[0],
									 _T("SetRadialBlend"),
									 &blendStr[0],
									 centerBlend,
									 centerCount);
	}

	// No surround blend since outer edge blend is fixed by
	// by radial blend

	for (pos = 1; pos < pts.GetCount()-1; pos++)
	{
		if (id)
			_stprintf(&colorStr[0], _T("color%db%d"), id, pos);
		else
			_stprintf(&colorStr[0], _T("color%d"), pos);

		outfile->BlankLine();

		outfile->ColorDeclaration(&colorStr[0],
								  &argb[pos]);

		outfile->ObjectCommand(&brushStr[0],
							   _T("SetSurroundColor"),
							   _T("%s, %d"),
							   &colorStr[0],
							   pos-1);
	}
}

VOID TestPathGradBrush :: InitDialog(HWND hwnd)
{
	TCHAR tmp[MAX_PATH];

	HWND hwndList = GetDlgItem(hwnd, IDC_POLYGRAD_POINTLIST);

	INT count = SendMessage(hwndList, LB_GETCOUNT, 0, 0);

	while (count)
	{
		// remove all items in list and repopulate
		count = SendMessage(hwndList, LB_DELETESTRING, 0, 0);
	}

	for (INT pos = 0; pos < pts.GetCount(); pos++)
	{
		if (!pos)
			_stprintf(tmp,"Center (%.f,%.f), Color=%08X",
					pts[0].X, pts[0].Y, argb[0]);
		else
			_stprintf(tmp,"Point (%.f,%.f), Color=%08X",
					pts[pos].X, pts[pos].Y, argb[pos]);
	
		SendMessage(hwndList, LB_ADDSTRING, 0, (WPARAM)tmp);
	}

	DeleteObject(hwndList);

	SetDialogCombo(hwnd, IDC_BRUSH_WRAP, wrapList, numWrap, wrapMode);
}

BOOL TestPathGradBrush :: SaveValues(HWND hwnd)
{
	BOOL warning = FALSE;

	wrapMode = GetDialogCombo(hwnd, IDC_BRUSH_WRAP);

	return FALSE;
}

BOOL TestPathGradBrush :: ProcessDialog(HWND hwnd, 
							UINT msg, 
							WPARAM wParam, 
							LPARAM lParam)
{
	if (msg == WM_COMMAND)
	{
		switch(LOWORD(wParam))
		{
		case IDC_OK:
			if (SaveValues(hwnd))
				WarningBeep();
			else
				::EndDialog(hwnd, TRUE);
			break;

		case IDC_POLYGRAD_BUTTON:
		{
			EnableDialogControl(hwnd, IDC_POLYGRAD_BUTTON, FALSE);
			EnableDialogControl(hwnd, IDC_OK, FALSE);
			EnableDialogControl(hwnd, IDC_CANCEL, FALSE);
				
			// create gradient edit shape
			TestPathGradShape *polyGradShape
				= new TestPathGradShape();

			polyGradShape->Initialize(&pts,
									 &argb,
									 surroundBlend,
									 surroundCount,
									 centerBlend,
									 centerCount);
			
			// create new draw object for window
			// and initialize it with this shape
			TestGradDraw *gradDraw = new TestGradDraw();
			gradDraw->Initialize(polyGradShape);

			if (gradDraw->ChangeSettings(hwnd))
			{
				pts.Reset();
				argb.Reset();

				pts.AddMultiple(polyGradShape->GetPoints(),
								polyGradShape->GetCount());
				
				argb.AddMultiple(polyGradShape->GetARGB(),
								 polyGradShape->GetCount());

				if (surroundBlend)
					free(surroundBlend);

				if (centerBlend)
					free(centerBlend);

				surroundCount = polyGradShape->GetSurroundBlendCount();
				centerCount = polyGradShape->GetCenterBlendCount();

				if (surroundCount)
				{
					surroundBlend = (REAL*) malloc(sizeof(REAL)*surroundCount);
					memcpy(surroundBlend, polyGradShape->GetSurroundBlend(),
								sizeof(REAL)*surroundCount);
				}
				else
					surroundBlend = NULL;

				if (centerCount)
				{
					centerBlend = (REAL*) malloc(sizeof(REAL)*centerCount);
					memcpy(centerBlend, polyGradShape->GetCenterBlend(),
								sizeof(REAL)*centerCount);
				}
				else
					centerBlend = NULL;

				// update points in dialog box
				InitDialog(hwnd);

				// update color pictures
				InvalidateRect(hwnd, NULL, TRUE);

			}  // ChangeSettings(hwnd);

			delete polyGradShape;
			delete gradDraw;

			EnableDialogControl(hwnd, IDC_POLYGRAD_BUTTON, TRUE);
			EnableDialogControl(hwnd, IDC_OK, TRUE);
			EnableDialogControl(hwnd, IDC_CANCEL, TRUE);

			// update color pictures if necessary
			UpdateWindow(hwnd);
			InvalidateRect(hwnd, NULL, FALSE);
			break;
		}
		
		case IDC_BRUSH_TRANSFORM:
			{
				TestTransform transDlg;
				
				transDlg.Initialize(&matrix);

				transDlg.ChangeSettings(hwnd);
			}
			break;

		case IDC_CANCEL:
			::EndDialog(hwnd, FALSE);
			break;

		default:
			return FALSE;
		}

		return TRUE;
	}

	return FALSE;
}

//*******************************************************************
//
// TestHatchBrush
//
//
//
//*******************************************************************

BOOL TestHatchBrush :: ChangeSettings(HWND hwndParent)
{
	BOOL ok = DialogBoxParam(hInst,
							MAKEINTRESOURCE(IDD_HATCH_DLG),
							hwndParent,
							AllDialogBox,
							(LPARAM)((TestDialogInterface*)this));


	if (ok)
	{
		// initialize a new GDI+ brush with settings
		delete brush;
	
		Color foreColor(foreArgb);
		Color backColor(backArgb);
		hatch = 0;

		brush = new HatchBrush(hatchValue[hatch], 
							   foreColor, 
							   backColor);

		return TRUE;
	}
	
	return FALSE;
};

VOID TestHatchBrush :: Initialize()
{
	foreArgb = 0xFF000000;
	backArgb = 0xFFFFFFFF;

	delete brush;
	
	Color foreColor(foreArgb);
	Color backColor(backArgb);
	hatch = 0;

	brush = new HatchBrush(hatchValue[hatch],
						   foreColor, 
						   backColor);
}

VOID TestHatchBrush::AddToFile(OutputFile* outfile, INT id)
{
	TCHAR brushStr[MAX_PATH];
	TCHAR color1Str[MAX_PATH];
	TCHAR color2Str[MAX_PATH];

	if (id)
	{
		_stprintf(&brushStr[0], _T("brush%d"), id);
		_stprintf(&color1Str[0], _T("foreColor%db"), id);
		_stprintf(&color2Str[0], _T("backColor%db"), id);
	}
	else
	{
		_tcscpy(&brushStr[0], _T("brush"));
		_tcscpy(&color1Str[0], _T("foreColor"));
		_tcscpy(&color2Str[0], _T("backColor"));
	}

	outfile->ColorDeclaration(&color1Str[0], 
							  &foreArgb);

	outfile->BlankLine();

	outfile->ColorDeclaration(&color2Str[0],
							  &backArgb);

	outfile->BlankLine();

	outfile->Declaration(_T("HatchBrush"), 
						 &brushStr[0], 
						 _T("%s, %s, %s"),
						 &color1Str[0],
						 &color2Str[0],
						 hatchStr[hatch]);
}

VOID TestHatchBrush :: InitDialog(HWND hwnd)
{
	SetDialogLong(hwnd, IDC_HATCH_FOREALPHA, 
		foreArgb >> Color::AlphaShift);

	SetDialogLong(hwnd, IDC_HATCH_BACKALPHA,
		backArgb >> Color::AlphaShift);

	SetDialogCombo(hwnd, IDC_HATCH_STYLE, hatchList, numHatch, hatch);
}

BOOL TestHatchBrush :: SaveValues(HWND hwnd)
{
	BOOL warning = FALSE;

	foreArgb = (foreArgb & ~Color::AlphaMask) |
		      (GetDialogLong(hwnd, IDC_HATCH_FOREALPHA) 
				  << Color::AlphaShift);

	backArgb = (backArgb & ~Color::AlphaMask) |
			  (GetDialogLong(hwnd, IDC_HATCH_BACKALPHA)
				  << Color::AlphaShift);

	hatch = GetDialogCombo(hwnd, IDC_HATCH_STYLE);
	
	if (warning)
		InitDialog(hwnd);

	return warning;
}

BOOL TestHatchBrush :: ProcessDialog(HWND hwnd, 
							UINT msg, 
							WPARAM wParam, 
							LPARAM lParam)
{
	if (msg == WM_COMMAND)
	{
		switch(LOWORD(wParam))
		{
		case IDC_OK:
			if (SaveValues(hwnd))
				WarningBeep();
			else
				::EndDialog(hwnd, TRUE);
			break;

		case IDC_HATCH_FORECOLOR:
			UpdateRGBColor(hwnd, IDC_HATCH_FOREPIC, foreArgb);
			break;

		case IDC_HATCH_BACKCOLOR:
			UpdateRGBColor(hwnd, IDC_HATCH_BACKPIC, backArgb);
			break;

		case IDC_REFRESH_PIC:
			UpdateColorPicture(hwnd, IDC_HATCH_FOREPIC, foreArgb);
			UpdateColorPicture(hwnd, IDC_HATCH_BACKPIC, backArgb);
			break;

		case IDC_CANCEL:
			::EndDialog(hwnd, FALSE);
			break;

		default:
			return FALSE;
		}

		return TRUE;
	}

	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\gdiptest\gdipdraw.cpp ===
#include "gdiptest.h"
#include <commctrl.h>


extern const TCHAR* formatExtList = 
					_T("CPP files\0*.cpp\0"
					   "Java files\0*.Java\0"
					   "VML files\0*.vml\0"
					   "All files\0*.*\0");

extern const TCHAR* defaultFormatExt = _T("cpp");

//*******************************************************************
//
// TestDraw
//
//
//
//*******************************************************************

VOID TestDraw::AddPoint(HWND hwnd, Point pt)
{
	if (!curShape)
	{
		// no current shape, create one of appropriate type
		curShape = TestShape::CreateNewShape(shapeType);
		curShape->Initialize(NULL);

		// save copy of brush & pen in shape
		curShape->SetBrush(curBrush->Clone());
		curShape->SetPen(curPen->Clone());
	}
	else if (curShape->IsComplete())
	{
		TestShape *lastShape = curShape;

		// add current shape to shape stack
		shapeStack.Push(curShape);

		// create blank shape of this type
		curShape = TestShape::CreateNewShape(shapeType);
		curShape->Initialize(lastShape);

		// save copy of brush & pen in shape
		curShape->SetBrush(curBrush->Clone());
		curShape->SetPen(curPen->Clone());
	}

	curShape->AddPoint(hwnd, pt);
}

BOOL TestDraw::DoneShape(HWND hwnd)
{
	// we are at regular end point regardless
	if (!curShape->IsComplete())
	{
		// if point can't be treated as an 'end point' then treat
		// it as a regular control point
		curShape->DoneShape(hwnd);
	}

	return curShape->IsComplete();
}

BOOL TestDraw::EndPoint(HWND hwnd, Point pt)
{
	AddPoint(hwnd, pt);
	
	return DoneShape(hwnd);
}

BOOL TestDraw::RemovePoint(HWND hwnd)
{
	if (!curShape || (curShape && !curShape->RemovePoint(hwnd)))
	{
		if (shapeStack.GetCount() > 0)
		{
			// the shape is empty, delete it
			delete curShape;
		
			curShape = shapeStack.Pop();

			// !! reset menu option for current shape
			UpdateStatus();

			return curShape->RemovePoint(hwnd);
		}
	}

	return FALSE;
}

VOID TestDraw::Draw(HWND hwnd)
{
	PAINTSTRUCT ps;
	RECT rt;
	HDC hdc;

	// !!! when CopyPixels work, cache the graphics up to the
	//     last shape.  We blit that, then the new shape begins.

	// posts a WM_ERASEBKGND message
	hdc = BeginPaint(hwnd, &ps);

	/////////////////////////////////////////////////////
	// GDI+ code BEGINS
	////////////////////////////////////////////////////
	Graphics *g = new Graphics(hwnd);

	GetClientRect(hwnd, &rt);
	ERectangle rect(rt.left, 
				   rt.top, 
				   rt.right-rt.left, 
				   rt.bottom-rt.top
				   -18);	// for status window

	// set appropriate clip region
	if (useClip)
	{
		Region region(rect);
		region.And(clipRegion);
		g->SetClip(&region);
	}
	else
	{
		g->SetClip(rect);
	}

	g->SetRenderingHint(antiAlias);

	g->SetWorldTransform(worldMatrix);

	// !!! iterate through stack of shapes.

	// because of alpha we can't just redraw the last shape,
	// otherwise we will blend alpha with ourself and whatever
	// else is under us.  clear the rectangle and redraw all.

	if (redrawAll)
	{
		INT count = shapeStack.GetCount();
		INT pos;
		
		for (pos=0; pos<count; pos++)
		{
			TestShape *shape = shapeStack[pos];
			
			if (!shape->GetDisabled())
			{
				// shape must be complete
				ASSERT(shape->IsComplete());

				shape->DrawShape(g);
	
				if (keepControlPoints)
					shape->DrawPoints(g);
			}
		}
	}

	if (curShape)
	{
		if (curShape->IsComplete())
		{
			curShape->DrawShape(g);

			if (keepControlPoints)
				goto DrawCurShape;
		}
		else
		{
DrawCurShape:
			g->SetClip(rect);
			curShape->DrawPoints(g);
		}
	}
	
	delete g;

	////////////////////////////////////////////////////
	// GDI+ code ENDS.
	////////////////////////////////////////////////////

	UpdateStatus();

	EndPaint(hwnd, &ps);

}

VOID TestDraw::SetClipRegion(HWND hwnd)
{

	if (!curShape)
	{
		WarningBox(_T("Create at least one shape first!"));
		return;
	}

	// we want to allow the very last shape to clip
	// so we add it in here to the stack list.
	if (curShape->IsComplete())
	{
		TestShape *lastShape = curShape;

		// add current shape to shape stack
		shapeStack.Push(curShape);

		// create blank shape of this type
		curShape = TestShape::CreateNewShape(shapeType);
		curShape->Initialize(lastShape);

		// save copy of brush & pen in shape
		curShape->SetBrush(curBrush->Clone());
		curShape->SetPen(curPen->Clone());
	}

	// notice we repeatly initialize even though we only
	// created this once...
	clipShapeRegion->Initialize(&shapeStack, curShape, useClip);

	if (clipShapeRegion->ChangeSettings(hwnd))
	{
		delete clipRegion;
		clipRegion = clipShapeRegion->GetClipRegion();

		useClip = clipShapeRegion->GetClipBool();
	
		SetMenuCheckCmd(hwnd, 
						MenuOtherPosition, 
						IDM_USECLIP, 
						useClip);

		// force redraw of all stacked shapes w/new clip region
		InvalidateRect(hwnd, NULL, TRUE);
		UpdateWindow(hwnd);
	}

	UpdateStatus();
}

VOID TestDraw::RememberPoint(Point pt)
{
	remPoint = pt;
}

VOID TestDraw::MoveControlPoint(Point pt)
{
	// find shape that hits control point.

	Point *hitpt = NULL;
	
	if (curShape)
	{
		if (curShape->MoveControlPoint(remPoint, pt))
			return;
		
		INT count = shapeStack.GetCount();
		INT pos;

		for (pos = count-1; pos>=0; pos--)
		{
			TestShape* shape = shapeStack[pos];

			if (shape->MoveControlPoint(remPoint, pt))
				return;
		}
	}

	// nothing moved
	WarningBeep();
}

VOID TestDraw::ChangeBrush(HWND hwnd, INT type)
{
	TestBrush *newBrush = NULL;

	if (curBrush && (type == curBrush->GetType()))
	{
		// same brush type

		// !!! change brush color in middle of drawing?

		TestBrush* newBrush = curBrush->Clone();

		if (newBrush->ChangeSettings(hwnd))
		{
			delete curBrush;
			curBrush = newBrush;
		}
	}
	else
	{
		// new brush type		
		
		SetMenuCheckPos(hwnd, 
						MenuBrushPosition, 
						curBrush->GetType(), 
						FALSE);

		newBrush = TestBrush::CreateNewBrush(type);

		if (!newBrush)
		{
			return;
		}

		newBrush->Initialize();
		
		// keep or discard changed brush settings
		if (newBrush->ChangeSettings(hwnd))
		{
			delete curBrush;
			curBrush = newBrush;
			// !!! change brush color in middle of drawing
		}
		else
		{	
			delete newBrush;
		}

		SetMenuCheckPos(hwnd, 
						MenuBrushPosition, 
						curBrush->GetType(), 
						TRUE);
	}

	if (curShape && curShape->GetCount() == 0)
	{
		curShape->SetBrush(curBrush->Clone());
	}

	UpdateStatus();
}

VOID TestDraw::ChangePen(HWND hwnd)
{
	TestPen *newPen = NULL;

	if (curPen)
	{
		TestPen *newPen = curPen->Clone();

		if (newPen->ChangeSettings(hwnd))
		{
			delete curPen;
			curPen = newPen;
		}
	}
	else
	{
		newPen = new TestPen();
		newPen->Initialize();

		// !!! change pen in middle of drawing?
		if (newPen->ChangeSettings(hwnd))
		{
			delete curPen;
			curPen = newPen;
		}
		else
		{
			delete newPen;
		}
	}

	if (curShape && curShape->GetCount() == 0)
	{
		curShape->SetPen(curPen->Clone());
	}

	UpdateStatus();
}

VOID TestDraw::ChangeShape(HWND hwnd, INT type)
{
	TestShape *shape;
	
	shape = TestShape::CreateNewShape(type);
	shape->Initialize(curShape);

	// save copy of brush & pen in shape
	shape->SetBrush(curBrush->Clone());
	shape->SetPen(curPen->Clone());

	if (shape->ChangeSettings(hwnd))
	{
		SetMenuCheckPos(hwnd, 
						MenuShapePosition, 
						shapeType, 
						FALSE);

		shapeType = type;

		// if shape can be completed, complete it, otherwise
		// destroy the shape.

		if (curShape)
		{
			if (!curShape->IsComplete())
			{
				curShape->DoneShape(hwnd);
			}

			if (!curShape->IsComplete() || curShape->IsEmpty())
			{
				delete curShape;
				curShape = NULL;
			}
		}

		if (curShape)
			shapeStack.Add(curShape);

		curShape = shape;

		SetMenuCheckPos(hwnd, 
						MenuShapePosition, 
						shapeType, 
						TRUE);
		
		// removing last incomplete shape, redraw the window.
		// OR completed shape, redraw the window
		InvalidateRect(hwnd, NULL, TRUE);
		UpdateWindow(hwnd);
	}
	else
	{
		delete shape;
	}

	UpdateStatus();
}

VOID TestDraw :: UpdateStatus(HWND hwnd)
{
	if (hwnd)
	{
		
		if (hwndStatus)
		{
			// destroy previous window
			DestroyWindow(hwndStatus);
			hwndStatus = NULL;
		}

		// we only want to destroy this window
		if (hwnd == (HWND)-1)
			return;

		hwndStatus = CreateStatusWindow(WS_CHILD | WS_VISIBLE,
										_T(""),
										hwnd,
										0);		// never used?
	}

	if (hwndStatus)
	{
		TCHAR str[MAX_PATH];
		
		_stprintf(&str[0],"[Last shape: %s] [Brush: %s] [Number of Points: %d]",
				shapeList[inverseShapeValue[GetShapeType()]],
				brushList[inverseBrushValue[GetBrushType()]],
				curShape ? curShape->GetCount() : 0);

		// !! for some reason, DrawStatusText didn't work here...
		//    wouldn't it just call SendMessage() ?!?

		SendMessage(hwndStatus, SB_SETTEXT, 0 | 0, (LPARAM)(LPTSTR)str);
	}
}

VOID TestDraw :: SaveAsFile(HWND hWnd)
{
	static TCHAR fname[MAX_PATH] = _T("");

	OPENFILENAME ofn =
	{
		sizeof(OPENFILENAME),
		hWnd,
		0,
		formatExtList,
		NULL,
		0,
		1,
		&fname[0],
		MAX_PATH-1,
		NULL,
		0,
		NULL,
		NULL,
		OFN_PATHMUSTEXIST,
		0,
		0,
		defaultFormatExt,
		NULL,
		NULL,
		NULL
	};

	if ((GetSaveFileName(&ofn) == TRUE) &&
			fname[0] != '\0')
	{
		OutputFile* outfile = OutputFile::CreateOutputFile(fname);
		
		if (outfile)
		{
			outfile->GraphicsProcedure();
			
			outfile->BeginIndent();
			
			outfile->GraphicsDeclaration();
			
			outfile->BlankLine();

			outfile->SetMatrixDeclaration(_T("g"),
										  _T("SetWorldTransform"),
										  _T("worldMatrix"),
										  worldMatrix);

			INT count = shapeStack.GetCount();
		
			for (INT pos=0; pos<count; pos++)
			{
				TestShape *shape = shapeStack[pos];
				ASSERT(shape->IsComplete());

				outfile->BlankLine();

				outfile->BeginIndent();

				shape->AddToFile(outfile);

				outfile->EndIndent();
			}

			if (curShape && curShape->IsComplete())
			{
				outfile->BlankLine();

				outfile->BeginIndent();

				curShape->AddToFile(outfile);

				outfile->EndIndent();
			}

			outfile->EndIndent();

			delete outfile;

			WarningBox(_T("Graphics source code saved."));
		}
		else
			WarningBox(_T("Can't create file for writing."));
	}

	UpdateStatus();
}

//*******************************************************************
//
// TestGradDraw
//
//
//
//*******************************************************************

VOID TestGradDraw::AddPoint(HWND hwnd, Point pt)
{
	gradShape->AddPoint(hwnd, pt);
}

BOOL TestGradDraw::DoneShape(HWND hwnd)
{
	// pop-up dialog box to configure point parameters
	gradShape->DoneShape(hwnd);

	return TRUE;
}

BOOL TestGradDraw::EndPoint(HWND hwnd, Point pt)
{
	return gradShape->EndPoint(hwnd, pt);
}

BOOL TestGradDraw::RemovePoint(HWND hwnd)
{
	return gradShape->RemovePoint(hwnd);
}

VOID TestGradDraw::Draw(HWND hwnd)
{
	PAINTSTRUCT ps;
	RECT rt;
	HDC hdc;

	// !!! when CopyPixels work, cache the graphics up to the
	//     last shape.  We blit that, then the new shape begins.

	hdc = BeginPaint(hwnd, &ps);

	/////////////////////////////////////////////////////
	// GDI+ code BEGINS
	////////////////////////////////////////////////////
	Graphics *g = new Graphics(hwnd);

	GetClientRect(hwnd, &rt);
	ERectangle rect(rt.left, 
				   rt.top, 
				   rt.right-rt.left, 
				   rt.bottom-rt.top);
	g->SetClip(rect);
	
	g->SetRenderingHint(TRUE);

	gradShape->DrawShape(g);
	gradShape->DrawPoints(g);
	
	delete g;

	////////////////////////////////////////////////////
	// GDI+ code ENDS.
	////////////////////////////////////////////////////

	EndPaint(hwnd, &ps);
}

VOID TestGradDraw::SetClipRegion(HWND hwnd)
{
}

VOID TestGradDraw::RememberPoint(Point pt)
{
	remPoint = pt;
}

VOID TestGradDraw::MoveControlPoint(Point pt)
{
	if (!gradShape->MoveControlPoint(remPoint, pt))
		WarningBeep();
}

VOID TestGradDraw :: UpdateStatus(HWND hwnd)
{
}

VOID TestGradDraw :: SaveAsFile(HWND hwnd)
{
}

BOOL TestGradDraw :: ChangeSettings(HWND hwndParent)
{
	HWND hWnd;
	MSG msg;
	
	HMENU hMenu = LoadMenu(hInst, 
						MAKEINTRESOURCE(IDR_GRADBRUSH));

	hWnd = CreateWindow(
			szWindowClass, 
			_T("Gradient Brush Shape"), 
			WS_OVERLAPPEDWINDOW | WS_VISIBLE,
			CW_USEDEFAULT, 
			CW_USEDEFAULT, 
			300, 
			200, 
			(HWND)hwndParent, 
			(HMENU)hMenu,							// menu handle
			(HINSTANCE)hInst, 
			(LPVOID)(static_cast<TestDrawInterface*>(this)));

    if (!hWnd)
    {
        return FALSE;
    }

    ShowWindow(hWnd, SW_SHOWNORMAL);
    UpdateWindow(hWnd);

	HACCEL hAccelTable = LoadAccelerators(hInst, (LPCTSTR)IDC_GDIPTEST);

   	// Main message loop:
	while (GetMessage(&msg, NULL, 0, 0)) 
	{
		if (!TranslateAccelerator(msg.hwnd, hAccelTable, &msg)) 
		{
			TranslateMessage(&msg);
			DispatchMessage(&msg);
		}
	}

	DeleteObject(hAccelTable);

	return msg.wParam;
}

VOID TestGradDraw::Initialize()
{
	DebugBreak();
}

VOID TestGradDraw::Initialize(TestGradShape *newGradShape)
{
	gradShape = newGradShape;
}

VOID TestGradDraw::Reset(HWND hwnd)
{
	NotImplementedBox();
}

VOID TestGradDraw::Instructions(HWND hwnd)
{
	NotImplementedBox();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\gdiptest\gdipoutput.cpp ===
#include "gdiptest.h"

//*******************************************************************
//
// OutputFile
//
//
//
//*******************************************************************

OutputFile* OutputFile :: CreateOutputFile(LPTSTR filename)
{
	// convert to upper case & verify file extension
	TCHAR tmpStr[MAX_PATH];
	_tcscpy(&tmpStr[0], filename);
	_tcsupr(&tmpStr[0]);
		
	LPTSTR ext = &tmpStr[0] + _tcslen(&tmpStr[0]) - 3;
	INT formatType = -1;

	FILE* outfile = _tfopen(filename, _T("w"));

	if (!outfile)
	{
		WarningBox(_T("Can't create the output file."));
		return NULL;
	}

	if (!_tcscmp(ext, _T("CPP")) || 
		!_tcscmp(ext, _T("C")) ||
		!_tcscmp(ext, _T("CXX")))
		return new CPPOutputFile(outfile);
	else if (!_tcscmp(ext, _T("JAVA")))
		return new JavaOutputFile(outfile);
	else if (!_tcscmp(ext, _T("VML")))
		return new VMLOutputFile(outfile);
	else
	{
		WarningBox(_T("Unrecognized file type (.cpp, .c, .cxx, .Java, .vml)"));
		return NULL;
	}
}

//*******************************************************************
//
// CPPOutputFile
//
//
//
//*******************************************************************

VOID CPPOutputFile :: GraphicsProcedure()
{
	_ftprintf(outfile, _T("VOID DoGraphicsTest(HWND hWnd)\n"));
}

VOID CPPOutputFile :: GraphicsDeclaration()
{
	_ftprintf(outfile, _T("%*sGraphics g(hWnd);\n"),
					   4, 
					   _T(""));
}

VOID CPPOutputFile :: PointDeclaration(LPCTSTR pointName, Point* pts, INT count)
{
	if (count < 0)
		_ftprintf(outfile, 
				  _T("%sPoint %s(%e, %e);\n"),
				  tabStr, 
				  pointName, 
				  pts->X, 
				  pts->Y);
	else
	{
		_ftprintf(outfile,
				  _T("%sPoint %s[%d];\n"),
				  tabStr, 
				  pointName, 
				  count);
		for (INT pos=0; pos<count; pos++, pts++)
			_ftprintf(outfile,
					  _T("%s%s[%d].X=%e; %s[%d].Y=%e;\n"),
					  tabStr, pointName, pos, pts->X, pointName, pos, pts->Y);
	}
}

VOID CPPOutputFile :: ColorDeclaration(LPCTSTR colorName, ARGB* argb, INT count)
{
	if (count < 0)
		_ftprintf(outfile, 
				  _T("%sColor %s(0x%08X);\n"),
				  tabStr, 
				  colorName, 
				  *argb);
	else
	{
		_ftprintf(outfile,
				  _T("%sColor %s[%d];\n"),
				  tabStr, 
				  colorName, 
				  count);
		for (INT pos=0; pos<count; pos++, argb++)
			_ftprintf(outfile,
					  _T("%s%s[%d] = Color(0x%08X);\n"),
					  tabStr, 
					  colorName, 
					  pos, 
					  *argb);
	}
}

VOID CPPOutputFile :: RectangleDeclaration(LPCTSTR rectName, ERectangle& rect)
{
	_ftprintf(outfile, 
			  _T("%sERectangle %s(%e, %e, \n"
			     "%s%*s%e, %e);\n"),
			  tabStr, 
			  rectName, 
			  rect.X, 
			  rect.Y,
			  tabStr,
			  12 + _tcslen(rectName),
			  _T(""),
			  rect.Width, 
			  rect.Height);
}

VOID CPPOutputFile :: Declaration(LPCTSTR type,
					     LPCTSTR object,
					     LPCTSTR argList,
						 ...) 
{
	TCHAR declArgs[MAX_PATH];
	va_list args;
	
	va_start (args, argList);
	_vstprintf(&declArgs[0], argList, args);
	va_end (args);

	_ftprintf(outfile,
			  _T("%s%s %s(%s);\n"),
			  tabStr,
			  type,
			  object,
			  declArgs);
}

// set matrix, do nothing if identity matrix
VOID CPPOutputFile :: SetPointDeclaration(LPCTSTR object,
								 LPCTSTR command,
								 LPCTSTR varName,
								 Point* pts,
								 INT count,
								 BOOL ref) 
{
	if (count < 0)
	{
		_ftprintf(outfile, 
				  _T("%sPoint %s(%e, %e);\n"),
				  tabStr, 
				  varName, 
				  pts->X, 
				  pts->Y);
		_ftprintf(outfile,
				  _T("%s%s.%s(%s);\n"),
				  tabStr,
				  object,
				  command,
				  ref ? Ref(_T(varName)) : varName);
	}
	else
	{
		_ftprintf(outfile,
				  _T("%sPoint %s[%d];\n"),
				  tabStr, 
				  varName, 
				  count);
		for (INT pos=0; pos<count; pos++, pts++)
			_ftprintf(outfile,
					  _T("%s%s[%d].X=%e; %s[%d].Y=%e;\n"),
					  tabStr, 
					  varName, 
					  pos, 
					  pts->X, 
					  varName, 
					  pos, 
					  pts->Y);
		_ftprintf(outfile,
				  _T("%s%s.%s(%s);\n"),
				  tabStr,
				  object,
				  command,
				  RefArray(varName));	
	}
}
	
VOID CPPOutputFile :: SetColorDeclaration(LPCTSTR object,
								 LPCTSTR command,
								 LPCTSTR varName,
								 ARGB* colors,
								 INT count,
								 BOOL ref) 
{
	if (count < 0)
	{
		_ftprintf(outfile, 
				  _T("%sColor %s(0x%08X);\n"),
				  tabStr, 
				  varName, 
				  *colors);
		_ftprintf(outfile,
				  _T("%s%s.%s(%s%s);\n"),
				  tabStr,
				  object,
				  command,
				  ref ? _T("&") : _T(""),
				  varName);	
	}
	else
	{
		_ftprintf(outfile,
				  _T("%sColor %s[%d];\n"),
				  tabStr, 
				  varName, 
				  count);
		for (INT pos=0; pos<count; pos++, colors++)
			_ftprintf(outfile,
					  _T("%s%s[%d] = Color(0x%08X);\n"),
					  tabStr, 
					  varName, 
					  pos, 
					  *colors);
		_ftprintf(outfile,
				  _T("%s%s.%s(&%s[0]);\n"),
				  tabStr,
				  object,
				  command,
				  varName);	
	}
}

VOID CPPOutputFile :: SetMatrixDeclaration(LPCTSTR object,
								  LPCTSTR command,
								  LPCTSTR varName,
								  Matrix* matrix) 
{
	REAL m[6];

	if (matrix->IsIdentity())
	{
		_ftprintf(outfile,
				  _T("%s// identity matrix transform\n"),
				  tabStr);
		return;
	}
	
	matrix->GetElements(&m[0]);

	_ftprintf(outfile,
			  _T("%sMatrix %s(%e, %e, %e, \n"
			     "%s%*s%e, %e, %e);\n"),
			  tabStr,
			  varName,
			  m[0],
			  m[1],
			  m[2],
			  tabStr,
			  8 + _tcslen(varName),
			  _T(""),
			  m[3],
			  m[4],
			  m[5]);
	_ftprintf(outfile,
			  _T("%s%s.%s(&%s);\n"),
			  tabStr,
			  object,
			  command,
			  varName);
}

VOID CPPOutputFile :: SetBlendDeclaration(LPCTSTR object,
								 LPCTSTR command,
								 LPCTSTR varName,
								 REAL* blend,
								 INT count)
{
	_ftprintf(outfile,
			  _T("%sREAL %s[%d];\n"),
			  tabStr, 
			  varName, 
			  count);
	for (INT pos=0; pos<count; pos++, blend++)
		_ftprintf(outfile,
				  _T("%s%s[%d] = %e;\n"),
				  tabStr, 
				  varName, 
				  pos, 
				  *blend);
	_ftprintf(outfile,
			  _T("%s%s.%s(&%s[0]);\n"),
			  tabStr,
			  object,
			  command,
			  varName);	
}

VOID CPPOutputFile :: GraphicsCommand(LPCTSTR command,
			 				 LPCTSTR argList,
							 ...) 
{
	TCHAR declArgs[MAX_PATH];
	va_list args;
	
	va_start (args, argList);
	_vstprintf(&declArgs[0], argList, args);
	va_end (args);

	_ftprintf(outfile,
			  _T("%sg.%s(%s);\n"),
			  tabStr,
			  command,
			  declArgs);
}

VOID CPPOutputFile :: ObjectCommand(LPCTSTR object,
						   LPCTSTR command,
						   LPCTSTR argList,
						   ...) 
{
	TCHAR declArgs[MAX_PATH];
	va_list args;
	
	va_start (args, argList);
	_vstprintf(&declArgs[0], argList, args);
	va_end (args);

	_ftprintf(outfile,
			  _T("%s%s.%s(%s);\n"),
			  tabStr,
			  object,
			  command,
			  declArgs);
}

VOID CPPOutputFile :: BeginIndent()
{
	TCHAR tmp[MAX_PATH];

	_ftprintf(outfile, _T("%s{\n"), tabStr);
	tabs++;
	_stprintf(&tmp[0], "%%%ds", tabs*4);
	_stprintf(&tabStr[0], &tmp[0], _T(""));
}

VOID CPPOutputFile :: EndIndent()
{
	TCHAR tmp[MAX_PATH];

	tabs--;
	_stprintf(&tmp[0], "%%%ds", tabs*4);
	_stprintf(&tabStr[0], &tmp[0], _T(""));
	_ftprintf(outfile, _T("%s}\n"), tabStr);
}

VOID CPPOutputFile :: BlankLine() 
{
	_ftprintf(outfile, _T("\n"));
}

LPTSTR CPPOutputFile :: Ref(LPCTSTR refStr)
{
	static TCHAR tmpStr[3][MAX_PATH];
	static INT pos = 0;

	_stprintf(&tmpStr[pos % 3][0], "&%s", refStr);
		
	pos++;

	return &tmpStr[(pos-1) % 3][0];
}

LPTSTR CPPOutputFile :: RefArray(LPCTSTR refStr)
{
	static TCHAR tmpStr[3][MAX_PATH];
	static INT pos = 0;

	_stprintf(&tmpStr[pos % 3][0], "&%s[0]", refStr);
		
	pos++;

	return &tmpStr[(pos-1) % 3][0];
}

LPTSTR CPPOutputFile :: WStr(LPCTSTR refStr)
{
	static TCHAR tmpStr[3][MAX_PATH];
	static INT pos = 0;
	TCHAR tmpSlash[MAX_PATH];
	INT cnt, cntpos = 0;

	// convert single slashes to double slashes
	for (cnt = 0; cnt < _tcslen(refStr)+1; cnt++)
		if (refStr[cnt] == '\\')
		{
			tmpSlash[cntpos++] = '\\';
			tmpSlash[cntpos++] = '\\';
		}
		else
			tmpSlash[cntpos++] = refStr[cnt];

	_stprintf(&tmpStr[pos % 3][0], "L\"%s\"", tmpSlash);
		
	pos++;

	return &tmpStr[(pos-1) % 3][0];
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\gdiptest\gdipdraw.h ===
#ifndef GDIPDRAW_H
#define GDIPDRAW_H

// drawing context information 

class TestDrawInterface
{
public:
	// manipulate the current shape
	virtual VOID AddPoint(HWND hwnd, Point pt) = 0;
	virtual BOOL DoneShape(HWND hwnd) = 0;
	virtual BOOL EndPoint(HWND hwnd, Point pt) = 0;
	virtual BOOL RemovePoint(HWND hwnd) = 0;

	// draw all shapes
	virtual VOID Draw(HWND hwnd) = 0;
	virtual VOID SetClipRegion(HWND hwnd) = 0;

	// move around a control point
	virtual VOID RememberPoint(Point pt) = 0;
	virtual VOID MoveControlPoint(Point pt) = 0;
	
	// status window
	virtual VOID UpdateStatus(HWND hwnd = NULL) = 0;
	virtual VOID SaveAsFile(HWND hwnd) = 0;
};

class TestDraw : public TestDrawInterface
{
public:
	TestDraw() : curBrush(NULL), 
				 curPen(NULL), 
				 curShape(NULL),
				 clipShapeRegion(NULL),
				 shapeType(LineType),
				 redrawAll(FALSE),
				 keepControlPoints(FALSE),
				 antiAlias(FALSE),
				 useClip(FALSE)
	{
		// !! initialize in sync with menu choices
		curBrush = new TestSolidBrush();
		curBrush->Initialize();

		curPen = new TestPen();
		curPen->Initialize();

		clipShapeRegion = new TestShapeRegion();

		worldMatrix = new Matrix();
		hwndStatus = NULL;

		// !! infinite default may change??
		clipRegion = new Region();
		clipRegion->SetInfinite();
	}

	~TestDraw()
	{
		delete curBrush;
		delete curPen;
		delete curShape;
		delete clipShapeRegion;
		delete worldMatrix;
		delete clipRegion;
	}

	// manipulate the current shape
	virtual VOID AddPoint(HWND hwnd, Point pt);
	virtual BOOL DoneShape(HWND hwnd);
	virtual BOOL EndPoint(HWND hwnd, Point pt);
	virtual BOOL RemovePoint(HWND hwnd);

	// draw all shapes
	virtual VOID Draw(HWND hwnd);
	virtual VOID SetClipRegion(HWND hwnd);

	// move around a control point
	virtual VOID RememberPoint(Point pt);
	virtual VOID MoveControlPoint(Point pt);

	// status window
	virtual VOID UpdateStatus(HWND hwnd = NULL);
	virtual VOID SaveAsFile(HWND hwnd);
	
	VOID ChangeBrush(HWND hwnd, INT type);
	VOID ChangePen(HWND hwnd);
	VOID ChangeShape(HWND hwnd, INT type);

	INT GetBrushType()
	{
		if (!curBrush)
			return SolidColorBrush;
		else if (curShape && curShape->GetCount() > 0)
			return curShape->GetBrush()->GetType();
		else
			return curBrush->GetType();
	}

	INT GetPenType()
	{
		return 0;
	}

	INT GetShapeType()
	{
		if (curShape && curShape->GetCount() > 0)
			return curShape->GetType();
		else
			return shapeType;
	}

	Matrix* GetWorldMatrix()
	{
		return worldMatrix;
	}

	VOID SetWorldMatrix(Matrix* newMatrix)
	{
		delete worldMatrix;
		worldMatrix = newMatrix->Clone();
	}

	// make public to avoid get/set methods
public:
	BOOL redrawAll;
	BOOL keepControlPoints;
	BOOL antiAlias;
	BOOL useClip;

private:
	TestBrush *curBrush;
	TestPen *curPen;

	INT shapeType;
	TestShape *curShape;
	ShapeStack shapeStack;

	Matrix *worldMatrix;
	Region *clipRegion;

	TestShapeRegion *clipShapeRegion;

	Point remPoint;

	HWND hwndStatus;
};

class TestGradDraw : public TestDrawInterface,
					 public TestConfigureInterface
{
public:
	TestGradDraw() : gradShape(NULL) {};

	~TestGradDraw()
	{
		// caller's responsible to delete gradShape
	}

	// manipulate the current shape
	virtual VOID AddPoint(HWND hwnd, Point pt);
	virtual BOOL DoneShape(HWND hwnd);
	virtual BOOL EndPoint(HWND hwnd, Point pt);
	virtual BOOL RemovePoint(HWND hwnd);

	// draw all shapes
	virtual VOID Draw(HWND hwnd);
	virtual VOID SetClipRegion(HWND hwnd);

	// move around a control point
	virtual VOID RememberPoint(Point pt);
	virtual VOID MoveControlPoint(Point pt);

	// status window
	virtual VOID UpdateStatus(HWND hwnd = NULL);
	virtual VOID SaveAsFile(HWND hwnd);

	// configuration management interface
	// initializes/creates the test draw window
	BOOL ChangeSettings(HWND hwnd);
	VOID Initialize();
	VOID Initialize(TestGradShape *gradShape);

	/////////////////////////////////////////////////////////////////
	// Optional supported menu items

	virtual VOID Reset(HWND hwnd);
	virtual VOID Instructions(HWND hwnd);

private:
	TestGradShape *gradShape;

	Point remPoint;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\gdiptest\gdippen.hpp ===
#ifndef _GDIPPEN_HPP
#define _GDIPPEN_HPP

class TestPenInterface : public TestConfigureInterface,
						 public TestDialogInterface
{
public:
	// acquire brush object
	virtual Pen* GetPen() { return pen; };

	// output pen setup to File
	virtual VOID AddToFile(OutputFile* outfile, INT id = 0) = 0;

	~TestPenInterface()
	{
		delete pen;
	}

protected:
	// pointer to underlying GDI+ brush object
	Pen *pen;
};

class TestPen : public TestPenInterface
{
public:
	TestPen()
	{
	    pen = NULL;
		brush = NULL;
		tempBrush = NULL;
	}

	// Configuration Interface
	virtual BOOL ChangeSettings(HWND hwnd);
	virtual VOID Initialize();

	// Dialog Management Interface
	virtual	VOID InitDialog(HWND hwnd);
	virtual BOOL SaveValues(HWND hwnd);
	virtual BOOL ProcessDialog(HWND hwnd, 
					UINT msg, 
					WPARAM wParam, 
					LPARAM lParam);

	// output pen setup to File
	virtual VOID AddToFile(OutputFile* outfile, INT id = 0);

	virtual TestPen* Clone() 
	{
		TestPen *newPen = new TestPen();
		*newPen = *this;					// bitwise copy
		
		if (pen)
			newPen->pen = pen->Clone();	
		
		if (brush)	
			newPen->brush = brush->Clone();

		if (tempBrush)
			newPen->tempBrush = tempBrush->Clone();
		
		return newPen;
	};

protected:
	// helper routine to toggle enable/disable of brush
	VOID EnableBrushFields(HWND hwnd, BOOL enable = TRUE);

private:
	// tempBrush should be NULL unless we are changing settings
	TestBrush *brush, *tempBrush;
	INT brushSelect, tempBrushSelect;
	BOOL useBrush;

	ARGB argb;
	REAL width;
	INT startCap, endCap, dashCap;
	INT lineJoin;
	REAL miterLimit;
	INT dashStyle;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\gdiptest\gdiptest.h ===
#ifndef _GDIPTEST_H
#define _GDIPTEST_H

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <winuser.h>
#include <tchar.h>
#include <math.h>
#include <commdlg.h>
#include <commctrl.h>
#include <float.h>

// not used
#undef IStream
#define IStream int

#include <gdiplus.hpp>

using namespace Gdiplus;

#include "resource.h"

// needed for dynamic array support
#include "debug.h"
#include "runtime.hpp"
#include "dynarrayimpl.hpp"
#include "dynarray.hpp"

#include "gdiputils.h"
#include "gdipoutput.hpp"
#include "gdipbrush.hpp"
#include "gdippen.hpp"
#include "gdipshape.hpp"
#include "gdipclip.h"
#include "gdipdraw.h"

#endif // _GDIPTEST_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\gdiptest\gdiptest.cpp ===
// gdipdraw.cpp : Defines the entry point for the application.
//

#include "stdafx.h"
#include "gdiptest.h"

#pragma hdrstop
// end of precompiled header segment

//using namespace Gdiplus;

// Global Variables:
HINSTANCE hInst;								// current instance
TCHAR szTitle[MAX_LOADSTRING];								// The title bar text
TCHAR szWindowClass[MAX_LOADSTRING];								// The title bar text

int APIENTRY WinMain(HINSTANCE hInstance,
                     HINSTANCE hPrevInstance,
                     LPSTR     lpCmdLine,
                     int       nCmdShow)
{
	MSG msg;
	HACCEL hAccelTable;
	HWND hWnd;

	// Initialize global strings
	LoadString(hInstance, IDS_APP_TITLE, szTitle, MAX_LOADSTRING);
	LoadString(hInstance, IDC_GDIPTEST, szWindowClass, MAX_LOADSTRING);
	MyRegisterClass(hInstance);

	TestDraw draw;

	// Perform application initialization:
	hWnd = InitInstance (hInstance, nCmdShow, 
				(LPVOID)(static_cast<TestDrawInterface*>(&draw)));

	if (hWnd == (HWND)0)
	{
		return FALSE;
	}

	// initialize global control point colors
	blackColor = new Color(0x80, 0, 0, 0);
	blackBrush = new SolidBrush(*blackColor);
	blackPen = new Pen(*blackColor, 5.0f);

	Color whiteColor(0xFFFFFFFF);
	backBrush = new SolidBrush(whiteColor);

	draw.UpdateStatus(hWnd);

    // initialize menu check marks
    SetMenuCheckPos(hWnd, MenuShapePosition, 0, TRUE);
    SetMenuCheckPos(hWnd, MenuBrushPosition, 0, TRUE);

    hAccelTable = LoadAccelerators(hInstance, (LPCTSTR)IDC_GDIPTEST);

	// Main message loop:
	while (GetMessage(&msg, NULL, 0, 0)) 
	{
		if (!TranslateAccelerator(msg.hwnd, hAccelTable, &msg)) 
		{
			TranslateMessage(&msg);
			DispatchMessage(&msg);
		}
	}

	delete blackColor;
	delete blackBrush;
	delete blackPen;
	
	delete backBrush;

	return msg.wParam;
}

//
//  FUNCTION: MyRegisterClass()
//
//  PURPOSE: Registers the window class.
//
//  COMMENTS:
//
//    This function and its usage is only necessary if you want this code
//    to be compatible with Win32 systems prior to the 'RegisterClassEx'
//    function that was added to Windows 95. It is important to call this function
//    so that the application will get 'well formed' small icons associated
//    with it.
//
ATOM MyRegisterClass(HINSTANCE hInstance)
{
	WNDCLASSEX wcex;

	wcex.cbSize = sizeof(WNDCLASSEX); 

	wcex.style			= CS_HREDRAW | CS_VREDRAW;
	wcex.lpfnWndProc	= WndTestDrawProc;
	wcex.cbClsExtra		= 0;
	wcex.cbWndExtra		= 0;
	wcex.hInstance		= hInstance;
	wcex.hIcon			= LoadIcon(hInstance, (LPCTSTR)IDI_GDIPTEST);
	wcex.hCursor		= LoadCursor(NULL, IDC_ARROW);
	wcex.hbrBackground	= (HBRUSH)(COLOR_WINDOW+1);
	wcex.lpszMenuName	= (LPCSTR)IDC_GDIPTEST;
	wcex.lpszClassName	= szWindowClass;
	wcex.hIconSm		= LoadIcon(wcex.hInstance, (LPCTSTR)IDI_SMALL);

	return RegisterClassEx(&wcex);
}

//
//   FUNCTION: InitInstance(HANDLE, int)
//
//   PURPOSE: Saves instance handle and creates main window
//
//   COMMENTS:
//
//        In this function, we save the instance handle in a global variable and
//        create and display the main program window.
//
HWND InitInstance(HINSTANCE hInstance, int nCmdShow, LPVOID param)
{
   HWND hWnd;

   hInst = hInstance; // Store instance handle in our global variable

   hWnd = CreateWindow(
			szWindowClass, 
			szTitle, 
			WS_OVERLAPPEDWINDOW,
			CW_USEDEFAULT, 
			0, 
			CW_USEDEFAULT, 
			0, 
			NULL, 
			NULL, 
			hInstance, 
			param);

   if (!hWnd)
   {
      return (HWND)0;
   }

   ShowWindow(hWnd, nCmdShow);
   UpdateWindow(hWnd);

   return hWnd;
}

//
//  FUNCTION: WndTestDrawProc(HWND, unsigned, WORD, LONG)
//
//  PURPOSE:  Processes messages for the main window.
//
//  WM_COMMAND	- process the application menu
//  WM_PAINT	- Paint the main window
//  WM_DESTROY	- post a quit message and return
//
//
LRESULT CALLBACK WndTestDrawProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
	int wmId, wmEvent;

	switch (message) 
	{
		case WM_CREATE:
		{	
			TestDrawInterface* dlgInt = 
				static_cast<TestDrawInterface*>
				      (((LPCREATESTRUCT)lParam)->lpCreateParams);
					  
			SetWindowLong(hWnd, GWL_USERDATA, (LONG)dlgInt);
			break;
		}

		case WM_COMMAND:
		{
			wmId    = LOWORD(wParam); 
			wmEvent = HIWORD(wParam); 

			TestDrawInterface* drawInt = 
				(TestDrawInterface*)GetWindowLong(hWnd, GWL_USERDATA);

			TestDraw* draw = static_cast<TestDraw*>(drawInt);
			
			TestGradDraw* graddraw = static_cast<TestGradDraw*>(drawInt);
				
			// Parse the menu selections:
			switch (wmId)
			{
			// Shape Menu
			case IDM_LINE:
				draw->ChangeShape(hWnd, LineType);
				break;

			case IDM_ARC:
				draw->ChangeShape(hWnd, ArcType);
				break;
				
			case IDM_BEZIER:
				draw->ChangeShape(hWnd, BezierType);
				break;

			case IDM_RECT:
				draw->ChangeShape(hWnd, RectType);
				break;

			case IDM_ELLIPSE:
				draw->ChangeShape(hWnd, EllipseType);
				break;

			case IDM_PIE:
				draw->ChangeShape(hWnd, PieType);
				break;

			case IDM_POLYGON:
				draw->ChangeShape(hWnd, PolygonType);
				break;

			case IDM_CURVE:
				draw->ChangeShape(hWnd, CurveType);
				break;

			case IDM_CLOSED:
				draw->ChangeShape(hWnd, ClosedCurveType);
				break;

			case IDM_REGION:
				// do complete redraw if leaving incomplete shape
				break;

			// Brush Menu
			case IDM_SOLIDBRUSH: 
				draw->ChangeBrush(hWnd, SolidColorBrush); 
				break;

			case IDM_TEXTURE:    
				draw->ChangeBrush(hWnd, TextureFillBrush); 
				break;
				
			case IDM_RECTGRAD:   
				draw->ChangeBrush(hWnd, RectGradBrush); 
				break;

			case IDM_RADGRAD:   
				draw->ChangeBrush(hWnd, RadialGradBrush); 
				break;

			case IDM_TRIGRAD:   
				draw->ChangeBrush(hWnd, TriangleGradBrush); 
				break;

			case IDM_POLYGRAD:   
				draw->ChangeBrush(hWnd, PathGradBrush); 
				break;

			case IDM_HATCH:      
				draw->ChangeBrush(hWnd, HatchFillBrush); 
				break;

			// Pen Menu
			case IDM_PEN:		 
				draw->ChangePen(hWnd); 
				break;

			// Redraw Menu
			case IDM_REDRAWALL:
				draw->redrawAll = !draw->redrawAll;
				SetMenuCheckCmd(hWnd, 
					MenuOtherPosition, 
					wmId, 
					draw->redrawAll);
					
				// force redraw of all stacked shapes
				InvalidateRect(hWnd, NULL, TRUE);
				UpdateWindow(hWnd);
				break;

			case IDM_KEEPCONTROLPOINTS:
				draw->keepControlPoints = !draw->keepControlPoints;
				SetMenuCheckCmd(hWnd, 
					MenuOtherPosition, 
					wmId, 
					draw->keepControlPoints);

				// force redraw of all stacked shapes
				InvalidateRect(hWnd, NULL, TRUE);
				UpdateWindow(hWnd);
				break;

			case IDM_ANTIALIASED:
				draw->antiAlias = !draw->antiAlias;
				SetMenuCheckCmd(hWnd, 
					MenuOtherPosition, 
					wmId, 
					draw->keepControlPoints);

				// force redraw of all stacked shapes
				InvalidateRect(hWnd, NULL, TRUE);
				UpdateWindow(hWnd);
				break;

			case IDM_USECLIP:
				draw->useClip = !draw->useClip;
				SetMenuCheckCmd(hWnd, 
					MenuOtherPosition, 
					wmId, 
					draw->useClip);

				// force redraw of all stacked shapes
				InvalidateRect(hWnd, NULL, TRUE);
				UpdateWindow(hWnd);
				break;

			case IDM_WORLD_TRANSFORM:
			{
				Matrix *matrix = draw->GetWorldMatrix()->Clone();

				TestTransform transDlg;
				transDlg.Initialize(&matrix);
				transDlg.ChangeSettings(hWnd);

				draw->SetWorldMatrix(matrix);
				
				delete matrix;
				
				break;
			}

			case IDM_SETCLIP:
				draw->SetClipRegion(hWnd);
				break;

			case IDM_SAVEFILE:
				draw->SaveAsFile(hWnd);
				break;
		
			case IDM_DELETE:
				draw->RemovePoint(hWnd);
				InvalidateRect(hWnd, NULL, TRUE);
				UpdateWindow(hWnd);
				break;

			case IDM_RESET:
				graddraw->Reset(hWnd);
				break;

			case IDM_INSTRUCTIONS:
				graddraw->Instructions(hWnd);
				break;
				
			case IDM_CANCEL:
				DestroyWindow(hWnd);
				PostQuitMessage(FALSE);
				break;

			case IDM_DONE:
				DestroyWindow(hWnd);
				PostQuitMessage(TRUE);
				break;

			// Exit Test App
			case IDM_EXIT:
			   DestroyWindow(hWnd);
			   break;

			default:
			   return DefWindowProc(hWnd, message, wParam, lParam);
			}

			break;
		}

		case WM_LBUTTONUP:
			{
				Point pt(LOWORD(lParam), 
						 HIWORD(lParam));

				TestDrawInterface* drawInt = 
					(TestDrawInterface*)GetWindowLong(hWnd, GWL_USERDATA);

				drawInt->AddPoint(hWnd, pt);

				InvalidateRect(hWnd, NULL, TRUE);
				UpdateWindow(hWnd);
			}
			break;

		case WM_MBUTTONUP:
			{
				Point pt(LOWORD(lParam), 
						 HIWORD(lParam));

				TestDrawInterface* drawInt = 
					(TestDrawInterface*)GetWindowLong(hWnd, GWL_USERDATA);

				drawInt->EndPoint(hWnd, pt);
				
				InvalidateRect(hWnd, NULL, TRUE);
				UpdateWindow(hWnd);
			}
			break;

		case WM_RBUTTONDOWN:
			{
				Point pt(LOWORD(lParam), 
						 HIWORD(lParam));

				TestDrawInterface* drawInt = 
					(TestDrawInterface*)GetWindowLong(hWnd, GWL_USERDATA);
		
				drawInt->RememberPoint(pt);
			}
			break;

		case WM_RBUTTONUP:
			{
				Point pt(LOWORD(lParam), 
						 HIWORD(lParam));

				TestDrawInterface* drawInt = 
					(TestDrawInterface*)GetWindowLong(hWnd, GWL_USERDATA);
		
				drawInt->MoveControlPoint(pt);
				
				InvalidateRect(hWnd, NULL, TRUE);
				UpdateWindow(hWnd);
			}
			break;

		case WM_PAINT:
			{
				TestDrawInterface* drawInt = 
					(TestDrawInterface*)GetWindowLong(hWnd, GWL_USERDATA);
		
				if (drawInt)
					drawInt->Draw(hWnd);
			}
			break;

		case WM_ENTERSIZEMOVE:
			{
				// reposition the status window
				TestDrawInterface* drawInt = 
					(TestDrawInterface*)GetWindowLong(hWnd, GWL_USERDATA);
		
				if (drawInt)
					drawInt->UpdateStatus((HWND)-1);
			}
			break;

		case WM_SIZE:
			{
				// reposition the status window
				TestDrawInterface* drawInt = 
					(TestDrawInterface*)GetWindowLong(hWnd, GWL_USERDATA);
		
				if (drawInt)
					drawInt->UpdateStatus(hWnd);
			}
			break;

		case WM_DESTROY:
			PostQuitMessage(0);
			break;

		default:
			return DefWindowProc(hWnd, message, wParam, lParam);
   }

   return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\gdiptest\gdipshape.hpp ===
#ifndef GDIPSHAPE_HPP
#define GDIPSHAPE_HPP

class TestShapeInterface;
class TestShape;
class LineShape;
class ArcShape;
class BezierShape;
class RectShape;
class EllipseShape;
class PieShape;
class PolygonShape;
class CurveShape;
class ClosedCurveShape;

class TestRectGradShape;
class TestRadialGradShape;
class TestTriangleGradShape;
class TestPathGradShape;

class TestShapeInterface : public TestConfigureInterface,
						   public TestDialogInterface
{
public:
	// initialize shape parameters to that of compatible shape
	virtual VOID Initialize(TestShape *shape) = 0;

	// add point to shape
	virtual BOOL AddPoint(HWND hwnd, Point pt) = 0;

	// user indicates we're done shape
	virtual VOID DoneShape(HWND hwnd) = 0;

	// last point added directly by a user
	virtual BOOL EndPoint(HWND hwnd, Point pt) = 0;

	// remove last control point from shape
	virtual BOOL RemovePoint(HWND hwnd) = 0;

	// do we encapsulate an entire shape?
	virtual BOOL IsComplete() = 0;

	// are there no control points for this shape?
	virtual BOOL IsEmpty() = 0;

	// draw control points ONLY
	virtual VOID DrawPoints(Graphics* g) = 0;

	// draw entire shape (no control points)
	virtual VOID DrawShape(Graphics* g) = 0;

	// add shape to path if complete
	virtual VOID AddToPath(GraphicsPath* path) = 0;

	// write instructions to create function
	virtual VOID AddToFile(OutputFile* outfile) = 0;

	// get type of shape
	virtual INT GetType() = 0;

	// return DC containing shape picture
	virtual HDC CreatePictureDC(HWND hwnd, RECT *rect) = 0;
};

class TestShape: public TestShapeInterface
{
public:

	TestShape() : pen(NULL),
				  brush(NULL),
				  done(FALSE),
				  shapeName(NULL),
				  disabled(FALSE)
	{
		pts.Reset();

		// !! hack for distinct names
		static INT shapeCount = 0;
		shapeName = (LPTSTR)malloc(sizeof(TCHAR)*100);
		sprintf(shapeName, _T("Shape (%d)"), shapeCount++);

		hdcPic = NULL;
	}

	~TestShape()
	{
		if (hdcPic)
			DeleteDC(hdcPic);

		delete pen;
		delete brush;
		
		if (shapeName)
			free(shapeName);
	}

	// useful helper functions
	static TestShape* CreateNewShape(INT type);

	// temporary overload for those who don't implement these.
	virtual VOID Initialize()
	{
	};

	virtual VOID Initialize(TestShape *shape) 
	{
		this->Initialize();
	};

	virtual HDC CreatePictureDC(HWND hwnd, RECT *rect);

	virtual VOID SetBrush(TestBrush *newbrush)
	{
		delete brush;
		brush = newbrush;
	}

	virtual VOID SetPen(TestPen *newpen)
	{
		delete pen;
		pen = newpen;
	}
	
	virtual TestBrush* GetBrush()
	{
		return brush;
	}

	virtual TestPen* GetPen()
	{
		return pen;
	}

	virtual VOID SetDisabled(BOOL disabled)
	{
		this->disabled = disabled;
	}

	virtual BOOL GetDisabled()
	{
		return disabled;
	}

	virtual BOOL EndPoint(HWND hwnd, Point pt);
	virtual BOOL RemovePoint(HWND hwnd);
	virtual VOID DrawPoints(Graphics* g);
	virtual BOOL MoveControlPoint(Point origPt, Point newPt);
	virtual VOID AddToPath(GraphicsPath* path);
	virtual VOID AddToFile(OutputFile* outfile);

	virtual BOOL IsEmpty()
	{
		return (pts.GetCount() == 0);
	}

	virtual INT GetCount()
	{
		return pts.GetCount();
	}

	virtual INT GetType()
	{
		ASSERT(FALSE);
		return -1;	
	}

	virtual LPTSTR GetShapeName()
	{
		// !! alter name based on Disabled/Not disabled?!?
		return shapeName;
	}

/*
	virtual INT* ShapeCount()
	{
		static INT shapeCount = 0;
		return &shapeCount;
	}

	virtual INT* RevCount()
	{
		static INT revCount = 0;
		return &revCount;
	}

	virtual TestShape* Clone()
	{
		TestShape* newShape = new TestShape();
		*newShape = *this;

		// clone GDI+ brush and pen
		newShape->brush = brush->Clone();
		newShape->pen = pen->Clone();
	
		// make extra copy of dynamic point array and shape name
		newShape->pts.RenewDataBuffer();
	}
*/

public:
	// for use by other objects in system for temporary storage
	DWORD dwFlags;

protected:
	TestBrush *brush;
	TestPen *pen;

	PointArray pts;
	BOOL done;

	LPTSTR shapeName;
	BOOL disabled;

	HDC hdcPic;
};

class LineShape : public TestShape
{
public:
	friend class LineShape;

	// Shape usage methods
	virtual VOID Initialize(TestShape *shape);
	virtual BOOL AddPoint(HWND hwnd, Point pt);
	virtual VOID DoneShape(HWND hwnd);
	virtual BOOL RemovePoint(HWND hwnd);
	virtual BOOL IsComplete();
	virtual VOID DrawShape(Graphics* g);
	virtual VOID AddToPath(GraphicsPath* path);
	virtual VOID AddToFile(OutputFile* outfile);

	// Configuration Interface
	virtual BOOL ChangeSettings(HWND hwnd);
	virtual VOID Initialize();

	// Dialog Management Interface
	virtual	VOID InitDialog(HWND hwnd);
	virtual BOOL SaveValues(HWND hwnd);
	virtual BOOL ProcessDialog(HWND hwnd, 
					UINT msg, 
					WPARAM wParam, 
					LPARAM lParam);

	virtual INT GetType() 
	{ 
		return LineType; 
	}
};

class ArcShape : public TestShape
{
public:
	friend class ArcShape;
	
	// Shape usage methods
	virtual VOID Initialize(TestShape *shape);
	virtual BOOL AddPoint(HWND hwnd, Point pt);
	virtual VOID DoneShape(HWND hwnd);
	virtual BOOL RemovePoint(HWND hwnd);
	virtual BOOL IsComplete();
	virtual VOID DrawShape(Graphics* g);
	virtual VOID AddToPath(GraphicsPath* path);
	virtual VOID AddToFile(OutputFile* outfile);

	// Configuration Interface
	virtual BOOL ChangeSettings(HWND hwnd);
	virtual VOID Initialize();

	// Dialog Management Interface
	virtual	VOID InitDialog(HWND hwnd);
	virtual BOOL SaveValues(HWND hwnd);
	virtual BOOL ProcessDialog(HWND hwnd, 
					UINT msg, 
					WPARAM wParam, 
					LPARAM lParam);

	virtual INT GetType() 
	{ 
		return ArcType; 
	}

private:
	REAL start;
	REAL sweep;
	BOOL popup;
};

class BezierShape : public TestShape
{
public:
	friend class BezierShape;

	// Shape usage methods
	virtual VOID Initialize(TestShape *shape);
	virtual BOOL AddPoint(HWND hwnd, Point pt);
	virtual VOID DoneShape(HWND hwnd);
	virtual BOOL RemovePoint(HWND hwnd);
	virtual BOOL IsComplete();
	virtual VOID DrawShape(Graphics* g);
	virtual VOID AddToPath(GraphicsPath* path);
	virtual VOID AddToFile(OutputFile* outfile);

	// Configuration Interface
	virtual BOOL ChangeSettings(HWND hwnd);
	virtual VOID Initialize();

	// Dialog Management Interface
	virtual	VOID InitDialog(HWND hwnd);
	virtual BOOL SaveValues(HWND hwnd);
	virtual BOOL ProcessDialog(HWND hwnd, 
					UINT msg, 
					WPARAM wParam, 
					LPARAM lParam);

	virtual INT GetType() 
	{ 
		return BezierType; 
	}
};

class RectShape : public TestShape
{
public:
	friend class RectShape;
	
	// Shape usage methods
	virtual VOID Initialize(TestShape *shape);
	virtual BOOL AddPoint(HWND hwnd, Point pt);
	virtual VOID DoneShape(HWND hwnd);
	virtual BOOL RemovePoint(HWND hwnd);
	virtual BOOL IsComplete();
	virtual VOID DrawShape(Graphics* g);
	virtual VOID AddToPath(GraphicsPath* path);
	virtual VOID AddToFile(OutputFile* outfile);

	// Configuration Interface
	virtual BOOL ChangeSettings(HWND hwnd);
	virtual VOID Initialize();

	// Dialog Management Interface
	virtual	VOID InitDialog(HWND hwnd);
	virtual BOOL SaveValues(HWND hwnd);
	virtual BOOL ProcessDialog(HWND hwnd, 
					UINT msg, 
					WPARAM wParam, 
					LPARAM lParam);

	virtual INT GetType() 
	{ 
		return RectType; 
	}
};

class EllipseShape : public TestShape
{
public:
	friend class EllipseShape;
	
	// Shape usage methods
	virtual VOID Initialize(TestShape *shape);
	virtual BOOL AddPoint(HWND hwnd, Point pt);
	virtual VOID DoneShape(HWND hwnd);
	virtual BOOL RemovePoint(HWND hwnd);
	virtual BOOL IsComplete();
	virtual VOID DrawShape(Graphics* g);
	virtual VOID AddToPath(GraphicsPath* path);
	virtual VOID AddToFile(OutputFile* outfile);

	// Configuration Interface
	virtual BOOL ChangeSettings(HWND hwnd);
	virtual VOID Initialize();

	// Dialog Management Interface
	virtual	VOID InitDialog(HWND hwnd);
	virtual BOOL SaveValues(HWND hwnd);
	virtual BOOL ProcessDialog(HWND hwnd, 
					UINT msg, 
					WPARAM wParam, 
					LPARAM lParam);

	virtual INT GetType() 
	{ 
		return EllipseType; 
	}
};

class PieShape : public TestShape
{
public:
	friend class PieShape;
	
	// Shape usage methods
	virtual VOID Initialize(TestShape *shape);
	virtual BOOL AddPoint(HWND hwnd, Point pt);
	virtual VOID DoneShape(HWND hwnd);
	virtual BOOL RemovePoint(HWND hwnd);
	virtual BOOL IsComplete();
	virtual VOID DrawShape(Graphics* g);
	virtual VOID AddToPath(GraphicsPath* path);
	virtual VOID AddToFile(OutputFile* outfile);

	// Configuration Interface
	virtual BOOL ChangeSettings(HWND hwnd);
	virtual VOID Initialize();

	// Dialog Management Interface
	virtual	VOID InitDialog(HWND hwnd);
	virtual BOOL SaveValues(HWND hwnd);
	virtual BOOL ProcessDialog(HWND hwnd, 
					UINT msg, 
					WPARAM wParam, 
					LPARAM lParam);

	virtual INT GetType() 
	{ 
		return PieType; 
	}

private:
	REAL start;
	REAL sweep;
	BOOL popup;
};

class PolygonShape : public TestShape
{
public:
	friend class PolygonShape;
	
	// Shape usage methods
	virtual VOID Initialize(TestShape *shape);
	virtual BOOL AddPoint(HWND hwnd, Point pt);
	virtual VOID DoneShape(HWND hwnd);
	virtual BOOL RemovePoint(HWND hwnd);
	virtual BOOL IsComplete();
	virtual VOID DrawShape(Graphics* g);
	virtual VOID AddToPath(GraphicsPath* path);
	virtual VOID AddToFile(OutputFile* outfile);

	// Configuration Interface
	virtual BOOL ChangeSettings(HWND hwnd);
	virtual VOID Initialize();

	// Dialog Management Interface
	virtual	VOID InitDialog(HWND hwnd);
	virtual BOOL SaveValues(HWND hwnd);
	virtual BOOL ProcessDialog(HWND hwnd, 
					UINT msg, 
					WPARAM wParam, 
					LPARAM lParam);

	virtual INT GetType() 
	{ 
		return PolygonType; 
	}
};

class CurveShape : public TestShape
{
public:
	friend class CurveShape;
	
	// Shape usage methods
	virtual VOID Initialize(TestShape *shape);
	virtual BOOL AddPoint(HWND hwnd, Point pt);
	virtual VOID DoneShape(HWND hwnd);
	virtual BOOL RemovePoint(HWND hwnd);
	virtual BOOL IsComplete();
	virtual VOID DrawShape(Graphics* g);
	virtual VOID AddToPath(GraphicsPath* path);
	virtual VOID AddToFile(OutputFile* outfile);

	// Configuration Interface
	virtual BOOL ChangeSettings(HWND hwnd);
	virtual VOID Initialize();

	// Dialog Management Interface
	virtual	VOID InitDialog(HWND hwnd);
	virtual BOOL SaveValues(HWND hwnd);
	virtual BOOL ProcessDialog(HWND hwnd, 
					UINT msg, 
					WPARAM wParam, 
					LPARAM lParam);

	virtual INT GetType() 
	{ 
		return CurveType; 
	}

private:
	REAL tension;
	INT offset;
	INT numSegments;
	BOOL popup;
};

class ClosedCurveShape : public TestShape
{
public:
	friend class ClosedCurveShape;
	
	// Shape usage methods
	virtual VOID Initialize(TestShape *shape);
	virtual BOOL AddPoint(HWND hwnd, Point pt);
	virtual VOID DoneShape(HWND hwnd);
	virtual BOOL RemovePoint(HWND hwnd);
	virtual BOOL IsComplete();
	virtual VOID DrawShape(Graphics* g);
	virtual VOID AddToPath(GraphicsPath* path);
	virtual VOID AddToFile(OutputFile* outfile);

	// Configuration Interface
	virtual BOOL ChangeSettings(HWND hwnd);
	virtual VOID Initialize();

	// Dialog Management Interface
	virtual	VOID InitDialog(HWND hwnd);
	virtual BOOL SaveValues(HWND hwnd);
	virtual BOOL ProcessDialog(HWND hwnd, 
					UINT msg, 
					WPARAM wParam, 
					LPARAM lParam);

	virtual INT GetType() 
	{ 
		return ClosedCurveType; 
	}

private:
	REAL tension;
	BOOL popup;
};
//*******************************************************************
//
// TestGradShapeInterface
//
//
//
//*******************************************************************

class TestGradShape : public TestShape
{
public:
	TestGradShape()
	{
		argb.Reset();
	}
	
	virtual VOID DrawPoints(Graphics* g);

protected:
	INT FindControlPoint(Point pt);
	INT FindLocationToInsert(Point pt);

	ARGBArray argb;

	INT curIndex;
	ARGB tmpArgb;
};

//*******************************************************************
//
// TestTriangleGradShape
//
//
//
//*******************************************************************

#define TriangleCount 3

class TestTriangleGradShape : public TestGradShape
{
public:
	TestTriangleGradShape()
	{
		argb.Reset();

		blend[0] = blend[1] = blend[2] = NULL;
		
		gdiBrush = NULL;
	}

	~TestTriangleGradShape()
	{
		for (INT i = 0; i < 3; i++)
			if (blend[i])
				free(blend[i]);

		delete gdiBrush;
	}

	// Shape usage methods
	virtual VOID Initialize(TestShape *shape);
	virtual BOOL AddPoint(HWND hwnd, Point pt);
	virtual VOID DoneShape(HWND hwnd);
	virtual BOOL EndPoint(HWND hwnd, Point pt);
	virtual BOOL RemovePoint(HWND hwnd);

	virtual BOOL IsComplete();
	virtual VOID DrawShape(Graphics* g);
	virtual BOOL MoveControlPoint(Point origPt, Point newPt);

	// Configuration Interface
	virtual BOOL ChangeSettings(HWND hwnd);
	virtual VOID Initialize();

	// Dialog Management Interface
	virtual	VOID InitDialog(HWND hwnd);
	virtual BOOL SaveValues(HWND hwnd);
	virtual BOOL ProcessDialog(HWND hwnd, 
					UINT msg, 
					WPARAM wParam, 
					LPARAM lParam);

	VOID Initialize(Point* pts, 
					ARGB* argb, 
					REAL** blend, 
					INT* blendCount);
	
	Point* GetPoints()
	{
		return pts.GetDataBuffer();
	}

	ARGB* GetARGB()
	{
		return argb.GetDataBuffer();
	}

	REAL** GetBlend()
	{
		return &blend[0];
	}

	INT* GetBlendCount()
	{
		return &count[0];
	}

private:
	TriangleGradientBrush* gdiBrush;
	
	REAL* blend[3];
	INT count[3];
};

//*******************************************************************
//
// TestPathGradShape
//
//
//
//*******************************************************************

class TestPathGradShape : public TestGradShape
{
public:
	TestPathGradShape()
	{
		argb.Reset();

		surroundBlend = centerBlend = NULL;
		surroundCount = centerCount = 0;
		
		gdiBrush = NULL;
	}

	~TestPathGradShape()
	{
		if (surroundBlend)
			free(surroundBlend);

		if (centerBlend)
			free(centerBlend);

		delete gdiBrush;
	}

	// Shape usage methods
	virtual VOID Initialize(TestShape *shape);
	virtual BOOL AddPoint(HWND hwnd, Point pt);
	virtual VOID DoneShape(HWND hwnd);
	virtual BOOL EndPoint(HWND hwnd, Point pt);
	virtual BOOL RemovePoint(HWND hwnd);

	virtual BOOL IsComplete();
	virtual VOID DrawShape(Graphics* g);
	virtual BOOL MoveControlPoint(Point origPt, Point newPt);

	// Configuration Interface
	virtual BOOL ChangeSettings(HWND hwnd);
	virtual VOID Initialize();

	// Dialog Management Interface
	virtual	VOID InitDialog(HWND hwnd);
	virtual BOOL SaveValues(HWND hwnd);
	virtual BOOL ProcessDialog(HWND hwnd, 
					UINT msg, 
					WPARAM wParam, 
					LPARAM lParam);

	VOID Initialize(PointArray* pts, 
					ARGBArray* argb, 
					REAL* surroundBlend,
					INT surroundColor,
					REAL* centerBlend,
					INT centerColor);
	
	Point* GetPoints()
	{
		return pts.GetDataBuffer();
	}

	ARGB* GetARGB()
	{
		return argb.GetDataBuffer();
	}

	REAL* GetCenterBlend()
	{
		return centerBlend;
	}

	INT GetCenterBlendCount()
	{
		return centerCount;
	}

	REAL* GetSurroundBlend()
	{
		return surroundBlend;
	}

	INT GetSurroundBlendCount()
	{
		return surroundCount;
	}

private:
	PathGradientBrush* gdiBrush;

	REAL* surroundBlend;
	REAL* centerBlend;
	INT surroundCount, centerCount;
};

#endif  // _GDIPSHAPE_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\gdiptest\gdipshape.cpp ===
#include "gdiptest.h"

//*******************************************************************
//
// TestShape
//
//
//
//*******************************************************************

TestShape* TestShape :: CreateNewShape(INT type)
{
	switch (type)
	{
	case LineType:
		return new LineShape();
		
	case ArcType:
		return new ArcShape();

	case BezierType:
		return new BezierShape();

	case RectType:
		return new RectShape();

	case EllipseType:
		return new EllipseShape();

	case PieType:
		return new PieShape();

	case PolygonType:
		return new PolygonShape();

	case CurveType:
		return new CurveShape();
		break;

	case ClosedCurveType:
		return new ClosedCurveShape();
		break;

	// !!! Other shapes types

	default:
		NotImplementedBox();
		return NULL;
	}
}

// black squares
VOID TestShape :: DrawPoints(Graphics* g)
{
	INT count = pts.GetCount();
	Point* ptbuf = (Point*)pts.GetDataBuffer();

	while (count)
	{
		ERectangle rect(ptbuf->X-pointRadius,
						ptbuf->Y-pointRadius,
						2*pointRadius,
						2*pointRadius);

		g->FillRectangle(blackBrush, rect);
		// g->FillEllipse(ptBrush, rect);

		count--, ptbuf++;
	}
}

BOOL TestShape::EndPoint(HWND hwnd, Point pt)
{
	AddPoint(hwnd, pt);
	DoneShape(hwnd);

	return FALSE;
}

INT TestGradShape :: FindLocationToInsert(Point pt)
{
	// !! Not implemented yet.
	return 0;
}

// square color from ARGB value
VOID TestGradShape :: DrawPoints(Graphics* g)
{
	INT count = pts.GetCount();
	Point* ptbuf = (Point*)pts.GetDataBuffer();

	for (INT i = 0; i < count; i++)
	{
		ERectangle rect(ptbuf->X-pointRadius,
						ptbuf->Y-pointRadius,
						2*pointRadius,
						2*pointRadius);

		Color solidColor((argb[i] & ~Color::AlphaMask)
						| (0xFF << Color::AlphaShift));

		SolidBrush solidBrush((argb[i] & ~Color::AlphaMask) == 0
									? *blackColor : solidColor);

		g->FillRectangle(&solidBrush, rect);

		ptbuf++;
	}
}

BOOL TestShape :: MoveControlPoint(Point origPt, Point newPt)
{
	INT count = pts.GetCount();
	INT pos = 0;

	// !!! what if multiple control points overlap?
	//     can't get to one of them
	for (pos = 0; pos<count; pos++)
	{
		Point *ctrlPt = &pts[pos];

		ERectangle ctrlRect(ctrlPt->X-pointRadius,
							ctrlPt->Y-pointRadius,
							2*pointRadius,
							2*pointRadius);

		if (origPt.X>ctrlPt->X-pointRadius &&
			origPt.X<ctrlPt->X+pointRadius &&
			origPt.Y>ctrlPt->Y-pointRadius &&
			origPt.Y<ctrlPt->Y+pointRadius)
		{
			ctrlPt->X = newPt.X;
			ctrlPt->Y = newPt.Y;
			return TRUE;
		}
	}

	return FALSE;
}

INT TestGradShape :: FindControlPoint(Point pt)
{
	INT count = pts.GetCount();
	INT pos = 0;

	// !!! what if multiple control points overlap?
	//     can't get to one of them
	for (pos = 0; pos < count; pos++)
	{
		Point *ctrlPt = &pts[pos];

		ERectangle ctrlRect(ctrlPt->X-pointRadius,
							ctrlPt->Y-pointRadius,
							2*pointRadius,
							2*pointRadius);

		if (pt.X>ctrlPt->X-pointRadius &&
			pt.X<ctrlPt->X+pointRadius &&
			pt.Y>ctrlPt->Y-pointRadius &&
			pt.Y<ctrlPt->Y+pointRadius)
		{
			return pos;
		}
	}

	return -1;
}

BOOL TestShape :: RemovePoint(HWND hwnd)
{
	return FALSE;
}

VOID TestShape :: AddToPath(GraphicsPath* path)
{
}

VOID TestShape :: AddToFile(OutputFile* outfile)
{
}

HDC TestShape :: CreatePictureDC(HWND hwnd, RECT *dstRect)
{
	// always return the cached version if possible

	HWND hwndLast = GetWindow(hwnd, GW_OWNER);
	HDC hdc;
	HDC hdc2;

	HDC hdcWindow;
	HBITMAP hbm;
	HBITMAP hbm2;

	// get handle to main window
	while (hwndLast)
	{
		hwnd = hwndLast;
		hwndLast = GetWindow(hwnd, GW_OWNER);
	}

	// !! BUG BUG: we are actually getting handle
	//    to the dialog, not the main window 
	//    IS THIS TRUE?!?!
	
	RECT srcRect;
	GetClientRect(hwnd, &srcRect);
	hdcWindow = GetDC(hwnd);

	SIZE size;
	size.cx = srcRect.right-srcRect.left;
	size.cy = srcRect.bottom-srcRect.top;

	if (hdcPic)
	{
	    hbm = CreateCompatibleBitmap(hdcPic, 1, 1);
		hbm = (HBITMAP) SelectObject(hdcPic, (HGDIOBJ)hbm);
		
		SIZE origSize;
		GetBitmapDimensionEx(hbm, &origSize);

		DeleteObject(SelectObject(hdcPic, (HGDIOBJ)hbm));

		// if size hasn't changed, don't recreate
		if (origSize.cx == size.cx && 
			origSize.cy == size.cy)
		{
			ReleaseDC(hwnd, hdcWindow);
			return hdcPic;
		}

		// clean up the old picture DC
		DeleteObject(hdcPic);
		hdcPic = NULL;
		// create new picture image
	}

	SIZE size2;
	size2.cx = dstRect->right-dstRect->left;
	size2.cy = dstRect->bottom-dstRect->top;

	hdc = CreateCompatibleDC(hdcWindow);	// source
	hdc2 = CreateCompatibleDC(hdcWindow);	// destination

	hbm = CreateCompatibleBitmap(hdcWindow, size.cx, size.cy);
	hbm2 = CreateCompatibleBitmap(hdcWindow, size2.cx, size2.cy);

	SetBitmapDimensionEx(hbm2, size.cx, size.cy, NULL);

	DeleteObject((HBITMAP) SelectObject(hdc, (HGDIOBJ) hbm));
	DeleteObject((HBITMAP) SelectObject(hdc2, (HGDIOBJ) hbm2));

	// white GDI brush
	HBRUSH hbr = CreateSolidBrush(0x00FFFFFF);
	srcRect.left = srcRect.top = 0;
	srcRect.right = size.cx;
	srcRect.bottom = size.cy;
	
	FillRect(hdc, &srcRect, hbr);
	DeleteObject(hbr);

	{
		// create GDI+ graphics context for this memory DC
		Graphics g(hdc);

		DrawShape(&g);	
	}

	StretchBlt(hdc2,
			   0,
			   0,
			   size2.cx,
			   size2.cy,
			   hdc,
			   srcRect.left,
			   srcRect.top,
			   size.cx,
			   size.cy,
			   SRCCOPY);

	ReleaseDC(hwnd, hdcWindow);
	ReleaseDC(hwnd, hdc);
	
	// !! necessary?
	DeleteObject(hbm);

	// return DC with GDI+ drawn graphics shape, cache it
	return (hdcPic = hdc2);
}

//*******************************************************************
//
// LineShape
//
//
//
//*******************************************************************

BOOL LineShape :: AddPoint(HWND hwnd, Point pt)
{
	pts.Add(pt);
	return TRUE;
}

VOID LineShape :: DoneShape(HWND hwnd)
{
	if (pts.GetCount()>1)
		done = TRUE;
	else
		done = FALSE;
}

BOOL LineShape :: IsComplete()
{
	return done;
}

BOOL LineShape :: RemovePoint(HWND hwnd)
{
	INT count = pts.GetCount();

	if (count > 0)
	{
		pts.SetCount(count-1);
		done = TRUE;
		return TRUE;
	}
	else
		return FALSE;
}

VOID LineShape :: DrawShape(Graphics* g)
{
	INT count = pts.GetCount();
	Point* ptbuf = (Point*)pts.GetDataBuffer();

	ASSERT(IsComplete());

	if (pen)
		g->DrawLines(pen->GetPen(), ptbuf, count);

	// brush is not used
}

VOID LineShape :: AddToPath(GraphicsPath* path)
{
	INT count = pts.GetCount();
	Point* ptbuf = (Point*)pts.GetDataBuffer();

	ASSERT(Path);

	path->AddLines(ptbuf, count);
}

VOID LineShape :: AddToFile(OutputFile* outfile)
{
	INT count = pts.GetCount();

	pen->AddToFile(outfile);
	
	outfile->BlankLine();
	
	outfile->PointDeclaration(_T("pts"),
							  (Point*)pts.GetDataBuffer(),
							  count);
	
	outfile->BlankLine();
	
	outfile->GraphicsCommand(_T("DrawLine"),
							 _T("%s, %s, %d"),
							 outfile->Ref(_T("pen")),
							 outfile->RefArray(_T("pts")),
							 count);
}

// Configuration management functions
BOOL LineShape :: ChangeSettings(HWND hwnd)
{
	return TRUE;
}

VOID LineShape :: Initialize()
{
	// do nothing
};

VOID LineShape :: Initialize(TestShape* shape)
{
	// do nothing
}

// Dialog management functions (not used)
VOID LineShape :: InitDialog(HWND hwnd)
{
	DebugBreak();
}

BOOL LineShape :: SaveValues(HWND hwnd)
{
	DebugBreak();
	return FALSE;
}

BOOL LineShape :: ProcessDialog(HWND hwnd, 
					UINT msg, 
					WPARAM wParam, 
					LPARAM lParam)
{
	DebugBreak();
	return FALSE;
}

//*******************************************************************
//
// ArcShape
//
//
//
//*******************************************************************

BOOL ArcShape :: AddPoint(HWND hwnd, Point pt)
{
	ASSERT(pts.GetCount() < 2);

	pts.Add(pt);

	// force complete on point pairs (rect) if possible
	DoneShape(hwnd);
	
	return TRUE;
}

VOID ArcShape :: DoneShape(HWND hwnd)
{
	ASSERT(pts.GetCount() <= 2);

	if (pts.GetCount() == 2)
	{
		done = TRUE;

		if (popup)
		{
			// !!! cheating, we use global HWND, should use
			//     HWND passed in.
			ChangeSettings(hwnd);
		}

	}
	else
		done = FALSE;
}

BOOL ArcShape :: RemovePoint(HWND hwnd)
{
	INT count = pts.GetCount();

	if (count > 0)
	{
		pts.SetCount(count-1);
		done = FALSE;
		return TRUE;
	}
	else
		return FALSE;
}

BOOL ArcShape :: IsComplete()
{
	return done;
}

VOID ArcShape :: DrawShape(Graphics* g)
{
	INT count = pts.GetCount();
	Point* pt1 = (Point*)pts.GetDataBuffer();
	Point* pt2 = pt1++;

	ASSERT(IsComplete());
	ASSERT(count == 2);

	if (pen) 
	{
		// create appropriate rectangle
		// !! cache this?
		ERectangle rect(min(pt1->X, pt2->X),
						min(pt1->Y, pt2->Y),
						fabsf(pt1->X-pt2->X),
						fabsf(pt1->Y-pt2->Y));

		g->DrawArc(pen->GetPen(), rect, start, sweep);
	}

	// brush is not used
}

VOID ArcShape :: AddToPath(GraphicsPath* path)
{
	ASSERT(Path);

	INT count = pts.GetCount();
	Point* pt1 = (Point*)pts.GetDataBuffer();
	Point* pt2 = pt1++;

	if (count < 2)
		return;

	ERectangle rect(min(pt1->X, pt2->X),
					min(pt1->Y, pt2->Y),
					fabsf(pt1->X-pt2->X),
					fabsf(pt1->Y-pt2->Y));

	path->AddArc(rect, start, sweep);
}

VOID ArcShape :: AddToFile(OutputFile* outfile)
{
	Point* pt1 = (Point*)pts.GetDataBuffer();
	Point* pt2 = pt1++;

	ERectangle rect(min(pt1->X, pt2->X),
					min(pt1->Y, pt2->Y),
					fabsf(pt1->X-pt2->X),
					fabsf(pt1->Y-pt2->Y));

	pen->AddToFile(outfile);

	outfile->BlankLine();

	outfile->RectangleDeclaration(_T("rect"), 
								  rect);

	outfile->BlankLine();

	outfile->GraphicsCommand(_T("DrawArc"),
							 _T("%s, %s, %e, %e"),
							 outfile->Ref(_T("pen")),
							 _T("rect"),
							 start,
							 sweep);
}

// Configuration management functions
BOOL ArcShape :: ChangeSettings(HWND hwndParent)
{
	BOOL ok = DialogBoxParam(hInst,
							MAKEINTRESOURCE(IDD_ARC_DLG),
							hwndParent,
							AllDialogBox,
							(LPARAM)((TestDialogInterface*)this));

	return ok;
}

VOID ArcShape :: Initialize()
{
	sweep = 90.0f;
	start = 0.0f;
	popup = FALSE;
};

VOID ArcShape :: Initialize(TestShape *shape)
{
	// if compatible, copy parameters from another compatible shape
	if (shape && shape->GetType() == GetType())
	{
		ArcShape* arcshape = static_cast<ArcShape*>(shape);

		sweep = arcshape->sweep;
		start = arcshape->start;
		popup = arcshape->popup;
	}
	else
		Initialize();
}

// Dialog management functions (not used)
VOID ArcShape :: InitDialog(HWND hwnd)
{
	SetDialogReal(hwnd, IDC_ARC_START, start);
	SetDialogReal(hwnd, IDC_ARC_SWEEP, sweep);
	SetDialogCheck(hwnd, IDC_ARC_POPUP, popup);
}

BOOL ArcShape :: SaveValues(HWND hwnd)
{
	start = GetDialogReal(hwnd, IDC_ARC_START);
	sweep = GetDialogReal(hwnd, IDC_ARC_SWEEP);
	popup = GetDialogCheck(hwnd, IDC_ARC_POPUP);

	// no warnings, anything goes
	return FALSE;
}

BOOL ArcShape :: ProcessDialog(HWND hwnd, 
					UINT msg, 
					WPARAM wParam, 
					LPARAM lParam)
{
	if (msg == WM_COMMAND &&
		LOWORD(wParam) == IDC_OK)
	{
		if (SaveValues(hwnd))
			WarningBeep();
		else
			::EndDialog(hwnd, TRUE);

		return TRUE;
	}

	return FALSE;
}

//*******************************************************************
//
// BezierShape
//
//
//
//*******************************************************************

BOOL BezierShape :: AddPoint(HWND hwnd, Point pt)
{
	pts.Add(pt);

	return TRUE;
}

VOID BezierShape :: DoneShape(HWND hwnd)
{
	INT count = pts.GetCount();

	if (count>3)
	{
		if (count % 3 != 1)
		{
			// if they have wrong # of pts, but want to stop,
			// then draw with control points we have.
			while (count % 3 != 1) count--;
			pts.SetCount(count);
		}
		done = TRUE;
	}
	else
	{
		done = FALSE;
	}
}

BOOL BezierShape :: RemovePoint(HWND hwnd)
{
	INT count = pts.GetCount();

	if (count > 0)
	{
		pts.SetCount(count-1);
		done = FALSE;
		return TRUE;
	}
	else
		return FALSE;
}

BOOL BezierShape :: IsComplete()
{
	return done;
}

VOID BezierShape :: DrawShape(Graphics* g)
{
	INT count = pts.GetCount();
	Point* ptbuf = (Point*)pts.GetDataBuffer();

	ASSERT(IsComplete());

	if (pen)
		g->DrawBeziers(pen->GetPen(), ptbuf, count);

	// brush is not used
}

VOID BezierShape :: AddToPath(GraphicsPath* path)
{
	ASSERT(Path);

	INT count = pts.GetCount();
	Point* ptbuf = (Point*)pts.GetDataBuffer();

	if (count > 0)
		path->AddBeziers(ptbuf, count);
}

VOID BezierShape :: AddToFile(OutputFile* outfile)
{
	INT count = pts.GetCount();

	pen->AddToFile(outfile);

	outfile->BlankLine();

	outfile->PointDeclaration(_T("pts"),
							  (Point*)pts.GetDataBuffer(),
							  count);

	outfile->BlankLine();

	outfile->GraphicsCommand(_T("DrawBezier"),
							 _T("%s, %s, %d"),
							 outfile->Ref(_T("pen")),
							 outfile->RefArray(_T("pts")),
							 count);
}

// Configuration management functions
BOOL BezierShape :: ChangeSettings(HWND hwnd)
{
	return TRUE;
}

VOID BezierShape :: Initialize()
{
	pts.Reset();
};

VOID BezierShape :: Initialize(TestShape *shape)
{
}

// Dialog management functions (not used)
VOID BezierShape :: InitDialog(HWND hwnd)
{
	DebugBreak();
}

BOOL BezierShape :: SaveValues(HWND hwnd)
{
	DebugBreak();
	return FALSE;
}

BOOL BezierShape :: ProcessDialog(HWND hwnd, 
					UINT msg, 
					WPARAM wParam, 
					LPARAM lParam)
{
	DebugBreak();
	return FALSE;
}

//*******************************************************************
//
// RectShape
//
//
//
//*******************************************************************

BOOL RectShape :: AddPoint(HWND hwnd, Point pt)
{
	ASSERT(pts.GetCount() < 2);

	pts.Add(pt);

	// force complete on point pairs (rect) if possible
	DoneShape(hwnd);
	
	return TRUE;
}

VOID RectShape :: DoneShape(HWND hwnd)
{
	ASSERT(pts.GetCount() <= 2);

	if (pts.GetCount() == 2)
		done = TRUE;
	else
		done = FALSE;
}

BOOL RectShape :: RemovePoint(HWND hwnd)
{
	INT count = pts.GetCount();

	if (count > 0)
	{
		pts.SetCount(count-1);
		done = FALSE;
		return TRUE;
	}
	else
		return FALSE;
}

BOOL RectShape :: IsComplete()
{
	return done;
}

VOID RectShape :: DrawShape(Graphics* g)
{
	INT count = pts.GetCount();
	Point* pt1 = (Point*)pts.GetDataBuffer();
	Point* pt2 = pt1++;

	ASSERT(IsComplete());
	ASSERT(count == 2);

	if (pen && brush) 
	{
		// create appropriate rectangle
		// !! cache this?
		ERectangle rect(min(pt1->X, pt2->X),
						min(pt1->Y, pt2->Y),
						fabsf(pt1->X-pt2->X),
						fabsf(pt1->Y-pt2->Y));

		g->FillRectangle(brush->GetBrush(), rect);
		g->DrawRectangle(pen->GetPen(), rect);
	}
}

VOID RectShape :: AddToPath(GraphicsPath* path)
{
	ASSERT(Path);

	INT count = pts.GetCount();
	Point* pt1 = (Point*)pts.GetDataBuffer();
	Point* pt2 = pt1++;

	if (count < 2)
		return;

	ERectangle rect(min(pt1->X, pt2->X),
					min(pt1->Y, pt2->Y),
					fabsf(pt1->X-pt2->X),
					fabsf(pt1->Y-pt2->Y));

	path->AddRectangle(rect);
}

VOID RectShape :: AddToFile(OutputFile* outfile)
{
	Point* pt1 = (Point*)pts.GetDataBuffer();
	Point* pt2 = pt1++;

	ERectangle rect(min(pt1->X, pt2->X),
					min(pt1->Y, pt2->Y),
					fabsf(pt1->X-pt2->X),
					fabsf(pt1->Y-pt2->Y));

	
	brush->AddToFile(outfile);
	
	outfile->BlankLine();
	
	outfile->RectangleDeclaration(_T("rect"), rect);

	outfile->GraphicsCommand(_T("FillRectangle"),
							 _T("%s, %s"),
							 outfile->Ref(_T("brush")),
							 _T("rect"));
	
	outfile->BlankLine();

	pen->AddToFile(outfile);
	
	outfile->BlankLine();

	outfile->GraphicsCommand(_T("DrawRectangle"),
							 _T("%s, %s"),
							 outfile->Ref(_T("pen")),
							 _T("rect"));
}

// Configuration management functions
BOOL RectShape :: ChangeSettings(HWND hwndParent)
{
	return TRUE;
}

VOID RectShape :: Initialize()
{
	pts.Reset();
}

VOID RectShape :: Initialize(TestShape *shape)
{
}

// Dialog management functions (not used)
VOID RectShape :: InitDialog(HWND hwnd)
{
	DebugBreak();
}

BOOL RectShape :: SaveValues(HWND hwnd)
{
	DebugBreak();
	return FALSE;
}

BOOL RectShape :: ProcessDialog(HWND hwnd, 
					UINT msg, 
					WPARAM wParam, 
					LPARAM lParam)
{
	DebugBreak();
	return FALSE;
}

//*******************************************************************
//
// EllipseShape
//
//
//
//*******************************************************************

BOOL EllipseShape :: AddPoint(HWND hwnd, Point pt)
{
	ASSERT(pts.GetCount() < 2);

	pts.Add(pt);

	// force complete on point pairs (rect) if possible
	DoneShape(hwnd);
	
	return TRUE;
}

VOID EllipseShape :: DoneShape(HWND hwnd)
{
	ASSERT(pts.GetCount() <= 2);

	if (pts.GetCount() == 2)
		done = TRUE;
	else
		done = FALSE;
}

BOOL EllipseShape :: RemovePoint(HWND hwnd)
{
	INT count = pts.GetCount();

	if (count > 0)
	{
		pts.SetCount(count-1);
		done = FALSE;
		return TRUE;
	}
	else
		return FALSE;
}

BOOL EllipseShape :: IsComplete()
{
	return done;
}

VOID EllipseShape :: DrawShape(Graphics* g)
{
	INT count = pts.GetCount();
	Point* pt1 = (Point*)pts.GetDataBuffer();
	Point* pt2 = pt1++;

	ASSERT(IsComplete());
	ASSERT(count == 2);

	if (pen && brush) 
	{
		// create appropriate rectangle
		// !! cache this?
		ERectangle rect(min(pt1->X, pt2->X),
						min(pt1->Y, pt2->Y),
						fabsf(pt1->X-pt2->X),
						fabsf(pt1->Y-pt2->Y));

		g->FillEllipse(brush->GetBrush(), rect);
		g->DrawEllipse(pen->GetPen(), rect);
	}
}

VOID EllipseShape :: AddToPath(GraphicsPath* path)
{
	ASSERT(Path);

	INT count = pts.GetCount();
	Point* pt1 = (Point*)pts.GetDataBuffer();
	Point* pt2 = pt1++;

	if (count < 2) 
		return;

	ERectangle rect(min(pt1->X, pt2->X),
					min(pt1->Y, pt2->Y),
					fabsf(pt1->X-pt2->X),
					fabsf(pt1->Y-pt2->Y));

	path->AddEllipse(rect);
}

VOID EllipseShape :: AddToFile(OutputFile* outfile)
{
	Point* pt1 = (Point*)pts.GetDataBuffer();
	Point* pt2 = pt1++;

	ERectangle rect(min(pt1->X, pt2->X),
					min(pt1->Y, pt2->Y),
					fabsf(pt1->X-pt2->X),
					fabsf(pt1->Y-pt2->Y));

	brush->AddToFile(outfile);

	outfile->BlankLine();

	outfile->RectangleDeclaration(_T("rect"), rect);
	
	outfile->BlankLine();

	outfile->GraphicsCommand(_T("FillEllipse"),
							 _T("%s, %s"),
							 outfile->Ref(_T("brush")),
							 _T("rect"));
	
	outfile->BlankLine();

	pen->AddToFile(outfile);
	
	outfile->BlankLine();

	outfile->GraphicsCommand(_T("DrawEllipse"),
							 _T("%s, %s"),
							 outfile->Ref(_T("pen")),
							 _T("rect"));
}

// Configuration management functions
BOOL EllipseShape :: ChangeSettings(HWND hwndParent)
{
	return TRUE;
}

VOID EllipseShape :: Initialize()
{
	pts.Reset();
}

VOID EllipseShape :: Initialize(TestShape *shape)
{
}

// Dialog management functions (not used)
VOID EllipseShape :: InitDialog(HWND hwnd)
{
	DebugBreak();
}

BOOL EllipseShape :: SaveValues(HWND hwnd)
{
	DebugBreak();
	return FALSE;
}

BOOL EllipseShape :: ProcessDialog(HWND hwnd, 
					UINT msg, 
					WPARAM wParam, 
					LPARAM lParam)
{
	DebugBreak();
	return FALSE;
}

//*******************************************************************
//
// PieShape
//
//
//
//*******************************************************************

BOOL PieShape :: AddPoint(HWND hwnd, Point pt)
{
	ASSERT(pts.GetCount() < 2);

	pts.Add(pt);

	// force complete on point pairs (rect) if possible
	DoneShape(hwnd);
	
	return TRUE;
}

VOID PieShape :: DoneShape(HWND hwnd)
{
	if (pts.GetCount() >= 2)
	{
		done = TRUE;

		if (popup)
		{
			// !!! cheating, we use global HWND, should use
			//     HWND passed in.
			ChangeSettings(hwnd);
		}

	}
	else
		done = FALSE;
}

BOOL PieShape :: RemovePoint(HWND hwnd)
{
	INT count = pts.GetCount();

	if (count > 0)
	{
		pts.SetCount(count-1);
		done = FALSE;
		return TRUE;
	}
	else
		return FALSE;
}

BOOL PieShape :: IsComplete()
{
	return done;
}

VOID PieShape :: DrawShape(Graphics* g)
{
	INT count = pts.GetCount();
	Point* pt1 = (Point*)pts.GetDataBuffer();
	Point* pt2 = pt1++;

	ASSERT(IsComplete());
	ASSERT(count<2);

	if (pen && brush) 
	{
		// create appropriate rectangle
		// !! cache this?
		ERectangle rect(min(pt1->X, pt2->X),
						min(pt1->Y, pt2->Y),
						fabsf(pt1->X-pt2->X),
						fabsf(pt1->Y-pt2->Y));

		g->FillPie(brush->GetBrush(), rect, start, sweep);
		g->DrawPie(pen->GetPen(), rect, start, sweep);
	}
}

VOID PieShape :: AddToPath(GraphicsPath* path)
{
	ASSERT(Path);

	INT count = pts.GetCount();
	Point* pt1 = (Point*)pts.GetDataBuffer();
	Point* pt2 = pt1++;

	if (count < 2) 
		return;

	ERectangle rect(min(pt1->X, pt2->X),
					min(pt1->Y, pt2->Y),
					fabsf(pt1->X-pt2->X),
					fabsf(pt1->Y-pt2->Y));

	path->AddPie(rect, start, sweep);
}

VOID PieShape :: AddToFile(OutputFile* outfile)
{
	Point* pt1 = (Point*)pts.GetDataBuffer();
	Point* pt2 = pt1++;

	ERectangle rect(min(pt1->X, pt2->X),
					min(pt1->Y, pt2->Y),
					fabsf(pt1->X-pt2->X),
					fabsf(pt1->Y-pt2->Y));

	brush->AddToFile(outfile);

	outfile->BlankLine();

	outfile->RectangleDeclaration(_T("rect"), rect);
	
	outfile->BlankLine();

	outfile->GraphicsCommand(_T("FillPie"),
							 _T("%s, %s, %e, %e"),
							 outfile->Ref(_T("brush")),
							 _T("rect"),
							 start,
							 sweep);

	outfile->BlankLine();

	pen->AddToFile(outfile);

	outfile->BlankLine();
	
	outfile->GraphicsCommand(_T("DrawPie"),
							 _T("%s, %s, %e, %e"),
							 outfile->Ref(_T("pen")),
							 _T("rect"),
							 start,
							 sweep);
}

// Configuration management functions
BOOL PieShape :: ChangeSettings(HWND hwndParent)
{
	BOOL ok = DialogBoxParam(hInst,
							MAKEINTRESOURCE(IDD_ARC_DLG),
							hwndParent,
							AllDialogBox,
							(LPARAM)((TestDialogInterface*)this));

	return ok;
}

VOID PieShape :: Initialize()
{
	sweep = 90.0f;
	start = 0.0f;
	popup = FALSE;
};

VOID PieShape :: Initialize(TestShape *shape)
{
	// if compatible, copy parameters from another compatible shape
	if (shape && shape->GetType() == GetType())
	{
		PieShape* pieshape = static_cast<PieShape*>(shape);

		sweep = pieshape->sweep;
		start = pieshape->start;
		popup = pieshape->popup;
	}
	else
		Initialize();
}

// Dialog management functions (not used)
VOID PieShape :: InitDialog(HWND hwnd)
{
	SetWindowText(hwnd, _T("Pie Shape Parameters"));

	SetDialogReal(hwnd, IDC_ARC_START, start);
	SetDialogReal(hwnd, IDC_ARC_SWEEP, sweep);
	SetDialogCheck(hwnd, IDC_ARC_POPUP, popup);
}

BOOL PieShape :: SaveValues(HWND hwnd)
{
	start = GetDialogReal(hwnd, IDC_ARC_START);
	sweep = GetDialogReal(hwnd, IDC_ARC_SWEEP);
	popup = GetDialogCheck(hwnd, IDC_ARC_POPUP);

	// no warnings, anything goes
	return FALSE;
}

BOOL PieShape :: ProcessDialog(HWND hwnd, 
					UINT msg, 
					WPARAM wParam, 
					LPARAM lParam)
{
    if (msg == WM_COMMAND &&
        LOWORD(wParam) == IDC_OK)
    {
        if (SaveValues(hwnd))
            WarningBeep();
        else
            ::EndDialog(hwnd, TRUE);

        return TRUE;
    }

    return FALSE;
}

//*******************************************************************
//
// PolygonShape
//
//
//
//*******************************************************************

BOOL PolygonShape :: AddPoint(HWND hwnd, Point pt)
{
	pts.Add(pt);
	return TRUE;
}

VOID PolygonShape :: DoneShape(HWND hwnd)
{
	if (pts.GetCount()>=3)
		done = TRUE;
	else
		done = FALSE;
}

BOOL PolygonShape :: RemovePoint(HWND hwnd)
{
	INT count = pts.GetCount();

	if (count > 0)
	{
		pts.SetCount(count-1);
		done = FALSE;
		return TRUE;
	}
	else
		return FALSE;
}

BOOL PolygonShape :: IsComplete()
{
	return done;
}

VOID PolygonShape :: DrawShape(Graphics* g)
{
	INT count = pts.GetCount();
	Point* ptbuf = (Point*)pts.GetDataBuffer();

	ASSERT(IsComplete());
	ASSERT(count >= 3);

	if (pen && brush)
	{
		g->FillPolygon(brush->GetBrush(), ptbuf, count);
		g->DrawPolygon(pen->GetPen(), ptbuf, count);
	}
}

VOID PolygonShape :: AddToPath(GraphicsPath* path)
{
	ASSERT(Path);

	INT count = pts.GetCount();
	Point* ptbuf = (Point*)pts.GetDataBuffer();

	if (count > 2)
		path->AddPolygon(ptbuf, count);
}

VOID PolygonShape :: AddToFile(OutputFile* outfile)
{
	INT count = pts.GetCount();

	brush->AddToFile(outfile);

	outfile->BlankLine();

	outfile->PointDeclaration(_T("pts"), 
							  (Point*)pts.GetDataBuffer(),
							  count);
	
	outfile->BlankLine();

	outfile->GraphicsCommand(_T("FillPolygon"),
							 _T("%s, %s, %d"),
							 outfile->Ref(_T("brush")),
							 outfile->RefArray(_T("pts")),
							 count);
	
	outfile->BlankLine();

	pen->AddToFile(outfile);
	
	outfile->BlankLine();

	outfile->GraphicsCommand(_T("DrawPolygon"),
							 _T("%s, %s, %d"),
							 outfile->Ref(_T("pen")),
							 outfile->RefArray(_T("pts")),
							 count);
}

// Configuration management functions
BOOL PolygonShape :: ChangeSettings(HWND hwnd)
{
	return TRUE;
}

VOID PolygonShape :: Initialize()
{
	// do nothing
};

VOID PolygonShape :: Initialize(TestShape* shape)
{
	// do nothing
}

// Dialog management functions (not used)
VOID PolygonShape :: InitDialog(HWND hwnd)
{
	DebugBreak();
}

BOOL PolygonShape :: SaveValues(HWND hwnd)
{
	DebugBreak();
	return FALSE;
}

BOOL PolygonShape :: ProcessDialog(HWND hwnd, 
					UINT msg, 
					WPARAM wParam, 
					LPARAM lParam)
{
	DebugBreak();
	return FALSE;
}

//*******************************************************************
//
// CurveShape
//
//
//
//*******************************************************************

BOOL CurveShape :: AddPoint(HWND hwnd, Point pt)
{
	pts.Add(pt);
	
	return TRUE;
}

VOID CurveShape :: DoneShape(HWND hwnd)
{
	if (pts.GetCount() >= 2)
	{
		done = TRUE;

		if (popup)
		{
			// !!! cheating, we use global HWND, should use
			//     HWND passed in.
			ChangeSettings(hwnd);
		}

	}
	else
		done = FALSE;
}

BOOL CurveShape :: RemovePoint(HWND hwnd)
{
	INT count = pts.GetCount();

	if (count > 0)
	{
		pts.SetCount(count-1);
		done = FALSE;
		return TRUE;
	}
	else
		return FALSE;
}

BOOL CurveShape :: IsComplete()
{
	return done;
}

VOID CurveShape :: DrawShape(Graphics* g)
{
	INT count = pts.GetCount();
	Point* ptbuf = (Point*)pts.GetDataBuffer();

	ASSERT(IsComplete());
	ASSERT(count<2);

	if (pen) 
	{
		g->DrawCurve(pen->GetPen(), ptbuf, count, offset, numSegments, tension);
	}
}

VOID CurveShape :: AddToPath(GraphicsPath* path)
{
	ASSERT(Path);

	INT count = pts.GetCount();
	Point* ptbuf = (Point*)pts.GetDataBuffer();

	if (count > 2)
		path->AddCurve(ptbuf, count, tension, offset, numSegments);
}

VOID CurveShape :: AddToFile(OutputFile* outfile)
{
	INT count = pts.GetCount();

	pen->AddToFile(outfile);

	outfile->BlankLine();

	outfile->PointDeclaration(_T("pts"),
							  (Point*)pts.GetDataBuffer(),
							  count);
	
	outfile->BlankLine();

	outfile->GraphicsCommand(_T("DrawCurve"),
							 _T("%s, %s, %d, %d, %d, %e"),
							 outfile->Ref(_T("pen")),
							 outfile->RefArray(_T("pts")),
							 count,
							 offset,
							 numSegments,
							 tension);
}

// Configuration management functions
BOOL CurveShape :: ChangeSettings(HWND hwndParent)
{
	BOOL ok = DialogBoxParam(hInst,
							MAKEINTRESOURCE(IDD_CURVE_DLG),
							hwndParent,
							AllDialogBox,
							(LPARAM)((TestDialogInterface*)this));

	return ok;
}

VOID CurveShape :: Initialize()
{
	tension = 0.0;
	offset = 0;
	numSegments = 1;
	popup = FALSE;
};

VOID CurveShape :: Initialize(TestShape *shape)
{
	// if compatible, copy parameters from another compatible shape
	if (shape && shape->GetType() == GetType())
	{
		CurveShape* curveshape = static_cast<CurveShape*>(shape);

		tension = curveshape->tension;
		offset = curveshape->offset;
		numSegments = curveshape->numSegments;
		popup = curveshape->popup;
	}
	else
		Initialize();
}

// Dialog management functions (not used)
VOID CurveShape :: InitDialog(HWND hwnd)
{
	SetDialogReal(hwnd, IDC_CURVE_TENSION, tension);
	SetDialogLong(hwnd, IDC_CURVE_OFFSET, offset);
	SetDialogLong(hwnd, IDC_CURVE_SEGMENTS, numSegments);
	SetDialogCheck(hwnd, IDC_ARC_POPUP, popup);
}

BOOL CurveShape :: SaveValues(HWND hwnd)
{
	tension = GetDialogReal(hwnd, IDC_CURVE_TENSION);
	offset = GetDialogLong(hwnd, IDC_CURVE_OFFSET);
	numSegments = GetDialogLong(hwnd, IDC_CURVE_SEGMENTS);
	popup = GetDialogCheck(hwnd, IDC_ARC_POPUP);

	// !! could add some warnings...
	// no warnings, anything goes
	return FALSE;
}

BOOL CurveShape :: ProcessDialog(HWND hwnd, 
					UINT msg, 
					WPARAM wParam, 
					LPARAM lParam)
{
	if (msg == WM_COMMAND &&
		LOWORD(wParam) == IDC_OK)
	{
		if (SaveValues(hwnd))
			WarningBeep();
		else
			::EndDialog(hwnd, TRUE);

		return TRUE;
	}

	return FALSE;
}

//*******************************************************************
//
// ClosedCurveShape
//
//
//
//*******************************************************************

BOOL ClosedCurveShape :: AddPoint(HWND hwnd, Point pt)
{
	pts.Add(pt);
	
	return TRUE;
}

VOID ClosedCurveShape :: DoneShape(HWND hwnd)
{
	if (pts.GetCount() >= 2)
	{
		done = TRUE;

		if (popup)
		{
			// !!! cheating, we use global HWND, should use
			//     HWND passed in.
			ChangeSettings(hwnd);
		}

	}
	else
		done = FALSE;
}

BOOL ClosedCurveShape :: RemovePoint(HWND hwnd)
{
	INT count = pts.GetCount();

	if (count > 0)
	{
		pts.SetCount(count-1);
		done = FALSE;
		return TRUE;
	}
	else
		return FALSE;
}

BOOL ClosedCurveShape :: IsComplete()
{
	return done;
}

VOID ClosedCurveShape :: DrawShape(Graphics* g)
{
	INT count = pts.GetCount();
	Point* ptbuf = (Point*)pts.GetDataBuffer();

	ASSERT(IsComplete());
	ASSERT(count<2);

	if (pen && brush) 
	{
		g->FillClosedCurve(brush->GetBrush(), ptbuf, count, tension, Alternate);
		g->DrawClosedCurve(pen->GetPen(), ptbuf, count, tension);
	}
}

VOID ClosedCurveShape :: AddToPath(GraphicsPath* path)
{
	ASSERT(Path);

	INT count = pts.GetCount();
	Point* ptbuf = (Point*)pts.GetDataBuffer();

	if (count > 2)
		path->AddClosedCurve(ptbuf, count, tension);
}

VOID ClosedCurveShape :: AddToFile(OutputFile* outfile)
{
	INT count = pts.GetCount();

	brush->AddToFile(outfile);

	outfile->BlankLine();

	outfile->PointDeclaration(_T("pts"),
							  (Point*)pts.GetDataBuffer(),
							  count);
	
	outfile->BlankLine();

	outfile->GraphicsCommand(_T("FillClosedCurve"),
							 _T("%s, %s, %d, %e, %s"),
							 outfile->Ref(_T("brush")),
							 outfile->RefArray(_T("pts")),
							 count,
							 tension,							 
							 _T("Alternate"));
	
	outfile->BlankLine();

	pen->AddToFile(outfile);
	
	outfile->BlankLine();

	outfile->GraphicsCommand(_T("DrawClosedCurve"),
							 _T("%s, %s, %d, %e"),
							 outfile->Ref(_T("pen")),
							 outfile->RefArray(_T("pts")),
							 count,
							 tension);
}

// Configuration management functions
BOOL ClosedCurveShape :: ChangeSettings(HWND hwndParent)
{
	BOOL ok = DialogBoxParam(hInst,
							MAKEINTRESOURCE(IDD_CURVE_DLG),
							hwndParent,
							AllDialogBox,
							(LPARAM)((TestDialogInterface*)this));

	return ok;
}

VOID ClosedCurveShape :: Initialize()
{
	tension = 0.0;
	popup = FALSE;
};

VOID ClosedCurveShape :: Initialize(TestShape *shape)
{
	// if compatible, copy parameters from another compatible shape
	if (shape && shape->GetType() == GetType())
	{
		ClosedCurveShape* closedcurveshape = 
					static_cast<ClosedCurveShape*>(shape);

		tension = closedcurveshape->tension;
		popup = closedcurveshape->popup;
	}
	else
		Initialize();
}

// Dialog management functions (not used)
VOID ClosedCurveShape :: InitDialog(HWND hwnd)
{
	SetWindowText(hwnd, _T("Closed Curve Shape Parameters"));
	SetDialogReal(hwnd, IDC_CURVE_TENSION, tension);
	SetDialogLong(hwnd, IDC_CURVE_OFFSET, 0, FALSE);
	SetDialogLong(hwnd, IDC_CURVE_SEGMENTS, 0, FALSE);
	SetDialogCheck(hwnd, IDC_ARC_POPUP, popup);
}

BOOL ClosedCurveShape :: SaveValues(HWND hwnd)
{
	tension = GetDialogReal(hwnd, IDC_CURVE_TENSION);
	popup = GetDialogCheck(hwnd, IDC_ARC_POPUP);

	// no warnings, anything goes
	return FALSE;
}

BOOL ClosedCurveShape :: ProcessDialog(HWND hwnd, 
					UINT msg, 
					WPARAM wParam, 
					LPARAM lParam)
{
	if (msg == WM_COMMAND &&
		LOWORD(wParam) == IDC_OK)
	{
		if (SaveValues(hwnd))
			WarningBeep();
		else
			::EndDialog(hwnd, TRUE);

		return TRUE;
	}

	return FALSE;
}

//*******************************************************************
//
// TestTriangleGradShape
//
//
//
//*******************************************************************

BOOL TestTriangleGradShape :: AddPoint(HWND hwnd, Point pt)
{
	return FALSE;
}

VOID TestTriangleGradShape :: DoneShape(HWND hwnd)
{
	DebugBreak();
}

BOOL TestTriangleGradShape :: EndPoint(HWND hwnd, Point pt)
{
	curIndex = FindControlPoint(pt);

	// we aren't at a control point, no dialog box
	if (curIndex < 0)
	{
		WarningBeep();
	}
	else
	{
		// pop-up dialog to configure color & blend at this point.
		return ChangeSettings(hwnd);
	}

	return FALSE;
}

BOOL TestTriangleGradShape :: RemovePoint(HWND hwnd)
{
	return FALSE;
}

BOOL TestTriangleGradShape :: IsComplete()
{
	return TRUE;
}

BOOL TestTriangleGradShape :: MoveControlPoint(Point origPt, Point newPt)
{
	INT pos = 0;

	// !!! what if multiple control points overlap?
	//     can't get to one of them
	for (pos = 0; pos<3; pos++)
	{
		Point *ctrlPt = &pts[pos];

		ERectangle ctrlRect(ctrlPt->X-pointRadius,
							ctrlPt->Y-pointRadius,
							2*pointRadius,
							2*pointRadius);

		if (origPt.X>ctrlPt->X-pointRadius &&
			origPt.X<ctrlPt->X+pointRadius &&
			origPt.Y>ctrlPt->Y-pointRadius &&
			origPt.Y<ctrlPt->Y+pointRadius)
		{
			ctrlPt->X = newPt.X;
			ctrlPt->Y = newPt.Y;

			gdiBrush->SetTriangle(&pts[0]);

			return TRUE;
		}
	}

	return FALSE;
}

VOID TestTriangleGradShape :: DrawShape(Graphics* g)
{
	if (gdiBrush)
		g->FillPolygon(gdiBrush, (Point*)&pts[0], 3);
}

// Configuration management functions
BOOL TestTriangleGradShape :: ChangeSettings(HWND hwndParent)
{
	BOOL ok = DialogBoxParam(hInst,
							MAKEINTRESOURCE(IDD_TRIGRAD_DLG2),
							hwndParent,
							AllDialogBox,
							(LPARAM)((TestDialogInterface*)this));

	if (ok)
	{
		// !! really only need to set one blend & color, but
		//    the API requires we set all three.

		gdiBrush->SetBlend0(blend[0], count[0]);
		gdiBrush->SetBlend1(blend[1], count[1]);
		gdiBrush->SetBlend2(blend[2], count[2]);
	
		Color colors[3] =
		{
			Color(argb[0]),
			Color(argb[1]),
			Color(argb[2])
		};

		gdiBrush->SetColors(&colors[0]);

		gdiBrush->SetTriangle(&pts[0]);
	}

	return ok;
}

VOID TestTriangleGradShape :: Initialize()
{
	DebugBreak();
};

VOID TestTriangleGradShape :: Initialize(TestShape* shape)
{
	DebugBreak();
}	

VOID TestTriangleGradShape :: Initialize(Point* newPts,
										 ARGB* newArgb,
										 REAL** newBlend,
										 INT* newBlendCount)
{
	Color color[3];

	pts.Reset();
	argb.Reset();

	for (INT i = 0; i < 3; i++)
	{
		pts.Add(newPts[i]);
		argb.Add(newArgb[i]);

		count[i] = newBlendCount[i];

		if (count[i])
		{
			blend[i] = (REAL*) malloc(sizeof(REAL)*count[i]);
			memcpy(blend[i], newBlend[i], sizeof(REAL)*count[i]);
		}
		else
			blend[i] = NULL;

		color[i] = Color(argb[i]);
	}

	gdiBrush = new TriangleGradientBrush(newPts, &color[0]);

	gdiBrush->SetBlend0(blend[0], count[0]);
	gdiBrush->SetBlend1(blend[1], count[1]);
	gdiBrush->SetBlend2(blend[2], count[2]);
}

// Dialog management functions (not used)
VOID TestTriangleGradShape :: InitDialog(HWND hwnd)
{
	tmpArgb = argb[curIndex];

	SetDialogLong(hwnd, IDC_TRIGRAD_ALPHA, (tmpArgb & Color::AlphaMask) >> Color::AlphaShift);
	SetDialogRealList(hwnd, IDC_TRIGRAD_BLEND, blend[curIndex], count[curIndex]);
}

BOOL TestTriangleGradShape :: SaveValues(HWND hwnd)
{
	argb[curIndex] = ((tmpArgb & ~Color::AlphaMask) |
						(GetDialogLong(hwnd, IDC_TRIGRAD_ALPHA) 
							<< Color::AlphaShift));

	if (count[curIndex] > 0) 
		free(blend[curIndex]);

	GetDialogRealList(hwnd, IDC_TRIGRAD_BLEND, &(blend[curIndex]), 
											   &(count[curIndex]));
	return FALSE;
}

BOOL TestTriangleGradShape :: ProcessDialog(HWND hwnd, 
					UINT msg, 
					WPARAM wParam, 
					LPARAM lParam)
{
	if (msg == WM_COMMAND)
	{
		switch(LOWORD(wParam))
		{
		case IDC_OK:
			if (SaveValues(hwnd))
				WarningBeep();
			else
				::EndDialog(hwnd, TRUE);
			break;

		case IDC_TRIGRAD_COLORBUTTON:
			UpdateRGBColor(hwnd, IDC_TRIGRAD_PIC, tmpArgb);
			break;

		case IDC_REFRESH_PIC:
			UpdateColorPicture(hwnd, IDC_TRIGRAD_PIC, tmpArgb);
			break;

		case IDC_CANCEL:
			::EndDialog(hwnd, FALSE);
			break;

		default:
			return FALSE;
		}

		return TRUE;
	}

	return FALSE;
}

//*******************************************************************
//
// TestPathGradShape
//
//
//
//*******************************************************************

BOOL TestPathGradShape :: AddPoint(HWND hwnd, Point pt)
{
	// Find point pair to insert between
	// INT insertAt = FindLocationToInsert(pt);

	curIndex = pts.GetCount();

	pts.Add(pt);
	argb.Add(0x80000000);

	if(!ChangeSettings(hwnd))
	{
		// undo this add, we canceled the point.
		pts.SetCount(curIndex);
	}

	return FALSE;
}

VOID TestPathGradShape :: DoneShape(HWND hwnd)
{
	DebugBreak();
}

BOOL TestPathGradShape :: EndPoint(HWND hwnd, Point pt)
{
	curIndex = FindControlPoint(pt);

	// we aren't at a control point, no dialog box
	if (curIndex < 0)
	{
		WarningBeep();
	}
	else
	{
		// pop-up dialog to configure color & blend at this point.
		return ChangeSettings(hwnd);
	}

	return FALSE;
}

BOOL TestPathGradShape :: RemovePoint(HWND hwnd)
{
	INT count = pts.GetCount();

	if (count > 4)
	{
		pts.SetCount(count-1);
		return TRUE;
	}
	else
		return FALSE;
}

BOOL TestPathGradShape :: IsComplete()
{
	return TRUE;
}

BOOL TestPathGradShape :: MoveControlPoint(Point origPt, Point newPt)
{
	INT count = pts.GetCount();
	INT pos = 0;

	// !!! what if multiple control points overlap?
	//     can't get to one of them
	for (pos = 0; pos<count; pos++)
	{
		Point *ctrlPt = &pts[pos];

		ERectangle ctrlRect(ctrlPt->X-pointRadius,
							ctrlPt->Y-pointRadius,
							2*pointRadius,
							2*pointRadius);

		if (origPt.X>ctrlPt->X-pointRadius &&
			origPt.X<ctrlPt->X+pointRadius &&
			origPt.Y>ctrlPt->Y-pointRadius &&
			origPt.Y<ctrlPt->Y+pointRadius)
		{
			ctrlPt->X = newPt.X;
			ctrlPt->Y = newPt.Y;

			if (pos > 0)
				gdiBrush->SetPoint(ctrlPt,pos-1);
			else
				gdiBrush->SetCenterPoint(*ctrlPt);

			return TRUE;
		}
	}

	return FALSE;
}

VOID TestPathGradShape :: DrawShape(Graphics* g)
{
	INT count = pts.GetCount();
	Point* ptbuf = (Point*)pts.GetDataBuffer();

	if (gdiBrush)
		g->FillPolygon(gdiBrush, (Point*)&pts[1], count-1);
}

// Configuration management functions
BOOL TestPathGradShape :: ChangeSettings(HWND hwndParent)
{
	BOOL ok = DialogBoxParam(hInst,
							MAKEINTRESOURCE(IDD_POLYGRAD_DLG2),
							hwndParent,
							AllDialogBox,
							(LPARAM)((TestDialogInterface*)this));

	if (ok)
	{
		delete gdiBrush;

		gdiBrush = new PathGradientBrush((Point*)&pts[1], 
										pts.GetCount()-1);

		// set blending factors
		gdiBrush->SetBlend(centerBlend, centerCount);
		//gdiBrush->SetSurroundBlend(surroundBlend, surroundCount);

		// set colors
		Color center(argb[0]);
		gdiBrush->SetCenterColor(center);

		for (INT pos = 1; pos < pts.GetCount(); pos++)
		{
			Color color(argb[pos]);
			gdiBrush->SetSurroundColor(color, pos-1);
		}

		// set points
		gdiBrush->SetCenterPoint(pts[0]);
		gdiBrush->SetPolygon(&pts[1]);
	}

	return ok;
}

VOID TestPathGradShape :: Initialize()
{
	DebugBreak();
};

VOID TestPathGradShape :: Initialize(TestShape* shape)
{
	DebugBreak();
}	

VOID TestPathGradShape :: Initialize(PointArray* newPts,
										ARGBArray* newArgb,
										REAL* newSurroundBlend,
										INT newSurroundCount,
										REAL* newCenterBlend,
										INT newCenterCount)
{
	INT pos;

	pts.Reset();
	argb.Reset();
	
	for (pos = 0; pos < newPts->GetCount(); pos++)
	{
		pts.Add((*newPts)[pos]);
		argb.Add((*newArgb)[pos]);
	}

	surroundCount = newSurroundCount;
	centerCount = newCenterCount;

	if (surroundCount && newSurroundBlend)
	{
		surroundBlend = (REAL*) malloc(sizeof(REAL)*surroundCount);
		memcpy(surroundBlend, newSurroundBlend, sizeof(REAL)*surroundCount);
	}
	else
		surroundBlend = NULL;
	
	if (centerCount && newCenterBlend)
	{
		centerBlend = (REAL*) malloc(sizeof(REAL)*centerCount);
		memcpy(centerBlend, newCenterBlend, sizeof(REAL)*centerCount);
	}
	else
		centerBlend = NULL;

	gdiBrush = new PathGradientBrush((Point*)&pts[1], 
										newPts->GetCount()-1);

	gdiBrush->SetCenterPoint(pts[0]);
	Color centerColor(argb[0]);
	gdiBrush->SetCenterColor(centerColor);

	for (pos = 1; pos < pts.GetCount(); pos++)
	{
		Color color(argb[pos]);
		gdiBrush->SetSurroundColor(color, pos-1);
	}

	// set blending factors
	gdiBrush->SetBlend(centerBlend, centerCount);
	//gdiBrush->SetSurroundBlend(surroundBlend, surroundCount);
}

// Dialog management functions (not used)
VOID TestPathGradShape :: InitDialog(HWND hwnd)
{
	tmpArgb = argb[curIndex];

	SetDialogLong(hwnd, IDC_POLYGRAD_ALPHA, (tmpArgb & Color::AlphaMask) >> Color::AlphaShift);

	if (curIndex)
	{
		SetDialogRealList(hwnd, 
						  IDC_POLYGRAD_BLEND,
						  surroundBlend, 
						  surroundCount);
	}
	else
	{
		SetDialogRealList(hwnd, 
						  IDC_POLYGRAD_BLEND, 
						  centerBlend, 
						  centerCount);
	}

}

BOOL TestPathGradShape :: SaveValues(HWND hwnd)
{
	argb[curIndex] = ((tmpArgb & ~Color::AlphaMask) |
						(GetDialogLong(hwnd, IDC_POLYGRAD_ALPHA) 
							<< Color::AlphaShift));

	if (curIndex)
	{
		if (surroundBlend)
			free(surroundBlend);

		GetDialogRealList(hwnd, IDC_POLYGRAD_BLEND, &surroundBlend, 
												    &surroundCount);
	}
	else
	{
		if (centerBlend)
			free(centerBlend);
		
		GetDialogRealList(hwnd, IDC_POLYGRAD_BLEND, &centerBlend,
													&centerCount);
	}

	return FALSE;
}

BOOL TestPathGradShape :: ProcessDialog(HWND hwnd, 
					UINT msg, 
					WPARAM wParam, 
					LPARAM lParam)
{
	if (msg == WM_COMMAND)
	{
		switch(LOWORD(wParam))
		{
		case IDC_OK:
			if (SaveValues(hwnd))
				WarningBeep();
			else
				::EndDialog(hwnd, TRUE);
			break;

		case IDC_POLYGRAD_COLORBUTTON:
			UpdateRGBColor(hwnd, IDC_POLYGRAD_PIC, tmpArgb);
			break;

		case IDC_REFRESH_PIC:
			UpdateColorPicture(hwnd, IDC_POLYGRAD_PIC, tmpArgb);
			break;

		case IDC_CANCEL:
			::EndDialog(hwnd, FALSE);
			break;

		default:
			return FALSE;
		}

		return TRUE;
	}

	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\gdiptest\gdipoutput.hpp ===
class OutputFile
{
public:
	OutputFile(FILE* out)
	{
		outfile = out;
		tabs = 0;
		tabStr[0] = '\0';
	}

	~OutputFile()
	{
		if (outfile)
		{
			fflush(outfile);
			fclose(outfile);
		}
	}

	static OutputFile* CreateOutputFile(LPTSTR filename);

	virtual VOID GraphicsProcedure() = 0;
	virtual VOID GraphicsDeclaration() = 0;

	virtual VOID PointDeclaration(LPCTSTR pointName, Point* pts, INT count = -1) = 0;
	virtual VOID ColorDeclaration(LPCTSTR colorName, ARGB* argb, INT count = -1) = 0;
	virtual VOID RectangleDeclaration(LPCTSTR rectName, ERectangle& rect) = 0;

	virtual VOID Declaration(LPCTSTR type,
						     LPCTSTR object,
						     LPCTSTR argList,
						     ...) = 0;

	// set matrix, do nothing if identity matrix
	virtual VOID SetPointDeclaration(LPCTSTR object,
									 LPCTSTR command,
									 LPCTSTR varName,
									 Point* pts,
									 INT count = -1,
									 BOOL ref = FALSE) = 0;
	
	virtual VOID SetColorDeclaration(LPCTSTR object,
									 LPCTSTR command,
									 LPCTSTR varName,
									 ARGB* colors,
									 INT count = -1,
									 BOOL ref = FALSE) = 0;

	virtual VOID SetMatrixDeclaration(LPCTSTR object,
									  LPCTSTR command,
									  LPCTSTR varName,
									  Matrix* matrix) = 0;

 	virtual VOID SetBlendDeclaration(LPCTSTR object,
									 LPCTSTR command,
									 LPCTSTR varName,
									 REAL* blend,
									 INT count) = 0;

	virtual VOID GraphicsCommand(LPCTSTR command,
				 				 LPCTSTR argList,
								 ...) = 0;

	virtual VOID ObjectCommand(LPCTSTR object,
							   LPCTSTR command,
							   LPCTSTR argList,
							   ...) = 0;

	virtual VOID BeginIndent() = 0;
	virtual VOID EndIndent() = 0;
	virtual VOID BlankLine() = 0;

	virtual LPTSTR Ref(LPCTSTR) = 0;
	virtual LPTSTR RefArray(LPCTSTR refStr) = 0;
	virtual LPTSTR WStr(LPCTSTR) = 0;

protected:
	FILE* outfile;
	INT tabs;
	TCHAR tabStr[MAX_PATH];
};

class CPPOutputFile : public OutputFile
{
public:
	CPPOutputFile(FILE* out) : OutputFile(out) {}

	virtual VOID GraphicsProcedure();
	virtual VOID GraphicsDeclaration();

	virtual VOID PointDeclaration(LPCTSTR pointName, Point* pts, INT count = -1);
	virtual VOID ColorDeclaration(LPCTSTR colorName, ARGB* argb, INT count = -1);
	virtual VOID RectangleDeclaration(LPCTSTR rectName, ERectangle& rect);

	virtual VOID Declaration(LPCTSTR type,
						     LPCTSTR object,
						     LPCTSTR argList,
							 ...);

	// set matrix, do nothing if identity matrix
	virtual VOID SetPointDeclaration(LPCTSTR object,
									 LPCTSTR command,
									 LPCTSTR varName,
									 Point* pts,
									 INT count = -1,
									 BOOL ref = FALSE);
	
	virtual VOID SetColorDeclaration(LPCTSTR object,
									 LPCTSTR command,
									 LPCTSTR varName,
									 ARGB* colors,
									 INT count = -1,
									 BOOL ref = FALSE);

	virtual VOID SetMatrixDeclaration(LPCTSTR object,
									  LPCTSTR command,
									  LPCTSTR varName,
									  Matrix* matrix);

 	virtual VOID SetBlendDeclaration(LPCTSTR object,
									 LPCTSTR command,
									 LPCTSTR varName,
									 REAL* blend,
									 INT count);

	virtual VOID GraphicsCommand(LPCTSTR command,
				 				 LPCTSTR argList,
								 ...);

	virtual VOID ObjectCommand(LPCTSTR object,
							   LPCTSTR command,
							   LPCTSTR argList,
							   ...);

	virtual VOID BeginIndent();
	virtual VOID EndIndent();
	virtual VOID BlankLine();

	// add '&' to constant
	virtual LPTSTR Ref(LPCTSTR refStr);
	
	// add '&' name '[x]'
	virtual LPTSTR RefArray(LPCTSTR refStr);

	// Add 'L' to constant
	virtual LPTSTR WStr(LPCTSTR refStr);
};

class JavaOutputFile : public CPPOutputFile
{
public:
	JavaOutputFile(FILE* out) : CPPOutputFile(out) {};
};

class VMLOutputFile : public CPPOutputFile
{
public:
	VMLOutputFile(FILE* out) : CPPOutputFile(out) {};
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\gdiptest\gdiputils.cpp ===
#include "gdiptest.h"

//*******************************************************************
//
// AllBrushDialog 
//
//
//
//*******************************************************************

inline VOID NotImplementedBox()
{
	MessageBox(NULL, _T("Not Implemented") , _T(""),MB_OK);
};

inline VOID WarningBox(TCHAR* string)
{
	MessageBox(NULL, string, _T(""), MB_OK);
};

VOID WarningBeep()
{
	Beep(5000 /* hertz */, 400 /* milliseconds */);
}

Brush* blackBrush = NULL;
Brush* backBrush = NULL;
Pen* blackPen = NULL;
Color* blackColor = NULL;

	const TCHAR* tabStr = _T("    ");

	const TCHAR* formatList[numFormats] =
	{
		_T("CPP File"),
		_T("Java File"),
		_T("VML File")
	};

	const FormatType formatValue[numFormats] =
	{
		CPPFile,
		JavaFile,
		VMLFile
	};

	const TCHAR* shapeList[numShapes] =
	{
		_T("Line"),
		_T("Arc"),
		_T("Bezier"),
		_T("Rectangle"),
		_T("Ellipse"),
		_T("Pie"),
		_T("Polygon"),
		_T("Curve (Spline)"),
		_T("Closed Curve")
	};

	const INT shapeValue[numShapes] =
	{
		LineType,
		ArcType,
		BezierType,
		RectType,
		EllipseType,
		PieType,
		PolygonType,
		CurveType,
		ClosedCurveType
	};
		
	const INT inverseShapeValue[numShapes] =	// index by ShapeType
	{
		0,
		1,
		2,
		3,
		4,
		5,
		6,
		7,
		8
	};

	const TCHAR* brushList[numBrushes] =
	{
		_T("Solid"),
		_T("Texture (Bitmap)"),
		_T("Rectangle Gradient"),
		_T("Radial Gradient"),
		_T("Triangle Gradient"),
		_T("Polygon Gradient"),
		_T("Hatch")	
	};

	const INT brushValue[numBrushes] = 
	{
		SolidColorBrush,
		TextureFillBrush,
		RectGradBrush,
		RadialGradBrush,
		TriangleGradBrush,
		PathGradBrush,
		HatchFillBrush
	};

	const INT inverseBrushValue[numBrushes] = // index by BrushType
	{
		0,
		6,
		1,
		2,
		3,
		4,
		5
	};

	const TCHAR* capList[numCaps] = 
	{ 
		_T("Square"),
		_T("Round"),
		_T("Flat"),
		_T("Arrow"),
		_T("Diamond"),
		_T("Round") 
	};
	
	const TCHAR* capStr[numCaps] = 
	{ 
		_T("SquareCap"),
		_T("RoundCap"),
		_T("FlatCap"),
		_T("ArrowAnchor"),
		_T("DiamondAnchor"),
		_T("RoundAnchor") 
	};
	
	const LineCap capValue[numCaps] = 
	{
		SquareCap,
		RoundCap,
		FlatCap,
		ArrowAnchor,
		DiamondAnchor,
		RoundAnchor
	};

	const TCHAR* dashCapList[numDashCaps] = 
	{ 
		_T("Flat"),
		_T("Round"),
		_T("Triangle")
	};
	
	const TCHAR* dashCapStr[numDashCaps] = 
	{ 
		_T("FlatCap"),
		_T("RoundCap"),
		_T("TriangleCap")
	};
	
	const DashCap dashCapValue[numDashCaps] = 
	{
		FlatCap,
		RoundCap,
		TriangleCap
	};

	const TCHAR* joinList[numJoin] =
	{
		_T("Miter"),
		_T("Round"),
		_T("Bevel")
	};
	
	const TCHAR* joinStr[numJoin] =
	{
		_T("MiterJoin"),
		_T("RoundJoin"),
		_T("BevelJoin")
	};

	const LineJoin joinValue[numJoin] =
	{
		MiterJoin,
		RoundJoin,
		BevelJoin
	};

	const TCHAR* dashList[numDash] =
	{
		_T("Solid"),
		_T("Dash"),
		_T("Dot"),
		_T("Dash Dot"),
		_T("Dash Dot Dot")
	};

	const TCHAR* dashStr[numDash] =
	{
		_T("Solid"),
		_T("Dash"),
		_T("Dot"),
		_T("DashDot"),
		_T("DashDotDot")
	};

	const DashStyle dashValue[numDash] =
	{
		Solid,
		Dash,
		Dot,
		DashDot,
		DashDotDot
	};

	const TCHAR* wrapList[numWrap] =
	{
		_T("Tile"),
		_T("Tile Flip X"),
		_T("Tile Flip Y"),
		_T("Tile Flip XY"),
		_T("Clamp"),
		_T("Extrapolate")
	};

	const TCHAR* wrapStr[numWrap] =
	{
		_T("Tile"),
		_T("TileFlipX"),
		_T("TileFlipY"),
		_T("TileFlipXY"),
		_T("Clamp"),
		_T("Extrapolate")
	};

	const WrapMode wrapValue[numWrap] =
	{
		Tile,
		TileFlipX,
		TileFlipY,
		TileFlipXY,
		Clamp,
		Extrapolate
	};

	const TCHAR* hatchList[numHatch] =
	{
		_T("Forward Diagonal"),
		_T("Backward Diagonal"),
		_T("Cross"),
		_T("Diagonal Cross"),
		_T("Horizontal"),
		_T("Vertical")
	};

	const TCHAR* hatchStr[numHatch] =
	{
		_T("ForwardDiagonal"),
		_T("BackwardDiagonal"),
		_T("Cross"),
		_T("DiagonalCross"),
		_T("Horizontal"),
		_T("Vertical")
	};

	const HatchStyle hatchValue[numHatch] =
	{
		ForwardDiagonal,
		BackwardDiagonal,
		Cross,
		DiagonalCross,
		Horizontal,
		Vertical
	};

VOID SetDialogLong(HWND hwnd, UINT idc, UINT value, BOOL enable)
{
	HWND hwndControl;
	TCHAR tmp[256];

	hwndControl = GetDlgItem(hwnd, idc);
	_stprintf(tmp, _T("%ld"), value);
	SendMessage(hwndControl, WM_SETTEXT, 0, (LPARAM)&tmp[0]);

	EnableWindow(hwndControl, enable);

	DeleteObject(hwndControl);
}

UINT GetDialogLong(HWND hwnd, UINT idc)
{
	HWND hwndControl;
	TCHAR tmp[256];
	UINT value = 0;

	hwndControl = GetDlgItem(hwnd, idc);
	SendMessage(hwndControl, WM_GETTEXT, 255, (LPARAM)&tmp[0]);
	_stscanf(tmp,_T("%ld"), &value);

	DeleteObject(hwndControl);

	return value;
}

VOID SetDialogText(HWND hwnd, UINT idc, LPTSTR text, BOOL enable)
{
	HWND hwndControl;

	hwndControl = GetDlgItem(hwnd, idc);

	SendMessage(hwndControl, WM_SETTEXT, 0, (LPARAM)text);

	EnableWindow(hwndControl, enable);

	DeleteObject(hwndControl);
}

VOID GetDialogText(HWND hwnd, UINT idc, LPTSTR text, INT maxSize)
{
	HWND hwndControl;
	UINT value = 0;

	hwndControl = GetDlgItem(hwnd, idc);
	SendMessage(hwndControl, WM_GETTEXT, maxSize, (LPARAM)text);

	DeleteObject(hwndControl);
}

VOID SetDialogReal(HWND hwnd, UINT idc, REAL value)
{
	HWND hwndControl;
	TCHAR tmp[256];

	hwndControl = GetDlgItem(hwnd, idc);
	_stprintf(tmp, _T("%8.3f"), value);
	SendMessage(hwndControl, WM_SETTEXT, 0, (LPARAM)&tmp[0]);

	DeleteObject(hwndControl);
}

REAL GetDialogReal(HWND hwnd, UINT idc)
{
	HWND hwndControl;
	TCHAR tmp[256];
	REAL value = 0.0f;

	hwndControl = GetDlgItem(hwnd, idc);
	SendMessage(hwndControl, WM_GETTEXT, 255, (LPARAM)&tmp[0]);
	_stscanf(tmp, _T("%f"), &value);

	DeleteObject(hwndControl);

	return value;
}

VOID SetDialogRealList(HWND hwnd, UINT idc, REAL* blend, INT count)
{
	HWND hwndControl;
	TCHAR buf[4*MAX_PATH];
	TCHAR tmp[MAX_PATH];

	hwndControl = GetDlgItem(hwnd, idc);

	buf[0] = _T('\0');

	for (INT i = 0; i < count; i++)
	{
		_stprintf(tmp, _T("%.2f"), blend[i]);
		_tcscat(buf, tmp);
		if (i != count-1)
			_tcscat(buf, _T(" "));
	}

	SendMessage(hwndControl, WM_SETTEXT, 0, (LPARAM)buf);

	DeleteObject(hwndControl);
}

VOID GetDialogRealList(HWND hwnd, UINT idc, REAL** blend, INT *count)
{
	HWND hwndControl;
	TCHAR buf[4*MAX_PATH];
	TCHAR* curpos = &buf[0];
	REAL value;
	INT pos;

	const LPTSTR seps = _T(" \n\r,\t");

	hwndControl = GetDlgItem(hwnd, idc);
	SendMessage(hwndControl, WM_GETTEXT, 4*MAX_PATH, (LPARAM)buf);

	INT newCount = 0;

	curpos = _tcstok(&buf[0], seps);

	// find number of real values in list
	while (curpos)
	{
		if ((curpos[0] >= '0' && curpos[0] <= '9') ||
			curpos[0] == '.')
		{
			newCount++;
		}

		curpos = _tcstok(NULL, seps);
	}

	// !! caller must free the old blend factor memory
	//if (*count && *blend)
	//	free(*blend);

	if (!newCount)
	{
		*count = newCount;
		*blend = NULL;
		return;
	}

	SendMessage(hwndControl, WM_GETTEXT, 4*MAX_PATH, (LPARAM)buf);

	*count = newCount;
	*blend = (REAL*) malloc(sizeof(REAL)*newCount);

	// extract actual values from the list.
	pos = 0;

	curpos = _tcstok(&buf[0], seps);

	while (curpos != NULL)
	{
		if ((curpos[0] >= '0' && curpos[0] <= '9') ||
			curpos[0] == '.')
		{
			ASSERT(pos < newCount);
			if (pos >= newCount)
				DebugBreak();

			_stscanf(curpos, _T("%f"), &value);
			(*blend)[pos] = value;
			pos++;
		}

		curpos = _tcstok(NULL, seps);
	}

	DeleteObject(hwndControl);
}

VOID SetDialogCombo(HWND hwnd, UINT idc, const TCHAR* strings[], INT count, INT cursel)
{
	HWND hwndControl;

	// !!! use SendDlgItemMessage instead

	hwndControl = GetDlgItem(hwnd, idc);
	for (INT i=0; i<count; i++)
		SendMessage(hwndControl, CB_ADDSTRING, 0, (LPARAM)(LPCTSTR)strings[i]);

	SendMessage(hwndControl, CB_SETCURSEL, cursel, 0);

	DeleteObject(hwndControl);
}

INT GetDialogCombo(HWND hwnd, UINT idc)
{
	HWND hwndControl;

	hwndControl = GetDlgItem(hwnd, idc);

	INT cursel = SendMessage(hwndControl, CB_GETCURSEL, 0, 0);

	DeleteObject(hwndControl);

	return cursel;
}


VOID SetDialogCheck(HWND hwnd, UINT idc, BOOL checked)
{
	HWND hwndControl;

	hwndControl = GetDlgItem(hwnd, idc);
	SendMessage(hwndControl, BM_SETCHECK, (WPARAM)
					checked ? BST_CHECKED : BST_UNCHECKED, 0);
	DeleteObject(hwndControl);
}

BOOL GetDialogCheck(HWND hwnd, UINT idc)
{
	HWND hwndControl;
	BOOL checked = FALSE;

	hwndControl = GetDlgItem(hwnd, idc);
	checked = SendMessage(hwndControl, BM_GETCHECK, 0, 0);
	DeleteObject(hwndControl);

	return checked;
}

VOID EnableDialogControl(HWND hwnd, INT idc, BOOL enable)
{
	HWND hwndCtrl = GetDlgItem(hwnd, idc);
	EnableWindow(hwndCtrl, enable);
	DeleteObject(hwndCtrl);
}

VOID SetMenuCheck(HWND hwnd, INT menuPos, UINT idm, BOOL checked, BOOL byCmd)
{
	HMENU hmenu = GetMenu(hwnd);
	HMENU otherHmenu = GetSubMenu(hmenu, menuPos);

	CheckMenuItem(otherHmenu, idm, 
		(byCmd ? MF_BYCOMMAND : MF_BYPOSITION) |
		(checked ? MF_CHECKED : MF_UNCHECKED));

	DeleteObject(hmenu);
	DeleteObject(otherHmenu);
}

VOID UpdateColorPicture(HWND hwnd, INT idc, ARGB argb)
{
	LOGBRUSH lb;
	lb.lbStyle = BS_SOLID;
	lb.lbColor = ((argb & Color::RedMask) >> Color::RedShift) |
				 ((argb & Color::GreenMask)) |
				 ((argb & Color::BlueMask) << Color::RedShift);
	lb.lbHatch = NULL;

	HWND hwndPic = GetDlgItem(hwnd, idc);

	HDC hdc = GetDC(hwndPic);

	HBRUSH hbr = CreateBrushIndirect(&lb);
	ASSERT(hbr);

	HBRUSH hbrOld = (HBRUSH) SelectObject(hdc, hbr);

	RECT rect;
	GetClientRect(hwndPic, &rect);

	FillRect(hdc, &rect, hbr);

	SelectObject(hdc, hbrOld);

	InvalidateRect(hwndPic, NULL, TRUE);

	DeleteObject(hbr);
	DeleteObject(hdc);
	DeleteObject(hwndPic);
}

VOID UpdateRGBColor(HWND hwnd, INT idcPic, ARGB& argb)
{
	static COLORREF custColor[16]
		= { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 };

	CHOOSECOLOR chooseColor =
	{
		sizeof(CHOOSECOLOR),
		hwnd,
		0,
		argb & ~Color::AlphaMask,
		(COLORREF*)&custColor[0],
		CC_ANYCOLOR | CC_FULLOPEN | CC_RGBINIT,
		0,
		0,
		0
	};

	if (ChooseColor(&chooseColor))
	{
		// COLORREF & ARGB reverse Red and Blue position
		argb = ((chooseColor.rgbResult & 0x0000FF) << 16) |
			   ((chooseColor.rgbResult & 0x00FF00)) |
			   ((chooseColor.rgbResult & 0xFF0000) >> 16);

		UpdateColorPicture(hwnd, idcPic, argb);
	}
};
/*
VOID OutputRectangle(FILE* file, INT formatType, ERectangle* rect)
{
	switch(formatType)
	{
	case CPPFile:
		_ftprintf(file,
				  _T(tabStr tabStr tabStr
				     "ERectangle rect(%e, %e,\n"
					 tabStr tabStr tabStr
					 "                %e, %e);\n",
					 rect.X, rect.Y, rect.Width, rect.Height);
		break;

	case JavaFile:
		_ftprintf(file,
				  _T(tabStr tabStr tabStr
				     "Rectangle rect = new Rectangle(%e, %e,\n"
					 tabStr tabStr tabStr
					 "                               %e, %e);\n",
					 rect.X, rect.Y, rect.Width, rect.Height);
		break;

	case VMLFile:
		break;
	}
}


VOID OutputPointList(FILE* file, INT formatType, Point* pts, INT count)
{
	INT cnt;

	switch(formatType)
	{
	case CPPFile:
		_ftprintf(file, 
				  _T(tabStr tabStr tabStr 
							"Point pts[%d];\n"),
				  count);

		for (cnt = 0; cnt < count; cnt++)
			_ftprintf(file, 
					  _T(tabStr tabStr tabStr
							"pts[%d].X = %e; "
			                "pts[%d].Y = %e;\n"),
							cnt, pts[cnt].X,
							cnt, pts[cnt].Y);
		break;

	case JavaFile:
		_ftprintf(file, 
				  _T(tabStr tabStr tabStr
							"Point[] pts = new Point[%d]\n"),
					 count);

		for (cnt = 0; cnt < count; cnt++)
			_ftprintf(file, 
					  _T(tabStr tabStr tabStr 
					     "pts[%d] = new Point(%e, %e)\n"),
						 cnt, pts[cnt].X, pts[cnt].Y);
		break;

	case VMLFile:
		break;
	}
};
*/
//*******************************************************************
//
// TestTransform
//
//*******************************************************************

BOOL TestTransform :: ChangeSettings(HWND hwndParent)
{
	BOOL ok = DialogBoxParam(hInst,
							MAKEINTRESOURCE(IDD_MATRIX_DLG),
							hwndParent,
							AllDialogBox,
							(LPARAM)((TestDialogInterface*)this));

	if (ok)
	{
		REAL m[6];
		
		// !! This is bad inconsistency in matrix API
		matrix->GetElements(&m[0]);
		(*origMatrix)->SetElements(m[0], m[1], m[2], m[3], m[4], m[5]);
	}

	return ok;
}

VOID TestTransform :: Initialize()
{
	DebugBreak();
}

VOID TestTransform :: Initialize(Matrix **newMatrix)
{
	origMatrix = newMatrix;
	if (*newMatrix)
		matrix = (*newMatrix)->Clone();
	else
		matrix = new Matrix();
}

VOID TestTransform :: EnableDialogButtons(HWND hwnd, BOOL enable)
{
	EnableDialogControl(hwnd, IDC_MATRIX_RESET, enable);
	EnableDialogControl(hwnd, IDC_MATRIX_TRANSLATE, enable);
	EnableDialogControl(hwnd, IDC_MATRIX_SCALE, enable);
	EnableDialogControl(hwnd, IDC_MATRIX_ROTATE, enable);
	EnableDialogControl(hwnd, IDC_MATRIX_SHEAR, enable);
	EnableDialogControl(hwnd, IDC_MATRIX_INVERT, enable);
	EnableDialogControl(hwnd, IDC_OK, enable);
	EnableDialogControl(hwnd, IDC_CANCEL, enable);
}

VOID TestTransform :: UpdateTransformPicture(HWND hwnd, 
											 INT idc, 
											 Matrix* matrix)
{
	INT pos;
	Matrix tmpMatrix;

	// get client rectangle of picture area
	HWND hwndPic = GetDlgItem(hwnd, idc);
	RECT rect;
	GetClientRect(hwndPic, &rect);

	Graphics *g = new Graphics(hwndPic);

	ERectangle bound(REAL_MAX, REAL_MAX, -REAL_MAX, -REAL_MAX);
	
	ERectangle rectf(rect.left,	rect.top,
					 rect.right - rect.left,
					 rect.bottom - rect.top);

	Point pts[4] =
	{
		Point(rectf.X-rectf.Width/2, rectf.Y-rectf.Height/2),
		Point(rectf.X+rectf.Width/2, rectf.Y-rectf.Height/2),
		Point(rectf.X+rectf.Width/2, rectf.Y+rectf.Height/2),
		Point(rectf.X-rectf.Width/2, rectf.Y+rectf.Height/2)
	};

	matrix->TransformPoints(&pts[0], 4);

	// compute bounding box of transformed rectangle
	for (pos=0; pos < 4; pos++)
	{
		if (pts[pos].X < bound.GetLeft())
		{
			bound.Width += fabsf(pts[pos].X-bound.GetLeft());
			bound.X = pts[pos].X;
		}

		if (pts[pos].X > bound.GetRight())
			bound.Width = fabsf(pts[pos].X-bound.GetLeft());

		// on screen, y positive goes downward
		// instead of the traditional upward

		if (pts[pos].Y < bound.GetTop())
		{
			bound.Height += fabsf(pts[pos].Y-bound.GetTop());
			bound.Y = pts[pos].Y;
		}
		
		if (pts[pos].Y > bound.GetBottom())
			bound.Height = fabsf(pts[pos].Y-bound.GetTop());
	}

	// translate relative to the origin
	tmpMatrix.Translate(-((bound.GetLeft()+bound.GetRight())/2),
						 -((bound.GetTop()+bound.GetBottom())/2),
						 AppendOrder);

	// scale to fit our rectangle
	REAL scale = min((rectf.Width-30.0f)/bound.Width,
					 (rectf.Height-30.0f)/bound.Height);

	tmpMatrix.Scale(scale, scale, AppendOrder);

	// translate relative to center of our rectangle
	tmpMatrix.Translate(rectf.Width/2, 
						rectf.Height/2,
						AppendOrder);

	// transform our points by tmpMatrix
	tmpMatrix.TransformPoints(&pts[0], 4);

	// opaque colors RED & BLACK
	Color redColor(0xFF000000 | Color::Red);
	SolidBrush redBrush(redColor);

	Color blackColor(0xFF000000 | Color::Black);
	SolidBrush myBlackBrush(blackColor);

	g->FillRectangle(&myBlackBrush, rectf);
	g->FillPolygon(&redBrush, &pts[0], 4);

	delete g;
}

VOID TestTransform :: InitDialog(HWND hwnd)
{
	REAL m[6];
		
	matrix->GetElements(&m[0]);

	SetDialogReal(hwnd, IDC_MATRIX_M11, m[0]);
	SetDialogReal(hwnd, IDC_MATRIX_M12, m[1]);
	SetDialogReal(hwnd, IDC_MATRIX_M13, 0.0f);
	SetDialogReal(hwnd, IDC_MATRIX_M21, m[2]);
	SetDialogReal(hwnd, IDC_MATRIX_M22, m[3]);
	SetDialogReal(hwnd, IDC_MATRIX_M23, 0.0f);
	SetDialogReal(hwnd, IDC_MATRIX_M31, m[4]);
	SetDialogReal(hwnd, IDC_MATRIX_M32, m[5]);
	SetDialogReal(hwnd, IDC_MATRIX_M33, 1.0f);

	EnableDialogControl(hwnd, IDC_MATRIX_M13, FALSE);
	EnableDialogControl(hwnd, IDC_MATRIX_M23, FALSE);
	EnableDialogControl(hwnd, IDC_MATRIX_M33, FALSE);

	SetDialogCheck(hwnd, IDC_MATRIX_PREPEND, 
		*matrixPrepend == PrependOrder ? TRUE : FALSE);

	UpdateTransformPicture(hwnd, IDC_MATRIX_PIC, matrix);
}

BOOL TestTransform :: SaveValues(HWND hwnd)
{
	*matrixPrepend = (GetDialogCheck(hwnd, IDC_MATRIX_PREPEND) == TRUE ?
							PrependOrder : AppendOrder);

	matrix->SetElements(GetDialogReal(hwnd, IDC_MATRIX_M11),
						GetDialogReal(hwnd, IDC_MATRIX_M12),
						GetDialogReal(hwnd, IDC_MATRIX_M21),
						GetDialogReal(hwnd, IDC_MATRIX_M22),
						GetDialogReal(hwnd, IDC_MATRIX_M31),
						GetDialogReal(hwnd, IDC_MATRIX_M32));

	// !! check for singular matrix ??
	return FALSE;
}

BOOL TestTransform :: ProcessDialog(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
	if (msg == WM_COMMAND)
	{
		switch(LOWORD(wParam))
		{
		case IDC_OK:
			if (SaveValues(hwnd))
				WarningBeep();
			else
				::EndDialog(hwnd, TRUE);
			break;

		case IDC_MATRIX_RESET:
			matrix->Reset();
			InitDialog(hwnd);
			break;

		case IDC_MATRIX_TRANSLATE:
			{
				EnableDialogButtons(hwnd, FALSE);
				
				TestMatrixOperation matrixOp;

				matrixOp.Initialize(_T("Translate Matrix Operation"),
									_T("Translate"),
									_T("Translate points by X and Y"),
									2);

				if (matrixOp.ChangeSettings(hwnd))
				{
					matrix->Translate(matrixOp.GetX(),
									  matrixOp.GetY(),
									  *matrixPrepend);
					
					// redisplay dialog entries
					InitDialog(hwnd);
				}

				EnableDialogButtons(hwnd, TRUE);
			}
			break;

		case IDC_MATRIX_SCALE:
			{
				EnableDialogButtons(hwnd, FALSE);
				
				TestMatrixOperation matrixOp;

				matrixOp.Initialize(_T("Scale Matrix Operation"),
									_T("Scale"),
									_T("Scale points by X and Y"),
									2);

				if (matrixOp.ChangeSettings(hwnd))
				{
					matrix->Scale(matrixOp.GetX(),
								  matrixOp.GetY(),
								  *matrixPrepend);
					
					// redisplay dialog entries
					InitDialog(hwnd);
				}

				EnableDialogButtons(hwnd, TRUE);
			}
			break;

		case IDC_MATRIX_ROTATE:
			{
				EnableDialogButtons(hwnd, FALSE);
				
				TestMatrixOperation matrixOp;

				matrixOp.Initialize(_T("Rotate Matrix Operation"),
									_T("Rotate"),
									_T("Rotate points by angle"),
									1);

				if (matrixOp.ChangeSettings(hwnd))
				{
					matrix->Rotate(matrixOp.GetX(),
								   *matrixPrepend);
					
					// redisplay dialog entries
					InitDialog(hwnd);
				}

				EnableDialogButtons(hwnd, TRUE);
			}
			break;
			
		case IDC_MATRIX_SHEAR:
			{
				EnableDialogButtons(hwnd, FALSE);
				
				TestMatrixOperation matrixOp;

				matrixOp.Initialize(_T("Shear Matrix Operation"),
									_T("Shear"),
									_T("Shear points by X and Y"),
									2);

				if (matrixOp.ChangeSettings(hwnd))
				{
					matrix->Shear(matrixOp.GetX(),
								  matrixOp.GetY());
					// !! should this be added?
					//			  *matrixPrepend);
					
					// redisplay dialog entries
					InitDialog(hwnd);
				}

				EnableDialogButtons(hwnd, TRUE);
			}
			break;

		case IDC_MATRIX_INVERT:
			matrix->Invert();
			InitDialog(hwnd);
			break;

		case IDC_REFRESH_PIC:
			UpdateTransformPicture(hwnd, IDC_MATRIX_PIC, matrix);
			break;

		case IDC_CANCEL:
			::EndDialog(hwnd, FALSE);
			break;

		case IDC_MATRIX_PREPEND:
			*matrixPrepend = (GetDialogCheck(hwnd, IDC_MATRIX_PREPEND) == TRUE ?
					PrependOrder : AppendOrder);
			break;
			
		default:
			return FALSE;
		}

		return TRUE;
	}

	return FALSE;
}

BOOL TestMatrixOperation :: ChangeSettings(HWND hwndParent)
{
	BOOL ok = DialogBoxParam(hInst,
							MAKEINTRESOURCE(IDD_MATRIX_DLG2),
							hwndParent,
							AllDialogBox,
							(LPARAM)((TestDialogInterface*)this));

	return ok;
}

VOID TestMatrixOperation :: Initialize()
{
	DebugBreak();
}

VOID TestMatrixOperation :: Initialize(TCHAR* newDialogTitle,
									   TCHAR* newSubTitle,
									   TCHAR* newDescStr,
									   INT newCount)
{
	dialogTitle = newDialogTitle;
	subTitle = newSubTitle;
	descStr = newDescStr;
	count = newCount;
}

VOID TestMatrixOperation :: InitDialog(HWND hwnd)
{
	SetWindowText(hwnd, dialogTitle);
	SetDialogText(hwnd, IDC_MATRIX_OPERATION, subTitle);
	SetDialogText(hwnd, IDC_MATRIX_TEXT, descStr);

	SetDialogReal(hwnd, IDC_MATRIX_X, x);
	SetDialogReal(hwnd, IDC_MATRIX_Y, y);

	EnableDialogControl(hwnd, IDC_MATRIX_Y, count >= 2);
}

BOOL TestMatrixOperation :: SaveValues(HWND hwnd)
{
	x = GetDialogReal(hwnd, IDC_MATRIX_X);
	y = GetDialogReal(hwnd, IDC_MATRIX_Y);

	return FALSE;
}

BOOL TestMatrixOperation :: ProcessDialog(HWND hwnd, 
										  UINT msg, 
										  WPARAM wParam, 
										  LPARAM lParam)
{
    if (msg == WM_COMMAND)
	{
		if (LOWORD(wParam) == IDC_OK)
		{
			if (SaveValues(hwnd))
				WarningBeep();
			else
				::EndDialog(hwnd, TRUE);

	        return TRUE;
		}
		else if (LOWORD(wParam) == IDC_CANCEL)
		{
			::EndDialog(hwnd, FALSE);
		}
	}
    
	return FALSE;

}

//*******************************************************************
//
// Dialog Window Proc Handler
//
//*******************************************************************

INT_PTR CALLBACK AllDialogBox(
							  HWND hwnd,
							  UINT msg,
							  WPARAM wParam,
							  LPARAM lParam
							  )
{
	switch (msg)
	{
	case WM_INITDIALOG:
		{
			// save pointer to brush interface for this object
			SetWindowLong(hwnd, DWL_USER, lParam);
			ASSERT(lParam != 0);
			TestDialogInterface* dlgInt = (TestDialogInterface*) lParam;

			dlgInt->InitDialog(hwnd);
		}
		break;

	case WM_PAINT:
		{
			TestDialogInterface* dlgInt = (TestDialogInterface*) 
						GetWindowLong(hwnd, DWL_USER);
			ASSERT(dlgInt != NULL);

			if (dlgInt)
				dlgInt->ProcessDialog(hwnd, WM_COMMAND, IDC_REFRESH_PIC, 0);
			return FALSE;
		}
		break;

	case WM_CLOSE:
		{
			DestroyWindow(hwnd);
			break;
		}

	default:
		{
			TestDialogInterface* dlgInt = (TestDialogInterface*) 
						GetWindowLong(hwnd, DWL_USER);
			ASSERT(dlgInt != NULL);

			if (dlgInt)
				return dlgInt->ProcessDialog(hwnd, msg, wParam, lParam);
			else
				return FALSE;
		}
	}

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\gdiptest\gdippen.cpp ===
#include "gdiptest.h"

//*******************************************************************
//
// TestPen
//
//
//
//*******************************************************************

BOOL TestPen :: ChangeSettings(HWND hwndParent)
{
	BOOL ok = DialogBoxParam(hInst,
							MAKEINTRESOURCE(IDD_PEN_DLG),
							hwndParent,
							AllDialogBox,
							(LPARAM)(static_cast<TestDialogInterface*>(this)));

	// customize brush && then cancel
	if (tempBrush)
	{
		delete tempBrush;
		tempBrush = NULL;
	}

	if (ok)
	{		
		delete pen;

		if (useBrush)
		{
			ASSERT(brush);
		
			pen = new Pen(brush->GetBrush(), width);
		}
		else
		{
			Color color(argb);
			
			pen = new Pen(color, width);
		}

  		pen->SetLineCap(capValue[startCap],
						capValue[endCap],
						dashCapValue[dashCap]);
		pen->SetLineJoin(joinValue[lineJoin]);
		pen->SetMiterLimit(miterLimit);
		pen->SetDashStyle(dashValue[dashStyle]);
				
		return TRUE;
	}
	
	return FALSE;
};

VOID TestPen :: Initialize()
{
	delete brush;
	brush = NULL;
	delete tempBrush;
	tempBrush = NULL;
	brushSelect = tempBrushSelect = 0;
	useBrush = FALSE;

	argb = 0x80808080;			// grayish, alpha = 0x80

	width = 5.0f;
	startCap = SquareCap;
	endCap = SquareCap;
	dashCap = FlatCap;
	lineJoin = RoundJoin;
	miterLimit = 0;
	dashStyle = Solid;

	Color color(argb);

	pen = new Pen(color, width);
	
	pen->SetLineCap(capValue[startCap],
					capValue[endCap],
					dashCapValue[dashCap]);
	pen->SetLineJoin(joinValue[lineJoin]);
	pen->SetMiterLimit(miterLimit);
	pen->SetDashStyle(dashValue[dashStyle]);
}

VOID TestPen :: AddToFile(OutputFile* outfile, INT id)
{
	TCHAR penStr[MAX_PATH];
	TCHAR brushStr[MAX_PATH];
	TCHAR colorStr[MAX_PATH];

	if (id)
	{
		_stprintf(&penStr[0], _T("pen%dp"), id);
		_stprintf(&colorStr[0], _T("color%dp"), id);
	}
	else
	{
		_tcscpy(&penStr[0], _T("pen"));
		_tcscpy(&colorStr[0], _T("color"));
	}

	if (useBrush)
	{
		_stprintf(&brushStr[0], "brush%d", 2);

		brush->AddToFile(outfile, 2);
		outfile->Declaration(_T("Pen"),
							 &penStr[0],
							 _T("%s, %e"),
							 outfile->Ref(&brushStr[0]),
							 width);
	}
	else
	{
		outfile->ColorDeclaration(&colorStr[0],
								  &argb);
		outfile->Declaration(_T("Pen"),
							 &penStr[0],
							 _T("%s, %e"),
							 &colorStr[0],
							 width);
	}

	outfile->ObjectCommand(&penStr[0],
						   _T("SetLineCap"),
						   _T("%s, %s, %s"),
						   capStr[startCap],
						   capStr[endCap],
						   dashCapStr[dashCap]);

	outfile->ObjectCommand(&penStr[0],
						   _T("SetLineJoin"),
						   joinStr[lineJoin]);

	if (joinValue[lineJoin] == MiterJoin)
		outfile->ObjectCommand(&penStr[0],
							   _T("SetMiterLimit"),
							   _T("%e"),
							   miterLimit);
	
	outfile->ObjectCommand(&penStr[0],
						   _T("SetDashStyle"),
						   dashStr[dashStyle]);
}

VOID TestPen :: EnableBrushFields(HWND hwnd, BOOL enable)
{
	HWND hwdAlpha  = GetDlgItem(hwnd, IDC_PEN_ALPHA);
	HWND hwdColorB = GetDlgItem(hwnd, IDC_PEN_COLORBUTTON);
	HWND hwdColorP = GetDlgItem(hwnd, IDC_PEN_COLORPIC);
	HWND hwdBrushB = GetDlgItem(hwnd, IDC_PEN_BRUSHBUTTON);
	HWND hwdList   = GetDlgItem(hwnd, IDC_PEN_BRUSHLIST);
	
	SetDialogCheck(hwnd, IDC_PEN_BRUSH, enable);
	SetDialogCheck(hwnd, IDC_PEN_COLOR, !enable);

	EnableWindow(hwdBrushB, enable);
	EnableWindow(hwdList, enable);
	
	EnableWindow(hwdAlpha, !enable);
	EnableWindow(hwdColorP, !enable);
	EnableWindow(hwdColorB, !enable);

	DeleteObject(hwdAlpha);
	DeleteObject(hwdColorP);
	DeleteObject(hwdColorB);
	DeleteObject(hwdBrushB);
	DeleteObject(hwdList);
}

VOID TestPen :: InitDialog(HWND hwnd)
{
	INT i,j;

	// Color/Brush button

	SetDialogCheck(hwnd, IDC_PEN_BRUSH, useBrush);
	SetDialogCheck(hwnd, IDC_PEN_COLOR, !useBrush);

	HWND hwndBrushList = GetDlgItem(hwnd, IDC_PEN_BRUSHLIST);
	EnableWindow(hwndBrushList, useBrush);

	// Store pointer to underlying Brush object in Brush Button
	if (tempBrush)
	{
		// we had a warning, keep the temp Brush until we really save.
	}
	else if (brush)
	{		
		// first pop-up occurrence
		tempBrush = brush->Clone();
		tempBrushSelect = brushSelect;
		SetDialogCombo(hwnd, IDC_PEN_BRUSHLIST, brushList, numBrushes, brushSelect);
	}
	else
	{
		tempBrush = NULL;
		tempBrushSelect = 0;
		SetDialogCombo(hwnd, IDC_PEN_BRUSHLIST, brushList, numBrushes, 0);
	}

	DeleteObject(hwndBrushList);

	// Color values
	SetDialogLong(hwnd, IDC_PEN_ALPHA, argb >> Color::AlphaShift);
	
	EnableBrushFields(hwnd, useBrush);

	// Start/End/Dash Cap
	SetDialogCombo(hwnd, IDC_PEN_STARTCAP, capList, numCaps, startCap);
	SetDialogCombo(hwnd, IDC_PEN_ENDCAP, capList, numCaps, endCap);
	SetDialogCombo(hwnd, IDC_PEN_DASHCAP, dashCapList, numDashCaps, dashCap);

	// Line Join
	SetDialogCombo(hwnd, IDC_PEN_JOIN, joinList, numJoin, lineJoin);

	// Dash Style
	SetDialogCombo(hwnd, IDC_PEN_DASHSTYLE, dashList, numDash, dashStyle);
	
	// Width
	SetDialogReal(hwnd, IDC_PEN_WIDTH, width);

}

BOOL TestPen :: SaveValues(HWND hwnd)
{
	BOOL warning = FALSE;

	// Solid color values
	argb = (argb & ~Color::AlphaMask) |
				(GetDialogLong(hwnd, IDC_PEN_ALPHA)
					<< Color::AlphaShift);

	startCap = GetDialogCombo(hwnd, IDC_PEN_STARTCAP);
	endCap = GetDialogCombo(hwnd, IDC_PEN_ENDCAP);
	dashCap = GetDialogCombo(hwnd, IDC_PEN_DASHCAP);

	// Width
	width = GetDialogReal(hwnd, IDC_PEN_WIDTH);
	if (width < 0.01f)
	{
		width = 0.01f;
		warning = TRUE;
	}
	else if (width > 100)
	{
		width = 100.0f;
		warning = TRUE;
	}

	dashStyle = GetDialogCombo(hwnd, IDC_PEN_DASHSTYLE);
	lineJoin = GetDialogCombo(hwnd, IDC_PEN_JOIN);

	// !! miter limit not currently supported
	miterLimit = 0;

	BOOL tempUse = GetDialogCheck(hwnd, IDC_PEN_BRUSH);
	if (tempUse)
	{
		 tempBrushSelect = GetDialogCombo(hwnd, IDC_PEN_BRUSHLIST);
		 			 
		 if (!tempBrush || 
			 (tempBrush->GetType() != brushValue[tempBrushSelect]))
		 {
			 WarningBox("Must customize Brush or select Color.");
			 warning = TRUE;
		 }
		 else
		 {
			 // we are saving, copy tempBrush to real Brush
			 // no reason to clone
			 if (!warning)
			 {
				 delete brush;
				 brush = tempBrush;
				 brushSelect = tempBrushSelect;
				 tempBrush = NULL;
				 tempBrushSelect = 0;
			 }
		 }
	}
	else
	{
		// no warnings and not using temp brush, delete it.
		if (!warning)
		{
			delete tempBrush;
			tempBrush = NULL;
		}
	}

	if (warning)
		InitDialog(hwnd);

	return warning;
}

BOOL TestPen :: ProcessDialog(HWND hwnd, 
			  				  UINT msg, 
							  WPARAM wParam, 
							  LPARAM lParam)
{
	if (msg == WM_COMMAND)
	{
		switch(LOWORD(wParam))
		{
		case IDC_OK:
			if (SaveValues(hwnd))
				WarningBeep();
			else
				::EndDialog(hwnd, TRUE);
			break;

		case IDC_CANCEL:
			::EndDialog(hwnd, FALSE);
			break;

		// pop-up brush customization window
		case IDC_PEN_BRUSHBUTTON:
			{
				ASSERT(useBrush);

				// get selected brush type
				tempBrushSelect = GetDialogCombo(hwnd, IDC_PEN_BRUSHLIST);

				if (tempBrush)
				{
					// change in brush type, create new temp brush
					if (tempBrush->GetType() != brushValue[tempBrushSelect])
					{
						// we've changed type,
						delete tempBrush;
						tempBrush = NULL;

						tempBrush = TestBrush::CreateNewBrush(brushValue[tempBrushSelect]);
						tempBrush->Initialize();

						if (!tempBrush->ChangeSettings(hwnd))
						{
							delete tempBrush;
							tempBrush = NULL;
						}
					}
					else
					{
						// change settings on temp brush
						tempBrush->ChangeSettings(hwnd);
					}
				}
				else
				{
					// no brush type previously selected.
					tempBrush = TestBrush::CreateNewBrush(brushValue[tempBrushSelect]);
					tempBrush->Initialize();

					if (!tempBrush->ChangeSettings(hwnd))
					{
						delete tempBrush;
						tempBrush = NULL;
					}
				}
			}
			break;

		case IDC_REFRESH_PIC:
			UpdateColorPicture(hwnd, IDC_PEN_COLORPIC, argb);
			break;

		case IDC_PEN_COLORBUTTON:
			UpdateRGBColor(hwnd, IDC_PEN_COLORPIC, argb);
			break;

			// enable/disable appropriate fields
		case IDC_PEN_BRUSH:
			EnableBrushFields(hwnd, TRUE);
			useBrush = TRUE;
			break;

		case IDC_PEN_COLOR:
			EnableBrushFields(hwnd,FALSE);
			useBrush = FALSE;
			break;

		default:
			return FALSE;
		}

		return TRUE;
	}
/*
	if (HIWORD(wParam) == CBN_DROPDOWN)
	{
		// list box about to be displayed
		DebugBreak();
	}

	if (HIWORD(wParam) == CBN_CLOSEUP)
	{
		// about to close list-box
		DebugBreak();
	}

*/
	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\gdiptest\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	gdiptest.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file

#include "gdiptest.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\gdiptest\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__A9DB83DB_A9FD_11D0_BFD1_444553540000__INCLUDED_)
#define AFX_STDAFX_H__A9DB83DB_A9FD_11D0_BFD1_444553540000__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers


// Windows Header Files:
#include <windows.h>

// C RunTime Header Files
#include <stdlib.h>
#include <malloc.h>
#include <memory.h>
#include <tchar.h>

// Local Header Files

// TODO: reference additional headers your program requires here

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__A9DB83DB_A9FD_11D0_BFD1_444553540000__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\gdiptest\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by gdiptest.rc
//
#define IDC_MYICON                      2
#define IDD_GDIPTEST_DIALOG             102
#define IDD_ABOUTBOX                    103
#define IDS_APP_TITLE                   103
#define IDM_ABOUT                       104
#define IDM_EXIT                        105
#define IDS_HELLO                       106
#define IDI_GDIPTEST                    107
#define IDI_SMALL                       108
#define IDC_GDIPTEST                    109
#define IDR_MAINFRAME                   128
#define IDD_SOLIDBRUSH_DLG              130
#define IDD_PEN_DLG                     131
#define IDD_ARC_DLG                     132
#define IDD_CURVE_DLG                   133
#define IDD_TEXTURE_DLG                 134
#define IDD_RECTGRAD_DLG                135
#define IDD_RADGRAD_DLG                 136
#define IDR_GRADBRUSH                   137
#define IDD_TRIGRAD_DLG                 138
#define IDD_TRIGRAD_DLG2                139
#define IDD_POLYGRAD_DLG                140
#define IDD_POLYGRAD_DLG2               141
#define IDD_MATRIX_DLG                  142
#define IDD_MATRIX_DLG2                 143
#define IDD_HATCH_DLG                   144
#define IDD_SHAPE_DLG                   145
#define IDC_REFRESH_PIC                 200
#define IDC_SB_ALPHA                    1000
#define IDC_SB_RED                      1001
#define IDC_HATCH_BACKALPHA             1001
#define IDC_SB_GREEN                    1002
#define IDC_SB_BLUE                     1003
#define IDC_OK                          1004
#define IDC_CANCEL                      1005
#define IDC_PEN_BRUSH                   1006
#define IDC_PEN_COLOR                   1007
#define IDC_PEN_WIDTH                   1008
#define IDC_PEN_STARTCAP                1013
#define IDC_PEN_ENDCAP                  1014
#define IDC_PEN_DASHCAP                 1015
#define IDC_PEN_DASHSTYLE               1016
#define IDC_PEN_JOIN                    1017
#define IDC_PEN_ALPHA                   1018
#define IDC_PEN_GREEN                   1019
#define IDC_PEN_RED                     1020
#define IDC_PEN_BLUE                    1021
#define IDC_PEN_BRUSHBUTTON             1022
#define IDC_PEN_BRUSHLIST               1023
#define IDC_LIST2                       1026
#define IDC_POLYGRAD_POINTLIST          1026
#define IDC_ARC_START                   1028
#define IDC_ARC_SWEEP                   1029
#define IDC_ARC_POPUP                   1030
#define IDC_CURVE_TENSION               1031
#define IDC_CURVE_OFFSET                1032
#define IDC_CURVE_SEGMENTS              1033
#define IDC_TEXTURE_FILENAME            1034
#define IDC_BRUSH_WRAP                  1035
#define IDC_TEXTURE_FILEBUTTON          1036
#define IDC_BRUSH_TRANSFORM             1037
#define IDC_RECTGRAD_X                  1038
#define IDC_RECTGRAD_Y                  1039
#define IDC_RECTGRAD_WIDTH              1040
#define IDC_RECTGRAD_HEIGHT             1041
#define IDC_RECTGRAD_COLOR1             1042
#define IDC_RECTGRAD_COLOR2             1043
#define IDC_RECTGRAD_COLOR3             1044
#define IDC_RECTGRAD_COLOR4             1045
#define IDC_RECTGRAD_ALPHA1             1047
#define IDC_RECTGRAD_ALPHA2             1048
#define IDC_RECTGRAD_ALPHA4             1049
#define IDC_RECTGRAD_ALPHA3             1050
#define IDC_RECTGRAD_PIC1               1051
#define IDC_RECTGRAD_PIC3               1052
#define IDC_RECTGRAD_PIC2               1053
#define IDC_RECTGRAD_PIC4               1054
#define IDC_RADGRAD_X                   1055
#define IDC_RADGRAD_Y                   1056
#define IDC_RADGRAD_WIDTH               1057
#define IDC_RADGRAD_HEIGHT              1058
#define IDC_RADGRAD_CENTER              1059
#define IDC_RADGRAD_BOUNDARY            1060
#define IDC_RADGRAD_CENTERALPHA         1061
#define IDC_RADGRAD_BOUNDARYALPHA       1062
#define IDC_RADGRAD_PICB                1063
#define IDC_RADGRAD_PICC                1064
#define IDC_PEN_COLORBUTTON             1065
#define IDC_PEN_PIC                     1066
#define IDC_PEN_COLORPIC                1067
#define IDC_SB_COLORBUTTON              1068
#define IDC_SB_PIC                      1069
#define IDC_TRIGRAD_BUTTON              1070
#define IDC_HATCH_BACKCOLOR             1070
#define IDC_HATCH_BACKPIC               1071
#define IDC_TRIGRAD_PT1                 1072
#define IDC_TRIGRAD_PT2                 1073
#define IDC_TRIGRAD_PT3                 1074
#define IDC_TRIGRAD_PIC1                1075
#define IDC_TRIGRAD_PIC2                1076
#define IDC_TRIGRAD_PIC3                1077
#define IDC_TRIGRAD_COLORBUTTON         1078
#define IDC_TRIGRAD_ALPHA               1079
#define IDC_TRIGRAD_BLEND               1082
#define IDC_TRIGRAD_PIC                 1083
#define IDC_POLYGRAD_BUTTON             1084
#define IDC_POLYGRAD_COLORBUTTON        1086
#define IDC_POLYGRAD_ALPHA              1087
#define IDC_POLYGRAD_PIC                1088
#define IDC_POLYGRAD_BLEND              1089
#define IDC_MATRIX_RESET                1090
#define IDC_MATRIX_TRANSLATE            1091
#define IDC_MATRIX_SCALE                1092
#define IDC_MATRIX_ROTATE               1093
#define IDC_MATRIX_SHEAR                1094
#define IDC_MATRIX_INVERT               1095
#define IDC_MATRIX_M11                  1097
#define IDC_MATRIX_M12                  1098
#define IDC_MATRIX_M13                  1099
#define IDC_MATRIX_M21                  1100
#define IDC_MATRIX_M22                  1101
#define IDC_MATRIX_M23                  1102
#define IDC_MATRIX_M31                  1103
#define IDC_MATRIX_M32                  1104
#define IDC_MATRIX_M33                  1105
#define IDC_MATRIX_PIC                  1106
#define IDC_MATRIX_PREPEND              1107
#define IDC_MATRIX_TEXT                 1108
#define IDC_MATRIX_X                    1109
#define IDC_MATRIX_Y                    1110
#define IDC_MATRIX_OPERATION            1111
#define IDC_HATCH_FORECOLOR             1112
#define IDC_HATCH_FOREALPHA             1113
#define IDC_HATCH_FOREPIC               1114
#define IDC_HATCH_STYLE                 1115
#define IDC_CLIP_TREE                   1117
#define IDC_CLIP_AND                    1118
#define IDC_CLIP_OR                     1119
#define IDC_CLIP_XOR                    1120
#define IDC_CLIP_NOT                    1121
#define IDC_CLIP_ADD                    1125
#define IDC_CLIP_REMOVE                 1126
#define IDC_SHAPE_UP                    1127
#define IDC_SHAPE_DOWN                  1128
#define IDC_SHAPE_DISABLE               1129
#define IDC_SHAPE_TOP                   1130
#define IDC_SHAPE_CLONE                 1131
#define IDC_SHAPE_BRUSH                 1132
#define IDC_SHAPE_PIC                   1133
#define IDC_SHAPE_PEN                   1134
#define IDC_SHAPE_LIST                  1135
#define IDC_CLIP_BOOL                   1136
#define IDC_TREE_SELECT                 2000
#define IDM_ARC                         32775
#define IDM_BEZIER                      32776
#define IDM_REGION                      32777
#define IDM_ELLIPSE                     32778
#define IDM_SOLIDBRUSH                  32779
#define IDM_TEXTURE                     32780
#define IDM_RECTGRAD                    32781
#define IDM_RADGRAD                     32782
#define IDM_TRIGRAD                     32783
#define IDM_POLYGRAD                    32784
#define IDM_HATCH                       32785
#define IDM_PEN                         32786
#define IDM_REDRAW                      32787
#define IDM_REDRAWALL                   32788
#define IDM_KEEPCONTROLPOINTS           32789
#define IDM_LINE                        32790
#define IDM_RECT                        32791
#define IDM_PIE                         32792
#define IDM_POLYGON                     32793
#define IDM_CURVE                       32794
#define IDM_CLOSED                      32795
#define IDM_ANTIALIASED                 32796
#define IDM_RESET                       32797
#define IDM_INSTRUCTIONS                32798
#define IDM_DONE                        32799
#define IDM_CANCEL                      32800
#define IDM_WORLD_TRANSFORM             32801
#define IDM_DELETE                      32802
#define IDM_USECLIP                     32803
#define IDM_SAVEFILE                    32804
#define IDM_SHAPELIST                   32805
#define IDM_SETCLIP                     32806
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        146
#define _APS_NEXT_COMMAND_VALUE         32807
#define _APS_NEXT_CONTROL_VALUE         1137
#define _APS_NEXT_SYMED_VALUE           110
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\gdiptest\test.cpp ===
VOID DoGraphicsTest(HWND hWnd)
{
    Graphics g(hWnd);

    Matrix worldMatrix(1.000000e+000, 2.500000e-001, -2.500000e-001, 
                       1.000000e+000, 1.000000e+002, 0.000000e+000);
    g.SetWorldTransform(&worldMatrix);

    {
        Color color(0x400080FF);
        Pen pen(color, 2.000000e+001);
        pen.SetLineCap(RoundCap, FlatCap, FlatCap);
        pen.SetLineJoin(RoundJoin);
        pen.SetDashStyle(Solid);

        Point pts[13];
        pts[0].X=4.400000e+001; pts[0].Y=3.700000e+001;
        pts[1].X=3.190000e+002; pts[1].Y=4.000000e+001;
        pts[2].X=4.790000e+002; pts[2].Y=4.200000e+001;
        pts[3].X=5.210000e+002; pts[3].Y=8.200000e+001;
        pts[4].X=1.750000e+002; pts[4].Y=1.140000e+002;
        pts[5].X=1.300000e+001; pts[5].Y=1.390000e+002;
        pts[6].X=2.500000e+002; pts[6].Y=1.820000e+002;
        pts[7].X=5.280000e+002; pts[7].Y=1.890000e+002;
        pts[8].X=4.290000e+002; pts[8].Y=2.780000e+002;
        pts[9].X=1.280000e+002; pts[9].Y=2.840000e+002;
        pts[10].X=9.600000e+001; pts[10].Y=2.980000e+002;
        pts[11].X=4.280000e+002; pts[11].Y=3.270000e+002;
        pts[12].X=5.230000e+002; pts[12].Y=3.100000e+002;

        g.DrawLine(&pen, &pts[0], 13);
    }

    {
        Color color(0x8080FFFF);
        Pen pen(color, 1.000000e+001);
        pen.SetLineCap(RoundCap, FlatCap, FlatCap);
        pen.SetLineJoin(RoundJoin);
        pen.SetDashStyle(Solid);

        ERectangle rect(2.900000e+001, 4.000000e+001, 
                        3.600000e+002, 2.260000e+002);

        g.DrawArc(&pen, rect, 9.000000e+001, 9.000000e+001);
    }

    {
        Bitmap bitmap(L"Z:\\nt\\private\\ntos\\w32\\winplus\\src\\gdiplus\\test\\dlltest\\winnt256.bmp");

        TextureBrush brush(&bitmap, Tile);

        // identity matrix transform

        ERectangle rect(2.220000e+002, 4.200000e+001, 
                        3.170000e+002, 2.130000e+002);

        g.FillPie(&brush, rect, 0.000000e+000, 9.000000e+001);

        Color color(0x8080FFFF);
        Pen pen(color, 1.000000e+001);
        pen.SetLineCap(RoundCap, FlatCap, FlatCap);
        pen.SetLineJoin(RoundJoin);
        pen.SetDashStyle(Solid);

        g.DrawPie(&pen, rect, 0.000000e+000, 9.000000e+001);
    }

    {
        Bitmap bitmap(L"Z:\\nt\\private\\ntos\\w32\\winplus\\src\\gdiplus\\test\\dlltest\\winnt256.bmp");

        TextureBrush brush(&bitmap, Tile);

        // identity matrix transform

        ERectangle rect(2.230000e+002, 5.100000e+001, 
                        1.270000e+002, 1.300000e+002);

        g.FillEllipse(&brush, rect);

        Color color(0x8080FFFF);
        Pen pen(color, 1.000000e+001);
        pen.SetLineCap(RoundCap, FlatCap, FlatCap);
        pen.SetLineJoin(RoundJoin);
        pen.SetDashStyle(Solid);

        g.DrawEllipse(&pen, rect);
    }

    {
        Bitmap bitmap(L"Z:\\nt\\private\\ntos\\w32\\winplus\\src\\gdiplus\\test\\dlltest\\winnt256.bmp");

        TextureBrush brush(&bitmap, Tile);

        // identity matrix transform

        ERectangle rect(3.150000e+002, 2.900000e+001, 
                        2.500000e+002, 1.930000e+002);

        g.FillPie(&brush, rect, 9.000000e+001, 9.000000e+001);

        Color color(0x8080FFFF);
        Pen pen(color, 1.000000e+001);
        pen.SetLineCap(RoundCap, FlatCap, FlatCap);
        pen.SetLineJoin(RoundJoin);
        pen.SetDashStyle(Solid);

        g.DrawPie(&pen, rect, 9.000000e+001, 9.000000e+001);
    }

    {
        Bitmap bitmap(L"Z:\\nt\\private\\ntos\\w32\\winplus\\src\\gdiplus\\test\\dlltest\\winnt256.bmp");

        TextureBrush brush(&bitmap, Tile);

        // identity matrix transform

        Point pts[10];
        pts[0].X=4.600000e+001; pts[0].Y=5.500000e+001;
        pts[1].X=2.420000e+002; pts[1].Y=3.600000e+001;
        pts[2].X=3.780000e+002; pts[2].Y=3.900000e+001;
        pts[3].X=4.580000e+002; pts[3].Y=7.600000e+001;
        pts[4].X=4.850000e+002; pts[4].Y=2.540000e+002;
        pts[5].X=2.840000e+002; pts[5].Y=2.870000e+002;
        pts[6].X=1.230000e+002; pts[6].Y=2.800000e+002;
        pts[7].X=4.800000e+001; pts[7].Y=2.210000e+002;
        pts[8].X=3.100000e+001; pts[8].Y=1.550000e+002;
        pts[9].X=3.400000e+001; pts[9].Y=1.050000e+002;

        g.FillPolygon(&brush, &pts[0], 10);

        Color color(0x80FF8040);
        Pen pen(color, 1.000000e+001);
        pen.SetLineCap(RoundCap, FlatCap, FlatCap);
        pen.SetLineJoin(RoundJoin);
        pen.SetDashStyle(Solid);

        g.DrawPolygon(&pen, &pts[0], 10);
    }

    {
        Color color(0x80FF8040);
        Pen pen(color, 1.000000e+001);
        pen.SetLineCap(RoundCap, FlatCap, FlatCap);
        pen.SetLineJoin(RoundJoin);
        pen.SetDashStyle(Solid);

        Point pts[28];
        pts[0].X=4.300000e+001; pts[0].Y=1.900000e+001;
        pts[1].X=3.200000e+001; pts[1].Y=6.800000e+001;
        pts[2].X=3.200000e+001; pts[2].Y=1.590000e+002;
        pts[3].X=3.300000e+001; pts[3].Y=2.300000e+002;
        pts[4].X=3.200000e+001; pts[4].Y=2.840000e+002;
        pts[5].X=8.200000e+001; pts[5].Y=3.240000e+002;
        pts[6].X=1.310000e+002; pts[6].Y=2.090000e+002;
        pts[7].X=1.310000e+002; pts[7].Y=1.180000e+002;
        pts[8].X=1.470000e+002; pts[8].Y=1.900000e+001;
        pts[9].X=2.030000e+002; pts[9].Y=1.900000e+001;
        pts[10].X=2.160000e+002; pts[10].Y=6.400000e+001;
        pts[11].X=2.160000e+002; pts[11].Y=1.420000e+002;
        pts[12].X=2.180000e+002; pts[12].Y=2.040000e+002;
        pts[13].X=2.190000e+002; pts[13].Y=2.680000e+002;
        pts[14].X=2.580000e+002; pts[14].Y=3.160000e+002;
        pts[15].X=3.090000e+002; pts[15].Y=2.950000e+002;
        pts[16].X=3.080000e+002; pts[16].Y=1.260000e+002;
        pts[17].X=3.190000e+002; pts[17].Y=1.700000e+001;
        pts[18].X=3.890000e+002; pts[18].Y=2.100000e+001;
        pts[19].X=4.250000e+002; pts[19].Y=1.670000e+002;
        pts[20].X=4.250000e+002; pts[20].Y=2.510000e+002;
        pts[21].X=4.670000e+002; pts[21].Y=3.280000e+002;
        pts[22].X=5.720000e+002; pts[22].Y=2.410000e+002;
        pts[23].X=5.720000e+002; pts[23].Y=2.410000e+002;
        pts[24].X=5.450000e+002; pts[24].Y=1.110000e+002;
        pts[25].X=5.140000e+002; pts[25].Y=3.600000e+001;
        pts[26].X=5.140000e+002; pts[26].Y=3.500000e+001;
        pts[27].X=4.600000e+002; pts[27].Y=1.700000e+001;

        g.DrawCurve(&pen, &pts[0], 28, 2.000000e+000, 0, 23);
    }

    {
        Color colors[4];
        colors[0] = Color(0x50FFFFFF);
        colors[1] = Color(0x50FF0000);
        colors[2] = Color(0x5000FF00);
        colors[3] = Color(0x500000FF);

        ERectangle rectb(0.000000e+000, 0.000000e+000, 
                         1.000000e+002, 1.000000e+002);

        RectangleGradientBrush brush(rectb, &colors[0], Tile);

        Matrix matrixb(1.000000e+000, 2.500000e-001, -2.500000e-001, 
                       1.000000e+000, 0.000000e+000, 0.000000e+000);
        brush.SetTransform(&matrixb);

        ERectangle rect(7.000000e+000, 5.000000e+000, 
                        5.710000e+002, 3.470000e+002);
        g.FillRect(&brush, rect);

        Color color(0x80FF8040);
        Pen pen(color, 1.000000e+001);
        pen.SetLineCap(RoundCap, FlatCap, FlatCap);
        pen.SetLineJoin(RoundJoin);
        pen.SetDashStyle(Solid);

        g.DrawRect(&pen, rect);
    }
    {
        Color colors[4];
        colors[0] = Color(0x50FFFFFF);
        colors[1] = Color(0x50FF0000);
        colors[2] = Color(0x5000FF00);
        colors[3] = Color(0x500000FF);

        ERectangle rectb(0.000000e+000, 0.000000e+000, 
                         1.000000e+002, 1.000000e+002);

        RectangleGradientBrush brush(rectb, &colors[0], Tile);

        Matrix matrixb(1.000000e+000, 2.500000e-001, -2.500000e-001, 
                       1.000000e+000, 0.000000e+000, 0.000000e+000);
        brush.SetTransform(&matrixb);

        ERectangle rect(2.090000e+002, 1.800000e+001, 
                        1.100000e+001, 4.500000e+001);
        g.FillRect(&brush, rect);

        Color color(0x80FF8040);
        Pen pen(color, 1.000000e+001);
        pen.SetLineCap(RoundCap, FlatCap, FlatCap);
        pen.SetLineJoin(RoundJoin);
        pen.SetDashStyle(Solid);

        g.DrawRect(&pen, rect);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\gdiptest\gdiputils.h ===
class TestConfigureInterface	// abstract class
{
public:
	// pop-up dialog to configure brush
	virtual BOOL ChangeSettings(HWND hwnd) = 0;

	// re-initialize the brush to a default value
	virtual VOID Initialize() = 0;
};

class TestDialogInterface
{
public:
	// WM_INITDIALOG
	virtual VOID InitDialog(HWND hwnd) = 0;

	// IDC_OK only 
	virtual BOOL SaveValues(HWND hwnd) = 0;

	// WM_ else...
	virtual BOOL ProcessDialog(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam) = 0;
};

class TestTransform : public TestConfigureInterface,
                      public TestDialogInterface
{
public:
	TestTransform()
	{
		static MatrixOrder matrixPrependSave = PrependOrder;

		matrixPrepend = &matrixPrependSave;

		matrix = NULL;
	}

	~TestTransform()
	{
		delete matrix;
	}

	// Configuration interface methods
	virtual BOOL ChangeSettings(HWND hwnd);
	virtual VOID Initialize();
	virtual VOID Initialize(Matrix** matrix);

	// Dialog maintenance methods
	virtual VOID InitDialog(HWND hwnd);
	virtual BOOL SaveValues(HWND hwnd);
	virtual BOOL ProcessDialog(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);

protected:
	VOID EnableDialogButtons(HWND hwnd, BOOL enable);
	VOID UpdateTransformPicture(HWND hwnd, INT idc, Matrix* matrix);

private:
	Matrix** origMatrix;
	Matrix* matrix;

	MatrixOrder* matrixPrepend;
};

class TestMatrixOperation : public TestConfigureInterface,
							public TestDialogInterface
{
public:
	TestMatrixOperation()
	{
		x = y = 0.0f;
		count = 0;
	}

	~TestMatrixOperation()
	{
	}

	// Configuration interface methods
	virtual BOOL ChangeSettings(HWND hwnd);
	virtual VOID Initialize();
	virtual VOID Initialize(TCHAR* dialogTitle,
							TCHAR* subTitle,
							TCHAR* descStr,
							INT count);

	// Dialog maintenance methods
	virtual VOID InitDialog(HWND hwnd);
	virtual BOOL SaveValues(HWND hwnd);
	virtual BOOL ProcessDialog(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);

	REAL GetX()
	{
		return x;
	};
	
	REAL GetY()
	{
		return y;
	};

private:
	TCHAR* dialogTitle;
	TCHAR* subTitle;
	TCHAR* descStr;
	INT count;
	REAL x, y;
};

// !! hacky stack based on DynArray types...

template <class T> class Stack : public DynArray<T>
{
public:

	typedef DynArray<T*> TArray;

    VOID Push(T& t)
	{
		Add(t);
	}

    T& Pop()
	{
		INT count = GetCount();
		
		if (count)
		{
			T& t = Last();
			AdjustCount(-1);
			return t;
		}
		else
		{
			ASSERT(FALSE);
			return GetPosition(0);		// !! hackish...
		}
	}

	T& GetPosition(INT pos)
	{
		return GetDataBuffer()[pos];
	}
};

class TestShape;

typedef Stack<TestShape*> ShapeStack;

// menu positions in window menu bar
const INT MenuFilePosition    = 0;
const INT MenuShapePosition   = 1;
const INT MenuBrushPosition   = 2;
const INT MenuPenPosition     = 3;
const INT MenuOtherPosition   = 4;

#define SetMenuCheckPos(w,x,y,z) SetMenuCheck(w,x,y,z,FALSE)
#define SetMenuCheckCmd(w,x,y,z) SetMenuCheck(w,x,y,z,TRUE)

extern VOID SetMenuCheck(HWND hwnd, 
						 INT menuPos, 
						 UINT idm, 
						 BOOL checked, 
						 BOOL byCmd);

extern Brush* blackBrush;
extern Brush* backBrush;
extern Pen* blackPen;
extern Color* blackColor;

#define MAX_LOADSTRING 100

extern VOID NotImplementedBox();
extern VOID WarningBox(TCHAR* string);
extern HINSTANCE hInst;
extern TCHAR szTitle[MAX_LOADSTRING];
extern TCHAR szWindowClass[MAX_LOADSTRING];
extern VOID WarningBeep();

extern VOID SetDialogLong(HWND hwnd, UINT idc, UINT value, BOOL enable = TRUE);
extern UINT GetDialogLong(HWND hwnd, UINT idc);
extern VOID SetDialogReal(HWND hwnd, UINT idc, REAL value);
extern REAL GetDialogReal(HWND hwnd, UINT idc);
extern VOID SetDialogText(HWND hwnd, UINT idc, LPTSTR text, BOOL enable = TRUE);
extern VOID GetDialogText(HWND hwnd, UINT idc, LPTSTR text, INT maxSize);
extern VOID SetDialogCombo(HWND hwnd, UINT idc, const TCHAR* strings[], INT count, INT cursel);
extern INT GetDialogCombo(HWND hwnd, UINT idc);
extern VOID SetDialogCheck(HWND hwnd, UINT idc, BOOL checked);
extern BOOL GetDialogCheck(HWND hwnd, UINT idc);
extern VOID SetDialogRealList(HWND hwnd, UINT idc, REAL* blend, INT count);
extern VOID	GetDialogRealList(HWND hwnd, UINT idc, REAL** blend, INT *count);
extern VOID EnableDialogControl(HWND hwnd, INT idc, BOOL enable);

extern VOID UpdateColorPicture(HWND hwnd, INT idc, ARGB argb);
extern VOID UpdateRGBColor(HWND hwnd, INT idcPic, ARGB& argb);

// Foward declarations of functions included in this code module:
ATOM				MyRegisterClass(HINSTANCE hInstance);
HWND				InitInstance(HINSTANCE, int, LPVOID);
LRESULT CALLBACK	WndTestDrawProc(HWND, UINT, WPARAM, LPARAM);

extern INT_PTR CALLBACK AllDialogBox(
									 HWND hwnd,
									 UINT msg,
									 WPARAM wParam,
									 LPARAM lParam
									 );
enum FormatType
{
	CPPFile,
	JavaFile,
	VMLFile
};

extern const TCHAR* tabStr;

const INT numFormats = 3;
extern const TCHAR* formatList[numFormats];
extern const FormatType formatValue[numFormats];

const INT numShapes = 9;
extern const TCHAR* shapeList[numShapes];
extern const INT shapeValue[numShapes];
extern const INT inverseShapeValue[numShapes];

const INT numBrushes = 7;
extern const TCHAR* brushList[numBrushes];
extern const INT brushValue[numBrushes]; 
extern const INT inverseBrushValue[numBrushes];

const int numCaps = 6;
extern const TCHAR* capList[numCaps];
extern const TCHAR* capStr[numCaps];
extern const LineCap capValue[numCaps];

const int numDashCaps = 3;
extern const TCHAR* dashCapList[numDashCaps];
extern const TCHAR* dashCapStr[numDashCaps];
extern const DashCap dashCapValue[numDashCaps];

const INT numJoin = 3;
extern const TCHAR* joinList[numJoin];
extern const TCHAR* joinStr[numJoin];
extern const LineJoin joinValue[numJoin];
	
const INT numDash = 5;
extern const TCHAR* dashList[numDash];
extern const TCHAR* dashStr[numDash];
extern const DashStyle dashValue[numDash];

const INT numWrap = 6;
extern const TCHAR* wrapList[numWrap];
extern const TCHAR* wrapStr[numWrap];
extern const WrapMode wrapValue[numWrap];

const INT numHatch = 6;
extern const TCHAR* hatchList[numHatch];
extern const TCHAR* hatchStr[numHatch];
extern const HatchStyle hatchValue[numHatch];

// Shapes:
//   Line(s), Arc(s), Bezier(s), Rect(s), Ellipse(s), Pie(s), Polygon(s),
//   Curve(s), Path(s), ClosedCurve(s)

enum ShapeTypes
{
	LineType = 0,
	ArcType = 1,
	BezierType = 2,
	RectType = 3,
	EllipseType = 4,
	PieType = 5,
	PolygonType = 6,
	CurveType = 7,
	ClosedCurveType = 8
};

const INT pointRadius = 4;

typedef DynArray<Point> PointArray;
typedef DynArray<ARGB> ARGBArray;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\gdiptest\harness\main.cxx ===
//
// Generic Windows program template
//

#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <windows.h>
#include <math.h>             // sin & cos
#include <tchar.h>

//
// Where is IStream included from?
//

#define IStream int

#include <gdiplus.hpp>

using namespace Gdiplus;

CHAR* programName;      // program name
HINSTANCE appInstance;  // handle to the application instance

#include "..\test.cpp"  // include generated code file

//
// Display an error message dialog and quit
//

VOID
Error(
    PCSTR fmt,
    ...
    )

{
    CHAR buf[1024];
    va_list arglist;

    va_start(arglist, fmt);
    vfprintf(stderr, fmt, arglist);
    va_end(arglist);

    exit(-1);
}


//
// Handle window repaint event
//

VOID
DoPaint(
    HWND hwnd
    )

{
    HDC hdc;
    PAINTSTRUCT ps;
    
    hdc = BeginPaint(hwnd, &ps);

    RECT rect;
    GetClientRect(hwnd, &rect);

    HBRUSH hbr, hbrOld;

    hbr = CreateSolidBrush(0xFFFFFF);

    hbrOld = (HBRUSH) SelectObject(hdc, hbr);

    FillRect(hdc, &rect, hbr);

    SelectObject(hdc, hbrOld);

    DeleteObject(hbr);

    DoGraphicsTest(hwnd);
   
    EndPaint(hwnd, &ps);
}


//
// Window callback procedure
//

LRESULT CALLBACK
MyWindowProc(
    HWND    hwnd,
    UINT    uMsg,
    WPARAM  wParam,
    LPARAM  lParam
    )

{
    switch (uMsg)
    {
    case WM_PAINT:
        DoPaint(hwnd);
        break;

    case WM_DESTROY:
        PostQuitMessage(0);
        break;

    default:
        return DefWindowProc(hwnd, uMsg, wParam, lParam);
    }

    return 0;
}


//
// Create main application window
//

VOID
CreateMyWindow(
    LPVOID image,
    LPCTSTR title
    )

#define MYWNDCLASSNAME _T("Test Harness")

{
    //********************************************************************
    //
    // Register window class if necessary
    //

    static BOOL wndclassRegistered = FALSE;

    if (!wndclassRegistered)
    {
        WNDCLASS wndClass =
        {
            0,
            MyWindowProc,
            0,
            0,
            appInstance,
            NULL,
            NULL,
            NULL,
            NULL,
            MYWNDCLASSNAME
        };

        RegisterClass(&wndClass);
        wndclassRegistered = TRUE;
    }

    HWND hwnd;
    INT width = 600, height = 600;

    hwnd = CreateWindow(
                    MYWNDCLASSNAME,
                    title,
                    WS_OVERLAPPED | WS_SYSMENU | WS_VISIBLE,
                    CW_USEDEFAULT,
                    CW_USEDEFAULT,
                    width,
                    height,
                    NULL,
                    NULL,
                    appInstance,
                    NULL);

    if (hwnd == NULL)
        Error("Couldn't create image window\n");

    SetWindowLong(hwnd, GWL_USERDATA, (LONG) image);
}


//
// Main program entrypoint
//

INT _cdecl
main(
    INT argc,
    CHAR **argv
    )

{
    programName = *argv++;
    argc--;
    appInstance = GetModuleHandle(NULL);

    //
    // Create the main application window
    //
    //********************************************************************

    CreateMyWindow(NULL, _T("Original Image"));

    //
    // Main message loop
    //

    MSG msg;

    while (GetMessage(&msg, NULL, 0, 0))
    {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }

    return msg.wParam;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\gpcfm\conform\pentst.cxx ===
#include <windows.h>

#define IStream int
#include <gdiplus.h>

#include <pentst.hxx>
#include <report.hxx>
#include <epsilon.hxx>

PenTst::PenTst()
{
    lstrcpy(name, TEXT("PenTst"));
    //hresult = NO_ERROR;
}

PenTst::~PenTst()
{
}

VOID PenTst::vEntry(Graphics *gfx, HWND hwnd, Report *rpt, Epsilon *eps)
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\gpcfm\conform\regiontst.cxx ===
#include <windows.h>

#define IStream int
#include <gdiplus.h>

#include <regiontst.hxx>
#include <report.hxx>
#include <epsilon.hxx>

RegionTst::RegionTst()
{
    lstrcpy(name, TEXT("RegionTst"));
    //hresult = NO_ERROR;
}

RegionTst::~RegionTst()
{
}

VOID RegionTst::vEntry(Graphics *gfx, HWND hwnd, Report *rpt, Epsilon *eps)
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\gpcfm\conform\test.cxx ===
class TstIF
{
public:
    virtual BOOL Setup()=0;
    virtual BOOL Execute()=0;
    virtual BOOL Verify()=0;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\gpcfm\conform\gradienttst.cxx ===
#include <windows.h>

#define IStream int
#include <gdiplus.h>

#include <gradienttst.hxx>
#include <report.hxx>
#include <epsilon.hxx>
#include <tsterror.hxx>

// compiler complained abs() ambiguous call to overloaded functions!
#define ABS(x) ((x) > 0) ? (x) : -(x)

GradientTst::GradientTst(VOID)
{
    lstrcpy(name, TEXT("GradientTst"));
}

GradientTst::~GradientTst(VOID)
{
}

VOID GradientTst::vEntry(Graphics *gfx, HWND hwnd, Report *rpt, Epsilon *eps)
{
    RECT rc;
    GetClientRect(hwnd, &rc);

    hresult = NO_ERROR;

    int iWidth = rc.right-rc.left;
    int iHeight = rc.bottom-rc.top;
    Rect brushRect(rc.left, rc.top, iWidth, iHeight);

    Color colors[5] =
    {
        Color(255, 0, 0, 0),
        Color(255, 255, 0, 0),
        Color(255, 0, 255, 0),
        Color(255, 0, 0, 255),
        Color(255, 255, 255, 255)
    };

    RectangleGradientBrush rectGrad0(brushRect, (Color*) &colors, WrapModeTile);

    gfx->FillRectangle(&rectGrad0, 0, 0, iWidth, iHeight);

    // We will have a getPixel method so the derived class doesn't have to
    // get the dc and use the slow GetPixel.  We'll have the alpha value as well.
    //
    // Besides, we could have all sorts of dc, test don't have to know what's
    // the right way to retrieve either bits or dc.
    //
    // Epsilon should be part of Test.  So, we don't have to pass it in.
    //
    // For now, I cheat..
    HDC hdc = GetDC(hwnd);

    // Verification:
    // Check endpoints

    COLORREF cr[4];

    cr[0] = GetPixel(hdc, 0, 0);
    cr[1] = GetPixel(hdc, rc.right-2, 0);
    cr[2] = GetPixel(hdc, 0, rc.bottom-2);
    cr[3] = GetPixel(hdc, rc.right-2, rc.bottom-2);

    for (int i = 0; i < 4; i++)
    {
        int iRedGot = cr[i] & 0x000000ff;
        int iGrnGot = (cr[i] & 0x0000ff00) >> 8;
        int iBluGot = (cr[i] & 0x00ff0000) >> 16;

        int iRedExp = colors[i].GetRed();
        int iGrnExp = colors[i].GetGreen();
        int iBluExp = colors[i].GetBlue();

        if ((ABS(iRedExp - iRedGot) > eps->fRed) ||
            (ABS(iGrnExp - iGrnGot) > eps->fGrn) ||
            (ABS(iBluExp - iBluGot) > eps->fBlu))
        {
            rpt->vLog(TLS_SEV3,
                "Rendered(RGB) %lx, %lx, %lx, \tExpected(RGB) %lx, %lx, %lx, \tcorner=%d",
                iRedGot, iGrnGot, iBluGot, iRedExp, iGrnExp, iBluExp, i);
            hresult = S_E_GRADIENTTST1;
        }
    }

    // monotonic increasing?
    COLORREF crPrev = GetPixel(hdc, 0, 0);
    for (int y = 1; y < iHeight-2; y++)
    {
        COLORREF crX1 = GetPixel(hdc, 0, y);
        if (crX1 < crPrev)
        {
            rpt->vLog(TLS_SEV3, "Not monotonic inc in x: crX1 %lx < crPrev %lx", crX1, crPrev);
            break;
        }
    }

    crPrev = GetPixel(hdc, 0, 0);
    for (int x = 1; x < iWidth-2; x++)
    {
        COLORREF crX1 = GetPixel(hdc, x, 0);
        if (crX1 < crPrev)
        {
            rpt->vLog(TLS_SEV3, "Not monotonic inc in y: crX1 %lx < crPrev %lx", crX1, crPrev);
            break;
        }
    }

    //COLORREF crX1 = GetPixel(hdc, 0, 0);                // 0
    //COLORREF crX2 = GetPixel(hdc, rc.right/4, 0);       // 39
    //COLORREF crX3 = GetPixel(hdc, rc.right/2, 0);       // 7b
    //COLORREF crX4 = GetPixel(hdc, rc.right-2, 0);       // ff
    //COLORREF crX5 = GetPixel(hdc, rc.right-1, 0);       // 0  (whatever in desktop)
    //COLORREF crX6 = GetPixel(hdc, rc.right, 0);         // ffffffff (wnd frame)

    // expect brush origin at (0,0) ie. a value of 0
    // expect brush

    //rpt->vLog(TLS_LOG, "%lx, %lx, %lx, %lx, %lx, %lx", crX1, crX2, crX3, crX4, crX5, crX6);

    REAL penWidth = 1;

    Color blueColor(0, 0, 255);
    Pen bluePen(blueColor, penWidth);

    gfx->DrawRectangle(&bluePen, 0, 0, iWidth, iHeight);

    // check top
    COLORREF crX1 = GetPixel(hdc, 0, 0);                  // ff0000
    COLORREF crX2 = GetPixel(hdc, rc.right/4, 0);         // ff0000
    COLORREF crX3 = GetPixel(hdc, rc.right/2, 0);         // ff0000
    COLORREF crX4 = GetPixel(hdc, rc.right-2, 0);         // ff0000

    //rpt->vLog(TLS_LOG, "%lx, %lx, %lx, %lx", crX1, crX2, crX3, crX4);

    // check 2nd from top
    crX1 = GetPixel(hdc, 0, 1);                         // ff0000
    crX2 = GetPixel(hdc, rc.right/4, 1);                // 39
    crX3 = GetPixel(hdc, rc.right/2, 1);                // 7b
    crX4 = GetPixel(hdc, rc.right-2, 1);                // f7
    COLORREF crX5 = GetPixel(hdc, rc.right-1, 1);                // 0  (desktop color)
    COLORREF crX6 = GetPixel(hdc, rc.right, 1);                  // ffffffff (wnd frame)

    //rpt->vLog(TLS_LOG, "%lx, %lx, %lx, %lx, %lx, %lx", crX1, crX2, crX3, crX4, crX5, crX6);

    // check left
    // check right
    // check bottom

    ReleaseDC(hwnd, hdc);

    //Sleep(1000 * 60);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\gpcfm\conform\xformtst.cxx ===
#include <windows.h>

#define IStream int
#include <gdiplus.h>

#include <xformtst.hxx>
#include <report.hxx>
#include <epsilon.hxx>

XformTst::XformTst()
{
    lstrcpy(name, TEXT("XformTst"));
    //hresult = NO_ERROR;
}

XformTst::~XformTst()
{
}

VOID XformTst::vEntry(Graphics *gfx, HWND hwnd, Report *rpt, Epsilon *eps)
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\gradient\debug.h ===
/******************************Module*Header*******************************\
* Module Name: debug.h
*
* Copyright (c) 1999 Microsoft Corporation
*
\**************************************************************************/

extern void LBprintf(PCH, ...);
extern void LBreset(void);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\gpcfm\conform\brushtst.cxx ===
#include <windows.h>

#define IStream int
#include <gdiplus.h>

#include <brushtst.hxx>
#include <report.hxx>
#include <epsilon.hxx>


BrushTst::BrushTst(VOID)
{
    lstrcpy(name, TEXT("BrushTst"));
    //hresult = NO_ERROR;
}

BrushTst::~BrushTst(VOID)
{
}

VOID BrushTst::vEntry(Graphics *gfx, HWND hwnd, Report *rpt, Epsilon *eps)
{

    Matrix mat;
    mat.Rotate(15);
    mat.Translate(-2.5, -2.5);
    gfx->SetWorldTransform(&mat);

    hresult = NO_ERROR;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\gradient\wndstuff.h ===
/****************************** Module Header ******************************\
* Module Name: wndstuff.h
*
* Kent's Window Test.  To be used as a program template.
*
* Created: 09-May-91
* Author: KentD
*
* Copyright (c) 1991 Microsoft Corporation
\***************************************************************************/

#define DONTUSE(x) (x)

#define MM_NEW          0x8001
#define MM_EXIT         0x8002
#define MM_TEST         0x8003

#define IDB_BITMAPCMYKTEST  0x9001

VOID Test(HWND);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\gpcfm\engine\debug.cxx ===
#include <windows.h>
#include <stdio.h>
#include <stdarg.h>
#include <tchar.h>
#include <debug.hxx>

namespace Globals
{
    DWORD dwDebug = 0;
    #if 0
    TCHAR AvailableTst[][MAX_STRING] =
    {
        TEXT("BrushTst"),
        TEXT("PenTst"),
        TEXT("RegionTst"),
        TEXT("XformTst")
    };
    #endif
};

VOID vOut(DWORD dwFlag, TCHAR message[MAX_STRING], ...)
{
    if (Globals::dwDebug & dwFlag)
    {
        va_list ArgList;
        TCHAR text[MAX_STRING*2];

        va_start(ArgList, message);
        _vstprintf(text, message, ArgList);
        va_end(ArgList);

        OutputDebugString(text);
    }
    return;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\libtest\debug.h ===
/******************************Module*Header*******************************\
* Module Name: debug.h
*
* Copyright (c) 1999 Microsoft Corporation
*
\**************************************************************************/

extern void LBprintf(PCH, ...);
extern void LBreset(void);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\gpcfm\engine\report.cxx ===
#include <windows.h>
#include <stdio.h>
#include <stdarg.h>
#include <tchar.h>
#include <ntlog.h>
#include <report.hxx>
#include <debug.hxx>

Report::Report(TCHAR *name)
{
    handleLog = tlCreateLog(name,
        TLS_REFRESH | TLS_INFO | TLS_SEV3 | TLS_SEV2 | TLS_VARIATION);

    if (handleLog == NULL)
    {
        vOut(DBG_REPORT, TEXT("Report(): tlCreateLog failed"));
        valid = FALSE;
    }
    else
    {
        valid = TRUE;
        tlAddParticipant(handleLog, 0L, 0);
    }
}

Report::~Report(VOID)
{
    if (valid)
    {
        tlReportStats(handleLog);
        tlRemoveParticipant(handleLog);
        tlDestroyLog(handleLog);
    }
}

VOID Report::vLog(DWORD level, TCHAR *message, ...)
{
    if (valid)
    {
        va_list ArgList;
        TCHAR text[MAX_STRING*2];

        va_start(ArgList, message);
        _vstprintf(text, message, ArgList);
        va_end(ArgList);

        tlLog(handleLog, level, "", 0, text);
    }
}

VOID Report::vStartVariation(VOID)
{
    if (valid)
    {
        tlStartVariation(handleLog);
    }
}

DWORD Report::dwEndVariation(VOID)
{
    DWORD dwVer = 0L;

    if (valid)
    {
        dwVer = tlEndVariation(handleLog);
    }
    return dwVer;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\gpcfm\engine\driver.cxx ===
#include <windows.h>
#include <stdio.h>
#define IStream int
#include <gdiplus.h>

#include <environ.hxx>
#include <report.hxx>
#include <epsilon.hxx>
#include <debug.hxx>
#include <driver.hxx>
#include <test.hxx>
#include <common.hxx>
#include <brushtst.hxx>
#include <regiontst.hxx>
#include <pentst.hxx>
#include <xformtst.hxx>
#include <gradienttst.hxx>

class TestList;

enum dctypes
{
    CACHEDDC,
    DISPLAYDC,                      // xxx multimonitor
    PRINTERDC,
    METAFILEDC,
    DDRAWSURFDC,
    DIBDC,
    CMPBMPDC
};

TCHAR *GetTypeString(int iType)
{
    switch(iType)
    {
        default:
        case CACHEDDC:
            return TEXT("CACHEDDC");

        case DISPLAYDC:
            return TEXT("DISPLAYDC");

        case PRINTERDC:
            return TEXT("PRINTERDC");

        case METAFILEDC:
            return TEXT("METAFILEDC");

        case DDRAWSURFDC:
            return TEXT("DDRAWSURFDC");

        case DIBDC:
            return TEXT("DIBDC");

        case CMPBMPDC:
            return TEXT("CMPBMPDC");
    }
}

HDC hdcAcquireDC(HWND hwnd, int types)
{
    switch (types)
    {
    default:
    case CACHEDDC:
        return GetDC(hwnd);
    /*
    case DISPLAYDC:

    case PRINTERDC:

    case METAFILEDC:
        HDC hdcref = GetDC(hwnd);
        RECT rc;

        GetClientRect(hwnd, &rc);
        return CreateEnhMetaFile(hdcref, NULL, &rc, TEXT("gpcfm.emf"));

    case DDRAWSURFDC:
        //

    case DIBDC:
    case CMPBMPDC:

    */
    }
}

class TestList
{
    friend int __cdecl main(int argc, char **argv);

    TestList(Report *rpt, int argc, char **argv)
    {
        if (argc > 1)
        {
            lstrcpy(AvailableTst[0], TEXT("BrushTst"));
            lstrcpy(AvailableTst[1], TEXT("PenTst"));
            lstrcpy(AvailableTst[2], TEXT("RegionTst"));
            lstrcpy(AvailableTst[3], TEXT("XformTst"));
            lstrcpy(AvailableTst[3], TEXT("GradientTst"));
            lNumTst = 4;
            bInitialized = bInit(rpt, argv[1]);
        }
        else
        {
            bInitialized = FALSE;
            rpt->vLog(TLS_LOG, "No script file");
        }
    }

    ~TestList()
    {
    }

    LONG lFindMatch(TCHAR *name)
    {
        //LONG lNumTst = sizeof(AvailableTst)/sizeof(AvailableTst[0]);
        for (LONG idx = 0; idx < lNumTst; idx++)
        {
            if (strcmp(AvailableTst[idx], name) == 0)
            {
                return idx;
            }
        }
        return -1;
    }

    BOOL bInit(Report *rpt, char *scr)
    {
        FILE *scriptFile;

        //
        // xxx retrieve name of script file from command line!
        //     save name of script file!
        //
        //scriptFile = fopen(TEXT("gpcfm.scr"), "r");
        scriptFile = fopen(scr, "r");
        if (scriptFile != NULL)
        {
            LONG idx = 0;
            TCHAR buf[MAX_STRING];

            while (!feof(scriptFile) && (idx < MAX_ELEMENTS-1))
            {
                fscanf(scriptFile, "%[^\n]", buf);
                if (buf[0] != '#')
                {
                    LONG index = lFindMatch(buf);
                    if (index == -1)
                    {
                        rpt->vLog(TLS_LOG, "%s not found", buf);
                        continue;
                    }
                    else
                    {
                        lst[idx++] = index;
                    }
                }
                fscanf(scriptFile, "%[\n]", buf);
            }
            lst[idx] = -1;
            fclose(scriptFile);
            return TRUE;
        }
        else
        {
            rpt->vLog(TLS_LOG, "Failed to open script file");
            return FALSE;
        }
    }

    Test* AcquireTst(TCHAR *pname)
    {
        Test *tst;

        if (strcmp(pname, TEXT("BrushTst")) == 0)
            tst = new BrushTst();
        else if (strcmp(pname, TEXT("PenTst")) == 0)
            tst = new PenTst();
        else if (strcmp(pname, TEXT("RegionTst")) == 0)
            tst = new RegionTst();
        else if (strcmp(pname, TEXT("XformTst")) == 0)
            tst = new XformTst();
        else if (strcmp(pname, TEXT("GradientTst")) == 0)
            tst = new GradientTst();

        return tst;
    }

public:
    LONG lst[MAX_ELEMENTS];
    BOOL bInitialized;
    TCHAR AvailableTst[100][MAX_STRING];
    LONG lNumTst;
};


int __cdecl main(int argc, char **argv)
{
    //
    // xxx retrieve name of log file from
    //     [option 1]   script file
    //     [option 2]   registry
    //     [option 3]   hardcoded, leave it as is
    //
    Report *rpt = new Report(TEXT("GpCfm.log"));

    //
    // xxx processing the command line
    //     do we want anything more than just the script file in command line?
    //
    TestList *tstLst = new TestList(rpt, argc, argv);

    if (tstLst->bInitialized)
    {
        Environment *env = new Environment();
        env->vStatusReport(rpt);

        //
        // xxx
        // how do we dynamically turn a particular one on or off?
        // - use a structure instead of enum...
        //   read from script and dis/enable as appropriate
        //
        // reminder: need to get GDI HDC from various Graphics context.
        //
        for (int dct = CACHEDDC; dct <= CMPBMPDC; dct++)
        {
            rpt->vLog(TLS_LOG, "DCTypes: %s", GetTypeString(dct));
            TestWnd *tstWnd = new TestWnd();
            if (tstWnd->hwnd)
            {
                HDC hdc = hdcAcquireDC(tstWnd->hwnd, dct);
                Epsilon *eps = new Epsilon(env, hdc);

                for (int i = 0; tstLst->lst[i] != -1; i++)
                {
                    Test *tst = tstLst->AcquireTst(tstLst->AvailableTst[tstLst->lst[i]]);
                    rpt->vStartVariation();

                    Graphics *gfx = new Graphics(hdc);

                    tst->vEntry(gfx, tstWnd->hwnd, rpt, eps);

                    delete gfx;

                    DWORD dwVer = rpt->dwEndVariation();
                    if (tst->hresult != NO_ERROR)
                    {
                        rpt->vLog(TLS_SEV3 | TLS_VARIATION, "%s failed", tstLst->AvailableTst[tstLst->lst[i]]);
                        eps->vReport(rpt);
                    }
                    else
                    {
                        rpt->vLog(dwVer | TLS_VARIATION, "%s passed", tstLst->AvailableTst[tstLst->lst[i]]);
                    }
                    delete tst;
                }
                delete eps;

                if (dct == CMPBMPDC)
                    tstWnd->vUnReg();
            }
            else
            {
                rpt->vLog(TLS_LOG, "Create TestWnd failed");
            }
        }
        delete env;
    }
    else
    {
        rpt->vLog(TLS_LOG, "TestList initialization failed");
    }
    delete rpt;
    return 0;
}


LRESULT CALLBACK WndProc(HWND hwnd, UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
    LRESULT lr = 0;

    switch(uiMsg)
    {
        case WM_CLOSE:
            DestroyWindow(hwnd);
            break;
        case WM_DESTROY:
            PostQuitMessage(0);
            break;
        default:
            lr = DefWindowProc(hwnd, uiMsg, wParam, lParam);
            break;
    }
    return lr;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\gradient\gradient.cpp ===
/******************************Module*Header*******************************\
* Module Name: test.c
*
* Created: 09-Dec-1992 10:51:46          
* Author: Kirk Olynyk [kirko]
*
* Copyright (c) 1991 Microsoft Corporation
*
* Contains the test
*
\**************************************************************************/

#include <windows.h>
#include <objbase.h>
#include <math.h>             // sin & cos
#include "wndstuff.h"
#include "debug.h"

//
// Where is IStream included from?
//

#define IStream int

#include <gdiplus.h>

using namespace Gdiplus;

#ifndef ASSERT
    #define ASSERT(cond)    if (!(cond)) { DebugBreak(); }
#endif


// Figures out the Affine matrix mapping from the unit square to the
// input parallelogram

VOID InferAffineMatrix(
    const GpPointF* destPoints,  // must be 3 points.
    Matrix *m
    )
{
    float x0 = destPoints[0].X;
    float y0 = destPoints[0].Y;
    float x1 = destPoints[1].X;
    float y1 = destPoints[1].Y;
    float x2 = destPoints[2].X;
    float y2 = destPoints[2].Y;

    float u0 = 0.0f;
    float v0 = 0.0f;
    float u1 = u0 + 1.0f;
    float v1 = v0;
    float u2 = u0;
    float v2 = v0 + 1.0f;

    float d = u0*(v1-v2) - v0*(u1-u2) + (u1*v2-u2*v1);

    if (fabsf(d) < REAL_EPSILON)
    {
        ASSERT(FALSE);
        return;
    }
    
    d = 1.0f / d;

    float t0 = v1-v2;
    float t1 = v2-v0;
    float t2 = v0-v1;
    float M11 = d * (x0*t0 + x1*t1 + x2*t2);
    float M12 = d * (y0*t0 + y1*t1 + y2*t2);

    t0 = u2-u1;
    t1 = u0-u2;
    t2 = u1-u0;
    float M21 = d * (x0*t0 + x1*t1 + x2*t2);
    float M22 = d * (y0*t0 + y1*t1 + y2*t2);

    t0 = u1*v2-u2*v1;
    t1 = u2*v0-u0*v2;
    t2 = u2*v1-u1*v0;
    float Dx  = d * (x0*t0 + x1*t1 + x2*t2);
    float Dy  = d * (y0*t0 + y1*t1 + y2*t2);
    
    m->SetElements(M11, M12, M21, M22, Dx, Dy);
}


/******************************Public*Routine******************************\
* vTest
*
* This is the workhorse routine that does the test. The test is
* started by chosing it from the window menu.
*
* History:
*  Tue 08-Dec-1992 17:31:22 by Kirk Olynyk [kirko]
* Wrote it.
\**************************************************************************/


const PointF center(400.0f, 400.0f);

VOID Test(HWND hwnd)
{
    Graphics *g = new Graphics(hwnd);
    
    //g->SetSmoothingMode(SmoothingModeAntiAlias);
    
    DWORD c0 = 0xff0000ff;
    DWORD c1 = 0xffff0000;
    DWORD c2 = 0xff00ff00;
    
    LinearGradientBrush brush(
        PointF(-0.5f, -0.5f), 
        PointF(0.5f, 0.5f),
        Color(c0),
        Color(c1)
    );
    
    Pen edgePen(Color(0xff000000), 3.5f/400.0f);
    
    brush.SetGammaCorrection(TRUE);
    brush.SetWrapMode(WrapModeTile);
    brush.SetBlendTriangularShape(0.5f, 1.0f);
//    brush.SetBlendBellShape(0.2f, 0.5f);
    
    Matrix m;
    
    GraphicsPath gp;
    
    PointF points[4] = {
        PointF(-0.5f, -0.5f),
        PointF(0.5f, -0.5f),
        PointF(0.5f, 0.5f),
        PointF(-0.5f, 0.5f)
    };
    
    Matrix bm;
    brush.GetTransform(&bm);
    
    gp.AddPolygon(points, 4);
    
    
    
    g->TranslateTransform(center.X, center.Y);
    g->ScaleTransform(400.0f, 400.0f);
  /*  
    m.SetElements(100.0f, 0.0f, 0.0f, 300.0f, 0.0f, 0.0f);
    gp.Transform(&m);
    brush.MultiplyTransform(&m, MatrixOrderAppend);
    g->FillPath(&brush, &gp);
    g->TranslateTransform(-200.0f, 0.0f);
    brush.SetTransform(&bm);
    brush.SetLinearPoints(PointF(0.0f, 0.0f), PointF(100.0f, 300.0f));
    brush.SetLinearColors(Color(c1), Color(c0));
    g->FillPath(&brush, &gp);
  
  */
    
    // Simple rotate on the brush transform
    
    g->DrawPath(&edgePen, &gp);
    
    for(int i = 0; i < 181; i++)
    {
        g->FillPath(&brush, &gp);
        brush.RotateTransform(1.0f);
    }
    
    brush.SetTransform(&bm);
    
    // Vertical stretch, no brush transform.
    
    for(int i = 0; i < 101; i++)
    {
        float t = i/100.0f;
        float r = 2.0f*(float)M_PI*(t);
        m.Reset();
        m.Scale(1.0f, 1.0f + (float)sin(r)/70.0f);
        gp.Transform(&m);
        g->FillPath(&brush, &gp);
        g->DrawPath(&edgePen, &gp);
    }
    
    brush.SetTransform(&bm);
    gp.Reset();
    gp.AddPolygon(points, 4);

    for(int i = 0; i < 101; i++)
    {
        float t = i/100.0f;
        float r = 2.0f*(float)M_PI*(t);
        m.Reset();
        m.Scale(1.0f + (float)sin(r)/70.0f, 1.0f);
        gp.Transform(&m);
        g->FillPath(&brush, &gp);
        g->DrawPath(&edgePen, &gp);
    }
    
    brush.SetTransform(&bm);
    gp.Reset();
    gp.AddPolygon(points, 4);

    for(int i = 0; i < 101; i++)
    {
        float r = (float)M_PI*(i/200.0f);
        m.Reset();
        m.Scale(1.0f, 1.0f + (float)sin(r));
        
        gp.Reset();
        gp.AddPolygon(points, 4);
        gp.Transform(&m);
        
        brush.SetTransform(&bm);
        brush.GetTransform(&m);
        m.Scale(1.0f, 1.0f+(float)sin(r), MatrixOrderAppend);
        brush.SetTransform(&m);
        g->FillPath(&brush, &gp);
        g->DrawPath(&edgePen, &gp);
    }
    
    for(int i = 0; i < 101; i++)
    {
        float r = (float)M_PI*(i/200.0f);
        m.Reset();
        m.Scale(
            1.0f + (float)sin(r), 
            1.0f + (float)sin(r+M_PI/2.0f)
        );
        
        gp.Reset();
        gp.AddPolygon(points, 4);
        gp.Transform(&m);
        
        brush.SetTransform(&bm);
        brush.GetTransform(&m);
        
        m.Scale(
            1.0f + (float)sin(r), 
            1.0f + (float)sin(r+M_PI/2.0f), 
            MatrixOrderAppend
        );
        
        brush.SetTransform(&m);
        g->FillPath(&brush, &gp);
        g->DrawPath(&edgePen, &gp);
    }

    for(int i = 0; i < 101; i++)
    {
        float r = (float)M_PI*(i/200.0f);
        m.Reset();
        m.Scale(
            1.0f + (float)sin(r+M_PI/2.0f), 
            1.0f
        );
        
        gp.Reset();
        gp.AddPolygon(points, 4);
        gp.Transform(&m);
        
        brush.SetTransform(&bm);
        brush.GetTransform(&m);
        
        m.Scale(
            1.0f+(float)sin(r+M_PI/2.0f), 
            1.0f,
            MatrixOrderAppend
        );
        
        brush.SetTransform(&m);
        g->FillPath(&brush, &gp);
        g->DrawPath(&edgePen, &gp);
    }
   
    brush.SetTransform(&bm);
    gp.Reset();
    gp.AddPolygon(points, 4);
    
    Matrix gm;
    g->GetTransform(&gm);
   
    for(int i = 0; i < 181; i++)
    {
        g->FillPath(&brush, &gp);
        g->DrawPath(&edgePen, &gp);
        brush.RotateTransform(-1.0f);
        g->RotateTransform(1.0f);
    }

    for(int i = 0; i < 181; i++)
    {
        g->FillPath(&brush, &gp);
        g->DrawPath(&edgePen, &gp);
        g->RotateTransform(1.0f);
    }

    for(int i = 0; i < 181; i++)
    {
        float r = (float)M_PI*(i/180.0f);
        g->FillPath(&brush, &gp);
        g->SetTransform(&gm);
        g->RotateTransform((float)i);
        g->ScaleTransform(
            1.0f+(float)sin(r)/2.0f, 
            1.0f,
            MatrixOrderAppend
        );
    }
    g->SetTransform(&gm);
    brush.SetTransform(&bm);
    gp.Reset();
    gp.AddPolygon(points, 4);
    g->FillPath(&brush, &gp);
    g->DrawPath(&edgePen, &gp);
    delete g;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\imgtest\rsrc.h ===
#define IDR_MAINMENU        100
#define IDR_ACCELTABLE      101

#define IDM_OPEN            200
#define IDM_SAVE            201
#define IDM_FIT_WINDOW      202
#define IDM_QUIT            203

#define IDM_CONVERT_RGB555  300
#define IDM_CONVERT_RGB565  301
#define IDM_CONVERT_RGB24   302
#define IDM_CONVERT_RGB32   303
#define IDM_CONVERT_ARGB    304

#define IDM_SCALE_GDI       400
#define IDM_SCALE_GDIHT     401
#define IDM_SCALE_NEIGHBOR  402
#define IDM_SCALE_BILINEAR  403
#define IDM_SCALE_AVERAGING 404
#define IDM_SCALE_BICUBIC   405

#define IDM_BMP_CROP        500
#define IDM_BMP_RESIZE      501
#define IDM_BMP_FLIPX       502
#define IDM_BMP_FLIPY       503
#define IDM_BMP_ROTATE90    504
#define IDM_BMP_ROTATE270   505
#define IDM_BRIGHTEN        506
#define IDM_DARKEN          507
#define IDM_INCCONTRAST     508
#define IDM_DECCONTRAST     509
#define IDM_INCGAMMA        510
#define IDM_DECGAMMA        511
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\gradient\wndstuff.cpp ===
/******************************Module*Header*******************************\
* Module Name: wndstuff.cpp
*
* This file contains the code to support a simple window that has
* a menu with a single item called "Test". When "Test" is selected
* vTest(HWND) is called.
*
* Created: 09-Dec-1992 10:44:31
* Author: Kirk Olynyk [kirko]
*
* Copyright (c) 1991 Microsoft Corporation
*
\**************************************************************************/

// for Win95 compile
#undef UNICODE
#undef _UNICODE

#include <windows.h>
#include <stdio.h>
#include <tchar.h>
#include <objbase.h>
#include <gdiplus.h>

#include "wndstuff.h"

#include "../gpinit.inc"

HINSTANCE ghInstance;
HWND ghwndMain;
HWND ghwndDebug;
HWND ghwndList;
HBRUSH ghbrWhite;

/***************************************************************************\
* lMainWindowProc(hwnd, message, wParam, lParam)
*
* Processes all messages for the main window.
*
* History:
*  04-07-91 -by- KentD
* Wrote it.
\***************************************************************************/

LONG_PTR
lMainWindowProc(
    HWND    hwnd,
    UINT    message,
    WPARAM  wParam,
    LPARAM  lParam
    )
{
    PAINTSTRUCT ps;

    switch (message)
    {
    case WM_CREATE:
        break;

    case WM_COMMAND:
        switch(LOWORD(wParam))
        {
        case MM_TEST:
            Test(hwnd);
            break;

        default:
            break;
        }
        break;

    case WM_DESTROY:
        DeleteObject(ghbrWhite);
        PostQuitMessage(0);
        return(DefWindowProc(hwnd, message, wParam, lParam));

    default:
        return(DefWindowProc(hwnd, message, wParam, lParam));
    }

    return(0);
}

/******************************Public*Routine******************************\
* DebugWndProc
*
* List box is maintained here.
*
\**************************************************************************/

LONG_PTR FAR PASCAL DebugWndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    RECT    rcl;
    HDC     hdc;
    LONG_PTR    lRet = 0;

// Process window message.

    switch (message)
    {
    case WM_SIZE:
        lRet = DefWindowProc(ghwndList, message, wParam, lParam);
        GetClientRect(ghwndMain, &rcl);
        MoveWindow(
            ghwndList,
            rcl.left, rcl.top,
            (rcl.right - rcl.left), (rcl.bottom - rcl.top),
            TRUE
            );
        UpdateWindow(ghwndList);
        break;

    case WM_DESTROY:
        PostQuitMessage(0);
        break;

    default:
        lRet = DefWindowProc(hwnd, message, wParam, lParam);
        break;
    }

    return lRet;
}

/******************************Public*Routine******************************\
* LBprintf
*
* ListBox printf implementation.
*
* History:
*  15-Dec-1994 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

void LBprintf(PCH msg, ...)
{
    if (ghwndList)
    {
        va_list ap;
        char buffer[256];

        va_start(ap, msg);

        vsprintf(buffer, msg, ap);

        SendMessage(ghwndList, LB_ADDSTRING, (WPARAM) 0, (LPARAM) buffer);
        SendMessage(ghwndList, WM_SETREDRAW, (WPARAM) TRUE, (LPARAM) 0);
        InvalidateRect(ghwndList, NULL, TRUE);
        UpdateWindow(ghwndList);

        va_end(ap);
    }
}

/******************************Public*Routine******************************\
* LBreset
*
* Reset ListBox state (clear).
*
* History:
*  15-Dec-1994 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

void LBreset()
{
    if (ghwndList)
        SendMessage(ghwndList, LB_RESETCONTENT, (WPARAM) FALSE, (LPARAM) 0);
}

/***************************************************************************\
* bInitApp()
*
* Initializes app.
*
* History:
*  04-07-91 -by- KentD
* Wrote it.
\***************************************************************************/

BOOL bInitApp(BOOL debug)
{
    WNDCLASS wc;

    ghbrWhite = CreateSolidBrush(RGB(0xFF,0xFF,0xFF));

    wc.style            = 0;
    wc.lpfnWndProc      = lMainWindowProc;
    wc.cbClsExtra       = 0;
    wc.cbWndExtra       = 0;
    wc.hInstance        = ghInstance;
    wc.hIcon            = LoadIcon(NULL, IDI_APPLICATION);
    wc.hCursor          = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground    = ghbrWhite;
    wc.lpszMenuName     = _T("MainMenu");
    wc.lpszClassName    = _T("TestClass");
    if (!RegisterClass(&wc))
    {
        return(FALSE);
    }
    ghwndMain =
      CreateWindowEx(
        0,
        _T("TestClass"),
        _T("Win32 Test"),
        WS_OVERLAPPED   |  
        WS_CAPTION      |  
        WS_BORDER       |  
        WS_THICKFRAME   |  
        WS_MAXIMIZEBOX  |  
        WS_MINIMIZEBOX  |  
        WS_CLIPCHILDREN |  
        WS_VISIBLE      |  
        WS_SYSMENU,
        80,
        70,
        500,
        500,
        NULL,
        NULL,
        ghInstance,
        NULL);

    if (ghwndMain == NULL)
    {
        return(FALSE);
    }

    if (debug)
    {
        RECT rcl;

        memset(&wc, 0, sizeof(wc));
        wc.style = 0;
        wc.lpfnWndProc = DebugWndProc;
        wc.cbClsExtra = 0;
        wc.cbWndExtra = 0;
        wc.hInstance = ghInstance;
        wc.hIcon = LoadIcon(NULL, IDI_APPLICATION);
        wc.hCursor = LoadCursor(NULL, IDC_ARROW);
        wc.hbrBackground = ghbrWhite;
        wc.lpszClassName = "DebugWClass";
        RegisterClass(&wc);

        ghwndDebug = CreateWindow(
            "DebugWClass",
            "Debug output",
            WS_OVERLAPPEDWINDOW|WS_MAXIMIZE,
            600,
            70,
            300,
            500,
            NULL,
            NULL,
            ghInstance,
            NULL
            );

        if (ghwndDebug)
        {
            ShowWindow(ghwndDebug, SW_NORMAL);
            UpdateWindow(ghwndDebug);

        // Create the list box to fill the main window.

            GetClientRect(ghwndDebug, &rcl);

            ghwndList = CreateWindow(
                "LISTBOX",
                "Debug output",
                WS_CHILD | WS_VISIBLE | WS_VSCROLL
                | WS_HSCROLL | LBS_NOINTEGRALHEIGHT,
                rcl.left, rcl.top,
                (rcl.right - rcl.left), (rcl.bottom - rcl.top),
                ghwndDebug,
                NULL,
                ghInstance,
                NULL
                );

            if (ghwndList)
            {
                SendMessage(
                    ghwndList,
                    WM_SETFONT,
                    (WPARAM) GetStockObject(ANSI_FIXED_FONT),
                    (LPARAM) FALSE
                    );

                LBreset();

                ShowWindow(ghwndList, SW_NORMAL);
                UpdateWindow(ghwndList);
            }
        }

    }

    SetFocus(ghwndMain);

    return(TRUE);
}

/***************************************************************************\
* main(argc, argv[])
*
* Sets up the message loop.
*
* History:
*  04-07-91 -by- KentD
* Wrote it.
\***************************************************************************/

_cdecl
main(
    INT   argc,
    PCHAR argv[])
{
    MSG    msg;
    HACCEL haccel;
    CHAR*  pSrc;
    CHAR*  pDst;

    if (!gGdiplusInitHelper.IsValid())
    {
        return 0;
    }
    
    BOOL wantDebugWindow = FALSE;

    CoInitialize(NULL);

    // Parse arguments

    for (argc--, argv++ ; argc && '-' == **argv ; argc--, argv++ )
    {
        switch ( *(++(*argv)) )
        {
        case 'd':
        case 'D':
            wantDebugWindow = TRUE;
            break;
        }
    }

    ghInstance = GetModuleHandle(NULL);

    if (!bInitApp(wantDebugWindow))
    {
        return(0);
    }

    haccel = LoadAccelerators(ghInstance, MAKEINTRESOURCE(1));
    while (GetMessage(&msg, NULL, 0, 0))
    {
        if (!TranslateAccelerator(msg.hwnd, haccel, &msg))
        {
             TranslateMessage(&msg);
             DispatchMessage(&msg);
        }
    }

    CoUninitialize();
    return(1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\imgdiff\imgdiff.cxx ===
/**************************************************************************
*
* Copyright (c) 2000 Microsoft Corporation
*
* Program Name:
*
*   ImgDiff
*
*   ImgDiff source_file_1 source_file_2 destination_file
*
*   This will difference the two source files (provided they're the same size)
*   and output the resulting image.
*
*   Technically it does:
*
*   CD[i] = | S1[i] - S2[i] |
*
*   where i indexes the color channels rather than the pixels.
*   because it's an abs computation, the input source file order is unimportant.
*
*
* Created:
*
*   06/25/2000 asecchia
*      Created it.
*
**************************************************************************/

#include <stdio.h>
#include <windows.h>
#include <objbase.h>
#include <gdiplus.h>

INT AsciiToUnicodeStr(
    const CHAR* ansiStr,
    WCHAR* unicodeStr,
    INT unicodeSize
)
{
    return( MultiByteToWideChar(
        CP_ACP,
        0,
        ansiStr,
        -1,
        unicodeStr,
        unicodeSize
    ) > 0 );
}

#define Fail() goto cleanup

void _cdecl main(int argc, char **argv) 
{

    if(argc<4) 
    {
        printf("error - need source1 and source2 and destination filename\n");
        printf("usage: ImgDiff srcfilename srcfilename dstfilename\n");
        return;
    }
    
    using namespace Gdiplus;

    Status status;
    WCHAR source1[1024];
    WCHAR source2[1024];
    WCHAR outfilename[1024];
    AsciiToUnicodeStr(argv[1], source1, 1024);
    AsciiToUnicodeStr(argv[2], source2, 1024);
    AsciiToUnicodeStr(argv[3], outfilename, 1024);


    ImageCodecInfo* codecs = NULL;
    UINT count;
    UINT cbCodecs;
    
    // Open the source images
    
    Bitmap *srcBmp1 = new Bitmap(source1);
    Bitmap *srcBmp2 = new Bitmap(source2);

    // Ask the source image for it's size.
    
    int width = srcBmp1->GetWidth();
    int height = srcBmp1->GetHeight();

    
    if( (width != (int)srcBmp2->GetWidth()) ||
        (height != (int)srcBmp2->GetHeight())   )
    {
        printf("the two input files are different sizes\n");
        return;
    }

    printf("Input images are (%d x %d)\n", width, height);
    
    // Create a destination image to draw onto
    
    Bitmap *dstBmp = new Bitmap(
        width, 
        height,
        PixelFormat32bppARGB
    );
    
    BitmapData bdSrc1;
    BitmapData bdSrc2;
    BitmapData bdDst;
    
    Rect rect(0,0,width,height);
    
    srcBmp1->LockBits(rect, ImageLockModeRead, PixelFormat32bppARGB, &bdSrc1);
    srcBmp2->LockBits(rect, ImageLockModeRead, PixelFormat32bppARGB, &bdSrc2);
    dstBmp->LockBits(rect, ImageLockModeWrite, PixelFormat32bppARGB, &bdDst);
    
    int x, y;
    
    unsigned char *s1, *s2, *d;
    
    for(y = 0; y < (int)bdSrc1.Height; y++)
    {
        for(x = 0; x < (int)bdSrc1.Width; x++)
        {
            s1 = (unsigned char *)((ARGB*)(bdSrc1.Scan0) + x + y * bdSrc1.Width);
            s2 = (unsigned char *)((ARGB*)(bdSrc2.Scan0) + x + y * bdSrc2.Width);
            d =  (unsigned char *)((ARGB*)(bdDst.Scan0) + x + y * bdDst.Width);
         
            // per channel subtract.
               
            d[0] = (unsigned char)abs(s1[0] - s2[0]);
            d[1] = (unsigned char)abs(s1[1] - s2[1]);
            d[2] = (unsigned char)abs(s1[2] - s2[2]);
            d[3] = (unsigned char)abs(s1[3] - s2[3]);
        }
    }
    
    srcBmp1->UnlockBits(&bdSrc1);
    srcBmp2->UnlockBits(&bdSrc2);
    dstBmp->UnlockBits(&bdDst);
    
    // Now start finding a codec to output the image.

    cbCodecs = 0;
    GetImageEncodersSize(&count, &cbCodecs);

    // Allocate space for the codec list
    
    codecs = static_cast<ImageCodecInfo *>(malloc (cbCodecs));
    
    if (codecs == NULL)
    {
        printf("error: failed to allocate memory for codecs\n");
        Fail();
    }

    // Get the list of encoders
    
    status = GetImageEncoders(count, cbCodecs, codecs);
    
    if (status != Ok)
    {
        printf("Error: GetImageEncoders returned %d\n", status);
        Fail();
    }

    // Search the codec list for the JPEG codec.
    // Use the Mime Type field to specify the correct codec.
    
    for(UINT i=0; i<count; i++) {
        if(wcscmp(codecs[i].MimeType, L"image/bmp")==0) {break;}
    }

    if(i>=count)
    {
        fprintf(stderr, "failed to find the codec\n");
        Fail();
    }

    // Output the image to disk.
    
    CLSID tempClsID;
    tempClsID = codecs[i].Clsid;
    
    status = dstBmp->Save(
        outfilename, 
        &tempClsID, 
        NULL
    );

    if (status != Ok) 
    {
        fprintf(stderr, "SaveImage--Save() failed\n");
        Fail();
    }

    // We're golden - everything worked.
    
    printf("Done\n");


    // Clean up the objects we used.
    
    cleanup:   
    
    
    free(codecs);    
    delete dstBmp;
    delete srcBmp1;
    delete srcBmp2;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\imgtest\imgtest.cpp ===
//
// Simple test program for imaging library
//

#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <windows.h>
#include <objbase.h>
#include <urlmon.h>
#include <commdlg.h>

#include <imaging.h>
#include <initguid.h>
#include <imgguids.h>

#include "rsrc.h"

CHAR* programName;          // program name
HINSTANCE appInstance;      // handle to the application instance
HWND hwndMain;              // handle to application's main window
IImagingFactory* imgfact;   // pointer to IImageingFactory object
IImage* curImage;           // pointer to IImage object
CHAR curFilename[MAX_PATH]; // current image filename
INT scaleMethod = IDM_SCALE_NEIGHBOR;


//
// Display an error message dialog
//

BOOL
CheckHRESULT(
    HRESULT hr,
    INT line
    )
{
    if (SUCCEEDED(hr))
        return TRUE;

    CHAR buf[1024];

    sprintf(buf, "Error on line %d: 0x%x\n", line, hr);
    MessageBoxA(hwndMain, buf, programName, MB_OK);

    return FALSE;
}

#define CHECKHR(hr) CheckHRESULT(hr, __LINE__)
#define LASTWIN32HRESULT HRESULT_FROM_WIN32(GetLastError())

#if DBG
#define VERBOSE(args) printf args
#else
#define VERBOSE(args)
#endif


//
// Helper class to convert ANSI strings to Unicode strings
//

inline BOOL
UnicodeToAnsiStr(
    const WCHAR* unicodeStr,
    CHAR* ansiStr,
    INT ansiSize
    )
{
    return WideCharToMultiByte(
                CP_ACP,
                0,
                unicodeStr,
                -1,
                ansiStr,
                ansiSize,
                NULL,
                NULL) > 0;
}

inline BOOL
AnsiToUnicodeStr(
    const CHAR* ansiStr,
    WCHAR* unicodeStr,
    INT unicodeSize
    )
{
    return MultiByteToWideChar(
                CP_ACP,
                0,
                ansiStr,
                -1,
                unicodeStr,
                unicodeSize) > 0;
}


class UnicodeStrFromAnsi
{
public:

    UnicodeStrFromAnsi(const CHAR* ansiStr)
    {
        if (ansiStr == NULL)
        {
            valid = TRUE;
            unicodeStr = NULL;
        }
        else
        {
            // NOTE: we only handle strings with length < MAX_PATH.

            valid = AnsiToUnicodeStr(ansiStr, buf, MAX_PATH);
            unicodeStr = valid ? buf : NULL;
        }
    }

    BOOL IsValid() const
    {
        return valid;
    }

    operator WCHAR*()
    {
        return unicodeStr;
    }

private:

    BOOL valid;
    WCHAR* unicodeStr;
    WCHAR buf[MAX_PATH];
};


//
// Get scale method strings and interpolation hints
//

const CHAR*
GetScaleMethodStr()
{
    switch (scaleMethod)
    {
    case IDM_SCALE_GDI:         return "GDI";
    case IDM_SCALE_GDIHT:       return "GDI + Halftone";
    case IDM_SCALE_NEIGHBOR:    return "Nearest Neighbor";
    case IDM_SCALE_BILINEAR:    return "Bilinear";
    case IDM_SCALE_AVERAGING:   return "Averaging";
    case IDM_SCALE_BICUBIC:     return "Bicubic";
    default:                    return "Unknown";
    }
}

InterpolationHint
GetScaleMethodInterp()
{
    switch (scaleMethod)
    {
    case IDM_SCALE_BILINEAR:    return INTERP_BILINEAR;
    case IDM_SCALE_AVERAGING:   return INTERP_AVERAGING;
    case IDM_SCALE_BICUBIC:     return INTERP_BICUBIC;
    case IDM_SCALE_NEIGHBOR:    return INTERP_NEAREST_NEIGHBOR;
    case IDM_SCALE_GDI:
    case IDM_SCALE_GDIHT:
    default:                    return INTERP_DEFAULT;
    }
}


//
// Get pixel format strings
//

const CHAR*
GetPixelFormatStr(
    PixelFormatID pixfmt
    )
{
    switch (pixfmt)
    {
    case PIXFMT_1BPP_INDEXED:       return "1bpp indexed";
    case PIXFMT_4BPP_INDEXED:       return "4bpp indexed";
    case PIXFMT_8BPP_INDEXED:       return "8bpp indexed";
    case PIXFMT_16BPP_GRAYSCALE:    return "16bpp grayscale";
    case PIXFMT_16BPP_RGB555:       return "16bpp RGB 5-5-5";
    case PIXFMT_16BPP_RGB565:       return "16bpp RGB 5-6-5";
    case PIXFMT_16BPP_ARGB1555:     return "16bpp ARGB 1-5-5-5";
    case PIXFMT_24BPP_RGB:          return "24bpp RGB";
    case PIXFMT_32BPP_RGB:          return "32bpp RGB";
    case PIXFMT_32BPP_ARGB:         return "32bpp ARGB";
    case PIXFMT_32BPP_PARGB:        return "32bpp premultiplied ARGB";
    case PIXFMT_48BPP_RGB:          return "48bpp RGB";
    case PIXFMT_64BPP_ARGB:         return "64bpp ARGB";
    case PIXFMT_64BPP_PARGB:        return "64bpp premultiplied ARGB";
    case PIXFMT_UNDEFINED:
    default:                        return "Unknown";
    }
}

//
// Force a refresh of the image window
//

VOID RefreshImageDisplay()
{
    InvalidateRect(hwndMain, NULL, FALSE);

    // Update window title

    CHAR title[2*MAX_PATH];
    CHAR* p = title;

    strcpy(p, curFilename);
    p += strlen(p);

    HRESULT hr;
    SIZE size;
    IBitmapImage* bmp;

    hr = curImage->QueryInterface(IID_IBitmapImage, (VOID**) &bmp);

    if (FAILED(hr))
    {
        // Decoded image

        hr = curImage->GetPhysicalDimension(&size);

        if (SUCCEEDED(hr))
        {
            sprintf(p, ", Dimension: %0.2fx%0.2fmm", size.cx / 100.0, size.cy / 100.0);
            p += strlen(p);
        }
    }
    else
    {
        // In-memory bitmap image

        hr = bmp->GetSize(&size);

        if (CHECKHR(hr))
        {
            sprintf(p, ", Size: %dx%d", size.cx, size.cy);
            p += strlen(p);
        }

        PixelFormatID pixfmt;

        hr = bmp->GetPixelFormatID(&pixfmt);

        if (CHECKHR(hr))
        {
            sprintf(p, ", Pixel Format: %s", GetPixelFormatStr(pixfmt));
            p += strlen(p);
        }

        bmp->Release();
    }

    sprintf(p, ", Scale Method: %s", GetScaleMethodStr());
    p += strlen(p);

    SetWindowText(hwndMain, title);
}


//
// Set the current image
//

VOID
SetCurrentImage(
    IUnknown* unk,
    const CHAR* filename = NULL
    )
{
    IImage* image;

    if (filename != NULL)
    {
        // Decoded image

        image = (IImage*) unk;
        strcpy(curFilename, filename);
    }
    else
    {
        // In-memory bitmap image

        HRESULT hr;

        hr = unk->QueryInterface(IID_IImage, (VOID**) &image);
        unk->Release();

        if (!CHECKHR(hr))
            return;

        strcpy(curFilename, "In-memory Bitmap");
    }

    if (curImage)
        curImage->Release();

    curImage = image;
    RefreshImageDisplay();
}


//
// Resize the window so it fits the image
//

#define MINWINWIDTH     200
#define MINWINHEIGHT    100
#define MAXWINWIDTH     1024
#define MAXWINHEIGHT    768

VOID
DoSizeWindowToFit(
    HWND hwnd,
    BOOL strict = FALSE
    )
{
    HRESULT hr;
    IBitmapImage* bmp;
    SIZE size;

    // Check if the current image is a bitmap image
    //  in that case, we'll get the pixel dimension

    hr = curImage->QueryInterface(IID_IBitmapImage, (VOID**) &bmp);

    if (SUCCEEDED(hr))
    {
        hr = bmp->GetSize(&size);
        bmp->Release();
    }

    // Otherwise, try to get device-independent image dimension

    if (FAILED(hr))
    {
        hr = curImage->GetPhysicalDimension(&size);
        if (FAILED(hr))
            return;

        size.cx = (INT) (size.cx * 96.0 / 2540.0 + 0.5);
        size.cy = (INT) (size.cy * 96.0 / 2540.0 + 0.5);
    }

    if (SUCCEEDED(hr))
    {
        // Figure out window border dimensions

        RECT r1, r2;
        INT w, h;

        w = size.cx;
        h = size.cy;

        if (!strict)
        {
            if (w < MINWINWIDTH)
                w = MINWINWIDTH;
            else if (w > MAXWINWIDTH)
                w = MAXWINWIDTH;

            if (h < MINWINHEIGHT)
                h = MINWINHEIGHT;
            else if (h > MAXWINHEIGHT)
                h = MAXWINHEIGHT;
        }

        GetWindowRect(hwnd, &r1);
        GetClientRect(hwnd, &r2);

        w += (r1.right - r1.left) - (r2.right - r2.left);
        h += (r1.bottom - r1.top) - (r2.bottom - r2.top);

        // Resize the window

        do
        {
            SetWindowPos(
                hwnd,
                NULL,
                0, 0, 
                w, h,
                SWP_NOMOVE | SWP_NOZORDER);

            GetClientRect(hwnd, &r2);
            h += GetSystemMetrics(SM_CYMENU);
        }
        while (r2.bottom == 0);
    }
}


//
// Convert current image to a bitmap image
//

IBitmapImage*
ConvertImageToBitmap(
    IImage* image,
    INT width = 0,
    INT height = 0,
    PixelFormatID pixfmt = PIXFMT_DONTCARE,
    InterpolationHint hint = INTERP_DEFAULT
    )
{
    if (!image)
        return NULL;

    HRESULT hr;
    IBitmapImage* bmp;

    hr = image->QueryInterface(IID_IBitmapImage, (VOID**) &bmp);

    if (SUCCEEDED(hr))
    {
        SIZE size;
        PixelFormatID fmt;

        // Current image is already a bitmap image and
        //  its dimension and pixel format are already as expected

        hr = bmp->GetSize(&size);
        if (!CHECKHR(hr))
            return NULL;

        hr = bmp->GetPixelFormatID(&fmt);
        if (!CHECKHR(hr))
            return NULL;

        if ((width == 0 || size.cx == width) &&
            (height == 0 || size.cy == height) &&
            (pixfmt == PIXFMT_DONTCARE || pixfmt == fmt))
        {
            return bmp;
        }

        bmp->Release();
    }

    // Convert the current image to a bitmap image

    if (width == 0 && height == 0)
    {
        ImageInfo imageInfo;
        hr = image->GetImageInfo(&imageInfo);

        // If the source image is scalable, then compute
        // the appropriate pixel dimension for the bitmap

        if (SUCCEEDED(hr) && (imageInfo.Flags & IMGFLAG_SCALABLE))
        {
            width = (INT) (96.0 * imageInfo.Width / imageInfo.Xdpi + 0.5);
            height = (INT) (96.0 * imageInfo.Height / imageInfo.Ydpi + 0.5);
        }
    }

    hr = imgfact->CreateBitmapFromImage(
                        image,
                        width, 
                        height, 
                        pixfmt,
                        hint,
                        &bmp);

    return SUCCEEDED(hr) ? bmp : NULL;
}


//
// Create an image object from a file
//

VOID
OpenImageFile(
    const CHAR* filename
    )
{
    HRESULT hr;
    IImage* image;
    IStream* stream;
    static BOOL useUrlMon = FALSE;

    if (useUrlMon)
    {
        // Use URLMON.DLL to turn file into stream

        CHAR fullpath[MAX_PATH];
        CHAR* p;

        if (!GetFullPathName(filename, MAX_PATH, fullpath, &p))
            return;

        hr = URLOpenBlockingStreamA(NULL, fullpath, &stream, 0, NULL);

        if (!CHECKHR(hr))
            return;

        hr = imgfact->CreateImageFromStream(stream, &image);
        stream->Release();
    }
    else
    {
        // Use filename directly 

        UnicodeStrFromAnsi namestr(filename);

        if (namestr.IsValid())
            hr = imgfact->CreateImageFromFile(namestr, &image);
        else
            hr = E_FAIL;
    }

    // Set the new image as the current image

    if (CHECKHR(hr))
    {
        SetCurrentImage(image, filename);
        DoSizeWindowToFit(hwndMain);
    }
}


//
// Save the current image to a file
//

VOID
SaveImageFile(
    const CHAR* filename,
    const CLSID* clsid
    )
{
    if (!curImage)
        return;

    // Create an encoder object

    HRESULT hr;
    IImageEncoder* encoder;
    UnicodeStrFromAnsi namestr(filename);

    if (namestr.IsValid())
        hr = imgfact->CreateImageEncoderToFile(clsid, namestr, &encoder);
    else
        hr = E_FAIL;

    if (!CHECKHR(hr))
        return;

    // Get an IImageSink interface to the encoder

    IImageSink* sink;

    hr = encoder->GetEncodeSink(&sink);

#if defined(ROTATION_TEST)
    // Rotation test

    EncoderParams*  pMyEncoderParams;

    pMyEncoderParams = (EncoderParams*)malloc
                       ( sizeof(EncoderParams)
                       + sizeof(EncoderParam));

    pMyEncoderParams->Params[0].paramGuid = ENCODER_ROTATION;
    pMyEncoderParams->Params[0].Value = "90";
    pMyEncoderParams->Count = 1;
    hr = encoder->SetEncoderParam(pMyEncoderParams);
    free(pMyEncoderParams);
#endif

    if (CHECKHR(hr))
    {
        hr = curImage->PushIntoSink(sink);
        CHECKHR(hr);

        sink->Release();
    }

    encoder->TerminateEncoder();
    encoder->Release();
}


//
// Handle window repaint event
//

VOID
DoPaint(
    HWND hwnd
    )
{
    HDC hdc;
    PAINTSTRUCT ps;
    RECT rect;
    DWORD timer;
    HRESULT hr = E_FAIL;

    hdc = BeginPaint(hwnd, &ps);

    GetClientRect(hwnd, &rect);

    if (scaleMethod == IDM_SCALE_GDIHT)
        SetStretchBltMode(hdc, HALFTONE);
    else
        SetStretchBltMode(hdc, COLORONCOLOR);

    VERBOSE(("Scale method: %d, ", scaleMethod));
    timer = GetTickCount();

    if (scaleMethod == IDM_SCALE_GDI || 
        scaleMethod == IDM_SCALE_GDIHT)
    {
        hr = curImage->Draw(hdc, &rect, NULL);

        VERBOSE(("GDI time: %dms\n", GetTickCount() - timer));
    }
    else
    {
        IBitmapImage* bmp;

        bmp = ConvertImageToBitmap(
                    curImage,
                    rect.right,
                    rect.bottom,
                    PIXFMT_DONTCARE,
                    GetScaleMethodInterp());

        if (!bmp)
            goto endPaint;

        VERBOSE(("Stretch time: %dms, ", GetTickCount() - timer));

        IImage* image;

        hr = bmp->QueryInterface(IID_IImage, (VOID**) &image);
        bmp->Release();

        if (FAILED(hr))
            goto endPaint;
        
        timer = GetTickCount();
        hr = image->Draw(hdc, &rect, NULL);
        VERBOSE(("GDI time: %dms\n", GetTickCount() - timer));

        image->Release();
    }

endPaint:

    if (FAILED(hr))
        FillRect(hdc, &rect, (HBRUSH) GetStockObject(BLACK_BRUSH));

    EndPaint(hwnd, &ps);
}


//
// Convert the current image to a bitmap
//

VOID
DoConvertToBitmap(
    HWND hwnd,
    INT menuCmd
    )
{
    // Map menu selection to its corresponding pixel format

    PixelFormatID pixfmt;

    switch (menuCmd)
    {
    case IDM_CONVERT_RGB555:
        pixfmt = PIXFMT_16BPP_RGB555;
        break;
        
    case IDM_CONVERT_RGB565:
        pixfmt = PIXFMT_16BPP_RGB565;
        break;
        
    case IDM_CONVERT_RGB24:
        pixfmt = PIXFMT_24BPP_RGB;
        break;
        
    case IDM_CONVERT_RGB32:
        pixfmt = PIXFMT_32BPP_RGB;
        break;
        
    case IDM_CONVERT_ARGB:
    default:
        pixfmt = PIXFMT_32BPP_ARGB;
        break;
    }

    // Convert the current image to a bitmap image

    IBitmapImage* bmp = ConvertImageToBitmap(curImage, 0, 0, pixfmt);

    // Set the bitmap image as the current image

    if (bmp)
        SetCurrentImage(bmp);
}


//
// Compose a file type filter string given an array of
// ImageCodecInfo structures
//

#define SizeofWSTR(s) (sizeof(WCHAR) * (wcslen(s) + 1))
#define SizeofSTR(s) (strlen(s) + 1)

CHAR*
MakeFilterFromCodecs(
    UINT count,
    const ImageCodecInfo* codecs,
    BOOL open
    )
{
    static const CHAR allFiles[] = "All Files\0*.*\0";

    // Figure out the total size of the filter string

    UINT index, size;

    for (index=size=0; index < count; index++)
    {
        size += SizeofWSTR(codecs[index].FormatDescription) +
                SizeofWSTR(codecs[index].FilenameExtension);
    }

    if (open)
        size += sizeof(allFiles);
    
    size += sizeof(CHAR);

    // Allocate memory

    CHAR *filter = (CHAR*) malloc(size);
    CHAR* p = filter;
    const WCHAR* ws;

    if (!filter)
        return NULL;

    for (index=0; index < count; index++)
    {
        ws = codecs[index].FormatDescription;
        size = SizeofWSTR(ws);

        if (UnicodeToAnsiStr(ws, p, size))
            p += SizeofSTR(p);
        else
            break;

        ws = codecs[index].FilenameExtension;
        size = SizeofWSTR(ws);

        if (UnicodeToAnsiStr(ws, p, size))
            p += SizeofSTR(p);
        else
            break;
    }

    if (index < count)
    {
        free(filter);
        return NULL;
    }

    if (open)
    {
        size = sizeof(allFiles);
        memcpy(p, allFiles, size);
        p += size;
    }

    *((CHAR*) p) = '\0';
    return filter;
}


//
// Open image file
//

VOID
DoOpen(
    HWND hwnd
    )
{
    OPENFILENAME ofn;
    CHAR filename[MAX_PATH];

    ZeroMemory(&ofn, sizeof(ofn));

    ofn.lStructSize = sizeof(ofn);
    ofn.hwndOwner = hwnd;
    ofn.hInstance = appInstance;
    ofn.lpstrFile = filename;
    ofn.nMaxFile = MAX_PATH;
    ofn.lpstrTitle = "Open Image File";
    ofn.lpstrInitialDir = ".";
    ofn.Flags = OFN_FILEMUSTEXIST;
    filename[0] = '\0';

    // Make up the file type filter string

    HRESULT hr;
    ImageCodecInfo* codecs;
    UINT count;

    hr = imgfact->GetInstalledDecoders(&count, &codecs);

    if (!CHECKHR(hr))
        return;

    CHAR* filter = MakeFilterFromCodecs(count, codecs, TRUE);

    if (codecs)
        CoTaskMemFree(codecs);

    if (!filter)
    {
        CHECKHR(LASTWIN32HRESULT);
        return;
    }

    ofn.lpstrFilter = filter;
    
    // Present the file/open dialog

    if (GetOpenFileName(&ofn))
        OpenImageFile(filename);

    free(filter);
}


//
// Save image file
//

VOID
DoSave(
    HWND hwnd
    )
{
    OPENFILENAME ofn;
    CHAR filename[MAX_PATH];

    ZeroMemory(&ofn, sizeof(ofn));

    ofn.lStructSize = sizeof(ofn);
    ofn.hwndOwner = hwnd;
    ofn.hInstance = appInstance;
    ofn.lpstrFile = filename;
    ofn.nMaxFile = MAX_PATH;
    ofn.lpstrTitle = "Save Image File";
    ofn.lpstrInitialDir = ".";
    ofn.Flags = OFN_CREATEPROMPT | OFN_OVERWRITEPROMPT;
    filename[0] = '\0';

    // Make up the file type filter string

    HRESULT hr;
    ImageCodecInfo* codecs;
    UINT count;

    hr = imgfact->GetInstalledEncoders(&count, &codecs);

    if (!CHECKHR(hr))
        return;

    CHAR* filter = MakeFilterFromCodecs(count, codecs, FALSE);

    if (!filter)
    {
        CHECKHR(LASTWIN32HRESULT);
    }
    else
    {
        ofn.lpstrFilter = filter;

        // Present the file/save dialog

        if (GetSaveFileName(&ofn))
        {
            UINT index = ofn.nFilterIndex;

            if (index == 0 || index > count)
                index = 0;
            else
                index--;

            SaveImageFile(filename, &codecs[index].Clsid);
        }   

        free(filter);
    } 

    CoTaskMemFree(codecs);
}


//
// Crop the image
//
// NOTE: We're not spending time here to do a fancy UI.
//  So we'll just inset the image by 5 pixels each time.
//

VOID
DoCrop(
    HWND hwnd
    )
{
    IBitmapImage* bmp;

    if (bmp = ConvertImageToBitmap(curImage))
    {
        HRESULT hr;
        IBasicBitmapOps* bmpops = NULL;
        SIZE size;

        hr = bmp->QueryInterface(IID_IBasicBitmapOps, (VOID**) &bmpops);

        if (CHECKHR(hr))
            hr = bmp->GetSize(&size);

        if (CHECKHR(hr))
        {
            RECT r = { 5, 5, size.cx - 5, size.cy - 5 };
            IBitmapImage* newbmp;

            hr = bmpops->Clone(&r, &newbmp, TRUE);

            if (CHECKHR(hr))
                SetCurrentImage(newbmp);
        }

        if (bmp) bmp->Release();
        if (bmpops) bmpops->Release();
    }
}


//
// Resize the image to the current window size, using bilinear scaling
//

VOID
DoResize(
    HWND hwnd
    )
{
    RECT rect;
    HRESULT hr;
    IBitmapImage* bmp;

    GetClientRect(hwnd, &rect);

    bmp = ConvertImageToBitmap(
                curImage,
                rect.right,
                rect.bottom,
                PIXFMT_DONTCARE,
                INTERP_BILINEAR);

    if (bmp)
        SetCurrentImage(bmp);
}


//
// Flip or rotate the image
//

VOID
DoFlipRotate(
    HWND hwnd,
    INT menuCmd
    )
{
    IBitmapImage* bmp;
    IBitmapImage* newbmp;
    IBasicBitmapOps* bmpops;
    HRESULT hr;

    bmp = ConvertImageToBitmap(curImage);

    if (!bmp)
        return;

    hr = bmp->QueryInterface(IID_IBasicBitmapOps, (VOID**) &bmpops);

    if (CHECKHR(hr))
    {
        switch (menuCmd)
        {
        case IDM_BMP_FLIPX:
            hr = bmpops->Flip(TRUE, FALSE, &newbmp);
            break;
        case IDM_BMP_FLIPY:
            hr = bmpops->Flip(FALSE, TRUE, &newbmp);
            break;
        case IDM_BMP_ROTATE90:
            hr = bmpops->Rotate(90, INTERP_DEFAULT, &newbmp);
            break;
        case IDM_BMP_ROTATE270:
            hr = bmpops->Rotate(270, INTERP_DEFAULT, &newbmp);
            break;
        }

        bmpops->Release();

        if (CHECKHR(hr))
        {
            SetCurrentImage(newbmp);

            if (menuCmd == IDM_BMP_ROTATE90 ||
                menuCmd == IDM_BMP_ROTATE270)
            {
                DoSizeWindowToFit(hwnd);
            }
        }
    }

    bmp->Release();
}


//
// Perform point operation on the image
//

VOID
DoPointOps(
    HWND hwnd,
    INT menuCmd
    )
{
    IBitmapImage* bmp;
    IBitmapImage* newbmp;
    IBasicBitmapOps* bmpops;
    HRESULT hr;

    bmp = ConvertImageToBitmap(curImage);

    if (!bmp)
        return;

    hr = bmp->QueryInterface(IID_IBasicBitmapOps, (VOID**) &bmpops);

    if (CHECKHR(hr))
    {
        switch (menuCmd)
        {
        case IDM_BRIGHTEN:
            hr = bmpops->AdjustBrightness(0.1f);
            break;
        case IDM_DARKEN:
            hr = bmpops->AdjustBrightness(-0.1f);
            break;
        case IDM_INCCONTRAST:
            hr = bmpops->AdjustContrast(-0.1f, 1.1f);
            break;
        case IDM_DECCONTRAST:
            hr = bmpops->AdjustContrast(0.1f, 0.9f);
            break;
        case IDM_INCGAMMA:
            hr = bmpops->AdjustGamma(1.1f);
            break;
        case IDM_DECGAMMA:
            hr = bmpops->AdjustGamma(0.9f);
            break;
        }

        bmpops->Release();

        if (CHECKHR(hr))
            SetCurrentImage(bmp);
    }

    if (FAILED(hr))
        bmp->Release();
}

VOID
DisplayProperties(
        IPropertySetStorage *propSetStg
        )
{
    HRESULT hresult;
    IPropertyStorage *propStg;
    IEnumSTATPROPSTG *enumPS;

    hresult = propSetStg->Open(FMTID_ImageInformation, STGM_READ | STGM_SHARE_EXCLUSIVE, &propStg);
    if (FAILED(hresult)) 
    {
        //printf("DisplayProperties:  failed to open propSetStg\n");
        return;
    }

    hresult = propStg->Enum(&enumPS);
    if (FAILED(hresult)) 
    {
        printf("DisplayProperties:  failed to create enumerator\n");
        return;
    }

    hresult = enumPS->Reset();
    if (FAILED(hresult)) 
    {
        printf("DisplayProperties:  failed to reset enumerator\n");
        return;
    }

    STATPROPSTG sps;
    while ((enumPS->Next(1, &sps, NULL)) == S_OK) 
    {
        if (sps.lpwstrName) 
        {
            wprintf(sps.lpwstrName);
            CoTaskMemFree(sps.lpwstrName);

            PROPSPEC propSpec[1];
            PROPVARIANT propVariant[1];
            
            propSpec[0].ulKind = PRSPEC_PROPID;
            propSpec[0].propid = sps.propid;

            hresult = propStg->ReadMultiple(1, propSpec, propVariant);
            if (FAILED(hresult)) 
            {
                printf("DisplayProperties:  failed in ReadMultiple\n");
            }

            switch(propVariant[0].vt) 
            {
            case VT_BSTR:
                wprintf(L" : %s\n", propVariant[0].bstrVal);
                break;

            case VT_I4:
                wprintf(L" : %d\n", propVariant[0].lVal);
                break;

            case VT_R8:
                wprintf(L" : %f\n", (FLOAT) propVariant[0].dblVal);
                break;

            default:
                wprintf(L"Unknown VT type\n");
                break;
            }

            PropVariantClear(&propVariant[0]);
        }
    }

    enumPS->Release();
    propStg->Release();
}

//
// Handle menu commands
//

VOID
DoMenuCommand(
    HWND hwnd,
    INT menuCmd
    )
{
    switch (menuCmd)
    {
    case IDM_OPEN:
        DoOpen(hwnd);
        break;

    case IDM_SAVE:
        DoSave(hwnd);
        break;

    case IDM_QUIT:
        PostQuitMessage(0);
        break;

    case IDM_FIT_WINDOW:
        DoSizeWindowToFit(hwnd, TRUE);
        break;

    case IDM_CONVERT_RGB555:
    case IDM_CONVERT_RGB565:
    case IDM_CONVERT_RGB24:
    case IDM_CONVERT_RGB32:
    case IDM_CONVERT_ARGB:
        DoConvertToBitmap(hwnd, menuCmd);
        break;

    case IDM_SCALE_GDI:
    case IDM_SCALE_GDIHT:
    case IDM_SCALE_NEIGHBOR:
    case IDM_SCALE_BILINEAR:
    case IDM_SCALE_AVERAGING:
    case IDM_SCALE_BICUBIC:
        scaleMethod = menuCmd;
        RefreshImageDisplay();
        break;

    case IDM_BMP_CROP:
        DoCrop(hwnd);
        break;

    case IDM_BMP_RESIZE:
        DoResize(hwnd);
        break;

    case IDM_BMP_FLIPX:
    case IDM_BMP_FLIPY:
    case IDM_BMP_ROTATE90:
    case IDM_BMP_ROTATE270:
        DoFlipRotate(hwnd, menuCmd);
        break;
    
    case IDM_BRIGHTEN:
    case IDM_DARKEN:
    case IDM_INCCONTRAST:
    case IDM_DECCONTRAST:
    case IDM_INCGAMMA:
    case IDM_DECGAMMA:
        DoPointOps(hwnd, menuCmd);
        break;    
    }
}


//
// Window callback procedure
//

LRESULT CALLBACK
MyWindowProc(
    HWND    hwnd,
    UINT    uMsg,
    WPARAM  wParam,
    LPARAM  lParam
    )
{
    switch (uMsg)
    {
    case WM_COMMAND:
        DoMenuCommand(hwnd, LOWORD(wParam));
        break;

    case WM_PAINT:
        DoPaint(hwnd);
        break;

    case WM_DESTROY:
        PostQuitMessage(0);
        break;

    default:
        return DefWindowProc(hwnd, uMsg, wParam, lParam);
    }

    return 0;
}


//
// Create main application window
//

#define MYWNDCLASSNAME "ImgTest"

VOID
CreateMainWindow(
    VOID
    )
{
    HBRUSH hBrush = CreateSolidBrush(RGB(255, 250, 250));
    //
    // Register window class
    //

    WNDCLASS wndClass =
    {
        CS_HREDRAW|CS_VREDRAW,
        MyWindowProc,
        0,
        0,
        appInstance,
        LoadIcon(NULL, IDI_APPLICATION),
        LoadCursor(NULL, IDC_ARROW),
        hBrush,
        MAKEINTRESOURCE(IDR_MAINMENU),
        MYWNDCLASSNAME
    };

    RegisterClass(&wndClass);

    hwndMain = CreateWindow(
                    MYWNDCLASSNAME,
                    MYWNDCLASSNAME,
                    WS_OVERLAPPEDWINDOW,
                    CW_USEDEFAULT,
                    CW_USEDEFAULT,
                    CW_USEDEFAULT,
                    CW_USEDEFAULT,
                    NULL,
                    NULL,
                    appInstance,
                    NULL);

    if (!hwndMain)
    {
        CHECKHR(HRESULT_FROM_WIN32(GetLastError()));
        exit(-1);
    }
}


//
// Create a new test bitmap object from scratch
//

#define STEPS 16

VOID
CreateNewTestBitmap()
{
    IBitmapImage* bmp;
    BitmapData bmpdata;
    HRESULT hr;

    hr = imgfact->CreateNewBitmap(
                STEPS,
                STEPS,
                PIXFMT_32BPP_ARGB,
                &bmp);

    if (!CHECKHR(hr))
        return;

    hr = bmp->LockBits(
                NULL,
                IMGLOCK_WRITE,
                PIXFMT_DONTCARE,
                &bmpdata);

    if (!CHECKHR(hr))
    {
        bmp->Release();
        return;
    }

    // Make a horizontal blue gradient

    UINT x, y;
    ARGB colors[STEPS];

    for (x=0; x < STEPS; x++)
        colors[x] = MAKEARGB(255, 0, 0, x * 255 / (STEPS-1));

    for (y=0; y < STEPS; y++)
    {
        ARGB* p = (ARGB*) ((BYTE*) bmpdata.Scan0 + y*bmpdata.Stride);

        for (x=0; x < STEPS; x++)
            *p++ = colors[(x+y) % STEPS];
    }

    bmp->UnlockBits(&bmpdata);
    SetCurrentImage(bmp);
}


//
// Main program entrypoint
//

INT _cdecl
main(
    INT argc,
    CHAR **argv
    )
{
    programName = *argv++;
    argc--;
    appInstance = GetModuleHandle(NULL);
    CoInitialize(NULL);

    //
    // Create an IImagingFactory object
    //
     
    HRESULT hr;

    hr = CoCreateInstance(
            CLSID_ImagingFactory,
            NULL,
            CLSCTX_INPROC_SERVER,
            IID_IImagingFactory,
            (VOID**) &imgfact);

    if (!CHECKHR(hr))
        exit(-1);

    //
    // Create the main application window
    //

    CreateMainWindow();

    //
    // Create a test image
    //

    if (argc != 0)
        OpenImageFile(*argv);
    
    if (!curImage)
        CreateNewTestBitmap();

    if (!curImage)
        exit(-1);

    DoSizeWindowToFit(hwndMain);
    ShowWindow(hwndMain, SW_SHOW);

    //
    // Main message loop
    //

    MSG msg;
    HACCEL accel;

    accel = LoadAccelerators(appInstance, MAKEINTRESOURCE(IDR_ACCELTABLE));

    while (GetMessage(&msg, NULL, 0, 0))
    {
        if (!TranslateAccelerator(msg.hwnd, accel, &msg))
        {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }

    curImage->Release();
    imgfact->Release();

    CoUninitialize();
    return (INT)(msg.wParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\libtest\wndstuff.h ===
/****************************** Module Header ******************************\
* Module Name: wndstuff.h
*
* Kent's Window Test.  To be used as a program template.
*
* Created: 09-May-91
* Author: KentD
*
* Copyright (c) 1991 Microsoft Corporation
\***************************************************************************/

#define DONTUSE(x) (x)

#define MM_NEW          0x8001
#define MM_EXIT         0x8002
#define MM_TEST         0x8003

VOID Test(HWND);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\multithread\precomp.hpp ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <commdlg.h>
#include <string.h>
#include <math.h>
#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>
#include <wchar.h>
#include <commctrl.h>
#include <winspool.h>
#include <wingdi.h>
#include <malloc.h>
#include <limits.h>
#include <ntverp.h>

#include <objbase.h>
#include <gdiplus/gdiplus.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\libtest\wndstuff.cpp ===
/******************************Module*Header*******************************\
* Module Name: wndstuff.cpp
*
* This file contains the code to support a simple window that has
* a menu with a single item called "Test". When "Test" is selected
* vTest(HWND) is called.
*
* Created: 09-Dec-1992 10:44:31
* Author: Kirk Olynyk [kirko]
*
* Copyright (c) 1991 Microsoft Corporation
*
\**************************************************************************/

// for Win95 compile
#undef UNICODE
#undef _UNICODE

#include <windows.h>
#include <stdio.h>
#include <objbase.h>
#include <tchar.h>

//
// Where is IStream included from?
//

#define IStream int

#include <gdiplus.h>
using namespace Gdiplus;

#include "wndstuff.h"

HINSTANCE ghInstance;
HWND ghwndMain;
HWND ghwndDebug;
HWND ghwndList;
HBRUSH ghbrWhite;

VOID WINAPI
AltDebugEvent(
    DebugEventLevel level, 
    CHAR *message)
{
    OutputDebugStringA("AltDebugEvent: ");
    OutputDebugStringA(message);
    if (level == DebugEventLevelFatal)
    {
        DebugBreak();
    }
}

GdiplusStartupOutput gGpSto;

// Because we have global initializers which call GDI+, GDI+ needs to be
// initialized before, and destroyed after, those constructors and destructors.
// Here goes:

#pragma warning( push )
#pragma warning( disable : 4073 )

#pragma code_seg( "MySeg" )
#pragma init_seg( lib )

class GdiplusInitHelper
{
public:
    GdiplusInitHelper() : gpToken(0), Valid(FALSE)
    {
        // Use the non-defaults, to test the alternative code-path.

        GdiplusStartupInput sti(AltDebugEvent, TRUE, TRUE);
    
        if (GdiplusStartup(&gpToken, &sti, &gGpSto) == Ok)
        {
            Valid = TRUE;
        }
        else
        {
            MessageBox(0, _T("Engine didn't initialize"), _T("Uh oh"), MB_OK);
        }        
    }
    ~GdiplusInitHelper()
    {
        if (Valid)
        {
            GdiplusShutdown(gpToken);
        }
    }
    BOOL IsValid() { return Valid; }
    
private:    
    ULONG_PTR gpToken;
    BOOL Valid;
};

GdiplusInitHelper gGdiplusInitHelper;

#pragma code_seg()
#pragma warning( pop )

/***************************************************************************\
* lMainWindowProc(hwnd, message, wParam, lParam)
*
* Processes all messages for the main window.
*
* History:
*  04-07-91 -by- KentD
* Wrote it.
\***************************************************************************/

LONG_PTR
lMainWindowProc(
    HWND    hwnd,
    UINT    message,
    WPARAM  wParam,
    LPARAM  lParam
    )
{
    PAINTSTRUCT ps;

    switch (message)
    {

    case WM_COMMAND:
        switch(LOWORD(wParam))
        {
        case MM_TEST:
            Test(hwnd);
            break;

        default:
            break;
        }
        break;

    case WM_DESTROY:
        DeleteObject(ghbrWhite);
        PostQuitMessage(0);
        return(DefWindowProc(hwnd, message, wParam, lParam));

    default:
        return(DefWindowProc(hwnd, message, wParam, lParam));
    }

    return(0);
}

/******************************Public*Routine******************************\
* DebugWndProc
*
* List box is maintained here.
*
\**************************************************************************/

LONG_PTR FAR PASCAL DebugWndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    RECT    rcl;
    HDC     hdc;
    LONG_PTR    lRet = 0;

// Process window message.

    switch (message)
    {
    case WM_SIZE:
        lRet = DefWindowProc(ghwndList, message, wParam, lParam);
        GetClientRect(ghwndMain, &rcl);
        MoveWindow(
            ghwndList,
            rcl.left, rcl.top,
            (rcl.right - rcl.left), (rcl.bottom - rcl.top),
            TRUE
            );
        UpdateWindow(ghwndList);
        break;

    case WM_DESTROY:
        PostQuitMessage(0);
        break;

    default:
        lRet = DefWindowProc(hwnd, message, wParam, lParam);
        break;
    }

    return lRet;
}

/******************************Public*Routine******************************\
* LBprintf
*
* ListBox printf implementation.
*
* History:
*  15-Dec-1994 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

void LBprintf(PCH msg, ...)
{
    if (ghwndList)
    {
        va_list ap;
        char buffer[256];

        va_start(ap, msg);

        vsprintf(buffer, msg, ap);

        SendMessage(ghwndList, LB_ADDSTRING, (WPARAM) 0, (LPARAM) buffer);
        SendMessage(ghwndList, WM_SETREDRAW, (WPARAM) TRUE, (LPARAM) 0);
        InvalidateRect(ghwndList, NULL, TRUE);
        UpdateWindow(ghwndList);

        va_end(ap);
    }
}

/******************************Public*Routine******************************\
* LBreset
*
* Reset ListBox state (clear).
*
* History:
*  15-Dec-1994 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

void LBreset()
{
    if (ghwndList)
        SendMessage(ghwndList, LB_RESETCONTENT, (WPARAM) FALSE, (LPARAM) 0);
}

/***************************************************************************\
* bInitApp()
*
* Initializes app.
*
* History:
*  04-07-91 -by- KentD
* Wrote it.
\***************************************************************************/

BOOL bInitApp(BOOL debug)
{
    WNDCLASS wc;

    ghbrWhite = CreateSolidBrush(RGB(0xFF,0xFF,0xFF));

    wc.style            = 0;
    wc.lpfnWndProc      = lMainWindowProc;
    wc.cbClsExtra       = 0;
    wc.cbWndExtra       = 0;
    wc.hInstance        = ghInstance;
    wc.hIcon            = LoadIcon(NULL, IDI_APPLICATION);
    wc.hCursor          = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground    = ghbrWhite;
    wc.lpszMenuName     = _T("MainMenu");
    wc.lpszClassName    = _T("TestClass");
    if (!RegisterClass(&wc))
    {
        return(FALSE);
    }
    ghwndMain =
      CreateWindowEx(
        0,
        _T("TestClass"),
        _T("Win32 Test"),
        WS_OVERLAPPED   |  
        WS_CAPTION      |  
        WS_BORDER       |  
        WS_THICKFRAME   |  
        WS_MAXIMIZEBOX  |  
        WS_MINIMIZEBOX  |  
        WS_CLIPCHILDREN |  
        WS_VISIBLE      |  
        WS_SYSMENU,
        80,
        70,
        500,
        500,
        NULL,
        NULL,
        ghInstance,
        NULL);

    if (ghwndMain == NULL)
    {
        return(FALSE);
    }

    if (debug)
    {
        RECT rcl;

        memset(&wc, 0, sizeof(wc));
        wc.style = 0;
        wc.lpfnWndProc = DebugWndProc;
        wc.cbClsExtra = 0;
        wc.cbWndExtra = 0;
        wc.hInstance = ghInstance;
        wc.hIcon = LoadIcon(NULL, IDI_APPLICATION);
        wc.hCursor = LoadCursor(NULL, IDC_ARROW);
        wc.hbrBackground = ghbrWhite;
        wc.lpszClassName = "DebugWClass";
        RegisterClass(&wc);

        ghwndDebug = CreateWindow(
            "DebugWClass",
            "Debug output",
            WS_OVERLAPPEDWINDOW|WS_MAXIMIZE,
            600,
            70,
            300,
            500,
            NULL,
            NULL,
            ghInstance,
            NULL
            );

        if (ghwndDebug)
        {
            ShowWindow(ghwndDebug, SW_NORMAL);
            UpdateWindow(ghwndDebug);

        // Create the list box to fill the main window.

            GetClientRect(ghwndDebug, &rcl);

            ghwndList = CreateWindow(
                "LISTBOX",
                "Debug output",
                WS_CHILD | WS_VISIBLE | WS_VSCROLL
                | WS_HSCROLL | LBS_NOINTEGRALHEIGHT,
                rcl.left, rcl.top,
                (rcl.right - rcl.left), (rcl.bottom - rcl.top),
                ghwndDebug,
                NULL,
                ghInstance,
                NULL
                );

            if (ghwndList)
            {
                SendMessage(
                    ghwndList,
                    WM_SETFONT,
                    (WPARAM) GetStockObject(ANSI_FIXED_FONT),
                    (LPARAM) FALSE
                    );

                LBreset();

                ShowWindow(ghwndList, SW_NORMAL);
                UpdateWindow(ghwndList);
            }
        }

    }

    SetFocus(ghwndMain);

    return(TRUE);
}

/***************************************************************************\
* main(argc, argv[])
*
* Sets up the message loop.
*
* History:
*  04-07-91 -by- KentD
* Wrote it.
\***************************************************************************/

_cdecl
main(
    INT   argc,
    PCHAR argv[])
{
    MSG    msg;
    HACCEL haccel;
    CHAR*  pSrc;
    CHAR*  pDst;

    BOOL wantDebugWindow = FALSE;

    if (!gGdiplusInitHelper.IsValid())
    {
        return 0;
    }

    CoInitialize(NULL);

    // Parse arguments

    for (argc--, argv++ ; argc && '-' == **argv ; argc--, argv++ )
    {
        switch ( *(++(*argv)) )
        {
        case 'd':
        case 'D':
            wantDebugWindow = TRUE;
            break;
        }
    }

    ghInstance = GetModuleHandle(NULL);

    if (!bInitApp(wantDebugWindow))
    {
        return(0);
    }

    haccel = LoadAccelerators(ghInstance, MAKEINTRESOURCE(1));
    
    ULONG_PTR notifyToken;
    
    gGpSto.NotificationHook(&notifyToken);
    
    while (GetMessage(&msg, NULL, 0, 0))
    {
        if (!TranslateAccelerator(msg.hwnd, haccel, &msg))
        {
             TranslateMessage(&msg);
             DispatchMessage(&msg);
        }
    }

    gGpSto.NotificationUnhook(notifyToken);

    CoUninitialize();

    return(1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\libtest\libtest.cpp ===
/******************************Module*Header*******************************\
* Module Name: test.c
*
* Created: 09-Dec-1992 10:51:46
* Author: Kirk Olynyk [kirko]
*
* Copyright (c) 1991 Microsoft Corporation
*
* Contains the test
*
\**************************************************************************/

#include <windows.h>
#include <objbase.h>
#include <math.h>             // sin & cos
#include "debug.h"

#define USE_NEW_APIS 1
#define USE_NEW_APIS2 1

//
// Where is IStream included from?
//

#define IStream int

#include <gdiplus.h>

using namespace Gdiplus;

/******************************Public*Routine******************************\
* vTest
*
* This is the workhorse routine that does the test. The test is
* started by chosing it from the window menu.
*
* History:
*  Tue 08-Dec-1992 17:31:22 by Kirk Olynyk [kirko]
* Wrote it.
\**************************************************************************/

class RectI
{
public:
    INT X;
    INT Y; 
    INT Width;
    INT Height;
};

VOID TestContainerClip(Graphics *g);
VOID TestContainer(Graphics *g);
VOID TestPolygons(Graphics *g);
VOID TestPaths(Graphics *g);
VOID TestDashes(Graphics *g);
VOID TestRegions(Graphics *g);
VOID TestGradients(Graphics* g);
VOID TestHatches(Graphics* g);
VOID TestBitmaps(Graphics* g);
VOID TestPrimitives(Graphics *g);
VOID TestMixedObjects(Graphics *g);
VOID TestTexts(Graphics* g);
VOID TestTextAlongPath(Graphics *g);
VOID TestDerive(HWND hwnd);
VOID TestImaging(Graphics* g);
VOID TestBitmapGraphics(Graphics* g);
VOID TestCompoundLines(Graphics *g);

VOID
Test(
    HWND hwnd
    )
{
    Graphics *g = Graphics::FromHWND(hwnd);
    g->SetSmoothingMode(SmoothingModeAntiAlias);

    // Scale everything up by scale
    REAL scale = (REAL) 1.2;
    g->SetPageUnit(UnitDisplay);
    g->SetPageScale(scale);
    g->RotateTransform(10);

    {
        HDC     hdc = GetDC(hwnd);
        {
            Metafile    recording(L"TestEmfP.Emf", hdc);
            Graphics    gMeta(&recording);
    
            gMeta.SetSmoothingMode(SmoothingModeAntiAlias);
            TestContainer(&gMeta);
        }
    
        GpRectF playbackRect;
        g->GetVisibleClipBounds(&playbackRect);

        {
            Metafile    playback(L"TestEmfP.Emf");
            g->DrawImage(&playback, playbackRect);
        }

        ReleaseDC(hwnd, hdc);
    }
    
    TestContainerClip(g);
    TestPolygons(g);
    TestPaths(g);
    TestRegions(g);
    TestBitmaps(g);
    TestPrimitives(g);
    TestMixedObjects(g);
    TestGradients(g);
    TestHatches(g);
    TestTexts(g);
    TestDerive(hwnd);
    TestImaging(g);
    TestDashes(g);
    TestBitmapGraphics(g);
    TestCompoundLines(g);

    delete g;
}


VOID DrawContainer(Graphics * g, ARGB * argb, INT count)
{
    Matrix    mymatrix;
    g->SetPageUnit(UnitInch);

    Rect clipRect(0,0,5,5);
    g->SetClip(clipRect);

    mymatrix.Translate(2.5, 2.5);
    mymatrix.Rotate(15);
    mymatrix.Translate(-2.5, -2.5);
    g->SetTransform(&mymatrix);

    Color   color(*argb++); 
    SolidBrush contBrush(color);
    g->FillRectangle(&contBrush, 0, 0, 5, 5);
    if (--count == 0)
    {
        return;
    }
    RectF     destRect(.5, .5, 4, 4);
    RectF     srcRect(0, 0, 5, 5);
    INT id = g->BeginContainer(destRect, srcRect, UnitInch);
    g->ResetClip();
    DrawContainer (g, argb, count);
    g->EndContainer(id);
}

VOID TestContainerClip(Graphics *g)
{
    ARGB     colors[5];
    
    colors[0] = Color::MakeARGB(255, 255, 0, 0);
    colors[1] = Color::MakeARGB(255, 0, 255, 0);
    colors[2] = Color::MakeARGB(255, 0, 0, 255);
    colors[3] = Color::MakeARGB(255, 255, 255, 0);
    colors[4] = Color::MakeARGB(255, 0, 255, 255);

    GraphicsState s = g->Save();
    DrawContainer(g, colors, 5);
    g->Restore(s);
}

GraphicsPath      circlePath;
RectF        circleRect(0,0,4,4);

#define ROOT    0
#define LEFT    1
#define RIGHT   2
#define TOP     3
#define BOTTOM  4


VOID DrawFractal(Graphics * g, BYTE gray, INT side, INT count)
{
    ARGB        argb;

    switch (count % 3)
    {
    case 0:
        argb = Color::MakeARGB(255, 0, 0, gray);
        break;
    case 1:
        argb = Color::MakeARGB(255, 0, gray, 0);
        break;
    case 2:
        argb = Color::MakeARGB(255, gray, 0, 0);
        gray -= 60;
        break;
    }
    Color   color(argb);
    SolidBrush contBrush(color);
    g->SetPageUnit(UnitInch);
    g->FillPath(&contBrush, &circlePath);
    
    if (--count == 0)
    {
        return;
    }

    RectF              destRect;
    GraphicsContainer  cstate;

    if (side != LEFT)
    {
        destRect = RectF(4, 1, 2, 2);
        cstate = g->BeginContainer(destRect, circleRect, UnitInch);
        g->SetSmoothingMode(SmoothingModeAntiAlias);
        DrawFractal(g, gray, RIGHT, count);
        g->EndContainer(cstate);
    }
    if (side != TOP)
    {
        destRect = RectF(1, 4, 2, 2);
        cstate = g->BeginContainer(destRect, circleRect, UnitInch);
        g->SetSmoothingMode(SmoothingModeAntiAlias);
        DrawFractal(g, gray, BOTTOM, count);
        g->EndContainer(cstate);
    }
    if (side != RIGHT)
    {
        destRect = RectF(-2, 1, 2, 2);
        cstate = g->BeginContainer(destRect, circleRect, UnitInch);
        g->SetSmoothingMode(SmoothingModeAntiAlias);
        DrawFractal(g, gray, LEFT, count);
        g->EndContainer(cstate);
    }
    if (side != BOTTOM)
    {
        destRect = RectF(1, -2, 2, 2);
        cstate = g->BeginContainer(destRect, circleRect, UnitInch);
        g->SetSmoothingMode(SmoothingModeAntiAlias);
        DrawFractal(g, gray, TOP, count);
        g->EndContainer(cstate);
    }
}

VOID TestContainer(Graphics * g)
{
    circlePath.AddEllipse(circleRect);
    
    INT id = g->Save();
    g->TranslateTransform(5, 4);
    DrawFractal(g, 245, ROOT, 8);
    g->Restore(id);
}

/**************************************************************************\
* TestPolygons
*
* A test for drawing and filling of rectangles and polygons.
*
\**************************************************************************/

VOID TestPolygons(Graphics *g)
{
    REAL width = 4; // Pen width

    Color redColor(255, 0, 0);

    SolidBrush redBrush(redColor);
    g->FillRectangle(&redBrush, 20, 20, 50, 50);

    Color alphaColor(128, 0, 255, 0);

    SolidBrush alphaBrush(alphaColor);
    g->FillRectangle(&alphaBrush, 10, 10, 40, 40);

    Point points[4];
    points[0].X = 50;
    points[0].Y = 50;
    points[1].X = 100;
    points[1].Y = 50;
    points[2].X = 120;
    points[2].Y = 120;
    points[3].X = 50;
    points[3].Y = 100;    

    Color blueColor(128, 0, 0, 255);

    SolidBrush blueBrush(blueColor);
    g->FillPolygon(&blueBrush, points, 4);

    // Currently only Geometric pen works for lines. - ikkof 1/6/99.

    Color blackColor(0, 0, 0);
    SolidBrush blackBrush(blackColor);
    Pen blackPen(&blackBrush, width);
    blackPen.SetLineJoin(LineJoinRound);
    g->DrawPolygon(&blackPen, points, 4);
//    g->DrawLines(&blackPen, points, 4, FALSE);
}


/**************************************************************************\
* TestPaths
*
* A test for general paths.
*
\**************************************************************************/

VOID TestPaths(Graphics *g)
{
    REAL width = 4;         // Pen width
    Point points[4];

    points[0].X = 100;
    points[0].Y = 10;
    points[1].X = -50;
    points[1].Y = 50;
    points[2].X = 150;
    points[2].Y = 200;
    points[3].X = 200;
    points[3].Y = 70;

    Color yellowColor(128, 255, 255, 0);
    SolidBrush yellowBrush(yellowColor);

    GraphicsPath* path = new GraphicsPath(FillModeAlternate);
    path->AddBeziers(points, 4);
    Matrix matrix;
    matrix.Scale(1.5, 1.5);
    path->Transform(&matrix);
    
    Color blackColor(0, 0, 0);

    SolidBrush blackBrush(blackColor);
    // Set the pen width in inch.
    width = (REAL) 0.2;
    Pen blackPen(&blackBrush, width);
    blackPen.SetStartCap(LineCapRound);
//    blackPen.SetEndCap(LineCapSquare);
    blackPen.SetEndCap(LineCapArrowAnchor);
    Region * region = new Region(path);
    g->FillPath(&yellowBrush, path);
    g->DrawPath(&blackPen, path);
    delete path;
    delete region;
}

/**************************************************************************\
* TestDashes
*
* A test for drawing dashed lines.
*
\**************************************************************************/

VOID TestDashes(Graphics *g)
{
    REAL width = 4;         // Pen width
    PointF points[4];

    points[0].X = 100;
    points[0].Y = 10;
    points[1].X = -50;
    points[1].Y = 50;
    points[2].X = 150;
    points[2].Y = 200;
    points[3].X = 200;
    points[3].Y = 70;

    Color yellowColor(128, 255, 255, 0);
    SolidBrush yellowBrush(yellowColor);

    GraphicsPath* path = new GraphicsPath(FillModeAlternate);
    path->AddBeziers(points, 4);
    Matrix matrix;
    matrix.Scale(1.5, 1.5);

    path->Transform(&matrix);

    Color blackColor(0, 0, 0);
    SolidBrush blackBrush(blackColor);
    // Set the pen width in inch.
    width = (REAL) 0.2;
    Pen pen1(&blackBrush, width);
    pen1.SetDashStyle(DashStyleDashDotDot);
    pen1.SetDashCap(DashCapRound);
    g->DrawPath(&pen1, path);

    // Create a multiple segment with a closed segment.

    points[0].X = 50;
    points[0].Y = 50;
    points[1].X = 100;
    points[1].Y = 50;
    points[2].X = 120;
    points[2].Y = 120;
    points[3].X = 50;
    points[3].Y = 100;    

    path->Reset();
    path->AddLines(points, 4);
    path->CloseFigure();

    points[0].X = 150;
    points[0].Y = 60;
    points[1].X = 200;
    points[1].Y = 150;
    path->AddLines(points, 2);
    path->Transform(&matrix);

    Color blueColor(128, 0, 0, 255);

    SolidBrush blueBrush(blueColor);

    width = 5;
    Pen pen2(&blueBrush, width);
    pen2.SetDashStyle(DashStyleDashDotDot);
    g->DrawPath(&pen2, path);

    delete path;
}

/**************************************************************************\
* TestRegions
*
* A test for region fill.
*
\**************************************************************************/

VOID TestRegions(Graphics *g)
{
    REAL width = 2;     // Pen width
    PointF points[5];
    
    REAL s, c, theta;
    REAL pi = 3.1415926535897932f;
    REAL scale = 30;
    PointF orig(200, 140);

    theta = -pi/2;

    // Create a star shape.
    for(INT i = 0; i < 5; i++)
    {
        s = sinf(theta);
        c = cosf(theta);
        points[i].X = scale*c + orig.X;
        points[i].Y = scale*s + orig.Y;
        theta += 0.8f*pi;
    }

    Color orangeColor(128, 255, 180, 0);

    SolidBrush orangeBrush(orangeColor);
    GraphicsPath* path = new GraphicsPath(FillModeAlternate);
//    Path* path = new GraphicsPath(Winding);
    path->AddPolygon(points, 5);
    
    Color blackColor(0, 0, 0);

    SolidBrush blackBrush(blackColor);
    Pen blackPen(&blackBrush, width);
    Region * region = new Region(path);

    g->FillRegion(&orangeBrush, region);  // There is a BUG!
//    g->FillGraphicsPath(&orangeBrush, path);  // Fill path works fine.
    
    blackPen.SetLineJoin(LineJoinMiter);
    g->DrawPath(&blackPen, path);
    delete path;
    delete region;
}

GraphicsPath* CreateHeartPath(const RectF& rect)
{
    GpPointF points[7];
    points[0].X = 0;
    points[0].Y = 0;
    points[1].X = 1.00;
    points[1].Y = -1.00;
    points[2].X = 2.00;
    points[2].Y = 1.00;
    points[3].X = 0;
    points[3].Y = 2.00;
    points[4].X = -2.00;
    points[4].Y = 1.00;
    points[5].X = -1.00;
    points[5].Y = -1.00;
    points[6].X = 0;
    points[6].Y = 0;

    Matrix matrix;

    matrix.Scale(rect.Width/2, rect.Height/3, MatrixOrderAppend);
    matrix.Translate(3*rect.Width/2, 4*rect.Height/3, MatrixOrderAppend);
    matrix.TransformPoints(&points[0], 7);

    GraphicsPath* path = new GraphicsPath();
    
    if(path)
    {
        path->AddBeziers(&points[0], 7);
        path->CloseFigure();
    }

    return path;
}

    
/**************************************************************************\
* TestGradients
*
* A test for rectangle and radial gradients.
*
\**************************************************************************/

VOID TestGradients(Graphics* g)
{
    REAL width = 4; // Pen width

    // Create a rectangular gradient brush.

    RectF brushRect(0, 0, 32, 32);

    Color colors[5] = {
        Color(255, 255, 255, 255),
        Color(255, 255, 0, 0),
        Color(255, 0, 255, 0),
        Color(255, 0, 0, 255),
        Color(255, 0, 0, 0)
    };

//    RectangleGradientBrush rectGrad(brushRect, (Color*) &colors, WrapModeTile);
    
    // Rotate a brush.
    GpMatrix xForm;
    xForm.Rotate(30);
//    rectGrad.SetTransform(&xForm);

    // Change the wrapping mode and fill.

// !! No longer supported
//    rectGrad.SetWrapMode(WrapModeTileFlipXY);
//    g->FillRectangle(&rectGrad, 350, 20, 100, 80);
    
    Color blackColor(0, 0, 0);

    SolidBrush blackBrush(blackColor);
    Pen blackPen(&blackBrush, width);

    g->DrawRectangle(&blackPen, brushRect);

    // Create a radial gradient brush.

    Color centerColor(255, 255, 255, 255);
    Color boundaryColor(255, 0, 0, 0);
    brushRect.X = 380;
    brushRect.Y = 130;
    brushRect.Width = 60;
    brushRect.Height = 32;
    PointF center;
    center.X = brushRect.X + brushRect.Width/2;
    center.Y = brushRect.Y + brushRect.Height/2;
    xForm.Reset();
    xForm.RotateAt(-30, center, MatrixOrderAppend);
// !! No longer supported
//    RadialGradientBrush radGrad(brushRect, centerColor,
//                                boundaryColor, WrapModeClamp);
//    radGrad.SetTransform(&xForm);
//    g->FillRectangle(&radGrad, 320, 120, 120, 100);

//    Pen gradPen(&rectGrad, width);
//    g->DrawRectangle(&gradPen, 320, 120, 120, 100);

    // Triangle gradient.
    
    PointF points[7];
    points[0].X = 50;
    points[0].Y = 10;
    points[1].X = 200;
    points[1].Y = 20;
    points[2].X = 100;
    points[2].Y = 100;
    points[3].X = 30;
    points[3].Y = 120;

    Color colors1[5] = {
        Color(255, 255, 255, 0),
        Color(255, 255, 0, 0),
        Color(255, 0, 255, 0),
        Color(255, 0, 0, 255),
        Color(255, 0, 0, 0)
    };

// !! No longer supported
//    TriangleGradientBrush triGrad(points, (Color*) &colors);
//    g->FillPolygon(&triGrad, points, 3);
    RectF triRect;
//    triGrad.GetRectangle(triRect);
//    g->FillRectangle(&triGrad, triRect);

    points[0].X = 200;
    points[0].Y = 300;
    points[1].X = 280;
    points[1].Y = 350;
    points[2].X = 220;
    points[2].Y = 420;
    points[3].X = 160;
    points[3].Y = 440;
    points[4].X = 120;
    points[4].Y = 370;

    PathGradientBrush polyGrad(points, 5);

    REAL blend[10];
    Color presetColors[10];
    REAL positions[10];
    INT count;
    INT i;

    count = 3;
    blend[0] = (REAL) 0;
    blend[1] = (REAL) 0;
    blend[2] = (REAL) 1;
    positions[0] = (REAL) 0;
    positions[1] = (REAL) 0.4;
    positions[2] = (REAL) 1;

    // Test for blending factors.

    polyGrad.SetBlend(&blend[0], &positions[0], count);

    polyGrad.SetCenterColor(centerColor);
    i = 5;
    polyGrad.SetSurroundColors(colors1, &i);
    
//    g->FillPolygon(&polyGrad, points, 5);
    RectF polyRect;
    polyGrad.GetRectangle(&polyRect);
    g->FillRectangle(&polyGrad, polyRect);

    // Create a heart shaped path.

    RectF rect;
    rect.X = 300;
    rect.Y = 300;
    rect.Width = 150;
    rect.Height = 150;
    GraphicsPath *path = CreateHeartPath(rect);

    // Create a gradient from a path.

    PathGradientBrush pathGrad(path);
    delete path;
    pathGrad.SetCenterColor(centerColor);
    i = 1;
    pathGrad.SetSurroundColors(&Color(255, 255, 0, 0), &i);
    pathGrad.GetRectangle(&polyRect);

    // Set the rect focus.

    PointF centerPt;

    pathGrad.GetCenterPoint(&centerPt);
    centerPt.X -= 15;
    centerPt.Y += 30;
    pathGrad.SetCenterPoint(centerPt);
    REAL xScale, yScale;
    pathGrad.GetFocusScales(&xScale, &yScale);
    xScale = 0.4f;
    yScale = 0.3f;
    pathGrad.SetFocusScales(xScale, yScale);

    g->FillRectangle(&pathGrad, polyRect);

    // Test for LineGradientBrush.

    RectF lineRect(120, -20, 200, 60);
    Color color1(200, 255, 255, 0);
    Color color2(200, 0, 0, 255);

    LinearGradientBrush lineGrad(lineRect, color1, color1,
                        LinearGradientModeForwardDiagonal);

    // Test for preset colors

    presetColors[0] = Color(200, 0, 255, 255);
    presetColors[1] = Color(200, 255, 255, 0);
    presetColors[2] = Color(200, 0, 255, 0);
    lineGrad.SetInterpolationColors(&presetColors[0], &positions[0], count);

    g->FillRectangle(&lineGrad, lineRect);

}
    

/**************************************************************************\
* TestHatches
*
* A test for hatch brushes
*
\**************************************************************************/

VOID TestHatches(Graphics* g)
{
    Color foreColor(0, 0, 0);
    Color backColor(128, 255, 255, 255);

    HatchStyle style[6];
    style[0] = HatchStyleForwardDiagonal;
    style[1] = HatchStyleBackwardDiagonal;
    style[2] = HatchStyleCross;
    style[3] = HatchStyleDiagonalCross;
    style[4] = HatchStyleHorizontal;
    style[5] = HatchStyleVertical;

    // Pick one of the above hatch styles.

    HatchBrush hatch(style[3], foreColor, backColor);
    g->FillRectangle(&hatch, 200, 20, 100, 80);
}

/**************************************************************************\
* TestBitmaps
*
* A test for texture filling and DrawImage.
*
\**************************************************************************/

VOID TestBitmaps(Graphics* g)
{
    Poin